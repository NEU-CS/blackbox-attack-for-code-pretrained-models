{"id1": "3266833", "id2": "20073619", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "label": 0, "substitutes": {"is": ["mis", "as", "init", "ris", "im", "IS", "was", "isa", "us", "info", "its", "isu", "iss", "i", "Is", "image", "or", "iso", "ib", "in", "lis", "close", "ir", "ws", "ip", "os", "iv", "isc", "fits", "bs", "ins", "ais", "ios", "es", "abs", "iris", "id", "bis", "get", "has", "cms"], "name": ["source", "filename", "large", "path", "ame", "memory", "alias", "NAME", "this", "title", "domain", "pass", "one", "word", "Name", "image", "default", "data", "names", "module", "nice", "format", "description", "n", "directory", "url", "base", "database", "search", "null", "label", "code", "address", "term", "min", "string", "connection", "size", "prefix", "office", "named", "file", "value", "space", "part", "version", "key", "id", "type", "parent", "vision", "no"], "contentType": ["ContentName", "mediaType", " contenttype", "outputPath", "documentInfo", "contentInfo", "ContentInfo", "messageType", "contentPath", "sourcetype", " contentInfo", "outputTypes", " contentPoint", "messageName", "sourceInfo", "messageInfo", "sourceType", "documentPoint", "mediaTypes", "mediaPath", "outputName", "messagetype", "contentName", "contentPoint", "ContentType", "Contenttype", "ContentPath", "outputType", "contenttype", "mediaName", "ContentTypes", "sourcePoint", " contentName", "documentType", "contentTypes", "documenttype"], "index": ["x", "position", "shape", "expression", "depth", "length", "update", "page", "timeout", "level", "i", "pointer", "input", "image", "none", "default", "data", "in", "open", "fix", "multi", "axis", "width", "search", "Index", "number", "address", "body", "append", "string", "list", "size", "alpha", "prefix", "height", "write", "weight", "value", "include", "pull", "key", "slice", "id", "end", "type", "inc", "error", "offset", "content"], "extension": ["configension", "extensions", "extance", "variension", "variuration", "exturation", "variance", "Extance", "configensions", "configuration", "configance", "Exturation", "Extension", "Extensions", "variensions"], "isImage": ["ISVideo", "IsFile", "isVideo", "asimage", "isImages", " isimage", "isMedia", "areMedia", "IsVideo", "isaImage", "isInstance", "asFile", "areInstance", "isFile", "ISImage", "areImages", "IsPicture", "ISFile", "isaMedia", "isimage", " isPicture", " isVideo", " isMedia", "areimage", "isaFile", "asInstance", "asImage", "areImage", "isaImages", "areFile", " isInstance", "isPicture", "ISPicture", " isFile", " isImages", "IsImage"], "isAux": ["isWalux", "isAslux", "isArrayUX", "isWaUX", " isArrayxt", "isAsx", "isAsUX", " isHaux", "asAsExcept", "isAlux", "isAAxt", "isAru", " isAx", " isAUX", "isAnux", "isAnlux", "isAsux", "isAAru", "isAxt", "isAex", "isAcUX", "isUUX", "isAsex", "isWax", "isAcxt", "isArrayux", "isArrayru", " isArrayru", "isAUX", "isOAExcept", " isArrayux", " isHalux", " isAxt", " isHax", "isAcru", "isOAux", "isHalux", "asAsUX", "isAAux", "asAsex", "isAAUX", " isArrayUX", "isOAUX", " isHaUX", "isAsExcept", "isWaux", "isHaux", "asAslux", "isUExcept", "asAExcept", " isAlux", "isAExcept", "isAnex", "isUlux", "isOAlux", "isUex", "asAex", "asAsux", "isHaUX", " isAru", "isAnUX", "isHax", "asAux", "asAlux", "isUux", "isArrayxt", "isAx", "isAcux", "asAUX"], "out": ["work", "source", "result", "buffer", "copy", "cache", "output", "table", "client", "sync", "inner", "at", "this", "page", "extra", "ex", "word", "input", "socket", "OUT", "image", "conn", "project", "data", "in", "object", "up", "io", "next", "a", "base", "array", "null", "outer", "ext", "exec", "post", "pool", "obj", "exp", "size", "over", "plain", "prefix", "Out", "auto", "outs", "again", "off", "file", "temp", "version", "part", "parent", "o", "user", " in", "error"], "bufferedImage": ["bufferingImage", "buffledimage", "BufferedImage", "buffendedimage", "BufferingImage", "buffledImage", "bufferingimage", "buffendedImage", "bufferedimage", "Bufferingimage", "Bufferedimage"], "inputStream": ["InputBuffer", "outputstream", "inputSteam", "outputStream", "InputStream", "Inputstream", "InputSteam", " inputstream", " inputBuffer", " inputSteam", "outputSteam", "inputstream", "outputBuffer", "inputBuffer"]}}
{"id1": "8266672", "id2": "4461350", "code1": "    public static void updatePicInfo(Connection conn, int nr, int lock, DBPicInfo picInfo) throws SQLException {\n        String sql = \"\";\n        PreparedStatement pstmt = null;\n        try {\n            if (!picInfo.getName().equals(\"\")) {\n                sql = \"update DBPic set name=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setString(1, picInfo.getName());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            if (picInfo.getRate() != 0) {\n                sql = \"update DBPic set rate=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, picInfo.getRate());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            sql = \"update DBThumb set thumb_lock=? where bnr=?\";\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setInt(1, lock);\n            pstmt.setInt(2, nr);\n            pstmt.executeUpdate();\n            if (picInfo.getCategories() != null) {\n                sql = \"delete from Zuordnen where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInCategories(conn, nr, picInfo.getCategories());\n            }\n            if (picInfo.getKeywords() != null) {\n                sql = \"delete from Haben where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInKeywords(conn, nr, picInfo.getKeywords());\n            }\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            pstmt.close();\n        }\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 1, "substitutes": {"updatePicInfo": ["updatepicInfo", "updatePicInf", "savePicinfo", "saveImageinfo", "updatepicinfo", "updatePictureInfo", "updatePicinfo", "savePicInfo", "updatePictureinfo", "updateImageInfo", "updateImageInf", "updateImageinfo", "saveImageInf", "updatePictureInf", "savePicInf", "saveImageInfo", "updatepicInf"], "conn": ["orp", "db", "client", "connect", "ca", "Conn", "sync", "ctx", "oss", "stat", "cp", "rc", "cn", "cc", "pg", "cat", "cr", "cli", "nt", "ci", "mn", "core", "server", "coll", "cf", "reg", "loc", "ann", "gn", "dn", "connection", "nc", "dc", "pool", "manager", "con", "conf", "config", "pub", "en", "util", "col", "ch", "enc", "serv", "exec", "conv", "session", "rt", "jc", "ct", "pc", "co", "mc", "sys", "cms", "cmp", "act", "cmd", "cb", "c", "vol"], "nr": ["lr", "r", "gr", "fr", "ner", "nor", "n", "rl", "eni", "ctr", "chain", "nn", "orr", "rx", "mn", "sn", "dr", "ru", "adr", "rb", "radius", "our", "num", "nc", "nis", "rr", "nir", "rin", "wr", "rar", "sr", "NR", "mr", "dir", "rf", "rw", "nil", "major", "err", "ni", "range", "nick", "nw", "number", "nie", "inv", "rn", "yr", "vr", "arr", "counter", "nl", "nb", "random", "nar", "usr", "np", "lvl"], "lock": ["lr", "locks", "gr", "max", "pin", "sync", "sl", "ok", "block", "locking", "rc", "delay", "sol", "lc", "limit", "sn", "locked", "loc", "lin", "bl", "pull", "ssl", "Lock", "row", "len", "dir", "min", "zip", "lang", "rel", "live", "ock", "ll", "cl", "number", "arr", "l", "ml", "list", "pl", "LOCK", "lvl", "length"], "picInfo": ["pinInit", "pixelINFO", "moduleLi", "pinInfo", "collInf", "PicConf", "picINFO", "picSetup", "PicInf", "syncInf", "niceInf", "niceSetup", "pictureInf", "picEx", "collEx", "moduleInf", "pixelArea", "pinArea", " picInf", "pictureINFO", "kinSync", "picObj", "collINFO", "pictureArea", "pictureStyle", "picUpdate", "moduleInfo", "moduleINFO", "PicINFO", "iconInf", "pixelInfo", "studyInfo", "picInf", " picEx", "syncLi", "PicEx", "kinInfo", "iconStyle", "pictureObj", "pictInfo", "pictureInfo", "kinStyle", "iconInfo", "picInit", "styleSetup", " picINFO", "studyObj", "pictureId", "PicSetup", "pictType", "styleInfo", "studyUpdate", " picType", "syncInfo", "pictureUpdate", "pictureLi", "styleInf", "PicType", "picSync", "kinInf", "pinId", "PicInfo", "syncINFO", "pictInf", "picStyle", "niceConf", "pinInf", "pinUpdate", "picType", "pictureSync", "collInfo", "PicObj", "pinObj", "pictureInit", "niceInfo", "pictId", "pictObj", "picConf", "styleConf", " picInit", "picArea", "picLi", "picId", "studyInf", "iconSync", "pixelInf", " picObj", " picArea"], "sql": ["generic", "sync", "s", "comment", "sk", "ln", "serial", "http", "params", "fn", "str", "sq", "lang", "dl", "shell", "string", "tf", "uri", "cmp", "db", "details", "sl", "lambda", "html", "rl", "QL", "summary", "json", "loc", "lv", "pool", "err", "ll", "status", "utils", "sal", "job", "su", "email", "msg", "ls", "pkg", "cli", "lc", "limit", "sf", "result", "reason", "ssl", "function", "util", "url", "serv", "log", "printf", "kl", "auth", "ql", "nl", "seed", "sv", "filename", "tool", "socket", "install", "il", "sn", " SQL", "sol", "SQL", "sg", "rup", "xml", "csv", "zip", "session", "eps", "general", "sys", "select"], "pstmt": ["prestcl", "pstdtp", "pflmt", "pustsp", "pusttool", "ipstnl", "pstert", "psthrm", "pctmb", "Postmt", "ppstsp", "pstrtr", "pestmb", "pconstm", "ipstrnl", "pstatmc", "ppstql", " pftmn", " pftrt", "Pstret", "Pstpt", "pfmb", "lpstmt", "prestmn", "ipstrpm", "pclmn", "prestmd", "prsthmt", "psthtool", " pftmm", "pestsp", "pctpt", "pestau", "prestmb", "ppesttool", "pfmt", "putmt", "pstmc", "psthmc", "ppestql", "pstdemb", "ppstmb", "postmd", "pstatt", " pstemb", "ppmb", "pfrm", "pdm", "ppestmt", " pstert", "pdmn", "preostmn", "pstdm", "ppatt", "perstsmt", "pconstpm", "postret", " postmd", " pstm", "ppstdr", "pprmb", "lpsttr", "pstsmt", "Pctm", "pctcl", "perstmc", "pstdtool", " pstmb", "pctpm", "pctdr", "pstret", "pstau", "pctm", "pfcl", "pstpm", "pctmt", "ppmt", "pestatt", "pctgr", "putdr", "prestnl", "pflert", "pflm", "prstbh", "prestpm", "pfm", " pfmn", "ipstmt", "pstpl", "pstsgr", "ppsthmt", "postm", "presttool", "prsthmb", "Postmon", "pstrm", "pfpt", "postmon", "hstmn", "pctpl", "Pstmt", "lpstrtr", " pstrel", "lpstgr", "ppsthgr", "pconstql", "pftemb", "pctmd", "pustql", "pprmt", "hsttor", "prstmt", "pestmt", "pstsrm", "psthcl", "pstrret", "lpstm", "pconstcl", "ppstmd", "perstsmc", "postmb", "ppstgr", "postmn", "Pctmt", " pfm", "ppbh", "pprrm", "pfttp", "pfbh", "prsthql", "pstdrel", "pftmt", "psthrel", " postrel", "pcttr", "psthm", "pctrel", "pstsp", "pstrpm", "pdmt", "postau", "psthmt", "psthdr", "prstatt", "pdpl", "postmt", "perstsrm", "psthgr", "pclbh", "pconstmb", " pfmt", "lpstrmt", "pconstmn", "pstmb", "pustmt", "pftmn", "Pstmb", "Pctpl", "perstsgr", "Pstmon", " postm", "pconstpt", "ipstpm", "prestql", "pclmt", "pstdmn", "pstatmt", "ppestsp", "postrel", "preostau", "ipstrmt", " pstrm", "Pstm", "psthmn", "pstdr", " pfrel", "lpstrgr", "psctor", "psthrt", "lpstrm", " postert", "ppsthmd", "psttr", "pftmm", "postcl", "pscbh", "pptp", "putmd", "Pstpl", "pstdert", "Postret", "pctmn", "pstrgr", "pstpt", "pfatt", "prpmb", "psthql", "pfret", "perstrm", "pstgr", "pstemb", "pestcl", "pstddr", "Pstmn", "psttool", " pfrm", "pstrrt", "pstnl", " pfttp", "pestql", " pstcl", "perstmt", "ppstmt", "pstmon", "pfrel", "prestrel", "hstbh", "pscmt", " pfmb", " postmb", "pestbh", "pscpm", "pestdr", "postert", " pfcl", "Pctmb", "pstrnl", "pstmm", "prpbh", " psttp", "pstrmon", "pestgr", "prpmt", "pstsmc", " pstrt", "prpatt", "pstmd", "psttor", "pstmn", "prstql", "prestsp", "prstmb", "pprmn", "pstql", "pstatrm", "pstm", "ppsthdr", "preostcl", "ppmn", "Postmn", "perstgr", "pstrmt", "ppsttool", "psthmb", "ipstrtr", "pscnl", "prestau", " pstmn", "psthpm", "psctr", "puttool", "prsthpm", " pftmt", "ipsttr", "ppsthtool", "pstrmn", "prstpm", "pstatgr", "pfmon", "pstrmm", "pesttool", " pftemb", "pstrt", "pftrt", " pstmm", "pctql", "pcltor", "prestmt", "pstrpl", "pctrm", " pstmd", "pflrel", "pconstmt", "ppemb", "pscmn", "psthmm", "pstdmd", "psttp", "psthmd", " postmt", "ppsthmb", "hstmt", "preostmt", "presttr", "pstdmt", "pstrel", "pstcl", "pfmn", "pestmn", "pconstau", "Pctmn", "pstbh", "psthtr", "Pctpt"]}}
{"id1": "1769771", "id2": "3958807", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "copyChannel", "CopyFiles", "copyfile", "transferFiles", "copyFiles", "CopyChannel", " copyChannel", "CopyFile", "transferChannel", "transferfile"], "in": ["In", "again", "c", "IN", "m", "ex", "inner", "bin", "input", "io", "pin", "ins", "min", "inn", "l", "win", "base", "lin", "url", "query", "work", "config", "index", "f", "i", "image", "login", "reader", "diff", "data", "inc", "id", "source", "lock", "name", "file"], "out": ["resource", "external", "again", "n", "c", "string", "cache", "o", "ex", "call", "Out", "io", "outs", "conn", "user", "p", "up", "default", "w", "base", "prefix", "exec", "server", "x", "off", "image", "plain", "writer", "dot", "ext", "v", "output", "write", "OUT", "point", "b", "target", "name", "file", "extra"], "inChannel": [" inchannel", "insChan", "outchannel", "inputChannel", "inputStream", "winchannel", "winChannel", "binChan", "INStream", " inStream", "InChan", "inchannel", "winStream", "insClient", "binchannel", "InClient", "inStream", "winChan", "outStream", "insStream", "binClient", "INChannel", "inChan", "binChannel", "insChannel", "inClient", "INChan", "INchannel", "outChan", " inClient", "outClient", "inputChan", "InStream", "InChannel", " inChan", "Inchannel", "inputchannel", "binStream"], "outChannel": ["outputchannel", "outputChannel", " outChan", "outchannel", "inputChannel", "OutChannel", "OutConnection", "nStream", "Outchannel", " outManager", "inCh", "outManager", "inchannel", "outputStream", "outputController", "outputChan", "inStream", "nChan", "outStream", " outConnection", "inController", " outCh", "inChan", "inputController", "outCh", "outChan", "OutChan", " outchannel", "nManager", "inConnection", "outConnection", "inputChan", "outputCh", "nChannel", " outStream", "inputchannel", "inManager", "outController"]}}
{"id1": "12128591", "id2": "15051083", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "label": 1, "substitutes": {"hash": [" fingerprint", "str", "parse", "check", "Hash", "log", "hex", "build", "code", "SHA", "component", "crypt", " hashes", "print", "text", "update", "pack", " hashing", " Hash", "add", "get", "copy", "h", "dump", "sum"], "data": ["address", "template", "result", "base", "cache", "str", "output", "DATA", "input", "string", "name", "s", "length", "memory", "image", "missing", "hex", "database", "format", "a", "info", "connection", "class", "dat", "text", "body", "pad", "padding", "buffer", "message", "media", "alpha", "api", "p", "bytes", "content", "in", "source", "style", "value", "response"], "digest": ["peder", "digit", "signEST", " digusher", "signest", "decests", "logast", "logenge", "mdast", "bigest", "generit", " digests", "pede", "Digenge", "digast", "logester", "bigger", "Digger", "digenge", "mdest", "digEST", "bigester", " digester", "generests", "digester", " digEST", "decit", "decest", "decester", "Dige", "digusher", "pedester", "digests", "bigusher", "Digusher", " digit", "pedest", "DigEST", " dige", "Diger", "Digester", "dige", "signester", "diger", "Digest", " diger", "digger", "logest", "Digast", "generester", "mdenge", " digger", "generest", "signusher", "mdester"]}}
{"id1": "2461169", "id2": "9081749", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "4686922", "id2": "19147281", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"extractResourceToFile": ["extractResourcesAsfile", "extractResourceInResource", "extractResourceInFile", "extractResourceToResource", "extractResourceInfile", "extractResourceToFiles", "extractResourceInFiles", "extractResourcesToFiles", "extractResourceAsResource", "extractResourcesToResource", "extractResourcesAsFile", "extractResourceAndResource", "extractResourceAsFiles", "extractResourceAsFile", "extractResourcesAsResource", "extractResourcesAsFiles", "extractResourceAndfile", "extractResourceAndFiles", "extractResourceAsfile", "extractResourcesToFile", "extractResourcesTofile", "extractResourceTofile", "extractResourceAndFile"], "resourcePath": ["servicepath", "sourceUrl", "ResourceId", " resourceId", "serviceFolder", "resourceFolder", "resourcepath", " resourcepath", "sourceId", " resourceUrl", "sourcePath", "stringpath", "servicePath", "ResourcePath", "resourceUrl", "stringPath", "sourcepath", "stringFolder", "Resourcepath", " resourceFolder", "resourceId", "ResourceUrl"], "dest": ["sac", "result", "de", "img", "prop", "sup", "project", "output", "tmp", "comb", "transfer", "path", "folder", "default", "target", "filename", "flat", "resources", "Dest", "class", "route", "desc", "const", "config", "wb", "done", "resource", "content", "store", "data", "destroy", "file", "source", "dist", " destination", "src", "contract", "die", "later", "home", "trans", "txt", " Dest", "temp"], "in": ["url", "gin", "ins", "thin", "din", "reader", "IN", "re", "login", "bin", "id", "isin", "inc", "ini", "input", "In", "conn", "inner", "image", "c", "this", "like", "i", "r", "connection", "b", "n", "again", "sin", "rec", "socket", "nin", "win", "resource", "inn", "plus", "is", "arin", "cin", "source", "lin", "up", "file", "init", "inside", "kin", "rin", "pass", "con", "as", "f"], "out": ["net", "exec", "ins", "OUT", "client", "outs", "cache", "w", "output", "bin", "app", "io", "inc", "one", "boot", "outside", "auto", "conn", "s", "In", "ext", "obj", "image", "err", "this", "off", "Out", "ax", "lib", "norm", "all", "at", "writer", "i", "a", "user", "b", "ex", "n", "null", "again", "o", "co", "parent", "sync", "socket", "outer", "copy", "cookie", "cos", "source", "file", "up", "server", "f", "temp"]}}
{"id1": "4686922", "id2": "5299276", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourceInResource", "extractResourcesAsResource", "extractResourceAndFiles", "extractResourcesToResource", "extractResourceAndfile", "extractResourceAsResource", "extractResourceAsFile", "extractResourceAsfile", "extractResourcesAsfile", "extractResourcesAsFile", "extractResourceTofile", "extractResourceAndFile", "extractResourceAsFiles", "extractResourceInFiles", "extractResourcesToFiles", "extractResourceToResource", "extractResourcesTofile", "extractResourceInFile", "extractResourceAndResource", "extractResourceInfile", "extractResourceToFiles", "extractResourcesToFile", "extractResourcesAsFiles"], "resourcePath": ["servicePath", " resourceUrl", " resourceId", "resourceId", "stringFolder", "resourceFolder", "sourceId", "Resourcepath", "ResourceUrl", "ResourcePath", "sourcePath", "servicepath", " resourcepath", "resourcepath", "serviceFolder", "sourcepath", "ResourceId", "stringPath", "resourceUrl", "sourceUrl", "stringpath", " resourceFolder"], "dest": ["de", " Dest", "src", "output", "class", "transfer", "tmp", "comb", "default", "route", "const", "home", "Dest", "target", "result", "content", "desc", "path", "resource", "resources", "later", "img", "file", "sup", "dist", "config", "store", "sac", "die", "wb", "data", "temp", "flat", "trans", "done", "contract", " destination", "project", "prop", "folder", "destroy", "source", "filename", "txt"], "in": ["r", "image", "n", "inn", "gin", "isin", "i", "is", "socket", "init", "cin", "input", "thin", "id", "arin", "din", "sin", "plus", "conn", "lin", "connection", "inner", "resource", "nin", "ini", "con", "rec", "file", "rin", "kin", "inside", "f", "url", "this", "pass", "login", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "like", "re", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "auto", "client", "writer", "sync", "obj", "n", "off", "one", "all", "i", "output", "socket", "s", "app", "user", "copy", "parent", "ex", "server", "cache", "cookie", "outside", "conn", "boot", "ax", "a", "cos", "ext", "io", "at", "file", "f", "o", "null", "this", "exec", "lib", "err", "temp", "b", "norm", "w", "ins", "net", "co", "bin", "In", "OUT", "again", "outs", "outer", "source", "up", "inc"]}}
{"id1": "12389873", "id2": "13644375", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"load": ["test", " reload", "Load", "loading", "save", "transfer", "ready", "write", "link", "build", "read", "construct", " Load", " loaded", "config", "sync", "add", "get", " loading", "process", "init", "download", " loads", "dump", "clone", "select", "Loading"], "conn": ["exec", "mc", "client", "ca", "ann", "cache", "util", "reg", "db", "oci", "pt", "connect", "session", "ns", "sql", "state", "ls", "cp", "cr", "c", "ci", "cc", "rt", "ct", "ec", "sb", "connection", "Exec", "Connection", "n", "config", "co", "enc", "nt", "loc", "pub", "dc", "p", "h", "pg", "dn", "col", "cn", "ch", "act", "dh", "coll", "pc", "con", "nc", "cat", "Conn", "conf", "ctx", "pr"], "stmt": ["playtr", " sttr", " stmn", "esttr", "stager", " stmr", "astmn", "atmt", "astk", "fldo", "osttr", "estmd", "strs", "Stdb", "putur", "STml", "stb", " str", "playml", "stMT", "slager", "STbl", "stmr", "Stts", "Stpl", "stbt", "atmn", " strs", "stts", "actbl", "plb", "STdb", " stor", "Stur", "ostpr", "elmt", "stmb", "STnt", " sttor", "strdo", "stm", "playmt", "tct", "estct", "slk", "StMT", "putmb", "putts", "playor", "estMT", "stql", " stmb", "acttor", "dmd", "dmt", "Sttor", "dnt", "astmt", "astql", "playmn", "themn", "Stmn", "plr", "Stpr", "slr", "slmn", "flmt", "tm", "ostmt", "STpl", "Stmr", "ostct", "flk", "stct", "Stmt", " stk", "elrs", "Stnt", "actmt", " stager", "slnt", "STMT", "Stmd", "sttor", "stnt", "str", "Sttr", "elml", "puttr", "Stth", "estmt", "STmn", " stbt", "stk", "clur", "slmt", "plnt", "Stbt", "cltr", "flmd", " stb", "stmd", " stmi", "atMT", "STct", " stdb", "plmt", "stth", "stor", "themt", "stpr", "strmt", "strmd", "atb", " stct", "stdo", " stpl", "acttr", "STmt", "Stager", "Stmc", " stth", "clmn", "stbl", "estmr", "Stor", "STmd", " stts", "STk", "estk", "Stb", "stdb", "stmc", " stql", " stm", "putmn", "putmi", "stur", "Stm", "putbt", " stMT", "strk", "elmi", "tmt", " stbl", "STager", "stpl", "putml", "clmt", "plMT", "estth", "Stbl", "ostmn", " stmc", "putrs", "Stmb", "estdo", "STql", " stnt", "ostpl", "stml", "stmn", "theb", "estql", "plmn", "dMT", "sttr", " stml", "stmi", " stpr", "themc", "playpl", "tpl", "putmt", "ostager", "Stql", "Stml", "Stct"]}}
{"id1": "5998352", "id2": "4164833", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"testStandardTee": ["testStandardBee", "testStandardTees", "teststandardMees", "testStandardMee", "testStandardBees", "teststandardTee", "teststandardTeed", "testStandardFee", "testStandardTeed", "teststandardMae", "testStandardMae", "testStandardMeed", "testStandardFees", "teststandardTae", "teststandardMee", "testStandardFae", "testStandardTae", "testStandardFeed", "testStandardBeed", "teststandardTees", "testStandardBae", "teststandardMeed", "testStandardMees"], "reference": ["distance", "forward", "prefix", "Reference", "description", "attribute", "proxy", "url", "uri", "resource", "message", "report", "References", "copy", "server", "length", "connection", "remote", "relative", "version", "single", "hello", "external", "sequence", "output", "primary", "document", "archive", "index", "ref", "test", "type", "code", "see", "memory", "directory", "filename", "pair", "target", "number", "variable", "ference", "address", "string", " Reference", "REF", "c", "name", "re", "relation", "binary", "order", "location", "path", "pointer", "specified", "buffer", "format", "collection", "request", "rice", "database", "compatible"], "source": ["proxy", "text", "writer", "url", "resource", "e", "server", "se", "copy", "parent", "g", "view", "connection", "ce", "io", "ie", "output", "Source", "result", "input", "ref", "code", "temp", "i", "iter", "driver", "reader", "src", "config", "target", "table", "r", "object", "slice", "string", "ource", "service", "SOURCE", "context", "buffer", "fe"], "destination1": ["destinator01", "destribution1", "destinate01", "constinator2", "destarationOne", "destinatorOne", "Destension0", "Destension1", "destination01", "DestinateOnce", "destentionOnce", "constinationOne", "destribution0", "destinations2", "DestinationOnce", "constination01", "destaration0", "DestensionOne", "destentionOne", "destension0", "destination0", "destinate2", "DestinateOne", "destention1", "destinatorOnce", "destinateOne", "Destination1", "destaration1", "DestinationOne", "destinate1", "constination1", "constinatorOne", "destensionOne", "destinator2", "destinateOnce", "Destination0", "destinationOnce", "destinations01", "destinator1", "constinator1", "constinator01", "destributionOne", "Destinate1", "constination2", "destinationsOne", "destension1", "destinations1", "destinationOne"], "destination2": ["coordinate2", "coordinate22", "destignmentSecond", "destribution2", "destationtwo", "destinations02", "descination02", "destication22", "coordination8", "destication8", "destination02", "descination2", "destination22", "Destinationtwo", "desticationSecond", "Destination2", "descinationsSecond", "destinationSecond", "destinateSecond", "coordination2", "destation1", "coordinate8", "descinationSecond", "destination4", "destinating2", "destinate02", "destignment02", "coordination22", "destication2", "destinate8", "descination1", "destinatingtwo", "destinationsSecond", "destinationtwo", "destinations2", "Destination4", "destation4", "destinatetwo", "coordinationSecond", "coordinateSecond", "destinate22", "destinate2", "destination8", "Destination1", "descinations2", "destation2", "destribution8", "descinations02", "destributionSecond", "destinate1", "destribution22", "destignment2", "destinate4", "Destinate1", "destignment1", "descinations1", "Destinate4", "Destinate2", "Destinatetwo", "destinations1", "destinating4", "destinating1"], "tee": ["leee", "teee", "TEee", "eeee", " teec", "ettef", "lepe", " tef", "cee", " teee", "TEe", "TEc", "ceee", "eeffe", "tef", "chef", "cec", " teae", "teffe", "lee", "ceea", "sef", "tepe", "chee", "leec", "seae", "tec", "teec", "see", "eee", "chei", " tei", "etteee", "seee", "tei", " tec", "teae", " tepe", "TEea", "lei", " teffe", "ettee", "leffe", "etteae", "lef", " teea", "eeec", "chepe", "teea"]}}
{"id1": "22366505", "id2": "18962382", "code1": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "code2": "    protected void connect() throws SocketException, IOException, LoginFailException {\n        logger.info(\"Connect to FTP Server \" + account.getServer());\n        client = new FTPClient();\n        client.connect(account.getServer());\n        if (client.login(account.getId(), account.getPassword()) == false) {\n            logger.info(\"Fail to login with id=\" + account.getId());\n            throw new LoginFailException(account.getId(), account.getPassword());\n        }\n    }\n", "label": 0, "substitutes": {"incluir": ["incluear", "inclituire", "inCLUire", "inCLuir", "inclurir", "inclUiro", "incluiro", "inclituear", "inclUire", "incluire", "inclUear", "inclurire", "inclituiro", "inclUir", "inclituir", "inclurear", "incluriro", "inCLuiro", "inCLuear", "inCLUir", "inCLUear", "inCLUiro", "inCLuire"], "igreja": ["igreraza", "ligrej", " iggreji", "igruji", "igreraya", " igreji", "igruj", "igcreJa", "igrej", "igr\u00e9je", "igreya", "iggreJa", " igreraja", "igr\u00e9ja", "iggreje", "igruya", "igreji", "ligr\u00e9ja", "iggreya", " iggreja", " igreza", "igruje", "igreje", " igreJa", "ligr\u00e9je", "ligr\u00e9j", " igreraya", "igereja", "igerej", "igereji", "ligrejas", "igrejas", "iggrejas", "igcreji", "igrujas", "igreraji", " igreya", " iggrej", "iggrej", "igcreja", "iggreja", "ligr\u00e9jas", "igruja", "igreJa", "igcrej", "ligreja", " igrej", "iggreza", "igr\u00e9j", "igr\u00e9jas", "igreraja", "igreza", " igreraza", " iggreJa", "iggreji", "igereJa", "igruza", "ligreje", " igreraji"], "connection": ["index", "pool", "graph", "system", "ion", "section", "event", "function", "Connection", "cache", "table", "environment", "conn", "application", "option", "c", "cf", "position", "condition", "engine", "session", "collection", "core", "relation", "BC", "query", "client", "cc", "context", "manager", "statement", "communication", "con", "loc", "server", "union", "document", " Connection", "connect", "lock", "description", "error", "database", "bc", "connected", "config", "ctx", "db", "socket", "machine", "directory"], "sql": ["log", "sol", "setup", "section", "printf", "nl", "function", "ls", "SQL", "filename", "sync", "conn", "csv", "string", "null", "spec", "session", "params", "query", "join", "stat", "ql", "sb", "eps", "sq", "statement", "socket", "ssl", "term", "sys", "ln", "id", "fn", "seed", "sl", "database", "seq", "dl", "select", "db", "url", "s"], "sql2": ["url1", " sql02", " sql1", "sql02", "url2", "ql1", "ql02", "sqltwo", "ssl02", "qltwo", "ssl1", "sqlII", "sql1", "ql2", " sqltwo", "ssl2", "qlII", "urltwo", "sslII", " sqlII"], "stmt": ["STmt", "fmd", "frconn", "strh", "Stmt", "istconn", "strmd", "Stmn", "Stql", "frtr", "frmn", " stmr", "stconn", "Stmb", "ostmn", "frmt", " sttr", "tm", "stmd", "STmd", "Stst", "Stmr", "stql", " stst", "sttr", "ostmd", "istmn", "stpt", "isttr", "ostmr", "stmn", "STmb", " stconn", " stmd", "fh", "Stmd", "fdb", " stmb", "stm", "Stpt", "strmt", "fmt", "stst", "istmt", " stpt", "tpt", "tmr", "Stm", " stm", "ostmt", "sth", "ostql", "STst", " stdb", "stdb", "stmr", "tmt", "strdb", " stql", "stmb", " sth", " stmn"], "stmt2": ["stmd1", " stmt3", "stmp02", "stmd3", "stmt4", "stmp2", " stmt1", " stmr02", "stmp1", " stmt4", " stmtTwo", "stmpTwo", " stmp3", "stmt1", "stmr02", "stmnTwo", " stmp4", " stmp2", "stmd4", "ctmtTwo", "stmr1", "stm4", "ctmt1", "stm2", "stmr3", "stbmTwo", "stmn1", "stmd2", "stbm1", "stmp4", "ctmt2", " stmrTwo", "stmrTwo", " stmt02", "stmt02", " stmr2", "stmtTwo", "ctmpTwo", "stm1", " stmpTwo", " stmp1", "stmp3", "ctmp2", "stbm2", "stmr4", "stmdTwo", "stmr2", "stmt3", " stmr1", "ctmp1", "stbm02", "stmn4", "stmn2"], "rs": ["ars", "rys", "eers", "errors", "rates", "ls", "runs", "details", "vers", "ms", "conn", "pr", "Rs", "rd", "r", "xs", "rows", "rc", "ps", "params", "ows", "ds", "relations", "ris", "ros", "rr", "ras", "cs", "mr", "row", "qs", "ins", "hs", "ys", "sr", "gs", "RS", "ss", "results", "res", "ks", "ts", "cr", "rss", "s"], "retorno": ["Retago", " retro", "respro", "Retorn", "retro", "ntorn", "ntour", "Retro", "retour", " retorn", "Retorno", "resporno", "Retour", "ntro", " retour", "ntorno", "retago", "resporn", "respago", " retago", "retorn"]}}
{"id1": "822452", "id2": "1357662", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrap", "readandRewrites", "readAndRewwrite", "readandrewrites", "readandRewrap", "readAndSwwrite", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readAndRebrites", "readAndRewrites", "readAndrewrites", "readandrewrite", "readandRewwrite", "readandrewrap", "readAndRebrite", "readAndSwrites", "readAndSwrite", "readAndRebrap", "readAndrewrap", "readandrewwrite", "readAndRewrap", "readandRewrite"], "inFile": ["inputFile", "outFiles", "oldFile", "loginfile", "oldFilename", "infile", "inputfile", "outfile", "loginFile", " inSourceFile", "loginFiles", "inSourceFile", "outSourceFile", "loginFilename", "inFiles", "InFiles", " infile", "InSourceFile", "oldfile", "oldFiles", "inputFiles", "outFilename", " inFilename", "inFilename", "InFile", "Infile", " inFiles", "inputFilename"], "outFile": ["processFILE", "newFile", "newStream", "Outfile", " outStream", "thisFILE", "outDir", "thisfile", "outfile", " outDir", "outStream", "outputFile", "processFile", "processPlace", "offFile", "processFilename", "outputPlace", "offFilename", " outfile", "OutStream", "newDir", "outputFILE", "outputFilename", "thisFile", "outPlace", "exFILE", "exFilename", "newfile", "exFile", "outFilename", "outputfile", "offPlace", "OutDir", "outFILE", "thisFilename", "exfile", "OutFile", "offFILE"], "iis": ["iais", "Iais", " iIs", "iiss", "Iis", "IIS", " iiss", "iiIs", "iniis", "iniiss", " iris", "iniIs", "ciris", "iniIS", "iiis", "ciIs", "iiris", "iniris", "Iiss", "iiiss", " iIS", "ciIS", "iiIS", "iIS", "iris", "ciis", "iIs", "ciiss", "ciais", " iais"], "dcmParser": ["dcrParser", " dpmPar", "dmParser", "dcmJar", "dcrPar", "DcmInstallation", "dmissionReader", "dpmPlugin", "dmissionParser", " dpmReader", "dkmParser", "dcrLoader", "dhemInstallation", " dcrReader", " dcmReader", "dmcJar", "dmissionPlugin", "dcmPar", "dpmInstallation", "dcmHandler", "dpmHandler", " dpmparser", "dmLoader", "dpmPolicy", "dpmParser", "dcmPlugin", "dmmParser", " dcmLoader", " dpmJar", "dcmLanguage", "DcmJar", "dcrPlugin", " dpmarser", " dcmparser", "dmcPar", " dcmPar", "dmcParser", " dcrPlugin", "dkmPolicy", "dpmPar", "dCMLoader", "dpmLoader", "dbmPlugin", "dCMParser", " dpmHelper", "fcmReader", "dbmParser", "dCMHandler", "fpmReader", "dcrReader", "dkmPlugin", " dcmPolicy", "fpmHandler", "fcmparser", "dpmarser", "dmmparser", " dcmarser", "dbmPolicy", "dpmLanguage", "dcrJar", "dmoduleJar", "dmoduleparser", " dpmParser", "fcmHandler", "dmcarser", "dpmReader", "dcmPolicy", "dcmLoader", "dcmHelper", " dcmJar", " dcmPlugin", " dpmPlugin", "dpmparser", "dmoduleReader", "dmPlugin", " dcmHelper", "dhemJar", "dcmarser", "fpmparser", "dbmHelper", " dpmLoader", " dpmLanguage", "dmReader", " dcrLoader", "dcmparser", " dpmPolicy", "dmissionLanguage", "dhemParser", "dmmLoader", "dmodulePlugin", "dcrarser", "fpmParser", "dCMReader", "dCMPlugin", "fcmParser", "dCMparser", " dcmLanguage", "dcmInstallation", "dmoduleParser", " dcrParser", "DcmReader", "dhemReader", "dpmHelper", "dpmJar", "dmmPlugin", "dcmReader", "DcmParser", "dkmHelper"], "ds": ["cdn", "df", "ts", "asi", "data", "iss", "vals", "eps", "s", "icks", "bs", "dd", "ins", "services", "sync", "session", "ns", "da", "Ds", "utils", "os", "sys", "cs", "ld", "ls", "ys", "di", "conn", "parts", "is", "rs", "drivers", "dds", "Db", "dr", "dc", "d", "ras", "nas", "gd", "db", "points", "qs", "js", "ws", "tes", "DS", "Os", "xs", "uds", "vs", "gs", "ays", "ps", "details", "ils", "ants", "des", "src", "amps", "ros", "dat", "ss", "pd", "ads", "tx", "ks", "dt"], "pdReader": ["hdLoader", "pdRunner", "pbReader", "hdStream", "ddRunner", "dsreader", "dsReader", "ddLoader", "pdLoader", "pdStream", "pcLoader", "xdReader", "pcReader", "dsRead", "pbRunner", "pdreader", "pcWriter", "ddStream", "ddReader", "hdreader", "xdreader", "dsLoader", "xdWriter", "pdRead", "pbLoader", "pcRead", "hdWriter", "hdRead", "xdRead", "pbStream", "hdRunner", "hdReader", "dsWriter"], "out": ["lock", "ext", "login", "data", "doc", "name", "at", "down", "outs", "ssl", "w", "err", "flow", "o", "dot", "cli", "oder", "exec", "url", "default", "null", "io", "as", "co", "exp", "over", "point", "later", "session", "auto", "to", "sys", "page", "cache", "conn", "inner", "output", "term", "her", "key", "client", "builder", "outer", "parent", "order", "group", "code", "up", "word", "result", "director", "copy", "model", "with", "part", "line", "writer", "temp", "external", "lib", "image", "inc", "store", "Out", "obj", "device", "full", "connection", "manager", "s", "dev", "array", "sync", "layer", "ex", "gen", "base", "user", "again", "img", "password", "OUT", "list", "db", "child", " in", "object", "pass", "net", "in", "file", "diff", "write"], "dcmEncParam": ["dcmEstPar", "dcmDecPart", "dcmEncParameter", "dcmEncPart", "dcmElType", "dcmEnParameter", "dcmArchParameter", "dcmEnPar", "dcmDecArg", "dcmEnType", "dcmEstParameter", "dcmEstParam", "dcmArchArg", "dcmSecPart", "dcmDecParameter", "dcmEnPart", "dcmDecType", "dcmDecParam", "dcmEncPar", "dcmSecPar", "dcmSecParam", "dcmEncArg", "dcmEncType", "dcmElPar", "dcmEstType", "dcmElParameter", "dcmDecPar", "dcmEnArg", "dcmSecType", "dcmEnParam", "dcmArchParam", "dcmElParam"], "pdWriter": ["dsWrite", "PDWriting", "dpWriter", "pdWriting", "dsReader", "hdWrite", "dpWrite", "htWriting", "PDReader", "ddWrite", "dsOutput", "hdOutput", "PDWrite", "ddReader", "dpReader", "htReader", "pdOutput", "ddWriter", "pdWrite", "htWrite", "ddOutput", "PDWriter", "htWriter", "hdWriter", "hdReader", "dsWriter", "dpWriting"]}}
{"id1": "838844", "id2": "411595", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 1, "substitutes": {"convert": ["Converting", "subverting", "unverted", "Conversion", "converted", "CONverted", "unception", "CONverting", "conversion", " deconverting", "Convert", " deconvert", "conception", " deconverted", "subversion", "oconverted", "Conception", "subverted", "CONception", "oconvert", "oconversion", "subvert", "unvert", "CONversion", "CONvert", "converting", " deconversion", "unversion", "Converted", "oconverting"], "src": ["resource", "scene", "stage", "sth", "username", "cmp", "SourceFile", "string", "href", "Source", "spec", "cpp", "dist", "input", "ource", "path", "inst", "ctx", "sc", "buf", "slice", "sys", "attr", "rl", "download", "impl", "fn", "loc", "proc", "video", "gb", "s", "rc", "storage", "upload", "tmp", "url", "component", "load", "sn", "config", "sb", "code", "gz", "filename", "sin", "Dest", "fp", "cb", "ssl", "img", "reader", "st", "RC", "supp", "secure", "obj", "req", "feat", "rb", "prot", "back", "source", "stream", "uri", "sel", "name", "sit", "file", "ref"], "dest": ["dc", "txt", "temp", "class", " dst", "dat", "dist", "bin", "path", "di", "disk", "dir", "fn", "orig", "tmp", "home", "lib", "Dest", "std", "img", "test", "obj", "target", "null", " destination", "source", "cont"], "in": ["In", "inas", "pass", "ini", "n", "IN", "ex", "is", "d", "din", "bin", "input", "as", "io", "pin", "ins", "doc", "inn", "err", "up", "isin", "win", "f", "i", "a", "inf", "val", "login", "reader", "data", "r", "ps", "t", "inc", "source", "stream", "file"], "p": ["pc", "cop", "pd", "pm", "g", "c", "pr", "pi", "op", "py", "pb", "pg", "o", "m", "d", "np", "pp", "bp", "tp", "wp", "l", "part", "s", "pe", "cp", "pa", "j", "sp", "per", "f", "e", "lp", "i", "pre", "h", "fp", "v", "P", "jp", "r", "po", "ps", "t", "parser", "b"], "ds": ["dc", "hs", "words", "dl", "gs", "da", "obs", "s", "icks", "ges", "dm", "ts", "sts", "db", "df", "js", "pd", "bs", "ys", "dat", "lines", "dos", "d", "utils", "ads", "styles", " props", " sd", "amps", "ld", "ans", "Ds", "lp", "ns", "data", "posts", "parts", "docs", "ps", "DS", "ss", "dp", "scripts", "uds", "di", "os", "sync", "sys", "ins", "xs", "tests", "dds", "ls", "dt", "cs", "des", "nas", " DS", "ups", "ks", "eps", "dist", "cons", "ays", "tools", "ants", "groups", "plugins", "dd", "qs", "vs", "services", "dates", "ths", "els", "gd", "ded", "vals", "points", "ils", " ps", "ipes", "rs", "models"], "format": ["struct", "class", "function", "at", "act", "string", "host", "table", "spec", "version", "language", "atter", "path", "fd", "api", "magic", "letter", "unit", "handler", "fn", "frame", "nat", "scale", "tag", "part", "layout", "Format", "model", "prefix", "ant", "url", "config", "f", "sche", "filename", "record", "fp", "filter", "data", "type", "feat", "style", "plugin", "t", "parser", "pattern", "source", "form", "name", "file", "template"], "hasPixelData": ["showsPixeldata", "haspixeldata", "showsPixelDATA", "hasByteDATA", "hasPixeldata", "hasPixelDATA", "showsPixelStyle", " hasPixelSize", " hasPixeldata", "showsBytedata", "showsByteStyle", "haspixelSize", "showsPixelData", "hasByteData", "hasByteStyle", "hasBytedata", "haspixelData", "hasPixelStyle", "showsByteData", "hasPicturedata", "hasByteSize", "hasPictureSize", "hasPixelSize", "hasPictureData", "showsByteDATA"], "inflate": ["inFlated", "inadequating", "infloace", "insflode", "InFlate", "infolATE", "inadequode", "insvenATE", "inFlate", "insflating", "InFlace", "insflATE", "inffated", "inflation", "invenate", "inflace", "infolode", "inFlation", "infloate", "insvenate", "invenATE", "infloated", "inffation", "invenating", "InFlated", "insvenating", "insflate", "inflATE", "inflating", "Inflace", "infface", "inFlace", "infolate", "Inflated", "inffate", "Inflate", "inadequate", "insvenode", "inflated", "infolating", "infloation", "inflode", "invenode", "Inflation", "InFlation", "inadequATE"], "pxlen": ["fxdata", "pnglen", "pxlin", "mxln", "axlon", "pxcount", "fxln", "pglen", "txln", "pcln", "ppl", "pxlon", "txlin", "camlen", "fxl", "pgden", "pngsize", "axlin", "mxlen", "camln", "fxden", "xplength", "ppLen", "mxdata", "pxLen", "pxdata", "pclen", "pclin", "axln", "pxln", "axlen", "txlen", "pngcount", "campos", "mxpos", "fxLen", "xpsize", "xpcount", "pxsize", "pgl", "pxpos", "ppden", "pgLen", "fxpos", "pxlength", "fxlen", "mxlength", "mxcount", "xplen", "mxsize", "camdata", "pxden", "pclon", "pplen", "pxl", "pnglength", "txlon"], "out": ["group", "line", "again", "cache", "step", "inter", "state", "Out", "copy", "log", "io", "outs", "list", "co", "post", "sys", "pad", "user", "conn", "store", "err", "up", "server", "query", "work", "cli", "session", "dump", "lib", "v", "page", "output", "gen", "error", "obj", "OUT", "point", "parent", "lock", "re"]}}
{"id1": "22410173", "id2": "4481712", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "source": ["resource", "route", "use", "site", "Source", "inner", "input", "copy", "ource", "path", "down", "from", "slice", "ins", "unit", "ie", "up", "connection", "base", "url", "size", "iter", "SOURCE", "start", "internal", "sin", "image", "reader", "ources", "target", "id", "parent", "stream", "src", "name", "file"], "dest": ["folder", "temp", "done", "exit", "project", "dist", "bin", "destroy", "desc", "down", "path", "die", "this", "comb", "connection", "orig", "tmp", "delete", "thin", "flat", "home", "Dest", "transfer", "img", "output", "test", "true", "target", " destination", "de", "wb", "src", "name", "later", "file"], "in": ["resource", "In", "pull", "again", "n", "c", "ini", "IN", "m", "cin", "inner", "din", "bin", "src", "input", "as", "con", "this", "pin", "ins", "min", "conn", "inn", "ie", "err", "up", "init", "win", "s", "url", "work", "gin", "f", "inside", "i", "by", "nin", "a", "image", "socket", "start", "file", "login", "reader", "data", "r", "b", "plugin", "inc", "id", "info", "lock", "client", "re", "name"], "out": ["timeout", "temp", "not", "at", "again", "cat", "n", "c", "channel", "o", "option", "call", "ex", "exp", "inner", "bin", "with", "Out", "self", "log", "outer", "io", "outs", "this", "sync", "conn", "no", "our", "err", "up", "connection", "init", "net", "w", "exec", "url", "index", "pool", "off", "password", "i", "lib", "socket", "plain", "writer", "to", "ext", "img", "output", "ou", "write", "data", "obj", "OUT", "vert", "inc", "id", "parent", "client", "name", "file", "extra"]}}
{"id1": "2521141", "id2": "4468255", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["get", "image", "clone", "sync", "upload", "ize", "cp", "transfer", "delete", "Copy", "load", "write", "cat", "directory", "archive", " cp", "ame", "open", "source", "diff", "share", "rm", "clip", "cop", "ignore", "change", "file", "ge", "link", "update", "zip", "download", "create", "type", "pe", "paste", "attach", "dump", "opy", "config", "move"], "from_name": ["from_names", "from__name", " from_names", "from_memory", "to_path", "from_key", "fromFfilename", "fromFname", "source_filename", "fromMname", "source_memory", "from_filename", "to_filename", "source_name", " from_Name", "from__path", "fromFpath", "from__memory", "from_path", "fromMnames", "fromFmemory", "fromMfile", "source_path", " from_key", "from_Name", "from__filename"], "to_name": ["toamname", "toamhome", "to_home", "toampath", "to_path", " to_Name", "to_Name", " to_path", "from_path", "from_filename", "toamfile", "to_filename", " to_home"], "from_file": ["fromappfunction", "from_directory", " from__auto", "from__name", "from_brain", "from___filename", "from_resource", "from_source", "from___file", " from__filename", " from__file", " from_directory", "source_filename", "source_directory", "fromCfile", "remote_lane", "from__files", " from_filename", " from__name", "from__directory", "from__resource", "fromCname", "remote_function", "from_function", "from_filename", "from___name", "from_lane", "remote_log", "fromCbrain", "source_brain", " from_folder", "source_name", " from_auto", "source_files", "remote_file", " from_files", "fromapplane", "from_auto", "from_log", " from_source", "from_files", "fromCfilename", "fromappfile", "from__file", "from_folder", "fromapplog", "source_resource", "from__filename", "from__auto", "source_file", "from___auto"], "to_file": ["to64use", "to_model", "tojfile", "intojfile", "eto___remote", "intojfunction", "into_use", "to__dir", "eto_remote", "from_model", "to64name", "to_remote", "to_binary", "source_filename", "to_server", "to67load", "eto_file", "intojname", "intojuse", "to___remote", "tojuse", " to_class", "into_function", "to67dir", " to_queue", "to__name", "to_filename", "from_bar", "source_server", "to_queue", "to_dir", "to67name", "eto___name", "toJstream", "to__load", "to64file", " to_model", "to64function", "into_file", "toJfile", "to___name", "to_class", "tojfunction", "source_files", "eto_name", "from_dir", "to67file", " to_filename", "to_stream", "to___file", "from_files", "from_stream", "from_load", "to_function", "toJbar", "eto___file", " to_files", "to_files", "to_load", "to_use", "tojname", "into_name", "to_bar", "toJname", "from_binary", "to__file", "source_file"], "parent": ["size", "author", "old", "global", "complete", "address", "target", "content", "container", "Parent", "root", "api", "test", "search", "name", "string", "folder", "am", "uri", "ip", "client", "p", "full", "pa", "user", "page", "patch", "rule", "cache", "home", "loc", "path", "pool", "file", "part", "unit", "div", "any", "ac", "inc", "ppa", "tree", "host", "id", "directory", "port", "per", "child", "out", "manager", "function", "url", "null", "memory", "remote", "point", "source", "term", "mother", "par", "owner", "po", "handler", "server", "or", "connection", "fat", "location", "resource", "session", "type", "temp", "parents", "current"], "dir": ["r", "db", "in", "entry", "block", "def", "class", "object", "user", "global", "dict", "cat", "dec", "id", "directory", "coll", "cache", "home", "per", "md", " directory", "loc", "group", "module", "or", "dr", "ver", "dc", "container", "path", "dep", "cur", "io", "exp", "ir", "out", "manager", "wd", "file", "root", "director", "part", "build", "iter", "f", "url", "die", "doc", "data", "div", "rel", "keep", "Dir", "name", "di", "d", "folder", "tr", "lock", "dev", "nav", "dis"], "from": ["when", "get", "auto", "From", "fr", "client", "component", "flo", "left", "one", "entry", "stream", "form", "ce", "view", "feed", "context", "ou", "parse", "e", "cr", "cf", "cache", "server", "address", "per", "fe", "conn", "or", "connection", "http", "low", "io", "se", "cor", "cm", "ra", "con", "file", "find", "part", "who", "start", "link", "url", "ch", "this", "api", "base", "normal", "with", "pe", "range", "can", "so", "name", "bean", "by", "without", "two", "empty", "add", "source", "self", "vol"], "to": ["auto", "db", "su", "client", "that", "flo", "size", "too", "sync", "one", "output", "socket", "proxy", "write", "on", "po", "tto", "office", "To", "t", "server", "per", "conn", "thro", "target", "or", "connection", "fat", "http", "TO", "fb", "ver", "io", "top", "op", "see", "not", "out", "value", "dest", "file", "storage", "store", "pi", "o", "until", "api", "base", "will", "session", "type", "with", "token", "via", "so", "co", "by", "as", "two", "about"], "buffer": ["position", "writer", "shape", "batch", "block", "queue", "texture", "transfer", "default", "comment", "feed", "character", "slice", "reference", "bb", "page", "Buffer", "server", "address", "source", "padding", "message", "resource", "buff", "row", "uffer", "iter", "url", "buf", "binary", "channel", "null", "data", "b", "border", "number", "wave", "document", "total", "memory", "reader", "variable", "header", "seed", "duration", "window", "read", "flush", "layer", "length"], "bytes_read": ["gets___pass", "bytesXbefore", "gets___allow", "byte_current", "byte_load", " bytes_en", "bytes___reads", "bytes_en", "gets_allow", "byteslexread", " bytes_found", "bytes___allow", " bytes_write", "bytes_found", "bytesXload", "bytes_reads", "bytesXread", "byte_before", "bytes_allow", "bytes_pass", "bytes_load", "bytesXcurrent", "bytes_write", "bytes_before", "bytes___read", "gets___read", "gets_reads", "gets___reads", "bytes___pass", "gets_pass", "bytes_current", "byteslexload", "byte_read", "gets_read", "byteslexbefore", "byteslexcurrent"]}}
{"id1": "6009527", "id2": "5299276", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadAttment", "doFinishloadAttment", "doFinishLoadInstachment", "doFinishloadAttachment", "doFinishloadAttments", "doFinishLoadAttachachment", "doFinishLoadAttachortion", "doFinishloadAttachments", "doFinishLoadAssments", "doFinishLoadInstment", "doFinishLoadAssachment", "doFinishLoadAssortion", "doFinishLoadAttments", "doFinishLoadAttachments", "doFinishLoadInstments", "doFinishloadAttortion", "doFinishLoadAssment", "doFinishloadAttachachment", "doFinishloadAttachortion", "doFinishLoadInstortion", "doFinishLoadAttortion"], "attachmentId": ["attachmentInfo", "attentionInfo", "attociationId", "ttociationid", "ttociationID", "ttachmentId", "AttachmentType", "attimageId", "adachmentPath", "ttachmentID", "Attachmentid", "adociationID", "attentionid", "attachmentPath", "AttachmentId", "attachmentType", "attlementID", "attlementid", "adachmentID", "attociationid", "attlementType", "attentionID", "adachmentId", "attplementationid", "adociationId", "ttociationId", "attimagePath", "adociationPath", "attachmentID", "adociationInfo", "ttachmentid", "attentionType", "attplementationID", "AttachmentID", "attlementId", "attociationPath", "attimageInfo", "attociationInfo", "adachmentInfo", "attentionPath", "attachmentid", "attentionId", "attplementationId", "attimageID", "attociationID"], "attachment": ["assachment", "instment", "attociation", "instention", "attention", " adaptention", "appention", "instruction", "appment", " attociation", "attachruction", "assment", "instachment", "attment", "appruction", "appachment", "adached", "adment", " attment", "adachment", "attachached", "attachention", "assention", "attruction", " adaptachment", " adaptociation", " adaptment", "assached", "attached", "attachachment", "adention", " attention", "association"], "attachmentUri": ["attachedARI", "attmentIri", "attachmentSuURI", "attachmentUris", "attachedUuri", "attachmentSuris", "attmentIris", "attachmentSuuri", "attachmentERI", "attachmentEuri", "attachmentARI", "attachedURI", "attachmentSuti", "attmentIuri", "attachmentSuRI", "attachmentEri", "attachmentURI", "attachmentIri", "attmentUuri", "attachedUri", "attachedAti", "attachmentUuri", "attachmentCuURI", "attmentUris", "attachmentSuri", "attachmentIURI", "attachmentAuri", "attmentIURI", "attmentUri", "attachmentCuuri", "attachmentIuri", "attachedAri", "attachedAuri", "attachmentUti", "attachmentUURI", "attachmentCuri", "attachmentCuris", "attachmentAri", "attachmentAti", "attmentUURI", "attachmentIris", "attachedUti", "attachmentEti"], "contentUri": ["contentUsRI", "contentUsdi", "resourceUi", " contentURI", "contentFileRI", " contentUdi", "resourceIris", "contentURuri", "contentUuri", " contentUris", "contentUsuri", "contentUsri", "contentUsris", "contentUdi", "resourceUri", "contentSuris", "contentCdi", "contentIris", " contentSuris", " contentSuRI", "contentFileri", "contentCris", "contentCuri", " contentSudi", " contentSuri", "contentSuri", "contentIuri", "contentFileuri", "contentURri", "resourceIi", "contentURI", "contentURris", "resourceIuri", "contentCi", "contentCri", "resourceURI", "contentUi", "contentIi", "contentUris", "contentIri", "resourceIri", "contentFileris", "contentSudi", "contentURi", "contentIRI", "contentCRI", "resourceIRI", "resourceUuri", "resourceUris", "contentSuRI"], "file": ["to", "book", "pe", "log", "url", "unit", "resource", "image", "uri", "le", "copy", "FILE", "b", "view", "able", "letter", "connection", "io", "data", "single", "this", "child", "socket", "folder", "output", "f", "via", "zip", "model", "input", "source", "create", "reader", "filename", "use", "work", "stream", "files", "base", "ger", "object", "local", "cache", "load", "handler", "upload", "name", "entity", "up", "binary", "File", "get", "path", "auto", "picture", "content", "buffer", "line", "fp"], "in": ["m", "ins", "url", "e", "image", "In", "copy", "b", "connection", "init", "io", "data", "this", "sync", "inc", "socket", "f", "gin", "input", "o", "din", "IN", "inn", "s", "conn", "i", "pull", "win", "source", "reader", "a", "nin", "cli", "login", "inner", "r", "id", "ac", "bin", "c", "err", "con", "up", "binary", "pin", "ini", "as", "or", "again"], "out": ["to", "page", "ex", "log", "writer", "resource", "one", "image", "copy", "null", "b", "view", "In", "connection", "lock", "init", "io", "outer", "data", "this", "sync", "inc", "socket", "output", "o", "IN", "Out", "s", "conn", "i", "source", "client", "cli", "nin", "inner", "base", "outs", "cache", "exec", "bin", "err", "by", "up", "net", "OUT", "again", "line", "on", "ext"], "intent": ["Activity", "ink", "activity", "text", "request", "term", "act", "init", "event", "animate", "this", "focus", "anc", "entry", "document", "inst", "it", "effect", "acc", "ent", "android", " Intent", "ani", "xml", "element", "action", "eng", "agent", "impact", "advert", "activate", "contact", "feature", "object", "language", "ents", "activation", "spirit", "entity", "ctx", "context", "ant", "response", "content", "concept", "vent", "anim", "enc", "intention", "category", "feat"]}}
{"id1": "397240", "id2": "10385815", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewwrite", "readandRewrite", "readandrewrites", "readAndSwrites", "readAndrewrite", "readAndRebrite", "readandRewwrite", "readAndrewwrite", "readAndRebrites", "readandrewwrite", "readandrewrap", "readAndSwwrite", "readandRewrap", "readandRewrites", "readAndrewrap", "readAndRewrites", "readAndrewrites", "readAndRebrap", "readAndRewrap", "readAndSwrap", "readandrewrite", "readAndSwrite", "readAndRebwrite"], "inFile": ["oldFilename", "InFiles", "Infile", "oldFiles", "loginFilename", "inputFile", "InFile", "InSourceFile", "loginFile", "infile", "oldfile", "inputFiles", "oldFile", " infile", "inputFilename", " inFilename", "loginfile", "outfile", "loginFiles", "inFilename", " inSourceFile", "outSourceFile", "inFiles", "outFiles", "outFilename", "inSourceFile", " inFiles", "inputfile"], "outFile": ["newDir", "thisfile", "outDir", "processPlace", "OutStream", "thisFILE", "OutDir", "outFILE", "newFile", "offFile", "offFILE", "thisFilename", "outputFILE", "outStream", "outputFilename", "offFilename", " outfile", "exfile", "offPlace", "processFILE", "outputPlace", "thisFile", "processFilename", " outStream", " outDir", "outputfile", "newfile", "newStream", "exFilename", "outfile", "exFILE", "outPlace", "OutFile", "processFile", "exFile", "Outfile", "outFilename", "outputFile"], "iis": ["Iis", "iiris", " iiss", "iiIs", "ciIs", "ciIS", "ciis", "Iiss", "Iais", "iniiss", "iniIs", "iiss", "iniris", "ciais", "iiiss", " iIS", "iniIS", " iais", "iIS", " iIs", "iiIS", "iIs", " iris", "iris", "ciiss", "iniis", "iiis", "IIS", "ciris", "iais"], "dcmParser": [" dcrPlugin", "dmParser", " dcmHelper", " dcmarser", "fcmHandler", "dpmPlugin", "dcrPar", "fpmParser", "dCMReader", "dcmLoader", " dcmPlugin", "dpmLanguage", "dkmParser", "fpmparser", "dcmHelper", " dpmLanguage", "dmcParser", "dbmPolicy", "dcrReader", "dmcPar", " dpmParser", "dmissionReader", "dCMHandler", " dcmparser", "dmissionPlugin", "dmPlugin", "dmmparser", "dCMParser", "dpmHandler", "dbmHelper", "dpmReader", "dpmInstallation", " dcrLoader", "dbmPlugin", " dpmarser", "dmmLoader", "dhemJar", "dmoduleparser", "DcmReader", " dcrParser", " dpmJar", "dcmPolicy", "DcmInstallation", "dhemInstallation", "dmcJar", " dpmPolicy", "dpmparser", " dpmHelper", "dmissionLanguage", "dcmPar", " dpmparser", "dcmReader", "dpmPar", "fpmHandler", "dmodulePlugin", "dkmPlugin", "dbmParser", "dcmparser", " dcmPar", "dkmPolicy", "dmoduleParser", "dcrPlugin", "fcmParser", "dCMPlugin", "dmoduleJar", "dmcarser", "dcmPlugin", "dmoduleReader", " dcmPolicy", "DcmJar", "dcrParser", " dpmPlugin", "dCMLoader", " dcrReader", "DcmParser", " dcmLanguage", "dpmJar", "dmissionParser", "dhemParser", "dcmarser", " dcmJar", "dcmInstallation", "dpmParser", "dCMparser", "dmmPlugin", "dcrLoader", "dcrarser", "fpmReader", " dpmPar", "dcrJar", "dpmLoader", " dpmLoader", "dmLoader", "dmmParser", " dpmReader", "dcmJar", "fcmReader", "dhemReader", "dkmHelper", "fcmparser", "dpmarser", "dpmHelper", "dpmPolicy", " dcmLoader", "dcmHandler", "dcmLanguage", "dmReader", " dcmReader"], "ds": ["sys", "services", "da", "Os", "ins", "Ds", "ays", "eps", "xs", "ts", "ils", "db", "vs", "tx", "ws", "nas", "ads", "df", "session", "ns", "ks", "asi", "ls", "s", "conn", "iss", "os", "dd", "Db", "gd", "des", "ys", "dat", "js", "cs", "vals", "drivers", "cdn", "ps", "sync", "pd", "dc", "parts", "uds", "ants", "dt", "dr", "di", "dds", "data", "is", "ld", "qs", "amps", "DS", "d", "src", "icks", "details", "utils", "points", "ss", "bs", "ros", "tes", "rs", "gs", "ras"], "pdReader": ["pcRead", "pcLoader", "dsreader", "hdWriter", "xdReader", "xdRead", "hdRunner", "hdStream", "pcWriter", "hdRead", "ddStream", "dsLoader", "pbRunner", "pcReader", "dsReader", "dsRead", "hdreader", "pbLoader", "hdLoader", "ddRunner", "pdLoader", "pbStream", "pdStream", "pdreader", "pdRunner", "dsWriter", "pbReader", "hdReader", "xdreader", "pdRead", "xdWriter", "ddReader", "ddLoader"], "out": ["external", "outs", "cache", "gen", "inc", "model", "session", "conn", "name", "doc", "ssl", "writer", "at", "null", "with", "data", "file", "full", "group", "part", "as", "client", "child", "term", "db", "dot", "s", "ext", "word", "to", "lock", "write", "down", "Out", "user", "object", "o", "her", "key", "store", "page", "in", "cli", "password", "device", "later", "net", "result", "base", "OUT", "w", "login", "io", "auto", "obj", "inner", "err", "lib", "code", "layer", "again", "parent", "over", "oder", "list", "outer", "copy", "director", "temp", "exec", "flow", "sys", "url", "img", "builder", "output", "exp", "default", "image", "order", "connection", "ex", " in", "co", "sync", "diff", "array", "point", "line", "up", "pass", "dev", "manager"], "dcmEncParam": ["dcmElType", "dcmEnParam", "dcmEstType", "dcmEstPar", "dcmDecPart", "dcmDecParameter", "dcmArchParameter", "dcmEnArg", "dcmEncArg", "dcmElPar", "dcmEncParameter", "dcmDecType", "dcmSecType", "dcmEncPart", "dcmDecParam", "dcmEnType", "dcmSecPart", "dcmEncType", "dcmArchParam", "dcmSecPar", "dcmEnPart", "dcmSecParam", "dcmDecArg", "dcmEnPar", "dcmEstParam", "dcmElParameter", "dcmElParam", "dcmEstParameter", "dcmDecPar", "dcmEnParameter", "dcmArchArg", "dcmEncPar"], "pdWriter": ["PDWrite", "dpWrite", "hdWriter", "htReader", "ddWrite", "dpReader", "pdWriting", "dsOutput", "dsReader", "dpWriter", "hdWrite", "PDWriter", "dpWriting", "PDReader", "htWriting", "dsWriter", "hdReader", "htWrite", "htWriter", "PDWriting", "ddWriter", "ddOutput", "hdOutput", "pdOutput", "dsWrite", "ddReader", "pdWrite"]}}
{"id1": "8132219", "id2": "9727056", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    @Override\n    public OBJModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        OBJModel model = loadModel(url.openStream(), skin);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyStream", "copyFiles", "transferfile", "CopyFile", "CopyFiles", "transferFiles", "CopyStream", " copyfile", "transferStream", "Copyfile", "copyStream", "transferFile", "copyfile", " copyFiles"], "inFile": ["InFilename", "Infile", "binfile", "inputFile", "InFile", "INfile", "InSourceFile", "INSourceFile", "infile", "binPlace", "inputFiles", "inPlace", " infile", "binFiles", " inFilename", "inputPlace", "outfile", "outPlace", "inFilename", " inSourceFile", "binFile", "inFiles", "outFiles", "inSourceFile", "INFile", "inputfile", "INFilename"], "outFile": ["againFilename", " outFilename", "againPlace", "outputFilename", " outfile", "infile", " outPlace", "outputPlace", "outputFiles", "outputfile", " outFiles", "outfile", "againfile", "outPlace", "inFilename", "inFiles", "outFiles", "outFilename", "againFile", "outputFile"], "in": ["url", "base", "ins", "reader", "din", "IN", "bin", "id", "io", "inc", "x", "ini", "index", "input", "ic", "In", "name", "inner", "image", "c", "like", "m", "a", "i", "connection", "n", "again", "config", "inn", "pin", "is", "data", "source", "file", "work", "rin", "part", "as", "f"], "out": ["exec", "external", "v", "OUT", "client", "outs", "cache", "w", "call", "output", "bin", "io", "x", "log", "default", "conn", "name", "ext", "string", "dot", "obj", "to", "image", "write", "c", "prefix", "Out", "plain", "writer", "user", "b", "null", "n", "ex", "o", "buffer", "version", "resource", "p", "copy", "line", "data", "file", "part", "Output"], "inChannel": ["inputChan", " inchannel", "sinFlow", "inChan", " inSocket", "iniStream", " inConnection", "sinChan", "outChan", "winStream", "inchannel", "outchannel", "INFlow", "inichannel", "outStream", "inSocket", "inputStream", "inputchannel", "winLanguage", "outConnection", "winchannel", "INChan", "INSocket", "INchannel", "winChannel", "INChannel", "inStream", "sinChannel", "iniLanguage", "outLanguage", " inChan", "iniChannel", "INStream", "sinSocket", " inFlow", "inConnection", "INConnection", "inFlow", "inputChannel", "inLanguage"], "outChannel": ["againChannel", "Outchannel", "outputChan", "outContext", " outConnection", "inChan", "OutStream", " outChan", "outputchannel", "againchannel", "newContext", "outChan", " outContext", "OutConnection", "inchannel", "outchannel", "outputChannel", "outStream", "outConnection", "againChan", " outStream", "newChannel", "againPath", "OutContext", "inConnection", "newStream", " outchannel", "outPath", "OutChan", "newChan", "OutChannel", "inPath", " outPath"]}}
{"id1": "9275622", "id2": "2642914", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private static void addFileToTarGz(TarArchiveOutputStream taro, String path, String base) throws IOException {\n        File f = new File(path);\n        String entryName = base + f.getName();\n        FileInputStream goIn = new FileInputStream(f);\n        TarArchiveEntry tarEntry = new TarArchiveEntry(f, entryName);\n        taro.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        taro.putArchiveEntry(tarEntry);\n        if (f.isFile()) {\n            IOUtils.copy(goIn, taro);\n            taro.closeArchiveEntry();\n        } else {\n            taro.closeArchiveEntry();\n            File[] children = f.listFiles();\n            if (children != null) {\n                for (File child : children) {\n                    addFileToTarGz(taro, child.getAbsolutePath(), entryName + \"/\");\n                }\n            }\n        }\n        taro.close();\n        goIn.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferfile", "copyFolder", "movefile", " copyFolder", "moveFolder", "transferFolder", "transferFiles", "moveFiles", " copyfile", "moveFile", "transferFile", "copyfile", " copyFiles"], "_file1": ["_fileone", "_files01", "_files2", "_zipOne", "_zipFirst", "_File0", "_mail1", "_mail01", "_fileFirst", "_resourceOne", "_resourceone", "_fFirst", "_files0", "_fOne", "_fone", "_files1", "_File2", "_zipone", "_f1", "_mail2", "_File1", "_file01", "_mail0", "_resource1", "_File01", "_file0", "_resourceFirst", "_fileOne", "_zip1"], "_file2": [" _files4", "_play4", "_Filesecond", " _fileTwo", "_files2", "_playsecond", "_files4", "_file3", "_files3", "jmodel2", "_modelsecond", "_file5", "_play3", " _file4", "_play5", " _file3", " _filesTwo", "jfile5", "_File5", "jfile1", "jmodelsecond", " _files3", "_play1", " _files2", "_model2", "_File2", "_play2", "_fileTwo", "_File1", "_filesTwo", "_file4", "jfilesecond", "_model1", "_filesecond", "jmodel1", "jmodel5", "_playTwo", "_model5", "jfile2"], "fis": [" fiss", "fais", "cfis", "fris", "cfas", " fais", "lfais", "infis", "lfi", " fi", "Fris", "infiss", " fas", "Fos", "infils", "fils", "Fis", "fas", " fils", "afis", "cfiss", "afi", "lfis", "Fiss", "Fils", "lfiss", "Fas", "fiss", "afiss", "fi", "cfos", "cfris", "afais", "infos", " fris"], "fos": ["foes", "Fo", "feus", "infus", "gus", "fus", "gos", "infios", "Fros", "flis", "poes", "fOS", "feis", "Foos", "feos", " foos", "Fus", "Foses", " faos", "feoses", "Fos", "Fis", "fros", " fo", "infoos", "fios", "pis", "lOS", "info", "Fios", "infaos", "flOS", "floes", "lis", " fus", " fios", "infos", "goses", "los", "loes", "fo", "pOS", "infros", "gis", "flos", "foses", "pos", " fros", "faos", "Faos", "foos"], "canalFuente": ["canalFUente", "canaledFuze", "canalFuento", "canallBuence", "canallFuencia", "canalsBuencia", "canalFuze", "canaledBuze", "canaledBuente", "canallFuze", "canalSuestro", "canalFuence", "canalBuence", "canalFUze", "canalKuente", "canalKuento", "canalsBuence", "canalFUencia", "canalFuestro", "canallBuencia", "canalsBuento", "canalKuence", "canaledFuje", "canalFUestro", "canalCraencia", "canalBuze", "canaledFuestro", "canallFuence", "canalSuze", "canalsFuence", "canalFUje", "canaledFuente", "canalsFuencia", "canalBuje", "canalCraente", "canalBuento", "canalSuje", "canalsFuente", "canalBuente", "canalsFuento", "canaledBuje", "canalFuencia", "canalCraence", "canalKuencia", "canalCraento", "canallBuze", "canalKuze", "canallBuente", "canalBuestro", "canaledBuestro", "canalBuencia", "canallFuente", "canalFUence", "canalFuje", "canalSuente", "canalsBuente"]}}
{"id1": "21010945", "id2": "16825994", "code1": "    private static List runITQLQuery(String itqlQuery) throws Exception {\n        String escapedItqlQuery = URLEncoder.encode(itqlQuery, \"UTF-8\");\n        String url = \"http://\" + Config.getProperty(\"FEDORA_SOAP_HOST\") + \":\" + Config.getProperty(\"FEDORA_SOAP_ACCESS_PORT\") + \"/fedora/risearch?type=tuples\" + \"&lang=iTQL\" + \"&format=CSV\" + \"&distinct=on\" + \"&stream=on\" + \"&query=\" + escapedItqlQuery;\n        logger.debug(\"url for risearch query: \" + url);\n        URL urlObject = new URL(url);\n        HttpURLConnection con = (HttpURLConnection) urlObject.openConnection();\n        BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        logger.debug(\"response code: \" + con.getResponseCode());\n        if (con.getResponseCode() != 200 && con.getResponseCode() != 302) {\n            throw new FedoraAccessException(\"Could not access the risearch service at url: \" + url);\n        }\n        ArrayList arrayList = new ArrayList();\n        String inputLine;\n        int counter = 0;\n        while ((inputLine = br.readLine()) != null) {\n            logger.debug(\"reading line:\" + inputLine);\n            if (inputLine.indexOf(\"<html>\") >= 0) {\n                logger.error(\"problem quering the relationship\");\n                throw new Exception(\"Problem querying relationships; probably a bad ITQL query:\" + itqlQuery);\n            }\n            if (counter >= 1 && inputLine.indexOf(\"/\") >= 0 && inputLine.trim().length() > 0) {\n                logger.debug(\"adding line:\" + inputLine);\n                inputLine = inputLine.substring(inputLine.indexOf(\"/\") + 1);\n                arrayList.add(inputLine);\n                logger.debug(\"found relationship to item: \" + inputLine);\n            }\n            counter++;\n        }\n        br.close();\n        logger.debug(\"num relationships found: \" + arrayList.size());\n        return arrayList;\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"runITQLQuery": ["runITqlQuery", "runItqlQuery", "runITqlRequest", "runITQquery", "runItqlRequest", "runITSQLRequest", "runITQQuery", "runITSQLQuery", "runITQString", "runITqlString", "runItQLString", "runITQRequest", "runITSQLString", "runItqlString", "runITQLRequest", "runItQLquery", "runItQLRequest", "runITSQLquery", "runItqlquery", "runITqlquery", "runITQLString", "runItQLQuery", "runITQLquery"], "itqlQuery": ["pitqlString", "pitqlQuery", "ItsqlStatement", "ItsqlRequest", "itqlStatement", "itqlString", "pitSQLquery", "ItqlCommand", "itSQLquery", "itqlCommand", "itSQLQu", "ItsqlQuery", "itsqlRequest", "itQLStatement", "itQLquery", "itwlCommand", "ItqlQuery", "itQLQu", "itqlquery", "itQLQuery", "pitSQLString", "itqlQu", "ItqlRequest", "itsqlStatement", "pitqlquery", "itwlRequest", "itSQLStatement", "itwlquery", "ItsqlCommand", "Itqlquery", "itQLString", "Itsqlquery", "itsqlCommand", "ItsqlString", "itQLCommand", "itqlRequest", "itsqlquery", "itsqlString", "pitSQLQu", "ItqlString", "itQLRequest", "itSQLString", "pitqlQu", "itsqlQu", "pitSQLQuery", "ItqlStatement", "itSQLQuery", "itwlQuery", "itsqlQuery"], "escapedItqlQuery": ["escapedItqQuery", "escapedItqString", "escapedItqlRequest", "escapedITqlQuery", "escapeditqlRequest", "escapedItsqlQuery", "escapedITsqlRequest", "escapedItqlString", "escapeditQLquery", "escapedItQLQu", "escapedItsqlQu", "escapedItqRequest", "escapeditqlquery", "escapedItsqlRequest", "escapeditqlQuery", "escapeditQLRequest", "escapeditqlString", "escapedItsqlString", "escapedItQLQuery", "escapedITsqlQu", "escapedItQLquery", "escapedITsqlQuery", "escapedITqlQu", "escapedItqlQu", "escapedItqQu", "escapeditQLString", "escapedItQLString", "escapedITqlRequest", "escapedItsqlquery", "escapedITsqlquery", "escapedItqlquery", "escapedITqlquery", "escapeditQLQuery", "escapedItQLRequest", "escapedItqquery"], "url": ["rule", "image", "method", "html", "URL", "service", "resource", "base", "email", "lr", "www", "feed", "impl", "q", "coll", "download", "Url", "pattern", "obj", "http", "href", "l", "page", "string", " URL", "route", "buffer", "path", "large", "org", "uri", "build", "response", "xml", "ur", "name", "location", "ssl", "request", "loc", "server", "id", "file", "ll", "lc", "el", "sl", "rl", "connection", "config", "host", "f", "address"], "urlObject": ["urlObj", " urlOb", " urlNumber", "urlNumber", "URLobject", "urlobject", "UrlNumber", " urlObj", "httpURL", "UrlObj", "urlURL", "UrlOb", "UrlObject", "Urlobject", " urlobject", "httpNumber", "httpObj", "UrlURL", "urlOb", " urlURL", "URLObject", "httpObject", "URLOb"], "con": ["enc", "dec", "ver", "conv", "sub", "func", "can", "fac", "syn", "coll", "inner", "cl", "cons", "nc", "pc", "open", "ctrl", "Connection", " conn", "fc", "http", "exec", "ch", "conn", "un", " CON", "CON", "ran", "c", "cf", "ct", "rc", "core", "en", "part", "min", "xc", "client", "Con", "close", "cm", "co", " connection", "bn", "acon", "cn", "ec", "ocon", "connect", "Conn", "res", "bc", "Connect", "connection", "uc", "inc", "cr", "conf", "obj", "non"], "br": ["err", "ver", "dr", "lr", "fr", " reader", "fac", "stream", "form", "bl", "arr", "fin", "http", "cro", "output", "bridge", "ch", "b", "ctr", "conn", "buf", "r", "buffer", "gr", "rc", "tr", "bro", "er", "p", "result", "io", "Br", "BR", "mr", "response", "hr", "cm", "bar", "sr", "runner", "fore", "data", "ob", "browser", "str", "Reader", "reader", "rb", "res", "bc", "bh", "grab", "cr", "obj"], "arrayList": ["inputArray", "arrayClient", "areaList", "elementTree", "arrayTree", "inputGroup", "inputList", "areaChain", "elementChain", "areaClient", "arrayChain", " arrayClient", "inputClient", " arrayTree", "elementArray", "arrayGroup", " arrayGroup", "areaTree", " arrayArray", "arrayArray", " arrayChain", "elementList", "areaArray", "areaGroup"], "inputLine": ["outputPage", "Inputline", "InputPage", "currentFile", "imageLine", "issueLINE", "imageLINE", "InputFile", "outputline", "inL", "workFile", " inputPage", "InputLu", "interfaceLu", "rawL", "inputString", "inputL", "inputLINE", "workLine", "interfaceFile", " inputList", "inLine", " inputString", "qaL", "InputLine", "inputLetter", "interfaceLine", "uploadline", "qaFile", "inline", "inFile", "qaLine", "InputL", "uploadLine", "imageLin", "imageBlock", "imageList", "outputLine", "currentline", "inputBlock", "imageL", "issueList", "interfaceline", "currentL", "workline", "inputDir", "inputLu", " inputLu", " inputLINE", "inputline", "inputLin", "qaLetter", "inputFile", "inputPage", " inputFile", "InputDir", "uploadPage", "rawLin", "outputLin", "inputList", "issueBlock", " inputDir", " inputL", "imageDir", "InputBlock", " inputLin", "InputLetter", "currentBlock", "rawLine", " inputline", " inputBlock", " inputLetter", "currentString", "InputString", "rawBlock", "rawPage", "rawline", "currentLine", "imageline", "uploadLin", "issueLine"], "counter": ["lc", "num", "repeat", "index", "ver", "field", "child", "outer", "offset", "continue", "inner", "stop", "step", "function", "pattern", "cur", "entry", "inter", "ctrl", "count", "cre", "cache", "stack", "key", "info", "ctr", "race", "page", "code", "c", "handler", "rew", "type", "Counter", "result", "cmp", "currency", "number", "nr", "loop", "controller", "loader", "trace", "name", "sum", "ter", "server", "instance", "second", "i", "center", "default", "time", "parent", "cover", "processor"]}}
{"id1": "11562173", "id2": "16572931", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "label": 1, "substitutes": {"checkInputStream": [" checkOutputstream", "checkInputstream", "checkOutputChannel", " checkInputSteam", "checkFilestream", "checkIOStream", " checkOutputSteam", "checkInputSteam", " checkOutputStream", "checkIOChannel", " checkInputChannel", "checkFileSteam", "checkOutputstream", "checkFileStream", "checkIOstream", "checkOutputSteam", "checkInputChannel", "checkFileChannel", "checkIOSteam", "checkOutputStream", " checkInputstream", " checkOutputChannel"], "in": ["In", "plus", "again", "ini", "c", "IN", "is", "din", "inner", "bin", "input", "ic", "as", "con", "io", "ins", "min", "inn", "ack", "into", "p", "up", "isin", "connection", "x", "index", "comp", "image", "login", "reader", "data", "inc", "source", "src"], "cmp": ["mp", "ctrl", "pc", "ch", "cop", "cho", "mom", "c", "cache", "op", "spec", "cpp", "pixel", "comment", "conv", "ci", "ctx", "prev", "np", "match", "co", "omp", "loc", "sup", "p", "cc", "up", "proc", "amp", "rc", "asc", "cp", "prefix", "coll", "config", "cs", "cup", "index", "comp", "code", "pre", "upp", "cb", "fp", "diff", "clip", "sort", "roc", "com", "lc"], "all": ["local", "each", "ALL", "not", "global", "full", "and", "call", "total", "ann", "sum", "partial", "match", "none", "list", "only", "process", "p", "alpha", "valid", "cl", "default", "l", "except", "asc", "coll", "array", "best", "am", "allow", "any", "auto", "a", "both", "al", "acl", "null", "All", "always", "parent", "one"], "stream": ["track", "temp", "speed", "string", "channel", "instance", "host", "context", "src", "input", "self", "response", "transform", "platform", "feed", "this", "impl", "progress", "object", "user", "ack", "roll", "iterator", "trans", "up", "steam", "document", "sw", "Stream", "model", "port", "coll", "per", "pool", "comp", "wrapper", "socket", "result", "v", "test", "output", "reader", "raw", "null", "stack", "source", "client", "cont", "form", "round", "ream"], "out": ["not", "again", "project", "full", "c", "o", "exp", "option", "comment", "bin", "Out", "response", "sum", "copy", "outer", "io", "outs", "list", "this", "sync", "user", "p", "up", "part", "prefix", "x", "array", "index", "other", "image", "v", "result", "output", "data", "obj", "OUT", "null", "point", "b", "inc", "parent", "block", "name", "extra"], "i": ["hi", "si", "qi", "u", "multi", "n", "ii", "c", "k", "pi", "ini", "d", "abi", "ci", "di", "io", "key", "slice", "ji", "ui", "ri", "bi", "p", "it", "l", "strength", "init", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "ind", "start", "h", "v", "gi", "ti", "type", "ai", "mi", "r", "b", "xi", "id", "info", "uri", "ix", "lc", "end"]}}
{"id1": "20939940", "id2": "12766394", "code1": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 0, "substitutes": {"createJavaProject": ["getjavaProject", "createJavaFolder", "createRubyFolder", "createjavaProject", "createJavaConnector", "getJavaApplication", "getjavaApplication", "getJavaConnector", "createjavaApplication", "getJavaProject", "createjavaConnector", "createJSConnector", "createJSProject", "getJavaFolder", "createRubyApplication", "createJSFolder", "createJavaApplication", "getjavaConnector", "createRubyConnector", "createJSApplication", "createRubyProject", "getjavaFolder", "createjavaFolder"], "proj": ["prod", "pez", "projs", "promj", "parb", "perJ", "cojo", "sujo", "projo", "upj", "rouj", "suuj", "promjo", "parj", "propjet", "perject", "profject", "perj", "pejp", "produz", "profjs", " projs", "conj", "produj", "pejo", "suk", "conjc", " project", "parjet", "cobj", "Prok", "promjp", "upJ", "Proz", "pej", " projet", "PROz", "peJ", "produjet", "propje", "probj", "Projp", "produjo", "PROjp", "prouj", " prob", " projo", "Projc", "project", "proJ", "produjp", "coj", "suz", "preuj", " prod", " projp", "Proj", "Proaj", " proJ", "ProJ", "Prouj", "produjs", "profJ", " prouj", " probj", "prejo", " prok", "sujet", "produb", "promz", "coJ", "Projs", " projc", "Prod", "proz", "proje", "parjc", "roujc", "profj", "rouJ", "propj", "prez", "perjp", "propjo", "suj", " proz", "Projo", "conJ", "projet", "perjs", "PROj", "suje", "perz", "projc", " proaj", " proje", "prob", "upjo", "prok", "produjc", "PROJ", "projp", "produJ", "proaj", "produuj", "conjp", "upbj", "rouaj", "prej", "roujs", "roud"], "desc": ["doc", "loc", "name", "sup", "sc", "dev", "ca", "info", "dec", "dep", "div", "str", "rc", "rec", "summary", "description", "text", "contract", "txt", "dist", "esc", "dc", "comment", "sub", "anc", "asc", "struct", "sec", "attr", "Description", "config", " description", "details", "neg", "id", "des", "obj", "out", "def", "pro", "Desc", "de"], "javaProject": [" javaPlugin", "jaModule", "jarProject", " javaFolder", " javaUnit", "jarServer", "pythonModule", "pythonServer", "nativeFolder", "nativeApp", "JavaUnit", "JavaApp", "jaFolder", "JavaFolder", "jarFolder", " javaModule", " javaApp", "jaUnit", "pythonProject", "pythonFolder", "javaFolder", "javaServer", "nativeProject", " javaServer", "javaUnit", "rubyFolder", "jaProject", "javaPlugin", "JavaPlugin", "rubyProject", "JavaProject", "jarModule", "javaApp", "JavaModule", "rubyApp", "rubyUnit", "javaModule", "nativePlugin"], "srcFolder1": ["rcFolder2", "rcFolder0", "rcFolderOne", "rcDirectory1", "rcFolder81", "srcPath2", "rcFolder1", "srcFolderOne", "srcfolder2", "srcLocation1", "srcPath1", "rcDirectoryOne", "rcDirectory2", "srcfolder0", "srcFile2", "srcLocation0", "srcPathOne", "srcDirectory0", "srcPath0", "srcFolder0", "srcfolderOne", "srcFile81", "srcDirectory1", "srcLocation2", "srcDirectory2", "srcFolder81", "rcDirectory0", "srcfolder81", "srcDirectoryOne", "srcFileOne", "srcfolder1", "srcFile1", "srcDirectory81", "rcDirectory81"], "srcFolder2": ["rcFolder2", " srcfolder1", "rcDirectory1", "rcFolder1", "srcArea4", "srcfolder2", "srcFolder4", "srcDirectory4", "rcDirectoryTwo", "srcFile5", "rcDirectory2", "srcFolder5", "srcArea1", "srcAreaTwo", "srcfolderTwo", "srcfolder5", "srcFile2", "srcDirectoryTwo", "srcArea2", " srcfolderTwo", "rcDirectory5", " srcFolder4", "rcDirectory4", "srcDirectory1", " srcfolder2", " srcfolder4", "rcFolder4", "srcDirectory2", " srcFolderTwo", "srcFileTwo", "srcFolderTwo", "rcFolder5", "rcFolderTwo", "srcfolder4", "srcfolder1", "srcFile1", "srcDirectory5"], "classpathEntries": ["classpathAddries", "classPathAddry", "classpathEntEntry", "classPathAddEntry", "classpathEnrs", "classpathEnories", "classpathentry", "classpathEntryrys", "classPathAddrys", "classpathEntories", "classnameEntrys", "classpathentEntry", "classPathEntries", "classpathAddrys", "classpathEntryry", "classnameEnrys", "classpathEnries", "classpathentrs", "classnameEnrs", "classpathAddEntry", "classpathEntryries", "classPathAddries", "classnameEntries", "classpathEntryrs", "classPathEntEntry", "classnameEntrs", "classpathentries", "classPathEntry", "classpathEnrys", "classpathEntry", "classnameEnries", "classpathAddry", "classPathEntrys", "classnameEntories", "classpathEntryEntry", "classnameEnories", "classpathEntrs", "classpathentrys", "classpathEntryories", "classpathentories", "classpathEntrys"], "binFolder": ["winUrl", "workDir", "resultLoop", "binfolder", "winDirectory", "baseProject", " binLoop", "winfolder", "binDir", "workProject", "baseLoader", "workfolder", "binDirectory", "binaryUrl", "binaryProject", "baseFolder", "binaryFolder", " binLoader", "binaryDir", "binLoop", "resultUrl", "baseDir", " binfolder", "resultfolder", "binaryDirectory", "binLoader", " binDirectory", "workFolder", "binaryLoop", "binProject", "winFolder", "basefolder", " binUrl", "binaryLoader", "binUrl", "binaryfolder"], "testFolder": [" testfolder", "testfolder", "matchFolder", "mainfolder", "matchPath", "resultLoop", "mainFolder", " testLoop", "mainLoop", "matchOrg", "resultDirectory", " testOrg", "resultPath", "resultOrg", "mainDirectory", " testDirectory", "resultfolder", " testPath", "testPath", "testOrg", "testLoop", "testDirectory"], "resultFolder": ["returnLayer", "testfolder", "resultSection", "ResultDirectory", "resultDirectory", "returnFolder", "messageLayer", "returnPath", "testingSection", "resultPath", "messageFolder", "messagePath", "ResultLayer", " resultSection", "testingfolder", "testingFolder", "resultfolder", "ResultFolder", "testSection", "returnDirectory", " resultLayer", "resultLayer", "ResultPath", "testingLayer", "testLayer", " resultfolder", "messageDirectory"]}}
{"id1": "9647576", "id2": "8079516", "code1": "    private void Reserve() throws SQLException {\n        Statement stbookings, stchartwl;\n        String sp = \"\";\n        if (useragent) sp = \"agent\"; else sp = \"user\";\n        String userbooksql = \"\";\n        String agentbooksql = \"\";\n        String bookingid = String.valueOf(System.currentTimeMillis());\n        String currentcoach;\n        String currentseat;\n        try {\n            if (useragent) {\n                agentbooksql = \"update hp_administrator.agent_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                agentbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            } else if (!useragent) {\n                userbooksql = \"update hp_administrator.user_bookings set BOOKINGS = xmlquery('copy $new := $BOOKINGS modify do insert \";\n                userbooksql += \" <detail booking_id=\\\"\" + booking_details.getTicketno() + \"\\\" status=\\\"open\\\" train_no=\\\"\" + booking_details.getTrain_no() + \"\\\" source=\\\"\" + booking_details.getSource() + \"\\\" dest=\\\"\" + booking_details.getDestination() + \"\\\" dep_date=\\\"\" + booking_details.getDate() + \"\\\" > \";\n            }\n            for (int tickpos = 0; tickpos < booking_details.getNoOfPersons(); tickpos++) {\n                currentcoach = coach.get(tickpos);\n                currentseat = seatno.get(tickpos);\n                if (!currentcoach.equals(\"WL\")) {\n                    String chartavailupdsql = \"update hp_administrator.chart_wl_order set AVAILABLE_BOOKED = xmlquery('copy $new := $AVAILABLE_BOOKED   modify do insert \";\n                    chartavailupdsql += \"<seat number=\\\"\" + currentseat + \"\\\"><details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\"  /></seat>\";\n                    chartavailupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"]/coach[@number=\\\"\" + currentcoach + \"\\\"] \";\n                    chartavailupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartavailupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartavailupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  availability  updated\");\n                } else if (currentcoach.equals(\"WL\")) {\n                    String chartwlupdsql = \"update hp_administrator.chart_wl_order set WAITLISTING = xmlquery('copy $new := $WAITLISTING modify do insert \";\n                    chartwlupdsql += \"<details user_id=\\\"\" + booking_details.getUserId() + \"\\\" usertype=\\\"\" + sp + \"\\\" ticket_no=\\\"\" + booking_details.getTicketno() + \"\\\" name=\\\"\" + booking_details.getNameAt(tickpos) + \"\\\" age=\\\"\" + booking_details.getAgeAt(tickpos) + \"\\\" sex=\\\"\" + booking_details.getSexAt(tickpos) + \"\\\" type=\\\"primary\\\" /></seat>\";\n                    chartwlupdsql += \" into $new/status/class[@name=\\\"\" + booking_details.getTclass() + \"\\\"] \";\n                    chartwlupdsql += \" return  $new' ) where train_no like '\" + booking_details.getTrain_no() + \"' and date = '\" + booking_details.getDate() + \"' \";\n                    System.out.println(chartwlupdsql);\n                    stchartwl = conn.createStatement();\n                    int updstat = stchartwl.executeUpdate(chartwlupdsql);\n                    if (updstat > 0) System.out.println(\"chart_wl  waitlisting  updated\");\n                }\n                if (useragent) agentbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\"; else userbooksql += \"<person><coach>\" + currentcoach + \"</coach><seat>\" + currentseat + \"</seat></person>\";\n            }\n            if (useragent) {\n                agentbooksql += \"</detail>   as first into $new/book return  $new' ) where agent_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(agentbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(agentbooksql);\n                if (updstat > 0) System.out.println(\"agent bookings updated\");\n            } else {\n                userbooksql += \"</detail>   as first into $new/book return  $new' ) where user_id like '\" + booking_details.getUserId() + \"'\";\n                System.out.println(userbooksql);\n                stbookings = conn.createStatement();\n                int updstat = stbookings.executeUpdate(userbooksql);\n                if (updstat > 0) System.out.println(\"user bookings  updated\");\n            }\n        } catch (SQLException e) {\n            conn.rollback();\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"Reserve": ["Rolve", "Resolve", " Resolve", "Rerve", "Send", "Rend", "Resend", "Rerves", "Serve", "Reserves", " Resend", "Serves", "Solve", " Reserves"], "stbookings": ["stbookies", "ssbooksings", "stbooksifications", "ssbookalls", "stbooksalls", "ssbookifications", "ssbooksalls", "stBookifications", "stbookalls", "stBookies", "stbookifications", "ssbooksifications", "stbooksies", "stbooksings", "stauthories", "ssbookies", "stauthorifications", "stauthoralls", "ssbookings", "stBookalls", "stBookings", "stauthorings", "ssbooksies"], "stchartwl": ["STconfigwl", "stplotml", "stchartml", "stplotls", "STchartwl", "stchartowl", "stchartls", "stplotwl", "stconfigls", "st_ls", "st_wl", "STchartls", "stconfigowl", "STconfigowl", "STchartowl", "stplotowl", "st_ml", "stconfigml", "stconfigwl", "STconfigls", "STchartml", "st_owl", "STconfigml"], "sp": ["jp", "ip", "arp", "amp", "tp", "sf", "scope", "str", "ap", "bp", "pace", "spr", "xml", "space", "sl", "session", "name", "profile", "bsp", "pl", "si", "yp", "sg", "rap", "ipp", "type", "sk", "Sp", "html", "span", "text", " Sp", "ps", "ig", "inst", "service", "p", " sc", "isp", "page", "source", "op", "sc", "sil", "email", "osp", " esp", "script", "pp", "spe", "SP", "esp", "spl", "ss", "mp", "pr", " SP"], "userbooksql": ["userlocksQL", "userreadskel", " useraveskel", "usersbooksearch", "userbooksil", "otherbookql", "otherbooksqs", "userbooksearch", "usersbookQL", " useraveskl", "userbookQL", "userbooksprintf", "usersbookql", "userbookskel", "userbanksil", "userbookssql", "userbookskl", "userlocksprintf", "userordersqs", "otherbooksql", " userbookskel", "userordersQL", "otherbookssql", "userreadsQL", "userbookql", "usersbookearch", "userreadsil", "userbooksQL", "otherbooksQL", "usersbooksql", "usersbooksprintf", "userreadsql", "useravesql", "userreadsearch", "userpagesQL", "userreadskl", "otherbookQL", " userbookskl", " userbooksil", "userbookearch", "userlocksearch", "userordersql", "usersbookprintf", "userbanksql", "userbankskel", "userreadsprintf", "userpagesqs", " useravesil", "useraveskel", "useraveskl", "userpagesql", "userpagessql", "userlocksql", "userbookprintf", "usersbooksQL", "userorderssql", "userbankskl", "userbooksqs", "useravesil", "userbookqs", " useravesql", "otherbookqs"], "agentbooksql": ["userbooksil", "agentbooksil", "agentstylesql", "agentstylesil", "agentstylesqu", "agentstylessql", "agentbooksci", "userbookssql", "userbooksli", "userpagesli", "agentBookssql", "agentbookQL", "agentpagesci", "agentbooksli", "agentpagesQL", "agentgroupsli", "agentgroupsQL", "agentbooksQL", "agentgroupssql", "agentpluginsci", "userbooksQL", "agentpagesli", "agentpluginsQL", "userpagesQL", "agentBooksqu", "userbooksqu", "agentbooksqu", "agentgroupsql", "agentBooksil", "agentpagesql", "userbooksci", "agentBooksql", "agentpagessql", "agentbookssql", "userpagesql", "userpagessql", "userpagesci", "agentbookli", "agentpluginssql", "agentbookql", "agentpluginsql"], "bookingid": ["bookingurl", "bookingsinfo", "bookillingid", "bookinginfo", "bookINGurl", "bookillingurl", "bookingname", "bookillinginfo", "bookingsname", "booksingsname", "bookINGname", "booksingsid", "booksinginfo", "booksingurl", "bookINGid", "booksingsinfo", "bookillingname", "booksingname", "bookINGinfo", "bookingsurl", "booksingid", "booksingsurl", "bookingsid"], "currentcoach": ["currentlypoach", "currentloache", " currentcoache", " currentcoac", " currentpoach", "currentpoaching", "currentCOach", "currentchoase", "currentloach", "currentgoaching", "currentlycoach", "currentgoac", "currentcoached", "currentnoache", "currentcoaching", "currentlycoache", " currentpoac", "currentnoach", " currentloache", "currentlypoaching", " currentcoase", "currentpoache", "currentboach", "currentcoache", "currentpoached", "currentgoach", "currentpoac", "currentCOase", "currentpoach", "currentgoache", "currentlypoac", "currentcoam", "currentboache", "currentchoach", "currentpoase", "currentloached", "currentpoam", " currentpoase", "currentlycoac", "currentpoah", " currentcoam", " currentloach", "currentcoase", "currentcoah", " currentpoam", "currentboached", "currentlypoache", "currentCOac", "currentnoac", "currentchoam", "currentboah", "currentchoac", " currentloached", "currentloah", " currentcoah", "currentnoaching", "currentcoac", "currentlycoaching", " currentcoached", " currentloah", "currentCOam"], "currentseat": ["currentlyslave", "Currentseason", " currentcourse", "currentticket", "currentslave", "Currentseat", "Currentcourse", "activecourse", " currentslave", " currentsex", "currentlysex", "activeticket", "activecomponent", "Currentsex", "currentlyseason", "currentseason", "Currentslave", "currentlyseat", "Currentticket", "currentsex", "Currentcomponent", "currentcourse", "activeseat", "currentcomponent", " currentcomponent", " currentticket", " currentseason"], "tickpos": ["ickpointer", "hellopointer", "hellopos", " tickPOS", "stickpos", "ickposition", "ickPOS", " tickPos", "ickPos", "ickpo", "trialPos", "tickpose", "helloposition", "crosspos", "trialPOS", "helloPOS", "tickposition", "crossPos", " tickpo", "crosspo", " tickposition", "helloPos", "trialpose", "ickerPos", "ickerpos", "ickpose", "ickerpointer", " tickpose", "tickpointer", "stickPos", "ickerposition", "trialpos", "tickPOS", "ickpos", "stickposition", "tickpo", "tickPos"], "chartavailupdsql": ["chartavailupdatesql", "chartavailumpdssql", "chartavailumpssqs", "chartavailupdssql", "chartavailupcsql", "chartavailupdatesqs", "chartavailupcssql", "chartavailupcsqs", "chartavailumpdsql", "chartavailupssqs", "chartavailupsssql", "chartavailumpssql", "chartavailupdsqs", "chartavailupssql", "chartavailumpdsqs", "chartavailupdatessql", "chartavailumpsssql"]}}
{"id1": "8216539", "id2": "23370621", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileContentInStr", "getFileContentasStr", "getFileContentasStream", "getFileContentInString", "getFileContentFromStr", "getFilecontentAsStr", "getFileContentFromText", "getFileContentFromStream", "getFilecontentAsString", "getFileContentasText", "getFileContentAsText", "getFilecontentInStr", "getFileContentFromString", "getFileContentInStream", "getFileContentInText", "getFileContentAsStream", "getFilecontentInString", "getFilecontentAsStream", "getFileContentasString", "getFilecontentInStream", "getFilecontentInText", "getFilecontentAsText", "getFileContentAsStr"], "filePath": ["basePath", "singlePath", "Filepath", "FileStr", "FileUrl", "baseStr", "fileName", "resourcepath", "fileStr", "baseName", "resourcePath", " fileStr", "FilePath", "singleLocation", " fileUrl", "FileName", "singlepath", "fileLocation", "FileLocation", "resourceLocation", "singleUrl", "resourceName", "fileUrl", "basepath", "filepath", "baseLocation", " filepath", "baseUrl"], "encoding": ["decoding", "languageging", "decryption", "Encoding", "encryption", "Enclocking", "encasing", "coded", "encging", "enclocking", "languagelocking", "encoded", "Encging", "encpling", "Encasing", "languageoding", "Encoded", "Encpling", "coding", "Encryption", "languagepling", "equpling", "cryption", "equoding", "decasing", "equging", "decoded", "equlocking", "casing"], "testURL": ["appurl", "testUrl", "testingurl", "testingURL", "shortTL", "shortUrl", "testUR", "appUR", "testingTL", "shorturl", "TestUrl", "testTL", "testingURI", "testingRL", "TestUR", "fileURI", "shortURL", "testingUR", " testUrl", "appURL", " testurl", "testingUrl", "testurl", "fileURL", "appUrl", "fileUrl", "testURI", "fileRL", " testRL", " testURI", "Testurl", "testRL", " testTL", "TestURL"], "input": ["enc", "image", "ou", "flow", "in", "resource", "temp", "raw", "feed", "this", "stream", "current", "ink", "inner", "form", "inf", "dc", "audio", "acl", "Input", "entry", "active", "text", "http", "output", "api", "bin", "conn", "url", "null", "through", "act", "element", "ack", "rc", "path", "op", "type", "upload", "result", "out", "pull", "img", "client", "xml", "but", "init", "ssl", "ac", "inside", "wrapper", "data", "file", "binary", "parent", "qa", "instance", "error", "i", "reader", "get", "connection", "config", "source", "exec", "socket", "inc"], "sw": ["aw", "ib", "wb", "rx", "SW", "stream", "sk", "w", "sa", "WS", "writer", "now", "ow", "ws", "we", "ew", "wt", "wp", "rc", "sn", "wr", "wx", "work", "iw", "rew", "sc", "en", "wrap", "io", "sb", "nw", "sh", "sv", "sm", "fp", "tw", "ww", "wrapper", " SW", "sf", "hw", "Sw", "sl", "rw", "web", "cr"]}}
{"id1": "5399593", "id2": "13414771", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["encipher", "escrypt", "encress", "decryption", "escryption", " encryption", "decipher", " encress", "decrypt", "encryption", " encipher", "escipher", "escress", "decress"], "plaintext": ["forecontent", " plainText", " plaincontent", "plainTEXT", "rainText", "plainform", "singleform", "ainform", "singletext", "foreText", "plainText", " plainform", "singleText", "ainText", "raincontent", "raintext", "singleTEXT", "foretext", "rainTEXT", "aintext", "plaincontent", " plainTEXT", "foreTEXT", "ainTEXT"], "UnsupportedEncodingException": ["UnsupportedEncodingError", "UnsupportedEncryptionException", "UnsupportedCodedException", "UnsupportedEncodingEx", "UnsupportedCodingEx", "UnsupportedCodedEx", "UnsupportedEncgorithmError", "UnsupportedEncodedError", "UnsupportedEncgorithmEx", "UnsupportedEncryptionError", "UnsupportedEncryptionEx", "UnsupportedCodingException", "UnsupportedCodedError", "UnsupportedEncodedException", "UnsupportedEncodedEx", "UnsupportedEncgorithmException", "UnsupportedCodingError"], "md": ["mad", "MD", "map", "sha", "mc", "dig", "ms", "metadata", "rm", "pm", "bd", "amd", "db", "am", "mo", "meta", "mb", "mt", "mage", "cmd", "material", "hd", "code", "mand", "m", "dd", "Cmd", "hed", "od", "mg", "mm", "ma", "message", "dc", "cd", "wd", "mac", "mn", "hm", "mod", "me", "d", "mag", "bf", "nm", "dm", "mem", "sum", "mu", " MD", "mp", "po"], "raw": ["ghost", "sha", "dec", "wrap", "unsigned", "clean", "ng", "flash", "RAW", "sign", "load", "row", "input", "aws", "rew", "original", "missing", "hex", "serial", "Raw", "null", "micro", "unknown", "empty", "buf", "enc", "block", "message", "alpha", "array", "blocks", "buffer", "shared", "instance", "full", "initial", "ack"], "hash": ["url", "base", "sha", "header", "ash", "cache", "rh", "flash", "id", "Hash", "log", "string", "kh", "image", "hex", "hh", "ruby", "ashes", "code", "auth", "build", "html", "text", "hed", "block", "message", "array", "version", "alpha", "key", "mac", "h", "math", "abi", "sh", "data", "password", "secret", "shared", "sum", "ha"]}}
{"id1": "20623709", "id2": "4895903", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    public List load(String sourceType, Object source, String param) throws Exception {\n        if (log.isTraceEnabled()) {\n            log.trace(\"load \" + source);\n        }\n        String location = null;\n        String type = null;\n        Object inputsource = null;\n        if (source instanceof DynamicMBean) {\n            sourceType = \"MbeansDescriptorsDynamicMBeanSource\";\n            inputsource = source;\n        } else if (source instanceof URL) {\n            URL url = (URL) source;\n            location = url.toString();\n            type = param;\n            inputsource = url.openStream();\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof File) {\n            location = ((File) source).getAbsolutePath();\n            inputsource = new FileInputStream((File) source);\n            type = param;\n            if (sourceType == null) {\n                sourceType = sourceTypeFromExt(location);\n            }\n        } else if (source instanceof InputStream) {\n            type = param;\n            inputsource = source;\n        } else if (source instanceof Class) {\n            location = ((Class) source).getName();\n            type = param;\n            inputsource = source;\n            if (sourceType == null) {\n                sourceType = \"MbeansDescriptorsIntrospectionSource\";\n            }\n        }\n        if (sourceType == null) {\n            sourceType = \"MbeansDescriptorsDigesterSource\";\n        }\n        ModelerSource ds = getModelerSource(sourceType);\n        List mbeans = ds.loadDescriptors(this, location, type, inputsource);\n        return mbeans;\n    }\n", "label": 0, "substitutes": {"split": ["exec", "share", "delete", "parse", "Split", "transfer", "sort", "start", "archive", "set", "run", "build", "format", "join", "diff", "sync", "update", "add", "copy", "match", "append", "execute", "process", "init", "part", "open", "cmp"], "targetDirectory": ["destFile", "outputDir", "masterDirectory", "outputFolder", "currentDir", "destFolder", "destDir", "baseFolder", "targetDatabase", "targetFolder", "TargetFolder", "targetDir", " targetRoot", "targetFile", "TargetPath", "TargetDatabase", "baseDir", "masterPath", "TargetFile", " targetDir", "TargetRoot", " targetPath", "currentDirectory", "currentRoot", "basePath", "targetPath", "masterDir", " targetFile", "TargetDirectory", "currentFolder", "baseFile", "masterDatabase", "baseDirectory", "targetRoot", "currentPath", "outputDirectory", "TargetDir", "baseDatabase", "destDirectory", "outputFile", " targetFolder"], "prefix": ["first", "template", "fp", "prot", "base", "cache", "resolution", "pre", "path", "folder", "Pref", "index", "filename", "patch", "name", "string", "sequence", "offset", "pattern", "domain", "queue", "format", "username", "type", "root", "number", " suffix", "directory", "config", "padding", "uri", "timeout", "resource", "ix", "append", "fixed", "FIX", "fix", "unit", "txt", "temp"], "maxUnitBases": ["maxUnitAliasing", "maxUnitEases", "maxUnitEails", "maxUnitAliails", "maxUnitAliaches", "maxunitAliase", "maxUnitQuease", "maxunitAliasing", "maxUnitBase", "maxUnitQueases", "maxUnitEase", "maxUnitBails", "maxUnitBues", "maxUnitQueues", "maxUnitBaches", "maxUnitPlase", "maxunitBases", "maxunitAliails", "maxUnitPlaches", "maxUnitChases", "maxunitBues", "maxUnitChues", "maxUnitEaches", "maxunitBase", "maxUnitPlases", "maxUnitAliues", "maxUnitChasing", "maxunitAliaches", "maxunitBaches", "maxUnitAliase", "maxunitBasing", "maxUnitAliases", "maxunitBails", "maxunitAliases", "maxunitAliues", "maxUnitBasing", "maxUnitChase", "maxUnitPlails", "maxUnitQueasing"], "maxUnitEntries": ["maxUnitEntrys", "maxUnitOrdies", "maxUnitOrdresses", "maxUnitInties", "maxunitEntryresses", "maxUnitErries", "maxUnitErines", "maxLineEntries", "maxUnitOrdines", "maxUnitErry", "maxLineOrdrations", "maxUnitEntures", "maxunitEntryrys", "maxUnitCountines", "maxunitEntryies", "maxUnitOrdrys", "maxUnitEntryries", "maxUnitEntrations", "maxUnitIntries", "maxLineOrdries", "maxunitEntresses", "maxUnitEnties", "maxUnitAddries", "maxLineOrdry", "maxUnitOrdries", "maxUnitEntry", "maxUnitEntryry", "maxUnitAddry", "maxUnitAddresses", "maxUnitEntryures", "maxUnitOrdry", "maxUnitEntryresses", "maxLineEntry", "maxUnitAddures", "maxUnitCountrations", "maxLineEntines", "maxUnitEntryrys", "maxUnitCountry", "maxUnitIntrys", "maxUnitCountries", "maxunitEntries", "maxunitEnties", "maxUnitIntresses", "maxUnitEntines", "maxUnitOrdrations", "maxUnitEntresses", "maxunitEntrys", "maxunitEntryries", "maxUnitErrations", "maxLineEntrations", "maxUnitEntryies", "maxLineOrdines"], "fis": ["forisa", " fiss", "visa", "fris", " fIs", "Fisc", "fisc", "forisc", " fai", "Fris", " fisc", "vIs", "foris", " fisa", "fIs", "Fis", "vai", "forai", "Fiss", "vis", "fiss", "foriss", "forris", "fai", "forIs", " fris", "fisa"], "fci": ["vcos", "hci", "Fco", "Fai", " foci", "bis", " fai", " fii", "hco", "foci", "efcos", "bco", "efco", "Fis", "vai", "efai", "hai", "bci", "vco", "vci", "fii", "Foci", "bai", "efci", "dii", "fai", "dci", "Fci", "Fii", "doci", "hcos", "fcos", "dco"], "fos": ["foes", "tos", "tis", "ifo", "fsos", "toss", "foss", "infis", "Fos", "Fis", "ifios", " fo", "Foss", "fios", "Foes", "fsios", "infoes", "toes", "fscos", " fios", "ifcos", "fo", " fcos", "fso", "ifos", "infos", "infoss", "fcos"], "fco": ["fileco", "filebo", "hci", "dro", "Fco", "fileico", "Fico", "hgo", "lco", "fgo", "hco", "fbo", "lcos", "fro", "fico", "lro", " fbo", "lgo", "Fbo", "dcos", " fcos", "lci", " fro", "fileci", "dci", "Fci", " fico", "hcos", "fcos", "dco", " fgo"], "buffer": ["Buffer", "bc", "position", "result", "base", "header", "uffer", "reader", "cache", "window", "bin", "transfer", "pause", "comment", "view", "feed", "request", "border", "input", "length", "context", "binary", "offset", "memory", "queue", "image", "callback", "expression", "rate", "read", "layer", "writer", "info", "batch", "reference", "counter", "bar", "null", "buf", "block", "pad", "loader", "message", "iter", "resource", "timeout", "scale", "flush", "copy", "document", "translation", "data", "channel", "entry", "server", "source", "device", "capacity", "size", "zero", "buff", "response", "texture"], "currentBasesCount": ["currentBasingNum", "currentBaseCounter", "currentBatchescount", "currentChasescount", "currentChasesCount", "currentChasesCounter", "currentBasingCount", "currentBatchesCounter", "currentBasesCounter", "currentBatchesCount", "currentBatchesNum", "currentChasesNum", "currentChasecount", "currentBasingcount", "currentChaseCount", "currentBasescount", "currentBasingCounter", "currentBaseNum", "currentChaseNum", "currentBaseCount", "currentBasecount", "currentBasesNum", "currentChaseCounter"], "currentEntriesCount": ["currentAddriesSize", "currentEntursSize", "currentAddriesOffset", "currentEntursOffset", "currentEntursCount", "currentEntriesOffset", "currentEntriesLimit", "currentEnturesLimit", "currentAdduresSize", "currentEntrasSize", "currentEnturesSize", "currentEntriesSize", "currentEnturesCount", "currentEnturesOffset", "currentAddriesCount", "currentAdduresCount", "currentEntrasOffset", "currentAdduresOffset", "currentAdduresLimit", "currentEntrasCount", "currentEntrasLimit", "currentEntursLimit", "currentAddriesLimit"], "targetCount": ["argetCount", "targetSize", "TargetSize", "patternSize", "targetSum", "argetSum", "argetSize", "patterncount", "targetcount", "TargetSum", "TargetCount", "argetcount", "patternCount", "Targetcount", "patternSum"], "fastaChannel": [" fastABuffer", " fastaConnection", " fastAConnection", "fastanBuffer", "fastAContainer", "fastasChannel", "fastAColumn", "fastasColumn", "fastasContext", "fastasConnection", "fastanContainer", " fastaContainer", "fastaqColumn", "fastasBuffer", "fastanContext", "fastAChannel", "fastaqChannel", " fastaColumn", " fastAChannel", "fastAContext", "fastanChannel", "fastaqConnection", " fastaContext", "fastasContainer", "fastaConnection", " fastAContainer", "fastABuffer", "fastaqBuffer", " fastAColumn", "fastaContainer", " fastAContext", "fastaContext", "fastaColumn", "fastAConnection"], "totalSeqCount": ["totalQueqCount", "totalSeQCounter", "totalSeQNum", "totalSeQCount", "totalSeqsNum", "totalQueQCounter", "totalSeqcount", "totalSeuxCounter", "totalQueQcount", "totalSeuxCount", "totalSeqsCount", "totalSeqsCounter", "totalSeqscount", "totalQueQNum", "totalQueqCounter", "totalSeqNum", "totalSeQcount", "totalQueqcount", "totalQueqNum", "totalQueQCount", "totalSeuxNum", "totalSeuxcount", "totalSeqCounter"], "totalResiduesCount": ["totalResiduingCount", "totalResiduationNum", "totalResiduescount", "totalResqueuresSize", "totalResqueuesNum", "totalResiduingcount", "totalResiduationcount", "totalResqueuresCount", "totalResqueuesCount", "totalResiduationSize", "totalResiduationCount", "totalResiduresNum", "totalResiduingNum", "totalResiduesNum", "totalResiduingSize", "totalResidurescount", "totalResiduesSize", "totalResqueuesSize", "totalResqueuresNum", "totalResqueuescount", "totalResiduresCount", "totalResqueurescount", "totalResiduresSize"], "prevTime": ["commitFile", " prevFile", "PrevSize", "PrevValue", " prevSize", "commitTime", "PrevTime", "PrevFile", "prevSize", "commitValue", " prevValue", "commitSize", "prevFile", "prevValue"], "fastaFileSize": ["fastaFileAddress", "fastaLineAddress", "fastaFilesSize", "fastABufferCount", "fastasFileAddress", "fastaFilesLength", "fastaPageName", "fastaBufferLength", "fastaFilesAddress", "fastaBlockSize", "fastasFileLength", "fastAFileSize", "fastaLineLength", "fastaFilesName", "fastaFileCount", "fastaBufferAddress", "fastaPageLength", "fastABufferLength", "fastaBlockLength", "fastaLineCount", "fastaFileLength", "fastasHeaderLength", "fastaBlockAddress", "fastABufferAddress", "fastasFileSize", "fastaFileName", "fastAFileLength", "fastaBlockCount", "fastasHeaderAddress", "fastaBufferCount", "fastasHeaderName", "fastaPageAddress", "fastaHeaderAddress", "fastasFileName", "fastaHeaderName", "fastaLineSize", "fastAFileCount", "fastaHeaderSize", "fastaBufferSize", "fastAFileAddress", "fastABufferSize", "fastaHeaderLength", "fastaPageSize", "fastasHeaderSize"], "fastaFileReadOffset": ["fastaFilesWriteoffset", "fastaFileWriteEntry", "fastaDirectoryWriteEntry", "fastaFileLengthOffset", "fastaFileLengthOff", "fastaFileRunoffset", "fastaFileRunOff", "fastaFileReadoffset", "fastaBufferWriteoffset", "fastaFileWriteoffset", "fastaFileRunEntry", "fastaDirectoryReadOff", "fastaFileLoadLength", "fastaDirectoryWriteoffset", "fastaBufferReadoffset", "fastaFilereadOff", "fastaBufferReadAmount", "fastaFileReadAmount", "fastaFilesWriteOffset", "fastaFileLoadoffset", "fastaFilesReadOff", "fastaBufferWriteAmount", "fastaBufferWriteOffset", "fastaDirectoryWriteOff", "fastaBufferWriteLength", "fastaFilesReadLength", "fastaFileStartoffset", "fastaFileLengthoffset", "fastaFileWriteOffset", "fastaFileReadOff", "fastaDirectoryWriteOffset", "fastaDirectoryReadOffset", "fastaBufferReadOffset", "fastaFileWriteOff", "fastaFileReadEntry", "fastaFileLengthLength", "fastaFilesWriteOff", "fastaFilesWriteLength", "fastaFileStartEntry", "fastaDirectoryReadoffset", "fastaFileWriteAmount", "fastaFileWriteLength", "fastaFilesReadoffset", "fastaFilereadoffset", "fastaFileStartOffset", "fastaFileReadLength", "fastaFileRunOffset", "fastaDirectoryReadEntry", "fastaFilereadLength", "fastaFileLengthAmount", "fastaFileLoadAmount", "fastaFileLoadOffset", "fastaBufferReadLength", "fastaFilereadOffset", "fastaFileStartOff", "fastaFilesReadOffset"], "partitionStartOffset": ["partitionStartOrder", "partitionsEndOrder", "partitionStopOff", "partitionsStartOff", "partitionBufferOrder", "partitionBufferOffset", "partitionStartRange", "partitionStopOffset", "partitionEndOff", "partitionsEndOffset", "partitionsEndOff", "partitionsStartOrder", "partitionStopRange", "partitionStopOrder", "partitionStartOff", "partitionBufferOff", "partitionsStartOffset", "partitionsEndRange", "partitionEndOrder", "partitionEndRange", "partitionsStartRange", "partitionBufferRange"], "bufferSize": ["BufferC", "BufferSIZE", " bufferType", "BufferType", "bufferC", "queueSize", "processType", "bufferCount", " bufferSIZE", " bufferCount", "BufferCount", "bufferSIZE", "processC", "BufferSize", "processSIZE", "processSize", "queueCount", "bufferType", " bufferC"], "fastaBuffer": [" fastABuffer", "fastanFile", "fastasBuff", "fastanPtr", "fastanBuffer", "fastAContainer", "fastasChannel", " fastasContainer", "fastaQueue", "fastasQueue", " fastasFile", "fastasPtr", "fastanBuff", "fastaceBuffer", "FastasChannel", "fastaStream", "fastaaPtr", "FastaStream", "fastaFile", "fastanContainer", "FastaBuffer", "FastaBuff", "FastaChannel", "FastasStream", " fastaContainer", "fastasStream", "fastaaBuff", " fastABuff", "FastasBuffer", "fastasBuffer", "fastanStream", "fastAChannel", "FastasPtr", " fastaBuff", "fastanQueue", "fastaaStream", " fastAChannel", "fastanChannel", "fastaPtr", "fastaaBuffer", "fastasContainer", "fastAQueue", " fastasChannel", "fastAFile", " fastAFile", " fastAQueue", "fastABuff", "fastABuffer", " fastasBuffer", "fastaBuff", "fastacePtr", "FastasBuff", "fastaceChannel", " fastaQueue", "fastasFile", "fastaContainer", "FastaPtr", "fastAPtr", "fastaceBuff", " fastaFile"], "fastaReadState": ["fastasReaderState", "fastasReaderType", "fastaReadingState", "fastaReaderstate", "fastaReadstate", "fastaFileMode", "fastaReadType", "fastaReaderType", "fastaFileType", "fastaReadingType", "fastasReadType", "fastasReaderstate", "fastaReadingstate", "fastasReadstate", "fastasReadMode", "fastaReaderMode", "fastaFilestate", "fastaReadingMode", "fastaReadMode", "fastasReadState", "fastaFileState", "fastasReaderMode", "fastaReaderState"], "nBytes": ["pBytes", "nFrames", "lenbytes", "nbytes", "numFrames", "NBytes", "oFiles", "lenBytes", "oBytes", "nFiles", "NFiles", " nbytes", "NParts", "NByte", " nParts", "pParts", "pByte", "nByte", "pbytes", " nByte", "lenFrames", " nFrames", "lenFiles", "nParts", "numFiles", " nFiles", "oParts", "Nbytes", "numbytes", "numBytes", "obytes"]}}
{"id1": "21181542", "id2": "14093044", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    @Override\n    public boolean insert(String consulta, boolean autocommit, int transactionIsolation, Connection cx) throws SQLException {\n        filasInsert = 0;\n        if (!consulta.contains(\";\")) {\n            this.tipoConsulta = new Scanner(consulta);\n            if (this.tipoConsulta.hasNext()) {\n                execConsulta = this.tipoConsulta.next();\n                if (execConsulta.equalsIgnoreCase(\"insert\")) {\n                    Connection conexion = cx;\n                    Statement st = null;\n                    try {\n                        conexion.setAutoCommit(autocommit);\n                        if (transactionIsolation == 1 || transactionIsolation == 2 || transactionIsolation == 4 || transactionIsolation == 8) {\n                            conexion.setTransactionIsolation(transactionIsolation);\n                        } else {\n                            throw new IllegalArgumentException(\"Valor invalido sobre TransactionIsolation,\\n TRANSACTION_NONE no es soportado por MySQL\");\n                        }\n                        st = (Statement) conexion.createStatement(ResultSetImpl.TYPE_SCROLL_SENSITIVE, ResultSetImpl.CONCUR_UPDATABLE);\n                        conexion.setReadOnly(false);\n                        filasInsert = st.executeUpdate(consulta.trim(), Statement.RETURN_GENERATED_KEYS);\n                        if (filasInsert > -1) {\n                            if (autocommit == false) {\n                                conexion.commit();\n                            }\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    } catch (MySQLIntegrityConstraintViolationException e) {\n                        System.out.println(\"Posible duplicacion de DATOS\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLNonTransientConnectionException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } catch (MySQLDataException e) {\n                        System.out.println(\"Datos incorrectos\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (MySQLSyntaxErrorException e) {\n                        System.out.println(\"Error en la sintaxis de la Consulta en MySQL\");\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        return false;\n                    } catch (SQLException e) {\n                        if (autocommit == false) {\n                            try {\n                                conexion.rollback();\n                                System.out.println(\"Se ejecuto un Rollback\");\n                            } catch (MySQLTransactionRollbackException sqlE) {\n                                System.out.println(\"No se ejecuto un Rollback\");\n                                sqlE.printStackTrace();\n                            } catch (SQLException se) {\n                                se.printStackTrace();\n                            }\n                        }\n                        e.printStackTrace();\n                        return false;\n                    } finally {\n                        try {\n                            if (st != null) {\n                                if (!st.isClosed()) {\n                                    st.close();\n                                }\n                            }\n                            if (!conexion.isClosed()) {\n                                conexion.close();\n                            }\n                        } catch (NullPointerException ne) {\n                            ne.printStackTrace();\n                        } catch (SQLException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                } else {\n                    throw new IllegalArgumentException(\"No es una instruccion Insert\");\n                }\n            } else {\n                try {\n                    throw new JMySQLException(\"Error Grave , notifique al departamento de Soporte Tecnico \\n\" + email);\n                } catch (JMySQLException ex) {\n                    Logger.getLogger(JMySQL.class.getName()).log(Level.SEVERE, null, ex);\n                    return false;\n                }\n            }\n        } else {\n            throw new IllegalArgumentException(\"No estan permitidas las MultiConsultas en este metodo\");\n        }\n    }\n", "label": 1, "substitutes": {"deleteRoleType": ["deleteResourceTypes", " deleteroleTyp", "deleteResourcetype", "deleteRoletype", " deleteroletype", " deleteRoleTypes", "deleteroleType", "deleteroletype", "deleteRoleTypes", " deleteRoletype", " deleteRoleTyp", "deleteFunctionTyp", "deleteroleTypes", "deleteFunctionTypes", "deleteFunctionType", " deleteroleTypes", "deleteFunctiontype", "deleteRoleTyp", "deleteroleTyp", " deleteroleType", "deleteResourceTyp", "deleteResourceType"], "id": ["source", "edit", "kid", "uid", "Id", "rid", "uri", "length", "path", "f", "info", "model", "view", "i", "ident", "data", "in", "object", "vid", "ip", "error", "url", "name", "it", "code", "is", "mid", "address", "index", "string", "connection", "lock", "section", "oid", "ID", "sid", "pid", "like", "version", "request", "part", "key", "aid", "end", "type", "parent", "start", "ids"], "namespaceId": ["namesaneId", "NamespaceName", "membersetid", "namespacedPath", "namesentityID", "namesaneid", "worksspaceKey", "namesplaceID", "namesetID", "namesetId", "namesaceType", "namespacesID", "memberspaceType", "asentityId", "namesaceid", "asentityInfo", "Namespacedid", "namesplaceInfo", "worksspaceInfo", "namesentityName", "NamespaceType", "namesetInfo", "namespacedName", "namesaceInfo", "namespaceInfo", "memberspaceid", "workspaceid", "asentityName", "aspaceID", "workspaceType", "namesaceId", "aspaceName", "namesentityId", "namesspaceInfo", "namespacesName", "workspacesId", "namespacesid", "namespaceName", "worksspaceId", "namesenceContext", "membersetType", "nsaceid", "workspaceInfo", "namespacesId", "nsaceID", "nsaceId", "nspaceId", "nspaceid", "aspaceInfo", "nspaceID", "namesplaceId", "workspaceKey", "memberspaceId", "namespacedInfo", "namesentityInfo", "namesaceContext", "workspaceContext", "namespacesInfo", "namesaneType", "namespaceType", "namespacedid", "asentityID", "namespaceKey", "NamespacedName", "namesplaceid", "Namespaceid", "NamespacedId", "NamespaceId", "namesetType", "namesaceID", "workspacesContext", "aspaceId", "namespacesType", "namespacesPath", "namesspacePath", "workspacesType", "namespaceid", "namesetid", "namespaceContext", "worksspacePath", "namespacesContext", "namespaceID", "namesaneName", "membersetName", "namespacesKey", "namespacePath", "namesenceId", "namesspaceId", "namespacedId", "membersetId", "namesetName", "namesspaceKey", "namesenceType", "namespacedKey", "workspaceId", "nsaceInfo", "workspacesid", "namespacedType", "memberspaceName", "nspaceInfo", "NamespacedType", "namesenceid", "workspacePath"], "removeReferencesInRoleTypes": ["removeReferencesInServiceTypes", "removeReferencesFromRoleType", "removeReferencesFromroleTypes", "removeReferencesInroletypes", "removeReferencesedInRoleNames", "removeReferencesFromroleType", "removeReferencesFromRoleTypes", "removeReferencesInroleType", "removeReferencesFromroleRelations", "removeReferencesFromRoleRelations", "removeReferencesInRoletypes", "removeReferencesInRoleRelations", "removeReferencesInServiceType", "removeReferencesInroleTypes", "removeReferencesFromRoleNames", "removeReferencesInRuletypes", "removeReferencesInroleNames", "removeReferencesFromroleNames", "removeReferencesedInroletypes", "removeReferencesedInRoleTypes", "removeReferencesInRuleRelations", "removeReferencesInRuleNames", "removeReferencesedInroleTypes", "removeReferencesedInroleType", "removeReferencesInServiceNames", "removeReferencesInServiceRelations", "removeReferencesedInroleNames", "removeReferencesedInRoletypes", "removeReferencesedInRoleType", "removeReferencesInRuleType", "removeReferencesInRoleType", "removeReferencesInroleRelations", "removeReferencesInRoleNames", "removeReferencesInRuleTypes"], "permit": ["perit", "PERmission", "recmit", "Permits", "Permission", "PERmit", "permMIT", "permmit", "PERmissions", "permmissions", "recmits", "permits", "Perit", "permission", "recmission", "perMIT", "recit", " permits", "PerMIT", "PERMIT", " perit", "Permissions", " permission", "permissions", "permmission", "Permit"], "exist": ["match", "form", "edit", "create", "ist", "stick", "check", "continue", "update", "existing", "front", "purpose", "ident", "keep", "present", "icate", "destruct", "existent", "cont", "add", "destroy", "fill", "know", "index", "list", "existence", "write", "fail", "delete", "inc", "include", "register", "support", "diff", "apply", "same", "start", "cmp", "draw", "except"], "msgBuf": ["msgBUF", "msgDuf", " msgFuf", "msgDuff", "msgEBuf", "msgFBUF", "msgPlundle", "msgCbuf", "msgBbuff", "messageBbuf", "msgFaf", "msgLob", " msgLuf", "msgFBuf", "messageFbuf", "messageAuff", "msgFob", "msgEBbox", "msgAuff", "messageFuff", "messageAbuf", "msgCuf", "msgLUF", " msgFbuf", "msgLaf", "msgAbuf", "msgAaf", " msgFbuff", "msgFraf", "messageBob", "msgBuff", "msgFbuf", " msgFaf", " msgBbuf", "msgFuff", "msgDBbuf", "msgDBuff", "msgLuf", "msgBaf", " msgBuff", "messageFuf", " msgBraf", "msgAbox", "msgAraf", " msgLundle", "msgFBob", "msgFbuff", "msgCob", "msgFUF", "msgEBuff", "msgDbuf", "msgBob", " msgBundle", "msgAob", "msgLuff", "msgEBbuf", "msgPluf", "msgFuf", "messageBuf", "msgBbox", "msgBundle", "msgAuf", " msgBaf", "messageFUF", "messageFbox", "messageBuff", "msgDBUF", "messageAUF", "msgAUF", "msgFundle", "msgPluff", " msgFuff", "msgFbox", " msgFraf", " msgLuff", " msgLaf", "messageBUF", "msgPlaf", "msgAbuff", "msgFBuff", "msgLundle", "msgBraf", "msgDaf", " msgBbuff", "messageBbox", "msgBbuf", "msgCuff", "messageFob", "msgDBuf", "messageAuf"], "objects": ["relations", "frames", "types", "parts", "apps", "archs", "locks", "cats", "lines", "agents", "bugs", "jobs", "kids", "keys", "actions", "groups", "notes", "projects", "resources", "organisms", "names", "pps", "parents", "object", "products", "children", "cells", "values", "archives", "ks", "oids", "pins", "os", "boxes", "obj", "files", "members", "features", "links", "models", "ins", "points", "plugins", "users", "owners", "properties", "obs", "results", "items", "classes", "blocks", "people", "ids", "articles", "images", "roots", "phones", "ops"], "sqlRightId": ["SQLRightid", "SQLRightRef", "SQLRestRef", "SQLRightId", " sqlrightPoint", "sqlRestId", "SQLRestID", "sqlrightType", "sqlRRef", "sqlRID", "sqlLeftPoint", " sqlrightId", "SQLRestid", "sqlrightid", " sqlrightType", "SQLRightID", "sqlLeftId", " sqlRightType", "sqlLeftid", " sqlRightid", "sqlRightType", "SQLRestId", "sqlRestRef", " sqlrightid", "sqlrightId", "sqlRid", "sqlRestid", " sqlRightPoint", "sqlRestID", "sqlRightID", "sqlrightPoint", "sqlRightPoint", "sqlRId", "sqlRightRef", "sqlRightid", "sqlLeftType"], "sqlParent": ["qlParents", "qlParent", "sqlParents", "suRoot", "suparent", "qlRoot", " sqlParents", " sqlRoot", " sqlparent", "suParent", "sqlRoot", "qlparent", "sqlparent", "suParents"], "sql": ["session", " SQL", "update", " session", "ql", "s", "link", "conn", " db", "where", "dl", "description", "url", " msg", "log", "SQL", " url", "msg", "operation", "sl", "db", "repl", " params", "acl", "replace", "error", "select", "delete"], "pstmt": [" pstnt", "postmr", "Pcttr", " pndmb", " postmr", "s", "pstatnt", "pStm", "pstatmr", "pftr", " pStct", "pstatmt", "add", "pndmt", "postct", "pctmd", "All", "The", "pcttr", "pmtmd", "pctbl", " postmt", " postnt", "pstct", "Pctct", "this", "pctmr", "pmttr", "psttr", "pctmb", "Pstmt", "pstmd", "pndct", "pndbl", "pctm", "pstatct", "pstnt", "pstrmt", " pStmt", "_", "Security", "pfmt", "Pctmt", "pmtct", "pfmd", " pSttr", "Psttr", "New", "Error", "pstrtr", "pmtmb", " pstmb", "Pctmd", "pstmr", "pstrm", "pfct", "pSttr", "pmtmt", "pctmt", "pStmt", "Delete", " pndct", "delete", " pStm", "pctct", "pmtbl", "pctnt", "Pstct", " psttr", "pstm", "postnt", " pstm", " pstbl", "pstrct", "Pstmd", " pndmt", "pndmb", "postmt", "pStct", "pstbl", " pndbl", " postct", " pstct", "pstmb", " pstmr"], "typeGid": ["TypeCname", "typeGUid", "typeWid", "typeGVoid", "linkGname", "TypeGname", "typegname", "typeCname", "typeGID", "typeGUID", "linkGID", "typeGUname", "typeAccid", "TypeCmin", "typeGmin", "typeWmin", "typeGoid", "typeGUoid", "typeAccmin", "TypeCID", "typeCmin", "linkGid", "typegID", "typeWname", "typeGname", "linkGVname", "TypeGmin", "linkGVID", "typeCid", "TypeGID", "typegid", "linkGVoid", "TypeCid", "typeGVname", "typeAccID", "typeCID", "TypeGid", "typegoid", "typeAccname", "typeWID", "typeGVID", "linkGoid", "linkGVid", "typeGVid"], "defaultLevel": ["configDepth", "DefaultLevel", " defaultCl", "DefaultMode", "defaultCl", " defaultMode", " defaultDepth", "DefaultDepth", "DefaultCl", "configMode", "configLevel", "configCl", "defaultDepth", "defaultMode"], "success": ["match", "message", "result", "continue", "successful", "reg", "successfully", "Success", "complete", "resp", "data", "warning", "progress", "accept", "submit", "fail", "batch", "serial", "replace", "failed", "test", "results", "response", "roll", "launch", "error", "status"]}}
{"id1": "13657527", "id2": "742465", "code1": "    synchronized List<String> getDatasetsList(String surl) {\n        if (datasetsList == null) {\n            datasetsList = new HashMap<String, List<String>>();\n        }\n        List<String> result = datasetsList.get(surl);\n        if (result == null) {\n            BufferedReader reader = null;\n            try {\n                URL url = new URL(surl + \"?server=list\");\n                reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String s = reader.readLine();\n                ArrayList<String> list = new ArrayList<String>();\n                while (s != null) {\n                    list.add(s);\n                    s = reader.readLine();\n                }\n                datasetsList.put(surl, list);\n            } catch (IOException ex) {\n                Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                throw new RuntimeException(ex);\n            } finally {\n                try {\n                    reader.close();\n                } catch (IOException ex) {\n                    Logger.getLogger(Das2ServerDataSourceFactory.class.getName()).log(Level.SEVERE, null, ex);\n                }\n            }\n        }\n        return datasetsList.get(surl);\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"getDatasetsList": ["getDatasenciesSearch", "getDatAsetlist", "getDatAsetList", "getDatasuresSearch", "getDatasetsSearch", "getDatasetslist", "getDatasencieslist", "getDatAsetSearch", "getDatasetSearch", "getDatasetList", "getDatasuresList", "getDatAsetslist", "getDatasureslist", "getDatasenciesList", "getDatAsetsList", "getDatasetlist", "getDatAsetsSearch"], "surl": ["slrule", "ssl", "slog", "ssuri", "slayer", "wslayer", "suri", "slurl", "sinlog", "sfeed", "osuri", "SUrl", "sURL", "shttp", "Srule", "Shttp", "ossl", "turi", " sURL", "sesfile", "turl", "sUrl", "dlayer", "osfile", "wsuri", "Slog", "ssfile", "osurl", " sUrl", "Sfeed", "srule", "Surl", "sinurl", "wssl", "sesurl", "jsuri", "jssl", "sinrule", "nsjob", "SURL", "lsURL", " shttp", "sesjob", "sesuri", "duri", "lsUrl", "lshttp", "durl", "dsuri", "sinfeed", "wsurl", "nsuri", "lsurl", "slfeed", "sjob", "dsurl", "dssl", "jsurl", "nsurl", "tsl", "ssurl", "sllog", "jslayer", "nsfile", "dsfile", "ssjob", "dsl", "sfile", "tfile"], "datasetsList": ["datastersString", "dataselineslist", "datasetsString", "datrasETSList", "datastersList", "datascencesString", "datasitesMap", "datrasetslist", "datascetsString", "datasETSTable", "datasetList", "datasencesCollection", "datascetsCollection", "datrasuresMap", "datasencesList", "datassetsL", "dataselinesMap", "datasETSList", "datassetsPool", "datetetsList", "datasETSL", "datassetsCollection", "dataschesMap", "dataselinesTable", "datasencesMap", "dataschesList", "datrasureslist", "datassETSList", "datasitesList", "datasetslist", "datrasetsTable", "datasitesL", "datasagesMap", "datascetsMap", "datascheslist", "datasuresL", "datasuresCollection", "datassETSMap", "datassetsList", "datasureslist", "datrasETSTable", "datassETSCollection", "dataselinesList", "datrasetsL", "datasETSPool", "datetsetsMap", "datascencesList", "datrasetsMap", "datascencesCollection", "datastersMap", "datasagesPool", "datetetslist", "datasiteslist", "datasetsMap", "datrasetsList", "datetetsL", "datasuresMap", "datasETSlist", "datasetsCollection", "datasetL", "datasagesList", "datetsetsL", "datetsetsList", "datassetsMap", "datasetsL", "datascencesMap", "datasetsTable", "datetetsMap", "dataschesTable", "datasetsPool", "datascetsList", "datastersCollection", "datasagesCollection", "datrasETSlist", "datassetslist", "datasuresList", "datassETSPool", "datasETSCollection", "datrasuresList", "datasETSMap", "datasetlist", "datetsetslist", "datrasuresL", "datasencesString", "datasuresString", "datasetMap", "datrasETSMap"], "result": ["event", "info", "resource", "response", "rc", "user", "entry", "report", "res", "results", "message", "ge", "inner", "end", "instance", "match", "record", "fr", "ret", "part", "load", "rule", "ner", "r", "default", "page", "request", "rar", "row", "test", "status", "card", "runner", "success", "comment", "Result", "found", "repl", "re", "valid"], "reader": ["ssl", "handler", "loader", "i", "input", "server", "buffer", "feed", "editor", "reading", "her", "builder", "entry", "http", "resource", "slice", "per", "inner", "older", "lr", "l", "driver", "dr", "keeper", "read", "iter", "ler", "er", "oder", "ner", "r", "ger", "parser", "file", "rar", "row", "rr", "rer", "io", "writer", "rx", "runner", "worker", "layer", "cher", "ser", "stream", "roller", "over", "err", "upper", "Reader"], "url": ["string", "ssl", "buffer", "loader", "base", "address", "server", "uri", "resource", "feed", "user", "entry", "http", "socket", "lr", "l", "driver", "URL", "iter", "client", "source", "rule", "connection", "browser", "str", "file", "page", "bel", "ll", "log", "io", "image", "sl", "Url", "stream", "ur", "b", "f", "hub", "element", "service"], "s": ["services", "string", "ssl", "i", "server", "spec", "n", "site", "ns", "comments", "S", "o", "l", "ins", "abs", "line", "si", "su", "is", " lines", "rs", "ings", "sync", "less", "ws", "source", "lines", "sb", "strings", "ops", "r", "str", "p", "es", "search", "u", "ls", "js", "e", "sets", "t", "ss", "details", "sl", "ses", "b", "ds", "words", "os", "ps", "f"], "list": ["val", "letter", "string", "base", "server", "entry", "table", "join", "l", "set", "all", "record", "pl", "el", "key", "queue", "la", "LIST", "type", "load", "lc", "str", "default", "listed", "collection", "data", "li", "cl", "ll", "null", "lists", "test", "ls", "coll", "chain", "array", "ml", "bl", "left", "ul", "and", "batch", "view"]}}
{"id1": "22046596", "id2": "13891080", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["get", "p", "sync", "upload", "Transfer", "all", "cp", "transfer", "Copy", "write", " cp", "to", " copied", "clip", "io", " copying", "file", " dup", "exec", "zip", "download", "paste", "put", " Copy", " copies", " transfer"], "s": ["S", "os", "m", "p", "sl", "g", "files", "i", "src", "is", "input", "xs", "ls", "ns", "e", "ses", "sin", "es", "sb", "sf", "sh", "a", "services", "se", "ssl", "ds", "storage", "x", "f", "fs", "o", "u", "b", "v", "south", "w", "ins", "l", "ss", "as", "si", "ps", "gs", "sv", "outs", "less", "source", "c", "ts"], "t": ["r", "T", "m", "template", "p", "n", "g", "i", "object", "e", "ty", "to", "target", "ta", "z", "at", "file", "tc", "x", "down", "f", "ot", "o", "tp", "temp", "b", "y", "v", "it", "l", " T", "tty", "tf", "tr", "tor", "pt", "c", "ts"], "in": ["r", "m", "h", "p", "pin", "sync", "g", "n", "inn", "i", "is", "socket", "init", "input", "e", "id", "sin", "din", "conn", "inner", "io", "pull", "nin", "ssl", "rin", "file", "min", "f", "url", "login", "b", "ins", "bin", "In", "l", "reader", "IN", "d", "as", "again", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "plain", "client", "writer", "p", "obj", "sync", "off", "n", "g", "output", "user", "parent", "ex", "conn", "connection", "ext", "not", "io", "at", "file", "x", "f", "o", "channel", "null", "err", "temp", "b", "v", "w", "net", "call", "l", "bin", "d", "again", "outs", "OUT", "c", "inc"]}}
{"id1": "1180878", "id2": "720361", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        int result = 20;\n        if (args.length == 1) {\n            StringBuffer urlString = new StringBuffer(args[0]);\n            if (urlString.lastIndexOf(\"/\") != urlString.length() - 1) {\n                urlString.append('/');\n            }\n            urlString.append(\"GetConfig.jsp\");\n            URLConnection conn = new URL(urlString.toString()).openConnection();\n            System.out.println(Configuration.readObject(conn.getInputStream()));\n            result = 0;\n        } else {\n            System.err.println(\"usage: GetConfig <URL>\");\n        }\n        System.exit(result);\n    }\n", "label": 0, "substitutes": {"fetchURLData": ["frieveUrldata", "fetchURLDATA", "frieveURLDATA", "fetchJSONData", "frieveUrlDATA", "fetchHTTPDATA", "fetchUrldata", "fetchURLdata", "fetchUrlDATA", "frieveURLdata", "fetchHTTPdata", "fetchUrlData", "frieveURLData", "fetchHTTPData", "fetchJSONdata", "fetchJSONDATA", "frieveUrlData"], "url": ["image", "html", "URL", "base", "resource", "feed", "www", "view", "download", "Url", "ls", "http", "text", "src", "filename", "l", "href", "api", "page", "string", "path", "fl", "source", "uri", "xml", "ur", "name", "location", "ssl", "server", "data", "file", "user", "gl", "username", "sl", "el", "connection", "loc", "host", "f", "address"], "proxyHost": ["cacheHost", " proxyServer", "serverAddress", "serverPath", " proxyAddress", "baseHost", "baseDomain", "remoteAddress", "proxyHead", "baseAddress", "ProxyHead", "remoteDomain", "ProxyHost", " proxyPath", "proxyhost", "serverServer", " proxyhost", "proxyDomain", "baseHead", "ProxyDomain", "ProxyServer", "cachePort", "proxyPath", "remoteHead", "ProxyPath", "proxyAddress", "proxyServer", "cachehost", "cacheAddress", "ProxyPort", "ProxyAddress", "remoteHost", "Proxyhost", "serverHost"], "proxyPort": ["cacheHost", " proxyServer", " proxyport", " proxyAddress", "httpPort", "ProxyHost", "httpServer", "httpAddress", "cachePort", "Proxyport", "ProxyServer", "cacheport", "proxyAddress", "proxyServer", "proxyport", "cacheAddress", "ProxyPort", "ProxyAddress", "httpHost"], "con": ["com", "fa", "ls", "rec", "ch", "c", "cf", "rc", "ci", "per", "uc", "connection", "cr", "f", "login", "cl", "pc", "cur", "ca", "cache", "run", "sync", "conn", "CON", "ran", "co", "ocon", "cone", "connect", "go", "win", "re", "conv", "change", "sub", "fac", "fun", "don", "common", "pre", "cons", "fc", "remote", "un", "an", "x", "out", "xc", "Con", "pub", "cn", "on", "gen", "mc", "cp", "ec", "inc", "exec", "conf", "socket", "ver", "canon", "func", "can", "syn", "open", "pen", "ctrl", "http", "act", "pin", "fl", "en", "part", "ai", "min", "cc", "cas", "close", "cm", "ac", "n", "bc", "fan"], "is": ["ib", "its", "in", "can", "serv", "isi", "vs", "abs", "ops", "mis", "cms", "ir", "lis", "has", "does", "api", "info", "conn", "isu", "ws", "IS", "js", "ri", "act", "sp", "state", "ps", "was", "ie", "p", "ci", "ris", "si", "os", "it", "cs", "oss", "ai", "out", "isa", "isl", "fs", "iss", "cos", "il", "as", "es", "iso", "are", "bis", "us", "ori", "bs", "isin", "id", "isc", "ios", "Is", "i", "im", "get", "ais", "or", "ar", "iris", "ics", "s"], "u": ["ou", "o", "q", "U", "ul", "up", "ue", "http", "cu", "ut", "l", "un", "b", "ui", "uv", "api", "conn", "uci", "c", "m", "p", "io", "su", "uri", "os", "v", "client", "hu", "fu", "ur", "nu", "us", "h", "user", "file", "yu", "tu", "iu", "i", "uc", "ru", "lu", "f"], "proxy": ["force", "pool", "resource", "create", "clone", "phone", "pc", "fe", "http", "zip", "cache", "cop", " Proxy", "l", "api", "remote", "prot", "XY", "c", "pe", "pin", "Proxy", "pa", "plus", "p", "type", "xy", "uri", "x", "roxy", "ip", "client", "pse", "ssl", "bean", "wrapper", "server", "shadow", "port", "timeout", " proxies", "lib", "connection", "config", "host", "web", "f", "socket", "copy", "address"], "baos": ["abis", "baOS", "caas", "caos", "haOS", "bao", "bais", "BAOS", "BAos", "BAis", "pao", "boOS", "hao", "BaOs", "Baos", "boas", "haos", "calos", "caOS", "paOS", "Bais", "balos", "paos", "baas", "boos", "abOs", "abros", "BAo", "baOs", "aas", "bolos", "Baros", "pais", "hais", "alos", "baros", "BAOs", "aos", "aOS", "abos", "BAros"]}}
{"id1": "21224967", "id2": "8330057", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"crear": ["generar", "Creas", "generare", "Crear", "generas", " Creare", " creare", " Crear", "Crea", "Creare", " crea", " creas", "genera", " Crea", " Creas"], "result": ["success", "error", "match", "db", "rate", "entry", "order", "currency", "comment", "default", "user", "page", "limit", "valid", "diff", "ver", "found", "grade", "response", "message", "Result", "ret", "df", "results", "out", "count", "function", "date", "value", "cash", "die", "feature", "err", "type", "mark", "status", "number", "force", "record", "res", "counter", "score", "ure", "event", "sign", "up", "length"], "sql": ["job", "db", "where", "query", "script", "sync", "sl", "q", "comment", "pg", "action", "install", "statement", " SQL", "SQL", "conn", "params", "fp", "ssl", "fn", "plan", "url", "serv", "exec", "base", "session", "update", "zip", "sq", "log", "printf", "dl", "database", "ql", "string", "seed", "setup", "cmd", "join", "up", "select", "repl"], "connection": ["position", "db", "error", "client", "connect", "BC", "union", "writer", "p", "query", "ctx", "cond", "relation", "socket", "proxy", "context", "pg", "environment", "section", "statement", "server", "cache", "Exception", "conn", "loc", "bc", "container", "graph", "index", "manager", "con", "function", "tc", "which", "connected", "engine", "session", "system", "log", "database", "collection", "application", "document", "driver", "table", "ion", "communication", "Connection", "lock", "event", "config", "c", "condition"], "ps": ["ppa", "os", "ups", "p", "PS", "query", "pp", "qs", "pos", "pa", "cp", "cs", "bs", "proxy", "pg", "pre", "ns", "po", "ips", "pd", "properties", "conn", "ks", "pers", "cop", "params", "posts", "proc", "ds", "changes", "gres", "pe", "jp", "eps", "hs", "ins", "pc", "ops", "settings", "Ps", "vs", "ss", "pse", "gs", "pps", "ports", "pt", "pr", "sp"]}}
{"id1": "21182766", "id2": "6890417", "code1": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "code2": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "label": 0, "substitutes": {"load": ["call", "init", "create", "loading", "copy", "set", "parse", "path", "loaded", "check", "update", "config", "download", "info", "store", "use", "construct", "dump", "read", "install", "loader", "process", "resources", "build", "resource", "Load", "find", "class", "add", "proc", "setup", "loads", "write", "save", "include", "pack", "get", "start", "delete", "LOAD"], "propsName": ["propsname", "pepsName", "pepsNames", "propertiesPath", "comppsname", "comppsDesc", "proPSDesc", "pepertiesPath", "profsDesc", "propsDesc", "proPSPath", "comppertiesName", "propertiesname", "pepertiesName", "pepsPath", "propertiesNames", "propsNames", "propertiesDesc", "profsname", "proPSNames", "profsName", "pepertiesNames", "comppertiesPath", "propsPath", "proPSname", "comppertiesname", "comppsName", "comppertiesDesc", "proPSName", "pepsname", "pepertiesname", "propertiesName", "comppsPath", "profsPath", "profsNames"], "props": ["propps", "preps", "perds", "crops", "procs", "Procs", "prets", "prids", "cropps", "protpps", "comppos", "pecs", "prps", "probs", "perpos", "prips", "prots", "pebs", "prebs", "compps", "pripos", "pribs", "protpr", "croperties", "propos", "prpps", "compbs", "perbs", "propr", "perps", "Props", "peps", "prperties", "compds", "pets", "precs", "prods", "protps", "prpr", "protperties", "Probs", "properties", "Prots", "cropr"], "url": ["source", "ref", "gl", "buffer", "uri", "browser", "path", "Url", "f", "config", "not", "page", "event", "e", "i", "l", "src", "loader", "data", "service", "resource", "location", "base", "name", "bel", "b", "server", "URL", "fl", "sl", "api", "channel", "stream", "cl", "file", "r", "feed", "ssl", "ob", "id", "user", "xml", "jar", "http"]}}
{"id1": "12428013", "id2": "21308543", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "label": 0, "substitutes": {"polishOff": [" polishingOn", " synchroniceDown", " polishDown", " synchronishOn", " synchronishingOn", " synchronipeDown", " synchroniceOffline", " synchronishOffline", " polishOn", " polishOffline", " synchronishingOffline", " synchronishOff", " synchronishingOff", " polishingOff", " synchronipeOff", " synchroniceOn", " polishingOffline", " synchronipeOffline", " synchroniceOff", " polishingDown", " synchronishDown", " synchronishingDown", " synchronipeOn"], "monitor": ["timeout", "or", "reason", "watch", "status", "username", "container", "pm", "function", "cm", "m", "sm", "method", "state", "condition", "log", "report", "manager", "mor", "match", "number", "driver", "umi", "progress", "conn", "object", "client", "handler", "cher", "unit", "mc", "consumer", "program", "port", "component", "thread", "clock", "config", "loader", "processor", "control", "Monitor", "controller", "period", "don", "callback", "image", "dm", "widget", "stat", "counter", "member", "runner", "directory", "mon", "meter", "module", "annot", "duration", "timer", "message", "update", "oper", "master", "body", "core"], "from": ["resource", "action", "or", "actor", "attribute", "route", "username", "owner", "who", "at", "front", "string", "channel", "host", "false", "with", "From", "about", "path", "vol", "contact", "add", "form", "email", "ce", "user", "address", "loc", "connection", "part", "base", "since", "prefix", "server", "small", "url", "component", "left", "size", "code", "by", "start", "remote", "range", "type", "ou", "id", "back", "source", "uri", "org", "name", "origin"], "to": ["resource", "token", "so", "full", "site", "o", "go", "reply", "table", "version", "with", "about", "io", "key", "dest", "database", "user", "address", "into", "connection", "base", "pos", "TO", "out", "prefix", "two", "server", "url", "location", "To", "left", "size", "eto", "su", "value", "by", "top", "remote", "repl", "until", "range", "type", "target", "po", "info", "uri", "source", "toc", "name", "file", "ref"], "renameTo": ["renAMEto", "renAMEToken", "renameFrom", " RenAMETarget", "renenameto", " renAMETarget", "renenameFrom", "renamelOf", "renributeFor", "relenameto", "renributeTarget", "renseTo", "reameTo", "renAMEWill", "renalFrom", "renenameUrl", "renewTo", " RenseTo", " RenameTO", "relenameFrom", "renamelTO", "renokeTo", "renokeTO", "renalTarget", " RenAMEFor", "renoketo", "reageToken", "renameFor", "renamTo", "relenameTo", "relalto", "renalToken", " RenseFor", " RenameOf", "renokeOf", "relalTarget", " renAMEFrom", "renameto", "relameUrl", "renameWill", "renseOf", "renameOf", "renameToken", "renamWill", "reameTO", " RenameTarget", "relalTo", " RenseTO", " RenAMETo", "relameto", "renAMEUrl", "renAMETO", " renameFrom", "renributeWill", "renokeFrom", "reageTO", "relalFrom", "renamFor", "relameFrom", "renamelFor", "renalTO", "renageTO", "rennameTo", "reameto", "renameTO", "renalTo", " RenseOf", "renameTarget", "renageTo", "reageto", "renenameTo", "renributeTo", "rennameFrom", "renAMEFor", " renAMETo", "renageto", " RenameTo", "renAMEFrom", "renamTarget", "renageToken", "renAMETo", "renewFrom", "relameTarget", "rennameto", "renseFor", "renseTO", "renalto", "renenameTarget", " RenameFor", "renokeFor", "renewTarget", "reameToken", "renAMETarget", "renamelTo", "rennameTarget", "renameUrl", " RenAMEWill", "renokeUrl", "relenameUrl", "reageTo", " renameTarget", "relameTo", " RenameWill"], "ftpClient": [" ftpoCenter", " ftpiHost", " ftoHost", "afttStream", " fttpControl", "ftapiCloud", "ftlCommunity", "fticlient", " ftoClient", " ftnHost", "ftpcHelper", "ftcpHost", "ftpsContainer", "ftpCan", "ftmClient", "ftpoCenter", "ftapiClient", "ftpsControl", "ftpHost", "ftcpResource", "ftcServer", "ftfpResource", " ftlClient", "ftapiServer", "ftpClass", " ftpCan", "ftfpCenter", "ftcpGuest", " ftlCenter", "ftcpServer", "ftpCommunity", " ftpChannel", "ctpClient", "ftlClient", " ftpoCloud", "ftpcCloud", " ftpCloud", "ftpcServer", "ftfpCloud", " ftoCan", "ftfpClient", " ftpclient", " ftlConnection", "ftpHelper", " ftoServer", "ftbHost", "ftcclient", "ftnServer", " ftpGuest", "ctcpChannel", "ftoClient", "ftfCenter", " ftiServer", "ftnHost", "ftpiServer", "fttpStream", " ftapiHelper", "afttClient", "ftoCan", "ctpChannel", "ftlConnection", "fttpCan", "ctpServer", " ftiGuest", "ftiClient", "fttpControl", "ftoHost", "ftbrClient", " ftpControl", "ftfClient", "ftpcConnection", "ftpControl", "ftpiClient", "aftpClient", "ftmResource", "ftpcCommunity", "fttpContainer", "ctcpServer", "fttpClass", "ftpoClient", "ftnClient", " ftnClient", " ftpContainer", " ftlCommunity", "ftpServer", "ftmServer", "ftcpHelper", "ftpResource", "ftcGuest", " fttpClass", "ftpiChannel", " ftpiChannel", "ftpoCloud", "fttpHost", " fttpClient", "ftcpCloud", "ftpContainer", "ftpiHost", "ftpCenter", " fttpContainer", "ftpcContainer", "ftbrStream", "ftpConnection", " ftnServer", "ftoServer", "ftpsClass", "ftpStream", " ftiClient", " ftpConnection", " ftpServer", "ftfpChannel", " ftpiServer", "ftfpServer", "ftfCloud", " ftpiClient", "ctcpClient", "ftbServer", " ftapiClient", "ftlCenter", " ftpHelper", "fttpClient", "ftbClient", "ftpcClient", "fttpChannel", "ftcpChannel", "fttStream", " fticlient", "ftiGuest", "ftbCan", " ftpoClient", "ftpGuest", "ftcClient", " ftpHost", "ftpcClass", "fttpServer", "ftpChannel", " ftpCommunity", " ftapiCloud", "ctcpResource", " ftpCenter", "ftpcCenter", "ftcpClient", " ftapiServer", "ftmChannel", "ftpsClient", "fttClient", "ftpCloud", "ftapiHelper", " ftpClass", "ftcpclient", "ftcpCenter", "ftpclient", "ftcpConnection", "ftcpCommunity", "aftpStream", "ftpcControl", "ctpResource", "ftiServer"], "ftpHolder": ["ftpWorkolder", "ftpcWolder", "fttpChard", "ftphander", "fttpChander", "ftpShard", "ftpShook", "ftpWold", "fttpHook", "ftpcHolder", "ftpHholder", "ftpCholder", "ftphook", "ftpcWather", "ftpWholder", "ftpHook", "ftpcHold", "ftphholder", "ftpHard", "ftphard", "ftpSholder", "ftpWorkather", "ftpHather", "ftpWorkold", "ftpWolder", "ftpChander", "ftpcHholder", "ftpWorkholder", "ftpholder", "fttpCholder", "ftpWather", "ftphold", "ftpcWholder", "ftphather", "ftpChook", "ftpHander", "ftpcHather", "ftpHold", "fttpHander", "fttpHard", "ftpcWold", "fttpHolder", "fttpChook", "ftpChard", "ftpShander"], "iter": ["entry", "or", "ip", "ter", "over", "ir", "inter", "http", "ator", "former", "inner", "limit", "walker", "outer", "ner", "collect", "list", "enter", "in", "skip", "Iterator", "er", "iterator", "cher", "it", "loc", "err", "izer", "ener", "init", "chain", "coll", "ipper", "its", "oper", "index", "f", "ite", "e", "itter", "size", "i", "set", "result", "next", "finder", "ser", "reader", "Iter", "gener", "id", "info", "inc", "ver", "iv", "keep", "file", "end"], "element": ["resource", "container", "environment", "match", "email", "letter", "cell", "definition", "next", "parent", "text", "item", "entry", "or", "expression", "comment", "empty", "this", "atom", "header", "connection", "variable", "per", "air", "value", "editor", "page", "member", "output", "data", "module", "optional", "folder", "attribute", "section", "owner", "entity", "instance", "ee", "node", "content", "er", "part", "document", "coll", "component", "ele", "Element", "reader", "type", "activity", "action", "token", "line", "option", "inner", "service", "input", "layer", "key", "number", "object", "child", "event", "server", "article", "e", "el", "result", "style", "plugin", "et"]}}
{"id1": "14191679", "id2": "9846843", "code1": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"EncodeReturn": ["EnccodeData", "EnodedReturns", "EnccodeReturns", "EnodedReturn", "EncodReturn", "EncodeData", "EncodeResult", "EnodeReturns", "EnodedResult", "EnodeReturn", "EncodData", "EnodeResult", "EncodResult", "EnodeData", "EnccodeReturn", "EncodReturns", "EncodeReturns", "EnodedData", "EnccodeResult"], "IOException": ["IOError", "DownloadError", " IOception", "IPException", "DownloadException", "IOception", " IOError", "IPError", "IPception", "Downloadception"], "c": ["cu", "cc", "sc", "n", "cmp", "cf", "enc", "gc", "fc", "l", "dc", "cpp", "nc", "ec", "client", "cp", "ce", "proc", "lc", "d", "ct", "cache", "uc", "r", "ch", "conv", "xc", "p", "cd", "C", "u", "ci", "e", "m", "t", "cr", "chain", "pc", "mc", "b", "y", "ac", "cs", "f", "cur"], "tmpf": ["zipF", "poraryf", "tempfen", "vmF", " tmpfs", "tempcf", " tmpF", "vmf", "tmpcf", "poraryfen", "tmpfd", "tempf", "tempfs", "tempF", "zipfs", "empf", "porarycf", "tmpF", "empF", "empfd", "vmfs", "empfs", "vmcf", "poraryF", "zipf", " tmpfen", " tmpcf", "zipfd", "tmpfen", "tempfd", "tmpfs"], "cw": [" cW", " cwa", "pw", "rcwd", " cwd", "cwe", " cwe", "ffw", "fw", "fwa", " cfw", "psw", "CW", "cW", "pwa", "fws", "lcwb", "cwd", "lcw", "lcwd", "rcwe", "pW", "Cw", " cwb", "cws", "lcwe", "cwa", "rcwb", "cfw", "csw", "Csw", "Cfw", "Cws", "Cwa", " csw", "rcw", "cwb", " cws"], "encdata": ["Enckeys", "encdatabase", "envreader", " enccache", " encdatabase", "secdata", "extdatabase", "envkeys", "envData", "extdat", "installdat", "encreader", "increader", " encdat", "seckeys", "secData", " encroot", "incdata", "envdat", "installdata", "EncData", "enckeys", "installData", " encreader", "Encdata", "extdata", "encdat", "envdata", "envroot", "Encdat", "encroot", "inccache", "installdatabase", "envcache", "encData", "incroot", " encData", "secdat", "extData", "enccache"], "pigdata": ["Pigsla", "pigsla", "pagresults", "Pigdata", "pippdata", "pocdat", "picresource", "Pibresource", "pigData", "pibData", "Pigsresults", "pibresource", "pibdat", "pocresource", "Pigdat", "Pigcache", "Pigla", "pichData", "Pigresource", "pocdata", "picdata", "pagdat", "pigscache", "pagData", "pigresults", "pigsdat", "Pigresults", "pigrData", "pagdata", "pigsdata", "pigrresults", "Pigsdat", "pigsData", "pigrdat", "pocData", "pippcache", "pibdata", "pigsresults", "Pigsdata", "pichcache", "pigcache", "pigrdata", "PigsData", "PibData", "Pigscache", "pippla", "pichla", "pichdata", "pigresource", "pigla", "picData", "picdat", "Pibdata", "PigData", "Pibdat", "pippData", "pigdat"], "pigroute": ["pipelange", "fibrote", "apigrouting", "miarune", "figrote", "apibrouting", "pigerote", "pipelune", "pigrouting", "figroute", "apigrroute", "fibrange", "pibrroute", "pirmouting", "migrote", "pirmroute", "pigrationoute", "pigrationange", "pibroute", "pigrange", "pibrange", "apigrouter", "pigerouting", "pigerune", "fibroute", "pigrroute", "pipelote", "pigrationroute", "pigrationote", "pibrouting", "apibrouter", "pigeroute", "pirmoute", "fibrroute", "figrroute", "piarote", "figrange", "migroute", "miaroute", "pipeloute", "apigroute", "pibrouter", "miarouting", "apibroute", "pigrote", "pirmouter", "pigrationouting", "pigrune", "pibrote", "miarote", "pigrouter", "piarouting", "migrune", "pigrationouter", "pipelroute", "piarune", "piaroute", "apibrroute", "migrouting", "pipelouting"], "fos": ["fops", "pOS", "poes", " fops", "Foes", "refos", "Foc", "refOS", " fOS", "tos", "Fos", "refoes", " foes", "fo", "pops", "pos", "toc", "to", "Fo", " fo", "toes", "fOS", "foes", "refops"], "foc": ["infec", "Fac", "infoc", "infocol", "infic", "Fec", "Focol", " focol", " fac", "Foc", "Fic", "infac", " fec", "focol", "fac", "fec"], "fis": ["cig", "fig", "fi", "infic", "infis", "cic", "Fig", "cics", "Fi", "Fic", "infi", " fi", "cis", "Fis", "fics", " fics", "infics", " fig", "Fics"], "fic": ["Fico", "cfic", " fico", "Fac", "infoc", "cfis", "cfics", "cfoc", "infic", "poc", "rfics", "fisc", "pis", "Foc", " fac", "Fisc", "rfic", "pac", " fisc", "Fic", "fico", "Fis", "pic", "fics", "rfis", " fics", "cfico", "infics", "rfoc", "infisc", "Fics", "fac"]}}
{"id1": "20091126", "id2": "17190057", "code1": "    static File copy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            return out;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "label": 0, "substitutes": {"copy": ["zip", "Copy", "cmp", "output", "join", "write", "cop", "type", "cp", "source", "up", "proxy", "cat", "upload", "open", "file", "archive", "Cop", "put", "p", "exec", "io", "call", "over", "paste", "process", "transfer", "download"], "in": ["IN", "index", "base", "buffer", "i", "input", "id", "ic", "inner", "l", "ins", "bin", "query", "part", "reader", "source", "login", "min", "old", "diff", "connection", "inc", "work", "data", "file", "config", "or", "again", "name", "m", "image", "In", "a", "url", "lin", "b", "ac", "f"], "out": ["string", "base", "buffer", "temp", "i", "ex", "output", "server", "plain", "OUT", "c", "result", "outs", "o", "off", "write", "content", "source", "cache", "dot", "value", "target", "default", "parent", "data", "file", "channel", "page", "object", "x", "p", "again", "name", "exec", "Out", "image", "io", "exp", "array", "call", "prefix", "a", "url", "ext", "comment", "v", "err", "external", "point"], "inChannel": ["inputChannel", "INchannel", "iniChannel", "inStream", " inchannel", "inputchannel", " inClient", "winChan", "INGate", "inchannel", "inButton", "inputChan", "iniStream", "INChan", "INClient", "outStream", "iniChan", "outchannel", "outChan", "inChan", " inButton", "INButton", "insClient", "insStream", "inputStream", "outButton", "insChannel", "INStream", "winChannel", "winchannel", "INChannel", " inStream", "inClient", " inChan", "insChan", "winStream", "inputGate", "iniGate", "inputButton", "inGate"], "outChannel": [" outContext", "OutStream", "inStream", "outsStream", "OutChannel", "inchannel", "outContext", " outConnection", "OutChan", "outStream", "inContext", "outchannel", "outChan", "outsChan", "inChan", "outputStream", "OutContext", "OutClient", "outClient", "outputchannel", "outsChannel", "outputChannel", "outConnection", "Outchannel", "outputClient", "outputChan", "inConnection", "inClient", "outsConnection", " outStream", " outchannel", " outChan"]}}
{"id1": "8216539", "id2": "1357662", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileContentasStr", "getFileContentAsStr", "getFileContentasStream", "getFileContentInStream", "getFileContentFromString", "getFilecontentInStream", "getFileContentInText", "getFilecontentInText", "getFileContentAsStream", "getFilecontentAsText", "getFileContentAsText", "getFileContentFromStream", "getFileContentInString", "getFilecontentInStr", "getFilecontentAsString", "getFilecontentInString", "getFileContentInStr", "getFileContentFromText", "getFileContentFromStr", "getFileContentasString", "getFilecontentAsStream", "getFilecontentAsStr", "getFileContentasText"], "filePath": ["resourcePath", "basePath", "FileLocation", "fileLocation", "resourceName", "baseLocation", "FileStr", "resourceLocation", " fileStr", "FilePath", "singleLocation", "fileUrl", "Filepath", "baseUrl", "FileName", "baseStr", "fileName", "FileUrl", " filepath", "filepath", "baseName", "basepath", "fileStr", "singleUrl", "resourcepath", "singlepath", "singlePath", " fileUrl"], "encoding": ["Encging", "languageoding", "equlocking", "equoding", "decasing", "Encoding", "encoded", "encryption", "Encasing", "decoded", "enclocking", "languagelocking", "casing", "decryption", "languageging", "Encoded", "Encryption", "coding", "encpling", "languagepling", "cryption", "equging", "Enclocking", "equpling", "encging", "decoding", "Encpling", "encasing", "coded"], "testURL": ["TestURL", "testingURL", " testTL", "testRL", "testUR", " testURI", "fileURL", "shorturl", "fileURI", " testRL", "TestUR", "testurl", "testUrl", "shortUrl", "appURL", "appUrl", "Testurl", "fileUrl", "appUR", " testUrl", "testingUR", " testurl", "testTL", "shortURL", "TestUrl", "testingUrl", "testURI", "shortTL", "testingTL", "testingurl", "testingRL", "appurl", "fileRL", "testingURI"], "input": ["flow", "text", "source", "form", "init", "result", "output", "current", "out", "client", "path", "inner", "ac", "instance", "config", "dc", "through", "this", "Input", "i", "socket", "conn", "image", "inside", "data", "in", "resource", "binary", "act", "img", "bin", "error", "ink", "url", "inf", "null", "ou", "active", "exec", "api", "ack", "rc", "upload", "connection", "enc", "stream", "qa", "wrapper", "raw", "but", "acl", "element", "file", "temp", "parent", "pull", "ssl", "feed", "op", "entry", "reader", "type", "get", "inc", "xml", "audio", "http"], "sw": ["work", " SW", "rx", "sb", "fp", "rew", "wt", "w", "wp", "hw", "writer", "web", "ib", "we", "SW", "ws", "io", "sa", "ww", "wx", "sm", "aw", "tw", "cr", "sc", "wr", "sl", "rc", "sk", "now", "rw", "stream", "wrap", "nw", "wrapper", "sh", "Sw", "en", "sn", "WS", "wb", "sf", "iw", "ow", "sv", "ew"]}}
{"id1": "16760971", "id2": "18005010", "code1": "    public static String generateHash(String key) {\n        key += \"use_your_key_here\";\n        MessageDigest md;\n        try {\n            md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            StringBuffer buff = new StringBuffer();\n            for (int l = 0; l < bytes.length; l++) {\n                String hx = Integer.toHexString(0xFF & bytes[l]);\n                if (hx.length() == 1) buff.append(\"0\");\n                buff.append(hx);\n            }\n            return buff.toString().trim();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    private void setProfile(String loginName, SimpleUserProfile profile) throws MM4UCannotStoreUserProfileException {\n        try {\n            OutputStream outStream = null;\n            URL url = new URL(this.profileURI + profile.getID() + FILE_SUFFIX);\n            if (url.getProtocol().equals(\"file\")) {\n                File file = new File(url.getFile());\n                outStream = new FileOutputStream(file);\n            } else {\n                URLConnection connection = url.openConnection();\n                connection.setDoOutput(true);\n                outStream = connection.getOutputStream();\n            }\n            OutputStreamWriter writer = new OutputStreamWriter(outStream);\n            Enumeration myEnum = profile.keys();\n            while (myEnum.hasMoreElements()) {\n                String key = myEnum.nextElement().toString();\n                if (key != \"id\") writer.write(key + \"=\" + profile.getStringValue(key) + System.getProperty(\"line.separator\"));\n            }\n            writer.flush();\n            writer.close();\n        } catch (Exception e) {\n            throw new MM4UCannotStoreUserProfileException(this, \"setProfile\", e.toString());\n        }\n    }\n", "label": 0, "substitutes": {"generateHash": ["generateKey", "generatedMac", " GeneratedSalt", "generateMac", "generateSalt", "generatedSalt", "generoseMac", "generatedHash", "generatesMac", " GeneratedKey", " GenerateHash", " GenerateSalt", "generatesHash", "generatedKey", " GenerateMac", "generatesSalt", "generatesKey", " GeneratedHash", " GeneratedMac", "generoseSalt", " GenerateKey", "generoseKey", "generoseHash"], "key": ["keys", "path", "string", "address", "fee", "base", "ace", "id", "self", "token", "user", "proof", "message", "hex", "char", "password", "type", "rule", "mac", "ce", "seed", "date", "connection", "KEY", "str", "cy", "work", "data", "file", "Key", "text", "body", "msg", "name", "word", "full", "prefix", "url", "k", "pe", "secret", "pair", "point", "sign", "block", "crypt", "cert", "hash", "code", "trust"], "md": ["editor", "mem", "mag", "df", "bd", "od", "Cmd", "amd", "clean", "mail", "message", "mo", "ma", "am", "dr", "wd", "MD", "dc", " MD", "ms", "sm", "ld", "ad", "rpm", "cm", "mage", "mt", "mb", "d", "mac", "dh", "mp", "hd", "pm", "pd", "mm", "nd", "metadata", "cd", " Md", "dig", "po", "m", "hm", "dm", "mand", "mc", "nm", "di", "mod", "me", "ds", "bm", "rm", "mg", "mad", "cmd", "dd", "hash"], "bytes": ["keys", "zip", "bis", "bles", "pages", "pieces", "les", "outs", "s", "bs", "errors", " bits", "parts", "gb", "items", "lines", "binary", "blocks", "bps", "ops", "strings", "data", "vals", "objects", "fb", "ips", "es", "Bytes", "ls", "vs", "ones", "seconds", "cells", "rows", "files", "values", "pins", "b", "words", "os", "bits", "codes", "boot", "letters"], "buff": ["uff", "buffer", "bis", "Buffer", "bf", "bd", "eb", "py", "cb", "html", "obb", "bo", "fw", "kb", "ff", "pb", "cpp", "uf", "txt", "bag", "gb", "mb", "abb", "cp", "sb", "pp", "buf", "diff", "ob", "amp", "flat", "tmp", "fb", "cast", "append", "bb", "agg", "nb", "ctx", "hack", "Buff", "app", "tt", "bug", "b", "ph", "bm", "tf", "f", "batch", "fx"], "l": ["i", "lu", "n", "kl", "lb", "lp", "c", "j", "z", "o", "col", "il", "length", "ly", "jl", "el", "pl", "dl", "fl", "la", "d", "lc", "ell", "li", "al", " L", "cl", "h", "p", "ll", "x", "u", "nl", "le", "ls", "e", "t", "sl", "rl", "ln", "v", "b", "bl", "ul", "lv", "ol", "f", "L"], "hx": ["hmx", "hmxa", "dhc", "Hy", " hrx", " hy", "hex", "Hwx", "Hex", "Hrx", " hxa", "hsxc", "hxa", " hxs", " hc", "dhex", "hwx", "hsrx", "hxc", "hmy", "hxs", "Hc", " hxc", "dhxc", "hsx", " hwx", "hmxs", "Hxa", "hc", " hex", "hy", "hswx", "Hx", "dhx", "Hxc", "hrx", "Hxs"]}}
{"id1": "1097146", "id2": "7372311", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 1, "substitutes": {"getMessageDigest": ["getMessagedigester", "getContentdigester", "getMessageDigifier", "getContentDigifier", "getMessagedigests", "getMessagedigifier", "getMessageEncester", "getMessageEncests", "getContentDigest", "getContentdigifier", "getMessageSignest", "getContentDigester", "getMessageEncifier", "getMessageEncest", "getMessageSignester", "getMessageDigests", "getMessagedigest", "getMessageSignests", "getMessageDigester", "getMessageSignifier", "getContentDigests", "getContentdigests", "getContentdigest"], "input": ["temp", "plus", "accept", "stream", "container", "string", "instance", "context", "request", "xml", "str", "inner", "state", "self", "empty", "list", "this", "in", "content", "object", "address", "audio", "amp", "document", "out", "element", "model", "definition", "config", "now", "array", "Input", "i", "password", "image", "inf", "output", "argument", "data", "type", "raw", "submit", "parse", "null", "reader", "target", "message", "parent", "source", "buffer", "text", "binary", "form"], "md": ["dc", "df", "mb", "mg", "mp", "ms", "pm", "od", "mand", "cm", "mac", "rm", "m", "sm", " MD", "um", "d", "sha", "di", "MD", "bd", "meta", "wd", "M", "dd", "mc", "mod", "cmd", "mn", "dr", "ma", "mag", "am", "gd", "dm", "nm", "amd", "rpm", "mm", "metadata", "vd", "bf", "mad", "mt", "me", "bm", "mo"], "bytes": ["pages", "Bytes", "classes", "words", "codes", "bs", "bps", "string", "ies", "lines", "values", "bits", "outs", "bles", "files", "groups", "seconds", "address", "tes", "pieces", "gb", "base", "s", "strings", "keys", "its", "blocks", "units", "vals", "data", "parts", "ipes", "b", "null", "es", "binary", "les", "body", "odes", "rows"]}}
{"id1": "17630906", "id2": "12417893", "code1": "    public static int[] sortAscending(float input[]) {\n        int[] order = new int[input.length];\n        for (int i = 0; i < order.length; i++) order[i] = i;\n        for (int i = input.length; --i >= 0; ) {\n            for (int j = 0; j < i; j++) {\n                if (input[j] > input[j + 1]) {\n                    float mem = input[j];\n                    input[j] = input[j + 1];\n                    input[j + 1] = mem;\n                    int id = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = id;\n                }\n            }\n        }\n        return order;\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"sortAscending": ["sortAascEND", "sortUscending", "sortAscend", "sortUascending", "sortUascend", "sortASCEND", "sortAascend", "sortAescEND", "sortAascending", "sortAscender", "sortASCender", "sortAascender", "sortUascender", "sortUascEND", "sortAescend", "sortAscEND", "sortUscender", "sortAescending", "sortASCending", "sortASCend", "sortAescender", "sortUscend", "sortUscEND"], "input": ["request", "image", "error", "in", "position", "accept", "progress", "batch", "element", "alpha", "argument", "stream", "entry", "up", "output", "form", "view", "object", "load", "context", "flow", "dict", "version", "instance", "feed", "parent", "select", "address", "integer", "inf", "result", "format", "target", "array", "index", "audio", "pull", "single", "xml", "img", "raw", "value", "out", "now", "work", "key", "area", "null", "model", "update", "data", "type", "Input", "text", "table", "string", "list", "sample", "filter", "field", "event", "current", "source", "config", "initial"], "order": ["request", "position", "process", "image", "error", "sort", "attr", "element", "block", "asc", "key", "output", "use", "app", "map", "default", "user", "Order", "instance", "rank", "parent", "enter", "page", "reverse", "after", "version", "rule", "e", "address", "info", "group", "ordering", "result", "code", "array", "grade", "index", "only", "work", "date", "count", "now", "root", "end", "ordered", "class", "type", "are", "err", "comment", "er", "test", "orders", "force", "search", "record", "call", "name", "table", "style", "list", "seed", "event", "sign", "move"], "i": ["ind", "ai", "ip", "m", "h", "p", "ie", "n", "ik", "is", "key", "fi", "ix", "J", "e", "phi", "ci", "gi", "jit", "ui", "info", "li", "index", "ii", "io", "ori", "iu", "z", "ini", "ij", "bi", "start", "x", "pi", "f", "iter", "o", "xi", "api", "ri", "u", "ni", "b", "y", "v", "ji", "mi", "di", "l", "si", "qi", "uri", "I"], "j": ["job", "fr", "m", " dj", "oj", "p", "n", "g", "br", "obj", "q", "key", "ie", "uj", "J", "jen", "ix", "e", "section", "jit", "json", "aj", "ui", "adj", "jj", "ja", "dj", "li", "ii", "jl", "z", "bj", "ij", "x", "f", "o", "k", "jp", "u", "b", "y", "v", "ji", "jc", "je", "l", "d", "js", "si", "jet", "qi", "kj", "jo"], "mem": ["dim", "ind", "image", "ip", "mm", "mo", "m", "max", "dem", "lim", "nt", "md", "ui", "info", "um", "ram", "mini", "sum", "Mem", "ref", "num", "mb", "buff", "pool", "img", "value", "count", "dist", "part", "fun", "len", "cpu", "mind", "data", "mi", "mor", "mp", "memory", "name", "dev", "vm"], "id": ["ind", "ip", "in", "max", "n", "key", "is", "init", "kind", "oid", "Id", "mid", "ID", "info", "code", "a", "index", "num", "ref", "z", "count", "end", "x", "start", "uid", "area", "base", "sid", "data", "type", "b", "offset", "ids", "name", "d", "pid", "kid"]}}
{"id1": "19335986", "id2": "812803", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["CaughtException", "uncachedexc", "uncatchedexc", "uncaughtEvent", "CatchedEvent", "Catchedexc", "Caughtexc", "uncaughtexc", "uncachedEvent", "uncachedException", "uncatchedException", "unchandledException", "unchandledexc", "CatchedException", "uncatchedEvent", "CaughtEvent", "unchandledEvent"], "t": ["n", "c", "l", "s", "te", " T", "ty", "type", "d", "r", "g", "w", "out", "p", "ts", "let", "title", "m", "tree", "ing", "it", " td", "T", "tr", "ed", "f", "tx"], "e": ["event", "fe", "i", "ace", "ee", "be", "ie", "eb", "c", "ge", "j", "se", "o", "s", "el", "ception", "ele", "en", "ec", "er", "d", "ce", "diff", "r", "data", "de", "exc", "ep", "p", "es", "ae", "environment", "ne", "eu", "example", "m", "E", "ev", "ed", "pe", "me", "err", "f", "error", "oe", "Exception", "element", "code", "enter", "esi"], "display": ["play", "fe", "console", "panel", "report", "profile", "description", "window", "host", "layout", "content", "monitor", "scroll", "d", "hide", "show", "default", "config", "de", "body", "page", "object", "p", "style", "dis", "status", "image", "screen", "Display", "position", "app", "me", "summary", "design", "container", "process", "this", "view", "platform"], "shell": ["hell", "buffer", "console", "server", "copy", "lock", "mail", "system", "echo", "l", "child", "host", "el", "clone", "loop", "tools", "sb", "live", " Shell", "machine", "math", "body", "cl", "launch", "h", "environment", "log", "bash", "m", "exec", "image", "status", "Shell", "ml", "kernel", "sym", "app", "sh", "sound", "b", "poll", "container", "process", "xml", "help", "gui", "cli", "tool"], "message": ["event", " exception", "address", "buffer", "translation", "mess", "console", "server", "output", "copy", "response", "report", "mail", "document", "description", "result", "management", "queue", "content", "monitor", "email", "member", "value", "media", "model", "application", "data", "body", "page", "object", "request", "flash", "Message", "log", "msg", "header", "m", "meter", "status", "image", " messenger", "update", "summary", "xml", "essage", "error", "view"], "e1": [" e3", "e3", "exc2", "e8", " e2", "E1", "e2", "E3", "E2", " e8", "E8", "exc3", "exc8", "exc1"]}}
{"id1": "4223002", "id2": "13414771", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getPasswordMD5": ["getPasswordMAC512", "getpasswordMD512", "getPasswordMac256", "getPasswordMD1", "getPasswordMAC256", "getpasswordMD1", "getpasswordSHA1", "getpasswordMD256", "getpasswordMD5", "getPasswordSHA5", "getPasswordMAC1", "getPasswordMac1", "getPasswordMac5", "getPasswordMD512", "getpasswordSHA256", "getPasswordMD256", "getPasswordMAC5", "getpasswordSHA5", "getPasswordSHA1", "getpasswordSHA512", "getPasswordMac512", "getPasswordSHA512", "getPasswordSHA256"], "algorithm": ["calgorith", "algebra", "algo", "aggo", "geest", "gem", " alm", "Alignment", "alger", "agignment", "fgorithm", "Algebra", "Alger", "fgo", "Algorithm", " algorith", " alignment", "Alest", " alger", "geger", " algo", "alm", " alphabet", "fgorith", "alrator", "Algorith", "aggorithm", "omalgo", "omalgorith", "Alrator", "omalgorithm", "calgo", "alphabet", "Alm", "calgorithm", "calgebra", "omalphabet", "alignment", "Alphabet", " alest", "agrator", "alest", "fgebra", "gegorithm", " alrator", "Algo", "algorith"], "messageDigest": ["messageMDester", " messageDigString", " messageDigEST", "messageDester", "messageDEST", "messageMDest", "messageDest", "phraseDigested", "messagedigester", "MessageDigested", "phrasedigester", "messageDigester", "messagedigEST", " messageDigester", "MessageDigEST", "messageDested", "messageDigString", "messageModested", "messagedigested", "MessageModEST", "messageMDString", "phraseDigest", "messagedigString", "messageDigEST", "MessageDigest", " messagedigest", " messagedigester", "MessageModester", "phrasedigEST", "messageDigested", "phrasedigest", "MessageModest", "messageMDEST", "phraseDigEST", "MessageModested", "phrasedigested", " messagedigString", "messageModEST", "messagedigest", " messagedigEST", "messageModString", "messageModest", "phraseDigester", "MessageDigester", "messageModester"], "hexString": ["byteStream", "checkStr", " hexArray", "textBuffer", " hexStream", "shortBuffer", "checkString", " hexStr", "checkFunction", "hexstring", " hexLine", "hashBuffer", "hexArray", "byteArray", "hexFunction", "shortString", "checkBuffer", "byteLine", " hexFunction", "hexLine", "textstring", "shortstring", "textLine", "hashFunction", "hashString", " hexBuffer", "textStream", "hashStr", "textArray", "byteString", "hexBuffer", "hexStream", "hexStr", "shortArray", " hexstring", "textString"], "i": ["r", "ai", "in", "m", "h", "p", "j", "n", "key", "s", "multi", "fi", "slice", "ix", "e", "phi", "id", "mu", "ci", "gi", "abi", "t", "ui", "info", "a", "zi", "li", "index", "ii", "io", "bi", "end", "x", "pi", "f", "o", "xi", "ti", "ri", "type", "u", "b", "v", "oi", "mi", "di", "volume", "l", "hi", "d", "si", "chi", "uri", "I", "c"]}}
{"id1": "421042", "id2": "4830847", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "label": 0, "substitutes": {"url": ["source", "ref", "filename", "buffer", "uri", "path", "Url", "f", "config", "link", "l", "image", "loc", "loader", "service", "location", "resource", "www", "io", "base", "name", "bel", "null", "server", "host", "URL", "rl", "sl", "address", "string", "connection", "fr", "ur", "el", "ll", "lr", "html", "file", "ssl", "feed", "href", "ob", "id", "xml", "http"], "in": ["source", "as", "init", "inn", "gin", "out", "token", "pin", "inner", "c", "f", "config", "this", "ex", "i", "input", "socket", "serv", "conn", "inside", "image", "val", "or", "IN", "data", "m", "ini", "con", "resource", "n", "io", "isin", "a", "bin", "din", "is", "nin", "min", "ins", "In", "impl", "again", "rin", "file", "part", "err", "r", "login", "ssl", "id", "reader", "inc", "xml", "cms"]}}
{"id1": "15799935", "id2": "20100809", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedBody", "saveAppensionFile", "saveAttachedbody", "saveAppachmentBody", "saveAppensionPart", "saveAppachmentPart", "saveAttensionPart", "saveAppachmentbody", "saveAppachmentFile", "saveAttachmentbody", "saveAttensionBody", "saveAttachmentPart", "saveAppensionbody", "saveAppensionBody", "saveAttensionbody", "saveAttPartbody", "saveAttachmentFile", "saveAttachedFile", "saveAttensionFile", "saveAttPartFile", "saveAttachedPart", "saveAttPartBody", "saveAttPartPart"], "context": ["resource", "subject", "media", "container", "support", "project", "front", "c", "cache", "Context", "host", "ca", "request", "present", "current", "view", "environment", "service", "state", "concept", "input", "cca", "manager", "ctx", "contact", "text", "queue", "network", "cms", "driver", "cf", "ce", "content", "translation", "document", "mc", "connection", "event", "coll", "component", "definition", "config", "system", "processor", "center", "reader", "kernel", "channel", "message", "parent", "community", "client", "collection", "version", "template"], "part": ["or", "section", "media", "position", "Part", "channel", "area", "comment", "phase", "service", "state", "partial", "Parts", "patch", "from", "place", "object", " Part", "mission", "translation", "p", "app", "connection", "base", "chapter", "upload", "component", "event", "per", "block", "pre", "image", "start", " parts", "plan", "to", "PART", "html", "parts", "type", "pod", "point", "po", "message", "parent", "source", "body", "name", "art", "file"], "localAttachment": ["localAddail", "localExtention", "localAddachment", "LocalAssachment", "localAttment", " localExtachment", "localPartachment", "localAddention", "localAssention", "localInstribution", "LocalAttment", "localAssachment", "localAttachacher", "localExtacement", "localAttachachment", " localExtacher", "localAttacement", "localattrollment", "localAddment", " localAttrollment", "localInstension", "localAttachribution", "localArtention", " localAttacement", " localAttachachment", "localAssment", "localAvacher", "localAssail", "localAttacher", "LocalAttention", "localAttachension", "LocalAssail", "localattment", "localAttribution", " localAttribution", "localattachment", " localPartention", "localPartension", "LocalAssention", "localAttachacement", "localAvachment", "localAvention", "localattention", "localAvacement", "localAttrollment", "localAttail", "localArtachment", "LocalAttail", "LocalAttachment", " localPartachment", " localAttention", " localPartribution", "LocalAssment", "localPartention", "localArtail", "localAddrollment", " localExtacement", " localAttension", "localInstachment", " localExtention", "localExtachment", "localAttachention", " localAttachrollment", "localAttention", "localExtacher", " localAttachention", " localAttacher", " localAttment", "localPartribution", "localArtment", "localAttachrollment", " localPartension", "localInstention", "localAttension"], "accountId": ["AccountName", "accountName", "feedName", "accId", "jobName", "accInfo", "jobid", "appID", "contractid", "contactId", "jobId", "feedId", "jobID", "AccountID", "appInfo", "accid", "feedid", "accountInfo", " accountInfo", "feedID", "contactid", "accID", "contactName", " accountid", "accountid", " accountID", " accountName", "appId", "Accountid", "AccountId", "accountID", "contractId", "contractName", "appid"], "attachmentId": ["attentionInfo", "attachmentID", "attentionid", "extensionid", "attachmentUrl", "attmissionId", "addentionUrl", "attachmentName", "attentionIndex", "attagramID", "attmissionID", "attmentID", "attentionID", "atachmentReference", "attmentName", "attachmentSource", "attociationID", "atachmentName", "adentionId", "attptionId", "attachmentType", "extensionID", "attensionid", "attociationName", "attachedID", "adentionIndex", "attptionIndex", "extensionId", "attmentReference", "atociationName", "adentionID", "adachmentIndex", "extachmentId", "extachmentSource", "attlementId", "attentionId", "attlementReference", "atociationId", "atachmentId", "addentionId", "attachedType", "attachmentInfo", "addachmentID", "extachmentID", "attentionType", "attociationReference", "adachmentId", "attptionID", "attagramIndex", "atachmentID", "attensionId", "attagramInfo", "attentionSource", "addentionType", "addachmentType", "attentionUrl", "extachmentid", "attmissionSource", "attachmentIndex", "atociationReference", "attensionID", "attachedId", "attmissionid", "adachmentID", "addentionID", "addachmentId", "attachedUrl", "attmentId", "attachmentid", "extensionSource", "attlementName", "attagramId", "atociationID", "attachmentReference", "attlementID", "attociationId", "adachmentInfo", "adentionInfo", "addachmentUrl", "attensionSource", "attociationUrl", "attptionInfo", "attociationType"], "in": ["In", "or", "pull", "plus", "pass", "again", "ini", "IN", "cin", "is", "inner", "din", "bin", "input", "copy", "as", "con", "slice", "pin", "ins", "ac", "conn", "inn", "p", "err", "it", "up", "init", "url", "load", "gin", "f", "inside", "i", "nin", "a", "image", "socket", "login", "reader", "data", "inc", "id", "info", "source", "file"], "saveIn": ["writein", "aveIn", "stageAs", "aveOut", "aveAs", "saveIns", "savIn", "savin", " savein", "writeIN", "stageIn", "saveOut", "stageIns", "SaveAs", "SaveOut", "SaveIn", " saveOut", "aveIN", "savAs", "writeOut", "stageOut", "savein", "writeIn", "saveIN", "savOut", " saveIns", "SaveIns", "avein", " saveIN"], "saveAs": ["createAt", "createAS", "createFile", "saveFile", "openFile", "SaveAS", "saveAt", "saveOut", " saveFile", "SaveAs", "SaveOut", "openAt", "SaveIn", "copyIn", " saveOut", " saveAS", "writeAS", "copyas", "Saveas", " saveAt", "writeAs", "writeOut", "openAS", "writeIn", "openAs", "saveas", "copyAs", "copyAS", "saveAS", " saveas", "createAs"], "out": ["temp", "plus", "line", "at", "again", "string", "c", "cache", "o", "ex", "inner", "bin", "Out", "copy", "as", "path", "outer", "io", "outs", "this", "sync", "conn", "err", "up", "default", "init", "s", "exec", "other", "off", "a", "image", "to", "writer", "v", "page", "output", "ext", "data", "OUT", "null", "inc", "source", "client", "name", "file", "flow"], "copySize": ["savesize", "byteSize", "CopyTime", "lesize", "openSIZE", "openSize", "copyTime", " copyTime", "copyLength", "byteTime", "byteAddress", "leSize", "CopyLength", "bytesize", "leLength", "leSIZE", "copySIZE", " copyAddress", "CopySize", " copyLength", "saveLength", " copysize", "openLength", "copyAddress", "copysize", "opensize", "saveAddress", "saveSize", "byteLength", " copySIZE", "Copysize"], "contentUriString": ["contentUiostring", "contentUpiStr", "contentIriNumber", "contentUriUnit", "contentUridUnit", "contentUuriStr", "contentUrisUnit", "contentUrisString", "contentIriUnit", "contentUpiInt", "contentUiString", "contentUuriString", "contentUrisStr", "contentUiniString", "contentIiStr", "contentIrisInt", "contentUridStr", "contentIiByte", "contentIriStr", "contentUristring", "contentIriInt", "contentIriByte", "contentUuriNumber", "contentIristring", "contentIrisStr", "contentUiNumber", "contentUiniStr", "contentUiUnit", "contentIiString", "contentUiniNumber", "contentUriNumber", "contentUriInt", "contentUrisstring", "contentIrisstring", "contentUiStr", "contentUridString", "contentUioString", "contentIiNumber", "contentIriString", "contentUriByte", "contentUiByte", "contentIrisString", "contentUioStr", "contentUpiString", "contentUioInt", "contentIrisUnit", "contentUriStr", "contentUiniByte", "contentUpistring", "contentUrisInt", "contentUuriByte"], "mSize": ["iName", "cName", "pLength", "iLength", "cSize", "cCount", "cLength", "iSize", "iCount", "mCount", "pCount", "mLength", "pName", "mName", "pSize"], "mContentUri": ["mResourceUci", "mResourceIris", "mContentOUric", "mContentUrri", "mContentUris", "mResourceUris", "mContentOUci", "mContentIci", "mContentUrris", "mContentUci", "mContentUrric", "mResourceIric", "mResourceUric", "mContentIri", "mContentOUris", "mContentOUri", "mResourceUri", "mContentIris", "mContentUric", "mContentUrci", "mResourceIri", "mResourceIci", "mContentIric"], "cv": ["VC", "que", "ctrl", "auc", "nv", "fc", "cm", "GV", "c", "vv", "ca", "pb", "um", "cover", "CV", "conv", "xc", "ctx", "sc", "co", "buf", "uv", "cf", "cu", "iq", "content", "loc", "vm", "cc", "cr", "mc", "cd", "vc", "csv", "rc", "vs", "cp", "coll", "cs", "bc", "enc", "lv", "av", "cap", "vr", "uc", "cb", "fp", "v", "lc", "sv", "nc", "iv", "ov", "keep", "core", "vp"], "uri": [" scheme", "resource", " ur", "attribute", "route", "qi", "username", " Uri", "string", "href", "pi", "oid", "environment", "universal", "http", "proxy", "uid", "ci", "path", "api", "ui", "ri", "address", "URI", "gb", "base", " URI", "storage", "prefix", "url", "query", "location", "cli", " url", "i", "iri", "format", "range", "mi", "data", "point", "metadata", "id", "iv", "uni"]}}
{"id1": "13644374", "id2": "3430784", "code1": "    public byte[] getBytesFromUrl(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toByteArray(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 0, "substitutes": {"getBytesFromUrl": ["getbytesFormUrl", "getBytesFormString", "getBytesFromString", "getBytesFromRoute", "getbytesFormRoute", "getbytesFormString", "getbytesFormURL", "getBytesfromUrl", "getBytesfromRoute", "getBytesFormURL", "getBytesFromURL", "getBytesViaString", "getbytesFromUrl", "getBytesfromString", "getBytesViaRoute", "getBytesViaUrl", "getBytesFormUrl", "getBytesFormRoute", "getBytesfromURL", "getbytesFromRoute", "getbytesFromString", "getBytesViaURL", "getbytesFromURL"], "url": ["connection", "sl", "data", "loc", "name", "email", "ur", "method", "download", "str", "xml", "base", "page", "href", "l", "key", "address", "Url", "i", "URL", "buffer", "service", "source", "api", "request", "path", "server", "uri", "route", "http", "resource", "result", "host", "ref", "location", "json", "string"], "get": ["open", "start", "create", "method", "put", "handle", "body", "send", "load", "find", "set", "gets", "query", "e", "client", "pull", "call", "service", "i", "cli", "build", "parse", "api", "request", "Get", "exec", "like", "GET", "update", "read", "http", "resource", "execute", "use", "json"], "response": ["full", "connection", "f", "data", "tree", "error", "respond", "method", "body", "application", "received", "Response", "status", "page", "output", "content", "success", "e", "reply", "feed", "api", "request", "object", "document", "server", "http", "wave", "message", "result", "resource", "out", "report", "onse", "json", "resp"], "entity": ["connection", "data", "el", "body", "info", "event", "xml", "model", "page", "node", "output", "instance", "content", "ale", "collection", "e", "translation", "this", "entry", "image", "Entity", "api", "object", "environment", "document", "server", "null", "pe", "person", "http", "metadata", "file", "message", "action", "resource", "result", "security", "json", "ent", "element", "resp"]}}
{"id1": "15799935", "id2": "6470716", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedFile", "saveAppensionPart", "saveAttachedBody", "saveAttPartBody", "saveAppachmentBody", "saveAppensionBody", "saveAttensionBody", "saveAttachedPart", "saveAppachmentPart", "saveAttachedbody", "saveAttachmentbody", "saveAttachmentFile", "saveAppensionFile", "saveAttensionFile", "saveAttensionbody", "saveAppachmentbody", "saveAttachmentPart", "saveAttPartFile", "saveAppachmentFile", "saveAttPartPart", "saveAttensionPart", "saveAppensionbody", "saveAttPartbody"], "context": ["text", "component", "subject", "message", "resource", "parent", "view", "connection", "system", "ce", "event", "version", "project", "channel", "definition", "document", "input", "mc", "coll", "translation", "template", "support", "community", "container", "Context", "cca", "driver", "config", "cms", "client", "media", "contact", "reader", "center", "network", "queue", "cache", "present", "c", "service", "kernel", "ctx", "host", "environment", "cf", "current", "state", "concept", "front", "ca", "content", "collection", "manager", "request", "processor"], "part": ["art", "to", "partial", " Part", "component", "message", "image", "parent", "html", "body", "connection", "event", "parts", " parts", "channel", "area", "block", "Parts", "translation", "phase", "type", "comment", "source", "mission", "section", "plan", "media", "PART", "pod", "base", "place", "point", "position", "Part", "object", "po", "patch", "file", "chapter", "upload", "start", "app", "name", "service", "per", "pre", "or", "state", "from", "p"], "localAttachment": ["localArtment", "LocalAttail", "LocalAssachment", "localAssention", "localAssment", "localAssachment", "localAddachment", "localAttention", "localAddrollment", " localAttention", "localAttachrollment", "LocalAssail", "LocalAttention", "localAttachacher", " localExtention", " localAttribution", "localattention", " localPartention", "localattachment", "localPartachment", " localAttrollment", "localExtachment", " localExtacher", "localAddail", "localAttachachment", " localExtachment", "localAvacement", "localAddment", " localAttacement", "localAvacher", "localAttail", "localInstachment", " localAttachachment", "localPartension", "localPartribution", "LocalAttachment", " localAttachrollment", "LocalAssment", "LocalAttment", " localAttacher", " localExtacement", "localInstension", " localPartension", "localattment", "localAttrollment", "localAttension", "localExtacement", " localAttachention", " localAttension", "localAttachention", "localAttachension", " localPartachment", "LocalAssention", "localArtail", "localAvachment", "localInstention", "localExtention", "localAttachacement", "localAttacement", "localAttachribution", "localExtacher", "localattrollment", " localPartribution", " localAttment", "localAttribution", "localAttment", "localInstribution", "localAssail", "localArtention", "localPartention", "localAddention", "localArtachment", "localAttacher", "localAvention"], "accountId": ["feedName", "AccountName", "accInfo", "jobName", "appID", "contractId", "appid", "jobid", "contactId", "contractName", "accid", "accID", "AccountID", " accountID", "accountName", "feedId", " accountid", "jobId", "accountInfo", "jobID", "AccountId", " accountName", "accountid", "contractid", "appId", " accountInfo", "Accountid", "contactid", "feedid", "appInfo", "accountID", "contactName", "accId", "feedID"], "attachmentId": ["attociationType", "addachmentType", "extensionSource", "atachmentID", "addachmentId", "attachedID", "attentionID", "attensionSource", "attentionIndex", "attagramInfo", "attlementName", "attagramId", "attlementId", "adachmentIndex", "addentionId", "attensionId", "attmissionSource", "attachmentid", "atociationID", "attentionUrl", "attachmentSource", "attociationReference", "attensionID", "addentionID", "attmissionID", "extachmentSource", "adentionId", "atociationId", "attmissionId", "attmentName", "attociationName", "attachmentType", "adachmentId", "attptionIndex", "attachmentID", "attptionInfo", "addentionType", "attachedType", "extensionId", "attachedId", "attociationID", "atachmentReference", "attachmentReference", "attachmentInfo", "attentionInfo", "addentionUrl", "attachmentName", "addachmentID", "attagramID", "extachmentId", "attmentId", "atachmentName", "attensionid", "adentionIndex", "atociationReference", "extachmentID", "extensionID", "attmentReference", "attlementReference", "attachedUrl", "attptionID", "adachmentInfo", "attentionId", "attachmentIndex", "extensionid", "adentionID", "attagramIndex", "attociationId", "atachmentId", "attentionSource", "attentionid", "attmissionid", "attlementID", "adachmentID", "adentionInfo", "attmentID", "addachmentUrl", "attentionType", "attachmentUrl", "attociationUrl", "extachmentid", "atociationName", "attptionId"], "in": ["ins", "url", "image", "In", "copy", "init", "info", "data", "inc", "socket", "gin", "f", "it", "input", "din", "IN", "inn", "conn", "pass", "cin", "i", "is", "source", "pull", "reader", "inside", "nin", "a", "login", "inner", "slice", "id", "ac", "load", "bin", "file", "con", "err", "up", "pin", "ini", "as", "or", "plus", "again", "p"], "saveIn": [" saveOut", " saveIN", " savein", "savein", "SaveOut", "savOut", "stageOut", "saveOut", "aveAs", "savin", "aveIN", "writein", "writeOut", "stageAs", "writeIN", "avein", "stageIn", "stageIns", "aveIn", "saveIns", "SaveIns", "savIn", "savAs", " saveIns", "saveIN", "SaveAs", "aveOut", "SaveIn", "writeIn"], "saveAs": [" saveOut", " saveFile", "SaveOut", "copyAs", " saveAS", "writeAS", "copyAS", "openFile", "saveOut", "copyas", "saveAS", "saveas", "createAS", "copyIn", " saveas", "createFile", "writeOut", "openAt", "createAt", "writeAs", "saveFile", "Saveas", " saveAt", "openAs", "saveAt", "createAs", "SaveAs", "SaveAS", "SaveIn", "writeIn", "openAS"], "out": ["at", "to", "page", "ex", "writer", "default", "flow", "image", "copy", "null", "init", "io", "off", "data", "outer", "this", "sync", "inc", "output", "o", "Out", "s", "conn", "temp", "source", "client", "a", "inner", "outs", "cache", "string", "v", "bin", "file", "c", "err", "exec", "name", "other", "up", "OUT", "path", "as", "plus", "again", "line", "ext"], "copySize": ["opensize", "leSIZE", " copysize", "saveLength", "copysize", "openLength", " copyLength", "leLength", "CopyLength", " copySIZE", " copyAddress", "openSize", "byteAddress", "copyLength", "savesize", "saveAddress", "CopySize", "copyAddress", " copyTime", "lesize", "saveSize", "CopyTime", "leSize", "copyTime", "bytesize", "byteLength", "openSIZE", "byteTime", "copySIZE", "byteSize", "Copysize"], "contentUriString": ["contentIiStr", "contentUriStr", "contentUiniByte", "contentIriStr", "contentUristring", "contentUiniStr", "contentIriUnit", "contentIrisUnit", "contentUiniNumber", "contentUiNumber", "contentUioString", "contentUriUnit", "contentUuriStr", "contentUridString", "contentIriNumber", "contentUpiString", "contentUiostring", "contentUriByte", "contentUridStr", "contentIrisstring", "contentIriString", "contentUiString", "contentUrisStr", "contentUiStr", "contentUioStr", "contentUrisstring", "contentIriInt", "contentUiniString", "contentUpiInt", "contentUrisInt", "contentUuriNumber", "contentUiByte", "contentIrisStr", "contentIrisInt", "contentUpistring", "contentIriByte", "contentUrisString", "contentUuriString", "contentUridUnit", "contentIiString", "contentIiNumber", "contentUrisUnit", "contentUriInt", "contentUioInt", "contentUiUnit", "contentUriNumber", "contentIrisString", "contentIiByte", "contentUuriByte", "contentIristring", "contentUpiStr"], "mSize": ["pSize", "pCount", "iSize", "mCount", "pLength", "pName", "cCount", "mName", "mLength", "iName", "cLength", "cName", "cSize", "iLength", "iCount"], "mContentUri": ["mContentIci", "mResourceUri", "mContentOUric", "mResourceIci", "mResourceIris", "mContentOUci", "mContentIric", "mResourceIri", "mContentUrris", "mResourceUci", "mResourceUric", "mContentUrri", "mContentUris", "mContentUric", "mContentOUris", "mResourceUris", "mResourceIric", "mContentIri", "mContentUrci", "mContentOUri", "mContentIris", "mContentUci", "mContentUrric"], "cv": ["conv", "buf", "cap", "que", "core", "vp", "uc", "cp", "loc", "rc", "sv", "um", "av", "uv", "csv", "bc", "vv", "vr", "vs", "mc", "pb", "iv", "coll", "nc", "cb", "auc", "iq", "cc", "nv", "ctrl", "cu", "cm", "keep", "co", "ov", "xc", "sc", "CV", "lv", "cr", "v", "c", "VC", "fc", "GV", "vc", "ctx", "cf", "cd", "cover", "vm", "lc", "content", "cs", "ca", "enc", "fp"], "uri": ["prefix", "proxy", "attribute", "url", "resource", "data", "username", "universal", " URI", "range", "route", "iv", "storage", "href", "ci", " Uri", "uni", "i", "uid", "metadata", "api", "cli", " url", "mi", "pi", "base", "point", " ur", "id", "address", "string", " scheme", "URI", "gb", "iri", "environment", "path", "ui", "query", "qi", "location", "format", "http", "oid", "ri"]}}
{"id1": "8047989", "id2": "19134229", "code1": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getHashedID": ["getHachedID", "getHashIP", "getHashingUID", "getHashUID", "getShashUID", "getShashedUID", "getHashingID", "getHachedIP", "getShashedIP", "getHashedIP", "getHashedUID", "getHashingId", "getHachedUID", "getHashingIP", "getHashID", "getShashIP", "getHashedId", "getShashedID", "getShashID", "getShashedId", "getHashId", "getShashId", "getHachedId"], "ID": ["DATA", "RI", "NAME", "prefix", "STR", "MAC", "ENT", "AD", "API", "IR", "ED", "INT", "DB", "EXT", "IP", "GET", "IDS", "hash", "Code", "URL", "Id", "IN", "INFO", "Address", "code", "JSON", "Name", "MD", "Path", "SHA", "TEXT", "id", "UID", "string", "URI", "name", "Hash", "IDs", "VERSION", "KEY"], "md5": ["id2", "MD8", "id512", " md8", "cmd25", "id5", "sha512", "sha25", "sha2", "cmd5", "MD512", " md512", " md7", "sha5", " md25", "MD5", " md2", "md7", "md2", "md4", "MD7", "id8", "md25", "md8", "cmd7", "sha7", "MD4", "MD2", " md4", "cmd512", "sha4", "md512"], "digest": ["mdester", "mdse", "longHash", "longse", "Digace", "Digester", "Digest", " digpe", "mdested", "signace", "signest", "codpe", "DigHash", " digests", "codest", "signested", "mdace", "digse", "Digested", "digester", "signester", "Digests", "digests", "codse", "digpe", "mdHash", "digested", "Digse", "mdest", "longests", "Digpe", "digHash", "digace", " digse", "longest", "mdests", "codests"], "bytes": ["ls", "values", "maps", "proxy", "keys", "rows", "Bytes", "details", "body", "letters", "ps", "data", "parts", "ones", "es", "bs", "zip", "vs", "classes", "devices", "lines", "ips", "out", "seconds", "objects", "results", "is", "tes", "pieces", "files", "units", "pages", "ids", "outs", "bits", "base", "address", "id", "string", "errors", "codes", "cells", "binary", "blocks", "words", "content", "services", "strings", "items", "its", "bb", "issues"], "i": ["k", "m", "u", "z", "uri", "e", "j", "b", "n", "fi", "io", "info", "si", "in", "field", "pos", "f", "it", "o", "index", "d", "end", "h", "type", "val", "s", "oi", "ci", "abi", "multi", "li", "l", "di", "hi", "pi", "inner", "xi", "slice", "r", "id", "uli", "ti", "v", "gi", "c", "t", "ri", "I", "ai", "phi", "ii", "ui", "x", "bi", "mu", "qi", "p"]}}
{"id1": "4938100", "id2": "18631594", "code1": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "label": 1, "substitutes": {"sha1": ["sha256", "hash64", "hash1", " SHA64", "hashOne", "shaOne", " SHA1", "hash256", " SHAOne", "SHAOne", " SHA256", "SHA64", "sha64", "SHA1", "SHA256"], "text": ["struct", "txt", "font", "class", "token", "Text", "string", "word", "secret", "str", "version", "input", "EXT", "path", "hex", "number", " Text", "this", "key", "content", "object", "letter", "translation", " TEXT", "connection", "url", "contract", "config", "code", "value", "password", "image", "format", "bytes", "TEXT", "editor", "ext", "test", "output", "data", "message", "pattern", "source", "name", "template"], "UnsupportedEncodingException": ["UnsupportedEncoderception", "UnsupportedEncodedException", "UnsupportedEncoderEx", "UnsupportedEncodedception", "UnsupportedEncasingEx", "UnsupportedEncodedEx", "UnsupportedEncasingception", "UnsupportedEncodingception", "UnsupportedEncasingException", "UnsupportedEncoderException", "UnsupportedEncodingEx"], "md": ["df", "mb", "mg", "mp", "pd", "ms", "pm", "od", "mand", "rm", "mac", "map", "m", "Cmd", "sm", " MD", "d", "sha", "di", "MD", "bd", "meta", "wd", "mode", "hd", "ad", "dd", "valid", "mc", "ld", "cd", "mod", "cmd", "mn", "ma", "mag", "code", "am", "gd", "ind", "hash", "dm", "editor", "nm", "amd", "data", "dig", "mm", "metadata", "bf", "vd", "message", "mad", "mt", "me", "body", "mo"], "sha1hash": ["wa3sum", "sha3sum", "SHA1hash", "sha2address", "sha41hash", "sha1dash", "SHA1sum", "sha1hex", "wa1sum", "SHA2Hash", "sha41sum", "sha001hash", "SHA1address", "sha2sum", "sha5sum", "sha91hash", "SHA2sha", "SHA1sha", "sha4sum", "wa3dash", "sha4hex", "sha1Hash", "sha5hash", "sha3hash", "sha256sum", "SHA2check", "wa3hash", "sha1sum", "sha41address", "SHA1check", "sha2sha", "sha256hash", "wa3hex", "sha41check", "SHA1Hash", "sha1check", "sha256sha", "sha3dash", "sha5Hash", "sha001sum", "sha91address", "SHA2sum", "sha2check", "sha1address", "sha4hash", "sha4dash", "sha2Hash", "wa1dash", "sha91sum", "sha256Hash", "sha3hex", "sha91check", "sha001dash", "sha2hash", "wa1hash", "SHA2hash", "sha5sha", "wa1hex", "sha001hex", "sha1sha", "SHA2address"]}}
{"id1": "12537270", "id2": "9033639", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "label": 0, "substitutes": {"parse": ["report", "ge", " analyse", "se", "patch", "match", "read", "split", "raw", "load", "see", "build", "parser", "open", "format", "ract", "apply", "pack", "update", "ize", "arse", "process", "scan", "xml", "Parser", "eval"], "link": ["path", "string", "info", "base", "address", "lang", "uri", "id", "lock", "Link", "http", "add", "message", "rel", "html", "l", "match", "location", "URL", "line", "tag", "linked", "like", "type", "links", "source", "load", "connection", "data", "file", "text", "route", "li", "local", "page", "inline", "href", "style", "msg", "name", "e", "image", "word", "ln", "bug", "xml", "ink", "loc"], "conn": ["Connection", "ssl", "Conn", "cc", "n", "enc", "rc", "con", "c", "socket", "ctrl", "act", "col", "dr", "rt", "dc", "nc", "er", "client", "nt", "cp", "ct", "connection", "rn", "r", "ch", "open", "config", "ca", "out", "p", "rec", "ai", "ci", "Config", "io", "cr", "ann", "db", "pc", "mc", "ctx", "apt", "err", "connect", "cn", "ac", "pt", "cmd", "pg", "loc"], "rd": ["rw", "dra", "bd", "rc", "RR", "RS", "ru", "rg", "lr", "dr", "rt", "fr", "wd", "dc", "rs", "ld", "RD", "rb", "reader", "rh", "xd", "ra", "rn", "rid", "r", "nd", "RM", "rr", "rss", "rx", "rog", "adr", "fd", "rl", "hr", "ds", "rm", "dd", "sr"], "kit": ["qt", "info", "base", "loader", "Kit", "sci", "feed", "spec", "site", "net", "fit", "py", "et", "pot", "wt", "rt", "ui", "kat", "util", "ku", "rot", "nt", "tools", "sit", "reader", "tk", "lib", "ct", "browser", "cat", "kt", "w", "ut", "config", "h", "p", "plugin", "init", "format", "io", "t", "cr", "kin", "bot", "k", "ki", "bug", "b", "pit", "os", "f", "tool", "api", "auto"], "doc": ["val", "root", "info", "base", "Doc", "http", "docs", "document", "ref", "DOC", "pub", "html", "tag", "dr", "fr", "dc", "in", "config", "d", "dir", "div", "md", "data", "file", "text", "out", "de", "open", "mm", "body", "page", "msg", "po", "desc", "m", "coll", "pos", "dec", "db", "pc", "di", "mc", "tt", "bc", "bug", "ac", "xml", "dom", "f", "tx", "api", "loc"], "url": ["path", "address", "base", "ssl", "server", "uri", "resource", "feed", "http", "lr", "l", "location", "host", "URL", "html", "el", "util", "cdn", "source", "connection", "config", "github", "file", "src", "page", "ll", "log", "href", "name", "image", "blog", "sl", "rl", "pull", "Url", "service", "www", "bug", "ur", "xml", "f", "hub", "gl", "org", "download", "loc"], "it": ["ite", "info", "dit", "id", "ic", "IT", "et", "end", "se", "l", "mit", "in", "iter", "split", "nt", "its", "sit", "stat", "r", "ip", "iterator", "p", "init", "lit", "or", "edit", "ci", "iti", "t", "ait", "you", "v", "st", "It", " It", "pit", "iz"], "elem": [" Eade", "oelem", "eject", " neade", "pelev", "eelements", " nelem", "oelev", "Element", "Elev", " Element", " Eler", "peler", "eler", "oeler", "seject", "Eler", "Elem", "pelem", "Elements", "selem", "eade", "pelement", " nelement", " neler", "Eade", "eeject", "elev", "eelement", "Eject", "eelem", "selement", "elements", "oelement", "selements", " Elem", "element"], "s": ["services", "string", "ssl", "sf", "server", "n", "fs", "spec", "ns", "c", "S", "sch", "se", "o", "set", "si", "rs", "params", "parts", "sync", "session", "ws", "d", "sb", "strings", "ops", "scope", "r", "sv", "g", "attr", "gs", "xs", "h", "p", "es", "u", "ts", "submit", "ls", "js", "e", "m", "sets", "t", "ss", "details", "sl", "sym", "a", "ses", "v", "b", "ds", "os", "f", "ps", "service"], "lnk": ["nlks", "olnkr", "lnok", "dlf", "dlk", "linf", "lenky", "lnku", "knkh", "olnk", "lenke", "dlok", "dnkr", "gnky", "dnf", "lenk", "olnf", "lnke", "dnky", "lnkh", "nlK", "nnky", "lnky", "lnK", "olnK", "dnke", "lnkr", "dlks", "nlkh", "linky", "gnk", "nlke", "nnke", "olnke", "nlok", "linke", "lenku", "gnke", "nlky", "nlk", "nnku", "dnku", "dlky", "lnf", "dnk", "knK", "nnk", "knke", "lenks", "lnks", "gnok", "knk", "olnkh", "dlke", "nlf", "dlkr"], "j": ["index", "info", "job", "uj", "n", "ij", "note", "dj", "ie", "jc", "ind", "z", "o", "jl", "jo", "si", "fr", "ii", "key", "aj", "qi", "syn", "part", "ja", "ji", "pr", "ch", "g", "li", "x", "p", "jj", "ne", "J", "js", "name", "m", "kj", "pos", "jp", "a", "obj", "adj", "ni", "br", "y", "oj", "im"], "urlLink": ["fileHub", "resourceConnect", "urlHub", "urlLine", "fileUrl", "resourceLine", "URLLink", "strlink", " urlPath", "resourceLink", " urlUrl", "URLUrl", "filePath", "UrlPath", " urllink", " urlConnect", " urlLine", "resourcelink", "urlUrl", "urlPath", "urlConnect", "fileLink", "urlPage", "urlRel", " urlPage", "UrlLink", "strLine", " urlRel", "UrlRel", "strLink", "URLRel", "UrlPage", "UrlUrl", "urllink", " urlHub", "URLPage", "strConnect", "UrlHub"], "str": ["sta", "string", "n", "wr", "enc", "res", "inner", "spr", "l", "line", "fr", "dr", "inst", "pass", "char", "arr", "elt", "txt", "Str", "pr", "ctr", "r", "div", "STR", "data", "text", "js", "name", "coll", "t", "cr", "dec", "sl", "tr", "strip", "ext", "hr", "b", "sp", "br", "kr", "st", "err", "obj", "f", "stri", "sr"], "i": ["index", "info", "mu", "id", "n", "pi", "uri", "ini", "yi", "slice", "c", "fi", "ri", "o", "l", "si", "ui", "ii", "in", "ori", "en", "qi", "vi", "ti", "ji", "phi", "chi", "li", "ip", "x", "p", "mi", "bi", "u", "init", "uli", "ai", "oi", "e", "I", "ci", "io", "eni", "zi", "m", "xi", "di", "gi", "hi", "v", "b", "ni", "y", "abi", "iu", "multi", "f", "ix"], "skip": [" bypass", " scan", "cmp", "copy", "replace", "add", "jump", " exclude", "active", "Skip", " skipping", "iter", "loop", " dup", "append", "ips", "empty", " duplicate", "complete", " repeat", "special", " skipped", "sp", "scan", "error", "fast", "stop"]}}
{"id1": "1156851", "id2": "3756429", "code1": "    public void runWeb(String beginURL, String contextRoot, String pageURI) {\n        if (bDebug) System.out.println(\"WEB Path\");\n        List<String> vtURLs = new ArrayList<String>();\n        List<String> vtRobots = getRobots(beginURL, contextRoot);\n        vtURLs.add(\"/\" + contextRoot + \"/\" + pageURI);\n        Indexer indexer = null;\n        IndexDocument indexDoc = null;\n        try {\n            indexer = new Indexer(\"/tmp/tmp/index\");\n            for (String sxURL : vtURLs) {\n                if (bDebug) System.out.println(\"\\n\\n*** INDEXING \" + sxURL);\n                if (bDebug) System.out.println(\"Have - \" + sxURL);\n                boolean bIndexPage = true;\n                if (vtRobots != null) {\n                    for (String sxRobotURL : vtRobots) {\n                        if (bDebug) System.out.println(\"Comparing to - \" + sxRobotURL);\n                        if (sxURL.startsWith(sxRobotURL)) {\n                            if (bDebug) System.out.println(\"Found URL - \" + sxRobotURL + \" - \" + sxURL);\n                            bIndexPage = false;\n                            break;\n                        }\n                    }\n                } else {\n                    bIndexPage = true;\n                }\n                sxURL = beginURL + sxURL;\n                ParserDelegator pd = new ParserDelegator();\n                CallbackHandler cb = new CallbackHandler(vtURLs, bIndexPage, contextRoot);\n                try {\n                    URLConnection urlConn = new URL(sxURL).openConnection();\n                    urlConn.setUseCaches(false);\n                    Date modDate = new Date(urlConn.getLastModified());\n                    if (bDebug) System.out.println(\"\\nMatch - \" + sxURL + \" - Modified Date - \" + modDate);\n                    BufferedReader bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n                    pd.parse(bfReader, cb, true);\n                    if (bIndexPage) {\n                        if (bDebug) System.out.println(\"Adding Index - \" + sxURL + \"\\nContent:\" + cb.getText() + \"\\nSummary:\" + cb.getSummary() + \"\\nTitle:\" + cb.getTitle());\n                        indexDoc = new IndexDocument();\n                        indexDoc.setUID(sxURL + modDate.toString());\n                        indexDoc.setPageURL(sxURL);\n                        indexDoc.setModifiedDate(modDate.toString());\n                        indexDoc.setContents(cb.getText());\n                        indexDoc.setTitle(cb.getTitle());\n                        indexDoc.setSummary(cb.getSummary());\n                        indexer.addDocument(indexDoc);\n                    }\n                } catch (Exception ee) {\n                    PetstoreUtil.getLogger().log(Level.SEVERE, \"Inner Exception\" + ee);\n                }\n            }\n        } catch (Exception e) {\n            PetstoreUtil.getLogger().log(Level.SEVERE, \"Outer Exception\" + e);\n        } finally {\n            try {\n                if (indexer != null) {\n                    indexer.close();\n                }\n            } catch (Exception ee) {\n                ee.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"runWeb": ["runweb", "processWs", "runWs", "runningSite", " runWs", "runningWs", "runningWeb", " runweb", "runningweb", "processSite", "processWeb", "processweb", "runSite", " runSite"], "beginURL": [" beginUrl", "untilurl", "useUR", "beginurl", "startURL", "untilURL", "startUrl", " beginSSL", "useUrl", "startELF", "BeginSSL", "useURI", "endUrl", "untilURI", " beginELF", "beginUR", "startSSL", "BeginELF", "endurl", "BeginURL", "BeginUR", "BeginUrl", "beginURI", "BeginURI", "endUR", "useURL", "endURI", "beginUrl", "endURL", "untilUrl", "beginSSL", "Beginurl", "beginELF"], "contextRoot": ["conceptRoot", "resourcePath", " contextRO", " contextHome", "contextPath", "serviceRO", "conceptBase", "eventRoot", " contextroot", "ContextBase", "ContextPath", "Contextroot", "serviceGround", "ContextRoot", "eventroot", "serviceRoot", "conceptHome", "contextroot", "contextRO", "conceptroot", " contextGround", "ContextGround", "serviceroot", "resourceroot", "resourceRoot", "ContextHome", " contextBase", "contextHome", "contextGround", "contextBase", "ContextRO", " contextPath"], "pageURI": [" pageUR", "siteURL", "PageURI", "PageUR", " pageURL", "pageID", "pageURL", "siteUR", "endUR", "pageUR", " pageuri", "siteURI", "endURI", "PageURL", "endURL", "PageID", " pageID", "enduri", "siteID", "Pageuri", "pageuri"], "vtURLs": ["vtUrli", "vtURS", "vtUrlobs", "VTURls", "vtURLobs", "rtURLS", "VTURLs", "htURls", "VTURi", "htURLParts", "vtGETS", "vtIPS", "vtUrlS", "vtStreams", "vtUrllines", "vtURlines", "vtURLi", "rtURs", "vtURs", "vtURLls", "vtUrls", "vtUrlParts", "vtDownloadS", "vtIPes", "vtUrlls", "vtURls", "vturlls", "tvURLs", "vtURobs", "vtStreamParts", "vtGETs", "rtURLls", "VTURLlines", "vtDownloads", "rtURS", "tvURLes", "vturls", "vtRLes", "tvDownloadS", "vtURLes", "VTURLls", "htURobs", "vtRLs", "vtURParts", "vtURi", "htURs", "vtDownloades", "htURLobs", "htURLls", "vtURLS", "VTURlines", "tvURLS", "htURParts", "vtURLlines", "vtRLS", "vturllines", "vtStreamls", "vturli", "tvDownloades", "vtGETls", "vtURLParts", "rtURLs", "VTURLi", "VTURs", "vtStreamobs", "vtIPs", "tvDownloads", "rtURls", "htURLs"], "vtRobots": ["htRobots", "vtBots", "vtLogs", "vtRobs", "vtPlrots", "vtrobots", "VTRobOTS", "vtrobops", "VTGrougs", "vtBOTS", "htrobots", "vtBs", "VTProops", "vtRobrots", "vtRobops", "VTGroibraries", "vtPlugs", "vtPlibraries", "vtBlots", "vtBlops", "VTRobrots", "VTRobugs", "VTRobs", "vtPlots", "vtRobugs", "vtBops", "htRobOTS", "vtProOTS", "vtBlot", "VTRobibraries", "VTRobops", "htRobot", "vtLogOTS", "vtBlOTS", "VTProOTS", "vtLogops", "VTGrorots", "VTProots", "vtLogots", "vtrobOTS", "VTPros", "vtPros", "htRobops", "vtLegrots", "vtRobibraries", "vtGrorots", "vtBot", "vtLegugs", "vtrobot", "vtGrougs", "VTGroots", "VTRobots", "vtGroibraries", "htrobot", "vtProots", "vtLegots", "vtRobot", "htrobOTS", "vtGroots", "vtProops", "vtLegibraries", "vtRobOTS", "htrobops"], "indexer": ["indexers", " indexReader", " indexe", "Indexer", "indexe", "finder", "IndexER", " indexeer", "Indexeer", "finde", "fixed", " indexers", "indexed", "fixer", "indexReader", " indexER", "indexER", "checkER", "findReader", "checker", "indexeer", "Indexers", " indexed", "checkeer", "checkers", "fixReader", "finded", "fixe"], "indexDoc": ["indexDom", "documentdoc", "IndexDom", "documentPage", "indexdoc", "officePage", "officeDom", "IndexPage", "officedoc", "documentDoc", "IndexDoc", "Indexdoc", "officeDoc", "documentDom", "indexPage"], "sxURL": ["sxiDOM", "sxaUR", "SxURL", "dsxTL", "sxxDB", "dsxurl", "sxDB", "sxeUrl", "pxUrl", "dsxeurl", " sxDB", "sxcUR", "pxURI", "sxaurl", " sexUR", "sxiSSL", "sxcurl", "sexURL", " sxurl", "sxSSL", "sxbUrl", "swwURL", "sXUR", "snexTL", "dsxeUR", "sxLink", "lXSSL", "snexURL", "sxaURL", " sexUrl", "sxbUR", "lxUR", " sxURI", "sfxURL", "sxcURL", "dsxUR", "sfxSSL", "dsxeURL", "sxiUR", "sXDOM", "sexDOM", "sexSSL", "sxxUR", "sXURL", "SxUR", "sxeURL", "sexUrl", "sxeUR", " sXURL", "sxTL", "sXUrl", "pxcURI", "sxxurl", " sxUrl", "swwUrl", "sexurl", "dsxeTL", "sxtUR", "sxcLink", " sxcUrl", "sxaTL", "swwLink", " sxLink", "sxELF", "lxURL", "sfxURI", "sxtURL", "sXELF", "lXDOM", "sxUR", "lXURL", "sXSSL", "snexUR", "sXDB", "lxDOM", "sxtDB", "pxURL", "sxiURL", "lxSSL", " sexURL", " sxUR", "snexurl", "sfxUrl", "sfxUR", "sxtURI", " sexurl", "sxtUrl", " sXDB", "sxxUrl", " sxcUR", "sxturl", "SxELF", "lXUR", "SexELF", "sxcURI", " sxcurl", "dsxURL", "pxcURL", "sxcSSL", "SexURL", "sexELF", "sxeurl", "SexUrl", "sxDOM", "sxcUrl", " sxcSSL", "sxUrl", "sxeTL", " sXUR", " sxcURI", "sxbURL", "sxURI", "SexUR", "sxburl", "SxUrl", "sxurl", "sxeSSL", " sxSSL", "sexUR", "sxcELF", "pxcUrl", "sxxURI", "sxxURL", "swwUR", " sxcURL", "sXurl", " sXurl"], "sxRobotURL": ["sxRoboyPath", "sxRobogurl", "sxRobotTL", "sxRubotURL", "sxLooburl", "sxRobOTTL", "sxRobogURL", "sxRooyURL", "sxRoboyUrl", "sxRobogSSL", "sxRobortTL", "sxRoboURL", "sxLootSSL", "sxRobobCL", "sxRobootURL", "sxLooturl", "sxRobOTURI", "sxRoboburl", "sxRoboUrl", "sxRobotURI", "sxRobOTPath", "sxRobobURL", "sxRobotPath", "sxRubotPath", "sxLootTL", "sxRobotationURI", "sxRobOTCL", "sxLootURL", "sxRobobTL", "sxRoboyUR", "sxRobotUrl", "sxRobotSSL", "sxRootURL", "sxRoboyURL", "sxRobotCL", "sxRobOTURL", "sxRooyUR", "sxRubotUrl", "sxRobobSSL", "sxRobortURL", "sxRobobURI", "sxRoboUR", "sxRootUR", "sxRobOTUrl", "sxRobotUR", "sxRoboturl", "sxRuboURL", "sxLoobURL", "sxRobootTL", "sxLoobTL", "sxLoobSSL", "sxRuboUR", "sxRuboUrl", "sxRobotationURL", "sxRoboPath", "sxRobotationCL", "sxRobobUR", "sxRootTL", "sxRobogTL", "sxRobooturl", "sxRobortUR", "sxRuboPath", "sxRobOTUR", "sxRobootSSL", "sxRubotUR", "sxRooyTL", "sxRoboyTL", "sxRobotationUR"], "pd": [" cp", "lp", "ht", "p", "PD", "md", "ppa", "py", "CB", "bb", "wp", " md", " dd", " DD", "pb", "ds", "Parser", " db", "pg", "dl", "bf", " cd", "pc", " td", "vd", "pi", "gd", "APD", " pp", " PD", "dd", "cpp", "hd", "cd", "parser", " pm", "xd", "pp", "BT", "PF", "PB", " df", "pm", " sd", "d", " dc", " pdf", "td", "bd"], "cb": ["cv", "sb", "cf", "c", "CB", "obb", "bb", "fb", "buff", "cmd", " CB", " dd", "pb", "ca", "ff", "func", "bp", "kb", " db", "bf", " cd", "callback", "bc", "b", "BBC", " bc", "fd", " rc", "rb", "db", "gb", "fn", "eb", "cp", "handler", "cpp", "cm", "fc", "cd", "cod", "Callback", "ob", "ctx", "cmp", "bd", "dc"], "bIndexPage": ["bSearchpage", "bindexTable", "bbSearchPage", " bSearchpage", "bIndexFile", "bindexPage", " bindexpage", " bQueryLine", " bindexLine", "bbIndexpage", " bindexPages", "bLinkPage", " bIndexPages", " bQueryTable", "bbSearchpage", "bLinkFile", "bSearchLine", "bQueryFile", "bQueryLine", "bQueryTable", "nbLinkFile", "nbIndexpage", "bindexpage", "bLinkLine", " bQueryPage", " bIndexFile", "bShortpage", " bIndexTable", "bindexLine", "bShortLine", "bQueryPage", "nbIndexPage", "nbLinkpage", "bShortPage", " bIndexpage", "nbIndexLine", "bbIndexLine", "bSearchPage", "bindexPages", " bindexPage", "bSearchPages", "bSearchTable", "bIndexTable", " bQueryFile", "bIndexPages", "bLinkpage", " bIndexLine", "bIndexpage", "bindexFile", "nbLinkLine", "bLinkPages", "bIndexLine", " bSearchPages", "bbIndexPage", "nbIndexFile", "nbLinkPage", "bSearchFile", " bSearchPage", "bbSearchLine"], "urlConn": ["httpconn", "URLConnect", "serverCon", "urlCo", "UrlConf", "httpConnection", "fileConn", "urlBuff", "fileconn", " urlBuff", "httpConnect", "URLConn", "httpCon", "URLConnection", " urlConnection", "UrlConfig", "urlCon", "urlconn", " urlCon", " urlConnect", "URLConf", "fileConnection", "UrlBuff", "urlConfig", " urlCo", "fileConnect", "URLCo", "httpCo", "httpConn", "urlConnect", "URLconn", "URLConfig", " urlConfig", "URLBuff", " urlConf", "UrlConn", "serverConnect", "serverConn", "urlConf", "urlConnection", "serverConnection"], "modDate": ["MODTime", "ModTime", "ModDay", " modDat", "MODDay", "modDay", "MODDat", "modTime", "ModDate", " modTime", "ModDat", "modDat", " modDay", "MODDate"], "bfReader": ["bdWriter", "bfFile", "bbWriter", "bfRead", "btRead", "bbBuffer", "btWriter", "bdreader", "bfBuffer", "btreader", "BFWriter", "bbRead", "bdBuffer", "BFRead", "BFFile", "bbreader", "bfreader", "btReader", "bdReader", "bfWriter", "BFReader", "btFile", "bbReader", "btBuffer", "bbFile"]}}
{"id1": "22441244", "id2": "1180878", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"send": ["text", "message", "create", "set", "parse", "build", "from", "reply", "open", "export", "execute", "add", "sent", "transfer", "post", "exec", "address", "append", "Send", "write", "submit", "end", "get", "start", "delete", "mail"], "hsession": ["hession", "hesess", "openssession", "hsess", "hsSession", "hhessions", "hhort", "HSsession", "hSession", "hesort", "hsort", "hmSession", "hesession", "hsessions", "opensess", "hmsession", "hhess", "HSessions", "hmessions", "hessession", "opensession", "opensort", "opensessions", "hessions", "hmession", "opensSession", "HSSession", "hssession", "hhsession", "hhSession", "hhession", "HSession"], "session": ["message", "cache", "client", "port", "essions", "ession", "state", "event", "manager", "project", "proxy", "resource", "chat", "document", "class", "mail", "security", "server", "host", "sl", "connection", "parent", "response", "site", "Session", "context", "application"], "repositoryName": ["reposicationName", "reposositoryEmail", "reposessionEmail", "repositoryEmail", "reposicationFamily", "repoositoryNAME", "repositiveEmail", "repositoryPath", "repositoryNAME", "repoitoryEmail", "reposicationAddress", "repoositoryEmail", "repoitoryNAME", "repositiveName", "repoitoryPath", "reposositoryAddress", "reposicleName", "repositoryFamily", "repositiveNAME", "reposositoryFamily", "repoitoryFamily", "reposositoryName", "reposicleFamily", "reposessionNAME", "reposessionName", "repositivePath", "repoositoryFamily", "repoositoryName", "repoositoryAddress", "reposicleAddress", "reposositoryPath", "repoositoryPath", "reposicationEmail", "repositoryAddress", "repoitoryAddress", "repoitoryName", "reposicleEmail", "reposositoryNAME", "reposessionPath"], "ideIdint": ["ideInn", "ideidInt", "ideInints", "ideAuthints", "ideInfoint", "ideNameout", "ideTimeInt", "ideInInt", "IDEidint", "IDENamenumber", "ideAuthInt", "IDEIdints", "ideidint", "IDENameInt", "ideIdn", "IDEIdn", "IDEIdInt", "IDEidInt", "ideidn", "ideIdout", "ideNameint", "ideTimenumber", "ideInfonumber", "IDEidints", "ideAuthint", "ideInfoInt", "ideNameInt", "IDENameout", "ideIdints", "ideTimeint", "ideInint", "IDENameint", "ideNamenumber", "IDEIdnumber", "ideIdInt", "IDEidn", "IDEIdint", "ideIdnumber", "IDEIdout", "ideidints", "ideAuthn", "ideInfoout", "ideTimeout"], "to": ["account", "source", "contact", "message", "top", "about", "summary", "token", "TO", "client", "phone", "uri", "with", "company", "title", "options", "po", "by", "from", "location", "name", "mail", "sub", "address", "target", "prefix", "tel", "To", "settings", "office", "response", "template", "site", "mobile", "reply"], "cc": ["account", "contact", "cs", "phone", "client", "uc", "cf", "ac", "c", "company", "tc", "card", "ca", "ci", "from", "ce", "comment", "ec", "lc", "CC", "cr", "code", "sc", "password", "address", "cus", "rc", "nc", "cl", "cca", "cn", "ct", "ck", "cb", "dc"], "bcc": ["pce", "bbrc", " bck", "abcc", "brc", "abce", "fck", "bbck", "bc", "pc", " bc", "pck", "abck", " bce", "fc", "bbcc", "bce", " brc", "pcc", "frc", "bck", "bbc", "fcc", "abc"], "subject": ["message", "method", "filename", "uri", "phone", "username", "author", "head", "title", "state", "object", "format", "reply", "comment", "description", "reason", "host", "sub", "header", "prefix", "ject", "Subject", "request", "template", "response", "content", "mail"], "body": ["text", "source", "secret", "message", "normal", "style", "summary", "media", "pod", "length", "Body", "empty", "inner", "view", "pass", "how", "tree", "line", "data", "left", "resource", "money", "object", "comment", "description", "shell", "url", "base", "name", "reason", "code", "bound", "password", "function", "zip", "header", "string", "connection", "lock", "plain", "wrapper", "html", "part", "template", "response", "foot", "content"], "attachments": ["Attachments", "messings", "messents", "embedment", "embedments", "messment", "messments", "attachings", "Attachents", "embedents", "embedings", "attachents", "Attachings", "Attachment"], "isHtml": [" isChtml", "isChhtml", "isWhtml", "isHive", "isChive", "isWhive", "isHahtml", "isChtml", " isHttp", "isPhttp", "isPhtml", " isWhail", "isChttp", " isChttp", "isHttp", " isHive", "isHaail", " isWhive", " isWhhtml", " isChhtml", "isCail", " isChail", "isChail", "isWhhtml", "isHhtml", " isHail", " isWhtml", "isHatml", "isHattp", "isWhail", "isCive", "isPhail", "isCtml", "isPhhtml", " isHhtml", "isHail"], "charset": ["chARSete", "charsET", "charsetting", "chasesET", "chearsetting", "CharsET", "Charset", "charseting", "Charsetting", "chansetter", "chasesetting", "chacksET", "charsets", "cheansET", "chackset", "cheansete", "chanspace", "chasetter", "chearspace", "chashesET", "chasET", "chasheset", "chearset", "chaseting", "Charsets", "charsete", "chaspace", "chARSetting", "chaseseting", "chARSet", "chasetting", "chanset", "chansetting", "chearsetter", "charspace", "chasets", "Charseting", "chansET", "chansete", "chARSets", "cheanspace", "chearsete", "chaset", "chacksetting", "chaseset", "cheansetter", "chashespace", "cheanset", "cheansetting", "chARSeting", "chearsET", "chARSET", "charsetter", "chacksete", "chashesetter"], "headers": ["types", " recipients", "writers", "lines", " emails", "ers", "content", "options", "groups", "errors", "names", "strings", "metadata", "authors", "params", " messages", "files", "header", " cookies", "settings", "mails", "users", "properties", "classes", "comments", "status"], "priority": ["secret", " recipients", "mode", "phone", "length", "language", "author", "date", "title", "state", "level", " title", "comment", "class", "security", "reason", "code", "theme", "lang", "quote", "prefix", "queue", "template", "comments", " severity", "status", "reply"], "email": ["account", "text", "contact", "message", "create", "result", "business", "output", "international", "generic", "username", "update", "info", "lex", "model", "event", "view", "e", "note", "enter", "line", "oe", "default", "install", "data", "example", "service", "object", "print", "export", "online", "document", "url", "em", "name", "base", "core", "server", "article", "ext", "password", "zip", "entity", "address", "letter", "external", "element", "el", "Email", "engine", "fax", "auto", "en", "html", "test", "office", "ssl", "template", "response", "liner", "gmail", "ilo", "pm", "xml", "mail"], "user": ["account", "me", "uid", "role", "token", "client", "username", "author", "info", "model", "use", "person", "e", "friend", "USER", "unknown", "data", "object", "resource", "consumer", "ip", "character", "name", "string", "connection", "profile", "plugin", "creator", "users", "er", "member", "id", "type", "people", "mobile", "User"], "identity": ["authentization", "publicITY", "authoronymous", "authentifier", "identITY", "ethnicication", "publicity", "idication", "IdentITY", "authentity", "electricentity", "IDENTities", "personentity", "publiciciary", "identonymous", "authorities", "authentITY", "personifier", "ethnicentity", "identifier", "personITY", "ethnicifier", "electriconymous", "idity", "idization", "installity", "authority", "entityization", "electricity", "authorifier", "IDENTentity", "ethnicITY", "electricITY", "authorentity", "Idententity", "identities", "idententity", "IDENTity", "idifier", "entityonymous", "personity", "identication", "identiciary", "installonymous", "installITY", "authentication", "Identities", "authorication", "ethniciciary", "identization", "authorITY", "publicentity", "authoriciary", "ethnicity", "idonymous", "authentonymous", "IDENTITY", "Identity", "entityifier", "entityity", "installentity", "idITY"], "_returnPath": ["_returnHalf", " _returnHalf", "_relationId", "_resultHalf", "_backPart", "_returnpath", "_inputNode", "_correctId", " _backPath", "_correctDirectory", "_backName", "_relationPath", "_correctPath", " _backPart", "_returnId", "_returnText", "_backHalf", "_responsepath", "_returnUrl", "_replyPart", " _returnUrl", "_returnType", "_returnMid", "_replyPath", " _returnName", "_successId", "_backPath", "_displayNode", "_replyUrl", "_displayMid", "_successDirectory", "_responseType", "_returnPart", "_responsePath", "_returnDirectory", "_inputMid", "_resultTo", "_relationText", "_backTo", "_replyNode", "_backpath", "_relationDirectory", "_replyMid", "_returnTo", "_addType", "_addPath", " _backTo", "_resultName", "_returnNode", "_returnName", " _backName", "_successText", "_displayPart", " _backUrl", " _returnPart", " _backHalf", "_resultPath", "_backUrl", "_displayPath", "_addpath", "_inputUrl", "_backType", "_correctText", " _returnTo", "_inputPath", "_displayUrl", "_successPath"], "_from": ["placefor", " _owner", "_for", " _source", "blockto", "_who", "_with", "workto", "_From", "blockfrom", "placeowner", " _error", " _for", "_source", "existingowner", " _with", "blockerror", "_owner", "blockFrom", "workfrom", "placeto", "existingto", "_error", "workwho", " _From", "existingfor", "placefrom", "worksource", "existingfrom", " _who"], "_replyTo": ["_returnFrom", "_replyOf", "_commentTO", "_commentOf", "_commentFrom", "_addTo", "_reasonFrom", "_addPoint", "_respondAddress", "_respondTO", " _replyTO", "_commentTo", "_closeTo", "_respondTo", "_replyTO", "_closeFrom", "_reasonTO", "_replyAddress", " _replyFrom", "_addAddress", "_returnAddress", "_respondPoint", " _returnTO", "_returnTo", "_returnOf", "_closeOf", " _returnFrom", "_addFrom", "_reasonTo", "_returnTO", "_respondFrom", "_replyFrom", "_returnPoint", "_replyUrl", " _returnTo", "_replyPoint", "_returnUrl", "_respondUrl", " _replyUrl", "_closeTO", "_reasonUrl", " _returnUrl"], "_to": ["_about", "Jfrom", "Jtarget", " _about", "_target", "Jabout", " _target", "Jto"], "_cc": ["_cf", " _cd", " _ce", "_cd", "_ce", " _cf"], "_bcc": ["_sbcc", "_bcs", " _abcc", "_rbcs", " _bce", "_bce", " _bc", "_abce", "_rbc", "_sbc", " _abc", "_sbce", "_bc", "_abcs", "_abcc", "_sbcs", "_abc", "_rbce", "_rbcc", " _abce", " _bcs", " _abcs"]}}
{"id1": "364438", "id2": "20128728", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["oconverted", "subversion", "unverted", "unversion", "converted", "CONverted", " deconverted", "subverted", "Convert", "CONception", "unception", "subvert", " deconversion", "Conversion", "CONvert", "oconverting", "Converting", "Converted", "Conception", "CONverting", "conception", "conversion", "oconvert", "subverting", "converting", " deconverting", "unvert", "oconversion", " deconvert", "CONversion"], "src": ["attr", "source", "ref", "filename", "video", "sb", "fp", "uri", "secure", "st", "path", "username", "feat", "load", "download", "config", "s", "back", "buf", "component", "gz", "input", "ource", "inst", "sin", "loc", "RC", "req", "Source", "sys", "prot", "resource", "img", "storage", "sth", "url", "tmp", "name", "stage", "proc", "spec", "code", "obj", "sel", "sc", "rl", "sit", "supp", "scene", "SourceFile", "rc", "upload", "string", "fn", "rb", "gb", "dist", "stream", "cpp", "impl", "sn", "file", "Dest", "ssl", "slice", "href", "reader", "ctx", "cb", "cmp"], "dest": ["disk", "source", "path", " destination", "home", "txt", "img", "class", "tmp", "null", "cont", "obj", "dist", "dat", "fn", "di", "orig", "test", "std", "temp", "lib", "Dest", "dir", "bin", " dst", "target", "dc"], "in": ["source", "as", "ps", "inn", "pin", "f", "pass", "ex", "i", "input", "inas", "val", "IN", "data", "ini", "win", "n", "up", "isin", "a", "io", "inf", "din", "is", "ins", "stream", "In", "inc", "file", "r", "t", "err", "login", "reader", "bin", "d", "doc"], "p": ["lp", "pre", "tp", "ps", "fp", "py", "c", "f", "np", "s", "wp", "per", "i", "e", "pb", "po", "l", "bp", "m", "pg", "cop", "pa", "g", "v", "pc", "b", "pe", "pd", "pi", "sp", "j", "h", "cp", "pr", "jp", "parser", "part", "t", "pp", "op", "r", "o", "pm", "d", "P"], "ds": ["ts", "ups", "s", "DS", "hs", "ans", "ipes", "ded", "dds", "ins", "xs", "ns", "d", "ays", "dos", "ps", "words", "sync", "styles", "ys", "groups", "data", "da", "des", "rs", "ths", " ps", "os", "utils", "pd", "icks", "dist", "els", "models", "points", "sts", "scripts", "plugins", "js", "db", "cons", "posts", "ls", "parts", "tools", "cs", "ss", "lines", "dm", "vals", "sys", "ges", "ks", "qs", "docs", "ants", "bs", "nas", "amps", "Ds", "di", "dd", " props", "gs", "ads", "ils", " sd", "lp", "uds", "tests", "eps", "services", "dates", "dl", "vs", "dt", "dat", "gd", "ld", " DS", "dp", "df", "obs", "dc"], "format": ["source", "nat", "form", "style", "filename", "fp", "table", "path", "language", "feat", "frame", "config", "f", "at", "model", "data", "magic", "record", "act", "class", "url", "name", "spec", "Format", "host", "fd", "function", "letter", "api", "tag", "string", "struct", "sche", "fn", "prefix", "handler", "plugin", "scale", "filter", "parser", "file", "version", "part", "t", "template", "atter", "layout", "unit", "type", "ant", "pattern"], "hasPixelData": ["hasPixelSize", "haspixeldata", "hasByteData", "haspixelData", "hasByteStyle", "showsByteDATA", "hasPictureSize", "hasPixelStyle", "hasPixelDATA", "haspixelSize", "showsPixelDATA", "hasPictureData", "showsPixelData", "hasBytedata", "showsPixeldata", " hasPixelSize", "showsPixelStyle", "hasPixeldata", "hasByteSize", "hasByteDATA", "showsByteStyle", "showsBytedata", "hasPicturedata", " hasPixeldata", "showsByteData"], "inflate": ["infloated", "infolode", "insvenode", "insflode", "infface", "inFlation", "insvenATE", "insvenating", "invenating", "inadequode", "inadequATE", "insflATE", "Inflation", "infloation", "invenATE", "insflate", "infolate", "inflode", "inflATE", "invenate", "invenode", "inflace", "Inflate", "inFlace", "inadequating", "inadequate", "inFlate", "InFlate", "infolATE", "infolating", "InFlace", "inffated", "insflating", "inFlated", "infloace", "infloate", "inflated", "inflation", "InFlated", "inffate", "inflating", "inffation", "insvenate", "InFlation", "Inflated", "Inflace"], "pxlen": ["pcln", "xplength", "pglen", "txln", "pnglen", "fxpos", "fxlen", "mxpos", "xpcount", "pxlength", "mxdata", "pxln", "pxpos", "ppl", "campos", "mxlen", "txlen", "fxdata", "pxcount", "mxlength", "axlon", "pclin", "pgLen", "txlin", "xplen", "axlen", "axlin", "pxlin", "mxsize", "pxdata", "pxlon", "pclen", "axln", "pgden", "mxln", "pxsize", "pngsize", "camdata", "txlon", "pnglength", "pngcount", "camlen", "ppLen", "fxLen", "xpsize", "mxcount", "fxln", "camln", "fxl", "pxLen", "pplen", "pgl", "pclon", "pxl", "ppden", "pxden", "fxden"], "out": ["work", "group", "copy", "cache", "output", "re", "session", "point", "pad", "store", "page", "state", "dump", "OUT", "conn", "line", "sys", "io", "up", "v", "log", "server", "gen", "obj", "post", "query", "list", "lock", "Out", "outs", "again", "lib", "step", "cli", "err", "inter", "user", "parent", "error", "co"]}}
{"id1": "19584877", "id2": "6840241", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToStream", "encodeFiletoStream", "encodeString2Stream", "encodeFiletoFile", "encodeStringToString", "encodeString2String", "encodeFileToStream", "encodeFileToString", "encodeFileFromFiles", "encodeFile2Files", "encodeStringToFiles", "encodeFile2String", "encodeStringToFile", "encodeFileFromString", "encodeString2Files", "encodeFileFromFile", "encodeFiletoString", "encodeFile2Stream", "encodeFileToFiles", "encodeFiletoFiles", "encodeString2File", "encodeFile2File", "encodeFileFromStream"], "infile": ["inputFile", "inputfilename", "Infiles", "outfilename", "infilename", "inputfile", "outFile", "inputfiles", "outfiles", "infp", "inputfp", "outfp", " infilename", " infp", " infiles", "infiles", "Infilename", "InFile", "Infile", "inFile"], "outfile": ["newFile", "outputfilename", "Outfile", "outfilename", "infilename", "outFile", "Outfolder", " outfp", " outfilename", "infp", "newfolder", "outname", "outfp", " outname", " outFile", "Outname", " outfolder", "outputfp", "newname", "newfile", "outputfile", "infolder", "OutFile", "outputfolder", "outfolder"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "vin", "base", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "image", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "copy", "conn", "cache", "again", "output", "inner", "writer", "work", "line", "err", "off", "client", "o", "OUT", "lib", "source", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "post", "io", "net", "file", "up", "co", "on", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "reader", "border", "uffer", "iter", "data", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "len", "queue", "input", "result", "length", "write", "fb", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "close", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "input", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "modified", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "respons", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "13757855", "id2": "18731843", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "label": 1, "substitutes": {"process": ["Process", "path", "resource", "output", "project", "run", "construct", "load", "proc", "build", "request", "cess", "submit", "processing", "exec", "call", "evaluate", "update", "processor", "parse", "create", "handle", "transform", "code", "view"], "tpl": ["tipl", "templ", "atpl", "fml", "tbl", "lcl", "qtpl", " tple", "Tpp", "tml", "Tbl", "stPL", " tipl", " tplate", "lplate", "latyl", "qtfc", "lpl", "tmpl", " tcl", "latcp", "tcp", "Tplate", " ttemplate", "pipl", "tplate", "Tpl", "temPL", "fplate", "qtple", "lPL", "latpl", "lple", "qtyl", "tmcp", "tmyl", "qtcp", "pcl", "psl", " tplug", "tsl", " tfc", "TPL", " tbl", " tper", "tmple", "tyl", "Tcl", "tpp", "templates", "Tper", "ppl", "tplug", "lml", "itPL", "Tipl", "lper", "Ttemplate", "temtemplate", "qtbl", "atplug", "tplates", " tsl", "pPL", "ttemplate", "itplates", "tfc", "Tple", "Tsl", "Tplates", " tplates", "tcl", "Tml", " tml", "stpl", "itplate", "fpl", "fplug", "atml", "tPL", " tpp", "stpp", "tple", "atplate", "stplate", "Tfc", " tPL", "latple", "itpl", "tper"], "model": ["where", "node", "copy", "json", "message", "document", "project", "result", "location", "params", "doc", "media", "config", "data", "body", "models", "language", "log", "Model", "m", "graph", "conf", "command", "xml", "module", "param"], "packageName": ["PackageName", "Packagename", "contextInfo", "packageInfo", "modulename", "groupUrl", "groupname", "contextname", "packageUrl", " packageNames", "packageNames", "groupName", "projectKey", "moduleUrl", "projectname", "PackageInfo", "moduleKey", "projectName", "moduleName", " packageInfo", "PackageNames", "contextNames", "packagename", "groupKey", "packageKey", " packagename", "projectUrl", "contextName"], "outFileName": ["outFilenameHalf", "outFullTime", "outFullLine", "inDirCopy", "OUTFileHalf", "OutFileName", "outfileOnce", "outfileNames", "outDirName", "outFullname", "difffileTime", "difffileName", "outFilenameNames", "diffFileTime", "OutFilename", "outDirname", "OutDirNames", "outFullNames", "outFileCopy", " outFileInfo", "OUTBufferName", "difffileOnce", "diffFileName", "OutFileLine", "outFilesLine", "outLineInfo", "OUTFileMode", "outLineNames", "outfileName", "inFileName", "outDirInfo", "outfileEnd", "inDirPath", " outFullInfo", " outFileLine", " outDirName", " outFilePath", "outfilePath", "outLinename", "outFileLine", "outFilenameMode", "outFilePath", "outFilenameEnd", "outFullPath", "outFilenamePath", "outLineTime", "outFileInfo", "outfileCopy", "outDirLine", "outfileMode", "outStreamName", "outDirPath", " outDirTime", "OUTBufferMode", "outRuleInfo", "OUTBufferHalf", "outRuleType", "outFilename", "outFilenameCopy", "outDirCopy", "difffileInfo", " outFileTime", "outFileHalf", "outBufferMode", " outDirLine", "outDirNames", "diffFileOnce", "OutDirLine", "outfileInfo", "inFilePath", "OutDirName", "outDirEnd", "outFileEnd", " outFullName", "outFullInfo", "OUTFileNames", "diffFileInfo", "outfileHalf", "outBufferNames", "OutFileNames", " outFileType", "outfileTime", "outDirOnce", "inDirEnd", "inFileEnd", "outStreamInfo", "outFileTime", "outFileMode", "outFileOnce", "outLineOnce", "outFilesPath", "OUTFileName", "outFileNames", "outDirTime", "OUTBufferNames", "outFullType", "outLineName", "outRuleName", " outDirPath", "outFilenameName", "outLineLine", "outBufferName", "outFileType", "outFilesTime", "outFilesName", " outFullType", "inDirName", "inFileCopy", "outStreamType", "OutDirname", "outBufferHalf", "outFullName"], "xsltParam": ["xldparam", "xsldParam", "xsltVal", "xslicVal", "xltMode", "xslpVal", "xslpParam", "xslpMode", "xsldparam", "xltVal", "xslicMode", "xldParam", "xldVal", "xltparam", "xslicParam", "xslicparam", "xslpparam", "xsltparam", "xsldVal", "xltParam", "xsldMode", "xsltMode", "xldMode"], "artifact": ["ARTifest", " artifacts", " artribution", "ARTifact", "Artifact", "adverturation", "aratifest", "ARTfact", "advertifacts", "arturation", "ARTifacts", "advertribution", "aratifacts", "aratifact", "Arturation", " arturation", "Artifest", "aratfact", "Artifacts", "artifest", "artifacts", "artribution", "Artribution", "Artfact", "advertifact", "artfact"], "destinationPath": ["destinatorLocation", "destinationWidth", "restinationHalf", "destinatedpath", "combinatorpath", "restificationPath", "datinationTime", "destinationHalf", "distinatorPath", "destinateHandler", "destinatorHalf", "DestinationName", "destinationCry", "destinatorStep", "distributionPath", "destiationPath", "destiningName", "constinationsName", "DestinationPart", "destiningPoint", "destinationHandler", "destinatedDir", "destinateName", "restinationPoint", "destiationAuth", "destinationUrl", "distinationName", "restificationpath", "restificationPoint", "destinatorWidth", "destificationPath", "constinationContext", "destinatedStep", "destinatingName", "destinatorPath", "destinatorHandler", "restinatorPoint", "destinatorFile", "distributionpath", "destinatingLocation", "desturationHandler", "destinatorKey", "constinatorUrl", "destinationTime", "destplingDir", "distinationCry", "datinatepath", "destinatorString", "distinatorFile", "destinerContext", "destinatedString", "destributionCase", "desticationPart", "distinatorName", "destiationDir", "destationpath", "tempinatedHalf", "DestinatingPoint", "destcreationPath", "destignmentCry", "destiningpath", "datinationpath", "destinationpath", "destinatorPoint", "combinationpath", "destinatedPoint", "destplingUrl", "distinationpath", "destinatorCase", " destificationLog", "constinatorWidth", "destiationLog", "destinatePath", "tempinationDir", "DestificationPart", "destplingWidth", "destinationString", "destinatingPoint", "constinationDir", "destinatedPath", "destinationAuth", "destributionpath", "destinationKey", "destinerPath", "destinatedFile", "destensionText", "restinatorHalf", "destinationsPath", "constinatorDir", "destplingLog", "DestificationPath", "datinatePath", "destinationDir", "constinationUrl", "destinatorTime", "destinationsName", "distinationFile", "restinationpath", "destplingAuth", "destributionPath", "distinationKey", "constinatorContext", "destinationText", "restinationPath", "tempinatedPath", "destinationName", "restinatorString", "destinationPart", "constinationsPath", "destinateString", "distinatorStep", "destinatePoint", "distinationCase", "destributionDir", "desticationFile", "restinationString", "destificationDir", "destinationFile", "combinatorPath", "constinatorPath", "desticationPath", "destinateText", "destensionPoint", " destinationLog", "destiningContext", "destinatingpath", "destplingPath", "desturationpath", "destificationpath", "destignmentName", "restinationLocation", "destificationPoint", "datinateTime", "destributionCry", "datinationLocation", "restinatorPath", "destinatingPath", "destinateLocation", "destinatedHalf", "destinatorCry", " destinationAuth", "DestinatingPath", "destinerDir", " destinationDir", "destcreationUrl", "constinationspath", "constinationWidth", "destributionName", "destinatorpath", "destinationStep", "tempinationPath", "destationPath", "destensionPath", "combinationHandler", "tempinationHalf", "datinationPath", " destificationAuth", "destiningDir", "destinatorUrl", "distributionDir", "destiningPath", "distinatorCase", "destinatedCase", "DestinationText", "distinationStep", "distributionCase", "destinatingText", "destationTime", "destinatorDir", "desturationPath", "DestinatingText", "destificationName", "destinateDir", "tempinationpath", "datinateLocation", "distinationDir", " destificationPath", "destinationCase", "distinationPath", "destationLocation", "destificationPart", "combinationName", "distinatorCry", "desticationKey", "combinatorHandler", "destinateHalf", "destificationAuth", "destinationLog", "destinatedKey", "desticationStep", "tempinatedDir", "destificationLocation", "desturationName", "constinationpath", "destinatepath", "destinationLocation", "constinationPoint", "destinationContext", "destensionName", "constinationName", "destinateTime", "constinationsPoint", "combinatorName", "destignmentCase", "destinationspath", "DestificationName", "DestinationPoint", "destinatorContext", "constinationPath", "DestinatingName", "restificationLocation", "destcreationWidth", "destignmentPath", "distinatorKey", "desticationName", " destificationDir", "destinationsPoint", "constinatorpath", "DestinationPath", "destinationPoint", "tempinatedpath", "destinatePart", "destinatorName", "destinerpath", "destificationLog", "combinationPath"], "in": ["IN", "i", "input", "ex", "n", "con", "c", "ins", "bin", "source", "reader", "d", "doc", "cache", "connection", "min", "r", "inc", "config", "data", "x", "name", "image", "t", "In", "din"], "out": ["index", "string", "path", "temp", "outer", "output", "ex", "sys", "server", "user", "lock", "copy", "Output", "version", "OUT", "result", "outs", "o", "pool", "all", "write", "line", "manager", "bin", "key", "post", "client", "part", "session", "source", "doc", "cache", "lib", "up", "connection", "str", "group", "store", "parent", "w", "file", "page", "log", "gen", "conn", "msg", "ne", "again", "name", "exec", "Out", "io", "writer", "dump", "prefix", "full", "free", "comment", "err", "obj", "with", "state", "cli", "error", "list", "point"], "root": ["index", "path", "node", "loader", "id", "results", "resources", "json", "instance", "modules", "meta", "query", "pattern", "params", " result", "cache", "r", "cat", "collection", "parent", "roots", "Root", "options", "format", "tree", "graph", "values", "url", "_", "include", " roots", "history", "xml", "module", "transform"]}}
{"id1": "8164056", "id2": "23517481", "code1": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"encode": ["encquote", "unquote", "enquote", "uncode", "Enquote", "Encod", "enccode", "enccod", "enode", "Enode", "encod", "unode", "uncod", "Encode"], "str": ["STR", "r", "in", "fr", "buffer", "p", "obj", "br", "sp", "ctr", "strings", "input", "e", "Str", "stri", "result", "code", "exp", "inner", "cur", "orig", "hr", "iter", "f", "rev", "st", "enc", "this", "data", "temp", "err", "div", "char", "er", "text", "arr", "string", "hex", "txt"], "buf": ["db", "bp", "buffer", "cas", "bu", "ctx", "bf", "br", "obj", "ff", "ab", "src", "fd", "queue", "tmp", "bb", "pkg", "cf", "Buffer", "sb", "coll", "result", "aux", "bc", "rb", "fb", "array", "af", "cur", "fp", "buff", "proc", "uc", "box", "pb", "Buff", "bh", "bd", "bag", "f", "binary", "wb", "vec", "conv", "data", "err", "b", "cv", "uf", "cb", "agg"], "md5": [" md512", "MD2", "md4", "dig512", " md2", "MD3", "MD5", "sha5", "MD11", "sha2", "md3", "md2", " md3", "dig11", " md4", "md11", "MD512", "md512", "dig5", " md11", "sha512", "dig4", "MD4", "sha3"], "bytes": ["items", "letters", "seq", "words", "bis", "steps", "files", "bs", "units", "cells", "sequence", "slice", "ls", "ns", "ips", "es", "lines", "objects", "boot", "quarters", "seconds", "content", "tes", "bps", "Bytes", "codes", "pieces", "ings", "classes", "bits", "pages", "binary", "data", "values", "b", "pins", "errors", " elements", "rows", "text", "bles", "vs", "body", "string", "parts", "rules", "outs", " strings"], "i": ["ai", "in", "m", "h", "p", "j", "n", "key", "multi", "slice", "e", "phi", "id", "mu", "ci", "gi", "abi", "t", "val", "ui", "info", "length", "inner", "index", "li", "ii", "io", "ori", "bi", "part", "x", "pi", "f", "o", "xi", "ti", "ri", "u", "b", "v", "ji", "oi", "di", "hi", "l", "d", "si", "chi", "qi", "uri", "I", "c"], "s": ["S", "os", "su", "in", "m", "h", "p", "sl", "service", "n", "cs", "strings", "its", "ls", "e", "ns", "ex", "t", "es", "sb", "sg", "a", "aws", "ds", "abs", "f", "o", "fs", "u", "b", "v", "spec", "hs", "secret", "l", "signed", "ss", "d", "string", "si", "js", "ws", "c"]}}
{"id1": "15018553", "id2": "13595251", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["decryption", "encryption", "Enccrypt", "secipher", "Encrypt", "secrypt", "secryption", "decrypt", "Encryption", "encipher", "seccrypt", "deccrypt", "decipher", "Encipher", "enccrypt"], "text": ["image", "letter", "method", " Text", "hex", "content", "sequence", "input", "pattern", "message", "key", "output", "password", "bytes", "object", "struct", "string", "txt", "code", "class", "font", "contract", "buffer", "Text", "token", "path", "template", "source", "number", "secret", "length", "name", "test", "ext", "word", "data", "binary", "seed", "transfer", "str", "connection", "config", "TEXT", "address"], "md": ["dd", "mi", "sha", "cmd", "dr", "am", "dig", "metadata", "ma", "amd", " MD", "hd", "mm", "mo", "message", "ms", "ld", "wd", "mp", "hash", "gb", "mn", "mand", "d", "m", "bd", "pg", "ad", "cmp", "pm", "df", "mt", "mg", "mac", "sm", "od", "me", "mk", "cm", "MD", "Cmd", "mod", "data", "pd", "mag", "rm", "dm", "mc", "em", "mb", "pkg", "hm", "meta", "db"], "md5hash": ["md256hex", " md4block", "md2block", "md7sum", "md5hex", "MD5hex", "md512key", " md4hash", "md4hash", "md4Hash", "md4log", "md25log", " md5log", " md5sum", "md256hash", "md4sum", "md5block", "md2Hash", "md7hash", "md4block", "md5key", "MD5hash", "MD512hex", "md7Hash", "md6hash", " md4sum", "md2sum", "md5sum", "md6hex", "md6Hash", " md5block", "md25Hash", " md4Hash", "md25hash", "md6log", "md512hash", "MD512key", "md5Hash", "md6key", "md7block", "MD512hash", "md2hash", " md4log", "md512hex", "MD5key", "md6sum", "md256key", "md25sum", "md5log", " md5Hash"]}}
{"id1": "4468255", "id2": "20128728", "code1": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["zip", "info", "ssh", "Copy", "replace", "move", "clip", "write", "save", "clone", "split", "sync", "cop", "cp", "load", "cat", " cp", "file", "share", "ignore", "get", "put", "log", "delete", "link", "dump", "update", "create", "parse", "paste", "rm", "process", "opy", "transfer", "download"], "from": [" the", "path", "original", "base", "zip", "string", "id", "resource", "vol", "user", "by", "add", "http", "entry", " form", "c", "o", "html", "se", "code", "ate", "form", "er", "part", "client", "one", "source", "ce", "at", "without", "dir", "connection", "old", "before", "the", "open", "parent", "data", "file", "config", "empty", "log", "context", "or", "name", "start", "e", "io", "normal", "back", "link", "url", "of", "stream", "left", "range", "with", "From", "missing", "os", "f", "so", "this", " file"], "to": ["root", "base", "temp", "output", "resource", "token", "eto", "http", "on", "as", "jo", "database", "son", "not", "file", "dis", "toc", "termin", "sp", "office", "plus", "by", "site", "all", "sync", "so", "source", "cache", "load", "dir", "connection", "parent", "about", "name", "process", "disk", "storage", "path", "tom", "system", "socket", "o", "se", "line", "tto", "TO", "two", "flo", "comp", "one", "stat", "back", "no", "To", "p", "null", "or", "template", "io", "yet", "os", "auto", "front", "user", "client", "target", "data", "de", "x", "size", "po", "but", "t", "db", "pe", "too", "me", "top"], "result": ["val", "event", "info", "method", "sum", "accept", "plus", "replace", "mask", "ult", "rc", "lock", "continue", "results", "res", "ure", "entry", "report", "var", "ok", "current", "match", "length", "pass", "ret", "follow", "fail", "die", "arr", "part", "allow", "true", "cache", "use", "source", "up", "diff", "member", "date", "r", "default", "work", "data", "math", "search", "test", "effect", "force", "status", "card", "function", "success", "ver", "url", "comment", "mer", "err", "compl", "future", "br", "sign", "Result", "found", "count", "error", "cur", "term", "valid"], "subFiles": ["Subfiles", "ubFiles", " subParents", " subFile", "partfiles", " subPages", "ubDir", "singfiles", "singFs", "ubfiles", "partParents", "newFiles", "partFiles", "subPages", "subContents", "subDir", " subFs", "ubPages", "subParents", "SubContents", "SubFiles", "newfiles", "newPages", " subDir", "subTokens", "newParts", " subParts", "singFiles", "SubPages", " subTokens", " subContents", "newsFiles", "subFile", "ubContents", "SubFile", "SubTokens", "newsParts", "subParts", "subFs", "newsfiles", "singParents", "ubFile", "newsTokens", "newFile", "subfiles", "partFs", "SubParts", " subfiles"], "i": ["index", "id", "n", "pi", "uri", "ini", "ie", "slice", "c", "inner", "j", "ri", "o", "l", "s", "si", "ui", "is", "ii", "ori", "key", "ti", "d", "phi", "q", "li", "ip", "x", "p", "h", "mi", "u", "bi", "ai", "name", "oi", "ci", "I", "e", "io", "it", "xi", "di", "gi", "hi", "a", "k", "b", "v", "y", "iu", "multi", "f", "iv", "ix"], "newDir": [" newD", "NewDirectory", "nowDIR", "nowDirectory", "nextQu", "oldDir", "NewD", "nextFile", "nextFolder", "subDir", "oldFile", "subFolder", "newJar", "newQu", "newDirectory", "newDIR", "NewJar", "subD", "NewFile", "nextDirectory", "newFolder", " newDIR", " newFile", "newD", "subFile", " newJar", " newFolder", "nextDir", "subDirectory", "nowDir", "subJar", "NewFolder", " newDirectory", "oldFolder", "oldDirectory", "subQu", "NewDir", "oldDIR", "newFile", " newQu", "nowFolder"], "in": ["IN", "index", "pin", "input", "ex", "id", "serv", "ini", "lock", "gin", "on", "ie", "con", "c", "inner", "socket", "o", "l", "ins", "bin", "is", "part", "reader", "thin", "source", "up", "login", "min", "diff", "r", "inc", "data", "file", "init", "conn", "again", "e", "m", "image", "re", "isin", "it", "In", "nin", "a", "pull", "url", "lin", "b", "err", "cin", "inn", "f", "win", "this", "din"], "out": ["base", "ou", "sum", "ex", "output", "n", "serv", "op", "lock", "on", "net", "OUT", "socket", "inner", "c", "outs", "o", "all", "off", "write", "line", "bin", "co", "post", "sync", "client", "at", "one", "lib", "up", "cat", "cy", "w", "ch", "inc", "file", "log", "conn", "again", "name", "exec", "Out", "writer", "io", "exp", "call", "word", "ext", "can", "b", "err", "obj", "with", "img"], "fileLength": ["lineLength", " fileSize", "FileSize", "fileSize", "Filelength", " fileLen", "pageName", "baseSize", "fileLen", " fileName", "filelength", "pageLength", "FileLength", " filelength", "fileName", "baseLen", "pagelength", "linelength", "FileLen", "pageSize", "lineSize", "baselength", "lineName", "baseLength"], "charBuff": ["stringMatrix", " charBuffer", " charMatrix", "stringBuffer", "pairMatrix", "charBuffer", "pairBuff", "pairBuffer", "stringBuff", "charMatrix"], "len": ["val", "id", "lf", "cmp", "n", "Len", " pos", "l", "line", "bin", "en", "iter", "split", "fl", "fin", "nt", "part", "li", "lit", "start", " split", "name", "pos", "rev", "ln", " Len", "ni"], "oneChar": [" oneCor", " oneCh", " onechar", "fourCor", " oneCharacter", "singleCar", "singlechar", "singleCharacter", "zeroCharacter", "nextChar", "zerochar", "onechar", "singleCh", "zeroChar", "singleChar", "zeroCor", " oneCar", "nextCh", "oneCar", "fourchar", "eachCharacter", "singleCor", "fourChar", "nextCor", "eachchar", "eachChar", "oneCharacter", "oneCh", "eachCor", "fourCharacter", "oneCor", "nextCar"]}}
{"id1": "14194234", "id2": "10212189", "code1": "    private String File2String(String directory, String filename) {\n        String line;\n        InputStream in = null;\n        try {\n            File f = new File(filename);\n            System.out.println(\"File On:>>>>>>>>>> \" + f.getCanonicalPath());\n            in = new FileInputStream(f);\n        } catch (FileNotFoundException ex) {\n            in = null;\n        } catch (IOException ex) {\n            in = null;\n        }\n        try {\n            if (in == null) {\n                filename = directory + \"/\" + filename;\n                java.net.URL urlFile = ClassLoader.getSystemResource(filename);\n                if (urlFile == null) {\n                    System.out.println(\"Integrated Chips list file not found: \" + filename);\n                    System.exit(-1);\n                }\n                in = urlFile.openStream();\n            }\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            StringBuffer xmlText = new StringBuffer();\n            while ((line = reader.readLine()) != null) {\n                xmlText.append(line);\n            }\n            reader.close();\n            return xmlText.toString();\n        } catch (FileNotFoundException ex) {\n            System.out.println(\"Integrated Chips list file not found\");\n            System.exit(-1);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n        return null;\n    }\n", "code2": "    public String getXML(String servletURL, String request) {\n        StringBuffer stringBuffer = new StringBuffer();\n        try {\n            String encodedRequest = URLEncoder.encode(request, \"UTF-8\");\n            URL url = new URL(servletURL + request);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                stringBuffer.append(inputLine);\n            }\n            in.close();\n        } catch (MalformedURLException ex) {\n            return null;\n        } catch (UnsupportedEncodingException ex) {\n            return null;\n        } catch (IOException ex) {\n            return null;\n        }\n        return stringBuffer.toString();\n    }\n", "label": 1, "substitutes": {"File2String": ["File4string", "FiletoString", "Filetostring", "File4Line", "file4Line", "file4String", "FiletoStr", "file4Str", "File2Line", "FileTostring", "file4string", "File4Str", "FileToStr", "file2string", "FileToLine", "File4String", "file2Str", "FileToString", "File2Str", "file2String", "FiletoLine", "File2string", "file2Line"], "directory": ["office", "connection", "division", "manager", "archive", "database", "python", "application", "mode", "direction", "library", "description", "direct", "txt", "section", "root", "collection", "password", "d", "source", "storage", "project", "path", "environment", "system", "document", "uri", "category", "folder", "file", "prefix", "module", "Directory", "resource", "dir", "location"], "filename": ["connection", "sequence", "name", "File", "database", "language", "layer", "download", "xml", "fil", "SourceFile", "nil", "binary", "summary", "inline", "kl", "Filename", "description", "ssl", "loader", "files", "txt", "href", "l", "ppa", "fn", "collection", "journal", "password", "ename", "which", "source", "path", "phrase", "il", "url", "document", "figure", "uri", "route", "metadata", "jo", "file", "folder", "title", "prefix", "utf", "FILE", "resource", "sf", "fp", "token", "location", "rl", "string", "dll", "username"], "line": ["le", "iter", "data", "name", "char", "type", "se", "en", "str", "xml", "letter", "log", "base", "lc", "rule", "page", "part", "text", "l", "ace", "e", "cell", "key", "ine", "row", "buffer", "source", "entry", "comment", "parse", "feed", "Line", "write", "character", "url", "cl", "next", "li", "code", "nl", "unit", "ml", "pe", "file", "id", "LINE", "word", "len", "frame", "lin", "link", "string", "liner", "ip", "end"], "in": ["x", "bin", "connection", "isin", "login", "into", "get", "it", "socket", "inas", "ins", "pin", "stream", "cin", "ex", "min", "In", "en", "vin", "is", "kin", "conn", "b", "inner", "include", "rin", "part", "again", "win", "r", "din", "l", "IN", "err", "o", "ini", "i", "source", "init", "inc", "nin", "or", "arin", "url", "reading", "n", "thin", "io", "inn", "c", "file", "as", "id", "index", "a", "fa", "src", "lin", "fin", "input", "out", "resource", "token", "gin"], "f": ["x", "df", "inf", "File", "fl", "fen", "p", "info", "fe", "b", "w", "F", "l", "fn", "e", "tf", "fr", "lf", "this", "d", "i", "fx", "feed", "t", "h", "v", "n", "c", "file", "folder", "fa", "func", "fd", "fin", "bf", "sf", "fp", "fm", "out", "fo", "fc", "fb", "fs"], "urlFile": [" urlLine", "urlUrl", "viewUrl", "viewfile", "viewContent", "URLInfo", "resourcePath", "systemPath", "viewFile", "UrlLine", " urlContent", "UrlInfo", "resourcefile", " urlfile", " urlFolder", "urlInfo", "UrlFile", "resourceContent", "urlContent", "UrlFolder", " urlUrl", "urlFolder", "urlfile", "URLLine", " urlInfo", "urlLine", "resourceUrl", " urlPath", "URLFolder", "resourceLine", "URLFile", "resourceFile", "urlPath", "systemFile", "systemUrl", "systemLine"], "reader": ["iter", "er", "ri", "handler", "stream", "layer", "ger", "per", "rc", "loader", "inner", "r", "writer", "l", "rer", "parser", "rr", "row", "buffer", "i", "ner", "oder", "feed", "builder", "driver", "reading", "read", "bird", "uri", "server", "io", "file", "cher", "rar", "ry", "result", "input", "out", "ler", "Reader", "editor", "over", "rx"], "xmlText": ["mlString", "mlBuffer", "xmlString", "jsonBuffer", "urlString", "phpTEXT", "phpText", "phptext", "jsonTEXT", " xmltext", "xmlTEXT", "xmltext", "phpData", "mlText", "mlData", "jsonData", "urlData", "xmlBuffer", "xmlData", " xmlData", "urlTEXT", " xmlBuffer", "mltext", " xmlTEXT", "mlTEXT", "jsonText", "urlText", " xmlString"]}}
{"id1": "12066447", "id2": "17729554", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"truncate": ["trrenate", "trunational", "trrenator", "truncator", "trunator", "autuncator", "truncation", "autuncational", "autatenation", "autuncation", "trrenation", "truncational", "autatenational", "autuncate", "tratenate", "trrenational", "tratenational", "tratenator", "autatenator", "trunate", "tratenation", "trunation", "autatenate"], "file": ["source", "local", "filename", "File", "fp", "cache", "out", "uri", "current", "path", "f", "info", "this", "model", "page", "ile", "plus", "archive", "e", "one", "per", "l", "image", "single", "line", "or", "get", "data", "folder", "object", "resource", "format", "binary", "FILE", "directory", "io", "class", "url", "base", "log", "name", "document", "it", "files", "function", "zip", "address", "body", "time", "string", "connection", "future", "handler", "stream", "queue", "full", "type", "parent", " File", "db", "http"], "backupRoot": ["BackupPath", "backupsDirectory", "backbaseRoot", "backbackDirectory", "backupDir", "backbasePath", "frontupDir", "backupHome", "frontdownroot", "backbackRoot", "backflowDir", "backdownDirectory", "backdownFolder", "backupDirectory", "backureHome", "BackbackFile", "backUpDir", "frontdownDir", "backUpFolder", "backdownHome", "backupsroot", "BackureDirectory", "backupPath", "BackdownRoot", "backupFile", "backUproot", "BackdownDirectory", "backbackDir", "backdownRoot", "backUpRoot", "frontupFolder", "BackupDirectory", "backureDirectory", "backbackHome", "backdownroot", "backbaseroot", "backupsPath", "BackbackDir", "BackdownPath", "backbackFile", "backflowFile", "backflowRoot", "frontdownRoot", "backflowroot", "BackupHome", "BackupDir", "backupFolder", "frontupRoot", "backdownFile", "backureDir", "Backuproot", "backupsFolder", "backupsDir", "frontdownFolder", "backbaseDirectory", "BackureDir", "BackbackRoot", "backuproot", "BackupFile", "backupsRoot", "backdownDir", "backdownPath", "Backbackroot", "backureRoot", "frontuproot", "Backdownroot", "BackureHome", "BackureRoot", "backbackroot", "BackupRoot"], "df": ["flow", "DF", "md", "fp", "dict", "cf", "f", "fb", "CF", "dm", "de", "ds", "func", "data", "da", " def", "format", "dl", "bf", "pdf", "af", "io", "deb", "fd", "dt", "fs", "fe", "pd", "fn", "fr", "di", "dd", "tf", "dp", "fc", "def", "dn", "sf", "xf", "dq", "db", "d", "raf", "dc"], "date": ["work", "x", "pre", "created", "form", "message", "create", "style", "ate", "days", "re", "output", "str", "out", "fee", "sync", "day", "update", "back", "use", "ale", "input", "dates", "complete", "atom", "data", "m", "updated", "year", "module", "format", "open", "age", "valid", "url", "name", "log", "stage", "pe", "modified", "dt", "code", "ge", "dat", "time", "min", "j", "string", "tag", "dose", "rule", "Date", "D", "value", " Date", "version", "bug", "custom", "diff", "type", "db", "d"], "zipFile": ["sqlModel", "ZipFile", "zipfile", "ressFile", "Zipfile", "ressfile", "zipFiles", "zipSection", "zFiles", "ressModel", " zipFiles", "zipModel", " zipfile", "zFile", "ZipFiles", "zfile", "zModel", "zSection", "ZipEntry", "ressSection", "zipEntry", "sqlFile", "sqlfile", "sqlSection", " zipEntry", "zEntry"], "zos": ["ls", "closure", "dos", "hess", "bos", "z", "chini", "obb", "iffs", "zer", "zl", "gz", "zik", "tz", "robe", "han", "zona", "nz", "cash", "zy", "zb", "proxy", "zzy", "bitcoin", "eros", "ros", "zero", "ses", " sands", "os", "cos", "los", "ZA", "inos", "dylib", "zip", "fits", "zo", "address", "webkit", "uz", "zag", "budget", "zes", "zh", "zn", "exit", "las", "liquid", "rez", "outs", "settings", "zen", "kos", "lins", "ils", "css", "ozo", "zan", "ssl", "asio", "her", "osi", "zi", "zx", "jas", "nox", "js", "forge", "zon", "zar", "bes", "ops"], "fis": ["lids", "rafris", "fliss", "infias", "flids", "fiz", "infiss", "Fiss", "fiss", "lias", "rafis", "rafias", "flias", "flis", " fits", "flris", "vils", "bos", " fiss", "rafiss", " fiz", " fos", "biss", "bisl", "fris", "fisl", "fias", "infits", "Fos", "Fias", "lis", "liss", "Fis", "infis", " fils", "vits", "Fris", "fits", "fils", "vis", "Fisl", "Fisp", " fias", " fisp", "fisp", "infiz", "infils", "fos", " fisl", "flisp", "fids", "bis", "infids", " fris", "viz"], "entry": [" Entry", "style", "the", "uri", "se", "ace", "so", "z", "ry", "cell", "ion", "Entry", "info", "archive", "event", "extra", "e", "ie", "per", "de", "card", "image", "cel", "or", "data", "record", "array", "comment", "and", "next", "si", "ries", "lc", "add", "it", "server", "obj", "ui", "zip", "ge", "address", "term", "letter", "index", "zo", "exp", "element", "auto", "row", "r", "feed", "key", "her", "reader", "offset"], "buffer": ["vector", "sequence", "position", "shape", "cache", "result", "length", "available", "memory", "pad", "buff", "bb", "buf", "page", "seed", "bytes", "uffer", "padding", "border", "FFER", "data", "writer", "binary", "comment", "b", "device", "null", "server", "transfer", "number", "address", "Buffer", "beta", "header", "channel", "queue", "layer", "batch", "reference", "iter", "row", "wave", "feed", "slice", "reader", "flush"], "readed": ["inputED", " ReadED", "inputled", "inted", "intED", "textized", "readled", "textED", "readended", " readable", "readned", " Readed", " Readered", "readable", "bootered", "inputned", " readered", " readED", "bootable", "textended", "inputed", " readended", "texted", " Readned", " Readable", "intended", " readized", "readED", " Readled", " readled", "readered", "readized", "bootED", " readned", "booted", "intized"]}}
{"id1": "15799935", "id2": "5237257", "code1": "    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment, long accountId) throws MessagingException, IOException {\n        if (part.getBody() != null) {\n            long attachmentId = localAttachment.mId;\n            InputStream in = part.getBody().getInputStream();\n            File saveIn = AttachmentProvider.getAttachmentDirectory(context, accountId);\n            if (!saveIn.exists()) {\n                saveIn.mkdirs();\n            }\n            File saveAs = AttachmentProvider.getAttachmentFilename(context, accountId, attachmentId);\n            saveAs.createNewFile();\n            FileOutputStream out = new FileOutputStream(saveAs);\n            long copySize = IOUtils.copy(in, out);\n            in.close();\n            out.close();\n            String contentUriString = AttachmentProvider.getAttachmentUri(accountId, attachmentId).toString();\n            localAttachment.mSize = copySize;\n            localAttachment.mContentUri = contentUriString;\n            ContentValues cv = new ContentValues();\n            cv.put(AttachmentColumns.SIZE, copySize);\n            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);\n            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);\n            context.getContentResolver().update(uri, cv, null, null);\n        }\n    }\n", "code2": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"saveAttachmentBody": ["saveAttachedPart", "saveAttachedBody", "saveAppensionFile", "saveAttPartPart", "saveAttachmentPart", "saveAttachedFile", "saveAttensionBody", "saveAttPartFile", "saveAppachmentbody", "saveAppensionbody", "saveAttensionbody", "saveAppensionPart", "saveAttachedbody", "saveAttachmentFile", "saveAppachmentFile", "saveAttachmentbody", "saveAttPartBody", "saveAppachmentPart", "saveAttensionFile", "saveAppensionBody", "saveAppachmentBody", "saveAttensionPart", "saveAttPartbody"], "context": ["connection", "reader", "current", "Context", "version", "manager", "present", "channel", "container", "support", "cca", "ca", "state", "cms", "event", "definition", "center", "component", "cache", "text", "front", "concept", "content", "collection", "translation", "client", "subject", "service", "kernel", "ctx", "template", "cf", "request", "parent", "driver", "project", "environment", "system", "config", "document", "view", "c", "ce", "message", "community", "resource", "input", "queue", "mc", "coll", "contact", "host", "network", "processor", "media"], "part": ["connection", "app", "name", "point", "channel", "place", "type", "from", "body", "to", "p", "partial", "state", "phase", "event", "art", "per", "base", "component", "position", "parts", "Part", "section", " parts", "pre", "translation", "patch", "mission", "PART", " Part", "comment", "service", "source", "block", "pod", "image", "or", "media", "parent", "object", "file", "message", "upload", "po", "chapter", "plan", "area", "html", "Parts", "start"], "localAttachment": ["LocalAssachment", " localAttachachment", "localPartribution", "localAttachension", "localAttension", "localAvacher", " localAttrollment", "LocalAttment", "localAvacement", "localInstribution", "localAttacement", "localArtment", " localAttribution", " localAttention", "localAddment", "localAttment", " localAttacement", " localExtachment", " localPartension", "LocalAttention", "localattention", "localattrollment", "localAssention", " localPartribution", "LocalAssail", "localAvachment", "localPartension", "localAvention", "localArtail", "localAssment", " localPartention", "localAttachrollment", "LocalAttachment", "localAssail", " localExtacement", "localAddrollment", "localAttachention", "LocalAttail", "localPartention", "localExtacher", " localAttension", "localAttachacement", "localAttacher", "localPartachment", "localAttribution", "localAddail", " localExtacher", "LocalAssment", "localattachment", "localArtention", " localExtention", "localAttention", " localAttachrollment", "localAttrollment", " localAttacher", "localArtachment", "localAttail", "localAssachment", " localPartachment", " localAttment", "localExtacement", "localExtachment", "localAttachachment", "localAttachribution", "LocalAssention", "localInstachment", "localInstention", " localAttachention", "localExtention", "localInstension", "localAddachment", "localattment", "localAddention", "localAttachacher"], "accountId": ["contractId", "contractName", "jobid", "accountInfo", "contactid", "jobId", "appInfo", " accountID", "AccountName", "appId", "accountid", "feedID", "Accountid", "appID", "accInfo", " accountid", "feedid", "accId", "accountID", "appid", "feedName", "feedId", "AccountId", "jobName", "jobID", "accID", "AccountID", "accid", " accountInfo", "accountName", "contractid", "contactName", "contactId", " accountName"], "attachmentId": ["addachmentID", "attociationID", "attlementName", "attmentId", "atachmentReference", "attociationType", "addachmentType", "extachmentid", "adachmentID", "attentionId", "addentionID", "attmissionID", "attmissionId", "extachmentId", "atachmentName", "atociationReference", "attensionSource", "attentionSource", "adachmentInfo", "atociationName", "attlementId", "attmentName", "attmentReference", "attociationId", "attachmentID", "attachedType", "attentionIndex", "attentionUrl", "attociationReference", "atociationID", "extachmentSource", "attociationUrl", "attlementReference", "attociationName", "attachmentReference", "attlementID", "attensionid", "attachmentSource", "attentionType", "attachedID", "attentionid", "extensionSource", "atociationId", "attachedUrl", "attptionID", "adachmentIndex", "attensionID", "addentionId", "extensionid", "attptionId", "adentionIndex", "attmissionSource", "attmissionid", "attachmentType", "attachmentIndex", "attachmentInfo", "addachmentId", "adentionInfo", "attagramIndex", "attachmentUrl", "attagramInfo", "atachmentID", "adachmentId", "atachmentId", "addachmentUrl", "attachmentName", "attptionIndex", "attmentID", "extachmentID", "attentionID", "attachmentid", "attptionInfo", "attachedId", "extensionId", "attentionInfo", "adentionId", "extensionID", "addentionUrl", "attensionId", "attagramID", "attagramId", "adentionID", "addentionType"], "in": ["reader", "bin", "login", "f", "data", "it", "socket", "slice", "ins", "pin", "p", "cin", "info", "load", "In", "is", "inside", "copy", "conn", "inner", "again", "din", "IN", "err", "plus", "pull", "ini", "i", "source", "init", "image", "inc", "nin", "or", "url", "pass", "inn", "file", "as", "id", "up", "a", "input", "con", "ac", "gin"], "saveIn": [" savein", "savIn", "aveIn", "avein", "saveOut", "saveIN", "aveAs", " saveIns", "stageIn", "savAs", "writeIN", " saveOut", "SaveIns", "writeIn", "aveOut", "savOut", "stageOut", "savein", "stageIns", "SaveIn", "saveIns", "stageAs", " saveIN", "savin", "writeOut", "SaveAs", "aveIN", "SaveOut", "writein"], "saveAs": ["openAs", "copyAs", "saveAt", "openAS", "saveOut", "createAt", "copyas", " saveOut", "copyIn", "writeIn", " saveas", " saveAS", "writeAs", "SaveAS", "createAS", "saveAS", "SaveIn", "createAs", "saveFile", " saveFile", "copyAS", " saveAt", "writeOut", "openAt", "openFile", "SaveAs", "saveas", "writeAS", "SaveOut", "createFile", "Saveas"], "out": ["bin", "ext", "data", "name", "at", "s", "sync", "to", "ex", "outs", "copy", "page", "conn", "again", "output", "cache", "inner", "line", "writer", "err", "flow", "o", "client", "off", "OUT", "temp", "this", "plus", "source", "init", "image", "inc", "path", "exec", "outer", "v", "other", "default", "null", "io", "c", "file", "as", "up", "a", "Out", "string"], "copySize": ["CopyTime", " copyTime", "saveLength", "leSize", "byteTime", " copySIZE", "saveSize", "savesize", "lesize", "copyAddress", "CopySize", "openSIZE", "copyTime", "leLength", "copySIZE", "leSIZE", "Copysize", " copysize", "bytesize", "copysize", "byteAddress", " copyLength", "openLength", "copyLength", "saveAddress", "CopyLength", "byteLength", "opensize", " copyAddress", "openSize", "byteSize"], "contentUriString": ["contentUioStr", "contentIiByte", "contentUiniByte", "contentUridStr", "contentUrisString", "contentUioInt", "contentUpiInt", "contentUriUnit", "contentUpiStr", "contentUriByte", "contentUiNumber", "contentUriStr", "contentIrisInt", "contentUrisstring", "contentUiByte", "contentIrisStr", "contentUiostring", "contentUpiString", "contentIriStr", "contentIrisUnit", "contentUuriByte", "contentIriInt", "contentIiStr", "contentUridString", "contentUuriString", "contentUrisUnit", "contentUiString", "contentIrisString", "contentIriByte", "contentUuriNumber", "contentIiNumber", "contentIiString", "contentIristring", "contentUioString", "contentUiStr", "contentIrisstring", "contentUiniNumber", "contentUridUnit", "contentUiniStr", "contentUriInt", "contentUriNumber", "contentUuriStr", "contentUrisStr", "contentUiUnit", "contentUpistring", "contentUrisInt", "contentIriNumber", "contentUiniString", "contentIriString", "contentUristring", "contentIriUnit"], "mSize": ["pLength", "iLength", "cCount", "cSize", "mCount", "mLength", "pSize", "cLength", "mName", "pName", "iCount", "iSize", "iName", "cName", "pCount"], "mContentUri": ["mContentIci", "mResourceUric", "mContentUrci", "mResourceIris", "mContentUci", "mResourceUri", "mContentUric", "mContentOUri", "mContentUrris", "mContentIric", "mResourceUci", "mContentUris", "mContentIris", "mContentOUris", "mResourceUris", "mResourceIri", "mResourceIci", "mResourceIric", "mContentOUci", "mContentUrri", "mContentIri", "mContentOUric", "mContentUrric"], "cv": ["nv", "GV", "cb", "keep", "loc", "cd", "nc", "CV", "av", "vp", "sc", "iv", "ca", "cap", "vr", "enc", "vv", "rc", "cs", "lc", "iq", "auc", "csv", "content", "sv", "cr", "vm", "um", "bc", "cc", "ctx", "vc", "uc", "cf", "xc", "v", "vs", "conv", "core", "cu", "uv", "c", "lv", "VC", "co", "ov", "coll", "cm", "cover", "mc", "fp", "que", "ctrl", "cp", "fc", "pb", "buf"], "uri": ["URI", " url", "data", "point", "ri", "gb", "iri", "iv", "range", "pi", "universal", "base", "oid", "format", " ur", "href", "qi", "query", "address", "proxy", "i", "cli", "ci", "storage", "api", "path", "environment", "url", " scheme", "ui", "mi", "attribute", " Uri", "route", "metadata", "http", "id", "prefix", "resource", "uid", "location", "uni", "string", " URI", "username"]}}
{"id1": "18891988", "id2": "310182", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["downloadFile", "downloadfile", "loadFilename", "GetFile", "loadString", "GetFilename", "downloadFilename", "Getfile", "getString", "getfile", "getFilename", "GetString", "loadFile", "downloadString", "loadfile"], "serviceName": [" servicename", " servicePath", " serviceType", "ServiceUrl", "projectUrl", "projectName", "packagename", "ServiceName", "Servicename", "ServicePath", "servicename", "packagePath", "packageUrl", "ServiceType", "projectPath", "projectType", "servicePath", " serviceUrl", "packageName", "serviceType", "serviceUrl"], "wsdlLocation": ["wllFolder", "wsdlAddress", "wdlAddress", "wsDLUrl", "wslDirectory", "wdlFile", "awsdlUrl", "wsDLDirectory", "wsDLFile", "wsllDirectory", "awslFile", "awsdlDirectory", "wdlLocation", "awslLocation", "wssdFolder", "wslpFolder", "wslpDirectory", "wsllFolder", "wddlFile", "wsslFile", "wsllLocation", "wdlDirectory", "wsllFile", "wllLocation", "wslFile", "wdlFolder", "wssdFile", "wddlLocation", "wsslFolder", "wsdlDirectory", "wslUrl", "wslpFile", "wddlDirectory", "wsslAddress", "wsdlUrl", "awsdlFile", "wsdlFolder", "awsdlLocation", "wsllUrl", "wsslLocation", "wsdlFile", "wslLocation", "wsllAddress", "awslUrl", "wslpLocation", "wllAddress", "wddlFolder", "awslDirectory", "wssdLocation", "wslFolder", "wssdAddress", "wllFile", "wsDLLocation"], "endpoint": ["endsocol", "ENDpoint", "startaddress", "Endpoints", "endaddress", "ENDination", "startpointer", "Endword", "Endocol", "endocol", "startpoint", "Endpo", "enination", " endpointer", " endpo", "endspo", "enPoint", "endspoint", "enpoints", "enpointer", "endsword", "EndPoint", " endaddress", "ENDpoints", " endword", "endination", "endword", "ENDPoint", "Endpoint", "endpoints", "Endination", "enaddress", "enpoint", "endPoint", " endocol", " endPoint", "endpointer", "startPoint", "endpo"], "fileLocation": ["FileUrl", "fileDirectory", "FileURI", "fileUrl", " fileDirectory", "FILELocation", " fileURI", "FILEURI", "FILEDirectory", " fileUrl", "fileURI", "FileDirectory", "FileLocation", "FILEUrl"], "tempDir": [" temporaryDirectory", "tempdir", " temporaryVer", " tempDirectory", " tempPath", "TempPath", "tmpVer", "TempDir", "tmpdir", "tempVer", "tempPath", " tempdir", " temporaryPath", "tempDirectory", " tempVer", " temporaryDir", "tmpDir", "tmpDirectory", "Tempdir", "TempDirectory", "tmpPath"], "url": ["pull", "string", "channel", "host", "http", "service", "www", "URL", "log", "ll", "path", "ur", "io", "open", "contact", "Url", "download", "conn", "address", "l", "connection", "base", "ls", "server", "coll", "config", "sl", "f", "ul", "el", "image", "socket", "ssl", "fl", "web", "uri", "stream", "client", "source", "file"], "WSDLFile": ["WSDLLPath", "WSDLLFile", "WINDLFolder", "WSDlfile", "WSDlPath", "WDDlPath", "WDDlFile", "WSDELFiles", "WSDLLfile", "WSDELFile", "WSDLLFolder", "WSDDLPath", "WSDDLSourceFile", "WSDLFolder", "WSDLLFiles", "WSDDLFolder", "WDDlBase", "WINDELPath", "WSDLLBase", "WDDlfile", "WSDLPath", "WSDELFolder", "WSDLSourceFile", "WDDlFolder", "WDDLfile", "WDDLPath", "WINDELFolder", "WDDLFolder", "WINDELFile", "WDDlSourceFile", "WSDDLFile", "WSDELPath", "WSDLLSourceFile", "WDDLFile", "WINDLFile", "WSDLfile", "WINDLFiles", "WINDLPath", "WSDlSourceFile", "WSDlFolder", "WDDLBase", "WSDLBase", "WSDLFiles", "WSDDLfile", "WSDlBase", "WSDlFile", "WDDLSourceFile", "WINDELFiles", "WSDDLBase", "WSDDLFiles"], "tmpWSDLFile": ["tmpWDDLUrl", "tmpWSDDLFile", "tmpWSDLLFolder", "tmpWDDlFolder", "tmpWSDLLUrl", "tmpWDDlFiles", "tmpWDDLFiles", "tmpWSDlFile", "tmpWDDLLocation", "tmpWSDlFiles", "tmpWSDELFile", "tmpWSDLLFiles", "tmpWSDLUrl", "tmpWSDELFolder", "tmpWDDlFile", "tmpWDDELFile", "tmpWSDlFolder", "tmpWSDDLUrl", "tmpWSDELUrl", "tmpWSDLLocation", "tmpWSDLLFile", "tmpWSDELFiles", "tmpWDDELUrl", "tmpWSDELLocation", "tmpWSDDLFiles", "tmpWSDlLocation", "tmpWDDELFiles", "tmpWDDlUrl", "tmpWSDlUrl", "tmpWSDDLLocation", "tmpWDDELLocation", "tmpWSDLFiles", "tmpWDDLFile", "tmpWDDLFolder", "tmpWSDLFolder"], "inputFile": ["inDir", " inputDir", "Inputfile", " inputPage", " inputPlace", " inputfile", "outputFile", " inputStream", "tempBuffer", "inputStream", "inputUrl", "requestfile", " inputUrl", "inputFiles", "infile", "requestFile", "tempBase", "inPage", " inputFiles", "inputFactory", " inputBase", "InputFactory", "inputBuffer", "InputBase", "InputFile", "requestFiles", "InputFiles", "tempFile", "InputPlace", "InputPage", "inputDir", "outputDir", "inputfile", "inFile", " inputBuffer", "InputBuffer", "tempfile", "tempPage", "inputPage", " inputFactory", "outputfile", "tempUrl", "inputBase", "outputFiles", "InputUrl", "requestStream", "inputPlace", "InputStream", "tempPlace", "tempFactory", "InputDir"], "tmpFile": ["tempFiles", "uploadFile", " tmpPage", " tmpDirectory", "tempDocument", "uploadFiles", "uploadStream", "inputStream", "TempPage", "tempStream", "tmpPage", "inputFiles", "TempFiles", "tmpFiles", "inputDocument", "tempFile", "tmpStream", "tempDirectory", " tmpFiles", "tempPage", "TempFile", "tmpDirectory", "uploadDocument", "TempDirectory"], "in": ["In", "again", "c", "IN", "m", "is", "inner", "din", "bin", "input", "pin", "ins", "impl", "on", "conn", "inn", "p", "up", "l", "connection", "init", "win", "lin", "gin", "f", "image", "socket", "login", "ssl", "reader", "data", "r", "inc", "id", "source", "lock", "client", "file"], "out": ["timeout", "In", "ch", "group", "line", "again", "c", "channel", "IN", "cache", "o", "inner", "bin", "Out", "input", "conv", "copy", "outer", "log", "io", "can", "outs", "co", "sync", "on", "conn", "err", "up", "connection", "net", "part", "server", "image", "socket", "writer", "to", "output", "error", "OUT", "inc", "conf", "parent", "source", "client", "name", "file"], "con": ["ch", "ctrl", "fc", "cm", "c", "channel", "IN", "rec", "inner", "Conn", "conv", "can", "open", "co", "sync", "ins", "client", "ran", "conn", "kin", "connection", "win", "cn", "rc", "gin", "bc", "thin", "CON", "Con", "socket", "uc", "close", "plain", "ssl", "en", "inc", "nc", "conf", "com", "connect", "un"], "fileLength": ["FileLen", "fileSize", " fileSize", "FileWidth", "filelength", "channelLen", "contentLength", "contentLen", "contentlength", "Filelength", " fileLen", "channelSize", "contentSize", " fileWidth", "fileWidth", " filelength", "FileSize", "fileLen", "channelWidth", "FileLength", "channelLength"], "channelIn": [" channelIN", "ChannelOut", "characterin", "connectionin", "Channelin", " channelConn", "characterIn", "resourceIn", "connectionIn", " channelin", "resourceOut", "characterIN", "ChannelIn", "resourcein", "resourceIN", "ChannelIN", "connectionOut", "channelConn", "ChannelConn", "channelIN", "channelin", "connectionConn", "characterOut"], "channelOut": ["canOutside", " channelout", "canOUT", "ChannelOut", "ChannelOUT", "canOut", "channelOUT", "connectionOutput", "connectionout", "connectionIn", " channelOutput", "connectionOutside", "chanOUT", "Channelout", "channelOutside", "chanIn", "chanOutside", "ChannelIn", "connectionOut", "canIn", "chanOut", "ChannelOutside", "channelOutput", "chanout", "channelout", "ChannelOutput"], "tmpDocument": ["newFile", "tmpContent", "mpDocument", "tempDocument", "tmpDoc", "tmDocument", "tmdocument", "newdocument", " tmpContent", "mpFile", "tempdocument", "newDocument", "tmFile", " tmpdocument", "tmpdocument", "tempFile", " tmpNode", "tempNode", "tempContent", "tmpNode", "newContent", "tmNode", "mpDoc", " tmpDoc", "tempDoc", "mpNode"], "nl1": ["nn0", "NL0", "ln2", "kl1", "arlone", "arl1", "dl0", "kl5", "dl2", "nn2", "nlone", "ln11", "arlFirst", "arl5", "ln1", "NL11", "jl5", "ln6", "nl5", "NL6", "nl2", "nl6", "jlFirst", "nn6", "nlFirst", "NL2", "nn1", "dl1", "klone", "nl0", "nl11", "jlone", "klFirst", "NL1", "nn11", "jl1"], "i": ["iu", "hi", "si", "chi", "qi", "ip", "u", "multi", "ini", "ii", "n", "m", "pi", "y", "o", "d", "abi", "ci", "di", "io", "z", "slice", "ji", "ui", "ri", "bi", "ie", "p", "it", "l", "part", "phi", "j", "I", "fi", "uli", "eni", "index", "f", "e", "oi", "li", "ni", "v", "gi", "ti", "mi", "ai", "yi", "b", "xi", "id", "info", "uri", "ix", "mu"], "node1": ["node0", "layer91", "packageone", "shape91", "package91", "n1", "Node0", "Node2", " nodeOne", "nodeOne", "node91", "NodeOne", "Node91", "packageOne", "n0", "layer1", "package1", " node0", "layer2", " node2", "nodeone", "shapeone", "node2", " nodeone", "nOne", "layerOne", " node91", "shape1", "n2", "shapeOne", "Node1"], "tmpOut": ["tmpWriter", "tempOUT", " tmpWriter", "tmpout", "tmpOUT", " tmpIn", "txtout", "tempOut", "tempOutput", "tmpIn", "vmIn", "tempout", "cacheOUT", "ptyOutput", "txtWriter", "cacheIn", " tmpOUT", "cacheOut", " tmpOutput", "txtOut", "ptyout", "vmOut", "cacheFile", "tmpOutput", " tmpout", "tempFile", "ptyIn", "tempIn", "tempWriter", "ptyOut", "vmOUT", "txtOutput", "vmout"], "retVal": ["valObj", " retval", "RETVal", "valVal", "valRet", "RETObj", " retObj", "RETval", " retRet", "retObj", "retval", "RETRet", "retRet", "valval"]}}
{"id1": "1141361", "id2": "4593012", "code1": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "code2": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"makeRead": [" makeREAD", "doREAD", "doRead", " executePut", " executeAdd", "executeAdd", "doPut", "executeREAD", "doAdd", "executePut", " executeRead", " executeREAD", " makeAdd", "executeRead", " makePut"], "user": ["item", "row", "token", "username", "use", "owner", "project", "blog", "string", "host", "word", "comment", "uid", "log", "post", "meta", "mode", "creator", "custom", "bug", "USER", "install", "server", "url", "usr", "date", "field", "admin", "password", "User", "author", "write", "pod", "human", "job", "users", "alias", "name", "db"], "databaseID": [" databaseid", "tableID", "DatabaseUID", " databaseName", "dbName", "DatabaseName", "databaseUID", "databaseid", "tableid", " databaseKey", "connectionid", " databaseUID", "connectionID", "DatabaseID", "databaseName", "databaseKey", "dbId", "DatabaseId", " databaseId", "tableKey", "dbID", "dbUID", "databaseId", "connectionKey"], "time": ["timeout", "times", "string", "instance", "host", "hour", "table", "depth", "str", "comment", "money", "path", "year", "post", "length", "Time", "mode", "tz", "month", "rate", "port", "clock", "size", "read", "date", "TIME", "value", "set", "home", "tim", "ime", "type", "id", "timer", "message", "source", "text", "name", "end"], "query": ["timeout", "function", "string", "join", "execute", "table", "request", "Query", "select", "script", "comment", "call", "report", "qu", "search", "sequence", "post", "database", "sql", "command", "connection", "work", "commit", "code", "q", "filter", "error", "question", "module", "ql", "eries", "message", "id", "update", "name", "db", "sq"], "statement": ["slave", "status", "study", "si", "use", "media", "section", "function", "string", "instance", "note", "execute", "join", "volume", "table", "expression", "str", "comment", "language", "state", "response", "di", "jo", "post", "this", "database", "sql", "opened", "unit", "command", "batch", "rule", "connection", "document", "s", "init", "agent", "storage", "server", "commit", "ma", "machine", "session", "usage", "ment", "i", "password", "journal", "stat", "result", "memory", "joined", "st", "Statement", "style", "parser", "message", "general", "mt", "alias", "builder"], "count": ["cache", "table", "depth", "limit", "total", "state", "more", "sum", "log", "Count", "number", "force", "list", "process", "length", "content", "child", "err", "batch", "cc", "part", "connection", "base", "cond", "expected", "size", "index", "code", "start", "check", "handle", "counter", "diff", "error", "type", "found", "id", "inc", "offset"]}}
{"id1": "22411381", "id2": "2910383", "code1": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "code2": "    public String downloadAndOpen(JProgressBar bar) {\n        long size = 0;\n        try {\n            size = photo.getSize();\n        } catch (ServiceException ex) {\n            ex.printStackTrace();\n        }\n        try {\n            bar.setMaximum((int) size);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        bar.setValue(0);\n        image = new File(\"TMP/\" + photo.getTitle().getPlainText());\n        try {\n            if (!image.exists()) {\n                image.createNewFile();\n                image.deleteOnExit();\n                URL url = null;\n                BufferedOutputStream fOut = null;\n                try {\n                    url = new URL(photo.getMediaContents().get(0).getUrl());\n                    InputStream html = null;\n                    html = url.openStream();\n                    fOut = new BufferedOutputStream(new FileOutputStream(image));\n                    byte[] buffer = new byte[32 * 1024];\n                    int bytesRead = 0;\n                    int in = 0;\n                    while ((bytesRead = html.read(buffer)) != -1) {\n                        in += bytesRead;\n                        bar.setValue(in);\n                        fOut.write(buffer, 0, bytesRead);\n                    }\n                    html.close();\n                    fOut.close();\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return image.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"stop": ["remove", "close", "release", "pause", "job", " Stop", "quit", "kill", "setup", "Stop", "reset", "end", "find", "run", "destroy", "save", "sleep", "next", "loop", "operation", "work", "get", "delete", "start", "status", "update", "create", "process"], "task": ["class", "temp", "resource", "master", "run", "patch", "match", "tag", "func", "component", "problem", "worker", "element", "module", "point", "server", "clean", "game", "lock", "ack", "query", "sync", "source", "load", "work", "parent", "channel", "route", "Task", "object", "device", "plugin", "test", "complete", "name", "again", "exec", "link", "this", "unit", "contract", "localhost", "process", "event", "job", "tc", "message", "act", "socket", "session", "request", "pack", "app", "question", "trace", "error", "view", "user", "slave", "table", "project", "instance", "thread", "manager", "key", "form", "type", "date", "target", "ask", "config", "data", "status", "t", "action", "call", "role", "command", "block", "tx"], "con": ["remote", "core", "tc", "Conn", "cc", "server", "resource", "CON", "cf", "clean", "cons", "lock", "ran", "rc", "c", "fc", "ctrl", "col", "Con", "co", "query", " conn", "en", "condition", "client", "sync", "cm", "session", "cp", "cache", "cas", "uc", "ion", "connection", "login", "common", "ch", "inc", "conv", "un", "ca", "config", "xc", "log", "null", "conn", "rec", "row", "ain", "coll", "exec", "ci", "cr", "ann", "db", "pc", "commit", "mc", "ctx", "sql", "bc", "ver", "can", "conf", "cn", "connect", "container", "f", "win", "re"], "s": ["ssl", "sum", "sc", "sf", "n", "sys", "fs", "sg", "ks", "ns", "c", "S", "j", "se", "l", "ins", "bs", "si", "o", "su", "is", "rs", "ws", "sb", "r", "ans", "w", "gs", "h", "p", "es", "sq", "u", "search", "submit", "south", "ls", "js", "e", "m", "rows", "ss", "sl", "a", "sql", "ses", "cs", "ds", "os", "f", "ps"], "result": ["event", "info", "sum", "server", "resource", "response", "uri", "rc", "user", "results", "res", "report", "http", "message", "json", "ge", "table", "instance", "record", "manager", "su", "ret", "session", "source", "cache", "rh", "reader", "ner", "r", "ch", "work", "data", "page", "request", "search", "row", "coll", "e", "status", "runner", "success", "db", "details", "ver", "ser", "comment", "ur", "err", "future", "successful", "Result", "error", "sr", "re", "view"], "url": ["string", "path", "base", "address", "job", "id", "uri", "feed", "http", "lr", "l", "host", "location", "URL", "key", "source", "str", "ob", "file", "route", "object", "request", "href", "ls", "e", "image", "link", "sl", "rl", "pull", "Url", "obj", "f", "hub", "loc"], "i": ["uri", "pi", "ini", "ie", "ic", "c", "ri", "o", "l", "si", "ui", "is", "in", "ii", "ori", "qi", "vi", "d", "phi", "r", "ami", "li", "ip", "h", "p", "bi", "u", "ai", "oi", "ci", "e", "io", "I", "m", "eni", "it", "iri", "xi", "gi", "di", "ib", "a", "isi", "v", "abi", "iu", "f", "cli", "esi", "api"], "b": ["string", "base", "bf", "bd", "bh", "emb", "http", "eb", "lb", "c", "cb", "o", "l", "bs", "orb", "bin", "pb", "bg", "gb", "mb", "abb", "rb", "d", "ab", "sb", "wb", "buff", "lib", "buf", "ob", "body", "fb", "p", "e", "nb", "db", "bytes", "ib", "bc", "B", "bl", "y", "br", "ba", "f"], "bb": ["buffer", "base", "BB", "bf", "feed", "bd", "ok", "eb", "cb", "obb", "gg", "bin", "pb", "key", "char", "gb", "mb", "abb", "rb", "ab", "sb", "buff", "BBC", "ob", "fb", "bi", "bn", "nb", "db", "ib", "bc", "xb", "batch", "dd", "ogg", "boot"], "ll": ["BB", "lf", "kl", "lp", "lb", "wl", "z", "lr", "l", "col", "el", "nn", "LL", "ii", "ld", "dl", "fl", "la", "lla", "lc", "len", "ell", "ql", "cl", "nl", " l", "ls", "vl", "rl", "ln", "bl", "bm", "lv"], "k": ["ak", "sk", "ko", "n", "id", "ok", "ke", "kl", "ck", "ks", "dk", "j", "o", "uk", "K", "key", "ku", "unk", "d", "tk", "pp", "q", "kk", "r", "g", "work", "kid", "p", "x", "u", "m", "kw", "ky", "kin", "ikk", "ka", "f", "kn", "ik"], "s2": ["ws2", "s02", "Stwo", " sII", "STwo", " s4", "u2", "ds4", "s20", " s02", "js10", "utwo", " s10", " s8", " s0", "wstwo", "s8", "sum2", "su02", "wsTwo", " s20", "S5", "dsII", "c02", "su2", "ws5", "js0", "s96", "su1", "sII", "s10", "c2", "S2", "ds2", "s1", " s1", "sum10", " s96", "c1", "SII", "c20", "S4", "su20", "s0", "sTwo", "stwo", "js96", "u5", "sum96", "js2", "s5", "s4", "ds8", "uTwo", "sum0", "S8"]}}
{"id1": "2396191", "id2": "20851065", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksfromURLSafe", "getLinksFromUrlfast", "getLinksFromSSLSafe", "getLinksFromURLSafe", "getLinksFromURLSlow", "getLinksfromURLFast", "getLinksFromUrlFast", "getLinksFromSSLfast", "getLinksFromSSLSlow", "getLinksFromStringfast", "getLinksfromURLSlow", "getLinksfromUrlSafe", "getLinksFromStringSafe", "getLinksFromUrlSafe", "getLinksFromStringSlow", "getLinksfromUrlSlow", "getLinksFromUrlSlow", "getLinksFromStringFast", "getLinksfromUrlFast", "getLinksFromURLfast", "getLinksfromURLfast", "getLinksFromSSLFast", "getLinksfromUrlfast"], "p_url": ["p_link", "p__name", "tp_root", "p__resource", "p25layer", "pklink", "pe_config", "pipfile", "x_domain", "x_resource", "ekurl", "p64page", "p_html", "x_service", "e_link", "pfpath", "tp24root", "p64path", " p_resource", "pfroot", "pamhtml", "p6config", "p9resource", "p64line", " p_line", "pipurl", "p_file", "e_layer", " p_name", "p9url", "p_path", "p6root", "p24file", "pxurl", "pklayer", "p_name", "p_resource", "p25url", "p24link", "pkhtml", "pfurl", "p24root", "pffile", "p_service", "p_line", "p25html", "pe_root", "p_layer", "pe_url", "pamlink", "pamlayer", "e_url", "pamurl", "pxline", "p__url", "p25link", "p64url", "tp_url", "p_config", "e_html", "tp24link", "p_root", "pfline", "p24url", "p6line", "p9service", "tp_file", "p9domain", "tp24url", "pkurl", "pxconfig", "p_domain", "pxroot", " p_page", "pflink", "tp_link", "ekhtml", "piplink", " p_path", "pe_line", "tp24file", "eklayer", "piproot", "p6url", "eklink", "pfpage", "p_page", "p__path"], "x_url": ["x_log", "x_resource", " x_resource", "p_host", "p_conn", " x_ssl", "p_loc", "x_ssl", " x_log", "x_loc", "x_host"], "x_conn": ["x___conn", "x___con", "x___db", "x_conv", "p_client", "p_db", "wx_con", "x_con", "wx_conv", "x_cat", "p_conn", "p_con", "x_client", "wx_cat", "wx_conn", "x_db", "x___client"], "x_is_reader": ["x_ismlmanager", "x_is_pointer", "x_is_manager", "x_is_stream", "x_is_draft", "x_ismlstream", "x_is_resource", "x_ismlreader", "x_is_writer", "x_ismldraft"], "x_reader": ["cross8url", "x_parser", "x67url", "x24reader", "X_stream", "X_result", "x24result", "x67root", "x8reader", "cross_reader", "cross8reader", "x67reader", "x24parser", "cross_root", "x24stream", "cross8parser", "x8parser", "cross8root", "x67parser", "cross_parser", "x_stream", "X_reader", "x8url", "cross_url", "X_parser", "x8root"], "x_line": ["x__link", "p_link", "xingcell", "x24line", "ex_record", "x_record", "xx_line", "x_comment", "x__line", "x24lin", "x24comment", "xx_lin", "xingline", "xingrecord", "xingpage", "ex_line", "x24link", "p_line", "xx_link", "ex_page", "p_page", "x__url", "xx_comment", "x__page", "x_lin", "x_cell", "ex_cell"], "e": ["le", "er", "f", "y", "oe", "eps", "error", "edge", "ze", "eur", "g", "el", "m", "body", "ente", "p", "se", "ge", "ae", "fe", "ec", "eb", "event", "en", "ie", "me", "match", " E", "b", "he", "entity", "je", "r", "line", "l", "engine", "E", "o", "d", "ne", "entry", "t", "driver", "exec", "ev", "v", "ue", "te", "code", "n", "eve", "pe", "c", "eu", "file", "ce", "ele", "es", "ea", "re", "esi", "ace", "ee", "end", "element"], "x_match": ["p_matched", "p__match", "e_matched", "xammatch", "p_match", "xamreplace", "x_tag", "x_pattern", "x___meet", "x__match", "ax5case", "e___matched", "xamslice", "e___meet", "xjmatch", "e_match", "e_check", "x5info", "xJmember", "ext_search", " x__replace", "x___matched", "x___check", "x5match", "x_member", "ext_match", "ax_info", "x__replace", " x__slice", "x_check", "xlpattern", "ax_link", "x___match", " x_slice", "xlgroup", "ax5link", "xltag", "xJmatch", "ax5match", "x_replace", "extJsearch", "ext_member", "x__url", "x_info", "xjurl", "xjpattern", "xamcase", "x__matched", "xjmatched", "extJmember", "xJsearch", "xlmatch", "xlsearch", "x_matched", "x5case", "extJmatch", "ax_match", " x_date", "extJpattern", "p__url", "x_case", "xJpattern", "xldate", "x_date", "ax_case", "xlmember", " x_tag", " x_group", "e___match", " x_case", "p_pattern", " x_replace", "x_group", " x__match", "p__matched", "x__pattern", "x_search", "x_meet", "x__slice", "ax5info", "p__pattern", "x5link", "e___check", "x_slice", "e_meet", "x__case", " x__case", "ext_pattern"], "x_dir": [" x_file", "x6dir", "x_group", "xneturl", "xnetfile", "xnetdir", "x6group", "x_file", "x6file", " x_group", "x6url", "xnetgroup"], "x_root": ["x7directory", "x7root", "x7alias", "x_directory", "xml_root", "xml_path", "xml_directory", "xml_alias", "x_path", "x7path", "x_alias"], "x_links": [" x_points", "x_lines", " x_lines", "x_ids", "x67links", "x_points", " x_ids", "x67lines", "x67ids", "x67points"], "x_texts": ["x_pathes", "x_textches", "x_pathches", "x_logls", "x_textes", "x_urls", "x_loges", "x_urlls", "x_urles", "x_textls", "x_logches", "x_logs", "x_urlches", "x_paths", "x_pathls"], "x_buf": ["x1buff", "y__buf", "x_wb", "X_buff", "ex_tmp", "x__tmp", "x64buf", "x64bag", "x_cb", "x___uf", "x_buff", "X_buffer", "y__bag", "x1tmp", "ex_buff", "ex__tmp", "x__cb", "ex_cb", "x64uf", "ex__buf", "y_uf", "x___buf", "x_tmp", "ex__buff", "x_buffer", "x_bag", "ex_buf", "x64rc", "x__bag", "y__uf", "y_rc", "x__wb", "y_buf", "X_buf", "x__buf", "ex__cb", "y__rc", "x_rc", "y_bag", "x_uf", "x__buffer", "x___rc", "x1cb", "X_wb", "x1buf", "x__uf", "x__rc", "x___bag", "x__buff"], "x_matches": ["x_morting", "x_Matches", "x_matchcks", "x_matchchers", "x_matchting", "x_batures", "xKmatoms", "x_attched", "x_matchers", "xKtextoms", "x_calhes", "x_patched", "x_batches", "x_patchers", "x_attches", "x_morhes", "x_matoms", "xKtexthes", "x_pathes", "x_matures", "x__mathes", "x_calings", "xKtextings", "x_matting", "x__matures", "x_matchings", "x_locches", "x_locting", "x_patcher", "x_matings", "x_Mathes", "x_matchches", "xKtextches", "x_Matcher", "x_matchhes", "x_matcks", "x_morched", "x_Matures", "xKmatings", "x_Matchers", "x_patcks", "x_textings", "x__matchers", "x_calches", "x_matched", "x_attcks", "x_atthes", "xKmathes", "xKmatches", "x_mathes", "x_caloms", "x_batchers", "x_loches", "x_matchched", "x_texthes", "x_textches", "x_morches", "x_patches", "x_matchoms", "x__matches", "x_locched", "x_bathes", "x_textoms", "x_matchcher", "x_matcher"], "x_page": ["X_line", "xerfeed", "x67loc", "xerlink", "xerpage", "xerline", "ex_loc", "tx_page", "x_feed", "X_page", "tx_link", "x67link", "ex_link", "tx_feed", "x_path", "tx_line", "X_path", "x_file", "x_loc", "ex_file", "ex_page", "X_url", "x67page", "x67file"], "x_link": ["xpubloc", " x_target", "xpubline", "x_target", "xpublink", "ex_link", "xpubtarget", " x_loc", "x_loc", "ex_url", "ex_line", "ex_page"], "i": ["x", "ji", "f", "y", "si", "it", "ti", "ri", "iv", "p", "j", "info", "pi", "k", "ori", "ie", "ix", "hi", "I", "di", "u", "b", "multi", "bi", "qi", "r", "o", "key", "ini", "count", "ci", "z", "xi", "v", "oi", "ui", "n", "li", "uri", "zi", "ii", "io", "c", "in", "id", "index", "a", "chi", "iu", "eni", "ai", "gi", "phi"]}}
{"id1": "2022160", "id2": "5759961", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"write": ["writing", "flow", "written", "wrote", "service", "create", "send", "feed", "end", "flush", "w", "open", "run", "process", "play", "output", "sync", "add", "writer", "update", "read", "set", "code", "export", "store", "next", "Write", "out", "size", "close", "cycle", "dump", "data", "call", "connect", "put", "writ", "pipe", "kill", "lex", "exec", "append", "copy"], "byteBuffers": ["byteCompares", "bytesPackERS", "byteCornests", "bytebuffiners", "byteBuilderers", "byteOffers", " byteBuffERS", " byteCompares", "bytesBuffered", "byteOrdapers", "byteInfERS", "byteIntegelines", "bytebuffters", "byteCompers", "ByteOrdresses", "bytesDefers", "bytebuffinals", "byteBuffors", "byteBufferelines", " byteOffERS", " byteBuffors", "byteInferers", "bytesCornatters", "byteAkelines", "byteIntegers", "bytebufferers", "byteIntegatters", "byteDefERS", "byteOrderers", "wordBufferers", "byteCornlers", "bytesPackapers", "byteWritizers", "byteDefers", "byteBufferers", "bytesDefatters", " byteOffors", "byteWritlers", "bytesBuffests", " byteBuffiners", "byteChered", "byteAkizers", "byteBuffapers", "byteWritelines", "byteOrdresses", "bytebuffizers", "connectionBuffERS", "byteBuffinals", "connectionbuffERS", "byteChERS", " byteBuffeners", "byteBuffered", "byteComplers", "byteBuildERS", "byteBuffizers", "connectionBuffeners", "connectionBufferers", "byteBuffings", " byteBufferers", "bytesBuffERS", "ByteOrdERS", "byteBuffeners", "bytesCornests", "ByteOrders", "ByteOrderers", "bytesCorners", "byteBuffresses", "bytebuffers", "byteBuffererers", "byteBufflers", "byteHeadERS", "bytesBuffapers", " byteBuffinals", "byteCornatters", "byteOrdeners", "byteOrders", " byteOrdiners", "byteOrdiners", "ByteBufferers", "bytebuffests", "doubleHeadings", " byteBuffares", " byteOffters", "byteBuffereners", " byteOrders", "byteWritiners", "byteCompERS", "bytesBuffers", "byteBuffERS", " byteOrderers", "byteBuffests", "byteDefelines", "bytePackapers", "byteWriterers", "byteCornERS", "byteHeadings", "bytebuffelines", "doubleBuffered", "bytesDefelines", "ByteBufflers", " byteComplers", "byteAkers", " byteOrdeners", " byteBufflers", "wordBuffers", "bytesBuffatters", "byteBufferatters", "byteBuffelines", "bytesBuffelines", "byteHeaders", "ByteBuffERS", "bytebuffERS", "byteOrdinals", "connectionbufferers", " byteBuffters", "byteOffters", "byteBufferapers", "bytesAkelines", "byteHeadered", "byteIntegeners", "doubleBuffERS", "bytebufflers", " byteOffers", "bytebuffings", "byteOffERS", "byteInfers", "bytesPackerers", "byteWriters", " byteOrdinals", "byteChings", "bytesCornered", "bytesBufferers", "byteCornered", "bytesAkizers", "byteIntegERS", "ByteBuffresses", "doubleHeadERS", "bytesAkors", " byteCompers", "ByteBuffers", "connectionBuffers", "bytesPackers", "byteBufferlers", "bytePackerers", "bytebuffered", "wordBuffERS", "bytebuffresses", "byteOffors", "doubleHeaders", "doubleHeadered", " byteOrdERS", "byteDefatters", "bytebuffatters", " byteCompERS", "byteWritors", "bytebuffors", "byteInfatters", "byteChers", "byteBuilders", "bytePackERS", "byteBuffters", "byteBufferERS", "connectionbuffers", "connectionbuffeners", "byteCorners", "bytePackers", "bytesBuffors", "byteCornares", "bytesAkers", "byteOrdERS", "byteAkors", "bytesBuffizers", "byteBuffiners", "byteBuffares", "bytebuffeners", "bytesDefERS", " byteOrdlers", "byteBuffatters", "byteOrdlers", "doubleBuffings", "wordBuffatters", "byteBuildatters", "doubleBuffers", "byteInteginals"], "m_initialOutBuffer": ["m_initialoutLine", "m_initialInChannel", "m_InitialOutputBuffer", "m_finaloutChannel", "m_initialoutBuffer", "m_finalOutBuffer", "m_initialOutMessage", "m_initialInLine", "m_initialClientBuffer", "m_finalOutLine", "m_initialOutBuff", "m_finalInCache", "m_finaloutBuff", "m_initialNewMessage", "m_finalInBuffer", "m_initialAuthAddress", "m_initialAuthLine", "m_initialOutFile", "m_initialInFile", "m_originaloutFile", "m_InitialOutFile", "m_initialOutputLayer", "m_finaloutBuffer", "m_initialInBuffer", "m_initialOutputMessage", "m_initialOutLine", "m_finalOutMessage", "m_initialInMessage", "m_initialSocketBuffer", "m_finalInMessage", "m_originalOutLine", "m_initialNewBuffer", "m_InitialOutBuffer", "m_initialoutAddress", "m_initialOutLayer", "m_finalInFile", "m_initialSocketLayer", "m_initialInLayer", "m_originalOutFile", "m_initialShortFile", "m_InitialOutputFile", "m_originaloutLine", "m_initialoutCache", "m_initialOutChannel", "m_initialShortBuffer", "m_finalOutFile", "m_initialShortCache", "m_initialClientLine", "m_initialNewBuff", "m_finalOutChannel", "m_initialSocketHeader", "m_InitialOutputLayer", "m_InitialOutHeader", "m_originalOutBuffer", "m_initialClientFile", "m_initialoutFile", "m_initialOutputFile", "m_initialInAddress", "m_finalOutCache", "m_initialClientBuff", "m_initialOutputChannel", "m_initialInHeader", "m_initialShortChannel", "m_originaloutAddress", "m_finalOutBuff", "m_originaloutBuffer", "m_initialInBuff", "m_initialSocketFile", "m_initialAuthBuffer", "m_finalInLine", "m_initialOutHeader", "m_initialOutputHeader", "m_initialOutAddress", "m_initialAuthFile", "m_initialOutCache", "m_initialNewFile", "m_originalOutAddress", "m_initialOutputBuff", "m_finalInBuff", "m_initialInCache", "m_InitialOutputHeader", "m_finalInChannel", "m_initialoutChannel", "m_InitialOutLayer", "m_initialoutBuff", "m_initialOutputBuffer", "m_finaloutFile"], "buffer": ["resource", "temp", "window", "channel", "stack", "queue", "page", "null", "layer", "block", "file", "binary", "limit", "comment", "source", "f", "pool", "wave", "flush", "input", "cur", "cache", "slice", "output", "bridge", "table", "engine", "builder", "string", "read", "phrase", "response", "loader", "server", "document", "reader", "timeout", "console", "template", "Buffer", "header", "copy", "re", "base", "event", "worker", "shell", "object", "array", "fb", "uffer", "er", "row", "client", "FFER", "data", "port", "callback", "batch", "address", "feed", "view", "ker", "message", "back", "writer", "buf", "buff", "cell", "transfer", "iter", "bc", "config", "url", "holder"], "buffers": ["Buffers", "buffered", "bufaches", " buffars", "bufered", "buffors", "phresses", " buffler", "buffler", "Bufferers", "bufars", "affers", "buferers", "bufers", "affaches", " buffering", "ufors", "ufers", "buffages", "phers", "bufering", "bufresses", " buffresses", "bufERS", "buffering", "bufators", " buffages", "transformler", "transformering", "buffators", "Buffered", "buffaches", "affors", "ufaches", "transformers", "ufering", "Buffars", "buffERS", " buffERS", "phages", "phators", " buffators", "bufages", "buffresses", "transformERS", "bufler", " bufferers", "bufors", "affering", " buffered", "bufferers", "buffars"], "result": ["re", "err", "ver", "resource", "Result", "view", "inner", "event", "val", "function", "json", "grade", "match", "consumer", "or", "up", "cache", "message", "use", "output", "rate", "info", "status", "driver", "future", "flash", "r", "session", "rc", "success", "successful", "winner", "er", "ret", "diff", "out", "response", "row", "manager", "report", "test", "sr", "runner", "request", "search", "data", "user", "valid", "true", "cup", "card", "error", "comment", "complete", "results", "res", "date", "default", "acc", "f", "url"], "encrypted": ["image", "body", "temp", "stream", "inner", "flush", "entry", "channel", "available", "text", "cache", "packed", "extra", "pad", "flash", "padding", "selected", "layer", "secret", "interrupted", "loader", "internal", "binary", "transfer", "reader", "config", "source", " data"]}}
{"id1": "1769771", "id2": "4618237", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "copyChannel", "CopyFiles", "copyfile", "transferFiles", "copyFiles", "CopyChannel", " copyChannel", "CopyFile", "transferChannel", "transferfile"], "in": ["In", "again", "c", "IN", "m", "ex", "inner", "bin", "input", "io", "pin", "ins", "min", "inn", "l", "win", "base", "lin", "url", "query", "work", "config", "index", "f", "i", "image", "login", "reader", "diff", "data", "inc", "id", "source", "lock", "name", "file"], "out": ["resource", "external", "again", "n", "c", "string", "cache", "o", "ex", "call", "Out", "io", "outs", "conn", "user", "p", "up", "default", "w", "base", "prefix", "exec", "server", "x", "off", "image", "plain", "writer", "dot", "ext", "v", "output", "write", "OUT", "point", "b", "target", "name", "file", "extra"], "inChannel": [" inchannel", "insChan", "outchannel", "inputChannel", "inputStream", "winchannel", "winChannel", "binChan", "INStream", " inStream", "InChan", "inchannel", "winStream", "insClient", "binchannel", "InClient", "inStream", "winChan", "outStream", "insStream", "binClient", "INChannel", "inChan", "binChannel", "insChannel", "inClient", "INChan", "INchannel", "outChan", " inClient", "outClient", "inputChan", "InStream", "InChannel", " inChan", "Inchannel", "inputchannel", "binStream"], "outChannel": ["outputchannel", "outputChannel", " outChan", "outchannel", "inputChannel", "OutChannel", "OutConnection", "nStream", "Outchannel", " outManager", "inCh", "outManager", "inchannel", "outputStream", "outputController", "outputChan", "inStream", "nChan", "outStream", " outConnection", "inController", " outCh", "inChan", "inputController", "outCh", "outChan", "OutChan", " outchannel", "nManager", "inConnection", "outConnection", "inputChan", "outputCh", "nChannel", " outStream", "inputchannel", "inManager", "outController"]}}
{"id1": "14188043", "id2": "3375718", "code1": "    public static byte[] openHttpResult(String urlPath, boolean retry) throws IOException {\n        AQUtility.debug(\"net\", urlPath);\n        URL url = new URL(urlPath);\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setUseCaches(false);\n        connection.setInstanceFollowRedirects(true);\n        connection.setConnectTimeout(NET_TIMEOUT);\n        int code = connection.getResponseCode();\n        if (code == 307 && retry) {\n            String redirect = connection.getHeaderField(\"Location\");\n            return openHttpResult(redirect, false);\n        }\n        if (code == -1 && retry) {\n            return openHttpResult(urlPath, false);\n        }\n        AQUtility.debug(\"response\", code);\n        if (code == -1 || code < 200 || code >= 300) {\n            throw new IOException();\n        }\n        byte[] result = AQUtility.toBytes(connection.getInputStream());\n        return result;\n    }\n", "code2": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "label": 0, "substitutes": {"openHttpResult": ["openRouteResult", "openNetworkresult", "closeHttpresult", "openSocketRequest", "openNetworkRequest", "openHTTPresult", "closeHTTPSource", "openHttpResponse", "openUrlresult", "openNetworkResult", "getHttpResult", "openSocketResponse", "getHttpRequest", "openttpResult", "getHTTPResponse", "closeHTTPresult", "openhttpRequest", "openHttpRequest", "openSocketSource", "openhttpResult", "closeHTTPRequest", "openHTTPResponse", "closeHTTPResult", "openRouteRequest", "closeHttpMessage", "openUrlResponse", "openttpMessage", "closeHttpSource", "getHTTPresult", "getHTTPResult", "openSocketResult", "closeHTTPResponse", "openttpresult", "openhttpresult", "openNetworkResponse", "openHttpSource", "openHTTPRequest", "openHttpMessage", "openRouteSource", "openhttpResponse", "closeHTTPMessage", "getHTTPRequest", "closeHttpResult", "closeHttpRequest", "openUrlResult", "openttpResponse", "openHTTPSource", "openRouteResponse", "closeHttpResponse", "openHttpresult", "openUrlMessage", "getHttpResponse", "openHTTPResult", "getHttpresult", "openHTTPMessage"], "urlPath": ["urlText", "httpPath", "UrlHome", "resourceFile", "httpHome", "uriFile", "UrlText", "UrlPath", "resourcepath", "uriPath", "lPath", "runInfo", "urlCase", "urlFile", "urlHome", "urlpath", "uriName", "lpath", " urlpath", "URLText", "urlName", " urlPoint", "uripath", "httpCase", " urlCase", " urlHome", "urlInfo", "filepath", "resourcePath", " urlInfo", "Urlpath", "fileFile", "filePath", "URLpath", "runpath", "URLPoint", "UrlPoint", "runPath", "resourceName", "URLPath", "urlPoint", "UrlCase", "fileName", "httppath", " urlText", "lInfo"], "retry": ["detry", "detrying", "refrying", "pretried", "Retried", "detri", "retone", "retrying", "refried", " retone", "retrow", "Retry", "pretri", "reltry", "refri", "retri", " retried", "pretry", "relry", "relrying", " retrow", "rtri", "rerying", "pretrow", "Retri", "relone", " retri", "rtry", "reone", " retrying", "rettry", "Retrying", "rtrow", "retried", "detried", "refry", "rtried", "rery", " rettry"], "url": ["lc", "base", "client", "util", "URL", "proxy", "path", "log", "sl", "Url", "connect", "conn", "string", "li", "image", "c", "link", "org", "ssl", "user", "www", "config", "loc", "uri", "service", "resource", "http", "l", "page", "entry", "file", "server", "channel", "source", "con", "web", "f", "relation"], "connection": ["lc", "error", "client", "cache", "connected", "union", "use", "io", "proxy", "function", "creator", "index", "connect", "session", "conn", "context", "driver", "section", "image", "c", "link", "nn", "database", "character", "event", "communication", "component", "info", "user", "Connection", "b", "application", "object", "text", "number", "body", "handler", "config", "loc", "socket", "co", " Connection", "uri", "resource", "wrapper", "close", "condition", "http", "ion", "l", "cli", "channel", "server", "con", "nc", "f", "response", "relation"], "code": ["score", "complete", "cm", "test", "error", "dec", "level", "grade", "status", "cod", "change", "call", "pri", "cycle", "id", "zip", "force", "e", "sec", "Code", "check", "one", "x", "index", "state", "bug", "success", "order", "c", "xx", "fe", "cc", "zone", "reason", "type", "ie", "mode", "count", "go", "ce", "desc", "charge", "ception", "orig", "see", "co", "message", "done", "version", "close", "key", "content", "coded", "age", "rc", "line", "last", "se", "sc", "cause", "stage", "create", "coord", "nc", "ode", "expected", "size", "codes", "response"], "redirect": ["Redirect", "codedef", "refirection", "redirection", " redirection", "redanch", " redition", "transition", "transirection", "refanch", "refrict", " redef", "codedirect", "Redanch", "Redrict", "transef", "Redirection", "codedition", "redrict", "redition", "refirect", " redrict", "transirect", "redef", "codedirection", " redanch"], "result": ["error", "cache", "grade", "status", "str", "output", "answer", "comment", "dict", "load", "Result", "request", "default", "df", "string", "ret", "image", "err", "success", "results", "report", "r", "object", "diff", "buffer", "array", "message", "resource", "content", "rc", "page", "continue", "match", "source", "work", "data", "entry", "up", "instance", "value", "record", "response"]}}
{"id1": "8132219", "id2": "823074", "code1": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyStream", "Copyfile", "copyFiles", " copyfile", " copyStream", "transferFile", "transferfile", " copyFiles", "transferStream", "CopyFiles", "CopyFile", "transferFiles", "copyfile", "copyStream"], "inFile": ["inputFile", "binFiles", "binPlace", "outFiles", "inPlace", "INfile", "infile", "inputfile", "outfile", " inSourceFile", "INFilename", "binFile", "inSourceFile", "INFile", "inFiles", " infile", "InSourceFile", "outPlace", "binfile", "INSourceFile", "inputFiles", " inFilename", "inFilename", "InFile", "InFilename", "Infile", "inputPlace"], "outFile": ["outFiles", "againFile", "infile", "outputFile", "outfile", "againfile", " outFiles", "inFiles", "outputPlace", " outFilename", " outfile", "outputFilename", "againFilename", "outPlace", " outPlace", "outputFiles", "outFilename", "outputfile", "inFilename", "againPlace"], "in": ["x", "reader", "bin", "connection", "f", "data", "name", "ins", "pin", "m", "In", "base", "is", "part", "inner", "again", "rin", "din", "work", "IN", "ini", "i", "source", "image", "inc", "like", "url", "config", "n", "io", "inn", "c", "as", "file", "id", "index", "a", "ic", "input"], "out": ["x", "bin", "ext", "data", "name", "version", "to", "p", "ex", "outs", "plain", "log", "copy", "conn", "w", "b", "output", "part", "cache", "user", "line", "writer", "dot", "o", "client", "OUT", "external", "call", "buffer", "image", "exec", "v", "default", "n", "null", "io", "c", "file", "prefix", "resource", "obj", "Out", "string", "write", "Output"], "inChannel": ["iniChannel", "INSocket", " inchannel", "INChannel", "sinFlow", "INChan", "inConnection", "outStream", " inConnection", "sinSocket", "outLanguage", "winStream", "inchannel", "INFlow", "sinChan", "winChannel", "inichannel", " inChan", "iniStream", "outchannel", "inFlow", "sinChannel", " inFlow", "outChan", "winchannel", "INchannel", "outConnection", "INConnection", "winLanguage", "inputChan", "inLanguage", "inputChannel", "inChan", "inputStream", "iniLanguage", "inputchannel", "inSocket", "inStream", "INStream", " inSocket"], "outChannel": ["inPath", "newStream", "againchannel", " outStream", "inConnection", "newChan", " outContext", " outConnection", "outContext", "outStream", "outputChan", "inchannel", "outPath", "againChannel", "againPath", "outchannel", "OutChan", " outChan", "outChan", "OutContext", "againChan", "OutStream", "outConnection", "Outchannel", "OutConnection", "outputchannel", "OutChannel", "inChan", "outputChannel", " outchannel", "newContext", "newChannel", " outPath"]}}
{"id1": "21998571", "id2": "10391753", "code1": "    private String readTwitterFead() {\n        StringBuilder builder = new StringBuilder();\n        HttpClient client = new DefaultHttpClient();\n        HttpGet httpGet = new HttpGet(\"http://twitter.com/statuses/user_timeline/vogella.json\");\n        try {\n            HttpResponse response = client.execute(httpGet);\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n            if (statusCode == 200) {\n                HttpEntity entity = response.getEntity();\n                InputStream content = entity.getContent();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(content));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    builder.append(line);\n                }\n            } else {\n                Log.e(AndroidJsonTestingActivity.class.getName(), \"Failed to download file\");\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return builder.toString();\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"readTwitterFead": ["downloadTwitterFleee", "downloadTwitterJrequency", "downloadTwitterFee", "downloadTwitterFees", "downloadFacebookJee", "downloadFacebookJrequency", "downloadTwitterJead", "downloadTwitterFFrequency", "downloadTwitterFleees", "downloadFacebookFees", "downloadTwitterFlerequency", "downloadFacebookFrequency", "downloadTwitterFleead", "downloadTwitterFFees", "downloadTwitterJee", "downloadFacebookFead", "downloadFacebookFee", "downloadTwitterFrequency", "downloadTwitterFFee", "downloadFacebookJead", "downloadTwitterFead", "downloadTwitterFFead", "downloadTwitterJees", "downloadFacebookJees"], "builder": ["r", "image", "db", "buffer", "writer", "worker", "block", "entry", "object", "trace", "instance", "sb", "server", "address", "sf", "result", "board", "builders", "http", "array", "message", "editor", "container", "keeper", "row", "we", "build", "building", "iter", "store", "f", "url", "letter", "null", "base", "wrapper", "loader", "b", "er", "oder", "runner", "database", "atter", "built", "driver", "bean", "upper", "string", "parser", "Builder", "holder", "layer"], "client": ["request", "get", "connect", "service", "google", "queue", "i", "ce", "class", "socket", "host", "app", "proxy", "cli", "handler", "server", "per", "conn", "connection", "http", "resource", "io", "con", "tc", "cloud", "Client", "url", "api", "channel", "session", "contact", "https", "application", "force", "method", "bird", "plugin", "project", "config", "c"], "httpGet": ["httpget", "urlget", " httpSend", "HttpPut", "ttpSplit", "HTTPget", "httpFind", "HttpDo", "HTTPFind", "HttpSplit", " httpDo", "httpSplit", "httpPut", " httpget", " httpSplit", " httpFind", "httpSend", "HttpGet", "urlFind", "httpDo", "HTTPSend", "urlGet", "ttpDo", "ttpPut", " httpPut", "urlSend", "HTTPGet", "ttpGet"], "response": ["request", "error", "success", "writer", "service", "stream", "received", "full", "output", "reply", "object", "page", "handler", "server", "json", "result", "connection", "http", "message", "resource", "successful", "report", "Response", "resp", "ception", "api", "onse", "session", "data", "collection", "status", "application", "wave", "document", "body", "respond", "event"], "statusLine": ["StatusEntry", "statusEntry", "httpLine", "statResponse", "statusResponse", "statLine", "httpStatus", " statusResponse", "httpEntry", "responseEntry", " statusEntry", "responseCode", "statCode", "StatusStatus", "StatusLine", "statusStatus", "contentEntry", "contentLine", "responseLine", "statEntry", "statusBlock", "httpBlock", "contentStatus", "contentBlock", "StatusBlock", "responseResponse"], "statusCode": ["statusCount", "contentCode", "statusType", "contentType", "stateType", " statusCount", "stateCode", "stateStatus", "StatusStatus", "contentCount", " statusType", "StatusType", "StatusLine", " statusStatus", "StatusCount", "StatusCode", "statusStatus", "contentLine"], "entity": ["writer", "element", "entry", "stream", "object", "el", "e", "page", "json", "coll", "server", "agent", "result", "code", "media", "http", "resource", "Entity", "connection", "xml", "file", "enc", "model", "data", "type", "er", "ent", "article", "activity", "status", "collection", "application", "document", "et", "body", "event", "person", "source"], "content": ["image", "writer", "buffer", "entry", "stream", "Content", "output", "object", "load", "feed", "input", "layer", "page", "handler", "json", "server", "conn", "child", "result", "media", "pointer", "resource", "message", "xml", "raw", "file", "channel", "data", "loader", "activity", "status", "collection", "text", "driver", "body", "cont", "read", "source"], "reader": ["r", "in", "writer", "buffer", "ner", "worker", "Reader", "stream", "rer", "i", "input", "handler", "server", "per", "ler", "or", "editor", "resource", "io", "rr", "row", "reading", "rar", "iter", "data", "ri", "loader", "er", "oder", "parser", "ser", "read", "bird"], "line": ["r", "ip", "buffer", "sl", "lf", "sync", "one", "entry", "block", "i", "key", "cell", "object", "comment", "feed", "character", "sheet", "write", "e", "id", "page", "lc", "lines", "Line", "lin", "code", "connection", "message", "row", "file", "str", "liner", "iter", "link", "part", "url", "letter", "end", "pass", "base", "inline", "data", "pe", "char", "LINE", "text", "name", "l", "style", "string", "body", "le", "point", "source"]}}
{"id1": "22560224", "id2": "20073619", "code1": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "label": 0, "substitutes": {"hashStringMD5": [" hashStringMD6", " hashStringM5", " hashStringUTF4", " hashFileMK6", " hashFileMK5", " hashStringMD4", " hashFileMD4", " hashFileMK8", " hashFileMD8", " hashFileMK4", " hashFileMD6", " hashStringMK4", " hashStringMK6", " hashFileMD5", " hashStringM8", " hashStringMD8", " hashStringM6", " hashStringUTF6", " hashStringUTF8", " hashStringUTF5", " hashStringM4", " hashStringMK8", " hashStringMK5"], "string": ["text", "array", "writer", "uri", "message", "STR", "ring", "null", "script", "letter", "data", "version", "operator", "sequence", "result", "input", "str", "map", "password", "bytes", "date", "source", "section", "filename", "number", "slice", "object", "address", "file", "name", "list", "service", "binary", "word", "content", "buffer", "strings", "p", "database"], "md": ["m", "rm", "hd", " MD", "mp", "cmd", "data", "um", "dig", "dd", "km", "gd", "f", "rpm", "hash", "mc", "mag", "d", "vd", "od", "me", "ms", "mb", "meta", "hm", "amd", "mg", "dm", "wd", "bd", "cm", "metadata", "bf", "pd", "MD", "gm", "ad", "mac", "nm", "mand", "mm", "sm", "am", "pm", "vm", "df"], "byteData": ["letterData", "hardLength", "ByteString", "hardDATA", "largeData", "ByteData", "blockData", " byteArray", " byteBytes", "wordInfo", " byteDATA", "byteBytes", "ByteDATA", "bitdata", "bitData", "byteInfo", "lineBytes", " byteInfo", "wordArray", "wordData", "blockString", " byteString", "letterDATA", "bytePart", "bitBytes", "byteSeries", " bytedata", "Bytedata", "largeSeries", "letterLength", "byteDATA", "ByteInfo", "bitInfo", "wordPart", "BytePart", "lineInfo", "lineData", "blockArray", " bytePart", "ByteArray", "hardData", "blockdata", "byteString", "linedata", "harddata", " byteSeries", "largeArray", "byteLength", " byteLength", "largeDATA", "ByteSeries", "byteArray", "letterdata", "bytedata"], "sb": ["ls", "buf", "ssl", "sf", "b", "fb", "bp", "bh", "kB", "usb", "xb", "bc", "BP", "pb", "SB", "rb", "mb", "cb", "Buff", "sq", "bf", "BG", "bm", "src", "ruby", "buff", "sg", "db", "abb", " SB", "sc", "BB", "gb", "obb", "buffer", "SF", "ab", "nb", "eb", "bs", "Bs", "bb", "bps"], "i": ["k", "m", "u", "uri", "e", "j", "b", "g", "n", "fi", "ori", "io", "info", "si", "ie", "in", "field", "f", "it", "o", "index", "d", "ci", "iu", "h", "s", "oi", "ji", "sp", "abi", "is", "multi", "y", "li", "di", "l", "mi", "ip", "pi", "hi", "eni", "xi", "slice", "yi", "id", "ti", "v", "gi", "c", "ri", "w", "I", "ai", "phi", "ix", "ini", "ii", "ui", "bi", "x", "qi", "lc", "p"], "hexString": [" hexstring", "octBuffer", "hexBuffer", "nullText", "exText", "formstring", " hexText", "hexstring", "nullString", "nullstring", "exStr", " hexStr", "nullBuffer", "shortArray", "exArray", "shortString", "hexStr", "hexArray", " hexArray", "formArray", "octStr", "shortstring", "octString", "shortBuffer", "exBuffer", "hexText", "octArray", " hexBuffer", "formStr", "exString", "formString", "exstring", "octstring"], "hex": ["text", "ex", "he", "closure", "http", "pack", "length", "cmp", "form", "num", "xf", "rh", "quad", "nexus", "bit", "sync", "hello", "alph", "escape", "raw", "shape", "cross", "hash", "str", "exp", "digit", "sum", "h", "temp", "iter", "kh", "xxxxxxxx", "pex", "buff", "ip", "oct", "coord", "lit", "ctr", "brew", "id", "sex", "character", "hess", " Hex", "alpha", "cube", "cf", "xa", "x", "rex", "utf", "shift", "wh", "char"]}}
{"id1": "15241397", "id2": "3495460", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public boolean actEstadoEnBD(int idRonda) {\n        int intResult = 0;\n        String sql = \"UPDATE ronda \" + \" SET estado = 1\" + \" WHERE numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"doGet": [" doGET", "handleGET", "didget", " doPut", "didGET", "handlePut", "doGET", "didGet", "handleget", " doget", "didPut", "doget", "doPut", "handleGet"], "request": ["complete", "url", "result", "client", "reader", "received", "QUEST", "xml", "input", "er", "context", "queue", "image", "event", "type", "connection", "method", "report", "info", "application", "user", "object", "query", "message", "uri", "buffer", "resource", "Request", "document", "http", "data", "server", "subject", "req", "instance", "initial", "web"], "response": ["result", "error", "esi", "client", "status", "output", "view", "site", "model", "Response", "function", "host", "session", "out", "generation", "queue", "image", "next", "results", "respond", "writer", "connection", "report", "application", "object", "body", "parent", "message", "resource", "version", "wave", "document", "other", "page", "data", "resp", "server", "pool", "full", "reply", "onse", "json", "collection"], "rewrittenQueryString": ["rewwrittenQueryStr", "rewrittenUrlString", "rewrittenRequestString", "rewrittenPageArray", "rewwrittenRequestString", "rewwrittenQueryString", "rewrittenQuestionText", "rewwrittenQueryArray", "rewrittenQuestionArray", "rewrittenqueryString", "rewwrittenRequestService", "rewrittenQueryStr", "rewwrittenQueryText", "rewwrittenQueryService", "rewrittenqueryService", "rewrittenQueryList", "rewrittenRequestLine", "rewrittenUrlText", "rewrittenRequestText", "rewwrittenQueryList", "rewrittenRequestArray", "rewrittenUrlService", "rewrittenRequestList", "rewrittenQueryLine", "rewrittenQuestionLine", "rewrittenqueryLine", "rewrittenQueryArray", "rewrittenQuestionString", "rewrittenRequestStr", "rewwrittenRequestText", "rewrittenQueryText", "rewrittenqueryText", "rewwrittenRequestArray", "rewrittenPageString", "rewrittenUrlLine", "rewrittenRequestService", "rewrittenQuestionStr", "rewwrittenQueryLine", "rewrittenPageList", "rewrittenqueryStr", "rewwrittenRequestLine", "rewwrittenRequestList", "rewwrittenRequestStr", "rewrittenPageLine", "rewrittenQuestionList", "rewrittenQueryService"], "rewrittenUrl": ["RewrittenJar", "RewwrittenText", "rerittenLanguage", "rewardedURL", "rewardedUr", "rewmatchedURL", "rewrapedURL", "rewwrittenServer", "rewwrittenURL", "rerittenUrl", "rewardedLanguage", "rewmatchedFile", "rewedUr", "rewilledUrl", "rewrapedFile", "RewwrittenServer", "rewilledJar", "rewcraftedLocation", "rewodedUrl", "rewardedFile", "RewrittenURL", "rewatchedUrl", "rewatchedURL", "RewrittenServer", "rewrittenInt", "Rewwrittenurl", "rewodedFile", "rewriteText", "RewwrittenUrl", "rewardedJar", "rewedurl", "rewcraftedURL", "rewcraftedUr", "rewwrittenUr", "rewrittenLocation", "RewrittenFile", "RewwrittenURL", "rewardedInt", "rewmatchedUrl", "rewrittenJar", "RewrittenText", "rerittenFile", "rewrapedUr", "rewrittenServer", "rewatchedServer", "RewwrittenJar", "rewardedLocation", "rewwrittenLanguage", "rewedFile", "RewrittenInt", "rewrittenFile", "rewedURL", "rewwrittenFile", "rewardedUrl", "RewrittenUr", "rewrittenUr", "rewriteServer", "rewatchedText", "rewrittenText", "RewwrittenInt", "rewodedLanguage", "RewwrittenLocation", "rewwrittenJar", "RewrittenUrl", "rewilledInt", "rewmatchedurl", "Rewrittenurl", "rewilledURL", "RewwrittenFile", "rewwrittenurl", "rewriteURL", "rerittenUr", "rewcraftedUrl", "rerittenURL", "RewrittenLocation", "rewwrittenUrl", "rewrittenURL", "rewrittenurl", "rewwrittenLocation", "rewrapedUrl", "rewrittenLanguage", "rewodedURL", "rewwrittenInt", "RewwrittenUr", "rewedUrl", "rewwrittenText", "rewriteUrl"], "httpURLConnection": ["httpSSLConn", " httpURConnect", " httpStreamCurrent", "webURLConnection", "HttpURLConnection", " httpUrlConn", " httpURLConn", "httpURIconnection", "httpWebConnection", "webSSLConnection", "httpURLContext", "httpURLConn", "httpWebConnect", "httpELConn", "httpURLService", " httpURLConnect", " httpURConn", "httpURLconnection", "httpURLClient", "webURLClient", "httpGEconnection", "httpURIConnection", " httpStreamConnection", "httpPathconnection", "httpGEConnect", "httpurlSession", " httpURLSession", "httpWebConn", "httpUrlconnection", "httpCLConn", "httpURLCode", "httpUrlConnection", "httpURConn", "httpELConnection", "httpURIConn", "httpChannelConnection", "apacheURLconnection", "httpURconnection", "httpUrlContext", "HttpURLService", "httpStreamconnection", "httpUrlConnect", "httpurlConnection", "webURLConn", "httpChannelConnect", "httpURLSession", "httpPathSession", "httpURConnection", "httpStreamConnection", "httpELConnect", "apacheGEConnect", " httpURLCurrent", "httpurlCurrent", "httpSSLClient", "webSSLConn", " httpURConnection", " httpStreamconnection", " httpURLconnection", "httpChannelconnection", "HttpURLconnection", "httpURIFlow", "webSSLClient", "httpURIContext", "httpPathCurrent", "apacheGEconnection", "httpStreamCurrent", "httpGEFlow", " httpStreamSession", "httpURLFlow", "httpCLCode", "apacheGEFlow", " httpURLCode", "httpurlConnect", "httpurlFlow", "apacheGEConnection", "webSSLContext", "httpGEConnection", " httpUrlCode", "apacheURLConnect", "HttpChannelConnection", "httpUrlService", "httpurlConn", "httpurlCode", "apacheURLFlow", "httpSSLContext", "httpURLCurrent", "httpUrlConn", "httpurlconnection", "httpURConnect", "httpURIClient", "httpUrlClient", "httpURService", "HttpChannelService", "httpPathConnection", "httpURIConnect", "httpSSLConnection", "webURLContext", " httpUrlConnection", "HttpURLConnect", "httpUrlCode", "httpCLConnection", "HttpChannelConnect", "HttpChannelconnection", "httpStreamSession", "httpChannelService", "httpURLConnect", "apacheURLConnection"], "header": ["hash", "feature", "pair", "result", "item", "master", "error", "column", "token", "ter", "metadata", "after", "cover", "default", "function", "index", "er", "string", "bridge", "driver", "queue", "section", "next", "character", "layer", "event", "component", "writer", "info", "reference", "definition", "player", "head", "rule", "handler", "Header", "back", "list", "block", "headers", "outer", "buffer", "message", "iter", "version", "date", "her", "attribute", "key", "document", "dr", "line", "consumer", "entry", "filter", "server", "channel", "data", "match", "member", "director", "field", "second", "group", "part", "comment", "author"], "value": ["v", "sv", "description", "now", "current", "valid", "child", "Value", "model", "default", "function", "val", "label", "string", "name", "values", "end", "language", "set", "expression", "format", "type", "VALUE", "info", "element", "object", "text", "parent", "hello", "message", "office", "media", "version", "option", "property", "attribute", "key", "content", "V", "gi", "get", "document", "entry", "data", "server", "letter", "password", "variable", "field", "json", "comment", "item"], "inputStream": ["pullStreamer", "pullSteam", "inputSteam", "outputStreamer", "pullStream", "resourcestream", "InputChannel", "resourceSteam", "outputChannel", "resourceStream", "resourceChannel", "outputSteam", "InputStreamer", "Inputstream", "outputstream", "InputSteam", "inputstream", "inputChannel", "inputStreamer", "pullstream", "InputStream"], "outputStream": ["OutputFile", " outputSteam", "inputSteam", "outputStreamer", "OutputChannel", "OutputSteam", "externalStream", "outputChannel", "OutputStream", "externalstream", "externalSteam", "responseSteam", "outputSteam", "OutputStreamer", "responseStream", "outputstream", "responseChannel", "externalStreamer", "Outputstream", "responseFile", " outputChannel", " outputFile", "inputstream", "inputStreamer", "outputFile"]}}
{"id1": "2461169", "id2": "20310134", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFileToStream", "decodeStringToString", "decodeFileAsFiles", "decodeFileAsStream", "decodeString2Files", "decodeStringToFiles", "decodeFile2String", "decodeFile2File", "decodeFileAsString", "decodeStringToFile", "decodeFile2Files", "decodeFileFromFiles", "decodeFileFromFile", "decodeFileFromStream", "decodeFile2Stream", "decodeString2File", "decodeFileToFiles", "decodeStringToStream", "decodeFileToString", "decodeFileAsFile", "decodeString2String", "decodeString2Stream"], "infile": [" infilename", "infiles", "inputfile", "outfiles", "inFile", "InFile", " instream", "minstream", "Instream", "inputfilename", "inbase", " infiles", " infp", " inFile", "minbase", "minFile", "minfile", "outfilename", "outfp", "instream", "inputfiles", "infp", "Inbase", "inputfp", "infilename", " inbase", "Infile"], "outfile": ["outputdatabase", "outFile", "inputfile", " outFile", "outpath", "outputfilename", "inFile", " outpath", "inputdatabase", " outfilename", "outdatabase", "outfolder", "outputfolder", "outputpath", "inputpath", "inputFile", " outfolder", "infolder", "outfilename", " outdatabase", "outputfile", "infilename", "outputFile"], "in": ["re", "err", "ini", "login", "inner", "gin", "inn", "input", "In", "bin", "b", "conn", "pin", "r", "IN", "again", "pass", "ic", "source", "nin", "sin", "cin", "min", "ins", "is", "into", "as", "lin", "init", "inas", "a", "inside", "thin", "ac", "con", "data", "rin", "isin", "id", "i", "reader", "win", "m", "din", "socket", "inc", "s"], "out": ["ou", "err", "log", "image", "base", "o", "outer", "point", "inner", "to", "write", "net", "obj", "channel", "In", "up", "cache", "sync", "output", "OUT", "bin", "conn", "post", "writer", "home", "exit", "lib", "session", "again", "pass", "outs", "work", "job", "line", "io", "Out", "client", "off", "name", "co", "file", "parent", "error", "ex", "no", "timeout", "one", "or", "inc", "exec", "socket", "copy"], "buffer": ["base", "feed", "wave", "raw", "offset", "flush", "write", "input", "channel", "count", "cache", "slice", "queue", "b", "bytes", "bin", "bb", "null", "buf", "buff", "border", "padding", "split", "uffer", "type", "result", "layer", "length", "size", "server", "data", "reference", "binary", "seed", "transfer", "limit", "value", "reader", "iter", "batch", "source", "Buffer", "url", "address"], "read": ["_", "feed", "send", "end", "raw", "current", "check", "tell", "write", "inc", " skip", "find", "parse", "load", "reads", "reading", " write", "Read", "count", "use", "play", "run", "sync", "add", "slice", "ride", "fill", "r", "pass", "next", "work", "ind", "ad", "io", "sleep", "allow", "se", "len", "x", "ip", "length", " copy", "size", "start", "id", "READ", "limit", " Read", "connect", "i", "reader", "get", "n", "wait", "seek", "iter", "select", "lex", "exec", "f", " count", "copy"], "success": [" succeed", "method", "model", "right", "Success", "func", "fast", "continue", "done", "default", "warning", "content", "open", "better", "message", "growth", "status", "null", "flash", "initial", "danger", "pass", "again", "path", "good", " Success", "winner", "result", "fail", "positive", "ccess", "cess", "response", "ceed", "xx", "first", "primary", "construct", "rolled", " succ", "data", "follow", "successfully", "true", "valid", "roll", "comment", "error", " successful", "complete", "results", "value", "rolling", "successful", "failed"]}}
{"id1": "22366505", "id2": "4481712", "code1": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "code2": "    public void deleteObject(String id) throws SQLException {\n        boolean selfConnection = true;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            if (dbConnection == null) {\n                DatabaseConn dbConn = new DatabaseConn();\n                conn = dbConn.getConnection();\n                conn.setAutoCommit(false);\n            } else {\n                conn = dbConnection;\n                selfConnection = false;\n            }\n            stmt = conn.prepareStatement(this.deleteSql);\n            stmt.setString(1, id);\n            stmt.executeUpdate();\n            if (selfConnection) conn.commit();\n        } catch (Exception e) {\n            if (selfConnection && conn != null) conn.rollback();\n            throw new SQLException(e.getMessage());\n        } finally {\n            if (stmt != null) {\n                stmt.close();\n                stmt = null;\n            }\n            if (selfConnection && conn != null) {\n                conn.close();\n                conn = null;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"incluir": ["inclurear", "inclituiro", "incluiro", "inCLuire", "inCLUir", "inclUear", "inCLuiro", "inclurir", "inclituear", "inCLuear", "inCLUire", "inclituir", "inclurire", "incluriro", "incluear", "inCLUear", "inCLuir", "incluire", "inclUir", "inclUire", "inclituire", "inCLUiro", "inclUiro"], "igreja": ["igr\u00e9jas", "igreji", "igereji", "igruza", "iggrej", "igruya", "ligr\u00e9j", "igreraya", " igreji", "ligr\u00e9ja", " igreya", "ligreje", " igreraya", "igrej", "igruj", "igreraji", " igreraza", " iggreJa", "igruje", " igreraja", "igruji", "igreya", "igreraza", "iggrejas", "ligreja", "igcreJa", " igrej", "ligr\u00e9jas", "igr\u00e9ja", "ligr\u00e9je", "igcreji", "igruja", "igreraja", "igereJa", "iggreji", " igreza", "igreJa", " iggreja", " iggrej", "igreje", "ligrej", "igr\u00e9j", "igerej", "iggreJa", "igrujas", "iggreza", "ligrejas", "igrejas", "igreza", " iggreji", "iggreja", "iggreya", " igreraji", "igcrej", " igreJa", "igr\u00e9je", "igcreja", "igereja", "iggreje"], "connection": ["description", "statement", "server", "core", "communication", "system", "loc", "lock", "event", "session", "engine", "socket", "bc", "Connection", "application", "document", "connect", "ion", "index", "graph", "error", "union", "conn", "connected", "cc", "config", "section", "directory", "client", "BC", "db", "table", "position", "cache", "con", "c", "machine", "option", "relation", "ctx", "environment", "context", "cf", "function", "condition", "pool", " Connection", "query", "collection", "manager", "database"], "sql": ["ls", "sol", "fn", "statement", "log", "ln", "url", "ssl", "null", "term", "SQL", "sys", "session", "sync", "csv", "socket", "sb", "spec", "stat", "nl", "s", "conn", "sq", "dl", "section", "filename", "seed", "db", "eps", "id", "string", "params", "select", "printf", "sl", "function", "query", "setup", "seq", "database", "ql", "join"], "sql2": ["ssl2", "ql02", "ssl02", "url1", "sslII", "ql2", "ql1", "ssl1", " sql1", "sql02", "sqlII", " sql02", "sql1", " sqltwo", "qltwo", "url2", "sqltwo", " sqlII", "qlII", "urltwo"], "stmt": ["frmn", "sth", "ostmr", "stmr", "fh", "Stm", "tmr", " stm", "stdb", " sttr", "fmt", "frconn", "frmt", "istmt", "STmd", " stst", "tpt", "Stmb", " stmn", " sth", "tm", "stmb", "strmt", "strmd", "STmt", " stdb", "istmn", "stmd", "Stpt", "stpt", " stpt", "STst", "ostmt", "stst", "tmt", "Stmn", "ostmn", "frtr", " stmb", "STmb", "ostmd", "istconn", "Stql", "stql", "ostql", " stmd", "Stst", "stmn", "Stmd", "Stmt", " stconn", "sttr", "Stmr", "fmd", "stconn", "strh", "fdb", " stql", "strdb", "stm", "isttr", " stmr"], "stmt2": [" stmt4", " stmp4", "stmd1", "stm4", "ctmt2", "stmdTwo", "stmt3", "stmt4", "stmp2", " stmt1", "stbmTwo", " stmrTwo", "stmn4", "stmp3", " stmp1", "stmr1", "stmp1", "stmtTwo", " stmp3", "stmpTwo", " stmr1", "stm1", "stmp4", " stmt3", "stmn2", " stmpTwo", "stmr3", "stmr4", "stbm2", "stmt02", "stmr02", " stmtTwo", "stmn1", " stmr02", " stmt02", "stm2", " stmp2", "stbm1", "ctmp2", "ctmpTwo", "stmp02", "stmd3", "stmd4", "ctmp1", "stmnTwo", "ctmt1", "stmd2", "stmr2", "stmrTwo", "stmt1", "ctmtTwo", " stmr2", "stbm02"], "rs": ["ls", "ros", "res", "rss", "ins", "rows", "details", "ss", "mr", "rc", "ps", "relations", "hs", "ows", "rys", "ys", "ms", "s", "RS", "Rs", "conn", "results", "row", "pr", "rr", "qs", "ras", "r", "ars", "ris", "eers", "errors", "rates", "xs", "params", "rd", "sr", "ts", "gs", "cs", "cr", "ks", "runs", "ds", "vers"], "retorno": ["retago", "resporn", "ntour", "ntro", "respago", " retago", "retorn", "Retour", "resporno", " retro", "ntorn", "retro", "retour", "Retorno", "respro", "Retro", " retour", "ntorno", " retorn", "Retorn", "Retago"]}}
{"id1": "17901739", "id2": "22442270", "code1": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"setMembers": ["setMember", "parseMember", "setJoin", "parseMethods", "SetMethods", " setMember", "SetMember", " setMethods", " setJoin", "SetJoin", "parseMembers", "parseJoin", "SetMembers", "setMethods"], "url": ["connection", "sl", "data", "org", "channel", "socket", "email", "base", "ssl", "blog", "user", "loader", "article", "l", "client", "address", "Url", "URL", "source", "service", "entry", "feed", "image", "hub", "path", "uri", "server", "io", "http", "file", "resource", "www", "queue", "location", "string"], "reader": ["iter", "er", "f", "handler", "table", "worker", "stream", "per", "rc", "keeper", "loader", "inner", "r", "writer", "l", "err", "rer", "parser", "e", "rr", "row", "i", "ner", "entry", "feed", "builder", "driver", "reading", "read", "server", "bird", "iterator", "io", "http", "file", "rar", "resource", "input", "report", "ler", "Reader", "editor"], "buffer": ["iter", "sequence", "data", "background", "str", "received", "binary", "b", "flush", "FFER", "source", "transfer", "uri", "null", "message", "queue", "header", "resource", "length", "fb", "border", "page", "cache", "output", "bytes", "address", "rb", "row", "parse", "template", "game", "document", "read", "code", "flash", "result", "texture", "uffer", "seed", "info", "counter", "expression", "bb", "loader", "line", "writer", "fr", "paste", "image", "feed", "phrase", "stage", "pause", "http", "wave", "buf", "bin", "batch", "sync", "layer", "buff", "Buffer", "button", "base", "video", "text", "password", "comment", "padding", "bar", "player", "request", "response", "filename", "server", "file", "input", "window", "string"], "pattern": ["df", "app", "handler", "slice", "command", "type", "array", "filter", "layer", "event", "str", "counter", "letter", "expression", "log", "rule", "match", "model", "format", " Pattern", "cache", "part", "position", "password", "parser", "patch", "Pattern", "condition", "atter", "image", "template", "feed", "child", "builder", "path", "object", "serial", "system", "regular", "config", "number", "group", "document", "file", "function", "cher", "script", "print", "re", "string", "graph"], "matcher": ["matter", "matach", "harler", "mither", "motter", "patchers", "patner", "motpattern", "mirter", "matchches", "captpattern", "matatter", "matchpattern", "attger", "matchter", "harpattern", "attcher", "compner", "matatcher", "lincher", "manher", "statcher", "mirher", " matchers", "matchatcher", "matched", "ratacher", "matler", "matching", "statner", " matpattern", " matacher", "linter", " matner", "Matacher", "linatter", " matler", "matches", "attacher", "Matter", "matchcher", "statler", "reches", "patatcher", "ratcher", "compter", "Matner", "mitchers", "patter", "reched", "mitch", "mitcher", "manner", "recher", "matacher", "matchach", "captcher", "patch", "attching", " mather", "matchler", " match", "mancher", "Mather", " matter", "Matching", "Matcher", "matchers", "patpattern", "captter", "compcher", "reach", "statpattern", "Matpattern", "matger", "harner", "matchher", "matchner", "match", "matchched", "compatcher", "linpattern", "harcher", "compach", "mirpattern", "patcher", "matchacher", "pather", "matner", "manacher", " matatter", "ratching", "compches", "compched", "captatter", "motcher", "mircher", "matpattern", "mather", "Matger", "motner", "ratger"], "erg": ["ag", "region", "arc", "er", "sg", "uster", "orters", "git", "org", "ander", "eri", "ung", "oga", "berg", "eur", "anger", "worker", "igor", "ero", "ERG", "irc", "rator", "era", "ard", "ger", "gas", "feat", "yang", "alg", "clus", "aga", "magic", "agog", "gae", "east", "gra", "orter", "usa", "dr", "og", "urg", "ig", "jing", "gd", "justice", "ers", "game", "rg", "der", "eng", "agg", "eric", "ord", "ocr", "ga", "gr", "gg", "gy", "porter", "aug", "rog", "forge", "ider", "progress", "gru", "ager"], "start": ["current", "name", "End", "stop", "type", "started", "cost", "grade", "art", "find", "ie", "shift", "mid", "work", "max", "off", "step", "source", "fill", "close", "sol", "stat", "Start", "pick", "pad", "end", "fit", "open", "it", "something", "boot", "se", "load", "ind", "position", "ish", "inner", "plus", "address", "count", "init", "read", "id", "last", "offset", "scale", "starting", "grad", "first", "seed", "pend", "info", "space", "state", "send", "sort", "set", "add", "part", "check", "old", "show", "style", "run", "sum", "pos", "ad", "rest", "bin", "get", "head", "st", "min", "base", "match", "need", "size", "like", "speed", "unit", "in", "middle", "index", "diff", "none", "begin"], "von": ["bin", "nn", "ver", "su", "tin", "john", "fen", "endon", "aven", "jan", "byn", "non", "won", "dn", "kn", "bn", "hn", "uber", "vin", "feat", "vu", "tun", "fun", "di", "fat", "anon", "jen", "don", "evin", "lon", "onna", "fn", "vid", "zon", "vor", "lu", "una", "hon", "bon", "mon", "han", "wen", "endor", "oni", "andon", "len", "olson", "eni", "lin", "flo", "fin", "ou", "ln", "mun", "melon", "ten", "tu"], "bis": ["offs", "bett", "cos", "bat", "bes", "outs", "vin", "is", "ls", "bi", "bits", "val", "phis", "cedes", "bas", "uno", "fb", "isi", "oss", "bs", "boot", "ori", "os", "lins", "obs", "vid", "abi", "bid", "nas", "ois", "ui", "li", "uss", "des", "len", "sis", "los", "vals", "BUS", "udi", "bos", "cin", "idis", "bb", "pins", "vs", "oni", "zi", "ris", "ni", "pos", "prefix", "oris", "ours", "eni", "us", "onis", "bin", "isin", "su", "ri", "buff", "pi", "base", "bian", "fat", "di", "lus", "bles", "bus", "nexus", "bps", "lin", "ios", "cus"], "m_strComponents": ["m_arrCommonents", "m_strCommales", "m_strComponentales", "m_strReponents", "m_intReponents", "m_strComponent", "m_strRepenses", "m_strCommorts", "m_intReports", "m_intCompales", "m_arrCompenses", "m_strCompenses", "m_strComports", "m_strComponentonents", "m_intCompenses", "m_arrComponent", "m_strExpenses", "m_arrCommenses", "m_strReports", "m_strRepales", "m_strCommenses", "m_strCommonents", "m_strExports", "m_intRepales", "m_arrCompales", "m_strExponents", "m_strCompales", "m_strComponentonent", "m_strExpales", "m_arrCommonent", "m_strExponent", "m_intRepenses", "m_intComponents", "m_strCommonent", "m_arrComponents", "m_strComponentenses", "m_arrCommales", "m_intComports"], "m_strPriorities": ["m_strPosifiers", "m_intPrefries", "m_strMonries", "m_StrPriorifiers", "m_strPriorifiers", "m_strPrioritions", "m_strPriorries", "m_intPriorities", "m_strPositions", "m_strPrefries", "m_strQualitions", "m_strQualities", "m_strQualifiers", "m_strActivitions", "m_StrPositions", "m_intPrioritives", "m_intPrefitions", "m_strPosity", "m_StrPriority", "m_StrPriorities", "m_intPrioritions", "m_strMonitions", "m_StrPrioritions", "m_StrPosities", "m_strActivitives", "m_strComparitions", "m_strActivries", "m_strMonities", "m_strPrefitions", "m_strMonitives", "m_strPosities", "m_strComparity", "m_strPriority", "m_intPrefitives", "m_strActivities", "m_strPrefities", "m_strQuality", "m_intPrefities", "m_intPriorries", "m_StrPosifiers", "m_StrPosity", "m_strComparifiers", "m_strPrefitives", "m_strPrioritives", "m_strComparities"]}}
{"id1": "16388708", "id2": "12883117", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public PhoneSetImpl(URL url) throws IOException {\n        BufferedReader reader;\n        String line;\n        phonesetMap = new HashMap();\n        reader = new BufferedReader(new InputStreamReader(url.openStream()));\n        line = reader.readLine();\n        lineCount++;\n        while (line != null) {\n            if (!line.startsWith(\"***\")) {\n                parseAndAdd(line);\n            }\n            line = reader.readLine();\n        }\n        reader.close();\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFile2Stream", "decodeFileToString", "decodeStringToStream", "decodeStringToFiles", "decodeFileAsStream", "decodeFile2String", "decodeFile2File", "decodeFileFromStream", "decodeFileAsFile", "decodeStringToFile", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Files", "decodeString2String", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeString2Files", "decodeFileToStream", "decodeString2File", "decodeFileFromFile", "decodeFileAsString"], "infile": [" instream", "infp", "minstream", "infiles", "inbase", "InFile", "outfiles", "instream", " infiles", "Instream", "outfilename", " inFile", "inputfile", " infilename", "minbase", "inputfilename", "inFile", " inbase", "minFile", "inputfiles", "outfp", "inputfp", "Infile", "infilename", "minfile", "Inbase", " infp"], "outfile": ["inputpath", "outdatabase", "outputpath", "outFile", "inputdatabase", "inputFile", "outputdatabase", "outpath", " outpath", " outfilename", " outfolder", " outFile", "infolder", "outputfolder", "outfolder", "outfilename", "inputfile", "outputfile", "outputfilename", " outdatabase", "inFile", "outputFile", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "b", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "pass", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "io", "up", "job", "base", "log", "name", "ou", "outer", "exec", "post", "obj", "channel", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "buf", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "channel", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "bin", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "count", "sleep", "ind", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "r", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "positive", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", " succ", "true", "rolling", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "10218878", "id2": "19912848", "code1": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"DecodeMapFile": ["DecodeFilefile", "DecodeDataFile", "DecoderFileFile", "DecodeDataFiles", "DecoderMapFiles", "DecoderFilefile", "DecodemapFiles", "DecodeDatafile", "DecodeMapfile", "DecoderMapfile", "DecodeFileFile", "DecodeFileFiles", "DecodeMapFiles", "DecodemapFile", "Decodemapfile", "DecoderFileFiles", "DecoderMapFile"], "mapFile": ["loadfile", "addressTable", "loadTable", "mapFull", "fileTable", "MapUrl", "mapLog", "batchLog", "batchUrl", "addressfile", "mapTable", "loadFull", "fileFull", "MapFile", "batchFile", "addressFull", "filefile", "MapLog", "addressFile", "mapUrl", "mapfile", "apperLog", "loadFile", "apperUrl", "apperFile", "fileFile"], "outputFile": ["inputFolder", "outputfile", "outputFolder", "responseStream", "OutputFolder", " outputFolder", "responseFiles", "inputFile", "OutputFiles", "inputDir", "OutputStream", " outputStream", "OutputDir", "outputStream", " outputfile", "responseFile", " outputFiles", "inputFiles", " outputDir", "outputFiles", "Outputfile", "outputDir", "OutputFile", "responsefile"], "magicKey": [" magicLetter", "MagicLetter", "prefixKEY", " specialKey", "magicKEY", "MagicK", "magicChar", "magicLetter", " specialkey", "cacheKey", " magicChar", "magicK", " specialK", " specialLetter", "magicSecret", "MagicKey", " magickey", "magickey", " magicSecret", "techKey", " magicK", "prefixLink", "prefixKey", " magicKEY", "techLink", "specialKey", "cachekey", "specialkey", "techkey", "cacheChar", "specialChar", "cacheSecret", "prefixkey", " magicLink", "magicLink", "Magickey", "techKEY", "specialSecret"], "buffer": ["base", "address", "Buffer", "input", "uffer", "token", "feed", "pause", "document", "message", "slice", "result", "length", "memory", "read", "queue", "iter", "offset", "bar", "source", "cache", "reader", "binary", "seed", "buff", "buf", "wave", "data", "variable", "bb", "row", "null", "header", "writer", "FFER", "array", "layer", "position", "url", "shape", "comment", "b", "reference", "stack", "count", "pad", "transfer", "batch", "code"], "nread": ["enfind", " nwrite", "Nreader", " nfind", "NRead", "nreads", "enreads", "nload", "Nwrite", " nreader", "enwrite", "neRead", "pload", "enRead", "nfind", "enread", "nereader", "newrite", "nwrite", " nreads", "pwrite", "Nload", "Nfind", "pRead", "neread", " nload", "nRead", " nRead", "Nreads", "pread", "nreader", "Nread"], "map": ["index", "maps", "address", "core", "input", "list", "copy", "resource", "lock", "master", "pre", "bridge", "message", "per", "pool", "write", "flow", "key", "client", "ap", "cm", "MAP", "one", "cache", "use", "source", "cover", "media", "group", "wave", "work", "open", "data", "file", "out", "config", "header", "m", "image", "pack", "layer", "app", "stream", "create", "parse", "pair", "over", "apper", "block", "make", "pad", "transfer", "module", "code"], "output": ["address", "ou", "core", "error", "console", "outer", "response", "resource", "input", "Output", "document", "oper", "ilo", "o", "run", "pot", "number", "office", "global", "write", "flow", "sort", "queue", "exit", "cache", "operation", "cut", "target", "connection", "model", "other", "application", "config", "data", "file", "out", "export", "web", "page", "object", "put", "log", "control", "image", "function", "layer", "update", "unit", "reference", "utils", "module", "external"], "i": ["info", "id", "mu", "pi", "uri", "ini", "slice", "c", "j", "z", "ri", "o", "l", "length", "si", "ui", "ii", "in", "qi", "ti", "ji", "phi", "li", "ip", "x", "p", "bi", "u", "uli", "oi", "ai", "e", "I", "io", "ci", "m", "zi", "t", "it", "xi", "di", "gi", "a", "b", "v", "multi", "f"]}}
{"id1": "20028790", "id2": "19520541", "code1": "    private static boolean setBundleInfoName(String location, List<BundleInfo> list) {\n        try {\n            URL url = new URL(location);\n            BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n            while (true) {\n                String line = br.readLine();\n                if (line == null) {\n                    break;\n                }\n                int pos1 = line.indexOf('=');\n                if (pos1 < 0) {\n                    continue;\n                }\n                String bundleSymbolicName = line.substring(0, pos1);\n                String bundleName = line.substring(pos1 + 1);\n                for (BundleInfo info : list) {\n                    if (info.bundleSymbolicName.equals(bundleSymbolicName)) {\n                        info.bundleName = bundleName;\n                        break;\n                    }\n                }\n            }\n            return true;\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n", "code2": "    public static URL[] getDirectoryListing(URL url) throws IOException, CancelledOperationException {\n        FileSystem.logger.log(Level.FINER, \"listing {0}\", url);\n        String file = url.getFile();\n        if (file.charAt(file.length() - 1) != '/') {\n            url = new URL(url.toString() + '/');\n        }\n        String userInfo = KeyChain.getDefault().getUserInfo(url);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.setAllowUserInteraction(false);\n        urlConnection.setConnectTimeout(FileSystem.settings().getConnectTimeoutMs());\n        if (userInfo != null) {\n            String encode = Base64.encodeBytes(userInfo.getBytes());\n            urlConnection.setRequestProperty(\"Authorization\", \"Basic \" + encode);\n        }\n        InputStream urlStream;\n        urlStream = urlConnection.getInputStream();\n        return getDirectoryListing(url, urlStream);\n    }\n", "label": 0, "substitutes": {"setBundleInfoName": ["setBindingIdDefault", "setBundleIdName", "setBindingInfoPart", "setBundleDirName", "setBundleIdDefault", "setBindingInfoName", "setBundleInformationList", "setBindingIdList", "setBundleInfoList", "setBindingInfoList", "setBundleInformationName", "setBundleDirPart", "setBundleInfoDefault", "setBundleDirDefault", "setBindingInfoDefault", "setBundleIdPart", "setBundleInfoPart", "setBundleDirList", "setBundleInformationPart", "setBindingIdPart", "setBundleInformationDefault", "setBindingIdName", "setBundleIdList"], "location": ["description", "uri", "localhost", "resource", "message", "server", "loc", "remote", "database", "data", "link", "station", "folder", "area", "site", "Location", "URL", "href", "type", "xml", "selection", "library", "directory", "filename", "LOC", "l", "point", "base", "node", "position", "address", "language", "string", "layout", "file", "loader", "region", "path", "content"], "list": ["array", "we", "parent", "data", "lists", "later", "part", "sequence", "group", "range", "entry", "all", "result", "LIST", "set", "stack", "batch", "cl", "coll", "the", "see", "i", "record", "li", "keep", "l", "listed", "cli", "tree", "pair", "table", "queue", "object", "string", "load", "mentioned", "detail", "name", "chain", "there", "collection"], "url": ["uri", "fr", "resource", "ssl", "server", "b", "connection", "loc", "io", "org", "data", "socket", "f", "URL", "bel", "jar", "source", "reader", "l", "stream", "lr", "base", "user", "r", "address", "string", "orb", "file", "err", "service", "sl", "plug", "Url", "buffer", "http", "bb", "open", "browser"], "br": ["buf", "res", "bro", "fr", "arr", "b", "body", "dr", "mr", "io", "yr", "data", "bh", "bc", "result", "str", "rb", "ch", "brush", "handle", "BR", "jar", "i", "reader", "ar", "stream", "er", "ber", "bar", "tr", "r", "err", "obj", "ob", "gr", "sr", "sp", "hr", "bl", "ler", "Br", "bridge", "cr", "bb", "img", "browser"], "line": ["page", "LINE", "text", "log", "lf", "e", "le", "b", "style", "connection", "letter", "lock", "cell", "data", "link", "sync", "shell", "part", "entry", "status", "result", "zip", "rule", "str", "split", "lin", "strip", "cl", "lines", "nl", "job", "inline", "row", "band", "code", "pass", "phase", "error", "source", "parse", "section", "header", "l", "license", "lr", "look", "string", "character", "file", "Line", "name", "up", "response", "lo", "word", "lc", "non", "block"], "pos1": ["pos2", "Pos0", "indexOne", "pos3", "POSN", "posOne", "POSOne", " posOne", "POS3", "Pos1", "Pos2", "POS1", "PosOne", "position2", "position0", " posN", "position3", "posN", "index0", "positionOne", " pos2", "index1", "part3", "part2", "pos0", "PosN", " pos3", "part1", "position1", "index2", "Pos3"], "bundleSymbolicName": ["bundleSymbolicKey", "bundleSyMBicalName", "bundleSymbriticalName", "bundleSymbicInfo", "bundleSymbillyName", "bundleSymbicallyname", "bundleSyMBolicName", "bundleSymbicModule", "bundleSymbicallyWord", "bundleSysembolicname", "bundleSymbillyInfo", "bundleSymbicalModule", "bundleSymbolicModule", "bundleSymbriticalWord", "bundleSymbuousWord", "bundleSyMBicalPart", "bundleSymbicalPath", "bundleSysembuousUrl", "bundleSymbicallyUrl", "bundleSymbicName", "bundleSyembolicInfo", "bundleSyembicKey", "bundleSymbuousUrl", "bundleSymbularPart", "bundleSymbicalKey", "bundleSysembolicUrl", "bundleSymbicalInfo", "bundleSymbuousName", "bundleSymbularPath", "bundleSymbuousname", "bundleSymbillyModule", "bundleSymbularString", "bundleSymbigiousName", "bundleSymbolicString", "bundleSymbicKey", "bundleSymbolicInfo", "bundleSyMBolicString", "bundleSymbolicUrl", "bundleSymbicallyName", "bundleSymbillyKey", "bundleSyembicModule", "bundleSymbularName", "bundleSymbriticalUrl", "bundleSymbicalString", "bundleSyembicName", "bundleSysembuousWord", "bundleSyMBicalPath", "bundleSyembolicName", "bundleSymbigiousPath", "bundleSymbigiousPart", "bundleSyembolicKey", "bundleSymbolicname", "bundleSymbigiousString", "bundleSymbolicPath", "bundleSyembicInfo", "bundleSysembolicWord", "bundleSyMBolicPart", "bundleSyembolicModule", "bundleSymbolicWord", "bundleSymbolicPart", "bundleSysembuousname", "bundleSyMBicalString", "bundleSymbicalName", "bundleSysembolicName", "bundleSymbicalPart", "bundleSymbriticalname", "bundleSyMBolicPath", "bundleSysembuousName"], "bundleName": ["rbundleType", "baffleInfo", "BundleName", "BendorInfo", "BpackageName", "bridgeDesc", "BundleDesc", "babiname", "bpluginName", "rbpluginname", "bendorID", "boodleID", "rbundleName", "bendorname", "BundleInfo", "bpluginInfo", "bblName", "BundleID", "bafflename", "bridgeInfo", "bpackageInfo", "bendorName", "bundleID", "bpackageName", "rbpluginName", "bblID", "BpackageDesc", "babiInfo", "BendorID", "bblname", "bendorInfo", "bundleType", "baffleType", "Bendorname", "bendorType", "rbundleInfo", "bpackageDesc", "BpackageInfo", "babiName", "Bpackagename", "Bundlename", "boodleInfo", "bundlename", "bpluginname", "bundleInfo", "boodlename", "bridgeName", "rbpluginType", "rbpluginInfo", "rbundlename", "BendorName", "bpluginType", "baffleName", "bundleDesc", "boodleName", "bridgename", "babiDesc", "bpackagename", "bblInfo"], "info": ["filter", "available", "fo", "image", "b", "Info", "off", "data", "link", "child", "part", "alias", "entry", "f", "py", "result", "check", "zip", "archive", "index", "error", "INFO", "end", "type", "key", "inf", "ignore", "tf", "i", "comment", "api", "parse", "li", "of", "base", "fw", "object", "id", "string", "gi", "handler", "file", "obj", "start", "name", "def", "extra", "by", "next", "diff", "bug", "op"]}}
{"id1": "4686922", "id2": "18793482", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourceInResource", "extractResourcesAsResource", "extractResourceAndFiles", "extractResourcesToResource", "extractResourceAndfile", "extractResourceAsResource", "extractResourceAsFile", "extractResourceAsfile", "extractResourcesAsfile", "extractResourcesAsFile", "extractResourceTofile", "extractResourceAndFile", "extractResourceAsFiles", "extractResourceInFiles", "extractResourcesToFiles", "extractResourceToResource", "extractResourcesTofile", "extractResourceInFile", "extractResourceAndResource", "extractResourceInfile", "extractResourceToFiles", "extractResourcesToFile", "extractResourcesAsFiles"], "resourcePath": ["servicePath", " resourceUrl", " resourceId", "resourceId", "stringFolder", "resourceFolder", "sourceId", "Resourcepath", "ResourceUrl", "ResourcePath", "sourcePath", "servicepath", " resourcepath", "resourcepath", "serviceFolder", "sourcepath", "ResourceId", "stringPath", "resourceUrl", "sourceUrl", "stringpath", " resourceFolder"], "dest": ["de", " Dest", "src", "output", "class", "transfer", "tmp", "comb", "default", "route", "const", "home", "Dest", "target", "result", "content", "desc", "path", "resource", "resources", "later", "img", "file", "sup", "dist", "config", "store", "sac", "die", "wb", "data", "temp", "flat", "trans", "done", "contract", " destination", "project", "prop", "folder", "destroy", "source", "filename", "txt"], "in": ["r", "image", "n", "inn", "gin", "isin", "i", "is", "socket", "init", "cin", "input", "thin", "id", "arin", "din", "sin", "plus", "conn", "lin", "connection", "inner", "resource", "nin", "ini", "con", "rec", "file", "rin", "kin", "inside", "f", "url", "this", "pass", "login", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "like", "re", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "auto", "client", "writer", "sync", "obj", "n", "off", "one", "all", "i", "output", "socket", "s", "app", "user", "copy", "parent", "ex", "server", "cache", "cookie", "outside", "conn", "boot", "ax", "a", "cos", "ext", "io", "at", "file", "f", "o", "null", "this", "exec", "lib", "err", "temp", "b", "norm", "w", "ins", "net", "co", "bin", "In", "OUT", "again", "outs", "outer", "source", "up", "inc"]}}
{"id1": "18005010", "id2": "20939940", "code1": "    private void setProfile(String loginName, SimpleUserProfile profile) throws MM4UCannotStoreUserProfileException {\n        try {\n            OutputStream outStream = null;\n            URL url = new URL(this.profileURI + profile.getID() + FILE_SUFFIX);\n            if (url.getProtocol().equals(\"file\")) {\n                File file = new File(url.getFile());\n                outStream = new FileOutputStream(file);\n            } else {\n                URLConnection connection = url.openConnection();\n                connection.setDoOutput(true);\n                outStream = connection.getOutputStream();\n            }\n            OutputStreamWriter writer = new OutputStreamWriter(outStream);\n            Enumeration myEnum = profile.keys();\n            while (myEnum.hasMoreElements()) {\n                String key = myEnum.nextElement().toString();\n                if (key != \"id\") writer.write(key + \"=\" + profile.getStringValue(key) + System.getProperty(\"line.separator\"));\n            }\n            writer.flush();\n            writer.close();\n        } catch (Exception e) {\n            throw new MM4UCannotStoreUserProfileException(this, \"setProfile\", e.toString());\n        }\n    }\n", "code2": "    private IProject createJavaProject() {\n        IProject proj = ResourcesPlugin.getWorkspace().getRoot().getProject(\"DefaultFolderPropertiesTest\");\n        if (!proj.exists()) {\n            try {\n                proj.create(null);\n                proj.open(null);\n                IProjectDescription desc = proj.getDescription();\n                desc.setNatureIds(new String[] { JavaCore.NATURE_ID });\n                proj.setDescription(desc, null);\n                IJavaProject javaProject = JavaCore.create(proj);\n                javaProject.open(null);\n                IFolder srcFolder1 = proj.getFolder(new Path(\"src\"));\n                srcFolder1.create(true, true, null);\n                IFolder srcFolder2 = proj.getFolder(new Path(\"custom_src\"));\n                srcFolder2.create(true, true, null);\n                IClasspathEntry[] classpathEntries = new IClasspathEntry[] { JavaCore.newSourceEntry(srcFolder1.getFullPath()), JavaCore.newSourceEntry(srcFolder2.getFullPath()), JavaRuntime.getDefaultJREContainerEntry() };\n                javaProject.setRawClasspath(classpathEntries, null);\n                IFolder binFolder = proj.getFolder(new Path(\"bin\"));\n                if (!binFolder.exists()) {\n                    binFolder.create(true, true, null);\n                }\n                javaProject.setOutputLocation(binFolder.getFullPath(), null);\n                IFolder testFolder = proj.getFolder(new Path(\"test\"));\n                testFolder.create(true, true, null);\n                IFolder resultFolder = proj.getFolder(new Path(\"result\"));\n                resultFolder.create(true, true, null);\n            } catch (CoreException e) {\n                fail(e.getMessage());\n            }\n        }\n        return proj;\n    }\n", "label": 0, "substitutes": {"setProfile": ["Setprofile", "SetRole", "updateProfile", "SetAccount", "SetProfile", "updateRole", "setAccount", "updateprofile", "setRole", " setAccount", " setRole", "updateAccount", "setprofile", " setprofile"], "loginName": ["displayUrl", "displayName", " friendlyName", " screenName", "displayID", " friendlyID", " friendlyPath", " screenPath", " screenUrl", " profileName", "displayPath", " profileUrl", " profileID", " screenID", " friendlyUrl", " profilePath"], "profile": ["property", "resource", "role", "application", "phy", "username", "shadow", "line", "project", "position", "history", "site", "environment", "photo", "option", "proxy", "character", "family", "report", "path", "phone", "display", "network", "queue", "summary", "user", "object", "header", "p", "base", "pe", "config", "settings", "office", "FILE", "password", "feature", "image", "Profile", "page", "result", "data", "type", "picture", "style", "plugin", "prof", "account", "job", "buffer", "name", "person"], "outStream": ["OutFile", "outputSteam", "outWriter", "OutSteam", "OutStream", "outputFile", " outFile", "intFile", "intSteam", "outputPath", "inSteam", "outputStream", "outPath", " outWriter", "instream", "inStream", "outSteam", "OutWriter", "OutPath", "inFile", " outSteam", "inWriter", "outFile", "Outstream", " outstream", "intstream", " outPath", "outputstream", "intStream", "outstream"], "url": ["resource", "entry", "pull", "or", "large", "function", "position", "zip", "string", "channel", "host", "http", "proxy", "service", "www", "URL", "log", "path", "api", "open", "feed", "this", "Url", "email", "impl", "download", "client", "conn", "address", "loc", "browser", "l", "base", "out", "server", "coll", "location", "plug", "sl", "f", "link", "e", "hub", "image", "socket", "page", "ssl", "data", "b", "id", "web", "uri", "stream", "source", "buffer", "org"], "file": ["File", "resource", "folder", "fe", "class", "use", "line", "function", "entity", "full", "zip", "channel", "http", "le", "path", "log", "io", "feed", "files", "place", "content", "unit", "loc", "l", "part", "base", "out", "pe", "get", "f", "FILE", "per", "filename", "image", "lib", "plain", "fp", "page", "output", "data", "b", "binary", "stream", "body", "name"], "connection": ["resource", "application", "section", "function", "position", "c", "Connection", "channel", "cache", "union", "proxy", "character", "response", "conv", "ctx", "con", "io", "open", "co", "driver", "relation", "conn", "object", "creator", "handler", "loc", "part", "out", "communication", "server", "config", "bc", "control", "session", "director", "password", "connect", "socket", "to", "directory", "connected", "stream", "client", "which"], "writer": ["entry", "riter", "writ", "function", "writers", "string", "later", "word", "xml", "inner", "ee", "walker", "outer", "Writer", "engine", "this", "driver", "er", "handler", "w", "wire", "out", "element", "event", "server", "work", "loader", "office", "per", "e", "wrapper", "worker", "editor", "to", "widget", "socket", "runner", "reader", "output", "writing", "write", "data", "buffer", "master", "builder"], "myEnum": ["myenum", "myLenumeric", "yourEncum", "myRenation", "myENum", "myenumber", "myenumer", "myEncation", "yourEnumer", "myLenumer", "myEnation", "yourEnque", "myEncum", "MyENumeric", "myEumb", "yourEncumer", "yourEnum", "myEncUM", "myEnUM", "myEncque", " myEnumb", "myEUM", "myENums", "myENumer", "yourEncumber", "MyEnumer", "myEnumeric", " myEum", "myRenum", "myenque", "myEation", "myEnque", "yourEncque", "MyEnum", " myEnation", "MyEnums", "myEnums", "myEncumber", " myEUM", "MyENums", "myRenumb", "myEncumb", "MyENum", "myENumeric", "myLenums", "myEnumer", "myENque", "myEncumer", "myEnumber", "MyEnumeric", " myEation", " myEnUM", "yourEnumber", "myRenUM", " myEumb", "myENumber", "myLenum", "myEnumb", "myEum", "MyENumer"], "key": ["item", "entry", "row", "ask", "section", "Key", "ip", "k", "string", "act", "step", "col", "exp", "ex", "str", "match", "KEY", "co", "box", "char", "sign", "child", "my", "weight", "ie", "cookie", "rule", "part", "base", "fix", "element", "pe", "nice", "load", "keys", "link", "field", "code", "value", "by", "feature", "any", "check", "val", "result", "page", "member", "change", "ice", "type", "point", "id", "hop", "info", "source", "ver", "me", "ace", "form", "name", "lock"]}}
{"id1": "2022160", "id2": "7891509", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"write": ["next", "process", "writer", "connect", "service", "size", "sync", "kill", "read", "flow", "output", "feed", "copy", "written", "run", "wrote", "open", "code", "out", "send", "lex", "end", "store", "Write", "cycle", "close", "exec", "set", "update", "data", "append", "put", "w", "call", "export", "writ", "play", "add", "flush", "dump", "create", "writing", "pipe"], "byteBuffers": ["connectionbuffERS", "bytesBuffatters", "connectionbuffeners", "bytebuffresses", "bytePackapers", " byteComplers", "byteBuffresses", "ByteBuffresses", "byteOrders", "byteBuffererers", " byteOffters", "byteWritlers", "byteBufferelines", "doubleHeadered", "ByteOrderers", " byteOffors", "byteCornatters", "byteOrdERS", "byteHeaders", " byteBuffares", "byteBuffapers", "byteBuildERS", "bytesPackers", "bytesBuffors", "connectionBuffeners", "byteBuffizers", "bytebuffings", "bytesCornatters", "byteDefelines", "connectionbuffers", "bytesPackerers", "byteCornests", "bytePackerers", "doubleHeadERS", "ByteOrdresses", "ByteBufflers", "byteBuffereners", "ByteBuffers", "byteIntegers", "byteDefers", "ByteOrdERS", "bytesBuffizers", "bytesBuffERS", " byteOrdlers", "doubleHeadings", "bytebuffests", "ByteBuffERS", "byteOrderers", "byteOffERS", "bytePackERS", "byteCornered", "bytesCorners", " byteBuffinals", " byteBuffors", "byteBufferERS", "bytebuffeners", "byteAkelines", " byteOrderers", "ByteBufferers", " byteBufflers", "bytesBuffelines", "byteDefatters", " byteCompERS", "byteInferers", "byteComplers", "bytebuffors", "byteChers", "byteCornares", "connectionBuffERS", "byteBuffinals", "byteInteginals", "bytesDefelines", " byteOrders", "bytebuffered", "wordBuffatters", "connectionBuffers", "byteBuilderers", " byteBuffeners", "byteAkizers", "byteChERS", "byteWritelines", "byteOffters", "bytesAkizers", "wordBuffers", "byteOrdeners", "byteOrdlers", "byteWritors", " byteOrdinals", "doubleBuffered", "byteWriters", "byteBuffters", " byteOffERS", " byteOrdERS", " byteOffers", "byteBufferers", "byteBuilders", " byteBuffters", "bytesAkers", " byteBuffERS", "byteDefERS", "byteBufferatters", "bytebuffiners", "doubleHeaders", "byteIntegERS", "byteIntegatters", "bytesBuffapers", "byteCompares", "bytesBuffers", "byteBuffERS", "byteHeadERS", "bytePackers", "bytebuffinals", "byteIntegeners", "bytebuffelines", "byteBuffelines", "bytesAkelines", "wordBufferers", "bytesDefERS", " byteCompares", "bytebuffERS", "byteOffers", "byteAkors", "byteOrdapers", "bytesDefers", "byteBuffings", "connectionbufferers", "bytebuffizers", "ByteOrders", "bytebuffers", "byteAkers", "byteBufflers", "byteChered", "bytebufflers", " byteCompers", "bytesBuffests", "doubleBuffERS", "byteCornERS", " byteOrdeners", "byteCompERS", "byteWritizers", "bytesPackapers", "bytesAkors", "byteChings", "byteBuffatters", "bytebufferers", "doubleBuffers", "byteInfers", " byteBuffiners", "wordBuffERS", "byteIntegelines", "byteHeadings", "byteHeadered", "bytesCornests", "bytesBuffered", "byteCompers", "byteOrdresses", "byteOrdinals", "byteCornlers", "connectionBufferers", "byteBuffered", "byteBuffests", "bytebuffatters", "doubleBuffings", " byteBufferers", "byteBufferlers", "byteOrdiners", "bytesBufferers", "byteCorners", "byteInfatters", "byteBufferapers", "byteWritiners", "byteBuffiners", "byteBuildatters", "byteInfERS", "bytesCornered", "byteWriterers", "byteBuffors", "byteOffors", " byteOrdiners", "byteBuffeners", "bytesPackERS", "bytebuffters", "bytesDefatters", "byteBuffares"], "m_initialOutBuffer": ["m_initialOutBuff", "m_initialAuthBuffer", "m_finalOutChannel", "m_initialShortChannel", "m_InitialOutLayer", "m_initialInLine", "m_initialoutAddress", "m_initialOutLine", "m_initialOutCache", "m_initialShortCache", "m_initialOutputBuff", "m_initialOutFile", "m_initialOutputHeader", "m_initialNewBuff", "m_initialAuthFile", "m_initialSocketBuffer", "m_initialSocketHeader", "m_finalInBuffer", "m_finalOutMessage", "m_initialNewMessage", "m_finalOutBuff", "m_initialOutHeader", "m_finalInMessage", "m_initialShortBuffer", "m_initialoutLine", "m_originalOutAddress", "m_InitialOutBuffer", "m_finalInChannel", "m_InitialOutFile", "m_InitialOutputHeader", "m_finaloutChannel", "m_initialClientLine", "m_originaloutBuffer", "m_initialInMessage", "m_InitialOutputLayer", "m_initialNewBuffer", "m_originalOutLine", "m_finalInFile", "m_initialoutFile", "m_initialInChannel", "m_initialoutChannel", "m_finalOutLine", "m_finalOutFile", "m_InitialOutHeader", "m_initialoutBuff", "m_initialShortFile", "m_finalInLine", "m_initialClientBuffer", "m_initialOutLayer", "m_initialSocketLayer", "m_finalInBuff", "m_initialInCache", "m_initialNewFile", "m_originaloutFile", "m_initialClientBuff", "m_finaloutBuffer", "m_originalOutBuffer", "m_originaloutAddress", "m_initialOutAddress", "m_finaloutFile", "m_initialOutMessage", "m_initialOutChannel", "m_finalOutCache", "m_initialSocketFile", "m_originalOutFile", "m_initialOutputChannel", "m_initialAuthAddress", "m_InitialOutputFile", "m_initialInBuff", "m_initialInLayer", "m_initialInFile", "m_finalOutBuffer", "m_finalInCache", "m_finaloutBuff", "m_initialOutputBuffer", "m_initialoutBuffer", "m_initialoutCache", "m_InitialOutputBuffer", "m_initialInAddress", "m_initialOutputFile", "m_initialInBuffer", "m_originaloutLine", "m_initialClientFile", "m_initialAuthLine", "m_initialOutputLayer", "m_initialInHeader", "m_initialOutputMessage"], "buffer": ["FFER", "cell", "comment", "Buffer", "address", "bc", "fb", "iter", "buf", "engine", "base", "re", "builder", "er", "shell", "reader", "string", "window", "flush", "back", "client", "batch", "console", "view", "feed", "input", "page", "cache", "stack", "array", "response", "message", "buff", "pool", "uffer", "file", "table", "event", "holder", "writer", "worker", "output", "object", "slice", "copy", "limit", "port", "phrase", "cur", "row", "url", "null", "callback", "channel", "wave", "source", "layer", "timeout", "template", "block", "queue", "transfer", "server", "ker", "resource", "f", "binary", "data", "temp", "loader", "document", "header", "bridge", "read", "config"], "buffers": ["ufers", "ufering", "buffERS", "bufering", " buffators", "transformERS", "affaches", "transformler", "Buffered", " buffered", "bufages", "buffler", "bufler", "transformers", " buffler", " buffars", " buffages", " buffERS", "Buffers", "bufered", " buffresses", "buffaches", "affors", "phages", "phators", "buffresses", "buferers", "transformering", "ufors", "Bufferers", "ufaches", "affering", "buffering", " bufferers", "buffors", " buffering", "bufators", "bufars", "bufresses", "phers", "bufferers", "buffars", "Buffars", "bufaches", "bufERS", "buffators", "buffered", "bufers", "bufors", "buffages", "phresses", "affers"], "result": ["request", "r", "success", "error", "match", "rate", "card", "flash", "output", "rc", "view", "use", "default", "comment", "consumer", "user", "future", "cache", "valid", "complete", "val", "json", "info", "diff", "or", "ver", "grade", "response", "report", "resource", "message", "Result", "successful", "inner", "ret", "results", "out", "manager", "function", "row", "date", "sr", "winner", "f", "acc", "url", "session", "data", "err", "cup", "er", "runner", "test", "status", "search", "driver", "res", "true", "event", "re", "up"], "encrypted": ["image", "pad", "selected", "flash", "entry", "stream", "transfer", "internal", "cache", " data", "source", "padding", "inner", "available", "binary", "channel", "temp", "loader", "packed", "secret", "text", "body", "reader", "interrupted", "extra", "flush", "layer", "config"]}}
{"id1": "7169984", "id2": "14609912", "code1": "    public static String connRemote(JSONObject jsonObject, String OPCode) {\n        String retSrc = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(AZConstants.validateURL);\n            HttpParams httpParams = new BasicHttpParams();\n            List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>();\n            nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode));\n            nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString()));\n            httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair));\n            httpPost.setParams(httpParams);\n            HttpResponse response = httpClient.execute(httpPost);\n            retSrc = EntityUtils.toString(response.getEntity());\n        } catch (Exception e) {\n            Log.e(TAG, e.toString());\n        }\n        return retSrc;\n    }\n", "code2": "    private static String lastModified(URL url) {\n        try {\n            URLConnection conn = url.openConnection();\n            return long2date(conn.getLastModified());\n        } catch (Exception e) {\n            SWGAide.printDebug(\"cach\", 1, \"SWGCraftCache:lastModified: \" + e.getMessage());\n        }\n        return \"0\";\n    }\n", "label": 0, "substitutes": {"connRemote": ["invokeIP", "invokeRemote", " executeIP", "invokeLocal", "execURL", " execRemote", " executeURL", "execLocal", " execURL", " executeLocal", " execIP", "invokeURL", "execIP", " execLocal", " executeRemote", "execRemote"], "jsonObject": ["JSONObject", "customOperation", "JSONOperation", "javaBody", "JSONString", "javaOb", "jsonObj", "jsonOb", "jsonOperation", "httpArray", " jsonString", "jsonArray", "JSONBody", "JSONOb", "JSONObj", " jsonBody", "javaString", "customObj", "jsonBody", "jsonString", "javaObject", "customArray", "httpObject", " jsonOb", "httpOperation", "customObject", "JSONArray", "httpObj"], "OPCode": ["OPAction", "OPERName", "opName", "OPcode", "OpAction", " OPAction", "OPERCode", "opAction", "OPName", "opCode", "OpCode", "OpName", "opcode", " OPcode", " OPName", "Opcode", "OPERcode"], "retSrc": ["retDuc", "retDrt", "retSvc", "retNRC", "retInuc", "retInRC", " retDsrc", "RetAsuc", "retSrt", "RetSrc", " retSvc", "retOsrc", " retDRC", "retInck", "retPRC", "retNvc", "retAsrc", "retOsrt", "retSck", "retAsRC", "retDrc", "retSsrc", "retNsrc", "retOssrc", "retDRC", "RetAsck", " retDrc", "retAsuc", "retPvc", "retSuc", "retSRC", "retPsrc", "retOsRC", "RetAsrc", "RetAsRC", "retNrt", "retAsck", "retDsrc", " retSsrc", "RetSRC", " retSrt", "retNrc", " retSRC", " retDrt", "retInrc", "RetSuc", "retPrc", "retDck", "RetSck"], "httpClient": ["httpsPost", "httpsCall", "xmlProxy", "phpPost", "HttpClient", "httpProxy", "httpCase", "httpConnection", " httpConnection", "phpClient", "apiClient", "xmlCase", "httpclient", "httpCall", "HttpCase", "apiCall", "httpsClient", "xmlClient", "HttpProxy", "HttpConnection", "phpclient", "apiclient", "xmlConnection", "httpsclient", "phpCall", " httpCase", " httpProxy", "apiPost"], "httpPost": ["workpost", "httpsPost", "HttpRequest", "workPre", "htmlCopy", "httpCopy", "phpPost", "httppost", "httpPOST", "autoPOST", "httpDo", "webpost", "webDo", " httpCopy", "htmlDo", "webPost", "HttpPOST", "httpPre", " httpDo", " httppost", "httpsCopy", "autoPre", "phpPOST", "HttpPre", " httpRequest", " httpPOST", "webPre", "httpRequest", "httpsPOST", "HttpPost", " httpPre", "autoCopy", "workDo", "HttpCopy", "autoPost", "htmlPost", "HttpDo", "httpsPre", "htmlPOST", "phpDo", "workPost", "phpRequest"], "httpParams": ["httpVariam", " httpPams", "httpVariams", "httpVariars", "httpPms", " httpParam", "httpParars", "httpVariums", "hrPams", "httpParam", "hrParams", "httpPerars", "httpPam", "hrParars", "httpArgam", "hrParam", "httpPars", "httpCatam", "httpPams", " httpParars", "httpPums", "hrPam", "httpPeram", "httpArgams", "httpArgars", "httpPerums", "httpCatars", "hrParms", "httpParms", " httpPums", " httpParums", "httpCatams", "hrPars", " httpPam", "httpParums", "httpPerams", "httpCatms", " httpPars", "httpArgms", "hrPms"], "nameValuePair": ["nameValueProtore", "nameValueParair", "nameValuepatch", "nameValueCpair", "nameValuePerair", "nameValueSore", "nameValuePore", "nameValueLair", "nameValuePhair", "nameVPpair", "nameValueCair", "nameValueLolder", "nameValuePointpair", "nameValuePpair", "nameValueSpair", "nameNameProtpair", "nameValueFortion", "nameNamePatch", "nameNameProtair", "nameNamePiece", "nameValuePhiece", "nameNamePolder", "nameVCait", "nameValueSair", "nameVPait", "nameNameProtore", "nameValueportion", "nameValuePhortion", "nameValueppair", "nameValueParpair", "nameValuePointair", "nameValuepair", "nameValuePatch", "nameValueLatch", "nameValuePait", "nameValuePortion", "nameVCpair", "nameValuepolder", "nameNameportion", "nameValueCait", "nameNamePortion", "nameNameLolder", "nameNamePore", "nameValueProtpair", "nameValuePolder", "nameValuePerolder", "nameValuepait", "nameValuePenter", "nameValuePointenter", "nameNameLair", "nameVCair", "nameValueProtair", "nameNamepair", "nameValuepiece", "nameValueFiece", "nameNamepiece", "nameNamePenter", "nameValuePeratch", "nameValueFair", "nameNameLatch", "nameValuePiece", "nameNamePair", "nameValueProtenter", "nameValueSenter", "nameVPair", "nameValuePointore", "nameNamePpair", "nameValueParait", "nameNameProtenter"], "response": ["Response", "resource", "jet", "application", "status", "entity", "full", "respond", "site", "environment", "channel", "reply", "request", "http", "method", "view", "api", "wave", "feed", "tree", "json", "object", "resp", "connection", "server", "throw", " Response", "f", "block", "e", "session", "i", "success", "res", "result", "page", "v", "output", "data", "message", "body"]}}
{"id1": "5676111", "id2": "19687456", "code1": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 0, "substitutes": {"get": ["exec", "output", " download", "export", "start", " extract", "end", " upload", "build", "info", "print", " it", " quit", "close", "it", "process", "let", "init", "download", " this", " exit", "open", "run"], "cnt": ["rcnt", "Cwd", "cnn", "fount", "cst", "Cnc", "cnd", " cnd", "rcnd", "Cst", "encNT", "Count", " count", "cwd", " cnc", "fwd", "cNT", " cst", "count", "encnn", " cnn", "rcNT", "fnt", "encnt", "CNT", "Cnn", "Cnt", " cNT", " cwd", "rcnc", "fNT", "encst", "Cnd", "cnc"], "url": ["client", "cache", "str", "bb", "URL", "git", "cur", "path", "log", "sl", "Url", "host", "session", "ir", "ls", "name", "image", "c", "org", "ssl", "connection", "r", "b", "ll", "www", "config", "loc", "socket", "ur", "uri", "resource", "bel", "http", "l", "page", "source", "file", "server", "channel", "download", "coll", "impl", "open", "web", "blog", "f"], "conn": ["exec", "cm", "client", "ai", "ann", "ca", "ob", "io", "not", "cur", "ctx", "connect", "oss", "out", "conv", "cp", "c", "ci", "err", "os", "org", "en", "ec", "ct", "connection", "ssl", "Connection", "n", "enc", "co", "loc", "socket", "dc", "api", "p", "http", "col", "cli", "ch", "server", "init", "cn", "act", "coll", "ens", "con", "nc", "Conn", "open", "cb"], "is": ["us", "im", "ais", "ip", "ai", "ib", "ois", "ob", "are", "isa", "iso", "io", "id", "IS", "bis", "ws", "Is", "es", "res", "ir", "s", "ui", "ris", "ci", "isl", "ios", "iss", "os", "or", "ssl", "ie", "i", "info", "lis", "loc", "isc", "isi", "ri", "uri", "iter", "api", "open", "close", "iris", "http", "in", "init", "src", "as", "bs", "il"], "filename": ["fp", "title", "login", "output", "fil", "family", "ename", "path", "folder", "utf", "nl", "nil", "location", "name", "string", "length", "queue", "size", "prefix", "files", "username", "format", "connection", "class", "directory", "loc", "uri", "key", "fd", "phrase", "l", "source", "fn", "file", "password", "ername", "sf", "Filename", "f", "il"], "fos": ["Fo", " foss", "gos", "fus", "fdo", "fdicks", " fis", "loses", "lo", "Fus", "Foses", "foss", "lios", "efose", "efos", "Fos", "Fis", " fo", "Foss", "fios", "fose", "go", "gios", "Fios", "fis", "Ficks", "fdos", " fus", "los", "goses", "fo", "ficks", " ficks", " fose", "efoss", "fdis", "Fose", "foses", "efus"], "buffer": ["Buffer", "position", "address", "result", "base", "header", "uffer", "reader", "cache", "bb", "output", "transfer", "pause", "feed", "vector", "fb", "border", "input", "length", "sequence", "binary", "offset", "seed", "memory", "queue", "read", "layer", "duration", "reference", "batch", "counter", "b", "shape", "buf", "null", "number", "padding", "iter", "bytes", "wave", "flush", "document", "phrase", "page", "data", "channel", "file", "source", "server", "limit", "size", "buff"]}}
{"id1": "539195", "id2": "20886320", "code1": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "code2": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "label": 0, "substitutes": {"copy": [" cp", "create", "csv", "py", "paste", "load", "download", "cat", "cop", "io", "clone", "rm", "it", "change", "transfer", "zip", "split", "Copy", "cp", "opy", "write", "delete", "replace", "php", "put", "file", "get", "cmp"], "src": ["source", "remote", "filename", "sb", "uri", "sync", "path", "config", "s", "archive", "txt", "image", "sin", "inst", "loc", "RC", "sys", "resource", "rs", "img", "sup", "url", "name", "code", "sit", "sel", "sub", "sc", "sl", "secure", "dist", "rc", "rb", "string", "gb", "cur", "upload", "stream", "ruby", "desc", "file", "ssl", "href", "slice", "id", "target"], "dest": ["text", "source", "them", "filename", "flat", "prop", "output", "feat", " destination", "home", "buff", "wd", "txt", " Dest", "rest", "default", "loc", "data", "const", "folder", "done", "later", "tmp", "du", "tern", "die", "destroy", "dat", "dist", "target", "comb", "orig", "test", "desc", "coord", "replace", "temp", "wb", "Dest", "dir", "slice", "end", "opt", "d", "delete"], "ifp": ["upp", "ibtp", "pppa", "dfap", "IFpp", " ifap", "ifcp", "ifap", "ifpa", "upcp", "uppp", "dfb", "dfpa", "ifb", " ifpp", "Ifpa", "ppb", "iftp", "dfp", " ifpa", "iplp", "ifi", "Ifp", "iplpa", "ppap", "upo", "ifo", "ibp", "ipltp", "ibi", "Iftp", " ifcp", "ifpp", " ifb", "ibpa", "IFp", "Ifi", "ppp", "IFo", " ifo", "ipli", "IFcp"], "ofp": ["Off", "ofy", "OFc", "ovi", "ofc", " ofi", "ippc", "ovf", " ofy", "ippy", "ippps", " off", "ippp", "OFy", " ofc", "Ofi", "Ofc", "OFp", "OFps", "ofps", "ovp", "Ofp", "ovc", " ofps", "off", "ofi"], "fis": ["infi", "flus", "infos", "infiss", "fiss", "flis", " fps", "ofis", "cfi", "ofbis", " fiss", "flps", "hps", "fps", "cfiss", "his", " fus", "hs", "hus", " fais", "infis", "fais", " fbis", "fus", "fs", "cfis", "cfbis", " fi", " fs", "fbis", "fls", "ofos", "ofais", "cfais", "fi", "cfos"], "fos": ["foses", " foses", "fpos", "bos", "foes", " foser", "Foes", "foser", " fops", "pos", "Fos", "poses", "bios", " fpos", "pis", "Fis", " fios", "Foses", "ifops", " foes", "boser", "poes", "ifos", "ifis", "ifoser", "fios", "Fios", "Fpos", "bis", "fops", "bpos", "bops"], "b": ["p", "ab", "buffer", "sb", "xb", "br", "c", "f", "bb", "buff", "ba", "buf", "e", "i", "l", "mb", "B", "ib", "binary", "lb", "bf", "bi", "a", "base", "bound", "nb", "bs", "rb", "eb", "gb", "h", "abb", "emb", "wb", "r", "ob", "boot", "bis", "v", "db", "d"]}}
{"id1": "23215235", "id2": "2113444", "code1": "    public void readFile(URL url) throws PedroException, IOException, ParserConfigurationException, SAXException {\n        this.zipFileName = url.toString();\n        URLConnection urlConnection = url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n        unzipNativeFormatFile(inputStream);\n        parseAlertFiles();\n        deleteAlertFiles();\n    }\n", "code2": "    private VelocityEngine newVelocityEngine() {\n        VelocityEngine velocityEngine = null;\n        InputStream is = null;\n        try {\n            URL url = ClassPathUtils.getResource(VELOCITY_PROPS_FILE);\n            is = url.openStream();\n            Properties props = new Properties();\n            props.load(is);\n            velocityEngine = new VelocityEngine(props);\n            velocityEngine.init();\n        } catch (Exception e) {\n            throw new RuntimeException(\"can not find velocity props file, file=\" + VELOCITY_PROPS_FILE, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n        return velocityEngine;\n    }\n", "label": 0, "substitutes": {"readFile": ["readContent", "readZip", "readFiles", "loadFile", " readZip", "loadZip", " readContent", "importFiles", "importZip", "loadContent", " readFiles", "importContent", "importFile", "loadFiles"], "url": ["image", "job", "client", "buffer", "service", "sl", "stream", "host", "class", "object", "feed", "input", "user", "bug", "page", "server", "address", "filename", "connection", "location", "http", "path", "resource", "URL", "io", "xml", "ssl", "file", "str", "link", "f", "Url", "base", "zip", "data", "download", "loader", " URL", "name", "l", "browser", "reader", "uri", "source", "config"], "IOException": ["IPInterface", " IOInterface", "IOInterface", "TimeoutInterface", "TimeoutException", "IPException"], "ParserConfigurationException": ["ParserConfigurationAPE", "ParserDefinitionException", "ParserDefinitionEX", "ParserConstructionEX", "InvalidConfigAPE", "ParserConfigurationEX", "ParserDefinitionAPE", "InvalidConfigurationAPE", "ParserConfigAPE", "ParserConstructionAPE", "InvalidConfigurationException", "InvalidConfigException", "InvalidConfigurationEX", "ParserConstructionException", "InvalidConfigEX", "ParserConfigEX", "ParserConfigException"], "SAXException": [" SAXPception", "SAXception", "SAXPException", "SAFEception", "SAXPception", " SAXception", "SAXMException", " SAXPException", "SAFEException", "SAXMception"], "zipFileName": ["zipFolderDirectory", "archiveFileDirectory", "zipFilesPath", "zipDirDirectory", "zipFolderPath", "archiveFilesType", "zipDirPath", "zipFilesDirectory", "archiveFilesPath", "zipFilesType", "zipDirType", "archiveFilesDirectory", "archiveFileName", "zipFilesName", "archiveFileType", "zipFileType", "zipFolderName", "zipDirName", "archiveFilesName", "archiveFilePath", "zipFilePath", "zipFolderType", "zipFileDirectory"], "urlConnection": ["webChannel", " urlResponse", "webconnection", "httpConnection", "URLconnection", " urlChannel", "inputConn", "urlconnection", "urlConn", "httpManager", "inputPool", "URLChannel", "httpPool", "httpConn", "inputConnection", "webResponse", "urlManager", "filePool", "inputManager", "urlChannel", "fileConn", " urlconnection", "webConnection", "URLResponse", "urlPool", "URLConnection", "fileManager", "urlResponse", "fileConnection"], "inputStream": ["outputContext", "InputFile", "inputChannel", "outputstream", "inputContext", "urlStream", "Inputstream", "InputChannel", "outputStream", "urlSession", " inputstream", "InputSession", " inputFeed", "outputChannel", "urlFeed", "urlFile", " inputFile", " inputSession", "InputStream", " inputContext", " inputChannel", "InputFeed", "InputContext", "inputFile", "inputSession", "inputFeed", "inputstream"]}}
{"id1": "2668853", "id2": "12306305", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFiletoFiles", "decodeFileAsStream", "decodeString2file", "decodeFile2Stream", "decodeFiletoFile", "decodeFileToStream", "decodeFiletofile", "decodeFileAsFiles", "decodeFileTofile", "decodeStringToFile", "decodeStringTofile", "decodeStringToStream", "decodeFileAsFile", "decodeString2Stream", "decodeFile2File", "decodeString2File", "decodeFileAsfile", "decodeFiletoStream", "decodeFileToFiles", "decodeFile2file", "decodeStringToFiles", "decodeString2Files", "decodeFile2Files"], "infile": ["minfile", "infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", "inputfp", " inFile", "inputFile", "outfiles", " infilename", "inputfiles", " infiles", "outfp", "minfilename", "minFile", "minfp", "inputfilename", "infilename"], "outfile": ["infp", "outfull", "outputfile", " outfull", "outfilename", "outFile", " outFile", "infolder", "outputfolder", " outfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "outputfull", "Outfull", "Outfolder", "OutFile", "Outfile", "outputFile", "infilename", " outfilename"], "in": ["IN", "pin", "i", "input", "inas", "ex", "ini", "gin", "ic", "con", "inner", "socket", "as", "ins", "s", "bin", "is", "reader", "source", "up", "login", "min", "inside", "r", "inc", "data", "rin", "init", "conn", "again", "m", "e", "image", "re", "In", "nin", "a", "lin", "err", "b", "ac", "cin", "inn", "f", "win", "this", "din"], "out": ["base", "ex", "output", "copy", "outer", "op", "lock", "on", "net", "OUT", "socket", "as", "inner", "outs", "o", "s", "off", "line", "write", "bin", "co", "pass", "exit", "post", "client", "sync", "session", "no", "cache", "lib", "up", "target", "other", "inc", "work", "file", "conn", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "exp", "In", "ext", "b", "obj", "err", "error", "point"], "buffer": ["address", "base", "input", "Buffer", "uffer", "resource", "pause", "border", "server", "feed", "slice", "limit", "result", "length", "bin", "memory", "queue", "offset", "iter", "split", "reader", "source", "binary", "seed", "buff", "value", "buf", "wave", "data", "size", "bb", "null", "row", "bytes", "layer", "flush", "url", "shape", "b", "reference", "padding", "pad", "transfer", "batch"], "read": ["index", "Read", " receive", " r", "run", "ride", " get", "open", " copy", "get", "lex", " send", " check", "id", "feed", "add", "ind", "end", "find", " reach", "next", "sync", "use", "load", " sleep", "r", "work", "fill", "exec", "skip", "connect", " request", "play", " use", "reading", " parse", "limit", "se", "length", "write", "line", "ad", "sleep", "iter", "allow", "reader", " Read", "start", "tell", " load", "wait", " write", "input", "copy", " connect", "current", "reads", "pass", "select", " ride", "seek", "inc", " find", "check", "x", "size", " reader", "send", "k", "parse", "count", "READ"], "success": ["roll", "accept", "job", "response", "rolling", "ok", "continue", "ceed", "results", "warning", "better", "yes", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "selected", "default", "data", "safe", "null", "cess", "danger", "complete", "again", "status", " successful", "full", "correct", "good", "Success", "successful", "successfully", "rolled", "found", " succ", "zero", "error", "fast", "first", "winner", "initial"]}}
{"id1": "1769771", "id2": "5061606", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyChannel", "copyFiles", "copyfile", "transferChannel", "transferFile", " copyChannel", "transferFiles", "CopyChannel", "CopyFile", "Copyfile"], "in": ["image", "m", "pin", "query", "inn", "i", "input", "id", "ex", "diff", "lin", "inner", "index", "io", "work", "file", "min", "f", "url", "base", "login", "data", "ins", "name", "bin", "In", "l", "reader", "IN", "again", "lock", "win", "source", "config", "c", "inc"], "out": ["Out", "plain", "image", "writer", "p", "off", "n", "up", "output", "default", "user", "write", "ex", "server", "cache", "conn", "target", "ext", "resource", "io", "file", "x", "dot", "o", "prefix", "base", "exec", "b", "v", "w", "call", "name", "again", "string", "point", "outs", "extra", "external", "OUT", "c"], "inChannel": [" inClient", "inClient", "insClient", "insStream", "outStream", "binClient", " inchannel", "inchannel", "inputChannel", "INStream", "INChan", "outchannel", "outChan", "binChannel", " inChan", "InClient", "InStream", "winchannel", "inputchannel", "binchannel", "INChannel", "InChan", "inputChan", "inChan", "binChan", " inStream", "InChannel", "winChannel", "winStream", "Inchannel", "insChan", "INchannel", "winChan", "insChannel", "outClient", "inputStream", "binStream", "inStream"], "outChannel": ["inputController", "outStream", " outchannel", "inputChannel", " outCh", "inchannel", "nChannel", "OutChan", "outchannel", "outChan", "outputController", "outCh", "inCh", "OutChannel", "outController", "outputChan", "outputStream", "OutConnection", "outputchannel", "nChan", "inputchannel", "outputCh", " outChan", "outputChannel", "nStream", " outConnection", " outStream", "inputChan", "inChan", "outConnection", " outManager", "inConnection", "nManager", "outManager", "inManager", "Outchannel", "inController", "inStream"]}}
{"id1": "8515891", "id2": "20519261", "code1": "    protected String readUrl(String svnUrl) throws IOException {\n        URL url = new URL(svnUrl);\n        URLConnection uc = url.openConnection();\n        if (url.getProtocol().equals(\"https\")) {\n            String userPassword = user + \":\" + password;\n            String encoding = new sun.misc.BASE64Encoder().encode(userPassword.getBytes());\n            uc.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        InputStream is = null;\n        String in = null;\n        try {\n            is = uc.getInputStream();\n            in = read(is);\n        } finally {\n            try {\n                is.close();\n            } catch (Exception e) {\n            }\n        }\n        return in;\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 0, "substitutes": {"readUrl": ["processQuery", "readURL", "ReadUrl", "readQuery", "getUrl", "processPage", "ReadPage", "processURL", "readPage", "processUrl", "getQuery", "getURL", "ReadQuery", "ReadURL", "getPage"], "svnUrl": ["svlEl", "svpnUrl", "svnUr", "svNURL", "svnFile", "svpnFile", "svcnURL", "svNEl", " svnUr", " svNURL", " svNUrl", "svlURL", " svnStr", "svcnStr", " svnEl", " svnFile", " svnURL", "svbUr", "svpnUr", " svNUr", "svlUrl", "svnURL", "svNStr", " svNStr", " svNFile", "svlStr", "svNFile", "svbUrl", "svnEl", "svNUr", "svNUrl", "svnStr", "svcnUrl", " svNEl", "svbFile", "svcnEl", "svpnURL", "svbURL"], "url": ["bc", "cl", "client", "util", "bb", "ob", "feed", "URL", "cur", "path", "log", "sl", "Url", "context", "conn", "stream", "bug", "c", "this", "org", "ssl", "connection", "r", "user", "b", "www", "config", "fc", "pull", "loc", "ur", "ul", "uri", "resource", "http", "plug", "l", "page", "server", "up", "open", "web", "blog", "f"], "uc": ["exec", "us", "bc", "cl", "cf", "lc", "mc", "client", "uci", "cur", "roc", "tc", "connect", "oc", "conn", "cci", "soc", "cp", "bug", "c", "cc", "hub", "ec", "ssl", "connection", "auc", "uca", "cu", "ub", "co", "fc", "loc", "anc", "ul", "uri", "UC", "cas", "ucc", "http", "rc", "sc", "up", "userc", "pc", "coll", "ac", "con", "usc", "ocr"], "userPassword": ["userpassword", "Userpassword", "useAuth", "currentpassword", " userPass", "userAuth", "useSecret", " userSecret", "usepassword", "UserAuth", "currentPass", "usePassword", "userPass", " userAuth", "userSecret", " userpassword", "usePass", "UserPass", "currentPassword", "UserPassword", "currentSecret"], "encoding": ["encoder", "enoding", "Encoded", "Encasing", "engoding", "encoded", "engasing", " encoded", "enasing", "Encording", "engoder", "Encoder", "enoded", " encoder", "encasing", "engoded", "encording", "Encoding", " encording", "enording", "enoder"], "is": ["us", "serv", "ais", "ins", "ip", "ms", "ib", "ois", "iso", "id", "isa", "was", "are", "has", "IS", "bis", "vs", "ws", "Is", "es", "abs", "ir", "out", "ui", "ls", "ris", "s", "ci", "isl", "si", "iss", "ios", "os", "nis", "ori", "i", "info", "ie", "irc", "cs", "lis", "isc", "isi", "ri", "uri", "fs", "api", "it", "its", "iris", "init", "src", "as"], "in": ["gin", "ins", "din", "reader", "IN", "atin", "login", "re", "bin", "id", "isin", "inc", "raw", "vin", "ini", "input", "out", "In", "string", "inner", "inas", "oin", "read", "m", "i", "edIn", "again", "rec", "tin", "nin", "inn", "pin", "into", "cin", "source", "line", "arin", "inside", "kin", "rin", "pc", "con", "reading", "f"]}}
{"id1": "8216539", "id2": "7149578", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFilecontentInStream", "getFileContentAsText", "getFileContentInStream", "getFilecontentAsStream", "getFileContentasStream", "getFileContentFromText", "getFilecontentInString", "getFileContentAsStr", "getFileContentasText", "getFileContentInText", "getFilecontentAsStr", "getFileContentasString", "getFileContentFromString", "getFileContentasStr", "getFilecontentAsString", "getFileContentInStr", "getFileContentFromStream", "getFilecontentInText", "getFileContentAsStream", "getFileContentInString", "getFilecontentInStr", "getFileContentFromStr", "getFilecontentAsText"], "filePath": ["fileName", "baseUrl", "singlepath", "basepath", "FileUrl", "resourceName", "filepath", "FileStr", "basePath", "Filepath", "singleLocation", " fileUrl", "baseName", "singleUrl", " fileStr", "resourcePath", "baseStr", "FileName", "FileLocation", "resourcepath", "fileUrl", "fileLocation", "baseLocation", "FilePath", "singlePath", "fileStr", " filepath", "resourceLocation"], "encoding": ["encryption", "enclocking", "equlocking", "encpling", "encging", "languagepling", "Encging", "Encryption", "Encasing", "decasing", "languageging", "encoded", "equoding", "Encpling", "Encoded", "coded", "cryption", "Encoding", "languageoding", "coding", "decoding", "decoded", "casing", "languagelocking", "encasing", "decryption", "Enclocking", "equging", "equpling"], "testURL": ["testingURI", "testingTL", "testTL", "TestUrl", "testingURL", " testUrl", "appurl", "fileURL", " testURI", "Testurl", " testRL", "appUrl", "TestUR", "testingUR", "testRL", "testingUrl", "testURI", " testurl", "testUrl", "shortTL", "shortURL", "appURL", "testUR", "testingRL", "fileUrl", "testingurl", "shortUrl", "shorturl", "testurl", "fileRL", "fileURI", "TestURL", "appUR", " testTL"], "input": ["dc", "resource", "temp", "pull", "entry", "act", "current", "instance", "qa", "op", "xml", "http", "inner", "bin", "path", "api", "feed", "this", "in", "active", "client", "ac", "conn", "ack", "audio", "connection", "init", "rc", "out", "element", "exec", "upload", "url", "get", "config", "enc", "Input", "but", "wrapper", "inside", "i", "ink", "image", "through", "socket", "inf", "result", "ssl", "img", "output", "reader", "data", "type", "raw", "error", "ou", "null", "acl", "inc", "parent", "source", "stream", "text", "binary", "form", "file", "flow"], "sw": ["ib", "wrap", "we", "wt", "sh", "nw", " SW", "sm", "sf", "iw", "tw", "wx", "io", "sc", "sa", "Sw", "ew", "ww", "wp", "cr", "w", "WS", "rc", "sn", "work", "rew", "aw", "now", "ws", "sl", "sb", "SW", "hw", "rw", "wrapper", "writer", "fp", "wr", "sk", "sv", "rx", "en", "web", "stream", "wb", "ow"]}}
{"id1": "12389873", "id2": "13159394", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public HttpResponse fetch(HttpServletRequest request) throws IOException {\n        GUI = SwingUI.getApplicatoin();\n        DefaultHttpClient httpclient = new DefaultHttpClient();\n        CookieSpecFactory csf = new CookieSpecFactory() {\n\n            public CookieSpec newInstance(HttpParams params) {\n                return new BrowserCompatSpec() {\n\n                    @Override\n                    public void validate(Cookie cookie, CookieOrigin origin) throws MalformedCookieException {\n                    }\n                };\n            }\n        };\n        if (Helper.useProxy()) {\n            HttpHost proxy = new HttpHost(Helper.getProxyServer(), Helper.getProxyPort());\n            httpclient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy);\n        }\n        httpclient.getCookieSpecs().register(\"easy\", csf);\n        httpclient.getParams().setParameter(ClientPNames.COOKIE_POLICY, \"easy\");\n        String currentRemoteGAEHost = Helper.getRemoteServer();\n        try {\n            HttpUriRequest httpRequest = createRequest(request);\n            addHeader(request, httpRequest);\n            HttpResponse response = httpclient.execute(httpRequest);\n            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_FORBIDDEN) {\n                challengeProxy(currentRemoteGAEHost);\n            }\n            logger.info(Helper.count.incrementAndGet() + \" Response received from \" + request.getRequestURL().toString() + \", status is \" + response.getStatusLine());\n            GUI.updateFetchCount();\n            return response;\n        } catch (ClientProtocolException e) {\n            logger.error(\"Fetch ClientProtocol Error\", e);\n            throw e;\n        } catch (IOException e) {\n            logger.error(\"Fetch IO Error\", e);\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"load": ["save", " Load", "Loading", "get", " loads", " loading", " reload", "sync", "ready", "download", "dump", "add", "loading", "construct", "test", "build", "init", "select", "process", "config", "transfer", "read", "clone", "Load", "link", " loaded", "write"], "conn": ["connection", "nt", "loc", "cn", "reg", "util", "nc", "session", "pt", "ca", "ct", "p", "dn", "state", "ns", "enc", "pub", "ec", "pc", "ann", "ls", "pr", "cache", "conf", "Exec", "cr", "client", "oci", "dc", "cat", "ci", "cc", "db", "connect", "ch", "ctx", "h", "exec", "col", "config", "n", "rt", "Conn", "c", "dh", "co", "coll", "sb", "con", "mc", "sql", "pg", "Connection", "cp", "act"], "stmt": ["stmi", "Stnt", " stts", "estql", " stmc", "Stmr", "stpl", "STbl", " stct", "putbt", " stnt", "str", "playor", "themt", "strk", "STmt", "flmd", "ostager", "playpl", "stmc", "putts", "elmt", "clmn", "putml", "stmr", "dnt", "stpr", "Stct", "stdb", "slmn", "strdo", "stql", "StMT", "Stpr", "Stts", "acttor", "cltr", "ostpl", "tpl", "ostmn", "putur", "elmi", "ostpr", "stnt", "Stmc", " stbl", "putmt", "slk", "Stmn", "estdo", " stmb", "estMT", " stpr", "Stmt", " stdb", "acttr", "estct", "STml", "stmd", "estmr", " stm", "Stmb", "actmt", "theb", "ostct", "playmn", "sttor", "themn", " stmr", "stth", " stml", "stts", "Stbl", "themc", " sttr", "atMT", "stml", "atb", "elml", " stager", "osttr", "playml", "plmn", "Stql", " stth", "slmt", "astk", "Stm", " strs", "Stmd", "slager", "fldo", "stct", "STager", "astmn", "ostmt", " stbt", "dMT", "estmt", "Stml", "STmd", "stager", " sttor", " stmn", "STk", "elrs", "STnt", "flmt", " stor", "STpl", "putmn", "estmd", "astql", "Stor", "STct", "playtr", "Stb", "clur", "plr", "putrs", "atmn", "plMT", "Stpl", "clmt", "atmt", "Stager", "tm", "puttr", "stbl", "dmd", "stmn", "stor", "strmt", "Sttor", "tmt", "stm", "tct", "stmb", " stk", "stb", "esttr", "Stur", "plb", "sttr", "stk", "playmt", "plmt", " stql", "Sttr", "Stbt", "stMT", "STmn", "STMT", "putmb", " stMT", "Stth", "strmd", "estk", " stb", "putmi", "slr", "Stdb", " stmi", "STdb", "estth", " stpl", "STql", "strs", "astmt", "flk", "dmt", "stdo", "slnt", "actbl", "stbt", "plnt", "stur", " str"]}}
{"id1": "20414923", "id2": "22401746", "code1": "    protected int deleteBitstreamInfo(int id, Connection conn) {\n        PreparedStatement stmt = null;\n        int numDeleted = 0;\n        try {\n            stmt = conn.prepareStatement(DELETE_BITSTREAM_INFO);\n            stmt.setInt(1, id);\n            numDeleted = stmt.executeUpdate();\n            if (numDeleted > 1) {\n                conn.rollback();\n                throw new IllegalStateException(\"Too many rows deleted! Number of rows deleted: \" + numDeleted + \" only one row should be deleted for bitstream id \" + id);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"Problem deleting bitstream. \" + e.getMessage(), e);\n            throw new RuntimeException(\"Problem deleting bitstream. \" + e.getMessage(), e);\n        } finally {\n            cleanup(stmt);\n        }\n        return numDeleted;\n    }\n", "code2": "    public String sendRequest(java.lang.String servletName, java.lang.String request) {\n        String reqxml = \"\";\n        org.jdom.Document retdoc = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.util.zip.CheckedInputStream cis = new java.util.zip.CheckedInputStream(ios, new java.util.zip.Adler32());\n            java.util.zip.GZIPInputStream gip = new java.util.zip.GZIPInputStream(cis);\n            java.io.InputStreamReader br = new java.io.InputStreamReader(gip, \"UTF-8\");\n            retdoc = (new org.jdom.input.SAXBuilder()).build(br);\n        } catch (java.net.ConnectException conexp) {\n            javax.swing.JOptionPane.showMessageDialog(null, newgen.presentation.NewGenMain.getAppletInstance().getMyResource().getString(\"ConnectExceptionMessage\"), \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n        }\n        System.out.println(reqxml);\n        return \"\";\n    }\n", "label": 0, "substitutes": {"deleteBitstreamInfo": ["deleteBitstreamINFO", "deletebitStreamINFO", "deleteBitStreaminfo", "deletebitStreamDetails", "deleteBitsystemINFO", "deleteBitstoreINFO", "deletebitStreamInfo", "deleteBitstoreDetails", "deleteBitstreaminfo", "deletebitStreaminfo", "deleteBitstreamDetails", "deletebitstreamDetails", "deletebitstreaminfo", "deletebitstreamINFO", "deleteBitsysteminfo", "deleteBitsystemDetails", "deleteBitStreamInfo", "deleteBitStreamINFO", "deleteBitStreamDetails", "deletebitstreamInfo", "deleteBitstoreInfo", "deleteBitsystemInfo", "deleteBitstoreinfo"], "id": ["ids", "x", "offset", "did", "aid", "seq", "data", "name", "error", "type", "create", "ident", "p", "info", "ip", "one", "status", "oid", "mid", "part", "num", "ide", "root", "vid", "key", "address", "kid", "d", "count", "i", "which", "source", "entry", "db", "path", "parent", "object", "pid", "like", "url", "no", "code", "number", "ID", "in", "index", "Id", "uid", "ref", "rid", "sid", "ad", "start"], "conn": ["connection", "nt", "cn", "nc", "session", "ca", "ct", "sync", "dn", "enc", "ann", "rc", "pr", "jp", "cr", "client", "mn", "dc", "ci", "cc", "ctx", "connect", "db", "ch", "cf", "exec", "col", "config", "server", "rt", "Conn", "c", "co", "stat", "coll", "cm", "con", "mc", "sql", "cp", "Connection", "pg", "serv", "obj", "act"], "stmt": ["sttr", "Stmr", "Stmn", " stmn", " stpr", "Sttr", "stMT", "strdb", "strmr", "Stmt", " start", " stdb", "strm", "stmd", " stm", " stMT", "strmd", " stmr", "shMT", " stmd", "Stdb", "stpr", "stmr", " sttr", "stdb", "shmd", "StMT", "Stpr", "Stlt", " stlt", "strpr", "stlt", " stst", "stmn", "strmt", "strtr", "stst", "stm", "Stst", "shart", "Stm", "Start", "Stmd", "shmt", "start", "strmn", "strMT", "strlt", "strst"], "numDeleted": ["numDeoded", "numdelected", "numDelete", "Numdeleted", "numDelected", "NumDeleted", "numNeleted", "numUndleted", " numDeoded", " numdeashed", " numDeashed", "numDuleted", "numdeleted", "NumDeigrated", "numdeigrated", "numUndDelete", "numExletes", "numDeletes", "numDuDelete", "numDeashed", "numDeloded", "numdeashed", "numExashed", " numdeoded", "numDellected", "numDefleted", "Numdeigrated", " numDeased", "numdeued", "numdelete", "numDeDelete", "numDeased", "numModleted", "numDelased", " numDeletes", " numDelete", "numdeletes", "numDeigrated", "numNeletes", "numExoded", "numDuigrated", "NumdeDelete", "numNelete", "NumDeued", " numdeleted", " numDelected", "NumDeDelete", "numdeoded", "numModletes", "numModashed", "numdeDelete", "numDelleted", " numdelected", "numExleted", " numdeased", " numdeletes", "numDefoded", "numDeflected", "numUndued", "numdeased", "numMododed", "numDefased", "Numdeued", "numDeued"]}}
{"id1": "310182", "id2": "13657103", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["conception", " deconvert", "Convert", "converting", "subvert", "unversion", " deconverting", "CONverting", "unvert", "CONvert", "unception", "Conversion", " deconverted", "unverted", "subverted", "Converted", "conversion", " deconversion", "CONverted", "subversion", "oconvert", "CONversion", "converted", "Conception", "Converting", "CONception", "subverting", "oconversion", "oconverted", "oconverting"], "src": ["reader", "username", "cb", "sin", "loc", "RC", "name", "sn", "gb", "s", "sc", "slice", "cpp", "stream", "st", "secure", "inst", "download", "sth", "load", "gz", "proc", "sys", "rc", "SourceFile", "ssl", "component", "ource", "prot", "req", "feat", "video", "img", "href", "fn", "dist", "back", "rb", "cmp", "source", "storage", "ctx", "path", "spec", "filename", "attr", "stage", "url", "config", "code", "uri", "sit", "file", "impl", "Dest", "upload", "sel", "scene", "sb", "input", "resource", "Source", "fp", "ref", "rl", "string", "obj", "buf", "tmp", "supp"], "dest": ["bin", " destination", "cont", " dst", "class", "orig", "di", "txt", "img", "fn", "dist", "temp", "std", "dc", "test", "lib", "source", "disk", "path", "null", "Dest", "target", "dir", "dat", "home", "obj", "tmp"], "in": ["reader", "bin", "inf", "isin", "login", "f", "data", "doc", "inas", "ins", "pin", "stream", "ex", "In", "is", "win", "r", "din", "val", "IN", "err", "ini", "d", "i", "source", "inc", "t", "n", "pass", "ps", "inn", "io", "as", "up", "file", "a", "input"], "p": ["f", "lp", "tp", "s", "g", "py", "m", "j", "pi", "wp", "pc", "per", "pr", "jp", "b", "part", "op", "l", "bp", "pre", "cop", "e", "r", "parser", "o", "pp", "d", "i", "sp", "t", "h", "v", "ps", "pe", "c", "P", "pm", "np", "pa", "po", "fp", "pd", "cp", "pg", "pb"], "ds": ["data", "dl", "dd", "services", "groups", "ys", "cs", "ls", "ld", "tools", "d", " props", "js", "ded", "xs", "uds", "ps", "ils", "ges", "tests", "pd", "ads", " sd", "df", "lp", "ups", "ins", "bs", "Ds", "os", "sys", "sts", "obs", "rs", "dds", "dm", "nas", "gd", "hs", "points", "ipes", "qs", "DS", "styles", "des", "ss", "ks", "dos", "cons", "ts", "vals", "eps", "els", "icks", "da", "ns", "parts", " ps", "dist", " DS", "posts", "dc", "scripts", "ths", "dates", "vs", "gs", "ays", "dat", "docs", "dt", "s", "sync", "utils", "ans", "di", "words", "models", "lines", "db", "dp", "ants", "amps", "plugins"], "format": ["tag", "data", "f", "layout", "sche", "scale", "name", "version", "at", "ant", "handler", "type", "table", "language", "filter", "letter", "feat", "class", "plugin", "model", "part", "magic", "fn", "parser", "atter", "style", "source", "template", "t", "api", "spec", "struct", "filename", "pattern", "path", "form", "url", "config", "unit", "Format", "file", "function", "act", "prefix", "fd", "frame", "record", "host", "fp", "string", "nat"], "hasPixelData": ["hasPicturedata", "hasPictureSize", "hasByteData", " hasPixeldata", "hasPixeldata", "showsPixelDATA", "hasPixelSize", "hasPixelStyle", "showsByteStyle", " hasPixelSize", "showsBytedata", "hasByteStyle", "showsPixeldata", "showsByteData", "hasPictureData", "hasByteSize", "showsByteDATA", "hasByteDATA", "showsPixelData", "haspixeldata", "hasBytedata", "hasPixelDATA", "haspixelSize", "haspixelData", "showsPixelStyle"], "inflate": ["insflATE", "invenATE", "inflode", "inffated", "inFlated", "InFlace", "Inflace", "invenate", "insflate", "inflated", "inadequating", "inFlace", "insflating", "infolating", "infolATE", "inadequATE", "invenode", "inadequode", "insflode", "inffation", "infloated", "insvenATE", "invenating", "inffate", "inFlate", "inadequate", "inflating", "InFlated", "infolode", "infface", "Inflated", "Inflate", "InFlation", "inflation", "Inflation", "infloace", "insvenating", "insvenode", "infolate", "InFlate", "inflATE", "inflace", "infloate", "insvenate", "infloation", "inFlation"], "pxlen": ["mxlen", "fxdata", "mxpos", "campos", "pclon", "axln", "ppl", "txlen", "fxLen", "pxdata", "pxsize", "pngcount", "xpsize", "pxpos", "txln", "xpcount", "ppLen", "txlin", "mxdata", "camdata", "camln", "mxln", "axlen", "pcln", "pnglength", "pglen", "pxden", "fxden", "txlon", "pgLen", "pxl", "pxlength", "pxlon", "axlon", "pclin", "camlen", "pgden", "pxln", "mxcount", "pngsize", "fxln", "pgl", "mxlength", "mxsize", "axlin", "pclen", "fxl", "pxcount", "fxpos", "pxLen", "fxlen", "xplen", "pnglen", "ppden", "pxlin", "xplength", "pplen"], "out": ["lock", "point", "error", "session", "state", "outs", "gen", "dump", "sys", "log", "copy", "page", "cache", "user", "again", "output", "conn", "line", "work", "query", "err", "OUT", "list", "lib", "cli", "step", "parent", "v", "store", "server", "group", "post", "io", "up", "co", "inter", "pad", "re", "Out", "obj"]}}
{"id1": "10795866", "id2": "812803", "code1": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"upload": [" transform", "paste", "run", "full", "zip", "clean", "view", "transform", "report", "open", "process", "post", "download", " Upload", "up", "url", "delete", "load", "Upload", "dump", "image", "transfer", "save", "output", "info", "stream", " thumbnail", "create"], "destDir": ["destPath", "distdir", "srcDir", " destDirectory", "DestDirectory", "destFile", "DestPath", "destDIR", "srcDirectory", "Destdir", "destdir", "DestFile", "destDirectory", "distDIR", "srcFile", "DestDir", "distDir", "srcPath", "srcDIR", "srcdir", "distFile", " destdir", "DestDIR", " destPath"], "fos": ["Foses", "lOS", "sfis", "fo", " fOS", " foses", "fdos", "fios", "nows", "foos", "paos", "fdios", "no", "fdOS", "faos", " fios", " fo", "nos", "pos", "los", "foows", "noss", "fOS", " fows", "foo", " foser", "fdoser", "foses", " fis", "Fos", " faos", "fis", "lo", "FOS", "Fios", "Faos", "lis", "fooss", " foss", "sfo", "sfOS", "Fo", "fows", "po", "foss", "poses", "Foser", "sfos", "foser"]}}
{"id1": "19235551", "id2": "1097147", "code1": "    protected BufferedImage handleFCLAException() {\n        if (params.uri.startsWith(\"http://image11.fcla.edu/cgi\")) try {\n            params.uri = params.uri.substring(params.uri.indexOf(\"q1=\") + 3);\n            params.uri = params.uri.substring(0, params.uri.indexOf(\"&\"));\n            params.uri = \"http://image11.fcla.edu/m/map/thumb/\" + params.uri.substring(params.uri.length() - 3, params.uri.length() - 2) + \"/\" + params.uri.substring(params.uri.length() - 2, params.uri.length() - 1) + \"/\" + params.uri.substring(params.uri.length() - 1, params.uri.length()) + \"/\" + params.uri + \".jpg\";\n            URL url = new URL(params.uri);\n            URLConnection connection = url.openConnection();\n            return processNewUri(connection);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"handleFCLAException": [" handlePCLError", " handleFCLError", " handleFCMAException", " handlePCLAError", " handleFCAError", " handlePCLAException", " handleFCMA1", " handleFCLception", " handleFCLA1", " handlePCLception", " handleFCLAception", " handlePCLAception", " handleFCMAception", " handlePCLException", " handlePCL1", " handleFCA1", " handleFCMAError", " handleFCAException", " handleFCLException", " handleFCL1", " handlePCLA1", " handleFCLAError", " handleFCAception"], "params": ["data", "type", "services", "ls", "css", "members", "features", "source", "ps", "as", "module", "resources", "images", "ams", "cache", "apps", "rs", "parse", "points", "phys", "spec", "names", "errors", "styles", "tags", "global", "series", "result", "es", "rules", "json", "eps", "database", "options", "param", "model", "parts", "ops", "Parameters", "posts", "vm", "temp", "external", "pins", "image", "api", "vs", "config", "details", "http", "pos", "same", "res", "site", "manager", "master", "s", "results", "settings", "relations", "base", "plugin", "status", "words", "models", "video", "files", "list", "i", "request", "server", "core", "photos", "changes", "plugins", "types", "media"], "uri": ["sequence", "version", "git", "archive", "iri", "type", "detail", "binary", "oid", "picture", "service", "source", "cli", "path", "transfer", "route", "io", "module", "message", "resource", "gi", "directory", "tile", "volume", "origin", "theme", "ori", "description", "query", "distance", "nuclear", "doi", "address", "mi", "ui", "general", "metadata", "duration", "folder", "id", "containing", "database", "remote", "verb", "umi", "component", "multi", "ini", "image", "api", "http", "title", "prefix", "eni", "location", "username", "site", "uin", "URI", "force", "ri", "slice", "course", "pi", "mode", "wiki", "direction", "plugin", "future", "domain", "href", "i", "nexus", "response", "filename", "server", "unit", "core", "menu", "link", "uni", "license"], "url": ["open", "sl", "director", "loc", "channel", "layer", "web", "base", "ssl", "plugin", "control", "page", "conn", "user", "l", "client", "Url", "proxy", "URL", "source", "image", "path", "object", "system", "config", "li", "server", "browser", "http", "file", "id", "resource", "target", "window", "orb", "link", "location", "string"], "connection": ["open", "data", "channel", "socket", "handler", "database", "body", "application", "communication", "control", "conn", "section", "client", "proxy", "service", "connected", "condition", "image", "db", "connect", "i", "response", "object", "ion", "character", "context", "close", "config", "document", "relation", "server", "io", "http", "c", "result", "resource", "con", "Connection", "string"]}}
{"id1": "17856064", "id2": "7122523", "code1": "    public static PersistencyParameters parse(String unitName) {\n        URL[] persistenceUnits;\n        try {\n            persistenceUnits = Classpath.search(\"META-INF/\", \"persistence.xml\");\n        } catch (IOException e) {\n            throw new Error(e);\n        }\n        Set classes = new HashSet();\n        for (int i = 0; i < persistenceUnits.length; i++) {\n            URL url = persistenceUnits[i];\n            try {\n                nu.xom.Builder b = new nu.xom.Builder(false);\n                Document d = b.build(url.openStream());\n                Nodes unitNodes = d.getRootElement().query(\"//p:persistence-unit\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                for (int j = 0; j < unitNodes.size(); j++) {\n                    Node unitNode = unitNodes.get(j);\n                    Element unitElt = ((Element) unitNode);\n                    String uName = unitElt.getAttributeValue(\"name\");\n                    if (!uName.equals(unitName)) continue;\n                    {\n                        PersistencyParameters parameters = new PersistencyParameters();\n                        Nodes classNodes = unitElt.query(\"//p:property\", new XPathContext(\"p\", \"http://java.sun.com/xml/ns/persistence\"));\n                        for (int k = 0; k < classNodes.size(); k++) {\n                            Node classNode = classNodes.get(k);\n                            if (!(classNode instanceof Element)) continue;\n                            Element classElt = (Element) classNode;\n                            String elementName = classElt.getAttribute(\"name\").getValue();\n                            if (elementName.equals(\"eclipselink.jdbc.url\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setJdbcUrl(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.user\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBUserName(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.password\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBPassword(elementValue);\n                            } else if (elementName.equals(\"eclipselink.jdbc.driver\")) {\n                                String elementValue = classElt.getAttribute(\"value\").getValue();\n                                parameters.setDBDriverClassName(elementValue);\n                            }\n                        }\n                        return parameters;\n                    }\n                }\n            } catch (Exception x) {\n                x.printStackTrace();\n                throw new Error(x);\n            }\n        }\n        return null;\n    }\n", "code2": "    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request);\n        if (delegate == null) {\n            ActionErrors errors = new ActionErrors();\n            errors.add(null, new ActionError(\"errors.session\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"fail\");\n        }\n        AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla();\n        TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion();\n        String urlSonido = traAyudaPantalla.getUrlSonido();\n        if (urlSonido == null) {\n            return null;\n        }\n        URL url = new URL(urlSonido);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.connect();\n        String tipoMime = urlConnection.getContentType();\n        log.debug(\"Tipo Mime: \" + tipoMime);\n        Map audioOptions = new HashMap();\n        if (tipoMime.indexOf(\"audio\") != -1 || tipoMime.indexOf(\"asf\") != -1 || tipoMime.equals(\"unknown/unknown\")) {\n            audioOptions.put(\"id\", \"MediaPlayer\");\n            audioOptions.put(\"codeBase\", \"http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,7,1112\");\n            audioOptions.put(\"classId\", \"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\");\n            audioOptions.put(\"mimeType\", \"application/x-mplayer2\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/\");\n        } else if (tipoMime.indexOf(\"real\") != -1) {\n            audioOptions.put(\"id\", \"RVOCX\");\n            audioOptions.put(\"codeBase\", \"\");\n            audioOptions.put(\"classId\", \"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\");\n            audioOptions.put(\"mimeType\", \"audio/x-pn-realaudio-plugin\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"\");\n        }\n        request.setAttribute(\"audioOptions\", audioOptions);\n        log.debug(\"entra success\");\n        return mapping.findForward(\"success\");\n    }\n", "label": 0, "substitutes": {"parse": [" analyze", " params", " parsed", " assemble", " scan", " compile", " resolve", " execute", " test", " inspect", " analyse", " load", " ls", " validate", " parsing", " start", " read", " extract", " structure", " install", " parser", " check", " constructor", " process", " pars", " discover"], "unitName": ["uiType", "unitsNames", "unitsname", " unitname", "machineName", "machineType", " unit1", "uiName", "unitType", "units1", "UnitNames", "uiValue", " unitType", "unitValue", "unit1", " unitNames", " unitValue", "unitPath", "unitNames", "uiPath", "Unit1", "machineValue", "machinePath", "unitsName", " unitPath", "Unitname", "UnitName", "unitname"], "persistenceUnits": ["persistenceUnites", "persistenceClits", "persistanceUnites", "persistenceUNits", "persistanceUnit", "persistenceUNites", "persistenceLogits", "persistenceUnitits", "persistanceClites", "persistenceunites", "persistanceClits", "persistenceClites", "persistenceUNodes", "persistenceUnitodes", "persistanceUnitists", "persistenceUnitists", "persistenceOperit", "persistanceClITS", "persistenceUit", "persistenceUnitunits", "persistenceLogunits", "persistenceUnitITS", "persistenceunits", "persistanceUnodes", "persistenceOperites", "persistenceUnodes", "persistenceUnITS", "persistenceUNITS", "persistanceUnitites", "persistenceUnitions", "persistanceUnunits", "persistanceUnitITS", "persistenceUITS", "persistanceClitions", "persistanceUnitits", "persistenceUNitions", "persistenceUnunits", "persistenceUits", "persistenceLogists", "persistenceUnists", "persistanceUnitunits", "persistenceUnitites", "persistenceUnitit", "persistanceUnitit", "persistanceUnists", "persistenceClITS", "persistenceununits", "persistenceLogites", "persistenceOperodes", "persistenceUnit", "persistanceUnitodes", "persistanceUnits", "persistanceUnITS", "persistenceUites", "persistenceUnititions", "persistenceOperits", "persistenceUNit", "persistenceClitions", "persistenceunists", "persistanceUnitions"], "classes": ["resources", " protocols", "services", "properties", " constants", " assignments", "class", "set", " interfaces", "params", "groups", "ps", " tests", " groups", " suites", "result", " class", " Classes", " configurations", "Class", " formulas", "es", " models", " packages", "names", "results", " sources", " instances"], "i": ["z", "ini", "mi", "index", "in", "oi", "yi", "hi", "phi", "ii", "fi", "ix", "l", "info", "ui", "ri", "pi", "gi", "li", "ci", "p", "ie", "multi", "si", "ni", "xi", "bi", "uri", "v", "x", "ai", "ji", "eni", "y", "ip", "ori", "qi", "ti", "id", "iu", "u", "f", "n", "di", "I"], "url": ["image", "link", "plugin", "URL", "base", "resource", "in", "service", "Url", "ls", "entry", "up", "http", "filename", "href", "l", "api", "string", "element", "route", "path", "io", "uri", "xml", "ur", "name", "ssl", "location", "server", "data", "file", "user", "username", "sl", "connection", "config", "source", "web", "f", "address"], "b": ["wb", "base", "o", "br", "eb", "hub", "Builder", "l", "bb", "cb", "builder", "c", "gb", "lib", "r", "fb", "be", "bd", "p", "sb", "build", "v", "B", "bt", "pb", "bis", "a", "verb", "bs", "ob", "e", "rb", "n", "bc", "bh", "m", "db", "f", "obj", "ab", "library"], "d": ["dd", " D", "dc", "dat", "D", "dos", "l", "did", "c", "r", "g", "dom", "fd", "t", "ds", "p", "dt", "df", "director", "dir", "xml", "md", "data", "id", "pd", "e", "dm", "u", "dot", "n", "di", "dl", "m", "db", "f", "s"], "unitNodes": ["unitRenubes", "unitNoded", " unitNurs", "unitNeoded", "unitNobs", " unitNideos", "unitnoms", " unitnoms", "unitSnode", "unitnoded", " unitNoded", "unitDurs", " unitnurs", "unitnubes", "unitNeode", "unitSnodes", " unitnodes", "unitnideos", " unitnideos", "unitNurs", " unitNoms", "unitNeodes", "unitDodes", "unitSnoded", "unitnodes", " unitnode", "unitRenobs", "unitNoms", "unitRenodes", "unitnode", "unitNeoms", " unitNubes", "unitDideos", "unitRenoms", " unitNobs", "unitNubes", " unitnoded", "unitnobs", "unitNideos", "unitSnoms", "unitnurs"], "j": ["z", "aj", "jc", "fr", "q", "section", "kj", "syn", "jl", "jit", "je", "json", "ii", "obj", "key", "l", "ch", "jp", "js", "uj", "g", "job", "note", "p", "ie", "ni", "jen", "it", "ja", "v", "ji", "y", "dj", "jj", "qi", "h", "jet", "jo", "J", "u", "ij", "n", "bj", "br", "f"], "unitNode": ["UnitN", "unitsElement", "tunnode", "connectionPath", " unitElement", "unitsNode", "unitElement", "unitPath", "tunElement", " unitnode", "connectionNode", "tunNode", "connectionN", " unitN", "unitsName", "unitnode", "tunName", "connectionElement", " unitPath", "UnitNode", "UnitPath", "unitsnode", "UnitElement", "unitN"], "unitElt": ["unitNelt", "unitEslet", "unitEler", "unitOLT", "unitGeelt", " unitEelt", "unitEelt", "unitUlt", "unitELT", " unitELT", "unitIlt", "unitUlem", "unitGelt", "unitElem", "elementEslet", " unitUler", "unitext", "unitelem", "elementEslt", "unitelt", "unitGeLT", "unitOlt", " unitOld", " unitElem", "elementElt", "elementElet", "unitElet", "unitOelt", "unitGeld", "unitExt", " unitEld", "elementEelt", "uniteler", "unitNld", " unitOLT", "unitelet", "unitOlet", " unitUlem", "elementEld", "unitEsld", " unitExt", "unitNLT", "unitUler", " unitUlt", " unitOlt", "elementEselt", "elementEsld", "uniteld", " unitUxt", "unitUxt", " unitOelt", "unitIler", "uniteelt", "unitNlt", " unitEler", "unitEld", "unitEslt", "unitEselt", "unitIxt", "unitOld", "unitIlem"], "uName": ["uValue", " uValue", "duName", "suPath", "uPath", " uPath", " uNames", " uNode", "unitValue", "uNode", "duNames", "unitPath", "unitNames", "uname", "suname", "duValue", "duNode", "uNames", "suName", "unitname", " uname", "suValue"], "parameters": ["paramumers", "parels", "prometers", "arameter", "paramParameters", "paramseters", "paramsParameters", "peters", "persams", "pams", "persumers", "pareters", "promParameters", "paramams", "pumers", "params", "perseters", "aramels", "prometer", "arameters", "parumers", "paramseter", "promels", "parameter", "paramsels", "pels", "persels", "paramels", "aramParameters"], "classNodes": ["classNobs", "classVode", " classClements", "classCode", "classNeoded", "ClassNanks", "Classnoded", "classEoded", "Classnode", "fieldNode", "classNinode", "classNinobs", " classNoded", "classnoded", "classSnode", "classSnlements", "classSnoded", "fieldNODE", " classNlements", "classEode", "classNelements", "classNeode", "classVODE", "fieldNinobs", "Classnodes", "fieldNinodes", "Classnanks", "classnodes", "classNanks", "classNlements", "classNeodes", "ClassNodes", "classNinodes", "classEanks", "classnode", " classCodes", "ClassNode", "classSode", "fieldNinode", "fieldNinODE", "classEodes", "classCodes", "classVobs", "classVodes", "classSobs", "classClements", "classCoded", " classCoded", "classNinODE", "classnanks", "classSodes", "fieldNodes", "classNoded", "classSnodes", "fieldNobs", "classSODE", " classCode", "classNODE", "ClassNoded"], "k": ["z", "ek", "q", "kr", "kn", "unk", "ku", "ky", "sk", "w", "kat", "ik", "ke", "key", "ch", "km", "kk", "c", "r", "g", "ok", "work", "kick", "ck", "ad", "p", "v", "y", "kw", "K", "ko", "h", "dk", "id", "f", "ks", "n", "ki", "kid"], "classNode": ["busnode", " classSource", " classNs", "baseTree", "Classnode", "elementSource", " classFile", "elementTree", "classFile", "ClassFile", "fileTree", "fileRoot", "busNode", "elementRoot", "classRoot", " classElement", "configName", " className", "configSource", "elementElement", "classSource", "classNs", "elementNode", "ClassNs", "classnode", "fileNode", "ClassNode", " classnode", "busFile", "configNode", "baseNode", "busNs", "classElement", "baseElement", "configElement", "fileElement", "className", "baseRoot", "classTree"], "classElt": ["ClassOler", "elementeelt", "classXLT", "classYxt", "Classelt", "ClassOxt", "classXlt", "Classelem", "ClassEld", "Classeld", "classUelt", "classYelt", "elementeld", "classElem", "classUlem", "elementElt", "classUxt", "classeld", "elementEelt", "ClassXelt", "classEelt", "Classeelt", "classXxt", "ClassOld", "classeelt", "classYler", "classOld", "elementExt", "ClassOlt", "elementEld", "ClassEelt", "elementext", "classelem", "ClassExt", "classXld", "classExt", "classext", "ClassXLT", "ClassELT", "classELT", "ClassEler", "classOxt", "elementelt", "classXler", "classXelt", "ClassElt", "classelt", "classEler", "classOlt", "classEld", "classYlt", "classUlt", "ClassXlt", "ClassElem", "classYld", "classYlem", "classOler", "classUld", "ClassXld", "classeLT"], "elementName": ["articleName", " elementFamily", "layerApp", " elementname", "modulename", "typeFamily", "articleApp", "classValue", "articleFamily", "articleAnn", "elementFamily", "sectionFamily", "elementPath", "typeApp", "layerFamily", "elementname", "layerName", "elementAnn", "classname", "typeAnn", " elementFace", "layerAnn", "sectionName", "stringFace", "sectionFace", "moduleName", "classPath", "elementFace", "elementApp", "modulePath", "typeName", "stringName", "className", "stringFamily", " elementPath", "moduleValue"], "elementValue": ["objectvalue", "entryVALUE", "styleVALUE", " elementVal", " elementText", "objectValue", "optionString", "objectString", "optionVal", "stylevalue", "ElementVALUE", "memberValue", "entryvalue", "entryVal", "elementString", "optionvalue", "entryText", "objectVal", "optionValue", "memberVal", "elementVALUE", "Elementvalue", "ElementString", "ElementValue", "elementVal", "entryValue", "styleText", "elementvalue", "memberText", "ElementText", "styleValue", "elementText", "ElementVal", " elementVALUE", "memberVALUE"]}}
{"id1": "17901739", "id2": "7468819", "code1": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "label": 1, "substitutes": {"setMembers": ["setJoin", "SetJoin", "SetMembers", "setMember", "SetMethods", " setJoin", "parseMembers", " setMethods", "parseMember", "parseJoin", "setMethods", "parseMethods", "SetMember", " setMember"], "url": ["image", "blog", "client", "service", "email", "sl", "entry", "queue", "socket", "feed", "user", "server", "address", "connection", "http", "location", "URL", "resource", "path", "io", "hub", "ssl", "file", "Url", "channel", "base", "data", "loader", "org", "article", "l", "string", "uri", "source", "www"], "reader": ["r", "iterator", "writer", "ner", "worker", "Reader", "entry", "stream", "rer", "i", "rc", "feed", "input", "e", "handler", "server", "per", "ler", "http", "inner", "editor", "report", "resource", "io", "keeper", "rr", "row", "reading", "file", "rar", "iter", "f", "builder", "err", "loader", "er", "driver", "l", "table", "parser", "read", "bird"], "buffer": ["video", "image", "stage", "sync", "flash", "FFER", "comment", "Buffer", "address", "info", "fb", "http", "str", "iter", "buf", "base", "text", "string", "uri", "window", "flush", "length", "request", "bytes", "batch", "feed", "input", "parse", "page", "cache", "rb", "response", "message", "buff", "file", "uffer", "b", "bar", "border", "pause", "button", "writer", "fr", "received", "output", "bb", "expression", "phrase", "result", "padding", "line", "row", "null", "player", "paste", "wave", "background", "password", "counter", "seed", "layer", "source", "filename", "template", "queue", "read", "transfer", "sequence", "server", "game", "code", "resource", "binary", "data", "loader", "document", "bin", "header", "texture"], "pattern": ["image", "position", " Pattern", "match", "template", "cher", "script", "object", "print", "feed", "app", "slice", "serial", "expression", "patch", "handler", "Pattern", "rule", "cache", "child", "group", "format", "array", "graph", "path", "regular", "df", "function", "file", "part", "str", "letter", "model", "system", "builder", "type", "log", "number", "atter", "document", "password", "counter", "string", "parser", "command", "filter", "event", "re", "layer", "config", "condition"], "matcher": ["reches", "ratger", "patatcher", "manacher", "statcher", "compner", "patner", "mitchers", "ratacher", "Matpattern", "matchpattern", "Matger", "statpattern", "captatter", "attacher", "compatcher", " matter", "captpattern", "patcher", "matacher", "mirher", "matches", " matpattern", "mither", "Matner", "harpattern", "matchher", "matchers", "motpattern", "reched", "harcher", "reach", "compach", "patch", "mather", "Matching", "matatcher", "matchched", "mancher", "compched", " matacher", "harner", " mather", "captter", "motner", "matchches", " matatter", "matger", " matler", "attcher", "matchler", "matchter", "manher", "matching", "patpattern", "compter", "matatter", "patter", "matpattern", "matler", "mirter", "Matacher", "linter", "matach", "matchach", "pather", "ratcher", " matchers", "Matter", "compcher", " match", "ratching", "captcher", "linatter", "statler", "linpattern", "statner", "motter", "lincher", "attching", "match", "matchcher", "mircher", "attger", "patchers", "manner", "mirpattern", "harler", "Matcher", "mitcher", "compches", "matchatcher", "matchacher", "matched", "recher", "motcher", "matter", "matner", " matner", "mitch", "matchner", "Mather"], "erg": ["der", "gr", "ander", "gae", "irc", "orter", "eur", "gru", "eri", "progress", "ag", "worker", "justice", "rator", "rog", "git", "ga", "ord", "eng", "igor", "gra", "east", "ger", "gg", "urg", "ero", "sg", "eric", "yang", "game", "dr", "aug", "alg", "berg", "region", "gy", "magic", "oga", "gd", "feat", "orters", "era", "ager", "porter", "uster", "jing", "org", "arc", "ERG", "er", "agog", "ig", "forge", "rg", "ider", "og", "usa", "clus", "ers", "ocr", "aga", "ard", "anger", "gas", "ung", "agg"], "start": ["pad", "size", "sort", "grad", "old", "mid", "address", "open", "info", "last", "something", "end", "space", "st", "base", "name", "ind", "get", "End", "fit", "off", "load", "begin", "check", "boot", "diff", "state", "inner", "index", "find", "part", "started", "close", "unit", "set", "scale", "pend", "offset", "stop", "like", "middle", "in", "stat", "art", "init", "ad", "starting", "id", "run", "plus", "sum", "grade", "pick", "Start", "show", "work", "count", "step", "min", "it", "seed", "speed", "head", "first", "add", "shift", "source", "position", "match", "cost", "max", "ie", "pos", "read", "sol", "se", "send", "fill", "need", "ish", "none", "rest", "type", "bin", "style", "current"], "von": ["fin", "su", "flo", "jan", "tu", "eni", "melon", "vid", "bn", "endon", "nn", "vu", "ou", "tin", "fen", "oni", "ln", "won", "zon", "han", "jen", "aven", "dn", "lin", "ver", "fat", "bon", "anon", "vin", "andon", "lon", "olson", "fn", "uber", "fun", "feat", "len", "kn", "hon", "wen", "don", "byn", "tun", "mun", "di", "hn", "vor", "onna", "bin", "ten", "mon", "lu", "evin", "endor", "una", "john", "non"], "bis": ["os", "bs", "vid", "ois", "phis", "lins", "bid", "zi", "fb", "bas", "len", "bits", "prefix", "base", "bat", "vs", "bos", "outs", "isin", "eni", "is", "bus", "uno", "nas", "isi", "ris", "val", "boot", "ios", "li", "vin", "buff", "offs", "bi", "uss", "su", "BUS", "us", "cus", "oss", "ls", "bb", "nexus", "abi", "lin", "obs", "cos", "bps", "sis", "bian", "ri", "bles", "cedes", "vals", "pos", "oris", "cin", "oni", "ui", "los", "fat", "ori", "bes", "ours", "pi", "onis", "des", "ni", "pins", "di", "bin", "lus", "bett", "udi", "idis"], "m_strComponents": ["m_strExpales", "m_strComponent", "m_strExpenses", "m_intRepales", "m_intComports", "m_arrCommales", "m_intReports", "m_strRepales", "m_intRepenses", "m_strCompenses", "m_strReports", "m_strExponents", "m_strRepenses", "m_arrCommonent", "m_arrCompenses", "m_arrComponents", "m_strReponents", "m_strCommonent", "m_strExports", "m_arrCommenses", "m_strCommales", "m_intReponents", "m_intCompales", "m_strCommenses", "m_strComponentonents", "m_arrComponent", "m_intCompenses", "m_strCommorts", "m_intComponents", "m_arrCommonents", "m_strExponent", "m_strCommonents", "m_strCompales", "m_strComponentales", "m_strComponentonent", "m_arrCompales", "m_strComponentenses", "m_strComports"], "m_strPriorities": ["m_intPrefries", "m_strActivities", "m_strActivries", "m_StrPriority", "m_strComparifiers", "m_strPrioritives", "m_strMonities", "m_intPrioritions", "m_strMonitives", "m_StrPosity", "m_strComparities", "m_intPriorries", "m_intPriorities", "m_StrPriorities", "m_strPrefitions", "m_StrPrioritions", "m_intPrioritives", "m_strPositions", "m_strComparitions", "m_StrPositions", "m_strPriorries", "m_strActivitions", "m_intPrefitives", "m_strPrefries", "m_strPrefitives", "m_StrPosifiers", "m_strQualitions", "m_strActivitives", "m_strMonitions", "m_strComparity", "m_strPosity", "m_strMonries", "m_intPrefities", "m_strPosities", "m_strPriority", "m_strPriorifiers", "m_intPrefitions", "m_StrPosities", "m_strQuality", "m_strQualifiers", "m_strPosifiers", "m_strQualities", "m_StrPriorifiers", "m_strPrioritions", "m_strPrefities"]}}
{"id1": "21999120", "id2": "3536332", "code1": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"encrypt": ["encrypted", "decryption", "decrypted", "encryption", "Encrypt", "Encrypted", "crypted", "decrypt", "Encryption", "encipher", "cryption", "cipher", "decipher", "crypt", "Encipher"], "password": ["enc", "Password", " Password", "account", "prefix", "content", "input", " passwords", "pattern", "text", "message", "key", "wd", "string", "buffer", "pass", "crypt", "token", "path", "padding", "phrase", "p", "attribute", "number", "secret", "auth", "name", "PASS", "word", "data", "seed", "username", "sword", "security", "address"], "md5": ["hash5", "MD4", "hash2", "MD512", "MD53", "MD5", " md53", "md512", " MD2", "md8", " md512", "md2", "md4", " md2", " MD512", " MD8", " MD5", " MD4", " MD53", " mdless", " md8", "MDless", " md4", "MD2", "MD8", "mdless", "hash512", "md53", "hashless"], "hash": ["image", "her", "sha", "num", "log", "html", "hex", "check", "square", "version", "message", "count", "cache", "key", "output", "object", "update", "string", "fill", "array", "kh", "result", "build", "sh", "number", "sign", "mac", "handle", "ash", "length", "auth", "Hash", "sum", "hed", "h", "value", "dot", "cover"], "hashword": ["ashword", "Hashkey", " hashWord", "hashpassword", "hashkey", "Hashwords", "sumword", "sumwords", " hashkey", "hashWord", "HashWord", "sumkey", "Hashword", "trustbyte", "hashbyte", "trustWord", "ashbyte", "ashWord", "trustpassword", " hashbyte", "sumWord", "trustword", "hashwords", " hashpassword", " hashwords", "ashpassword"]}}
{"id1": "5142039", "id2": "16590954", "code1": "    public static String uncompress(String readPath, boolean mkdir) throws Exception {\n        ZipArchiveInputStream arcInputStream = new ZipArchiveInputStream(new FileInputStream(readPath));\n        BufferedInputStream bis = new BufferedInputStream(arcInputStream);\n        File baseDir = new File(readPath).getParentFile();\n        String basePath = baseDir.getPath() + \"/\";\n        if (mkdir) {\n            String[] schema = readPath.split(\"/\");\n            String baseName = schema[schema.length - 1].replaceAll(\".zip\", \"\");\n            FileUtils.forceMkdir(new File(basePath + baseName));\n            basePath = basePath + baseName + \"/\";\n        }\n        ArchiveEntry entry;\n        while ((entry = arcInputStream.getNextEntry()) != null) {\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(basePath + entry.getName()));\n            } else {\n                String writePath = basePath + entry.getName();\n                String dirName = FilenameUtils.getPath(writePath);\n                FileUtils.forceMkdir(new File(dirName));\n                BufferedOutputStream bos = new BufferedOutputStream(FileUtils.openOutputStream(new File(writePath)));\n                int i = 0;\n                while ((i = bis.read()) != -1) {\n                    bos.write(i);\n                }\n                IOUtils.closeQuietly(bos);\n            }\n        }\n        IOUtils.closeQuietly(bis);\n        return basePath;\n    }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"uncompress": ["uncompressed", "uncompzip", "uncopzip", " unompzip", " uncompression", "unompressed", " uncompressed", " unompress", "uncopression", "uncompression", " unompressed", "unCompress", " unompression", "uncopressed", "unompzip", "unompression", "unCompressed", "unCompression", "unompress", "uncopress", " uncompzip", "unCompzip"], "readPath": ["writeCase", "baseTree", "readTree", " readFile", "loadpath", "writePo", "loadPo", "loadWith", "loadFile", "loadDir", "scanDir", "checkPo", "workTree", "loadCase", "readerPath", "baseWith", "loadPath", "checkPath", "readWith", "writeDir", "readPo", " readWith", "writeFile", "workFile", "readCase", "scanPath", "readDir", "baseFile", "scanCase", "scanpath", "workpath", "readerpath", "basepath", "checkDir", "checkFile", "readpath", "readFile", "workPath", "writepath", "readerTree", "readerFile", " readpath"], "mkdir": ["MKdir", "MKDir", "kkrel", "kkdir", "ckDir", " mkDir", "muturl", "mkrel", " mkdb", " mkrel", "MKrel", "mkDir", "ckurl", "mutdir", "kkzip", "MKzip", "mutDir", " mkurl", "ckdb", "ckdir", "mkdb", "mutdb", "mkzip", " mkzip", "mkurl", "kkDir"], "arcInputStream": ["ancInputFile", "ancOutputFile", "arcFileStream", "arcReadStream", "cInputStream", "cOutputSync", "arcHttpStream", "arcReaderChannel", "arcOutputChannel", "arcImportChannel", "arcReadstream", "arcOutputFile", "arcHttpForm", "arcInputFile", "ancOutputStream", "arcOutputSt", "arcOutputstream", "ancInputChannel", "arcOutputForm", "arcFileSteam", "arcReaderStream", "cInputSteam", "arcFileSt", "ancInputstream", "arcInputChannel", "arcReadSync", "ancInputForm", "cInputSt", "ancOutputChannel", "cOutputStream", "ancInputStream", "arcHttpstream", "arcFileSync", "arcReadSteam", "arcOutputStream", "arcHttpSteam", "arcInputstream", "cOutputSt", "arcInputSt", "cOutputSteam", "arcOutputSync", "arcInputSteam", "arcInputForm", "arcInputSync", "arcImportstream", "arcReaderFile", "arcReaderstream", "arcReadForm", "arcImportFile", "arcImportStream", "ancOutputstream", "cInputSync", "ancOutputSteam", "ancInputSteam", "arcOutputSteam", "arcReadSt", "ancOutputForm"], "bis": ["pins", "ours", "kos", "lus", "vs", "abs", "mis", "bits", "ls", "alis", "bid", "lins", "bb", "cb", "raf", "usb", "idis", "ubis", "obs", "abi", "fb", "boot", "onis", "ris", "ros", "obb", "bi", "os", "ras", "oss", "uds", "phis", "banks", "sis", "ins", "is", "cos", "ses", "ubs", "phys", "ois", "bs", "isin", "oris", "binary", "bps", "ios", "BUS", "bus", "parts"], "baseDir": ["BaseDir", "baseFolder", " baseDirectory", "rootDir", "basedir", "BaseDirectory", "baseDirectory", "Basedir", "fileFolder", " baseFolder", "BasePath", "BaseFolder", "rootFolder", "fileDir", "filedir", "fileDirectory", " basedir", "rootPath", "rootDirectory"], "basePath": ["basicCondition", "BaseName", "BaseDir", "baseCondition", "baseStream", "buildType", "baseHost", " baseStream", "BaseFile", " baseUrl", "fileName", "resourcepath", "parentUrl", "filePath", "resourceDir", "BaseInfo", "basicPath", "viewPath", "basicInfo", "basedPath", "BaseUrl", "writeHome", "buildPath", "basedType", "resourcePath", "writeStream", "viewStream", " baseHost", "baseInfo", "parentFile", "basedDir", " baseOrder", " baseType", "parentName", "buildHost", "outDir", "viewHome", "BasePath", "basedHost", "baseOrder", "writeOrder", "readDir", "buildDir", "baseFile", "readUrl", "BaseCondition", "baseHome", "outUrl", "parentPath", "fileDir", "resourceName", " baseFile", "fileUrl", "basepath", "readName", " basepath", "outName", "readCondition", "Basepath", "outPath", "basicDir", "readInfo", " baseHome", "viewOrder", "baseType", "baseUrl"], "schema": ["mama", "Schema", " scheme", "cheaga", "mame", "cheme", "scheme", "syaga", "Scheme", "syme", "mapa", "chema", "issma", "issmas", "mamas", "issme", "Schemas", "schepa", "chemar", "syma", "schemar", "Schemar", " schemas", "schemas", "Schepa", "chemas", "scheaga", "symas", "isspa", " schemar", "Scheaga"], "baseName": ["BaseName", "basDir", "basicKey", "basInfo", "basName", "areaName", "areaPath", "BaseKey", "normalTitle", "basicName", " baseKey", "coreInfo", "normalPath", "areaKey", "baseInfo", " baseTitle", "normalKey", " baseInfo", "BasePath", "baseTitle", "BaseTitle", "coreDir", "normalName", "coreName", "baseKey", "corePath", "basPath", "basicPath"], "entry": ["lc", "her", "de", "index", "base", "letter", "service", "nt", "system", "feed", "office", "section", "child", "inner", "je", "ry", "parse", "zip", "Entry", "exp", "add", "journal", "key", "info", "post", "object", "extra", "style", "element", "pe", "cel", "ace", "next", "path", "ie", "part", "line", "record", "result", "se", "ent", "uri", "it", "entity", "si", "row", "le", "article", "name", "la", "ae", "ge", "archive", "server", "data", "ries", "sea", "e", "valid", "card", "iterator", "comment", "no", "reader", "enter", "or", "connection", "inc", "install", "obj", "editor"], "writePath": ["writeCase", "baseStream", " writeCase", "WriteDir", "writtenPath", " writeDir", "WritePath", "writeCh", "writtenStream", "writtenName", "writeStream", "writerEx", "writeName", "writerPath", "writeDir", "readPoint", "basePoint", "readCase", "readDir", "writeEx", " writeCh", "writerDir", "writingPoint", "writePoint", "writtenPoint", "readStream", "readName", "WriteEx", " writePoint", "writerCh", "writingCase", "WriteCh", "writingDir", "writingPath", " writeEx"], "dirName": ["orderUrl", "Dirname", "ordername", "DirDef", "DirName", "DIRAlias", " dirDef", "dirname", " dirAlias", "dirDef", " dirname", "DirUrl", " dirPath", "DIRName", "orderName", "DIRPath", "dirPath", "DirAlias", " dirUrl", "dirAlias", "DIRDef", "DirPath", "dirUrl"], "bos": ["bo", "rots", "asio", "zos", "osa", "kos", "atis", "dies", "osi", "lins", "bas", "bb", "boards", "bones", "gb", "obo", "ubis", "obs", "bies", "zo", "bes", "boot", "ros", "obb", "obos", "os", "bi", "oids", "uds", "oks", "banks", "bott", "ubs", "las", "ois", "ko", "nas", "bs", "opus", "ios", "oos", "fits", "bc", "los", "aos", "obi"], "i": ["ini", "z", "index", "j", "o", "batch", "chi", "in", "hi", "inner", "phi", "ii", "mini", "slice", "l", "b", "info", "ui", "ri", "pi", "c", "r", "abi", "li", "ci", "p", "multi", "si", "xi", "ni", "bi", "io", "v", "uri", "ai", "ji", "it", "x", "ip", "is", "length", "start", "a", "qi", "id", "e", "limit", "f", "di", "you", "exec", "I", "zi", "s"]}}
{"id1": "4223002", "id2": "21152728", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "label": 1, "substitutes": {"getPasswordMD5": ["getpasswordSHA1", "getPasswordMD1", "getpasswordMD512", "getPasswordMD256", "getPasswordMAC256", "getPasswordMAC5", "getpasswordMD1", "getPasswordMac256", "getPasswordMac1", "getPasswordSHA5", "getPasswordSHA512", "getPasswordMAC1", "getpasswordMD256", "getPasswordMAC512", "getPasswordMac5", "getPasswordMac512", "getpasswordMD5", "getPasswordSHA256", "getpasswordSHA5", "getpasswordSHA512", "getpasswordSHA256", "getPasswordMD512", "getPasswordSHA1"], "algorithm": ["aggorithm", "geest", "gem", " alm", "alrator", "algo", "Alignment", " alger", " alignment", " algo", " alrator", "alest", "alger", "calgorith", "Alm", "calgo", "Alrator", "calgebra", "algebra", "Alest", " alest", "gegorithm", "Alphabet", "Algorith", "alphabet", "agrator", "Alger", "Algorithm", "fgo", "fgebra", "omalgorith", "omalgo", "aggo", "alignment", "calgorithm", "omalgorithm", "algorith", "geger", "Algo", "agignment", "omalphabet", "alm", " algorith", " alphabet", "fgorithm", "fgorith", "Algebra"], "messageDigest": ["messageModester", "MessageDigEST", "MessageDigest", "phrasedigester", "phrasedigest", "phraseDigEST", "messageMDester", "messageDigested", "messageModEST", "messagedigest", " messagedigEST", " messagedigString", "messageMDest", "messageDest", "messagedigester", "messagedigString", "messageDEST", " messageDigString", "messageMDString", "messagedigested", " messageDigester", "messageModest", "messageDigString", "MessageModester", "messageModested", "phraseDigester", "MessageModest", " messageDigEST", "messageModString", "messagedigEST", "MessageModested", "messageDested", " messagedigest", "phraseDigest", "phrasedigested", "phraseDigested", " messagedigester", "MessageDigester", "phrasedigEST", "messageDigEST", "MessageDigested", "messageDester", "MessageModEST", "messageMDEST", "messageDigester"], "hexString": [" hexFunction", "hexLine", "textStream", "hashStr", " hexstring", "hexBuffer", "textString", "textstring", "hexstring", "byteLine", " hexStr", "shortArray", "textLine", "shortString", "hexArray", "hexStr", "hashString", "checkFunction", "hexStream", " hexArray", "shortstring", "textArray", "shortBuffer", "byteStream", "hashBuffer", "hexFunction", "checkStr", " hexStream", "byteString", "checkString", "checkBuffer", "textBuffer", "hashFunction", " hexBuffer", " hexLine", "byteArray"], "i": ["m", "u", "uri", "e", "j", "b", "volume", "n", "fi", "io", "info", "ix", "si", "in", "f", "o", "index", "d", "end", "key", "h", "type", "s", "ci", "oi", "abi", "multi", "li", "a", "l", "di", "hi", "pi", "xi", "mi", "slice", "r", "id", "ti", "v", "gi", "c", "t", "ri", "I", "ai", "phi", "zi", "ii", "ui", "x", "bi", "chi", "mu", "p"]}}
{"id1": "15051083", "id2": "17558353", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            URL urlhome = new URL(\"http://www.verussolutions.biz/NGLDashBoard.xml\");\n            URLConnection uc = urlhome.openConnection();\n            InputStreamReader input = new InputStreamReader(uc.getInputStream());\n            BufferedReader in = new BufferedReader(input);\n            String inputLine;\n            String xmlData = \"\";\n            while ((inputLine = in.readLine()) != null) {\n                xmlData += inputLine;\n            }\n            in.close();\n            PrintWriter fw = new PrintWriter(new FileWriter(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            fw.println(xmlData);\n            fw.flush();\n            fw.close();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n        try {\n            Document doc = new SAXBuilder().build(new File(System.getProperty(\"user.home\") + \"/NGLDashBoard.xml\"));\n            String onlinsuppcdat = doc.getRootElement().getChild(\"OnlineSupportInformation\").getText();\n            CDATA cdata = new CDATA(onlinsuppcdat);\n            host.setOnlineInformationHTML(cdata.getText());\n            onlinsuppcdat = doc.getRootElement().getChild(\"News\").getText();\n            cdata = new CDATA(onlinsuppcdat);\n            host.setNewsHTML(cdata.getText());\n            host.fillData();\n        } catch (Exception exp) {\n            exp.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getMessageDesignest", "getmessageDigest", "getMessageDigester", "getMessageHashest", "getMessageHashests", "getMessageHashester", "getmessagedigester", "getmessageDigester", "getMessagedigester", "getmessagedigests", "getMessageHashature", "getMessageDigature", "getMessageDesignature", "getMessagedigature", "getmessageDigature", "getMessageDesignests", "getMessageDigests", "getMessagedigest", "getMessagedigests", "getmessagedigest", "getmessagedigature", "getMessageDesignester", "getmessageDigests"], "digest": ["Diger", " Digest", "digiter", "hexest", "greatest", "hexEST", "sandest", "DigEST", "Digger", " digEST", " digeter", "greatiter", "Digeter", "feedester", "Digex", "Digester", "digEST", "Digest", " digested", " Digeter", "sandesting", " digex", "digesting", "greatester", "hexex", " Digger", "sandester", "signest", "digger", "sandested", "hexests", " diger", " Dighed", "greatested", " digests", " Digester", " digester", " digger", "signested", " Diger", "digeter", "Digested", "Digesting", "digester", "digex", "signester", "Digests", "digests", "dighed", "Dighed", "Digiter", "diger", " dighed", "digested", "signesting", "feedest", "feedested", "signiter"], "node": ["component", "Node", "uri", "one", "resource", "server", "module", "parent", "n", "connection", "remote", "event", "child", " nodes", "document", "ode", "route", "index", " source", "element", "instance", "source", "config", " parent", "network", "self", " annotation", "point", "internal", "object", "local", "address", "name", "entity", " namespace", "root", "global", " Node", "location", "path", " child", "odes"], "external": ["intern", "ex", "ternal", "resource", "e", "n", "remote", " remote", "outer", "international", "outside", "foreign", "External", "tern", "multiple", "out", "element", "instance", "source", "network", "client", "target", "Intern", "internal", "object", "local", "https", "account", "name", "secondary", "global", "binary", "reference", " foreign", "environment", " global", " External", "export"], "messageDigest": ["messageMarkester", "messageModester", "messageSignested", "MessageDigest", "messagedigger", "messageMarkested", "messageModesting", "messageDigested", "messageDesignesting", "messagedigest", " messageHashest", "messageDigesting", " messageHashesting", "messageHashesting", "messageDesignest", " messageDesignger", "MessageSignest", "messageDesignger", " messageDigesting", "messageMarkenge", "messageDest", "messagedigester", " messageDigger", " messageDesignest", "messageSignenge", "messageDenge", "messageDesignested", "messageDigger", "messagedigested", " messageDigester", "messageModest", " messageDesignester", "messageHashest", "MessageSignester", "messageModested", "MessageDigenge", "MessageSignested", "messageDigenge", "messageDesignester", "messageSignest", " messageHashested", "messageDested", "messageMarkest", "messageSignester", " messageDigested", "MessageDigester", "MessageDigested", "messageHashested", "messageDester", "MessageSignenge", "messageHashester", " messageHashester", " messageDesignested", "messageDigester"]}}
{"id1": "3375722", "id2": "10715601", "code1": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"importarSetor": [" importarProcessorn", " importarsetori", " importarProcessori", " importarProcessor", " importarProcessutor", " importarsetor", " importarsetorn", " importarStructorn", " importTarSetorn", " importarStructutor", " importarStructori", " importarsetutor", " importarSetutor", " importTarSetutor", " importTarsetori", " importarSetorn", " importarStructor", " importTarsetutor", " importarSetori", " importTarSetori", " importTarsetorn", " importTarsetor", " importTarSetor"], "pArquivoXLS": ["pArquivoYls", "pArquivoYCL", "pArquivoEXCL", "pArquivaEXSL", "pArquivoTXls", "pArquivoYML", "pArquivoXCL", "pArquivoXML", "pArquivaEXLS", "pArquivoXls", "pArquivoXSL", "pArquivaXLS", "pArquivoZXLS", "pArquivaXCL", "pArquivaXSL", "pArquivoZXML", "pArquivoEXls", "pArquivaEXCL", "pArquivoZXSL", "pArquivoEXML", "pArquivoTXCL", "pArquivoYLS", "pArquivoTXSL", "pArquivoEXSL", "pArquivaEXls", "pArquivoTXML", "pArquivaEXML", "pArquivoEXLS", "pArquivoTXLS", "pArquivaXML", "pArquivaXls", "pArquivoZXls"], "pCabecalhoSetor": ["pCabecalhoSeteur", "pCabecalhoEdite", "pCabecalhoSetors", "pCabecalhaSetor", "pCabecalhoSelecte", "pCabecalhoEditeur", "pCabecalhaSelecteur", "pCabecalhoEditor", "pCabecalhaSelecte", "pCabecalhoSelectors", "pCabecalhaSetors", "pCabecalhoSete", "pCabecalhoSelector", "pCabecalhaSelector", "pCabecalhoSelecteur", "pCabecalhaSelectors", "pCabecalhaSete", "pCabecalhaSeteur", "pCabecalhoEditors"], "pAndamento": ["pAndietono", "pAndmento", "pOramentono", "pAndmentO", "pOrementono", "pAndementono", "pOramentO", "pAndementO", "pOramentos", "pAndietos", "pAndmentono", "pOremento", "pAndamentO", "pAndmentos", "pAndieto", "pOrementos", "pAndietO", "pAndementos", "pAndemento", "pAndamentono", "pOramento", "pOrementO", "pAndamentos"], "iLinha": ["iPlanya", "iLinya", "NumPlanya", "iFranHa", "iFraneno", "iMaleno", "NumPlanha", "iLineno", "iMalHa", "iLinHa", "NumPlanHa", "iPlanha", "NumPlaneno", "NumLinya", "iMalya", "iPlanHa", "iPlaneno", "NumLinha", "iFranya", "NumLinHa", "NumLineno", "iMalha", "iFranha"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialdestino", "stmtLimpezaInicialESTination", "stmtLimpezaInicialDestina", "stmtLimpezaInicialCombino", "stmtLimpezaIniciodestino", "stmtLimpezaIniciaDestination", "stmtLimpezaIniciodestination", "stmtLimpezaInicialdestINO", "stmtLimpezaInicialDesino", "stmtLimpezaInicialdestania", "stmtLimpezaIniciodestina", "stmtLimpezaIniciadestin", "stmtLimpezaIniciodestaco", "stmtLimpezaInicioDestania", "stmtLimpezaInicialDesination", "stmtLimpezaInicialDesINO", "stmtLimpezaInicioDestina", "stmtLimpezaInicialDestania", "stmtLimpezaIniciodestania", "stmtLimpezaInicialESTaco", "stmtLimpezaIniciadestaco", "stmtLimpezaInicioDestino", "stmtLimpezaInicialDestin", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialdestination", "stmtLimpezaInicialCombina", "stmtLimpezaInicialdestina", "stmtLimpezaInicioDestaco", "stmtLimpezaInicialCombINO", "stmtLimpezaInicioDestination", "stmtLimpezaInicialDestination", "stmtLimpezaIniciadestination", "stmtLimpezaIniciadestino", "stmtLimpezaInicialDestINO", "stmtLimpezaInicialDestaco", "stmtLimpezaInicialDesania", "stmtLimpezaInicialdestin", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialdestaco", "stmtLimpezaIniciodestINO", "stmtLimpezaInicialCombaco", "stmtLimpezaInicioDestINO", "stmtLimpezaInicialESTino", "stmtLimpezaInicialESTin", "stmtLimpezaIniciaDestin"], "stmtDestino": ["stmtLocationino", "stmDestin", "stmtDestinos", "stmtDistorno", "stmDestINO", "stmrdestaco", "stmtRestinos", "stmrdestinning", "stmtDestaco", "stmpDestaco", "stmDestinos", "stmpDestINO", "stmpDestorno", "stmtLocationaco", "stmtdestino", "stmtCombinos", "stmtDestorno", "stmtDistino", "stmrDestinning", "stmtdestINO", "stmdestINO", "stmpdestINO", "stmtLocationinning", "stmtdestinos", "stmrDestINO", "stmrdestino", "stmdestin", "stmDestino", "stmpDestino", "stmtRestino", "stmtDistINO", "stmtCombINO", "stmtCombino", "stmtDistaco", "stmtRestaco", "stmrDestino", "stmtDestin", "stmpdestino", "stmtdestaco", "stmpdestorno", "stmrdestINO", "stmtRestin", "stmtLocationINO", "stmtdestin", "stmtRestinning", "stmdestinos", "stmtCombin", "stmtDestINO", "stmrDestaco", "stmdestino", "stmtDestinning", "stmpdestaco", "stmtdestorno", "stmtdestinning", "stmtRestINO"], "arquivo": [" arQuarius", " arqivo", "arQUiva", "arqiva", " ar\u00e7arius", " ar\u00e7ivo", "arqivo", "arQUico", " arquicio", "arquico", "arQUivo", " arqiva", "arquarius", "Arqiva", "arQuico", "arquoso", "arqicio", "Arquiva", "arquicio", " arQuiva", "Arquico", " ar\u00e7iva", " arQuicio", "arQuivo", "arqico", "arqarius", "arQUoso", " arquarius", "arQuoso", " arqicio", " arquiva", "arQuiva", " arqarius", "Arqoso", "arqoso", "Arquivo", "Arqico", " ar\u00e7icio", " arQuivo", "Arquoso", "Arqivo", "arquiva"], "plan1": [" PlanOne", " plan0", "PlanOne", " plan2", "product0", "Plan0", " Plan1", "Plan1", "product1", "product2", "plan2", "planOne", " planOne", "plan0", "PlanName", " Plan2", " planName", "planName", "productName", " Plan0", "Plan2"], "QUANTIDADE_DE_REGISTROS_DE_CABECALHO": ["QUANTIDADE_DE_REGISTRASAD", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTRO__", "QUANTIDADE_DE_REGISTRONS__", "QUANTIDADE_DE_REGISTEROS__", "QUANTIDADE_DE_REGISTRATES__", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTROS__", "QUANTIDADE_DE_REGISTEROSAD", "QUANTIDADE_DE_REGISTROAD", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRosJ", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTROSAD", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRASJ", "QUANTIDADE_DE_REGISTRosAD", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTRONS_", "QUANTIDADE_DE_REGISTEROAD", "QUANTIDADE_DE_REGISTERO__", "QUANTIDADE_DE_REGISTROSJ"], "QUANTIDADE_DE_REGISTROS_DE_RODAPE": ["QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROs_", "QUANTIDADE_DE_REGISTROSEC", "QUANTIDADE_DE_REGISTRYOSJ", "QUANTIDADE_DE_REGISTROsJ", "QUANTIDADE_DE_REGISTROsEC", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTRYAS_", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTRYASJ", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRosJ", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRosEC", "QUANTIDADE_DE_REGISTRASJ", "QUANTIDADE_DE_REGISTROEC", "QUANTIDADE_DE_REGISTEROSEC", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTEROEC", "QUANTIDADE_DE_REGISTRYOS_", "QUANTIDADE_DE_REGISTROSJ"], "QUANTIDADE_DE_REGISTROS_DE_METADADOS": ["QUANTIDADE_DE_REGISTROSID", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTRONID", "QUANTIDADE_DE_REGISTRATESJ", "QUANTIDADE_DE_REGISTROSEC", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRESJ", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRON_", "QUANTIDADE_DE_REGISTEROSID", "QUANTIDADE_DE_REGISTROEC", "QUANTIDADE_DE_REGISTEROID", "QUANTIDADE_DE_REGISTEROSEC", "QUANTIDADE_DE_REGISTRESEC", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTROID", "QUANTIDADE_DE_REGISTEROEC", "QUANTIDADE_DE_REGISTRES_", "QUANTIDADE_DE_REGISTRATESEC", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTRosID"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstimmator", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstifado", "quantidadeDeRegistrosEstivado", "quantidadeDeRegistrosEstivator", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstifadas", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstifator", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstifada", "quantidadeDeRegistrosEstimator"], "vSetor": ["vSelecte", " vSetors", " vSetoring", "vSelector", "vSelectors", "vShipors", "vShiporing", " vSete", "vSetors", "vShipor", "vSelectoring", "vShipe", "vSetoring", "vSete"], "vSubsetor": ["vsubscor", "vSubsetors", "vsubsetors", "vSubjectr", "vsubsetr", "vSubsetr", "vSubsco", "vsubscors", "vSubjectors", "vSubscriptr", "vSubjector", "vsubscr", "vSubscriptors", "vSubscor", "vsubsco", "vsubsetor", "vSubscriptor", "vSubscors", "vSubseto", "vsubseto", "vSubjecto", "vSubscr", "vSubscripto"], "vSegmento": ["vSegMENTa", "vGmentor", "vSegamenta", "vSegmentationo", "vSegmentationor", "vGamentos", "vSegmentationa", "vSegMENTos", "vGmento", "vSegMENTo", "vGamenta", "vSegmentationos", "vSegamentor", "vSegmentos", "vGamento", "vSegamento", "vSegmenta", "vGmentos", "vGamentor", "vSegmentor", "vGmenta", "vSegamentos", "vSegMENTor"], "registroAtual": ["RegistrosAtual", "RegistroExual", "Registroatial", "RegistroExional", "Registrosatial", "Registroational", "RegistroAtial", "RegistrosAtial", "RegistroAtUAL", "RegistroAtional", "RegistroExUAL", "RegistroAtual", "RegistrosAtUAL", "RegistroGenUAL", "RegistroGenional", "RegistrosAtional", "RegistroGenial", "RegistroatUAL", "Registroatual", "RegistroGenual", "RegistrosatUAL", "Registrosational", "Registrosatual", "RegistroExial"], "vPapeisPorSegmento": ["vPapeisPorFragmento", "vPapeisPorSegmentso", "vPapeisPorFragmentso", "vPapeisPorFragmentor", "vPapeisPorSegmentse", "vPapeisPorFragmentsor", "vPapeisPorFragmente", "vPapeisPorSegmente", "vPapeisPorSegamentor", "vPapeisPorSegmentsor", "vPapeisPorSegmentationo", "vPapeisPorSegmentationos", "vPapeisPorFragmentsos", "vPapeisPorSegmentos", "vPapeisPorSegmentor", "vPapeisPorSegmentsos", "vPapeisPorFragmentse", "vPapeisPorSegamente", "vPapeisPorSegmentationor", "vPapeisPorSegamentos", "vPapeisPorSegmentatione", "vPapeisPorFragmentos", "vPapeisPorSegamento"], "sql": ["where", "db", "os", "term", "query", "sl", "script", "msg", "html", "QL", "layout", "s", "comment", "slice", "install", "ln", "ls", "id", "statement", " SQL", "sn", "sol", "SQL", "json", "sb", "section", "sf", "sg", "http", "pr", "params", "acl", "ssl", "csv", "description", "str", "util", "url", "base", "serv", "zip", "data", "sq", "log", "spec", "dl", "eps", "shell", "ql", "body", "string", "nl", "seed", "setup", "sv", "spr", "select"]}}
{"id1": "21224967", "id2": "13499897", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 0, "substitutes": {"crear": [" Crear", "generas", "genera", " crea", " creas", "Creas", "generare", " Crea", " Creas", "generar", "Crea", "Creare", " Creare", "Crear", " creare"], "result": ["df", "entry", "status", "function", "Result", "results", "limit", "comment", "currency", "response", "match", "number", "die", "force", "length", "user", "ret", "count", "err", "valid", "grade", "up", "default", "order", "rate", "out", "event", "score", "date", "mark", "value", "success", "feature", "record", "res", "counter", "diff", "error", "type", "cash", "ure", "found", "page", "sign", "message", "ver", "db"], "sql": ["action", "seed", "serv", "zip", "join", "string", "pg", "statement", " SQL", "select", "script", "comment", "dl", "log", "params", "sync", "database", "printf", "conn", "fn", "up", "base", "setup", "install", "cmd", "exec", "query", "url", "where", "sl", "session", "q", "plan", "fp", "repl", "ssl", "ql", "job", "update", "SQL", "db", "sq"], "connection": ["application", "section", "container", "function", "position", "c", "Connection", "cache", "environment", "context", "statement", "union", "table", "pg", "proxy", "condition", "ion", "log", "con", "manager", "ctx", "engine", "BC", "driver", "database", "relation", "conn", "loc", "which", "Exception", "p", "document", "cond", "event", "communication", "server", "query", "system", "config", "bc", "index", "session", "graph", "connect", "socket", "writer", "error", "connected", "lock", "client", "collection", "db", "tc"], "ps": ["ups", "hs", "ks", "pc", "cop", "pd", "pps", "bs", "pr", "pg", "pse", "eps", "proxy", "gs", "params", "pt", "Ps", "os", "ins", "ppa", "changes", "pp", "conn", "pers", "properties", "p", "proc", "qs", "pos", "pe", "cp", "pa", "vs", "query", "ops", "sp", "settings", "cs", "ports", "ns", "ds", "pre", "ips", "posts", "jp", "PS", "po", "gres", "ss"]}}
{"id1": "8069594", "id2": "665420", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"copyFile": ["transferFolder", " copyfile", " copiedFile", " copiedFolder", " copiedFiles", "copyfile", " copiedfile", "transferfile", "copyFolder", " copyFiles", " copyFolder", "transferFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "base", "pin", "i", "input", "id", "ex", "lock", "ic", "inner", "as", "ins", "bin", "part", "at", "reader", "source", "up", "login", "min", "old", "diff", "inc", "work", "data", "file", "config", "x", "null", "or", "name", "again", "m", "exec", "image", "io", "it", "In", "a", "url", "err", "inn", "win", "this", "din"], "out": ["base", "ex", "output", "n", "server", "outer", "user", "plus", "plain", "version", "OUT", "c", "outs", "o", "all", "off", "write", "bin", "line", "outside", "at", "one", "source", "up", "not", "target", "old", "inc", "file", "object", "x", "p", "null", "conn", "about", "name", "again", "exec", "Out", "io", "writer", "image", "to", "ext", "update", "v", "err", "b", "vert", "this", "external"], "inChannel": ["binStream", "inputChannel", "INchannel", "inStream", "inputchannel", " inClient", "binClient", "inchannel", "binChan", "outContext", "InChan", "loginChannel", "inputChan", "Inchannel", "INChan", "INClient", "outStream", "inContext", "outchannel", "inputConnection", "outChan", "inChan", "InChannel", "loginContext", "InStream", "InConnection", "inputStream", "binChannel", "INStream", " inConnection", "INChannel", " inStream", "inputContext", "inConnection", "inClient", " inChan", "loginchannel", "loginStream", "INConnection"], "outChannel": ["innerStream", "OutStream", "outputConnection", "inStream", "againChannel", "oChannel", "OutChannel", "inchannel", "oChan", "outContext", " outConnection", "againChan", "oStream", "againContext", "againConnection", "OutChan", "outStream", "inContext", "outchannel", "innerChannel", "againStream", "outChan", "inChan", "ochannel", "outputStream", "outputChannel", "innerChan", "outConnection", "Outchannel", "againchannel", "outputChan", "inConnection", " outStream", "innerContext", " outchannel", " outChan"]}}
{"id1": "13499897", "id2": "23452437", "code1": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"CopyFile": ["CreateFolder", " CopyDir", "CopyFolder", "CreateFile", "Createfile", " copyFile", " CopyFolder", " copyDir", "CreateDir", " copyfile", "Copyfile", "CopyDir", " copyFolder", " Copyfile"], "sourcefile": ["destfilename", "configlog", "destFile", "deststream", " sourceFile", "configstream", "sinstream", "configFile", "sinFile", "sourcefilename", "Sourcefilename", "sourceFile", "SourceFile", "configfile", "sinlog", "Sourcef", "sourcestream", "Sourcefile", " sourcefilename", "sourcelog", "sinfile", "destf", " sourcef", "sourcef", "destlog"], "destfile": ["destfilename", "sourcestring", "tempFile", "destFile", "DestFile", "targetfilename", "tempfile", "buildfile", "srcfilename", "srcpath", "destroypath", "Destfilename", " desturl", "newfp", "desturl", "tempfilename", "destfp", "targeturl", "deststream", "newfilename", "Destpath", "tempstream", " deststring", "destroyfile", " destFile", "Desturl", "newfile", "buildstring", "srcstream", "deststring", "sourcefilename", "sourceFile", "targetfile", " destpath", "targetFile", "temppath", "destroystream", " destfp", "newFile", "destroyfilename", "Destfp", "srcfile", "destpath", "srcFile", "buildFile", "Destfile", "buildfilename", "targetpath", "sourcepath", " destfilename"], "last": ["nd", "right", "base", "child", "end", "depth", "offset", "latest", "current", "event", "cur", "count", "total", "key", "use", "later", "full", "cat", "after", "left", "style", "code", "from", "route", "core", "path", "next", "recent", "part", "Last", "se", "real", "prev", "first", "ending", "length", "size", "start", "range", "value", "empty", "old", "or", " Last", "max", "ast"], "parent": ["unit", "base", "child", "temp", "section", "point", "root", "fat", "current", "content", "po", "function", "patch", "target", "anc", "exp", "text", "cache", "filename", "key", "remote", "api", "post", "Parent", "home", "string", "null", "pa", "path", "next", "ant", "p", "line", "parents", "part", "pointer", "and", "dest", "mac", "ip", "name", "location", "test", "ac", "search", "data", "file", "id", "valid", "port", "shared", "partial", "loc", "source", "url", "ppa"], "f": ["folder", "j", "base", "o", "feed", "of", "found", "self", "fa", "inf", "lf", "F", "fe", "ref", "fc", "l", "b", "full", "c", "cf", "r", "g", "fd", "t", "d", "fb", "p", "v", "df", "flat", "fp", "fs", "dir", "h", "file", "af", "e", "sf", "i", "m", "s"], "srcChannel": ["srcchannel", " srcConnection", "destchannel", "rcClient", "destChannel", "rcChan", "destConnection", " srcChan", "rcchannel", "sourcechannel", "rcChannel", "srcChan", " srcchannel", "sourceChan", " srcClient", "sourceConnection", "sourceChannel", "destClient", "destChan", "srcClient", "rcConnection", "srcConnection"], "dstChannel": ["drcChannel", "idrcButton", "DstContext", "idstchannel", "DstChannel", "DestChan", "dstschannel", "destchannel", "DstChan", "drcChan", "DestContext", "dstsChan", "idstChan", "ddestContext", "dstButton", "DstBuffer", "destChannel", "dstBuffer", "Dstchannel", "dntChan", "ddestBuffer", "DestBuffer", "idrcChan", "idrcChannel", "dntBuffer", "dstchannel", "destBuffer", "dstsChannel", "drcButton", "idrcchannel", "destContext", "idstChannel", "dsrcChan", "dntContext", "dstChan", "ddestChannel", "destButton", "idstButton", "ddestChan", "drcchannel", "dsrcChannel", "destChan", "dsrcButton", "dsrcchannel", "Destchannel", "DestChannel", "dstContext", "dntChannel"]}}
{"id1": "12066447", "id2": "7911686", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"truncate": ["autatenational", "autuncation", "truncator", "trunate", "autuncate", "autatenation", "autuncator", "trunation", "trrenation", "trrenator", "truncation", "tratenator", "trrenate", "trunational", "trrenational", "tratenate", "tratenational", "autuncational", "trunator", "autatenate", "truncational", "autatenator", "tratenation"], "file": ["File", "log", "image", "base", "folder", "resource", "model", "body", "address", "this", "stream", "current", "format", "function", "ile", "zip", "cache", "http", "local", "filename", "queue", "l", "info", "full", "object", "page", "string", "class", "future", "files", "path", "handler", "single", "plus", "type", "line", "io", "uri", " File", "it", "out", "fp", "FILE", "name", "archive", "data", "binary", "document", "e", "parent", "time", "one", "per", "get", "or", "connection", "source", "db", "f", "url", "directory"], "backupRoot": ["backbaseRoot", "backUpDir", "BackupRoot", "backbackDir", "backupsFolder", "backupHome", "frontupFolder", "backdownDirectory", "backdownFile", "backdownFolder", "backureDirectory", "Backuproot", "BackureRoot", "BackbackFile", "backupsPath", "backUpRoot", "backupsDir", "backdownRoot", "backflowRoot", "backdownroot", "backbackDirectory", "BackureDirectory", "backupDirectory", "BackbackRoot", "backupFolder", "backupsroot", "backbaseDirectory", "BackdownRoot", "BackdownPath", "backupsDirectory", "backflowFile", "backflowDir", "backupsRoot", "BackbackDir", "backupFile", "Backbackroot", "Backdownroot", "backureDir", "BackupDir", "BackureDir", "backbackroot", "frontdownFolder", "frontdownDir", "frontuproot", "frontupDir", "backUproot", "backureHome", "backUpFolder", "BackupHome", "backupPath", "BackupDirectory", "BackupPath", "backdownHome", "backbasePath", "backuproot", "backureRoot", "backbackFile", "backdownDir", "frontdownroot", "BackureHome", "BackdownDirectory", "frontdownRoot", "backbaseroot", "backbackHome", "backflowroot", "backupDir", "BackupFile", "frontupRoot", "backbackRoot", "backdownPath"], "df": ["dd", "DF", "flow", "de", "dp", "fr", "pdf", "func", "dc", "format", " def", "fe", "fc", "xf", "raf", "da", "cf", "def", "deb", "fd", "di", "d", "fb", "ds", "dt", "io", "CF", "fp", "fs", "dq", "md", "tf", "data", "fn", "af", "dn", "sf", "pd", "dm", "bf", "dl", "db", "f", "dict"], "date": ["re", "rule", "log", "fee", "j", "create", "module", "form", "dat", "format", "pre", "input", "D", "open", "version", "day", "age", "message", "back", "modified", "dose", "use", "output", "sync", "created", "update", "style", "string", "code", "updated", "atom", "days", "pe", "Date", "stage", "custom", "d", "work", "ate", "db", "type", "dt", "year", "x", "min", "out", "diff", "bug", "ale", "name", "ge", "data", "valid", "value", "str", "complete", " Date", "time", "m", "tag", "dates", "url"], "zipFile": ["zModel", " zipEntry", "ressModel", "zipModel", "sqlFile", "Zipfile", "ressSection", "sqlfile", "zFiles", "zSection", "zipFiles", "zFile", "ZipEntry", "zipEntry", "zipfile", "zipSection", "ressfile", "sqlModel", "sqlSection", "ZipFile", " zipfile", "zfile", "ressFile", "ZipFiles", " zipFiles", "zEntry"], "zos": ["z", "iffs", "her", "asio", "zes", "closure", "zx", "kos", "gz", "zb", "uz", "zar", "ops", "zzy", "cash", "ls", "dos", "bos", "osi", "lins", "zip", "nz", "liquid", "webkit", "zon", "nox", "zer", "js", "tz", "ZA", "zy", "exit", "zn", "inos", "outs", "zo", "forge", "eros", " sands", "zag", "bes", "ils", "settings", "chini", "ros", "ozo", "obb", "os", "bitcoin", "dylib", "css", "zl", "cos", "ses", "ssl", "proxy", "zan", "las", "zona", "han", "zik", "rez", "robe", "zen", "zero", "jas", "hess", "fits", "zh", "los", "budget", "zi", "address"], "fis": [" fits", "flisp", "rafris", "infiz", "flis", "rafis", "infids", "liss", "fisl", "flris", "fisp", "viz", "bos", "fias", "fids", "lis", "fils", "vis", " fos", "infits", "bisl", "fos", " fias", "lias", "infias", " fils", "vils", "Fisp", "infils", " fisp", "rafiss", " fiss", "Fisl", "Fos", "Fis", "fris", " fisl", "fiz", "bis", "Fiss", "fliss", "fiss", "lids", "infis", "vits", "flias", "biss", " fiz", "infiss", "flids", "Fias", "rafias", "fits", "Fris", " fris"], "entry": ["z", "lc", "her", "de", "image", "letter", "index", "feed", "ion", "offset", "event", "ry", "obj", "exp", "zip", "Entry", "add", "key", "info", "ui", "auto", "extra", "style", "element", "array", "so", "r", "cel", "ace", "next", "zo", "ie", "si", "record", "se", "uri", "it", "and", "row", " Entry", "term", "the", "archive", "ge", "server", "data", "ries", "cell", "e", "card", "comment", "reader", "per", "or", "address"], "buffer": ["shape", "wave", "feed", "sequence", "flush", "beta", "channel", "available", "cache", "slice", "queue", "b", "writer", "bytes", "bb", "device", "page", "pad", "null", "buf", "buff", "position", "border", "vector", "Buffer", "padding", "uffer", "result", "number", "row", "layer", "length", "FFER", "server", "data", "reference", "binary", "seed", "transfer", "comment", "reader", "iter", "batch", "memory", "header", "address"], "readed": ["intended", " Readable", "intized", "readered", "intED", " readable", " readered", "texted", "inputED", " Readed", "textended", "bootered", " Readled", " readned", "inputed", "textED", "inted", "bootable", " readED", " ReadED", "readable", " Readned", "readized", " readized", " readended", "inputled", "readled", "textized", "bootED", "booted", "readED", " readled", "readned", " Readered", "readended", "inputned"]}}
{"id1": "10728243", "id2": "1986417", "code1": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "code2": "    @Override\n    public void export(final Library lib) throws PluginException {\n        try {\n            new Thread(new Runnable() {\n\n                public void run() {\n                    formatter.format(lib, writer);\n                    writer.flush();\n                    writer.close();\n                }\n            }).start();\n            ftp.connect(host);\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                ftp.disconnect();\n                throw new PluginException(\"Unable to connect to FTP\");\n            }\n            ftp.login(user, pass);\n            ftp.pasv();\n            ftp.changeWorkingDirectory(dir);\n            ftp.storeFile(file, inStream);\n            ftp.logout();\n        } catch (SocketException e) {\n            throw new PluginException(e);\n        } catch (IOException e) {\n            throw new PluginException(e);\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"scramble411": ["scramprint411", "screamprint411", "screamble123", "screamprint41", "screamble5", "screamprint123", "screamprint5", "scramble5", "scramble41", "scramcy41", "scramprint5", "scramprint123", "screamble411", "scrambe5", "scramcy123", "scramble123", "scrambe41", "scramcy5", "scrambe123", "screamble41", "scrambe411", "scramprint41", "scramcy411"], "password": ["wallet", "name", "channel", "email", "wd", "sudo", "words", "user", "Password", "mac", "account", "key", "address", "secret", "crypt", "padding", "sword", "project", "phrase", "PASS", "hash", "path", "filename", "attribute", "sum", "config", "number", "pass", "dh", "word", "prefix", "token", "input", "pad", "security", "auth", "string", "username"], "seed": ["offset", "volume", "Salt", "finger", "name", "machine", "slice", "pair", "state", "mode", "sudo", "text", "size", "zip", "alias", "key", "random", "address", "secret", "crypt", "padding", "source", "template", "driver", "phrase", "hash", "pattern", "prime", "sum", "pass", "shadow", "id", "prefix", "eed", "token", "pad", "length", "string", "device", "username"], "md": [" Md", "bm", "meta", "df", "bd", "vd", "doc", "mag", "mg", "cd", "addr", "rm", "wd", "ds", "grad", "mad", "dd", "m", "ma", " MD", "mt", "mode", "ind", "ld", "kg", "dig", "di", "mid", "om", "mb", "ht", "am", "part", "mac", "hm", "cmd", "dm", "mn", "sm", "d", "dc", "MD", "km", "gd", "mo", "diff", "amd", "mi", "mp", "metadata", "mm", "pm", "dh", "sha", "po", "cm", "mem", "mc", "nd", "ms", "pd", "mand", "ad", "od", "hd", "nm", "Cmd", "pkg"], "passwordHashStage1": ["passwordSumStage1", "passwordSumPhase1", "passwordHashPhaseOne", "passwordSumStage0", "passwordHashstage3", "passwordHashstage4", "passwordHashstage0", "passwordSumStage4", "passwordSumPhase2", "passwordSumPhase4", "passwordHashPhase0", "passwordHashPhase4", "passwordHashStageOne", "passwordSumStage3", "passwordHashStep3", "passwordHashStep1", "passwordHashStep2", "passwordSumPhase3", "passwordHashstage2", "passwordSumStage2", "passwordHashstage1", "passwordSumPhaseOne", "passwordSumPhase0", "passwordHashPhase1", "passwordHashPhase2", "passwordHashPhase3", "passwordHashStage4", "passwordHashstageOne", "passwordSumStageOne", "passwordHashStage3", "passwordHashStage0"], "passwordHashStage2": ["passwordHashStage02", "passwordSumStage1", "passwordSumPhase1", "passwordSumStageTwo", "passwordHashStage8", "passwordBlockStage1", "passwordBlockStage4", "passwordBlockstage4", "passwordHashstage8", "passwordBlockstage2", "passwordHashstage4", "passwordBlockStage8", "passwordHashStep4", "passwordSumPhase2", "passwordSumStage02", "passwordHashPhase8", "passwordHashStageTwo", "passwordHashPhase02", "passwordHashPhase4", "passwordBlockStage2", "passwordHashstage02", "passwordHashstageTwo", "passwordHashStep1", "passwordHashStep2", "passwordHashstage2", "passwordSumStage2", "passwordHashstage1", "passwordHashPhaseTwo", "passwordBlockstage1", "passwordHashPhase1", "passwordHashStep8", "passwordSumPhaseTwo", "passwordHashPhase2", "passwordBlockstage8", "passwordHashStage4", "passwordSumPhase02"], "toBeXord": ["tobeXorder", "toBeCrossor", "toBeZorder", "toBeWorkors", "tobeYors", "toBeXords", "toBEYord", "toBeXor", "toBeXors", "toBeZors", "toBEYORD", "toBeCrossords", "toBeZor", "toBEXords", "toBeYorder", "tobeXords", "tobeYorder", "toBeWorkord", "toBEXORD", "toBEYor", "toBeXorder", "toBeCrossord", "toBeYord", "tobeYord", "tobeXors", "tobeXord", "tobeCrossords", "toBEXord", "tobeCrossor", "toBeWorkords", "toBeXORD", "toBeYors", "toBeWorkORD", "toBeCrossors", "tobeCrossord", "tobeYor", "toBeZORD", "toBeWorkorder", "toBeYor", "toBeYords", "toBeCrossORD", "toBEYords", "toBeWorkor", "toBeZords", "toBEXor", "tobeXor", "tobeCrossors", "toBeZord", "toBeYORD"], "numToXor": ["numToXors", "numToXOr", "numToCrossOr", "num2XOr", "numToxOR", "numToWorkOR", "numToAbsorer", "numtoXors", "numtoxorer", "numToXOR", "num2Xorer", "numToAbsor", "numtoxor", "numToxors", "numToAnyOR", "numtoxOR", "numToAbsOR", "num2AbsOr", "num2XOR", "numtoxors", "numToAnyorer", "numToWorkors", "numToXorer", "numToWorkor", "num2AbsOR", "numToWorkorer", "numToCrossor", "numToCrossors", "numtoXorer", "numtoXOR", "numToxor", "numToAnyOr", "numToCrossorer", "num2Xor", "numToxorer", "numToAbsOr", "num2Absorer", "numToAnyor", "num2Absor", "numtoXor", "numToCrossOR"], "i": ["x", "f", "y", "si", "it", "ti", "ri", "slice", "m", "p", "j", "info", "pi", "k", "ix", "hi", "I", "di", "u", "b", "part", "multi", "bi", "qi", "l", "r", "e", "o", "key", "off", "abi", "d", "ci", "z", "t", "h", "xi", "v", "oi", "ui", "li", "uri", "n", "ii", "io", "c", "in", "id", "index", "chi", "a", "ai", "gi", "ip"]}}
{"id1": "21998571", "id2": "3809087", "code1": "    private String readTwitterFead() {\n        StringBuilder builder = new StringBuilder();\n        HttpClient client = new DefaultHttpClient();\n        HttpGet httpGet = new HttpGet(\"http://twitter.com/statuses/user_timeline/vogella.json\");\n        try {\n            HttpResponse response = client.execute(httpGet);\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n            if (statusCode == 200) {\n                HttpEntity entity = response.getEntity();\n                InputStream content = entity.getContent();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(content));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    builder.append(line);\n                }\n            } else {\n                Log.e(AndroidJsonTestingActivity.class.getName(), \"Failed to download file\");\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return builder.toString();\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"readTwitterFead": ["downloadFacebookJead", "downloadTwitterFleead", "downloadTwitterFFees", "downloadFacebookFees", "downloadTwitterFleee", "downloadTwitterFee", "downloadTwitterFFee", "downloadTwitterFrequency", "downloadTwitterJee", "downloadTwitterFees", "downloadFacebookFead", "downloadTwitterFlerequency", "downloadFacebookFee", "downloadTwitterJead", "downloadTwitterFead", "downloadTwitterFleees", "downloadTwitterFFrequency", "downloadFacebookJrequency", "downloadTwitterJrequency", "downloadFacebookJees", "downloadTwitterJees", "downloadFacebookJee", "downloadTwitterFFead", "downloadFacebookFrequency"], "builder": ["image", "letter", "base", "address", "board", "entry", "worker", "http", "message", "parser", "Builder", "atter", "writer", "b", "upper", "object", "we", "driver", "string", "null", "array", "r", "store", "buffer", "oder", "built", "er", "builders", "result", "container", "build", "sb", "row", "layer", "block", "loader", "trace", "runner", "bean", "wrapper", "server", "sf", "instance", "building", "keeper", "database", "iter", "db", "f", "url", "holder", "editor"], "client": ["method", "force", "service", "resource", "Client", "cli", "google", "channel", "http", "bird", "queue", "api", "conn", "url", "class", "application", "c", "session", "cloud", "handler", "io", "https", "ce", "app", "request", "proxy", "tc", "con", "server", "host", "connect", "i", "per", "get", "contact", "connection", "config", "project", "plugin", "socket"], "httpGet": ["HTTPSend", "HttpGet", "HttpDo", "HTTPget", " httpDo", " httpget", "HttpSplit", "ttpSplit", "ttpDo", "httpSend", "urlGet", "httpPut", "HTTPGet", " httpSend", " httpFind", "HttpPut", "httpget", "urlFind", "httpFind", "httpSplit", "urlSend", "HTTPFind", "ttpPut", "httpDo", " httpSplit", " httpPut", "ttpGet", "urlget"], "response": ["body", "onse", "service", "resource", "wave", "stream", "event", "Response", "json", "http", "message", "output", "api", "writer", "respond", "full", "object", "page", "status", "application", "collection", "resp", "session", "success", "handler", "successful", "result", "report", "ception", "received", "request", "server", "data", "document", "error", "connection", "reply"], "statusLine": ["contentLine", "statusBlock", "httpEntry", "StatusLine", "statResponse", "responseEntry", "statusResponse", "statLine", "StatusEntry", "contentStatus", "statEntry", " statusEntry", "responseResponse", "responseLine", "statusEntry", "httpBlock", "contentEntry", "responseCode", "statCode", "StatusBlock", "StatusStatus", "httpLine", "contentBlock", "statusStatus", " statusResponse", "httpStatus"], "statusCode": ["contentLine", "statusCount", "StatusLine", "contentCode", "stateStatus", "StatusCount", "StatusCode", " statusType", "statusType", "contentCount", "stateType", "contentType", "StatusStatus", "stateCode", "statusStatus", "StatusType", " statusCount", " statusStatus"], "entity": ["enc", "body", "model", "resource", "agent", "stream", "coll", "event", "et", "json", "entry", "http", "media", "writer", "object", "page", "status", "code", "element", "application", "collection", "er", "result", "type", "ent", "xml", "article", "server", "data", "file", "document", "e", "person", "el", "activity", "Entity", "connection", "source"], "content": ["body", "image", "resource", "Content", "feed", "raw", "child", "cont", "stream", "input", "json", "entry", "channel", "text", "message", "load", "output", "media", "writer", "conn", "object", "page", "status", "read", "driver", "collection", "buffer", "handler", "result", "pointer", "layer", "xml", "loader", "server", "data", "file", "activity", "source"], "reader": ["in", "resource", "stream", "rer", "input", "worker", "reading", "ler", "parser", "rar", "bird", "writer", "read", "ri", "r", "buffer", "oder", "handler", "er", "io", "rr", "row", "ner", "loader", "server", "data", "ser", "Reader", "i", "per", "iter", "or", "editor"], "line": ["link", "body", "letter", "lc", "base", "feed", "end", "liner", "point", "sheet", "lf", "write", "lines", "entry", "inline", "LINE", "text", "message", "Line", "sync", "key", "l", "object", "page", "style", "string", "code", "pe", "r", "buffer", "pass", "part", "row", "ip", "block", "le", "character", "name", "data", "file", "id", "cell", "e", "char", "str", "sl", "i", "comment", "one", "iter", "connection", "source", "url", "lin"]}}
{"id1": "20267500", "id2": "23620712", "code1": "    public static AudioInputStream getWavFromURL(String urlstr) {\n        URL url;\n        AudioInputStream ais = null;\n        try {\n            url = new URL(urlstr);\n            URLConnection c = url.openConnection();\n            c.connect();\n            InputStream stream = c.getInputStream();\n            ais = new AudioInputStream(stream, playFormat, AudioSystem.NOT_SPECIFIED);\n            LOG.debug(\"[getWavFromURL]Getting audio from URL: {0}\");\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return ais;\n    }\n", "code2": "    private void insertService(String table, int type) {\n        Connection con = null;\n        log.info(\"\");\n        log.info(\"\u6b63\u5728\u751f\u6210\" + table + \"\u7684\u670d\u52a1\u3002\u3002\u3002\u3002\u3002\u3002\u3002\");\n        try {\n            con = DODataSource.getDefaultCon();\n            con.setAutoCommit(false);\n            Statement stmt = con.createStatement();\n            Statement stmt2 = con.createStatement();\n            String serviceUid = UUIDHex.getInstance().generate();\n            DOBO bo = DOBO.getDOBOByName(table);\n            List props = new ArrayList();\n            StringBuffer mainSql = null;\n            String name = \"\";\n            String l10n = \"\";\n            String prefix = table;\n            String serviceType = \"null\";\n            Boolean isNew = null;\n            switch(type) {\n                case 1:\n                    name = prefix + \"_insert\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = getInsertSql(props, table);\n                    serviceType = \"8\";\n                    isNew = Boolean.TRUE;\n                    break;\n                case 2:\n                    name = prefix + \"_update\";\n                    l10n = name;\n                    props = bo.retrieveProperties();\n                    mainSql = this.getModiSql(props, table);\n                    serviceType = \"7\";\n                    isNew = Boolean.FALSE;\n                    break;\n                case 3:\n                    DOBOProperty property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_delete\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"delete from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"5\";\n                    break;\n                case 4:\n                    property = DOBOProperty.getDOBOPropertyByName(bo.getName(), this.keyCol);\n                    if (property == null || property.getColName() == null) {\n                        return;\n                    }\n                    name = prefix + \"_browse\";\n                    l10n = name;\n                    props.add(property);\n                    mainSql = new StringBuffer(\"select * from \").append(table).append(\" where \").append(this.keyCol).append(\" = ?\");\n                    serviceType = \"10\";\n                    break;\n                case 5:\n                    serviceType = \"2\";\n                    name = prefix + \"_list\";\n                    l10n = name;\n                    mainSql = new StringBuffer(\"select * from \").append(table);\n            }\n            this.setParaLinkBatch(props, stmt2, serviceUid, isNew);\n            StringBuffer aSql = new StringBuffer(\"insert into DO_Service(objuid,l10n,name,bouid,mainSql,type) values(\").append(\"'\").append(serviceUid).append(\"','\").append(l10n).append(\"','\").append(name).append(\"','\").append(this.getDOBOUid(table)).append(\"','\").append(mainSql).append(\"',\").append(serviceType).append(\")\");\n            log.info(\"Servcice's Sql:\" + aSql.toString());\n            stmt.executeUpdate(aSql.toString());\n            stmt2.executeBatch();\n            con.commit();\n        } catch (SQLException ex) {\n            try {\n                con.rollback();\n            } catch (SQLException ex2) {\n                ex2.printStackTrace();\n            }\n            ex.printStackTrace();\n        } finally {\n            try {\n                if (!con.isClosed()) {\n                    con.close();\n                }\n            } catch (SQLException ex1) {\n                ex1.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getWavFromURL": ["getWavForURL", "getWavefromUR", "getWaveFromUR", "getWavefromurl", "getWavForUR", "getWaveFromURL", "getWavfromUR", "getWavForurl", "getWavefromURL", "getWavFromurl", "getWavefromUrl", "getWaveFromurl", "getWavfromUrl", "getWaveFromUrl", "getWavForUrl", "getWavfromurl", "getWavFromUrl", "getWavFromUR", "getWavfromURL"], "urlstr": ["urlstring", "urlpath", " urlSTR", "urlSTR", "httppath", "fileStr", "llStr", "urlStr", " urlStr", "llSTR", "llstr", " urlpath", "lSTR", "lstring", "lstr", "httpstring", "lStr", "filepath", "filestring", "llstring", "filestr", " urlstring", "httpStr", "httpstr"], "url": ["lc", "image", "log", "URL", "lr", "resource", "feed", "www", "coll", "ul", "cl", "Url", "ls", "cur", "http", "l", "api", "ch", "b", "conn", "page", "string", "path", "li", "fl", "source", "org", "uri", "plug", "build", "ur", "oc", "ssl", "server", "file", "ll", "ob", "e", "u", "sl", "str", "rl", "connection", "loc", "host", "f"], "ais": ["audi", "oi", "ahi", "cci", "aus", "ay", "aud", "audio", " ado", "oci", " arra", "ls", "sa", "mos", "acs", "ians", " ain", "bb", " audi", "ws", "ami", "waves", "aa", "ays", "plays", " au", "au", "avi", "ait", "ci", "ds", "ras", " ads", " sax", "ai", "is", "xml", "as", "rs", " audio", "ac", "ae", "ois", " tapes", "ios", "ss", "rss", "gae", "ava", "asi", "aos", "Audio", "aaa", "ia"], "c": ["enc", "lc", "coll", "dc", "cl", "nc", "pc", "channel", "ctrl", "http", "fc", "cu", "l", "ch", "conn", "cd", "b", "api", "cb", "C", "cf", "ct", "ci", "p", "cmp", "cs", "client", "cc", "cm", "ac", "co", "a", "con", "ec", "cn", "e", "u", "mc", "bc", "cp", "connection", "m", "cr", "f"], "stream": ["video", "in", "uu", "feed", "coll", "form", "w", "audio", "input", "channel", "src", "zip", "cache", "fc", "output", "l", "b", "object", "string", "engine", "path", "d", "p", "io", "context", "cm", "h", "server", "data", "host", "e", "u", "sl", "reader", "sw", "Stream", "uc", "connection", "m", "source", "f", "s"]}}
{"id1": "11546108", "id2": "3756429", "code1": "    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(new URL(urlInfo).openStream()));\n            String ligneEnCours;\n            int i = 0;\n            informations = \"\";\n            while ((ligneEnCours = in.readLine()) != null) {\n                switch(i) {\n                    case 0:\n                        version = ligneEnCours;\n                        break;\n                    case 1:\n                        url = ligneEnCours;\n                        break;\n                    default:\n                        informations += ligneEnCours + '\\n';\n                        break;\n                }\n                i++;\n            }\n            in.close();\n            erreur = false;\n        } catch (IOException e) {\n            erreur = true;\n            texteErreur = e.getMessage();\n            if (texteErreur.equals(\"Network is unreachable\")) {\n                texteErreur = \"Pas de r\u00e9seau\";\n                numErreur = 1;\n            }\n            if (e instanceof FileNotFoundException) {\n                texteErreur = \"Probl\u00e8me param\u00e9trage\";\n                numErreur = 2;\n            }\n            e.printStackTrace();\n        } finally {\n            for (ActionListener al : listeners) {\n                al.actionPerformed(null);\n            }\n        }\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"run": ["call", "output", "load", "download", "update", "println", "running", "input", "Run", "build", "process", "read", "evaluate", "print", "action", "execute", "runner", "exec", "submit", "write", "test", "loop", "request", "apply", "start"], "in": ["source", "init", "buffer", "inn", "token", "out", "client", "inner", "c", "f", "s", "e", "input", "l", "socket", "serv", "IN", "data", "loader", "ini", "con", "io", "isin", "bin", "b", "server", "fin", "is", "pool", "nin", "min", "ins", "h", "fr", "stream", "lin", "In", "inc", "again", "rin", "r", "t", "login", "ssl", "reader", "din", "cms"], "ligneEnCours": ["ligneEnScOUR", "ligneEnAcour", "ligneEnScore", "ligneENcrosse", "ligneEnTore", "ligneOpenAcurs", "ligneOpenCOUR", "ligneEnAcours", "ligneenAcours", "ligneENcour", "ligneenCour", "ligneEnScrosse", "ligneEnLCrosse", "ligneEnTour", "ligneEnAcurs", "ligneEnCour", "ligneENCOUR", "ligneEnLCOUR", "ligneEnCore", "ligneenCore", "ligneENCore", "ligneEnFCOUR", "ligneEncourses", "ligneOpenAcour", "ligneEncOUR", "ligneOpenAcours", "ligneEncurs", "ligneENCrosse", "ligneEnTours", "ligneEnSours", "ligneOpenCour", "ligneOpenAcOUR", "ligneEnTourses", "ligneEnLCour", "ligneEnSour", "ligneENAcour", "ligneenCours", "ligneEnAcore", "ligneEnFCours", "ligneEncours", "ligneEnFCurs", "ligneEnFCour", "ligneEnScour", "ligneENAcourses", "ligneenAcore", "ligneENCourses", "ligneEnTurs", "ligneENAcore", "ligneEncrosse", "ligneEnCOUR", "ligneEncore", "ligneENCurs", "ligneEnTOUR", "ligneEncour", "ligneEnScourses", "ligneENcOUR", "ligneEnAcOUR", "ligneenAcourses", "ligneOpenCours", "ligneEnAcourses", "ligneENcours", "ligneEnCrosse", "ligneENcurs", "ligneEnLCours", "ligneENCours", "ligneEnCurs", "ligneEnSurs", "ligneenCourses", "ligneENCour", "ligneENAcours", "ligneOpenCurs", "ligneEnSOUR", "ligneenAcour", "ligneEnScours", "ligneEnCourses"], "i": ["p", "x", "uri", "c", "ai", "f", "gi", "ii", "info", "e", "l", "I", "k", "count", "ci", "yi", "m", "ini", "ip", "io", "iu", "bi", "n", "si", "u", "b", "col", "esi", "counter", "ui", "pi", "oi", "li", "index", "j", "di", "qi", "eni", "xi", "t", "o", "id", "zi", "type", "v", "start", "ti", "ski", "phi"], "informations": ["incstrumentations", "instrumentation", "inceptionats", "incformations", "incstrumentation", "informators", "inpectats", "inparators", "inpectations", "informsats", "inparats", "inparations", "information", "informsators", "inpectators", "insformations", "invocation", "instrumentings", "informsations", "invocations", "inparals", "incstrumentats", "informals", "insformals", "informsals", "incformats", "inceptionation", "incstrumentings", "informings", "inceptionations", "invocats", "inspectations", "instrumentations", "informats", "incformation", "inspectators", "inspectals", "instrumentats", "inspectats", "inpectals", "insformats", "insformators", "invocings", "incformings", "inceptionings"], "version": ["source", "position", "uri", "feature", "language", "versions", "download", "ver", "model", "page", "VERSION", "install", "release", "resource", "comment", "ip", "description", "v", "server", "number", "index", "Version", "channel", "prefix", "unit", "parent"], "url": ["text", "source", "position", "uri", "json", "output", "path", "language", "download", "config", "page", "image", "resource", "location", "comment", "base", "server", "URL", "number", "address", "channel", "prefix", "ssl", "href", "xml", "status", "http"], "texteErreur": ["texteErreeur", "texteErrecurs", "texteErreurs", "texteErregour", "texteErrenour", "texteErruries", "texteErrorreur", "texteErreau", "texteErrecure", "texteErrenure", "texteCurreUR", "texteErruaser", "texteErregurs", "texteErrecour", "texteErrur", "texteErrenau", "texteIrreour", "texteErrenur", "texteErreeau", "texteErrorreour", "texteCurrecurred", "texteErrourred", "texteErrecur", "texteErritour", "texteErrecUR", "texteErbreur", "texteErbreuries", "texteErreeuries", "texteErrecurred", "texteIrraser", "texteArreour", "texteErrorreau", "texteIrreaser", "texteErpreurred", "texteArrenurs", "texteErrorrenur", "texteErreuries", "texteErrecaur", "texteErregure", "texteArreurs", "texteErraser", "texteErreurred", "texteCurrecUR", "texteCurreur", "texteErrenuries", "texteErreure", "texteErreour", "texteErreUR", "texteErbreaser", "texteCurrecur", "texteErbreour", "texteErritau", "texteErruuries", "texteErpreur", "texteCurreaur", "texteErrorrenuries", "texteIrreuries", "texteErpreaur", "texteArrenure", "texteErreaur", "texteArreur", "texteErruur", "texteErrorrenour", "texteErrituries", "texteErrenurs", "texteErroUR", "texteArrenur", "texteErregur", "texteCurreurred", "texteIrrur", "texteErroaur", "texteIrruries", "texteArreure", "texteArrenour", "texteErpreUR", "texteIrreur", "texteIrrour", "texteCurrecaur", "texteErrorrenau", "texteErrour", "texteErrorreuries", "texteErreeour", "texteErruour", "texteErritur", "texteErreaser"], "numErreur": ["numSerreurs", "numErREurs", "numErroUR", "numSerrenUR", "numErroure", "numErrenur", "numEreure", "numErrecUR", "numErreure", "numErREur", "numErrecurs", "numErrours", "numEREurs", "numErroeur", "numEREur", "numEreur", "numErrecur", "numErreceur", "numErreUR", "numSerrenur", "numErrour", "numEreurs", "numSerreure", "numEREeur", "numErrecure", "numErREeur", "numErREure", "numErrenUR", "numSerreUR", "numEREure", "numEreeur", "numErrenurs", "numSerreur", "numSerrenure", "numErreeur", "numSerrenurs", "numErreurs", "numErrenure"], "al": [" signal", " fal", " ale", " bell", " AL", "hal", "f", "sal", "all", "back", "Al", "ale", "il", "cal", "ala", " ul", "unal", "stal", "als", "l", "pal", "val", "alist", "mal", "af", "alis", "alled", "bal", "alf", "ar", "dal", " Al", " nil", "aler", " cal", " hal", " all", " rel", "list", "tal", "el", "ul", " ab", "ali", "AL", "oper", "ral"]}}
{"id1": "11562173", "id2": "8069594", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["checkOutputSteam", "checkOutputStream", "checkIOstream", "checkInputstream", " checkInputChannel", "checkInputChannel", "checkOutputChannel", "checkIOSteam", " checkOutputChannel", " checkInputstream", "checkOutputstream", " checkOutputStream", "checkIOChannel", " checkOutputstream", " checkInputSteam", "checkIOStream", "checkInputSteam", "checkFileSteam", " checkOutputSteam", "checkFileChannel", "checkFilestream", "checkFileStream"], "in": ["ins", "din", "reader", "IN", "login", "bin", "io", "isin", "inc", "x", "ini", "index", "input", "ic", "In", "inner", "image", "c", "comp", "connection", "again", "inn", "p", "min", "plus", "is", "into", "data", "source", "up", "src", "con", "ack", "as"], "cmp": ["fp", "lc", "upp", "amp", "cache", "sup", "pixel", "com", "pre", "cb", "sort", "proc", "roc", "index", "omp", "conv", "cp", "c", "ci", "spec", "prefix", "comp", "cc", "asc", "np", "code", "prev", "cho", "cop", "cs", "co", "config", "diff", "loc", "clip", "p", "rc", "cup", "match", "op", "ch", "up", "mom", "coll", "pc", "cpp", "ctrl", "comment", "ctx", "mp"], "all": ["cl", "ann", "local", "allow", "ALL", "call", "valid", "not", "none", "partial", "am", "one", "default", "always", "total", "al", "auto", "asc", "All", "global", "a", "null", "both", "parent", "any", "best", "except", "list", "each", "alpha", "array", "p", "l", "match", "process", "and", "coll", "only", "full", "sum", "acl"], "stream": ["v", "test", "result", "cont", "client", "reader", "output", "port", "feed", "platform", "raw", "progress", "model", "input", "host", "string", "context", "this", "comp", "ream", "self", "Stream", "user", "transform", "null", "object", "per", "speed", "socket", "steam", "wrapper", "form", "stack", "track", "iterator", "document", "round", "source", "channel", "up", "pool", "instance", "coll", "src", "roll", "ack", "impl", "sw", "trans", "response", "temp"], "out": ["v", "result", "OUT", "outs", "project", "output", "bin", "exp", "io", "inc", "not", "x", "index", "name", "obj", "image", "c", "prefix", "this", "Out", "extra", "user", "b", "null", "again", "parent", "o", "list", "sync", "block", "outer", "array", "option", "p", "copy", "point", "other", "data", "up", "full", "part", "sum", "comment", "response"], "i": ["qi", "v", "lc", "k", "ai", "ti", "I", "e", "id", "io", "xi", "x", "ini", "index", "start", "ind", "u", "ui", "end", "li", "hi", "multi", "c", "ci", "si", "mi", "ii", "j", "type", "r", "info", "b", "n", "bi", "slice", "ri", "uri", "p", "strength", "key", "gi", "h", "ix", "abi", "it", "l", "oi", "di", "fi", "init", "d", "ji", "f", "pi"]}}
{"id1": "2396191", "id2": "20275821", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksFromUrlFast", "getLinksFromStringSafe", "getLinksFromStringFast", "getLinksfromUrlSlow", "getLinksfromURLFast", "getLinksFromSSLFast", "getLinksFromURLSafe", "getLinksfromUrlSafe", "getLinksFromUrlfast", "getLinksfromUrlFast", "getLinksfromURLSlow", "getLinksFromURLSlow", "getLinksFromUrlSafe", "getLinksfromUrlfast", "getLinksFromURLfast", "getLinksFromSSLfast", "getLinksFromSSLSlow", "getLinksFromSSLSafe", "getLinksfromURLSafe", "getLinksfromURLfast", "getLinksFromStringfast", "getLinksFromStringSlow", "getLinksFromUrlSlow"], "p_url": ["pxroot", "pklayer", "tp24url", "p__url", "p_link", "tp_link", "tp24root", "pamurl", "pamhtml", "pxline", "p_domain", "e_layer", " p_line", "pe_root", "p24url", "p_layer", "p24file", "p64url", "pkurl", "tp24link", "p_resource", "pxconfig", "tp_file", "p__resource", "pe_config", "piplink", "p64page", "p_name", "pipfile", "p25html", "pamlayer", "ekurl", "e_html", " p_resource", "p__name", "p6url", "tp_root", "p9domain", "p_line", "p6line", "p9service", " p_page", "p64line", "pe_url", "p9resource", "p_root", "p64path", "p6config", "pipurl", "x_resource", "p25layer", "pe_line", "eklayer", "pfurl", "p_page", "eklink", "p_config", "e_link", "p24root", "ekhtml", "pxurl", "p_html", " p_path", "p25url", "p__path", "piproot", "p6root", "e_url", " p_name", "x_service", "x_domain", "pflink", "pklink", "p_path", "p9url", "tp24file", "pfpage", "p25link", "pkhtml", "pamlink", "p24link", "pfline", "p_file", "tp_url", "pfroot", "p_service", "pffile", "pfpath"], "x_url": ["x_ssl", " x_log", " x_resource", "x_resource", "x_log", "p_host", " x_ssl", "x_host", "p_conn", "p_loc", "x_loc"], "x_conn": ["x___conn", "x___con", "p_db", "x_conv", "x_client", "x___client", "x___db", "wx_cat", "x_cat", "x_con", "x_db", "wx_con", "p_conn", "wx_conn", "p_client", "p_con", "wx_conv"], "x_is_reader": ["x_ismldraft", "x_ismlstream", "x_is_manager", "x_is_stream", "x_is_draft", "x_ismlmanager", "x_is_pointer", "x_is_resource", "x_is_writer", "x_ismlreader"], "x_reader": ["x67reader", "x24stream", "X_reader", "cross_parser", "x_parser", "X_result", "x_stream", "cross8url", "x67url", "x67root", "x8parser", "x8reader", "x24result", "x24parser", "x24reader", "X_stream", "cross_reader", "cross_url", "x8url", "cross8root", "cross_root", "cross8parser", "x67parser", "cross8reader", "x8root", "X_parser"], "x_line": ["ex_cell", "x_record", "x__url", "x_comment", "ex_page", "x24line", "x24comment", "x__line", "xingcell", "ex_line", "xx_link", "xingpage", "x__link", "p_link", "xx_line", "x24link", "ex_record", "p_page", "xx_comment", "xingline", "x__page", "x24lin", "x_cell", "x_lin", "xingrecord", "p_line", "xx_lin"], "e": ["r", "error", "ne", "match", "eu", "m", "eur", "ace", "p", "oe", "ie", "element", "n", "g", "entry", "ue", "ce", "el", "eve", "ee", "ze", "es", "t", "ente", "fe", "code", "se", "esi", "line", "E", "file", " E", "end", "ge", "en", "eb", "ev", "f", "o", "engine", "exec", "edge", "pe", "b", "y", "er", "v", "eps", "ele", "he", "je", "entity", "me", "l", "driver", "body", "d", "ae", "le", "te", "event", "re", "ea", "c", "ec"], "x_match": ["p__match", "x_info", "p_match", "e___matched", "e_meet", "xamreplace", "ext_pattern", "x_group", "xltag", "x__case", "p__url", " x_slice", "xjurl", "x_slice", "xlpattern", "x__replace", "ax5link", "x5match", "x__slice", "ax5info", "x_tag", " x_date", "xJsearch", "x__matched", "e_matched", "x__url", "x_date", "e_match", "x_meet", " x_group", " x__case", "p__matched", "x__pattern", "x__match", "xjmatched", "xjmatch", "ax_info", "xJmember", " x__replace", "ax_case", " x__slice", "e___meet", "x_check", "x___check", "e___check", "xlgroup", "e_check", "xldate", "e___match", "p_matched", " x_tag", "p__pattern", "ax_match", "x___meet", "ext_member", "xlmember", "ax5match", "x5link", "ext_search", "xlmatch", "extJsearch", "xJmatch", "xJpattern", "extJpattern", "p_pattern", "xlsearch", "x5info", " x__match", "x_pattern", "extJmember", "ext_match", "x___matched", "x5case", "x_member", "xamslice", " x_case", "xammatch", "x_case", "x_search", "extJmatch", "x_matched", "x_replace", "x___match", "xjpattern", "ax_link", "ax5case", " x_replace", "xamcase"], "x_dir": ["xnetdir", " x_group", "x6dir", " x_file", "x_group", "xnetfile", "xneturl", "x6url", "x6group", "x_file", "xnetgroup", "x6file"], "x_root": ["xml_alias", "x7root", "x_path", "x_alias", "x_directory", "xml_directory", "x7directory", "x7alias", "x7path", "xml_root", "xml_path"], "x_links": ["x_lines", "x67points", " x_points", "x_points", " x_lines", "x67ids", "x67lines", "x67links", " x_ids", "x_ids"], "x_texts": ["x_paths", "x_urls", "x_pathls", "x_textes", "x_textches", "x_pathches", "x_logches", "x_urles", "x_pathes", "x_textls", "x_loges", "x_logls", "x_urlls", "x_urlches", "x_logs"], "x_buf": ["x1tmp", "x64uf", "x___buf", "ex__buf", "x_buff", "x1cb", "x64rc", "x1buf", "x_cb", "ex__buff", "x_tmp", "x__tmp", "ex__tmp", "ex_cb", "x_rc", "y__rc", "y__bag", "X_wb", "ex_tmp", "X_buff", "x___uf", "x_bag", "ex__cb", "x64bag", "y_bag", "x___bag", "X_buffer", "y__buf", "x_buffer", "x64buf", "x__uf", "x___rc", "x_wb", "x__buffer", "ex_buf", "x__buf", "x1buff", "y_rc", "y__uf", "y_buf", "x__wb", "ex_buff", "x__cb", "y_uf", "X_buf", "x__bag", "x__buff", "x_uf", "x__rc"], "x_matches": ["xKtexthes", "x_patches", "x_textings", "x_matcher", "x_Matchers", "x__matures", "x_bathes", "x_attcks", "x_morhes", "x_matcks", "xKmatches", "x_texthes", "x_matchcks", "x__matchers", "x_patcher", "x_morches", "x_matchers", "x_attched", "xKtextoms", "x_matchoms", "x_matings", "x_atthes", "x_textoms", "x_calches", "x_patchers", "x_calings", "x_caloms", "x_matchings", "x_calhes", "xKmatings", "x_locches", "x_matoms", "x_locched", "x_matchches", "x_matchchers", "x_batches", "xKmathes", "x__mathes", "x_mathes", "x_patcks", "xKtextings", "x_loches", "x_Matcher", "x_Matures", "x_matures", "xKmatoms", "x_locting", "x_textches", "x_matting", "x_attches", "x_matchcher", "x_matchting", "x_morched", "x_matchched", "x_Mathes", "x_pathes", "x__matches", "x_patched", "xKtextches", "x_morting", "x_batures", "x_batchers", "x_matched", "x_Matches", "x_matchhes"], "x_page": ["X_url", "X_line", "tx_feed", "tx_link", "tx_page", "ex_page", "ex_loc", "xerfeed", "x67link", "x67page", "ex_link", "xerline", "x_path", "x67file", "xerpage", "X_path", "xerlink", "x67loc", "ex_file", "x_loc", "tx_line", "x_file", "x_feed", "X_page"], "x_link": ["ex_page", "xpubloc", "ex_line", "ex_url", "ex_link", " x_loc", "xpubtarget", "x_target", "xpublink", "x_loc", " x_target", "xpubline"], "i": ["r", "ai", "in", "j", "p", "n", "ie", "eni", "key", "multi", "ix", "phi", "id", "ci", "gi", "info", "ui", "a", "zi", "li", "index", "ii", "io", "ori", "iu", "z", "ini", "count", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "u", "b", "y", "v", "ji", "oi", "it", "di", "hi", "si", "chi", "qi", "uri", "iv", "I", "c"]}}
{"id1": "4629990", "id2": "21555906", "code1": "    private String logonToServer(FTPClient ftpClient, String ftpAddress, int noRetries) {\n        String remoteHomeDir = null;\n        noRetriesSoFar = 0;\n        while (true) {\n            try {\n                ftpClient.connect(ftpAddress, ftpPort);\n                int reply = ftpClient.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftpClient.disconnect();\n                    throw new IOException();\n                }\n                if (!ftpClient.login(user, password)) {\n                    throw new IOException();\n                }\n                remoteHomeDir = ftpClient.printWorkingDirectory();\n                msgEntry.setAppContext(\"logonToServer()\");\n                msgEntry.setMessageText(\"Logged into FTP server \" + ftpAddress + \":\" + ftpPort + \" as user \" + user);\n                logger.logProcess(msgEntry);\n                break;\n            } catch (IOException e) {\n                logoutAndDisconnect(ftpClient);\n                if (noRetriesSoFar++ < noRetries) {\n                    waitBetweenRetry();\n                    notifyAndStartWaitingFlag = false;\n                } else {\n                    notifyAndStartWaitingFlag = true;\n                    errEntry.setThrowable(e);\n                    errEntry.setAppContext(\"logonToServer()\");\n                    errEntry.setAppMessage(\"Unable to login after \" + (noRetriesSoFar - 1) + \" retries. Max Retries.\\n\" + \"Address:\" + ftpAddress + \"\\n\" + \"User:\" + user);\n                    errEntry.setSubjectSendEmail(\"Unable to login to \" + ftpAddress + \" after \" + (noRetriesSoFar - 1) + \" retries.\");\n                    logger.logError(errEntry);\n                    break;\n                }\n            }\n        }\n        return remoteHomeDir;\n    }\n", "code2": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"logonToServer": ["logonToGuest", "logOnFromRemote", "logOnFromClient", "logOnToRemote", "logOnToServer", "logOnFromServer", "logonTOClient", "logonFromServer", "logonTOGuest", "logOnToClient", "logonFromGuest", "logOnToGuest", "logonFromClient", "logonFromRemote", "logontoRemote", "logonTOServer", "logonTORemote", "logontoClient", "logOnFromGuest", "logonToRemote", "logontoServer", "logonToClient", "logontoGuest"], "ftpClient": ["ftcpAPI", "ftpaClient", "ctpPort", "ftbclient", "ftbConn", "ftcpPort", "ctcpConn", "ctcpConnect", "ctcpServer", "ftapclient", " ftpCloud", "ftpConnect", "ftpaCloud", "ftpaConn", "ftpcClient", "ftcpCenter", "ftprClient", " ftpclient", "ftpaServer", "ftpclient", " ftpaServer", " ftpaClient", "ftcpContext", "ftpiServer", "ftpcConnect", "ftpConn", "ftprPort", "ftpiClient", "ftpcServer", "ftpcPort", "ftcServer", " ftbCloud", "ftpcContext", " ftpPort", " ftpcServer", " ftpcClient", "ftpiAddress", "ftsPort", "ftcpClient", "ftcConnection", "ctpAPI", "ctpServer", "ftcClient", "ftcpConn", " ftpcContext", "ftpcAddress", "ftpaPort", "ftsClient", " ftpConn", "ftcpConnection", "ftpaCenter", "ftcpServer", "ctpConnect", "ftbPort", " ftpaclient", " ftpServer", "ftsServer", "ctcpAddress", "ctcpAPI", " ftpConnection", "ctpAddress", "ftpConnection", "ftpcclient", "ftpcConn", "ftbCloud", "ftnAddress", " ftpcConnection", "ctcpClient", "ftapCenter", "ftcContext", " ftpCenter", " ftpaCenter", "ftnServer", "ctcpPort", "ftpCloud", "ftbClient", "ftpContext", "ftpAPI", "ftcpConnect", "ftnClient", "ftapClient", "ftpcCloud", "ftsConnect", "ftnAPI", " ftpaPort", "ftapServer", "ctpConn", "ctpClient", "ftpServer", "ftpiAPI", "ftcpAddress", "ftcpclient", "ftprclient", "ftpcConnection", "ftpaAddress", " ftpContext", "ftpaclient", "ftpPort", " ftbConn", "ftpCenter", " ftbClient", " ftbclient"], "ftpAddress": ["ctpPort", "ftcpURL", "ftcpPort", " ftpaddress", "ftfAdd", "ftoAddress", "ftapPort", "ctoPort", "ftfEntry", " ftcpaddress", "ctpAdd", "ftoaddress", "ftfPort", "ftapAlias", "ctcpURL", "ftlAddress", "ftcpInterface", " ftcpAddress", "ftrInterface", "ftwpAddress", " ftcpPort", "ftportaddress", "ftnpAddress", " ftpPort", "ctcpaddress", "ctcpInterface", "ftlPort", "ctpaddress", "ftnpPort", "ftwpaddress", " ftcpAlias", "ctoAddress", "ftportPort", "ftfInterface", "ftportAlias", "fttpPort", "ctcpAdd", "ctcpAddress", "ctpInterface", "ftapaddress", "ftnpURL", "ctpAddress", "ctoaddress", "ftcpaddress", "ftpInterface", "ctpEntry", "ftpURL", "ftrPort", "ftrAdd", "ftpAdd", "ftladdress", "ctcpEntry", "ctcpPort", "ftcpAlias", "fttpURL", "ftfAddress", "ftpAlias", "ftwpPort", "ftpEntry", "ftapAddress", "ctpURL", "ftcpAddress", "ftnpaddress", "fttpEntry", "fttpaddress", "ftrAddress", "ftfaddress", "ftcpEntry", "ftcpAdd", "ftportAddress", "ftpPort", "ftpaddress", "fttpAddress", "ftoPort", " ftpAlias"], "noRetries": ["noretrying", "noEntrying", " noPatriers", " noRetrys", " noPatries", "noPatrys", "noTry", "noTrying", "noPatry", "noPatriers", "noTrys", "noExtrys", "noExtrying", "noretries", "noExtries", " noPatry", "noRetrying", "noEntries", "noTries", " noPatrying", " noRetriers", "noRetriers", "noPatries", " noPatrys", " noRetry", "noretrys", "noRetrys", "noRetry", "noretriers", "noEntrys", "noEntriers", " noRetrying", "noExtry", "noPatrying"], "remoteHomeDir": ["remoteHomePath", "RemoteRootPath", " remoteHomeFolder", "remoteHostPath", "RemoteHomeFile", "remoteWorkingPath", "remoteRootDir", " remotehomeFolder", "remoteHomeFolder", " remotehomeFile", "remotehomePath", "remoteHostDirectory", "remoteRootPath", "remotehomeFolder", "remoteRootDirectory", "remoteHostDir", "RemoteRootFile", "remoteHostFolder", " remoteHomeDirectory", "RemoteRootDirectory", "remoteRootFile", "remoteWorkingDir", " remotehomeDir", "RemoteHomeDirectory", "remoteHomeDirectory", "remotehomeFile", "remoteRootFolder", "RemoteRootDir", "RemoteHomeDir", "remotehomeDirectory", "remoteWorkingDirectory", "remoteHostFile", "RemoteHomePath", " remoteHomeFile", "remotehomeDir", " remotehomeDirectory", "remoteHomeFile", "remoteWorkingFile"], "noRetriesSoFar": ["noRetryingsoMuch", "noRetriesSOFurther", "noRetriesStillFurther", "noRetriesSofar", "noRetriessoFar", "noRetrySoFar", "noRetriesTooMuch", "noRetriesSoFurther", "noRetrySOfar", "noRetrysSOFar", "noRetrysSoFar", "noRetriesStillFar", "noRetrysSOfar", "noRetryingSoMuch", "noRetriessoMuch", "noRetriessofar", "noRetriessoFurther", "noRetryingsofar", "noRetrysSofar", "noRetrySOFar", "noRetriesSoMuch", "noRetrysSoFurther", "noRetriesSOMuch", "noRetriesSincefar", "noRetrySofar", "noRetriesTooFar", "noRetriesSOfar", "noRetrysSOFurther", "noRetryingSoFar", "noRetryingsoFar", "noRetryingSofar", "noRetriesSOFar", "noRetriesSinceFar", "noRetriesToofar", "noRetriesStillfar"], "reply": ["address", "result", "base", "error", "lie", "ping", "send", "status", "call", "answer", "comment", "feed", "request", "py", "state", "ret", "queue", "prefix", "link", "len", "bot", "next", "write", "code", "respond", "reason", "repl", "connection", "count", "info", "user", "report", "Reply", "sync", "ply", "message", "post", "service", "ix", "from", "rc", "dy", "resp", "server", " replies", " replied", "response"]}}
{"id1": "160739", "id2": "884867", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createInputReader", "createInputFile", " createIOReader", "createInputSteam", " createOutputReader", " createIOFile", " createByteReader", "createOutputReader", "createInputStream", " createOutputSteam", " createByteFile", "createOutputFile", " createInputSteam", " createIOStream", " createOutputFile", "createInputReader", " createInputStream", " createByteStream", " createInputFile", "createOutputSteam", " createIOSteam", " createByteSteam"], "inFile": ["sourceFiles", "sourceStream", "inputFile", "incFile", "outStream", "infile", "insfile", "inputStream", "incfile", "sourcefile", "inStream", "insFile", "incStream", "sourceFile", "inputFiles", "incFiles", "insStream", "outfile", "inFiles", "outFiles", "insFiles", "inputfile"], "outFile": ["workingfile", "outDir", "inputDir", "workFile", "targetFile", "inputFile", "workTime", "workingStream", "targetfile", "outStream", "workfile", " outfile", "infile", "outDirectory", "inTime", "workDir", "inputTime", " outStream", " outDirectory", "targetStream", "targetDirectory", "outTime", "outfile", "workingFile", "inDir", "workingDirectory", "inputfile"], "k_blockSize": ["k_lockCount", "k_BlockLength", "k_BlockCode", "k_byteCode", "k_byteLength", "k_lineInfo", "k_BlockSize", "k_blockCount", "k_blocksSize", "k_byteLen", "k_bitSize", "k_lineCount", "k_blocksCount", "k_bitCount", "k_lockLength", "k_lockLen", "k_BlockCount", "k_blockLen", "k_byteSize", "k_blocksLen", "k_bitInfo", "k_blockInfo", "k_blockCode", "k_byteCount", "k_lockCode", "k_blocksLength", "k_lineSize", "k_lockSize", "k_byteInfo", "k_blockLength"], "byteCount": [" bytecount", "blockSum", "byteSize", "bytecount", "byteLength", "flushCount", " byteSize", "flushcount", "characterCount", "blockSize", "blockCount", "characterLength", "blockLength", "Bytecount", "ByteSize", "byteSum", "flushLength", "ByteCount", " byteLen", "byteLen", "characterSize", "ByteLength", "ByteSum", " byteSum", "ByteLen", "flushSize", "characterLen", " byteLength"], "buf": ["vec", "uf", "Buffer", "cap", "result", "base", "img", "exc", "tmp", "cv", "feed", "brace", "font", "ctx", "fb", "border", "seq", "cmd", "queue", "len", "alloc", "bag", "Buff", "batch", "b", "background", "loc", "config", "buffer", "la", "bytes", "rb", "flush", "cas", "fd", "feat", "rc", "ucc", "data", "append", "bh", "src", "bf", "cb", "buff"], "ofp": ["fort", "afc", "Ofnp", "afp", "OFl", "forc", "ofnp", "Oft", "oftp", "forp", "OFt", "Ofp", "OFp", "oft", "ofl", "afl", "ofc", "afnp", "fortp", "OFc", "OFnp", "Ofc", "Oftp", "Ofl", "OFtp"], "zos": ["osi", "outs", "kos", "core", "zon", "budget", "zes", "os", "modules", "ozo", "zyk", "los", "ossus", "cos", "jas", "inos", "robe", "ZI", "zik", "utils", "zy", "enos", "soon", "ls", "zen", "zona", "zn", "iframe", "zi", "css", "rons", "zag", "hz", "abi", "forge", "bes", "obb", "ros", "oS", "bitcoin", "zar", "ZA", "zh", "zip", "zers", "oda", "liquid", "tz", "zl", "webkit", "bos", "owicz", "js", "za", "lins", "oses", "zx", "nz", "rez", "gz", "lol", "dylib", "z", "zin", "ws", "uz", "ses", "cfg", "iffs", "zer", "ops", "zo", "fits", "zig", "ogl", "obs", "zb", "packs", "nox", "bs"], "osw": ["lsx", "osww", "ishell", "esow", "bwo", "ossww", "essw", "oshell", "esw", "lsws", "oswo", "esnow", "osssw", "lswo", " osow", "bx", "osnow", "bsws", "osow", "ossw", "bsw", "bws", "esfw", "osswd", "isy", "isnow", "isw", "ossnow", "ossd", "esd", "osy", "osshell", " osww", "osws", "esww", "isd", "esy", "lsw", "ossow", "eswd", "iswd", " osfw", "ossfw", "issw", "ossy", "bswo", "osfw", "eshell", "bsx", "osx", "osd", "oswd"], "bw": ["lbwh", "abW", "bbz", "bbw", "abw", "bW", "bbew", "bbwa", " bwh", " bws", "lwa", "lbw", "bwa", "Bws", "baw", "bbws", " bwa", "owa", "bx", "fbwd", "bwu", "ebwd", "bwd", "lx", "bsw", "Bwa", "bwh", "bz", "bws", "lbws", "ebw", "fsw", "fbwe", "lbwa", "Bew", "fbW", "fx", "fwh", "bwe", "lbr", " bwu", "Bw", "lw", "bbwu", "lbx", "ow", "owu", "lsw", "fr", "fwa", "lbsw", "abwe", "bew", " baw", "lbz", "ebwe", "fbw", "fw", "bbaw", " bz", " bew", "ebW", "oaw", "bbwh", "abwd"], "zot": ["jot", "zott", " zor", "jori", "Ziot", "azit", "zerot", "jit", "Zor", "zita", "azita", "zeros", " ziot", "azot", "zor", "jos", "azott", "zerott", "zerita", " zori", "aziot", "Zott", "zori", "Zot", "azor", "zerori", "ziot", "Zita", "Zit", "zerit"], "ifp": ["ipl", "ipc", "iff", " ifb", "Iff", " ifi", "IFi", "ifb", "Ifi", "IFf", " ifl", "IFb", "ifi", "ipp", " ifc", "IFp", "ifc", "ipb", "IFl", "Ifc", "IFc", "ifl", "Ifp", " iff"], "zis": ["zipis", "xib", " zits", " zisi", "zeis", "xis", "zip", "zeip", " zib", "jit", " zIS", "Zits", "Ziss", "jits", "zenIS", "xits", "zeits", "zenib", "xais", "zais", "jisi", "xisi", "zenais", "Zis", "jis", "zipiss", "zib", "zIS", "zipits", "zisi", "xIS", "zipip", "zenis", "zeiss", "Zip", "zits", "xit", " zais", "ziss"], "isr": ["IScr", "isrs", "risr", " issr", "issrs", "risrc", "isrc", "rispr", "isrb", "isscr", "ISsr", "irpr", "ISrs", "isssr", "irrb", "ispr", "ISrc", "ISrb", "ISpr", " isrs", "irrc", "risrb", "ISr", " iscr", "iscr", "issr", "irr"], "br": ["yr", "bc", "obl", "img", "mr", "sr", "str", "ob", "bp", " Br", "ibr", "ber", "HR", "arr", "div", "hr", "rib", "bsp", "obi", "bro", "err", "bl", "Br", "r", "b", "kr", "browser", "bar", "body", "tr", " dr", "fr", "lr", "ibl", "rb", " fr", " BR", "BR", "ch", "bh", "gr", "cro", "sp", "ctr", "rs", "shr", "ocr"], "zit": ["zenits", "zenitter", " zits", "zipit", "zipitter", "zenit", "zip", "zenith", "xi", "jita", " zip", "zipita", "jit", "zipith", "zeit", "jits", " zite", "zith", "jith", "zita", "zeits", "zIT", "zeIT", "zeith", "zipIT", "zitter", "jite", "zi", "xith", "xic", " zic", " zith", "zeitter", "zite", "jip", "zipits", "zipite", "jic", "zipip", "ji", "zits", "xit", "zic", "jIT", "zeita", " zi"]}}
{"id1": "6190356", "id2": "20310134", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForOldmd512", " hashPasswordForOldmd4", " hashPasswordForNewM4", " hashPasswordForOldmd3", " hashPasswordForOldMC512", " hashPasswordForOldMC5", " hashPasswordForOldMD512", " hashPasswordForNewMD4", " hashPasswordForOldM4", " hashPasswordForOldM5", " hashPasswordForNewMD512", " hashPasswordForOldMD4", " hashPasswordForOldMD3", " hashPasswordForOldM512", " hashPasswordForNewMD5", " hashPasswordForNewMD3", " hashPasswordForOldmd5", " hashPasswordForNewM512", " hashPasswordForNewM5", " hashPasswordForOldMC3", " hashPasswordForOldMC4", " hashPasswordForNewM3", " hashPasswordForOldM3"], "password": ["account", "pad", "buffer", "words", "p", "crypt", "key", "pattern", "input", "sword", "phrase", "address", "result", "padding", "Password", "code", "content", "array", "path", "message", "word", "value", "wd", "pass", "wallet", "data", "token", "secret", "text", " passwords", "name", "auth", "string", "seed", " Password", "encrypted", "hash", "PASS", "username"], "md": ["km", "mm", "mac", "mo", "clean", "ind", "m", "Cmd", "dig", "grad", "pg", "managed", "pd", "metadata", "um", "cd", "ma", "od", "dc", "rm", "amd", "mb", "nm", "df", "wd", "gd", "mand", "bd", "f", "dm", "pm", "mt", "MD", "di", "mp", "mc", "hd", "mag", "mod", "d", "rpm", "vd", "am", "meta", "cmd", "dd", " MD", "vm", "hm"], "messageDigest": ["messageDester", " messageDigEST", "messageAddse", "messageDEST", "messageDest", "messagedigester", " messageModester", "messageDigester", "messageDse", "messagedigEST", " messageDigester", "MessageDigEST", "MessageModse", "MessageModEST", "messageAddester", "MessageDigest", "messageDigEST", " messageModEST", "MessageAddester", "messageModests", "MessageModester", "messageAddEST", "MessageAddse", "messagedigse", "MessageDigse", "messageAddest", "MessageModest", "messageDigests", " messageModests", "messageAddests", "messageDigse", "messagedigests", " messageDigests", " messageModest", "messageModse", "messageModEST", "messagedigest", "MessageAddEST", "MessageAddest", "messageModest", "MessageDigester", "messageModester"], "hexString": ["tempFile", " hexArray", "stringService", "octArray", "transformStr", "hashSection", " hexStr", "sumStr", "octStr", "tempFunction", "hexstring", "crossstring", "tempStr", "hexArray", " hexSection", " hexService", " hexFile", "hexFunction", "stringArray", "transformString", "hexSection", "crossStr", "hexFile", " hexFunction", "stringString", "sumString", "hashService", "transformArray", "hashString", "transformBuffer", " hexBuffer", "sumstring", "crossString", "hashArray", "hexBuffer", "stringSection", "hexStr", " hexstring", "sumFile", "hexService", "octBuffer", "tempString", "crossFunction", "tempstring", "octString"], "i": ["r", "ai", "ip", "m", "h", "p", "j", "n", "s", "multi", "fi", "ix", "slice", "e", "phi", "id", "ci", "t", "ui", "info", "length", "a", "index", "li", "ii", "io", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "u", "b", "v", "ji", "oi", "di", "l", "d", "si", "qi", "uri", "I", "c"], "hex": ["ip", "h", "batch", "hello", "alpha", "bit", "full", "host", "form", "pattern", "default", "character", "serial", "nexus", "ex", "sex", "cache", "json", "cookie", "hack", "result", "format", "http", "exp", "path", "zero", "orig", "rh", "buff", "pack", "digit", "raw", "lit", "str", "pex", "oct", "letter", "binary", "none", "null", "data", "temp", "rex", "char", "comp", "transform", "text", "he", "pixel", "string", "utf", "hash", " Hex", "cmp", "shift", "length"]}}
{"id1": "1508161", "id2": "3767903", "code1": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"conMail": [" sendContact", " submitEmail", " sendEmail", " parseEmail", " parseContent", " sendMail", " submitContact", " parseMail", " uploadContact", " sendContent", " uploadContent", " uploadMail", " submitContent", " parseContact", " submitMail", " uploadEmail"], "mail": ["item", "il", "local", "Mail", " email", "class", "ml", "Email", "multi", "zip", "mand", "m", "request", "call", "xml", "view", "proxy", "service", "log", "open", "match", "key", "post", "email", "content", "object", "letter", "user", "build", "l", "base", "order", "del", "element", "ship", "model", "mass", "server", "load", "mill", "event", "f", "mo", "e", "pkg", "link", "el", "gmail", "html", "ssl", "test", "follow", "data", "mails", "md", "id", "message", "update", "sel", "body", "name", "file"], "client": ["resource", "project", "cache", "host", "request", "method", "http", "call", "service", "self", "con", "api", "contact", "force", "this", "driver", "ce", "conn", "object", "handler", "bird", "app", "connection", "base", "l", "server", "config", "cli", "session", "i", "socket", "ssl", "plugin", "web", "uri", "Client", "et"], "url": ["resource", "route", "string", "channel", "href", "host", "request", "method", "http", "service", "www", "URL", "path", "ur", "feed", "key", "Url", "email", "download", "address", "up", "l", "connection", "base", "server", "config", "sl", "f", "e", "ssl", "data", "id", "web", "uri", "name", "file"], "get": ["resource", "pull", "send", "g", "GET", "call", "invoke", "service", "gets", "api", "open", "post", "json", "Get", "build", "connection", "show", "exec", "find", "load", "query", "server", "read", "like", "cli", "session", "set", "start", "check", "next", "parse", "req", "put", "info", "uri", "update", "body", "create", "end"], "response": ["Response", "resource", "application", "status", "full", "respond", "environment", "reply", "request", "api", "wave", "feed", "onse", "Entity", "json", "object", "re", "resp", "document", "connection", "event", "server", "e", "success", "received", "res", "remote", "result", "page", "output", "error", "data", "message", "body", "collection"], "entity": ["resource", "entry", "application", "instance", "em", "environment", "xml", "comment", "ee", "node", "api", "Entity", "json", "email", "ce", "content", "object", "unit", "om", "document", "connection", "collection", "agent", "element", "pe", "model", "ity", "event", "coll", "server", "article", "e", "el", "image", "page", "result", "output", "error", "data", "ent", "esi", "message", "body", "et", "file", "person"], "doc": ["dc", "resource", "struct", "pc", "line", "map", "m", "Doc", "exp", "xml", "d", "desc", "Document", "content", "div", "dir", "unit", "oc", "dict", "valid", "up", "document", "pos", "coll", "dr", "f", "lib", "html", "page", "data", "docs", "md", "po", "message", "DOC", "uri", "text", "body", "db", "file", "dec"], "msg": ["ug", "ms", "g", "map", "m", "op", "urg", "xml", "title", "str", "comment", "ge", "log", "desc", "char", "mess", "agg", " ms", "content", "loc", "err", "ag", "db", "cmd", "reg", "dr", "pkg", "code", "Msg", "html", " desc", "error", "data", "type", "gen", "md", "req", "comm", "id", "message", "info", "text", "mid", "reason"]}}
{"id1": "18202328", "id2": "19322910", "code1": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "code2": "    @Test\n    public void test_blueprintTypeByTypeID() throws Exception {\n        URL url = new URL(baseUrl + \"/blueprintTypeByTypeID/20188\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"{\\\"blueprintTypeID\\\":20188,\\\"blueprintTypeName\\\":\\\"Obelisk Blueprint\\\",\\\"productTypeID\\\":20187,\\\"productTypeName\\\":\\\"Obelisk\\\",\\\"productCategoryID\\\":6,\\\"techLevel\\\":1,\\\"productionTime\\\":1280000,\\\"researchProductivityTime\\\":7680000,\\\"researchMaterialTime\\\":5120000,\\\"researchCopyTime\\\":2560000,\\\"researchTechTime\\\":500000,\\\"productivityModifier\\\":256000,\\\"wasteFactor\\\":10,\\\"maxProductionLimit\\\":1,\\\"productVolume\\\":\\\"17550000\\\",\\\"productPortionSize\\\":1,\\\"dumpVersion\\\":\\\"cru16\\\"}\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n        connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/xml\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?><invBlueprintTypeDto><blueprintTypeID>20188</blueprintTypeID><blueprintTypeName>Obelisk Blueprint</blueprintTypeName><dumpVersion>cru16</dumpVersion><maxProductionLimit>1</maxProductionLimit><productCategoryID>6</productCategoryID><productPortionSize>1</productPortionSize><productTypeID>20187</productTypeID><productTypeName>Obelisk</productTypeName><productVolume>17550000</productVolume><productionTime>1280000</productionTime><productivityModifier>256000</productivityModifier><researchCopyTime>2560000</researchCopyTime><researchMaterialTime>5120000</researchMaterialTime><researchProductivityTime>7680000</researchProductivityTime><researchTechTime>500000</researchTechTime><techLevel>1</techLevel><wasteFactor>10</wasteFactor></invBlueprintTypeDto>\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/xml; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"register": ["play", " reg", "setup", "user", "master", " regenerate", "activate", "Register", "save", "password", "load", "login", "Login", "bind", "config", "check", "init", "start", "chain", " registration", " unlock", "app", "update", "create", "auth", "reg", "connect", " Register"], "session": ["play", "event", "remote", "ssl", "ession", "temp", "input", "server", "resource", "video", "game", "user", "lock", "master", "site", "message", "version", "slave", "socket", "python", "window", "child", "shell", "host", "driver", "global", "thread", "manager", "database", "room", "security", "password", "client", "sync", "sa", "cache", "sb", "use", "proxy", "login", "connection", "browser", "facebook", "machine", "group", "section", "config", "parent", "channel", "h", "request", "device", "conn", "Session", "ess", "image", "port", "person", "mc", "position", "connect", "cookie", "state", "gui", "script", " Session", "service", "caster", "view"], "username": ["string", "path", "address", "NAME", "duration", "uri", "token", "user", "subject", "message", "filename", "profile", "character", "uid", "mother", "account", "driver", "host", "ame", "length", "database", "password", "Password", "monitor", "email", "minecraft", "source", "users", "seed", "login", " nickname", "sword", "text", "phone", "verb", "hello", "title", "name", "Name", "amer", "nick", "ername", "word", "voice", "prefix", "mobile", "person", "url", "steam", "property", "localhost", "auth", "secret", " password", "attribute", "crypt", "phrase", "term"], "verificationKey": ["verifyPoint", "vermentSecret", "verationSecret", "verificationSecret", "vermentKEY", "validifyingKey", "significationSecret", "verifySecret", "significationkey", "verationPoint", "verificationPoint", "verifykey", "verifyingkey", "signationKey", "validifyingPoint", "verationkey", "validificationKey", "verifyingKEY", "signationKEY", "significationKey", "validifyingkey", "vermentKey", "verifyingSecret", "verationKey", "vermentkey", "signationkey", "verificationkey", "verationKEY", "signationSecret", "validificationPoint", "verifyingPoint", "verifyingKey", "verificationKEY", "significationKEY", "validifyingSecret", "verifyKey", "validificationkey", "validificationSecret"], "salt": [" sodium", " sort", "Shash", "seSalt", "setsodium", "sSalt", "suffSalt", "sort", "Salt", "SSalt", "suffalt", "sALT", "SALT", "sodium", " sALT", "sehash", "setsalt", "seALT", "suffhash", "shash", "setsort", "suffALT", "setsALT", "sealt"], "hash": ["string", "square", "address", "total", "sum", "her", "input", "buffer", "output", "user", "message", "version", "kh", "result", "hex", "Hash", "html", "match", "pool", "host", "number", "memory", "query", "ash", "key", "password", "mac", "cache", "sha", "build", "text", "h", "log", "name", "header", "hed", "array", "url", "auth", "secret", "crypt"], "digest": ["defester", "Digester", " diggest", "DigEST", "signEST", "logit", "signest", "bigest", " digested", "biggest", "bigested", "digit", "signests", "hedested", "logester", " dige", "signested", "Digests", "diggest", "Diggest", " digger", "digester", "Dige", "digests", "digested", "Digit", "digger", "Digest", "defest", "logger", " digEST", "bigester", " digester", "Digger", "hedEST", " digests", "Digested", " digit", "defe", "dige", "defEST", "logest", "hedester", "digEST", "hedest"], "nameChars": ["nameCheARS", "namechacters", "nameChases", "nameCheats", "nameCharars", "nameChats", "nameChARS", "namechars", "nameCheases", " nameChararts", "nameChears", " nameChacters", " nameCharts", "nameGrars", " nameChARS", " nameCharars", "namechats", " nameChases", "namecharts", " nameChats", " nameCharacters", "nameGracters", " nameCharARS", "nameChacters", "namechARS", "nameCharARS", "nameChararts", "namechases", "nameGrARS", "nameGrarts", "nameCharts", "nameCharacters"], "nameChar": ["NameCh", "nameCharacter", "idChar", "Namechar", "addressCh", "nameCh", "NameChar", " NameText", " NameCharacter", "nameDir", "resourceCharacter", "idText", " nameDir", "addressCtrl", "addressChar", "nameCtrl", " nameCtrl", " nameText", "idCharacter", " nameCharacter", "idCh", "addressCharacter", " namechar", "nameText", " nameCh", " NameCh", "namechar", "NameCharacter", "NameCtrl", "resourceDir", "resourcechar", "resourceChar", " NameChar", "NameDir"], "p": ["P", "i", "n", "op", "pre", "lp", "per", "py", "j", "fp", "o", "l", "s", "er", "client", "cop", "part", "ap", "at", "d", "pp", "q", "up", "cp", "r", "g", "h", "np", "u", "po", "e", "m", "t", " P", "jp", "pc", "a", "pa", "pe", "pair", "b", "sp", "br", "v", "ps", "f", "api", "point"], "player": ["play", "class", "ace", "server", "video", "n", "game", "user", "gamer", "master", "slave", "per", "board", "l", "driver", "pool", "match", "players", "manager", "owner", " Player", "ler", "er", "client", "part", "member", "live", "aster", "connection", "leader", "media", "pm", "machine", "g", "parent", "data", "pro", "league", "party", "Player", "name", "e", "m", "playing", "controller", "worker", "person", "team", "layer", "position", "steam", "pe", "can", "played", "script", "conference", "caster", "winner"], "c": ["cu", "tc", "cc", "sc", "n", "cf", "rc", "enc", "con", "fc", "cb", "o", "l", "dc", "nc", "ec", "cm", "cp", "cache", "lc", "d", "ce", "ct", "r", "config", "ca", "cl", "h", "C", "arc", "ci", "m", "t", "cr", "chain", "pc", "mc", "ctx", "bc", "abc", "k", "conf", "v", "ac", "cs", "f"]}}
{"id1": "3745402", "id2": "11032546", "code1": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 0, "substitutes": {"createCipher": ["createScrypt", " createCrypt", " createScursor", "createIntegipher", "createcrypt", "createcipher", " createCursor", "createcSecret", "createIntegSecret", "createScipher", "createScursor", " createCSecret", "createIntegursor", " createScipher", " createScrypt", "createCursor", "createCSecret", " createScSecret", "createIntegrypt", "createScSecret", "createCrypt", "createcursor"], "passwd": ["Passphrase", " passpassword", "passpassword", "failword", "passwordword", " password", "failwd", "passwordpassword", "PassWD", "Password", "passphrase", "Passwd", "password", "passwordphrase", " passWD", "failWD", " passphrase", "passWD", "passwordwd", "failpassword", "Passpassword"], "mode": ["Mode", "name", "manager", "version", "depth", "type", "slice", "seed", "language", "method", "command", "phase", "range", "direction", "time", "domain", "mac", "mask", "cmd", "password", "address", "source", "driver", "phrase", "path", "mod", "role", "MODE", "level", "code", "server", "core", "mm", "delay", "module", "prefix", "message", "dir", "slave"], "keySpec": ["secretSet", "keySet", "signConfig", "KeySet", "secretFactory", "KeySpec", "KeyFactory", "keyConfig", "secretSpec", "signSpec", "secretCS", " keyspec", "keyspec", " keySet", "KeyConfig", "Keyspec", " keyCS", "signspec", "KeyCS", " keyConfig", "keyCS"], "keyFactory": ["KeyService", " keyService", "kService", "secretFactory", " keyFamily", "KeySpec", "KeyFactory", "kFamily", "secretSpec", "keyFamily", "kFactory", "keyService", "kSpec", "secretService", "KeyFamily"], "key": ["data", "name", "type", "seed", "sk", "p", "pair", "state", "k", "enc", "pub", "base", "ssl", "KEY", "cache", "text", "user", "mac", "password", "temp", "secret", "ke", "source", " secret", "phrase", "ki", "hash", "sum", "config", "sign", "code", "pass", "core", "pe", "keys", "c", "file", "cert", "id", "ce", "message", "Key"], "md": ["msg", "meta", "df", "bd", "vd", "f", "mag", "cd", "dd", "m", "ma", " MD", "mt", "dig", "mb", "mac", "cmd", "dm", "dr", "material", "dc", "d", "sm", "MD", "db", "amd", "mp", "metadata", "mm", "pm", "dh", "message", "sha", "cm", "mc", "mand", "ad", "hd"], "digest": ["mdest", "demested", "digeter", " digeter", "DigEST", "Digester", "Digend", "digested", "demeter", "digester", "demest", "digEST", "mdested", "mdEST", "mdester", "demester", " digend", "signester", " digEST", "Digested", "digend", "signested", "mdend", "signest", "signeter", " digested", " digester", "Digest"], "salt": ["isodium", "Salt", "ssalt", "psort", "isalt", "sesalt", "dsodium", "secretalt", "secretsecret", "Sodium", "ssALT", "secretALT", "sort", "dsALT", "ssipher", "sesodium", "dsort", "sSalt", "sesALT", "sssecret", "sodium", "psalt", "isALT", "secretipher", "Sipher", " sALT", "SSalt", "Ssecret", "sipher", "dsalt", "sesSalt", "SALT", "isSalt", "psALT", " sort", "ssecret", "sALT", "psodium", " sodium"], "i": ["x", "f", "y", "si", "it", "ti", "ri", "at", "s", "m", "p", "j", "info", "pi", "k", "ind", "ix", "hi", "I", "di", "u", "b", "bi", "qi", "l", "e", "o", "uli", "d", "ci", "init", "z", "t", "xi", "v", "oi", "ui", "n", "li", "uri", "ii", "c", "in", "id", "index", "mu", "ai", "gi", "ip"], "paramSpec": ["aramSel", "paramSpe", "parspec", "parConfig", "aramSpe", "ParamConfig", "paramsConfig", "ParamSpec", " parameterSpe", " parameterConfig", "paramspec", "parSpec", "ParamCS", "paramsSpec", "paramSel", "Paramspec", "parCS", " parameterSpec", " parameterSel", "paramConfig", " paramSpe", "aramConfig", " paramConfig", "aramSpec", "paramsspec", "paramsCS", "paramCS", " paramSel"], "cipher": [" cursor", "conuster", "custer", "Cairo", "encoder", "Coder", "conrypt", "encairo", "pairo", "encipher", "encrypt", "Crypt", "coder", " cairo", "Cursor", "crypt", "coipher", "cursor", " coder", "Cistor", "corypt", "Cipher", "couster", "pistor", "coursor", "prypt", "conipher", "encistor", "encuster", "cistor", "pipher", "cairo", "conursor", "encursor"]}}
{"id1": "19810820", "id2": "8182932", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"copyFileChannel": ["copyDirectorychannel", "transferFilechannel", "copyStreamStream", "copyDirectoryChannel", "transferFileChannel", "copyfileChan", "transferfilechannel", "transferfileChan", "copyDirectoryStream", "copyFileChan", "copyStreamChannel", "copyStreamChan", "transferfileStream", "copyDirectoryChan", "copyfileChannel", "transferfileChannel", "copyfilechannel", "copyFilechannel", "copyfileStream", "transferFileChan", "copyFileStream", "copyStreamchannel", "transferFileStream"], "src": ["ls", "sth", "url", "ssl", "server", "dest", "b", "st", "loc", "rc", "rs", "sys", "sync", "func", "sb", "inst", "Source", "input", "rb", "cur", "s", "conn", "sq", "download", "rest", "sin", "source", "config", "client", "filename", "ruby", "sub", "stream", "tmp", "slice", "ses", "sc", "sit", "lower", "dist", "sup", "upload", "RC", "start", "sl", "sel", "ctx", "SOURCE", "path", "scene", "img"], "dst": ["lddest", "fdput", "ddest", "Ddest", "adput", "fdrc", "bST", "ldST", "drc", "tST", "ldost", "tart", "Dost", "dST", "stST", "tlt", "dart", "dost", "stst", "DST", "blt", "adST", "bput", " dost", "fdst", "Dst", "tst", "fdST", "adst", "adrc", "bart", "stlt", "dput", "ldst", " dST", "dlt", "start", "brc", "bst", " ddest"], "preserveModificationTime": ["preserveMinificationTime", "preserveModificationFile", "preserveModifiedtime", "preserveModifyTime", "preserveModationtime", "preserveModifyingFile", "preserveModifytime", "preserveModifiedTime", "preserveModationTime", "preserveMinifiedtime", "preserveMinificationFile", "preserveModifiedFile", "preserveModifyingtime", "preserveMinifiedFile", "preserveMinifiedTime", "preserveModifyingTime", "preserveMinificationtime", "preserveModationFile", "preserveModificationtime"], "inputChannel": ["binarychannel", "inputChan", "outputStream", " inputCode", "requestCode", "binaryGate", "inputGate", "imageGate", "inputCache", "outputCache", "inputQueue", "imagechannel", "requestChan", " inputchannel", "errorCache", "errorChan", "outputConsole", "inputchannel", "Inputchannel", "outputCode", " inputConsole", "InputSocket", " inputChan", "outputSocket", "errorStream", "binaryChannel", "imageChannel", "inputConnection", "InputQueue", "inputStream", "fileConsole", "requestChannel", "inputConsole", "outputConnection", "outputQueue", "fileChan", "binaryChan", " inputStream", "errorChannel", "inputCode", "outputChan", "fileChannel", " inputCache", " inputConnection", " inputSocket", " inputBuffer", "outputBuffer", "InputChan", " inputQueue", "InputBuffer", "inputBuffer", "fileConnection", "requestStream", "outputGate", "InputChannel", "inputSocket", "imageChan", "outputchannel"], "outputChannel": ["outchannel", "outputStream", "inputChan", "writeChannel", " outputChan", "writeStream", "Outputchannel", " outputManager", " outputQueue", "OutputQueue", "outStream", "outputManager", "inputStream", "outputQueue", "writeQueue", "outputChan", "outButton", "OutputChannel", "OutputStream", "outChan", " outputchannel", "OutputChan", "outChannel", "writeManager", "inputButton", " outputStream", "inputManager", "outputButton", " outputButton", "writeChan", "outputchannel"], "length": ["available", "partial", "text", "delay", "count", "style", "build", "volume", "offset", "form", "lock", "complete", "child", "session", "duration", "last", "part", "sequence", "limit", "result", "block", "sum", "end", "type", "pull", "max", "section", "size", "with", "width", "l", "len", "Length", "slave", "base", "number", "position", "id", "load", "start", "full", "next", "php", "current", "value", "buffer", "head", "join"], "total": ["available", "partial", "count", "complete", "offset", "failed", "info", "scale", "duration", "last", "part", "no", "limit", "all", "result", "set", "sum", "valid", "translation", "done", "error", "key", "type", "cur", "i", "Total", "multi", "max", "size", "len", "toc", "base", "found", "id", "less", "start", "otal", "full", "used", "current", "always"]}}
{"id1": "2017833", "id2": "13981689", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["string", "Hash", "str", "sha", "sum", "transform", "hex", "number", "add", "build", "print", "base", "replace", "get", "ash", "dump", "set", "format", "check", "h", "html", "parse", "message", "update", "crypt", "block", "create"], "text": ["struct", "txt", "font", "class", "token", "Text", "string", "context", "word", "secret", "str", "version", "input", "EXT", "path", "key", "hex", " Text", "number", "length", "content", "object", "letter", "translation", " TEXT", "out", "contract", "url", "code", "value", "password", "image", "format", "bytes", "TEXT", "editor", "ext", "test", "output", "data", "message", "pattern", "source", "buffer", "binary", "name", "template"], "UnsupportedEncodingException": ["UnsupportedencodedException", "UnsupportedencodedWarning", "UnsupportedEncodedException", "UnsupportedEncgorithmWarning", "Unsupportedencodingception", "UnsupportedencodingWarning", "UnsupportedEncodedception", "Unsupportedencodedception", "UnsupportedencodingException", "UnsupportedEncasingception", "UnsupportedEncodingception", "UnsupportedEncgorithmception", "UnsupportedEncasingException", "UnsupportedEncodedWarning", "UnsupportedEncodingWarning", "UnsupportedEncasingWarning", "UnsupportedEncgorithmException"], "md": ["mb", "mp", "mg", "ms", "pm", "od", "mand", "rm", "mac", "m", "um", " MD", "d", "sha", "hm", "MD", "bd", "meta", "wd", "hd", "ad", "dd", "ld", "mc", "mod", "cmd", "ma", "mag", "f", "am", "ds", "gd", "ind", "dm", "nm", "amd", "dig", "mm", "metadata", "bf", "vd", "message", "mad", "mt", "bm", "mo"], "sha1hash": ["sha2h", "sha3sum", "ha1hex", "SHA1hash", "ha1hash", "sha4Hash", "shaonehex", "sha1match", "SHA2Hash", "sha1hex", "SHA1sum", "sha3match", "ha2sum", "shaonesum", "ha2hash", "sha2sum", "sha5sum", "sha5hex", "shaonehash", "ha2hex", "sha4sum", "sha4hex", "sha5hash", "sha1Hash", "sha3hash", "sha5h", "sha256sum", "shaonematch", "sha2hex", "sha1sum", "SHA1hex", "ha1match", "SHA2h", "sha256hash", "SHA1Hash", "sha5Hash", "sha2match", "sha2Hash", "sha4hash", "SHA2sum", "sha256Hash", "sha3hex", "sha2hash", "ha2match", "ha1sum", "SHA2hash", "sha256h", "SHA1h", "sha1h"]}}
{"id1": "17199913", "id2": "20924119", "code1": "    protected static InputStream loadResource(String resource) throws MissingResourceException {\n        Thread thread = Thread.currentThread();\n        ClassLoader cLoader = thread.getContextClassLoader();\n        URL url = cLoader.getResource(resource);\n        if (url == null) {\n            throw new MissingResourceException(\"Unable to find resource '\" + resource + \"'.\", resource, resource);\n        }\n        try {\n            InputStream is = url.openStream();\n            return is;\n        } catch (IOException e) {\n            throw new MissingResourceException(\"Unable to load resource '\" + resource + \"' (IOException).\", resource, resource);\n        }\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 0, "substitutes": {"loadResource": ["findResource", " loadUrl", "findUrl", "findURL", "loadURL", "loadFile", "downloadResource", "downloadUrl", " loadURL", "loadUrl", " loadFile", "findFile", "downloadURL", "downloadFile"], "resource": ["base", "class", "loader", "http", "document", "match", "content", "rule", "serial", "component", "model", "region", "file", "archive", "context", "style", "reference", "module", "sr", "ource", "element", "string", "address", "buffer", "library", "query", "source", "use", "connection", "r", "parent", "channel", "route", "OURCE", "texture", "name", "resolution", "attribute", "service", "path", "remote", "rest", "core", "uri", "resources", "message", "record", "reader", "scope", "collection", "src", "request", "image", "Resource", "error", "method", "single", "view", "relative", "res", "filename", "project", "client", "expression", "type", "date", "media", "feature", "data", "text", "ruby", "href", "pointer", "role", "stream", "parse", "right", "range", "re"], "thread": ["path", "class", "loader", "tc", "job", "Thread", "http", "system", "project", "run", "host", "pool", "task", "util", "func", "loop", "reader", "connection", "module", "component", "build", "config", "parent", "object", "context", "or", "t", "worker", "kernel", "ctx", "layer", "app", "tt", "stream", "th", "stack", "runtime", "process", "method", "this", "boot", " Thread"], "cLoader": ["cUrl", "lCl", "CCl", "cConfig", "CConfig", "lLoad", "cDir", " cConfig", "cLoad", "lConfig", "cCl", "cPath", "CLoader", "lPath", "CLoad", "lDir", "lLoader", "CUrl", "CPath", " cDir", "CDir", "lUrl", " cPath", " cUrl", " cLoad", " cCl"], "url": ["impl", "path", "string", "base", "ssl", "loader", "job", "server", "uri", "feed", "id", "rc", "http", "ref", "rel", "lr", "l", "html", "location", "URL", "il", "el", "host", "source", "jar", "browser", "ob", "file", "src", "bel", "ll", "object", "bb", "conn", "ls", "coll", "e", "image", "io", "sl", "rl", "Url", "www", "stream", "ur", "xml", "download", "f", "gl", "element", "service", "api", "loc"], "is": ["bis", "lis", "css", "iss", "uri", "fs", "IS", "Is", "as", "ri", "bs", "il", "abs", "ui", "inst", "ii", "ms", "its", "ws", "ais", "ir", "web", "ip", "vs", "ris", "js", "ists", "ics", "it", "ils", "ios", "us", "isi", "os", "ps", "was", "ar", "iv", "im", "api", "mis"]}}
{"id1": "23118425", "id2": "18613870", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"encrypt": [" Encipher", "enrypted", " Encrypted", " Encrypt", "Encrypt", "enipher", "enrypt", "enccrypt", "encipher", "encrypted", "Enccrypt", "Encipher", "Encrypted", " Enccrypt"], "plaintext": ["broadtext", "flatdata", "plaindata", "plainstruct", "protectedText", "plainText", " plainText", "flattext", "broadText", "flatText", "broadsource", " plaindata", "flatstring", " plainsource", "protecteddata", "plainstring", "flatsource", "flatstruct", " plainstring", " plainstruct", "protectedtext", "broadstring", "plainsource", "protectedstruct"], "md": ["mad", "m", "mb", "hd", " MD", "Cmd", "message", "mp", "sha", "cmd", "pg", "material", "data", "mo", "ph", "dig", "dd", "mc", "mag", "d", "vd", "od", "meta", "nm", "hm", "wd", "code", "amd", "mg", "dm", "bd", "pkg", "metadata", "pd", "MD", "db", "ad", "mac", "mand", "ms", "mm", "ma", "mem", "dc", "am", "ld", "pm", "kg", "mt", "cd", "mu", "mod", "dh"], "raw": ["buf", "partial", "original", "shared", "array", "pack", "message", "image", "null", "empty", "RAW", "dec", "channel", "wrap", "input", "hex", "feed", "row", "ng", "instance", "ack", "rew", " RAW", "stream", " hex", "local", "load", "initial", "Raw", "def", "binary", "full", "clean", "response", "unknown", "unsigned", "content", "buffer", "serial", "enc", "custom", "block"], "hash": ["secret", "crypt", "text", "ash", "array", "auth", "log", "url", "message", "image", "html", "build", "sha", "rh", "empty", "data", "version", "her", "hex", "sum", "password", "h", "key", "row", "code", "kh", "header", "base", "mac", "id", "cache", "string", "full", "Hash", "response", "value", "buffer", "block"]}}
{"id1": "14303294", "id2": "11933797", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"getServerHash": ["getSessionAddress", "getSessionSHA", " getSecureAddress", "getserverAddress", " getServerSalt", " getSecureSalt", "getSessionSalt", "getSecureSalt", "getserverSHA", "getServerSalt", " getServerSHA", "getSecureAddress", " getServerAddress", "getserverHash", "getserverSalt", "getSessionHash", "getSecureHash", " getSecureSHA", " getSecureHash", "getSecureSHA", "getServerAddress", "getServerSHA"], "passwordHash": ["privatehash", " PasswordCode", "privatePassword", "privateHash", "Passwordhash", "passwordPassword", " passwordhash", "passwordCode", "PasswordCode", "privateSalt", " PasswordHash", "passwordPass", "PasswordPass", "passwordhash", " passwordPassword", " passwordCode", "passwordSalt", " passwordPass", " PasswordPass", "PasswordPassword", "PasswordHash", " passwordSalt"], "PasswordSalt": [" PasswordPassword", " Password256", " PasswordSecret", "passwordPassword", " PasswordHash", "passwordSecret", "PASSSalt", " passwordSecret", "Password256", "password256", " passwordPassword", "PASSPassword", "passwordSalt", "PasswordSecret", "PasswordPassword", "PASS256", "PasswordHash", "PASSHash", " passwordSalt"], "hash": ["data", "ha", "pool", "error", "array", "change", "hex", "base", "log", "dig", "copy", "html", "cache", "check", "user", "size", "content", "her", "kh", "mac", "work", "password", "key", "address", "crypt", "row", "buffer", "build", "image", "block", "value", "response", "h", "url", "update", "sum", "number", "code", "search", "message", "sha", "result", "ash", "auth", "Hash", "string", "sh"], "digest": ["mdest", "generest", " diger", "digener", "Digester", "Digusher", "generester", "hashester", "digested", " digusher", "integester", "integested", "digester", "hashener", "mdested", "Digener", "integall", "mdester", "hasher", " digger", "digger", "signester", "digher", "digall", "Digested", " digall", "integest", "diger", "Digger", "digusher", "signer", "signher", "Diger", "signest", "signger", "Digher", "hashest", "generested", "generall", " digener", " digested", " digester", "Digest", "mdusher", " digher"]}}
{"id1": "9857412", "id2": "18696387", "code1": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 0, "substitutes": {"writeData": ["writeDATA", " writePart", "outputPart", " writeBytes", "sendData", "outputBytes", "outputDATA", "writePart", " writeDATA", "writeBytes", "sendBytes", "sendPart", "outputData", "sendDATA"], "data": ["DATA", "buf", "sample", "text", "array", "resource", "image", "body", "connection", "sequence", "result", "input", "dat", "batch", "bytes", "timeout", "source", "memory", "reader", "multi", "config", "media", "resources", "queue", "video", "cache", "address", "load", "binary", "json", "response", "content", "value", "database"], "options": ["Options", "values", "keys", "resource", "details", "style", "scope", "io", "info", "parts", "times", "headers", "groups", "bytes", "meta", "settings", "results", "config", "properties", "vals", "opt", "files", "resources", "table", "object", "bits", "cache", "address", "obj", "params", "option", "ops", "ts", "json", "flags"], "transferMetaData": [" transferMetLeft", "transfermetaLast", "transferDataData", " transferMetaLeft", " transferMetaBreak", "ferMetaData", "transferDataScript", "ferMetaName", "sendMetaData", "sendMetaBreak", "sendMetaDATA", "transferMediaDATA", "transferMetaName", "transferMetaHash", "transfermetaBreak", "transferMetLast", "transferMediaData", "ferDataHash", "transferDataName", "transfermetaLeft", "transferMetaDATA", "transferMediaBreak", "transfermetaData", " transferMetaLast", "transferMetLeft", "ferDataScript", "transferMetaLeft", "transfermetaName", "transfermetaScript", "transfermetaDATA", "transferMetaBreak", "sendMetaScript", " transferMetLast", "ferDataData", "transferMetBreak", "transferMetData", " transferMetBreak", "transferMediaScript", "ferDataName", "transferMetaLast", "transferMetaScript", " transferMetData", "ferMetaHash", "transfermetaHash", "transferDataHash", "ferMetaScript"], "startTime": [" startTim", "initStream", "startLine", "initTim", " startLine", "StartPoint", "startedTime", "StartTim", "startPoint", " startPoint", "startStream", "initLine", "StartLine", "startTim", " startStream", "initTime", "StartTime", "startedLine", "startedPoint", "StartStream"], "transferredBytesNum": ["transferredbytesBu", "transferredByteChan", "translatedbytesNum", "transferredBytesMon", "translatedPagesLen", "translatedPagesMon", "transferredFilesBu", "transferredFramesMon", "transferredTokensNum", "transendedByteChan", "translatedBytesSum", "transferredBytesChan", "transferredFramesSum", "transferredbytesSum", "transferredPagesBu", "transendedBytesSum", "transferredTokensMon", "translatedbytesVal", "transferredFilesLen", "transferredFramesNum", "translatedPagesBu", "transferredFilesMon", "transendedBytesMon", "transendedBytesChan", "translatedBytesNum", "transferredPagesMon", "transendedByteNum", "transferredbytesVal", "transferredBytesSum", "translatedPagesNum", "transferredbytesLen", "transferredByteSum", "translatedBytesBu", "translatedBytesVal", "transendedByteMon", "transferredFramesChan", "transferredFilesNum", "translatedBytesMon", "transferredBytesBu", "transferredPagesNum", "translatedbytesSum", "transferredTokensChan", "translatedBytesLen", "transendedByteSum", "transferredByteMon", "transferredTokensSum", "transferredBytesLen", "transferredByteNum", "transferredByteVal", "transferredSharesSum", "transendedBytesNum", "transferredbytesNum", "transferredPagesLen", "transferredSharesVal", "transferredBytesVal", "transferredbytesMon", "transferredSharesNum"], "elapsedTime": ["elocatedTimes", "elayedtime", "elivedDuration", "ElapseValue", "elayedDuration", "elapseForce", " elavedForce", " elavedValue", "elroredForce", "elapseTimes", "elapsedForce", "elayedTime", "ElapseTimes", "elavedTime", "elivedtime", "elivedTime", "ElapseDuration", "Elapsetime", "ElapsedTimes", "Elapsedtime", "elapsetime", "ElapsedTime", "elroredValue", " elavedTime", "elapsedtime", "ElapsedDuration", "elavedForce", "elapseValue", " elapsedValue", "elocatedTime", "elapsedTimes", "elapsedDuration", "elocatedValue", "elapseTime", "ElapseTime", "elroredTime", " elapsedForce", "elapseDuration", "elavedValue", "ElapsedValue", "elapsedValue", "elroredTimes"], "opts": ["OPtt", " opments", " optt", "preters", "copts", "optts", "ottr", "OPfs", "optments", "OPps", "opfs", "optTS", "optrs", "opty", "OPters", " optte", "obter", "optps", "prets", "OPty", "optty", "OPter", "opttt", "opters", " oprs", "optr", "coprs", "otTS", "opter", " optts", "prete", " optters", "otter", "oprs", " opps", "opments", "opps", "otts", "OPts", "obTS", "copTS", "OPTS", "obtr", "copments", " optfs", "OPtr", " opty", "optte", "obts", "optt", "prefs", "OPte", "opTS", " opTS", "opte", " opte"], "server": ["prefix", "peer", "uri", "ssl", "resource", "localhost", "ser", "system", "Server", "version", "sys", "socket", "port", "folder", "site", "type", "client", "user", "erver", "address", "email", "string", "name", "service", "host", "domain", "path", "value", "http", "serv", "secret", "database"], "username": ["ame", "prefix", "attribute", "mobile", "auth", "subject", "uri", "USER", "users", "profile", "info", "method", "port", "sword", "family", "key", "uid", "config", "client", "filename", "header", "login", "user", "usr", "email", "address", "string", "account", "character", "token", "machine", "name", "property", "dn", "path", "ername", "ui", "nick", "manager", "person", "database", "staff"], "password": ["prefix", "attribute", "padding", "pad", "auth", "uri", "mask", "resource", "priv", " passwords", "profile", "session", "port", "sword", "phrase", "channel", "fax", "sudo", "key", "wallet", "wd", "pass", "column", "client", "user", "token", "account", "params", "name", "device", "path", "word", "nick", "Password", "secret", "PASS"], "filePath": ["fileParent", "FILEPath", "workpath", "FileUrl", "FILEName", " fileParent", "FILEpath", "basepath", "singleUrl", "workPath", "FILEUrl", "FileParent", "singleInfo", " fileType", "Filepath", "baseName", "resourceName", "fileType", "singlePath", "resourcepath", "fileUrl", " fileHandler", "filepath", "resourceType", "FilePoint", "FileHandler", " fileUrl", "filePoint", "FILEHandler", "workName", "singlepath", " filePoint", "fileInfo", "fileHandler", " fileInfo", "FilePath", "FILEParent", "resourceUrl", "FILEPoint", "singleName", "FileName", "basePath", "workType", " filepath", "resourceInfo", "resourcePath", "baseUrl"], "idx": ["pidx", "intx", "intX", "IDn", "idxs", "Idxc", "indn", " idc", "indx", "IdX", " idxs", "Idn", "indc", "indy", "idy", "intxs", "indxc", " idX", "IDy", " idn", "pidn", "Idy", "IDX", " idy", "pidc", "idv", "intv", "indv", " idv", "idn", "idxc", "indX", "IDx", "idX", "pidX", "idc", "indxs", "Idx", " idxc"], "fileName": [" filePart", "resourceName", "FilePart", "resourcePart", "sourcePart", "fileInfo", "filename", " fileInfo", "Filename", "FileInfo", "FilePath", "sourcename", " filename", "FileName", "filePart", "sourcePath", "resourceInfo", "sourceName", "resourcePath"], "url": ["proxy", "page", "p", "fl", "uri", "ssl", "resource", "z", "build", "b", "g", "connection", "io", "org", "f", "impl", "www", "URL", "o", "str", "bel", "i", "api", "config", "client", "li", "web", "l", "base", "user", "object", "v", "gl", "service", "t", "sl", "host", "json", "Url", "http", "bb", "open", "browser"], "urlc": ["webac", "downloadc", "webcode", "URLfc", "slc", "serverf", "httpp", "urlcf", "httpci", "downloadci", "urlf", "serverfc", "urlac", "webf", "slcf", "urlci", "urlcode", " urlC", "urlp", " urlcode", "downloadfc", "URLc", " urlac", "urlfc", " urlf", "httpf", "httpac", "downloadC", "servercode", "slp", " urlfc", "httpc", "webfc", " urlp", "serverc", "webc", "urlC", "URLC", " urlci", "URLci", " urlcf", "httpcf", "slci", "webp"], "os": ["ros", "oa", "dos", "http", "fits", "ori", "io", "ot", "obs", "las", "ps", "osi", "iso", "oss", "socket", "aos", "cos", "pos", "so", "o", "bos", "us", "oses", "out", "s", "conn", "fs", "oi", "oS", "ios", "is", "i", "Os", "oos", "bits", "mos", "los", "obj", "ob", "ops", "bs", "oid", "boot", "OS", "ors"], "bis": ["ls", "dos", "ins", "pins", "b", "lis", "obs", "ori", "fb", "nis", "usb", "uds", "oss", "cos", "aos", "sb", "bos", "lins", "bytes", "cb", "fs", "oi", " Bis", "abi", "ios", " cis", "is", "bes", "boot", "co", "buff", "opus", "alis", "ses", "bits", "phys", "cache", "los", "ais", "ris", "obj", "sis", "rots", "ob", "ri", "obb", " bos", "bi", "abs", "ois", "bs", "bb", "bps", "ubis"], "buffer": ["border", "buf", "bb", "available", "padding", "button", "message", "resource", "length", "b", "this", "Buffer", "channel", "sequence", "document", "batch", "timeout", "texture", "source", "flush", "memory", "iter", "reader", "header", "buff", "queue", "position", "table", "cache", "string", "window", "binary", "device", "reference", "vector", "pause", "layer", "uffer", "FFER", "value", "feed", "block"], "br": ["buf", "span", "bro", "wr", "fr", "arr", "shr", "j", "gap", "length", "b", "dr", "nr", "mr", "yr", "bp", "bh", "bc", "ele", "bal", "str", "block", "ch", "cb", "el", "ver", "BR", "bf", "bd", "i", "cm", " Br", "bre", "rib", "width", "li", "lr", "ber", "bn", "tr", "ctr", "bar", "r", "div", "err", "obj", "gr", "aa", "pre", "next", "hr", "bl", "ler", "or", "bi", "Br", "bridge", "line", "cr", "p", "img", "char"]}}
{"id1": "16557837", "id2": "6501291", "code1": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copyFromTo": ["copyFromFile", "transferfromTo", "copyDirFile", "copyfromTo", "transferfromWith", "transferFromFile", "copyFromFrom", "transferfromFile", "transferFromFrom", "copyfromFile", "copyFileTo", "copyfromWith", "copyfromFrom", "copyFromWith", "transferFromTo", "copyDirWith", "copyFileFrom", "transferfromFrom", "copyFileFile", "copyDirTo", "copyDirFrom", "transferFromWith", "copyFileWith"], "srcFile": ["destPage", "srcSourceFile", "destClass", "srcPath", "rcPage", " srcfile", " srcSourceFile", "destFiles", "rcDir", "rcSourceFile", "srcDir", "srcClass", "srcFiles", " srcPath", "srcPage", "srcfile", "rcfile", "destDir", "sourceFile", "rcPath", "sourcefile", " srcDir", " srcPage", "sourceClass", "sourceSourceFile", "sourceFiles", " srcFiles", "destfile", "sourcePath", "destSourceFile", "rcFile", "rcFiles", "sourceDir", " srcClass"], "destFile": ["destPage", " destPage", "srcFilename", "destPlace", " destFine", " destSourceFile", "defaultDir", "southDir", "destFiles", "targetDir", "targetPath", "DestSourceFile", "srcDir", " destinationDir", " destinationFiles", " destinationFile", "destPath", "destFilename", " destPlace", "targetFiles", "DestFile", "destDir", "defaultfile", " destinationFine", " destinationfile", "Destfile", "DestPath", " destfile", "wbSourceFile", "srcPlace", "wbFiles", "southPlace", "destFine", "destroyFilename", "DestDir", "targetFile", "wbFile", "defaultFile", " destFiles", "southFilename", "DestFilename", "southFile", " destFilename", "wbFilename", "destroyPage", "destfile", "destroyFine", " destDir", "DestFiles", "destSourceFile", "destroyFile", " destPath", "defaultFiles", " destinationPage", " destinationFilename"], "in": ["ins", "url", "image", "In", "b", "n", "connection", "init", "like", "io", "inc", "socket", "part", "channel", "f", "input", "o", "din", "IN", "inn", "index", "Out", "lin", "ci", "h", "cin", "i", "is", "win", "source", "reader", "rin", "pull", "inside", "co", "nin", "login", "inner", "min", "r", "id", "ac", "con", "c", "bin", "err", "file", "pin", "ini", "as", "x", "again", "p", "isin"], "out": ["ex", "writer", "image", "parent", "term", "socket", "part", "o", "conn", "win", "cli", "outs", "cache", "string", "exec", "file", "err", "list", "net", "pre", "lib", "query", "page", "resource", "server", "call", "In", "connection", "this", "inc", "group", "no", "input", "error", "key", "code", "dump", "ger", "point", "c", "down", "json", "post", "to", "prefix", "gen", "log", "url", "ico", "cmd", "io", "outer", "off", "store", "sys", "sync", "channel", "IN", "Out", "job", "comment", "co", "user", "bin", "obj", "extra", "up", "ou", "diff", "again", "note", "write", "copy", "lock", "session", "raw", "output", "source", "client", "inner", "base", "window", "name", "OUT", "auto", "state", "line", "doc", "ext"], "fis": ["FIs", "fais", "pIs", "hos", "fi", "gais", "lis", "cfoss", "Fos", "flos", "Fris", "fris", "pos", "flios", "cfis", " fi", " fIs", " fris", "fross", "gis", "frris", "pis", "his", "fios", "li", "pris", "fIs", " foss", "hi", "flis", "gi", "los", "cfris", " fais", "fli", "cfos", "gos", "foss", "hios", "lais", "cfios", "cfi", "fros", "Fis"], "fos": ["tis", "fo", "infose", "fose", "flout", "poes", " faos", "fout", "eis", "boes", "lis", "bics", "Fos", "flos", "eoss", "loss", "tics", "pos", "faos", "infos", " fics", "flo", "Fo", "bis", "bos", "eose", "go", "infoss", " fout", "gose", "pis", " fose", " fo", "flose", "fics", "lose", "Faos", "tos", "po", "los", "infis", "gos", "foss", " foes", "Foes", "foes", "gout", "eos", "toes", "paos", "Fis"], "srcModified": ["srcMetressed", "srcMinIFIED", "srcVered", "srcXed", "sourceModify", " srcModification", "srcModined", "srcmodressed", "srcVerified", "srcModIFIED", "srcXification", "srcModressed", "srcmodIFIED", "srcXified", "srcmodify", "srcModification", "sourceMinify", "sourceModIFIED", "sourceMinified", " srcModressed", "srcMetified", "srcModify", "sourceMinIFIED", " srcModed", "srcMetification", "srcModed", "srcVerification", "srcmodification", " srcModined", "sourceModified", "sourceMinification", "sourceModification", "srcMinified", "srcmodified", " srcModIFIED", "srcMinify", "srcVerined", "srcMetIFIED", "srcMinification", "srcXined"]}}
{"id1": "4593012", "id2": "5725177", "code1": "    private void upgradeSchema() throws IOException {\n        Statement stmt = null;\n        try {\n            int i = getSchema();\n            LOG.info(\"DB is currently at schema \" + i);\n            if (i < SCHEMA_VERSION) {\n                LOG.info(\"Upgrading from schema \" + i + \" to schema \" + SCHEMA_VERSION);\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                while (i < SCHEMA_VERSION) {\n                    String qry;\n                    switch(i) {\n                        case 1:\n                            qry = \"UPDATE settings SET val = '2' WHERE var = 'schema'\";\n                            stmt.executeUpdate(qry);\n                            break;\n                    }\n                    i++;\n                }\n                conn.commit();\n            }\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException e2) {\n                LOG.error(SQL_ERROR, e2);\n            }\n            LOG.fatal(SQL_ERROR, e);\n            throw new IOException(\"Error upgrading data store\", e);\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                conn.setAutoCommit(true);\n            } catch (SQLException e) {\n                LOG.error(SQL_ERROR, e);\n                throw new IOException(\"Unable to cleanup SQL resources\", e);\n            }\n        }\n    }\n", "code2": "    @Override\n    protected <T> T execute(final HttpMethod method, final String url, Parameters parameters, final Handler<T> handler) throws FoursquareException {\n        HttpURLConnection connection = null;\n        try {\n            switch(method) {\n                case GET:\n                    connection = openConnection(url.concat(\"?\").concat(formEncode(parameters)));\n                    connection.setRequestMethod(\"GET\");\n                    connection.connect();\n                    break;\n                case POST:\n                    connection = openConnection(url);\n                    connection.setRequestMethod(\"POST\");\n                    connection.setDoOutput(true);\n                    connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                    connection.connect();\n                    final OutputStream out = connection.getOutputStream();\n                    out.write(formEncode(parameters).getBytes());\n                    out.flush();\n                    out.close();\n                    break;\n            }\n            final int statusCode = connection.getResponseCode();\n            if (statusCode / 100 != 2) {\n                final Error error = parseBody(connection.getErrorStream(), new ErrorHandler());\n                if (error == null) throw new FoursquareException(connection.getResponseMessage()); else if (\"error\".equals(error.getType())) throw new FoursquareException(error.getMessage()); else if (\"unauthorized\".equals(error.getType())) throw new AuthenticationException(error.getMessage()); else if (\"ratelimited\".equals(error.getType())) throw new RateLimitingException(error.getMessage()); else throw new FoursquareException(connection.getResponseMessage());\n            }\n            return parseBody(connection.getInputStream(), handler);\n        } catch (final IOException e) {\n            throw new FoursquareException(e);\n        } catch (final ParserConfigurationException e) {\n            throw new FoursquareException(e);\n        } catch (final SAXException e) {\n            throw new FoursquareException(e);\n        } finally {\n            if (connection != null) connection.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"upgradeSchema": ["upgradeCatalogMeta", "upgradeSchement", "upgradeDatabasement", "upgradingscheMeta", "upgradeCatalogma", "upgradeScheMeta", "upgradeCatalogmas", "upgradeDatabaseMeta", "upgradeschemas", "upgradeDatabasemas", "upgradingschement", "upgradeschema", "upgradingScheMeta", "upgradingschema", "upgradeCatalogment", "upgradescheMeta", "upgradingSchemas", "upgradingSchement", "upgradeSchemas", "upgradeDatabasema", "upgradingschemas", "upgradingSchema", "upgradeschement"], "stmt": ["stmsg", "STtm", "Stmt", "pmt", "estmt", "frmp", "STvt", "estmsg", " stmr", "stmp", "frmsg", "frmt", "stvt", "Stdb", " stmit", "Stnt", "stql", "Stmr", "pvt", "hmit", "hmp", "stmit", "estmp", "rmp", "ptm", "stnt", "hmt", "estm", "frm", "ftmp", "ftmit", "pm", "strnt", "STm", " stmsg", " stmp", "strmp", "stm", "strmt", " sttm", "rmr", "rmt", " stnt", " stvt", "hnt", "rql", "strmr", " stm", "strql", " stql", "sttm", "stmr", "strdb", "ftmt", "stdb", " stdb", "ftnt", "STmt"], "i": ["ini", "mi", "index", "j", "in", "o", "yi", "hei", "hi", "isi", "phi", "cli", "ii", "fi", "ix", "count", "slice", "api", "b", "info", "ui", "isu", "ami", "ri", "pi", "c", "r", "gi", "t", "abi", "k", "li", "ci", "ie", "p", "multi", "si", "ni", "xi", "I", "bi", "v", "uri", "ai", "x", "adi", "eni", "it", "ip", "start", "name", "esi", "qi", "ti", "id", "e", "iu", "vi", "u", "f", "n", "di", "ki", "oi", "zi"], "qry": ["quRY", "Qry", " qri", "qrc", "quri", "QRY", "quries", "querri", "qRY", "Qri", " qries", "Qrys", " qcr", " qRY", "querRY", "Qcr", "Qries", "qurys", " qrc", " qrys", "qrys", "qucr", "qury", "querrc", "qcr", "querry", "qri", "qurc", "qries"]}}
{"id1": "15645004", "id2": "19109981", "code1": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "code2": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"unzip": ["freepatch", "freearchive", "unpatch", " unress", " unpatch", "Unarchive", "Unzip", " unarchive", "Unress", "freeress", "unress", "freezip", "Unpatch", "unarchive"], "filename": ["fd", "SourceFile", "fn", "prefix", "url", "txt", "FILE", "uri", "ssl", "connection", "sheet", "il", "username", "socket", "journal", "folder", "f", "document", "zip", "via", "archive", "nil", "out", "download", "xml", "wl", "source", "metadata", "directory", "l", "files", "queue", "Filename", "kl", "string", "file", "upload", "name", "loader", "binary", "File", "path", "location", "json", "word", "iterator", "manager", "fp", "database"], "in": ["into", "rec", "ln", "ins", "ssl", "fin", "In", "io", "info", "inc", "ie", "gin", "impl", "zip", "oin", "input", "vin", "din", "IN", "lin", "inn", "zin", "inas", "out", "cin", "is", "i", "win", "kin", "reader", "source", "inside", "nin", "login", "inner", "internal", "cache", "bin", "file", "con", "ilo", "obj", "pin", "ini", "arin", "again", "afi", "orig", "line", "isin"], "entry": ["enter", "page", "log", "url", "install", "module", "image", "server", "connection", "cell", "info", "ge", "je", "si", "child", "parser", "inc", "ie", "part", "folder", "it", "zip", "archive", "exp", "ga", "ace", "draft", "ent", "country", "key", "out", "row", "Entry", "container", "element", "jo", "plugin", "source", "parse", "reader", "record", "section", "directory", "article", "inner", "de", "internal", "object", "id", "string", "file", "obj", "name", "service", "entity", "next", "path", "auto", "or", "lc", "ident", "office", "iterator", "line", "feed", "database", "ry"], "first_entry": ["first_connection", " first_connection", "first_zip", "empty_ent", " first_element", " first_Entry", " first_ent", "first_section", "firstxreader", "firstxEntry", "empty_section", "first_enter", "first_ent", "first_Entry", "firstxentry", "firstxconnection", "first_reader", "first_element", "empty_enter", " first_zip", " first_reader", "empty_entry"], "subdir": [" subfile", " subDir", "superdir", "subfolder", "ubdir", "ubDir", "superDir", "partfile", " subclass", "singdir", "singDir", "ubclass", " subdb", "Subdist", "singdb", "Subdirectory", "SubDir", " subfolder", "ubfile", " subdist", "partDir", "singclass", " subdirectory", "subclass", "ubdirectory", "subDir", "subfile", "Subfile", "ubfolder", "partdir", "subdb", "subdirectory", "Subdir", "superfolder", "superfile", "subdist", "partdirectory", "ubdb", "ubdist"], "dir": ["prefix", "direction", "log", "url", "uri", "module", "parent", "build", "dr", "loc", "lock", "manager", "DIR", "rc", "folder", "group", "du", " directory", "spec", "area", "zip", "Directory", "coll", "finder", "draft", "done", "sort", "wd", "home", "pkg", "iter", "directory", "target", "tree", "db", "base", "id", "div", "desc", "ir", "file", "window", "dist", "root", "lib", "host", "diff", "domain", "path", "Dir", "mod", "http", "doc"], "outfile": [" outfiles", "fullfolder", "exurl", " outfolder", " outf", "exdir", "infile", "fulldir", "Outfiles", "Outpath", "inpath", " outFile", "Outurl", "exFile", "inFile", "outputFile", "outpath", "Outfolder", "execf", "indir", "Outdir", "infiles", "outfolder", "fullfile", "fullf", "inurl", "outf", "Outf", "outurl", "outfiles", "outputpath", "outFile", "Outfile", "execdir", "outputdir", "execfolder", "execfile", "OutFile", "outputfile", "exfile"], "outdir": ["Outdirectory", " outDir", " outfolder", "infile", "outdirectory", "outputfolder", "outDir", "outputdirectory", " outdirectory", "Outfolder", "indirectory", "indir", "inDir", "Outdir", "outfolder", "OutDir", "infolder", "Outfile", "outputdir", "outputfile"], "fo": ["wo", "FO", "ro", "ico", "gio", "os", "io", "info", "mo", "iso", "osa", "oe", "so", "flo", "bis", "o", "olo", "prof", "bo", "ko", "tra", "ao", "jo", "ho", "co", "zo", "fam", "po", "obj", "oo", "ob", "op", "lo", "obo"], "bos": ["tis", "ros", "dos", "rows", "fits", "kos", "obs", "os", "bh", "uds", "osi", "iso", "osa", "bc", "aos", "oss", "zos", "obi", "bs", "so", "flo", "bis", "lins", "bott", "ko", "bo", "fs", "oS", "ios", "bes", "zo", "opus", "oos", "outs", "bits", "mos", "los", "bin", "bas", "gb", "ob", "ops", "lo", "bi", "oops", "obo", "ubis"], "read": ["pe", "text", " load", "play", "pack", "write", "e", "call", "length", "count", " Read", "copy", "n", "en", "scan", "io", "child", "allow", "sync", "inc", "raw", "pos", "ride", "shape", "connect", "check", "input", "reads", "READ", "index", "Read", "run", "seek", "fill", "tell", "end", "pass", "i", "add", "parse", "create", "reader", "size", "use", "ip", "send", "ind", "skip", "load", "c", "start", "find", "select", "wait", "next", "get", "transfer", "x", "put", "buffer", "level", "current", "feed", "open", "readable"], "data": ["DATA", "pad", "ada", "message", "image", "one", "write", "length", "style", "body", "empty", "raw", "no", "result", "input", "str", "d", "dat", "batch", "bytes", "results", "i", "memory", "reader", "size", "number", "da", "slice", "cache", "address", "load", "bin", "start", "alpha", "aa", "next", "response", "value", "buffer", "zero", "feed", "block"], "read_position": ["read_length", "read_limit", " read_limit", " read_length", "read_pos", " read_pos"]}}
{"id1": "19584877", "id2": "16048516", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static SVNConfiguracion load(URL urlConfiguracion) {\n        SVNConfiguracion configuracion = null;\n        try {\n            XMLDecoder xenc = new XMLDecoder(urlConfiguracion.openStream());\n            configuracion = (SVNConfiguracion) xenc.readObject();\n            configuracion.setFicheroConfiguracion(urlConfiguracion);\n            xenc.close();\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        }\n        return configuracion;\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeFiletoFiles", "encodeFileToFiles", "encodeFiletoFile", "encodeString2File", "encodeString2Stream", "encodeFileToStream", "encodeFileFromStream", "encodeStringToStream", "encodeFileFromFile", "encodeString2String", "encodeFile2Files", "encodeStringToFile", "encodeFile2File", "encodeFileToString", "encodeString2Files", "encodeFiletoString", "encodeStringToString", "encodeFile2Stream", "encodeFiletoStream", "encodeStringToFiles", "encodeFileFromString", "encodeFileFromFiles", "encodeFile2String"], "infile": ["infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", " infp", "inputfp", "inputFile", "outfiles", " infilename", "inputfiles", "Infilename", " infiles", "outfp", "Infile", "InFile", "inputfilename", "infilename", "Infiles"], "outfile": ["newfile", "Outname", "infp", "outfilename", "outputfile", "outFile", "newname", " outFile", "infolder", " outfolder", "outputfolder", "newfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "Outfolder", " outname", "outname", "OutFile", "Outfile", "infilename", "newFile", " outfilename"], "in": ["IN", "base", "pin", "i", "input", "inas", "sin", "id", "ini", "gin", "into", "ic", "con", "inner", "as", "socket", "ins", "s", "bin", "pass", "is", "reader", "source", "thin", "login", "min", "inside", "r", "inc", "data", "rin", "vin", "init", "conn", "again", "m", "image", "re", "isin", "In", "nin", "a", "err", "b", "ac", "cin", "inn", "win", "din"], "out": ["base", "ou", "job", "ex", "output", "outer", "copy", "timeout", "on", "net", "OUT", "socket", "inner", "outs", "o", "off", "write", "bin", "co", "line", "exit", "post", "client", "sync", "session", "no", "cache", "source", "one", "up", "lib", "inc", "parent", "work", "file", "conn", "or", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "In", "err", "obj", "error", "point"], "buffer": ["address", "base", "Buffer", "input", "uffer", "feed", "server", "border", "slice", "limit", "result", "length", "write", "queue", "offset", "iter", "split", "raw", "type", "reader", "cache", "binary", "source", "seed", "buff", "value", "buf", "len", "wave", "data", "fb", "size", "bb", "null", "bytes", "layer", "flush", "url", "b", "reference", "count", "padding", "transfer", "batch"], "read": ["play", "close", "i", "input", "Read", "feed", "n", "copy", "reading", "id", "add", "ind", "slice", "current", "end", "limit", "run", "se", "find", "length", "write", "reads", "ride", "pass", "sleep", "ad", "iter", "next", "raw", "sync", " count", "select", "allow", "use", "load", "reader", " Read", "len", "seek", "work", "inc", "check", " copy", "ip", "size", "x", "get", "fill", "start", "exec", "io", "lex", "send", "tell", "_", "parse", "connect", "wait", "count", "READ", " write", " skip", "f"], "success": ["respons", "roll", "error", "path", "response", "rolling", "continue", "results", "ceed", "modified", "xx", "message", "primary", "warning", "better", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "model", "default", "open", "data", "growth", "flash", "null", "cess", "danger", "complete", "again", "status", " successful", "good", "Success", "comment", "right", "successful", "successfully", "rolled", " succ", "method", "fast", "first", "winner", "initial"]}}
{"id1": "21063400", "id2": "14794404", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "label": 0, "substitutes": {"doImageProcess": [" doImageFile", "doimageProcess", "doFileFile", "doThumbnailProcess", " doimageProcess", "doimageprocess", "doimageFile", "doThumbnailFile", " doimageprocess", "doImageprocess", " doimageFile", "doThumbnailprocess", " doImageprocess", "doFileProcess", "doFileprocess", "doImageFile"], "request": ["req", "writer", "url", "resource", "image", "server", "message", "report", "method", "data", "application", "model", "result", "input", "Request", "type", "xml", "instance", "reader", "config", "client", "header", "stream", "object", "name", "path", "query"], "response": ["wave", "resp", " Response", "page", "description", "writer", "respond", "default", "report", "message", "server", "image", "resource", "example", "complete", "view", "Response", "connection", "body", "version", "more", "session", "output", "application", "document", "status", "result", "site", "model", "reply", "index", "error", "out", "results", "api", "client", "queue", "object", "video", "cache", "success", "service", "host", "next", "full", "json", "location", "pool", "collection", "http", "feed", "ception", "onse"], "imgSize": ["ifSize", "imgC", "largeSize", "bgWidth", " imgLength", "dimSize", "imgLen", "augLen", "imagesize", "bgLength", "hrType", " imgWidth", "refSize", "imgHeight", "bgScale", "augWidth", "ifName", "imgWidth", "imagsize", "imgLength", "imHeight", "dimsize", " imgFamily", "ifLen", "imageLength", "imageSize", "dimHeight", "imageName", "refLength", "augSize", "imageLen", "imSize", " imgLen", "imageScale", "hrSize", "imLength", " imgName", "dimLength", "imgsize", "largeType", "bgLen", "imgScale", "bgSize", "imagType", "imgType", "imagC", "ifsize", "refHeight", "refsize", "hrsize", "augFamily", "imgFamily", "bgFamily", "imagSize", "largesize", " imgScale", "largeC", "imsize", " imgsize", "imgName", "hrC"], "imageInputStream": [" imageOutputSteam", "imageInstream", " imageOutputView", "imageReadFile", "imageStreamStream", "imageContentSteam", " imageInputFile", "imageInString", "pictureUploadFile", "imageInputSteam", "imageReadLength", "pictureUploadStream", "imageUploadstream", "imageReadstream", " imageOutputFile", "imageFilestream", "fileInputString", "imageFileString", "imageReadString", "imageInputFile", "imageInputView", "imageOutputView", "pictureInputstream", "imageInputstream", "pictureInputSteam", "fileReadStream", "fileInputstream", "imageUploadView", "photoReadSteam", "photoInputStream", "photoInputFile", "pictureUploadstream", "pictureInputStream", "pictureUploadSteam", "imageOutputFile", "imageReadStream", "fileInputLength", "fileInputStream", "photoReadStream", "photoInputSteam", "imageContentView", "pictureInputFile", "imageUploadStream", "imageUploadSteam", "imageOutputSteam", "fileReadString", " imageInputView", " imageOutputStream", "imageStreamFile", " imageInputSteam", "imageInLength", "imageStreamSteam", "imageInputString", "imageContentStream", "imageInStream", "fileReadstream", "imageContentFile", "photoReadstream", "imageStreamstream", "imageFileLength", "photoReadFile", "fileReadLength", "imageUploadFile", "imageFileStream", "imageReadSteam", "photoInputstream", "imageOutputstream", "imageOutputStream", "imageInputLength"], "imageBytes": ["imgBytes", "fileBlocks", "ImageBlocks", "audioBytes", "viewbytes", " imageUrl", "ImageData", "fileBytes", "viewBytes", "Imagebytes", "imageUrl", "fileData", "pictureData", "imageByte", "imgByte", "imgData", "audioBuffer", "viewData", "audiobytes", " imagebytes", "imagebytes", "imageBlocks", "ImageBytes", "imgBuffer", " imageData", "imageData", "audioByte", "filebytes", "picturebytes", "imgUrl", "viewUrl", " imageBuffer", "pictureBlocks", "imageBuffer", "imgbytes", "pictureBytes", " imageByte"]}}
{"id1": "5125848", "id2": "9272325", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    private static HttpURLConnection sendPost(String reqUrl, Map<String, String> parameters) {\n        HttpURLConnection urlConn = null;\n        try {\n            String params = generatorParamString(parameters);\n            URL url = new URL(reqUrl);\n            urlConn = (HttpURLConnection) url.openConnection();\n            urlConn.setRequestMethod(\"POST\");\n            urlConn.setConnectTimeout(5000);\n            urlConn.setReadTimeout(5000);\n            urlConn.setDoOutput(true);\n            byte[] b = params.getBytes();\n            urlConn.getOutputStream().write(b, 0, b.length);\n            urlConn.getOutputStream().flush();\n            urlConn.getOutputStream().close();\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n        return urlConn;\n    }\n", "label": 0, "substitutes": {"combineJs": ["combinScript", "combinedjs", "Combinatejs", "combinateJs", "combinateScript", "combinedJS", "CombineScript", "CombinateJs", "CombinateJS", "combinJs", "combinateJS", "combineScript", "combinatejs", "combinjs", "Combinejs", "combineJS", "combinejs", "CombineJs", "CombinateScript", "combinJS", "CombineJS", "combinedScript", "combinedJs"], "base": ["resource", "root", "bot", "string", "cache", "site", "http", "area", "proxy", "log", "api", "absolute", "address", "build", "store", "Base", "part", "out", "prefix", "builder", "server", "config", "f", "bas", "based", "home", "image", "page", "relative", "data", "b", "info", "source", "uri", "db", "file", "ref"], "linkJs": [" linkJS", "linkedScript", "linkedjs", "linkedJS", "linkedJs", "linkLinks", "loadScript", "linkedLinks", " linkLinks", "loadjs", "loadJS", "likeLinks", "likeJs", " linkScript", " linkjs", "likejs", "likeJS", "linkJS", "linkScript", "loadJs", "linkjs"], "newFiles": ["oldResources", "addResources", "newfiles", "newLinks", "oldLinks", "oldfiles", "addLinks", "addfiles", " newfiles", " newLinks", "oldFiles", " newResources", "newResources", "addFiles"], "dir": ["folder", "or", "root", "local", " block", "keep", "container", "zip", "cache", "ir", "http", "d", " repo", "dist", " Dir", "src", "log", "manager", "in", " folder", "wd", "div", "object", " db", "DIR", "download", "loc", "build", " d", "out", "domain", " module", " director", "work", " dep", "session", "home", "Dir", " directory", "lib", "editor", "relative", "directory", "direction", " download", "md", "module", "b", "plugin", "id", "lock", "uri", "source", "dep", "db", "file", " manager"], "name": [" zip", " root", " dest", " repo", " abs", " title", " app", " folder", " suffix", " cache", " prefix", " info", " relative", " id", " module", " parent", "Dir", " bundle", " head", " resource", " source", " init", " build", " manager"], "minDir": [" minManager", "minDriver", "tempdir", " minDriver", " minFile", "MinFile", " minMin", "initManager", "minJar", " minDb", " minDirectory", "tempMin", "miniFile", "minFile", "versionFolder", "versionManager", "MinDir", " minFolder", "MinJar", "minDest", "versionDirectory", "MinDest", " minDest", "MinDb", "blockdir", "minMin", "miniDest", "Mindir", "blockDriver", "miniDir", "MinMin", "blockFile", "initDirectory", "blockDir", "minDb", "minFolder", " mindir", " minJar", "versionDir", "tempJar", "initDir", "mindir", "minDirectory", "minidir", "miniDriver", "miniDb", "tempDir", "initFolder", "minManager"], "combineFile": ["combinedDir", "combinedWriter", "combicateSourceFile", "combineReader", "combicateLog", "combinateDir", "combinerWriter", "CombinateWriter", "combinateWriter", "combinerFile", "comboseWriter", "joineDir", "CombineLog", "joinateFile", "CombineFile", "combineLog", "combinerSourceFile", "joinateDir", "combinateLog", "combinedFile", "comboseDir", "combinedReader", "joinateWriter", "combinateSourceFile", "combinerLog", "joinateReader", "CombineWriter", "combicateWriter", "comboseFile", "joineFile", "combineDir", "joineReader", "combinateFile", "CombineSourceFile", "CombinateLog", "CombinateSourceFile", "combicateFile", "combineSourceFile", "comboseReader", "CombinateFile", "joineWriter", "combinateReader"], "concatFile": ["conateDir", "ConcatStream", "concatStream", "concentDir", "concentWriter", "Concatfile", "concatsWriter", "concatfile", "concStream", "concfile", "conateFile", "concentStream", "concatDir", "concFiles", "concatFiles", "Concatsfile", "conatefile", "concatsFiles", "concatsfile", "concentFile", "concFile", "ConcatsDir", "concWriter", "ConcatsFiles", "concatsStream", "conateFiles", "ConcatFiles", "ConcatDir", "concatsDir", "ConcatsStream", "ConcatsFile", "concDir", "ConcatsWriter", "ConcatFile", "ConcatWriter", "concatsFile"], "combineWriter": ["combiseFile", "combineWalker", "combineReader", "combinerWalker", "combinerWriter", "combiseReader", "combinateWriter", "comboseWriter", "combinerRW", "CombineFile", "mixinerRW", "combinateReader", "mixineRW", "ComboseFile", "comboseRW", "CombineWrite", "combinerReader", "combideReader", "comboseWrite", "CombineReader", "mixineWriter", "mixinerWalker", "combiseWriter", "combinateWrite", "CombineWriter", "mixinerReader", "comboseFile", "combinateFile", "combideWriter", "ComboseReader", "combiseWrite", "comboseWalker", "mixineReader", "mixineWalker", "ComboseWrite", "combineRW", "combideWalker", "comboseReader", "combineWrite", "mixinerWriter", "ComboseWriter", "combideRW"], "concatWriter": ["convertFile", "ConcatWrite", "syncWriter", "concilFile", "syncatFile", "concatsWriter", "syncWrite", "syncatReader", "syncatWrite", "concWrite", "convertWrite", "convertDriver", "syncFile", "convertWriter", "concilDriver", "concilWrite", "concatsDriver", "concatsFile", "concFile", "ConcatDriver", "concWriter", "concatDriver", "concReader", "concatReader", "convertReader", "concilWriter", "concatsReader", "ConcatsDriver", "syncReader", "ConcatsWrite", "syncatWriter", "ConcatsFile", "ConcatsWriter", "ConcatFile", "concatWrite", "ConcatWriter", "concatsWrite"], "fails": ["Fls", "foralls", "frors", "forils", "failed", "ifils", "infails", "ifails", "infils", "fakes", "Fails", "fils", "Falls", "Fakes", "faults", "Fils", " fls", "dfils", "Failing", "Frors", "Faults", "failing", "dfailed", "ifls", "dfails", "tails", " frors", " fils", "dfailing", " fakes", " failing", "tls", "tils", "trors", "Failed", " failed", "forails", "falls", "infaults", "ifakes", "foraults", "fls", "infalls"], "link": [" page", " item", "line", "Link", " node", " config", " tag", "comment", " inline", "open", "match", "add", "linked", " comment", "address", "bug", "loc", " http", " document", "dd", " site", "l", "connection", " location", " module", "load", " entry", "e", "li", "ink", " html", "image", " anchor", " target", "links", " resource", "follow", "parse", " lang", " source", "style", "message", " Link", "uri", "info", "block"], "path": ["entry", "attribute", "route", "class", "string", "href", "step", "Path", "pointer", "script", "node", "input", "key", "attr", "wd", "content", "loc", "location", "code", "value", "ath", "filename", "data", "type", "PATH", "point", "id", "pattern", "info", "uri", "source", "text", "src", "file"], "url": ["resource", "pull", "route", "string", "channel", "host", "http", "xml", "str", "www", "URL", "log", "api", "open", "key", "Url", "download", "ri", "address", "build", "loc", "browser", "l", "connection", "server", "location", "loader", "sl", "f", "image", "result", "html", "ssl", "page", "data", "r", "b", "web", "uri", "stream", "source", "file"], "inputStream": ["outputChannel", "InputReader", "outputWriter", "inputFile", "inputWriter", "inputChannel", "outputStreamer", "InputChannel", "outputFile", " inputFile", "downReader", "inputstream", "InputWriter", "downStream", " inputstream", "inputStreamer", "InputFile", "Inputstream", "inputReader", "InputStreamer", " inputWriter", "downFile", "outputReader", "InputStream", "outputstream", "downStreamer", " inputChannel"], "jsFile": [" jsStream", "Jsfile", "javascriptWriter", "jsSource", "javascriptSource", "javascriptDir", "JsLog", "scriptPath", " jsWriter", "jsWriter", " jsLog", "jsReader", "jsfile", "jsPath", "JsStream", "javascriptLog", "jsDir", "JsFile", "jsonSource", " jsfile", "scriptFile", "jsonPath", "scriptSource", "javascriptStream", "jsonFile", "JsReader", "JsWriter", "jsonDir", "jsLog", "javascriptPath", " jsReader", "javascriptReader", "javascriptfile", "jsStream", "javascriptFile", "scriptDir"], "fileName": ["fileSize", " fileSize", "fileNumber", "FileNumber", "filePath", "resourcePath", "FilePath", " filePath", "resourceNumber", "FileName", "resourceName", "resourceSize", "FileSize", " fileNumber"], "outputStream": ["responseSteam", "Outputstream", "outputSteam", "OutputStream", " outputWriter", "responseStream", "resourceSteam", "outputWriter", "inputFile", "inputWriter", "outputFile", "resourceReader", "OutputFile", " outputSteam", "responseWriter", " outputReader", "OutputWriter", "responseReader", "OutputSteam", "resourceStream", " outputstream", "OutputReader", "resourcestream", " outputFile", "outputReader", "outputstream", "inputSteam"], "first": ["root", "each", "use", "again", "full", "th", "current", "initial", "right", "self", "same", "prev", "then", "primary", "only", "second", "user", "count", "it", "alpha", "p", "default", "First", "must", "all", "replace", "left", "now", "other", "third", "before", "success", "start", "top", "auto", "split", "result", "last", "next", "error", "st", "found", "stack", "always", "required", "one"], "reader": ["resource", "entry", "reads", "context", " Reader", "reading", "xml", "inner", "input", "report", "io", "feed", "driver", "in", "object", "er", "handler", "dd", "rc", "server", "config", "loader", "read", "Reader", "f", "e", "image", "h", "writer", "data", "r", "parser", "info", "source", "stream", "buffer", "builder", "file"], "jsCompressor": ["jsRepression", " jsCompression", "jsExporter", "jsExpress", "jsReporter", "jsCompress", " jsCompress", "jsRepressor", "jsExpression", "jsExpressor", "jsRepress", " jsComporter", "jsCompression", "jsComporter"], "s": ["words", "S", "ings", "ses", "g", "n", "ens", "m", "lines", "is", "sets", "scripts", "gs", "gets", "abs", "objects", "os", "sys", "groups", "xs", "ing", "fs", "l", "qs", "strings", "ls", "ws", "ments", "ns", "ions", "types", "v", "states", "ts", "ps", "comments", "t", "en", "es", "ss"], "s1": ["ings2", "ysB", "s81", "es2", "ys01", "ats2", "sPre", "ets2", "atsPre", "esAP", "esB", "qs2", "es1", "esPre", "ings1", "ys1", "ets1", "es81", "sB", "etsPre", "ys2", "sAP", "etsAP", "qs81", "sIP", "qs1", "ingsB", "es01", "esIP", "qsIP", "atsAP", "s01", "ats1", "ings01"], "i": ["si", "qi", "ip", "u", "ii", "c", "m", "pi", "o", "is", "d", "ic", "z", "ui", "bi", "ing", "p", "l", "phi", "w", "j", "I", "ifier", "x", "f", "e", "q", "a", "v", "b", "xi", "t", "id", "ik"], "s2": ["ings2", "sSecond", "es2", "ets62", "sCloud", "ets2", "es82", "ets82", "qs2", "es1", "qsSecond", "ets1", "es12", "s62", "etsSecond", "es62", "sets2", "ings12", "etsCloud", "s12", "ls1", "qs1", "esCloud", "qs12", "esSecond", "lsSecond", "sets82", "ls62", "ingsSecond", "setsCloud", "ls2", "s82", "ings1", "sets1"], "i1": ["iOne", "a1", "e0", "sFirst", "eFirst", "eOne", "a2", "l2", "pi1", "sOne", "a9", "iFirst", "i2", "s4", "l0", "pi2", "l1", "pi9", "e1", "lOne", "pi0", "i9", "s9", "pi4", "e2", "piFirst", "i4", "s0", "i0", "a4"]}}
{"id1": "1362", "id2": "17538992", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public static boolean check(String urlStr) {\n        try {\n            URL url = new URL(urlStr);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            urlConnection.setConnectTimeout(2000);\n            urlConnection.getContent();\n        } catch (Exception e) {\n            logger.error(\"There is no internet connection\", e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubblingOrder", "ubbleSort", "bubblerSort", "ubblingSort", "bubblingCompare", "bubblersort", "bubblessort", "bubblesOrder", "ubblingCompare", "bubbleOrder", "bubblesCompare", "bubblesort", "bubbleCompare", "ubblingOrder", "ubbleCompare", "bubblerOrder", "bubblingsort", "ubblingsort", "bubblingSort", "bubblerCompare", "ubbleOrder", "bubblesSort", "ubblesort"], "a": ["an", "another", "va", "aux", "ama", "u", "at", "c", "access", "m", "apps", "o", "oa", "A", "area", "d", "na", "as", "au", "abs", "aa", "empty", "sa", "list", "la", "active", "ac", "ack", "address", "sup", "p", "aaa", "alpha", "ad", "l", "s", "ans", "all", "ga", "aw", "work", "ma", "array", "f", "index", "e", "am", "auto", "any", "tta", "result", "img", "ae", "data", "something", "b", "ba", "ata", "ab", "aj"], "swapped": [" swaped", "swaps", "rewaped", "rewap", " swap", "wap", "Swapping", "Swaped", "waps", " swapping", "wapped", "Swapped", " swaps", "flapped", "Swoped", "Swap", "flap", "rewoped", "floped", "swap", "wapping", "rewapped", "flapping", "waped", "swapping", "swoped", "swaped", "rewaps", "rewapping"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "k", "ii", "ini", "m", "pi", "y", "d", "ci", "di", "api", "io", "key", "ui", "in", "ri", "bi", "ie", "p", "it", "sup", "l", "ami", "init", "ki", "j", "I", "eni", "x", "fi", "index", "f", "e", "oi", "li", "ind", "ori", "anti", "h", "ni", "start", "v", "gi", "ti", "next", "mini", "mi", "ai", "module", "b", "xi", "id", "info", "uri", "iv", "ix", "uni", "adi"], "tmp": ["txt", "temp", "mp", "yy", "nb", "cmp", "front", "m", "append", "stuff", "area", "angle", "mmm", "prev", "dest", "pad", "qq", "pp", "tv", "sup", "p", "alpha", "ie", "xxx", "amp", "part", "j", "addr", "x", "foo", "f", " ff", "pre", "emp", "tc", "v", "bb", "test", "st", "obj", "b", "t", "tt", "kk", "opp", "vt"]}}
{"id1": "15262411", "id2": "19322941", "code1": "    String fetch_pls(String pls) {\n        InputStream pstream = null;\n        if (pls.startsWith(\"http://\")) {\n            try {\n                URL url = null;\n                if (running_as_applet) {\n                    url = new URL(getCodeBase(), pls);\n                } else {\n                    url = new URL(pls);\n                }\n                URLConnection urlc = url.openConnection();\n                pstream = urlc.getInputStream();\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        if (pstream == null && !running_as_applet) {\n            try {\n                pstream = new FileInputStream(System.getProperty(\"user.dir\") + System.getProperty(\"file.separator\") + pls);\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        String line = null;\n        while (true) {\n            try {\n                line = readline(pstream);\n            } catch (Exception e) {\n            }\n            if (line == null) {\n                break;\n            }\n            if (line.startsWith(\"File1=\")) {\n                byte[] foo = line.getBytes();\n                int i = 6;\n                for (; i < foo.length; i++) {\n                    if (foo[i] == 0x0d) {\n                        break;\n                    }\n                }\n                return line.substring(6, i);\n            }\n        }\n        return null;\n    }\n", "code2": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"fetch_pls": ["fetch_pullp", "fetch_pulls", "fetch_pulla", "fetch_Plss", "fetch_plp", "fetch_pla", "fetch_Plp", "fetch_plss", "fetch_Pls", "fetch_pullss", "fetch_Pla"], "pls": [" Pls", "splS", " Plgs", "PLS", "plS", "replS", "plss", "splss", "bls", "PLss", "spls", "ylses", "plses", " plp", "ptS", "plts", " pli", "plf", "replss", "pli", "Pls", " plss", "pts", "yls", "bli", " plgs", "Plf", "ylp", "ylts", "repls", "plgs", "blgs", "Plses", "PLs", "plp", "splses", "splb", "splf", "splts", "ptss", " plS", "Plp", "plb", " plb", "replb", " Pli", "ylf", " plts", "splp"], "pstream": ["pengine", " pfeed", " prow", "tstream", "psengine", "psStream", "psw", "tbody", "Pchannel", "pschannel", "PStream", "fchannel", "spsw", "Pstream", "tchannel", "ipstream", "frow", "fstream", "ipstring", "Pengine", "ppsource", "ipsource", "ppfeed", "psstream", "spStream", "psource", " punk", "ipfeed", "Psw", "ppstream", " pbody", "fengine", "pstring", "spstream", "ppath", "tsource", "perbody", " ppath", "pchannel", "parpath", " pStream", "ppstring", " pstring", "pStream", "perchannel", " psource", "punk", "parrow", "fstring", "fpath", "perstream", "parstream", "Punk", " pchannel", "prow", "persource", "fStream", " psw", "parstring", "spunk", "pfeed", "pbody"], "url": ["image", "blog", "client", "service", "sl", "ul", "rl", "host", "feed", "impl", "fl", "bug", "ls", "page", "www", "server", "coll", "address", "bel", "conn", "loc", "open", "connection", "http", "hub", "URL", "path", "resource", "pull", "ob", "ssl", "file", "build", "link", "f", "Url", "api", "base", "control", "gl", "b", "log", "org", "rel", "ll", "l", "string", "web", "ur", "uri", "source", "c"], "urlc": ["webf", " urlconn", " urlp", "webc", "bbf", "urln", "webn", "Urlc", "bbci", "urlf", "webci", "URLconn", "bbn", "Urll", "Urlconn", " urln", "URLp", "URLc", "URLl", "Urlp", "urlp", " urlci", " urll", "urlci", "urll", "urlconn", " urlf", "bbc"], "line": ["next", "error", "lo", "sl", "lf", "one", "sync", "entry", "block", "key", "cell", "object", "comment", "el", "load", "parse", "write", "e", "page", "lc", "rule", "home", "val", "lines", "Line", "lin", "code", "strip", "response", "message", "day", "word", "value", "row", "file", "end", "link", "no", "pass", "base", "definition", "inline", "data", "pe", "log", "b", "ine", "LINE", "text", "co", "name", "l", "frame", "style", "body", "string", "header", "nl", "le", "lock", "look", "source"], "foo": ["la", "flo", "hello", "pos", "key", "little", "bug", "bo", "page", "office", "po", "py", "nice", "oo", "fe", "info", "que", "stuff", "home", "goo", "dirty", "fb", "code", "day", "something", "value", "date", "file", "qa", "oa", "fun", "f", "buf", "prefix", "data", "type", "xxxx", "bar", "token", "done", "name", "company", "string", "header", "front", "floor", "field"], "i": ["ai", "in", "ip", "ki", "j", "p", "eni", "is", "multi", "fi", "ix", "e", "id", "abi", "ci", "mu", "gi", "limit", "ui", "info", "index", "li", "ii", "io", "vi", "ini", "bi", "start", "x", "pi", "f", "end", "o", "xi", "ti", "k", "ri", "u", "ni", "b", "v", "oi", "mi", "di", "hi", "l", "d", "si", "qi", "uri", "I", "c"]}}
{"id1": "6966398", "id2": "22801734", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 1, "substitutes": {"reader": ["her", "dr", "resource", "o", "feed", "stream", "input", "ry", "load", "reads", "parser", "reading", "ler", "rar", "cms", "writer", "raf", "read", "ri", "builder", "pp", "pe", "r", "driver", "buffer", "rc", "oder", "k", "handler", "er", "p", "io", "rake", "se", "rr", "df", "row", "client", "ner", "context", "manager", "loader", "server", "file", "cer", "instance", "Reader", "rw", "keeper", "per", "iter", "or", "connection", "config", "source", "book"], "ks": ["gets", "kes", "books", "kb", "keys", "ku", "ans", "sk", "vs", "ops", "DS", "ls", "powers", "ns", "reads", "ges", "acs", "KS", "ke", "ms", "acts", "rows", "inks", "ps", "k", "ck", "ds", "akes", "ches", "works", "acks", "CS", "se", "cs", "checks", "opens", "qs", "fs", "hs", "rs", "es", "co", "ko", "ips", "icks", "orks", "bs", "ss", "kies", "ctx", "ki", "ics", "cks"], "key": ["base", "service", "trust", "point", "keys", "ca", "cache", "pair", "ke", "court", "read", "code", "c", "pe", "state", "k", "p", "type", "io", "sign", "ce", "client", "secret", "ssl", "co", "ring", "server", "user", "file", "seed", "transfer", "char", "lock", "value", "Key", "ki", "pg", "ee"], "chain": ["enc", "rule", "image", "base", "box", "Chain", "root", "chains", "coll", "sequence", "wheel", "none", "circle", "cache", "pair", "stack", "table", "list", "slice", "object", "set", "scale", "c", "code", "store", "collection", "crypt", "family", "path", "wrap", "container", "network", "secret", "block", "range", "file", "lock", "mc", "config", "cr"], "os": ["ou", "o", "options", "ops", "osi", "bos", "ms", "object", "pos", "ps", "outs", "op", "p", "ds", "io", "ros", "Os", "oid", "oss", "fs", "opens", "is", "cos", "rs", "iso", "es", " o", " bos", "oses", "ot", "ob", "ol", "ios", "OS", "res", "los", "aos", "rss", "s"], "stamper": ["stample", " nostameper", "_", " nostamper", "spAMper", "this", "stammpe", "function", " nostamler", "starmpper", "spAMmer", "starmper", "stAMpe", "stamepper", "stameper", "stameler", "stammer", "streammer", "spammer", "spampe", "stammmer", "stameple", "g", "stammple", "stammper", "path", "stampper", "stAMmer", "spAMpe", "starmple", "stamler", " nostamepper", "streamler", "spAMler", "streampe", "spamler", "stAMler", " nostameler", "spamper", "stampe", "stAMper", "data", "stammler", "streamper", "starmler", "stammpper", " nostameple", " nostample", " nostampper", "s"], "appearance": ["feedointment", " appence", " appfacing", "Appearing", " appear", " appears", "appaser", "appfacing", "askence", "installear", "installasion", "askeared", " appismo", "atteared", " appeared", "appismo", "attence", "byearing", "signear", "askfacing", "signfacing", "feedfacing", "suppear", " applier", "ppearing", "appasion", "byismo", "installearing", "suppointment", "appeared", "byear", "formearing", "feedear", " appearing", "byearance", "attearance", "installearance", "attfacing", "formaser", "suppasion", "ppear", "signearing", "suppearing", "appointment", "formearance", "formear", "askearance", "Applier", "Appearance", "signlier", "signears", "signointment", "Appears", "suppearance", "feedearance", "appence", "ppearance", "applier", "appearing", "formismo", "ppaser", "ppasion", "suppfacing", " appaser", "appear", "appears", "signearance"]}}
{"id1": "19849797", "id2": "17773263", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 0, "substitutes": {"copyFile": ["clonefile", "copyFiles", "transferfile", "copySource", "cloneFiles", "transferSource", " copySource", "transferFiles", " copyfile", "cloneSource", "transferFile", "copyfile", "cloneFile", " copyFiles"], "sourceFile": [" sourceDir", "ourceDirectory", "sourceUrl", "ourceUrl", "srcDir", "srcFile", " sourceFolder", "sourceFolder", "ourceFile", "SourceUrl", "srcfile", " sourcefile", "destfile", "SourceDirectory", "SourceFile", "ourcefile", "sourcefile", "sourceDirectory", "srcFolder", "destUrl", "Sourcefile", "SourceFolder", "destDirectory", "sourceDir", "SourceDir"], "destFile": ["destFiles", "targetFiles", "sourceFiles", "resultDir", "destLine", "DestFiles", " destfile", "destDir", "destPoint", "DestDirectory", "resultfile", "Destfile", "srcFile", "srcDir", "targetDir", "targetFile", "foreignFile", "srcfile", "foreignPath", "DestFile", "destPath", "targetfile", "DestPoint", "destfile", "targetLine", " destFiles", "targetPath", "foreignFiles", "resultFile", "DestDir", " destPoint", "foreignfile", " destDir", "srcDirectory", " destDirectory", "DestPath", "resultLine", "sourcePoint", "destDirectory", "srcFiles", "sourceDir", "srcLine"], "source": ["ource", "slave", "url", "result", "client", "reader", "cache", "status", "scope", "output", "site", "use", "id", "view", "current", "proxy", "scene", "index", "input", "target", "session", "start", "context", "core", "seed", "remote", "stream", "inner", "secure", "image", "Source", "this", "si", "storage", "component", "reference", "connection", "ie", "root", "route", "null", "object", "parent", "sin", "dest", "config", "slice", "table", "uri", "service", "resource", "api", "wrapper", "iter", "get", "from", "channel", "file", "server", "src", "unit", "size", "manager", "ce", "SOURCE"], "destination": ["participinate", "destinator", "generination", "Destinated", "dominated", "constinator", "identination", "distination", "construction", "distion", "participinator", "Destination", "domination", " destribution", "constribution", "domation", "Destribution", "Destruction", "destribution", " destinator", "destation", "Destation", "generruction", "destion", "identinator", "destinate", " destruction", "participinated", " destinated", " destation", "destinated", "participination", "distruction", "destruction", "dominator", "distinated", "distinator", "Destion", " destion", "Destinate", "constination", "generinator", "identinate", "generinated", "Destinator", "identinated"]}}
{"id1": "11556231", "id2": "12766394", "code1": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 0, "substitutes": {"ByURL": ["CreateURL", "ByURI", "BySSL", "CreateUrl", "CreateSSL", "createURL", "byURL", "createURI", "byUrl", "byURI", "bySSL", "CreateURI", "createSSL", "ByUrl", "createUrl"], "urlstr": ["URLStr", "httpStr", "urlStr", "UrlStr", "URLname", "urlSTR", "httpstring", "Urlstr", "UrlSTR", "URLstring", "urlname", "Urlname", "Urlstring", "URLstr", "httpSTR", "urlstring", " urlname", "httpstr", " urlSTR", "URLSTR", " urlstring"], "uri": ["qi", "address", "base", "description", "absolute", "id", "io", "URL", "iri", "path", "Url", "filename", "location", "string", "ui", "host", " URI", "domain", "image", "prefix", "database", "username", "type", "i", "route", "directory", "text", "direction", "query", "ri", "attribute", "resource", "URI", "http", "href", "server", "file", "collection", "manager", "pi"], "url": ["address", "base", "client", "system", "id", "feed", "URL", "proxy", "path", "sl", "Url", "session", "location", "conn", "string", "li", "host", "stream", "image", "link", "ssl", "user", "loc", "loader", "service", "resource", "http", "l", "page", "channel", "file", "server", "download", "web", "f"], "connection": ["client", "system", "connected", "io", "URL", "connect", "conn", "context", "stream", "c", "database", "or", "writer", "i", "Connection", "application", "directory", "body", "handler", "socket", "resource", "http", "l", "channel", "server", "director", "con", "collection", "open", "control", "response", "relation"], "in": ["ins", "client", "IN", "login", "bin", "inc", "ini", "input", "connect", "out", "In", "s", "conn", "stream", "inner", "cms", "c", "or", "a", "i", "r", "writer", "socket", "inn", "lin", "init", "kin", "and", "con", "ac", "as", "f"], "reader": ["result", "ais", "client", "io", "ini", "row", "input", "er", "ler", "out", "conn", "stream", "inner", "read", "Reader", "or", "writer", "i", "r", "handler", "loader", "buffer", "iter", "resource", "parser", "wrapper", "rc", "server", "channel", "entry", "reading"], "is": ["im", "serv", "ais", "ins", "ai", "sr", "iso", "has", "isa", "io", "was", "iri", "IS", "bis", "Is", "conn", "out", "s", "ui", "ris", "cms", "ci", "err", "isl", "si", "iss", "ios", "os", "nis", "or", "i", "info", "lis", "isi", "ri", "fs", "iris", "src", "rss", "sp", "as", "rs", "mis"], "document": ["result", "output", "xml", "docs", "node", "doc", "database", "m", "element", "writer", "class", "application", " documents", "object", "parent", "root", " documentation", "config", "graph", "Document", "message", "ocument", "resource", "content", "collection", "Documents", "response"], "source": ["container", "input", "node", "context", "string", "language", "stream", "driver", "Source", "element", "info", "class", "object", "text", "parent", "parser", "service", "resource", "content", "file", "src", "instance", "unit", "SOURCE"], "name": ["base", "description", "id", "Name", "node", "filename", "location", "string", "word", "named", "domain", "prefix", "format", "type", "element", "info", "definition", "root", "object", "NAME", "text", "parent", "tag", "attribute", "property", "resource", "URI", "key", "file", "instance", "value", "names", "comment"], "namespaceURI": ["namesferenceuri", "namespaceNS", "NamespaceURI", "namesheetURI", "namesferenceMI", "namespacedGI", "NamespaceMI", "namesistenceFINE", "nameservinguri", "namespacedNS", "namespaceGI", "Namespacesuri", "NamespacesMI", "namesheeturi", "namesistenceuri", "namespacesFINE", "namespacesURI", "namespacesMI", "namespaceFINE", "namesistenceURI", "namespacedURI", "perspacedGI", "Namespaceuri", "namespaceuri", "perspaceuri", "namesferenceURI", "namespaceduri", "NamespacesURI", "namespaceMI", "namesheetGI", "NamespaceNS", "nameservingNS", "NamespacesFINE", "NamespaceFINE", "namespacesuri", "perspacedURI", "perspaceURI", "perspaceGI", "namesferenceFINE", "perspaceduri", "nameservingURI", "namesistenceMI"], "qualifiedName": ["qualifiedURI", " qualifiedPath", "qualifiedType", "localname", "qualname", "localPath", "qualifiedname", "qualURI", "fixedPath", "fixedName", "fixedname", "qualifiedPath", "simplename", "qualName", " qualifiedURI", " qualifiedType", " qualifiedname", "simpleURI", "simplePath", "localType", "simpleName", "qualPath", "fixedType"], "data": ["template", "base", "ata", "description", "str", "output", "id", "child", "model", "DATA", "xml", "default", "input", "node", "string", "context", "language", "stream", "doc", "comments", "format", "element", "type", "info", "def", "class", "definition", "number", "text", "object", "body", "parent", "config", "message", "buffer", "resource", "property", "media", "content", "value", "script", "NAME"], "tagName": [" tagClass", "localClass", "tagClass", "localname", "TagName", "Tagname", "TagClass"], "target": ["template", "address", "base", "prop", "path", "label", "host", "location", "node", "domain", "next", "format", "Target", "component", "info", "method", "root", "class", "object", "parent", "head", "resource", "property", "href", "instance", "uid", "NAME"], "elementId": [" elementID", "nodeId", "nodeid", "elementid", " elementTag", "elementID", " elementid", "objectTag", "elementTag", "objectid", "nodeTag", "objectId", "objectID", "nodeID"], "tagname": ["className", " tagNAME", "classNAME", "tagNAME", "TagName", "Tagname", "classname", "TagNAME"], "localName": ["qualifiedNAME", " localNAME", "qualifiedname", "clientName", "clientname", "localname", "localNAME", " localname", "clientNAME"]}}
{"id1": "12678045", "id2": "22625683", "code1": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static Model downloadModel(String url) {\n        Model model = ModelFactory.createDefaultModel();\n        try {\n            URLConnection connection = new URL(url).openConnection();\n            if (connection instanceof HttpURLConnection) {\n                HttpURLConnection httpConnection = (HttpURLConnection) connection;\n                httpConnection.setRequestProperty(\"Accept\", \"application/rdf+xml, */*;q=.1\");\n                httpConnection.setRequestProperty(\"Accept-Language\", \"en\");\n            }\n            InputStream in = connection.getInputStream();\n            model.read(in, url);\n            in.close();\n            return model;\n        } catch (MalformedURLException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            cat.debug(\"Unable to download model from \" + url, e);\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"addQDInformation": ["addKdDirectory", "addQDSInformation", "addKDDirectory", "addQDMInformation", "addQdinformation", "addQdInformation", "addQdDirectory", "addKDinformation", "addQdInfo", "addQDMDirectory", "addQDSinformation", "addQDSInfo", "addKDInfo", "addQDinformation", "addKdInformation", "addQDMInfo", "addQDSDirectory", "addKdinformation", "addKDInformation", "addQDMinformation", "addQDDirectory", "addKdInfo", "addQDInfo"], "qdDate": [" qfDate", "qdAge", "qdxDate", "qtDate", " qfStatus", "qtDay", "qdtDate", "qdatTime", " qdData", "qfFile", "qdatDay", "qdVal", "qcDay", "sqdType", "qsModule", " qtDay", "qdyStatus", "qdtTime", "sqpVal", "qdxVal", "qdyTime", "qsTime", "qfStatus", "sqdDate", "qdxType", "qsName", "qdTime", "qdModule", " qsTime", "sqpName", "qdName", "qdyData", "qsDate", "qtStatus", "qtFile", "qdyName", "qidType", "qdtModule", "sqpDate", "qdxName", "qidVal", "qdatAge", "qcTime", "qfDate", "qidName", "qtTime", " qdName", " qdModule", "qcAge", "qdatDate", " qsDate", "qfData", "sqdName", " qtTime", "qtAge", "qdtName", "qcDate", " qdStatus", "qidDate", " qfData", "qpType", "qtData", "qdyDate", "qdType", "qdDay", " qdAge", "qdStatus", "qdyModule", "sqpType", " qtAge", "qpName", " qfFile", " qsModule", "sqdVal", "qdyFile", " qdTime", " qtDate", " qdDay", "qdData", "qpDate", " qsName", "qpVal"], "qdFile": ["qddDir", "sqdDir", "qdsInfo", "qdDir", "qfFolder", " qdFiles", "qdsfile", "sqdsDir", " qfDir", "qdxReader", "sqdsfile", " qdDir", "qdxFile", " qdInfo", "qdfile", "sqdReader", "qdsLog", "qdLog", " qfFile", "qdFiles", " qdsFile", " qdsLog", "qddInfo", "qdsDir", "qddFile", "qdsFolder", "sqdfile", "qfDir", "qdInfo", "qdxfile", "qdsReader", "qfLog", "qfFile", " qdsFolder", " qfBuffer", "qdsFile", "qdaFiles", " qdFolder", "qfInfo", "qdxDir", "qdaFile", "sqdFile", "sqdsFile", "qdFolder", "qdBuffer", "qdsBuffer", "qsFile", "qdReader", "qsDir", "qsfile", "qsReader", " qdBuffer", "qfFiles", "qddBuffer", "qdaLog", " qdsFiles", " qdLog", " qfInfo", "qdaFolder", "sqdsReader", "qdsFiles", "qfBuffer"], "_qdFileDate": ["_qndTimeDesign", "_qdcfileUpdate", "_qdcFileStatus", "_qdTimeDesign", "_qdDirectoryDesign", "_qdfileDesign", "_qdBaseStatus", "_qdBaseUpdate", "_qdFileName", "_qdTimeDate", "_qdDirectoryDate", "_qdcfileStatus", "_qdcFileDate", "_qdMinName", "_qdFileUpdate", "_qndTimeStatus", "_qndFileDate", "_qdMinUpdate", "_qdcfileName", "_qndFileStatus", "_qdFileDesign", "_qndTimeDate", "_qdTimeStatus", "_qdFiledate", "_qndFileDesign", "_qdDirectorydate", "_qdfileName", "_qdMinDate", "_qdcFileName", "_qdcFileUpdate", "_qdBaseDate", "_qdDirectoryStatus", "_qdMinStatus", "_qdfiledate", "_qdfileUpdate", "_qndTimedate", "_qdFileStatus", "_qdfileStatus", "_qndFiledate", "_qdcfileDate", "_qdfileDate", "_qdTimedate", "_qdBaseName"], "ii": ["uni", "uri", "ni", "ai", "gi", "ix", "ori", "ei", "i", "vi", "ie", "image", "ci", "oe", "ind", "yi", "abi", "ini", "chi", "ice", "vid", " iii", "iii", "iu", "bi", "si", "inf", "II", "ou", "mini", "ui", "pi", "oi", "ji", "index", "li", "ih", "iri", "hi", "di", "qi", "qa", "jp", "lu", "eni", "xi", "fi", "que", "id", "zi", "ti", " i"], "info": ["kid", "ref", "init", "information", "py", "f", "home", "gi", "buff", "alias", "archive", "extra", "link", "txt", "i", "INFO", "data", "abi", "object", "af", "comment", "prev", "job", "fo", "inf", "name", "b", "fw", "ext", "obj", "ui", "conf", "child", "api", "opt", "li", "h", "di", "Info", "qa", "handler", "def", "off", "bug", "part", "feed", "ignore", "entry", "id", "fam", "op", "end", "error", "hi"], "_qdValue": ["_qdsData", "_qdcName", "_sqdcInfo", "_sqdcData", "_qdsName", "_qdcInfo", "_sqdValue", "_qdData", "_qdcValue", "_qdsValue", "_qDInfo", "_qdsInfo", "_sqdInfo", "_qdcData", "_sqdcName", "_sqdcValue", "_qdName", "_qDName", "_qDValue", "_qDData", "_sqdData", "_sqdName", "_qdInfo"], "reader": ["source", "buffer", "result", "re", "uri", "client", "reading", "inner", "author", "f", "rr", "rar", "ler", "per", "driver", "input", "manager", "or", "read", "loader", "writer", "data", "service", "resource", "ger", "io", "rer", "server", "fd", "player", "dr", "rc", "worker", "handler", "parser", "Reader", "iter", "row", "r", "er", "feed", "entry", "ri", "report", "library", "http"], "urlName": ["uriInfo", "UrlArea", " urlPart", "UrlName", "URLPart", "Urlname", "URLString", "urlKey", "URLname", "urlname", " urlFamily", "uriFamily", " urlname", "UrlInfo", "urlFamily", " urlKey", "webFamily", "webInfo", "uriName", "UrlFile", " urlString", "webName", "URLInfo", " urlArea", "URLKey", "urlString", "UrlPart", "URLName", "urlFile", "URLArea", " urlFile", "URLFile", "urlPart", "urlArea", "UrlString", "UrlKey", "urlInfo", " urlInfo"], "url": ["source", "gl", "buffer", "uri", "large", "browser", " URL", "path", "Url", "f", "ball", "page", "l", "socket", "data", "web", "resource", "open", "director", "www", "base", "name", "bel", "server", "host", "URL", "sl", "address", "string", "connection", "channel", "pull", "ssl", "feed", "r", "user", "http"], "stream": ["source", "form", "buffer", "ream", "out", "client", "flash", "download", "f", "s", "view", "driver", "per", "input", "trans", "socket", "control", "draft", "data", "writer", "in", "resource", "open", "io", "zip", "sl", "Stream", "channel", "handler", "coll", "raw", "row", "r", "response", "feed", "user", "v", "oper", "http"], "file": ["source", "buffer", "File", "fp", "parse", "f", "page", "use", "ile", "l", "socket", "data", "writer", "loader", "folder", "object", "resource", "io", "log", "b", "server", "files", "book", "body", "lock", "handler", "part", "r", "feed", "user", " File", "db", "handle", "report", "http"], "line": ["text", "message", "column", "look", "buffer", "parse", "day", "strip", "comment", "base", "name", "log", "pe", "header", "rule", "LINE", "key", "entry", "section", "error", "lf", "sync", "pin", "home", "one", "word", "inline", "item", "data", "force", "job", "phase", "lc", "split", "lin", "range", "user", "style", "Line", "lines", "str", "lo", "link", "cle", "single", "definition", "nl", "shell", "limit", "cr", "side", "string", "block", "response", "status", "no", "se", "cell", "frame", "page", "pass", " Line", "l", "band", "ge", "letter", "body", "connection", "cl", "el", "part", "row", "le"], "_qdDate": ["_qdsYear", "_QdMonth", "_qdNumber", "_qndMonth", "_qfDate", "_qndTime", "_QdTime", "_sqdcDate", "_sqdcData", "_sqdsData", "_qdcDat", "_QdDate", "_qndDate", "_qdData", "_QdsDat", "_sqdsNumber", "_sqdDate", "_qdYear", "_qdcDay", "_qcdNumber", "_qdsTime", "_qdTime", "_sqdcDay", "_sqdsYear", "_sqdYear", "_qdsMonth", "_qdMonth", "_qndData", "_qdcDate", "_sqdsDate", "_qfData", "_qdsDat", "_QdDat", "_qcdDate", "_qdcData", "_qdDay", "_qdDat", "_qcdYear", "_qfDay", "_sqdNumber", "_qdsNumber", "_qdcTime", "_qfTime", "_QdsMonth", "_qdsDate", "_sqdcTime", "_sqdTime", "_qdcMonth", "_QdsDate", "_qndDat", "_sqdData", "_sqdDay", "_qndYear", "_qndNumber", "_qdsDay", "_qcdData", "_QdsTime", "_qdsData"], "pos": ["p", "x", "position", "ps", "pt", "prop", "port", "length", "push", " position", "point", "all", "len", "pl", "pass", "i", "po", "Pos", "down", "val", "loc", "in", "open", "act", "nos", "pose", "n", "next", "axis", "limit", "no", "os", "col", "spec", "post", "mid", "min", "index", "sp", "neg", "j", "POS", "size", "dev", "pres", "pr", "block", "sort", "pid", "off", "part", "pull", "end", "o", "unit", "type", "start", "doc", "offset", "rel"], "projectNum": ["productFamily", "componentNumber", "componentHash", "productNumber", "taskLen", " projectHash", "productNum", "projectName", " projectNumber", "ProjectName", "ProjectNumber", " projectLen", "taskName", " projectFamily", "componentFamily", "taskNumber", "ProjectNum", " projectName", "productHash", "projectNumber", "taskNum", "ProjectLen", "projectLen", "projectHash", "projectFamily", "componentNum"], "value": ["vector", "message", "group", "result", "Value", "feature", "amount", "project", "val", "data", "object", "resource", "description", "values", "name", "number", "profile", "range", "scale", "trial", "version", "key", "response", "type", "v", "target", "price"]}}
{"id1": "2668634", "id2": "10795866", "code1": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "code2": "    public String upload() {\n        System.out.println(imgFile);\n        String destDir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\map_bg.jpg\";\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(new File(destDir));\n            IOUtils.copy(new FileInputStream(imgFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"show\";\n    }\n", "label": 1, "substitutes": {"inputName": [" inputFile", "imagename", "inputFile", " inputname", "InputPath", "inputAddress", "imageFile", " inputPath", "outputUrl", "inputname", "InputFile", "InputUrl", "InputName", "inputPath", " inputUrl", " inputAddress", "imageName", "imageAddress", "Inputname", "inputUrl", "InputAddress", "outputFile", "outputPath"], "outputName": [" outputname", "OutputFile", " outputDir", "outputDir", "OutputPath", "inputDir", "inputFile", "applicationPath", "applicationFile", "OutputDir", "outputname", "inputPath", "applicationname", "OutputName", "applicationDir", "Outputname", " outputFile", "applicationName", "outputFile", "outputPath"], "stripLoggers": [" striplogger", "striplogging", "stripDebugger", " striplogging", "stripLogging", "stripDebugters", "stripColger", "stripColgers", "stripColters", "stripLogters", "striploggers", " stripLogging", " stripLogger", "striplogters", "stripColging", " striploggers", "stripLogger", " stripLogters", "stripDebuggers", "striplogger", " striplogters", "stripDebugging"], "tempFile": ["poraryFiles", "poraryfile", "TempFiles", "tempMessage", " tempStream", "inputDir", "tmpDir", "TempMessage", "inputFile", " tempDir", "TempFile", " temporaryfile", "inputPage", "TempDir", "tempDir", "tempPage", "tmpFile", " temporaryFile", " temporaryStream", " tempMessage", " tempFiles", "tmpPage", "poraryMessage", "Tempfile", " tempPage", "poraryFile", "tempStream", "tempFiles", "tempfile", "tmpfile", "tmpFiles", " tempfile", " temporaryFiles", "TempStream", "inputfile"], "jin": ["su", "jp", "sit", "Mu", "gin", "thin", "din", "ja", "icer", "util", "hn", "bin", "jun", "fil", "zip", "zin", "Skin", "skin", "vin", "spin", "ini", "plugin", "Ru", "Intern", "hin", "john", "ln", "zon", "jing", "raf", "jan", "lib", "lu", "zn", " Jin", "nu", "sin", "jack", "pillar", "tin", "Kit", "NI", "nin", "nir", "Js", "Mos", "jen", "irin", "pin", "inx", "arin", "cli", "in", "lin", "cin", "jl", "cos", "kin", "ni", "rin", "NJ", "rio", "zik", "unin", "fen"], "jout": [" jouter", " jOut", "Jout", "JOut", "narray", "jetOut", "nOUT", " jarray", "nout", "ujouter", "jetarray", "jOUT", "ujOut", "Jouter", "ujout", "nOut", "jOut", "jetout", "jouter", " jOUT", "jetOUT", "jarray"], "srcChannel": ["sourceCh", "sourceChan", "srcChan", " srcCh", "rcCh", "rcchannel", "srcchannel", "sourceChannel", "sourcechannel", " srcChan", " srcchannel", "rcChannel", "srcCh", "rcChan"], "dstChannel": [" dstCh", "dndChan", " dstChan", "ddestChannel", "ddestCh", "dspCh", "dstCh", "dndchannel", " ddestCh", "dndChannel", "ddestchannel", "dstchannel", " ddestChan", "ddestChan", " ddestChannel", "dspChannel", " ddestchannel", "dspchannel", "dspChan", "dstChan", "dndCh", " dstchannel"], "portletApplicationName": ["portletApplicationsInfo", "portletAppPath", "portalPlatformPath", "portalApplicationType", "portletAppType", "portletPlatformCode", "portletAppUrl", "portletsApplicationPath", "portletapplicationUrl", "portletsApplicationInfo", "portletPlatformName", "portletApplicationCode", "portletApplicationsPath", "portalPlatformName", "portletAppName", "portletPlatformUrl", "portletsAppPath", "portalApplicationUrl", "portletApplicationsName", "portletapplicationName", "portletsApplicationCode", "portalPlatformUrl", "portletAppCode", "portletApplicationsCode", "portletapplicationType", "portletPlatformPath", "portletPlatformType", "portletApplicationUrl", "portletAppInfo", "portletApplicationPath", "portalApplicationName", "portalPlatformType", "portletapplicationPath", "portletPlatformInfo", "portletApplicationType", "portletsAppInfo", "portletsAppCode", "portletApplicationInfo", "portletsAppName", "portletsApplicationName", "portalApplicationPath"], "webXml": ["webHiel", "webxml", "webWorkaml", " webXaml", "webXxml", "webEcpl", "webHml", " webXxml", "webCrossul", "webXli", "webXaml", "webxML", "contextXML", "webCrossml", "contextCrossML", "webxlass", "contextClass", "webWorkML", "webXMxml", "webXlass", "webEciel", "webXiel", "webClass", "webHML", " webXMxml", "webWorkxml", "webXMML", "contextCML", "contextCml", "contextCxml", " webXMml", "webXML", "webEcML", "webWorkli", "webxxml", "webXMaml", "contextXlass", "contextCrossml", "contextXul", "webCrossli", "webCxml", " webXMaml", "webXpl", "webHpl", "WebXML", "webXMml", "contextCrossul", "webEcml", "webXul", "WebXMml", "webXMpl", " webXMML", "contextXxml", " webXML", "WebXMpl", "WebXml", "contextXli", "WebXpl", "contextCrossli", "WebXMiel", "webCML", "webxaml", "webCml", "webCrossML", "WebXMML", "WebXiel", "webWorkul", "webXMiel", "webWorkml"], "portletXml": ["portletSyaml", "portletCML", "portletsYng", "portletXmal", "portfileHmos", "portletYmal", "portletsXML", "portletEML", "portletXMml", "portletxml", "portleXxml", "portletXaml", "portletSyml", "portleSyml", "portletYml", "portletEmal", "portletsYmal", "portfileHxml", "portletSyncml", "portleSyxml", "portletXMtml", "portletXng", "portletHxml", "portletXMML", "portletYng", "portletXMng", "portletHmos", "portletxML", "portletCmos", "portletSyncxml", "portfileXml", "portfileXML", "portleSytml", "portletsXml", "portletEml", "portletSytml", "portleXaml", "portletXMaml", "portfileXmos", "portletXmos", "portfileHML", "portletXxml", "portletXMxml", "portletsXng", "portletYML", "portletxxml", "portleXml", "portletsYml", "portletHml", "portletSyxml", "portletXMmal", "portletEng", "portfileHml", "portletXML", "portletHML", "portletCxml", "portfileXxml", "portletSyncaml", "portleSyaml", "portletsYML", "portletXtml", "portleXtml", "portletxmos", "portletSynctml", "portletCml", "portletsXmal"], "contextXml": ["contextUla", " contextXML", "contextHwl", "contextAxML", "conceptHwl", " contextXl", " contextAxl", "contextXl", "contextHml", "conceptHxml", "contextHxml", "contextXMaml", "contextXMxml", "contextXMwl", "contextExml", "contextxxml", "contextUl", "contextAxla", "contextExla", "contextXla", " contextAxla", "contextExML", "contextxwl", "conceptHml", " contextAxml", "contextUml", "conceptXwl", "contextXMml", "contextXML", "contextHaml", "conceptXxml", "contextxaml", "conceptXml", "conceptHaml", "contextXaml", "contextXwl", "contextAxl", "conceptXaml", " contextXla", "contextxml", "contextXxml", " contextAxML", "contextExl", "contextAxml", "contextUML"], "src": ["ource", "ser", "prot", "url", "sit", "result", "lit", "rest", "img", "st", "cont", "uc", "sup", "rel", "sr", "gb", "zip", "jar", "sub", "cur", "sl", "host", "secure", "obj", "s", "Source", "spec", "lower", "ruby", "comp", "ses", "sel", "username", "ssl", "ie", "i", "r", "sb", "sq", "sin", "dest", "rec", "config", "loc", "socket", "slice", "sync", "inst", "ri", "ur", "sn", "uri", "resource", "rb", "http", "rc", "in", "href", "entry", "sc", "bh", "dist", "gz", "req", "rin", "rss", "rl", "ctx", "rs", "SOURCE"], "source": ["ource", "fp", "url", "sit", "result", "thin", "reader", "client", "token", "gen", "sr", "scope", "status", "view", "e", "use", "zip", "proxy", "xml", "function", "sl", "input", "session", "start", "out", "string", "core", "secure", "stream", "inner", "driver", "context", "Source", "resources", "spec", "this", "comp", "storage", "reason", "component", "ie", "i", "connection", "null", "text", "parent", "sin", "handler", "slice", "ources", "loader", "uri", "service", "resource", "iter", "wrapper", "get", "from", "in", "form", "stack", "rc", "file", "channel", "kin", "sp", "unit", "size", "ce", "SOURCE"], "zipEntries": ["zipentries", "zipEnrations", "zipCurions", "zipEntions", "zipEndry", " zipEntrations", "ZipEntrys", "zipentrys", "zipEndlines", "sliceEntries", "zipIntegrations", "zipentions", "sliceEntresses", "sliceElines", "sliceEries", "zipIntegry", "zipEntrations", "zipEnrys", " zipEntrys", "zipCurries", " zipEntry", "sliceEresses", "zipCurlements", "zipElines", "zipEntry", "zipEries", "zipEnresses", "zipEnlines", "zipEresses", "zipEndresses", "zipEntrys", "zipCurrys", "zipIntegries", "sliceEntlines", "zipIntegrys", "ZipEntlements", "zipentlements", "zipEnries", "ZipEntries", "zipEntlements", "zipEntresses", "zipEndries", "sliceEry", "ZipEntions", "zipEntlines", "zipEnry", "zipEry", "sliceEntry"], "target": ["external", "template", "address", "arget", "project", "rel", "scope", "output", "site", "platform", "current", "wrong", "path", "goal", "remote", "filename", "host", "context", "name", "location", "top", "string", "hop", "flat", "tail", "prefix", "next", "format", "Target", "type", "component", "method", "class", "route", "object", "tag", "dest", "config", "loc", "nt", "resource", "it", "content", "feat", "href", "data", "file", "bh", "style", "match", "compatible", "value", "theme", "unit"], "webRewriter": [" webRewitcher", "webRewitcher", "New", " webrewriter", "webrewrite", "webReprite", " webrewitcher", "webReporter", "app", " webrewrite", "webResitcher", "webRepitcher", "_", "webreworter", "s", "webrewriter", "webrewitcher", "webResorter", "this", "webReworter", "application", "Entry", "webRewrite", "webResriter", " webRewrite", "http", "webRepriter", " webreworter", " webReworter", "webResrite"]}}
{"id1": "23398710", "id2": "14464131", "code1": "    public String getUser() {\n        try {\n            HttpGet get = new HttpGet(\"http://api.linkedin.com/v1/people/~\");\n            consumer.sign(get);\n            HttpClient client = new DefaultHttpClient();\n            HttpResponse response = client.execute(get);\n            if (response != null) {\n                int statusCode = response.getStatusLine().getStatusCode();\n                if (statusCode != 200) {\n                    this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n                }\n                StringBuffer sBuf = new StringBuffer();\n                String linea;\n                BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), \"UTF-8\"));\n                while ((linea = reader.readLine()) != null) {\n                    sBuf.append(linea);\n                }\n                reader.close();\n                response.getEntity().consumeContent();\n                get.abort();\n                String salida = sBuf.toString();\n                String user_firstname = salida.split(\"</first-name>\")[0].split(\"<first-name>\")[1];\n                String user_lastname = salida.split(\"</last-name>\")[0].split(\"<last-name>\")[1];\n                return user_firstname + \" \" + user_lastname;\n            }\n        } catch (UnsupportedEncodingException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (IOException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthMessageSignerException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthExpectationFailedException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthCommunicationException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        }\n        return null;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(\"http://hostname:80\");\n            URLConnection conn = url.openConnection();\n            for (int i = 0; ; i++) {\n                String headerName = conn.getHeaderFieldKey(i);\n                String headerValue = conn.getHeaderField(i);\n                if (headerName == null && headerValue == null) {\n                    break;\n                }\n                if (headerName == null) {\n                }\n            }\n        } catch (Exception e) {\n        }\n    }\n", "label": 0, "substitutes": {"getUser": ["getAccount", "getProfile", " getProfile", "createProfile", "createAccount", "newAccount", "newUser", "createUser", "getPerson", "createPerson", " getPerson", " getAccount", "newPerson", "newProfile"], "get": ["body", "method", "give", "model", "service", "resource", "create", "send", "got", "this", "view", "check", "cli", "json", "google", "open", "consumer", "find", "parse", "http", "cache", "remote", "api", "post", "object", "show", "update", "read", "set", "status", "c", "g", "token", "query", "single", "GET", "p", "it", "build", "v", "entity", "sign", "pull", "handle", "Get", "start", "init", "request", "ge", "call", "put", "i", "like", "url", "invoke"], "client": ["method", "service", "resource", "send", "this", "Client", "cli", "open", "channel", "consumer", "http", "output", "bird", "api", "conn", "session", "handler", "p", "control", "io", "result", "https", "console", "secure", "manager", "app", "ssl", "request", "con", "server", "call", "php", "connect", "i", "per", "contact", "connection", "web", "url", "copy"], "response": ["body", "image", "index", "service", "resource", "wave", "send", "feed", "site", "serv", "view", "Response", "json", "version", "offer", "http", "message", "output", "queue", "api", "writer", "respond", "full", "object", "page", "status", "application", "collection", "resp", "subject", "relation", "success", "handler", "successful", "result", "uri", "generation", "report", "tree", "received", "request", "server", "data", "document", "error", "results", "connection", "reply"], "statusCode": ["StatusCode", "statusC", "StatusC", "Statuscode", " statusC", " statusType", "successCode", "statusType", "responseCode", " statuscode", "responseType", "successC", "successcode", "successType", "StatusType", "statuscode"], "sBuf": ["sBBumb", "sBbuf", "sFuf", "sAuff", "sBBbuff", " sBbuff", "sBBuff", "sFuff", "sFumb", "sQbuf", "sFbuff", " sBuff", " sBlu", "sQumb", "sBlu", "sBeruf", "sBerbuf", " sBBuf", "sPlbuf", "sBerumb", "sBuff", "sFbuf", " sAbuf", " sFumb", " sAuff", "sAbuf", "sBerlu", " sAbuff", " sFuf", " sFbuf", "sBumb", "sPluf", "sQuf", " sBbuf", "sFlu", "sBbuff", "sBBbuf", " sAuf", "sPlumb", " sBBumb", "sAbuff", "sAuf", " sFlu", "sPllu", " sBumb", " sBBbuf", "sBBuf"], "linea": ["Lineas", "ideA", "linA", "lineva", " lineva", "lineas", "ideas", "Linea", " lineas", "Lineva", " lineha", "linas", "ideva", "linha", "lina", "lineha", "linva", "Lineha", "lineA", "LineA", "idea", " lineA"], "reader": ["right", "feed", "rx", "stream", "rer", "inner", "input", "player", "worker", "reading", "ler", "rar", "parser", "bird", "l", "writer", "upper", "read", "ri", "driver", "builder", "r", "buffer", "oder", "handler", "er", "line", "result", "io", "pointer", "rr", "row", "layer", "ner", "loader", "cher", "wrapper", "server", "data", "e", "ser", "Reader", "per", "i", "keeper", "iter", "f", "editor"], "salida": ["salanda", " salidas", "bilida", " salara", "Salido", "Salanda", "Salida", "Salidas", "salara", " salanda", "salidas", "satida", "milido", "salido", "milida", " salido", "milidas", "milanda", "slanda", "bilicka", "salicka", " salicka", "slida", "bilido", "satido", "slara", "bilara", "saticka", "Salara", "slidas", "satara"], "user_firstname": ["user_headname", "user_headphone", "user_realName", "user_realname", "user_firstame", "user_lastphone", "user_firstName", "user_thirdname", "user_fullame", "user_realnames", "user_fullnames", "user_fullName", "user_lastName", "user_firstnames", "user_lastame", "user_headame", "user_thirdphone", "user_fullname", "user_thirdame", "user_realame", "user_lastnames", "user_firstphone"], "user_lastname": ["user_firstame", "user_fullame", "user_longaddress", "user_lastaddress", "user_fullnames", "user_fulladdress", "user_fullName", "user_lastName", "user_pastaddress", "user_firstnames", "user_lastame", "user_lastword", "user_longName", "user_longname", "user_fullword", "user_fullname", "user_longame", "user_pastame", "user_firstword", "user_lastnames", "user_pastname", "user_pastName"]}}
{"id1": "4593011", "id2": "20275821", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"loadDDL": ["LoadCDE", "loadDDE", "loadODL", "LoadDDLL", "loadSDLL", "loadCDML", "loadSDE", "loadODLL", "loadCDL", "loadODML", "LoadDDML", "loadSDML", "LoadDDE", "loadDDLL", "loadODE", "LoadDDL", "LoadCDL", "LoadCDLL", "LoadCDML", "loadSDL", "loadDDML", "loadCDLL", "loadCDE"], "stmt": ["stm", "constm", "Stmd", " stm", " stmn", "Stmp", " sttr", " stgr", "sttt", "Stm", "STtr", "Sttt", "rm", "estmt", "rdb", "rmt", "rmd", "tmt", "constmt", "esttt", "tmd", "STmp", "estmd", "strgr", "Stdb", "stmd", " stdb", "constmn", "Stmb", " sttt", "estm", "tdb", "Stmn", "estmp", "stmr", "STmb", "strmt", "stpr", "stmn", "STgr", "tm", "STpr", "sttr", "Stmr", " stpr", "STmr", "constdb", "stmp", "Stmt", "STmt", "strpr", "stgr", "strtr", "stmb", "estmr", "estmb", " stmd", "stdb"], "qry": ["quri", "qries", "equry", " qury", "Qries", "quries", "qurys", "qrys", "eqRY", "Qry", "qRY", " qrys", "quury", "qury", "qri", " qri", " qries", "quRY", "eqry", " qRY", "Qri", "Qrys", "eqrys"], "q": ["v", "k", " p", "e", "id", "requ", "request", " query", "queue", "c", "Q", " sq", "t", "sq", "i", "r", "dq", "ql", "b", "iq", "n", "query", "config", "qq", " req", "qu", "p", "key", "qa", "ch", "qs", "eq", "qt", "d", "req", "quant", "quest", "select", "f"]}}
{"id1": "9096314", "id2": "15810440", "code1": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"handleNodeLostService": ["handleNodeUnknownService", "handleNodeUnknownServer", "handleNodeLostFunction", "handlenodelostService", "handleNodeErrorFunction", "handleNodeErrorService", "handlenodelostServer", "handlenodelostServices", "handlenodeLostServices", "handleNodelostService", "handlenodelostFunction", "handleNodeLostServices", "handleNodeErrorServer", "handlenodeLostFunction", "handleNodeUnknownServices", "handlenodeLostServer", "handleNodelostServices", "handleNodeUnknownFunction", "handlenodeLostService", "handleNodeErrorServices", "handleNodelostServer", "handleNodelostFunction", "handleNodeLostServer"], "eventID": ["eventid", "documentID", "nodeName", "EventName", "eventType", " eventId", " eventid", "sessionID", "documentId", " eventType", "nodeId", "resourceID", "sessionName", "EventID", "serviceId", "resourceid", "serviceName", "resourceName", " eventName", "eventId", "nodeType", "eventName", "EventId", "documentName", "resourceId", "sessionId", "nodeid", "EventType"], "nodeID": ["Nodeid", " nodeName", "eventid", "nodeName", "eventInfo", " nodeURL", " nodeInfo", " nodeId", "nodeURL", "objectName", "networkId", "nodeId", "resourceID", "networkID", "serviceId", "networkInfo", "serviceName", "resourceid", "resourceName", "objectid", "eventId", "NodeID", "objectId", " nodeid", "eventName", "NodeURL", "serviceid", "resourceId", "objectID", "eventURL", "nodeid", "nodeInfo", "NodeId"], "ipAddr": ["epaddr", "apiAddri", " ipAttrs", "apiAddrs", " ipAddri", "ipChl", "ipAddl", "apiAddr", "ipAddresso", "ipAtter", " ipChri", " ipAddrer", "epaddl", "apiAttr", "ipAttrs", "ipAttress", "ipAddrs", "apiAttrs", "ipAddressl", "ipAddresser", "ipAddp", "epAddl", " ipAddo", "ipAttrer", " ipAdder", "ipaddress", "ipChr", "ipaddri", "ipAttp", "ipAddressp", "ipAdder", "ipAtto", "ipAddressri", "ipChri", "apiAddp", "ipAttr", " ipAtter", "ipChrs", "ipaddl", "apiAttri", "epAddrs", "epAddrer", " ipAttr", "ipAddo", "ipaddr", " ipAtto", " ipAddrs", "ipAddressrs", "apiAttp", "ipAddrer", "epaddrer", "ipaddo", "ipAddress", "ipAddressr", " ipChrs", "ipAttri", "ipAddressrer", "epaddrs", "ipaddrer", "ipadder", " ipChrer", " ipChr", "ipChp", " ipAddress", "ipaddrs", "epAddr", "ipAddri", "ipChrer"], "serviceID": ["imageUID", "eventIDs", "ServiceId", "ServiceName", "networkid", "siteid", "roleIP", "eventid", "serviceIP", "featureID", "networkName", "roleId", "eventIP", "featureId", " serviceid", "eventType", "siteID", " serviceName", "ServiceType", "imageId", " serviceId", "siteIP", "networkId", "roleid", "serviceIDs", "roleID", "ServiceIDs", "networkID", "imageID", "ServiceIP", "featureUID", "serviceId", "serviceName", "ServiceID", "eventId", "serviceUID", " serviceIP", "eventName", "serviceType", " serviceType", "serviceid", "siteId", " serviceUID", " serviceIDs"], "eventTime": ["EventName", "serverName", " eventInfo", "EventInfo", "eventName", "EventTime", "serverInfo", "servertime", "serverTime", "eventtime", "Eventtime", " eventtime", " eventName", "eventInfo"], "log": ["model", "crit", "sec", "ger", "full", "class", "c", "job", "it", "Log", "ge", "call", "thread", "lex", "host", "f", "pool", "stop", "debug", "cl", "write", "cache", "output", "info", "cat", "contract", "where", "tool", "user", "lo", "error", "get", "reg", "pg", "base", "event", "entry", "exp", "use", "l", "LOG", "path", "type", "blog", "low", "gen", "level", "port", "lock", "put", "or", "tag", "guard", "db", "feed", "w", "net", "http", "key", "writer", "pe", "pl", "en", "stat", "plug", "sign", "loop", "bug", "proxy", "cell", "og", "config", "url"], "dbConn": [" dbSession", "DbDr", "databaseDr", "DBCs", "webCtrl", "sqlCo", "webNC", "Dbconn", "DBConn", "databaseConnection", "DBCt", " dbCt", "dbConnection", "dbColl", "dbCon", " dbConnection", "webCt", "logCtrl", " dbCo", "DbCt", "DbConn", "webConn", "DbCs", "DbSession", " dbconn", "dbconn", "databaseConn", "dbDr", "libconn", " dbCon", "libCon", "logColl", "DbCtrl", "dbSession", " dbDr", "DbConnection", " dbCs", "libConn", "DbConnect", "sqlConn", "DBConnect", "sqlSession", " dbNC", "DbCo", "dbCo", "sqlCtrl", "dbCtrl", "dbNC", " dbCtrl", "databaseconn", "libCt", "logConn", "DbColl", "sqlconn", " dbConnect", "sqlNC", "logConnect", "DbCon", "dbCt", "dbCs", " dbColl", "sqlCt", "dbConnect"], "getNextOutageIdStmt": ["getNextOutageIdCMT", "getNextOutageIdCnt", "getNextOutageIdSr", "getNextOutageIdRb", "getNextOutageIdstMT", "getNextOutageIdSnt", "getNextOutageIDStMT", "getNextOutageIdStr", "getNextOutageIdstr", "getNextOutageIdCmt", "getNextOutageIdstmt", "getNextOutageIdSMT", "getNextOutageIdstnt", "getNextOutageIdStnt", "getNextOutageIdSb", "getNextOutageIDSb", "getNextOutageIdRr", "getNextOutageIDStnt", "getNextOutageIDStb", "getNextOutageIdRmt", "getNextOutageIDSMT", "getNextOutageIdCr", "getNextOutageIDSnt", "getNextOutageIDStr", "getNextOutageIdRMT", "getNextOutageIDStmt", "getNextOutageIdCb", "getNextOutageIdStMT", "getNextOutageIdSmt", "getNextOutageIDSmt", "getNextOutageIDSr", "getNextOutageIdStb"], "outageID": ["outflowID", "inageId", "outagingName", "outrageID", "outrageHandle", "outagingId", "outagementName", "outAGEURL", "outAGEId", "outrageName", "outageId", "OutrageId", "inrageID", "outAGEName", "outageName", "inageURL", "OutageName", "outAGEID", "OutageId", "outAGESecret", "outrageId", "OutrageID", "outageHandle", "outageURL", "inrageURL", "outissueId", "inrageUID", "outageUID", "outagementId", "outagingSecret", "OutageHandle", "outrageSecret", "outagementHandle", "OutageSecret", "outissueURL", "outrageURL", "inrageId", "outissueUID", "outrageUID", "inageID", "inageUID", "OutrageName", "outflowId", "outagementID", "outagingID", "outflowName", "outflowHandle", "OutrageHandle", "OutrageSecret", "outageSecret", "outissueID", "OutageID", "outAGEUID"], "seqRS": ["structrs", "seqRC", "sqMR", "seqTS", "reqRL", "sequTS", "reqRR", " sequenceRS", "seqRT", " sequenceMR", " seqRT", "eqRR", "sequenceRS", "sequenceRs", "colRT", "seqMR", "colRR", "eqRs", "seqSR", "sequRL", "sqRC", "invRS", "sequRS", " sequenceRT", "invSR", "structRs", " seqMR", "reqTS", "reqRT", "seqRR", " seqTS", "seqrs", " sequenceRC", "reqRS", "seqRL", "sqRT", "structRS", "reqRs", "sequenceSR", " seqRL", "structSR", "eqRS", "invrs", "colRS", "sqRS", "invRs", "sequRC", "seqRs", "sequencers", "eqRT", "reqRC", " seqRC", "colRs"], "newOutageWriter": ["newOutpaceRW", "newOutagementWrit", "newOutpacewriter", "newExagewriter", "newoutageReader", "newOutflowWrit", "newOutlineReader", "newOutpointWrite", "newExlineReader", "newOutureInfo", "newOutageWrite", "newExageWrite", "newOutageWrit", "newOutrageRW", "newInageRW", "newOutageRW", "newOutissueWrite", "newExlineWriter", "newInflowWrite", "newoutureWriter", "newInageWriter", "newOutpaceWriter", "newOutlineWrite", "newInflowRW", "newoutageRW", "newOutrageWriter", "newoutageWriter", "newOutureWrite", "newOutagewriter", "newOutflowWriter", "newInageWrit", "newOutrageWrit", "newoutageInfo", "newOutagementRW", "newOutartWrite", "newoutageWrite", "newOutureReader", "newOutflowRW", "newOutartWriter", "newOutissueWriter", "newOutpointWriter", "newOutpointRW", "newOutflowInfo", "newOutageInfo", "newOutpaceReader", "newOutartInfo", "newExageReader", "newOutagementWrite", "newOutissuewriter", "newOutureRW", "newOutflowWrite", "newExageWriter", "newOutageReader", "newInageWrite", "newOutissueReader", "newOutartRW", "newoutureWrite", "newOuturewriter", "newOutflowReader", "newOutlineWriter", "newExlinewriter", "newOutrageWrite", "newouturewriter", "newExlineWrite", "newInflowWriter", "newOutagementWriter", "newOutflowwriter", "newoutureRW", "newoutureInfo", "newOutlinewriter", "newoutagewriter", "newOutureWriter", "newOutpointReader", "newoutureReader", "newInflowWrit"]}}
{"id1": "4593011", "id2": "3430784", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 0, "substitutes": {"loadDDL": ["LoadDDE", "loadSDLL", "loadDDML", "LoadCDL", "loadSDL", "loadODML", "loadCDE", "loadODL", "LoadCDE", "loadDDE", "loadCDLL", "loadSDE", "LoadCDML", "loadSDML", "LoadDDL", "loadDDLL", "LoadDDML", "loadCDL", "LoadCDLL", "loadCDML", "loadODLL", "loadODE", "LoadDDLL"], "stmt": ["strgr", "tm", "Stmn", "stpr", "rmt", "estmd", "tmd", "constm", "sttt", " stm", "esttt", "rdb", "Stdb", "STgr", "tmt", "strmt", " stmd", "tdb", "stmp", "Stmr", " sttt", "stm", " sttr", "STpr", "STmp", "Stmp", "STmt", "estmt", "sttr", "stmr", "strtr", "constmt", "Stmd", "estmp", "STmr", "rmd", "STmb", "stgr", "constmn", " stdb", "estmr", "STtr", " stgr", "constdb", "Stm", "Stmb", " stpr", " stmn", "rm", "stmn", "Sttt", "stmb", "stdb", "Stmt", "estm", "estmb", "stmd", "strpr"], "qry": [" qri", "qRY", "equry", "qries", "Qries", "qrys", "Qry", "quries", "quury", " qries", "eqry", " qRY", " qrys", "qri", "Qrys", " qury", "Qri", "quri", "quRY", "eqRY", "eqrys", "qurys", "qury"], "q": ["iq", "qt", "i", "qa", "id", "n", "c", "qu", "qs", "query", " query", "dq", "key", "queue", "req", "select", "d", "r", "ch", "eq", "ql", "qq", "config", "quant", "Q", " p", "request", "requ", "p", "sq", " sq", "e", "t", "quest", "k", "v", "b", " req", "f"]}}
{"id1": "6840241", "id2": "8788371", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["proxy", "write", "image", "server", "system", "cmp", "io", "sync", "loop", "clone", "clip", "type", "download", "process", "Copy", "create", "size", "slave", "ip", "mop", "load", "share", "cover", "transfer", "opy", "open", "cop"], "source": ["ink", "proxy", "e", "resource", "image", "se", "parent", "null", "server", "connection", "data", "this", "si", "session", "ie", "channel", "Source", "result", "input", "ources", "sin", "iter", "i", "src", "reader", "size", "stream", "target", "slave", "seed", "inner", "slice", "address", "ource", "handler", "start", "service", "SOURCE", "sp", "wrapper", "iterator", "use", "from", "rice"], "sink": ["sigh", "pinker", "dsink", "sinker", "dsinker", "sINK", "partsINK", "dsource", "tinker", "asinker", "pINK", "outsink", " sigh", "outsource", "Source", "outsigh", "tider", "Sinker", "pider", "pource", "Sink", "dsider", "tink", "asigh", "pink", "asource", "sider", "tource", " sinker", "partsinker", "SINK", "partsource", "asink", "partsink", "outsinker"]}}
{"id1": "12766394", "id2": "11562165", "code1": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 1, "substitutes": {"testReadHelloWorldTxt": ["testReadHelloWorldFxt", "testReadHelloWorldMxt", "testReadHelloWorldFext", "testReadHelloWordMext", "testReadHelloWordText", "testReadHelloWorldMtxt", "testReadHelloWorldMext", "testReadHelloWorldFXT", "testReadHelloWordTxt", "testReadHelloWordMXT", "testReadHelloWorldMXT", "testReadHelloWorldFtxt", "testReadHelloWordMxt", "testReadHelloWordMtxt", "testReadHelloWordTtxt", "testReadHelloWordTXT", "testReadHelloWorldTXT", "testReadHelloWorldTtxt", "testReadHelloWorldText"], "helloWorldIS": [" helloCityIR", " helloWorldIDE", "helloCommunityIDE", " helloWorldIR", "helloCityAS", "helloWorldIR", " helloWorldAS", "helloWorldIDE", " helloWorldis", " helloWorldIs", "helloCityIS", "helloCityIR", "helloWestAS", "helloCityIs", "helloWorldIs", "helloCommunityIS", "helloWestIS", "helloWestIs", "helloCommunityIs", "helloWorldAS", "helloWorldis", "helloCityis", " helloCityIS", " helloCityIs", "helloCityIDE", " helloCityAS", "helloWestIR"], "helloWorldPath": [" helloWorldpath", "hiWorldFile", "helloWorldCorp", "helloworldPATH", "helloCommunityPATH", "helloCommunitypath", "helloWorldLocation", "helloWorldFile", "helloWallName", "hiWorldUrl", "helloCommunityLocation", "hiWebpath", "helloCommunityPath", "officeCommunityPath", "officeWorldPath", "helloCommunityDir", "hiWorldPath", "helloWorldPATH", "helloWallpath", "officeCommunityPATH", "helloWallPath", "officeCommunityCorp", "helloworldCorp", "helloCommunityCorp", " helloWorldDir", "hiWebPath", "hiWorldpath", "helloWorldUrl", "helloWebFile", "helloWebUrl", "officeCommunityLocation", "officeWorldCorp", "helloWebpath", "hiWebFile", "helloWebPath", "officeWorldPATH", "helloWallDir", "helloworldLocation", "helloworldPath", " helloWorldName", "helloWorldDir", "helloWorldName", "officeWorldLocation", "helloWorldpath", "hiWebUrl", "helloCommunityName"], "fileOutputStream": ["fileWriteSteam", "resourceOutputSteam", "FileInputHandler", "FileOutputFile", "fileInputSteam", "fileoutputStream", "FileOutputSteam", "fileOutputHandler", "fileWritePath", "FileInputFile", "resourceOutputFile", "resourceInputFile", "fileWritestream", "fileWriteFile", "FileInputSteam", "resourceInputPath", "FileInputstream", "fileOutputPath", "fileOutSteam", "resourceInputStream", "fileInputFile", "fileInputHandler", "fileOutPath", "fileOutputSteam", "fileOutStream", "resourceOutputPath", "FileOutputStream", "fileoutputSteam", "fileWriteStream", "fileOutFile", "resourceInputSteam", "FileOutputHandler", "fileoutputHandler", "fileOutputstream", "resourceOutputStream", "fileInputStream", "fileoutputstream", "fileOutputFile", "FileOutputstream", "FileInputStream", "fileInputPath", "fileInputstream"], "contentResolver": [" contentresolver", "contentResponseistor", "contentRolution", "contentResolves", "contentReslier", "contentAbsoser", "contentRevolved", "contentRlier", "resourceRolved", "messageResolve", "contentResponseolved", "contentRevolution", "contentResoser", "resourceResolver", " contentRevolver", " contentResolves", "contentResolution", " contentresolve", "contentAbsolver", "contentResistor", "contentresolution", "ContentRoser", "contentResultolution", "ContentResolving", "messageResultolve", "contentRevolver", "contentResolving", "messageReslier", "resourceResolve", "contentRolve", "contentResultolve", "ContentResolve", "contentAbsolve", "contentRolves", "contentRolver", "contentRolved", "resourceRolve", "resourceRolution", "contentresolve", "contentRevolve", "messageResultlier", "contentresolving", "contentreslier", "ContentResoser", "contentResolve", "ContentRolve", " contentRevolve", "messageResultolver", "contentresolver", "ContentRolution", " contentRevolved", "resourceRolver", "contentresolved", "resourceResolved", "contentResultistor", "ContentResolver", "contentResultolved", "contentAbsolution", " contentresolves", "contentRevistor", "ContentRolving", " contentResistor", "resourceResolution", "contentResolved", " contentResolved", "contentRoser", " contentRevistor", "contentRevolves", "messageResolver", "contentResultolver", "contentResponseolver", "messageResolution", " contentResolution", "ContentResolution", "contentResultlier", "contentRolving", "ContentRolver", "contentresolves", "messageResultolution", "contentResponseolve", " contentResolve", " contentresolution"], "content": ["next", "image", "job", "size", "children", "script", "html", "full", "Content", "current", "output", "default", "comment", "load", "feed", "java", "handle", "title", "version", "write", "copy", "parent", "page", "css", "lc", "core", "json", "cache", "address", "valid", "ontent", "example", "conn", "complete", "server", "result", "child", "code", "media", "connection", "ext", "message", "resource", "path", "response", "word", "xml", "work", "value", "fill", "file", "url", "model", "update", "data", "temp", "activity", "status", "any", "text", "document", "name", "password", "body", "string", "header", "column", "play", "cont", "empty", "read", "draft", "layer", "config"]}}
{"id1": "21488518", "id2": "13783549", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"createNew": ["openResource", "createCopy", "openNew", "newNew", "openOpen", "createResource", "resourceCopy", "resourceResource", "newOpen", "newResource", "newCopy", "resourceNew", "openCopy", "resourceOpen", "createOpen"], "name": ["image", "client", "self", "large", "size", "one", "n", "full", "key", "class", "old", "label", "comment", "default", "common", "ix", "title", "parent", "e", "id", "office", "directory", "on", "address", "ame", "ui", "alias", "connection", "code", "content", "time", "path", "resource", "ext", "word", "value", "file", "part", "NAME", "end", "x", "url", "prefix", "no", "none", "base", "model", "data", "type", "missing", "Name", "number", "search", "names", "anc", "member", "style", "string", "ename", "named", "folder", "non", "current", "filename", "username"], "in": ["image", "buffer", "size", "src", "i", "init", "input", "slice", "thin", "id", "din", "plus", "diff", "connection", "inner", "resource", "ini", "raw", "file", "work", "con", "len", "pass", "exec", "login", "data", "ins", "record", "bin", "In", "reader", "IN", "read", "win", "source", "up", "inc"], "length": ["timeout", "buffer", "level", "size", "bytes", "load", "sequence", "ength", "id", "limit", "padding", "Length", "content", "path", "time", "line", "count", "len", "url", "type", "offset", "number", "width", "password", "body", "duration", "filename"], "contentType": ["ContentLength", "contentPath", "resourceLength", " contenttype", "resourceType", "contenttype", " contentLength", "ContentType", "resourcePath", "Contenttype", "contentLength", "resourcetype", " contentPath", "ContentPath"], "dest": ["de", "tx", "upload", "src", "output", "tmp", "comb", "opt", "parent", "thin", "route", "home", "Dest", "target", "result", "dc", "desc", "orig", "later", "img", "conf", "sup", "cdn", "dist", "store", "dir", "trip", "wb", "zip", "temp", "flat", "trans", "done", "transform", " destination", "d", "prop", "folder", "destroy", "gz", "cont", "tif", "source", "config", "txt"], "out": ["Out", "image", "client", "writer", "buffer", "obj", "sync", "up", "output", "socket", "object", "view", "copy", "parent", "ex", "page", "cache", "server", "conn", "result", "connection", "exp", "path", "resource", "ext", "io", "pool", "img", "line", "file", "f", "url", "o", "null", "this", "exec", "zip", "channel", "data", "temp", "err", "log", "bin", "password", "again", "outs", "lock", "cmd", "gz", "flush", "source", "OUT"], "request": ["get", "job", "client", "buffer", "rate", "access", "query", "upload", "rer", "transfer", "object", "use", "user", "input", "instance", "reference", "route", "directory", "complete", "open", "child", "ext", "report", "resource", "path", "response", "xml", "quest", "store", "url", "req", "forward", "base", "type", "pe", "wheel", "call", "Request", "friend", "remote", "project", "QUEST", "respect", "re", "external", "config", "claim"]}}
{"id1": "3558512", "id2": "12306305", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"serialize": ["Serialize", "normalized", "normalze", "Serialze", "finalized", "erialization", "Serialify", " serialization", "finalify", "Serialized", "finalize", "serialze", "Serializable", "erialize", "Serialization", "finalze", "normalize", "erialze", " serialze", "serialify", " serializable", "serializable", "serialization", "serialized", "normalify", "erializable"], "out": ["page", "ex", "gen", "writer", "report", "image", "server", "copy", "parent", "io", "data", "raw", "output", "archive", "o", "Out", "conn", "temp", "i", "source", "client", "filename", "a", "png", "dump", "outs", "cache", "string", "exec", "bin", "err", "file", "obj", "name", "loader", "up", "w", "OUT", "pool", "content", "buffer"], "parser": ["pe", "pillar", "writer", "lp", "txt", "server", "copy", "master", "parent", "ss", "cp", "system", "rar", "tt", "test", "plugin", "pkg", "instance", "class", "xml", "parse", "reader", "builder", "seed", "er", "worker", "base", "cache", "handler", "file", "upload", "loader", "Parser", "up", "per", "php", "as", "wrapper", "pp", "manager", "p", "processor", "arser"], "on_disk": ["off_demand", "on_delete", "off_drive", "onbootstorage", "onJdisk", "onbookdisk", "off_delete", "off_disk", "on_drive", "on_lock", "onJlock", "onnetfile", "off_storage", "onbootdrive", "onnetdemand", "onjdrive", "on_demand", "onjdisk", "off_lock", "onnetdrive", "off_file", "onjspace", "onnetspace", "onnetdisk", "onJdemand", "on_file", "onjfile", "onbootlock", "on_space", "onbootdisk", "onbookdelete", "onbookdrive", "on_storage", "off_space", "onJdrive"], "in": ["ins", "In", "copy", "ax", "connection", "thin", "info", "data", "inc", "socket", "f", "input", "o", "din", "IN", "inn", "lin", "inas", "conn", "pass", "i", "rin", "win", "kin", "reader", "source", "stream", "login", "inner", "min", "r", "ac", "bin", "file", "con", "c", "pin", "ini", "as", "again"]}}
{"id1": "16623181", "id2": "237493", "code1": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"srcDir": ["rcDir", "rcFile", "srcFile", "rcDirectory", "srcDirectory", "sourceDir", " srcFolder", "destDir", "sourceDirectory", " srcDirectory", " srcFile", "destFile", "destFolder", "srcFolder", "sourceFolder", "sourceFile", "rcFolder", "destDirectory"], "dstDir": ["drcPath", "DstDir", "dotFile", "DrcDIR", "drcFile", "drcDir", "ddestFile", "dstDirectory", "DstPath", "dndFile", "dndDirectory", "DrcDir", "dptDIR", "dotDirectory", "dotPath", "dptFile", "dstDIR", "DrcFile", "drcDirectory", "dstFile", "dotDir", "dndDir", "DstFile", "ddestPath", "DrcPath", "DrcDirectory", "ddestDirectory", "ddestDir", "dndDIR", "dptDirectory", "drcDIR", "dstPath", "dptDir", "DstDirectory", "DstDIR"], "srcFiles": ["rcDir", "rcFile", "srcFile", "scFiles", "srcPoints", "scFile", " srcPoints", "sourceDir", "rcFiles", "sourceFiles", "scPoints", "scFs", "srcfiles", "sourceFs", " srcfiles", " srcFile", "rcfiles", "srcFs", "sourcePoints", "sourceFile", " srcFs", "sourcefiles"], "f": ["x", " df", "name", "self", " F", "s", "m", "p", "info", "j", "fe", "fed", "u", "b", "w", "files", "rf", "F", "r", "l", "fn", "fi", "e", "fr", "tf", "lf", "o", "d", "i", "fx", "feed", "t", "path", "h", "filename", "of", "v", "url", "form", "n", "io", "flat", "c", "file", "folder", "fa", "fd", "bf", "sf", "fp", "dir", "ref", "directory", "fc", "fb", "fs"], "srcChannel": [" srcContext", "rcClient", "sourceChan", "rcConnection", "rcBuffer", "sourceClient", "srcGate", "destConnection", " srcchannel", "destChan", "sourceChannel", "distChannel", "distChan", "rcContext", " srcBuffer", "sourceConnection", " srcConnection", "rcChan", "rcGate", "srcBuffer", "srcClient", "srcChan", "sourceBuffer", " srcGate", "destContext", "rcchannel", "sourcechannel", "distGate", "destChannel", "srcContext", "sourceContext", "srcchannel", "rcChannel", "distchannel", " srcClient", "srcConnection", " srcChan"], "dstChannel": [" dstchannel", "Dstchannel", "drcchannel", "dblChannel", "dstsConnection", "dscchannel", "ddrcButton", "dstConnection", "drcChannel", "dstchannel", " destHandler", "dscButton", "DrcChannel", "ddrcChan", "DrcBuffer", " dstHandler", "drcChan", "dstHandler", "ddstButton", "ddrcChannel", "destConnection", "Drcchannel", "ddrcchannel", "drcBuffer", "destChan", "DstChannel", "dstBuffer", "ddstChannel", "dblBuffer", "drcButton", " destchannel", "ddstChan", " dstConnection", "destButton", "dscBuffer", "dstChan", "dscChan", "destChannel", "drcConnection", "dscChannel", "destHandler", " destChannel", "dstschannel", "dstsHandler", "destchannel", "DstBuffer", "drcHandler", "dblchannel", "dstsChannel", " destConnection", "dstButton", "ddstchannel"], "buffer": ["reader", "bin", "border", "cur", "uffer", "iter", "data", "cb", "job", "batch", "reference", "seed", "layer", "buff", "Buffer", "stack", "zero", "binary", "base", "position", "copy", "bb", "cache", "b", "loader", "size", "r", "writer", "FFER", "flush", "row", "bar", "block", "image", "comment", "limit", "feed", "abi", "request", "url", "transfer", "document", "server", "read", "null", "wave", "message", "queue", "header", "out", "pad", "resource", "length", "result", "fb", "bc", "buf", "offset"], "nr": ["mr", "cur", "iter", "nn", "rn", "cb", "ri", "nc", " ni", "radius", "sn", "adr", "vr", "ru", "eno", "counter", "orr", " sr", "br", "rf", "num", "nu", "r", "err", "fr", "rr", "rb", " NR", "ner", "pointer", "row", "i", "rw", "lr", "number", "nor", "n", "nl", "NR", "ng", "wr", "ni", "nw", "sr", "pos", "gr", "result", "usr", "rl", "nm", "uni", "obj", "nb", "rx"]}}
{"id1": "20414923", "id2": "23531898", "code1": "    protected int deleteBitstreamInfo(int id, Connection conn) {\n        PreparedStatement stmt = null;\n        int numDeleted = 0;\n        try {\n            stmt = conn.prepareStatement(DELETE_BITSTREAM_INFO);\n            stmt.setInt(1, id);\n            numDeleted = stmt.executeUpdate();\n            if (numDeleted > 1) {\n                conn.rollback();\n                throw new IllegalStateException(\"Too many rows deleted! Number of rows deleted: \" + numDeleted + \" only one row should be deleted for bitstream id \" + id);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"Problem deleting bitstream. \" + e.getMessage(), e);\n            throw new RuntimeException(\"Problem deleting bitstream. \" + e.getMessage(), e);\n        } finally {\n            cleanup(stmt);\n        }\n        return numDeleted;\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 1, "substitutes": {"deleteBitstreamInfo": ["deletebitStreamDetails", "deletebitstreamInfo", "deleteBitStreamInfo", "deleteBitsystemDetails", "deletebitstreamINFO", "deleteBitstoreInfo", "deleteBitStreaminfo", "deleteBitStreamINFO", "deletebitStreamInfo", "deletebitStreamINFO", "deleteBitsystemInfo", "deleteBitstoreINFO", "deletebitStreaminfo", "deletebitstreamDetails", "deleteBitstreamDetails", "deleteBitsysteminfo", "deleteBitstoreDetails", "deleteBitstoreinfo", "deleteBitstreamINFO", "deleteBitsystemINFO", "deleteBitStreamDetails", "deleteBitstreaminfo", "deletebitstreaminfo"], "id": ["error", "ip", "in", "db", "seq", "p", "one", "entry", "key", "i", "object", "vid", "oid", "ad", "parent", "Id", "mid", "ID", "address", "info", "did", "source", "code", "ident", "index", "num", "path", "ref", "ide", "count", "root", "part", "which", "start", "x", "uid", "url", "no", "sid", "data", "type", "offset", "status", "number", "ids", "name", "d", "like", "aid", "rid", "pid", "kid", "create"], "conn": ["db", "client", "connect", "ca", "Conn", "obj", "ctx", "sync", "stat", "cp", "rc", "cn", "cc", "pg", "cr", "mn", "nt", "ci", "cf", "coll", "server", "ann", "dn", "connection", "nc", "dc", "cm", "con", "col", "ch", "enc", "serv", "exec", "sql", "session", "jp", "rt", "ct", "co", "mc", "Connection", "act", "config", "c", "pr"], "stmt": [" stm", "shmd", "Stlt", "stmr", "Stmr", "Stm", "StMT", "stlt", " stdb", " stmn", "strst", " stpr", "strlt", "sttr", "Stmd", "shMT", "strpr", "stmd", "stst", " sttr", " stst", "stMT", "strmt", "strMT", " stmd", "Start", "strmd", "strdb", "strmn", "start", "shart", "Stst", "strm", "strmr", "shmt", "stpr", "stm", " start", "strtr", "Sttr", "Stmt", "stmn", "Stmn", "Stdb", " stlt", "stdb", " stmr", " stMT", "Stpr"], "numDeleted": ["numDelased", "NumDeigrated", "numDelleted", "numExashed", "Numdeigrated", "numdeased", "Numdeleted", "numExletes", "numdelected", " numDeashed", "numDelete", "numExoded", "numDeoded", "numDefoded", "numModashed", " numDelected", "numDuleted", "numUndued", "numNeletes", " numdeashed", "numdeashed", "numModleted", " numDeased", "numDeloded", "numNelete", "numdeleted", " numDelete", "numDefleted", " numdeased", "numDefased", "numDeigrated", "Numdeued", "numMododed", "numDeflected", "NumDeDelete", " numdeleted", "numDeased", "numDuDelete", "numdelete", "numNeleted", "numExleted", "numdeigrated", "numdeued", " numdeoded", "numDeletes", "numUndDelete", "numModletes", "numDeued", "NumdeDelete", "numDelected", "numDellected", "NumDeued", "numdeletes", "numUndleted", " numdelected", " numDeoded", " numDeletes", "numdeDelete", "NumDeleted", "numDeDelete", "numdeoded", " numdeletes", "numDeashed", "numDuigrated"]}}
{"id1": "15241397", "id2": "8079516", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["doGET", "handleget", " doPut", " doget", "doget", "handlePut", "didPut", "doPut", "didget", "handleGET", "handleGet", "didGet", "didGET", " doGET"], "request": ["connection", "reader", "er", "data", "complete", "QUEST", "method", "type", "info", "application", "web", "event", "received", "xml", "req", "user", "instance", "query", "client", "subject", "buffer", "image", "object", "Request", "url", "context", "document", "uri", "server", "http", "message", "input", "result", "resource", "queue", "initial", "report"], "response": ["full", "connection", "data", "version", "error", "pool", "session", "respond", "body", "results", "application", "Response", "status", "model", "page", "output", "writer", "collection", "client", "reply", "image", "parent", "object", "next", "other", "esi", "document", "view", "server", "wave", "function", "message", "resource", "result", "out", "queue", "host", "report", "onse", "generation", "json", "resp", "site"], "rewrittenQueryString": ["rewwrittenQueryList", "rewrittenUrlService", "rewrittenqueryString", "rewrittenQueryText", "rewwrittenRequestString", "rewrittenQueryList", "rewrittenRequestService", "rewwrittenQueryLine", "rewrittenPageList", "rewrittenqueryStr", "rewrittenQueryArray", "rewwrittenQueryArray", "rewrittenQuestionList", "rewrittenPageLine", "rewrittenUrlString", "rewwrittenRequestArray", "rewwrittenRequestLine", "rewrittenqueryService", "rewwrittenQueryStr", "rewrittenRequestText", "rewrittenQueryService", "rewrittenUrlText", "rewrittenQuestionArray", "rewwrittenRequestStr", "rewrittenqueryLine", "rewrittenPageArray", "rewrittenQuestionText", "rewwrittenQueryString", "rewwrittenRequestService", "rewrittenRequestStr", "rewrittenQueryLine", "rewwrittenQueryText", "rewrittenQuestionStr", "rewrittenRequestString", "rewwrittenRequestText", "rewwrittenQueryService", "rewrittenRequestLine", "rewrittenQuestionString", "rewrittenUrlLine", "rewrittenQuestionLine", "rewrittenRequestList", "rewrittenqueryText", "rewwrittenRequestList", "rewrittenRequestArray", "rewrittenQueryStr", "rewrittenPageString"], "rewrittenUrl": ["RewwrittenUrl", "rewilledUrl", "rewriteUrl", "rewardedLanguage", "rewardedInt", "rewwrittenInt", "rewmatchedUrl", "rerittenLanguage", "rewrapedUrl", "rewmatchedURL", "rewrittenInt", "rewardedUrl", "rewrittenLanguage", "rewardedJar", "rewardedUr", "RewrittenFile", "RewrittenUr", "rewilledURL", "rewatchedServer", "RewwrittenLocation", "rewardedURL", "rewatchedURL", "RewrittenServer", "rewrittenText", "rewwrittenServer", "rewcraftedUrl", "rewrapedUr", "rewwrittenJar", "rewrittenurl", "rewwrittenLanguage", "rewedurl", "rewcraftedUr", "rewwrittenLocation", "rewwrittenText", "Rewwrittenurl", "rewrapedFile", "rewriteText", "rewrittenURL", "rewodedUrl", "RewwrittenInt", "rewwrittenUr", "rewrittenServer", "rewrapedURL", "rewrittenJar", "RewrittenURL", "RewrittenLocation", "RewwrittenText", "rewodedFile", "rewriteServer", "rewmatchedFile", "rerittenUrl", "RewrittenInt", "rerittenURL", "rewatchedUrl", "rewwrittenUrl", "rewedURL", "rewmatchedurl", "RewrittenUrl", "rewrittenUr", "rewrittenLocation", "rewwrittenFile", "rewedUrl", "rewriteURL", "rewcraftedURL", "RewwrittenURL", "RewwrittenUr", "rewcraftedLocation", "rewilledJar", "RewrittenText", "rerittenFile", "RewwrittenFile", "rewatchedText", "rewodedLanguage", "rewardedLocation", "RewrittenJar", "rewedFile", "RewwrittenServer", "rewardedFile", "rewrittenFile", "rerittenUr", "rewilledInt", "rewodedURL", "rewwrittenURL", "rewedUr", "RewwrittenJar", "rewwrittenurl", "Rewrittenurl"], "httpURLConnection": ["httpCLConnection", "httpURIConnect", "apacheURLFlow", "httpURLCode", "httpURLService", "webSSLClient", "httpurlCurrent", "httpurlConnection", "httpURLConn", "httpURConn", "apacheURLConnect", "httpStreamconnection", "httpSSLConnection", "httpURIClient", "HttpChannelconnection", "httpUrlconnection", " httpURConn", " httpUrlConnection", "httpUrlConnection", "httpStreamSession", " httpURLconnection", "httpStreamConnection", " httpURConnect", "httpurlFlow", "httpUrlContext", "httpChannelService", "HttpURLConnection", "httpURLContext", " httpUrlConn", "httpCLConn", " httpStreamCurrent", "webSSLConnection", "httpURIconnection", "HttpURLconnection", "httpPathCurrent", "webURLContext", "webSSLContext", "httpurlconnection", "httpUrlConn", "httpURLCurrent", "apacheGEConnect", "httpURConnect", " httpStreamSession", "httpWebConnect", "httpSSLContext", "httpPathConnection", "httpPathconnection", "httpurlSession", "HttpChannelConnect", "httpGEconnection", " httpURLSession", "httpURIFlow", "httpURIContext", "httpURLClient", "httpurlConn", " httpURLConn", "httpUrlService", "httpStreamCurrent", "httpURConnection", "httpUrlConnect", "apacheGEConnection", "HttpURLConnect", " httpStreamConnection", " httpURConnection", "httpGEConnection", "httpURIConnection", "httpURLconnection", "httpurlConnect", " httpURLCurrent", "httpChannelconnection", "httpELConn", " httpURLConnect", "httpChannelConnection", "httpWebConn", "webURLClient", "apacheGEFlow", "httpSSLConn", " httpStreamconnection", "apacheURLconnection", "HttpURLService", "httpSSLClient", "httpELConnection", "HttpChannelConnection", "httpGEFlow", "webURLConnection", "webURLConn", "httpChannelConnect", "httpGEConnect", "httpUrlCode", "HttpChannelService", "httpWebConnection", "httpURconnection", " httpURLCode", "httpURService", " httpUrlCode", "httpUrlClient", "httpPathSession", "apacheGEconnection", "httpURLFlow", "httpCLCode", "webSSLConn", "apacheURLConnection", "httpurlCode", "httpURIConn", "httpURLConnect", "httpELConnect", "httpURLSession"], "header": ["feature", "iter", "er", "director", "data", "version", "channel", "master", "error", "handler", "head", "reference", "filter", "layer", "pair", "info", "after", "field", "event", "definition", "rule", "match", "component", "part", "bridge", "section", "her", "writer", "line", "member", "key", "ter", "dr", "column", "back", "buffer", "list", "entry", "player", "comment", "block", "driver", "outer", "hash", "second", "character", "Header", "next", "default", "attribute", "document", "group", "server", "date", "consumer", "author", "metadata", "function", "index", "message", "item", "token", "headers", "queue", "result", "cover", "string"], "value": ["office", "values", "data", "current", "name", "version", "now", "get", "type", "language", "V", "info", "field", "variable", "option", "label", "letter", "expression", "set", "format", "description", "model", "text", "content", "sv", "val", "VALUE", "key", "password", "comment", "entry", "child", "parent", "object", "v", "property", "attribute", "default", "document", "hello", "server", "function", "valid", "message", "item", "gi", "Value", "json", "string", "media", "end", "element"], "inputStream": ["pullStreamer", "inputSteam", "resourceSteam", "InputChannel", "InputStream", "InputStreamer", "outputStreamer", "pullstream", "inputStreamer", "resourceChannel", "pullStream", "pullSteam", "resourcestream", "resourceStream", "inputChannel", "Inputstream", "outputChannel", "outputSteam", "InputSteam", "inputstream", "outputstream"], "outputStream": ["inputSteam", " outputChannel", "OutputSteam", "outputFile", "OutputChannel", " outputFile", "OutputStream", "outputStreamer", "externalstream", "Outputstream", "inputStreamer", "externalSteam", "externalStreamer", "responseStream", "responseSteam", " outputSteam", "responseFile", "outputChannel", "outputSteam", "responseChannel", "externalStream", "inputstream", "OutputFile", "outputstream", "OutputStreamer"]}}
{"id1": "1586662", "id2": "17083703", "code1": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "code2": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doOne": ["DoSync", "goOne", "goone", "Doone", "Do1", "go1", "loOne", "DoOne", "do1", "goSync", "lo1", "doone", "doSync", "loone", "loSync"], "bid": ["wid", "vid", "paid", "sha", "base", "bm", "ud", "aud", "rid", "mad", "ban", "ref", "bon", "bas", "bit", "b", "bb", "bh", "cb", "bed", "ld", "aba", "uid", "ed", "abi", "pid", "ad", "year", "lay", "oid", "bi", "auth", "bt", "hid", "sid", "mid", "la", "chid", "bn", "du", "received", "id", "seed", "rb", "bc", "bf", "batch", "ast"], "tid": ["paid", " taid", "ptaid", "tiden", "tids", "pids", " tbase", " tids", "ptid", "Tbase", "timID", "trid", "tID", "timbid", "pbase", "tide", "trID", "ptinfo", "trids", "tbase", "trbid", "pid", "ptiden", "pide", " tide", "timid", "Tid", "Tids", "pinfo", "taid", "tbid", "Tbid", "TID", "piden", "Tide", " tiden", "tinfo", " tinfo", "timids"], "aid": ["paid", "dd", "sha", "ga", "said", "ay", "aud", "alias", "order", "lan", "lied", "mad", "ase", "anc", "ca", "ada", "bas", "acid", "aida", "sat", "idd", "da", "aa", "ays", "ed", "aned", "pa", "d", "au", "Aid", "ad", "lay", "oid", "ai", "cas", "sd", "na", "ady", "auth", "aim", "man", "sid", "du", "ased", "ac", "a", "ara", "id", "af", "az", "aed", "ding", "added", "delay", "ab", "ast", "ia"], "delta": ["Dota", "ddDelta", "edetime", "ddelta", "sdelta", "sdelt", "dta", "dada", "dDelta", " dada", "ndDelta", "ndta", "Delta", "lelta", "lada", "adelt", "dota", "d\n", "edDelta", "sdta", "adota", "ldelt", "sdDelta", "D\n", "edelta", "adDelta", "adada", "ndelta", "ldota", "d_", "lelt", " delt", "Dada", "sdota", "ndota", "ddota", " d_", "ndelt", "DDelta", "edta", "sdetime", "ndata", "lota", " dota", "detime", " d\n", " dDelta", "D_", "data", "sdata", "delt", "ddelt", "ldDelta", "ldelta", "Delt", "adelta", "ndetime"], "aBalance": ["sabalance", "aaHalf", "aCost", "bHalf", "aaWeight", "saBalance", "eaBalance", " aCredit", " abalance", "aaBalance", "eabalance", "eaBal", "abalance", "bAmount", "aBal", "aWeight", " aWeight", "aaCredit", "bBalance", " aAmount", "eaCost", "pBalance", "aabalance", " aCost", "pbalance", "aHalf", "saBal", "saCost", " aBal", "pWeight", "pCredit", "bCredit", "aCredit", " aHalf", "aAmount", "aaAmount"], "RS": ["RE", "JS", "RN", "VS", "SW", "RC", "DS", "DR", "FS", "KR", "NRS", "RD", "RR", "RT", "KS", "SS", "RO", "RW", "Rs", "LS", "IS", "CL", "TS", "SH", "MC", "RB", "RL", "POST", "Res", "Vs", "VR", "US", "BS", "IR", "MR", "MS", "rs", "CD", "LL", "OSS", "RM", "Ms", "AR", "RI", "OS", "PS", "GR", "JR", "TR", "HS", "CS", "RP", "SR"], "Stmt": ["LMT", "stbl", "Stut", "Cmn", "Strau", "Stmn", "stMT", "Stp", "stmp", " StMT", "Strmp", "Cmt", " Stmp", "STut", "Stgr", "Stmp", " Stpr", "Lmp", "Cut", " Sttm", " Stau", "STTr", " StTr", "STp", "Stau", "Cmp", "STMT", " Stbl", "Stpr", "stp", "CMT", "Firstmt", "STbl", "StMT", " stmp", "Firstpr", "Firstmb", " Stmn", "Cau", "StTr", "stmt", " Stmb", " Stut", " stMT", "stgr", " Stp", " stmt", "Lgr", "Sttm", "STmn", " stgr", "stmb", "Firsttm", "sttm", "stpr", "Strmt", "Stmb", "Stbl", "STmt", "StrMT", "Lmt", "stTr"], "Query": ["File", "Time", "Check", "Raw", "Factory", "Command", "Form", "Database", "Model", "Stage", "Driver", "Body", "Source", "Route", "Statement", "Report", "Url", "Range", "Table", "Force", "SQL", "Connection", "Qu", "Display", "Line", "Function", "Comment", "Format", "Update", "query", "Array", "Request", "Do", "This", "Db", "Service", "Row", "Cache", "Common", "Code", "Server", "Scan", "Method", "Exp", "Test", "Script", "Option", "Document", "URI", "Filter", "Init", "Msg", "Fixed", "Style", "Previous", "Rule", "Module", "Join", "Info", "Flow", "Str", "Conn", "Q", "Error", " query", "Key", "Condition", "ERY", "QL"], "res": ["re", "RE", "ES", "vals", "resh", "Gr", "Response", "runs", "js", "gr", "resp", "rows", "RES", "Resources", "Res", "ches", "Results", "lets", "ras", "rest", "Resp", "Ret", "rem", "PS", "results", "reg", "Cons", "obj"]}}
{"id1": "17161805", "id2": "3745402", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 1, "substitutes": {"encode": ["reoding", "encoder", "encoding", "reode", "enoding", "ensoder", "Encode", "enscod", "Encod", "enscode", "Enoding", "recod", "enode", "enccod", "recode", "enoder", "ensode", "enccode", "Enode", "encod", "Enoder"], "plaintext": [" plaincontent", "longText", "foreTEXT", "bodyform", "forestring", " plainform", "plainTEXT", "plaincontent", "plainform", "bodyText", "bodytext", " plainTEXT", "bodycontent", "batstring", "foreText", "foretext", "longtext", "batText", "batTEXT", "longform", " plainText", "battext", "plainText", " plainstring", "plainstring", "longcontent"], "md": ["meta", "df", "bd", "f", "mag", "cd", "rm", "wd", "grad", "mad", "dd", "m", "ma", " MD", "ind", "me", "di", "mb", "mac", "cmd", "dm", "um", "sm", "d", "MD", "gd", "mod", "amd", "mp", "code", "rpm", "metadata", "mm", "pm", "dh", "sha", "po", "mc", "ms", "od", "mand", "pd", "hd", "ad"], "raw": ["missing", " Raw", "blocks", "ack", " hex", "remote", "array", "stream", "dec", "clean", "RAW", "enc", "load", "shared", "local", "hex", "binary", "ghost", "orig", "Raw", "instance", "all", "rew", "pure", "row", "buffer", "block", "pack", "feed", "ode", "serial", "original", "unsigned", "input", "out", "custom", "initial", "unknown", "internal", "alpha", "micro"]}}
{"id1": "2936678", "id2": "3767903", "code1": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "code2": "    public static void copy(File source, File destination) throws FileNotFoundException, IOException {\n        if (source == null) throw new NullPointerException(\"The source may not be null.\");\n        if (destination == null) throw new NullPointerException(\"The destination may not be null.\");\n        FileInputStream sourceStream = new FileInputStream(source);\n        destination.getParentFile().mkdirs();\n        FileOutputStream destStream = new FileOutputStream(destination);\n        try {\n            FileChannel sourceChannel = sourceStream.getChannel();\n            FileChannel destChannel = destStream.getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n        } finally {\n            try {\n                sourceStream.close();\n                destStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getUniqueKey": ["getStringkey", "getStringLink", "makeuniqueHash", "getUniqueHash", "makeuniquekey", "makeUniqueKey", "getuniquekey", "getPrimaryLink", "makeUniquekey", "getPrimaryHash", "getStringKey", "getPrimarykey", "getuniqueHash", "getuniqueLink", "getUniquekey", "makeUniqueLink", "makeuniqueLink", "makeuniqueKey", "makeUniqueHash", "getStringHash", "getUniqueLink", "getuniqueKey", "getPrimaryKey"], "digest": [" digests", "digit", "dests", "DigEST", "Digid", "Digester", "uuester", "longest", "digested", "dester", "longEST", "genest", "genit", "digester", "digEST", " digid", "dest", "longester", " digEST", "Digested", "uuest", "uuid", "uuEST", "genEST", "longested", "digests", "Digit", " digit", "digid", " digested", "Digests", " digester", "Digest", "dested"], "md": ["meta", "df", "bd", "vd", "mag", "mg", "cd", "sd", "gb", "wd", " dd", "grad", "dd", "m", "mad", "ma", " MD", "mt", "gen", "dig", "ld", "alg", "mb", "mac", "hm", "cmd", "dm", "mn", "dc", "d", "sm", "MD", "km", "gd", "mo", "hash", "amd", "v", "mp", "rpm", "metadata", "mm", "pm", "dh", "ud", "mc", "nd", "pd", "mand", "hd", "med", "ad", "od", "Cmd", "de", "nm"], "timeVal": ["rateValue", "TIMEval", " timeValue", "timeval", " timeSeries", "Timeval", " timeLen", " timeval", "timeValue", "TimeBu", "rateVal", "rateBu", "TIMEValue", " timeBu", "rateLen", "TimeValue", "TimeVal", "TimeLen", "TIMESeries", "timeBu", "TIMEVal", "timeLen", "timeSeries", "TimeSeries"], "localHost": ["localhost", "localPort", "remotePort", " localPort", "privateAddress", "localAddress", "LocalMac", "privateHost", " localAddress", "localMac", "remoteMac", "remotehost", "LocalAddress", "Localhost", "remoteHost", "LocalHost", "privatePort", "remoteAddress", " localhost", "privatehost", "LocalPort", " localMac"], "randVal": ["randLen", "randomval", " randBu", "RandomVal", " randval", "randomVal", "randValue", " randLen", "RandBu", " randValue", "RandValue", "randomValue", " randStr", "randBu", "RandomValue", "Randomval", "randomLen", "randomBu", "randStr", "RandomLen", "randval", "RandStr", "randomStr", "RandVal"], "val": ["x", "msg", "abc", "sl", "vals", "values", "data", "loc", "seq", "reg", "gb", "grad", "range", "pt", "rev", "el", "dev", "enc", "Val", "ind", "bl", "base", "format", "vol", "pr", "az", "key", "temp", "ret", "test", "live", "db", "value", "eval", "v", "update", "unit", "pm", "id", "valid", "sel", "result", "res", "VAL", "ref", "addr", "string", "buf"]}}
{"id1": "6840241", "id2": "14865947", "code1": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "code2": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"copy": ["mop", "server", "Copy", "cmp", "slave", "system", "clip", "write", "clone", "loop", "sync", "cop", "type", "load", "cover", "proxy", "open", "share", "ip", "size", "io", "image", "create", "process", "opy", "transfer", "download"], "source": ["sin", "address", "handler", "i", "input", "server", "resource", "Source", "ie", "slice", "slave", "inner", "result", "se", "si", "ources", "SOURCE", "iter", "session", "use", "reader", "proxy", "seed", "connection", "target", "parent", "data", "channel", "src", "size", "iterator", "null", "start", "e", "image", "this", "stream", "sp", "wrapper", "rice", "ink", "ource", "service", "from"], "sink": ["outsigh", "Sinker", "Source", "pinker", "dsinker", "outsinker", "asink", "dsource", "partsINK", "pink", "sider", "tource", "asigh", "SINK", "pource", "tink", "outsink", "Sink", "outsource", "sinker", "tider", "partsource", "sINK", " sinker", "pINK", "asinker", " sigh", "tinker", "dsink", "asource", "partsinker", "dsider", "partsink", "sigh", "pider"]}}
{"id1": "14758866", "id2": "18211588", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"getResourceAsStream": ["getResourcesAsStream", "getResourceASStream", "getResourceToStream", "getResourceasSteam", "getResourcesAsSteam", "getResourcesasFile", "getResourceasString", "getResourceToFile", "getResourcesasStream", "getResourceAsString", "getResourceASFile", "getResourceasStream", "getResourceAsFile", "getResourceToSteam", "getResourceAsSteam", "getResourceASSteam", "getResourcesAsString", "getResourceToString", "getResourcesAsFile", "getResourcesasString", "getResourcesasSteam", "getResourceasFile", "getResourceASString"], "name": ["base", "resource", "NAME", "prefix", "alias", "domain", "version", "cache", "filename", "key", "remote", "info", "full", "object", "string", "hash", "ame", "path", "Name", "type", "part", "uri", "named", "ip", "size", "location", "word", "data", "file", "id", "parent", "username", "time", "str", "names", "connection", "config", "source", "memory", "address"], "inputStream": ["pullSteam", "InputChannel", "inputBody", "cacheSteam", "inputstream", "InputFeed", "currentBody", " inputChannel", "InputSteam", "inputChannel", "currentSteam", "inputConnection", "cachestream", " inputBody", " inputSteam", "currentstream", "cacheStream", "cacheFeed", "inputSteam", "InputBody", " inputConnection", "pullChannel", "InputStream", " inputFeed", "pullConnection", "pullStream", " inputstream", "currentStream", "inputFeed", "Inputstream", "InputConnection"], "in": ["re", "image", "err", "log", "inner", "input", "din", "In", "src", "rec", "bin", "read", "c", "r", "IN", "buffer", "path", "Out", "ins", "data", "reader", "m", "source", "exec", "socket"], "out": ["err", "log", "pool", "cmd", "outer", "raw", "temp", "point", "flush", "debug", "pre", "cli", "inter", "window", "up", "ref", "group", "cache", "output", "OUT", "list", "writer", "bin", "conn", "object", "ger", "page", "key", "r", "params", "buffer", "state", "outs", "query", "line", "part", "io", "proc", "Out", "client", "bar", "dump", "server", "data", "file", "user", "sys", "gen", "lock", "error", "ex", "println", "msg", "obj", "copy"], "url": ["image", "log", "URL", "base", "resource", "service", "feed", "stream", "coll", "event", "download", "Url", "open", "http", "cache", "remote", "l", "b", "api", "full", "object", "page", "update", "string", "left", "r", "bel", "route", "path", "li", "source", "result", "rel", "https", "uri", "org", "pull", "client", "ur", "ssl", "socket", "loc", "server", "data", "file", "ob", "gl", "user", "browser", "sl", "connection", "config", "location", "web", "f", "address"], "remoteName": ["RemoteUrl", "remoteKey", "RemotePath", "RemoteName", "localPath", "fullKey", "localKey", " remoteKey", "fullname", " remotename", "remoteUrl", "RemoteKey", " remoteUrl", "remotePath", "fullPath", "fullName", "localUrl", "Remotename", " remotePath", "remotename"], "localName": ["globalString", " localUrl", "locString", "remoteKey", " localPath", "remoteString", "LocalPath", " localString", "LocalKey", "localPath", "locName", "globalPath", "globalFile", "localKey", "locname", "globalKey", "locPath", "remoteFile", "locUrl", "localname", "LocalName", "remoteUrl", "globalName", " localname", "remotePath", "localString", "Localname", " localKey", "localUrl", "localFile", " localFile", "globalname", "remotename"], "host": ["service", "localhost", "hard", "prefix", "format", "domain", "head", "Host", "target", "arch", "http", "src", "remote", "conn", "hop", "home", "string", "driver", "path", "type", "uri", "addr", "ip", "dir", "proxy", "h", "loc", "server", "username", "database", "config", "header", "address"], "prot": ["nat", "conv", "serv", "pt", " protocols", "prefix", "config", "ht", "cli", "pattern", "channel", "ref", "platform", "cert", "api", "password", "conn", "att", "txt", "pos", "def", "pass", "family", "part", "lat", "stat", "proc", "Prot", "addr", "prop", "client", "ocol", "ssl", " plat", "col", " protocol", " proto", "ios", "afi", "rot", "pro", "rel"], "port": ["ports", "index", "service", "priority", "point", "direction", "patch", "phone", "target", "version", "slice", "password", "pr", "hop", "string", "pi", "future", "position", "pass", "path", "pid", "ort", "p", "type", "allow", "Port", "width", "uri", "number", "rest", "ip", "length", "size", "proxy", "PORT", "server", "file", "limit", "value", "timeout", "time", "select", "project", "f", "address"], "cacheFile": ["storageFile", "cacheHandle", "tempFile", "outputMessage", " cacheMessage", " cacheDir", " cacheDirectory", " cacheHandle", "tempfile", "outputConnection", "remoteLine", "localFiles", "CacheUrl", "fakeUrl", "proxyfile", "proxyHandle", "acheFile", "cacheDir", "proxyDir", "cacheLine", "cachePlace", "sessionFile", "CacheDir", "baseMessage", "localDirectory", "storageFiles", "fakeLine", " cachePlace", "cacheFiles", "tempDir", "achePlace", "sessionDir", "sessionUrl", " cacheLine", "CacheFile", "remoteFile", "cacheMessage", " cacheFiles", "localfile", " cachefile", "acheFiles", "baseConnection", "remoteUrl", "baseFile", "proxyFile", "cacheDirectory", "storagePlace", "Cachefile", "remotefile", " cacheConnection", "CacheDirectory", "cacheConnection", "tempHandle", "outputfile", "cachefile", "cacheUrl", "fakeFile", "basefile", "fakefile", "CacheFiles", "localFile", "sessionFiles", "outputFile", " cacheUrl", "localDir"], "urlConnection": ["httpResponse", "httpCommand", "URLConnect", "URLConn", "sslResponse", " urlCommand", "httpConnection", "URLConnection", "urlFile", "webConnection", "urlCode", "httpPool", "httpconnection", " urlCode", " urlChannel", "downloadEntry", "URLconnection", "cacheConn", "httpCode", "sslFile", "slChannel", "sslConn", "httpChannel", " urlFile", "fileConnect", " urlEntry", "fileConn", "urlconnection", "urlPool", "httpCon", " urlConn", "filePart", "httpConn", " urlPart", "urlCommand", "webCon", "httpConnect", "webConnect", "URLPart", "urlConn", " urlConnect", " urlPool", "webconnection", "URLResponse", "slCommand", "cacheConnect", "downloadFile", "downloadConnection", "cacheConnection", " urlconnection", "urlCon", "sslEntry", "urlConnect", "sslConnection", "slConnection", "urlResponse", "cachePool", "slCode", "sslConnect", "urlEntry", "sslconnection", "downloadconnection", "urlChannel", "fileConnection", "URLCon", "urlPart"], "httpURLConnection": ["httpUrlStatement", "httpDOMconnection", "httpREStatement", "httpCLConnector", "httpURLConnector", " httpHTTPFunction", "httpFormConnection", "currentURLconnection", " httpLLConn", " httpLLconnection", "httpRLConnector", "httpRNode", "shortSLconnection", "httpSLConnect", "urlUrlConnection", "httpURLConnect", "httpWSTransaction", "httpURNode", "httpLLConnection", "httpDOMConnection", "httpDateConnection", "httpRLClient", "httpBLFunction", "httpRConnection", "httpLLConn", "httpFormconnection", "httpURLQuery", "httpMLFunction", "httpDOMFunction", "httpSLConnection", "httpMconnection", "httpSLCode", "cacheURLConnection", "httpDateConn", " httpURLQuery", "cacheUrlConnector", "httpURLconnection", "httpUrlClient", "httpLLconnection", "httpURconnection", "httpurlConnection", "shortSLConnection", " httpHTTPConnection", "httpURLConstruction", "httpURLStatement", "httpHTTPOperation", " httpHTTPQuery", "httpBLOperation", " httpUrlConnect", "httpHTTPQuery", " httpUrlconnection", "cacheURLConnector", "httpREconnection", "httpUrlconnection", "shortURLConnection", "cacheUrlConnection", "httpMConnect", "httpURLNode", "httpWSConnection", "httpURTransaction", "httpurlClient", "httpFormConnect", "urlURLconnection", "httpRconnection", "upperURLconnection", "shortSLConnect", "httpURFunction", "httpSLconnection", "httpREClient", "httpURQuery", "httpLLConstruction", "httpURLConn", "httpCLClient", "urlURLStatement", "upperRConnection", "httpRLconnection", "cacheURLConnect", "upperRconnection", "httpMLConnect", "httpCLConnection", " httpURLOperation", "httpMLConnection", " httpLLConnection", "cacheURLClient", "httpDateconnection", " httpURLconnection", "httpREConnection", "upperRTransaction", "urlURLClient", "httpURConnection", "httpHTTPFunction", " httpUrlConnection", "upperRNode", "urlUrlconnection", "httpURLTransaction", "httpDOMConnect", "upperURLConnection", "httpMConnection", "httpRTransaction", " httpURLConstruction", "currentURLConnect", "upperURLNode", " httpLLConstruction", " httpURLConnect", "httpURLFunction", "httpBLConnection", "httpUrlConnect", "httpURLOperation", "currentURLCode", "upperURLTransaction", "shortURLconnection", "httpRLConnect", " httpUrlFunction", " httpURLFunction", "httpHTTPConnection", "httpUrlConnection", "httpMCode", "httpURLClient", "currentURLConnection", "httpurlconnection", "httpMLconnection", "httpBLQuery", "httpCLConnect", "cacheUrlConnect", "httpUrlConnector", " httpURLConn", "httpDateConstruction", "httpUrlFunction", " httpHTTPOperation", "httpWSconnection", "shortURLConnect", "cacheUrlClient", "urlURLConnection", "httpREConn", "httpurlStatement", "httpRLConnection", "httpUROperation", "httpURLCode", "urlUrlClient", "httpWSNode", "urlUrlStatement", "httpREConstruction"], "responseCode": ["statusCount", "ResponseType", "statusCode", "replyCode", "responseCount", "statusMessage", "ResponseStatus", "ResponseCount", "replyType", " responseType", "responseStatus", "statusType", " responseMessage", "ResponseCode", "replyCount", "responseMessage", " responseStatus", "ResponseMessage", "responseType", "statusStatus", "replyMessage"], "lastModified": ["lastmodied", "lastModification", "lastModined", "nextModIFIED", "lastMODIFIED", "lastMinied", "nextMODification", "lastMODification", "nextMODed", "New", "lastMODined", " lastModined", "nextModified", "lastEdified", "lastMinified", "lastMinIFIED", "nextMODIFIED", "s", " lastMODIFIED", "this", "nextModed", "nextModification", "lastMODified", "lastModed", "lastEdIFIED", "lastModIFIED", "lastEded", "nextMODified", " lastMODified", "_", "lastmodified", "lastmodification", "lastEdification", " lastModied", "lastmoded", "lastmodIFIED", "nextMODied", " lastModIFIED", " lastMODied", "lastMODed", "lastMinined", " lastMODined", "lastModied", "nextModied", "lastMODied"]}}
{"id1": "5237257", "id2": "4750967", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"download": ["output", "paste", "load", "update", "archive", "dump", "complete", "process", "release", "open", "url", "log", "transfer", "Download", "zip", "exec", "upload", "run", "submit", "file", "register", " downloading", "pack", "start", "select", "delete", "report"], "fileName": ["fileCode", "resourcePath", "fileDirectory", "resourceName", "fileType", "FileCode", " fileType", " fileDirectory", "FilePath", "fileFolder", "resourceDirectory", " fileFolder", "fileUrl", "FileFolder", "FileName", "resourceUrl", "FileUrl", "FileDirectory", "resourceCode", "FileType", "resourceFolder", "resourceType", " fileCode", " fileUrl"], "filePath": ["resourcePath", " fileFile", "FileLocation", "fileLocation", "resourceName", "filePart", "resourceFile", "resourceLocation", "FilePart", "fileFile", " filePart", "FilePath", "Filepath", "resourcePart", "FileName", "FileFile", " filepath", "filepath", "resourcepath", " fileLocation"], "in": ["work", "x", "source", "as", "init", "copy", "re", "gin", "inn", "sync", "pin", "inner", "ac", "f", "ax", "this", "i", "input", "l", "socket", "inside", "image", "IN", "data", "m", "con", "win", "ini", "resource", "issue", "on", "n", "up", "bin", "a", "url", "io", "name", "isin", "b", "is", "nin", "ins", "cin", "spin", "In", "lin", "inc", "again", "rin", "file", "r", "err", "login", "cgi", "id", "reader", "din"], "out": ["x", "source", "call", "copy", "cache", "output", "sync", "client", "path", "net", "inner", "at", "point", "with", "this", "extra", "view", "ex", "cmd", "one", "to", "socket", "OUT", "conn", "image", "line", "or", "IN", "by", "writer", "on", "n", "io", "up", "url", "base", "name", "log", "null", "outer", "ext", "server", "exec", "obj", "password", "nin", "string", "exp", "prefix", "option", "Out", "write", "In", "outs", "again", "off", "office", "file", "lib", "err", "o", "id", "user", "bin", "error"]}}
{"id1": "13421722", "id2": "17029388", "code1": "    public static long getFileSize(String address) {\n        URL url = null;\n        try {\n            url = new URL(address);\n            System.err.println(\"Indirizzo valido - \" + url.toString().substring(0, 10) + \"...\");\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Indirizzo non valido!\");\n        }\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=0-\");\n            connection.connect();\n            return connection.getContentLength();\n        } catch (IOException ioe) {\n            System.err.println(\"I/O error!\");\n            return 0;\n        }\n    }\n", "code2": "    public static InputStream getConfigIs(String path, String name) throws ProgrammerException, DesignerException, UserException {\n        InputStream is = null;\n        try {\n            URL url = getConfigResource(new MonadUri(path).append(name));\n            if (url != null) {\n                is = url.openStream();\n            }\n        } catch (IOException e) {\n            throw new ProgrammerException(e);\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"getFileSize": [" getFileBytes", "getfileLength", "getFilesInfo", "getByteLength", "getfileInfo", " getfileLength", " getfileSize", "getByteBytes", "getFilesSize", "getByteSize", "getFileInfo", " getFileInfo", "getFilesBytes", " getfileInfo", "getfileBytes", " getfileBytes", "getFileBytes", "getFilesLength", " getFileLength", "getFileLength", "getByteInfo", "getfileSize"], "address": ["prefix", "attribute", "array", "uri", "localhost", "report", "resource", "server", "message", "offset", "data", "port", "output", "route", "str", "type", "Address", "code", "source", "addr", "config", "size", "network", "target", "ip", "number", "base", "point", "position", "object", "email", "string", "name", "reference", "host", "location", "path", "content", "format", "request"], "url": ["ur", "page", "proxy", "log", "uri", "ssl", "resource", "image", "server", "e", "ll", "html", "build", "loc", "io", "org", "session", "socket", "channel", "f", "impl", "result", "www", "URL", "str", "job", "conn", "xml", "api", "config", "client", "l", "web", "lr", "base", "user", "object", "found", "string", "orb", "file", "service", "ob", "sl", "host", "bug", "path", "Url", "location", "http", "feed", "lib"], "connection": ["to", "proxy", "uri", "resource", "server", "communication", "event", "io", "info", "version", "session", "socket", "bc", "channel", "Connection", "application", "entry", "connect", "out", "conn", "connected", "config", "section", "client", "control", "object", "position", "character", "handler", "c", "con", "service", "relation", "reference", "environment", "context", "function", "response", "wrapper", "or", "current", "condition", "collection", "http", "use", "request", "open", "database"]}}
{"id1": "18989018", "id2": "17947246", "code1": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "code2": "    public String readURL(String urlLocation, ArrayList headers, RenderEngine c) throws Exception {\n        URL url = null;\n        HttpURLConnection conn = null;\n        InputStream istream = null;\n        try {\n            url = new URL(urlLocation);\n            conn = (HttpURLConnection) url.openConnection();\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to retrieve URL for '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        loadCookies(urlLocation, conn, c);\n        if (headers != null) {\n            for (int i = 0; i < headers.size(); i++) {\n                String header = (String) headers.get(i);\n                String key = header.substring(0, header.indexOf(\":\"));\n                String value = header.substring(header.indexOf(\":\") + 2);\n                Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                conn.setRequestProperty(key, value);\n            }\n        }\n        Debug.debug(\"Set to use GET, URL=\" + urlLocation);\n        try {\n            istream = conn.getInputStream();\n        } catch (Exception e) {\n            Debug.debug(\"Unable to capture input stream: \" + e.getMessage());\n            throw new Exception(\"Unable to capture input stream from URL '\" + urlLocation + \"': \" + e.getMessage());\n        }\n        Debug.debug(\"'GET' - Got input stream.\");\n        if (conn.getContentLength() == -1) {\n            Debug.debug(\"Content length = unknown\");\n        } else {\n            Debug.debug(\"Content length = \" + conn.getContentLength());\n        }\n        byte data[] = null;\n        int curPos = 0, contentLength = conn.getContentLength();\n        if (conn.getContentLength() == -1) {\n            String byteSize = NodeUtil.walkNodeTree(Server.getConfig(), \"//configuration/object[@type='engine.tunable']/property[@type='engine.unknowncontentsize']/@value\");\n            if (byteSize == null) {\n                contentLength = 4096;\n            } else {\n                contentLength = Integer.parseInt(byteSize);\n            }\n            Debug.debug(\"Content length unknown.  Allowing fuzz of \" + contentLength + \" bytes.\");\n        }\n        data = new byte[contentLength];\n        try {\n            int dataRead = 0;\n            while ((dataRead = istream.read(data, curPos, contentLength - curPos)) != -1) {\n                if (dataRead == 0) {\n                    break;\n                }\n                curPos += dataRead;\n            }\n        } catch (Exception e) {\n            throw new Exception(\"Soap is unable to read data from HTTP connection: \" + e.getMessage());\n        }\n        try {\n            istream.close();\n            conn.disconnect();\n        } catch (MalformedURLException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' is invalid: \" + e.getMessage());\n        } catch (IOException e) {\n            throw new Exception(\"Soap request to site '\" + urlLocation + \"' failed to connect.\");\n        }\n        String dataOut = new String(data);\n        int counter = 0;\n        data = null;\n        istream = null;\n        conn = null;\n        url = null;\n        return dataOut.trim();\n    }\n", "label": 0, "substitutes": {"doSetInput": [" doGetInput", " doSetContent", "dosetOutput", "dosetContent", "doGetContent", "doGetOutput", " doGetOutput", "doSetOutput", "doProcessInput", " doSetText", "dosetInput", " doGetText", "doGetInput", "doProcessOutput", "doProcessContent", "doProcessText", " doGetContent", " doSetOutput", "doSetContent", "doSetText", "doGetText", "dosetText"], "input": ["text", "form", "method", "util", "select", "remote", "expression", "output", "current", "client", "session", "inner", "field", "instance", "config", " inputs", "model", "head", "view", "Input", "command", "enter", "image", "present", "project", "install", "IN", "magic", "definition", "agent", "q", "argument", "act", "resource", "storage", "operator", "progress", "img", "error", "inf", "initial", "null", "exec", "child", "upload", "container", "list", "element", "submit", "raw", "impl", "parser", "insert", "request", "pull", "temp", "key", "entry", "reader", "type", "inc", "xml", "audio", "context", "active"], "monitor": ["p", "method", "meter", "summary", "out", "timer", "client", "pin", "mod", "config", "system", "state", "param", "timeout", "processor", "watch", "dm", "console", "manager", " monitors", "condition", "loader", "m", "module", "resource", "metadata", "progress", "mx", "directory", "callback", "subject", "counter", " Monitor", "mon", "channel", "mi", "Monitor", "bm", "handler", "cm", " monitoring", "wm", "mc", "reader", "unit", "pm", "report"], "root": ["work", "p", "remote", "result", "media", "output", "table", "out", "cover", "instance", "config", "home", "system", "this", "store", "archive", "slave", "owner", "manager", "src", "tx", "or", "process", "writer", "m", "folder", "resource", "Root", "location", "storage", "n", "directory", "base", "array", "null", "server", "host", "container", "target", "region", "plugin", "mount", "collection", "r", "parent", "node", "cms", "roots", "library", "http"], "format": ["form", "style", "filename", "util", "output", "FORM", "feature", "f", "config", "at", "model", "title", "event", "image", "et", "data", "magic", "writer", "service", "object", "location", "record", "transform", "act", "class", "base", "name", "spec", "Format", "function", "term", "api", "string", "fn", "handler", "element", "plugin", "filter", "parser", "attribute", "temp", "version", "template", "atter", "unit", "type", "ant", "pattern"], "source": ["text", "remote", "result", "output", "token", "client", "session", "inner", "instance", "config", "info", "component", "view", "use", "via", "driver", "src", "ource", "image", "SOURCE", "data", "Source", "service", "object", "resource", "proxy", "storage", "description", "spec", "secure", "container", "string", "connection", "scope", "channel", "size", "rule", "reference", "slice", "id", "reader", "unit", "rate", "parent", "node", "target", "content"], "in": ["text", "init", "buffer", "gin", "out", "session", "config", "image", "con", "isin", "name", "ins", "In", "slice", "inn", "token", "pin", "i", "conn", "or", "IN", "data", "ini", "win", "img", "n", "io", "nin", "include", "pull", "id", "parent", "bin", "str", "update", "socket", "ource", "resource", "from", "is", "container", "element", "value", "version", "login", "reader", "get", "din", "inc", "doc", "p", "inner", "c", "download", "f", "pass", "src", "inside", "read", "m", "on", "it", "min", "body", "index", "connection", "again", "r", "err"], "path": ["work", "text", "remote", "out", "session", "config", "alias", "PATH", "image", "loc", "location", "directory", "core", "base", "name", "log", "code", "true", "key", "template", "dir", "slice", "type", "pattern", "token", "sync", "this", "model", "component", "ath", "one", "data", "loader", "object", "binary", "password", "api", "thin", " Path", "mount", "id", "parent", "method", "str", "Path", "point", "link", "folder", "resource", " filename", "container", "string", "value", "step", "reader", "node", "content", "p", "filename", "port", " string", "pointer", "src", "host", "child", "index", "full", "route", "part", "walk"], "s": ["p", "ls", "sb", "ps", "ss", "sync", "session", "c", "f", "store", "sym", "e", "i", "l", "services", "src", "ds", "an", "m", "sys", "folder", "service", "ws", "storage", "n", "g", "sa", "si", "b", "share", "spec", "os", "fs", "sl", "secure", "stores", "h", "scope", " storage", "gs", "settings", "ns", "space", "abs", "sharing", "r", "ssl", "slice", "sf", "o", "sv", "S", "v", "js", "d", "http"], "file": ["p", "Image", "x", "filename", "remote", "copy", "File", "fp", "port", "output", "media", "f", "info", "store", "archive", "use", "il", "ile", "e", "l", "image", "xml", "data", "folder", "object", "resource", "binary", "open", "storage", "up", "directory", "FILE", "io", "base", "name", "b", "pe", "files", "string", "fn", "future", "full", " File", "value", "lib", "feed", "dir", "slice", "sf", "unit", "icon", "section", "node", "audio", "content"], "uri": ["text", "uni", "uid", "filename", "util", "username", "Url", "gi", "i", " URI", "image", "data", "abi", "service", "object", "location", "resource", "storage", "io", "base", "name", "database", "server", "URL", "ui", "query", "pi", "api", "address", "term", "iri", "connection", "rule", "prefix", "qi", "handler", "range", "attribute", "route", "cli", "dir", "URI", "id", "entry", "ri", "http"], "url": ["text", "ref", "str", "Url", "config", "store", "link", "l", "src", "ource", "image", "data", "object", "resource", "location", "sr", "io", "base", "name", "URL", "address", "sl", "string", "channel", "fr", "layer", "ul", "ssl", "key", "id", "user", "ri", "rel", "http"], "cd": ["CE", "cy", "cs", "CR", "md", "xc", "cf", "clean", "c", "lab", "de", "ca", "ds", "ci", "DC", "ce", "CD", "vd", "C", "CC", "cr", "nd", "pd", "gd", "dr", "rc", "cc", "arch", "cp", "dd", "cm", "co", "def", "xd", "CS", "ct", "cand", "ck", "cb", "d", "CF", "dc"], "valid": ["local", "Invalid", "normal", "style", "current", "Valid", "available", "empty", "successful", "all", "compatible", " invalid", "vals", "visible", "val", "present", "defined", "data", "required", "vari", " Valid", "allowed", "cert", "missing", "stable", "supported", "good", "multi", "VAL", "complete", "array", "standard", "multiple", "post", "secure", "list", "regular", "full", "legal", "iter", "bad", "value", "def", "sign", "id", "acceptable", "broken", "v", "correct", "pattern", "active"], "stream": ["flow", "message", "form", "video", "sw", "output", "client", "clean", "model", "content", "trans", "image", "read", "data", "writer", "object", "resource", "transform", "body", "container", "string", "Stream", "channel", "handler", "raw", "serial", "temp", "row", "feed", "response", "reader", "v", "draw", "context"], "document": ["text", "style", "filename", "video", "media", "output", "author", "system", "model", "this", "ocument", "image", "material", "data", "writer", "Source", "record", "object", "resource", "metadata", "description", "io", "Document", "Filename", "_", "Reader", "collection", "response", "template", "feed", "reader", "parent", "xml", "doc", "content"]}}
{"id1": "6341264", "id2": "8330057", "code1": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "code2": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"getJarEntry": ["getFolderEntry", "GetJarSource", "GetZipEntry", "loadJarEnt", "getZipentry", "getFolderInfo", "loadZipEntry", "getZipFile", "loadZipEnt", "loadZipFile", "GetJarEntry", "GetJarFile", "getEntryEntry", "getZipSource", "getEntryentry", "loadJarEntry", "getJarEnt", "getJarFile", "getZipInfo", "GetZipSource", "getJarentry", "GetZipFile", "getFolderFile", "getFolderSource", "getJarSource", "loadZipentry", "getEntryEnt", "GetZipInfo", "getZipEntry", "getJarInfo", "getjarEnt", "getjarFile", "getjarentry", "loadJarentry", "GetJarInfo", "getEntryFile", "getjarEntry", "getZipEnt", "loadJarFile"], "jarName": ["javaAlias", " jarId", "javaPath", "JarName", " jarPath", " jarID", " jarUrl", "browserName", "browserUrl", "JarAlias", "browserId", "javaName", " jarAlias", "jarPath", "javaUrl", "jarUrl", "jarAlias", "JarID", "browserAlias", "jarId", "javaId", "javaID", "jarID", "JarPath"], "entry": ["zip", "string", "path", "address", "ry", "ticket", "server", "uri", "id", "resource", "feed", "ie", "filename", "description", "host", "query", "ident", "Entry", "key", "offset", "type", "source", "jar", "connection", "str", "data", "file", "archive", "route", "plugin", "start", "name", "image", "secret", "element", "service", "enter"], "port": ["string", "path", "address", "server", "ort", "uri", "timeout", "version", "project", "limit", "patch", "length", "host", "time", "key", "offset", "password", "type", "delay", "target", "ports", "file", "ip", "name", "pos", "pid", "position", "PORT", "count", "Port", "service", "point", "direction"], "b": ["base", "buffer", "i", "beta", "bf", "emb", "bd", "eb", "lb", "c", "library", "cb", "l", "s", "bs", "obb", "orb", "pb", "mb", "bar", "reb", "abb", "d", "binary", "ab", "wb", "erb", "sb", "buff", "buf", "r", "ob", "fb", "p", "bb", "zb", "e", "nb", "db", "a", "bytes", "ib", "B", "bp", "v", "br", "xb", "f", "boot"], "codebase": [" codebas", "Codebas", "workBase", "corebar", "queb", "workbase", "corebase", " codefull", "workb", "broadb", "corebas", "queBase", "codebar", "CodeBase", "workfull", " codeBase", "broadbase", "quebase", "codebas", "quebas", "Codeb", "Codebase", "broadBase", "codeBase", " codebar", " codeb", "Codebar", "codeb", "broadfull", "coreBase", "codefull"], "protocol": ["Protocol", "Protology", "proport", " protology", "ocolocol", "ocolore", "verbocol", "protport", "predocol", "proocol", "Protport", "ocolurl", "predore", "predurl", "propology", "verbology", " protost", "proturl", "verbost", "prourl", "verburl", "propocol", "propurl", "proology", "predology", "Protore", "protology", "ocolology", "Protost", "propport", "Proturl", " proturl", "protost", "protore"], "x": ["val", "index", "xt", "xxxx", "max", "cross", "xf", "ex", "id", "xa", "xx", "z", "X", "en", "xxx", "xp", "d", "xd", "xes", "w", "work", "xs", "check", "xc", "h", "p", "es", "m", "ax", "lex", "rx", "pos", "exp", "xi", "ctx", "xxxxxxxx", "pe", "v", "y", "dx", "f", "wx", "tx", "fx", "ix", "ww"], "s2": [" sls", "e62", "patter", "xls", "o2", "sii", "s62", "v2", "osecond", "vtwo", "sls", "ptwo", "satter", "qsii", "e2", "v1", " s62", "esecond", "string2", "qsls", "s1", " s1", "qs2", "o62", "vatter", "o1", "ssecond", "e1", "stringtwo", "stwo", "xii", "p1", "qs1", " ssecond", "x1", " sii", "string1", "p2", "stringatter"], "x2": ["ix6", "ix0", "xSecond", "index6", "X1", "x6", "x0", "index2", " xSecond", "index0", "tx2", " x52", "X52", "XSecond", "tx1", "txSecond", "ix1", "index1", " x6", " x1", "X2", "x52", "x1", " x0", "ix2", "tx52"], "downloadHost": ["DownloadHost", " downloadDomain", "urlHost", "transferAddress", "updateAddress", " downloadAddress", "urlPort", "urlhost", "transferRoot", "transferPort", "downloadPath", "updateRoot", " downloadRoot", "updatehost", "urlDomain", "DownloadPath", "writePort", "transferHost", "downloadDomain", " downloadhost", "DownloadAddress", "downloadhost", "writeHost", "writeDomain", "downloadPort", "downloadRoot", " downloadPort", "transferhost", " downloadPath", "writehost", "transferPath", "Downloadhost", "updateHost", "downloadAddress"], "url": ["zip", "base", "ssl", "server", "uri", "resource", "user", "lock", "http", "rel", "j", "l", "il", "URL", "orb", "el", "util", "fl", "source", "jar", "connection", "ob", "build", "file", "li", "web", "ll", "bb", "log", "control", "ls", "ball", "coll", "image", "link", "sl", "rl", "service", "Url", "www", "ur", "obj", "ul", "contact", "f", "gl", "org", "loc"], "jurl": ["Jconnection", "Juri", "jUrl", "jjfile", "nurl", "ajurl", "jjob", "Jurl", "gUrl", "jeturi", "nconnection", "gURL", "jURL", "jetfile", "Jhttp", " jURL", "Jcoll", " jcoll", " jjob", "Jjob", "nURL", "jpURL", "ajuri", "jhttp", "jphttp", "jconnection", "jfile", "JUrl", " jfile", "ajfile", "jjcoll", "gurl", "gconnection", "jeturl", " jhttp", "jjurl", "JURL", "jjURL", "ajURL", "jetURL", "nUrl", "Jfile", "jpjob", "jpurl", "juri", "jcoll"], "je": ["zip", " ze", "jen", "ee", "pse", "ju", "ie", "kee", "py", "j", "se", "jl", "java", "jo", "si", "fr", "su", "la", "elt", "ja", "ji", "jar", "li", "Je", "jj", "ne", "oi", "js", "e", "ze", "jp", "obj", "ni", "opy", "Obj", "oe", "esi"], "is": ["zip", "info", "sin", "address", "i", "lis", "iss", "uri", "self", "IS", "isa", "http", "ie", "Is", "as", "ri", "api", "bs", "s", "il", "si", "ois", "ui", "ii", "ori", "in", "isl", "its", "so", "jar", "ais", "ob", "ir", "nis", "li", "src", "bb", "es", "ai", "ris", "js", "vs", "oss", "isin", "iris", "ios", "ib", "ses", "isi", "are", "obj", "state", "os", "iso", "cos", "mis"], "bis": ["zip", "uds", "sin", "base", "lis", "iss", "i", "uri", "pi", "IS", "usb", "bus", "lock", "serv", "http", "Is", "slice", "inner", "ri", "cb", "obb", "bs", "s", "abs", "ois", "bin", "ori", "bes", "binary", "sb", "bos", "oris", "bps", "connection", "proxy", "ubis", "ob", "ignore", "nis", "fb", "bb", "bi", "afi", "ris", "ls", "obs", "oss", "isin", "iris", "di", "ios", "ses", "obj", "abi", "os", "download", "bits", "boot", "cos", "mis"], "size": ["capacity", "address", "core", "sum", "close", "enc", "rc", "now", "act", "loc", "se", "eng", "mode", "large", "length", "si", "co", "grade", "time", "en", "content", "sized", "sync", "form", "cm", "rate", "use", "len", "small", "body", "cl", "hh", "init", "Size", "cel", "name", "ci", "cr", "send", "esc", "area", "SIZE", "speed", "unit", "shape", "ize", "err", "range", "sn", "scale", "width", "sec", "term", "iz"], "rb": ["bf", "rf", "nr", "rc", "lb", "vr", "eb", " rc", "ru", "cb", "rg", "lr", "obb", "ri", "rub", "orb", "rt", "RB", "pb", "rab", "gb", "reb", "abb", "rh", "sb", "wb", "ra", "erb", "buf", "r", "ob", "ruby", "src", "fb", "bb", "rar", "zb", "rr", "io", "rx", "rob", "cr", "nb", "adr", "area", "rl", "xb", "range", "rd", "sr", "loc"], "chunk": ["schrow", "bone", "chink", "Chunks", "cheunk", "shink", "prow", "CHink", "chunks", " Chunks", "clone", "punky", "clink", "pask", "cloy", "shoy", "cheunc", "chone", "qurow", "cheink", "chunky", "chunc", "CHunc", "boy", "quunk", " chunks", "schunk", "clunk", "shunk", "clunks", "chack", "quask", "Chack", "CHunk", "quunky", " Chunk", "schunky", " chack", " Chack", "chask", "chrow", "Chunk", "punk", "CHunks", "bink", "choy", "clunc", "cheunks", "bunk", "schask", "shone"]}}
{"id1": "23273706", "id2": "942693", "code1": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"getProjectTreeData": ["getProjectDocumentMeta", "getProjectTreeInfo", "getProjecttreeData", "getprojecttreeInfo", "getprojecttreeDATA", "getProjectPageData", "getprojectTreeData", "getProjecttreeDATA", "getProjectTreeDATA", "getProjecttreeInfo", "getProjecttreeMeta", "getprojectTreeDATA", "getProjectPageInfo", "getprojectTreeMeta", "getprojecttreeData", "getprojecttreeMeta", "getProjectTreeMeta", "getProjectDocumentData", "getprojectTreeInfo", "getProjectPageMeta", "getProjectDocumentInfo", "getProjectPageDATA", "getProjectDocumentDATA"], "treeData": ["treeDec", "reeArray", "bodyDat", "TreeInfo", " treeText", "treeString", "reeString", "storyData", "monkeyArray", "bodyList", "storyDec", "reeData", "contentDat", "treeText", "TreeArray", " treeDec", "treeList", "contentInfo", "storyArray", "TreeData", " treeArray", "bodyData", " treeString", "reeText", "bodyString", "treeInfo", " treeList", "reeInfo", " treeInfo", "reeDat", "contentText", " treeDat", "monkeyDat", "TreeString", "treeDat", "storyDat", "monkeyDec", "monkeyData", "treeArray", "TreeList", "reeList", "contentData"], "filename": ["folder", "txt", "username", "SourceFile", "string", "jpg", "kj", "xml", "title", "Filename", "path", "kn", "fd", "fil", "sheet", "whatever", "files", "database", "ppa", "framework", "fn", "prefix", "tmp", "upload", "url", "location", "dylib", "FILE", "dll", "password", "journal", "figure", "fp", "ername", "directory", "nil", "data", "wav", "metadata", "kl", "uri", "name", "file"], "urlString": ["URLstring", "addressStr", "URLUrl", "locationUrl", "locationString", "urlStr", "addressURL", "addressString", " urlURL", "locationStr", "URLStr", "addressstring", "URLString", " urlstring", "URLURL", "urlUrl", " urlStr", "locationstring", " urlUrl", "urlstring", "urlURL"], "urldata": ["urlddata", "URldata", "URlfdata", " urLDATA", "URldATA", "urLDdata", "urlfdata", "urlledta", "urlledata", "urldATA", "urledata", "urlfat", "urLDta", "urleddata", "urLDat", "urlleddata", "urlfATA", "urlldata", "urledATA", "urlfata", " urLDta", " urlddata", "URlfat", "urLDATA", "URldat", "urLData", " urldta", "urldat", "URlddata", " urldATA", "urllATA", " urLData", "urlledATA", "URlfata", " urLDdata", "urllat", "URlfATA", "urldta", "urledta", "urllata"], "factory": [" flier", "ufictionary", "confFactory", "cFactory", "fault", "cfFactory", "fFactory", " filler", "cfiller", "liller", "lactory", "ufiller", "confiller", "filler", "cflier", "luild", "pault", " fault", "cactory", "flier", "pFactory", "fictionary", "ufactory", "lictionary", " fuild", "cfactory", " fictionary", " fFactory", "ufuild", "cault", "ciller", "pactory", "conflier", "fuild", "confactory", "piller"], "parser": ["root", "ger", "pdf", "library", "string", "instance", "jack", "xml", "http", "utils", "raf", "manager", "api", "util", "monkey", "driver", "json", "er", "handler", "p", "up", "l", "ph", "s", "Parser", "loader", "fruit", "lp", "auto", "arser", "writer", "reader", "se", "parse", "r", "b", "plugin", "t", "parent", "uri", "builder"], "u": ["iu", "eu", " ur", "us", "uu", "c", "ru", "o", "http", "universal", "d", "U", "ur", "io", "util", "yu", "ui", "uv", "cu", "p", "l", "s", "plug", "url", "su", "uf", "ul", "hu", "ou", "tu", "b", "uri", "nu", "uni", "lu"], "is": ["ib", "or", "us", "isa", "ip", "ios", "serv", "ob", "isl", "pi", "ir", "http", "iris", "has", "as", "gets", "io", "api", "ais", "IS", "abs", "ui", "in", "ri", "are", "ie", "p", "fs", "it", "obs", "init", "s", "Is", "iso", "iss", "ar", "ops", "its", "ori", "mis", "bis", "lis", "isu", "ai", "es", "info", "uri", "ris"], "os": ["or", "us", "ms", "ol", "ios", "so", "bs", "ens", "ob", "osi", "o", "dos", "opens", "http", "oa", "fits", "oss", "as", "gets", "io", "sys", "aos", "bos", "oes", "oos", "fs", "ose", "obs", "s", "pos", "los", "iso", "ops", "cos", "Os", "oses", "ros", "bis", "ils", "ps", "es", "OS"], "iBufSize": ["iBytebufSize", "iLlfSt", "iLlfsize", "iBytebufsize", "iBytebufLength", "iBlfLen", "iBlfLength", "iByteufSize", "iBufferLength", "iBytebufLen", "iBufferSt", "iLlfLength", "iBufLen", "iByteufLen", "iLufSize", "iByteufLength", "iBufsize", "iBbufSize", "iBlfSt", "iLlfSize", "iBbufLen", "iBuffLength", "iBlfSize", "iBuffSt", "iBuffsize", "iBufSt", "iBufferSize", "iBuffersize", "iBbufLength", "iByteufsize", "iBlfsize", "iBufLength", "iLufsize", "iLufSt", "iBbufsize", "iLufLength", "iBuffLen", "iBuffSize"], "inBuf": ["outBuffbuf", "inBbuf", "inCuff", "outBuffub", "outBub", "outBuffuf", "inBlump", "inFbuf", "inBuffump", "inBunk", "inFaf", "inDbuf", "inBuff", "inCbuf", "inbuf", "inCunk", "inPlunk", " inBump", "inCump", "inDuf", "inBump", " inCbuf", "inFuff", " inBunk", " inFaf", "inPlbuf", "inBluf", " inFuff", "outBump", " inBaf", " inBbuf", "inBlbuf", "inBuffuf", "inbub", "inPluf", "inCuf", "inFuf", "inDuff", "inBub", "inBuffbuf", "inPlump", " inCunk", "inbump", "inBlub", "outBuffump", "inDaf", " inCuf", " inBuff", "outBuf", "inCaf", "inBlunk", " inFbuf", "inBuffub", "outBbuf", "inBaf", "inbbuf", " inCump", " inFuf"], "iNumRead": ["iValBuild", "iChanBuild", "pNumWritten", "iChanRead", "pNumread", "qiNumBuild", "qiValBuild", "iFatWritten", "iNumberBuild", "qiNumRead", "inumWritten", "inumRead", "qiNumREAD", "pNumberRead", "pNumberWritten", "iNumberREAD", " iFatWrite", "pNumWrite", "iNumberWrite", "iLenWritten", "iNumread", "qiValread", "inumread", "iLenRead", "iChanread", "iNumberWritten", "iFatRead", " iFatWritten", "inumWrite", "iNumWritten", "pNumberread", "iNumberRead", "iValread", " iNumWrite", "iChanREAD", "qiNumread", "iNumBuild", "pNumRead", "iLenWrite", "iNumWrite", "qiValREAD", "pNumberWrite", " iFatRead", "iValRead", "iNumREAD", "qiValRead", " iNumWritten", "iFatWrite", "iValREAD", "iNumberread"], "f": ["fa", "df", "fe", "fr", "F", "fc", "full", "g", "c", "n", "m", "o", "sf", "d", "fd", "io", "feed", "fn", "handler", "p", "fs", "l", "ff", "s", "j", "fi", "e", "uf", "h", "fp", "v", "r", "b", "t", "file", "rf"], "inputstream": ["outputchannel", "inputsystem", "inputsw", " inputStream", "inputStream", "contentsw", "outputStream", "Inputsystem", "Inputchannel", "contentstream", "Inputstream", " inputchannel", "contentStream", " inputsw", "InputStream", "contentsystem", "outputstream", " inputsystem", "Inputsw", "inputchannel"], "document": ["window", "media", "container", "project", "n", "m", "context", "xml", "d", "language", "node", "response", "list", "tree", "doc", "Document", "content", " documents", "object", "p", "l", "Documents", " documentation", "office", "e", "director", "dom", "record", "page", "html", "output", "DOM", "data", "directory", "docs", "ocument", "null", "t", "info", "source", "parent", "collection", "file"], "nodelist": ["Nodemark", "NODestyle", "nonedette", " nodeselist", "nodeestate", "Nodestyle", "nonedename", " nodesename", "nozelist", "snodselist", "anodedelist", "anodedestate", "anodedeme", "nODeline", "nozels", "anodata", "nozemark", "nodesh", "nODestyle", "nodeeme", "nodeata", " nodename", "anodeme", "nODesh", "nodedestyle", "nodename", "nodeelist", "nondeme", "nodesels", "snodeline", "anodedata", "nodeline", "nondelist", "Nodesh", "nodeme", "nondestate", "nodedata", "Nodelist", "nodata", " nodesels", "nonedels", "nodedlist", "snodelist", " nodels", "nodedeline", "NODelist", "nodlist", "nodsette", "nonedelist", "nozestyle", "nozename", "nodestate", "nODemark", "nozette", "nodselist", "nODette", "nODlist", "nodeselist", "anodestate", "snodette", "nODelist", "NODemark", "nodedeme", " nodette", "nodels", "nodestyle", "snodsette", "snodlist", "anodelist", "nodette", "nodseline", "nondata", "nozesh", "nodedelist", "nodesename", " nodesette", "snodslist", "snodseline", "nodedesh", "nodedette", "nodedemark", "nodedestate", "NODesh", "nodemark", "nodslist", "nodesette"], "num": ["span", "temp", "nb", "multi", "n", "zero", "m", "col", "um", "total", "mult", "node", "sum", "con", "np", "norm", "number", "NUM", "div", "umi", "nr", "mu", "count", "unit", "Num", "loc", "om", "comb", "part", "net", "init", "pos", "max", "index", "len", "ul", "nom", "lim", "dom", "tri", "mon", "en", "nam", "inc", "nu", "uri", "dim", "uni"], "i": ["iu", "hi", "si", "qi", "chi", "ip", "multi", "g", "ii", "ini", "c", "pi", "col", "o", "y", "m", "d", "ci", "di", "io", "slice", "ji", "ui", "in", "ri", "bi", "ie", "p", "it", "l", "part", "phi", "j", "I", "eni", "fi", "x", "index", "cli", "isi", "oi", "li", "ori", "a", "start", "v", "gi", "ti", "mi", "ai", "yi", "b", "xi", "id", "info", "uri", "iv", "ix", "mu", "ik"]}}
{"id1": "7296597", "id2": "4921631", "code1": "    public void create() {\n        Connection conn = OrmHandler.getInstance().getSession().getConnection(this);\n        Statement stat = null;\n        StringBuilder sql = new StringBuilder(256);\n        try {\n            getRenderer().printCreateDatabase(this, sql);\n            conn = createConnection();\n            stat = conn.createStatement();\n            stat.executeUpdate(sql.toString());\n            conn.commit();\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.info(sql.toString());\n            }\n        } catch (Throwable e) {\n            if (conn != null) {\n                try {\n                    conn.rollback();\n                } catch (SQLException ex) {\n                    LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n                }\n            }\n            throw new IllegalArgumentException(\"Statement error:\\n\" + sql, e);\n        } finally {\n            try {\n                close(conn, stat, null, true);\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n            }\n        }\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 1, "substitutes": {"create": ["process", "error", "clone", "connect", "save", "query", "init", "construct", "write", "run", "open", " recreate", "build", "start", "store", "close", "exec", "make", "update", "clear", "log", "drop", "database", "Create", "setup", "destroy"], "conn": ["db", "ai", "error", "client", "connect", "ca", "Conn", "h", "sync", "ctx", "n", "obj", "cert", "cp", "socket", "cn", "rc", "pg", "cat", "cr", "nt", "ci", "core", "ex", "sb", "coll", "cache", "server", "ann", "loc", "adj", "open", "connection", "nc", "dc", "ssl", "con", "conf", "pub", "connected", "oci", "ch", "enc", "serv", "exec", "col", "session", "ac", "close", "log", "rt", "org", "ct", "contract", "co", "Connect", "mc", "commit", "Connection", "lock", "act", "c", "pr"], "stat": ["stats", "db", "error", "su", "success", "pas", "connect", "vis", "sync", "query", "ga", "init", "sit", "cat", "id", "statement", "cli", "sn", "ex", "cache", "sb", "fail", "reg", "ann", "info", "adj", "state", "pr", "debug", "con", "bas", "str", "pred", "close", "null", "serv", "exec", "session", "login", "err", "log", "b", "spec", "shell", "status", "it", "Stat", "name", "auth", "si", "commit", "da", "act", "config", "STAT", "sp"], "sql": ["stats", "where", "db", "su", "error", "query", "msg", "html", "socket", "s", "comment", "ls", "cli", "statement", " SQL", "sol", "sn", "SQL", "sb", "info", "sf", "connection", "params", "xml", "ssl", "str", "util", "url", "col", "serv", "zip", "session", "data", "sq", "log", "dl", "database", "shell", "status", "text", "auth", "ql", "ss", "string", "nl", "si", "seed", "general", "sv", "select", "sp"]}}
{"id1": "18504192", "id2": "22479286", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyfile", "CopyFile", "copyfile", "transferfile", " copyStream", "CopyStream", "transferFiles", "copyStream", "transferStream", " copyFiles", "Copyfile", "CopyFiles", "copyFiles", "transferFile"], "in": ["IN", "index", "info", "base", "buffer", "i", "input", "id", "copy", "ini", "c", "inner", "ins", "bin", "part", "at", "reader", "d", "login", "min", "old", "diff", "inc", "parent", "data", "file", "src", "or", "again", "name", "m", "image", "io", "In", "url", "b", "ac", "inn"], "out": ["string", "base", "temp", "ex", "output", "n", "copy", "c", "OUT", "outs", "o", "dest", "line", "password", "client", "part", "cache", "connection", "target", "w", "inc", "data", "file", "object", "p", "conn", "name", "again", "exec", "Out", "writer", "io", "call", "prefix", "b", "obj", "err", "external", "point"], "source": ["sin", "ssl", "core", "i", "input", "self", "server", "copy", "Source", "settings", "ie", "slice", "slave", "project", "se", "dest", "origin", "ources", "clone", "SOURCE", "iter", "client", "sync", "use", "reader", "proxy", "connection", "target", "scope", "component", "parent", "channel", "src", "size", "get", "null", "start", "writer", "sl", "secure", "stream", "unit", "ource", "service", "from", "view", "storage"], "destination": ["declinated", "dependination", "contining", "declination", "testination", "testinated", " destinations", "dependinator", "declification", "destining", "continator", " destinated", "destinated", "testinator", " destinator", "Destination", "Destinated", "dependification", "Destification", "Destinator", "destification", "contination", "dependinated", "Destining", "declinator", "destinator", "testinations", "continated", "Destinations", "destinations", " destining"]}}
{"id1": "1371265", "id2": "19810820", "code1": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"update": ["replace", "save", "UPDATE", "write", "report", "append", "resource", "apply", "updated", "info", "data", "set", "index", "run", "create", "add", "Update", "edit", "delete", "table", "select", "json", "query", "insert", "request", "post"], "channelPath": ["downloadpath", "downloadObject", "fileObject", "downloadMap", " channelpath", "resourceObject", "filePath", "resourceMap", "downloadPath", "resourcePath", "resourcepath", "fileMap", "filepath", " channelObject", " channelMap"], "dataField": ["responseFIELD", "alphaField", "DataArea", "resourceField", "dataTerm", " dataFIELD", "responseTerm", "responseField", "DataField", "dataArea", "responsefield", "DataTerm", " dataTerm", "resourcefield", "alphaTable", "resourceFIELD", "alphaArea", "resourceTerm", "alphaTerm", " datafield", "DataTable", "datafield", "dataTable", " dataTable", "dataFIELD", " dataArea"], "fatherDocId": ["fatherDocName", "fatherPoID", "fatherFilePath", "motherDocInfo", "motherDocID", "fatherPoid", "fatherDocInfo", "motherDocumentInfo", "fatherDocumentName", "fatherDocumentPath", "fatherdocName", "motherDocName", "fatherdocId", "motherDocumentid", "fatherDocID", "motherDocumentName", "fatherdocInfo", "fatherWriterName", "motherDocId", "fatherWriterID", "motherDocumentID", "fatherFileid", "fatherFileName", "motherDocumentId", "motherDocid", "fatherFileID", "motherDocumentPath", "fatherPoName", "fatherdocPath", "fatherWriterInfo", "fatherWriterId", "motherDocPath", "fatherWriterid", "fatherDocumentId", "fatherDocumentID", "fatherFileInfo", "fatherFileId", "fatherDocid", "fatherDocumentInfo", "fatherDocPath", "fatherPoId", "fatherDocumentid"], "sqlInitial": ["qlinitial", "qlFinal", "qlInitialized", " sqlInitialized", "sqlInitialized", "qlInitial", "SQLInitialized", "SQLInitial", "sqlinitial", "queryInit", "SQLInit", " sqlInit", "SQLinitial", " sqlinitial", "queryInitial", "queryinitial", "queryFinal", "SQLFinal", "qlInit", "sqlInit", "sqlFinal"], "sqlsortURL": ["sqlssortURI", "sqlsORTURI", "sqlsourceURL", "sqlsorturl", "sqlsendURL", "sqlsORTurl", "sqlsaltSSL", "sqlsORTURL", "sqlsortUrl", "sqLSORTURI", "sqLSorturl", "sqlsaltURI", "sqlsortSSL", "sqllortUrl", "sqlsaltURL", "sqllortURI", "sqllaltURL", "sqLSortURI", "sqlssorturl", "sqlsendUrl", "sqlsourceUrl", "sqLSortURL", "sqLSORTURL", "sqLSortUrl", "sqlsendURI", "sqlssortUrl", "sqllaltURI", "sqlsaltUrl", "sqlsendSSL", "sqlsourceURI", "sqllortURL", "sqlsORTUrl", "sqlsourceurl", "sqlsortURI", "sqllaltUrl", "sqLSORTurl", "sqLSORTUrl", "sqllaltSSL", "sqlssortURL", "sqlsourceSSL", "sqllortSSL"], "conn": ["rt", "res", "ct", "cn", "col", "core", "Connect", "conf", "cp", "connection", "n", "rc", "pg", "en", "act", "lock", "session", "sql", "sync", "reg", "oss", "Connection", "ht", "pt", "syn", "connect", "mc", "nt", "coll", "ch", "nc", "ci", "ens", "Conn", "cc", " con", "cat", "pr", "oci", "client", "co", "db", "apt", "ann", "orp", "pc", "con", "c", "dc", "dn", "net", "ctx", "pub", "cs", "ca", "enc", "cr", "p", "ds"], "rs": ["rt", "ros", "maps", "asts", "res", "rss", "rors", "arch", "ins", "rows", "DS", "rx", "mr", "rc", "obs", "PS", "ns", "acks", "ges", "hs", "ows", "vs", "rys", "rb", "ys", "lines", "ms", "rg", "s", "Rs", "RS", "results", "ues", "pr", "its", "src", "rl", "rr", "qs", "ras", "r", "sc", "ars", "ris", "ocr", "icks", "sels", "xs", "repl", "rd", "sr", "ts", "ans", "hr", "ats", "ra", "cs", "pers", "bs", "cr", "rep", "ks", "runs", "ds", "vers"], "ps": ["ros", "pe", "res", "ins", "DS", "ss", "pg", "pl", "os", "PS", "ns", "aps", "pos", "pse", "pt", "syn", "fs", "vs", "pa", "pres", "amps", "ys", "ips", "ens", "s", "Rs", "RS", "ws", "Ps", "pr", "pass", "LS", "posts", "pex", "co", "ports", "ras", "pps", "eps", "po", "ms", "pc", "con", "ars", "ts", "pre", "sp", "pm", "ans", "ons", "gs", "jp", "ples", "cs", "ups", "pers", "pp", "bs", "p", "ks", "ds"], "dbo": ["Dbo", "ldbo", "bpo", "dba", " dBo", "bbo", "dBo", "dbc", " dbc", "Dpo", "mdBo", "Dbi", " dba", " dbi", "mdbo", "dbi", "bbi", "dpo", "mdba", "DBo", "mdbc", "bBo", "ldba", " dpo", "ldbc", "ldBo"], "url": ["ur", "page", "text", "fl", "uri", "ssl", "resource", "ll", "image", "server", "html", "fr", "view", "loc", "rel", "force", "data", "username", "blog", "f", "rule", "route", "www", "URL", "str", "href", "nl", "date", "download", "source", "src", "rl", "filename", "l", "hl", "r", "id", "address", "language", "string", "email", "file", "name", "sl", "host", "layer", "path", "Url", "location", "response", "q", "http", "feed", "request"], "st": ["ost", "sth", "std", "rt", "pe", "Str", "est", "fr", "stri", "nd", "const", "ss", "ste", "ut", "sts", "stress", "ST", "pt", "sb", "inst", "str", "sn", "stack", "cl", "s", "rest", "stop", "pr", "St", "th", "src", "ist", "l", "sw", "ft", "r", "sc", "string", "start", "rd", "t", "sl", "sp", "ast", "ld", "la", "bl", "sh", "sta", "x", "ust", "cr", "p"], "sortDocId": ["updateDocumentInfo", "updateDocumentid", " sortFileId", "sortdocName", "sortDOCid", "sortDocumentId", "sortDepID", "updateDocID", " sortDocumentid", "sortDepInfo", "sortDocumentid", " sortFileID", " sortDocumentID", "sortWriterID", " sortDocumentId", "sortdocid", "updateDocumentId", "sortDepId", "sortdocId", "sortPageid", "sortDocumentInfo", "sortdocPath", "sortDOCName", "sortdocInfo", "sortDocid", "sortWriterid", "sortFilePath", " sortDocID", "sortPageName", "sortFileid", "sortDepid", "sortDocumentID", "updateDocumentID", "updateDocid", "sortPageID", "sortDocumentPath", " sortDocPath", "updateDocId", " sortDocumentName", "sortDocPath", "sortDOCID", "sortDocumentName", "sortFileInfo", "updateDocInfo", "sortDocInfo", " sortFilePath", "sortWriterName", "sortdocID", "sortFileID", "sortDocName", " sortDocName", "sortDOCId", "sortWriterId", " sortFileInfo", "sortDocID", "sortPageId", " sortDocid", "sortDepName", "sortFileId", " sortDocInfo"], "flag": ["prop", "fl", "standard", "debug", "count", "offset", "star", "FLAG", "tag", " Flag", "data", "leaf", "store", "child", "sync", "bit", "blog", "part", "func", "bool", "field", "status", "agg", "str", "key", "inline", "only", "cat", "fun", "Flag", "id", "ind", "match", "string", "lag", "file", "start", "wait", "binary", "arg", "bug", "ret", "format", "flags", "ag", "force", "use", "kind", "ext", "char"], "sqlsort": ["sqLSorted", " sqlesort", "sqlessort", "sqllorter", "sqLSsort", " sqLSort", "sqLSORT", " sqlesorter", "sqlesORT", "sqLSorts", "sqlesort", " sqLSorts", "sqLSort", " sqLSORT", " sqlsorted", " sqlssort", "sqLSorter", "sqllORT", "sqlsORT", "sqssort", "sqsORT", " sqlsorter", "sqllorted", " sqlesORT", "sqlsorter", "sqllort", "sqlssort", " sqlesorted", "sqlesorted", " sqLSsort", "sqlsorts", "sqlsorted", "sqlesorts", "sqsorts", " sqlsORT", "sqlesorter", " sqlsorts", "sqsort"], "sortURL": ["editurl", "altSSL", "altUrl", " sortSSL", "sortID", "ortID", "editUrl", "SortUrl", " sortURI", "SortURL", "searchUrl", "sortURI", "searchID", "updateSSL", "updateUR", " sorturl", "sortSSL", " sortUrl", "updateURL", "editUR", "sorturl", "searchURI", "editURL", "ortURL", "updateURI", "SortUR", "ortSSL", " sortUR", "altURL", "sortUR", "altUR", "searchURL", "ortURI", "searchUR", "sortUrl", " sortID", "ortUR", "Sorturl", "ortUrl"], "sortflag": ["addressflag", "considerflag", " sortFlag", "ortFlag", "sortfeed", "considerfeed", " sorttype", "orttype", "sortFlag", "ortflags", "filtertype", "SortFlag", "Sortflag", "considerflags", "addressfeed", "ortlike", "sorttype", "ortFLAG", "sortlike", "SortFLAG", "addressflags", "filterFLAG", "sortflags", "sortFLAG", " sortFLAG", "addresslike", "filterflag", "ortflag", "considerlike", "ortfeed"]}}
{"id1": "62362", "id2": "20855053", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "label": 0, "substitutes": {"convert": ["conversion", "CONvert", " deconversion", "Converting", "unverted", "subvert", "CONverted", "subverting", "Convert", "CONversion", "unception", "converted", "subversion", "oconvert", "Conversion", "Conception", "oconverting", " deconverted", "oconversion", "unversion", "conception", "converting", "CONception", "subverted", "unvert", " deconverting", " deconvert", "oconverted", "CONverting", "Converted"], "src": ["SourceFile", "buf", "sth", "fn", "prot", "component", "req", "url", "uri", "ssl", "resource", "st", "cmp", "loc", "Dest", "rc", "back", "username", "sys", "sb", "impl", "inst", "Source", "spec", "input", "sn", "cpp", "storage", "ref", "rb", "supp", "href", "attr", "cb", "s", "download", "code", "sin", "source", "reader", "config", "filename", "tmp", "stream", "rl", "slice", "sc", "video", "sit", "string", "load", "ource", "file", "obj", "upload", "gb", "name", "RC", "gz", "dist", "stage", "sel", "ctx", "proc", "path", "secure", "scene", "fp", "img", "feat"], "dest": [" dst", "std", "fn", "txt", "disk", "null", "Dest", "dat", "test", " destination", "home", "temp", "source", "class", "dir", "tmp", "di", "target", "bin", "obj", "dist", "dc", "path", "cont", "orig", "lib", "img"], "in": ["ex", "ins", "In", "n", "ps", "io", "data", "inc", "f", "input", "din", "IN", "d", "inn", "inas", "val", "inf", "pass", "i", "is", "source", "win", "reader", "a", "stream", "login", "r", "bin", "err", "file", "t", "up", "pin", "ini", "as", "doc", "isin"], "p": ["m", "pe", "np", "lp", "e", "j", "g", "b", "cp", "ps", "pg", "bp", "parser", "part", "f", "py", "P", "pa", "pb", "d", "o", "h", "s", "pr", "i", "pd", "l", "wp", "pi", "r", "po", "pc", "v", "c", "t", "per", "sp", "pre", "op", "pm", "jp", "pp", "fp", "tp", "cop"], "ds": ["des", "ths", "rs", "data", "ded", " DS", "vs", "dat", "ys", "dm", "models", "nas", "cs", "utils", "ups", "bs", "ks", "ipes", "df", "dos", "js", "ads", "DS", "obs", "parts", "gd", "dl", "qs", " sd", "eps", "dds", " ps", "dp", "ls", "points", "ps", "sys", "uds", "sts", "sync", "dd", "groups", "ges", "Ds", "d", "lines", "s", "pd", "db", "da", "ils", "icks", "ld", "ts", "gs", "services", "ants", "cons", "ins", "lp", "ss", " props", "os", "ns", "dates", "plugins", "hs", "amps", "docs", "posts", "tools", "vals", "di", "scripts", "dist", "tests", "dc", "xs", "ays", "ans", "words", "els", "dt", "styles"], "format": ["filter", "at", "fd", "prefix", "fn", "url", "frame", "unit", "struct", "style", "form", "letter", "act", "atter", "tag", "data", "version", "scale", "parser", "part", "model", "f", "spec", "template", "type", "sche", "plugin", "source", "class", "api", "config", "record", "nat", "filename", "table", "layout", "string", "language", "handler", "file", "Format", "name", "t", "magic", "pattern", "host", "function", "ant", "path", "fp", "feat"], "hasPixelData": ["hasByteStyle", " hasPixeldata", "hasPixelStyle", "hasPixeldata", "showsByteStyle", "haspixelSize", "haspixeldata", "hasByteDATA", "hasPicturedata", "showsPixelData", "showsPixeldata", "hasByteData", " hasPixelSize", "hasPixelDATA", "showsPixelStyle", "hasPixelSize", "hasByteSize", "showsBytedata", "showsPixelDATA", "hasPictureData", "hasPictureSize", "hasBytedata", "showsByteDATA", "haspixelData", "showsByteData"], "inflate": ["inflated", "infolATE", "invenode", "inFlation", "Inflace", "insvenATE", "InFlace", "inffated", "infloated", "inflation", "Inflation", "insvenode", "Inflated", "infloate", "inflating", "infolating", "inffate", "inadequate", "infloace", "insflate", "inflode", "inadequATE", "insflATE", "InFlated", "invenating", "inFlated", "infolode", "insflating", "inflace", "Inflate", "inadequode", "InFlation", "inFlate", "infface", "invenate", "inadequating", "inffation", "insvenating", "infloation", "inflATE", "invenATE", "insvenate", "inFlace", "insflode", "InFlate", "infolate"], "pxlen": ["fxden", "txlon", "pxcount", "camln", "txlen", "pnglen", "txlin", "pglen", "pxden", "xplength", "axlon", "pxLen", "mxln", "mxdata", "pgden", "ppl", "axlin", "fxLen", "campos", "pxlon", "pgLen", "xplen", "camdata", "mxsize", "pcln", "mxlen", "ppLen", "pxlin", "xpsize", "pxlength", "pgl", "fxlen", "fxln", "pnglength", "pclon", "mxcount", "mxpos", "pxpos", "ppden", "axlen", "pplen", "pxl", "mxlength", "camlen", "pclen", "axln", "fxl", "fxdata", "pngsize", "pxsize", "pxln", "fxpos", "pclin", "xpcount", "pngcount", "txln", "pxdata"], "out": ["page", "pad", "gen", "log", "server", "copy", "parent", "lock", "io", "store", "sys", "step", "session", "output", "group", "Out", "error", "conn", "cli", "work", "co", "dump", "point", "outs", "user", "cache", "v", "err", "obj", "list", "re", "up", "inter", "OUT", "query", "state", "again", "line", "lib", "post"]}}
{"id1": "2017833", "id2": "5441579", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["get", "h", "html", "ash", "block", "crypt", "print", "parse", "check", "replace", "format", "sum", "message", "Hash", "build", "str", "base", "set", "update", "transform", "sha", "number", "string", "add", "dump", "create", "hex"], "text": ["image", "font", "buffer", "template", "bytes", " Text", "key", "class", "output", "object", "pattern", "context", "input", "Text", "version", "code", "format", "content", "path", "message", "TEXT", "ext", "word", "editor", "translation", "out", "value", "EXT", "str", "url", "letter", "binary", "data", " TEXT", "struct", "secret", "token", "test", "number", "contract", "name", "password", "string", "source", "length", "hex", "txt"], "UnsupportedEncodingException": ["UnsupportedEncgorithmException", "UnsupportedencodedWarning", "UnsupportedEncodingWarning", "UnsupportedEncodedception", "UnsupportedEncodingception", "Unsupportedencodedception", "UnsupportedEncodedException", "UnsupportedEncasingception", "UnsupportedEncgorithmception", "Unsupportedencodingception", "UnsupportedencodingWarning", "UnsupportedEncasingException", "UnsupportedEncodedWarning", "UnsupportedEncgorithmWarning", "UnsupportedencodingException", "UnsupportedEncasingWarning", "UnsupportedencodedException"], "md": ["mm", "mac", "mo", "ind", "m", "dig", "bf", "mad", "ad", "metadata", "um", "ma", "od", "bm", "rm", "message", "amd", "mb", "nm", "wd", "ds", "gd", "mand", "bd", "f", "mg", "dm", "pm", "sha", "mt", "MD", "mp", "mc", "mod", "mag", "hd", "d", "vd", "ld", "ms", "meta", "am", "cmd", "dd", " MD", "hm"], "sha1hash": ["sha4hash", "ha2hash", "ha1hex", "sha4hex", "ha2hex", "sha3sum", "ha2match", "sha2match", "sha5Hash", "SHA1hex", "sha4Hash", "sha1h", "sha2hash", "sha5hex", "sha1Hash", "SHA2hash", "SHA2h", "ha1sum", "sha3hex", "SHA1hash", "shaonehex", "sha1match", "sha4sum", "sha5hash", "sha256Hash", "shaonesum", "sha5sum", "SHA2Hash", "sha2h", "sha5h", "SHA1sum", "sha2hex", "ha1hash", "SHA1Hash", "sha256hash", "sha3match", "sha2sum", "shaonematch", "sha2Hash", "sha256sum", "SHA1h", "shaonehash", "SHA2sum", "sha1sum", "sha1hex", "sha3hash", "ha2sum", "sha256h", "ha1match"]}}
{"id1": "2668853", "id2": "8778962", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFiletoFiles", "decodeFileAsStream", "decodeString2file", "decodeFile2Stream", "decodeFiletoFile", "decodeFileToStream", "decodeFiletofile", "decodeFileAsFiles", "decodeFileTofile", "decodeStringToFile", "decodeStringTofile", "decodeStringToStream", "decodeFileAsFile", "decodeString2Stream", "decodeFile2File", "decodeString2File", "decodeFileAsfile", "decodeFiletoStream", "decodeFileToFiles", "decodeFile2file", "decodeStringToFiles", "decodeString2Files", "decodeFile2Files"], "infile": ["minfile", "infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", "inputfp", " inFile", "inputFile", "outfiles", " infilename", "inputfiles", " infiles", "outfp", "minfilename", "minFile", "minfp", "inputfilename", "infilename"], "outfile": ["infp", "outfull", "outputfile", " outfull", "outfilename", "outFile", " outFile", "infolder", "outputfolder", " outfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "outputfull", "Outfull", "Outfolder", "OutFile", "Outfile", "outputFile", "infilename", " outfilename"], "in": ["IN", "pin", "i", "input", "inas", "ex", "ini", "gin", "ic", "con", "inner", "socket", "as", "ins", "s", "bin", "is", "reader", "source", "up", "login", "min", "inside", "r", "inc", "data", "rin", "init", "conn", "again", "m", "e", "image", "re", "In", "nin", "a", "lin", "err", "b", "ac", "cin", "inn", "f", "win", "this", "din"], "out": ["base", "ex", "output", "copy", "outer", "op", "lock", "on", "net", "OUT", "socket", "as", "inner", "outs", "o", "s", "off", "line", "write", "bin", "co", "pass", "exit", "post", "client", "sync", "session", "no", "cache", "lib", "up", "target", "other", "inc", "work", "file", "conn", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "exp", "In", "ext", "b", "obj", "err", "error", "point"], "buffer": ["address", "base", "input", "Buffer", "uffer", "resource", "pause", "border", "server", "feed", "slice", "limit", "result", "length", "bin", "memory", "queue", "offset", "iter", "split", "reader", "source", "binary", "seed", "buff", "value", "buf", "wave", "data", "size", "bb", "null", "row", "bytes", "layer", "flush", "url", "shape", "b", "reference", "padding", "pad", "transfer", "batch"], "read": ["index", "Read", " receive", " r", "run", "ride", " get", "open", " copy", "get", "lex", " send", " check", "id", "feed", "add", "ind", "end", "find", " reach", "next", "sync", "use", "load", " sleep", "r", "work", "fill", "exec", "skip", "connect", " request", "play", " use", "reading", " parse", "limit", "se", "length", "write", "line", "ad", "sleep", "iter", "allow", "reader", " Read", "start", "tell", " load", "wait", " write", "input", "copy", " connect", "current", "reads", "pass", "select", " ride", "seek", "inc", " find", "check", "x", "size", " reader", "send", "k", "parse", "count", "READ"], "success": ["roll", "accept", "job", "response", "rolling", "ok", "continue", "ceed", "results", "warning", "better", "yes", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "selected", "default", "data", "safe", "null", "cess", "danger", "complete", "again", "status", " successful", "full", "correct", "good", "Success", "successful", "successfully", "rolled", "found", " succ", "zero", "error", "fast", "first", "winner", "initial"]}}
{"id1": "2668853", "id2": "11341711", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileAsStream", "decodeFiletoStream", "decodeStringTofile", "decodeFiletofile", "decodeFileToFiles", "decodeFile2File", "decodeStringToStream", "decodeFiletoFiles", "decodeFileAsfile", "decodeFileAsFile", "decodeString2File", "decodeFiletoFile", "decodeFileTofile", "decodeString2Stream", "decodeFile2file", "decodeStringToFiles", "decodeString2Files", "decodeFileToStream", "decodeFile2Stream", "decodeFileAsFiles", "decodeStringToFile", "decodeFile2Files", "decodeString2file"], "infile": ["inputFile", "inputfilename", "outfilename", "infilename", "inputfile", "outFile", "inputfiles", "minfile", "outfiles", "infp", "inputfp", "outfp", " infilename", " infiles", " inFile", "infiles", "minfp", "minFile", "minfilename", "inFile"], "outfile": ["outputfilename", "Outfile", "outfilename", "infilename", "outputFile", "outFile", "Outfolder", " outfp", " outfilename", "infp", "outfp", " outFile", "outputfull", " outfull", "outfull", "Outfull", " outfolder", "outputfp", "outputfile", "infolder", "OutFile", "outputfolder", "outfolder"], "in": ["reader", "bin", "login", "f", "data", "socket", "inas", "s", "ins", "pin", "m", "cin", "ex", "min", "In", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "e", "ini", "this", "i", "source", "init", "image", "inc", "nin", "inn", "up", "as", "a", "ic", "lin", "input", "con", "re", "ac", "gin"], "out": ["lock", "bin", "ext", "name", "point", "socket", "error", "session", "s", "sync", "to", "ex", "outs", "In", "base", "copy", "conn", "cache", "b", "output", "again", "inner", "op", "writer", "line", "work", "err", "off", "client", "o", "OUT", "lib", "image", "inc", "exec", "outer", "other", "exit", "no", "pass", "post", "io", "net", "file", "up", "as", "co", "on", "target", "home", "exp", "Out", "write", "obj"], "buffer": ["offset", "bin", "reader", "border", "uffer", "iter", "data", "batch", "slice", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "b", "size", "bytes", "shape", "address", "flush", "row", "padding", "source", "value", "limit", "feed", "url", "transfer", "pause", "server", "null", "memory", "wave", "split", "queue", "input", "resource", "result", "pad", "length", "buf"], "read": ["iter", "current", " check", "find", "reads", "work", " r", "select", "limit", "exec", "fill", "next", " reach", " sleep", "length", "end", "wait", "READ", "open", "Read", "allow", "play", "se", "load", "ind", " write", " connect", "count", "parse", "tell", "id", " load", " reader", "start", "use", " ride", "x", "reader", "ride", "send", " find", "add", "copy", "check", "r", "line", "seek", "lex", " copy", "run", "feed", "connect", "inc", " use", "ad", " receive", "get", " request", "sync", "k", "size", " parse", " Read", "reading", "pass", " send", "index", "input", "skip", "sleep", " get", "write"], "success": ["full", " successful", "job", "rolling", "data", "true", " succ", "cess", "error", "complete", "correct", "successfully", "first", "results", " succeed", "good", "fast", "zero", "winner", "status", "roll", "successful", "again", "ok", "content", "ceed", "rolled", "done", "better", "construct", "found", "warning", "continue", "value", "response", "selected", "Success", "default", "ccess", "pass", "null", "danger", "func", "valid", "yes", "follow", "result", "fail", "initial", "safe", " Success", "accept", "failed"]}}
{"id1": "18891988", "id2": "9261777", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["GetString", "GetFilename", "downloadFile", "loadFile", "loadfile", "downloadfile", "getfile", "getFilename", "Getfile", "getString", "loadString", "downloadFilename", "GetFile", "downloadString", "loadFilename"], "serviceName": ["ServiceName", "projectType", " servicePath", "ServicePath", "Servicename", " serviceType", " servicename", "packagename", "servicePath", "ServiceType", "projectUrl", " serviceUrl", "servicename", "projectPath", "ServiceUrl", "packagePath", "serviceType", "packageName", "serviceUrl", "packageUrl", "projectName"], "wsdlLocation": ["wllFolder", "wssdFolder", "awsdlLocation", "wddlLocation", "awslDirectory", "wsllFolder", "wssdAddress", "wsDLUrl", "wslLocation", "wslpDirectory", "wslUrl", "wsllAddress", "wdlAddress", "wslFile", "awslFile", "wsslFolder", "wdlFile", "wddlFile", "wdlFolder", "wllFile", "wslpLocation", "awsdlDirectory", "awslUrl", "wslDirectory", "awsdlFile", "wslFolder", "wsdlDirectory", "wddlFolder", "wsllLocation", "wsDLFile", "wsslLocation", "wsdlFolder", "wsDLLocation", "awsdlUrl", "wsllUrl", "wsslFile", "wllLocation", "wssdLocation", "wddlDirectory", "wsdlFile", "wsdlUrl", "wsslAddress", "wsdlAddress", "wsllFile", "wdlDirectory", "wslpFolder", "wdlLocation", "wssdFile", "wslpFile", "wllAddress", "awslLocation", "wsDLDirectory", "wsllDirectory"], "endpoint": ["endPoint", "endination", "enPoint", " endaddress", "Endword", "endpointer", " endocol", " endPoint", " endpo", "EndPoint", "Endination", "Endpoint", "ENDpoint", "enpointer", "endsword", "startaddress", "endpo", "startpointer", "Endpoints", "startPoint", " endword", "ENDpoints", "endword", "enaddress", "enination", "endsocol", "startpoint", "enpoint", "ENDPoint", " endpointer", "endspo", "endaddress", "Endocol", "endspoint", "endocol", "enpoints", "endpoints", "ENDination", "Endpo"], "fileLocation": ["FILEUrl", " fileURI", "FileURI", " fileUrl", "fileURI", " fileDirectory", "FILEDirectory", "fileUrl", "fileDirectory", "FileDirectory", "FILELocation", "FileLocation", "FileUrl", "FILEURI"], "tempDir": [" temporaryPath", "TempDirectory", " tempVer", "tmpDir", " tempDirectory", "tmpPath", "TempPath", " tempdir", " tempPath", "TempDir", "tmpDirectory", "tempdir", "Tempdir", "tempDirectory", "tmpVer", " temporaryVer", " temporaryDir", "tempVer", "tempPath", "tmpdir", " temporaryDirectory"], "url": ["address", "base", "client", "el", "io", "URL", "path", "log", "fl", "sl", "Url", "host", "string", "conn", "ls", "contact", "stream", "image", "ssl", "connection", "ll", "www", "config", "pull", "socket", "ur", "ul", "uri", "service", "http", "l", "source", "file", "server", "channel", "download", "coll", "open", "web", "f"], "WSDLFile": ["WDDlBase", "WSDLLFile", "WINDELPath", "WDDLFolder", "WDDLFile", "WDDlFile", "WDDLBase", "WSDDLFile", "WSDlPath", "WSDLfile", "WSDlBase", "WSDLLFiles", "WDDlFolder", "WDDLfile", "WSDLSourceFile", "WSDDLFolder", "WDDlPath", "WSDLFiles", "WSDLLFolder", "WSDLLSourceFile", "WDDlfile", "WSDELFolder", "WINDLFile", "WSDlFolder", "WSDLPath", "WINDELFiles", "WSDlfile", "WDDLPath", "WSDDLBase", "WSDELFile", "WSDLLBase", "WINDELFolder", "WSDDLfile", "WSDDLFiles", "WSDDLPath", "WINDELFile", "WSDLLfile", "WSDlFile", "WSDELFiles", "WSDlSourceFile", "WSDDLSourceFile", "WINDLFolder", "WSDLLPath", "WSDLBase", "WDDlSourceFile", "WDDLSourceFile", "WSDLFolder", "WSDELPath", "WINDLFiles", "WINDLPath"], "tmpWSDLFile": ["tmpWDDELUrl", "tmpWSDDLLocation", "tmpWSDELFile", "tmpWSDDLFiles", "tmpWSDLLocation", "tmpWDDELFile", "tmpWDDlFile", "tmpWSDLFiles", "tmpWSDlFolder", "tmpWSDLLFolder", "tmpWDDLFile", "tmpWSDELFiles", "tmpWSDlLocation", "tmpWDDLLocation", "tmpWSDlFiles", "tmpWSDlFile", "tmpWDDlFolder", "tmpWDDLUrl", "tmpWSDlUrl", "tmpWSDLLFile", "tmpWSDLFolder", "tmpWDDELLocation", "tmpWSDELFolder", "tmpWSDELUrl", "tmpWDDlFiles", "tmpWSDLLUrl", "tmpWSDLUrl", "tmpWDDlUrl", "tmpWDDELFiles", "tmpWSDDLFile", "tmpWDDLFiles", "tmpWSDLLFiles", "tmpWDDLFolder", "tmpWSDDLUrl", "tmpWSDELLocation"], "inputFile": ["outputDir", " inputFactory", "InputFactory", "inputDir", " inputStream", "Inputfile", " inputFiles", " inputBuffer", "tempBuffer", " inputPage", "tempPlace", "requestfile", "InputDir", "inFile", " inputBase", "inputPage", "InputFile", "inputFactory", "tempUrl", "infile", "inputStream", "tempFactory", "tempPage", "tempFile", "tempBase", "InputUrl", "InputFiles", " inputfile", " inputUrl", "InputPlace", "inputFiles", " inputPlace", "outputFiles", "outputfile", "requestStream", "InputBuffer", "requestFiles", "inputPlace", "inputUrl", "inputBase", " inputDir", "requestFile", "inDir", "tempfile", "InputBase", "inputBuffer", "InputPage", "inPage", "InputStream", "outputFile", "inputfile"], "tmpFile": ["TempFiles", " tmpFiles", "TempDirectory", " tmpDirectory", "uploadStream", "tempDocument", "uploadFile", "TempFile", "inputDocument", "tmpStream", "inputStream", "tempPage", "tempFile", "tmpDirectory", "tmpPage", "tempDirectory", "inputFiles", "tempStream", "TempPage", "tempFiles", "tmpFiles", "uploadDocument", " tmpPage", "uploadFiles"], "in": ["gin", "ins", "din", "reader", "IN", "client", "login", "bin", "id", "inc", "input", "In", "conn", "on", "inner", "image", "c", "lock", "m", "ssl", "connection", "r", "again", "socket", "win", "inn", "p", "pin", "is", "l", "data", "source", "file", "up", "lin", "init", "impl", "f"], "out": ["net", "error", "OUT", "client", "outs", "IN", "cache", "output", "bin", "io", "inc", "log", "input", "conn", "conv", "on", "inner", "In", "name", "to", "image", "err", "c", "Out", "writer", "connection", "again", "parent", "o", "co", "socket", "sync", "outer", "timeout", "copy", "line", "source", "channel", "file", "up", "ch", "server", "group", "part", "conf", "can"], "con": ["bc", "cm", "gin", "ins", "thin", "uc", "client", "IN", "un", "ran", "com", "inc", "connect", "conn", "conv", "inner", "c", "plain", "en", "ssl", "connection", "rec", "co", "fc", "socket", "sync", "Con", "win", "close", "CON", "rc", "channel", "ch", "cn", "kin", "nc", "Conn", "open", "ctrl", "conf", "can"], "fileLength": ["Filelength", " fileSize", "FileWidth", "channelWidth", "contentLen", " fileLen", "channelLen", "fileWidth", "FileLength", "filelength", "fileLen", " filelength", "contentlength", " fileWidth", "FileSize", "channelSize", "fileSize", "contentLength", "channelLength", "contentSize", "FileLen"], "channelIn": ["ChannelOut", "characterIN", "connectionOut", "Channelin", "characterin", "resourceIN", "connectionIn", "ChannelIN", " channelIN", "channelConn", "connectionConn", "resourcein", " channelConn", "characterOut", "resourceIn", "ChannelConn", "resourceOut", "ChannelIn", "connectionin", "channelIN", " channelin", "channelin", "characterIn"], "channelOut": ["chanOUT", "ChannelOut", "connectionOutput", "connectionOut", "ChannelOutput", "ChannelOutside", " channelOutput", "connectionIn", "channelOutside", "channelout", "connectionOutside", "connectionout", "channelOutput", "channelOUT", "ChannelOUT", "canIn", "canOUT", "ChannelIn", " channelout", "canOut", "chanOut", "canOutside", "chanOutside", "chanIn", "chanout", "Channelout"], "tmpDocument": ["tmpDoc", "tmFile", "tmNode", "newContent", " tmpDoc", "mpDoc", "tmpNode", "newFile", "tempDoc", " tmpContent", "tempdocument", "tempDocument", " tmpNode", "mpDocument", "tmpContent", "tempFile", "newDocument", "tmpdocument", "tempContent", "mpFile", "tmDocument", " tmpdocument", "newdocument", "mpNode", "tempNode", "tmdocument"], "nl1": ["dl1", "arlone", "dl0", "NL11", "kl1", "ln1", "klFirst", "nl5", "ln6", "arlFirst", "ln2", "klone", "arl5", "nl6", "nn11", "NL6", "NL0", "nn6", "nl11", "jl1", "nl0", "jlone", "jl5", "dl2", "kl5", "nn2", "nn0", "nl2", "nlFirst", "NL2", "nlone", "nn1", "ln11", "jlFirst", "NL1", "arl1"], "i": ["qi", "v", "z", "ip", "ai", "ti", "I", "uli", "e", "id", "io", "iu", "xi", "ini", "index", "eni", "ui", "li", "u", "hi", "multi", "ci", "si", "mi", "phi", "ii", "m", "y", "j", "ie", "info", "b", "n", "o", "slice", "ri", "uri", "p", "ix", "gi", "fi", "it", "abi", "di", "oi", "l", "ni", "d", "chi", "yi", "ji", "f", "part", "mu", "bi", "pi"], "node1": ["package91", "Node91", "packageOne", "NodeOne", "packageone", "Node0", "shape1", " node91", "node2", "layer91", "layer1", "n0", "layerOne", "n1", "n2", "node0", "nOne", "Node1", "package1", "layer2", "shapeone", "nodeOne", " nodeone", " node0", "nodeone", "shapeOne", "node91", "shape91", " nodeOne", " node2", "Node2"], "tmpOut": [" tmpOUT", "txtOut", "vmOUT", "ptyOut", " tmpWriter", "tempOUT", "tempWriter", "txtOutput", "tempIn", "ptyIn", "tempOut", "tmpWriter", "vmOut", "tempFile", "ptyOutput", "cacheFile", "tempout", "tmpOUT", "tempOutput", "txtout", "cacheOut", "txtWriter", "cacheOUT", "vmIn", "ptyout", "tmpout", " tmpIn", "cacheIn", "tmpIn", " tmpout", "tmpOutput", " tmpOutput", "vmout"], "retVal": ["valRet", "valval", "retObj", "retval", " retval", "retRet", "RETval", "RETObj", " retObj", " retRet", "valObj", "valVal", "RETVal", "RETRet"]}}
{"id1": "7945594", "id2": "20519261", "code1": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "code2": "    public String readReferenceText(final String ident) throws NoContentException {\n        try {\n            String name = getFilename(ident);\n            URL url = new URL(FreqAnalysisPlugin.getDefault().getBundle().getEntry(\"/\"), name);\n            InputStream in = url.openStream();\n            InputStreamReader isr = new InputStreamReader(in, \"UTF-8\");\n            BufferedReader br = new BufferedReader(isr);\n            StringBuffer buffer = new StringBuffer();\n            String line = br.readLine();\n            while (null != line) {\n                buffer.append(line + \"\\n\");\n                line = br.readLine();\n            }\n            return buffer.toString();\n        } catch (MalformedURLException muEx) {\n            logError(muEx);\n        } catch (UnsupportedEncodingException ueEx) {\n            logError(ueEx);\n        } catch (IOException ioEx) {\n            logError(ioEx);\n        }\n        throw new NoContentException(\"Unable to find or read reference text.\");\n    }\n", "label": 1, "substitutes": {"fileDownload": ["filePull", " filedownload", " fileURL", "urlURL", "folderdownload", "folderDownload", "folderURL", "filedownload", "urlDownload", "urlPull", "fileURL", " filePull", "urldownload", "folderPull"], "fAddress": ["sfOrder", "rfMessage", "urlOrder", " fPath", "fEmail", "baddress", "FAddress", "fileAddress", "FAdd", "sfPath", " fMessage", "FLocation", "faddr", "urladdress", "rfaddress", "sfAdd", " fEmail", "fingaddr", "bAdd", "urlAdd", "fingEmail", "sfLocation", "sfaddress", "fileAdd", "bPath", "fOrder", "fPath", "fingAdd", "fMessage", "rfLocation", "faddress", "fLocation", "sfAddress", "bLocation", " fAdd", "baddr", "fingAddress", "urlAddress", "bAddress", "bEmail", "fAdd", "sfMessage", " fOrder", "fileLocation", " faddress", "rfAddress", " fLocation", " faddr"], "destinationDir": ["destributionDur", "destativeDIR", "DestributionDir", "destinatedDar", "declinationDur", "declinatedPath", "destativeArea", "declinatedDar", "DestinationDIR", "destinatedDir", "destinationDirectory", "destinationDar", "destinationDur", "destributionDirectory", "destributionDar", "destinatedPath", "destinePath", "destinationPath", "declinationDar", "destributionDIR", "destineDir", "destinationArea", "DestinationArea", "destippingArea", "DestributionArea", "destinationDIR", "declinationDir", "destinatedDur", "destativeDir", "destippingDir", "destributionPath", "destativeDirectory", "destineDur", "declinationPath", "destineDar", "destippingDIR", "DestinationDir", "destributionArea", "declinatedDir", "DestributionDIR", "DestributionDirectory", "destributionDir", "destippingDirectory", "declinatedDur", "DestinationDirectory"], "slashIndex": ["Slashedindex", "SlashLength", "slashedIndex", "slashLength", "SlashCount", "SlashIndex", "SlashedCount", "slushLength", "slashedCount", "slushIndex", "slargeindex", "slargeLength", "Slashindex", "slushindex", "sllashCount", "slargeCount", "slashedindex", "SlashedLength", "slargeIndex", "slashindex", "sllashindex", "sllashLength", "slashCount", "sllashIndex", "slashedLength", "SlashedIndex"], "periodIndex": ["moneyStart", "moneyindex", "dollarindex", " periodStart", "periodStart", "dollarIndex", " periodindex", "moneyIndex", "moneyOffset", "periodindex", " periodOffset", "dollarOffset", "periodOffset", "dollarStart"], "fileName": [" filePath", "FilePath", "filePath", " fileAddress", "fname", "fPath", "fName", "fileAddress", "FileAddress", "Filename", "FileName", "filename", " filename"], "url": ["path", "string", "base", "ssl", "ou", "server", "uri", "resource", "feed", "user", "http", "c", "socket", "rel", "l", "URL", "uu", "fl", "proxy", "up", "connection", "oc", "str", "ch", "ob", "open", "config", "org", "li", "channel", "web", "page", "ll", "bel", "log", "u", "conn", "image", "re", "blog", "link", "sl", "rl", "Url", "www", "bug", "ur", "ul", "download", "f", "plug", "service", "api", "loc"], "uc": ["anc", "cu", "ou", "tc", "cc", "sc", "um", "rc", "http", "con", "c", "fc", "uu", "nc", "cus", "ec", "union", "lc", "auc", "connection", "oc", "exc", "usc", "u", "conn", "ci", "uci", "ucc", "pc", "mc", "soc", "bc", "com", "stream", "cci", "ac", "UC", "ul", "unc", "hub", "cur"], "in": ["IN", "i", "input", "n", "rc", "ini", "gin", "into", "con", "c", "inner", "socket", "ins", "s", "bin", "is", "reader", "source", "up", "login", "inside", "r", "inc", "data", "conn", "init", "again", "io", "image", "it", "In", "nin", "stream", "lin", "b", "ac", "err", "cin", "inn", "f", "cli", "this", "din"], "file": ["zip", "path", "letter", "base", "class", "fe", "output", "resource", "ile", "filename", "per", "socket", "place", "fp", "o", "l", "line", "File", "source", "rule", "dir", "up", "book", "connection", "FILE", "parent", "data", "page", "log", "name", "folder", "e", "io", "to", "full", "files", "b", "f", "this"], "fos": ["fops", "fileOs", "sfis", "sfOS", "sfo", " fops", "FOs", "FOS", " fOs", " fOS", "Fis", "Fos", "fob", "fOs", "fileops", "fileob", "fo", " fis", " fob", "sfos", "Fops", "Fo", " fo", "fOS", "Fob", "fileos", "fis"], "out": ["string", "ou", "outer", "output", "copy", "net", "plain", "OUT", "inner", "o", "outs", "s", "line", "write", "bin", "sync", "up", "w", "work", "data", "inc", "down", "log", "init", "again", "exec", "Out", "io", "writer", "to", "flush", "update", "err", "b", "block", "f"], "inputLine": ["outputL", "outputRow", "inputRow", " inputRow", " inputBlock", "errorRow", " inputLINE", "outputline", "InputEl", "outputBlock", "inputEl", "InputLine", "Inputline", "errorL", "inputBlock", "InputBlock", "errorLINE", "inputL", "outputEl", "InputChar", " inputline", "InputL", " inputEl", "inputChar", " inputChar", "outputLine", "inputline", "outputChar", "outputLINE", "inputLINE", " inputL", "errorLine"]}}
{"id1": "21491791", "id2": "19335986", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "label": 1, "substitutes": {"run": ["job", "app", "create", "worker", "command", "fork", "log", "loop", "all", "work", "spawn", "test", "call", "build", "process", "exec", "code", "unit", "func", "runner", "running", "execute", "invoke", "Run", "start", "apply"], "input": ["active", "connection", "readable", "data", "audio", "worker", "stream", "state", "control", "conn", "user", "loader", "inner", "text", "instance", "work", "flow", "parser", "client", "address", "source", "storage", "image", "entry", "feed", "request", "driver", "form", "context", "config", "iterator", "reading", "raw", "read", "view", "io", "in", "file", "up", "index", "resource", "out", "initial", "internal", "Input"], "output": ["connection", "office", "job", "data", "later", "put", "operation", "application", "web", "letter", "log", "control", "page", "cache", "writing", "user", "text", "writers", "console", "temp", "source", "image", "response", "path", "filename", "parent", "environment", "object", "exit", "outer", "config", "document", "unit", "file", "index", "generated", "written", "queue", "resource", "out", "target", "network", "Writer", "write", "Output", "end"], "reader": ["er", "manager", "ri", "handler", "book", "worker", "audio", "stream", "rator", "loader", "inner", "wrapper", "r", "rer", "parser", "client", "row", "ner", "oder", "entry", "source", "image", "builder", "driver", "request", "system", "context", "reading", "read", "server", "view", "author", "io", "owner", "in", "resource", "riter", "slave", "Reader", "peer"], "writer": ["connection", "ew", "office", "er", "data", "manager", "wan", "writ", "worker", "creator", "maker", "writing", "inner", "w", "wrapper", "her", "r", "engine", "work", "writers", "ter", "player", "ner", "entry", "ws", "war", "wa", "builder", "driver", "or", "outer", "rw", "request", "author", "wr", "wire", "wb", "nw", "wer", "word", "written", "riter", "out", "Writer", "write", "editor"], "pump": ["Pump", "mumps", "ppumper", "prumper", "prdump", "dmp", "Pprint", "pdump", "Pam", "Pumper", "pamp", "dump", "Pmp", "pmp", "camp", "pumping", "pram", "hump", "ppump", "Pamp", "humps", "ppumps", "mumper", " pdump", " pumping", "cumper", "pprint", "cump", "mprint", " pam", " pumps", "pumps", " pumper", "humper", "Pdump", "Pumps", " pmp", "prump", "pam", "pumper", "hprint", "dumps", " pamp", "mump", "ppumping", "Pumping", "cumping", "dumper"], "counter": ["const", "offset", "ener", "er", "keep", "Counter", "current", "ver", "ception", "sequence", "version", "master", "worker", "seed", "layer", "ger", "zero", "comment", "center", "loop", "page", "keeper", "loader", "instance", "num", "clock", "walker", "inner", "r", "collection", "rew", "ter", "trace", "currency", "row", "pointer", "count", "entry", "ner", "continue", "step", "starter", "race", "cookie", "builder", "outer", "parent", "second", "order", "url", "lr", "enter", "number", "hello", "server", "consumer", "code", "author", "repeat", "index", "timer", "result", "inter", "progress", "processor", "now", "runner", "meter"], "buffer": ["uffer", "iter", "data", "channel", "batch", "reference", "layer", "buff", "Buffer", "binary", "base", "position", "page", "text", "loader", "address", "entry", "source", "limit", "port", "url", "document", "server", "file", "message", "uf", "queue", "header", "resource", "length", "buf"], "off": ["offset", "open", "offs", "oa", "opt", "ff", "down", "head", "low", "auto", "Off", "info", "eno", "OFF", "set", "art", "less", "inner", "left", "own", "flow", "o", "of", "ui", "offer", "ord", "pos", "on", "fail", "out", "Offset", "ref", "unknown", "area", "addr", "start", "end", "now"], "len": ["lock", "bin", "lt", "elt", "loc", "name", "fl", "lim", "el", "body", "layer", "en", "gen", "log", "ll", "lc", "ld", "lan", "all", "size", "lon", "l", "line", "val", "lf", "den", "count", "lib", "limit", "url", "width", "li", "n", "in", "pos", "fd", "lin", "on", "fin", "lit", "Len", "ref", "length", "ln", "ler", "end"], "rd": ["rh", "rn", "RD", "red", "rm", "ds", "dd", "adr", "rod", "ru", "ind", "rc", "ld", "rob", "rf", "cr", "r", "rs", "val", "ra", "raid", "fr", "dr", "rb", "rr", " r", "d", "db", "hr", "rw", "lr", "dra", "ord", "rt", "nr", "rand", " prod", "fd", "rss", "RR", "xd", "nd", "rid", "rl", "ud", "rx"]}}
{"id1": "6966398", "id2": "9109613", "code1": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"reader": ["resource", "df", "or", "row", "reads", "ry", "k", "instance", "context", "o", "reading", "rake", "oder", "ler", "raf", "input", "cer", "manager", "io", "ner", "feed", "driver", "cms", "ri", "client", "pp", "keeper", "er", "handler", "book", "p", "connection", "rc", "pe", "server", "load", "dr", "config", "loader", "read", "Reader", "iter", "per", "rw", "her", "writer", "se", "rr", "r", "parser", "rar", "source", "stream", "buffer", "builder", "file"], "ks": ["ics", "acts", "akes", "reads", "kes", "hs", "KS", "ms", "books", "bs", "k", "opens", "ko", "checks", "gets", "orks", "ctx", "co", "ke", "powers", "acs", "fs", "qs", "ki", "ans", "ls", "inks", "acks", "cks", "vs", "ops", "ches", "keys", "icks", "cs", "ns", "ds", "ku", "CS", "kb", "ges", "ips", "sk", "se", "ps", "DS", "es", "rs", "works", "ck", "kies", "ss", "rows"], "key": ["Key", "seed", "k", "c", "cache", "pg", "ca", "secret", "ee", "service", "state", "io", "co", "char", "pair", "ke", "ce", "ring", "trust", "user", "p", "base", "ki", "court", "pe", "server", "keys", "read", "code", "value", "transfer", "ssl", "type", "point", "sign", "lock", "client", "file"], "chain": ["wrap", "root", "container", "c", "cache", "chains", "table", "wheel", "secret", "circle", "family", "path", "sequence", "box", "network", "list", "none", "slice", "pair", "object", "store", "cr", "rule", "mc", "scale", "base", "coll", "Chain", "config", "enc", "code", "set", "image", "range", "stack", "lock", "crypt", "block", "collection", "file"], "os": ["rss", "ms", "ol", "ios", "ob", "osi", "oid", "op", "o", "opens", "is", " o", "oss", "options", "io", "outs", "aos", "object", "bos", " bos", "p", "fs", "s", "pos", "los", "iso", "ops", "cos", "ot", "Os", "ds", "oses", "ros", "res", "ou", "ps", "es", "rs", "OS"], "stamper": ["starmple", "spampe", "function", " nostameple", "g", "spamper", " nostamler", "streampe", "stammper", "stAMper", "spammer", "path", "spAMpe", "stAMmer", "stampper", "stammple", "this", " nostamepper", "starmper", "stammpe", "starmpper", " nostamper", " nostameper", "stammmer", "s", "stAMpe", "stampe", "streammer", "stameple", "streamper", "spamler", "stamler", "spAMler", "stameler", "_", "stample", "starmler", "stammler", "stammer", "stammpper", "stamepper", "stAMler", "stameper", "data", " nostample", "streamler", " nostameler", " nostampper", "spAMper", "spAMmer"], "appearance": ["ppearance", "attfacing", "installear", "appasion", " appears", "ppearing", "suppearing", "byearance", "feedearance", "feedointment", "formismo", "atteared", "formearing", "appfacing", "askence", "appence", " appfacing", "appearing", "suppearance", "appismo", "ppaser", "signearing", "appointment", "attence", "feedfacing", "suppfacing", "byismo", "askeared", "feedear", " appeared", "Appearance", "signfacing", "ppear", "signear", "byearing", "suppasion", "signearance", "askearance", "installearing", "Appears", "formaser", " applier", "appears", "signointment", "askfacing", "formear", "byear", "installearance", "appear", "ppasion", "signears", "signlier", "attearance", "suppointment", "applier", "Appearing", " appence", "appaser", " appear", " appearing", " appaser", "formearance", " appismo", "installasion", "Applier", "suppear", "appeared"]}}
{"id1": "18989018", "id2": "21531069", "code1": "    protected void doSetInput(IEditorInput input, IProgressMonitor monitor) throws CoreException {\n        IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();\n        IFileFormat format = null;\n        Object source = null;\n        InputStream in = null;\n        try {\n            IPath path;\n            if (input instanceof IStorageEditorInput) {\n                IStorage s = ((IStorageEditorInput) input).getStorage();\n                in = s.getContents();\n                if (s instanceof IFile) {\n                    IFile file = (IFile) s;\n                    path = file.getRawLocation();\n                    if (root.exists(path)) {\n                        path = root.getLocation().append(path);\n                    }\n                    source = path.toFile();\n                }\n            } else if (input instanceof IPathEditorInput) {\n                path = ((IPathEditorInput) input).getPath();\n                source = path.toFile();\n            } else if (input instanceof IURIEditorInput) {\n                URI uri = ((IURIEditorInput) input).getURI();\n                if (URIUtil.isFileURI(uri)) {\n                    source = URIUtil.toFile(uri);\n                } else {\n                    URL url = URIUtil.toURL(uri);\n                    in = url.openStream();\n                }\n            }\n            if (source == null) {\n                if (!in.markSupported()) {\n                    in = new BufferedInputStream(in);\n                }\n                in.mark(10);\n                source = in;\n            }\n            IContentDescription cd = Platform.getContentTypeManager().getDescriptionFor(in, input.getName(), new QualifiedName[] { ImageCore.VALID_FORMATS });\n            if (in != null) {\n                in.reset();\n            }\n            Collection<?> valid = (Collection<?>) cd.getProperty(ImageCore.VALID_FORMATS);\n            if (valid.isEmpty()) throw new CoreException(new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"Unsupported file format.\"));\n            ImageInputStream stream = ImageIO.createImageInputStream(source);\n            format = (IFileFormat) valid.iterator().next();\n            IDocument document = format.decode(stream, monitor);\n            setDocument(document);\n        } catch (IOException e) {\n            Status status = new Status(Status.ERROR, ImageUI.PLUGIN_ID, \"IO Error\", e);\n            throw new CoreException(status);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        super.setInput(input);\n    }\n", "code2": "    public int updateuser(User u) {\n        int i = 0;\n        Connection conn = null;\n        PreparedStatement pm = null;\n        try {\n            conn = Pool.getConnection();\n            conn.setAutoCommit(false);\n            pm = conn.prepareStatement(\"update user set username=?,passwd=?,existstate=?,management=? where userid=?\");\n            pm.setString(1, u.getUsername());\n            pm.setString(2, u.getPasswd());\n            pm.setInt(3, u.getExiststate());\n            pm.setInt(4, u.getManagement());\n            pm.setString(5, u.getUserid());\n            i = pm.executeUpdate();\n            conn.commit();\n            Pool.close(pm);\n            Pool.close(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            Pool.close(pm);\n            Pool.close(conn);\n        } finally {\n            Pool.close(pm);\n            Pool.close(conn);\n        }\n        return i;\n    }\n", "label": 0, "substitutes": {"doSetInput": ["dosetOutput", " doGetContent", "doProcessOutput", "doProcessInput", " doGetText", " doSetContent", "doSetText", "dosetInput", "doGetInput", "doSetContent", " doSetText", "dosetText", "doSetOutput", "doProcessText", "doGetText", " doGetInput", " doGetOutput", " doSetOutput", "doGetContent", "doGetOutput", "dosetContent", "doProcessContent"], "input": ["impl", "IN", "head", "audio", "method", "error", "agent", "temp", "output", " inputs", "resource", "entry", "enter", "remote", "act", "inner", "current", "argument", "project", "present", "instance", "child", "magic", "util", "active", "key", "raw", "form", "client", "install", "select", "expression", "type", "reader", "session", "Input", "q", "inf", "model", "upload", "parser", "config", "inc", "text", "request", "img", "context", "null", "insert", "submit", "exec", "image", "initial", "operator", "pull", "container", "command", "xml", "progress", "field", "element", "definition", "list", "view", "storage"], "monitor": ["directory", "pin", "method", "loader", "handler", "console", "resource", "timeout", "report", "subject", " Monitor", "system", "watch", "wm", "manager", "condition", "mon", "client", "cm", "reader", "Monitor", "pm", "counter", "config", "channel", "timer", " monitors", "out", "mx", "mi", " monitoring", "p", "metadata", "m", "meter", "dm", "mc", "unit", "processor", "summary", "bm", "progress", "state", "mod", "callback", "module", "param"], "root": ["directory", "base", "node", "remote", "server", "resource", "output", "n", "http", "slave", "table", "system", "library", "result", "instance", "location", "host", "manager", "owner", "tx", "cms", "cover", "target", "media", "r", "collection", "work", "config", "parent", "out", "roots", "Root", "store", "archive", "region", "src", "p", "null", "plugin", "or", "folder", "m", "writer", "home", "array", "mount", "container", "process", "this", "storage"], "format": ["event", "base", "class", "string", "temp", "handler", "output", "spec", "filename", "version", "et", "act", "location", "fn", "record", "magic", "util", "Format", "pattern", "form", "filter", "at", "type", "FORM", "model", "feature", "parser", "config", "data", "term", "object", "ant", "style", "plugin", "title", "template", "name", "image", "writer", "function", "transform", "unit", "atter", "f", "attribute", "element", "service", "api"], "source": ["string", "remote", "node", "info", "id", "resource", "output", "spec", "Source", "token", "description", "slice", "inner", "result", "instance", "driver", "via", "SOURCE", "content", "client", "rate", "session", "reader", "use", "rule", "proxy", "connection", "target", "component", "scope", "config", "data", "src", "text", "channel", "parent", "object", "size", "image", "secure", "unit", "reference", "container", "ource", "service", "view", "storage"], "in": ["IN", "index", "pin", "resource", "token", "ini", "on", "ins", "bin", "get", "conn", "it", "container", "element", "ource", "download", "din", "buffer", "id", "read", "connection", "min", "value", "inside", "r", "str", "parent", "again", "name", "isin", "In", "inn", "win", "i", "n", "gin", "slice", "con", "inner", "socket", "session", "reader", "doc", "body", "src", "p", "init", "or", "m", "image", "io", "nin", "update", "version", "c", "pass", "is", "login", "inc", "config", "data", "text", "out", "pull", "include", "err", "f", "from", "img"], "path": ["index", "base", "loader", "resource", "token", "host", "content", "thin", "component", "model", "mount", "PATH", "container", "step", "point", "string", "id", "location", "sync", "part", " filename", "binary", "dir", "value", "str", "ath", "work", "alias", "parent", "route", "object", "name", "walk", "link", "full", " Path", "directory", "remote", "node", "core", "slice", "Path", "password", "session", "reader", "one", "true", "src", " string", "p", "template", "image", "method", "api", "filename", "child", "key", "pattern", "type", "config", "data", "text", "out", "log", "folder", "port", "pointer", "this", "code", "loc"], "s": ["services", "ssl", "i", "sf", "n", "sys", "fs", "spec", "settings", "http", "ns", "slice", "c", "S", "o", "l", "abs", "si", "sharing", "sync", "an", "session", "d", "ws", "sb", "sa", "scope", "r", "sv", "g", "store", " storage", "share", "src", "gs", "h", "stores", "p", "ls", "folder", "m", "e", "js", "ss", "sl", "secure", "sym", "v", "b", "ds", "os", "f", "ps", "service", "space", "storage"], "file": ["directory", "string", "info", "base", "node", "remote", "sf", "resource", "copy", "feed", "ile", "output", "filename", "slice", "fp", "l", "fn", "il", "File", "Image", "content", "icon", "use", "binary", "dir", "up", "lib", "value", "media", "FILE", "store", "section", "data", "archive", " File", "open", "object", "x", "p", "folder", "name", "e", "image", "port", "io", "full", "files", "pe", "unit", "audio", "b", "future", "xml", "f", "storage"], "uri": ["base", "address", "handler", "i", "id", "resource", "pi", "username", "server", "entry", "http", "filename", "uid", "ri", " URI", "location", "URL", "query", "ui", "util", "database", "qi", "rule", "dir", "connection", "data", "text", "route", "term", "object", "uni", "name", "io", "image", "iri", "prefix", "gi", "Url", "range", "abi", "attribute", "cli", "URI", "service", "api", "storage"], "url": ["string", "address", "base", "ssl", "id", "resource", "user", "http", "ref", "rel", "ri", "l", "location", "URL", "fr", "key", "sr", "str", "store", "config", "data", "channel", "src", "text", "object", "name", "image", "io", "link", "sl", "layer", "Url", "ul", "ource"], "cd": ["cc", "gd", "cf", "clean", "rc", "ck", "c", "lab", "cb", "co", "dr", "dc", "cm", "cp", "arch", "ce", "d", "xd", "ct", "CE", "cy", "md", "CD", "ca", "de", "xc", "nd", "CS", "C", "cand", "DC", "ci", "cr", "CR", "CC", "CF", "vd", "cs", "ds", "def", "pd", "dd"], "valid": ["val", "defined", "id", " invalid", "broken", "vari", "current", "Valid", "standard", "present", "all", " Valid", "active", "pattern", "iter", "post", "visible", "value", "legal", "data", "regular", "vals", "local", "empty", "multiple", "style", "complete", "Invalid", "allowed", "stable", "available", "normal", "array", "good", "full", "bad", "compatible", "correct", "supported", "secure", "required", "v", "sign", "missing", "successful", "def", "multi", "acceptable", "cert", "VAL", "list"], "stream": ["string", "handler", "temp", "video", "resource", "feed", "response", "output", "clean", "message", "draw", "flow", "trans", "read", "content", "raw", "form", "client", "reader", "serial", "model", "Stream", "data", "channel", "body", "object", "context", "row", "image", "writer", "v", "container", "sw", "transform"], "document": ["video", "output", "response", "resource", "feed", "Source", "filename", "description", "system", "author", "record", "content", "material", "reader", "doc", "Filename", "Reader", "media", "model", "collection", "parent", "data", "text", "object", "metadata", "style", "ocument", "template", "image", "writer", "io", "_", "xml", "Document", "this"]}}
{"id1": "397240", "id2": "19134229", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandrewrites", "readAndRewwrite", "readAndSwwrite", "readAndrewrites", "readAndRebrite", "readAndRebrap", "readAndRebrites", "readandrewrap", "readandRewwrite", "readAndSwrites", "readandRewrites", "readAndRewrap", "readAndrewrap", "readAndrewwrite", "readAndrewrite", "readAndRebwrite", "readAndSwrite", "readandrewrite", "readandRewrap", "readandrewwrite", "readAndSwrap", "readAndRewrites", "readandRewrite"], "inFile": ["Infile", " inFilename", "loginFiles", "inSourceFile", "loginFile", "loginFilename", "oldFiles", "loginfile", "outFilename", "outFiles", "inFilename", "oldFile", "outfile", "outSourceFile", "InSourceFile", " infile", " inFiles", "InFiles", "oldfile", "inputfile", "infile", "inputFiles", "inputFilename", "inputFile", "oldFilename", "InFile", "inFiles", " inSourceFile"], "outFile": ["processFILE", "newFile", "newDir", "OutDir", "outStream", "outputFILE", "processPlace", "outputFile", "processFile", "outputFilename", "offPlace", "Outfile", " outDir", " outfile", "offFilename", "newfile", "thisfile", "outFILE", " outStream", "outfile", "processFilename", "exFile", "thisFILE", "outPlace", "thisFilename", "newStream", "offFILE", "OutFile", "outDir", "offFile", "outputPlace", "exfile", "exFilename", "thisFile", "exFILE", "outputfile", "OutStream", "outFilename"], "iis": [" iris", " iIs", "Iis", "iiis", "ciIs", "iiIS", "iniIs", "iIs", "iiIs", "iniIS", "ciris", "ciais", " iIS", "iiiss", "ciis", "iniris", "iris", "iniiss", " iiss", "Iais", "iIS", "iiss", "iniis", " iais", "Iiss", "iais", "ciiss", "ciIS", "iiris", "IIS"], "dcmParser": ["dpmPlugin", "dCMparser", "dmPlugin", "dmoduleParser", " dcmparser", "dpmarser", " dpmarser", "fcmParser", "dmmParser", " dcmPar", "dcmPar", "dpmparser", "dmcarser", "dpmJar", "dCMHandler", " dcmReader", "dmodulePlugin", "dkmHelper", " dpmPolicy", "DcmParser", "DcmJar", "dmoduleReader", "dbmParser", "dpmPar", "fpmParser", " dpmHelper", " dcmLanguage", "dcmLoader", "dkmParser", "fcmHandler", "dbmPolicy", "dcmarser", "dhemInstallation", "dhemReader", " dpmLanguage", "DcmReader", "DcmInstallation", "dcrPlugin", "dmmLoader", "dcmPlugin", "dpmInstallation", "dcrReader", " dcmJar", "fpmHandler", " dcrPlugin", "dcrJar", "dpmReader", "dbmPlugin", " dpmParser", "dmcPar", "dmcJar", " dcmHelper", "dcrParser", "dmLoader", "dcmparser", "dmissionReader", "dpmLoader", "dhemParser", "dmmparser", "dmissionLanguage", "fcmReader", "dcrLoader", " dpmJar", "dCMLoader", " dpmReader", " dpmPar", "dmoduleJar", "dmissionPlugin", " dcrReader", " dcmarser", "dCMReader", "dpmLanguage", "fpmparser", "dcmInstallation", "dmmPlugin", "dcmLanguage", "dpmHelper", "dcrPar", " dpmparser", "dkmPolicy", " dpmPlugin", "dkmPlugin", "dmissionParser", "fpmReader", "dCMParser", " dcrParser", "dmoduleparser", "dmReader", "dbmHelper", "dhemJar", " dpmLoader", "dCMPlugin", "dmParser", "dcmHelper", "dcmReader", "dcmPolicy", "dpmHandler", "dcrarser", " dcmPlugin", " dcmLoader", "dmcParser", "dcmHandler", " dcrLoader", "dpmParser", "dcmJar", "fcmparser", " dcmPolicy", "dpmPolicy"], "ds": ["vals", "db", "os", "ils", "details", "points", "tx", "sync", "qs", "src", "is", "Db", "bs", "s", "dd", "cs", "asi", "rs", "xs", "ls", "ns", "nas", "pd", "ros", "dds", "conn", "DS", "ks", "dr", "iss", "ads", "dc", "tes", "services", "ants", "ras", "dt", "df", "cdn", "gd", "ts", "icks", "ays", "des", "data", "session", "eps", "drivers", "ins", "ys", "di", "vs", "utils", "amps", "ss", "d", "js", "ps", "gs", "ld", "parts", "sys", "da", "Os", "ws", "dat", "uds", "Ds"], "pdReader": ["dsLoader", "ddReader", "hdRead", "dsWriter", "pdRead", "pdreader", "pdStream", "pbReader", "hdLoader", "ddRunner", "pcReader", "hdReader", "dsreader", "xdWriter", "pbLoader", "pcLoader", "xdReader", "xdRead", "pbStream", "pdLoader", "pbRunner", "ddLoader", "hdRunner", "pcWriter", "xdreader", "pdRunner", "ddStream", "dsRead", "hdStream", "pcRead", "hdWriter", "dsReader", "hdreader"], "out": ["Out", "image", "sync", "flow", "key", "s", "parent", "ex", "conn", "to", "word", "at", "director", "store", "base", "builder", "oder", "w", "name", "outs", "OUT", "db", "client", "full", "user", "page", "cache", "diff", "array", "inner", "io", "file", "part", "down", "dot", "err", "over", "net", "again", "as", "lock", "external", "inc", "auto", "in", "writer", "output", "order", "object", "copy", "cli", "child", "result", "ext", "ssl", "line", "manager", "url", "lib", "o", "null", "pass", "doc", "password", "point", "outer", "dev", "layer", "up", "device", "term", "obj", "default", "write", "group", "code", "connection", "exp", "later", "img", "exec", "login", "session", "data", "temp", "model", "with", "her", "co", "list", " in", "sys", "gen"], "dcmEncParam": ["dcmDecParameter", "dcmArchParameter", "dcmArchArg", "dcmEncPar", "dcmSecParam", "dcmArchParam", "dcmElPar", "dcmSecPar", "dcmEnPart", "dcmElParameter", "dcmEncType", "dcmEncParameter", "dcmEstParam", "dcmEncArg", "dcmDecPar", "dcmEstParameter", "dcmEnArg", "dcmEstType", "dcmElParam", "dcmElType", "dcmDecPart", "dcmDecParam", "dcmSecType", "dcmEnType", "dcmEstPar", "dcmSecPart", "dcmEnPar", "dcmDecArg", "dcmDecType", "dcmEncPart", "dcmEnParameter", "dcmEnParam"], "pdWriter": ["ddWrite", "ddReader", "ddOutput", "dpWrite", "dsWriter", "PDWriting", "pdOutput", "hdWrite", "PDWrite", "dpReader", "dpWriting", "dsWrite", "hdReader", "PDReader", "htReader", "dsOutput", "PDWriter", "pdWrite", "pdWriting", "htWriting", "ddWriter", "htWrite", "htWriter", "hdWriter", "dsReader", "dpWriter", "hdOutput"]}}
{"id1": "11082670", "id2": "6517139", "code1": "    @SuppressWarnings(\"unchecked\")\n    public List<Event> lookupFutureEvents(String groupIdentifier) throws GtugsException {\n        StringBuilder json = new StringBuilder();\n        String requestUrl = \"http://api.meetup.com/events.json/?group_urlname=\" + groupIdentifier + \"&key=\" + key;\n        try {\n            URL url = new URL(requestUrl.toString());\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                json.append(inputLine);\n            }\n            in.close();\n        } catch (IOException e) {\n            throw new GtugsException(e);\n        }\n        List<Event> events = new ArrayList<Event>();\n        JSONObject jsonObj = (JSONObject) JSONValue.parse(json.toString());\n        JSONArray results = (JSONArray) jsonObj.get(\"results\");\n        for (int i = 0; i < results.size(); i++) {\n            JSONObject result = (JSONObject) results.get(i);\n            Event e = new Event();\n            e.setAttendeeCount(Integer.parseInt((String) result.get(\"rsvpcount\")));\n            e.setCity((String) result.get(\"venue_city\"));\n            e.setDescription((String) result.get(\"description\"));\n            e.setLatitude(Double.parseDouble((String) result.get(\"venue_lat\")));\n            e.setLongitude(Double.parseDouble((String) result.get(\"venue_lon\")));\n            e.setName((String) result.get(\"name\"));\n            Date myDate = null;\n            String time = (String) result.get(\"time\");\n            try {\n                myDate = meetupDateFormat.parse(time);\n                e.setStartTime(timeDateFormat.format(myDate));\n                e.setEndTime(timeDateFormat.format(myDate));\n                e.setStartDate(myDate);\n                e.setEndDate(myDate);\n                String tz = tzDateFormat.format(myDate);\n                if (tz != null && tz.startsWith(\"+\")) {\n                    tz = tz.substring(1);\n                }\n                e.setTimeZone(Integer.toString(Integer.parseInt(tz) / 100));\n            } catch (ParseException ex) {\n                ex.printStackTrace();\n                continue;\n            }\n            e.setState((String) result.get(\"venue_state\"));\n            StringBuilder addressBuilder = new StringBuilder();\n            if (result.get(\"venue_address1\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address1\") + \" \");\n            }\n            if (result.get(\"venue_address2\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address2\") + \" \");\n            }\n            if (result.get(\"venue_address3\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address3\") + \" \");\n            }\n            if (result.get(\"venue_address4\") != null) {\n                addressBuilder.append((String) result.get(\"venue_address4\"));\n            }\n            e.setStreetAddress(addressBuilder.toString().trim());\n            e.setZipCode((String) result.get(\"venue_zip\"));\n            e.setUrl((String) result.get(\"event_url\"));\n            events.add(e);\n        }\n        return events;\n    }\n", "code2": "    private String getPrefsKey(String key) {\n        try {\n            if (MD5 == null) MD5 = MessageDigest.getInstance(\"MD5\");\n            MD5.reset();\n            MD5.update(key.getBytes(\"UTF-8\"));\n            byte[] resultBytes = MD5.digest();\n            return toHexString(resultBytes);\n        } catch (Exception nsae) {\n            return key;\n        }\n    }\n", "label": 0, "substitutes": {"lookupFutureEvents": ["lookUpupItems", "lookupFutureEvent", "lookupFutureItems", "lookUpFutureEvents", "lookupRequestEvents", "lookupAllEvent", "lookupupEvent", "lookupupItems", "lookupRequestItems", "lookUpupEvents", "lookupRequestEvent", "lookUpFutureItems", "lookUpFutureEvent", "lookUpupEvent", "lookupAllEvents", "lookupAllItems", "lookupupEvents"], "groupIdentifier": ["groupSequifer", " groupIdentizer", "groupIdizer", "groupSequifier", "groupIdifer", "groupidentifiers", "groupidentifier", "groupidentizer", "groupSequification", "groupIdentifer", " groupIdentification", " groupIdentifiers", "groupSequifiers", "groupIdentification", "groupidentification", " groupIdentifer", "groupIdentifiers", "groupIdentizer", "groupIdifier", "groupidentifer", "groupIdifiers"], "json": ["struct", "rss", "txt", "status", "js", "token", "JSON", " JSON", "description", "zip", "string", "jack", "request", "photo", "http", "xml", "response", "input", "api", "io", "key", "list", "son", "sql", "build", "j", "server", "query", "twitter", "array", "value", "journal", "html", "ssl", "output", "data", "obj", "id", "message", "info", "text", "body"], "requestUrl": ["responseUrl", "responseName", " requestName", "requestAddress", "downloadUrl", "requestURL", "responseStr", " requestAddress", "downloadURL", " requestURL", "RequestURL", "downloadAddress", " requestUr", "responseURL", "requestName", "RequestUrl", "requestUr", "downloadUr", "RequestName", " requestStr", "RequestAddress", "RequestUr", "RequestStr", "requestStr"], "url": ["resource", "string", "channel", "http", "service", "input", "URL", "path", "api", "open", "io", "gl", "Url", "client", "rl", "user", "address", "l", "connection", "rule", "base", "event", "server", "sl", "f", "hub", "image", "socket", "ssl", "data", "web", "uri", "stream", "buffer", "source", "org", "file"], "in": ["In", "line", "again", "serv", "ini", "c", "IN", "is", "din", "inner", "bin", "input", "io", "ins", "impl", "min", "inn", "er", "into", "err", "l", "init", "s", "lin", "out", "gin", "read", "f", "image", "login", "ssl", "reader", "data", "r", "b", "inc", "id", "buffer", "stream", "source", "re", "fr"], "inputLine": ["InputLine", "controlLine", "audioLine", "eventText", " inputline", "inputText", "eventStream", " inputL", " inputStream", "inputStream", "outputline", "requestLine", "inputUrl", "inputL", " inputUrl", "eventline", "outputStream", "inputBlock", "eventLine", "controlStream", "audioUrl", "inputline", "requestBlock", "outputBlock", "outputText", "audioL", " inputText", "controlL", "InputUrl", "InputL", "requestStream", "requestL", "outputLine", "controlBlock", "outputL"], "events": ["reports", "pages", "views", "times", "lines", "errors", "ents", "files", "groups", "members", "plugins", "forms", "tests", "effects", "actions", "Events", "services", "dates", "fires", "features", "archives", "items", "comments", "es", "lists", "issues", "rows"], "jsonObj": ["JSONObject", "JSONExt", "sonObj", "xmlObject", "jsonobj", "xmlAct", "jsonExt", "jsonArray", "responseAct", "responseObject", "responseobj", "jsonObject", "JSONObj", "JSONAct", "JSONobj", "sonArray", "responseObj", "jsonAct", "xmlObj", "xmlExt", "xmlobj", "xmlArray", "sonobj", "JSONArray", "sonExt"], "results": ["reports", "pages", "words", "ings", "Result", "stats", "times", " Results", "resources", "values", "errors", "roads", "terms", "response", "objects", "details", "shows", "Results", "groups", "changes", "RESULTS", "successful", "tests", "ventures", "qs", "Events", "its", "dates", "vers", "ries", "ions", "res", "features", "vals", "output", "rules", "data", "items", "r", "es", "products", "runs", "rows"], "i": ["iu", "hi", "si", "chi", "qi", "ip", "u", "multi", "n", "ii", "c", "ini", "pi", "inner", "ci", "di", "io", "slice", "vi", "ui", "ji", "ri", "bi", "ie", "p", "phi", "j", "I", "fi", "x", "eni", "index", "f", "oi", "li", "ori", "h", "v", "gi", "ti", "ai", "yi", "b", "xi", "id", "info", "uri", "ix", "mu", "uni"], "result": ["resource", "entry", "row", "role", "plus", "status", "section", "function", "Result", "particip", "rh", "request", "venture", "view", "comment", "response", "report", "manager", "search", "ner", "match", "details", "sr", "user", "err", "goal", "profile", "successful", "rule", "default", "part", "order", "element", "event", "query", "game", "complete", "date", "session", "success", "feature", "record", "res", "page", "output", "error", "data", "product", "term", "found", "r", "style", "job", "message", "info", "back", "ver"], "e": ["eu", "fe", "g", "m", "none", "enter", "ce", "p", "l", "s", "E", "ne", "v", "error", "de", "t", "ec", "es", "or", "entry", "c", "oe", "o", "y", "d", "die", "ea", "pe", "element", "exc", "ga", "office", "ep", "ae", "eve", "esi", "en", "one", "end", "je", "entity", "n", "see", "te", "ee", "ed", "er", "ie", "ception", "j", "complete", "f", "ele", "ze", "ev", "r", "line", "u", "le", "ge", "be", "eb", "err", "it", "ente", "event", "ffe", "ite", "ye", "el", "se", "b", "me"], "myDate": ["homeDate", "myYear", "MYDat", "MYDay", "homedate", " myTime", "MYTime", "myDat", "anyDate", "myTime", "anyTime", "yourDate", "yourTime", "myDay", "homeTime", "MyDate", "yourDat", "anyDat", "MYDate", "homeDat", "MyDay", " myDat", "MyDat", "MyTime", " myYear", "yourdate", " myDay", "yourDay", "mydate", "yourYear", "anyYear", "anydate"], "time": ["timeout", "live", "etime", "times", "string", "host", "hour", "depth", "money", "week", "year", "length", "Time", "loc", "rate", "location", "work", "clock", "size", "price", "date", "TIME", "code", "am", "value", "home", "rice", "image", "start", "tim", "ime", "data", "type", "duration", "id", "message", "timer", "text", "name"], "tz": [" offset", " zones", " loc", "etime", "Clock", "hour", "UTC", "hh", "z", " hour", "zone", " zone", "Offset", " clock", " schedule", "loc", " timestamp", "Zone", "clock", " interval", " GMT", "Timeout", "Delta", " locale", "GMT", "zz", "offset", "Z", "tc"]}}
{"id1": "15241397", "id2": "22320592", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    private static void loadDefaultPreferences() {\n        try {\n            URL url = ClassLoader.getSystemResource(\"OpenDarkRoom.defaults.properties\");\n            preferences.load(url.openStream());\n        } catch (FileNotFoundException e) {\n            log.error(\"Default preferences file not found\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"doGet": ["handlePut", "didGet", "didGET", "didPut", "didget", "doget", " doPut", "doGET", "handleGET", "doPut", "handleget", " doget", "handleGet", " doGET"], "request": ["event", "info", "buffer", "input", "Request", "server", "resource", "uri", "user", "report", "http", "subject", "message", "document", "result", "instance", "query", "queue", "req", "client", "er", "type", "reader", "connection", "application", "data", "web", "object", "context", "complete", "QUEST", "image", "received", "url", "xml", "method", "initial"], "response": ["server", "output", "resource", "report", "results", "site", "message", "document", "json", "version", "onse", "result", "host", "pool", "queue", "next", "client", "session", "resp", "connection", "model", "other", "application", "collection", "wave", "parent", "data", "out", "body", "page", "object", "reply", "status", "image", "writer", "function", "generation", "full", "Response", "respond", "error", "esi", "view"], "rewrittenQueryString": ["rewrittenQuestionStr", "rewwrittenQueryService", "rewrittenQueryArray", "rewrittenRequestList", "rewrittenQueryText", "rewrittenRequestText", "rewrittenUrlText", "rewwrittenRequestStr", "rewrittenPageList", "rewrittenQuestionText", "rewrittenQuestionLine", "rewwrittenRequestText", "rewrittenRequestLine", "rewwrittenQueryArray", "rewrittenqueryLine", "rewrittenQueryLine", "rewrittenPageString", "rewrittenUrlString", "rewwrittenRequestArray", "rewwrittenQueryList", "rewrittenQueryList", "rewwrittenQueryLine", "rewrittenQuestionArray", "rewrittenqueryText", "rewwrittenRequestService", "rewrittenRequestStr", "rewrittenqueryString", "rewwrittenRequestList", "rewrittenQueryStr", "rewrittenUrlLine", "rewrittenRequestString", "rewrittenQuestionString", "rewrittenPageLine", "rewrittenQueryService", "rewrittenPageArray", "rewwrittenRequestLine", "rewwrittenQueryText", "rewrittenqueryService", "rewwrittenQueryStr", "rewwrittenRequestString", "rewrittenRequestArray", "rewrittenQuestionList", "rewrittenRequestService", "rewrittenUrlService", "rewwrittenQueryString", "rewrittenqueryStr"], "rewrittenUrl": ["rewilledJar", "rewmatchedFile", "rewodedURL", "rewedUrl", "rewwrittenurl", "rewwrittenURL", "rewatchedText", "rewardedLocation", "rewmatchedUrl", "rewilledUrl", "rewatchedURL", "rewardedUrl", "rerittenURL", "rewodedLanguage", "RewrittenInt", "rewwrittenUrl", "rewardedInt", "rewwrittenJar", "rewriteURL", "RewwrittenURL", "rewwrittenServer", "rewrittenUr", "rewrapedURL", "rewedUr", "rewodedFile", "RewrittenUr", "rewrittenURL", "Rewrittenurl", "rewcraftedURL", "RewwrittenInt", "rewardedLanguage", "rerittenUr", "RewwrittenLocation", "rewilledInt", "rewrittenLocation", "rerittenFile", "rewatchedServer", "rewwrittenLocation", "rewriteUrl", "RewrittenServer", "Rewwrittenurl", "rerittenUrl", "rewwrittenInt", "rewrapedUrl", "rewrittenLanguage", "RewrittenJar", "RewwrittenFile", "rewardedJar", "rewardedURL", "rewwrittenLanguage", "rewcraftedUrl", "rewriteText", "rewodedUrl", "rewmatchedURL", "rewriteServer", "rewrittenServer", "rewrittenInt", "rewedFile", "rewrittenFile", "rewwrittenText", "rewilledURL", "rewedURL", "RewwrittenText", "RewrittenFile", "RewrittenLocation", "rewrittenurl", "rewrapedUr", "RewwrittenUrl", "rewrapedFile", "RewrittenURL", "rewwrittenUr", "rerittenLanguage", "rewardedUr", "RewwrittenJar", "rewrittenText", "RewwrittenUr", "rewcraftedLocation", "RewrittenText", "rewcraftedUr", "rewatchedUrl", "rewwrittenFile", "rewrittenJar", "rewmatchedurl", "RewrittenUrl", "rewedurl", "RewwrittenServer", "rewardedFile"], "httpURLConnection": [" httpURLConn", "webURLClient", "apacheGEconnection", " httpURConn", "httpURConnect", "httpSSLConnection", "httpUrlConnect", "webURLContext", "httpUrlCode", "HttpChannelConnection", " httpURConnection", "httpURLClient", "apacheURLConnect", "apacheURLFlow", "httpSSLConn", "httpChannelConnection", "httpURIConnection", "httpurlConnect", "httpURIConnect", " httpURLSession", "webURLConnection", "httpUrlConn", "httpURLService", "HttpChannelService", "httpELConnection", " httpUrlConn", " httpURLconnection", "httpStreamCurrent", "httpUrlconnection", "apacheGEConnect", "apacheGEFlow", "apacheURLConnection", "httpELConnect", "httpurlconnection", "httpURLConn", "httpUrlConnection", "httpurlFlow", "httpGEFlow", "httpURLContext", "httpURLFlow", "httpPathSession", " httpStreamconnection", "httpPathConnection", "webSSLConn", "HttpURLConnect", "httpURLCode", "httpStreamConnection", "httpStreamSession", "webSSLClient", " httpURLCurrent", "httpURLConnect", "webURLConn", "httpPathCurrent", "httpSSLContext", " httpStreamSession", "httpurlSession", "httpURService", "httpURConnection", "httpURLCurrent", "httpurlConnection", "httpurlConn", "httpCLConn", "apacheGEConnection", "httpELConn", " httpURConnect", "httpWebConnection", "httpURLconnection", "webSSLContext", "httpUrlService", "HttpChannelconnection", "httpStreamconnection", "HttpURLService", "httpGEConnect", "httpURIFlow", "httpurlCurrent", " httpStreamCurrent", "httpCLConnection", " httpUrlCode", "httpUrlClient", "httpURLSession", "httpURIContext", "webSSLConnection", "httpWebConnect", "httpCLCode", "httpURIClient", "httpurlCode", "apacheURLconnection", "httpURConn", "httpURconnection", "HttpChannelConnect", "httpURIConn", "httpURIconnection", "httpGEConnection", " httpUrlConnection", "httpPathconnection", " httpURLConnect", "HttpURLConnection", "HttpURLconnection", "httpSSLClient", "httpUrlContext", " httpStreamConnection", "httpGEconnection", " httpURLCode", "httpChannelService", "httpChannelConnect", "httpWebConn", "httpChannelconnection"], "header": ["event", "string", "head", "info", "handler", "buffer", "her", "index", "server", "headers", "token", "list", "outer", "entry", "master", "message", "version", "bridge", "character", "document", "author", "result", "driver", "match", "ter", "line", "dr", "key", "iter", "queue", "next", "er", "filter", "part", "back", "rule", "after", "player", "cover", "member", "date", "item", "component", "group", "feature", "section", "default", "data", "channel", "director", "metadata", "Header", "hash", "writer", "function", "second", "layer", "comment", "pair", "consumer", "reference", "block", "attribute", "error", "field", "definition", "column"], "value": ["val", "string", "info", "letter", "server", "entry", "now", "option", "message", "version", "description", "current", "json", "end", "document", "child", "set", "key", "content", "password", "expression", "Value", "type", "item", "media", "model", "default", "sv", "parent", "data", "text", "VALUE", "variable", "object", "get", "language", "format", "hello", "name", "function", "label", "gi", "values", "V", "comment", "v", "attribute", "office", "field", "element", "property", "valid"], "inputStream": ["inputChannel", "inputStreamer", "resourceStream", "InputStreamer", "outputSteam", "inputSteam", "pullSteam", "pullStream", "outputstream", "outputStreamer", "resourcestream", "outputChannel", "pullstream", "InputChannel", "pullStreamer", "resourceChannel", "resourceSteam", "Inputstream", "inputstream", "InputSteam", "InputStream"], "outputStream": ["inputStreamer", "externalSteam", "responseStream", "OutputChannel", "outputSteam", "inputSteam", "externalstream", "OutputStreamer", "responseSteam", "Outputstream", "responseChannel", "OutputSteam", "outputstream", "outputStreamer", "externalStream", "externalStreamer", "OutputStream", " outputChannel", " outputFile", "outputChannel", "responseFile", " outputSteam", "outputFile", "inputstream", "OutputFile"]}}
{"id1": "17786231", "id2": "19810820", "code1": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"downloadFile": [" downloadStream", "downloadStream", "copyfile", "copyFile", "transferfile", "copyFiles", "transferFile", "copyStream", "transferStream", " downloadFiles", "downloadFiles", " downloadfile", "transferFiles", "downloadfile"], "downloadUrl": ["updateurl", "outputLine", "outputurl", "updateLine", "transferFile", "downloadURL", "transferurl", "updateUrl", "downloadLine", "transferURL", "outputUrl", "updateURL", " downloadURL", "downloadurl", "outputURL", " downloadLine", " downloadurl", "updateFile", "transferUrl"], "destinationFile": ["destporaryFiles", "destigrationFILE", "destoutputString", "DestinatingFILE", "destoutputImage", "destinatedFILE", "destinatedFile", "destigrationFile", "destporaryString", "destinatingFile", "DestinationFile", "DestinatingString", "destinatingFilename", "destinatingImage", "destporaryImage", "destigrationFiles", "DestinatingFiles", "destigrationFilename", "DestinationFILE", "DestinatingFilename", "DestinatingFile", "DestinationString", "DestinatingImage", "destinatingString", "destoutputFile", "destinatingFILE", "destinatedFilename", "destporaryFile", "destinationImage", "destinationFILE", "destinationFilename", "destoutputFiles", "destinationString", "DestinationImage", "destinatingFiles", "DestinationFiles", "DestinationFilename", "destinationFiles", "destinatedFiles"], "client": ["proxy", "url", "uri", "resource", "server", "call", "parent", "connection", "force", "remote", "ce", "method", "project", "session", "channel", "application", "connect", "cl", "conn", "plugin", "api", "config", "bird", "cli", "contact", "self", "Client", "queue", "cache", "https", "con", "c", "handler", "app", "service", "per", "cher", "get", "query", "http", "request"], "httpGet": ["HttpCreate", "ttpCall", "httpCall", "ttpSend", " httpSend", "ttpCreate", "resourcePut", "httpSend", "ttpGet", "HttpCall", "resourceCall", "httpPut", "resourceget", "HttpGet", " httpPut", "Httpget", "resourceGet", "HttpPut", " httpCall", " httpget", "httpCreate", "httpget", " httpCreate", "HttpSend"], "outputFile": ["outputFiles", "referencePath", "writeFile", "referenceFile", "targetDir", "writeStream", "inputFile", " outputPath", " outputDirectory", "targetFiles", " outputfile", "outputDirectory", "outfile", "outStream", "writePath", "outputPath", "referencefile", "targetFile", "inputDirectory", "inputDir", " outputFiles", "referenceStream", "targetDirectory", "outputDir", "outPath", "outFile", "inputFiles", " outputDir", "writefile", "outputfile"], "outputStream": ["inputSteam", "inputWriter", "outputStreamer", " outputSteam", " outputForm", "logWriter", "inputFile", "outputForm", "responseFile", "inputStreamer", "inputForm", "responseStream", "responseSteam", "outputWriter", " outputWriter", "logSteam", "logStream", "OutputWriter", " outputStreamer", "responseWriter", "OutputForm", "OutputStream", "OutputSteam", "outputSteam", "logStreamer", "OutputFile"], "response": ["resp", "respond", "report", "resource", "message", "image", "server", "Response", "connection", "body", "event", "data", "version", "session", "output", "application", "status", "document", "result", "reply", "error", "api", "queue", "object", "handler", "success", "relation", "json", "query", "generation", "collection", "http", "feed", "request", "ception", "received"], "entity": ["pe", "component", "attribute", "ity", "url", "unit", "resource", "e", "image", "server", "message", "volume", "body", "connection", "Entity", "item", "ce", "event", "data", "ie", "channel", "output", "model", "document", "entry", "result", "status", "application", "coll", "translation", "ent", "el", "xml", "instance", "element", "issue", "metadata", "source", "api", "media", "comment", "agent", " identity", "node", "object", "id", "cache", "email", "file", "machine", "service", "environment", "json", "content", "state", "collection"], "inputStream": ["downloadLength", "inputChannel", "inputSteam", " inputSteam", "InputLength", "childSteam", "audioSteam", "InputFile", "InputChannel", "outputStreamer", "outputstream", "selectFile", "inputFile", "childStream", "audiostream", "inputStreamer", "audioStream", "downloadSteam", "selectSteam", "inputLength", " inputStreamer", "Inputstream", "InputStreamer", "downloadstream", "childChannel", "audioStreamer", " inputFile", "childStreamer", " inputLength", " inputBuffer", "selectStream", "downloadStream", "outputSteam", "InputBuffer", "InputSteam", "inputBuffer", "outputChannel", "outputBuffer", "inputstream", " inputstream", "selectStreamer", "InputStream", " inputChannel"], "callback": ["proxy", "closure", "url", "CB", "message", "resource", "call", "connection", "Callback", "cell", "event", "fb", "back", "data", "sync", "func", "result", "batch", "clone", "cb", "band", "code", "cc", "plugin", "consumer", "future", "config", "ff", "backs", "cache", "handler", "loader", "behavior", "function", "wrapper", "state", "buffer", "collection", "processor"], "copiedLength": ["copiedlength", "copippedLength", "copodedWidth", "copyiedWidth", "copedBytes", "copodedSize", "copyingLength", "copyingCount", "copedSize", "copiedCount", "copyiedSize", "copyippedWidth", "copedLength", "copyinglength", "copixedBytes", "copiedBytes", "copyiedCount", "copyippedLength", "copodedLength", "copyingWidth", "copyiedLength", "copixedCount", "copyedLength", "copodedlength", "copyingSize", "copyiedlength", "copyiedBytes", "copippedlength", "copyingBytes", "copixedSize", "copixedLength", "copiedSize", "copedCount", "copyippedlength", "copippedWidth", "copippedSize", "copiedWidth", "copyedBytes", "copyedSize", "copyippedSize", "copyedCount"], "percentage": ["Percentance", "percentile", "Percentade", " percentages", "milade", " Percentages", " Percentance", "percentaged", " Percentile", "percentages", "milance", " percentance", "percentance", " percentade", " percentaged", "Percentaged", "milage", "Percentages", " Percentage", "Percentile", "percentade", " percentile", "milaged", "Percentage"]}}
{"id1": "6271502", "id2": "9347451", "code1": "    @Override\n    public InputStream getResourceByClassName(String className) {\n        URL url = resourceFetcher.getResource(\"/fisce_scripts/\" + className + \".class\");\n        if (url == null) {\n            return null;\n        } else {\n            try {\n                return url.openStream();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 0, "substitutes": {"getResourceByClassName": ["getResourceByclassString", "getResourceByclassName", "getResourceForClassName", "getResourceForclassName", "getResourceByClassString", "getResourceByFileString", "getResourceByFilename", "getResourceForclassString", "getResourceByclassname", "getResourceByClassname", "getResourceForClassString", "getResourceForClassname", "getResourceForclassname", "getResourceByFileName"], "className": ["ClassType", "Classname", "scriptPath", "ClassPath", " classPath", "classTitle", "classType", "scriptname", "shortPath", "classPath", " classType", "shortName", "ClassName", "scriptType", " classTitle", "scriptName", " classname", "ClassTitle", "shortTitle", "classname", "shortname"], "url": ["job", "sl", "f", "data", "name", "org", "el", "web", "event", "str", "xml", "class", "base", "ssl", "ls", "log", "page", "b", "loader", "instance", "plug", "zip", "l", "e", "address", "Url", "service", "URL", "source", "buffer", "image", "feed", "api", "path", "object", "lr", "server", "uri", "http", "file", "impl", "resource", "bel", "www", "coll", "orb", "ref", "location", "rl", "window", "resources", "rel", "string", "element", "ob"]}}
{"id1": "5683576", "id2": "755203", "code1": "    public String shorten(String url) {\n        List<NameValuePair> qparams = new ArrayList<NameValuePair>();\n        qparams.add(new BasicNameValuePair(\"version\", \"2.0.1\"));\n        qparams.add(new BasicNameValuePair(\"longUrl\", url));\n        if (login != null) {\n            qparams.add(new BasicNameValuePair(\"login\", login));\n            qparams.add(new BasicNameValuePair(\"apiKey\", apiKey));\n            qparams.add(new BasicNameValuePair(\"history\", \"1\"));\n        }\n        try {\n            BasicHttpParams params = new BasicHttpParams();\n            DefaultHttpClient httpclient = new DefaultHttpClient(params);\n            URI uri = URIUtils.createURI(\"http\", \"api.j.mp\", -1, \"/shorten\", URLEncodedUtils.format(qparams, \"UTF-8\"), null);\n            HttpGet httpget = new HttpGet(uri);\n            if (logger.isDebugEnabled()) logger.debug(\"HttpGet.uri={}\", httpget.getURI());\n            HttpResponse response = httpclient.execute(httpget);\n            HttpEntity entity = response.getEntity();\n            if (entity != null) {\n                InputStream instream = entity.getContent();\n                JsonFactory f = new JsonFactory();\n                JsonParser jp = f.createJsonParser(instream);\n                JmpShortenResponse responseObj = new JmpShortenResponse();\n                for (; ; ) {\n                    JsonToken token = jp.nextToken();\n                    String fieldname = jp.getCurrentName();\n                    if (logger.isDebugEnabled()) logger.debug(\"Token={}, currentName={}\", token, fieldname);\n                    if (token == JsonToken.START_OBJECT) {\n                        continue;\n                    }\n                    if (token == JsonToken.END_OBJECT) {\n                        break;\n                    }\n                    if (\"errorCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorCode(jp.getIntValue());\n                    } else if (\"errorMessage\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setErrorMessage(jp.getText());\n                    } else if (\"statusCode\".equals(fieldname)) {\n                        token = jp.nextToken();\n                        responseObj.setStatusCode(jp.getText());\n                    } else if (\"results\".equals(fieldname)) {\n                        Map<String, ShortenedUrl> results = parseResults(jp);\n                        responseObj.setResults(results);\n                    } else {\n                        throw new IllegalStateException(\"Unrecognized field '\" + fieldname + \"'!\");\n                    }\n                }\n                Map<String, ShortenedUrl> results = responseObj.getResults();\n                if (results == null) {\n                    return null;\n                }\n                ShortenedUrl shortened = results.get(url);\n                if (shortened == null) {\n                    return null;\n                }\n                if (logger.isDebugEnabled()) logger.debug(\"JmpShortenResponse: {}\", responseObj);\n                if (\"OK\".equals(responseObj.getStatusCode())) {\n                    return shortened.getShortUrl();\n                }\n                if (logger.isWarnEnabled()) logger.warn(\"JmpShortenResponse: {}\", responseObj);\n            }\n        } catch (IOException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        } catch (URISyntaxException ex) {\n            if (logger.isWarnEnabled()) logger.warn(\"Exception!\", ex);\n        }\n        return null;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"shorten": ["offen", "Shortend", " Shortener", " Shortening", "shortend", "offening", "shortening", "offend", "Shorten", "offener", " Shortend", "shortener", " Shorten", "Shortener", "Shortening"], "url": ["account", "ls", "source", "text", "method", "secret", "str", "json", "path", "username", "Url", "language", "config", "info", "page", "l", "data", "service", "resource", "email", "location", "www", "base", "name", "server", "host", "URL", "address", "api", "sl", "term", "string", " webpage", "version", "file", "request", "route", "key", "login", "id", " resource", "http"], "qparams": ["quparams", "reqoptions", "Qapi", "Qdetails", "qtypes", " qannels", "qParameters", " qParameters", "reqParameters", "Qplugins", " qtags", "qmac", "Qnames", "qplugins", "sqams", "quproperties", "qunames", "quapi", " qvals", "qtproperties", " qchanges", " qresults", " qproperties", "questapi", " qtypes", "qapi", "reqparams", "kresults", " qapi", "Qtags", " qquery", "Qproperties", "Qparams", "qdetails", "kams", " qams", "questparams", " qnames", "questproperties", "reqtags", "qresults", "qoptions", "Qtypes", "reqproperties", "questannels", "qtags", "qtquery", "qams", "qvals", "qtParameters", "Qvals", "questplugins", "reqmac", " qdetails", " qmac", "kchanges", "qutags", "sqmac", "sqresults", "qproperties", "qnames", "qannels", "questdetails", "qchanges", "qquery", "kparams", " qplugins", "reqquery", "sqtags", "sqparams", "sqoptions", "qutypes", "sqchanges", "questvals", " qoptions", "quannels", "qtparams"], "params": ["p", "lp", "secret", "rules", "ps", "json", "mm", "license", "py", "instance", "config", "s", "param", "phrase", "per", "i", "options", "services", "afi", "ras", "base", "qs", "apter", "server", "password", "pi", "api", "ams", "details", " parameters", "radius", "Parameters", "settings", "plugins", "properties", "pro", "ssl", "ctx", "cmp", "posts", "http"], "httpclient": ["httpconn", " httpconn", "httpconnection", " httppublic", "webClient", "webconn", "webcli", "webconnection", " httpcli", "webclient", "httpClient", "htmlconnection", "webpublic", "htmlclient", "httppublic", "webapi", "htmlcli", "phpclient", "phpClient", "phpapi", " httpconnection", "phppublic", "httpcli", "htmlconn", " httpClient", " httpapi", "httpapi"], "uri": ["uni", "client", "path", " ur", "gi", "environment", "i", " URI", "service", "resource", "proxy", "location", "directory", "document", "base", "database", "u", "server", "URL", "ui", "pi", "api", "address", "iri", "connection", "direction", "mi", "ur", "qi", "plugin", "range", "universal", "request", "route", "ilo", "href", "URI", "cli", "doi", "adi", "ri", "http"], "httpget": ["httpstart", "urlstart", "htmllike", " httpfind", " httplike", " httpGet", "ttpget", "httpquery", "htmlfind", "ttpsend", "harGet", "httpfind", "urlget", "httget", "httpshow", "httpGet", "httpsend", "httGet", "httpsshow", "ttpshow", "htmlget", "htmlGet", " httpsend", "httpssend", "ttpGet", " httpquery", "httpsget", "harfind", "harget", "urlquery", "harlike", " httpshow", "httstart", "httquery", "httplike", "httpsGet", " httpstart", "urlGet"], "response": ["message", "relation", "result", "output", "json", "generation", "successful", "environment", "page", "resp", "data", "service", "object", "resource", "reply", "document", "next", "server", "Response", "api", "body", "onse", "connection", "respond", "full", "received", "value", "collection", "request", "feed", "entry", "status", "application"], "entity": ["p", "ent", "message", "result", "output", "json", "translation", "info", "company", "model", "event", "page", "person", "environment", "component", "e", "po", "image", "issue", "data", "iso", "object", "resource", "email", "metadata", "node", "document", "error", "em", "server", "article", "obj", "api", "body", "connection", "element", "el", "coll", "eni", "value", "file", "collection", "ilo", "get", "xml", "Entity", "content"], "instream": [" invideo", "outstream", "outstruct", " infile", "inputstream", "instruct", " instring", "Instream", "Instring", "instring", " instruct", "invideo", "innstring", "inputfile", "innstream", " inStream", "inputStream", "innfile", "outfile", "infile", "outStream", "Invideo", "inputstruct", "Infile", "inStream", "innvideo"], "f": ["p", "F", "fp", "json", "fx", "cf", "c", "fb", "info", "w", "e", "i", "d", "l", "m", "fm", "aff", "framework", "fing", "bf", "inf", "fd", "fac", "fs", "fe", "api", "j", "h", "fr", "tf", "rf", "full", "fc", "df", "t", "feed", "sf", "v", "fab"], "jp": ["p", "lp", "ijk", "jing", "tp", "pai", "fp", "json", "mp", "git", "py", "jl", "np", "bj", "java", "txt", "dj", "pb", "ppo", "qt", "data", "bp", "fm", "prot", "vp", "bot", "pa", "gp", "jj", "kj", "ja", "dt", "obj", "zip", "api", "ji", "j", "jc", "je", "jen", "cp", "aja", "hp", "orb", "JP", "rup", "appy", "pp", "adj", "uj", "keeper", "pkg", "js", "jo", "jar"], "responseObj": [" responseObject", " responseExt", "respondObj", "ResponseObj", "respObject", "responseOb", "responseObject", "respondInfo", "ResponseObject", "serverobj", "Responseobj", " responseInfo", "respondObject", "respObj", " responseOb", "respondExt", "respExt", "serverObj", "responseExt", "serverObject", "responseobj", "respInfo", "responseInfo", "ResponseOb", " responseobj", "serverOb"], "token": ["p", "cookie", "init", "json", "current", "cho", "session", "generation", "field", "KEN", "language", "date", "info", "event", "wt", "seed", "note", "po", "tree", "notice", "complete", "atom", "qt", "or", "data", "aa", "writer", "in", "object", "format", "bot", "open", "operator", "Token", "valid", "next", "document", "character", "name", "action", "random", "oken", "api", "variable", "string", "fn", "tag", "header", "channel", "rule", "prefix", "option", "element", "parser", "ok", "iter", "tick", "key", "sign", "template", "after", "type", "start", "node", "pattern", "active"], "fieldname": [" fieldvalue", "columname", "fieldnan", "handname", "ieldName", "managervalue", "ieldvalue", "groupname", "Fieldnan", " fieldn", "handName", "Fieldname", "fieldame", "fieldvalue", "managerName", "groupvalue", "fieldn", "handame", "ieldalias", "columnnan", " fieldName", "columnname", "fieldName", " fieldalias", "ieldname", "groupName", "groupalias", "fieldalias", "FieldName", "Fieldame", "columnName", "managern", "handnan", "managername", "groupn"]}}
{"id1": "88047", "id2": "12766394", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndSwrites", "readAndSwwrite", "readAndRebrap", "readAndSwrap", "readandrewwrite", "readandRewwrite", "readandrewrap", "readAndRewrites", "readandrewrite", "readAndRewrap", "readandrewrites", "readandRewrap", "readAndRebrite", "readAndrewrites", "readandRewrites", "readAndrewwrite", "readAndRebwrite", "readAndrewrite", "readandRewrite", "readAndRewwrite", "readAndSwrite", "readAndrewrap", "readAndRebrites"], "inFile": ["outfile", "outSourceFile", "inputFile", " infile", "oldFiles", "outFiles", "oldfile", "InSourceFile", "loginfile", "infile", "inputFiles", "outFilename", " inFilename", "loginFilename", "Infile", "oldFilename", "InFiles", "inputFilename", "loginFiles", "inFiles", "InFile", "inputfile", "oldFile", " inSourceFile", "inSourceFile", "inFilename", "loginFile", " inFiles"], "outFile": ["outfile", "exFILE", "OutFile", "outputFilename", " outDir", "newFile", "OutStream", "offPlace", "outputPlace", "outPlace", "processFilename", "outputFile", "thisfile", "processFile", "thisFile", "outDir", "processFILE", "offFilename", "exFilename", "outFilename", "exFile", "offFile", "outFILE", "processPlace", "Outfile", "outStream", "outputFILE", "OutDir", "thisFilename", "thisFILE", "newfile", " outfile", "newStream", "outputfile", "newDir", "offFILE", " outStream", "exfile"], "iis": ["iiIS", "ciris", "iiss", "ciiss", "IIS", "iniIS", "Iiss", "iris", "Iis", " iIS", "iiris", "ciis", " iIs", "iniris", "ciIS", "iniiss", "iIs", "iIS", "iniis", "iiIs", "iais", "Iais", " iris", "iniIs", "ciais", " iiss", "ciIs", "iiiss", " iais", "iiis"], "dcmParser": ["dcmJar", "dcmPar", "dpmHandler", "DcmReader", "dkmPlugin", "dcrarser", "dmmparser", " dcmPlugin", "dmissionLanguage", "fcmReader", "dpmPar", " dpmPlugin", " dpmReader", "dmoduleReader", "dcmarser", "dmissionParser", " dpmParser", " dpmLoader", "dmmPlugin", "dbmPlugin", " dpmPolicy", "dcmHandler", "DcmJar", "DcmParser", "fpmReader", "dpmparser", "dCMparser", "dpmarser", "dpmLanguage", "dcmparser", "fpmparser", "dmmLoader", " dcmHelper", " dpmarser", "dcmLanguage", " dpmPar", " dpmHelper", "dCMPlugin", "dpmInstallation", "dbmParser", "dpmLoader", "dmodulePlugin", "dcrJar", "dmPlugin", " dcmReader", "dkmPolicy", "dcmPolicy", " dcrLoader", "dcrPlugin", "dcmHelper", "dCMReader", "fcmHandler", "dkmHelper", "fcmparser", "dpmJar", "dbmPolicy", "DcmInstallation", "dpmHelper", "dcmLoader", " dcmLoader", "dcmInstallation", " dpmLanguage", " dcmLanguage", " dcrPlugin", " dcmparser", " dcmJar", "dcrPar", "dpmPlugin", "dcmReader", "dbmHelper", "dCMParser", " dcmPolicy", "dmReader", "dpmPolicy", "dCMHandler", "dmcarser", "dhemJar", " dpmJar", "dcmPlugin", "dmcPar", "dcrParser", "dcrLoader", "dmoduleParser", "dCMLoader", "dmmParser", "dmissionPlugin", "dpmParser", "dmcJar", "fpmParser", " dpmparser", "dhemParser", "dhemReader", "dmLoader", "dhemInstallation", "dpmReader", " dcmPar", "dmoduleJar", "dmissionReader", "dmParser", "dmcParser", " dcmarser", " dcrParser", "fcmParser", "fpmHandler", "dkmParser", " dcrReader", "dcrReader", "dmoduleparser"], "ds": ["dc", "df", "cdn", "ks", "js", "pd", "bs", "ys", "dat", "eps", "d", "is", "gs", "uds", "ads", "utils", "da", "drivers", "di", "ays", "ants", "os", "details", "sync", "sys", "ins", "xs", "amps", "conn", "tes", "dd", "ld", "s", "dds", "qs", "vs", "ls", "iss", "Ds", "dr", "dt", "cs", "icks", "ws", "services", "Os", "session", "des", "gd", "ns", "tx", "ros", "ts", "Db", "vals", "points", "data", "parts", "ils", "nas", "ps", "DS", "ras", "rs", "asi", "src", "db", "ss"], "pdReader": ["pcLoader", "ddStream", "pdRead", "xdReader", "ddRunner", "xdRead", "xdreader", "pcWriter", "hdRunner", "pbLoader", "ddReader", "hdWriter", "hdRead", "dsLoader", "ddLoader", "pbRunner", "pcRead", "dsReader", "hdreader", "pdLoader", "dsreader", "dsRead", "pcReader", "pbReader", "xdWriter", "pdreader", "pdStream", "hdStream", "hdLoader", "dsWriter", "pdRunner", "hdReader", "pbStream"], "out": ["again", "full", "over", "ex", "with", "manager", "w", "order", "s", "url", "her", "image", "auto", "writer", "dot", "ssl", "gen", "write", "parent", "db", "file", "flow", "external", "cache", "o", "oder", "outer", "io", "user", "store", "connection", "model", "code", "password", "login", "page", "output", "data", "term", "OUT", "null", "later", "at", "word", "exp", "copy", "down", "co", "outs", "sync", "sys", "doc", "default", "part", "net", "device", "array", "cli", "lib", "to", "ext", "diff", "obj", "lock", "client", "name", "temp", "group", "pass", "line", "inner", "Out", "layer", "as", "list", "key", "in", "dev", "conn", "object", "child", "err", "up", "base", "exec", "session", "director", " in", "result", "img", "point", "inc", "builder"], "dcmEncParam": ["dcmDecParameter", "dcmEnArg", "dcmElPar", "dcmEstPar", "dcmEnPar", "dcmEncType", "dcmArchArg", "dcmEncArg", "dcmArchParam", "dcmSecType", "dcmElType", "dcmDecPar", "dcmSecParam", "dcmEstType", "dcmDecPart", "dcmDecParam", "dcmEncPar", "dcmEnPart", "dcmEncPart", "dcmArchParameter", "dcmDecType", "dcmEnParam", "dcmEnParameter", "dcmDecArg", "dcmElParam", "dcmEnType", "dcmSecPar", "dcmElParameter", "dcmEncParameter", "dcmSecPart", "dcmEstParameter", "dcmEstParam"], "pdWriter": ["htWriting", "pdWrite", "hdOutput", "htWrite", "PDWriter", "ddWrite", "dpWrite", "dpReader", "ddWriter", "ddReader", "ddOutput", "hdWriter", "dpWriting", "dpWriter", "hdWrite", "PDWrite", "dsReader", "htReader", "PDWriting", "PDReader", "pdOutput", "pdWriting", "dsOutput", "dsWrite", "htWriter", "dsWriter", "hdReader"]}}
{"id1": "22135199", "id2": "823074", "code1": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"testCodingEmptyFile": ["testCodingZeroFile", "testCachingEmptyStream", "testCachingEmptyFiles", "testCodingNoFile", "testCachingOfFile", "testCachingEmptySourceFile", "testCodingOfFile", "testCodingZeroFiles", "testCodingOfSourceFile", "testCodingZeroSourceFile", "testCachingOfSourceFile", "testCodingEmptyFiles", "testCodingNoSourceFile", "testCachingOfStream", "testCodingOfStream", "testCachingEmptyFile", "testCachingOfFiles", "testCodingNoFiles", "testCodingNoStream", "testCodingEmptyStream", "testCodingZeroStream", "testCodingEmptySourceFile", "testCodingOfFiles"], "baos": ["Baoes", "baoS", "waOs", "buo", "baoa", "aaaaOs", "paoa", "BaOS", "pao", "kao", "baOs", "bioS", "bioes", "biotes", "waos", "aaaaos", " baotes", "aaaaoS", "bao", "waoS", " baoS", "BaoS", " baoes", "baotes", "buos", "waOS", "baOS", "kaos", "kaOS", "kaoa", "baoes", "BaOs", "bios", "Baos", "paos", "aaaaOS", "buOS", "buoa", "Baotes", "paOS"], "channel": ["an", "camera", "flow", "url", "cam", "reader", "console", "system", "client", "bean", "feed", "io", "container", "chan", "log", "out", "conn", "context", "stream", "sea", "queue", "c", "self", "connection", "cho", "video", "parent", "handler", "config", "socket", "service", "Channel", "data", "ch", "sc", "server", "source", "group", "can", "annels"], "params": ["processor", "Param", "proc", "Parameters", "tx", "stats", "conn", "cms", "param", " parameters", "Par", "options", "cpu", "null", "par", "ops", "ps", "config", "mm", "css", "parser", " param", "api", "http", "ams", "size", "ctx", "cmp", "settings"], "outbuf": ["Outbuffer", "Outbuff", "inputbuf", " outbuffer", "outputcb", "Outbuf", "outputbuf", "Outcb", "inputqueue", "outputbag", "outputqueue", " outcb", "outqueue", " outbuff", "inputbuff", "outcb", "outbuffer", "inputbag", "outputbuff", "outputbuffer", " outbag", "outbuff", " outqueue", "outbag"], "metrics": ["metals", "matals", "Metals", " metics", "metics", " metals", "metras", " metrix", " metras", "Metric", "monrics", "matric", "metric", "matrix", "Metras", "monics", "Metrix", "monric", "Metrics", "monras", " metric", "Metics", "matrics", "metrix"], "encoder": ["Encoser", "Encoded", "ecode", " encipher", "encoser", " encressor", "enressor", "encoded", "enccode", "ecoding", "Encler", " encoded", "ecipher", "ecler", " encoding", "ecressor", "eccode", "Encoder", "ecoder", "enoded", "encressor", "Encipher", "ecoser", "encler", " encler", "enode", "ecoded", " encode", "encipher", "Encoding", "enoser", "encoding", "Encode", "encode", " enccode", " encoser", "enoder"], "tmpFile": ["poraryfile", "mpFiles", "txtFunction", " tmpFiles", " tmpfile", "vtFile", "poraryPage", "vtfile", "tmpDir", "tmpFunction", "tmpPath", "mpPage", "mpFilename", " tmpDir", "txtFile", "tmpFolder", "mpFunction", "tempFolder", " tmpFilename", "tmpFilename", "tempFile", "testFiles", "txtfile", "mpDir", "tmpPage", "mpFile", "vtDir", " tmpFolder", "poraryFile", "poraryFunction", "testFile", "testFolder", "tempFiles", "tempfile", "mpfile", "vtFilename", "txtPage", "testfile", "tmpfile", "mpPath", "tempPath", "tmpFiles", " tmpPath"], "fout": ["fdurl", " fio", "flwrite", "flurl", "sffile", "frwrite", "ffile", "sfchannel", "Fchannel", "flagain", "frurl", " ffile", "sfio", "frout", "fio", "furl", "sfout", "Fio", "fagain", "fdagain", "Ffile", "fragain", "fwrite", "flout", "fdwrite", "Fout", "fdout"], "wrtout": ["wRTin", "wadrout", "wRTOut", "wRTn", "wrdwriter", "wrdout", "wrin", " wrcouter", "wrcouter", "wrtouter", "wRTouter", "wrout", " wrcin", "wadrwriter", "Wrtouter", "WRTin", " wrcout", "wrcOut", "Wrtn", "wrcout", "wrOut", "wrtOut", " wrtouter", "wrdouter", "wrcn", "Wrtout", "wadragain", "WRTOut", "Wrtin", "wRTagain", " wrtagain", "wadrouter", "wrtn", "wadrin", "WRTwriter", "WRTn", "WrtOut", "wrdin", "wrcagain", " wrcagain", "wrcin", "WRTouter", "wrtin", "Wrtwriter", "wrn", "wrtagain", "wRTwriter", "wrtwriter", " wrtin", "WRTout", "wRTout"], "fchannel": [" fchan", "pqueue", "bcontainer", "fqueue", "fenresource", " fcontainer", "hstream", "pcontainer", "pchan", "hresource", " fconn", "fcontainer", "fconn", "bchan", "fresource", "fstream", "pstream", "fchan", "bconn", "fenchannel", "fenstream", "pchannel", "bchannel", "fenqueue", "hchannel", "pconn", "hqueue", "presource"], "s": ["su", "v", "services", "ins", "ms", "e", "ts", "es", "ns", "abs", "string", "ls", "u", "c", "states", "os", "ses", "strings", "m", "t", "i", "r", "g", "b", "js", "n", "o", "ps", "S", "p", "l", "qs", "ss", "f", "gs", "ings", "settings"]}}
{"id1": "20181656", "id2": "7143591", "code1": "    private int[] sortRows(int[] rows) {\n        for (int i = 0; i < rows.length; i++) {\n            for (int j = 0; j < rows.length - 1; j++) {\n                if (rows[j] > rows[j + 1]) {\n                    int temp = rows[j];\n                    rows[j] = rows[j + 1];\n                    rows[j + 1] = temp;\n                }\n            }\n        }\n        return rows;\n    }\n", "code2": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "label": 0, "substitutes": {"sortRows": ["sortLRow", "ortLows", "sortSlows", "sortPows", "sortSlOWS", "ortRrows", "sortLOWS", "sortProws", "sortPRow", "ortROWS", "sortSlrows", "sortLows", "ortRRow", "sortLrows", "ortLOWS", "ortLRow", "sortPOWS", "sortROWS", "ortLrows", "sortRrows", "sortSlRow", "sortRRow", "ortRows"], "rows": ["keys", "tracks", "maps", "uds", "index", "headers", "checks", "results", "pages", "docs", "ks", "vers", "slice", "posts", "result", "grid", "roads", "rank", "errors", "cases", "shows", "rs", "ids", "raw", "items", "projects", "users", "flows", "ros", "blocks", "lines", "builders", "diff", "ports", "runs", "members", "orders", "points", "roots", "ows", "grades", "ends", "models", "ips", "breaks", "row", "forms", "boards", "groups", "frames", "rss", "tests", "cells", "holes", "ss", "rooms", "array", "types", "values", "files", "relations", "fields", "rates", "right", "acks", "rules", "heads", "multi", "views", "times"], "i": ["index", "id", "pi", "ij", "ind", "c", "z", "ri", "l", "si", "ui", "ii", "ji", "phi", "li", "ip", "x", "p", "mi", "bi", "u", "ai", "ci", "I", "m", "io", "xi", "ix", "a", "ki", "b", "v", "y", "iu", "f", "ik"], "j": ["index", "job", "uj", "n", "ij", "dj", "json", "jc", "ind", "z", "o", "jl", "l", "jo", "fr", "ui", "ii", "key", "aj", "next", "qi", "ja", "ji", " dj", "d", "jan", "q", "li", "h", "x", "p", "u", "jj", "J", "js", "e", "jp", "ix", "k", "b", "y", "v", "jit", "obj", "br", "oj", "adj", "f", "ik"], "temp": ["index", " tmp", "max", "tc", "id", "n", "input", "pre", "tem", "z", "col", "Temp", "flow", "shift", "extra", "iter", "offset", "except", "cache", "diff", " Temp", "parent", "needed", "flat", "tmp", "fake", "emp", "ip", "empty", "get", "null", "test", "dev", "stable", "area", "circ", "k", "unit", "partial", "v", "err", "this", "orig", "cell"]}}
{"id1": "14773780", "id2": "15500892", "code1": "    public void testImageInfo() throws MalformedURLException, IOException {\n        System.out.println(\"ImageInfo:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            ImageInfo ii = new ImageInfo();\n            ii.setInput(istream);\n            assertTrue(\"Not a supported image file format.\", ii.check());\n            int width = ii.getWidth();\n            int height = ii.getHeight();\n            System.out.println(width + \"x\" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"testImageInfo": [" checkMediaInfo", " checkAudioINFO", "testImageINFO", " checkimageINFO", "testMediaInfo", " checkAudioInfo", "testMediaINFO", " checkImageINFO", " checkimageInfo", " checkMediaINFO", " checkImageInfo"], "IOException": ["TimeoutProblem", "TimeoutError", " IOProblem", "IOError", "IOProblem", "TimeoutException", " IOError", "IPException", "IPError", "IPProblem"], "start": ["get", "error", "stage", "size", "left", "pos", "art", "pre", "use", "init", "load", "delay", "id", "check", "open", "from", "info", "diff", "Start", "time", "date", "step", "started", "end", "ish", "min", "st", "set", "scale", "offset", "style", "speed", "first", "shift", "source", "length"], "i": ["image", "ai", "ip", "uli", "m", "j", "p", "ie", "eni", "key", "multi", "fi", "ix", "e", "phi", "id", "abi", "ci", "gi", "ui", "info", "zi", "li", "index", "io", "iu", "ini", "bi", "x", "pi", "f", "xi", "ami", "ti", "k", "ri", "u", "y", "v", "ji", "oi", "mi", "di", "name", "hi", "d", "si", "yi", "qi", "I"], "url": ["image", "in", "sl", "full", "src", "feed", "ls", "bb", "id", "route", "album", "address", "http", "location", "URL", "path", "resource", "a", "hub", "fb", "ref", "img", "out", "file", "build", "f", "Url", "api", "base", "data", "err", "org", "name", "l", "href", "string", "uri", "source", "www"], "istream": ["istam", "istREAM", "intREAM", "istsstream", "irststream", "intam", "istsram", "istsREAM", "diststream", "istsam", "distream", "istram", "ISTream", "distram", "intream", "ISTam", "ISTstream", "irstream", "irstREAM", "intstream", "irstram", "distREAM", "istsream", "ISTREAM", "iststream"], "ii": ["image", "ai", "iq", "ice", "ie", "cci", "iso", "is", "sci", "init", "fi", "ix", "cli", "abi", "ci", "gi", "info", "ui", "inf", "mini", "iss", "zi", "iff", "li", "io", "II", "vi", "iu", "ori", "img", "ini", "fc", "bi", "pi", "agi", "xi", "ti", "ani", "ni", "ji", "oi", "inch", "di", "audi", "hi", "si", "qi", "iv", "uri", "iii"], "width": ["dim", "image", "fw", "large", "size", "shape", "ize", "left", "flow", "layout", "slice", "page", "port", "wid", "diff", "fb", "iff", "weight", "crop", "img", "z", "work", "lon", "wd", "fill", "x", "Width", "min", "en", "area", "platform", "scale", "data", "zip", "w", "gender", "name", "driver", "fx", "frame", "age", "px", "layer", "length"], "height": ["dim", "image", "pad", "ip", "h", "size", "shape", "max", "ady", "Height", "view", "layout", "rank", "deep", "ty", "th", "padding", "right", "crop", "direction", "img", "work", "z", "wd", "build", "angle", "x", "depth", "area", "inches", "y", "density", "w", "rows", "volume", "hd", "style", "stroke", "head", "window", "dy", "length"], "stop": ["next", "ip", "shape", "sort", "block", "output", "feed", "parent", "pop", "limit", "address", "run", "op", "hide", "sleep", "exit", "change", "step", "fill", "end", "trip", "Stop", "set", "rest", "norm", "keep", "put", "drop", "log", "wait", "number", "continue", "ops", "skip", "nat", " Stop", "speed", "place", "enable", "sign", "cut"]}}
{"id1": "4417943", "id2": "8024375", "code1": "    public void test() {\n        try {\n            String query = \"* <http://xmlns.com/foaf/0.1/workplaceHomepage> <http://www.deri.ie/>\" + \"* <http://xmlns.com/foaf/0.1/knows> *\";\n            String url = \"http://sindice.com/api/v2/search?qt=advanced&q=\" + URLEncoder.encode(query, \"utf-8\") + \"&qt=advanced\";\n            URL urlObj = new URL(url);\n            URLConnection con = urlObj.openConnection();\n            if (con != null) {\n                Model model = ModelFactory.createDefaultModel();\n                model.read(con.getInputStream(), null);\n            }\n            System.out.println(url);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"test": [" tests", "run", "scan", "stats", "est", "report", " testing", "build", "app", "tests", "show", "server", "load", "work", "index", "evaluate", "Test", "train", " Test", "example", "check", "start", "parse", "testing", "debug", "loop"], "query": ["timeout", "media", "scan", "qa", "cache", "gallery", "request", "Query", "depth", "expression", "comment", "series", "report", "answer", "qu", "search", "json", "sql", "random", "qs", "qt", "index", "quest", "q", "filter", "range", "dq", "type", "question", "term", "uri", "source", "body", "re", "sq", "sort"], "url": ["resource", "route", "string", "host", "href", "request", "http", "xml", "proxy", "service", "www", "URL", "path", "ur", "api", "search", "Url", "download", "address", "loc", "l", "connection", "base", "server", "location", "config", "sl", "f", "link", "q", "page", "ssl", "html", "error", "data", "id", "web", "uri", "source", "buffer", "name", "db", "file"], "urlObj": [" urlObject", "resourceLib", "fileLib", "fileobj", "UrlLib", "resourceObject", "UrlObj", "Urlobj", " urlLib", "fileObj", "urlobj", " urlobj", "httpOb", "resourceOb", "httpLib", "urlLib", "resourceObj", "httpObject", " urlOb", "fileOb", "UrlOb", "httpObj", "urlOb", "urlObject"], "con": ["fa", "soc", "pc", "fc", "c", "Connection", " rc", "ca", "cons", "Conn", "fun", "aff", "conv", "xc", " CON", "open", "fat", "co", "sync", "Connect", "cf", "ct", "ran", "conn", "cl", "connection", " Con", "cn", "out", "rc", "ocon", "exec", "cp", "cur", "syn", "bc", "f", "CON", "Con", "connect", "uc", "close", "obj", "conf", "sub", " conn", "com", "un", "lc"], "model": ["resource", "class", "cm", "zip", "instance", "m", "view", "xml", "proxy", "response", "copy", "path", "api", "json", "object", "content", "app", "connection", "base", "server", "config", "code", "image", "page", "reader", "data", "type", "obj", "null", "module", "Model", "conf", "info", "source", "client", "file", "models"]}}
{"id1": "5274228", "id2": "659316", "code1": "    public String put(String resourceID, Map<String, String> headersMap) {\n        HttpClient httpClient = new DefaultHttpClient();\n        httpClient.getParams().setParameter(\"http.useragent\", \"sla@soi OCCI Client v0.2\");\n        HttpPut httpPut = new HttpPut(resourceID);\n        List<Header> headersList = this.convert2Headers(headersMap);\n        for (Iterator<Header> iterator = headersList.iterator(); iterator.hasNext(); ) {\n            httpPut.addHeader(iterator.next());\n        }\n        logger.info(httpPut.getRequestLine());\n        logger.info(httpPut.getAllHeaders());\n        Header[] headersArray = httpPut.getAllHeaders();\n        String[] fields = { Response.Location };\n        HashMap<String, String> occiHeaders = new HashMap<String, String>();\n        for (int H = 0; H < headersArray.length; H++) {\n            Header header = headersArray[H];\n            logger.info(\"header - request  -\" + header.toString());\n            logger.info(\"\theaderName - \" + header.getName());\n            logger.info(\"\theaderValue - \" + header.getValue());\n        }\n        String statusLine = null;\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpPut);\n            statusLine = httpResponse.getStatusLine().toString();\n            int statusCode = httpResponse.getStatusLine().getStatusCode();\n            logger.info(\"----------------------------------------\");\n            logger.info(\"StatusLine - (full) - \" + httpResponse.getStatusLine());\n            logger.info(\"\tStatusCode - \" + statusCode);\n            logger.info(\"\tReason - \" + httpResponse.getStatusLine().getReasonPhrase());\n            logger.info(\"\tProtocol - \" + httpResponse.getStatusLine().getProtocolVersion().toString());\n            logger.info(\"----------------------------------------\");\n            if (StatusCode.validate(statusCode)) {\n                logger.info(\"Response Validated\");\n            } else {\n                logger.error(\"Response NOT Validated\");\n                return null;\n            }\n            Header[] headers = httpResponse.getAllHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                Header header = headers[i];\n                logger.info(\"header - response - \" + header.toString());\n                logger.info(\"\theaderName - \" + header.getName());\n                logger.info(\"\theaderValue - \" + header.getValue());\n                for (int h = 0; h < fields.length; h++) {\n                    logger.info(\"\tLooking for  - \" + fields[h]);\n                    if (fields[h].equals(header.getName().toString())) {\n                        logger.info(\"\tFound an OCCI Header - \" + header.getName());\n                        occiHeaders.put(header.getName(), header.getValue());\n                    }\n                }\n            }\n        } catch (org.apache.http.conn.HttpHostConnectException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } finally {\n            httpClient.getConnectionManager().shutdown();\n        }\n        logger.info(\"occiHeaders - \" + occiHeaders);\n        if (occiHeaders.containsKey(Response.Location)) {\n            logger.info(\"Valid Provision\" + statusLine);\n            return occiHeaders.get(Response.Location).toString().replaceAll(Response.jobs, \"\");\n        }\n        logger.info(\"NOT a Valid Provision - \" + statusLine);\n        return statusLine;\n    }\n", "code2": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "label": 0, "substitutes": {"put": ["data", "get", "create", "operation", "st", "PUT", "add", "format", "cache", "output", "UT", "patch", "client", "pull", "parse", "build", "submit", "Put", "update", "transfer", "post", "file", "transform", "resource", "replace", "string", "write"], "resourceID": ["objectIDs", "resourceURL", "resourceid", "serviceIDs", "resourceId", "ResourceIDs", "ResourceURL", "resourceKey", "serviceID", "serviceId", "objectId", "serviceid", "requestKey", "objectID", "ResourceId", "Resourceid", "responseKey", "responseURL", "requestURL", "ResourceKey", "resourceIDs", "requestID", "objectid", "ResourceID", "responseID", "requestId", "responseId"], "headersMap": ["headerArray", "headerSet", " headersFile", "ersArray", "headerMap", "headerFile", "headersFile", "httpList", "httpArray", "httpSet", "ersFile", "headersSet", " headersSet", "headerList", "ersList", "httpMap", "ersMap"], "httpClient": ["phpPut", "httpsBase", "httpsContext", "httpBase", "httpContext", "phpCall", "ttpBase", "phpClient", "httpsPut", "HttpCase", " httpBase", "HttpPut", "HttpServer", "HttpCall", "httpServer", "ttpClient", " httpContext", "HttpClient", "httpsServer", "HttpContext", " httpConnection", "httpCase", " httpCase", "ttpPut", "httpsConnection", " httpCall", "ttpConnection", "httpCall", "phpCase", "httpsClient", " httpServer", "httpConnection"], "httpPut": ["webPUT", "phpPut", "httpPush", "httpsput", "viewPush", "internalGet", "webGet", "phpPush", "httpsDo", " httpPUT", "HttpGet", "viewput", "httpsPut", "httpPUT", "viewPut", "phpSplit", "phpAdd", "httpDo", "HttpPut", "phpGet", "webPut", "HttpDo", "httpsPUT", "Httpput", " httpDo", "httpsGet", "HttpClient", "HttpPUT", "httpsAdd", "httpsPush", "httpWrite", "httpGet", " httpPush", "httpsSplit", "httpSplit", "phpWrite", "viewPUT", "internalPush", "httpput", " httpGet", "httpAdd", "internalPut", "httpsClient", "webPush", " httpSplit", "internalWrite", " httpAdd", " httpWrite", "HttpPush"], "headersList": ["headerArray", "headerSet", "driversL", "ersArray", "headerL", "headerMap", "driversMap", "headersL", "headersSet", "driversArray", " headersSet", "ersL", "headerList", "driversList", "ersList", "ersSet", " headersL"], "iterator": ["reader", "iter", "sequence", "division", "ator", "gener", "vector", "basic", "handler", "later", "slice", "started", "creator", "stream", "set", "adder", "ie", "loop", "walker", "loader", "former", "size", "inner", "multi", "done", "instance", "engine", "writer", "collection", "parser", "random", "ter", "pointer", "step", "interstitial", "entry", "init", "starter", "driver", "oper", "outer", "kick", "next", "li", "finder", "Iterator", "Iter", "operator", "eni", "inter", "append", "processor", "start", "end", "runner", "ski"], "headersArray": [" headersAr", "hersList", "headsArray", "headsList", "ersArray", "headsLength", "ersAr", "filesMap", "headersAr", "headersHash", "filesHash", "filesArray", "hersArray", " headersHash", "hersLength", "hersAr", "headsAr", "filesAr", " headersLength", "headersLength", "ersHash", "ersMap"], "fields": ["region", "values", "data", "rows", "body", "FIELD", "field", "codes", "format", "Field", "files", "content", "zip", "lines", "dates", "pattern", "comments", "errors", "details", "keys", "params", "prefix", "dir", "properties", "types", "json"], "occiHeaders": ["ocsiHeaderers", "ocsiBufflers", "occiHoster", "ocsiBuffer", "ocsiHeadlers", "occiBufferers", "occiBuffers", "occiHostlers", "occiBuilders", "ocsiBuffers", "occiBuffer", "ocsiHeaders", "occiHosterers", "occiBufflers", "occiHeadlers", "occiBuilderers", "occiBuilder", "occiHeaderers", "occiHosters", "occiHeader", "occiBuildlers", "ocsiBufferers", "ocsiHeader"], "H": ["rh", "HT", "SH", "HC", "HH", "HR", "TH", "R", "D", "Length", "V", "C", "Handler", "HI", "HS", "Q", "EH", "OH", "DH", "MH", "I", "B", "U", "HE", "F", "M", "X", "L", "K", "Index", "S", "Head", "J", "G", "NH", "Header", "T", "N", "HTTP", "ID", "CH", "P", "HB", "W", "Hop", "HM", "Y"], "header": ["feature", "reader", "ker", "extra", "er", "f", " request", "manager", "later", "handler", "head", "layer", "info", "event", "definition", "detail", "per", "rule", "inner", "former", "bridge", "her", "writer", "key", "ter", "dr", "back", "row", "comment", "ler", "entry", "block", "buffer", "player", "value", "service", "builder", "request", "response", "outer", "driver", "second", "Header", "document", "consumer", "server", "http", "metadata", "file", "holder", "cher", "message", "frame", "cover", "result", "token", "string", "liner"], "statusLine": [" statusText", " statusBody", "responseCode", "statusBody", "errorCode", "StatusText", "statusFile", "responseLine", "errorString", "responseText", "StatusCode", "errorLine", "StatusLine", "statusText", "StatusBody", "StatusFile", " statusString", "StatusString", "statusString", "errorBody", "responseFile", " statusFile"], "httpResponse": ["httpsRequest", " httpBlock", "Httpresponse", "ttpRequest", "templateResp", "HttpRequest", "HttpPage", "httpsPage", "HttpLine", " httpBody", "httpLine", " httpStatus", "httpPage", "ttpResult", "statusBlock", "actualLine", "httpBody", " httpEnvironment", "statusBody", "statusResponse", "httpsEnvironment", "templateStatus", " httpResult", "httpRequest", "httpEnvironment", "statusResult", "httpsResponse", "httpsBody", "httpresponse", "actualRequest", "actualResponse", " httpRequest", "HttpResult", "httpResp", " httpLine", " httpresponse", "httpBlock", "httpsResult", "templateLine", " httpPage", "templateResponse", "HttpResp", "HttpResponse", " httpResp", "HttpStatus", "httpResult", "actualresponse", "ttpResp", "HttpBlock", "HttpEnvironment", "HttpBody", "ttpResponse", "httpStatus"], "statusCode": ["resultCode", "statusCount", "resultcode", "statusType", "statuscode", "responseCode", "errorCode", " statuscode", "StatusText", "errorType", "responseLine", " StatusData", "StatusData", "responseText", "StatusCode", "errorLine", "StatusLine", "resultLine", "statusText", "statusData", " StatusType", "StatusCount", " statusData", " StatusCode", "resultCount", " statusCount", " StatusLine", "Statuscode", "errorText", "responseType", "StatusType", " statusType"]}}
{"id1": "8932510", "id2": "18693224", "code1": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doPost": ["doPOST", " doPut", "DoGet", "doGet", "doPut", "DoPut", "sendPost", "sendPut", "DoPost", "sendPOST", "sendGet", " doPOST", " doGet", "DoPOST"], "request": ["next", "image", "rate", "query", "save", "parent", "enter", "attribute", "complete", "info", "http", "report", "post", "this", "re", "allow", "Request", "reader", "question", "uri", "create", "get", "client", "view", "user", "input", "message", "path", "rf", "remove", "requ", "command", "QUEST", "event", "join", "right", "writer", "self", "hello", "stream", "q", "form", "object", "context", "port", "child", "result", "url", "req", "subject", "method", "have", "frame", "remote", "head", "buffer", "queue", "instance", "server", "connection", "resource", "xml", "model", "session", "data", "type", "application", "document", "call", "project", "list", "current", "config", "condition"], "response": ["next", "image", "error", "client", "writer", "service", "stream", " Response", "host", "output", "reply", "view", "object", "respons", "server", "json", "result", "connection", "resource", "message", "report", "xml", "Response", "description", "resp", "onse", "data", "status", "application", "document", "res", "site", "respond", "re"], "is": ["lis", "ai", "ip", "in", "Is", "iri", "mis", "p", "us", "bis", "ie", "iso", "isl", "isin", "isa", "eni", "i", "bs", "ois", "was", "ib", "ci", "isi", "address", "ris", "alis", "IS", "info", "ui", "iss", "rss", "http", "ios", "ori", "isc", "nis", "ir", "out", "iris", "ini", "ais", "pi", "url", "api", "sis", "ri", "are", "isp", "it", "vs", "as", "si", "web", "uri", "ist"], "page": ["next", "image", "blog", "ip", "error", "button", "account", "p", "flash", "html", "pp", "phone", "order", "view", "object", "pg", "user", "sea", "parent", "photo", "po", "office", "handler", "server", "cache", "per", "child", "result", "code", "path", "message", "pool", "ko", "change", "line", "plane", "cover", "root", "end", "f", "url", "pages", "area", "channel", "session", "pe", "can", "bad", "pm", "article", "wp", "record", "wiki", "so", "node", "browser", "site", "list", "filter", "Page", "web", "menu", "pl", "www", "sp"], "os": ["mo", "p", "obj", "oss", "pos", "socket", "object", "oid", "ls", "po", "ros", "oo", "ios", "io", "op", "oto", " bos", "oa", "OS", "ot", "o", "so", "ops", "bos", "ps", "ms"], "rootUrl": ["randomPage", "webPage", "remoteURL", "randomURL", "remoteUrl", "randomUrl", "rootPage", "rootURL", "weburl", "remoteurl", " rooturl", "rooturl", " rootPage", "webURL", " rootURL", "randomurl", "remotePage"], "isMultipart": ["isMultitepart", "isMultiisepart", "isMultiseart", "isMultiiseArt", "isMultiteart", "isMultiteoint", "isMultiipoint", "isMultiipppart", "isMultipoint", "isMultippart", "isMultiparts", "isMultiseArt", "isMultiipart", "isMultypArt", "isMultumparts", "isMultypart", "isMultiipparts", "isMultyppart", "isMultiisearts", "isMultisearts", "isMultiiparts", "isMultiipArt", "isMultumppart", "isMultumpArt", "isMultitearts", "isMultyparts", "isMultipArt", "isMultipppart", "isMultiippart", "isMultisepart", "isMultiiseart", "isMultiippoint", "isMultippoint", "isMultipparts", "isMultumpart"], "rd": ["ind", "db", "RD", "fr", "dig", "rl", "fd", "func", "std", "lt", "fl", "rs", "cr", "rx", "pd", "wid", "loc", "dra", "cd", "dr", "od", "rb", "rss", "ru", "dj", "rh", "td", "rr", "ra", "wr", "ds", "dh", "director", "bd", "rw", "rf", "rolog", "ren", "rt", "xd", "rn", "aa", "rg", "respond", "ld", "rid", "ird", "hh", "dd", "pt", "rob"], "upload": ["image", " uploading", "stream", "form", "transfer", "object", "load", "input", "user", " archive", "instance", "install", "pkg", "archive", "server", "or", "pload", "http", "container", "audio", " instance", "io", " Upload", "out", "file", "sup", "post", "util", "f", "Upload", " submission", "url", "uploads", "zip", "control", "driver", " uploaded", "project", "parser", "command", "folder", "dd", "create", "up"], "webUrl": ["wwwUr", "rootUr", "WebLine", "WebPage", "webLine", "webPage", " webPath", "wwwURL", "WebUr", "wwwLine", "rootPage", "rootURL", "webUr", "WebPath", "WebUrl", " webLine", " webPage", "webPath", "wwwUrl", "WebURL", " webURL", "webURL", " webUr", "rootPath"], "iter": ["former", "Iterator", "iterator", "in", "liter", "vis", "ner", "cher", "inse", "Iter", "eni", "collect", "apper", "order", "init", "feed", "its", "slice", "enter", "coll", "loc", "info", "or", "oper", "ver", "http", "inner", "ite", "li", "gener", "ir", "keeper", "iner", "ignore", "file", "end", "ator", "set", "exec", "err", "keep", "inter", "er", "over", "it", "itter", "ter", "reader", "list", "ser", "iv", "outer", " iterator", "walker", "inc", "izer"], "item": ["items", "get", "r", "image", "ip", "in", "atom", "m", "p", "element", "g", "entry", "stat", "queue", "q", "order", "object", "el", "app", "feed", "input", "user", "instance", "e", "coll", "info", "source", "result", "or", "inner", "li", "op", "xml", "value", "row", "rec", "file", "part", "end", "link", "area", " Item", "this", "api", "unit", "update", "zip", "Item", "data", "temp", "bar", "er", "it", "other", "record", "hop", "entity", "site", "ar", "plugin", "custom", "extra", "layer", "up"], "name": ["in", "m", "size", "term", "one", "n", "block", "label", "key", "i", "old", "common", "on", "e", "id", "parent", "ame", "nam", "info", "child", "connection", "inner", "path", "time", "not", "orig", "nm", "word", "part", "NAME", "x", "end", "f", "col", "prefix", "no", "none", "data", "type", "ni", "Name", "names", "call", "member", "string", "named", "am", "field", "layer", "na", "non"], "baos": ["baOS", "caOs", "nao", "baoes", " baios", " bais", "BAoes", "caOS", "BAos", "pao", "Bao", " bao", "BAis", "BAOS", "paos", "abaos", "sao", "cais", "cao", "bao", "Baos", "Baios", "saOS", "paOs", "abaOS", "naos", "pais", "naOs", " baoes", "baios", "nais", "bais", "paoes", "abao", "baOs", "saos", " baOS", "BAo", "abaios", "BAios", "caos", "sais", "BaOs", "Bais"], "wpIs": ["wordpressis", "WPIs", "cpIns", "wxis", "wordpressAs", "gpIs", "wpis", "phpIs", "xpIs", "cpIS", "fwIs", "wordpressOs", "xpis", "fpIs", "fpOs", "WPAs", "cpIs", "wpOs", "ipI", "WPI", "wxIS", "fwAs", "xpOs", "wpIS", "ipIs", "wxIns", "WPis", "phpis", "gpis", "WPOs", "WPIS", "gpOs", "wxIs", "fpIns", "ipIS", "fpis", "fwIS", "phpIns", "ipAs", "gpIns", "wpI", "cpis", "wpIns", "fwI", "wordpressIs", "xpAs", "phpIS", "wpAs", "WPIns"], "u": ["hu", "su", "bu", "us", "p", "ul", "tu", "i", "s", "uv", "ou", "input", "nu", "U", "mu", "ui", "Lu", "cu", "ru", "iu", "uni", "file", "util", "f", "url", "Url", "uid", "api", "uu", "uci", "o", "b", "l", "fu", "web", "lu", "ur", "uri", "una", "c"]}}
{"id1": "7276377", "id2": "14617444", "code1": "    public static String checksum(URL url, String algorithm) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(algorithm);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex);\n        }\n        byte[] bytes = new byte[4 * 1024];\n        try {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                int nBytesRead = 0;\n                while ((nBytesRead = in.read(bytes)) > 0) {\n                    messageDigest.update(bytes, 0, nBytesRead);\n                }\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm);\n        }\n        byte[] checksumValue = messageDigest.digest();\n        return digestAsString(checksumValue);\n    }\n", "code2": "    public void readUNI(Vector<String> descriptions, String source) {\n        InputStream is = null;\n        try {\n            URL url = new URL(source);\n            is = url.openStream();\n            Scanner scanner = new Scanner(is);\n            scanner.nextLine();\n            String line = \"\";\n            String id = \"\";\n            String desc = \"\";\n            while (scanner.hasNextLine()) {\n                line = scanner.nextLine();\n                Scanner linescanner = new Scanner(line);\n                linescanner.useDelimiter(\"\\t\");\n                id = linescanner.next();\n                linescanner.next();\n                desc = linescanner.next();\n                linescanner.useDelimiter(\"\\n\");\n                linescanner.next();\n                descriptions.add(id + \" \" + desc);\n            }\n        } catch (MalformedURLException e) {\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"checksum": ["decumb", "cksums", "checksums", "ckssum", "decums", "cksumb", "cksum", " checkssum", " checksumb", "checkssum", "decum", " checksums", "checksumb", "decsum"], "url": ["image", "fr", "email", "service", "sl", "cert", "stream", "host", "src", "feed", "proxy", "user", "id", "server", "rule", "address", "loc", "or", "connection", "filename", "http", "location", "URL", "path", "resource", "ssl", "manager", "file", "str", "f", "Url", "base", "download", "gl", "loader", "ll", "text", "name", "l", "string", "href", "ur", "uri", "source", "config", "username"], "algorithm": ["malgebra", "algebra", "algo", "ALgebra", "Alignment", "exgo", "malignment", "Algebra", "Algorithm", " algorith", " alignment", " algo", "allgorithm", "allgo", "allgorith", "Algorith", "ALgo", "malgorith", " algebra", "ALgorith", "malgo", "alignment", "exgorithm", "allgebra", "malgorithm", "exgebra", "Algo", "exgorith", "algorith", "ALgorithm"], "messageDigest": ["messageRegator", "messageDester", "messageDigade", "messagediger", "messageMixpe", "messageDiger", "messageDigge", "messageDest", "MessageDest", "messageDigess", "messagedigester", "messageSignester", "messageDesignator", "messageDigester", "messageMixest", "messageDse", "messageSignge", "messageDge", "messageRegess", "MessageMixpe", "messageDesignester", "MessageDesignest", "MessageDester", "messageDade", "MessageDigest", "MessageSignester", "messagedigpe", "messageDesigness", "MessageDigess", "MessageDesignester", "MessageDigade", "messageDigpe", "MessageMixer", "messageDpe", "messagedigade", "messageMixer", "messagedigse", "messageSignest", "MessageMixest", "MessageDigse", "messagedigess", "MessageDigator", "messageDigator", "MessageDesignator", "messagedigge", "MessageSignest", "MessageDiger", "MessageMixester", "messageDer", "messageMixester", "messageDigse", "MessageDigge", "MessageDade", "MessageSignge", "MessageSignse", "MessageDse", "MessageDesigness", "messageDesignest", "messageSignse", "messagedigator", "messagedigest", "messageRegest", "messageRegester", "MessageDigpe", "MessageDigester"], "bytes": ["items", "vals", "os", "buffer", "words", "size", "ipes", "steps", "files", "loads", "limits", "bs", "units", "cells", "resses", "ls", "ips", "reads", "es", "lines", "gets", "objects", "boot", "seconds", "tes", "bps", "Bytes", "resources", "frames", "pieces", "classes", "bits", "pages", "ones", "zip", "blocks", "values", "errors", "eps", "rows", "bles", "vs", "parts", "outs"], "in": ["r", "fr", "m", "client", "n", "inn", "stream", "gin", "isin", "i", "is", "socket", "s", "init", "impl", "input", "version", "id", "ex", "din", "conn", "fe", "a", "inner", "nin", "ssl", "out", "ini", "con", "rin", "file", "kin", "min", "f", "serv", "login", "data", "ac", "err", "b", "token", "ins", "bin", "In", "l", "reader", "IN", "again", "as", "gen", "win", "source", "c", "inc"], "nBytesRead": ["nPagesLength", " nBytesCount", "nFramesFound", "nFramesLength", "nByteFound", "nBytesLength", "nCharactersLength", "nBytesCount", "nBytesFound", "nWordsWritten", "nWordsRead", " nByteCount", " nByteLength", "nBytesLoad", "nPartsRead", " nBytesLoad", "nCharactersRead", " nBytesFound", " nByteFound", " nByteWritten", " nByteRead", "nByteLoad", "nPagesRead", "nCharactersCount", "nPagesFound", "nPartsWritten", "nByteRead", " nBytesLength", "nPartsLoad", "nFramesWritten", "nBytesWritten", "nByteCount", "nWordsLength", "nByteWritten", "nFramesRead", "nPagesWritten", " nByteLoad", "nCharactersWritten", " nBytesWritten", "nByteLength", "nWordsCount"], "checksumValue": ["checksupString", "checksramArray", " checkssumString", "checkssumText", "checksummVal", "checksummArray", " checkssumVal", "checksupValue", " checkssumText", " checksumString", "checksumberValue", "checkssumValue", " checkssumData", " checksumText", "checksramPath", "checksummValue", "checksumData", "checksumArray", "checksumberText", " checkssumPath", "checkssumVal", "checksummPath", " checksumVal", "checksupData", " checkssumArray", " checkssumValue", "checksupText", "checksumString", "checksramValue", "checksumText", "checkssumArray", "checksumberData", " checksumArray", "checksumPath", " checksumData", "checksumberString", "checkssumPath", "checkssumData", " checksumPath", "checksramVal", "checkssumString", "checksumVal"]}}
{"id1": "20011285", "id2": "19739421", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" cp", "create", "sync", "paste", "py", "load", "update", "download", "cat", "link", "move", "cop", "clone", "rm", "share", "clip", "log", "change", "transfer", "zip", "split", "upload", "Copy", "cp", "opy", "write", "replace", "file", "save", "apply", "type", "get", "delete"], "sourceFile": ["ourceFolder", "sourceDir", "ourceDirectory", "apiFile", "SourceTime", "sourcePage", "ourceSourceFile", " sourcefile", " sourceFILE", "sourceFILE", "siteFiles", "sourceSourceFile", "ourceBook", " sourceFolder", "ourceFiles", "sampleFiles", " sourceFiles", " sourcePage", "apiFiles", "siteFILE", "sampleFilename", "siteFile", "slaveFilename", "sourceDirectory", "ourceFile", " sourceSourceFile", "ourceTime", "sampleFile", "sampleFILE", "SourcePlace", "sourcePlace", " sourceTime", "targetDirectory", "siteFilename", "targetDir", "apiFILE", "targetFiles", "sourceFilename", "ourcefile", "slaveFiles", "sourceBook", "targetFile", " sourceBook", "targetFolder", "SourceDir", " sourceDirectory", "SourceSourceFile", " sourceFilename", "SourceFile", "sourcefile", "slaveFile", "sourceFiles", "sourceTime", "sourceFolder", "apiFilename", "SourceDirectory", " sourcePlace", "slaveFILE", "ourcePage", "SourceBook", "targetPage", "ourcePlace", " sourceDir", "Sourcefile", "SourceFiles"], "destinationFile": ["destinatingFiles", "destwayFiles", "destinateFolder", "dominationPath", "destinatefile", " destinatingFile", "DestinationDirectory", "dominatorFiles", "distructionFolder", "destinationPath", "distructionFILE", "distinationFile", "dominationFile", "desturationDirectory", "distructionFile", "destwayfile", "targetinatedFolder", "destinatorSourceFile", "destinatorfile", " destinationfile", "destuationFile", "destuationfile", "destinatingFolder", "destinationDirectory", "targetinationFolder", "destinatorDirectory", "dominatorFILE", "DestinationFile", "destinatorFile", "destinateFile", "destinationSourceFile", "destinatePath", "distinationfile", "destinatedFolder", "destinatedFile", "DestinatingFile", "destructionfile", "targetinationfile", "destinateFiles", " destinatingfile", "destuationFILE", "destructionFile", "destinatingfile", "destinatedfile", "destinatorPath", "destinatingFILE", "dominatorFile", "desturationFiles", "destinationFolder", "destinationFILE", "destructionFolder", "DestinationSourceFile", "targetinatedFiles", "targetinationFiles", "destinatingFile", "destwayFile", "dominationfile", "destinatorFILE", "destwayFILE", "destuationFolder", "destinatorFolder", "destinationfile", "targetinatedfile", "DestinatingDirectory", "dominationFILE", "distructionfile", "destinationFiles", "distinationFolder", "destructionFILE", " destinationFolder", "desturationSourceFile", "dominationFiles", "destinatingSourceFile", " destinationFiles", "targetinationFile", "destinatedFiles", "desturationFile", "dominatorfile", " destinatingFiles", "destinatingPath", "dominatorPath", "targetinatedFile", "distinationFILE", " destinatingFolder", "destinatorFiles", "DestinationFiles", "DestinatingFiles", "destinatingDirectory", "DestinatingSourceFile"], "tmp": ["p", "stuff", "tp", "apps", "flat", "cache", "current", "media", "pty", "mp", "ppa", "st", "mm", "py", "csv", "np", "fb", "bb", "buf", "page", "e", "txt", "po", "area", "pos", "mb", "meta", "data", "amp", "folder", "storage", "img", "ip", "dest", "sup", "rm", "array", "vm", "params", "files", "obj", "zip", "split", "nb", "api", "dat", "sp", "rb", "upload", "list", "handler", "mo", "temp", "part", "t", "pp", "slice", "dir", "diff", "tab", "v", "db", "cmp"], "f": ["p", "x", "lf", "F", "fp", "uf", "fx", "cf", "c", "info", "fb", "this", "e", "l", "ff", "m", "af", "bf", "io", "g", "fo", "inf", "b", "u", "fd", "fs", "fe", "conf", "fl", "j", "fn", "fr", "fa", "tf", "handler", "rf", "full", "fc", "file", "fi", "t", "r", "df", "o", "xf", "v", "d"], "i": ["p", "x", "uri", "ij", "c", "ai", "s", "ii", "gi", "info", "ix", "e", "d", "vi", "l", "I", "ie", "ci", "m", "in", "multi", "ip", "n", "io", "iu", "bi", "si", "name", "u", "b", "lc", "ui", "pi", "oi", "ji", "li", "j", "index", "h", "hi", "di", "qi", "y", "xi", "fi", "key", "o", "id", "v", "start", "ri", "ti"], "source": ["result", "cache", "uri", "current", "client", "back", "use", "view", "component", "slave", "this", "e", "ie", "input", "ource", "src", "SOURCE", "get", "Source", "service", "from", "resource", "ce", "proxy", "storage", "force", "io", "core", "si", "base", "null", "server", "ge", "sl", "secure", "grade", "scope", "connection", "stream", "wrapper", "slice", "site", "diff", "id", "reader", "parent", "start", "target"], "destination": ["destinating", "destinated", " destation", "estinator", "Destinated", "partinator", "destation", "combinate", "generinator", "partation", "generination", "estination", "destinate", "partination", "combinating", "Destation", "generinate", "partinated", "combinator", "generinated", " destinator", "Destinate", " destinated", "estinating", "combination", "Destination", "destinator", "Destinating", "Destinator", "combinated", "estinate"]}}
{"id1": "15500892", "id2": "18164929", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandGID", "getRandomGuid", "getRandomIGuid", "getRandGUID", "getRandGuid", "getRandomUID", "getRandUuid", "getRandomGCuid", "getRandomIGUID", "getRandomGCid", "getRandomGid", "getRandomGID", "getRandUUID", "getRandUid", "getRandomIGID", "getRandomUUID", "getRandomUuid", "getRandUID", "getRandomUid", "getRandGid", "getRandomGCID", "getRandomIGid", "getRandomGCUID"], "secure": ["active", "https", "secondary", "force", "depth", "session", "allow", "remote", "seed", "encrypted", "exclusive", "timeout", "smart", "ssl", "require", "zip", "deep", "random", "pure", "sensitive", "secret", "external", "proxy", " insecure", "service", "sec", "confirmed", "config", "server", "protect", "weak", "Secure", "ce", "unsigned", "sr", "debug", "safe", "host", "security", "use", "stable"], "md5": ["md2", " MD2", "md500", " md500", " md3", "cmd512", "MDql", "MD5", "MD500", " md512", "MD11", "MD512", "md512", " MD500", "md11", " mdql", "cmdql", " MD11", " md2", "MD2", " MD3", "mdql", " MD5", "cmd5", "cmd3", " md11", "md3", "MD3"], "sbValueBeforeMD5": ["sbValueAfterMS95", "sbValueBeforeMD3", "sbValueBeforeMC5", "sbValueAfterMS55", "sbValueBeforeMP1", "sbValueBeforeD65", "sbValueAfterMP3", "sbValueAfterMD95", "sbValueAfterMS65", "sbValueBeforeMP3", "sbValueAfterMS5", "sbValueBeforemd25", "sbValueBeforeAMD3", "sbValueBeforeMAC0", "sbValueBeforeMS95", "sbValueBeforemd3", "sbValueBeforemd375", "sbValueBeforeDER1", "sbValueGivenMD375", "sbValueBeforeAMD5", "sbValueBeforeDER20", "sbValueBeforeMS512", "sbValueBeforeSHA1", "sbValueBeforeMP7", "sbValueBeforeMS375", "sbValueBeforeDER55", "sbValueBeforeMD55", "sbValueBeforeMI5", "sbValueBeforeD5", "sbValueBeforeMAC55", "sbValueBeforeMS20", "sbValueGivenmd512", "sbValueGivenmd3", "sbValueAfterMD20", "sbValueBeforeMS5", "sbValueBeforemd95", "sbValuebeforeMD005", "sbValueBeforeMD75", "sbValueBeforeDER005", "sbValueAfterMD7", "sbValueBeforeSHA5", "sbValueAfterMS75", "sbValueBeforeMS7", "sbValueBeforeMD7", "sbValueAfterMD0", "sbValueBeforeMI3", "sbValueAfterMS25", "sbValueBeforeMR25", "sbValueBeforeDER5", "sbValueAfterMD25", "sbValueBeforeAMD1", "sbValueBeforeMS75", "sbValuebeforeSD5", "sbValueBeforeSD005", "sbValueAfterMP1", "sbValueAfterMP7", "sbValueAfterMS0", "sbValueAfterMS20", "sbValueBeforeAMD20", "sbValueBeforeMS25", "sbValuebeforeSD20", "sbValueAfterMS1", "sbValueAfterMD1", "sbValueBeforeMD20", "sbValueBeforeMD1", "sbValueBeforeMD95", "sbValueBeforeDER0", "sbValueBeforemd65", "sbValuebeforeMD5", "sbValueBeforeMS65", "sbValueBeforeMI20", "sbValueBeforeMS55", "sbValueGivenMD3", "sbValueBeforeMI1", "sbValueAfterMD75", "sbValueBeforeMS0", "sbValueBeforeMAC5", "sbValueBeforeMI7", "sbValuebeforeSD005", "sbValueBeforeSD1", "sbValueBeforeMD0", "sbValueGivenMD512", "sbValueBeforeDER3", "sbValueBeforeD3", "sbValueAfterMP5", "sbValueBeforeD75", "sbValueBeforeMD512", "sbValueGivenmd5", "sbValueBeforeSD20", "sbValueAfterMD55", "sbValueBeforeMD25", "sbValuebeforeSD1", "sbValueAfterMD3", "sbValueBeforeMD65", "sbValueGivenmd375", "sbValueBeforemd75", "sbValuebeforeMD20", "sbValueGivenMD5", "sbValueAfterMD65", "sbValueBeforeMP5", "sbValueBeforeMD005", "sbValueBeforemd5", "sbValueBeforeMS3", "sbValueAfterMS3", "sbValueBeforeMD375", "sbValueBeforeSHA20", "sbValueBeforeMAC3", "sbValueAfterMD5", "sbValueBeforeMC3", "sbValueBeforeMS1", "sbValuebeforeMD1", "sbValueBeforeMR95", "sbValueBeforeMC375", "sbValueBeforeMC512", "sbValueBeforemd512", "sbValueBeforeMR3", "sbValueBeforeSD5", "sbValueBeforeSHA005", "sbValueBeforeMR5"], "time": ["offset", "etime", "loc", "name", "version", "times", "depth", "error", "type", "slice", "cost", "seed", "mode", "tim", "timeout", "event", "counter", "Time", "user", "size", "clock", "year", "TIME", "work", "random", "tz", "race", "count", "money", "value", "ime", "speed", "date", "rate", "duration", "delay", "id", "timer", "hour", "host", "length", "start"], "rand": ["rh", "rol", "reg", "version", "depth", "q", "risk", "error", "type", "range", "seed", "clean", "rank", "min", "gen", "winner", "bot", "rc", "rule", "rage", "mid", "win", "cr", "r", "root", "year", "raid", "max", "chance", "random", "lang", "rr", "Rand", "count", "serial", "order", "round", "ng", "rate", "delay", "id", "ro", "index", "right", "res", "pick", "alpha", "bit"], "valueBeforeMD5": ["valueBeforeMP53", "valueBeforeMD85", "valueBeforeMC3", "valueAfterAMD53", "valueBeforeMP2", "valueBeforeMD3", "valueBeforemd3", "valueBeforeMP5", "valueInsideMD3", "valueBeforeMC5", "valueBeforeMP3", "valueBeforeMD53", "valueAfterMD53", "valueInsideMD2", "valueInsideMD85", "valueBeforeAMD3", "valueBeforemd5", "valueBeforeAMD5", "valueBeforemd85", "valueBeforeAMD53", "valueAfterAMD5", "valueBeforeMC2", "valueBeforeMD2", "valueAfterMD3", "valueBeforeMC85", "valueAfterAMD3", "valueBeforeAMD2", "valueInsideMD5", "valueAfterMD2", "valueBeforemd2", "valueAfterAMD2"], "array": ["feature", "app", "error", "data", "vector", "archive", "batch", "allow", "arr", "range", "Array", "audio", "database", "pair", "any", "binary", "expression", "sample", "cache", "instance", "section", "collection", "shape", "angle", "address", "row", "list", "storage", "image", "value", "api", "arrow", "air", "object", "our", "number", "view", "function", "message", "result", "record", "integer", "area", "string", "element", "ray"], "sb": ["SB", " SB", "BB", "bm", "cb", "sl", "ob", "sg", "nn", "si", "lp", "bj", "gb", "s", "sbm", "bs", "sth", "bt", "eb", "lab", "bh", "xb", "bl", "binary", "kb", "bb", "rob", "mb", "sv", "bp", "ruby", "rb", "sq", "buffer", "abb", "lb", "stab", "zb", "lr", "sa", "pb", "ab", "wb", "nb", "src", "bsp", "bf", "sf", "orb", "usb", "obb", "fb", "bc", "ib", "buf"], "j": ["x", "job", "ji", "ij", "f", "y", "jj", "bj", "q", "g", "p", "k", "ie", "pr", "jp", "br", "num", "part", "l", "aj", "ja", "e", "key", "o", "dy", "d", "i", "z", "ch", "js", "J", "v", "li", "code", "n", "ii", "uj", "c", "jo", "index", "jl", "adj", "out", "length", "obj", "end"], "b": ["x", "be", "bin", "BB", "job", "cb", "f", "y", "bit", "bs", "p", "k", "eb", "binary", "bb", "bi", "B", "br", "mb", "l", "bug", "e", "bc", "rb", "d", "i", "bar", "db", "lb", "n", "ab", "c", "pb", "a", "bf", "orb", "fb", "nb", "ib", "ob"], "valueAfterMD5": ["valueBeforeMD7", "valueAfterMP3", "valueAfterVM7", "valueAfterMP5", "valueBeforeMP2", "valueBeforeMD3", "valueBeforeMP5", "valueAfterMD7", "valueBeforeMP3", "valueBeforeMP7", "valueAfterVM5", "valueAfterMP7", "valueAfterAMD5", "valueAfterVM2", "valueBeforeMD2", "valueAfterMD3", "valueAfterAMD3", "valueAfterVM3", "valueAfterMD2", "valueAfterMP2", "valueAfterAMD7", "valueAfterAMD2"]}}
{"id1": "20011285", "id2": "19687456", "code1": "    public static void copy(File sourceFile, File destinationFile) {\n        try {\n            if (((sourceFile == null) && (destinationFile == null)) || ((sourceFile == null) || (destinationFile == null))) {\n                System.out.println(\"sourceFile & destinationFile is null\");\n                System.exit(-1);\n            }\n            if (sourceFile.isDirectory()) {\n                File[] tmp = sourceFile.listFiles();\n                File f;\n                for (int i = 0; i < tmp.length; i++) {\n                    f = new File(destinationFile.getAbsolutePath() + File.separator + tmp[i].getName());\n                    f.getParentFile().mkdirs();\n                    copy(tmp[i], f);\n                }\n            } else {\n                System.out.println(\"\\nCopy from: \" + sourceFile + \"\\n\\n     to: \" + destinationFile);\n                FileChannel source = new FileInputStream(sourceFile).getChannel();\n                FileChannel destination = new FileOutputStream(destinationFile).getChannel();\n                destination.transferFrom(source, 0, source.size());\n                source.close();\n                destination.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 1, "substitutes": {"copy": ["share", "save", "delete", "apply", "change", "rm", "transfer", "zip", "load", "Copy", "replace", "log", "py", "cp", "write", "link", "upload", " cp", "clone", "type", "cop", "sync", "update", "clip", "get", "move", "file", "download", "create", "split", "cat", "paste", "opy"], "sourceFile": [" sourceDir", "targetFiles", "ourceDirectory", "apiFILE", "sourceFiles", "slaveFILE", "apiFilename", " sourceTime", "slaveFile", "sourceTime", "targetFolder", " sourcePlace", "sampleFiles", " sourceFolder", "targetDir", "ourcePage", "ourceFile", "sourceFolder", "targetFile", "sourcePage", " sourceFiles", " sourcePage", " sourceFILE", "sourceFILE", "sourceFilename", "SourceSourceFile", "ourceFiles", "sourceSourceFile", "ourceBook", " sourcefile", "SourceDirectory", " sourceDirectory", "siteFiles", "ourceTime", "sourceBook", "SourceFile", "ourcefile", "targetPage", "sourcefile", "SourcePlace", "apiFiles", "ourceSourceFile", "SourceDir", "SourceTime", "targetDirectory", "sampleFilename", "sampleFile", " sourceSourceFile", " sourceBook", "sampleFILE", "SourceBook", "sourceDirectory", " sourceFilename", "siteFilename", "apiFile", "Sourcefile", "siteFile", "siteFILE", "slaveFiles", "slaveFilename", "SourceFiles", "sourceDir", "sourcePlace", "ourceFolder", "ourcePlace"], "destinationFile": ["destructionFolder", " destinatingfile", "targetinationfile", "DestinatingSourceFile", "targetinationFiles", "destinatefile", "targetinationFolder", "destinatorFILE", "destinatorSourceFile", "destwayfile", "destinatingPath", "DestinatingFile", "distinationFile", "dominatorFile", "destuationFILE", "destinateFolder", "desturationFiles", "destinatedFiles", "destinatingFile", "destuationfile", "dominationPath", "DestinationFile", "targetinatedFile", "destinationFILE", "destinatingFolder", "destwayFile", "distinationfile", "dominatorPath", "destinatorFiles", " destinationFiles", "destinatorPath", "destwayFiles", "DestinatingFiles", "destinatorDirectory", "dominatorfile", "destructionFile", "destuationFolder", "destinateFiles", "destinationDirectory", "destructionfile", "destinatorfile", "targetinatedFiles", "DestinatingDirectory", "destinatedFile", " destinationfile", "destinatingfile", "destinatorFolder", "dominatorFiles", "destinatorFile", "distructionfile", "destinationPath", "destinateFile", "destinatedFolder", "dominationfile", "desturationDirectory", "distinationFILE", "distinationFolder", "destinationFolder", "destuationFile", "destinatingSourceFile", "desturationFile", "destinatingFiles", "distructionFolder", "DestinationSourceFile", "destinationFiles", "targetinatedFolder", "DestinationFiles", "distructionFILE", "destinatePath", "destinationSourceFile", " destinationFolder", " destinatingFolder", "DestinationDirectory", "destinatingDirectory", "dominationFiles", "destwayFILE", " destinatingFile", "distructionFile", "destinatedfile", "destructionFILE", "dominationFILE", "dominatorFILE", "destinationfile", "desturationSourceFile", "targetinationFile", "destinatingFILE", "dominationFile", " destinatingFiles", "targetinatedfile"], "tmp": ["csv", "v", "stuff", "ip", "st", "img", "params", "amp", "cache", "tp", "sup", "bb", "e", "rm", "zip", "current", "nb", "db", "folder", "mo", "py", "fb", "flat", "temp", "meta", "mb", "obj", "tab", "upload", "files", "np", "storage", "t", "dat", "ppa", "buf", "dest", "handler", "slice", "list", "diff", "mm", "apps", "array", "media", "api", "p", "rb", "page", "data", "pty", "dir", "vm", "pos", "pp", "area", "split", "sp", "part", "txt", "mp", "cmp", "po"], "f": ["uf", "fp", "v", "cf", "xf", "e", "io", "x", "df", "tf", "rf", "fb", "fl", "u", "c", "this", "fe", "fa", "m", "t", "j", "fx", "info", "r", "g", "b", "o", "F", "ff", "handler", "fc", "fr", "fs", "inf", "p", "fo", "fi", "fd", "af", "lf", "l", "fn", "file", "d", "bf", "full", "conf"], "i": ["qi", "v", "lc", "ip", "ai", "ti", "vi", "I", "e", "id", "io", "iu", "xi", "x", "index", "start", "name", "li", "u", "s", "ui", "hi", "multi", "ci", "c", "si", "ij", "ii", "m", "y", "j", "ie", "info", "b", "n", "o", "bi", "ri", "uri", "p", "gi", "key", "h", "fi", "ix", "in", "oi", "di", "l", "d", "ji", "pi"], "source": ["ource", "slave", "result", "base", "client", "reader", "cache", "grade", "scope", "view", "site", "e", "use", "force", "current", "proxy", "io", "id", "sl", "input", "target", "ge", "start", "core", "secure", "stream", "Source", "this", "si", "storage", "component", "ie", "connection", "null", "parent", "back", "slice", "diff", "uri", "service", "resource", "wrapper", "get", "from", "server", "src", "ce", "SOURCE"], "destination": ["generination", "destinator", "Destinated", "estinate", "destinating", "estinator", "combinating", "combinated", "Destination", "partinator", "combination", "partination", " destinator", "partation", "combinate", "destation", "Destation", "destinate", " destinated", " destation", "generinate", "destinated", "estinating", "estination", "Destinate", "generinator", "partinated", "combinator", "generinated", "Destinating", "Destinator"]}}
{"id1": "20886320", "id2": "8754809", "code1": "    @Override\n    public List<SearchResult> search(String query, SortOrder order, int maxResults) throws Exception {\n        if (query == null) {\n            return null;\n        }\n        String encodedQuery = \"\";\n        try {\n            encodedQuery = URLEncoder.encode(query, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw e;\n        }\n        final int startAt = 0;\n        final int pageNr = (startAt - 1) / 30;\n        final String url = String.format(QUERYURL, encodedQuery, String.valueOf(pageNr), (order == SortOrder.BySeeders ? SORT_SEEDS : SORT_COMPOSITE));\n        HttpParams httpparams = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(httpparams, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(httpparams, CONNECTION_TIMEOUT);\n        DefaultHttpClient httpclient = new DefaultHttpClient(httpparams);\n        httpclient.getParams().setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.2.2) Gecko/20100316 Firefox/3.6.2\");\n        HttpGet httpget = new HttpGet(url);\n        HttpResponse response = httpclient.execute(httpget);\n        InputStream instream = response.getEntity().getContent();\n        String html = HttpHelper.ConvertStreamToString(instream);\n        instream.close();\n        return parseHtml(html);\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 0, "substitutes": {"search": ["get", "scan", "create", "filter", "results", "send", "find", "sort", "all", "show", "list", "Search", "run", "select", "parse", "build", "submit", "request", "form", "index", "suggest", "result", "replace", "report", "start"], "query": ["feature", "answer", "data", "name", "question", "depth", "q", "error", "database", "command", "range", "filter", "results", "clean", "timeout", "str", "xml", "sort", "expression", "qu", "words", "cache", "text", "description", "term", "password", "quer", "comment", "source", "image", "value", "qs", "request", "general", "view", "uri", "params", "series", "queue", "result", "resource", "sql", "json", "string", "media", "Query"], "order": ["ORD", "er", "name", "effect", "type", "method", "state", "ard", "sort", "direction", "ordering", "rule", "position", "class", "page", "part", "user", "by", "r", "e", "err", "random", "orter", "address", "key", "orders", "row", "hop", "ort", "Order", "request", "asc", "der", "group", "server", "result", "record", "dir", "ordered", "string", "desc", "editor"], "maxResults": ["MaxPages", "minResult", "maxPages", "minResults", "MaxResult", "minresults", "Maxresults", "maxResult", "MaxResults", " maxResult", " maxPages", "maxresults", "minPages", " maxresults"], "encodedQuery": ["encodedUrl", "encachedUrl", "encapedquery", "encoredRequest", "EncryptedQ", "deccodedBody", "enccodedQuery", "encachedquery", "encryptedRequest", "encapedPage", "deccodedRequest", "encryptedquery", "encodedquery", "EncodedQuery", "incodedRequest", "encodedExp", "incoredUrl", "encryptedBody", "encodedQ", "enccodedBody", "incodedQuery", "incodedUrl", "encodingRequest", "EncodedQ", "enccodedQ", "Encryptedquery", "decodedRequest", "encryptedQ", "encodingBody", "enccodedRequest", "encodingQuery", "encachedQuery", "incoredExp", "enccodedExp", "enccodedUrl", "encachedPage", "encachedQ", "deccodedQuery", "decodedQuery", "incoredRequest", "encoredQuery", "decodedQ", "encodedPage", "encodedBody", "encachedRequest", "encapedQ", "encachedExp", "encoredExp", "decodedBody", "EncodedPage", "Encodedquery", "EncryptedPage", "encodedRequest", "EncryptedQuery", "encodingQ", "encryptedPage", "encryptedQuery", "incoredQuery", "encapedQuery", "encoredUrl", "incodedExp", "deccodedQ"], "startAt": ["StartAt", "endat", "StartFrom", "endAt", "endOr", " startNum", " startAfter", "startFrom", "endFrom", "Startat", "startat", "stopat", "StartNum", "endAfter", "startOr", "endNum", "stopFrom", "StartAfter", "StartOr", "startAfter", "stopOr", "startNum", "stopAt", " startFrom"], "pageNr": ["pageLenn", "pageSrc", " pageNrs", "pageLenrc", "pageSrs", "pageSn", "pageNumrs", "pageLenrs", "pageNrc", "pageNumn", "pageSr", " pageNnr", " pageNn", " pageNrc", "pageNumr", "pageNnr", "pageNn", "pageLenr", "pageNumnr", "pageNrs"], "url": ["connection", "sl", "data", "name", "version", "channel", "q", "string", "download", "str", "xml", "base", "ssl", "format", "page", "output", "href", "r", "address", "Url", "URL", "entry", "source", "image", "feed", "request", "path", "uri", "server", "route", "http", "id", "resource", "www", "host", "link", "location", " URL", "json"], "httpparams": ["httppARams", "httupparatums", "httPParAMS", "httPParas", "httpparsam", "httupparums", "httPParams", "httppparams", "httppareums", "httupparays", "httpparamAMS", "httPPARams", "httppParases", "httppARms", "httupparatays", "httpparatums", "httppparays", "httPPARas", "httppareas", "httpsarams", "httmpareams", "httmpareums", "httpsarases", "httmparams", "httpsaram", "httpsarsases", "httpparays", "httpparamam", "httpparamas", "httppARays", "httPPARms", "httPParms", "httpparatAMS", "httppParams", "httupparatams", "httppARums", "httpparsases", "httpparatams", "httmpareases", "httpparamams", "httmparas", "httmpareas", "httpparamparams", "httupparams", "httppparums", "httupparatAMS", "httpparAMS", "httppareams", "httmparums", "httppParparams", "httPPARAMS", "httpparatays", "httpparparams", "httpparaases", "httpparsparams", "httpparaums", "httpparamms", "httpparsas", "httppARAMS", "httpsarsams", "httupparAMS", "httpsarparams", "httpparamases", "httppParam", "httpsarsam", "httpsarsparams", "httpparms", "httppARas", "httpparsums", "httppareases", "httpparases", "httpparaas", "httpparas", "httpparums", "httmparases", "httpparsms", "httpparaams", "httpparsams", "httpparam", "httppparAMS", "httpparsAMS"], "httpclient": ["webconn", " httpmethod", "httpmethod", "httprequest", "htmlserver", " httpClient", "httpserver", " httpconnection", "httpsrequest", "phpconnection", "htmlconn", "phprequest", "httpsserver", "phpClient", "httpcall", "phpcall", "htmlClient", "phpserver", "httpClient", " httpserver", "httpconnection", "phpmethod", "webmethod", "httpconn", " httpcall", "htmlclient", "httpsclient", "webClient", "webclient", "httpscall", "webserver", "phpclient", "httpsconn", " httprequest", "webconnection", "httpsClient"], "httpget": ["phppost", "httpsput", "phpget", " httpsend", "httpsend", " httppost", "httppost", "perget", "Httpget", "persend", "perset", "Httpsend", "phpGet", "httpspost", " httpput", "httpsGet", " httpset", "Httpset", "httpGet", "httpput", "phpput", " httpGet", "httpsget", "httpset"], "response": ["full", "connection", "data", "get", "version", "session", "respond", "method", "stream", "body", "application", "received", "Response", "status", "page", "user", "successful", "output", "success", "collection", "client", "reply", "entry", "feed", "api", "request", "object", "seeking", "document", "server", "http", "message", "result", "res", "resource", "onse", "json", "resp"], "instream": ["inputform", " inchannel", "inview", "outstream", "inversion", "infile", "rinview", "inresource", "outStream", "inputview", "innerstream", "outresource", "intchannel", "inchannel", "innerversion", "rinStream", "rinstream", " inversion", "inform", " inresource", "outchannel", "intversion", " inStream", " infile", " inform", "inputresource", "outform", "intfile", "inputStream", "innerchannel", "outview", "inputchannel", "inStream", "innerfile", "inputstream", "intstream", "rinchannel"], "html": ["data", "doc", "version", "body", "string", "tml", "info", "web", "str", "xml", "plain", "base", "format", "page", "HTML", "text", "output", "css", "content", "article", "img", "source", "live", "template", "db", "js", "h", "object", "hash", "view", "raw", "ml", "browser", "http", "title", "message", "result", "header", "hot", "json"]}}
{"id1": "5399593", "id2": "13783898", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"encrypt": [" encipher", "escipher", " encress", "decrypt", "escress", "encipher", "encryption", "escryption", "encress", "decress", "decryption", "decipher", " encryption", "escrypt"], "plaintext": [" plaincontent", "foreTEXT", " plainform", "ainText", "plainTEXT", "raincontent", "rainTEXT", "singleText", "plaincontent", "plainform", "singleform", " plainTEXT", "foreText", "foretext", "ainTEXT", " plainText", "aintext", "plainText", "rainText", "forecontent", "ainform", "singleTEXT", "raintext", "singletext"], "UnsupportedEncodingException": ["UnsupportedCodedEx", "UnsupportedEncryptionEx", "UnsupportedEncodedEx", "UnsupportedEncodingError", "UnsupportedCodedError", "UnsupportedEncgorithmError", "UnsupportedEncodedException", "UnsupportedCodingException", "UnsupportedEncodingEx", "UnsupportedCodedException", "UnsupportedCodingError", "UnsupportedEncgorithmException", "UnsupportedEncodedError", "UnsupportedEncryptionError", "UnsupportedEncryptionException", "UnsupportedCodingEx", "UnsupportedEncgorithmEx"], "md": ["meta", "bd", "mag", "mg", "hed", "cd", "rm", "wd", "mad", "dd", "m", "ma", " MD", "mt", "mage", "me", "dig", "mb", "am", "mac", "hm", "cmd", "dm", "mn", "material", "dc", "d", "MD", "map", "db", "mo", "mod", "amd", "sum", "mp", "code", "metadata", "mm", "pm", "mu", "message", "sha", "po", "bf", "mem", "mc", "ms", "od", "mand", "hd", "nm", "Cmd"], "raw": ["full", "missing", "blocks", "ack", "array", "dec", "clean", "RAW", "enc", "load", "shared", "hex", "ghost", "wrap", "Raw", "instance", "rew", "row", "buffer", "block", "serial", "sign", "empty", "null", "ng", "original", "unsigned", "message", "flash", "sha", "input", "initial", "aws", "unknown", "alpha", "micro", "buf"], "hash": ["rh", "data", "ha", "hed", "version", "array", "shared", "hex", "base", "log", "html", "cache", "text", "math", "mac", "kh", "ruby", "key", "password", "secret", "abi", "block", "image", "build", "h", "url", "sum", "code", "ashes", "id", "message", "flash", "sha", "header", "ash", "hh", "auth", "Hash", "alpha", "string", "sh"]}}
{"id1": "22431487", "id2": "4830847", "code1": "    public static String doPost(String URL, List<NameValuePair> params) {\n        try {\n            OauthUtil util = new OauthUtil();\n            URI uri = new URI(URL);\n            HttpClient httpclient = util.getNewHttpClient();\n            HttpPost postMethod = new HttpPost(uri);\n            StringBuffer paramString = new StringBuffer();\n            paramString.append(\"OAuth\");\n            for (int i = 0; i < params.size(); i++) {\n                paramString.append(\" \" + params.get(i).getName());\n                paramString.append(\"=\\\"\" + encodeUrl(params.get(i).getValue()) + \"\\\",\");\n            }\n            String xx = paramString.substring(0, paramString.length() - 1);\n            postMethod.addHeader(\"Authorization\", xx);\n            HttpResponse httpResponse = httpclient.execute(postMethod);\n            if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                String strResult = EntityUtils.toString(httpResponse.getEntity());\n                Log.i(\"DEBUG\", \"result: \" + strResult);\n                return strResult;\n            }\n        } catch (Exception e) {\n            Log.i(\"DEBUG\", e.toString());\n        }\n        return null;\n    }\n", "code2": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "label": 0, "substitutes": {"doPost": [" doLoop", "doPosts", "doRequest", "formRequest", "apiPosts", "apiPost", "formPosts", " doPosts", "formPost", "apiRequest", "formLoop", "doLoop", "apiLoop", " doRequest"], "URL": ["URI", "File", "IO", "PORT", "R", "METHOD", "IP", "API", "WS", "HTML", "Address", "Url", "SSL", "url", "Name", "Page", "HTTP", "IR", "ID", "http", "CL", "PATH", "Base", "Location", "DIR", "UR", "Path", "resource", "JSON", "FILE", "DB", "GI", "string", "NAME", "SR"], "params": ["values", "data", "name", "s", "options", "services", "array", "results", "p", "settings", "ams", "pi", "par", "param", "relations", "arms", "is", "ls", "words", "parts", "members", "features", "Parameters", "apps", "rs", "Param", "strings", "ras", "list", "pins", "parse", "api", "request", "url", "vs", "names", "afi", "server", "ps", "http", "details", "terms", "photos", "pos", "changes", "users", "es", "properties", "types", "resources", "json", "Par", "ip"], "util": ["su", " url", "manager", "install", "auto", "ut", "universal", "utils", " utility", "mut", "u", "U", "internet", " u", "kit", "client", "lu", "utt", "anti", "cli", "lib", "init", "gui", "Ut", "api", "spec", "url", "ui", "general", "unit", "io", "http", "global", "impl", "iu", "mu", "valid", "string", "il"], "uri": ["connection", "URI", "absolute", "ri", "iri", "database", "handler", "pi", "base", "plugin", "API", "U", "Manager", "PI", "client", "address", "Url", "cli", "service", "api", "request", "path", "response", "url", "ui", "config", "server", "route", "io", "http", "id", "resource", "uni", " URI"], "httpclient": ["Httpapi", " httpmethod", "httpapi", " httpClient", "httpmethod", "htmlserver", "httpsapi", " httpconnection", " httpapi", "httpserver", "htmlmethod", "httpsconfig", "Httpserver", "htmlClient", "Httpmethod", " httpconfig", "HttpClient", "Httpconnection", "httpClient", "httpconnection", " httpserver", "Httpclient", "Httpconfig", "httpsclient", "htmlclient", "httpconfig", "httpsconnection"], "postMethod": ["POSTFunction", " postPath", " postmethod", " postRequest", " postFunction", "PostFunction", "postMessage", "POSTmethod", "PostMethod", "postFunction", "POSTMethod", "patchMethod", "Postmethod", "patchFunction", "POSTRequest", "PostMessage", "PostRequest", " postMessage", "typeFunction", "patchPath", "typeMethod", "typemethod", "PostPath", "typeRequest", "patchMessage", "postRequest", "postPath", "postmethod"], "paramString": ["paramStr", " paramArray", "paramstring", "memberFile", "priArray", "paramsStr", "paramFile", "ParamStream", "paramsArray", "cmService", "cmArray", "Paramstring", "parString", "ParamArray", " paramstring", "errorArray", "priStr", "ParamFile", "parFile", "paramStream", "parStream", " paramStr", "ParamString", " paramFile", "memberArray", "ParamBuffer", "paramBuffer", "ParamList", "parArray", "errorString", "paramList", "memberstring", " paramBuffer", "cmString", "errorBuffer", "errorFile", "ParamService", "paramArray", "paramsList", "cmstring", "memberString", "priString", "priBuffer", " paramService", " paramStream", "ParamStr", "paramsString", "paramService", " paramList"], "i": ["x", "ji", "f", "data", "y", "si", "name", "it", "ti", "ri", "q", "s", "slice", "iv", "g", "m", "p", "j", "info", "pi", "k", "ori", "ie", "ix", "is", "hi", "ei", "I", "di", "u", "b", "part", "multi", "bi", "qi", "l", "e", "o", "key", "ini", "d", "count", "ci", "cli", "z", "t", "xi", "oi", "v", "ui", "li", "n", "ii", "io", "c", "in", "id", "index", "iu", "ic", "eni", "ai", "gi", "length", "ip"], "xx": ["x", "XXX", "Code", "cn", "ux", "ant", "ww", "ck", "enc", "zz", "vv", "yy", "xy", "X", "ax", "key", " XX", "pp", "xxx", "xxxx", "XX", "cc", "response", "xi", "xa", "XXXX", "code", "pass", "xxxxxxxx", "foo", "prefix", "header", "ss", "uid", "host", "json", "act"], "httpResponse": ["phpResponse", "Httpresponse", "HttpRequest", " httpClient", "postResp", "phpResp", "HttpReply", "phpClient", "httpReply", " httpReply", "hrresponse", "httpRequest", "httpresponse", "HttpConnection", " httpRequest", "HttpClient", "httpResp", "phpresponse", " httpresponse", "httpClient", " httpConnection", "HttpResp", "HttpResponse", " httpResp", "hrReply", "postConnection", "hrResp", "hrResponse", "postRequest", "postResponse", "httpConnection"], "strResult": ["StrRes", "objReturn", "drResponse", "objResponse", " strReturn", " strRes", " strStatus", " strResponse", "strStatus", "strResponse", "stringRes", "StrResult", "stringReturn", "Strresult", "strRes", "stringResult", "strresult", "drStatus", " strresult", "drresult", "drResult", "StrResponse", "objResult", "objresult", "stringResponse", "StrStatus", "strReturn", "StrReturn"]}}
{"id1": "11484416", "id2": "5759961", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"moveFile": ["moveDirectory", "movePath", " movedPath", " moveFiles", " movedFiles", " movedFile", "MoveDirectory", "MoveFile", " movePath", "moveFiles", "MovePath", " movedDirectory", " moveDirectory", "MoveFiles"], "orig": ["origin", "folder", "image", "base", "coord", "temp", "impl", "coll", "transform", "src", "bas", "remote", "bin", "info", "ctr", "raf", "comb", "home", "buf", "array", "original", "org", "real", "build", "frame", "dest", "img", "prev", "raid", "tmp", "init", "internal", "imag", "ext", "proxy", "ori", "exe", "archive", "id", "file", "old", "rb", "iter", "loc", "source", "f", "obj", "Orig", "copy"], "target": ["origin", "force", "base", "resource", "temp", "nt", "this", "current", "to", "format", "eth", "Target", "match", "master", "platform", "remote", "replace", "prot", "object", "auto", "external", "t", "next", "path", "join", "original", "result", "ret", "it", "build", "dest", "manager", " Target", "tmp", "archive", "reference", "parent", "compatible", "arget", "template", "source", "project", "f", "copy"], "buffer": ["repeat", "base", "resource", "feed", "wave", "raw", "sequence", "content", "input", "write", "message", "cache", "slice", "queue", "stack", "b", "bin", "bytes", "bb", "read", "null", "buf", "code", "position", "buff", "padding", "uffer", "result", "frame", "layer", "block", "length", "request", "data", "file", "reference", "binary", "transfer", "header", "iter", "batch", "source", "Buffer", "url", "copy", "address"], "bread": ["fee", "die", "num", "raft", "feed", "circ", "eb", "buck", "cake", "inn", "fen", "beat", "fred", "fe", "fle", "fif", "zip", "grain", "meal", "key", "rub", "bb", "brew", "fall", "broken", "wake", "wen", "rows", "abi", "good", "hello", "fine", "ffe", "cook", "div", "sleep", "width", "four", "choice", "loop", "piece", "design", "length", "food", "knife", "bn", "bare", "ble", "bee", "robe", "rib", "fed", "str", "zero", "bc", "batch", "web", "bat"], "fis": ["lfiss", "ufiss", "ufis", " fIs", "afiss", "afis", "lfIs", "fxIs", "afos", "fils", "ufos", "qos", "lfis", "ufils", "hos", "qils", "hisa", "fIs", "qis", " fils", "his", " fiss", "fisa", "fxis", "fxisa", "fiss", "fxos", "qiss", "hIs", "afIs", "lfos", " fisa"], "fos": ["goss", "foses", " fens", "fens", " foss", "flens", "Fens", " fose", "infaos", "fors", "infors", "flois", "infos", "Fros", " fros", "Foses", "fose", "flos", "flose", "Fose", "faos", "fois", " foses", "floses", "Fos", "infois", "Fis", "flors", "gos", "Foss", "Fois", "Faos", "Fors", "gros", "flaos", "fros", "foss", "gis"]}}
{"id1": "22441244", "id2": "18544890", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public static GameRecord[] get(String url, float lat, float lon, int count) {\n        try {\n            HttpURLConnection req = (HttpURLConnection) new URL(url).openConnection();\n            req.setRequestMethod(\"GET\");\n            req.setRequestProperty(GameRecord.GAME_LATITUDE_HEADER, df.format(lat));\n            req.setRequestProperty(GameRecord.GAME_LONGITUDE_HEADER, df.format(lon));\n            req.setRequestProperty(\"X-GameQueryCount\", String.valueOf(count));\n            req.connect();\n            if (req.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                List<GameRecord> gl = new ArrayList<GameRecord>();\n                BufferedReader br = new BufferedReader(new InputStreamReader(req.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) {\n                    if (!line.startsWith(\"#\")) {\n                        gl.add(GameRecord.decode(line));\n                    }\n                }\n                return gl.toArray(new GameRecord[gl.size()]);\n            } else {\n                System.out.println(req.getResponseMessage());\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"send": ["open", "get", "create", "from", "set", "add", "text", "mail", "export", "address", "Send", "reply", "parse", "build", "submit", "exec", "delete", "transfer", "post", "message", "sent", "append", "execute", "write", "start", "end"], "hsession": ["HSessions", "openssession", "hsess", "opensessions", "hsSession", "hmession", "hhsession", "hhessions", "hession", "hsort", "hessions", "HSsession", "hmsession", "HSSession", "hsessions", "hhSession", "hessession", "hSession", "opensort", "hmSession", "hhess", "opensession", "hhort", "HSession", "opensSession", "hhession", "hssession", "hesort", "opensess", "hesession", "hmessions", "hesess"], "session": ["connection", "sl", "manager", "application", "state", "event", "class", "Session", "cache", "mail", "essions", "client", "proxy", "port", "project", "response", "parent", "context", "document", "server", "ession", "message", "chat", "resource", "host", "security", "site"], "repositoryName": ["repoositoryAddress", "repositoryFamily", "reposicleFamily", "repoositoryNAME", "repoitoryPath", "repositoryPath", "reposicleName", "repoitoryAddress", "reposessionNAME", "reposositoryNAME", "reposositoryPath", "reposicleAddress", "reposositoryName", "repoitoryEmail", "reposositoryFamily", "reposicationFamily", "reposicationName", "repoositoryName", "reposicationAddress", "reposositoryEmail", "repoitoryName", "repositoryAddress", "repoitoryFamily", "reposicleEmail", "reposessionName", "reposessionPath", "repositiveEmail", "repositoryNAME", "repositoryEmail", "repoositoryPath", "repositiveNAME", "reposositoryAddress", "reposicationEmail", "repoositoryFamily", "repositiveName", "reposessionEmail", "repoositoryEmail", "repoitoryNAME", "repositivePath"], "ideIdint": ["ideAuthints", "ideIdInt", "ideNameint", "ideidints", "IDEIdints", "ideIdints", "ideTimeInt", "ideAuthn", "ideidInt", "ideInn", "ideInint", "IDEidInt", "IDENameout", "IDEidint", "ideTimeout", "IDEIdInt", "ideIdout", "ideNameInt", "ideidn", "IDEIdout", "IDEidints", "IDENamenumber", "ideidint", "ideInfoout", "ideIdnumber", "IDENameint", "ideTimeint", "IDEIdn", "ideInfoint", "IDENameInt", "IDEIdnumber", "ideAuthint", "ideNameout", "ideInInt", "IDEIdint", "ideNamenumber", "ideAuthInt", "ideInints", "IDEidn", "ideInfonumber", "ideIdn", "ideTimenumber", "ideInfoInt"], "to": ["office", "name", "phone", "TO", "options", "from", "settings", "To", "top", "summary", "with", "mail", "by", "account", "client", "address", "reply", "sub", "source", "template", "mobile", "response", "tel", "uri", "title", "prefix", "message", "po", "token", "target", "about", "contact", "location", "company", "site"], "cc": ["cb", "cn", "phone", "nc", "card", "sc", "cca", "ca", "from", "ct", "ck", "ec", "rc", "cs", "lc", "cr", "account", "password", "client", "address", "dc", "comment", "ci", "uc", "cf", "CC", "cl", "code", "c", "ce", "tc", "contact", "company", "ac", "cus"], "bcc": ["abc", "pck", " bc", " brc", "fck", "bbrc", "pc", " bce", "bce", " bck", "pcc", "brc", "fcc", "bbck", "abcc", "bbc", "pce", "frc", "abce", "abck", "bck", "fc", "bc", "bbcc"], "subject": ["phone", "reason", "head", "method", "state", "format", "description", "mail", "content", "reply", "comment", "sub", "Subject", "template", "ject", "request", "response", "object", "filename", "uri", "author", "title", "prefix", "message", "header", "host", "username"], "body": ["connection", "lock", "data", "tree", "name", "reason", "how", "string", "plain", "base", "summary", "description", "part", "text", "inner", "wrapper", "content", "zip", "left", "line", "shell", "password", "normal", "secret", "comment", "style", "source", "template", "money", "response", "bound", "object", "foot", "url", "code", "view", "empty", "pass", "Body", "function", "message", "header", "resource", "length", "html", "media", "pod"], "attachments": ["embedings", "attachents", "messents", "embedment", "attachings", "Attachings", "embedments", "Attachents", "Attachments", "messment", "embedents", "Attachment", "messings", "messments"], "isHtml": ["isPhttp", "isChtml", "isPhhtml", " isChhtml", "isCtml", "isHive", " isHttp", " isWhail", "isWhtml", " isWhive", "isWhail", "isChhtml", " isWhhtml", "isCive", " isHail", "isCail", "isHhtml", "isChive", "isPhtml", " isWhtml", " isChail", "isHaail", "isWhive", "isChail", "isHattp", " isChtml", " isHhtml", "isHatml", "isHahtml", "isChttp", "isHail", "isWhhtml", " isHive", " isChttp", "isPhail", "isHttp"], "charset": ["charsET", "chaseset", "chasET", "chanset", "chaseting", "CharsET", "chasets", "chanspace", "chARSetting", "chearsete", "chansetter", "chearspace", "cheanset", "chansete", "chearsetter", "chARSET", "chARSeting", "Charseting", "charsetting", "chashesetter", "chARSets", "cheansET", "chackset", "charsetter", "chansetting", "chasheset", "chacksET", "chasetter", "Charsetting", "chaset", "cheansete", "chasetting", "cheansetter", "Charsets", "chacksetting", "chaseseting", "chaspace", "cheanspace", "chARSete", "Charset", "chearset", "charsets", "chearsET", "chashesET", "chansET", "cheansetting", "charsete", "charseting", "chARSet", "charspace", "chashespace", "chacksete", "chasesetting", "chearsetting", "chasesET"], "headers": ["mails", "options", "groups", "settings", " cookies", "status", "files", "content", "authors", "lines", "writers", " messages", "strings", " emails", " recipients", "classes", "comments", "names", "errors", "metadata", "params", "users", "header", "properties", "types", "ers"], "priority": ["phone", "reason", "language", "theme", "state", "mode", "status", "class", " title", "lang", "reply", "secret", "comment", "template", " severity", " recipients", "quote", "comments", "level", "code", "date", "author", "title", "prefix", "queue", "security", "length"], "email": ["office", "gmail", "ext", "data", "name", "oe", "ilo", "note", "create", "el", "auto", "em", "info", "install", "event", "en", "xml", "Email", "letter", "base", "ssl", "model", "text", "mail", "output", "online", "article", "entity", "zip", "line", "engine", "export", "account", "password", "e", "address", "external", "service", "fax", "test", "lex", "business", "template", "generic", "example", "response", "object", "url", "update", "enter", "document", "view", "server", "default", "core", "pm", "message", "contact", "result", "international", "print", "html", "liner", "element", "username"], "user": ["connection", "er", "profile", "data", "name", "type", "creator", "info", "ip", "me", "plugin", "model", "people", "account", "e", "member", "client", "User", "mobile", "object", "role", "character", "friend", "USER", "consumer", "author", "person", "id", "users", "uid", "resource", "token", "unknown", "string", "use", "username"], "identity": ["ethnicifier", "identication", "authorentity", "authority", "idITY", "ethnicity", "electricITY", "authoronymous", "authentonymous", "idifier", "authorities", "entityity", "IDENTity", "personITY", "idity", "personentity", "IdentITY", "authorication", "ethniciciary", "identiciary", "electriconymous", "ethnicITY", "installITY", "Identity", "IDENTities", "IDENTITY", "personity", "entityifier", "installonymous", "electricity", "authentITY", "publicity", "authentization", "authoriciary", "idization", "ethnicentity", "electricentity", "identonymous", "installentity", "authentication", "authentity", "idication", "publicITY", "entityonymous", "publicentity", "identization", "Identities", "Idententity", "IDENTentity", "entityization", "ethnicication", "identITY", "publiciciary", "authorifier", "idonymous", "authentifier", "idententity", "authorITY", "identifier", "identities", "installity", "personifier"], "_returnPath": ["_correctId", "_returnMid", "_resultPath", "_responseType", " _returnTo", " _backHalf", "_resultTo", "_returnHalf", " _returnUrl", "_resultHalf", "_displayPath", "_displayPart", "_backHalf", "_responsepath", "_backpath", "_displayUrl", "_inputMid", "_returnNode", "_returnPart", "_backName", "_returnText", "_inputPath", "_backType", "_returnDirectory", "_displayNode", "_successText", " _backTo", "_addType", "_backPath", "_backPart", " _backUrl", "_relationPath", "_backUrl", "_successId", "_resultName", "_returnTo", "_addPath", "_correctText", "_successPath", "_replyUrl", " _backPath", "_relationId", " _backPart", "_returnType", " _backName", "_replyMid", "_returnId", "_replyNode", "_correctPath", "_returnUrl", "_inputUrl", "_backTo", "_returnpath", "_relationDirectory", "_successDirectory", "_replyPart", "_addpath", "_correctDirectory", " _returnHalf", "_replyPath", "_displayMid", "_relationText", " _returnName", "_responsePath", "_returnName", "_inputNode", " _returnPart"], "_from": ["_for", "placeowner", "workwho", "worksource", "blockFrom", "_From", "_with", "blockerror", " _error", " _source", "workfrom", "blockto", " _owner", "existingto", "_source", "_who", "existingfrom", "_error", "blockfrom", "_owner", " _for", " _with", "existingowner", "placefrom", "workto", " _who", "placefor", " _From", "placeto", "existingfor"], "_replyTo": ["_replyFrom", "_returnUrl", "_respondTo", "_returnTo", "_respondTO", "_returnOf", " _returnTo", "_addFrom", "_reasonUrl", " _replyTO", "_closeTO", "_replyUrl", " _returnTO", "_reasonTo", "_replyTO", "_addAddress", "_commentOf", " _replyFrom", "_reasonTO", "_respondAddress", "_commentFrom", "_respondFrom", "_commentTO", "_replyAddress", "_commentTo", "_respondPoint", " _returnFrom", "_replyPoint", "_replyOf", " _replyUrl", "_returnAddress", " _returnUrl", "_returnPoint", "_addTo", "_respondUrl", "_returnFrom", "_addPoint", "_returnTO", "_closeTo", "_reasonFrom", "_closeOf", "_closeFrom"], "_to": [" _target", "_target", " _about", "Jfrom", "Jabout", "Jtarget", "_about", "Jto"], "_cc": [" _cd", " _ce", " _cf", "_cd", "_ce", "_cf"], "_bcc": [" _abc", " _bce", "_rbcs", " _bcs", "_abce", "_rbc", "_sbcs", "_sbc", " _bc", " _abcs", "_abcs", "_sbcc", "_abc", "_rbce", "_bce", "_bcs", "_rbcc", " _abce", "_sbce", "_bc", "_abcc", " _abcc"]}}
{"id1": "22503685", "id2": "350482", "code1": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"readGeoParserResult": ["readGeoWalkerResult", "readGeoparserReport", "readGeoReaderResult", "readGeoReaderReport", "readGeoParserOutput", "readGeOReaderReport", "readGeoWalkerReport", "readGeOParserReport", "readGeoReaderOutput", "readGeOParserOutput", "readGeoparserResult", "readGeoparserResults", "readGeoWalkerOutput", "readGeoReaderResults", "readGeOReaderResults", "readGeoWalkerResults", "readGeoParserReport", "readGeOReaderResult", "readGeOReaderOutput", "readGeoparserOutput", "readGeoParserResults", "readGeOParserResults", "readGeOParserResult"], "recordContent": ["resourceContents", " recordText", "recordText", "reportContent", "recordMessage", "RecordText", "resourceContent", "resourceText", "reportText", "recordBody", "RecordContent", "RecordMessage", "reportMessage", "RecordFile", "resourceFile", " recordBody", " recordMessage", "RecordBody", " recordFile", "recordFile", "reportBody", " recordContents", "recordContents", "RecordContents"], "getGazeteerIds": ["getGazeteerHostes", "getGazeteersIdes", "getGazeteerConfigxs", "getGazeteerNeedes", "getGazeteerNeeders", "getGazeteerLogls", "getGazeteersLogings", "getGazeteersIds", "getGazeteerHostings", "getGazeteersLogxs", "getGazeteerLogs", "getGazeteerIders", "getGazeteerTextings", "getGazeteerConfigings", "getGazeteerIdings", "getGazeteersLogls", "getGazeteersLogers", "getGazeteerNeeds", "getGazeteerHosts", "getGazeteerLogxs", "getGazeteersIdls", "getGazeteerHosters", "getGazeteerIdes", "getGazeteersIders", "getGazeteerTextls", "getGazeteerIdxs", "getGazeteerConfigs", "getGazeteersIdxs", "getGazeteerIdls", "getGazeteersLogs", "getGazeteerLogings", "getGazeteerNeedings", "getGazeteerLogers", "getGazeteerTextxs", "getGazeteersLoges", "getGazeteerConfigls", "getGazeteerTexts", "getGazeteerLoges", "getGazeteersIdings"], "ret": ["gt", "info", "fun", "Ret", "att", "bf", "replace", "mem", "sys", "results", "res", "ref", "vet", "result", "rg", "match", "arg", "rt", "feat", "ft", "usr", "iter", "arr", "part", "nt", "resp", "Return", "len", "str", "alt", "ut", "group", "default", "rets", "data", "out", "g", "r", "get", "ll", "reply", "hash", "dict", "t", "status", "array", "opt", "ext", "obj", "reg", "det", "Result", "RET", "repl", "f", "re", "list"], "retries": ["Retries", "altrys", "altrying", "RETrying", " retrying", "altries", "retry", "RETried", "RETries", "retrys", "altried", " retrys", "trys", "tried", "RETrys", "Retrys", "retrying", " retry", "Retry", "trying", "tries", "Retrying", "retried"], "reqPre": ["reqpre", "resppre", "refPost", "reqPost", "respPre", "refPlan", " requestPref", " reqPref", "requestPre", " reqPost", "respPost", " requestPost", "requestPost", "requestPref", " requestpre", "requestpre", "refpre", "reqPlan", " requestPre", "reqPref", "respPlan", " reqpre", "requestPlan", "refPre"], "outputFormat": ["OutputVersion", "OutputType", "outputType", "outputVersion", "inputSettings", "reportVersion", "reportFormat", "inputVersion", "reportType", "reportSettings", "inputType", "OutputSettings", "inputFormat", "OutputFormat", "outputSettings"], "doc": ["event", "info", "resource", "response", "Doc", "df", "http", "docs", "document", "DOC", "project", "result", "html", "record", "dr", "dc", "part", "git", "up", "date", "str", "feature", "md", "data", "file", "text", "body", "div", "page", "h", "style", "msg", "desc", "coll", "m", "e", "po", "home", "pos", "db", "di", "mc", "bc", "bug", "parse", "b", "xml", "f", "Document", "tx", "api"], "url": ["string", "path", "base", "info", "address", "buffer", "ssl", "server", "uri", "resource", "response", "id", "entry", "http", "document", "ref", "result", "html", "l", "location", "URL", "orb", "source", "connection", "browser", "str", "r", "data", "file", "channel", "page", "request", "web", "name", "e", "sl", "Url", "b", "f", "element", "org", "api"], "reader": ["info", "handler", "buffer", "input", "uri", "resource", "feed", "rc", "http", " parser", "instance", "read", "tx", "iter", "er", "oder", " readers", "r", "parser", "data", "file", "rr", "or", "writer", "io", "stream", "Reader"]}}
{"id1": "19912848", "id2": "6558022", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static String CheckUrl(String urlvalue) {\n        String inputLine = \"\";\n        try {\n            URL url = new URL(urlvalue);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            inputLine = in.readLine().toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return inputLine;\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileFromString", "decodeFile2Stream", "decodeFileToString", "decodeStringToStream", "decodeStringToFiles", "decodeFileAsStream", "decodeFile2String", "decodeFile2File", "decodeFileFromStream", "decodeFileAsFile", "decodeStringToFile", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Files", "decodeString2String", "decodeString2Stream", "decodeStringToString", "decodeFileToFiles", "decodeString2Files", "decodeFileToStream", "decodeString2File", "decodeFileFromFile", "decodeFileAsString"], "infile": [" instream", "infp", "minstream", "infiles", "inbase", "InFile", "outfiles", "instream", " infiles", "Instream", "outfilename", " inFile", "inputfile", " infilename", "minbase", "inputfilename", "inFile", " inbase", "minFile", "inputfiles", "outfp", "inputfp", "Infile", "infilename", "minfile", "Inbase", " infp"], "outfile": ["inputpath", "outdatabase", "outputpath", "outFile", "inputdatabase", "inputFile", "outputdatabase", "outpath", " outpath", " outfilename", " outfolder", " outFile", "infolder", "outputfolder", "outfolder", "outfilename", "inputfile", "outputfile", "outputfilename", " outdatabase", "inFile", "outputFile", "infilename"], "in": ["source", "as", "init", "into", "re", "gin", "inn", "pin", "inner", "ac", "s", "pass", "i", "input", "socket", "conn", "inside", "inas", "sin", "IN", "data", "m", "ini", "win", "con", "isin", "bin", "a", "b", "is", "nin", "min", "ins", "cin", "thin", "lin", "In", "inc", "again", "rin", "r", "err", "login", "id", "reader", "din", "ic"], "out": ["work", "copy", "cache", "output", "client", "sync", "net", "session", "inner", "point", "home", "timeout", "pass", "ex", "one", "to", "socket", "OUT", "conn", "line", "image", "or", "writer", "io", "up", "job", "base", "log", "name", "ou", "outer", "exec", "post", "obj", "channel", "exit", "Out", "write", "In", "outs", "again", "inc", "off", "file", "lib", "err", "o", "parent", "bin", "error", "co", "no"], "buffer": ["source", "result", "cache", "length", "bb", "buff", "buf", "bytes", "seed", "input", "uffer", "count", "border", "padding", "data", "binary", "limit", "url", "base", "b", "null", "server", "transfer", "split", "address", "Buffer", "channel", "size", "queue", "layer", "write", "raw", "batch", "reference", "iter", "value", "wave", "feed", "slice", "reader", "type", "flush", "bin", "offset"], "read": ["ride", "x", "work", "seek", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "f", "lex", "len", "use", "pass", "i", "READ", "send", "count", "sleep", "ind", "ad", "play", "find", "ip", "io", "n", "connect", "limit", "next", " copy", "add", " write", "allow", "exec", "reads", "size", "write", "raw", "inc", "_", "wait", " Read", "iter", "r", "feed", "slice", " count", "reader", "end", " skip", "get", "start", "id", "select", "fill", "run", "tell"], "success": ["primary", "ceed", "message", "method", "better", "fast", "result", "positive", "path", "flash", "first", "continue", "successful", "model", " Success", "construct", "rolled", "pass", "successfully", " successful", "Success", "complete", "func", " succeed", "default", "data", "follow", "warning", "growth", "open", "done", "comment", "good", "valid", "danger", "null", "initial", " succ", "true", "rolling", "fail", "winner", "again", "failed", "value", "xx", "response", "results", "cess", "roll", "right", "ccess", "error", "status", "content"]}}
{"id1": "10176678", "id2": "6403868", "code1": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 0, "substitutes": {"testLoadHttpGzipped": ["testLoadHttpGgzained", "testLoadHttpGozipped", "testLoadHttpGgzips", "testLoadHttpGzipipped", "testLoadHttpGzipipping", "testLoadHttpgzipained", "testLoadHttpGozained", "testLoadHttpGozips", "testLoadHttpGzained", "testLoadHttpGzipping", "testLoadHttpgzained", "testLoadHttpGozipping", "testLoadHttpgzipipped", "testLoadHttpGzipained", "testLoadHttpGzips", "testLoadHttpgzipips", "testLoadHttpgzipped", "testLoadHttpgzips", "testLoadHttpgzipipping", "testLoadHttpGgzipped", "testLoadHttpgzipping", "testLoadHttpGgzipping", "testLoadHttpGzipips"], "url": ["ls", "page", "log", "uri", "ssl", "resource", "image", "server", "ll", "html", "connection", "loc", "info", "data", "method", "f", "zip", "route", "URL", "ref", "error", "key", "type", "xml", "class", "source", "src", "config", "filename", "l", "base", "id", "address", "string", "gl", "file", "name", "sl", "host", "pattern", "location", "Url", "path", "response", "buffer", "http"], "loadingInfo": [" loadinginfo", " loadingObj", "loadingObj", "loadingInf", "loadinginfo", "LoadingInf", "loaderinfo", " loadingManager", "LoadingConfig", "loaderConfig", "lockingManager", "loadingConfig", "LoadingManager", "lockingInfo", "LoadingObj", " loadingInf", "Loadinginfo", "LoadingInfo", "lockingInf", "loaderInfo", "loadingManager", " loadingConfig", "lockingObj", "loaderInf"], "contentInputStream": ["contentReadSteam", "contentBytestream", "contentOutputStream", "contentReadStream", "ContentOutputString", "ContentInputSteam", "ContentInputString", "contentInputSteam", "contentImportSteam", "contentByteStream", "ContentOutputObject", "contentImportObject", "contentOutputObject", "contentImportStream", "ContentOutputstream", "contentContentObject", "contentInputObject", "ContentInputstream", "contentOutputString", "contentInputString", "contentOutputSteam", "contentOutputstream", "contentReadString", "ContentInputObject", "contentContentSteam", "contentReadstream", "contentInputstream", "ContentOutputSteam", "contentImportstream", "ContentOutputStream", "contentContentstream", "ContentInputStream", "contentContentStream", "contentByteString", "contentByteSteam"], "actual": ["original", "array", "older", "affected", "acceptable", "example", "als", "length", "act", "failed", "event", "successful", "pect", "evaluate", "valid", "truth", "covered", "future", "actually", "average", " Actual", "former", "found", "wrong", "pects", "ual", "handled", "initial", "anticipated", "reported", "existing", "fake", "response", "content", "current", "events", "real", "ception", "received", "including"], "expected": ["allowed", "original", "usual", "acceptable", "length", "example", "failed", "updated", "pect", "info", "data", "required", " expecting", "error", "future", " unexpected", "driver", "size", "found", "wrong", " expect", "reported", "seen", "handled", "anticipated", "defined", "fake", "cover", "nexpected", "always", "needed", "real", "pected", "ception", "received"]}}
{"id1": "7087108", "id2": "19687456", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 1, "substitutes": {"doGet": ["processGet", "doPut", " doDownload", "processDownload", "didDownload", "doDownload", " doGET", " doPut", "processPut", "didGet", "doGET", "didPut", "didGET", "processGET"], "request": ["forward", "req", "subject", "url", "uri", "report", "resource", "server", "message", "parent", "complete", "view", "connection", "event", "method", "data", "info", "project", "child", "version", "this", "external", "application", "model", "result", "input", "route", "Request", "error", "type", "xml", "instance", "builder", "QUEST", "create", "reader", "config", "client", "web", "target", "self", "user", "object", "string", "name", "host", "context", "query", "json", "current", "buffer", "condition", "http", "use"], "response": ["wave", "resp", "page", "writer", "respond", "report", "resource", "server", "message", "example", "image", "view", "Response", "connection", "body", "remote", "method", "version", "output", "application", "document", "status", "result", "site", "model", "reply", "out", "results", "client", "object", "cache", "service", "reference", "json", "content", "collection", "http"], "path": ["filter", "text", "p", "url", "uri", "message", "image", "resource", "info", "data", "ath", "method", "output", "folder", "PATH", "route", "index", "key", "out", "dir", "config", "directory", "filename", "Path", "base", "point", "object", "id", "cache", "string", "name", "pattern", "location", "content", "value", "format", "http"], "file": ["to", "pe", "log", "url", "FILE", "resource", "uri", "image", "le", "b", "connection", "lock", "info", "data", "child", "socket", "part", "folder", "f", "it", "zip", "rule", "route", "feed", "h", "out", "class", "source", "dir", "directory", "filename", "l", "use", "work", "files", "base", "object", "local", "handler", "name", "up", "full", "File", "function", "fe", "http", "fp", "lib"], "in": ["ins", "resource", "In", "copy", "b", "ax", "thin", "init", "data", "inc", "socket", "f", "gin", "it", "input", "din", "IN", "lin", "inn", "out", "s", "cin", "i", "is", "source", "kin", "reader", "rin", "win", "nin", "stream", "login", "inner", "r", "id", "ac", "bin", "c", "con", "binary", "pin", "ini", "as", "serv", "isin"]}}
{"id1": "2521141", "id2": "335223", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copy": [" cp", "source", "create", "sync", "paste", "load", "update", "download", "config", "cat", "ame", "archive", "link", "dump", "move", "image", "open", "cop", "directory", "clone", "rm", "clip", "share", "pe", "change", "ge", "transfer", "zip", "upload", "Copy", "attach", "cp", "opy", "ize", "write", "file", "ignore", "diff", "type", "get", "delete"], "from_name": ["fromFpath", "fromMname", "from__name", "fromFmemory", "fromMfile", "from_Name", "source_path", " from_names", "to_path", "from__filename", " from_key", "fromFfilename", "from_memory", "fromMnames", "source_filename", "from_filename", "from_key", "fromFname", "from_names", " from_Name", "from__memory", "from__path", "to_filename", "source_name", "from_path", "source_memory"], "to_name": ["to_path", "to_filename", "from_filename", "toampath", "toamfile", " to_home", "to_Name", "from_path", "to_home", "toamname", "toamhome", " to_path", " to_Name"], "from_file": ["from___auto", "remote_function", "from__directory", "remote_lane", "from__name", " from_folder", "from___file", "source_brain", "remote_log", "source_resource", " from_directory", "fromCfile", "fromappfunction", "from_log", "fromCname", "from_lane", "source_files", "from__files", "from___name", "from__filename", "remote_file", "from_resource", "fromapplane", "fromapplog", "source_filename", "from_function", "from_directory", "fromCbrain", "from_filename", " from_files", "from__auto", "fromappfile", "from_files", " from__file", "from_brain", " from__filename", "from_folder", " from__auto", "source_directory", "from__file", "fromCfilename", " from_source", "source_file", "source_name", "from___filename", " from_auto", " from__name", "from__resource", "from_auto", "from_source", " from_filename"], "to_file": ["from_stream", "to_files", "to64function", "to64name", "from_bar", " to_class", "eto___name", "from_model", "to_bar", " to_model", "tojuse", "eto___remote", "toJname", "from_load", "to___name", "to64file", "into_use", "toJstream", "source_files", "intojfunction", "to_model", "eto_file", "from_binary", "tojname", "to__load", " to_queue", "source_filename", "toJfile", "tojfunction", "intojfile", "to67load", "to___file", "eto_name", "to___remote", "to__dir", "into_file", "to__file", "intojname", "from_files", "to_queue", " to_filename", "to__name", "to_server", "to67name", "to_filename", "tojfile", "source_server", "to_binary", "source_file", "into_name", "to64use", " to_files", "to67file", "to_load", "to_use", "to67dir", "into_function", "toJbar", "eto_remote", "to_function", "to_remote", "to_stream", "intojuse", "to_class", "to_dir", "eto___file", "from_dir"], "parent": ["source", "remote", "cache", "current", "out", "session", "owner", "global", "loc", "location", "ip", "directory", "url", "name", "null", "search", "pool", "rule", "div", "size", "temp", "any", "type", "target", "uri", "client", "ppa", "home", "root", "po", "tree", "or", "pa", "term", "api", "test", "Parent", "id", "unit", "user", "path", "point", "mother", "folder", "resource", "container", "string", "par", "am", "inc", "content", "p", "port", "ac", "memory", "author", "page", "per", "manager", "complete", "parents", "old", "server", "host", "function", "child", "address", "connection", "patch", "handler", "full", "file", "part", "fat"], "dir": ["group", "md", "cache", "out", "dec", "dict", "path", "Dir", " directory", "cat", "f", "home", "ver", "wd", "per", "root", "keep", "manager", "global", "or", "build", "loc", "data", "folder", "object", "module", "in", "dep", "ir", "director", "directory", "io", "class", "url", "name", "nav", "die", "container", "dr", "cur", "exp", "div", "lock", "dev", "di", "coll", "block", "iter", "def", "file", "tr", "part", "r", "entry", "id", "dis", "user", "db", "d", "doc", "rel", "dc"], "from": ["source", "form", "normal", "who", "cache", "so", "se", "client", "parse", "cf", "empty", "cor", "with", "this", "component", "view", "link", "e", "one", "per", "vol", "conn", "or", "get", "by", "left", "con", "ce", "self", "find", "io", "bean", "flo", "url", "base", "name", "low", "add", "pe", "server", "ou", "cr", "fe", "address", "api", "ch", "without", "connection", "two", "fr", "From", "stream", "cm", "range", "auto", "ra", "file", "start", "part", "when", "feed", "entry", "can", "context", "http"], "to": ["tto", "as", "top", "su", "token", "TO", "so", "client", "out", "output", "session", "thro", "sync", "ver", "fb", "store", "not", "with", "via", "per", "one", "po", "socket", "conn", "too", "about", "or", "by", "proxy", "storage", "dest", "io", "on", "flo", "base", "server", "until", "pi", "api", "see", "db", "connection", "two", "will", "size", "write", "To", "auto", "office", "value", "file", "t", "op", "o", "fat", "type", "that", "target", "co", "http"], "buffer": ["source", "message", "position", "shape", "length", "memory", "bb", "buff", "buf", "page", "texture", "seed", "uffer", "border", "padding", "default", "read", "data", "writer", "duration", "total", "resource", "binary", "comment", "document", "window", "character", "url", "b", "null", "server", "transfer", "number", "address", "variable", "Buffer", "header", "channel", "queue", "layer", "batch", "reference", "iter", "block", "row", "wave", "feed", "slice", "reader", "flush"], "bytes_read": ["bytes___pass", "bytesXload", " bytes_en", "bytes_load", "bytesXcurrent", "byte_load", "byte_before", "gets___pass", "gets___read", "byteslexread", "bytes_write", "byteslexbefore", "bytes_reads", "bytesXread", "gets___reads", "bytes_current", "bytes___read", " bytes_write", "byteslexload", "bytes_pass", "bytes_before", "bytes_en", "gets_allow", "gets_reads", "byteslexcurrent", "byte_read", "bytes___reads", "byte_current", "gets___allow", "bytes_allow", "gets_read", "bytesXbefore", " bytes_found", "bytes_found", "gets_pass", "bytes___allow"]}}
{"id1": "3330944", "id2": "9347451", "code1": "    public void extractImage(String input, String output, DjatokaDecodeParam params, IWriter w) throws DjatokaException {\n        File in = null;\n        String dest = output;\n        if (input.equals(STDIN)) {\n            try {\n                in = File.createTempFile(\"tmp\", \".jp2\");\n                input = in.getAbsolutePath();\n                in.deleteOnExit();\n                IOUtils.copyFile(new File(STDIN), in);\n            } catch (IOException e) {\n                logger.error(\"Unable to process image from \" + STDIN + \": \" + e.getMessage());\n                throw new DjatokaException(e);\n            }\n        }\n        BufferedImage bi = extractImpl.process(input, params);\n        if (bi != null) {\n            if (params.getScalingFactor() != 1.0 || params.getScalingDimensions() != null) bi = applyScaling(bi, params);\n            if (params.getTransform() != null) bi = params.getTransform().run(bi);\n            try {\n                BufferedOutputStream os = new BufferedOutputStream(new FileOutputStream(new File(dest)));\n                w.write(bi, os);\n                os.close();\n            } catch (FileNotFoundException e) {\n                logger.error(\"Requested file was not found: \" + dest);\n                throw new DjatokaException(e);\n            } catch (IOException e) {\n                logger.error(\"Error attempting to close: \" + dest);\n                throw new DjatokaException(e);\n            }\n        }\n        if (in != null) in.delete();\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 1, "substitutes": {"extractImage": ["extressFile", "extractFile", "extrateLayer", "compractImage", "compractText", "extressText", "compressLayer", "extressLayer", "extvertText", "extrateImage", "extressImage", "extractLayer", "extrateFile", "extvertImage", "compressImage", "compractLayer", "extvertFile", "compressFile", "extractText", "compractFile", "extvertLayer", "extrateText", "compressText"], "input": ["IN", "string", "path", "audio", "sin", "i", "qa", "id", "base", "temp", "ini", "rc", "ink", "OUT", "current", "inner", "RAW", "standard", "bin", "dc", "SOURCE", "API", "picture", "raw", "form", "type", "source", "reader", "Input", "inc", "inf", "media", "inside", "DATA", "work", "config", "data", "file", "text", "out", "parent", "src", "tmp", "request", "empty", "amp", "null", "init", "image", "PUT", "prefix", "In", "pull", "url", "address", "include", "command", "xml", "view", "img"], "output": ["string", "path", "address", "temp", "response", "resource", "Output", "filename", "version", "current", "message", "document", "result", "write", "password", "exit", "source", "dir", "target", "config", "parent", "file", "out", "text", "page", "format", "name", "generated", "image", "prefix", "unit", "secret", "STDOUT", "external"], "params": ["services", "base", "bis", "mos", "i", "Par", "server", "spec", "pi", "lis", "settings", "results", "http", "resources", "json", "lp", "py", "features", "styles", "s", "si", "manager", "parts", "reader", "fps", "proc", "lc", "ams", "par", "Parameters", "config", "pro", "attr", "data", "mm", "names", "options", "models", "plugins", "las", "p", "ras", "afi", "dis", "vs", "details", "theme", "ctx", "photos", "pins", "processor", "conf", "obj", "pixel", "batch", "rules", "xml", "words", "ps", "properties", "Param", "phrase", "param", "api", "phys"], "w": ["nw", "wi", "rw", "temp", "wp", "wl", "fw", "wt", "write", "wm", "wd", "ws", "reader", "wb", "W", "wh", "wic", "wave", "work", "pipe", "war", "out", "web", "widget", "wal", "wcs", "p", "aw", "m", "writer", "kw", "worker", "we", "wa", "sw", "xml", "world", "hw", "ow", "wx", "f"], "in": ["IN", "index", "pin", "ssl", "i", "ex", "n", "fa", "qa", "temp", "id", "ini", "gin", "inas", "con", "socket", "ins", "arin", "bin", "part", "source", "thin", "binary", "login", "min", "connection", "inside", "r", "inc", "config", "data", "file", "out", "vin", "rin", "src", "p", "null", "conn", "init", "ai", "again", "cgi", "m", "image", "isin", "ani", "In", "nin", "kin", "mc", "lin", "b", "include", "ac", "err", "cin", "inn", "f", "cli", "win", "din", "img"], "dest": ["path", "rest", "remote", "temp", "beta", "id", "resource", "cont", "project", "loc", "destroy", "done", "wd", "dc", " Dest", "exit", "txt", "die", "comb", "source", "d", "doc", "wb", "dir", "target", "dist", "default", "config", "parent", "flat", "src", "de", "Dest", "tmp", "nam", "route", "null", "style", "delete", "dis", "test", "desc", "name", "folder", "home", "decl", "di", "sup", "dep", "prop", "coord", "st", "dom", "gui", "dat", "din", "img"], "bi": ["info", "wi", "pin", "bis", "i", "mu", "fa", "cu", "pi", "ini", "bh", "fi", "bs", "si", "bin", "ii", "ori", "obi", "qi", " bio", "wei", "vi", "gb", "ji", "ti", "sb", "phi", "chi", "bas", "li", "bank", "BI", "ai", "oi", "ci", "eni", "oci", "zi", "nb", "xi", "di", "gi", "ib", "bc", "umi", "ki", "isi", "b", "ga", "ni", "abi", "ba", "bm", "Bi", "agi", "dat", "mini", "cli", "bid"], "os": ["ou", "i", "oses", "fs", "Os", "fits", "ks", "oa", "ns", "as", "dos", "OS", "o", "outs", "bs", "s", "co", "is", "oos", "so", "ws", "bos", "ops", "nos", "ob", "out", "xs", "ors", "es", "des", "oes", "vs", "aos", "obs", "io", "oss", "pos", "ot", " bos", "ios", "oS", "us", "ds", "los", "cs", "osi", "cos"]}}
{"id1": "11616716", "id2": "1188100", "code1": "    private static InputStream getCMSResultAsStream(String rqlQuery) throws RQLException {\n        OutputStreamWriter osr = null;\n        try {\n            URL url = new URL(\"http\", HOST, FILE);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            osr = new OutputStreamWriter(conn.getOutputStream());\n            osr.write(rqlQuery);\n            osr.flush();\n            return conn.getInputStream();\n        } catch (IOException ioe) {\n            throw new RQLException(\"IO Exception reading result from server\", ioe);\n        } finally {\n            if (osr != null) {\n                try {\n                    osr.close();\n                } catch (IOException ioe) {\n                }\n            }\n        }\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"getCMSResultAsStream": ["getCMSResponseasFile", "getCMSResultInReader", "getCMSResponseAsFile", "getCMSResultInStream", "getCMSResponseAsReader", "getCMSResponseasReader", "getCMSResultasStream", "getCMSResultAsSteam", "getCMSResultWithSteam", "getCMSResultInSteam", "getCMSResultasFile", "getCMSResultAsReader", "getCMSResultInFile", "getCMSResponseAsStream", "getCMSResponseasStream", "getCMSResponseAsSteam", "getCMSResultWithReader", "getCMSResultWithStream", "getCMSResultWithFile", "getCMSResultasSteam", "getCMSResultasReader", "getCMSResultAsFile", "getCMSResponseasSteam"], "rqlQuery": ["srQLQ", "srQLQu", "srqlquery", "rqlquery", "rQLQ", "rQLQuery", "rQLQu", "srqlQuery", " rsqlquery", "rQLquery", "rSQLquery", "riliquery", " rqlquery", "riliQuery", " rsqlQu", " rsqlQuery", " rqlMethod", "rsqlMethod", "srQLquery", "rqlQ", "rqlMethod", "rqlQu", " rqlQu", "rsqlQuery", "srqlQu", "rSQLQuery", "rSQLMethod", "riliQu", "rsqlQu", "srQLQuery", " rsqlMethod", "rSQLQu", "srqlQ", "rsqlquery", "rsqlQ", "riliQ", "rQLMethod"], "osr": ["osrw", "opsR", "osR", "otsr", " osrr", "ysr", "bosr", "usrs", "ossrt", "ossrm", "osrs", "iosrs", " ossr", " oscr", "obsrar", "ossrar", "boswer", "usr", "usrw", "ysrar", "otssr", "losfr", "yscr", "osspr", "OSrr", "OSrt", " ospr", " osrar", "ossrr", " osrt", "iosrw", "ossrw", "opswer", "cosrt", "iospr", "ysrt", "losrt", "oswer", "otsrm", "obswer", "usrt", "ossrs", "osrt", "oscr", " osfr", "obsR", "iosr", "bosR", "osrr", "OSr", "osserr", "oserr", "usrr", "otspr", "ossr", " osrm", "OSerr", "osssr", "losrr", "uspr", "opsr", "userr", "opsrar", "osrm", "obsr", "osscr", "cosfr", "cosr", "bosrar", "ospr", "osrar", "losr", "cosrr", "osfr"], "url": ["string", "path", "ssl", "base", "server", "uri", "resource", "http", "socket", "l", "host", "URL", "fl", "client", "source", "lc", "connection", "r", "ob", "open", "config", "file", "channel", "fb", "web", "nl", "ll", "page", "ls", "blog", "sl", "rl", "Url", "www", "b", "f", "org"], "conn": ["Connection", "ssl", "Conn", "server", "n", "rc", "enc", "http", "net", "con", "c", "act", "cb", "col", "l", "fn", "rt", "dc", "en", "nc", "ec", "client", "sync", "nt", "cp", "pr", "lc", "ct", "connection", "rn", "ch", "open", "conv", "ca", "attr", "h", "p", "coll", "ci", "exec", "oss", "ann", "cr", "db", "pc", "ctx", "err", "connect", "cn", "wrapper", "reg", "f", "cur", "org", "loc"]}}
{"id1": "21821404", "id2": "6908537", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    public String login() {\n        System.out.println(\"Logging in to LOLA\");\n        try {\n            String data = URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_email(), \"UTF-8\");\n            data += \"&\" + URLEncoder.encode(\"pw\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_pw(), \"UTF-8\");\n            URL url = new URL(URL_LOLA + FILE_LOGIN);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line, sessid;\n            line = rd.readLine();\n            sessid = get_sessid(line);\n            this.set_session(sessid);\n            wr.close();\n            rd.close();\n            return sessid;\n        } catch (Exception e) {\n            System.out.println(\"Login Error\");\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"getWebPage": ["getVirtualpages", "getVirtualPage", "parseWebpage", "getWebpages", "parsewebpage", "parsewebpages", "getwebpages", "getwebpage", "parseWebpages", "getWebpage", "getVirtualpage", "parsewebPage", "parseWebPage", "getwebPage"], "urlObj": ["URLObj", "blogObject", "urlObject", " urlOb", "strObject", "URLobj", " urlObject", "urlobj", "resourceExt", "URLExt", "UrlObj", "urlExt", "httpobj", " urlExt", "UrlOb", "resourceObject", " urlInst", "httpOb", "strobj", "resourceobj", " urlobj", "httpObj", "strObj", "Urlobj", "blogObj", "blogInst", "urlOb", "blogobj", "resourceObj", "URLObject", "strInst", "urlInst"], "content": ["body", "model", "html", "resource", "Content", "feed", "raw", "section", "cont", "comments", "continue", "coll", "write", "json", "lines", "load", "message", "text", "output", "java", "object", "page", "string", "code", "array", "c", "online", "buffer", "core", "work", "result", "css", "out", "response", "report", "clean", "server", "data", "file", "document", "value", "empty", "comment", "source", "url", "header", "address"], "is": ["its", "in", "site", "isi", "stream", "est", "abs", "ops", "mis", "cms", "nis", "ir", "lis", "does", "problem", "info", "ui", "ires", "IS", "ri", "r", "ise", "you", "ps", "irc", "was", "be", "ie", "ris", "io", "isp", "os", "it", "isl", "x", "isa", "ai", "out", "rest", "fs", "iss", "ip", "ins", "il", "as", "any", "iso", "bis", "es", "us", "ois", "al", "id", "isc", "ser", "ios", "Is", "i", "im", "ais", "or", "ar", "iris", "s"], "reader": ["in", "rx", "stream", "rer", "inner", "worker", "parser", "ler", "reading", "rar", "bird", "l", "writer", " Reader", "read", "ri", "driver", "r", "buffer", "ro", "rc", "oder", "handler", "er", "io", "rr", "x", "row", "director", "actor", "ner", "loader", "h", "server", "e", "ser", "Reader", "i", "iter", "or", "editor"], "line": ["link", "body", "lc", "cle", "section", "lf", "cl", "lines", "entry", "inline", "LINE", "text", "message", "Line", "column", "key", "l", "object", "page", "ine", "string", "code", "buffer", "pass", "item", "strip", "part", "row", "out", "response", "character", "block", "name", "col", "word", " inline", "server", "data", "file", "user", "cell", "char", "str", "comment", "connection", "source", "cr", "f", "url", "lin"]}}
{"id1": "7425022", "id2": "14785308", "code1": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "code2": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"transferWSDL": ["transferSWSDDL", "transferWSDLS", "transferSWSDl", "transferWDDL", "transferWSDDL", "transferWsdL", "transferWsdLS", "transferWDDLS", "transferWDDl", "transferWDDDL", "transferWNDLS", "transferSWsdLS", "transferSWsdL", "transferWNDL", "transferWsdDL", "transferWNDDL", "transferWSDl", "transferWsdl", "transferWNDl", "transferSWsdl", "transferSWSDL", "transferSWsdDL", "transferSWSDLS"], "wsdlURL": ["wsslUrl", "wllURL", "wsdalPath", "wsdlFILE", "wssdPath", "wsdlURI", "wslUrl", "wdlPath", "wssdUrl", "wslPath", "wdlURL", "wsslURL", "wssdURL", "wdlUrl", "wsdalUrl", "wllFILE", "wllPath", "wsllPath", "wsdnFILE", "wslURL", "wsllUrl", "wsdalURL", "wllUrl", "wsdlUrl", "wsllURI", "wsslPath", "wsdnPath", "wsllFILE", "wssdFILE", "wdlFILE", "wsllURL", "wsdnURL", "wsdlPath", "wdlURI", "wsdnUrl", "wsslURI", "wsdalURI", "wslURI"], "userPassword": ["Userpassword", "userpassword", "useAuth", " userPass", "userAuth", "useData", "UserWord", "UserName", "usepassword", " userData", "UserAuth", "UserData", "userName", "USERpassword", "USERPassword", "usePassword", "userPass", " userAuth", " userpassword", "userData", " userName", " userWord", "UserPass", "usePass", "userWord", "UserPassword", "USERName", "USERWord"], "filePath": ["fileStr", "transferPath", " filepath", "transferLocation", "transferStr", "Filepath", "transferpath", "FileStr", " fileLocation", "FileLocation", "FilePath", "fileLocation", "filepath", " fileStr"], "endpoint": ["endPoint", "adPoint", "Endwall", "endwall", "adpoints", "adwall", " endpoints", " endPoint", "EndPoint", "Endpoint", "Endpoints", " endwall", "adpoint", "endpoints"], "conn": ["exec", "cm", "url", "cf", "mc", "client", "ca", "ann", "w", "Connect", "ob", "reg", "cb", "ws", "comm", "connect", "ns", "oss", "sql", "conv", "cp", "inner", "c", "ci", "adj", "auth", "org", "ct", "en", "ssl", "connection", "ec", "g", "Connection", "n", "enc", "loc", "co", "nt", "Con", "sync", "pub", "socket", "dc", "open", "p", "close", "h", "pg", "dn", "rc", "cli", "col", "fn", "ch", "cn", "dh", "init", "act", "coll", "pc", "con", "nc", "ac", "Conn", "oa", "part", "conf", "ctx", "impl"], "is": ["iv", "ib", "ois", "Is", "es", "hi", "si", "ios", "os", "ipp", "ie", "i", "irc", "ps", "ri", "fs", "p", "sc", "as", "rs", "rest", "has", "bis", "x", "res", "ir", "s", "ris", "iss", "or", "rx", "mes", "in", "src", "mis", "us", "im", "ais", "ins", "iet", "sr", "was", "ar", "io", "sec", "oc", "stream", "isl", "info", "js", "lis", "isc", "isi", "it", "isp", " IS", "rss", "ss", "ip", "ai", "iso", "IS", "ws", "ism", "index", "out", "est", "r", "ops", "any", "h", "its", "act", "serv", "il"], "isr": ["issp", "ISl", " isw", "isrs", "ssr", "issl", "issrs", "isrb", "ISw", "iscrb", "isl", "isw", "ssrs", "iscp", "issw", "ssp", "isp", "ssrb", " isp", "issrb", "ISp", "ISr", " isl", "iscrs", "issr", "iscr"], "sw": ["su", "wt", "wa", "im", "sv", "tw", "wrap", "aw", "w", "war", "was", "sem", "wl", "xml", "ws", "x", "sl", "hop", "cr", "wx", "stream", "hw", "hi", "rew", "ww", "rw", "sm", "wr", "sb", "r", "rx", "SW", "so", "eng", "ow", "ew", "wb", "nw", "wh", "pg", "wp", "iw", "sh", "sc", "wra", "rss", "sf", "wo", "response", "Sw"], "buf": ["vec", "uf", "bc", "Buffer", "base", "uc", "prop", "str", "bb", "bin", "br", "cv", "bd", "feed", "raw", "brace", "cur", "func", "fb", "cr", "seq", "err", "len", "bag", "box", "batch", "b", "rx", "text", "ha", "ff", "block", "pad", "wb", "buffer", "la", "bytes", "rb", "cas", "rc", "data", "pool", "shift", "bh", "char", "cb", "buff"], "read": ["k", "send", "reader", "w", "parse", "use", "feed", "load", "child", "raw", "old", "check", "skip", "default", "boot", "log", "reading", "index", "input", "connect", "start", "length", "end", "play", "max", "stream", "need", "write", "en", "i", "count", "ride", "wait", "g", "r", "text", "n", "find", "Read", "sync", "block", "READ", "ok", "buffer", " write", "iter", "add", "get", "copy", "in", "work", "sleep", "se", "data", "num", "reads", "pass", "open", "size", "select", "f", "run"], "outputDir": ["OutputFile", "OutputPath", "outputFolder", "outDir", "inputDir", "tmpDir", "outFolder", "tmpPath", "inputFile", "OutputFolder", " outputDirectory", "tmpFolder", "OutputDirectory", "outFile", "OutputDir", "outDirectory", "tmpDirectory", " outputFolder", " outputPath", "inputDirectory", " outputFile", "outputDirectory", "inputFolder", "outputFile", "outputPath"], "file": ["fp", "url", "FILE", "base", "local", "output", "feed", "zip", "db", "path", "folder", "log", "function", "filename", "name", "out", "stream", "lock", "ile", "files", "build", "File", "writer", "info", "b", "object", "directory", "parent", "handler", "future", "buffer", "message", "resource", "content", "store", "line", "data", "work", "letter", "dir", "up", "full", "unit", "f", "le"], "fos": ["FOS", " fOs", "fOS", "F\n", " faos", " fOS", "Fos", "t\n", "infOS", "f\n", "Faos", "infaos", " f\n", "fOs", "FOs", "infOs", "faos", "infos"]}}
{"id1": "13122204", "id2": "8788371", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["UnzipModel", "unzipmodel", "unarchiveProject", "Unzipmodel", "unpatchmodel", "unarchivemodel", "unarchiveModel", "UnarchiveFile", "UnarchiveProject", "unpatchFile", "UnzipFile", "unpatchProject", "unzipFile", "unarchiveFile", "UnzipProject", "unzipProject", "unpackmodel", "UnarchiveModel", "unpackProject", "unpackModel", "unpackFile", "unpatchModel", "Unarchivemodel"], "filename": ["fp", "url", "FILE", "title", "fil", "kl", "model", "path", "folder", "utf", "nil", "location", "string", "name", "database", "files", "jet", "username", "SourceFile", "File", "directory", "loc", "fits", "uri", "fd", "l", "source", "fn", "file", "download", "src", "bf", "txt", "Filename", "f", "il", "module"], "tempdir": ["tmpdirectory", "Tempdirectory", " tempfolder", "tmpDir", " tempDir", "temdir", "TempDir", "temfolder", "tempDir", "temppath", "tmpfolder", "tempfolder", "temDir", "Tempdir", "tmpDIR", " tempdirectory", "TempDIR", "tmppath", " temppath", "Tempfolder", "tempDIR", "temdirectory", "tempdirectory", " tempDIR", "tmpdir", "tempath"], "dest": ["rest", "test", "result", "de", "cont", "st", "sup", "prop", "gen", "delete", "builder", "output", "transfer", "tmp", "zip", "exit", "comb", "proc", "folder", "log", "walk", "default", "export", "target", "flat", "session", "ui", "obj", "inner", "tar", "std", "Dest", "transform", "dat", "desc", "cdn", "handler", "loc", "walker", "nt", "sync", "wb", "done", "dc", "store", "di", "source", "file", "usr", "dist", "dir", "src", "die", "later", "home", "trans", "opt", "txt", " Dest", "temp"], "fis": ["filebis", " fiss", "flisa", "fid", "flis", "liss", "fliss", "fileisa", "fsisa", "fsbis", " fi", "fileis", "li", "lid", "fileid", "fsiss", " fid", "fsis", "filei", "lis", "fbis", "fiss", "fileiss", "fi", "flbis", "fisa"], "BUFFER": ["UPFF", " BUVER", "SAPER", "BUUCK", "BUFER", "BUFF", "CUVER", "TAPER", "BOFFER", "BOPER", "CUUCK", "SAUCK", "CUFFER", "TAVER", "UPFFER", " BUFER", " BUVEN", "CUVEN", "CUPER", " BUFIX", "BOFIX", "CUFF", "SAFFER", "TAFFER", "MAFIX", " BUFF", "MAPER", "BUPER", " BUUCK", "BUFIX", "UPVEN", "BUVEN", "MAFER", "MAFFER", "BOFER", "SAVER", " BUPER", "UPVER", "BUVER", "TAUCK"], "zis": ["zipis", " zists", " zbis", "zipisa", " zisa", "xiss", "diss", " zii", "zins", "Zas", "xis", " zos", "zin", "zii", "xi", "Zisa", " ziss", "zas", " zIS", "yis", "zipIS", "zipas", "zos", "zists", "Zins", "xii", "yin", " zin", "jos", "yIS", "jists", "zi", "Zis", "xos", "jis", "zipins", "dis", "zIS", "yisa", "xists", "zbis", "dbis", "zisa", " zas", "xbis", "dii", " zins", "ji", "zipin", " zi", "ziss"], "entry": ["de", "result", "lc", "reader", "enter", "e", "id", "zip", "feed", "inc", "ace", "ou", "valid", "cel", "je", "ge", "row", "name", "end", "li", "inner", "archive", "image", "next", "spec", "si", "or", "element", "ie", "info", "way", "pe", "ent", "connection", "Entry", "nt", "porter", "her", "pack", "la", "iterator", "jo", "rc", "line", "file", "ry", "se", "match", "source", "server", "ident", "ries", "cat", "part", "record", "ce", "module"], "count": ["base", "cache", "allow", "e", "use", "id", "feed", "current", "_", "Count", "log", "val", "index", "start", "length", "name", "max", "time", "end", "core", "ind", "c", "write", "len", "next", "code", "read", "type", "writer", "i", "counter", "b", "number", "list", "weight", "cond", "buffer", "iter", "add", "key", "line", "in", "file", "last", "low", "pos", "limit", "coll", "part", "sum", "size", "f"], "data": ["result", "base", "reader", "str", "id", "feed", "load", "raw", "DATA", "index", "input", "start", "length", "name", "image", "next", "write", "size", "len", "read", "format", "a", "info", "batch", "dat", "number", "body", "block", "message", "pack", "buffer", "media", "array", "bytes", "alpha", "content", "la", "shift", "pos", "d", "value", "record", "zero"], "fos": ["foes", "dfoes", "fOS", "dfoos", "afos", " foos", "xoes", "afOS", "bis", "xoos", "bOS", " fOS", "dfos", " fops", "afis", "bos", "dfops", "bops", "xos", "fops", " foes", "xops", "afops", "foos"]}}
{"id1": "11962480", "id2": "4562786", "code1": "    public void read(String skeletonFilename) throws Exception {\n        ClassLoader loader = UnicodePropertiesSkeleton.class.getClassLoader();\n        URL url = loader.getResource(skeletonFilename);\n        if (null == url) {\n            throw new Exception(\"Cannot locate '\" + skeletonFilename + \"' - aborting.\");\n        }\n        String line;\n        StringBuilder section = new StringBuilder();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), \"UTF-8\"));\n        while (null != (line = reader.readLine())) {\n            if (line.startsWith(\"---\")) {\n                sections.add(section.toString());\n                section.setLength(0);\n            } else {\n                section.append(line);\n                section.append(NL);\n            }\n        }\n        if (section.length() > 0) {\n            sections.add(section.toString());\n        }\n        if (sections.size() != size) {\n            throw new Exception(\"Skeleton file '\" + skeletonFilename + \"' has \" + sections.size() + \" static sections, but \" + size + \" were expected.\");\n        }\n    }\n", "code2": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "label": 1, "substitutes": {"read": ["open", "readable", "get", "Read", "create", "download", "load", "find", "add", "copy", "register", "check", "construct", "parse", "build", "init", "process", "store", "split", "transform", "resource", "replace", "print", "report", "write", "start"], "skeletonFilename": ["southeastFile", "sletonFilename", " skelFilename", " skelFile", "sletonfilename", "skeletonSourceFile", "southeastFilename", "skelDownload", "SkeletonSourceFile", "sletonSourceFile", "skelFile", "SkelFilename", "SkelDownload", "skelSourceFile", "skeletonDownload", "SkeletonDownload", "sleeFilename", " skeletonFile", "southeastSourceFile", "sletonFile", "Skelfilename", "skelFilename", " skelSourceFile", "sleeFile", "skeletonFile", "SkelFile", "SkelSourceFile", " skeletonfilename", " skelfilename", "SkeletonFile", "Skeletonfilename", "sleeSourceFile", "sletonDownload", "sleefilename", "southeastDownload", "skelfilename", "skeletonfilename", "SkeletonFilename", " skeletonSourceFile"], "loader": ["lock", "er", "loc", "loaded", "name", "handler", "Loader", "layer", "load", "class", "log", "lc", "base", "cache", "b", "loading", "l", "r", "err", "parser", "lang", "buffer", "source", "init", "builder", "driver", "path", "system", "cl", "config", "server", "null", "http", "CL", "in", "file", "impl", "resource", "rl"], "url": ["connection", "sl", "cdn", "f", "data", "loc", "name", "ur", "load", "base", "ssl", "page", "b", "user", "l", "r", "client", "address", "Url", "buffer", "URL", "source", "service", "i", "image", "api", "lib", "feed", "path", "object", "uri", "server", "browser", "http", "file", "resource", "bel", "coll", "host", "location", "rl", "rel", "string"], "line": ["job", "le", "sl", "data", "name", "lo", "body", "sync", "se", "str", "definition", "letter", "log", "base", "inline", "lc", "page", "part", "text", "user", "content", "l", "cell", "L", "lines", "lf", "key", "row", "comment", "i", "entry", "source", "style", "parse", "Line", "write", "no", "cl", "number", "nl", "code", "unit", "pe", "file", "split", "LINE", "word", "lin", "item", "result", "header", "link", "string", "liner", "strip"], "section": ["job", "connection", "union", "region", "data", "division", "sect", "sections", "layout", "version", "handler", " intersection", "array", "layer", "body", "se", "sector", "definition", "letter", "rule", "lc", "format", "position", "page", "description", "text", "output", "contract", "content", "article", "zip", "writer", "journal", "patch", "parser", "key", "row", "service", "style", "entry", "ner", "block", "storage", "feed", "sub", "builder", "source", "parent", "sec", "character", "config", "server", "null", "element", "file", "Section", "function", "script", "search", "draft", "chapter", "join", "length", "location", "area", "string", "ler", "option", "editor"], "reader": ["iter", "er", "f", "ri", "handler", "worker", "stream", "layer", "per", "inner", "r", "writer", "rer", "parser", "rr", "row", "buffer", "i", "ner", "oder", "feed", "builder", "driver", "reading", "bird", "io", "file", "rar", "resource", "input", "ler", "Reader", "editor", "rx"]}}
{"id1": "3309233", "id2": "23215235", "code1": "        @Override\n        protected String doInBackground(String... params) {\n            try {\n                final HttpParams param = new BasicHttpParams();\n                HttpConnectionParams.setConnectionTimeout(param, 30000);\n                HttpConnectionParams.setSoTimeout(param, 30000);\n                DefaultHttpClient client = new DefaultHttpClient(param);\n                HttpPost post = new HttpPost(\"http://www.google.com/loc/json\");\n                post.setEntity(new StringEntity(params[0]));\n                if (DEBUG) Log.d(\"Location\", params[0]);\n                HttpResponse resp = client.execute(post);\n                if (resp.getStatusLine().getStatusCode() == 200) {\n                    HttpEntity entity = resp.getEntity();\n                    String result = EntityUtils.toString(entity);\n                    return result;\n                } else {\n                    if (isFirstLocation) {\n                        requestGearsLocation(1);\n                        isFirstLocation = false;\n                        return RESULT_FIRST_FAILE;\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public void readFile(URL url) throws PedroException, IOException, ParserConfigurationException, SAXException {\n        this.zipFileName = url.toString();\n        URLConnection urlConnection = url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n        unzipNativeFormatFile(inputStream);\n        parseAlertFiles();\n        deleteAlertFiles();\n    }\n", "label": 0, "substitutes": {"doInBackground": ["buildInBackground", " doAsyncBackground", " doUsingBackground", " doAsyncConsole", "buildUsingStudio", " doAsBackground", "buildUsingBackground", " doAsConsole", " doAsyncAsync", " doInConsole", " doUsingAsync", " doUsingStudio", " doAsyncStudio", "buildInAsync", " doAsStudio", " doInAsync", "buildUsingConsole", " doInStudio", "buildUsingAsync", " doUsingConsole", "buildInStudio", "buildInConsole", " doAsAsync"], "params": ["address", "services", "objects", "posts", "types", "eps", "parse", "Param", "pm", "reports", "Parameters", "py", "values", "ls", "Par", "lines", "s", "resources", "results", "files", "comments", "strings", "properties", "type", "i", "arms", "options", "par", "ps", "config", "mes", "pins", "ds", "los", "parts", "p", "phrase", "ams", "page", "source", "data", "keys", "json", "details", "sp", "names", "ctx", "settings"], "param": ["cm", "address", "monitor", "lc", "mor", "amp", "project", "Param", "comment", "pm", "pri", "model", "camp", "proc", "am", "path", "default", "prem", "conn", "name", "string", "prom", "cp", "iam", "Parameter", "mand", "connection", "gram", "null", "object", "par", "parent", "arm", "km", "config", "mm", "rem", "option", "p", " parameter", "meter", "single", "aram", "channel", "pool", "pb", "ams", "vm", "password", "page", "contract", "pc", "ram", "part", "conf", "ctx", "temp"], "client": ["cm", "url", "cl", "base", "project", "app", "force", "proxy", "request", "plugin", "session", "host", "connect", "conn", "secure", "cp", "c", "comp", "self", "bird", "ssl", "connection", "handler", "Client", "config", "apache", "service", "api", "resource", "p", "http", "cli", "channel", "server", "google", "help", "con", "ce", "response"], "post": ["base", "send", "e", "pod", "zip", "pre", "load", "feed", "put", "proc", "request", "patch", "hop", "next", "set", "c", "upload", "dd", "head", "body", "query", "install", "api", "p", "add", "form", "http", "wp", "submit", "entry", "op", "pb", "push", "Post", "server", "pos", "create", "and", "posted", "POST", "pp", "json", "part", "comment", "f", "response"], "resp": ["exec", "error", "Resp", "received", " response", "status", "re", "rh", "rel", "e", "Response", "request", "comm", "res", "conn", "obj", "rep", "success", "err", "respond", "par", "body", "handler", "rec", "enc", "fc", "api", "resource", "content", "http", "page", "server", "download", "ref", "req", "reply", "json", "sp", "serv", "response"], "entity": ["base", "status", "ity", "output", "e", "el", "model", "xml", "node", "string", "conn", "obj", "code", "ec", "event", "element", "connection", "ent", "object", "body", "enc", "attribute", "resource", "person", "agent", "content", "translation", "Entity", "line", "data", "entry", "article", "instance", "coll", "json", "activity", "unit", "response"], "result": ["address", "url", "description", "place", "status", "output", "Result", "default", "row", "res", "string", "location", "name", "ret", "success", "results", "report", "desc", "object", "text", "message", "resource", "property", "content", "translation", "page", "line", "entry", "data", "match", "source", "record", "instance", "value", "json", "details", "response"]}}
{"id1": "21921000", "id2": "665420", "code1": "    @Override\n    public void parse() throws IOException {\n        URL url = new URL((new DataUrlResolver()).getDataUrl(DomainName.CROATIA));\n        URLConnection con = url.openConnection();\n        BufferedReader bStream = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        String str;\n        bStream.readLine();\n        while ((str = bStream.readLine()) != null) {\n            String[] tokens = str.split(\"(\\\\s+)\");\n            String charCode = tokens[0].replaceAll(\"([0-9+])\", \"\");\n            Float value = Float.parseFloat(tokens[2].trim().replace(\",\", \".\"));\n            CurrencyUnit unit = new CurrencyUnit(charCode, value, DEFAULT_MULTIPLIER);\n            this.set.add(unit);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"parse": ["init", " parser", "load", "construct", " setup", " discover", "build", "process", "Parser", "print", " init", "next", " parsed", "execute", "add", " load", " analyze", " feed", " convert", "ize", "parser", " analyse", "end", " parsing", "run"], "url": ["ls", "source", "org", "uri", "client", "path", "Url", "f", "bb", "this", "l", "conn", "data", "web", "service", "resource", "open", "www", "base", "log", "b", "server", "host", "URL", "zip", "sl", "address", "connection", "string", "ur", "file", "ssl", "user", "http"], "con": ["out", "client", "sync", "c", "f", "com", "Connection", " conn", "socket", "conn", "Conn", "func", "ca", "in", "close", "resource", "open", "pub", "n", "connect", "bc", "log", "pc", "b", "conv", "ann", "exec", "cr", "Con", "conf", "connection", "channel", "fa", "coll", "fc", "un", "cn", "file", "r", "CON", "login", "ctx", "plain", "cons", "can", "http"], "bStream": ["bsstream", "aRead", "bsConnection", "rbstream", "rbFile", "bW", "bbConnection", "astream", " bReader", " bW", "bConnection", "bbstream", " bFile", " bstream", "rbReader", "aStream", "bbW", "bFile", "bRead", "bbStream", " bRead", "bsStream", "aFile", "rbStream", "aReader", "bstream", "bbRead", " bConnection", "bsW", "bbReader", "bReader"], "str": ["p", "text", "kr", "char", "result", "arr", "st", "dec", "br", "c", "Str", "f", "s", "pass", "i", "input", "l", "line", "STR", "stri", "data", "in", "strip", "sr", "n", "name", "spec", "obj", "cr", "sl", "res", "sp", "cur", "string", "div", "fr", "enc", "coll", "pr", "tr", "part", "step", "r", "er", "err", "key", "id", "doc", "status"], "tokens": ["pokenents", "tarsen", "tokenens", "topents", "tokes", "takos", "Taken", "token", "tokenets", "tractents", "Tokens", "Tokents", "takets", "tractens", "takens", "Tokes", "Tokets", "tokos", "Takents", "tokets", "toks", "taks", "Takicks", "Takens", "Tokicks", "poks", "tokicks", "topets", "Takos", "Token", "topens", "pokets", "tarses", "takents", "tarsens", "Takes", "Tokos", "tokenes", "takicks", "tractos", "tarsicks", "pokenets", "tokenen", "tokenicks", "takes", "tokenents", "tractets", "toksets", "taken", "pokents", "toksens", "pokenens", "tops", "Takets", "toksents", "tokents", "pokens", "toksos"], "charCode": [" charcode", "charNumber", "characterNumber", "CharName", "characterType", "characterCode", "CharNumber", "charcode", " charNumber", "charName", "charCount", "characterName", "CharCount", "charactercode", "characterCount", "Charcode", "CharCode", " charType", " charCount", " charName", "CharType", "charType"], "value": ["flow", "result", "current", "Value", "amount", "VALUE", "count", "val", "default", "data", "object", "money", "format", "dollar", "values", "flo", "base", "name", "num", "number", "function", "grade", "fe", "string", "size", "element", "range", "scale", "weight", "version", "key", "entry", "rate", "v", "type", "price", "volume"], "unit": ["flow", "uni", "position", "units", "output", "out", "union", "instance", "point", "component", "item", "data", "factor", "format", "class", "currency", "base", "num", "u", "it", "number", "split", "letter", "term", "string", "category", "size", "option", "element", "scale", "un", "version", "Unit", "rate", "type", "target"]}}
{"id1": "416857", "id2": "18202328", "code1": "    public void process(String dir) {\n        String[] list = new File(dir).list();\n        if (list == null) return;\n        int n = list.length;\n        long[] bubblesort = new long[list.length + 1];\n        if (!statustext) {\n            IJ.log(\"Current Directory is: \" + dir);\n            IJ.log(\" \");\n            IJ.log(\"DICOM File Name / \" + prefix1 + \" / \" + prefix2 + \" / \" + prefix3 + \" / \" + pick);\n            IJ.log(\" \");\n        }\n        for (int i = 0; i < n; i++) {\n            IJ.showStatus(i + \"/\" + n);\n            File f = new File(dir + list[i]);\n            if (!f.isDirectory()) {\n                ImagePlus img = new Opener().openImage(dir, list[i]);\n                if (img != null && img.getStackSize() == 1) {\n                    if (!scoutengine(img)) return;\n                    if (!statustext) {\n                        IJ.log(list[i] + \"/\" + whichprefix1 + \"/\" + whichprefix2 + \"/\" + whichprefix3 + \"/\" + whichcase);\n                    }\n                    int lastDigit = whichcase.length() - 1;\n                    while (lastDigit > 0) {\n                        if (!Character.isDigit(whichcase.charAt(lastDigit))) lastDigit -= 1; else break;\n                    }\n                    if (lastDigit < whichcase.length() - 1) whichcase = whichcase.substring(0, lastDigit + 1);\n                    bubblesort[i] = Long.parseLong(whichcase);\n                }\n            }\n        }\n        if (statussorta || statussortd || statustext) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (statussorta) {\n                        if (bubblesort[i] > bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    } else {\n                        if (bubblesort[i] < bubblesort[i + 1]) {\n                            long temp = bubblesort[i];\n                            tempp = list[i];\n                            bubblesort[i] = bubblesort[i + 1];\n                            list[i] = list[i + 1];\n                            bubblesort[i + 1] = temp;\n                            list[i + 1] = tempp;\n                            sorted = false;\n                        }\n                    }\n                }\n            }\n            IJ.log(\" \");\n            for (int i = 0; i < n; i++) {\n                if (!statustext) {\n                    IJ.log(list[i] + \" / \" + bubblesort[i]);\n                } else {\n                    IJ.log(dir + list[i]);\n                }\n            }\n        }\n        if (open_as_stack || only_images) {\n            boolean sorted = false;\n            while (!sorted) {\n                sorted = true;\n                for (int i = 0; i < n - 1; i++) {\n                    if (bubblesort[i] > bubblesort[i + 1]) {\n                        long temp = bubblesort[i];\n                        tempp = list[i];\n                        bubblesort[i] = bubblesort[i + 1];\n                        list[i] = list[i + 1];\n                        bubblesort[i + 1] = temp;\n                        list[i + 1] = tempp;\n                        sorted = false;\n                    }\n                }\n            }\n            if (only_images) {\n                Opener o = new Opener();\n                int counter = 0;\n                IJ.log(\" \");\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break; else {\n                        ImagePlus imp = o.openImage(path);\n                        counter++;\n                        if (imp != null) {\n                            IJ.log(counter + \" + \" + path);\n                            imp.show();\n                        } else IJ.log(counter + \" - \" + path);\n                    }\n                }\n                return;\n            }\n            int width = 0, height = 0, type = 0;\n            ImageStack stack = null;\n            double min = Double.MAX_VALUE;\n            double max = -Double.MAX_VALUE;\n            int k = 0;\n            try {\n                for (int i = 0; i < n; i++) {\n                    String path = (dir + list[i]);\n                    if (path == null) break;\n                    if (list[i].endsWith(\".txt\")) continue;\n                    ImagePlus imp = new Opener().openImage(path);\n                    if (imp != null && stack == null) {\n                        width = imp.getWidth();\n                        height = imp.getHeight();\n                        type = imp.getType();\n                        ColorModel cm = imp.getProcessor().getColorModel();\n                        if (halfSize) stack = new ImageStack(width / 2, height / 2, cm); else stack = new ImageStack(width, height, cm);\n                    }\n                    if (stack != null) k = stack.getSize() + 1;\n                    IJ.showStatus(k + \"/\" + n);\n                    IJ.showProgress((double) k / n);\n                    if (imp == null) IJ.log(list[i] + \": unable to open\"); else if (imp.getWidth() != width || imp.getHeight() != height) IJ.log(list[i] + \": wrong dimensions\"); else if (imp.getType() != type) IJ.log(list[i] + \": wrong type\"); else {\n                        ImageProcessor ip = imp.getProcessor();\n                        if (grayscale) ip = ip.convertToByte(true);\n                        if (halfSize) ip = ip.resize(width / 2, height / 2);\n                        if (ip.getMin() < min) min = ip.getMin();\n                        if (ip.getMax() > max) max = ip.getMax();\n                        String label = imp.getTitle();\n                        String info = (String) imp.getProperty(\"Info\");\n                        if (info != null) label += \"\\n\" + info;\n                        stack.addSlice(label, ip);\n                    }\n                    System.gc();\n                }\n            } catch (OutOfMemoryError e) {\n                IJ.outOfMemory(\"FolderOpener\");\n                stack.trim();\n            }\n            if (stack != null && stack.getSize() > 0) {\n                ImagePlus imp2 = new ImagePlus(\"Stack\", stack);\n                if (imp2.getType() == ImagePlus.GRAY16 || imp2.getType() == ImagePlus.GRAY32) imp2.getProcessor().setMinAndMax(min, max);\n                imp2.show();\n            }\n            IJ.showProgress(1.0);\n        }\n    }\n", "code2": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "label": 0, "substitutes": {"process": ["init", "output", " handle", "parse", " inspect", " display", " loop", " Process", "proc", "exec", " analyze", " report", " processes", " processing", " test", " finish", "run", "Process", " analyse", " work", "loop", " program", " browse", "report", "status"], "dir": ["p", "work", "source", "filename", "md", "File", "str", " Dir", "dict", "IR", "Dir", "c", "download", "config", "home", "wd", "txt", "root", "keep", "Name", "project", "src", "manager", "pos", "loc", "data", "folder", "object", "DIR", "ir", "dl", "dest", "directory", "base", "name", " d", "url", "fd", "zip", "dist", "dat", "dr", "Directory", "string", "direction", "dy", "target", "prefix", "lock", "cd", "file", "lib", "dn", "id", "pkg", "diff", "db", "d", "doc", "rel"], "list": ["x", "source", "cache", "out", "parse", "config", "bl", "left", "close", "we", "log", "name", "null", "pe", "cont", "code", "post", "li", "see", "header", "size", "queue", "write", "iter", "sort", "key", "entry", "listed", "pre", "group", "last", "result", "arr", "lists", "load", "all", "view", "show", "tree", "data", "names", "lc", "split", "live", "j", "coll", "batch", "test", "pull", "diff", "id", "parent", "ls", "match", "call", "LIST", "table", "output", "state", "link", "tail", "e", "input", "keep", "line", "map", "print", "array", "stat", "string", "chain", "detail", "filter", "block", "loop", "get", "status", "p", "set", "download", "page", "l", "complete", "record", "open", "www", "server", "index", "lock", "cl", "full", "file", "v"], "n": ["p", "x", "nat", "ln", "ot", "z", "net", "c", "ni", "all", "not", "len", "w", "e", "nt", "l", "conn", "none", "N", "count", "m", "ner", "nl", "left", "ne", "g", "nn", "name", "num", "b", "nb", "number", "j", "h", "nc", "fn", "size", "en", "sn", "iter", "ns", "y", "t", "adj", "network", "v", "node", "d", "no"], "bubblesort": ["rubblesorted", "bubbleshop", "ubblessort", "bubblingsort", "bubblerord", "grabblersorter", "bubbsort", "bubblesalt", "ubblingsort", "bubblehop", "bubbleort", "rubbleorted", "bubblinghop", "bubbesorter", "bubbleORT", "bublesalt", "ubblingport", "ubblingorted", "bubblersorter", "rubblessort", "bubbledorted", "barblesort", "bublesorter", "ubblesport", "ubblingort", "bubblingport", "bubbssort", "bubblesORT", "rubbleORT", "ubblehop", "grabblersalt", "rubblesORT", "bubblessort", "bubblesorted", "bubblerorter", "barblesorter", "bubblingorter", "bubblesorter", "bubbsorter", "grabblerssort", "rubblesort", "bubblersord", "rubbledorts", "bubblersalt", "bubblingorted", "rubblesorts", "rubbledsort", "bubbesport", "rubbleorts", "bubbleorter", "bubblesorts", "bubblerort", "barblesport", "bubblingORT", "bubbledorts", "barblerorter", "bublessort", "ubbleshop", "bubbesort", "bubblesord", "ubbleort", "rubblingsort", "bubbledORT", "bubbledhop", "bubblingorts", "bubblersport", "bubbledorter", "barblerort", "grabblesorter", "bubblesport", "bublesort", "barblerport", "rubbleort", "grabblesalt", "rubbledort", "bubblerorts", "grabblessort", "bubbsorts", "bubblersort", "bubbleorted", "ubblesort", "grabblersort", "rubblesorter", "bubbledport", "rubblingorted", "bubbledort", "bubblerssort", "rubbledorter", "barblerord", "grabblesort", "bubblerport", "ubbleorted", "rubblingorter", "bubbleorts", "bubbledsort", "bubbesord", "bubblingalt", "rubblingort", "bubblersorted", "barblesord", "ubblesorted", "bubblingort", "bubbsorted"], "i": ["x", "init", "ai", "I", "image", "ci", "chi", "directory", "isin", "name", "u", "li", "y", "slice", "start", "ti", "d", "uri", "shift", "ei", "ini", "multi", "bi", "iu", "io", "g", "sup", "lc", "iv", "pi", "api", "j", "anti", "eni", "cli", "mu", "id", "diff", "hi", "field", "ii", "e", "ind", "next", "si", "b", "is", "ji", "mi", "di", "qi", "xi", "ri", "phi", "p", "z", "inner", "c", "ni", "gi", "ix", "ori", "ie", "l", "inst", "uli", "yi", "m", "in", "it", "ui", "ik", "oi", "index", "part", "fi", "v"], "f": ["p", "F", "fp", "fx", "c", "fb", "w", "e", "l", "m", "folder", "g", "base", "b", "fd", "fw", "obj", "fs", "fe", "j", "h", "fn", "fr", "fa", "file", "df", "r", "fi", "sf", "v", "d", "raf"], "img": ["Image", "p", "png", "ani", "app", "iframe", "im", "br", "plug", "ai", "fb", "aug", "input", "l", "src", "image", "inst", "ff", "m", "fm", "aff", "pg", "g", "url", "pic", "NG", "inf", "iv", "hr", "fw", "tif", "picture", "obj", "bg", " image", "sl", "j", "api", "gd", "h", "div", "imag", "agi", "tf", "ng", "impl", "gif", "fc", "icon", "jpg", "v", "fig", "images"], "whichcase": ["whichpatch", "whoseCase", " whichcode", "howconfig", "whichconfig", " whichspace", "whatCase", "whetherCase", "howpath", "whethercase", "howcase", "whatcode", "howCase", "whichcode", "whichmatch", "hiscase", "whosecode", "existingpatch", "existingcase", " whichmatch", "whocase", "Whichmatch", "existingCase", "whosepath", "Whichpath", " whichpath", "whatspace", "whethermatch", "whosematch", "whichspace", "WhichCase", "Whichcode", "whichpath", "whatpath", "hiscode", "whocode", "Whichconfig", "whatcase", "existingcode", "whosecase", "whosespace", "whoCase", "whetherpatch", "hisCase", "hispatch", "whoseconfig", "Whichcase", "Whichpatch", "whosepatch", " whichCase", "whichCase"], "lastDigit": ["lastdigiton", "lastPosit", " lastDigger", "lastPosbit", "lastAddit", "lastdigbit", "lastDigger", "lastDits", " lastAddit", " lastAddits", " lastDigits", "lastDigition", "lastPosi", "lastAddith", "lastAddits", "lastPosition", "lastModbit", "lastCommith", "lastMarkash", "lastMarkith", "LastDigith", "lastSignbit", " lastDigi", "lastModith", "lastModash", "lastDigbit", "lastdigit", "lastCommi", "lastSignger", " lastDigbit", " lastDigition", "lastSignith", "lastModIT", "LastDigash", "lastDIT", "lastModit", " lastDigiton", "lastMarkits", "LastDigit", " lastAddith", "lastPosith", "lastSignit", "LastDigits", "lastDigiton", "lastAdditon", "lastDith", "lastDigith", "lastModits", "lastDigi", "lastModi", "lastdigith", "lastDit", "lastMarkit", "lastCommit", "lastdigger", " lastDigith", "lastDigIT", "lastdigits", "lastDigits", "lastCommition", "LastDigIT", "lastDigash", " lastAdditon"], "sorted": ["Sort", "setsored", "sorting", "unsorted", " sort", "setsorted", "nsorted", "saved", "Sorter", "unsorting", " sorter", "absort", "absorter", "sored", "Sorted", "insorted", "insorting", "setsorting", "nsaved", "unsort", "insaved", "absorting", "setsaved", "sort", "absorted", "nsored", "insored", "sorter", " sorting", "nsorting", "Sorting", "unsorter"], "temp": [" output", " tem", "buffer", "out", " Temp", "z", "c", "w", " tail", "l", "m", " template", "Temp", " big", "tmp", " temporary", " mm", " buf", " w", " seq", "size", " tmp", " buffer", " orig", " mem", " count", " result"], "tempp": ["prompl", "mempl", "tempar", "prompar", "timpar", "prompp", "timpl", "timporal", "templ", "memporal", "temporal", "mempar", "timpp", "promporal", "mempp"]}}
{"id1": "6988216", "id2": "5061606", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": [" runBasicConnect", "runRawQuery", " runSimpleConnect", " runBasicQuery", " runBasicSearch", " runSimpleFilter", " runClientSearch", " runClientFilter", "runSimpleConnect", "runSimpleFilter", "runSimpleSearch", " runSimpleQuery", " runBasicFilter", "runRawSearch", " runClientQuery", "runRawConnect", " runClientConnect", " runRawFilter", "runRawFilter", " runSimpleSearch", " runRawSearch", " runRawConnect", " runRawQuery", "runSimpleQuery"], "dummySource": ["puddyService", "dandySource", "dummyType", "dundleContent", "dellyService", "puddyType", "pummySite", "dumbContent", "dummyService", "dundleConfig", "duddyOrigin", "pummySource", "dumbSource", "puddySource", "dellySource", "daddyContent", " dumbSource", "puddyContent", "puddySourceFile", "pummyService", " dummyConfig", "puddySite", "dumbOrigin", "dummySourceFile", "dummySite", "daddySourceFile", "daddyService", "dundleOrigin", "dumbConfig", "duddySourceFile", "dandyClient", "duddyService", "dellyContent", "daddySource", " dumbOrigin", "duddyConfig", " dumbConfig", "pummyType", "duddySite", "duddyContent", "pummySourceFile", "puddyClient", "duddySource", " dummyOrigin", " dumbContent", "duddyType", "pummyContent", "dellyType", "dummyOrigin", "daddyClient", "dandySourceFile", "dummyClient", "daddyType", "dummyConfig", "pummyClient", "dandySite", "dundleSource", "duddyClient", "daddySite"], "os": ["ou", "o", "vs", "ops", "ls", "dos", "osi", "bos", "ox", "ns", "mos", "acs", "ms", "conn", "object", "pos", "obs", "ps", "ok", "ows", "op", "ds", "io", "ros", "om", "Os", "nos", "oss", "css", "out", "fs", "is", "cos", "as", "iso", "oS", "es", "oc", "ens", "us", "ori", "sys", "bs", "oa", "oses", "uns", "ose", "ol", "ios", "OS", "ss", "i", "ols", "oos", "ks", "or", "los", "aos", "s"], "dummyContent": ["DummyContent", "DuckyContent", "dummyReader", " dummyContents", "dellyContents", "dumperBody", "dumpingOutput", " dellycontent", " dummyOutput", "dumpingContent", "DummySource", "duddyReader", "DuckyBody", "dumperContent", "dumperSource", "dumpercontent", "dumpingContents", "DummyBody", "duckyReader", "dellyContent", "dumperContents", " dellyOutput", "dummyBody", " dellyContent", "duckySource", "duckyContent", "dummyContents", "dummyOutput", " dellyContents", "duddyContent", "dumpingcontent", "dumperOutput", "duddyBody", " dummycontent", "dummycontent", "duddySource", "DuckyReader", "dumperReader", "DummyReader", "dellyOutput", "DuckySource", "duckyBody", "dellycontent"], "source": ["resources", "unit", "slave", "service", "resource", "SOURCE", "site", "storage", "stream", "Source", "target", "channel", "src", "text", "cache", "sync", "use", "info", "object", "scope", "ources", "string", "class", "element", "core", "sn", "node", "sc", "ource", "result", "uri", " Source", "sin", "client", "secure", "cos", "size", "proxy", "search", "host", "seed", "e", "ser", "sl", "reader", "i", " sources", "connection", "config", "parent", "url", "s"], "content": ["body", "image", "model", "sol", "html", "service", "resource", "Content", "child", "feed", "comments", "cont", "current", "transform", "input", "children", "target", "match", "version", "text", "load", "cms", "message", "output", "music", "media", "update", "code", "news", "result", "css", "response", "xml", "cos", "size", "expression", "report", "title", "clean", "host", "data", "server", "document", "header", "value", "description", "activity", "comment", "config", "url", "cover", "address"], "qResult": ["qResponse", " qresult", "qresult", "kResults", "QFilter", "iqResults", "kresult", "qSource", "rSource", "rResult", "kResult", "kFilter", "queryResponse", "kRes", "queryRes", "qResults", "kReturn", "QResult", " qResponse", "iqResponse", "QReturn", "queryResult", "querySource", "qRes", "rresult", "qReturn", "iqResult", "queryReturn", "qFilter", "queryFilter", "queryResults", "queryresult", " qResults", "rRes", "kSource", "iqresult", "QResults"], "results": ["resources", "its", "versions", "objects", "errors", "shows", "children", "runs", "lines", "ids", "RESULTS", "details", "vers", "events", "blocks", "tests", "files", "collection", "rows", "groups", "successful", "ions", "result", "items", "response", "values", "qs", "reports", "users", "members", "ins", "models", "features", "docs", "pages", "data", "ries", "res", "Results", "s"], "it": ["IT", "its", "in", "ited", "rit", "lit", "which", "entry", "edit", "slice", "mit", "list", "l", "info", "itted", "pit", "r", "t", "ic", "not", "split", "ati", "ait", "op", "p", "ci", "ort", "si", "stat", "v", "and", "ip", "sit", "ins", "ite", "init", "iti", "the", "ITS", "id", " It", "It", "i", "iter", "or", "you"], "rSrc": ["rAsource", "rDssrc", "rPsource", " rEsource", "rIsRC", " rSsrc", "RSrc", "rEsource", "rIsrec", "rEssrc", " rEsRC", "rAssrc", " rDsource", "rPsRC", "rSource", "rAsrec", " rSource", "rAsrc", "rEsRC", "rSrec", "RIsRC", "RIsrec", "rAsRC", "RIsrc", "RIsource", "rPsrc", "rDsRC", "RSource", "rDsrc", "RSrec", " rSRC", "rEsrc", " rDsrc", "rSRC", "rPssrc", " rDssrc", "rIsrc", " rEsrc", "rIsource", "rDsource", "RSRC", "rSsrc", " rEssrc", " rDsRC"], "rSrcIn": ["rSvcin", "rAsRCIn", "rAsRCOut", "rCsrcOut", "rSRCIn", "rCrcin", "rAsrcOut", "rCRCIn", "rSvcIns", "rSourceOut", "rSourceIn", "rCrcIns", "rSvcIN", "rCrcIN", "rCrcOut", "rSrcOut", "rSRCIN", "rCRCOut", "rCsrcIn", "rCrcIn", "rSrcin", "rSrcIns", "rCRCIns", "rSRCOut", "rAsrcIn", "rSourceIns", "rSvcIn", "rSourcein", "rSsrcin", "rSrcIN", "rSsrcOut", "rSvcOut", "rSsrcIn", "rAsrcin", "rCsrcIN", "rCsrcin", "rAsRCin", "rSsrcIN", "rSRCIns", "rSRCin"], "actualOut": ["realout", " actualBridge", "eventout", "actualIn", "nexpectedOut", "assertOut", " actualout", "assertIn", "operatorout", "eventOUT", "actualOutput", "actualOUT", " ActualBridge", "realWin", " ActualOUT", "illegalOutput", " actualOutput", "illegalOUT", "illegalOut", " ActualOut", " actualOUT", "illegalIn", "publicOut", "operatorIn", "actualout", "operatorOUT", "eventOut", "actualWin", " ActualIn", "realOut", "nexpectedIn", "publicIn", "assertOUT", "nexpectedWin", "eventIn", "assertBridge", "operatorOut", " actualWin", " actualIn", "nexpectedout", "realIn", "publicOUT", "publicOutput", "actualBridge"]}}
{"id1": "13757855", "id2": "6966398", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"process": ["request", "cess", "output", "view", "load", "construct", "parse", "run", "evaluate", "handle", "code", "path", "resource", "submit", "proc", "build", "exec", "update", "transform", "processing", "call", "processor", "project", "create", "Process"], "tpl": ["stPL", "lple", " tcl", "tplate", "tmyl", "temPL", "tml", "ttemplate", "tplug", "stpl", "Tplates", "Tper", "lcl", "fpl", "Tsl", "tpp", " tplates", "tmple", "fplate", "tple", "latpl", "tcl", "temtemplate", "qtple", "templates", "tipl", "latple", "Tpl", "stplate", "tmcp", " tml", "Tml", "itPL", "lPL", "fplug", "pipl", "templ", "stpp", "lplate", " ttemplate", " tplug", "latyl", "itpl", "lper", "tmpl", "tcp", "atml", " tplate", "Tfc", "qtpl", "atplate", "fml", "Tbl", "qtfc", " tper", "itplates", "ppl", "tbl", "tPL", " tsl", "atplug", "pPL", "qtbl", "qtcp", "Tipl", "Tpp", " tbl", "psl", " tple", "latcp", "itplate", "lpl", " tpp", " tfc", "tper", "qtyl", "Tcl", " tipl", "atpl", "Tple", "lml", "tplates", "Ttemplate", "Tplate", "pcl", "TPL", " tPL", "tsl", "tfc", "tyl"], "model": ["where", "m", "models", "copy", "Model", "json", "module", "result", "media", "location", "graph", "message", "param", "params", "xml", "conf", "doc", "data", "log", "language", "document", "node", "project", "body", "command", "config"], "packageName": ["projectName", "projectKey", "packagename", "groupKey", "groupname", "packageInfo", "moduleUrl", "moduleKey", "contextname", "Packagename", " packageInfo", "projectname", "contextNames", "groupName", "PackageName", "moduleName", "packageUrl", " packagename", "PackageInfo", "modulename", "packageKey", "packageNames", " packageNames", "PackageNames", "groupUrl", "contextName", "projectUrl", "contextInfo"], "outFileName": ["outRuleInfo", "outRuleType", "outLineNames", "outfileNames", "outDirEnd", "OUTBufferName", "inFilePath", "diffFileName", "outDirCopy", "outfileName", "outFullTime", "outfileCopy", "outDirPath", "outFileTime", "inDirCopy", "outDirInfo", "outStreamName", "OUTFileName", " outFileLine", "outfileOnce", "OUTBufferMode", "outDirOnce", "outBufferMode", "outFileOnce", "outFileEnd", "outFilesPath", "outStreamType", "outFilenameName", "outfileInfo", "outFilesTime", "OutDirLine", "outFilename", "outfileHalf", "outBufferHalf", "outFileLine", "inDirName", "OutDirNames", "outFilesName", "outBufferNames", "outFileType", "outFullname", "outFileHalf", "difffileInfo", "outFilenameNames", "outFileCopy", "outFilenameCopy", "outLineInfo", "OutFileNames", " outFileInfo", "diffFileOnce", "outFullName", "inDirPath", "outFullInfo", "inFileName", "diffFileInfo", "outLineName", "diffFileTime", "difffileTime", "outFilenameEnd", "outFullType", "outFilenameMode", " outDirTime", " outFullType", "outFilenameHalf", "outfileTime", "outLineTime", "outFullPath", "outLineLine", "inFileCopy", " outDirLine", "OutDirname", "outFilesLine", " outFileType", "OutFilename", " outFilePath", "OUTFileNames", " outDirName", "outFileNames", "outLineOnce", "outBufferName", "outfileMode", "outDirTime", "inFileEnd", "outFullLine", "difffileOnce", "inDirEnd", "OUTBufferNames", " outFullName", "outStreamInfo", "outDirLine", "outLinename", "outfileEnd", "OutFileLine", " outDirPath", "outFullNames", "outFilenamePath", "OUTBufferHalf", "outFileInfo", "difffileName", "outDirname", "OutFileName", "outfilePath", "outFileMode", "outDirNames", "OUTFileHalf", " outFullInfo", "outDirName", " outFileTime", "OUTFileMode", "OutDirName", "outFilePath", "outRuleName"], "xsltParam": ["xslicparam", "xslpMode", "xslicMode", "xsldVal", "xslicParam", "xsltMode", "xslpparam", "xslpParam", "xltVal", "xsltVal", "xsldparam", "xsldParam", "xldMode", "xldparam", "xldVal", "xsltparam", "xltParam", "xltMode", "xslicVal", "xltparam", "xslpVal", "xldParam", "xsldMode"], "artifact": ["artfact", "Artfact", "Arturation", " artribution", "Artifacts", "advertribution", "Artifest", " arturation", "advertifacts", "adverturation", "artifest", " artifacts", "ARTifest", "arturation", "ARTifact", "ARTfact", "ARTifacts", "artifacts", "aratifacts", "Artifact", "advertifact", "aratifest", "aratifact", "aratfact", "artribution", "Artribution"], "destinationPath": ["destinatedPoint", "destinationFile", "constinationContext", "destinatorUrl", "datinationPath", "destificationPath", "destinatorFile", "tempinationPath", "restinatorPath", "tempinationpath", "destensionPoint", "destplingPath", "destinatorPath", "destinatorString", "distinatorStep", "constinatorpath", "destensionName", "destinatePath", "desticationKey", "destinatedHalf", "destinatorStep", "destinationsName", "destinateHandler", "destinerPath", "constinatorUrl", "destignmentCase", "destiationDir", "destinatedDir", "desticationPart", "distinationCase", "destinatingPath", "combinationName", "destinateText", "destinationspath", "constinationWidth", "destinationsPath", "restinationString", "tempinatedDir", "destinatepath", "destificationAuth", "destinatePart", "destinateName", "datinationpath", "destinationName", "destiationPath", "destinatedCase", "tempinatedpath", "destributionName", "datinateTime", "desturationName", "constinationName", "desticationPath", "DestinatingName", "destinationUrl", " destificationLog", "datinationTime", "destplingDir", "destplingAuth", "restinationLocation", "restinationpath", "destinatedFile", "destinateDir", " destinationLog", "destiationAuth", "destificationLog", "distinationStep", "desticationFile", "destributionCry", "destinationText", "DestinationPart", "destinateString", "combinationPath", "restinatorPoint", "destinationHandler", "destinationContext", "destinatedString", "constinationsPoint", "distinatorKey", "destplingWidth", "restinationPoint", "destificationLocation", "destationpath", "tempinationHalf", "restificationPath", "desturationPath", "destinationAuth", "distributionCase", "destiningDir", "restificationPoint", "destinatorName", "destinatorPoint", "constinationUrl", "destributionCase", "DestificationPath", "constinatorPath", "destinatedpath", "destinateLocation", "destinationpath", "destensionPath", "destcreationPath", "destinatingpath", "desturationpath", " destinationDir", "destificationpath", "destinatorpath", "destiationLog", "destignmentPath", "destationPath", "destificationName", "destinatorCase", "destplingLog", "destinationCase", "destinationWidth", "combinatorName", "combinatorPath", "destinationsPoint", "restinationHalf", "constinationPath", "constinatorContext", "destinatingName", "destributionDir", "destinerDir", "destinationTime", "restinatorHalf", "destiningContext", " destinationAuth", "DestinatingPath", "destinatorDir", "tempinatedPath", " destificationAuth", "distinationpath", "destinatedPath", "distinationCry", "combinatorHandler", "distributionpath", "distinatorName", " destificationDir", "datinationLocation", "constinatorWidth", "destinateTime", "DestificationPart", "restinatorString", "distinatorCase", "destinationLocation", "distinationDir", "destinationDir", "DestificationName", "destinatePoint", "destinatorHandler", "destinatorHalf", "destplingUrl", "destributionPath", "destinatingLocation", "destcreationUrl", "DestinationPath", "desticationStep", "destinerContext", "desticationName", "distinatorCry", "destinationKey", " destificationPath", "destinatedKey", "destationTime", "DestinationText", "constinatorDir", "combinatorpath", "constinationDir", "destinatingText", "distinationName", "constinationpath", "destiningName", "constinationsPath", "restinationPath", "destiningPath", "combinationHandler", "destributionpath", "distinatorPath", "constinationsName", "restificationpath", "destensionText", "destinationStep", "destinationPart", "destinatorWidth", "destificationPart", "desturationHandler", "destinateHalf", "destinatorTime", "constinationPoint", "distinationKey", "DestinatingText", "DestinationName", "destiningPoint", "destinatorLocation", "destinationLog", "distinationFile", "destationLocation", "destificationPoint", "datinatePath", "DestinationPoint", "distributionPath", "destinerpath", "distinationPath", "constinationspath", "destinationPoint", "destinatorKey", "destignmentName", "destinatingPoint", "destinationString", "combinationpath", "DestinatingPoint", "destiningpath", "destificationDir", "tempinationDir", "destinatedStep", "distributionDir", "distinatorFile", "destcreationWidth", "destinationHalf", "destinatorContext", "tempinatedHalf", "destinatorCry", "destignmentCry", "destinationCry", "datinateLocation", "restificationLocation", "datinatepath"], "in": ["r", "image", "n", "i", "input", "ex", "din", "t", "cache", "connection", "con", "x", "min", "doc", "data", "ins", "name", "bin", "In", "reader", "IN", "d", "source", "config", "c", "inc"], "out": ["Out", "error", "ne", "client", "writer", "obj", "msg", "full", "all", "up", "key", "output", "comment", "user", "version", "free", "write", "parent", "copy", "cli", "page", "ex", "cache", "server", "conn", "group", "state", "result", "connection", "path", "index", "io", "pool", "line", "manager", "file", "str", "post", "part", "store", "prefix", "lib", "o", "exec", "doc", "Output", "session", "err", "with", "temp", "log", "w", "name", "bin", "again", "string", "list", "point", "sys", "outer", "outs", "gen", "lock", "dump", "source", "OUT"], "root": ["r", "query", "tree", "pattern", "instance", "cat", "parent", "id", "include", "json", "cache", "history", "module", "format", " result", "index", "graph", "path", "params", "modules", "resources", "results", " roots", "roots", "_", "xml", "options", "url", "loader", "values", "collection", "transform", "node", "Root", "meta"]}}
{"id1": "647224", "id2": "16142024", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"uploadFile": ["Uploadfile", "processFiles", "uploadDir", "processDir", "processFile", "UploadFile", " uploadDir", "UploadDir", "UploadFiles", " uploadFiles", "processfile", "uploadfile", "uploadFiles", " uploadfile"], "inputFile": ["targetFiles", " inputType", "inputLog", "sourceType", "initialFile", "targetFolder", "inputDir", " inputStream", "sourceStream", "targetDir", "Inputfile", "sourceFolder", " inputFiles", "sourcePage", " inputPage", "targetFilename", "InputDir", "inputPage", "initialStream", "targetfile", "sourceLog", "InputFile", "targetLog", "inputStream", "InputFiles", "InputFolder", "sourcefile", " inputfile", "targetPage", "sourceFile", "inputFiles", " inputFolder", "targetStream", "InputType", "inputFilename", " inputDir", " inputLog", " inputFilename", "inputType", "initialFolder", "inputFolder", "initialFilename", "InputStream", "inputfile"], "targetFile": ["targetName", "targetFiles", "outputDir", "outputName", "inputDir", " targetPlace", "targetDir", " targetLine", "TargetPath", " targetfile", " targetFiles", "Targetfile", "TargetFile", "targetfile", "externalfile", " targetDir", " targetPath", "sourcePath", "targetLine", "sourceDir", "targetPath", "inputPath", "sourceFile", "outputFiles", "externalPath", "externalName", "TargetLine", "TargetFiles", "inputPlace", "outputLine", "TargetDir", "externalFile", "TargetName", " targetName", "sourcePlace", "targetPlace", "outputPath"], "outputFile": ["OutputFile", " outputDir", "targetFiles", "outputDir", "outputStream", "outputFolder", "writeStream", " targetDirectory", "inputDir", "outFolder", " outputStream", "OutputFolder", " targetFiles", " outputDirectory", " outputfile", " outputFiles", "inputPage", "targetQueue", "outputUrl", "targetfile", "outputPage", "outFile", "OutputDir", "writeUrl", " targetQueue", "inputStream", "outDirectory", "targetPath", " outputPlace", "inputPath", "outputPlace", "inputFiles", " outputFolder", " outputPath", "currentFolder", "outputFiles", "outputfile", "writeFile", "targetDirectory", " outputPage", " outputUrl", "inputUrl", "outfile", "inputDirectory", "outPath", "currentPlace", "outPlace", "outputDirectory", "inputQueue", "currentFile", "outputQueue", "currentfile", "Outputfile", "writePage", "inputFolder", "inputfile", "outputPath"], "in": ["url", "ins", "din", "reader", "IN", "login", "bin", "id", "io", "inc", "isin", "sub", "ini", "input", "issue", "In", "s", "inner", "stream", "err", "read", "i", "r", "again", "rec", "pull", "diff", "nin", "win", "inn", "pin", "is", "lin", "data", "up", "cin", "init", "inside", "kin", "source", "rin", "pass", "con", "ac", "serv"], "out": ["sys", "ger", "net", "exec", "base", "error", "OUT", "console", "outs", "cache", "client", "output", "bin", "io", "inc", "one", "log", "conn", "state", "s", "cmd", "inner", "ext", "to", "lock", "err", "write", "off", "image", "this", "Out", "plain", "writer", "print", "report", "user", "r", "ex", "n", "again", "o", "println", "co", "sync", "table", "outer", "by", "point", "copy", "page", "data", "file", "up", "source", "dump", "inter"], "line": ["url", "lc", "base", "header", "error", "job", "e", "le", "log", "row", "string", "name", "Line", "lines", "word", "range", "lock", "write", "link", "code", "LINE", "type", "pe", "rule", "block", "sync", "buffer", "lf", "page", "lin", "data", "entry", "char", "inline", "file", "limit", "frame", "pass", "split", "unit", "ine", "part", "comment", "cell"], "bytes": ["classes", "outs", "groups", "Bytes", "eps", "cycles", "seconds", "steps", "zip", "ines", "es", "odes", "length", "values", "s", "lines", "ls", "binary", "len", "tes", "files", "bps", "os", "code", " lines", "ones", "words", "comments", "items", "i", "count", "rows", "number", "bits", "blocks", "les", "ips", "pages", " cycles", "units", "pos", "reads", "bs", "size", "codes"]}}
{"id1": "13362846", "id2": "15445861", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"setContenu": ["setTenuit", "setTonenu", "setContenues", "setContineues", "setContineuer", "setTonenues", "setTenu", "setContennues", "setContineuit", "setTonenuer", "setContonenuer", "setContenuer", "setTenuer", "setContineu", "setContonenuit", "setContennu", "setContennuit", "setContonenues", "setTonenuit", "setContenuit", "setContonenu", "setTenues", "setContennuer"], "contenuFichier": ["contenuPrefichiers", "contenuFocher", "contenuPFochier", "contenuFrenchier", "contenuMichier", "contenuFaffier", "contenuTichiere", "contenuMrenchiere", "contenuMaffiere", "contenuFrenchiers", "contenuMichiers", "contenuFochiere", "contenuPFicher", "contenuMaffie", "contenuMaffieri", "contenuFchery", "contenuPrefaffie", "contenuFicheiere", "contenuPrefichier", "contenuFochie", "contenuPrefaffier", "contenuTicheery", "contenuMrenchique", "contenuFaffie", "contenuFichery", "contenuFicherer", "contenuFicoyer", "contenuFrenchery", "contenuFactoryiere", "contenuFicier", "contenuFaffiers", "contenuFicheique", "contenuFicheer", "contenuPFichique", "contenuPhichiere", "contenuFichtique", "contenuFichtiere", "contenuPrefaffiere", "contenuFichiers", "contenuFrenchoyer", "contenuFrenchie", "contenuPhichoyer", "contenuTicheiere", "contenuPrefichiere", "contenuTichery", "contenuFicher", "contenuPhactoryiere", "contenuPFochiere", "contenuPrefaffiers", "contenuFrenchique", "contenuFichtier", "contenuFaffieri", "contenuFrencherer", "contenuMaffier", "contenuFichoyer", "contenuTicheier", "contenuPhichier", "contenuPFichier", "contenuFiciere", "contenuFactoryie", "contenuFochiers", "contenuTicheerer", "contenuMichiere", "contenuFicheerer", "contenuFcherer", "contenuMichie", "contenuFichique", "contenuPhactoryoyer", "contenuFichie", "contenuMaffiers", "contenuTichier", "contenuMrenchie", "contenuFichtie", "contenuFaffiere", "contenuFaffer", "contenuFchier", "contenuMrenchier", "contenuFochier", "contenuFicie", "contenuFchiere", "contenuFaffique", "contenuMichieri", "contenuFichieri", "contenuFichiere", "contenuFrenchiere", "contenuFicheie", "contenuFicheieri", "contenuPhichie", "contenuTicherer", "contenuFicheery", "contenuFactoryoyer", "contenuMichique", "contenuPhactoryie", "contenuFactoryier", "contenuPhactoryier", "contenuPrefichie", "contenuFicheier", "contenuFichtieri", "contenuPFocher", "contenuPFochique", "contenuPFichiere", "contenuFochique"], "fichierElectronique": ["fichierAustrolique", "fichierCentornier", "fichierAdministronistic", "fichierElectron\u00e9e", "fichierElectromical", "fichierElectroneiques", "fichierElectronistic", "fichierElectronsique", "fichierElectaronique", "fichierElectonlique", "fichierElectronsie", "fichierAustroniere", "fichierElectoloniques", "fichierElectrolique", "fichierAdministronsie", "fichierElectronsiques", "fichierElectolonique", "fichierElectronsiere", "fichierElectroneie", "fichierElectpronique", "fichierElectronlique", "fichierAdministronical", "fichierElectaronier", "fichierAdministronique", "fichierElectornier", "fichierElectromique", "fichierElectrolier", "fichierElectromiques", "fichierElectronelique", "fichierElectonique", "fichierAdministronie", "fichierElectronslique", "fichierElectornique", "fichierAustronique", "fichierElectroniques", "fichierElectronica", "fichierAustroliere", "fichierAdministronlique", "fichierCentornique", "fichierAdministronslique", "fichierElectronsica", "fichierAdministronsique", "fichierAustrolier", "fichierElectronsical", "fichierElectolonica", "fichierCentronier", "fichierElectoloniere", "fichierAdministronier", "fichierAdministronsier", "fichierAdministronsical", "fichierElectromistic", "fichierAustroliques", "fichierElectronier", "fichierElectronical", "fichierElectpronistic", "fichierElectroneique", "fichierCentronique", "fichierElectrolie", "fichierCentornlique", "fichierElectorniques", "fichierAdministronsistic", "fichierElectrol\u00e9e", "fichierElectpronical", "fichierElectproniques", "fichierElectonier", "fichierCentroniques", "fichierElectornlique", "fichierElectronsistic", "fichierElectrons\u00e9e", "fichierAdministron\u00e9e", "fichierAdministroniques", "fichierElectaronie", "fichierElectaron\u00e9e", "fichierElectroneiere", "fichierElectronsier", "fichierAustronier", "fichierAdministrons\u00e9e", "fichierCentronlique", "fichierAdministronsiques", "fichierElectroniere", "fichierElectrolica", "fichierElectronie", "fichierCentorniques", "fichierAustroniques", "fichierElectroliques", "fichierElectroliere", "fichierElectonie", "fichierElectroneier"], "utilisateurCourant": ["utilisateurParticipants", "utilisationApplicants", "utilisateurParticipante", "utilisationCourante", "utilisationApplicateur", "utilisateurApplicant", "utilisateurParticipant", "utilisationCourateur", "utilisateurApplicante", "utilisateurGovernant", "utilisationApplicant", "utilisationCourant", "utilisateurCourateur", "utilisateurCourante", "utilisateurGovernateur", "utilisateurGovernante", "utilisateurCourants", "utilisationCourants", "utilisateurParticipateur", "utilisationApplicante", "utilisateurApplicants", "utilisateurApplicateur", "utilisateurGovernants"], "support": ["services", "push", "Support", "info", "know", "accept", "Library", "settings", " Support", "document", "system", "library", "concept", "util", "client", "friend", "allow", "protection", "respect", "cover", "proxy", "facebook", "media", "feature", "evidence", "config", "best", "share", "supp", "bank", "control", "plugin", "format", "knowledge", "force", "ann", "compatible", "supported", "pull", "review", "summary", "contact", "help", "utils", "pport", "service", "storage"], "ficheDocument": ["friquedocument", "FcheContent", "ficheDoc", "inficheDocument", "fchadocument", "enfoiceDocument", "fchaDocument", "enficheCompany", "fcheMatrix", "fraudDocument", "afficheDoc", "inficheNumber", "infraudDoc", "friqueDoc", "fraudCatalog", "inficheDoc", "fcheDocuments", "infraudDocument", "fraudCompany", "fcheDocument", " fcheMatrix", " ficheDocuments", "foiceDirectory", "fagueDirectory", "financeNumber", "fielCompany", "fielDirectory", "affineFeature", "foinedocument", "affichedocument", "affinedocument", "fruitNumber", "afficheDocument", "infraudNumber", "facheMatrix", "friqueDocument", "FcheDoc", "foineFeature", "ficheNumber", "afficheFeature", "enfoiceCatalog", "ficheFeature", "fetchDoc", "FicheContent", "fetchFeature", "fchaContent", " ficheMatrix", "friqueContent", "ficheCompany", "fielCatalog", "facheDocument", "fcheDirectory", "enfoiceDirectory", "fetchdocument", "fineDocument", "fagueDocuments", "facheDocuments", "fichedocument", "enficheDocument", "fagueMatrix", "affineDoc", "financedocument", "fielDocument", "fchaDoc", "infichedocument", "facheDirectory", "Fichedocument", "finedocument", "fineDoc", "foiceDocument", "FicheDoc", "ficheCatalog", " ficheDirectory", "foiceCompany", "ficheDirectory", " fcheDocument", "financeDocument", "ficheContent", "fraudDirectory", "enficheDirectory", "fruitdocument", "FcheDocument", "fraudDoc", "infrauddocument", "fruitDocument", "fineFeature", "foiceCatalog", "fcheContent", "foineDocument", "fchedocument", " fcheDirectory", "Fchedocument", "fruitDoc", "FicheDocument", "ficheMatrix", "frauddocument", " fcheDocuments", "foineDoc", "fetchDocument", "fagueDocument", "enficheCatalog", "enfoiceCompany", "fraudNumber", "fcheDoc", "ficheDocuments", "financeDoc", "affineDocument"], "nomFichier": ["nomFchy", "nomVichieri", "nomPichier", "nomVich\u00e8re", "nomFichtier", "nomFichtiller", "nomFachire", "nomFrench\u00e8re", "nomNicher", "nomWichery", "nomNichier", "nomFichiner", "nomFachiere", "nomFiqurier", "nomFrenchier", "nomFchien", "nomWichier", "nomFichtieri", "nomFochier", "nomPhichiere", "nomFichterer", "nomPchy", "nomFichery", "nomPhichieri", "nomVchieri", "nomWichire", "nomFiquier", "nomFachiller", "nomFchieri", "nomFch\u00e8re", "nomFitherer", "nomVicher", "nomNichter", "nomF\u00e9tier", "nomFachieri", "nomFichy", "nomPrefichier", "nomFichtiner", "nomFiquire", "nomFisciller", "nomF\u00e9tery", "nomPhichier", "nomPrefichieri", "nomPhachieri", "nomPrefichire", "nomPrefchieri", "nomFachier", "nomFicher", "nomPchier", "nomNichtier", "nomFichire", "nomPichy", "nomFiscier", "nomFisciner", "nomFicherer", "nomPchien", "nomFochire", "nomFichrier", "nomVch\u00e8re", "nomFiscer", "nomVcher", "nomFich\u00e8re", "nomFichien", "nomPhacherer", "nomFachiner", "nomFacher", "nomF\u00e9ty", "nomNichiller", "nomPichery", "nomPhachiere", "nomFichieri", "nomWchiere", "nomVichier", "nomPrefchrier", "nomWchire", "nomNichtiner", "nomFchery", "nomF\u00e9tien", "nomFachrier", "nomPhachier", "nomFrencher", "nomVchier", "nomFichtery", "nomFichter", "nomWichiere", "nomFcher", "nomWchery", "nomPchery", "nomFchiere", "nomPrefchier", "nomFichiller", "nomNichtiller", "nomWchier", "nomFach\u00e8re", "nomPrefchire", "nomPhicherer", "nomFiscien", "nomFithier", "nomFithiere", "nomNichiner", "nomPichien", "nomFochery", "nomFiquieri", "nomFichtiere", "nomFithieri", "nomFichiere", "nomFiscy", "nomPrefichrier", "nomFchier", "nomFchire", "nomFchrier", "nomFacherer", "nomFochiere", "nomFichtire", "nomFiscery", "nomFrenchieri"], "extension": ["encension", "extion", "Extception", "exion", "encception", "anchensions", "encression", "exression", "EXTime", "anchension", "Extression", "encion", "exception", "extception", "EXTensions", "exension", "EXTension", "Extension", "extime", "Extensions", "extensions", "Extime", "extression", "Extion", "anchime"], "fichierElectroniqueExistant": ["fichierElectroniquesXclusive", "fichierElectroniqueXivist", "fichierElectroniqueExplists", "fichierElectroniqueXistance", "fichierElectroniqueexistant", "fichierElectroniquesXistent", "fichierElectroniqueExistance", "fichierElectroniqueexists", "fichierElectroniqueexclusive", "fichierElectroniquesExistant", "fichierElectroniquesXivist", "fichierElectroniqueSistent", "fichierElectroniqueSistant", "fichierElectroniqueExists", "fichierElectroniqueXistant", "fichierElectroniquesExilingual", "fichierElectroniquesExistent", "fichierElectroniqueexistance", "fichierElectroniquesXistant", "fichierElectroniqueexist", "fichierElectroniqueExplist", "fichierElectroniqueSilingual", "fichierElectroniqueExistent", "fichierElectroniqueXists", "fichierElectroniqueXistent", "fichierElectroniquesXists", "fichierElectroniquesExivist", "fichierElectroniqueXilingual", "fichierElectroniquesExclusive", "fichierElectroniquesXilingual", "fichierElectroniqueSistance", "fichierElectroniquesExist", "fichierElectroniquesExists", "fichierElectroniquesXistance", "fichierElectroniqueexivist", "fichierElectroniqueexilingual", "fichierElectroniquesExistance", "fichierElectroniqueExist", "fichierElectroniqueExplistance", "fichierElectroniqueExilingual", "fichierElectroniqueExplivist", "fichierElectroniqueXist", "fichierElectroniqueexistent", "fichierElectroniqueExclusive", "fichierElectroniqueXclusive", "fichierElectroniqueExplistant", "fichierElectroniqueExplclusive", "fichierElectroniqueExivist", "fichierElectroniquesXist"], "idIgid": ["idIogids", "idUgid", "idIogbit", "idIgudid", "idIgmids", "idIgmname", "idIgdid", "idIgubit", "idIgenname", "idUguids", "idIguname", "idIogdid", "idIgenid", "idIgnids", "idIGid", "idIguID", "idIgnid", "idEGid", "idIguod", "idUguname", "idIggid", "idEgid", "idIgenids", "idIgids", "idIggod", "idEGids", "idIggID", "idUgname", "idUgID", "idIgID", "idIgbit", "idEGbit", "idIgname", "idIgnID", "idIGdid", "idEgbit", "idIGbit", "idIgenID", "idUguid", "idIgod", "idUguID", "idIguid", "idIogid", "idIgmID", "idIggids", "idEGdid", "idUgids", "idIGids", "idIgnod", "idEgids", "idIgmid", "idEgdid", "idIguids"], "inputStream": ["eventSteam", "InputThread", "eventstream", "inputStreamer", "outputLength", "InputStreamer", "outputSteam", "InputLength", "inputSteam", " inputThread", "eventStreamer", "inputThread", " inputstream", "inputLength", "outputstream", " inputSteam", "outputStreamer", "outputThread", " inputLength", "Inputstream", "inputstream", "InputSteam", "InputStream", "eventStream"], "outputStream": ["inputStreamer", "entityStream", "officeStream", "outputSteam", "inputSteam", "OutputContext", "OutputStreamer", "Outputstream", "entitySteam", " outputstream", "officeSteam", "OutputSteam", "outputstream", "outputStreamer", "OutputStream", " outputContext", "officestream", "outputContext", "inputContext", "officeStreamer", "entitystream", "entityStreamer", " outputSteam", "inputstream"], "typeMime": ["TypeMide", "TypeSmimes", "typeMangle", "TypeSmangle", "typeSmangle", "typeMatimes", "typeSmimes", "TypeMime", "typeMatime", "typeMimes", "TypeSmide", "TypeMangle", "typeMide", "typeMatangle", "typeSmide", "typeMetime", "typeMetimes", "TypeMimes", "typeMetide", "TypeSmime", "typeMetangle", "typeMatide", "typeSmime"], "tailleFichier": [" tailleFichiers", " tailleFigner", " taillefichie", " tailleFicheiers", " tailleFocher", " tailleFicheer", " tailleFignier", " tailleFicheie", " tailleFignie", " tailleFochie", " taillefochier", " taillefochiers", " taillefichiers", " tailleFochier", " tailleFigniers", " tailleFichie", " tailleficher", " taillefochie", " tailleFochiers", " tailleFicheier", " tailleFicher", " taillefichier", " taillefocher"]}}
{"id1": "19910627", "id2": "17947247", "code1": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "code2": "    public String postURL(String urlLocation, ArrayList headers, String content, HashMap postVariables, RenderEngine c) throws Exception {\n        String postContent = null;\n        if (postVariables != null) {\n            boolean firstElement = true;\n            postContent = new String();\n            Iterator elements = postVariables.keySet().iterator();\n            while (elements.hasNext()) {\n                String key = (String) elements.next();\n                String val = (String) postVariables.get(key);\n                if (firstElement) {\n                    postContent += Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                    firstElement = false;\n                } else {\n                    postContent += \"&\" + Encoder.URLEncode(key) + \"=\" + Encoder.URLEncode(val);\n                }\n            }\n            elements = null;\n        } else {\n            postContent = content;\n        }\n        Debug.log(\"Connecting to URL '\" + urlLocation + \"', content '\" + postContent + \"'\");\n        URL url = null;\n        try {\n            url = new URL(urlLocation);\n        } catch (MalformedURLException e) {\n            Debug.log(\"Unable to retrieve URL '\" + urlLocation + \"': \" + e.getMessage());\n            return null;\n        }\n        StringBuffer lines = new StringBuffer();\n        HttpURLConnection conn = null;\n        boolean contentLengthFound = false;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            loadCookies(urlLocation, conn, c);\n            if (headers != null) {\n                for (int i = 0; i < headers.size(); i++) {\n                    String header = (String) headers.get(i);\n                    String key = header.substring(0, header.indexOf(\":\"));\n                    String value = header.substring(header.indexOf(\":\") + 2);\n                    if (key != null && key.equalsIgnoreCase(\"content-length\")) {\n                        contentLengthFound = true;\n                    }\n                    Debug.log(\"Adding new request header '\" + key + \"'='\" + value + \"'\");\n                    conn.setRequestProperty(key, value);\n                }\n            }\n            if (!contentLengthFound) {\n                Debug.log(\"Adding new request header 'Content-Length'='\" + postContent.length() + \"'\");\n                conn.setRequestProperty(\"Content-Length\", Integer.toString(postContent.length()));\n            }\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(postContent);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                lines.append(line);\n                lines.append(\"\\r\\n\");\n            }\n            handleHeaders(urlLocation, conn.getHeaderFields());\n            wr.close();\n            rd.close();\n            wr = null;\n            rd = null;\n        } catch (IOException e) {\n            if (conn != null) {\n                lines = new StringBuffer();\n                try {\n                    throw new Exception(\"Server returned error code '\" + conn.getResponseCode() + \"': \" + conn.getResponseMessage());\n                } catch (IOException ee) {\n                    throw new Exception(\"Unable to report error codes: \" + ee.getMessage());\n                }\n            }\n            Debug.log(\"I/O Exception occurred while communicating with endpoint: \" + e.getMessage());\n            return lines.toString().trim();\n        } catch (Exception e) {\n        }\n        url = null;\n        conn = null;\n        return lines.toString().trim();\n    }\n", "label": 0, "substitutes": {"getData": ["readData", "printData", "readContent", "printdata", "getFeed", "postFeed", "postData", "postContent", "getContent", "postdata", "printContent", "getdata", "readFeed", "readdata", "printFeed"], "httpclient": [" httpClient", "httpserver", " httpconnection", "httpscache", "phpconnection", "httpsserver", "phpClient", "Httpserver", "ttpcache", "ttpserver", "ttpClient", "phpserver", "HttpClient", "Httpconnection", "httpClient", "httpconnection", " httpserver", "Httpclient", "httpsclient", "httpcache", "phpclient", " httpcache", "ttpclient", "httpsClient"], "get": ["full", "open", "start", "it", "g", "method", "put", "create", "body", "handle", "remote", "send", "ge", "enable", "load", "find", "set", "base", "add", "check", "query", "single", "e", "client", "pull", "service", "i", "call", "init", "show", "parse", "api", "build", "request", "Get", "like", "write", "exec", "GET", "update", "read", "make", "http", "resource", "json", "generic", "use", "invoke"], "response": ["connection", "data", "ception", "error", "respond", "body", "application", "event", "received", "Response", "status", "page", "output", "success", "collection", "e", "client", "reply", "feed", "api", "request", "document", "server", "http", "message", "result", "resource", "out", "report", "onse", "json", "resp"], "entity": ["connection", "data", "issue", "el", "body", "em", "application", "event", "xml", "activity", "component", "output", "content", "article", "collection", "e", "client", "image", "Entity", "api", "media", "object", "environment", "document", "server", "unit", "pe", "person", "http", "file", "ce", "message", "resource", "result", "json", "ent", "element"], "instream": ["inputform", " inchannel", "inprogress", "outstream", "insfile", "infile", "outfile", "Inchannel", "outStream", "InStream", "inchannel", "Instream", "inform", "outchannel", "Inprogress", "outprogress", "inputprogress", " inStream", "insStream", " infile", " inform", "inschannel", "insstream", "outform", "Inform", "inputStream", "inStream", "inputstream", "Infile"], "responseMessage": [" responsemessage", "respondContent", "respondmessage", "ResponseMessage", "respondMessage", "respondBody", " responseContent", "ResponseBody", "responseBody", "Responsemessage", " responseBody", " responseMsg", "responseMsg", "respondMsg", "responsemessage", "ResponseContent", "responseContent", "ResponseMsg"]}}
{"id1": "12428013", "id2": "23310397", "code1": "    public static void polishOff(IProgressMonitor monitor, String from, String to, String renameTo) {\n        if (monitor != null && monitor.isCanceled()) {\n            return;\n        }\n        try {\n            ftpClient = new FTPClient();\n            ftpClient.setRemoteAddr(InetAddress.getByName(PrefPageOne.getValue(CONSTANTS.PREF_HOST)));\n            ftpClient.setControlPort(PrefPageOne.getIntValue(CONSTANTS.PREF_FTPPORT));\n            ftpClient.connect();\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            ftpClient.login((PrefPageOne.getValue(CONSTANTS.PREF_USERNAME)), FTPUtils.decrypt(PrefPageOne.getValue(CONSTANTS.PREF_PASSWORD)));\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (from != null) {\n                FTPHolder ftpHolder = new FTPHolder(from, to, renameTo, false);\n                synchedSet.add(ftpHolder);\n            }\n            JobHandler.aquireFTPLock();\n            for (Iterator iter = synchedSet.iterator(); iter.hasNext(); ) {\n                if (monitor != null && monitor.isCanceled()) {\n                    JobHandler.releaseFTPLock();\n                    ftpClient.quit();\n                    return;\n                }\n                Thread.yield();\n                FTPHolder element = (FTPHolder) iter.next();\n                ftpClient.setType(FTPTransferType.ASCII);\n                ftpClient.put(element.from, element.to);\n                if (element.renameTo != null) {\n                    try {\n                        ftpClient.delete(element.renameTo);\n                    } catch (Exception e) {\n                    }\n                    ftpClient.rename(element.to, element.renameTo);\n                    log.info(\"RENAME: \" + element.to + \"To: \" + element.renameTo);\n                }\n            }\n            JobHandler.releaseFTPLock();\n            ftpClient.quit();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (FTPException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        synchedSet.clear();\n    }\n", "code2": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        mButton1 = (Button) findViewById(R.id.myButton1);\n        mButton2 = (Button) findViewById(R.id.myButton2);\n        mTextView1 = (TextView) findViewById(R.id.myTextView1);\n        mButton1.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpPost httpRequest = new HttpPost(uriAPI);\n                List<NameValuePair> params = new ArrayList<NameValuePair>();\n                params.add(new BasicNameValuePair(\"str\", \"post string\"));\n                try {\n                    httpRequest.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n        mButton2.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpGet httpRequest = new HttpGet(uriAPI);\n                try {\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        strResult = eregi_replace(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"\", strResult);\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n", "label": 0, "substitutes": {"polishOff": [" polishingOn", " synchroniceDown", " polishDown", " synchronishOn", " synchronishingOn", " synchronipeDown", " synchroniceOffline", " synchronishOffline", " polishOn", " polishOffline", " synchronishingOffline", " synchronishOff", " synchronishingOff", " polishingOff", " synchronipeOff", " synchroniceOn", " polishingOffline", " synchronipeOffline", " synchroniceOff", " polishingDown", " synchronishDown", " synchronishingDown", " synchronipeOn"], "monitor": ["timeout", "or", "reason", "watch", "status", "username", "container", "pm", "function", "cm", "m", "sm", "method", "state", "condition", "log", "report", "manager", "mor", "match", "number", "driver", "umi", "progress", "conn", "object", "client", "handler", "cher", "unit", "mc", "consumer", "program", "port", "component", "thread", "clock", "config", "loader", "processor", "control", "Monitor", "controller", "period", "don", "callback", "image", "dm", "widget", "stat", "counter", "member", "runner", "directory", "mon", "meter", "module", "annot", "duration", "timer", "message", "update", "oper", "master", "body", "core"], "from": ["resource", "action", "or", "actor", "attribute", "route", "username", "owner", "who", "at", "front", "string", "channel", "host", "false", "with", "From", "about", "path", "vol", "contact", "add", "form", "email", "ce", "user", "address", "loc", "connection", "part", "base", "since", "prefix", "server", "small", "url", "component", "left", "size", "code", "by", "start", "remote", "range", "type", "ou", "id", "back", "source", "uri", "org", "name", "origin"], "to": ["resource", "token", "so", "full", "site", "o", "go", "reply", "table", "version", "with", "about", "io", "key", "dest", "database", "user", "address", "into", "connection", "base", "pos", "TO", "out", "prefix", "two", "server", "url", "location", "To", "left", "size", "eto", "su", "value", "by", "top", "remote", "repl", "until", "range", "type", "target", "po", "info", "uri", "source", "toc", "name", "file", "ref"], "renameTo": ["renAMEto", "renAMEToken", "renameFrom", " RenAMETarget", "renenameto", " renAMETarget", "renenameFrom", "renamelOf", "renributeFor", "relenameto", "renributeTarget", "renseTo", "reameTo", "renAMEWill", "renalFrom", "renenameUrl", "renewTo", " RenseTo", " RenameTO", "relenameFrom", "renamelTO", "renokeTo", "renokeTO", "renalTarget", " RenAMEFor", "renoketo", "reageToken", "renameFor", "renamTo", "relenameTo", "relalto", "renalToken", " RenseFor", " RenameOf", "renokeOf", "relalTarget", " renAMEFrom", "renameto", "relameUrl", "renameWill", "renseOf", "renameOf", "renameToken", "renamWill", "reameTO", " RenameTarget", "relalTo", " RenseTO", " RenAMETo", "relameto", "renAMEUrl", "renAMETO", " renameFrom", "renributeWill", "renokeFrom", "reageTO", "relalFrom", "renamFor", "relameFrom", "renamelFor", "renalTO", "renageTO", "rennameTo", "reameto", "renameTO", "renalTo", " RenseOf", "renameTarget", "renageTo", "reageto", "renenameTo", "renributeTo", "rennameFrom", "renAMEFor", " renAMETo", "renageto", " RenameTo", "renAMEFrom", "renamTarget", "renageToken", "renAMETo", "renewFrom", "relameTarget", "rennameto", "renseFor", "renseTO", "renalto", "renenameTarget", " RenameFor", "renokeFor", "renewTarget", "reameToken", "renAMETarget", "renamelTo", "rennameTarget", "renameUrl", " RenAMEWill", "renokeUrl", "relenameUrl", "reageTo", " renameTarget", "relameTo", " RenameWill"], "ftpClient": [" ftpoCenter", " ftpiHost", " ftoHost", "afttStream", " fttpControl", "ftapiCloud", "ftlCommunity", "fticlient", " ftoClient", " ftnHost", "ftpcHelper", "ftcpHost", "ftpsContainer", "ftpCan", "ftmClient", "ftpoCenter", "ftapiClient", "ftpsControl", "ftpHost", "ftcpResource", "ftcServer", "ftfpResource", " ftlClient", "ftapiServer", "ftpClass", " ftpCan", "ftfpCenter", "ftcpGuest", " ftlCenter", "ftcpServer", "ftpCommunity", " ftpChannel", "ctpClient", "ftlClient", " ftpoCloud", "ftpcCloud", " ftpCloud", "ftpcServer", "ftfpCloud", " ftoCan", "ftfpClient", " ftpclient", " ftlConnection", "ftpHelper", " ftoServer", "ftbHost", "ftcclient", "ftnServer", " ftpGuest", "ctcpChannel", "ftoClient", "ftfCenter", " ftiServer", "ftnHost", "ftpiServer", "fttpStream", " ftapiHelper", "afttClient", "ftoCan", "ctpChannel", "ftlConnection", "fttpCan", "ctpServer", " ftiGuest", "ftiClient", "fttpControl", "ftoHost", "ftbrClient", " ftpControl", "ftfClient", "ftpcConnection", "ftpControl", "ftpiClient", "aftpClient", "ftmResource", "ftpcCommunity", "fttpContainer", "ctcpServer", "fttpClass", "ftpoClient", "ftnClient", " ftnClient", " ftpContainer", " ftlCommunity", "ftpServer", "ftmServer", "ftcpHelper", "ftpResource", "ftcGuest", " fttpClass", "ftpiChannel", " ftpiChannel", "ftpoCloud", "fttpHost", " fttpClient", "ftcpCloud", "ftpContainer", "ftpiHost", "ftpCenter", " fttpContainer", "ftpcContainer", "ftbrStream", "ftpConnection", " ftnServer", "ftoServer", "ftpsClass", "ftpStream", " ftiClient", " ftpConnection", " ftpServer", "ftfpChannel", " ftpiServer", "ftfpServer", "ftfCloud", " ftpiClient", "ctcpClient", "ftbServer", " ftapiClient", "ftlCenter", " ftpHelper", "fttpClient", "ftbClient", "ftpcClient", "fttpChannel", "ftcpChannel", "fttStream", " fticlient", "ftiGuest", "ftbCan", " ftpoClient", "ftpGuest", "ftcClient", " ftpHost", "ftpcClass", "fttpServer", "ftpChannel", " ftpCommunity", " ftapiCloud", "ctcpResource", " ftpCenter", "ftpcCenter", "ftcpClient", " ftapiServer", "ftmChannel", "ftpsClient", "fttClient", "ftpCloud", "ftapiHelper", " ftpClass", "ftcpclient", "ftcpCenter", "ftpclient", "ftcpConnection", "ftcpCommunity", "aftpStream", "ftpcControl", "ctpResource", "ftiServer"], "ftpHolder": ["ftpWorkolder", "ftpcWolder", "fttpChard", "ftphander", "fttpChander", "ftpShard", "ftpShook", "ftpWold", "fttpHook", "ftpcHolder", "ftpHholder", "ftpCholder", "ftphook", "ftpcWather", "ftpWholder", "ftpHook", "ftpcHold", "ftphholder", "ftpHard", "ftphard", "ftpSholder", "ftpWorkather", "ftpHather", "ftpWorkold", "ftpWolder", "ftpChander", "ftpcHholder", "ftpWorkholder", "ftpholder", "fttpCholder", "ftpWather", "ftphold", "ftpcWholder", "ftphather", "ftpChook", "ftpHander", "ftpcHather", "ftpHold", "fttpHander", "fttpHard", "ftpcWold", "fttpHolder", "fttpChook", "ftpChard", "ftpShander"], "iter": ["entry", "or", "ip", "ter", "over", "ir", "inter", "http", "ator", "former", "inner", "limit", "walker", "outer", "ner", "collect", "list", "enter", "in", "skip", "Iterator", "er", "iterator", "cher", "it", "loc", "err", "izer", "ener", "init", "chain", "coll", "ipper", "its", "oper", "index", "f", "ite", "e", "itter", "size", "i", "set", "result", "next", "finder", "ser", "reader", "Iter", "gener", "id", "info", "inc", "ver", "iv", "keep", "file", "end"], "element": ["resource", "container", "environment", "match", "email", "letter", "cell", "definition", "next", "parent", "text", "item", "entry", "or", "expression", "comment", "empty", "this", "atom", "header", "connection", "variable", "per", "air", "value", "editor", "page", "member", "output", "data", "module", "optional", "folder", "attribute", "section", "owner", "entity", "instance", "ee", "node", "content", "er", "part", "document", "coll", "component", "ele", "Element", "reader", "type", "activity", "action", "token", "line", "option", "inner", "service", "input", "layer", "key", "number", "object", "child", "event", "server", "article", "e", "el", "result", "style", "plugin", "et"]}}
{"id1": "4501356", "id2": "932225", "code1": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 1, "substitutes": {"calculateProfileDiffDigest": ["calculateProfileDiffdigests", "calculateProfileDiffCodests", "calculateProfilediffdigest", "calculateProfileDiffdigr", "calculateProfileDiffdigHash", "calculateProfileDiffdigest", "calculateProfilediffdigests", "calculateProfilediffDigHash", "calculateProfileDiffCodest", "calculateProfileDiffCodHash", "calculateProfileDiffDigr", "calculateProfilediffDigr", "calculateProfilediffdigr", "calculateProfileDiffDigests", "calculateProfileDiffMDHash", "calculateProfileDiffMDr", "calculateProfilediffDigest", "calculateProfilediffdigHash", "calculateProfileDiffDigHash", "calculateProfileDiffMDest", "calculateProfileDiffCodr", "calculateProfileDiffMDests", "calculateProfilediffDigests"], "profileDiff": ["messageInfo", "summaryEdit", "settingsDiff", "settingsDelta", "profileDust", "settingsDust", " profileDie", "profileName", "imageDelta", "profdiff", "familyDiff", "summaryInfo", "messagePath", "profPath", "imageDiff", "styleInfo", "pictureInfo", "styleName", "messagediff", "pictureName", " profileInfo", "picturediff", " profileName", "settingsDie", "familyInf", "familyEdit", "profileDie", " profileDust", "profilePath", "profileInf", "stylediff", "profDiff", "familyInfo", "imageDust", " profileDelta", " profilediff", "profInfo", " profilePath", "profileInfo", "profileDelta", "pictureDiff", "imageDie", "profileEdit", "summaryInf", "summaryDiff", "styleDiff", " profileInf", " profileEdit", "profilediff", "messageDiff"], "normaliseWhitespace": ["normaliseWhitesSpace", "normaliseWhipesspace", "normaliseWhpacepace", "normaliseWhpacespaces", "normaliseWitespace", "normaliseWhipspaces", "normaliseWpacespace", "normaliseWhickspace", "normaliseWhickspaced", "normaliseWhipespaces", "normaliseWhipspace", "normaliseWitespaces", "normaliseWhpacesspace", "normaliseWhitesspace", "normaliseWpacespaced", "normaliseWhipespaced", "normaliseWhickspaces", "normaliseWpacesSpace", "normaliseWhipespace", "normaliseWhpacespace", "normaliseWpacespaces", "normaliseWhpacespaced", "normaliseWhpaceSpace", "normaliseWhitespaces", "normaliseWhitespaced", "normaliseWpacesspace", "normaliseWitesspace", "normaliseWhipsspace", "normaliseWhpacesSpace", "normaliseWhpacepaces", "normaliseWitespaced", "normaliseWitesSpace", "normaliseWhipsSpace", "normaliseWhicksspace"], "md": ["ds", "mad", "m", "rm", "hd", "sd", " MD", "Cmd", "message", "b", "mp", "sha", "cmd", "msg", "dig", "dd", "gd", "f", "hash", "editor", "mc", "mag", "d", "od", "mb", "wd", "meta", "me", "amd", "mg", "dm", "bd", "bf", "metadata", "pd", "MD", "db", "mac", "mand", "mm", "ma", "pm", "diff", "mt", "cd", "df"]}}
{"id1": "13421722", "id2": "13362846", "code1": "    public static long getFileSize(String address) {\n        URL url = null;\n        try {\n            url = new URL(address);\n            System.err.println(\"Indirizzo valido - \" + url.toString().substring(0, 10) + \"...\");\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Indirizzo non valido!\");\n        }\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=0-\");\n            connection.connect();\n            return connection.getContentLength();\n        } catch (IOException ioe) {\n            System.err.println(\"I/O error!\");\n            return 0;\n        }\n    }\n", "code2": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getFileSize": ["getByteSize", " getfileInfo", "getFileBytes", " getfileBytes", "getFilesSize", "getFileLength", "getFilesBytes", "getByteBytes", " getFileBytes", "getfileLength", "getfileBytes", "getFileInfo", "getByteInfo", "getByteLength", " getfileLength", " getFileInfo", " getFileLength", "getfileSize", "getFilesLength", "getFilesInfo", " getfileSize", "getfileInfo"], "address": ["resource", "attribute", "route", "ip", "position", "string", "host", "Address", "request", "str", "path", "report", "number", "network", "email", "object", "content", "base", "prefix", "port", "server", "addr", "location", "config", "size", "array", "code", "localhost", "format", "output", "type", "data", "point", "target", "message", "offset", "uri", "source", "name", "reference"], "url": ["resource", "ob", "string", "channel", "host", "http", "xml", "str", "proxy", "service", "www", "URL", "path", "ll", "log", "ur", "api", "feed", "io", "Url", "impl", "object", "conn", "user", "orb", "bug", "loc", "lr", "build", "l", "base", "server", "location", "config", "sl", "f", "e", "session", "image", "lib", "socket", "page", "ssl", "html", "result", "found", "job", "web", "uri", "client", "org", "file"], "connection": ["resource", "or", "application", "entry", "use", "section", "function", "position", "c", "Connection", "channel", "current", "context", "environment", "request", "http", "proxy", "character", "service", "condition", "response", "con", "io", "open", "database", "relation", "conn", "object", "handler", "out", "event", "communication", "server", "config", "bc", "control", "session", "wrapper", "connect", "socket", "to", "connected", "info", "uri", "client", "collection", "version", "reference"]}}
{"id1": "18374598", "id2": "471804", "code1": "    private synchronized File download() throws AMSpacksException {\n        String a = addr.url.toExternalForm();\n        int p = a.lastIndexOf('/');\n        if (p < 0) {\n            p = a.lastIndexOf('\\\\');\n        }\n        if (p < 0) {\n            a = \"\" + Math.random();\n        } else {\n            a = a.substring(p + 1);\n        }\n        File td = null;\n        try {\n            td = File.createTempFile(a, \"\").getParentFile();\n        } catch (IOException ex) {\n            td = new File(\".\");\n        }\n        File f = new File(td, a);\n        td.delete();\n        long total = addr.update.getSize();\n        int progress = 0;\n        try {\n            InputStream in = new BufferedInputStream(addr.url.openStream());\n            FileOutputStream out = new FileOutputStream(f);\n            byte[] buf = new byte[500];\n            int n;\n            long percentage = 0;\n            callback.updateProgress(percentage);\n            do {\n                n = in.read(buf);\n                if (n > 0) {\n                    out.write(buf, 0, n);\n                    progress += n;\n                    long tmpPercentage = progress * 100 / total;\n                    if (percentage != tmpPercentage) {\n                        percentage = tmpPercentage;\n                        callback.updateProgress(percentage);\n                    }\n                }\n            } while (n > 0);\n            in.close();\n            out.flush();\n            out.close();\n        } catch (Exception ex) {\n            f.delete();\n            throw new DownloadFailedException(\"Error downloading update.\", ex);\n        }\n        long size = f.length();\n        String checksum = CheckSumFinder.checkSum(f);\n        if (size == addr.update.getSize() && checksum.equalsIgnoreCase(addr.update.getChecksum())) return f; else {\n            f.delete();\n            throw new CheckSumMismathchException(\"Checksum mismatch: \" + addr.update.getChecksum() + \" expected but was \" + checksum);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"download": ["pull", "external", "string", "copy", "open", "archive", "Download", "release", " Download", "install", "setup", "upload", "exec", "url", "get", "load", "loader", "dump", "filename", "transfer", "output", "diff", "data", "write", "update", "name", "file"], "a": ["an", "action", "fa", "aux", "u", "ua", "za", "c", "string", "m", "qa", "ca", "access", "asa", "oa", "area", "A", "input", "na", "da", "about", "as", "cha", "au", "api", "at", "aa", "wa", "sa", "la", "ppa", "ac", "ada", "ad", "aaa", "alpha", "audio", "l", "ha", "amp", "s", "base", "ea", "pa", "url", "addr", "ga", "aw", "ast", "ma", "array", "sta", "af", "e", "am", "i", "auto", "tta", "ae", "data", "r", "b", "t", "ba", "ata", "ab", "va", "name", "art", "file"], "p": ["ap", "ping", "dp", "ip", "u", "c", "pr", "pi", "py", "m", "y", "op", "o", "d", "pat", "after", "api", "np", "pp", "bp", "tp", "l", "part", "w", "pos", "pe", "cp", "pa", "j", "sp", "x", "e", "i", "pre", "q", "start", "h", "fp", "v", "P", "jp", "po", "b", "t"], "td": ["fa", "dc", "det", "txt", "fr", "pc", "pd", "fc", "od", "th", "pb", "dat", "table", "sf", "d", "dl", "aff", "fd", "bd", "pt", "TD", "rt", "cf", "ppa", "ht", "tr", "tn", "hd", "dd", "ld", "ff", "tf", "tif", "cd", "gb", "ud", "dh", "tmp", "dt", "sb", "nd", "af", "fm", "fp", "tl", "file", "elt", "sd", "b", "fb", "t", "lf", "tt", "rd", "buff", "bt", "db", "tc"], "f": ["fa", "df", "fe", "F", "fc", "u", "of", "function", "g", "c", "m", "full", "o", "sf", "d", "fo", "fx", "aff", "fast", "fd", "feed", "cf", "fam", "fold", "handler", "fn", "fs", "l", "ff", "tf", "fw", "base", "w", "j", "fi", "flat", "e", "fm", "i", "uf", "xf", "h", "fp", "fen", "v", "file", "fl", "r", "b", "fb", "t", "bf", "lf", "info", "buffer", "form", "fr", "rf"], "total": ["temp", "done", "local", "percent", "Total", "full", "otal", "current", "sum", "cost", "partial", "post", "doc", "active", "json", "length", "num", "count", "valid", "reported", "scale", "quant", "normal", "base", "all", "upload", "server", "max", "complete", "now", "serial", "set", "ok", "used", "start", "finished", "nt", "next", "error", "last", "info", "parent", "available", "recent"], "progress": ["rss", "resource", "Progress", "done", "status", "c", "current", "step", "rec", "dist", "path", "cost", "partial", "np", "process", "number", "skip", "active", "length", "summary", "num", "content", "conn", "roll", "count", "err", "grade", "resp", "running", "scale", "coll", "wait", "complete", "bar", "xp", "success", "next", "error", "vance", "width", "recent"], "in": ["In", "again", "c", "ini", "IN", "cin", "o", "din", "inner", "bin", "input", "as", "con", "io", "pin", "ins", "ac", "inn", "ie", "kin", "l", "isin", "init", "win", "lin", "url", "gin", "i", "nin", "socket", "v", "login", "reader", "data", "vin", "r", "b", "inc", "source", "stream"], "out": ["ch", "line", "again", "full", "c", "cache", "o", "ex", "call", "inner", "bin", "Out", "log", "io", "outs", "co", "ins", "conn", "fn", "err", "up", "w", "s", "exec", "url", "code", "off", "callback", "to", "extra", "cb", "v", "ext", "output", "error", "data", "obj", "b", "inc", "conf", "parent", "buffer", "update", "client", "file", "flow"], "buf": ["grab", "bh", "auc", "cv", "area", "bin", "box", "queue", "pad", "cf", "seq", "bp", "header", "loc", "br", "bag", "ff", "rc", "cmd", "tmp", "bc", "uno", "pkg", "uf", "cap", "callback", "uc", "bytes", "fp", "cb", "v", "border", "data", "raw", "feat", "Buff", "b", "fb", "buff", "ba", "bf", "buffer", "wb", "rb", "padding"], "n": ["nb", "nit", "not", "u", "N", "g", "m", "current", "c", "o", "d", "node", "dn", "np", "z", "none", "number", "nn", "network", "skip", "num", "length", "no", "nr", "min", "nor", "count", "fn", "br", "l", "ng", "net", "w", "pos", "cn", "j", "coll", "sn", "x", "non", "e", "len", "ns", "i", "rn", "ne", "v", "error", "r", "b", "en", "nc", "un"], "percentage": ["variity", "poundure", "latay", "Percentage", "variide", "metay", " percentages", "percentay", "Percentager", "percentile", "metages", "metage", "latide", "variage", "percentrage", "parage", "percentager", "percentity", "poundages", "latage", "Percenture", "compide", "pardages", "Percentages", "poundage", "metile", "pardure", "pardability", "metency", " percentile", "poundability", "pardage", "missay", "variile", "parages", "percentability", "voltage", "missile", "missrage", "Percentency", "compage", "metrage", "percenture", "percentages", "variay", "Percentability", "varirage", " percentency", "voltile", "percentide", "parile", "voltager", "percentency", "compity", "Percentile", "compay", "latity", "parager", "missage", "voltages"], "tmpPercentage": ["cppPercentrage", "tmppercentile", "tempPercentages", "tmpComple", "tmppercentay", "tmpPassrage", "cppPercentment", "tmpHalfency", "temppercentages", "tmpPassay", "tmpPercentile", "tmpPercentle", "tmppercentment", "cpppercentrage", "tmppercentages", "tmppercentency", "tmppercentrage", "temppercentle", "tmpPercentment", "tmpPassment", "tmpPassile", "ptypercentag", "cppPercentay", "tmppercentle", "tmpPercentency", "tmpPercentrage", "tmpPercentay", "ptypercentage", "tmpMagnment", "tmppercentag", "tmpHalfage", "temppercentency", "ptypercentency", "tmpCompages", "tmpPercentag", "tmpPassency", "ptyPercentage", "tmpCompency", "temppercentage", "tmpMagnrage", "cpppercentay", "ptyPercentency", "tempPercentency", "tmpPercentages", "ptypercentile", "tmpHalfag", "tmpPassage", "tempPercentle", "tmppercentage", "tmpMagnay", "tmpPassag", "tmpCompage", "cpppercentment", "tmpMagnage", "ptyPercentile", "tmpHalfile", "tempPercentage", "cpppercentage", "cppPercentage", "ptyPercentag"], "size": ["sized", "ize", "external", "fee", "send", "speed", "clean", "c", "capacity", "sum", "time", "empty", "length", "content", "address", "unit", "count", "loc", "SIZE", "grade", "scale", "rc", "small", "width", "sn", "max", "sec", "e", "code", "len", "i", "ne", "error", "Size", "data", "esc", "offset", "name", "core"], "checksum": ["timesig", " checksal", "checkme", " checksam", " checksig", "cksam", "cksums", "timessum", "getsumm", " checksme", "getssum", "checksums", "cksum", " Checksme", "timesum", " checkssum", "getsam", "checkum", " checksums", "cksumm", " checksumm", "checksumm", "timesums", " Checksal", "cksig", "checksig", "checksam", "checksal", "checkssum", " Checkssum", "checksme", "checkal", "ckssum", "getsum", " Checksum"]}}
{"id1": "6613944", "id2": "5135688", "code1": "    public static String installOvalDefinitions(final String xml_location) {\n        InputStream in_stream = null;\n        try {\n            URL url = _toURL(xml_location);\n            if (url == null) {\n                in_stream = new FileInputStream(xml_location);\n            } else {\n                in_stream = url.openStream();\n            }\n        } catch (IOException ex) {\n            throw new OvalException(ex);\n        }\n        Class<OvalDefinitions> type = OvalDefinitions.class;\n        OvalDefinitions object = _unmarshalObject(type, in_stream);\n        String pid = _getDatastore().save(type, object);\n        return pid;\n    }\n", "code2": "    private boolean saveNodeMeta(NodeInfo info, int properties) {\n        boolean rCode = false;\n        String query = mServer + \"save.php\" + (\"?id=\" + info.getId());\n        try {\n            URL url = new URL(query);\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            byte[] body = Helpers.EncodeString(Helpers.ASCII, createURLEncodedPropertyString(info, properties));\n            conn.setAllowUserInteraction(false);\n            conn.setRequestMethod(\"POST\");\n            conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            setCredentials(conn);\n            conn.setDoOutput(true);\n            conn.getOutputStream().write(body);\n            rCode = saveNode(info, conn);\n        } catch (Exception ex) {\n            System.out.println(\"Exception: \" + ex.toString());\n        }\n        return rCode;\n    }\n", "label": 0, "substitutes": {"installOvalDefinitions": [" saveOvalRefaults", " saveOvaldefines", " saveOvalFplates", " saveOvalRefines", " saveOvalDefplates", " saveOvalRefplates", " saveOptDefinitions", " saveOvaldefplates", " saveOptDefines", " saveOptDefaults", " saveOvaldefaults", " saveOvalDefaults", " saveOvalRefinitions", " saveOptdefines", " saveOvalDefines", " saveOvalFines", " saveOptDefplates", " saveOptdefinitions", " saveOvalFinitions", " saveOptdefaults", " saveOvaldefinitions", " saveOptdefplates", " saveOvalFaults", " saveOvalDefinitions"], "xml_location": [" xml_path", " xml_area", "http_location", "xml_area", "xml_directory", "xml67loc", "xmlFilelocation", "xmlFilefilename", " xml_type", "xmlFilearea", "xml67path", "xml67location", "xml_filename", "http_loc", " xml_loc", "xml_path", "xml_type", " xml_filename", "xmlFileLocation", "xml_loc", " xml_Location", "xml67type", "http_directory", "xml_Location"], "in_stream": ["inc_cont", "in_channel", "thin67channel", " in_stack", "in67clean", "in67struct", "inc_stream", "in_cont", " in_url", "in_clean", "thin67stream", "in_stack", " in_trans", "thin_stream", "in_trans", "in_sw", "in_ream", "in67channel", "inc_clean", "inc_ream", " in_form", "in67sw", "thin_sw", "in67cont", "in67stream", "thin67struct", "in_form", "thin_struct", "thin_channel", "in67ream", "in_struct", "thin67sw", "in_url"], "url": ["resource", "stream", "ob", "string", "blog", "host", "http", "xml", "str", "www", "URL", "path", "ll", "log", "api", "open", "feed", "Url", "impl", "address", "bel", "bug", "loc", "browser", "l", "connection", "base", "ls", "coll", "location", "server", "sl", "f", "image", "socket", "html", "ssl", "bb", "page", "data", "fl", "obj", "b", "web", "source", "uri", "org", "file", "ref"], "type": ["group", "class", "function", "kind", "instance", "py", "o", "method", "http", "xml", "tool", "copy", "path", "platform", "key", "address", "single", "unit", "handler", "p", "part", "base", "tag", "pe", "element", "model", "port", "like", "category", "python", "link", "TYPE", "types", "format", "pod", "file", "Type", "product", "obj", "style", "module", "plugin", "null", "ype", "parser", "t", "info", "id", "parent", "collection", "name", "core", "ref"], "object": [" error", "class", "function", "project", "string", "instance", "oid", " obj", "o", "pointer", "version", "node", "objects", "os", "number", " python", "address", " structure", "document", "base", "part", "element", "model", "config", "array", "value", "result", "nt", "data", "product", "obj", "target", "id", "info", "parent", "name"], "pid": ["ping", "root", "pc", "pd", "sid", "oid", "pb", "pointer", "pse", "proxy", "ids", "bin", "uid", "abi", "pac", "pin", "pp", "pak", " tid", "p", "proc", "phi", "pos", "pins", "pa", "port", "phrase", "processor", "pkg", "lp", " pin", "iana", "product", "vid", " PID", "plugin", "ps", "jp", "pty", "id", "parent"]}}
{"id1": "21821404", "id2": "7118860", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "label": 1, "substitutes": {"getWebPage": ["parsewebpage", "getwebpages", "parsewebPage", "getVirtualPage", "getVirtualpages", "getwebpage", "getWebpage", "parseWebpages", "parsewebpages", "parseWebpage", "getVirtualpage", "parseWebPage", "getwebPage", "getWebpages"], "urlObj": [" urlObject", "URLobj", "resourceObject", "urlExt", "httpobj", "blogobj", "URLObject", "UrlObj", "Urlobj", "urlobj", " urlExt", "URLObj", " urlobj", "strobj", "strObject", "blogObj", "httpOb", "resourceobj", "resourceObj", "URLExt", " urlInst", "blogInst", " urlOb", "strObj", "strInst", "resourceExt", "UrlOb", "urlInst", "urlOb", "httpObj", "urlObject", "blogObject"], "content": ["resource", "online", "section", "clean", "string", "c", "css", "lines", "comment", "response", "core", "java", "continue", "report", "cont", "feed", "empty", "json", "object", "address", "header", "document", "out", "model", "server", "Content", "url", "load", "coll", "work", "array", "code", "value", "page", "result", "html", "output", "data", "write", "raw", "comments", "message", "source", "buffer", "text", "body", "file"], "is": ["il", "or", "isp", "ires", "us", "isa", "ip", "ios", "im", "ois", "isl", "est", "you", "rest", "site", "ir", "irc", "was", "iris", "as", "be", "io", "ais", "abs", "os", "IS", "ui", "cms", "in", "ins", "ri", "does", "ie", "it", "fs", "s", "Is", "out", "iss", "iso", "ar", "ops", "x", "its", "isi", "isc", "i", "any", "mis", "bis", "lis", "ser", "ai", "al", "nis", "r", "ps", "id", "es", "info", "stream", "ris", "ise", "problem"], "reader": ["or", "row", "actor", " Reader", "reading", "oder", "inner", "ler", "io", "ner", "driver", "in", "ri", "er", "handler", "bird", "ro", "l", "rc", "server", "x", "loader", "read", "Reader", "iter", "rer", "e", "director", "i", "worker", "h", "writer", "editor", "ser", "rr", "r", "parser", "rar", "buffer", "stream", "rx"], "line": ["item", "inline", "entry", "row", "pass", "section", "string", "col", "word", "lines", "ine", "LINE", "str", "character", "comment", "Line", " inline", "response", "char", "key", "object", "user", "cr", "cl", "l", "part", "connection", "lin", "cell", "out", "server", "url", "block", "link", "f", "code", "cle", "strip", "page", "data", "lf", "message", "buffer", "source", "text", "body", "column", "name", "file", "lc"]}}
{"id1": "6625074", "id2": "14567939", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "label": 1, "substitutes": {"SHA1": ["HA384", "SHAOne", " SHAOne", "sha256", "shaOne", "SHA256", "sha384", "HA256", "SHA384", "HA1", "HAOne", " SHA256", " SHA384", "sha1"], "text": ["source", "message", "buffer", "output", "str", " Text", "out", "token", "path", "translation", "config", "font", "bytes", "txt", "word", "input", "image", "data", "TEXT", "in", "object", "format", "context", "editor", "class", "name", "ext", "Text", "code", "obj", "password", "transfer", "letter", "hex", "string", "struct", "test", "value", "template", "contract", "plain", "pattern", "content"], "sha1hash": ["sha256password", "shaOnehash", "SHA1cap", "SHA1text", "sha6Hash", "sha6hash", "sha_Hash", "ha2hash", "sha1hex", "sha2cap", "sha81Hash", "shaOnepassword", "ha1hash", "sha256text", "sha6log", "ha1hex", "sha_sum", "ha2hex", "SHA2cap", "sha6cap", "sha1cap", "ha2Hash", "ha1Hash", "sha1text", "sha2Hash", "sha81log", "sha1Hash", "sha2hash", "shaOnetext", "sha81cap", "sha256Hash", "ha2sum", "SHA2hash", "SHA1Hash", "sha2hex", "sha2sum", "SHA1hash", "sha_hex", "sha81hash", "sha2log", "sha1sum", "SHA2log", "ha1sum", "sha1password", "sha256hash", "shaOneHash", "sha_hash", "sha1log", "SHA1password", "SHA2Hash", "SHA1log"], "md": ["hm", "mm", "mp", "cf", "amd", "f", "hash", "wd", "dig", "cmd", "dm", "de", "mb", "meta", "m", "nm", "metadata", "ad", "mac", "editor", "rm", "ms", "sm", "vd", "um", "nd", "pd", "sha", " MD", "gb", "od", "ld", "dd", "mo", "mt", "hd", "cd", "MD", "mc", "ma", "df", "pkg", "mag", "pm", "d", "rpm", "bd"]}}
{"id1": "11865906", "id2": "7948308", "code1": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"testIdentification": ["testAuthentity", "testidentification", "testAuthentification", "TestIdentity", "testIdentifier", "testPersonity", "testAuthentifier", "TestIdentifier", "testidentify", "testIdentify", "testAuthentify", "testidentity", "Testidentification", "TestIdentify", "testPersonifier", "testIdentity", "Testidentity", "testPersonify", "testPersonification", "Testidentifier", "testidentifier", "TestIdentification", "Testidentify"], "username": ["address", "url", "sudo", "account", "token", "job", "whatever", "login", "uno", "uin", "ame", "sword", "verb", "utf", "nil", "your", "plugin", "users", "host", "filename", "creator", "string", "name", "ui", "profile", "month", "driver", "word", "prefix", "database", "character", "company", "purpose", "nick", "ug", "mobile", "hello", "uri", "property", "person", "rue", "staff", "consumer", "usr", "subject", "USER", "email", "ername", "uid", "home", "uu"], "password": ["picture", "hash", "address", "sudo", "params", "account", "token", "Password", "cache", "description", "login", "w", "sword", "security", "wallet", "session", "filename", "patch", "string", "name", "profile", "seed", "word", "driver", "prefix", "database", "auth", "words", "crypt", "null", "text", "diff", "pad", "padding", "attribute", "p", "wd", "key", " passwords", "mac", "phrase", "PASS", "fax", "email", "secret", "pass", "value", "Pass"], "md5": ["dd5", " mdob", "MD512", "MD3", "dd2", "ddob", " md75", "sha1", "MDob", "md512", "MD75", "MD4", "sha5", "sha512", "MD2", "mdob", " md1", " md512", "md2", "md75", "MD1", " md2", "md1", "sha3", "sha4", "sha75", " md4", "md3", "md4", "MD5", " md3", "dd512"], "logServiceMock": ["logServiceAMock", "logServiceMocked", "logServiceManagerock", "logServiceMOCK", "logServiceManock", "logServiceBOCK", "logServiceManocker", "logModuleMock", "logServiceAMocker", "logServiceFocker", "logServicePocks", "logClientBock", "logServiceAMocked", "logServicemOCK", "logServicePick", "logServiceMocker", "logServiceFocks", "logServiceManocks", "logServiceVocker", "logClientMocker", "logServiceBock", "logServiceVck", "logServiceFOCK", "logModuleMocker", "logClientBck", "logServiceVock", "logServiceAMOCK", "logModuleMOCK", "logServiceBck", "logServiceFck", "logServiceManagerOCK", "logClientBocker", "logServiceMick", "logServiceManagerocker", "logModulePocks", "logServiceFock", "logModuleMocks", "logServiceManocked", "logClientMOCK", "logServiceMck", "logModuleManock", "logServiceMocks", "logModulePOCK", "logServiceBick", "logClientBOCK", "logServicePock", "logModuleManocker", "logModuleMick", "logServicemick", "logServicemock", "logClientMck", "logServiceBocker", "logModulePock", "logServiceVocks", "logModuleManOCK", "logModulePick", "logServiceVOCK", "logClientMock", "logServiceBocks", "logServiceFocked", "logModuleManocks", "logServicemocks", "logServiceManagerocks", "logServicePOCK", "logServiceManOCK"], "dbServiceMock": ["dbServiceCMocker", "dbServiceFox", "dbServiceManick", "dbServicemock", "dbServicesManock", "dbClientFOCK", "dbservicemox", "dbserviceMOCK", "dbClientFock", "dbServicesMox", "dbServiceMocker", "dbServiceCMock", "dbServicesMocker", "dbServiceDocker", "dbClientMocked", "dbServiceManagerOCK", "dbServicemocker", "dbServicemox", "dbserviceMox", "dbServiceBox", "dbServicesMick", "dbClientMick", "dbServiceDock", "dbServiceMick", "dbServiceCMocked", "dbServiceBocker", "dbServiceManagerocker", "dbServiceDick", "dbServiceManagerock", "dbServiceMocked", "dbClientMOCK", "dbServiceVocker", "dbServiceFOCK", "dbServiceVox", "dbServiceManock", "dbServiceMOCK", "dbServiceFocked", "dbservicemock", "dbServicesManick", "dbServiceVock", "dbServiceVOCK", "dbServicesMock", "dbClientMock", "dbServiceManox", "dbServicesManox", "dbClientFick", "dbServicemOCK", "dbservicemocker", "dbserviceMock", "dbServiceDOCK", "dbServiceFock", "dbServiceVick", "dbServiceFick", "dbServiceFocker", "dbServiceCMick", "dbserviceMocker", "dbServiceBock", "dbServicemick", "dbClientMocker", "dbServicemocked", "dbServiceManagerick", "dbClientFocked", "dbServiceManocker", "dbServiceBOCK", "dbServiceMox", "dbServicesManocker", "dbservicemOCK", "dbClientFocker"], "user": ["result", "client", "account", "token", "job", "follow", "login", "project", "use", "current", "proxy", "model", "db", "log", "User", "creator", "row", "plugin", "name", "profile", "ee", "bug", "lock", "auth", "or", "you", "type", "info", "connection", "real", "class", "role", "object", "rule", "config", "per", "usa", "api", "person", "resource", "key", "by", "other", "page", "me", "usr", "data", "server", "up", "USER", "match", "member", "instance", "pass", "record", "blog", "author"]}}
{"id1": "13666876", "id2": "18211588", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"transformSingleFile": [" transformSingleFiles", "transformSinglePath", "transformMultifile", "transformOneSourceFile", "transformsingleSourceFile", "transformMultiFile", "transform1Path", "transformOneFile", "transformOnePath", "transformMultiFiles", " transformSingleSourceFile", " transformOneSourceFile", "transformMultiSourceFile", "transformSingleFiles", " transformSinglefile", "transformSinglefile", " transformOneFile", "transformsingleFile", "transform1Files", "transform1SourceFile", "transformOneFiles", "transformSingleSourceFile", "transform1File", "transformsingleFiles", " transformOnefile", "transformsinglefile", " transformSinglePath", " transformOnePath", "transformOnefile", " transformOneFiles"], "xed": [" xedited", "rexed", "xted", " Xed", " xED", "xED", "xteds", "rexeded", "xxeds", "xedited", "exEd", "xtEd", "exeb", "Xended", "xended", "exeds", "xxed", " xended", "xEd", "xxeded", "xeds", "exeded", "Xed", "rexED", "exed", "Xeded", "xxedited", "exED", "xxeb", " Xeds", "Xedited", "xxED", " Xeded", " xEd", " xeds", " xeded", "xtED", "xxended", "xeded", "xeb", " Xeb", "rexeds"], "node": ["slave", "row", "root", "live", "route", "day", "instance", "op", "option", "Node", "copy", "path", "shape", "none", "tree", "object", "child", "no", "loc", "document", "part", "event", "query", "component", "load", "location", "config", "index", "set", "image", "page", "error", "menu", "message", "parent", "source", "ode", "leaf", "name", "file", "edge"], "dob": ["dub", " dOb", "adod", "ddod", "ddOb", "ddob", "dOB", "adub", "DOb", " dub", "dOb", "adOB", "ddOB", "Dub", " dOB", "Dob", "adob", "DOB", " dod", "ddub", "dod"], "mySrc": ["MyAsrc", "mysRC", "mysrb", " mySst", "mySst", " myEsst", "myAssrc", "myAsrb", "myAsRC", "myEssrc", " myEsrc", "MySRC", " myEssrc", "MySrc", "mySRC", "MyEsRC", "MyEsrb", " myEsRC", "myDrc", "MyAsource", "MySource", "myDsource", "MyEsrc", " mySsrc", "myDst", "myDsrc", "myEsrb", "myAsst", "myAsrc", "myEsource", "myssrc", "mySrb", "MyEssrc", "myEsrc", " mySRC", "mySsrc", "myDssrc", "MyAssrc", "mysrc", "myEsst", "MySsrc", "myEsRC", "MyAsRC", "myAsource", "myDRC", "mySource", "myDsRC", "MySrb"], "mySrcF": ["myCrcM", "mySourceE", "mySRCM", "myCrcF", "myEssrcFile", "myCrcE", "myEsrcf", "myCRCF", "mySourceF", "mySrcf", "myCRCE", "myCRCf", "myCRCM", "mySsrcf", "mySRCE", "mySrcFile", "myEssrcF", "mySckM", "myCrcf", "mySourceFile", "mySsrcFile", "mySourcef", "myEssrcE", "mySRCFile", "myEsrcE", "mySsrcF", "myEsrcF", "mySRCf", "myEsrcFile", "mySrcM", "mySckE", "mySrcE", "mySsrcE", "myEssrcf", "mySckF", "mySsrcM", "mySckf", "mySRCF"], "myOutF": [" myOutputC", "myoutFF", "MyInQ", "myoutFile", "myoutF", "myOutFile", "MyInPF", " myOutC", "myInD", "MyInF", "myOUTF", "myInQ", "MyOutD", "myOutE", "myOUTFF", "myOutPF", "myInPF", "myOutFF", "MyOutFile", "myOutputFile", "myInF", "MyOutPF", "myOutC", "myOutD", "MyOutQ", " myOutE", "myOutQ", "myOUTD", "myoutPF", "myOutputC", " myOutFile", "MyInFile", "myOUTFile", "myInC", "myOutputF", " myOutputFile", "myInE", "myoutE", "MyOutE", "myOUTQ", " myOutputF", " myOutputE", "myoutC", "myOUTE", "myInFF", "MyInD", "myOUTPF", "MyInE", "MyOutF", "myInFile", "MyOutFF", "myOutputE", "MyInFF"], "co": ["che", "fe", "cho", "ctrl", "pc", "fc", "cmp", "gro", "so", "ob", "c", "oe", "cache", "ca", "o", "ko", "fo", "ee", "cca", "ci", "con", "can", "colo", "la", "flo", "cf", "OO", "cu", "CO", " Co", "ce", "no", "loc", "CC", "cc", "ico", "mc", "BO", "rc", "pe", "coll", "cur", "cos", "bc", "company", "isco", "code", "bo", "auto", "cb", "lo", "bb", " CO", "po", "oo", "Co", "coe", "conf", "aco", "ck", "mo", "lc"], "x3dvFile": ["x3dvSource", "x3rdVFiles", "x3rdVfile", "x3dvsFiles", "x3dsvSource", "x3ndvFiles", "x3ndvFile", "x3dfFile", "x3dvsfile", "x3dvFiles", "x3dvfile", "x3dVPage", "x3dVSource", "x3rdVFile", "x3dfFiles", "x3dvsFile", "x3dsvfile", "x3ndsvFile", "x3rdvFiles", "x3ndsvSource", "x3ndvfile", "x3dsvFile", "x3dfSource", "x3rdvfile", "x3dffile", "x3dsvPage", "x3rdvPage", "x3rdVPage", "x3ndsvFiles", "x3dVFiles", "x3dvsPage", "x3ndvSource", "x3ndsvfile", "x3dsvFiles", "x3dVFile", "x3dVfile", "x3dvPage", "x3rdvFile"], "fis": ["elfisa", "refiss", "fus", " fs", "elfus", "refi", " fiss", "elfbs", "Fs", "fs", "Fus", "refisa", "refis", "fbs", " fi", "elfi", "fi", "elfs", " fus", "fisa", "elfis", "elfiss", "Fis", " fbs", "Fbs", "fiss", " fisa"], "gzos": ["wxo", "bagops", "zipo", "zxops", "bagOS", "gzops", "gzo", "zxOS", "bagos", "bagis", "bago", "zipos", "zipis", "wxis", "zxis", "gzOS", "zxos", "zxo", "zo", "zipops", "zops", "wxos", "zis", "zos", "wxOS", "zipOS", "zOS", "gzis"], "buf": ["done", "bh", "grab", "vec", "cas", "cv", "bin", "bd", "box", "queue", "la", "pad", "seq", "loc", "fab", "batch", "br", "bag", "ff", "uint", "lb", "port", "cur", "bc", "block", "len", "av", "uf", "cap", "uc", "bytes", "cb", "result", "data", "feat", "Buff", "b", "fb", "buff", "ba", "bf", "buffer", "ab", "rb", "db", "dec"], "ret": ["det", "rep", "ry", "reply", "fin", "fun", "continue", "ft", "match", "rt", "bit", " RET", "num", "rf", "count", "default", "rc", "out", "rets", "reg", "f", "len", "success", "pet", "val", "res", "result", "nt", "repl", "att", "obj", "alt", "r", "b", "en", "bf", "id", "Ret", "ver", "RET", "re", "ref"]}}
{"id1": "5682569", "id2": "411595", "code1": "    public void metodo1() {\n        int temp;\n        boolean flagDesordenado = true;\n        while (flagDesordenado) {\n            flagDesordenado = false;\n            for (int i = 0; i < this.tamanoTabla - 1; i++) {\n                if (tabla[i] > tabla[i + 1]) {\n                    flagDesordenado = true;\n                    temp = tabla[i];\n                    tabla[i] = tabla[i + 1];\n                    tabla[i + 1] = temp;\n                }\n            }\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 0, "substitutes": {"metodo1": [" metato3", " metando2", " metodo8", " utando3", " metodo2", " metando8", " utodo1", " utodo2", " utodo3", " utando1", " metango1", " utando8", " metodo3", " metando3", " metando1", " metato2", " metango2", " metato8", " metango3", " metato1", " metango8", " utando2", " utodo8"], "temp": ["index", "tc", "mag", "clean", "pre", "modified", "c", "current", "tem", "z", "j", "result", "length", "Temp", "dest", "iter", "offset", "txt", "type", "source", "cache", "lc", "cut", "diff", "default", "alt", "parent", "level", "data", "tmp", "flat", "fake", "empty", "p", "null", "test", "cel", "stable", "status", "t", "font", "prefix", "partial", "v", "count", "f", "mini", "emp"], "flagDesordenado": ["flagDesORDenad", "flagDesordeniato", "flagDesordainido", "flagDesideredainar", "flagDesordienada", "flagDesordencad", "flagDesideredenar", "flagDesideredainada", "flagDesordenad", "flagDesordenada", "flagDesordENano", "flagDesideredainido", "flagDesideredenada", "flagDesordENada", "flagDesordencada", "flagDesordennado", "flagDesordinado", "flagDesORDENada", "flagDesordainada", "flagDesordernar", "flagDesORDenado", "flagDesordENado", "flagDesordENad", "flagDesordienad", "flagDesordeniad", "flagDesordienado", "flagDesordenido", "flagDesideredainado", "flagDesordennada", "flagDesORDenano", "flagDesordencado", "flagDesordeniado", "flagDesordernato", "flagDesordencano", "flagDesordienato", "flagDesordennato", "flagDesordeniar", "flagDesORDENado", "flagDesordainado", "flagDesordeniano", "flagDesordinato", "flagDesordennaban", "flagDesideredenado", "flagDesordenar", "flagDesordinada", "flagDesordernad", "flagDesideredenido", "flagDesordeniaban", "flagDesordeniada", "flagDesordeniido", "flagDesORDENad", "flagDesORDenada", "flagDesordenaban", "flagDesordinaban", "flagDesordenato", "flagDesordernido", "flagDesORDENano", "flagDesordernada", "flagDesordainar", "flagDesordenano", "flagDesordernado"], "i": ["index", "info", "id", "n", "pi", "uri", "mu", "list", "ini", "site", "slice", "c", "j", "ri", "l", "si", "ui", "ii", "key", "qi", "part", "ti", "ji", "source", "lc", "load", "phi", "diff", "chi", "data", "li", "ip", "x", "p", "mi", "bi", "u", "init", "cli", "oi", "ai", "start", "ci", "I", "e", "io", "eni", "image", "it", "xi", "gi", "di", "hi", "k", "b", "v", "ni", "left", "abi", "iu", "multi", "f", "mini", "api", "ix"], "tabla": ["taglas", "Tabla", "ablo", "tabela", " tabela", " tabula", "tagela", "tablelas", "tagula", "cellela", "tableela", "taglo", " tablas", "taga", "tablela", "taba", "Tablo", "abla", "tablea", "cellna", "Tabula", " taba", "tabna", "Taba", "Tabela", "tablas", "abula", "tagla", "ablas", " tabna", "tagna", "tabula", "tablo", "Tablas", " tablo", "cellla", "cellula", "abela"]}}
{"id1": "16572931", "id2": "21824901", "code1": "    private String unJar(String jarPath, String jarEntry) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntry.substring(0, jarEntry.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            ZipEntry ze = jar.getEntry(jarEntry);\n            File bin = new File(path + \"/\" + jarEntry);\n            IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path + \"/\" + jarEntry;\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"unJar": ["copyTar", "putTar", "addServer", "updateTar", "updateServer", "updatejar", "putjar", "addJava", "putJava", "addTar", "updateJava", "putServer", "copyServer", "copyjar", "copyJava", "addjar"], "jarPath": ["javaDir", "erbEntry", " jarUrl", "relDir", "javaUrl", " jarFile", "garPath", "JarPath", "JarName", "jarDir", "jarLog", "javaLog", "garLog", "JarFile", "javaEntry", "jarpath", " jarLog", "javaName", "garpath", " jarDir", "browserpath", "relFile", "jarUrl", "erbPo", "javaFile", " jarpath", "javapath", "Jarpath", "browserName", "relEntry", "erbName", "JarEntry", "jarFile", "javaPath", "browserEntry", "JarUrl", "JarDir", "javaPo", " jarName", "browserPath", "erbPath", " jarPo", "jarPo", "garEntry", "jarName"], "jarEntry": ["javaDir", " jarUrl", "irName", " jarJar", "cookEntry", "javaUrl", "cookEnt", "xmlPath", "JarPath", "jarLog", "jarDir", "javaLog", "Jarentry", "aliasName", "javaEntry", " jarLog", "zipDir", "javaName", "irJar", "dropPath", " jarInfo", "xmlEntry", "javaentry", "dropInfo", "xmlInfo", "javaInfo", " jarDir", "irEntry", "cookDir", "jarUrl", "irentry", "zipEntry", "zipUrl", "aliasEntry", "aliasInfo", "JarEntry", "jarentry", "javaEnt", "dropEntry", "jarJar", " jarentry", "javaPath", "javaJar", "JarInfo", "jarEnt", "cookPath", " jarName", "zipName", "aliasEnt", "xmlLog", " jarEnt", "jarInfo", "dropentry", "jarName"], "path": ["prop", "default", "image", "core", "parent", "data", "step", "part", "not", "zone", "entry", "conn", "pass", "temp", "directory", "po", "string", "patch", "file", "root", "context", "right", "text", "uri", "resource", "this", "ph", "folder", "model", "zip", "ion", "key", "type", "test", "code", "cel", "config", "dir", "skip", "content", "prefix", "log", "url", "dest", "loc", "sync", "mode", "route", "str", "archive", "end", "out", "th", "src", "Path", "id", "binary", "pattern", "next", "location", "clean", "p", "lock", "ath", "project", "mount", "PATH", "it", "wd", "home", "cat", "source", "work", "inner", "base", "address", "name", "left", "host", "request"], "relPath": ["RelPath", " relType", "relType", "RelEntry", "RelType", "revType", "relativePath", "Relpath", "revPath", " relUrl", "relpath", "revEntry", " relpath", "relativeUrl", " relName", "revpath", " relEntry", "relName", "relativeName", "RelUrl", "relEntry", "relativepath", "RelName", "relUrl"], "jar": ["java", "gar", " Jar", "url", "z", "pack", "module", "j", "le", "b", "dr", "Jar", "rar", "zone", "folder", "entry", "py", "tar", "zip", "her", "fire", "drop", "archive", "ja", "bag", "job", "cur", "tab", "jo", "pkg", "xml", "plugin", "war", "dir", "ar", "car", "er", "base", "bar", "cook", "gi", "file", "binary", "sl", "keeper", "ler", "gap", "lib", "open", "ball", "browser"], "ze": ["pe", "z", "e", "se", "le", "ce", "ge", "je", "sle", "ZE", "ie", "ele", "entry", "pse", "oe", "zip", "ja", "zin", "zes", " je", "zzy", "te", "kee", "zen", "de", "za", "aze", "zer", "ke", "zie", "be", "ipe", "zy", "zed", "sl", "zee", "zi", "ine"], "bin": ["bb", "bon", "proxy", "gen", "log", "pack", "resource", "ban", "b", "lock", "init", "abin", "data", "bit", "in", "cookie", "brain", "zip", "bis", "abi", "sin", "plugin", "win", "boot", "cin", "kin", "web", "len", "login", "inner", "base", "jin", "gi", "file", "bed", "bas", "bian", "binary", "bot", "pin", "bi", "spin", "lib", "isin"]}}
{"id1": "15051083", "id2": "5836744", "code1": "    @Override\n    public String getMessageDigest() throws SarasvatiLoadException {\n        if (messageDigest == null) {\n            Collections.sort(nodes);\n            Collections.sort(externals);\n            try {\n                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\n                digest.update(name.getBytes());\n                for (XmlNode node : nodes) {\n                    node.addToDigest(digest);\n                }\n                for (XmlExternal external : externals) {\n                    external.addToDigest(digest);\n                }\n                messageDigest = SvUtil.getHexString(digest.digest());\n            } catch (NoSuchAlgorithmException nsae) {\n                throw new SarasvatiException(\"Unable to load SHA1 algorithm\", nsae);\n            }\n        }\n        return messageDigest;\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"getMessageDigest": ["getMessagedigature", "getMessageDesignester", "getMessageHashester", "getmessagedigature", "getMessagedigester", "getmessageDigature", "getMessagedigest", "getmessageDigest", "getMessageDesignature", "getMessageDesignest", "getMessageDesignests", "getmessagedigests", "getMessageDigester", "getmessagedigest", "getMessageDigests", "getmessageDigester", "getMessagedigests", "getmessageDigests", "getMessageHashature", "getMessageDigature", "getmessagedigester", "getMessageHashest", "getMessageHashests"], "digest": [" Digest", "dighed", "sandest", "digiter", "feedest", " digger", "hexex", "Digesting", "Diger", "DigEST", " dighed", "Dighed", "digesting", "digester", "Digests", "digex", "hexests", "hexEST", "signiter", " digests", "Digex", "Digester", "hexest", "greatest", " Digeter", "signesting", " digex", "Digeter", "Digiter", "diger", " diger", "greatiter", "digeter", " Digester", "Digested", "sandester", "sandesting", " digeter", "greatested", "signest", "signester", " Dighed", "Digger", "digested", "sandested", " Diger", "signested", "digEST", " digested", " digEST", " Digger", "digger", "Digest", "feedester", "feedested", "digests", "greatester", " digester"], "node": ["index", "resource", "module", "child", "ode", "odes", "point", "self", "root", "event", "global", " Node", "local", "remote", " source", "object", "Node", " nodes", "element", " parent", "route", "path", "source", "uri", " annotation", "entity", "network", " child", "name", " namespace", "internal", "server", "component", "document", "instance", "one", "n", "connection", "config", "location", "parent", "address"], "external": [" External", "resource", "outer", "account", " foreign", "global", "outside", "target", "intern", "local", "remote", "environment", "object", "ternal", "element", "export", " global", " remote", "https", "External", "network", "out", "client", "multiple", "Intern", "name", "internal", "international", "secondary", "reference", "binary", "foreign", "e", "instance", "ex", "n", "source", "tern"], "messageDigest": ["messageDesignester", "messageDest", "messageDigester", "MessageDigenge", "messageMarkest", "messageDested", "messageHashester", "messagedigger", "messageModested", "messageDigenge", "messageMarkenge", "messageSignest", "MessageSignester", "MessageDigest", "messageSignested", " messageHashesting", "messageMarkested", " messageDesignested", " messageDesignger", " messageDigester", " messageHashest", "messageSignenge", "messageHashest", " messageDigesting", "messageSignester", "messageDesignest", " messageDigger", "messageHashested", " messageDesignest", "MessageDigester", "messagedigested", "messageDigger", "MessageSignenge", "messageDesignger", " messageDesignester", "messageDester", " messageDigested", "messageDesignesting", "messageHashesting", "messageModesting", "messageMarkester", "messageModester", "messagedigester", "MessageSignested", "messageDigesting", "MessageSignest", "messageDigested", "messageDenge", " messageHashester", "messageModest", "messageDesignested", "messagedigest", "MessageDigested", " messageHashested"]}}
{"id1": "16466743", "id2": "596993", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    private String makeLoginRequest(URL url) throws IOException {\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setDoInput(true);\n        urlConnection.setDoOutput(true);\n        urlConnection.setUseCaches(false);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"Email=\").append(URLEncoder.encode(EMAIL, \"UTF-8\"));\n        content.append(\"&Passwd=\").append(URLEncoder.encode(PASSWORD, \"UTF-8\"));\n        content.append(\"&service=\").append(URLEncoder.encode(SERVICE, \"UTF-8\"));\n        content.append(\"&source=\").append(URLEncoder.encode(\"Google Base data API\", \"UTF-8\"));\n        OutputStream outputStream = urlConnection.getOutputStream();\n        outputStream.write(content.toString().getBytes(\"UTF-8\"));\n        outputStream.close();\n        int responseCode = urlConnection.getResponseCode();\n        InputStream inputStream;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = urlConnection.getInputStream();\n        } else {\n            inputStream = urlConnection.getErrorStream();\n        }\n        return toString(inputStream);\n    }\n", "label": 0, "substitutes": {"getmd5": ["getmn512", " getMD6", " getMD12", "getmd6", "getmetadata5", "getMD512", "getmn5", "getMD12", " getMD512", "getMD6", " getMD5", "getmn6", "getmd12", "getmetadata512", " getmd6", "getMD5", "getmn12", " getmd12", "getmd512", " getmd512", "getmetadata6", "getmetadata12"], "password": ["pass", "attribute", "token", "username", "words", "sword", "string", "word", "secret", "input", "Password", "PASS", "path", "key", "number", " passwords", "auth", "pad", "email", "wd", "address", "p", " Password", "prefix", "phrase", "config", "array", "f", "hash", "login", "data", "account", "message", "pattern", "buffer", "crypt", "text", "name", "encrypted", "padding"], "pwHash": ["pwtHash", "qwDig", "PWHash", "PWSum", "pwMac", "qxDig", "qwSum", "pwhMac", "pwaSum", "pxDig", "pwhBlock", "pWBlock", "pwDig", "qwMac", " pwahash", "pWSum", " pwaHash", "PWMac", "PwMac", "qxHash", "pxMac", "pxHash", "qxSum", "pwdSum", "pwaMac", "pwaHash", "pxSum", "pWHash", "pwaDig", "PwBlock", "pwtBlock", "pweHash", "pwdDig", "qwHash", "pwahash", "pweSum", "pwhSum", " pwSum", "PwHash", "pwdMac", "pwtSum", "pwdHash", "pwSum", "pwdhash", "pWMac", "pwhash", " pwhash", "pwBlock", " pwDig", "PWBlock", "pwhHash", "qxMac", "pweDig", " pwaSum", "pwehash", "pwtMac", "PwSum", " pwaDig"], "md": ["dc", "mb", "mg", "mp", "pd", "ms", "pm", "mage", "od", "mand", "cm", "mac", "Cmd", "m", "rm", "sm", " MD", "um", "d", "sha", "hm", "MD", "bd", "meta", "ad", "M", "dd", "ld", "mc", "cd", "mod", "cmd", "ma", "mag", "am", "dm", "hash", "nm", "amd", "mi", "kg", "dig", "mm", "metadata", "mt", "me", "mu", "bm", "db", "mo"], "b": ["ib", "mb", "nb", "u", "bs", "B", "ob", "d", "bin", "be", "bd", "buf", "emb", "bi", "orb", "eb", "p", "batch", "br", "lb", "l", "gb", "reb", "base", "sb", "f", "e", "a", "bytes", "cb", "bis", "bb", "r", "fb", "buff", "ba", "bf", "binary", "buffer", "wb", "ab", "rb", "db"], "i": ["si", "chi", "qi", "ip", "u", "multi", "n", "ii", "c", "pi", "o", "d", "abi", "ci", "di", "io", "z", "slice", "ji", "ui", "vi", "ri", "bi", "mu", "p", "it", "l", "phi", "s", "base", "j", "I", "x", "index", "f", "e", "oi", "li", "a", "start", "h", "ni", "v", "gi", "ti", "data", "ai", "r", "xi", "zi", "id", "info", "uri", "block"]}}
{"id1": "14650352", "id2": "15810440", "code1": "    boolean checkIfUserExists(String username) throws IOException {\n        try {\n            URL url = new URL(WS_URL + \"/user/\" + URLEncoder.encode(username, \"UTF-8\") + \"/profile.xml\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.connect();\n            InputStream is = conn.getInputStream();\n            is.close();\n            return true;\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n    }\n", "code2": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"checkIfUserExists": ["checkIfUserExist", "checkIfUserexists", "checkIfuserexists", "checkIfUserexisting", "checkIfuserexes", "checkIfUserLists", "checkIfUserListing", "checkIfUserContes", "checkIfuserexist", "checkIfUserexes", "checkIfUserLes", "checkIfUserContists", "checkIfuserexisting", "checkIfuserExisting", "checkIfUserexist", "checkIfUserContisting", "checkIfUserList", "checkIfUserExisting", "checkIfUserContist", "checkIfuserExist", "checkIfuserExists", "checkIfuserExes", "checkIfUserExes"], "username": ["role", "token", "uu", "subject", "u", "description", "string", "method", "sudo", "title", "uid", "family", "path", "key", "auth", "database", "email", "user", "address", "me", "USER", "profile", "staff", "nick", "password", "home", "filename", "ame", "mobile", "login", "ername", "directory", "data", "account", "users", "uri", "text", "name"], "url": ["resource", "string", "blog", "host", "channel", "http", "www", "URL", "path", "ll", "log", "ur", "api", "feed", "Url", "impl", "user", "address", "object", "build", "loc", "browser", "l", "connection", "base", "ls", "aur", "server", "sl", "f", "uc", "page", "ssl", "bb", "fl", "b", "web", "uri", "client", "org", "file"], "conn": ["dc", "ch", "n", "c", "Connection", "act", "col", "http", "Conn", "ann", "conv", "ci", "dn", "ctx", "con", "open", "co", "os", "rt", "ct", "cf", "loc", "p", "connection", "cn", "rc", "cp", "ls", "cur", "cos", "cs", "enc", "cli", "ns", "h", "close", "cb", "ssl", "nt", "ai", "conf", "nc", "connect", "org", "lc"], "is": ["us", "ms", "ip", "isa", "serv", "bs", "ios", "ens", "isl", "css", "act", "iris", "has", "as", "abs", "api", "ais", "os", "IS", "ui", "in", "ins", "it", "fs", "err", "app", "Is", "ls", "vs", "iss", "iso", "cos", "its", "isi", "isc", "i", "ori", "bis", "ai", "info", "ris", "ss"]}}
{"id1": "7809093", "id2": "6840241", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    private static long copy(InputStream source, OutputStream sink) {\n        try {\n            return IOUtils.copyLarge(source, sink);\n        } catch (IOException e) {\n            logger.error(e.toString(), e);\n            throw new FaultException(\"System error copying stream\", e);\n        } finally {\n            IOUtils.closeQuietly(source);\n            IOUtils.closeQuietly(sink);\n        }\n    }\n", "label": 0, "substitutes": {"getContent": ["GetData", "requestBody", "GetBody", "GetEntity", " getData", "getBody", " getBody", "setBody", "responseEntity", "setData", "setContent", "responseOutput", "GetOutput", "requestEntity", "GetContent", "getOutput", "responseBody", "requestOutput", "setEntity", "getEntity", " getEntity", "getData", "responseContent", "requestContent"], "request": ["message", "method", "result", "position", "uri", "current", "path", "instance", "http", "e", "input", "req", "data", "q", "object", "resource", "QUEST", "url", "name", "server", "query", "address", "operation", "string", "connection", "handler", "queue", "reference", "route", "r", "user", "type", "xml", "Request", "report", "application"], "sb": ["lp", "ls", "bh", "buffer", "su", "ab", "fp", "xb", "SB", "cb", "obb", "bb", "fb", "bj", "lab", "sg", "pb", "src", "abi", "bp", "ib", "zb", "binary", "bf", "lb", "sa", "sup", "bc", "bt", "b", "vm", "usb", "nb", "bs", "bg", "rb", "eb", "gb", "sk", "bm", "BB", "amb", "bsp", "wb", "sf", "db", "abb", "bd"], "client": ["p", "contact", "call", "app", "remote", "util", "cache", "output", "current", "uri", "Client", "session", "net", "c", "config", "tc", "https", "per", "console", "apache", "conn", "project", "bird", "default", "application", "con", "web", "service", "proxy", "builder", "ce", "resource", "force", "connect", "url", "server", "host", "api", "container", "connection", "channel", "handler", "cl", "plugin", "queue", "cli", "ssl", "context", "http"], "httpParams": ["HttpParamas", "httpArums", "httpPamer", "HTTPPoparams", "httpPARams", "httpPareters", "httpPoamer", "HTTPPARam", "httpPramer", "HTTPPARams", "HTTPParparams", "httpPeram", "HTTPPareters", "HTTPParamer", "httpPreters", "httpPARamas", "httpArams", "httpPrams", "httpPeramas", "httpParums", "HttpParparams", "httpPoams", "HTTPPoams", "httpPrparams", "httpPARums", "HttpParam", "httpParcs", "HTTPPARcs", "httpParamer", "httpPoeters", "httpPeters", "httpPams", "HTTPPoeters", "HTTPPARums", "httpParparams", "httpArcs", "HTTPParams", "httpParam", "HTTPParcs", "httpPerams", "httpPARparams", "httpPoparams", "httpPerparams", "httpParamas", "httpPARam", "HTTPParam", "HTTPParums", "HTTPPoamer", "httpPparams", "httpAram", "HttpParams", "httpPARcs"], "response": ["message", "relation", "result", "output", "json", "successful", "model", "http", "view", "page", "success", "resp", "data", "object", "resource", "reply", "document", "server", "Response", "api", "body", "onse", "connection", "respond", "received", "collection", "feed", "results", "error", "report", "status", "application"], "entity": ["source", "ent", "result", "media", "output", "json", "translation", "instance", "company", "environment", "model", "event", "component", "person", "e", "conn", "xml", "application", "data", "writer", "agent", "object", "resource", "ce", "node", "document", "em", "pe", "server", "article", "address", "api", "body", "connection", "channel", "element", "coll", "creator", "file", "collection", "entry", "type", "Entity", "content", "http"], "reader": ["source", "rx", "buffer", "reading", "ry", "inner", "rr", "rar", "ler", "i", "per", "input", "driver", "bird", "read", "loader", "writer", "oder", "ner", "in", "io", "editor", "rer", "server", "worker", "stream", "handler", "parser", "Reader", "iter", "row", "r", "er", "ser", "feed", "iterator", "ri"], "line": ["source", "message", "lf", "char", "Line", "lines", "str", "sync", "cell", "non", "len", "page", "model", "pass", "link", "word", "l", "inline", "val", "data", "definition", "comment", "ip", "url", "character", "name", "base", "no", "lc", "job", "code", "ge", "sel", "sl", "li", "string", "header", "LINE", "cl", "lin", "el", "layer", "block", "iter", "row", "key", "r", "feed", "entry", "id", "end", "le", "user", "unit", "content"]}}
{"id1": "16556717", "id2": "16048516", "code1": "    public static String getSHADigest(String password) {\n        String digest = null;\n        MessageDigest sha = null;\n        try {\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            sha.reset();\n            sha.update(password.getBytes());\n            byte[] pwhash = sha.digest();\n            digest = \"{SHA}\" + new String(Base64.encode(pwhash));\n        } catch (NoSuchAlgorithmException nsae) {\n            CofaxToolsUtil.log(\"Algorithme SHA-1 non supporte a la creation du hashage\" + nsae + id);\n        }\n        return digest;\n    }\n", "code2": "    public static SVNConfiguracion load(URL urlConfiguracion) {\n        SVNConfiguracion configuracion = null;\n        try {\n            XMLDecoder xenc = new XMLDecoder(urlConfiguracion.openStream());\n            configuracion = (SVNConfiguracion) xenc.readObject();\n            configuracion.setFicheroConfiguracion(urlConfiguracion);\n            xenc.close();\n        } catch (Exception exception) {\n            exception.printStackTrace();\n        }\n        return configuracion;\n    }\n", "label": 0, "substitutes": {"getSHADigest": ["getSHADIGest", "getSHADIGEST", "getSHADipEST", "getSHADegEST", "getSHADegester", "getSHADigher", "getSHADigEST", "getSHAPigEST", "getSHADegher", "getSHAPigest", "getSHAPegester", "getSHADipest", "getSHADegest", "getSHADIGher", "getSHAPigher", "getSHAPegEST", "getSHADIGester", "getSHADipester", "getSHADigester", "getSHAPigester", "getSHAPegher", "getSHAPegest", "getSHADipher"], "password": ["secret", "crypt", "text", "padding", "prefix", "attribute", "auth", " passwords", "data", "username", "sword", "phrase", "hash", "input", "encrypted", "key", "wd", "pass", "code", "config", "user", "Pass", "id", "address", "token", "string", "email", "security", "name", "pattern", "words", "path", "word", "buffer", "Password", "p", "PASS"], "digest": ["hexest", "digress", "Digusher", "dighest", "digString", "greatest", "generhest", " digEST", "DigEST", "hashester", "Digester", "digEST", "Digest", "hashests", " dighest", "digesting", "greatester", "greatEST", "hashusher", "Dighest", " digesting", " digress", "digkey", "hashString", "generester", "generEST", "generest", "hexests", "greatesting", " digusher", "DigString", " digester", "Digkey", "Digesting", "digester", "hexkey", "hexString", "digests", "Digests", "hashkey", "digusher", "hashest", "Digress", "hashress"], "sha": ["ppa", "oa", "va", "volume", "ema", "pg", "ah", "acl", "HA", "shi", "si", "ph", " SHA", "alias", "hash", "pa", "mc", "ga", "sum", "ta", "ka", "h", "meta", "asha", "cca", "ami", "api", "hh", "qa", "a", "lambda", "slave", "pi", "SHA", "da", "mac", "na", "ba", "po", "sa", "wa", "acha", "alpha", "ma", "ua", "la", "eta", "ha", "ssh", "sh", "ca", "aa"], "pwhash": [" pwhashed", "pWHa", "pwest", "pphash", " pwhest", "pwheash", "jpwhashed", "pphest", "pWhashed", "pwhashed", "jpWHa", "pWHest", "jpWHashed", "pWhash", " pwashed", "pWHashed", "jpwhash", "pwhade", "pWhest", "pwheest", "jpwha", "pphade", "pwashed", "jpWHest", "pwhest", "pwash", "pwha", " pwest", "pphashed", "pWHash", "pwade", " pwade", " pwhade", "jpWHash", "pwa", "pwhea", "jpwhest", " pwash", "pWhade", "pwheashed"]}}
{"id1": "5977352", "id2": "12766394", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "copyDir", "copyfile", " copyDir", "CopyFile", "copyFiles", " copyFiles", "transferfile", "transferFile", "transferDir", "Copyfile", "CopyFiles", " copyfile", "CopyDir"], "src": ["source", "filename", "sb", "uri", "fp", "path", "config", "s", "this", "buf", "view", "input", "ource", "conn", "inst", "loc", "data", "loader", "resource", "proxy", "img", "url", "tmp", "b", "proc", "obj", "files", "sel", "sc", "sl", "dist", "rc", "rb", "ins", "gb", "stream", "file", "slice"], "dest": ["source", "cache", "output", "table", "st", "path", " destination", "config", "home", "store", "this", "master", " Dest", "txt", "d", "de", "trans", "project", "rest", "cdn", "folder", "done", "dep", "later", "img", "class", "url", "tmp", "name", "cont", "null", "die", "obj", "destroy", "zip", "dist", "cp", "thin", "orig", "desc", "file", "temp", "route", "wb", "Dest", "part", "dir", "parent", "opt", "target", "delete", "dc"], "bufSize": ["buf2", "ufSize", "bufferSize", "buffersize", " bufsize", "bufLen", "uf2", "queueSize", "ufLen", " buf2", " bufLen", "queuesize", "queueLen", "buffer2", "ufsize", "bufsize", "bufferLen"], "force": ["ride", "p", "source", "Force", "remote", "ist", "sync", "push", "dirty", "load", "forces", "front", "f", "store", "use", "place", "hard", "urse", "count", "base", "deep", "rc", "require", "write", "only", "auto", "replace", "like", "file", "parent", "forcing", "pull", "route", "id", "forced", "apply", "flush", "delete", "no"], "buffer": ["source", "result", "cache", "length", "memory", "load", "buff", "fb", "buf", "seed", "bytes", "uffer", "border", "padding", "data", "binary", "zero", "limit", "url", "base", "b", "null", "transfer", "split", "address", "append", "Buffer", "queue", "write", "raw", "batch", "reference", "iter", "value", "request", "feed", "slice", "reader", "flush", "bin", "offset"], "read": ["work", "text", "ride", "seek", "create", "select", "copy", "current", "se", "Read", "reading", "length", "sync", "parse", "check", "load", "lex", "len", "use", "view", "pass", "show", "level", "READ", "i", "input", "send", "skip", "ed", "count", "k", "sleep", "ind", "data", "build", "close", "ad", "open", "play", "find", "ip", "io", "n", "connect", "next", "b", "add", " write", "allow", "exec", "reads", "index", "size", "write", "raw", "block", "iter", "wait", "feed", "id", "reader", "end", "get", "start", "d", "fill", "run"], "in": ["source", "as", "init", "inn", "gin", "pin", "inner", "c", "ac", "f", "pass", "ex", "i", "input", "socket", "conn", "image", "sin", "inside", "serv", "IN", "m", "con", "win", "ini", "up", "n", "isin", "a", "url", "base", "din", "b", "nin", "min", "ins", "connection", "cin", "thin", "In", "inc", "again", "rin", "kin", "lib", "part", "pull", "r", "err", "login", "id", "reader", "bin"], "out": ["source", "call", "init", "app", "cache", "output", "sync", "client", "net", "inner", "ac", "at", "home", "this", "with", "w", "ex", "i", "one", "max", "socket", "conn", "OUT", "line", "image", "by", "writer", "n", "io", "up", "bin", "url", "name", "b", "ou", "outer", "ext", "exec", "obj", "nin", "connection", "exp", "plain", "Out", "write", "outs", "again", "off", "lib", "part", "err", "key", "o", "id", "user", "inc", "co", "can", "no"]}}
{"id1": "18489832", "id2": "10728243", "code1": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "code2": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"downLoadZippedFile": [" doLoadZaggedFiles", " doLoadZedFiles", " doLoadZippedFiles", " doLoadzippedFiles", " doLoadZaggedContent", " doLoadZippingDir", " doLoadzippingContent", " doLoadZippingFile", " doLoadZaggedDir", " doLoadzippedFile", " doLoadzippingFile", " doLoadZippingContent", " doLoadZaggedFile", " doLoadzippingFiles", " doLoadzippedContent", " doLoadZedDir", " doLoadZippedFile", " doLoadZedContent", " doLoadzippedDir", " doLoadzippingDir", " doLoadZippingFiles", " doLoadZedFile", " doLoadZippedContent", " doLoadZippedDir"], "url": ["ur", "proxy", "page", "log", "uri", "ssl", "resource", "image", "server", "ll", "b", "connection", "event", "store", "link", "f", "zip", "route", "URL", "download", "i", "source", "pull", "config", "client", "l", "web", "lr", "base", "r", "file", "c", "loader", "sl", "bug", "Url", "or", "update", "http", "lib", "open"], "destDir": ["destFile", " destFile", " destFolder", "tempFile", "destdir", "destFolder", "tmpdir", "tempFolder", " destdir", "tmpDirectory", " destDIR", "tmpDIR", "outputFile", "DestFile", "outputDirectory", " destDirectory", "DestDir", "tempDIR", "tempDir", "outputDIR", "outputDir", "outputFolder", "DestDIR", "destDIR", "destDirectory", "outputdir", "tmpDir", "DestFolder"], "urlConnection": ["urlNetwork", "webConnect", "URLChannel", "urlConnect", "URLconnection", "webChannel", "httpNetwork", "httpFactory", "URLConnect", "webconnection", "downloadNetwork", "webConnection", "URLConnection", "fileConn", "fileFactory", "urlConn", "urlChannel", "urlconnection", "downloadFactory", " urlConnect", " urlChannel", "httpConnection", "fileNetwork", "fileConnection", "downloadConnection", "urlFactory", "downloadConn", " urlconnection", "httpConn"], "tmpFile": ["destFile", "mpfile", "mpFile", " tmpFolder", " tmpPath", "partfile", "mpPath", "tempPath", "tmpFolder", "destWorld", "zipFiles", "tmpfile", "TempPath", "tempFile", "tmpFiles", "destFolder", "tempFiles", "tempEntry", " tmpFiles", "partFolder", "tmpPath", "partFile", "mpDir", "TempWorld", "destPath", "tmpLine", "Tempfile", "tempLine", "partDir", " tmpLine", " tmpfile", "tmpEntry", " tmpDir", "mpFolder", "zipFile", "tempfile", "zipfile", " tmpWorld", "tempDir", "destEntry", "zipLine", "mpFiles", "tmpWorld", "destfile", "tmpDir", "TempFile", " tmpEntry"], "in": ["ex", "ins", "In", "copy", "ax", "n", "connection", "en", "init", "info", "data", "sync", "inc", "socket", "gin", "f", "input", "din", "IN", "lin", "inn", "Out", "conn", "cin", "i", "is", "win", "source", "reader", "kin", "rin", "pull", "nin", "l", "a", "login", "work", "inner", "min", "r", "id", "token", "ac", "bin", "err", "con", "c", "file", "up", "pin", "ini", "as", "arin", "again"], "out": ["at", "ex", "writer", "one", "server", "call", "copy", "In", "null", "n", "connection", "cmd", "init", "io", "off", "outer", "this", "sync", "inc", "socket", "output", "no", "check", "o", "index", "IN", "Out", "conn", "download", "i", "source", "client", "nin", "co", "login", "inner", "point", "outs", "min", "exec", "bin", "file", "err", "obj", "name", "up", "OUT", "op", "again", "line", "ext"], "localURL": ["externalAPI", "LocalCL", "LocalAPI", "LocalUrl", " localFile", "localFile", "externalCL", "localAPI", "remoteURI", " localCL", "externalURL", "localCL", "externalUrl", "remoteURL", " localAPI", "localURI", "remoteUrl", " localURI", "remoteFile", "LocalURL", "localUrl", " localUrl", "baseFile", "baseURI", "baseURL", "baseUrl"]}}
{"id1": "17202158", "id2": "21438069", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    public ProjectDeploymentConfiguration createNewProjectDeploymentConfig(int projectID, String name, String description) throws AdaptationException {\n        ProjectDeploymentConfiguration config = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            config = getProjectDeploymentConfiguration(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProjectDeploymentConfig\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return config;\n    }\n", "label": 0, "substitutes": {"readZoneIDs": ["loadzoneID", "readCodeNames", "readzoneID", "readCodeID", "loadZoneID", "readZoneIDS", "readZoneNames", "loadZoneIDs", "readLocationIDS", "loadzoneIDS", "readLocationID", "readzoneIDs", "loadZoneIDS", "readCodeIDs", "loadzoneNames", "readLocationNames", "loadzoneIDs", "readCodeIDS", "readzoneIDS", "loadZoneNames", "readzoneNames", "readLocationIDs", "readZoneID"], "zoneFileName": ["zoneFilesUrl", "ZonefileName", "Zonefilename", "zoneDirName", "zoneFullPath", "zonefileUrl", "zoneFilePath", "zoneDirPath", "zoneClassName", "zonefilename", "zoneFilesPath", " zoneFileUrl", "zoneFilename", "ZoneFileName", " zoneFilePath", "zoneFilesname", "zoneClassname", "zoneLinePath", " zoneDirPath", "zoneFileUrl", " zoneDirName", "ZoneFileUrl", "zoneFullname", " zoneDirUrl", "ZonefileUrl", "zoneFullUrl", "ZonefilePath", "zonefilePath", "zoneLineName", "ZoneFilePath", "zonefileName", "zoneClassPath", "ZoneFilename", "zoneFullName", "zoneLineUrl", "zoneFilesName", "zoneClassUrl", "zoneDirUrl"], "zoneids": ["sizeints", "typeids", "Zoneids", "zipids", "poids", "zoneips", "Zoneid", "typeips", "typeints", " zoneid", " zonelines", "zipIDs", "ziplines", "Zonefiles", "zoneIDs", "zipid", "pofiles", " zoneints", "poid", "poIDs", "typeid", "zoneints", "sizeips", " zoneips", "ZoneIDs", "zonefiles", " zoneIDs", "sizeids", "polines", "sizeid", "zoneid", " zonefiles", "zonelines"], "url": ["reader", "job", "connection", "sl", "f", "data", "name", "channel", "ur", "stream", "base", "class", "ssl", "page", "b", "loader", "user", "l", "r", "client", "address", "this", "Url", "service", "URL", "source", "buffer", "feed", "api", "hub", "path", "server", "uri", "io", "http", "file", "ball", "resource", "bel", "location", "re", "string"], "lnr": ["rlr", "lenb", "lnw", "linr", "slb", "linp", "lenp", "rlb", "slrb", "nlw", "rlrb", "linrb", "sln", "nlb", "slr", "lenw", "lnb", "nlp", "lnn", "lnp", "linb", "lenr", "rln", "nlr", "linn", "lnrb", "linw"], "line": ["le", "sl", "data", "name", "char", "el", "ge", "str", "letter", "log", "rule", "base", "inline", "lc", "page", "part", "l", "cell", "lines", "key", "lf", "column", "row", "comment", "ne", "entry", "parse", "block", "Line", "response", "no", "cl", "number", "code", "nl", "unit", "jo", "c", "file", "id", "LINE", "word", "message", "sel", "lin", "header", "link", "col", "string", "look"]}}
{"id1": "6304373", "id2": "16820041", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrTemFiles", "uploadOrDeleteMediaOrtempl", "uploadOrDeleteMediaOrMemplates", "uploadOrDeleteMediaOrTemporary", "uploadOrDeleteMediaOrTemplatepl", "uploadOrDeleteMediaOrTemplateplates", "uploadOrDeleteMediaOrTemplateporary", "uploadOrDeleteMediaOrTemplateFiles", "uploadOrDeleteMediaOrMempl", "uploadOrDeleteMediaOrMemporary", "uploadOrDeleteMediaOrMemFiles", "uploadOrDeleteMediaOrtemporary", "uploadOrDeleteMediaOrtemplates", "uploadOrDeleteMediaOrtemFiles"], "action": ["flow", "method", "ACTION", "call", "style", "flash", "effect", "activity", "environment", "actions", "event", "state", "ction", "view", "item", "module", "service", "format", "resource", "act", "next", "url", "name", "change", "function", "operation", "Action", "api", "activation", "now", "lock", "element", "plugin", "test", "version", "parent", "part", "step", "controller", "what", "site", "type", "commit", "section", "error", "status", "active"], "object": ["edit", "group", "mode", "current", "instance", "environment", "system", "not", "event", "model", "project", "image", "none", "resource", "email", "module", "service", "self", "directory", "class", "url", "subject", "document", "objects", "thread", "article", "host", "obj", "function", "number", "address", "letter", "string", "now", "lock", "oid", "ject", "element", "full", "auto", "office", "version", "request", "part", "o", "zone", "parent", "node", "target"], "numElements": ["numGelem", "numeodes", " numElem", "numEllem", "numEllement", "numelem", "numelements", "numEodes", "numElem", "numGeodes", " numelem", " numelement", " numEodes", "numelement", "numGelements", "numGelement", " numelements", "numElodes", "numEllements", " numeodes"], "req": ["util", "ro", "load", "update", "use", "mr", "resp", "module", "builder", "g", "next", "base", "log", "params", "obj", "msg", "conf", "verb", "res", "gr", "usr", "html", "err", "r", "ctx", "parent", "xml", "report"], "session": ["local", "result", "cache", "token", "client", "browser", "flash", "instance", "ession", "system", "state", "event", "person", "use", "ESSION", "manager", "image", "global", "shared", "service", "resource", "sa", "document", "subject", "security", "thread", "sp", "container", "connection", "h", "scope", "lock", "test", "temp", "request", "response", "site", "Session", "ctx", "context", "http"], "ftp": ["FTP", "ttP", " ftc", "ttcp", " ftcp", "FTp", "ttp", "ftcp", "ftP", "ttc", "FTcp", "ftc", " ftP", "FTc"], "user": ["account", "match", "group", "facebook", "result", "current", "browser", "client", "path", "username", "author", "config", "ver", "info", "hash", "this", "use", "page", "pass", "person", "home", "e", "per", "view", "state", "usa", "project", "image", "shared", "USER", "by", "data", "module", "auth", "other", "record", "comment", "self", "class", "url", "base", "name", "log", "error", "mail", "post", "admin", "string", "rule", "connection", "lock", "profile", "ee", "full", "usr", "used", "html", "creator", "users", "system", "parent", "bug", "er", "custom", "type", "member", "db", "User"], "links": ["Links", "lines", "flash", "styles", "actions", "link", "groups", "tree", "image", "menu", "linked", "email", "url", "base", "log", "members", "Link", "pages", "details", "html", "mails", "headers", "results", "items", "ids", "images", "posts", "mail"], "folders": ["handers", "handors", "anchages", "handries", "foldages", "filers", "anchries", "anchers", "foldors", "handages", "anchors", "foldries", "filages", "filries", "filors"], "folder": ["source", "filename", "flat", "Folder", "uri", "path", "license", "home", "archive", "level", "command", "area", "enter", "project", "menu", "location", "email", "resource", "directory", "editor", "division", "document", "url", "database", "device", "picture", "theme", "zip", "address", "letter", "append", "upload", "scope", "connection", "two", "region", "future", "element", "layer", "plugin", "sample", "dir", "slice", "id", "layout", "fold", "zone", "ignore", "network", "volume"], "server": ["erver", "account", "source", "filename", "remote", "uri", "token", "client", "port", "username", "inner", "system", "page", "master", "slave", "seed", "socket", "manager", "localhost", "enter", "service", "resource", "email", "location", "directory", "url", "database", "device", "outer", "Server", "host", "peer", "address", "string", "connection", "scale", "value", "version", "ser", "ssl", "site", "reader", "engine", "network", "node", "type", "status"], "login": ["account", "secret", "access", "group", "cookie", "filename", "bridge", "path", "username", "pin", "basic", "config", "info", "skin", "pass", "socket", "blog", "service", "auth", "email", "resource", "journal", "consumer", "sudo", "shell", "url", "database", "name", "log", "mail", "picture", "label", "string", "connection", "machine", "lock", "profile", "plugin", "users", "ssl", "layout", "site", "network", "Login", "blank", "status"], "password": ["account", "secret", " passwords", "access", "column", "mask", "cookie", "filename", "token", "username", "language", "basic", "alias", "pass", "timeout", "phrase", "slave", "word", "manager", "padding", "photo", "auth", "email", "strip", "PASS", "sudo", "directory", "division", "database", "name", "device", "security", "sword", "picture", "string", "worker", "connection", "profile", "plugin", "Password", "ass", "pattern", "volume"], "fileTransferFolder": ["fileImportDirectory", "fileUploadServer", "fileImportFolder", "FileUploadTheme", "fileTransferTheme", "FileUploadPath", "fileTransferServer", "mediaUploadfolder", "fileAccessTheme", "fileTransformTheme", "fileUploadfolder", "mediaUploadServer", "fileUploadTheme", "fileImportfolder", "mediaUploadDirectory", "fileUploadPath", "FileUploadfolder", "FileTransferFolder", "fileTransformfolder", "mediaTransferFolder", "mediaTransferfolder", "fileAccessPath", "fileTransformPath", "fileImportServer", "fileUploadFolder", "fileTransformFolder", "fileUploadDirectory", "fileTransferDirectory", "FileTransferTheme", "fileAccessfolder", "FileTransferfolder", "FileTransferPath", "mediaTransferServer", "fileTransferfolder", "fileAccessFolder", "mediaTransferDirectory", "mediaUploadFolder", "FileUploadFolder", "fileTransferPath"], "liveFolder": ["LiveDirectory", "PreviewFolder", "Previewfolder", "livefolder", " livefolder", " liveLocation", "liveLocation", "LiveLocation", "Livefolder", "PreviewDirectory", "liveDirectory", "LiveFolder", " liveDirectory", "PreviewLocation"], "servers": ["SerServer", "serls", " serations", "servations", "serServer", "servServer", "serations", "servls", "Serls", "servvers", "Serations", "Servers", " serServer", " serls"], "message": ["Message", "buffer", "summary", "path", "flash", "update", "page", "manager", "image", "menu", "module", "resource", "email", "mess", "description", "document", "url", "log", "array", "mail", " messages", "msg", "address", "body", "header", "string", "details", "element", "request", "response", "member", "error", "status", "content", "application"]}}
{"id1": "14819747", "id2": "3958807", "code1": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 0, "substitutes": {"debug": ["Debug", "enabled", " debugging", "remote", "cache", "depth", "DEBUG", "develop", "production", " debugger", "config", "date", "store", "reg", "show", "enable", "root", "real", "console", "dump", " Debug", "github", "build", "module", "help", "play", "trace", "ger", "comment", "print", "progress", " DEBUG", "error", "export", "log", "display", "die", "admin", "tag", "quiet", "dev", "details", "plugin", "test", "file", "development", "bug", "err", "db", "doc", "status", "active"], "prologFile": ["prologPath", "PrologString", "proLogFiles", "prolangFull", "probaseFile", "prologFiles", "proconfigPath", "procatSource", "prolexFile", "prologFull", "proversionFile", "deflogSourceFile", "deflogFILE", "prolexfile", "proLogFull", "defblogFile", "proconfigModule", "prolexString", " prologFiles", "proLogSource", "problogDir", "proversionFILE", "proLogSourceFile", "proconfigString", "ProLogFile", "Prologfile", "proconfigfile", "prologSource", "proLogHeader", "roLogfile", "deflogDir", "proversionSourceFile", "prologfile", "problogHeader", "proflowfile", "procatfile", " problogSourceFile", "problogfile", "rologSource", "probaseHeader", "ProLogfile", " proLogFiles", "prollSource", "deflogFile", "defblogfile", "prologHeader", "proLogfile", "defLogFile", " proLogFile", "prologSourceFile", "defLogFILE", "rologfile", " prologFull", "prologFILE", "proflowDir", "roLogFile", "problogStream", "prologDir", "propathfile", "deflogPath", "propathFile", "prologModule", "probaseStream", "proLogFILE", "proLogString", "rologFile", "PrologFile", " problogfile", " proLogHeader", "problogFull", "defLogPath", "prolexModule", "roLogPath", "prollPath", " problogFull", "defLogSourceFile", "prollfile", "propathDir", "proflowFile", "procatFile", "ProLogString", "problogFiles", "prologString", "ProLogModule", "probaseFiles", " problogFile", "defblogSourceFile", "defblogDir", "prolangFile", "proLogFile", " prologHeader", "roLogSource", "deflogfile", "proLogPath", "proconfigFILE", "proLogModule", "propathSourceFile", " prologfile", "problogSourceFile", "rologPath", " prologSourceFile", "procatPath", " prologStream", "proconfigFile", "PrologModule", "proversionPath", "problogFile", "prologStream", "proconfigSourceFile", "prolangSourceFile", "prollFile", " proLogStream", "proLogStream", "proflowSourceFile", "prolangfile"], "targetFile": ["sourceDir", "outputPath", "outputDir", "targetfile", "sourceDirectory", " targetfile", "targetDirectory", "targetDir", "TargetFiles", "targetFiles", " targetDirectory", "sourcePath", "TargetFile", "TargetDir", "outputfile", "sourcefile", "sourceFiles", "targetPath", "Targetfile", "outputFile", "TargetDirectory", "sourceFile", "TargetPath", " targetFiles"], "source": ["text", "message", "style", "result", "position", "buffer", "uri", "str", "json", "parse", "language", "session", "config", "use", "view", "model", "i", "options", "input", "src", "ource", "SOURCE", "data", "Source", "service", "resource", "format", "proxy", "comment", "description", "class", "name", "zip", "sl", "term", "body", "string", "scope", "stack", "file", "template", "slice", "id", "unit", "type", "target", "content"], "myParser": [" myReader", " myJar", "yourJar", "MyParser", "MyJar", "yourReader", "myJar", "yourParser", "yourProgram", "MyReader", "MyProgram", "myReader"], "myProgram": ["Myprogram", "MYprogram", "myprogram", "yourParser", "MyProgram", " myPlan", "theParser", "yourMath", "MYParser", "theMath", "yourPlan", "MyPlan", "myPlan", "yourProgram", " myMath", "yourprogram", " myprogram", "theprogram", "MyParser", "myMath", "theProgram", "MYProgram"], "myVisitor": ["myDesignitable", "Myvisiter", "myExiter", "MyVisitors", "myVisIT", " myVisitors", "myAuditable", "mySignitor", "mySigniter", "myvisiter", " myvisitor", " myvisitors", " myVisitable", "myVISitable", "myvisulator", "myVISit", "myDesignIT", " myvisit", "Myvisulator", "mySignulator", "myDesignit", "myvisitable", "myVisititable", "myExulator", "myvisIT", " myVisIT", "myVISIT", "myVisiter", "myAudit", "myDesignitor", "Myvisitors", "myVisititor", " myVisit", "myExitor", "myVisit", " myvisIT", "myAuditors", "MyVisitor", "myVisitable", "MyVisiter", "myVISitor", "myAuditor", "myVisitors", "MyVisulator", "myVisulator", "myExitors", "myvisitor", " myvisitable", "myvisitors", "myvisit", "myVisititors", "Myvisitor", "mySignitors", "myVisitit"], "adapterLayer": ["adviceContainer", "adaptersFactory", "adptionLayer", "acaptersInfo", "adviceBuffer", "adaptersBuffer", "acapterLayer", "adaptersLayer", "acapterBuffer", "acaptersLanguage", "adviceLanguage", "adviceLayer", "admissionContainer", "admissionLayer", "acapterInfo", "acaptersBuffer", "acaptersLayer", "acapterLanguage", "acapterContainer", "adptionBuffer", "adviceFactory", "acaptersFactory", "admissionLanguage", "acaptersContainer", "adaptersContainer", "acapterFactory", "adaptersLanguage", "adptionFactory", "adptionInfo", "adapterLanguage", "adapterBuffer", "adviceInfo", "adapterContainer", "adaptersInfo", "adapterInfo", "adapterFactory"], "classLoader": ["ClassLoader", "classPath", "ClassPath", "classloader", "classDir", " classDir", "staticDir", " classPath", "ClassDir", "staticPath", "staticloader", "staticLoader", "Classloader", " classloader"], "adapterWriter": ["attapterswriter", "admissionWriter", "adaptersWrite", "adAdapterWriter", "attaptersWrite", "attaptersReader", "adapterswriter", "adAdapterWrite", "adapterwriter", "attapterWrite", "attapterWriter", "admissionwriter", "adAdapterReader", "adaptersWriter", "attaptersWriter", "adAdapterwriter", "attapterwriter", "adaptersReader", "adapterWrite", "admissionReader", "adapterReader", "admissionWrite", "attapterReader"], "annotationGenerator": ["annnotationGencer", "annnotationGenerator", "annnotationGenators", "annnotationGenerators", "annotationGcer", "annotationGators", "annotationGoder", "annotationgencer", "annnotationGeneroder", "annotationgenoder", "annnotationGenoder", "annotationGenators", "annnotationGenercer", "annotationGator", "annotationGencer", "annotationgenator", "annotationGenoder", "annotationGeneroder", "annotationgenators", "annnotationGenator", "annotationGenator", "annotationGenercer", "annotationGenerators"], "out": ["flow", "pre", "group", "copy", "cache", "output", "bar", "sync", "net", "point", "store", "page", "state", "cmd", "dump", "OUT", "conn", "line", "down", "sys", "in", "up", "print", "io", "n", "v", "log", "array", "outer", "server", "code", "obj", "post", "gen", "query", "list", "lock", "prefix", "chain", "Out", "raw", "outs", "again", "temp", "cli", "err", "diff", "user", "parent", "error"]}}
{"id1": "2668853", "id2": "16825994", "code1": "    public static boolean decodeFileToFile(final String infile, final String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            final byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (final java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (final Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (final Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public int run(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"Download dir local\");\n            return 1;\n        }\n        OutputStream out = new FileOutputStream(args[1]);\n        Path srcDir = new Path(args[0]);\n        Configuration conf = new Configuration();\n        FileSystem srcFS = FileSystem.get(conf);\n        if (!srcFS.getFileStatus(srcDir).isDirectory()) {\n            System.err.println(args[0] + \" is not a directory.\");\n            return 1;\n        }\n        try {\n            FileStatus contents[] = srcFS.listStatus(srcDir);\n            for (int i = 0; i < contents.length; i++) {\n                if (contents[i].isFile()) {\n                    System.err.println(contents[i].getPath());\n                    InputStream in = srcFS.open(contents[i].getPath());\n                    try {\n                        IOUtils.copyBytes(in, out, conf, false);\n                    } finally {\n                        in.close();\n                    }\n                }\n            }\n        } finally {\n            out.close();\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFiletoFiles", "decodeFileAsStream", "decodeString2file", "decodeFile2Stream", "decodeFiletoFile", "decodeFileToStream", "decodeFiletofile", "decodeFileAsFiles", "decodeFileTofile", "decodeStringToFile", "decodeStringTofile", "decodeStringToStream", "decodeFileAsFile", "decodeString2Stream", "decodeFile2File", "decodeString2File", "decodeFileAsfile", "decodeFiletoStream", "decodeFileToFiles", "decodeFile2file", "decodeStringToFiles", "decodeString2Files", "decodeFile2Files"], "infile": ["minfile", "infp", "outfilename", "infiles", "inFile", "outFile", "inputfile", "inputfp", " inFile", "inputFile", "outfiles", " infilename", "inputfiles", " infiles", "outfp", "minfilename", "minFile", "minfp", "inputfilename", "infilename"], "outfile": ["infp", "outfull", "outputfile", " outfull", "outfilename", "outFile", " outFile", "infolder", "outputfolder", " outfolder", "outfolder", " outfp", "outputfp", "outfp", "outputfilename", "outputfull", "Outfull", "Outfolder", "OutFile", "Outfile", "outputFile", "infilename", " outfilename"], "in": ["IN", "pin", "i", "input", "inas", "ex", "ini", "gin", "ic", "con", "inner", "socket", "as", "ins", "s", "bin", "is", "reader", "source", "up", "login", "min", "inside", "r", "inc", "data", "rin", "init", "conn", "again", "m", "e", "image", "re", "In", "nin", "a", "lin", "err", "b", "ac", "cin", "inn", "f", "win", "this", "din"], "out": ["base", "ex", "output", "copy", "outer", "op", "lock", "on", "net", "OUT", "socket", "as", "inner", "outs", "o", "s", "off", "line", "write", "bin", "co", "pass", "exit", "post", "client", "sync", "session", "no", "cache", "lib", "up", "target", "other", "inc", "work", "file", "conn", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "exp", "In", "ext", "b", "obj", "err", "error", "point"], "buffer": ["address", "base", "input", "Buffer", "uffer", "resource", "pause", "border", "server", "feed", "slice", "limit", "result", "length", "bin", "memory", "queue", "offset", "iter", "split", "reader", "source", "binary", "seed", "buff", "value", "buf", "wave", "data", "size", "bb", "null", "row", "bytes", "layer", "flush", "url", "shape", "b", "reference", "padding", "pad", "transfer", "batch"], "read": ["index", "Read", " receive", " r", "run", "ride", " get", "open", " copy", "get", "lex", " send", " check", "id", "feed", "add", "ind", "end", "find", " reach", "next", "sync", "use", "load", " sleep", "r", "work", "fill", "exec", "skip", "connect", " request", "play", " use", "reading", " parse", "limit", "se", "length", "write", "line", "ad", "sleep", "iter", "allow", "reader", " Read", "start", "tell", " load", "wait", " write", "input", "copy", " connect", "current", "reads", "pass", "select", " ride", "seek", "inc", " find", "check", "x", "size", " reader", "send", "k", "parse", "count", "READ"], "success": ["roll", "accept", "job", "response", "rolling", "ok", "continue", "ceed", "results", "warning", "better", "yes", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "selected", "default", "data", "safe", "null", "cess", "danger", "complete", "again", "status", " successful", "full", "correct", "good", "Success", "successful", "successfully", "rolled", "found", " succ", "zero", "error", "fast", "first", "winner", "initial"]}}
{"id1": "11484416", "id2": "16378239", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "label": 1, "substitutes": {"moveFile": [" movedDirectory", " moveDirectory", "MoveFiles", " movedFiles", "moveFiles", "MoveDirectory", " movedPath", " movedFile", " moveFiles", "movePath", "moveDirectory", " movePath", "MovePath", "MoveFile"], "orig": ["bin", "iter", "ext", "Orig", "f", "loc", "org", "origin", "archive", "ctr", "remote", "raf", "array", "ori", "info", "comb", "base", "prev", "copy", "img", "old", "coord", "raid", "dest", "imag", "temp", "rb", "exe", "proxy", "source", "real", "init", "image", "build", "bas", "original", "file", "folder", "id", "impl", "src", "transform", "frame", "coll", "home", "internal", "obj", "buf", "tmp"], "target": ["nt", "f", "current", "it", "force", "origin", "manager", "master", "archive", "arget", "remote", "reference", "auto", "to", "base", "prot", "format", "copy", "match", "eth", "dest", "temp", "this", "ret", "external", "source", "build", "template", "t", "project", "path", "parent", "object", "next", "platform", "original", "Target", "resource", "join", "result", "replace", "compatible", " Target", "tmp"], "buffer": ["bin", "iter", "uffer", "sequence", "data", "batch", "reference", "slice", "layer", "buff", "stack", "Buffer", "binary", "base", "position", "copy", "bb", "cache", "b", "bytes", "content", "address", "padding", "source", "block", "feed", "request", "url", "transfer", "read", "code", "raw", "null", "repeat", "file", "wave", "message", "frame", "header", "result", "resource", "input", "queue", "length", "write", "buf"], "bread": ["ffe", "rows", "bat", "fen", "batch", "robe", "piece", "fle", "ble", "fall", "good", "web", "rub", "div", "fe", "eb", "zero", "str", "fine", "fed", "bn", "loop", "bb", "die", "beat", "cook", "num", "zip", "wake", "bare", "key", "circ", "design", "bc", "abi", "meal", "feed", "cake", "raft", "brew", "choice", "fred", "food", "wen", "bee", "width", "hello", "inn", "knife", "buck", "grain", "sleep", "fee", "length", "fif", "rib", "four", "broken"], "fis": ["fiss", "lfos", "afis", "ufiss", "hIs", "fisa", " fisa", "his", "qils", "lfis", "fIs", " fIs", "fxIs", "fxis", "fxisa", "afiss", "afos", "afIs", "fxos", "qos", "fils", "hisa", "qiss", " fiss", "lfIs", "ufils", " fils", "lfiss", "qis", "ufis", "hos", "ufos"], "fos": ["infaos", " foss", "flens", "Foses", "foses", "flois", "fose", "flose", "Fose", "gros", "Fois", "Faos", "gis", "flaos", "Fros", " fose", "flors", "floses", "gos", "Fens", " foses", "Fis", "infos", "infois", "fors", "fros", "Foss", "goss", "foss", " fens", "Fos", " fros", "fois", "faos", "flos", "Fors", "fens", "infors"]}}
{"id1": "2461169", "id2": "17792212", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeString2Stream", "decodeFile2Stream", "decodeFileToString", "decodeFileToStream", "decodeFile2File", "decodeFileAsFile", "decodeFile2String", "decodeFileFromString", "decodeString2File", "decodeFileAsStream", "decodeStringToFile", "decodeFileFromStream", "decodeStringToStream", "decodeString2Files", "decodeString2String", "decodeFileToFiles", "decodeFileAsFiles", "decodeFileAsString", "decodeFile2Files", "decodeFileFromFiles", "decodeFileFromFile", "decodeStringToFiles", "decodeStringToString"], "infile": ["infp", " infiles", "InFile", "inputfiles", "minstream", " inbase", "instream", "outfp", "inbase", "outfilename", "inFile", " inFile", "minbase", "inputfp", "infiles", "Infile", "Instream", "infilename", "inputfilename", "minFile", "inputfile", "Inbase", "outfiles", " instream", " infp", "minfile", " infilename"], "outfile": [" outfilename", " outpath", "outputfilename", " outfolder", "outputfolder", "inputFile", "inputdatabase", " outFile", "outfilename", "inFile", "outputFile", "outpath", "outdatabase", "outputdatabase", "inputpath", "outfolder", "infilename", "inputfile", "outputpath", "infolder", "outFile", " outdatabase", "outputfile"], "in": ["into", "m", "ins", "In", "b", "init", "thin", "data", "inc", "socket", "gin", "input", "din", "IN", "inn", "inas", "lin", "s", "conn", "pass", "cin", "i", "is", "win", "sin", "reader", "rin", "source", "inside", "a", "nin", "login", "inner", "min", "r", "id", "ac", "bin", "err", "con", "ic", "re", "pin", "ini", "as", "again", "isin"], "out": ["to", "exit", "ex", "writer", "log", "write", "image", "one", "parent", "copy", "In", "off", "io", "outer", "session", "sync", "socket", "inc", "channel", "output", "no", "o", "Out", "job", "error", "timeout", "conn", "home", "pass", "client", "co", "work", "inner", "point", "outs", "base", "cache", "exec", "bin", "file", "obj", "err", "name", "up", "net", "ou", "OUT", "or", "again", "line", "lib", "post"], "buffer": ["wave", "border", "buf", "padding", "url", "write", "server", "length", "count", "b", "offset", "null", "data", "Buffer", "raw", "channel", "limit", "result", "input", "split", "batch", "bytes", "type", "flush", "iter", "source", "reader", "size", "buff", "seed", "base", "queue", "slice", "address", "cache", "bin", "binary", "reference", "layer", "uffer", "transfer", "value", "feed", "bb"], "read": ["play", "write", " count", "se", "length", "count", " Read", "copy", "n", "_", "lex", "io", "sync", "reading", "allow", "inc", "raw", "limit", "ride", "f", "connect", "check", "reads", "READ", "Read", "feed", "run", " write", "seek", "fill", "pass", "tell", "end", "i", "add", "parse", "reader", "iter", "size", "work", "len", "ip", "ad", "send", "slice", "ind", "id", "r", "load", "exec", " skip", "start", "select", "find", "wait", "next", "get", " copy", "x", "current", "sleep", "use"], "success": ["warning", "growth", "danger", "default", "message", "rolling", "successfully", "good", "null", "complete", "failed", "cess", "successful", "data", "method", "func", "follow", " Success", "model", "status", "winner", "result", "primary", "fail", "valid", "positive", "done", "error", " succeed", " successful", "pass", "results", "Success", "comment", "roll", "true", "flash", "xx", " succ", "initial", "continue", "rolled", "ceed", "first", "response", "path", "fast", "content", "ccess", "value", "again", "better", "construct", "open", "right"]}}
{"id1": "23161545", "id2": "19276022", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandomUid", "getRandomUUID", "getRandomGCID", "getRandGUID", "getRandGuid", "getRandGID", "getRandomGCUID", "getRandomGuid", "getRandUUID", "getRandUid", "getRandomIGID", "getRandGid", "getRandomIGid", "getRandomUuid", "getRandomGID", "getRandUID", "getRandomGCuid", "getRandomIGUID", "getRandomGid", "getRandomUID", "getRandomIGuid", "getRandomGCid", "getRandUuid"], "secure": ["secret", "remote", " insecure", "depth", "session", "config", "https", "use", "timeout", "seed", "unsigned", "service", "proxy", "ce", "stable", "weak", "force", "sr", "smart", "sec", "deep", "security", "random", "server", "allow", "host", "zip", "sensitive", "Secure", "external", "require", "confirmed", "encrypted", "safe", "pure", "secondary", "exclusive", "ssl", "protect", "debug", "active"], "md5": [" md500", "MDql", "md2", " md11", "md500", " md3", " MD11", " MD3", "cmd3", "cmdql", "md512", " mdql", "md3", " md2", "MD2", "cmd512", "MD5", "MD11", "cmd5", "mdql", "MD512", " MD500", " MD5", "md11", " md512", " MD2", "MD3", "MD500"], "sbValueBeforeMD5": ["sbValueBeforeMD1", "sbValueBeforeMD65", "sbValueBeforemd25", "sbValueAfterMD65", "sbValueBeforeMAC3", "sbValueBeforeMD7", "sbValueBeforeMS375", "sbValueBeforeMC5", "sbValueAfterMD7", "sbValueAfterMD0", "sbValueBeforeMD0", "sbValueBeforeMI5", "sbValueAfterMD95", "sbValueBeforeDER5", "sbValueBeforemd512", "sbValueBeforeSHA1", "sbValueBeforeDER3", "sbValueBeforeMD25", "sbValueAfterMD25", "sbValueBeforeMD20", "sbValueGivenMD375", "sbValueAfterMS0", "sbValueBeforeMAC55", "sbValueBeforeMD005", "sbValueAfterMS20", "sbValueGivenMD5", "sbValueAfterMS65", "sbValuebeforeMD1", "sbValueBeforeDER20", "sbValueBeforeMS3", "sbValueBeforeMR5", "sbValueBeforeMD75", "sbValueBeforeMAC5", "sbValueBeforeMS95", "sbValueBeforeMP3", "sbValueGivenMD512", "sbValueBeforeMI20", "sbValueBeforeMR3", "sbValuebeforeMD20", "sbValueBeforeSHA20", "sbValuebeforeMD005", "sbValueBeforeMS512", "sbValueAfterMS1", "sbValueAfterMD1", "sbValueBeforeAMD1", "sbValueBeforeD75", "sbValueBeforemd75", "sbValueBeforemd95", "sbValueGivenmd512", "sbValueBeforeMD3", "sbValueBeforeMS65", "sbValueBeforeSD20", "sbValueAfterMP1", "sbValueGivenmd3", "sbValueBeforeMI3", "sbValueAfterMS95", "sbValueBeforeMS20", "sbValueBeforeMC512", "sbValueBeforeMD55", "sbValueAfterMD5", "sbValueBeforeDER55", "sbValueBeforeMI7", "sbValuebeforeSD1", "sbValueBeforeDER0", "sbValueBeforemd65", "sbValueBeforeMS1", "sbValueBeforeSHA5", "sbValueBeforemd3", "sbValueBeforeMR25", "sbValueBeforeAMD3", "sbValueBeforeD3", "sbValueAfterMS3", "sbValueAfterMS25", "sbValueBeforeMS25", "sbValuebeforeSD20", "sbValueBeforeD65", "sbValueBeforemd5", "sbValueBeforeMS5", "sbValueBeforeMP5", "sbValueGivenmd5", "sbValueAfterMD75", "sbValueBeforeMD375", "sbValueBeforeSD5", "sbValueBeforeMS75", "sbValueBeforemd375", "sbValueBeforeMP7", "sbValueBeforeDER005", "sbValueAfterMS55", "sbValueAfterMS5", "sbValuebeforeSD5", "sbValueBeforeSD005", "sbValueAfterMP7", "sbValueAfterMS75", "sbValueAfterMD20", "sbValueAfterMP3", "sbValueBeforeMS7", "sbValueBeforeAMD20", "sbValueGivenmd375", "sbValueBeforeMS55", "sbValueBeforeMI1", "sbValueBeforeMC375", "sbValueBeforeMR95", "sbValueBeforeDER1", "sbValueBeforeMS0", "sbValuebeforeMD5", "sbValueBeforeSD1", "sbValueGivenMD3", "sbValueBeforeAMD5", "sbValueBeforeMC3", "sbValueAfterMD55", "sbValueBeforeMP1", "sbValueAfterMD3", "sbValueBeforeMD512", "sbValuebeforeSD005", "sbValueBeforeSHA005", "sbValueBeforeMAC0", "sbValueBeforeMD95", "sbValueBeforeD5", "sbValueAfterMP5"], "time": ["work", "mode", "depth", "timer", "length", "date", "etime", "event", "tz", "timeout", "seed", "Time", "tim", "count", "loc", "year", "duration", "hour", "money", "speed", "TIME", "name", "random", "host", "counter", "ime", "delay", "race", "times", "size", "clock", "value", "version", "cost", "slice", "id", "rate", "type", "user", "start", "error", "offset"], "rand": ["right", "ro", "depth", "clean", "risk", "reg", "rr", "seed", "root", "Rand", "max", "raid", "rank", "count", "year", "q", "pick", "win", "bot", "round", "bit", "random", "gen", "cr", "mid", "res", "chance", "index", "rc", "delay", "rule", "lang", "min", "alpha", "ng", "range", "rage", "serial", "winner", "version", "r", "id", "rate", "type", "rh", "error", "rol", "order"], "valueBeforeMD5": ["valueBeforeAMD53", "valueInsideMD5", "valueInsideMD85", "valueBeforeMP53", "valueBeforeAMD5", "valueBeforemd3", "valueBeforemd85", "valueBeforemd5", "valueBeforeMD85", "valueBeforeAMD2", "valueInsideMD3", "valueAfterMD53", "valueAfterAMD53", "valueBeforemd2", "valueBeforeMC85", "valueBeforeMC3", "valueBeforeAMD3", "valueBeforeMD2", "valueAfterAMD2", "valueBeforeMP3", "valueAfterMD3", "valueAfterAMD5", "valueAfterMD2", "valueBeforeMD3", "valueBeforeMC5", "valueBeforeMD53", "valueBeforeMC2", "valueAfterAMD3", "valueBeforeMP2", "valueBeforeMP5", "valueInsideMD2"], "array": ["vector", "message", "app", "result", "shape", "expression", "arr", "cache", "ray", "feature", "instance", "our", "archive", "view", "area", "angle", "image", "data", "record", "object", "binary", "storage", "air", "integer", "database", "allow", "function", "number", "address", "api", "string", "list", "arrow", "element", "range", "batch", "sample", "value", "collection", "Array", "row", "any", "section", "error", "audio", "pair"], "sb": ["lp", "sbm", "bh", "buffer", "ab", "xb", "SB", "obb", "bb", "fb", "s", "buf", "lab", "bj", "sg", "pb", "src", "bl", "mb", " SB", "bp", "kb", "ib", "zb", "binary", "bf", "lb", "sth", "sa", "nn", "si", "bc", "rob", "bt", "usb", "nb", "bs", "sl", "rb", "eb", "gb", "bm", "BB", "lr", "orb", "sq", "ruby", "bsp", "wb", "sf", "ob", "sv", "cb", "abb", "stab"], "j": ["p", "x", "out", "ij", "length", "z", "br", "c", "jl", "f", "bj", "ii", "e", "i", "ie", "l", "k", "aj", "q", "n", "g", "job", "v", "jj", "num", "ja", "code", "obj", "ji", "ch", "li", "index", "dy", "jp", "pr", "y", "part", "key", "adj", "uj", "o", "end", "J", "js", "d", "jo"], "b": ["p", "x", "ab", "bar", "br", "cb", "c", "f", "bb", "fb", "e", "i", "pb", "l", "k", "mb", "B", "ib", "binary", "bf", "lb", "n", "bi", "be", "a", "bit", "bc", "job", "nb", "bs", "eb", "rb", "BB", "orb", "y", "bug", "ob", "bin", "db", "d"], "valueAfterMD5": ["valueAfterMP2", "valueAfterMP3", "valueAfterVM2", "valueAfterVM3", "valueAfterVM5", "valueAfterMD7", "valueBeforeMD7", "valueAfterAMD7", "valueBeforeMD2", "valueAfterAMD2", "valueBeforeMP3", "valueAfterMD3", "valueAfterMP7", "valueAfterAMD5", "valueAfterMD2", "valueBeforeMD3", "valueAfterVM7", "valueAfterAMD3", "valueAfterMP5", "valueBeforeMP2", "valueBeforeMP5", "valueBeforeMP7"]}}
{"id1": "17161805", "id2": "21016435", "code1": "    private String encode(String plaintext) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plaintext.getBytes(\"UTF-8\"));\n            byte raw[] = md.digest();\n            return (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(\"Error encoding: \" + e);\n        }\n    }\n", "code2": "    private String getFullScreenUrl() {\n        progressDown.setIndeterminate(true);\n        System.out.println(\"Har: \" + ytUrl);\n        String u = ytUrl;\n        URLConnection conn = null;\n        String line = null;\n        String data = \"\";\n        String fullUrl = \"\";\n        try {\n            URL url = new URL(u);\n            conn = url.openConnection();\n            conn.setDoOutput(true);\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            while ((line = rd.readLine()) != null) {\n                if (line.contains(\"fullscreenUrl\")) {\n                    data = line.trim();\n                }\n            }\n            rd.close();\n            System.out.println(data);\n            int start = 0;\n            String[] lines = data.split(\"&\");\n            String[] tmp = null;\n            String video_id = null;\n            String t = null;\n            String title = null;\n            for (int i = 0; i < lines.length; i++) {\n                if (lines[i].startsWith(\"video_id=\")) {\n                    tmp = lines[i].split(\"=\");\n                    video_id = tmp[1];\n                }\n                if (lines[i].startsWith(\"t=\")) {\n                    tmp = lines[i].split(\"=\");\n                    t = tmp[1];\n                }\n                if (lines[i].startsWith(\"title=\")) {\n                    tmp = lines[i].split(\"=\");\n                    title = tmp[1].substring(0, (tmp[1].length() - 2));\n                }\n                System.out.println(lines[i]);\n            }\n            System.out.println(\"So we got...\");\n            System.out.println(\"video_id: \" + video_id);\n            System.out.println(\"t: \" + t);\n            System.out.println(\"title: \" + title);\n            ytTitle = title;\n            fullUrl = \"http://www.youtube.com/get_video.php?video_id=\" + video_id + \"&t=\" + t;\n        } catch (Exception e) {\n            System.err.println(\"Error: \" + e.getLocalizedMessage());\n        }\n        progressDown.setIndeterminate(false);\n        return fullUrl;\n    }\n", "label": 0, "substitutes": {"encode": ["enode", "enscode", "encod", "ensoder", "ensode", "enccode", "enccod", "encoder", "Enoder", "Encode", "reode", "reoding", "recode", "Encod", "enoding", "enoder", "recod", "enscod", "encoding", "Enode", "Enoding"], "plaintext": ["longform", "bodytext", " plaincontent", " plainText", "plainstring", "plainform", "plainTEXT", "foretext", "foreTEXT", " plainstring", "longcontent", "foreText", "bodyform", "bodyText", "forestring", "plaincontent", "plainText", "batText", "battext", "batstring", "longText", "batTEXT", " plainform", "longtext", " plainTEXT", "bodycontent"], "md": ["me", "mand", "mm", "mp", "mod", "amd", "f", "wd", "cmd", "dm", "po", "mb", "meta", "ind", "m", "metadata", "ad", "mad", "mac", "grad", "rm", "sm", "ms", "um", "code", "pd", "sha", "gd", " MD", "od", "di", "dd", "hd", "cd", "MD", "dh", "mc", "ma", "df", "mag", "pm", "d", "rpm", "bd"], "raw": ["local", "remote", "buffer", "ode", "out", "dec", "clean", "load", "instance", "rew", "all", "unsigned", "ghost", "input", "shared", "Raw", "unknown", "binary", "missing", "internal", "original", "array", "initial", " hex", "hex", "ack", "alpha", "enc", "stream", " Raw", "micro", "block", "serial", "orig", "pure", "row", "custom", "pack", "feed", "blocks", "RAW"]}}
{"id1": "19113613", "id2": "8754809", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["create", "change", "clone", "share", "download", "write", "paste", "zip", "cop", "load", "process", "sync", "replace", "Cop", "cat", "update", "clip", "split", "p", "type", "upload", "ssh", "opy", "archive", "Copy", "transfer", "rm", "put", "move", "delete", "get", "cp", " cp", "save"], "in": ["ini", "image", "kin", "plugin", "base", "login", "index", "this", "inner", "inn", "input", "din", "In", "bin", "update", "c", "pin", "IN", "again", "token", "ic", "work", "part", "cin", "sin", "min", "diff", "client", "ins", "lin", "as", "name", "init", "inside", "a", "thin", "id", "data", "on", "i", "reader", "old", "n", "win", "get", "connection", "config", "project", "f", "url", "inc"], "out": ["err", "image", "base", "o", "outer", "other", "resource", "point", "self", "root", "this", "outside", "project", "input", "with", "net", "at", "version", "up", "group", "cache", "output", "OUT", "remote", "bin", "conn", "b", "object", "page", "null", "option", "c", "external", "again", "outs", "path", "work", "goal", "p", "part", "line", "io", "v", "x", "Out", "client", "block", "off", "app", "init", "name", "ext", "user", "vert", "parent", "call", "ex", "no", "dot", "n", "one", "connection", "inc", "exec", "obj"], "source": ["origin", "force", "unit", "base", "service", "resource", "SOURCE", "site", "prefix", "view", "Source", "direction", "format", "src", "use", "scope", "status", "class", "pe", "from", "position", "subject", "route", "family", "type", "ource", "attribute", "uri", "sin", "dest", "ce", "secret", "secure", "size", "missing", "name", "internal", "proxy", "component", "id", "reference", "alt", "parent", "username", "feature", "iter", "project", "url"], "target": ["origin", "force", "base", "service", "resource", "site", "detail", "config", "prefix", "root", "current", "point", "alias", "direction", "format", "wrong", "pattern", "Target", "top", "master", "src", "output", "cat", "home", "null", "about", "tail", "route", "token", "path", "next", "goal", "dest", "name", "host", "component", "reference", "alt", "parent", "value", "arget", "template", "project", "url", "address"], "files": ["resources", "ports", "objects", "keys", "flows", "lines", "ls", "plugins", "links", "children", "sections", "filename", "blocks", "tools", "iles", "apps", "groups", "obs", "images", "Files", "ions", "cells", "jobs", "items", "fs", "ins", "users", "models", "features", "docs", "pages", "data", "classes", "names", "assets", "results", "f", "s"], "file": ["File", "folder", "letter", "unit", "base", "resource", "child", "feed", "current", "function", "ile", "entry", "fe", "load", "local", "filename", "l", "b", "object", "page", "url", "string", "future", "item", "path", "single", "line", "part", "uri", " File", "it", "entity", "fp", "layer", "dir", "FILE", "le", "name", "live", "data", "id", "binary", "e", "el", "per", "lib", "parent", "f", "directory"], "inCh": ["InCh", "inch", "inChan", "InChan", " inChannel", " inch", "outCH", " inChan", "INCh", "outChan", "outChannel", " inCH", "INChan", "inChannel", "Inch", "INCH", "InChannel", "INChannel", "InCH", "inCH", "outch"], "outCh": ["inch", "inChan", " outChannel", "OutCH", "outputChan", "outCH", " outch", "outChan", "outputch", "Outch", "outChannel", "OutChannel", " outCH", "inChannel", "OutCh", "outputCH", "inCH", "OutChan", "outputCh", "outch"]}}
{"id1": "8468859", "id2": "3536332", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"connect": ["bind", "exec", "stat", "client", "establish", "Connect", "login", "port", "sign", "log", "boot", "host", "start", "conn", "on", "patch", "write", " reconnect", "build", "read", "en", "nect", "construct", "connection", " disconnect", " connection", "config", "find", "stop", "socket", "close", "add", "init", "download", "create", "con", "open", "select", "connected", "run"], "status": ["complete", "result", "stat", "Status", "login", "str", "output", "site", "use", "id", "current", "progress", "skip", "log", "index", "session", "ui", "state", "success", "si", "step", "code", "type", "wait", "active", "count", "user", "parent", "speed", "sync", "standard", "edit", "update", "version", "min", "content", "continue", "source", "server", "style", "stage", "summary", "fail", "full", "unit", "response", "temp"], "reply": ["address", "result", "base", "error", "ping", "send", " response", "call", "answer", "request", "vote", "py", "state", "action", "ret", "next", "link", "prefix", "bot", "respond", "code", "reason", "repl", "connection", "count", "info", "Reply", "query", "sync", "post", "message", "update", "fee", "dy", "data", "resp", "server", "random", "second", "comment", "response"], "isConnected": ["isAccepted", "isNECTished", "isConnectioning", "isConnectable", "IsConnectp", " isConnectioned", "isaAdapted", "IsConnects", " isConnectaged", " isConnectable", " isAcceptable", "isFinished", "isFinaged", "isAcceptable", "isNECTalled", "isNECTing", "isConnectished", "isFining", "isConnectionp", "isConnectionalled", " isConnectionished", "isaAdapteded", "isConnections", "isConnectioneded", " isConnectioning", "isconnecteded", "isaAdapting", " isConnectished", "IsConnectioned", "isAcceptaged", " isConnecting", " isAcceptted", "isConnecting", "isNECTed", "IsConnecting", "IsConnections", "isAdapted", "isAdapting", "isaConnectified", "isConnectified", "isAdaptified", " isConnectalled", "isConnectionished", "isaAdaptified", "isaConnecting", "isconnecteds", "isFined", "IsConnected", "isFinalled", "isconnectedp", "isConnectalled", "isConnectaged", " isConnectted", "isConnectionified", "isConnectioned", "isaConnecteded", "IsConnectionp", " isAcceptaged", "isAdapteded", "isConnectted", "isFinable", "isAcceptted", " isAccepted", "isConnectp", "isaConnected", "IsConnectioning", " isConnectionalled", "isConnecteded", "isConnects", "isFinted", "isconnecteding"]}}
{"id1": "3584508", "id2": "5138455", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyResource": [" downloadresource", " copyresource", " downloadUrl", "copyFile", " copyUrl", "copyresource", "copyUrl", "transferUrl", " downloadResource", " copyFile", "transferResource", "transferresource", " downloadFile", "transferFile"], "url": ["ls", "page", "uri", "ssl", "resource", "image", "server", "connection", "loc", "remote", "data", "f", "www", "URL", "ref", "bel", "download", "xml", "source", "src", "stream", "l", "lr", "web", "base", "r", "object", "id", "address", "string", "ource", "file", "loader", "re", "name", "sl", "host", "path", "Url", "http", "feed"], "input": ["request", "ssl", "resource", "image", "connection", "form", "act", "data", "this", "session", "inc", "socket", "in", "f", "audio", "index", "error", "reader", "accept", "out", "inf", "temp", "instance", "i", "source", "xml", "api", "config", "pull", "element", "qa", "progress", "stream", "l", "ack", "parse", "inner", "base", "client", "Input", "cache", "address", "exec", "bin", "file", "load", "upload", "binary", "get", "context", "current", "plus", "buffer", "but", "active", "http", "feed", "bb", "open"], "output": ["log", "writer", "console", "default", "unit", "resource", "write", "image", "flow", "copy", "connection", "outer", "data", "socket", "external", "application", "document", "result", "out", "source", "Output", "config", "network", "stream", "target", "web", "queue", "control", "object", "cache", "address", "file", "other", "binary", "ou", "layer", "environment", "response", "operation", "current", "put", "buffer", "production"], "b": ["buf", "k", "m", "p", "e", "n", "fb", "bit", "lb", "bc", "sb", "f", "bs", "pb", "d", "rb", "batch", "cb", "mb", "h", "bf", "B", "i", "a", "l", "db", "base", "bar", "r", "br", "v", "bin", "c", "file", "be", "ob", "binary", "bi", "x", "buffer", "ab", "abs", "nb", "line", "bb"]}}
{"id1": "6379126", "id2": "7006052", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"gerarTutorialPage": ["riarTutorialPage", "riartutorialDir", "riartourDir", "riarTravisDir", "riarTourElement", "riarTravispage", "riarTravisPage", "riarTourDir", "riarTourpage", "riarTinyDir", "riartutorialPage", "riarTinyPage", "riarTravisElement", "riarTutorialDir", "riarTinypage", "riarTinyElement", "riarTutorialElement", "riartutorialpage", "riartourpage", "riartourElement", "riarTourPage", "riartourPage", "riarTutorialpage", "riartutorialElement"], "indexDir": ["IndexTier", "IndexDir", "includeTier", "indexTier", "includeJar", "indexJar", "zipDIR", "zipDir", "includeDir", "IndexJar", "zipJar", "IndexDIR", "includeDIR", "zipTier", "indexDIR"], "cssDir": ["fontDie", "piecesD", "ssDar", "javascriptDir", "codesLen", "ssUrl", "catsDoc", "CSSLen", "CSSDIR", "fontDir", "javascriptDb", "gzDIR", "ssDir", "CSSDoc", "cssDar", "ssDie", "cssLen", "codesDoc", "cssUrl", "cssDb", "ssDIR", "codesDir", "CSSDir", "catsDir", "cssD", "CSSDar", "piecesDIR", "CSSDb", "fontDIR", "CSSUrl", "javascriptDar", "gzDir", "ssDb", "ssD", "ssDirectory", "gzDirectory", "javascriptDIR", "cssDoc", "catsLen", "piecesDir", "cssDirectory", "gzUrl", "piecesDie", "cssDIR", "CSSDirectory", "fontD", "cssDie"], "capDir": ["casdir", "apsDirectory", "apsdir", "CapDirectory", "apsVol", "CapDir", "casDir", "capdir", "capDirectory", "capVol", "casVol", "apsDir", "casDirectory", "CapVol", "Capdir"], "licDir": ["lifManager", "licDoc", "libDir", "lifDoc", "libdir", "volDir", "libManager", "licdir", "volManager", "libDoc", "volDoc", "licManager", "voldir", "lifDir", "lifdir"], "midDir": ["casdir", "middir", "mindTier", "midTier", "mindDir", "casTier", "limdir", "midDIR", "limDir", "casDir", "mindDIR", "limTier", "casDIR", "limDIR", "minddir"], "filesDir": ["filesDur", "stylesDirectory", "stylesDur", "pagesDir", "stylesDIR", "imagesDirectory", "ballsPos", " filesVol", "opensDir", "filesDirectory", "filesVol", "pagesVol", "filesFile", "filesPos", "locksDIR", "stylesDir", "videosFile", " filesPos", "FilesFolder", "opensDIR", "locksDir", "opensDirectory", "locksDur", "locksDirectory", "opensDur", "videosDirectory", "imagesDir", "videosFolder", "filesDIR", "pagesPos", "FilesFile", "imagesFolder", "filesFolder", "ballsDir", "ballsVol", "FilesDir", "imagesFile", "FilesDirectory"], "videosDir": ["viewsDir", "videoFile", "videosDb", "viewsUrl", "videoDirectory", " videosFile", "videoDb", "videosFile", "viewsFile", " videosDirectory", "imagesDb", "videosDirectory", "viewsDirectory", " videosUrl", "imagesDir", "videoDir", "videosUrl", "videoUrl", " videosDb"], "imagensDir": ["imgensDir", "imagensJar", "imgensFile", "imagersDIR", "imagersJar", " imagensFile", "imagenciesDir", "imagentsJar", " imagersDir", "imagensFile", "imgensDIR", "imgentsFile", "imagenDirectory", " imagensDirectory", " imagensJar", "imgentsDir", "imagenciesDIR", "imagersDirectory", "imagentsDIR", "imagenJar", "imagenciesDirectory", "imagenFile", " imagersJar", "imagensDirectory", "imagentsFile", "imagenciesFile", "imgensDirectory", "imagensDIR", "imagenDir", " imagersFile", "imagentsDirectory", "imagersFile", " imagersDirectory", "imgentsDIR", "imagersDir", "imagentsDir", "imgentsDirectory"], "local": ["p", "util", "remote", "current", "json", "Location", "path", "username", "available", "inner", "basic", "home", "back", "state", "http", "pass", "Local", "input", "l", "pal", "localhost", "present", "global", "shared", "defined", "loc", "data", "total", "location", " Local", "LOC", "where", "personal", "internal", "self", "directory", "valid", "base", "name", "tmp", "log", "small", "initial", "standard", "relative", "conf", "upload", "specified", "managed", "lock", "prefix", "safe", "serial", "file", "temp", "request", "part", "partial", "dir", "user", "same", "d", "active"], "srcCss1": ["srcCpePre", "srcPcssPre", "srcPss1", "srcCfg2", "srcCse2", "srcRcss0", "srcCcss1", "srcPss2", "srcCfg4", "srcRcss81", "srcCss0", "srcCss11", "srcPss4", "srcPcss1", "srcCcss2", "srcCcssPre", "srcCfg1", "srcRss11", "srcRcss11", "srcCcss4", "srcPcss81", "srcCass3", "srcCcss3", "srcCcss11", "srcPssPre", "srcPss81", "srcCfgPre", "srcCss81", "srcCass11", "srcRss0", "srcCass2", "srcCrss81", "srcRcss2", "srcPcss4", "srcCrss3", "srcRss2", "srcCrss1", "srcRcss1", "srcCrss11", "srcCass81", "srcCssPre", "srcPss3", "srcCcss81", "srcCpe2", "srcCse1", "srcCass0", "srcCse0", "srcPcss3", "srcCse11", "srcCcss0", "srcCpe1", "srcCrss2", "srcCpe4", "srcPcss2", "srcRss1", "srcCass1", "srcRss81"], "destCss1": ["destPss3", "destCass1", "destCrss1", "destPss1", "destCass2", "destCrss2", "destPcssCard", "destPss81", "destPcss81", "destCrss81", "destCxx2", "destPcss2", "destCss0", "destCassCard", "destCfg1", "destCcss2", "destCfg0", "destCss81", "destPss0", "destPssCard", "destCcss0", "destCssCard", "destPss2", "destCxx3", "destPcss0", "destCass3", "destCxxCard", "destCcssCard", "destCcss1", "destCfg2", "destCrss0", "destPcss1", "destPcss3", "destCcss3", "destCass81", "destCfg3", "destCrss3", "destCcss81", "destCxx1"], "srcCss2": ["srcCcssB", "srcChess2", "srcAcss1", "srcPss1", "srcCfg2", "srcPcss27", "srcCass52", "srcCcss1", "srcCfgTwo", "srcPss2", "srcAccss2", "srcCcss52", "srcCng1", "srcCssB", "srcCfgB", "srcCross4", "srcCfgL", "srcCss27", "srcChessTwo", "srcPcss1", "srcCcss2", "srcCssTwo", "srcCfg1", "srcCross52", "srcUcss1", "srcCcss4", "srcCcss3", "srcUcssTwo", "srcCross1", "srcCng2", "srcUss2", "srcCrssL", "srcCass2", "srcAccss4", "srcAcss4", "srcCng27", "srcCrss3", "srcCfg3", "srcPssL", "srcUss1", "srcCrss1", "srcChess1", "srcCross2", "srcPss3", "srcAcss2", "srcUssB", "srcAcss52", "srcUssTwo", "srcCss52", "srcPcssL", "srcChessB", "srcPcss3", "srcAccss1", "srcCcss27", "srcPss27", "srcUcss2", "srcCrss2", "srcPcss2", "srcCssL", "srcCcssTwo", "srcCcssL", "srcUcssB", "srcCass1", "srcCass4", "srcAccss52", "srcCrss27"], "destCss2": ["destNcss32", "destCest2", "destNss4", "destCfg32", "destNss2", "destNss1", "destCfg72", "destNcssB", "destNcss3", "destCess2", "destNssB", "destCess4", "destCcssB", "destNcss72", "destNss32", "destCcss32", "destCess1", "destNcss2", "destCess72", "destCfg1", "destCcss2", "destCfgB", "destCssB", "destCcss72", "destCss72", "destCest3", "destCss32", "destCfg2", "destNss3", "destCcss1", "destCestB", "destCcss4", "destNcss4", "destCest1", "destCcss3", "destCess32", "destNss72", "destCfg3", "destCfg4", "destNcss1"], "srcCss3": ["srcCcss6", "srcPss2", "srcCss183", "srcClass15", "srcCcss15", "srcCcss4", "srcCssAND", "srcRcss4", "srcCass2", "srcPcssAND", "srcRcss1", "srcPss3", "srcPcss6", "srcRcssThird", "srcCass1", "srcCfg2", "srcCstyle6", "srcCstyle93", "srcCcss93", "srcCfg4", "srcCfg1", "srcCsh2", "srcCass3", "srcCcss183", "srcCrss3", "srcCfg3", "srcRss4", "srcPssAND", "srcScstyle2", "srcRss2", "srcCss93", "srcScss15", "srcClass3", "srcCssThird", "srcPcss3", "srcCss15", "srcRss1", "srcCcssAND", "srcRss183", "srcCcss1", "srcRssThird", "srcCsh183", "srcCsl3", "srcCstyle3", "srcCshThird", "srcScstyle15", "srcCrss6", "srcRcss183", "srcScss3", "srcCsh3", "srcRss3", "srcCstyleAND", "srcCstyle15", "srcCstyle2", "srcScstyle93", "srcCcss2", "srcCcss3", "srcScstyle3", "srcRcss3", "srcScss93", "srcRcss2", "srcCsl183", "srcClass2", "srcCrssAND", "srcCcssThird", "srcCslThird", "srcClass93", "srcCsl2", "srcCrss2", "srcPcss2", "srcPss6", "srcCass4", "srcScss2"], "destCss3": ["destScrss2", "destCcss183", "destPss3", "destCcss03", "destScrss183", "destNss2", "destScss183", "destNcss3", "destNcss43", "destNss43", "destCross2", "destCass2", "destCstyle2", "destCrss2", "destScss2", "destCstyle43", "destCross53", "destScss6", "destCss53", "destPss53", "destCrss6", "destCja2", "destCja3", "destPcss53", "destCja6", "destCross03", "destNcss2", "destPcss2", "destCstyle3", "destCstyle03", "destScss3", "destCcss43", "destCass43", "destCja183", "destPss2", "destCass3", "destNss3", "destCstyle53", "destCross3", "destCcss6", "destPcss03", "destCss03", "destCrss183", "destPss03", "destScrss3", "destPcss3", "destCcss53", "destCcss3", "destScrss6", "destCrss3", "destCss43", "destCcss2", "destCss183"], "srcCss4": ["srcCcssFour", "srcPcssFour", "srcPss1", "srcCcss1", "srcPss2", "srcPss4", "srcPcss1", "srcCcss2", "srcCcss4", "srcPssFour", "srcCass2", "srcCrssFour", "srcPcss4", "srcCrss4", "srcCrss1", "srcCassFour", "srcCssFour", "srcCrss2", "srcPcss2", "srcCass1", "srcCass4"]}}
{"id1": "19335986", "id2": "12766394", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["CaughtException", "uncachedexc", "uncatchedexc", "uncaughtEvent", "CatchedEvent", "Catchedexc", "Caughtexc", "uncaughtexc", "uncachedEvent", "uncachedException", "uncatchedException", "unchandledException", "unchandledexc", "CatchedException", "uncatchedEvent", "CaughtEvent", "unchandledEvent"], "t": ["n", "c", "l", "s", "te", " T", "ty", "type", "d", "r", "g", "w", "out", "p", "ts", "let", "title", "m", "tree", "ing", "it", " td", "T", "tr", "ed", "f", "tx"], "e": ["event", "fe", "i", "ace", "ee", "be", "ie", "eb", "c", "ge", "j", "se", "o", "s", "el", "ception", "ele", "en", "ec", "er", "d", "ce", "diff", "r", "data", "de", "exc", "ep", "p", "es", "ae", "environment", "ne", "eu", "example", "m", "E", "ev", "ed", "pe", "me", "err", "f", "error", "oe", "Exception", "element", "code", "enter", "esi"], "display": ["play", "fe", "console", "panel", "report", "profile", "description", "window", "host", "layout", "content", "monitor", "scroll", "d", "hide", "show", "default", "config", "de", "body", "page", "object", "p", "style", "dis", "status", "image", "screen", "Display", "position", "app", "me", "summary", "design", "container", "process", "this", "view", "platform"], "shell": ["hell", "buffer", "console", "server", "copy", "lock", "mail", "system", "echo", "l", "child", "host", "el", "clone", "loop", "tools", "sb", "live", " Shell", "machine", "math", "body", "cl", "launch", "h", "environment", "log", "bash", "m", "exec", "image", "status", "Shell", "ml", "kernel", "sym", "app", "sh", "sound", "b", "poll", "container", "process", "xml", "help", "gui", "cli", "tool"], "message": ["event", " exception", "address", "buffer", "translation", "mess", "console", "server", "output", "copy", "response", "report", "mail", "document", "description", "result", "management", "queue", "content", "monitor", "email", "member", "value", "media", "model", "application", "data", "body", "page", "object", "request", "flash", "Message", "log", "msg", "header", "m", "meter", "status", "image", " messenger", "update", "summary", "xml", "essage", "error", "view"], "e1": [" e3", "e3", "exc2", "e8", " e2", "E1", "e2", "E3", "E2", " e8", "E8", "exc3", "exc8", "exc1"]}}
{"id1": "16232202", "id2": "8064604", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"doPost": ["doingPut", "didPost", "doingPOST", "didPOST", "didPut", " doPOST", " doPut", "doSend", "doPut", "didSend", " doSend", "doPOST", "doingPost", "doingSend"], "request": ["event", "remote", "info", "order", "error", "input", "Request", "server", "resource", "self", "user", "list", "register", "report", "enter", "rf", "subject", "message", "current", "project", "result", "join", "instance", "child", "press", "query", "save", "condition", "req", "queue", "post", "next", "er", "client", "select", "rate", "session", "reader", "type", "use", "q", "load", "application", "upload", "store", "parent", "data", "route", "web", "object", "page", "get", "context", "row", "hello", "complete", "submit", "e", "QUEST", "image", "url", "create", "you", "parse", "xml", "state", "method", "re", "external", "view", "initial"], "response": ["index", "server", "output", "resource", "feed", "serv", "uri", "http", "report", "res", "message", "document", "subject", "site", "onse", "fire", "result", "forward", "shell", "pool", "query", "su", "ception", "en", "next", "exit", "session", "resp", "model", "application", "parent", "de", "body", "page", "environment", "object", "web", "ae", "reply", "complete", "tree", "e", "status", "writer", "image", "re", "Response", " Response", "respond", "we", "wa", "error", "esi", "service", "api", "view"], "cu": ["U", "ou", "tc", "cc", "lu", "cf", "rc", "aca", "ue", "c", "ru", "CU", "co", "du", "su", "ui", "agu", "Cu", "ku", "uu", "VC", "cus", "chu", "vc", "asu", "ce", "lc", "uc", "cy", "tu", "ca", "xc", "usa", "CA", "u", "eu", "uni", "hu", "ci", "coll", "uci", "ucc", "mc", "cum", "cci", "cul", "ac", "CI", "gu", "ul", "UC", "cin", "nu", "cli", "cur", "cca", "loc"], "ud": ["uds", "ou", "um", "uri", "lu", "user", "df", "rc", "od", "ck", "ue", "uv", "ru", "uid", "pub", "du", "su", "ui", "usr", "util", "ku", "uu", "ad", "cus", "uf", "gb", "chu", "asu", "uc", "uda", "ug", "UD", "ut", "upload", "au", "tu", "li", "utils", "udi", "ub", "usa", "usc", "u", "uli", "eu", "ci", "db", "us", "bug", "auth", "ur", "wik", "vd", "gu", "ada", "da", "cli", "pd", "stri", "dd", "storage"], "returnTo": ["exitFrom", "exitTo", "accessFrom", "ReturnFrom", "accessTO", "backto", "outputto", "exitTO", "outputTo", "outputTO", "returnFrom", "backTO", "backTo", "ReturnTo", "Returnto", "backFrom", "returnTO", "exitto", "replyto", "replyTo", "ReturnTO", "outputFrom", "replyFrom", "accessto", "returnto", "accessTo", "replyTO"], "password": ["string", "address", "sum", "mask", "username", "token", "user", "message", "confirmed", "account", "patch", "wd", "key", "params", "Password", "email", "mac", "PASS", "sha", "diff", "login", "sword", "data", "encrypted", "null", "name", "ass", "word", "wallet", "pa", "auth", "secret", "pad", "padding", "crypt", "phrase", "pg", "code"], "md": ["mag", "bd", "df", "managed", "od", "amd", "mo", "ma", "am", "meta", "wd", "MD", "dc", " MD", "rpm", "sm", "ms", "mb", "mt", "mac", "d", "mp", "hd", "sha", "diff", "mm", "cd", " Md", "dig", "m", "dm", "db", "mand", "mc", "mn", "vd", "rm", "mg", "mad", "f", "cmd", "dd", "pg"], "hash": ["total", "base", "sum", "her", "user", "version", "ref", "kh", "confirmed", "hex", "Hash", "number", "tag", "ash", "key", "char", "raw", "no", "mac", "cache", "dot", "rh", "sha", "diff", "h", "row", "dig", "ass", "hed", "array", "db", "url", "sh", "auth", "secret", "block", "code"], "pass": ["push", "string", "sum", "mess", "id", " mess", "user", " mac", "act", "ref", "wd", "key", "fail", " passed", " auth", "mac", "PASS", "phrase", "login", "diff", "r", "ask", "text", "Pass", " def", "gen", "row", "conn", "ass", " login", "pos", "az", "ss", "db", "sl", "strip", "pa", "secret", "auth", " Pass", "conf", "sign", "def", " secret"], "vis": ["class", "att", "qa", "cross", "id", "ex", "spot", "travel", "act", "c", "lab", "miss", "ref", "rib", "host", "press", "mit", "su", "dc", "san", "feat", "visible", "type", "stat", "see", "acc", "nav", "ip", "keep", "style", "lit", "tri", "name", "coll", "nic", "vest", "status", "VIS", "exp", "ravis", "access", "circ", "virt", "vid", "na", "skip", "nat", "secret", "shape", "design", "gu", "sign", "Vis", "wa", "state", "vert", "fac", "view", "mis"]}}
{"id1": "14324112", "id2": "14303294", "code1": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "code2": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "label": 1, "substitutes": {"innerProcess": ["innerprocess", "middleAccept", " innerMethod", " outerMethod", " innerAccept", "middleMethod", "middleprocess", "innerMethod", " outerAccept", "innerAccept", " innerprocess", "middleProcess", " outerProcess", " outerprocess"], "curi": ["luni", "numi", "lciri", "cuid", "Ciri", "biri", "lcri", "bURI", "cuni", "nuri", "lumi", "cui", "ctiri", "cacheuri", "funi", "cdu", "fri", " cuni", "furi", "CURI", "ctURI", "requuni", "ciri", "cURI", "requiri", "cturi", "luid", "ucURI", "buri", " cdu", "cacheui", " cui", "Cui", "cachedu", "cdirectory", " cuid", "requumi", " cURI", "ctuid", "lri", " cdirectory", "ucuri", "uciri", "lcui", "fURI", "lURI", "liri", "Cri", "fcri", " couri", "ldirectory", "lcURI", "Curi", " ciri", "fcumi", "firi", "Couri", "cacheURI", "Cdu", "cumi", "bdirectory", "ucuni", " cri", "lcuri", "couri", "luri", "requuri", "fui", "fcURI", " cumi", "lcouri", "cri", "fcuri", "nri", "nURI"], "maxsize": ["axize", "axsize", "totalsize", "Maxsize", "MaxSIZE", " maxSIZE", " maxname", "lastsize", "minSize", "defaultsize", "axSize", "MAXname", "MaxSize", " maxscale", "lastSize", "totalize", "maxname", "totalscale", "MAXSIZE", "minsize", "maxSIZE", "maxaddress", " maxSize", "Maxscale", "Maxname", "maxSize", "maxscale", "lastaddress", "minaddress", "Maxize", " maxaddress", " maxize", "defaultize", "MAXsize", "maxize", "defaultSize", "totalSize", "MAXSize"], "regexpr": ["replayor", "rerePr", "perepr", "regexpl", "pegexPr", "REgexr", "regexpp", "refgexpp", "regexexpr", "regexpect", "requpr", "refgexPr", "regexPR", "refgexpl", "egexpr", "egexPr", "rentaxexpr", "rereexpr", "reqor", "pegexexpr", "rerePR", "regexr", "rerexpr", "replaypt", "reuxpr", "rentaxPR", "replexexpr", "requpect", "REgexpr", "reuxpl", "REqpr", "egexps", "replexPR", "replaypr", "equpect", "REgexor", "regexpt", "perePR", "rerexps", "requPr", "rexpr", "resexPr", "reuxPr", "REgexpt", "replexpl", "refplexpp", "pereexpr", "resexps", "regexps", "REqor", "refplexpr", "refgexpr", "resexpr", "refplexpl", "rexpl", "rerexPr", "replexpr", "regexPr", "rentaxpr", "reuxpp", "REqpt", "pegexpr", "rexPr", "replexPr", "refplexPr", "resexpect", "replexpp", "rerexpect", "reqpr", "rerepr", "pegexPR", "egexpect", "perePr", "rexpp", "requps", "regexor", "replayr", "equps", "equPr", "equpr", "reqr", "rentaxPr", "REqr", "reqpt"], "cs": ["ts", "cn", "cos", "sc", "TS", "ds", "ca", "GC", "bs", "ences", "ins", "acks", "sync", "ns", "cms", "ics", "str", "ec", "pc", "lc", "ls", "cells", "cache", "css", "cr", "rs", "wcs", "ras", "ks", "cc", "ci", "ctx", "qs", "cf", "js", "ces", "spec", "ch", "cl", "gs", "ps", "c", "ce", "acs", "cks", "tc", "coll", "cas", "cm", "mc", "CS", "ches", "cons", "ms", "cp", "cus", "fs", "Cs", "acts"], "digest": ["signEST", "signusher", "returnEST", " diger", "DigEST", "diggest", "Digester", "Digusher", " digusher", "shaher", "shaest", "returnester", "digester", "digEST", "returnest", "signester", "shaer", " digEST", "digher", "returngest", "diger", "digusher", "Diggest", "Diger", "signest", "Digher", "shaEST", " digester", "Digest", " diggest", " digher"], "s": ["sl", "su", "f", "si", "session", "g", "groups", "services", "sets", "sync", "p", "ns", "str", "summary", "ls", "cells", "u", "b", "w", "sv", "l", "r", "single", "o", "lines", "strings", "d", "i", "S", "ws", "t", "js", "h", "v", "n", "ps", "details", "c", "params", "states", "sb", "ss", "ms", "string"], "m": ["bm", "gm", "f", "machine", "rm", "g", "p", "arm", "im", "b", "text", "imm", "am", "M", "wm", "mac", "l", "r", "dm", "ym", "um", "sm", "i", "d", "mo", "t", "h", "tm", "v", "mi", "n", "mm", "pm", "cm", "mc", "fm", "ms", "nm"]}}
{"id1": "12766394", "id2": "8079516", "code1": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 1, "substitutes": {"testReadHelloWorldTxt": ["testReadHelloWorldTXT", "testReadHelloWordTtxt", "testReadHelloWorldMXT", "testReadHelloWorldFext", "testReadHelloWorldText", "testReadHelloWordText", "testReadHelloWordMtxt", "testReadHelloWorldMtxt", "testReadHelloWordTxt", "testReadHelloWorldFtxt", "testReadHelloWordMxt", "testReadHelloWorldMext", "testReadHelloWorldMxt", "testReadHelloWorldTtxt", "testReadHelloWorldFXT", "testReadHelloWordMXT", "testReadHelloWordTXT", "testReadHelloWordMext", "testReadHelloWorldFxt"], "helloWorldIS": ["helloCommunityIs", "helloWorldIDE", " helloCityIS", " helloWorldIs", "helloCityIS", "helloCommunityIDE", "helloWestAS", "helloCityIR", "helloWestIS", "helloWestIR", "helloWorldis", "helloCityIs", " helloWorldIR", " helloCityIs", "helloCommunityIS", " helloCityIR", " helloWorldAS", " helloWorldIDE", "helloWestIs", "helloCityAS", " helloCityAS", "helloWorldIR", "helloWorldIs", "helloCityIDE", "helloCityis", "helloWorldAS", " helloWorldis"], "helloWorldPath": [" helloWorldDir", "helloworldPATH", "officeCommunityLocation", "helloWebUrl", "officeCommunityCorp", "helloWallName", "helloWorldName", "helloCommunityName", "hiWebpath", "helloWebpath", "helloWallPath", "helloWorldDir", "officeWorldPath", "hiWorldpath", "officeWorldLocation", "helloWallDir", "helloWebFile", "helloworldPath", "officeCommunityPath", " helloWorldName", " helloWorldpath", "officeWorldCorp", "officeCommunityPATH", "helloCommunityLocation", "helloWebPath", "helloCommunityCorp", "hiWorldUrl", "helloWorldUrl", "hiWebUrl", "helloWallpath", "helloworldLocation", "helloCommunityPATH", "helloCommunityPath", "hiWebFile", "helloWorldpath", "hiWebPath", "helloWorldCorp", "hiWorldPath", "helloworldCorp", "helloWorldPATH", "helloCommunityDir", "helloWorldLocation", "officeWorldPATH", "hiWorldFile", "helloCommunitypath", "helloWorldFile"], "fileOutputStream": ["fileWriteStream", "FileOutputstream", "fileOutputFile", "fileInputStream", "fileOutFile", "resourceInputSteam", "resourceOutputFile", "resourceOutputSteam", "resourceOutputPath", "fileWriteSteam", "resourceInputFile", "FileInputSteam", "resourceInputPath", "FileOutputHandler", "FileOutputSteam", "fileInputHandler", "FileOutputStream", "fileOutSteam", "fileInputPath", "fileoutputSteam", "fileWritePath", "fileOutputSteam", "FileInputStream", "FileInputstream", "fileoutputstream", "fileOutputHandler", "resourceOutputStream", "fileWritestream", "fileoutputStream", "fileoutputHandler", "FileInputFile", "fileInputFile", "fileOutPath", "fileWriteFile", "fileInputSteam", "FileOutputFile", "fileInputstream", "fileOutputstream", "fileOutStream", "FileInputHandler", "resourceInputStream", "fileOutputPath"], "contentResolver": [" contentresolver", "contentRoser", " contentresolution", "messageResultolver", "resourceResolve", "contentRevolve", "resourceResolver", "contentRolution", "contentresolver", "contentResponseolver", "resourceRolver", "contentRolving", "ContentRolver", "contentRlier", "contentResponseistor", "contentResistor", "contentRevolved", "messageResolver", "contentresolution", "contentRolve", " contentResolved", "contentResolves", "ContentRolution", " contentRevolve", "contentAbsolver", "contentResponseolve", "contentResultolve", "contentResponseolved", " contentRevistor", "contentAbsolution", "ContentResoser", "messageResultolution", "ContentResolution", "contentReslier", "ContentResolver", "contentResolve", "ContentResolving", "contentResolution", "resourceResolution", "contentResultlier", "messageResolution", "contentResoser", "contentRevolver", " contentResolution", "contentreslier", "contentAbsolve", "contentRolver", "messageReslier", "ContentResolve", "contentRevistor", "contentresolve", "contentResultistor", "contentAbsoser", " contentResolves", "contentresolving", "resourceRolution", "contentresolved", " contentRevolved", " contentResistor", "ContentRoser", "contentResolving", "contentRolves", "messageResultlier", "contentResultolver", "contentRevolution", "contentresolves", " contentresolves", "resourceResolved", "contentResolved", "contentRolved", "contentResultolved", "ContentRolve", "resourceRolve", "contentResultolution", "messageResultolve", " contentRevolver", " contentResolve", "ContentRolving", "contentRevolves", "resourceRolved", " contentresolve", "messageResolve"], "content": ["body", "image", "model", "lc", "html", "draft", "resource", "Content", "feed", "script", "child", "cont", "temp", "current", "write", "json", "children", "version", "text", "message", "cache", "load", "play", "output", "java", "password", "media", "conn", "full", "column", "page", "update", "string", "code", "read", "example", "fill", "status", "core", "path", "work", "next", "job", "result", "css", "response", "layer", "handle", "xml", "ontent", "size", "any", "name", "title", "ext", "word", "server", "data", "file", "valid", "document", "header", "value", "comment", "activity", "complete", "empty", "default", "connection", "config", "parent", "url", "copy", "address"]}}
{"id1": "4852691", "id2": "7372311", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["get", " fingerprint", " hashing", "str", "dump", "log", "dig", "copy", "add", "check", "component", "text", "password", " Hash", "build", "pack", "h", "sum", "update", "code", "read", " hashes", "print", "Hash", "string", "SHA"], "data": ["reader", "connection", "s", "database", "audio", "body", "p", "info", "str", "dump", "hex", "binary", "base", "format", "video", "text", "output", "bytes", "content", "key", "address", "buffer", "padding", "source", "storage", "image", "response", "memory", "DATA", "a", "message", "result", "input", "dat", "length", "json", "string", "media"], "digest": ["signEST", " diger", "digit", "DigEST", "digener", " digests", "Digester", "biger", "signests", "digester", "Digse", "logener", "bigester", "digEST", "Digener", "bigest", " digger", "digger", "logester", "digse", "bigEST", "signester", " digEST", "diger", "Digger", "logest", "signer", "Diger", "signest", "signger", " digse", "loger", "digests", "Digit", " digit", "signit", " digener", "signse", " digester", "Digest", "Digests", "bigger"]}}
{"id1": "16353490", "id2": "720361", "code1": "    private String executePost(String targetURL, String urlParameters) {\n        URL url;\n        HttpURLConnection connection = null;\n        try {\n            url = new URL(targetURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(urlParameters.getBytes().length));\n            connection.setRequestProperty(\"Content-Language\", \"en-US\");\n            connection.setUseCaches(false);\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            wr.writeBytes(urlParameters);\n            wr.flush();\n            wr.close();\n            InputStream is = connection.getInputStream();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n            String line;\n            StringBuffer response = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                response.append(line);\n                response.append('\\r');\n            }\n            rd.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        int result = 20;\n        if (args.length == 1) {\n            StringBuffer urlString = new StringBuffer(args[0]);\n            if (urlString.lastIndexOf(\"/\") != urlString.length() - 1) {\n                urlString.append('/');\n            }\n            urlString.append(\"GetConfig.jsp\");\n            URLConnection conn = new URL(urlString.toString()).openConnection();\n            System.out.println(Configuration.readObject(conn.getInputStream()));\n            result = 0;\n        } else {\n            System.err.println(\"usage: GetConfig <URL>\");\n        }\n        System.exit(result);\n    }\n", "label": 0, "substitutes": {"executePost": ["executePut", "executePosts", "sendPosts", "sendPut", "executePOST", "invokePOST", " executePosts", "sendPost", "invokePost", " executePOST", "invokePosts", " executePut", "invokePut", "sendPOST"], "targetURL": [" targetUrl", "targeturl", "sourceURL", "TargetUrl", " targetLocation", "outputURI", "outputURL", "TargetLocation", "outputurl", "Targeturl", "sourceUrl", "targetURI", " targetURI", "TargetURI", "targetUrl", "sourceURI", "sourceurl", "outputUrl", "sourceLocation", "TargetURL", "targetLocation"], "urlParameters": ["urlParameter", "URLBytes", "httpPosition", "formParameter", " urlString", "urlRequest", " urlParameter", " urlRequest", " urlRequirements", "URLParameters", "formRequest", "URLRequirements", "urlRequirements", "urlString", "URLString", "implParameter", "httpParameters", "implParameters", "URLParameter", "httpRequest", "urlPosition", "implRequirements", "URLPosition", " urlBytes", "httpParameter", "implString", "urlBytes", "httpBytes", "formParameters", " urlPosition"], "url": ["zip", "string", "Connection", "base", "ssl", "address", "path", "server", "uri", "resource", "feed", "http", "location", "l", "host", "URL", "client", "session", "source", "cache", "proxy", "r", "ob", "config", "data", "file", "li", "channel", "page", "web", "log", "conn", "e", "image", "link", "db", "sl", "Url", "bc", "www", "f", "loc"], "connection": ["handler", "resource", "http", "document", "database", "condition", "nc", "component", "conv", "context", "conn", "contact", "Connection", "server", "lock", "result", "driver", "query", "sync", "source", "cache", "lc", "use", "proxy", "ion", "section", "channel", "object", "link", "unit", "connect", "service", "directory", "remote", "close", "uri", "entry", "con", "socket", "relation", "password", "union", "session", "reader", "collection", "body", "director", "request", "creator", "image", "writer", "io", "function", "position", "sql", "wrapper", "error", "communication", "character", "c", "connected", "current", "instance", "manager", "client", "application", "config", "environment", "log", "db", "ctx", "command", "network", "loc"], "wr": ["nw", "Wr", "rw", "wi", "nr", "wp", "vr", "ru", "WR", "fw", "wt", "wm", "dr", "mr", "fr", "usr", "shr", "raw", "rou", "rh", "pr", "wb", "ws", "wh", "r", "w", "war", "wer", "wal", "rr", "rss", "writer", "rx", "cro", "worker", "angler", "hr", "wire", "raf", "wa", "sw", "RW", "wx", "sr", "raft"], "is": ["bis", "i", "iss", "serv", "IS", "isa", "ini", "Is", "as", "ri", "s", "ois", "rt", "ui", "in", "rs", "ws", "ais", "r", "str", "isc", "ir", "src", "war", "has", "conn", "ai", "ris", "js", "ci", "rss", "io", "rx", "isin", "iris", "ios", "isi", "stream", "os", "was", "ar", "sr", "iso"], "rd": ["rw", "ud", "dra", "bd", "rc", "ru", "rg", "lr", "dr", "rt", "fr", "mr", "ro", "rs", "ld", "RD", "arr", "rb", "reader", "rh", "pr", "xd", "ra", "rod", "rn", "r", "rar", "rr", "rss", "rx", "writer", "cr", "rob", "adr", "fd", "rl", "respond", "hr", "raf", "rm", "pd", "dd"], "line": ["letter", "string", "buffer", "i", "lf", "message", "character", "LINE", "ge", "end", "l", "key", "content", "raw", "sync", "part", "source", "reader", "lines", "lc", "len", "str", "r", "data", "text", "file", "body", "li", "page", "inline", "row", "name", "header", "e", "frame", "cr", "link", "sl", "pe", "unit", "comment", "Line", "lin", "err", "obj", "parse", "block", "f", "error", "code", "cell"], "response": ["string", "respons", "buffer", "server", "output", "resource", "uri", "feed", "report", "site", "message", "json", "document", "description", "version", "result", "answer", "queue", "content", "one", "source", "resp", "cover", "value", "r", "application", "collection", "default", "data", "text", "body", "out", "page", "request", "object", "reply", "example", "tree", "image", "writer", "array", "function", "bytes", "Response", "respond", "error", "api", "view"]}}
{"id1": "10385815", "id2": "21232043", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    public File call() throws IOException {\n        HttpURLConnection conn = null;\n        ReadableByteChannel fileDownloading = null;\n        FileChannel fileWriting = null;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            if (size == -1) {\n                size = conn.getContentLength();\n            }\n            fileDownloading = Channels.newChannel(conn.getInputStream());\n            fileWriting = new FileOutputStream(file).getChannel();\n            long left = size;\n            long chunkSize = BLOCK_SIZE;\n            for (long downloaded = 0; downloaded < size; left = size - downloaded) {\n                if (left < BLOCK_SIZE) {\n                    chunkSize = left;\n                }\n                fileWriting.transferFrom(fileDownloading, downloaded, chunkSize);\n                downloaded += chunkSize;\n                setProgress(downloaded);\n            }\n        } finally {\n            if (file != null) {\n                file.deleteOnExit();\n            }\n            if (conn != null) {\n                conn.disconnect();\n            }\n            if (fileDownloading != null) {\n                try {\n                    fileDownloading.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0441\u043a\u0430\u0447\u0438\u0432\u0430\u043d\u0438\u044f\", ioe);\n                }\n            }\n            if (fileWriting != null) {\n                try {\n                    fileWriting.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 \u0444\u0430\u0439\u043b\", ioe);\n                }\n            }\n        }\n        return file;\n    }\n", "label": 0, "substitutes": {"copy": ["Cop", "paste", "cmp", "send", "zip", "Copy", "move", "open", "Transfer", "process", "sync", "download", " Copy", "replace", "upload", "exec", "clone", "delete", "get", "split", "transfer", "file", "change", "write", "put", "update", "create"], "fileFrom": [" fileStart", "FileSource", "FileStart", "fileStart", "mailIn", "ioSource", "FileTo", "FileIn", "ioStart", "mailTo", " fileSource", "mailFrom", " fileAs", "FileFrom", "ioFrom", "fileSource", "FileAs", "mailAs", "fileAs", "ioTo", " fileIn", "fileIn"], "fileTo": ["fpto", "resourceFile", "resourceTarget", "fileTO", " fileFile", "FileTo", " fileto", "resourceFrom", "resourceTo", "fpFrom", " fileTO", "fpTO", "fileto", "fileTarget", " fileTarget", "Fileto", "FileFrom", "fpTo", "FileTarget", "fileFile", "FileFile", "FileTO"], "inputStream": ["inputContext", "outputSteam", " inputSteam", "inputFile", "InputChannel", " inputFile", "outputFile", "inputSync", "outputContext", "inputstream", "InputContext", " inputstream", "InputSteam", "InputFile", " inputContext", "Inputstream", "outputSync", " inputSync", "InputSync", "InputStream", "outputstream", "inputSteam"], "outputStream": ["referenceStream", "outputSteam", "OutputStream", "fourStream", "fourChannel", " outputChan", "outputStreamer", "referenceSocket", "outputSocket", " outputSteam", "fourStreamer", "inputSocket", "writeSocket", "fourSteam", "writeChannel", "OutputChan", "referenceSteam", "OutputStreamer", "outputPath", "OutputSteam", "outputChan", "inputPath", " outputStreamer", " outputPath", "OutputPath", "writeSteam", "inputChan", "writeStream", "OutputChannel", "referenceChannel", "inputSteam"], "inputChannel": ["inputContext", "audioClient", "butContext", "parentPassword", "InputChannel", " inputClient", "outputSocket", "butCommand", "outputContext", " inputPassword", "inputSocket", "inputCam", "butChan", " inputCam", "InputContext", "parentStream", "outputPassword", "audioChannel", " inputSocket", " inputChan", "outputChan", " inputCommand", "inputClient", " inputContext", "outputCam", "inputCommand", "parentChannel", "InputSocket", "butChannel", "InputChan", "inputPassword", "inputChan", "outputCommand", "outputClient", "audioStream", "audioCam", "parentChan", "InputStream"], "outputChannel": ["inputContext", "outputchannel", "OutputStream", "outChannel", "OutputContext", " outputQueue", " outputChan", "outputContext", " outputContext", "OutputChan", " outputchannel", "outputChan", "OutputQueue", "outStream", "outChan", "outputQueue", "inputChan", "OutputChannel", "inputQueue", "inputchannel", "outContext", "Outputchannel"]}}
{"id1": "6421904", "id2": "88047", "code1": "    public DataRecord addRecord(InputStream input) throws DataStoreException {\n        File temporary = null;\n        try {\n            temporary = newTemporaryFile();\n            DataIdentifier tempId = new DataIdentifier(temporary.getName());\n            usesIdentifier(tempId);\n            long length = 0;\n            MessageDigest digest = MessageDigest.getInstance(DIGEST);\n            OutputStream output = new DigestOutputStream(new FileOutputStream(temporary), digest);\n            try {\n                length = IOUtils.copyLarge(input, output);\n            } finally {\n                output.close();\n            }\n            DataIdentifier identifier = new DataIdentifier(digest.digest());\n            File file;\n            synchronized (this) {\n                usesIdentifier(identifier);\n                file = getFile(identifier);\n                if (!file.exists()) {\n                    File parent = file.getParentFile();\n                    parent.mkdirs();\n                    if (temporary.renameTo(file)) {\n                        temporary = null;\n                    } else {\n                        throw new IOException(\"Can not rename \" + temporary.getAbsolutePath() + \" to \" + file.getAbsolutePath() + \" (media read only?)\");\n                    }\n                } else {\n                    long now = System.currentTimeMillis();\n                    if (getLastModified(file) < now + ACCESS_TIME_RESOLUTION) {\n                        setLastModified(file, now + ACCESS_TIME_RESOLUTION);\n                    }\n                }\n                if (file.length() != length) {\n                    if (!file.isFile()) {\n                        throw new IOException(\"Not a file: \" + file);\n                    }\n                    throw new IOException(DIGEST + \" collision: \" + file);\n                }\n            }\n            inUse.remove(tempId);\n            return new FileDataRecord(identifier, file);\n        } catch (NoSuchAlgorithmException e) {\n            throw new DataStoreException(DIGEST + \" not available\", e);\n        } catch (IOException e) {\n            throw new DataStoreException(\"Could not add record\", e);\n        } finally {\n            if (temporary != null) {\n                temporary.delete();\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"addRecord": [" addRec", "createRecord", "createFile", "addRec", " addFile", "createrecord", "appendRecord", " addrecord", "appendRec", "createRec", "appendFile", "addrecord", "appendrecord", "addFile"], "input": ["exec", "flow", "error", "reader", "audio", "php", "current", "load", "raw", "progress", "Input", "xml", "request", "session", "out", "conn", "context", "stream", "image", "this", "storage", "hole", "active", "null", "text", "back", "config", "buffer", "media", "resource", "inf", "form", "document", "http", "data", "source", "up", "instance", "value", "temp"], "temporary": ["temmanent", "transporary", "typoral", "Temperature", "Temmanent", "emporal", "theemporary", "emporary", "separporal", "temperature", "mporary", "typerature", "transperature", "timemporary", "Temporal", "separperature", "transolute", "semporary", "semporal", "thetemp", "timermanent", "tempporary", "tmporary", "temermanent", "exporal", "temolute", "formtemp", "timperature", "tempemporary", "tmperature", "tememporary", "destporal", "mporal", "temacher", "experature", "tporal", "tmemporary", "theermanent", "temptemp", "formmanent", "mperature", "theporal", "emperature", "exolute", "semperature", "tempperature", "tporary", "tytemp", "timporal", "temporal", "tmacher", "destemporary", "tomporal", "Temporary", "tommanent", "temtemp", "timolute", "tempporal", "timporary", "Temtemp", "semmanent", "formporal", "formporary", "separporary", "tymanent", "tacher", "tmtemp", "tmermanent", "theporary", "destporary", "theperature", "tmporal", "typorary", "tomporary", "transporal", "exporary", "destacher", "tomperature", "separmanent"], "tempId": ["tmpID", "tmpId", " tempid", "tmpPath", "TempPath", "inputId", "inputid", "TempId", "fakeid", "TempID", "tempid", "inputID", "fakeId", "tempID", "inputPath", "Tempid", "TempName", "poraryId", "tempName", "fakeName", "tempPath", "tmpid", " tempName", "poraryid"], "length": ["position", "url", "result", "audio", "description", "ob", "id", "load", "volume", "path", "total", "distance", "filename", "string", "sequence", "time", "name", "driver", "range", "angle", "lock", "section", "len", "write", "code", "read", "duration", "Length", "type", "count", "library", "shape", "number", "text", "offset", "slice", "loc", "array", "version", "key", "content", "l", "data", "width", "style", "download", "ext", "limit", "capacity", "value", "full", "json", "open", "size"], "digest": [" digested", "signEST", "fests", "digraph", "signest", "fester", " Digester", " digests", "generEST", " digraph", "digEST", "fest", " digester", "digester", " digEST", "decest", "digests", "signests", "DigEST", "digested", "Digester", "signester", "Digest", "decested", "digist", "signraph", "Digested", "generist", "Digist", "fraph", " DigEST", "generested", "decist", "signested", "generest", "decEST", " Digest"], "output": ["external", "address", "result", "console", "exit", "put", "log", "Output", "target", "export", "out", "binary", "queue", "image", "write", "tube", "plain", "operation", "writer", "connection", "application", "null", "object", "config", "socket", "outer", "message", "office", "resource", "copy", "document", "other", "data", "channel", "source", "letter", "unit", "web", "control", "response", "cut", "temp"], "file": ["FILE", "cache", "local", "e", "force", "id", "model", "path", "log", "filename", "name", "queue", "plain", "File", "show", "null", "directory", "message", "p", "document", "data", "letter", "server", "full", "f", "complete", "fp", "use", "feed", "child", "folder", "function", "string", "word", "lock", "fe", "or", "pe", "class", "user", "object", "rule", "buffer", "get", "http", "single", "l", "page", "pool", "let", "create", "open", "comment", "picture", "base", "place", "php", "zip", "current", "auto", "binary", "lib", "entity", "code", "per", "socket", "uri", "resource", "it", "source", "work", "dir", "home", "unit", "temp", "url", "view", "play", "time", "image", "ile", "this", "self", "type", "live", "connection", "real", "handler", "future", "other", "line", "up", "style", "po"], "parent": ["base", "master", "pa", "cache", "id", "port", "current", "child", "container", "path", "remote", " Parent", "parents", "out", "name", "location", "to", "image", "large", "or", "type", "root", "class", "null", "directory", "handler", "per", "block", "resource", "p", "key", "copy", "data", "source", "dir", "and", "create", "full", "Parent", "home", "part", "unit", "fat", "temp"], "now": ["first", " NOW", "gen", "view", "cycle", "id", "current", "load", "not", "cur", "always", "node", "start", "auto", "NOW", "max", "time", "next", "set", "this", "ci", "comp", "day", "or", "ct", "type", "info", "wait", "active", "today", "Now", "co", "ow", "currently", "post", "date", "once", "from", "age", "last", "low", "since", "night", "lim", "hour", "size", "cmp"]}}
{"id1": "9319440", "id2": "18748516", "code1": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"load": ["link", "resource", "create", "check", "download", "open", "find", "show", "update", "read", "loaded", "LOAD", "work", "upload", "loading", "start", "loader", "init", "dump", "file", "transfer", "Load", "loads", "get", "install", "library"], "id": ["image", "link", "plugin", "base", "resource", "create", "root", "json", "bid", "kid", "ids", "text", "filename", "key", "info", "uid", "string", "code", "did", "token", "path", "pid", "type", "ID", "uri", "aid", "Id", "ip", "is", "start", "name", "sid", "request", "file", "data", "i", "source", "f"], "xml": ["image", "model", "html", "log", "dr", "email", "expl", "feed", "www", "raw", "impl", "stream", "wl", "xxx", "content", "sheet", "event", "ul", "audio", "write", "json", "input", "plain", "entry", "zip", "http", "text", "parser", "java", "writer", "full", "ws", "page", "string", "element", "txt", "form", "spec", "path", "work", "job", "doc", "line", "ml", "x", "response", "layer", "bug", "name", "ssl", "request", "server", "file", "document", "data", "layout", "php", "el", "enter", "web", "address"], "url": ["image", "log", "URL", "base", "resource", "service", "feed", "www", "stream", "download", "Url", "open", "channel", "http", "zip", "l", "b", "bb", "api", "page", "string", "db", "org", "uri", "build", "layer", "blog", "client", "loader", "socket", "ssl", "tool", "server", "file", "ll", "gl", "ob", "user", "connect", "browser", "sl", "connection", "config", "source", "web", "f", "address"], "conn": [" manager", " con", " factory", "Url", "nc", " net", "Connection", "http", "l", "ch", " conf", "c", "r", " mc", "er", "ci", "io", " pool", " db", "client", "loader", "ssl", " connection", "con", " internet", " auth", "Conn", "connection"], "reader": ["err", "dr", "lr", "feed", "rx", "stream", "rer", "inner", "input", "worker", "rt", "http", "reading", "parser", "ler", "rar", "bird", "l", "writer", "finder", "read", "ri", "driver", "builder", "r", "buffer", "rc", "oder", "handler", "er", "io", "rr", "uri", "row", "ner", "loader", "hr", "server", "ser", "iterator", "Reader", "i", "iter", "connection", "f", "editor"], "str": ["enc", "err", "lc", "in", "dr", "fr", "kr", "coll", "val", "input", "arr", "cl", "entry", "text", "l", "STR", "pr", "string", "read", "code", "txt", "r", "t", "tr", "wr", "strip", "st", "er", "stri", "p", "line", "doc", "dict", "x", "sr", "data", "inst", "char", "e", "Str", "sl", "i", "iter", "br", "cr", "f", "obj", "s"]}}
{"id1": "22503685", "id2": "13207437", "code1": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "code2": "    public Object sendRequestObjectResponse(java.lang.String servletName, java.lang.String request) {\n        String osRoot = OSRoot.getRoot();\n        String fname = \"\";\n        Object retobj = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (myport == null || myport.trim().equals(\"\")) {\n            myport = \"80\";\n        }\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            try {\n                java.io.FileOutputStream pw = new java.io.FileOutputStream(\"log.txt\");\n                pw.write(req1xml.getBytes());\n                pw.flush();\n                pw.close();\n            } catch (Exception exp) {\n                exp.printStackTrace();\n            }\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.io.File f1 = new java.io.File(osRoot + \"/localattachments/Reports\");\n            if (!f1.exists()) f1.mkdirs();\n            java.io.File file = null;\n            if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"application/vnd.oasis.opendocument.text\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".odt\");\n            } else if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"text/html\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".html\");\n            } else {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".xls\");\n            }\n            file = new java.io.File(file.getAbsolutePath());\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(file);\n            int c;\n            while ((c = ios.read()) != -1) fos.write(c);\n            fos.close();\n            ios.close();\n            fname = file.getAbsolutePath();\n            System.out.println(fname);\n            newgen.presentation.component.Utility.getInstance().showBrowser(\"file://\" + fname);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n            javax.swing.JOptionPane.showMessageDialog(null, \"<html>Could not establish connection with the server, <br>Please verify server name/IP adress, <br>Also check if NewGenLib server is running</html>\", \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        }\n        return fname;\n    }\n", "label": 1, "substitutes": {"readGeoParserResult": ["readGeoWalkerResult", "readGeoWalkerResults", "readGeoparserOutput", "readGeoparserReport", "readGeOParserResults", "readGeoParserResults", "readGeOParserReport", "readGeoparserResult", "readGeoparserResults", "readGeOReaderReport", "readGeoParserReport", "readGeoWalkerReport", "readGeOParserOutput", "readGeOReaderOutput", "readGeoReaderReport", "readGeOReaderResults", "readGeoParserOutput", "readGeoWalkerOutput", "readGeoReaderResults", "readGeOReaderResult", "readGeoReaderResult", "readGeoReaderOutput", "readGeOParserResult"], "recordContent": ["resourceContents", "RecordBody", "recordFile", "reportBody", "resourceText", "RecordText", "RecordMessage", "reportMessage", "RecordFile", "recordContents", "RecordContent", " recordContents", "reportContent", "recordBody", "resourceFile", " recordFile", "resourceContent", " recordText", "recordMessage", "recordText", "RecordContents", " recordBody", "reportText", " recordMessage"], "getGazeteerIds": ["getGazeteerConfigs", "getGazeteersIdes", "getGazeteerHostes", "getGazeteersLogxs", "getGazeteersIdings", "getGazeteerNeedes", "getGazeteersIdxs", "getGazeteerLogs", "getGazeteersIders", "getGazeteerIdxs", "getGazeteerIdls", "getGazeteerTextings", "getGazeteerTexts", "getGazeteerLogxs", "getGazeteerLogers", "getGazeteersLogers", "getGazeteerConfigxs", "getGazeteerConfigings", "getGazeteerIdes", "getGazeteerHostings", "getGazeteerLogls", "getGazeteerIders", "getGazeteerTextxs", "getGazeteerHosts", "getGazeteersLogls", "getGazeteerLogings", "getGazeteerNeeds", "getGazeteersIdls", "getGazeteersIds", "getGazeteerTextls", "getGazeteerHosters", "getGazeteerNeedings", "getGazeteerIdings", "getGazeteerNeeders", "getGazeteersLogings", "getGazeteerConfigls", "getGazeteersLoges", "getGazeteersLogs", "getGazeteerLoges"], "ret": ["get", "r", "att", "match", "obj", "bf", "g", "reply", "default", "opt", "dict", "RET", "ut", "ft", "nt", "t", "reg", "replace", "info", "group", "result", "array", "ext", "ref", "vet", "Result", "results", "out", "resp", "Return", "part", "rets", "len", "iter", "feat", "fun", "f", "str", "alt", "data", "rt", "ll", "Ret", "status", "arr", "res", "rg", "list", "det", "gt", "hash", "sys", "mem", "re", "usr", "arg", "repl"], "retries": ["tried", "retried", "altrying", " retrys", "Retries", " retry", "Retry", "Retrying", "trying", "trys", "RETried", "tries", "RETrying", "RETries", "retrying", "altrys", " retrying", "Retrys", "retry", "retrys", "altries", "altried", "RETrys"], "reqPre": ["reqpre", "refPre", "refPost", "requestPre", " requestPost", "requestPlan", "respPlan", " requestpre", "resppre", "refpre", "respPost", "requestPost", "refPlan", "reqPost", " reqpre", "respPre", "requestPref", " requestPref", " reqPost", "reqPlan", "requestpre", "reqPref", " reqPref", " requestPre"], "outputFormat": ["inputSettings", "reportType", "outputSettings", "outputVersion", "inputFormat", "reportVersion", "inputVersion", "OutputVersion", "inputType", "reportSettings", "reportFormat", "OutputType", "OutputFormat", "OutputSettings", "outputType"], "doc": ["db", "m", "h", "Document", "tx", "html", "msg", "pos", "git", "DOC", "bug", "parse", "e", "po", "page", "coll", "md", "home", "info", "result", "dr", "bc", "dc", "http", "desc", "docs", "response", "resource", "xml", "df", "date", "file", "part", "Doc", "str", "f", "api", "feature", "data", "div", "b", "text", "record", "document", "di", "mc", "style", "body", "project", "event", "up"], "url": ["request", "r", "buffer", "sl", "element", "html", "entry", "e", "id", "page", "server", "address", "info", "result", "connection", "http", "location", "response", "ref", "URL", "resource", "path", "ssl", "file", "str", "f", "Url", "api", "base", "channel", "data", "b", "org", "document", "name", "l", "browser", "string", "web", "uri", "orb", "source"], "reader": ["r", "buffer", "writer", "tx", "Reader", "stream", "rc", "feed", "input", "instance", "handler", "info", "or", "http", "resource", "io", "rr", " readers", " parser", "file", "iter", "data", "oder", "er", "parser", "uri", "read"]}}
{"id1": "6190356", "id2": "1235538", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 1, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForOldMC512", " hashPasswordForOldMD3", " hashPasswordForNewMD3", " hashPasswordForNewMD512", " hashPasswordForOldMD512", " hashPasswordForNewMD4", " hashPasswordForOldMC5", " hashPasswordForOldMC3", " hashPasswordForOldmd3", " hashPasswordForOldMC4", " hashPasswordForOldmd5", " hashPasswordForOldM512", " hashPasswordForOldmd512", " hashPasswordForNewM5", " hashPasswordForOldmd4", " hashPasswordForNewMD5", " hashPasswordForOldM4", " hashPasswordForOldM5", " hashPasswordForOldMD4", " hashPasswordForOldM3", " hashPasswordForNewM3", " hashPasswordForNewM4", " hashPasswordForNewM512"], "password": ["wallet", "data", "name", "wd", "seed", "array", "p", "encrypted", "words", "text", "Password", "content", "account", "key", "address", "crypt", "secret", "buffer", "padding", " passwords", "sword", "value", "phrase", "path", "hash", "PASS", "pattern", "code", "pass", "word", "message", " Password", "token", "input", "result", "pad", "auth", "string", "username"], "md": ["meta", "df", "bd", "vd", "f", "mag", "cd", "rm", "wd", "grad", "dd", "m", "ma", " MD", "mt", "clean", "ind", "dig", "di", "mb", "am", "mac", "hm", "cmd", "managed", "dm", "vm", "um", "dc", "d", "MD", "gd", "mo", "mod", "amd", "mp", "rpm", "metadata", "mm", "pm", "mc", "pd", "mand", "hd", "pg", "od", "km", "Cmd", "nm"], "messageDigest": ["MessageAddEST", "messageAddester", " messageModests", "messagedigester", " messageModEST", "MessageAddse", "messageDigests", "messageDse", "messageAddse", "messageDigse", "messageDigester", "MessageModester", "messagedigse", " messageModester", "messageModEST", "MessageModEST", "MessageDigse", "messageModse", "messageAddest", "MessageDigest", "messagedigest", "MessageDigEST", "messageDEST", "messageModests", " messageDigests", " messageDigEST", "messageModester", " messageModest", "MessageModse", "MessageModest", "messageDigEST", "MessageAddest", " messageDigester", "messageModest", "messageAddests", "MessageDigester", "messagedigests", "messageAddEST", "MessageAddester", "messageDester", "messagedigEST", "messageDest"], "hexString": ["hexstring", "hexArray", " hexArray", "tempStr", " hexBuffer", "crossFunction", "crossStr", " hexService", "crossstring", "sumstring", "tempstring", "hashService", "hexFile", "sumString", "hexBuffer", "transformString", "hashArray", "hashSection", "octArray", "hashString", "transformStr", "tempFunction", "octBuffer", "hexSection", "tempString", "hexFunction", " hexStr", "sumFile", "hexService", "stringArray", "sumStr", "transformArray", " hexFunction", "octString", "crossString", "hexStr", "stringSection", " hexstring", " hexSection", "transformBuffer", "stringString", "stringService", " hexFile", "octStr", "tempFile"], "i": ["x", "ji", "f", "si", "ti", "ri", "s", "slice", "m", "p", "j", "pi", "k", "info", "ix", "I", "di", "u", "b", "multi", "bi", "qi", "r", "l", "fi", "e", "o", "d", "ci", "t", "h", "xi", "v", "oi", "ui", "n", "li", "uri", "ii", "io", "c", "id", "index", "a", "ai", "phi", "length", "ip"], "hex": ["rh", "full", "data", "char", "digit", "batch", "comp", "buff", "rex", "ex", "json", "str", "zero", "letter", "binary", "orig", "format", "shift", "cache", "text", "he", "pixel", " Hex", "sex", "temp", "cmp", "pack", "pex", "nexus", "cookie", "path", "h", "hash", "serial", "pattern", "character", "form", "default", "hello", "oct", "raw", "null", "http", "transform", "hack", "utf", "lit", "result", "host", "length", "none", "exp", "alpha", "string", "ip", "bit"]}}
{"id1": "3046085", "id2": "4852691", "code1": "    public Song(String s) {\n        StringTokenizer tokenizer = new StringTokenizer(s, \";\");\n        free = false;\n        title = tokenizer.nextToken();\n        artist = tokenizer.nextToken();\n        location = tokenizer.nextToken();\n        rating = Integer.parseInt(tokenizer.nextToken());\n        overplay = Integer.parseInt(tokenizer.nextToken());\n        String temp = tokenizer.nextToken();\n        tokenizer = new StringTokenizer(temp, \",[] \");\n        tags = new ArrayList<String>();\n        while (tokenizer.hasMoreTokens()) {\n            tags.add(tokenizer.nextToken());\n        }\n        byte[] bytes = new byte[40];\n        try {\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-1\");\n            hasher.update(title.getBytes());\n            hasher.update(artist.getBytes());\n            bytes = hasher.digest();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 1, "substitutes": {"s": ["f", "data", "name", "g", "m", "services", "sets", "p", "ns", "str", "is", "sample", "w", "text", "b", "parts", "content", "r", "e", "strings", "i", "S", "source", "sound", "t", "path", "v", "speech", "gs", "n", "south", "in", "params", "a", "es", "ss", "sb", "joined", "string", "ses"], "tokenizer": [" tokener", " tokenner", "okener", " tokenization", "optimizer", " tokeniter", "okenzer", "generized", "logize", "okeniser", "generizer", "optiminer", "Tokenizers", "widgetizable", "tokenizers", "tunzer", "toolizer", "Tokenener", "Tokeniser", "initializable", "normalizer", " tokenzer", "normalizable", " tokenener", "tokenister", "tokener", "statizer", "Tokenized", "optimiser", "Tokeniner", "okenator", " tokenized", "initializer", "tunner", " tokenister", "widgetiser", "statator", "finer", "generize", "tokenner", "tooliner", "tokenener", "initialiser", "okenization", "tokeniser", " tokenizers", " tokenize", "tokenizable", "okenize", "normalize", "initialization", "okeniter", "widgetiner", "finizer", "Tokenizable", "finize", "tokenized", "initialize", "initialiner", " tokeniser", "statizers", "logizer", "okenister", " tokenator", "Tokener", "tunizer", "generiser", "tokeniner", "normaliner", "optimizable", "loginer", "tokenization", "okenner", "tokeniter", "logizable", "okenizers", "Tokenizer", "tokenzer", " tokenizable", "finizable", "okenizable", "statiter", "tuner", "okenener", "toolize", "Tokenister", "okenizer", "toolizable", "widgetizer", "tokenator", "okeniner", "Tokenize", "tokenize"], "title": ["meta", "genre", "profile", "tag", "song", "data", "name", "type", "audio", "layer", "theme", "Title", "label", "art", "bot", "album", "summary", "format", "description", "music", "team", "text", "source", "filename", "url", "author", "metadata", "owner", "prefix", "resource", "company", "string", "media", "editor", "license", "username"], "artist": ["genre", "tag", "song", "Artist", "master", "archive", "piece", "audio", "creator", "photo", "layer", "theme", "chart", "episode", "art", "winner", "album", "music", "video", "season", "alias", "patch", " artists", "track", "player", "source", "image", "filename", "author", "metadata", "prefix", "target", "cover", "voice", "media", "username"], "location": ["region", "tag", "loc", "layout", "photo", "audio", "language", "layer", "theme", "gallery", "album", "position", "description", "time", "content", "address", "lang", "image", "mobile", "path", "url", "level", "message", "Location", "motion", "length", "area", "media"], "rating": ["genre", "boarding", "audio", "training", "rank", "sharing", "album", "resolution", "description", "weight", "playing", "ranking", "scoring", "fps", "season", "random", "padding", "style", "live", "breaking", "game", "score", "rate", "repeat", "tracking", "alpha", "media", "rising"], "overplay": ["offledge", "offplay", "replay", "oplay", "overlay", "opplay", "overledge", "opload", "reledge", "reload", "offlay", "overload", "relay", "opledge", "offload"], "temp": ["tag", "data", "sequence", "name", "layout", "loc", "Temp", "current", "type", "pt", "stable", "body", "emp", "partial", "str", "base", "format", "music", "part", "cache", "txt", "content", "test", "track", "list", " temporary", "style", "source", "template", "testing", "path", "stage", " tmp", "tmp", "empty", "unit", "flat", "original", "prefix", "message", "tc", "fake", "string", "media", "font"], "tags": ["ids", "thumbnails", "images", "sections", "packages", "phones", "events", "relations", "words", "files", "features", "bots", "authors", "strings", "tracks", "assets", "archives", "stats", "stars", "dates", "notes", "products", "comments", "names", "styles", "Tags", "terms", "fields", "modules", "videos", "users", "bugs", "tests", "properties", "reports", "types", "resources", "plugins"], "bytes": ["pages", "values", "data", "blocks", "articles", "balls", "body", "ips", "outs", "units", "codes", "gets", "words", "les", "parts", "size", "bits", "files", "lines", "letters", "strings", "pieces", "tes", "objects", "notes", "comments", "errors", "bps", "keys", "params", "videos", "seconds", "es", "fee", "Bytes"], "hasher": ["haher", "hahers", "hanhr", "haveest", " hashed", "hadher", "hashher", "haveer", "haser", "Haser", "haer", "hanher", "havehandler", "haest", "Hashers", "hashandler", "hashhandler", "Hashed", " hashers", "hashers", "Hasest", "hashed", "hadumper", "haveumper", "haner", "hadest", " hashr", "Hasher", "hanest", "hashumper", " haser", "hasumper", "hashr", "haveher", "hashest", "hahed", "hasest", "havehr", " hasest", "hadhandler"]}}
{"id1": "18891988", "id2": "4562786", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "label": 0, "substitutes": {"getFile": ["getfile", "loadFile", "loadString", "Getfile", "GetFilename", "GetString", "downloadFilename", "loadFilename", "downloadString", "getString", "getFilename", "loadfile", "downloadFile", "GetFile", "downloadfile"], "serviceName": ["servicePath", "projectName", "packagename", "serviceType", "projectPath", "packageName", "ServiceName", " servicePath", " servicename", "packagePath", " serviceType", "packageUrl", "serviceUrl", "Servicename", "ServicePath", "servicename", "ServiceUrl", " serviceUrl", "projectUrl", "ServiceType", "projectType"], "wsdlLocation": ["wsDLFile", "wllAddress", "wslpFolder", "wsllUrl", "wslLocation", "wsllLocation", "wsslLocation", "wsdlFolder", "wllFolder", "wslFile", "awslFile", "wsllFolder", "wdlDirectory", "wsDLUrl", "wddlFolder", "wsdlDirectory", "wslpFile", "wslpDirectory", "awslLocation", "wsslFolder", "wssdAddress", "wdlAddress", "awslDirectory", "wsdlUrl", "wsllFile", "wddlFile", "wslUrl", "wsDLLocation", "wssdFolder", "wdlFile", "awsdlLocation", "awslUrl", "wddlDirectory", "wllLocation", "wslFolder", "wsdlFile", "wsslFile", "wsDLDirectory", "wsllDirectory", "awsdlDirectory", "wsllAddress", "wsdlAddress", "wddlLocation", "wssdFile", "wslpLocation", "wdlFolder", "wdlLocation", "wssdLocation", "wllFile", "awsdlUrl", "wsslAddress", "awsdlFile", "wslDirectory"], "endpoint": ["endsocol", " endpointer", "ENDpoint", "endocol", "endination", "EndPoint", "enPoint", "endsword", "startaddress", " endPoint", "startpoint", "Endpoint", "endpointer", "endpo", " endpo", " endaddress", "enaddress", "enpointer", "Endocol", " endocol", "Endpo", "Endpoints", " endword", "enpoints", "enination", "ENDpoints", "Endination", "Endword", "ENDination", "endspo", "ENDPoint", "endPoint", "endaddress", "endword", "endpoints", "startPoint", "enpoint", "startpointer", "endspoint"], "fileLocation": ["fileUrl", "FILEDirectory", " fileDirectory", "fileDirectory", "fileURI", "FILEUrl", "FileLocation", "FileUrl", " fileURI", "FileDirectory", "FILEURI", " fileUrl", "FileURI", "FILELocation"], "tempDir": [" temporaryDir", "tmpVer", " tempVer", "TempDir", " temporaryPath", "tempdir", "tmpDir", "tempVer", "Tempdir", "tmpDirectory", "tmpPath", " temporaryDirectory", "tempPath", " tempdir", " tempPath", " tempDirectory", "tmpdir", "TempDirectory", "TempPath", "tempDirectory", " temporaryVer"], "url": ["image", "client", "service", "sl", "ul", "stream", "host", "socket", "el", "fl", "ls", "server", "coll", "address", "conn", "open", "connection", "http", "URL", "path", "pull", "io", "ssl", "file", "f", "Url", "channel", "base", "download", "contact", "log", "ll", "l", "string", "web", "ur", "uri", "source", "config", "www"], "WSDLFile": ["WINDELFolder", "WSDDLPath", "WSDDLSourceFile", "WDDLSourceFile", "WDDlFile", "WINDLPath", "WDDLBase", "WSDLFolder", "WSDDLFolder", "WSDLLFolder", "WDDlSourceFile", "WSDELFolder", "WSDLSourceFile", "WINDLFile", "WSDDLFiles", "WDDLPath", "WSDLLPath", "WDDlfile", "WSDlSourceFile", "WSDLfile", "WSDlFile", "WINDLFiles", "WSDDLfile", "WSDlBase", "WINDLFolder", "WSDLPath", "WINDELFiles", "WSDLLFiles", "WDDlFolder", "WDDlBase", "WSDELFiles", "WSDLFiles", "WSDELFile", "WDDLFile", "WDDLFolder", "WSDLLSourceFile", "WSDlfile", "WDDLfile", "WSDDLBase", "WDDlPath", "WSDLLBase", "WSDLLfile", "WSDLBase", "WSDLLFile", "WINDELFile", "WSDlFolder", "WSDELPath", "WSDDLFile", "WSDlPath", "WINDELPath"], "tmpWSDLFile": ["tmpWDDLFolder", "tmpWDDlFile", "tmpWSDLFiles", "tmpWDDLFiles", "tmpWSDlUrl", "tmpWSDlFile", "tmpWSDELUrl", "tmpWSDELFile", "tmpWDDlFiles", "tmpWDDlUrl", "tmpWSDlFolder", "tmpWDDELFiles", "tmpWSDLLUrl", "tmpWDDELLocation", "tmpWDDLLocation", "tmpWSDlLocation", "tmpWSDLFolder", "tmpWSDLLocation", "tmpWSDDLFile", "tmpWSDDLLocation", "tmpWSDLLFiles", "tmpWSDlFiles", "tmpWDDLFile", "tmpWSDELFiles", "tmpWSDLLFolder", "tmpWSDLLFile", "tmpWSDELLocation", "tmpWDDlFolder", "tmpWSDELFolder", "tmpWSDDLUrl", "tmpWDDELFile", "tmpWSDDLFiles", "tmpWDDLUrl", "tmpWDDELUrl", "tmpWSDLUrl"], "inputFile": ["InputFile", " inputPage", "tempFile", "tempBase", " inputBase", " inputFactory", "InputBuffer", " inputPlace", "tempPage", "outputFile", "InputFiles", "outputDir", " inputfile", "inputUrl", "InputUrl", "tempBuffer", " inputStream", "inputBase", "Inputfile", "InputDir", "inputPlace", "requestStream", "requestFile", " inputFiles", "inputFactory", "tempfile", "outputFiles", "tempUrl", "InputStream", "InputFactory", "InputPage", "inputBuffer", "InputBase", "InputPlace", "inPage", " inputBuffer", " inputUrl", "inputfile", "inDir", "inputFiles", "infile", " inputDir", "inputDir", "inFile", "inputPage", "tempFactory", "tempPlace", "requestFiles", "outputfile", "inputStream", "requestfile"], "tmpFile": ["tempFile", "uploadStream", "TempFiles", "uploadFiles", "tempPage", " tmpPage", "tmpPage", "uploadFile", " tmpDirectory", " tmpFiles", "tmpFiles", "TempPage", "TempFile", "tmpDirectory", "tempFiles", "inputDocument", "uploadDocument", "tempStream", "tempDirectory", "inputFiles", "tempDocument", "inputStream", "tmpStream", "TempDirectory"], "in": ["r", "image", "client", "m", "p", "pin", "inn", "gin", "is", "socket", "init", "impl", "input", "on", "id", "din", "conn", "lin", "connection", "inner", "ssl", "file", "f", "login", "data", "ins", "bin", "In", "l", "reader", "IN", "again", "lock", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "error", "timeout", "client", "writer", "sync", "output", "socket", "input", "copy", "on", "parent", "server", "cache", "conn", "to", "group", "connection", "inner", "io", "line", "file", "conf", "part", "ch", "o", "channel", "conv", "err", "can", "log", "net", "co", "name", "bin", "In", "again", "OUT", "IN", "outs", "outer", "source", "up", "c", "inc"], "con": ["plain", "client", "connect", "Conn", "sync", "gin", "socket", "cn", "rc", "thin", "CON", "com", "conn", "open", "ran", "connection", "nc", "bc", "inner", "cm", "ssl", "uc", "fc", "rec", "conf", "Con", "kin", "ctrl", "en", "ch", "close", "channel", "conv", "can", "ins", "co", "un", "IN", "win", "c", "inc"], "fileLength": ["fileSize", "contentSize", "FileLength", " fileWidth", "channelWidth", "contentLen", "FileSize", "channelLen", "filelength", "fileLen", "FileLen", "FileWidth", " filelength", "channelLength", "channelSize", "contentlength", " fileSize", "fileWidth", " fileLen", "Filelength", "contentLength"], "channelIn": ["channelin", " channelConn", "ChannelIn", " channelin", "Channelin", "connectionIn", "channelConn", "connectionOut", "connectionin", "characterIN", "resourceIN", "connectionConn", "characterIn", "resourcein", "channelIN", "resourceOut", "ChannelIN", "ChannelConn", " channelIN", "resourceIn", "characterin", "characterOut", "ChannelOut"], "channelOut": ["connectionOutside", "ChannelOutput", "ChannelIn", "channelOutside", " channelOutput", "channelOUT", "connectionIn", "chanIn", "connectionOut", "canIn", "connectionOutput", "chanout", "chanOutside", "ChannelOutside", " channelout", "canOutside", "canOUT", "chanOUT", "Channelout", "channelout", "connectionout", "chanOut", "channelOutput", "canOut", "ChannelOUT", "ChannelOut"], "tmpDocument": ["tempContent", "tempFile", "tmNode", "newFile", "tmFile", "tempdocument", "tmdocument", " tmpNode", "tempNode", " tmpContent", "tmpDoc", "tmpdocument", "tmpContent", "tempDoc", "newDocument", "tmpNode", "mpFile", " tmpdocument", "newContent", " tmpDoc", "mpNode", "tempDocument", "newdocument", "tmDocument", "mpDoc", "mpDocument"], "nl1": ["arl1", "jlone", "nn2", "nn0", "arl5", "nl5", "jl5", "klFirst", "ln11", "kl1", "nn6", "nn1", "arlFirst", "NL0", "NL6", "NL11", "klone", "NL1", "jlFirst", "ln6", "nl2", "nn11", "ln1", "jl1", "dl0", "dl1", "nlFirst", "nl11", "nl0", "NL2", "kl5", "ln2", "arlone", "nlone", "dl2", "nl6"], "i": ["ai", "ip", "uli", "m", "j", "p", "ie", "n", "eni", "multi", "fi", "ix", "slice", "e", "phi", "id", "abi", "ci", "gi", "mu", "ui", "info", "index", "li", "ii", "io", "iu", "z", "ini", "bi", "part", "pi", "f", "o", "xi", "ti", "ri", "u", "ni", "b", "y", "v", "ji", "mi", "oi", "it", "di", "hi", "l", "d", "si", "yi", "chi", "qi", "uri", "I"], "node1": ["layerOne", "node91", "layer2", "node0", " node0", "nodeone", "Node1", "packageOne", "Node0", "layer91", "n0", " nodeone", "Node91", "shape91", "shapeOne", "layer1", "n1", "nOne", "packageone", "NodeOne", " nodeOne", "shapeone", " node91", "Node2", "nodeOne", "package91", "shape1", "node2", "package1", "n2", " node2"], "tmpOut": ["tempFile", "ptyOutput", "vmout", "cacheOUT", "txtOut", "vmOUT", "txtWriter", "tempout", "txtOutput", " tmpOutput", "cacheOut", "tmpIn", " tmpIn", "tempWriter", "tmpWriter", "tempOutput", "tmpOutput", "txtout", "cacheFile", "tmpout", "tmpOUT", "ptyIn", "tempIn", "ptyOut", " tmpWriter", "vmOut", "tempOut", "cacheIn", "tempOUT", " tmpout", "ptyout", " tmpOUT", "vmIn"], "retVal": [" retObj", "valRet", "RETval", "RETVal", "retval", "retObj", "RETObj", " retval", "valval", "retRet", "valObj", " retRet", "valVal", "RETRet"]}}
{"id1": "15241397", "id2": "6403868", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"doGet": [" doGET", "handleGET", "didget", " doPut", "didGET", "handlePut", "doGET", "didGet", "handleget", " doget", "didPut", "doget", "doPut", "handleGet"], "request": ["complete", "url", "result", "client", "reader", "received", "QUEST", "xml", "input", "er", "context", "queue", "image", "event", "type", "connection", "method", "report", "info", "application", "user", "object", "query", "message", "uri", "buffer", "resource", "Request", "document", "http", "data", "server", "subject", "req", "instance", "initial", "web"], "response": ["result", "error", "esi", "client", "status", "output", "view", "site", "model", "Response", "function", "host", "session", "out", "generation", "queue", "image", "next", "results", "respond", "writer", "connection", "report", "application", "object", "body", "parent", "message", "resource", "version", "wave", "document", "other", "page", "data", "resp", "server", "pool", "full", "reply", "onse", "json", "collection"], "rewrittenQueryString": ["rewwrittenQueryStr", "rewrittenUrlString", "rewrittenRequestString", "rewrittenPageArray", "rewwrittenRequestString", "rewwrittenQueryString", "rewrittenQuestionText", "rewwrittenQueryArray", "rewrittenQuestionArray", "rewrittenqueryString", "rewwrittenRequestService", "rewrittenQueryStr", "rewwrittenQueryText", "rewwrittenQueryService", "rewrittenqueryService", "rewrittenQueryList", "rewrittenRequestLine", "rewrittenUrlText", "rewrittenRequestText", "rewwrittenQueryList", "rewrittenRequestArray", "rewrittenUrlService", "rewrittenRequestList", "rewrittenQueryLine", "rewrittenQuestionLine", "rewrittenqueryLine", "rewrittenQueryArray", "rewrittenQuestionString", "rewrittenRequestStr", "rewwrittenRequestText", "rewrittenQueryText", "rewrittenqueryText", "rewwrittenRequestArray", "rewrittenPageString", "rewrittenUrlLine", "rewrittenRequestService", "rewrittenQuestionStr", "rewwrittenQueryLine", "rewrittenPageList", "rewrittenqueryStr", "rewwrittenRequestLine", "rewwrittenRequestList", "rewwrittenRequestStr", "rewrittenPageLine", "rewrittenQuestionList", "rewrittenQueryService"], "rewrittenUrl": ["RewrittenJar", "RewwrittenText", "rerittenLanguage", "rewardedURL", "rewardedUr", "rewmatchedURL", "rewrapedURL", "rewwrittenServer", "rewwrittenURL", "rerittenUrl", "rewardedLanguage", "rewmatchedFile", "rewedUr", "rewilledUrl", "rewrapedFile", "RewwrittenServer", "rewilledJar", "rewcraftedLocation", "rewodedUrl", "rewardedFile", "RewrittenURL", "rewatchedUrl", "rewatchedURL", "RewrittenServer", "rewrittenInt", "Rewwrittenurl", "rewodedFile", "rewriteText", "RewwrittenUrl", "rewardedJar", "rewedurl", "rewcraftedURL", "rewcraftedUr", "rewwrittenUr", "rewrittenLocation", "RewrittenFile", "RewwrittenURL", "rewardedInt", "rewmatchedUrl", "rewrittenJar", "RewrittenText", "rerittenFile", "rewrapedUr", "rewrittenServer", "rewatchedServer", "RewwrittenJar", "rewardedLocation", "rewwrittenLanguage", "rewedFile", "RewrittenInt", "rewrittenFile", "rewedURL", "rewwrittenFile", "rewardedUrl", "RewrittenUr", "rewrittenUr", "rewriteServer", "rewatchedText", "rewrittenText", "RewwrittenInt", "rewodedLanguage", "RewwrittenLocation", "rewwrittenJar", "RewrittenUrl", "rewilledInt", "rewmatchedurl", "Rewrittenurl", "rewilledURL", "RewwrittenFile", "rewwrittenurl", "rewriteURL", "rerittenUr", "rewcraftedUrl", "rerittenURL", "RewrittenLocation", "rewwrittenUrl", "rewrittenURL", "rewrittenurl", "rewwrittenLocation", "rewrapedUrl", "rewrittenLanguage", "rewodedURL", "rewwrittenInt", "RewwrittenUr", "rewedUrl", "rewwrittenText", "rewriteUrl"], "httpURLConnection": ["httpSSLConn", " httpURConnect", " httpStreamCurrent", "webURLConnection", "HttpURLConnection", " httpUrlConn", " httpURLConn", "httpURIconnection", "httpWebConnection", "webSSLConnection", "httpURLContext", "httpURLConn", "httpWebConnect", "httpELConn", "httpURLService", " httpURLConnect", " httpURConn", "httpURLconnection", "httpURLClient", "webURLClient", "httpGEconnection", "httpURIConnection", " httpStreamConnection", "httpPathconnection", "httpGEConnect", "httpurlSession", " httpURLSession", "httpWebConn", "httpUrlconnection", "httpCLConn", "httpURLCode", "httpUrlConnection", "httpURConn", "httpELConnection", "httpURIConn", "httpChannelConnection", "apacheURLconnection", "httpURconnection", "httpUrlContext", "HttpURLService", "httpStreamconnection", "httpUrlConnect", "httpurlConnection", "webURLConn", "httpChannelConnect", "httpURLSession", "httpPathSession", "httpURConnection", "httpStreamConnection", "httpELConnect", "apacheGEConnect", " httpURLCurrent", "httpurlCurrent", "httpSSLClient", "webSSLConn", " httpURConnection", " httpStreamconnection", " httpURLconnection", "httpChannelconnection", "HttpURLconnection", "httpURIFlow", "webSSLClient", "httpURIContext", "httpPathCurrent", "apacheGEconnection", "httpStreamCurrent", "httpGEFlow", " httpStreamSession", "httpURLFlow", "httpCLCode", "apacheGEFlow", " httpURLCode", "httpurlConnect", "httpurlFlow", "apacheGEConnection", "webSSLContext", "httpGEConnection", " httpUrlCode", "apacheURLConnect", "HttpChannelConnection", "httpUrlService", "httpurlConn", "httpurlCode", "apacheURLFlow", "httpSSLContext", "httpURLCurrent", "httpUrlConn", "httpurlconnection", "httpURConnect", "httpURIClient", "httpUrlClient", "httpURService", "HttpChannelService", "httpPathConnection", "httpURIConnect", "httpSSLConnection", "webURLContext", " httpUrlConnection", "HttpURLConnect", "httpUrlCode", "httpCLConnection", "HttpChannelConnect", "HttpChannelconnection", "httpStreamSession", "httpChannelService", "httpURLConnect", "apacheURLConnection"], "header": ["hash", "feature", "pair", "result", "item", "master", "error", "column", "token", "ter", "metadata", "after", "cover", "default", "function", "index", "er", "string", "bridge", "driver", "queue", "section", "next", "character", "layer", "event", "component", "writer", "info", "reference", "definition", "player", "head", "rule", "handler", "Header", "back", "list", "block", "headers", "outer", "buffer", "message", "iter", "version", "date", "her", "attribute", "key", "document", "dr", "line", "consumer", "entry", "filter", "server", "channel", "data", "match", "member", "director", "field", "second", "group", "part", "comment", "author"], "value": ["v", "sv", "description", "now", "current", "valid", "child", "Value", "model", "default", "function", "val", "label", "string", "name", "values", "end", "language", "set", "expression", "format", "type", "VALUE", "info", "element", "object", "text", "parent", "hello", "message", "office", "media", "version", "option", "property", "attribute", "key", "content", "V", "gi", "get", "document", "entry", "data", "server", "letter", "password", "variable", "field", "json", "comment", "item"], "inputStream": ["pullStreamer", "pullSteam", "inputSteam", "outputStreamer", "pullStream", "resourcestream", "InputChannel", "resourceSteam", "outputChannel", "resourceStream", "resourceChannel", "outputSteam", "InputStreamer", "Inputstream", "outputstream", "InputSteam", "inputstream", "inputChannel", "inputStreamer", "pullstream", "InputStream"], "outputStream": ["OutputFile", " outputSteam", "inputSteam", "outputStreamer", "OutputChannel", "OutputSteam", "externalStream", "outputChannel", "OutputStream", "externalstream", "externalSteam", "responseSteam", "outputSteam", "OutputStreamer", "responseStream", "outputstream", "responseChannel", "externalStreamer", "Outputstream", "responseFile", " outputChannel", " outputFile", "inputstream", "inputStreamer", "outputFile"]}}
{"id1": "17580775", "id2": "7118860", "code1": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "code2": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "label": 1, "substitutes": {"runInternal": ["doInternal", "processExternal", "doImpl", " runImpl", " runSync", "processSync", "runImpl", "runSync", "processInternal", "doExternal", " runExternal", "runExternal", "doSync", "processImpl"], "connection": ["resource", "current", "channel", "Connection", "c", "collection", "layer", "command", "context", "expression", "communication", "volume", "component", "source", "machine", "directory", "body", "lc", "log", "graph", "service", "ion", "function", "cache", "password", "builder", "driver", "engine", "session", "relation", "handler", "character", "operation", "server", "document", "connect", "error", "database", "reader", "timeout", "loc", "inner", "event", "entry", "version", "use", "remote", "object", "option", "position", "creator", "translation", "container", "entity", "client", "request", "port", "default", "connected", "location", "socket", "image", "index", "section", "message", "environment", "application", "condition", "statement", "proxy", "con", "wrapper", "description", "config"], "visited": ["visITED", "VISitted", "viewITED", "viewitted", "invitted", "VISed", "invited", "VisITED", "viewed", "invITED", "invalled", "Vised", "Visalled", "viewited", "VISited", "visalled", "VISITED", "VISalled", "vised", "visitted", "Visited", "Visitted"], "startTimeStamp": ["startTimeEstng", "startLineStamp", "startTimestamp", "startTimeStamps", "startTimeestng", "startTimeStng", "startTimeestamps", "startLineEstamp", "startTimestamped", "startLineEstamps", "startLineEstng", "startTimestng", "startLineStamps", "startLineStamped", "startLineEstamped", "startTimeestamped", "startTimeEstamped", "startTimeStamped", "startTimeEstamp", "startTimeestamp", "startTimeEstamps", "startLineStng", "startTimestamps"], "delayedProgress": ["eladedProgress", "delayedContent", "elayedStatus", "deladedContent", "delivedProgress", "eladedComplete", "delayedStatus", "elayedComplete", "deliverComplete", "delivedContent", "deliverProgress", "delayedComplete", "eladedContent", "deladedStatus", "deliverContent", "delivedComplete", "deladedProgress", "elayedContent", "eladedStatus", "deliverStatus", "elayedProgress", "delivedStatus", "deladedComplete"], "conn": ["enc", "lc", "conv", "nt", "config", "dc", " con", "cli", "nc", "ls", "open", "obj", "channel", "Connection", "http", "exec", "sync", "l", "ch", "cb", "connected", "ann", "att", "act", "c", "cf", "ct", "rc", "ci", "ad", "cmp", "io", "client", "cc", "comm", "ssl", "co", "con", "h", "cn", "connect", "mc", "Conn", "n", "ctx", "cp", "loc", "uc", "db"], "fileName": [" filePath", "imageName", "contentSpace", "filePath", "urlPath", "urlKey", "fileArea", "filename", " fileSpace", "FilePath", "contentName", "fileSpace", "imagename", "FileName", " filename", "FileArea", "contentname", " fileKey", "imagePath", "FileKey", "urlArea", "contentPath", " fileArea", "urlName", "imageSpace", "fileKey"], "disp": ["disap", "schep", "Disap", "Dispend", "Disps", "detp", "interpp", "disps", "defpart", "Dispatch", "dispe", "broadps", "Disp", "broadpart", "dispart", "defpend", "prope", "Dispr", "Dispe", "interap", "interpe", "broadpend", "defps", "Dispose", "dispose", "dispend", "dispp", "dispr", " dispr", "DisP", " dispe", "dispatch", "detpp", "interp", "prop", "Dispart", "defp", "interpatch", "scheap", "schepatch", "detpatch", " dispose", "detP", "propr", "propose", "schepe", "broadp", "Dispp", "disP", "interP"], "p": ["np", "index", "pat", "o", "j", "q", "end", "point", "po", "pre", "ap", "patch", "rep", "P", "at", "ping", "l", "b", "api", "jp", "pr", "after", "lp", "bp", "pi", "c", "pe", "r", "pp", "sp", "pos", "g", "pa", "t", "d", "m", "pl", "op", "vp", "part", "v", "y", "ip", "col", "h", "tp", "e", "i", "n", "loc", "f"], "response": ["body", "image", "model", "index", "resource", "feed", "site", "found", "Response", "respons", "function", "json", "version", "http", "message", "reset", "output", "api", "respond", "prot", "page", "status", "code", "collection", "resp", "path", "success", "next", "successful", "en", "result", "pointer", "uri", "ception", "received", "request", "server", "data", "id", "radius", "error", "value", "description", "timeout", "complete", "reply"], "contentType": ["documentTyp", "documentLength", "messageInfo", "ContentTyp", "contentTyp", "contentName", "documentType", "contentLength", "contentInfo", " contentInfo", "ContentLen", "ContentInfo", "messageLength", "ContentLength", " contentLength", " contentName", "messageType", "ContentName", "documentName", "messageLen", " contentTyp", "ContentType"], "contentEncoding": ["loadEncasing", "contentencoder", "contentEnaring", "contentDecoding", "contentCasing", "ContentEncReading", "contentencReading", "contentLocasing", "contentEncasing", "loadEnaring", "ContentDecoding", "contentEncoder", "contentEnoding", "ContentDecoder", "contentEoding", "loadEnryption", "contentCryption", "contentLocaring", "contentEReading", "ContentEncoding", "contentEocol", "contentLocryption", "contentencocol", "contentEnasing", "contentEnryption", "ContentEncocol", "contentEncryption", "contentEncaring", "contentEncocol", "loadEnasing", "ContentEncoder", "contentDecocol", "contentLocoding", "contentCoding", "loadEncoding", "contentDecoder", "contentEoder", "contentencoding", "contentEncReading", "loadEnoding", "contentDecReading", "ContentDecReading", "loadEncaring", "ContentDecocol", "contentCaring", "loadEncryption"], "contentLen": [" contentlen", "resourceLen", "resourcelen", "contentLength", " contentSl", "contentSize", "contentlen", "Contentlen", "activitySl", "ContentLen", "ContentLength", "resourceSize", "ContentSl", " contentLength", " contentSize", "contentSl", "activityLength", "activitySize", "activityLen", "resourceLength", "ContentSize"], "is": ["ion", "can", "ub", "mis", "net", "version", "un", "IS", "igh", "not", "ig", "ync", "isp", "os", "it", "isl", "out", "iss", "ip", "are", "ys", "us", "isc", "ot", "ios", "ss", "im"], "url": ["image", "link", "log", "html", "URL", "service", "resource", "email", "feed", "download", "Url", "json", "channel", "http", "text", "page", "status", "string", "buffer", "path", "source", "org", "uri", "layer", "client", "context", "socket", "ssl", "location", "server", "user", "file", "document", "username", "str", "sl", "config", "host", "address"], "loadNext": ["checkPrevious", "loadingPrevious", "loadsFirst", "checkNext", "loadsLast", "loadingFirst", "loadsNext", "checkLast", "loadingLast", "loadPrevious", "loadsPrevious", "loadingNext", "checkFirst", "loadFirst", "loadLast"], "itemsLoadedPartially": ["itemsLoadedCopials", "itemsLoadedCopial", "itemsLoadedPartials", "itemsLoadedpartial", "itemsLoadippedPartial", "itemsLoadedPartial", "itemsLoadippedPartally", "itemsLoadedCopally", "itemsLoadedPARTial", "itemsLoadedCopially", "itemsLoadippedPartially", "itemsLoadedPARTials", "itemsLoadippedpartially", "itemsLoadedPARTally", "itemsLoadippedpartial", "itemsLoadippedpartally", "itemsLoadedPartally", "itemsLoadedpartials", "itemsLoadedPARTially", "itemsLoadedpartially", "itemsLoadippedPartials", "itemsLoadedpartally", "itemsLoadippedpartials"]}}
{"id1": "9413074", "id2": "13362846", "code1": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "code2": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getLocation": ["getFile", "newURL", "setLocation", "GetFile", "GetAddress", " getAddress", "findLoc", "newLoc", "getURL", "findURL", "getLoc", "findFile", "GetPath", "setURL", "GetLoc", "newFile", "getPath", "setPath", " getURL", "newLocation", "GetLocation", "setAddress", "GetURL", "findLocation", "getAddress", " getPath"], "clazz": ["Clazz", "cluster", "Cllass", " cluster", "CLuster", "CLazz", "cllass", "Clclass", " clclass", "Cluster", "CLclass", " cllass", "clclass", "CLlass"], "url": ["ll", "image", "html", "null", "org", "entry", "cl", "class", "l", "string", "gl", "context", "browser", "page", "text", "uri", "resource", "server", "connection", "rel", "link", "zip", "URL", "Location", "coll", "code", "i", "config", "lr", "object", "local", "email", "loader", "layer", "path", "feed", "log", "loc", "channel", "impl", "site", "route", "pull", "api", "web", "user", "ob", "sl", "Url", "buffer", "http", "bb", "ssl", "b", "mount", "f", "ref", "href", "jar", "source", "client", "base", "position", "address", "language", "name", "service", "host", "bug", "or"], "location": ["warning", "description", "uri", "resource", "message", "image", "length", "style", "connection", "loc", "data", "via", "result", "site", "area", "route", "Location", "URL", "storage", "translation", "error", "home", "instance", "source", "library", "directory", "filename", "l", "feature", "position", "local", "address", "language", "string", "layout", "property", "region", "layer", "response", "path", "function", "lc", "content", "operation", "where"], "file": ["page", "pe", "log", "FILE", "uri", "resource", "ile", "image", "able", "remote", "il", "io", "child", "folder", "entry", "f", "it", "key", "el", "source", "class", "dir", "filename", "l", "files", "base", "object", "cache", "name", "entity", "per", "File", "full", "get", "path", "fe", "line", "fp", "lib"]}}
{"id1": "19113613", "id2": "14317425", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copy": ["share", "change", "delete", "save", "paste", "rm", "transfer", "zip", "Copy", "load", "put", "replace", "cp", "archive", "write", "upload", "Cop", " cp", "type", "cop", "sync", "update", "clip", "p", "get", "process", "move", "download", "create", "split", "ssh", "cat", "clone", "opy"], "in": ["url", "base", "ins", "thin", "reader", "din", "IN", "client", "token", "project", "login", "bin", "id", "inc", "old", "plugin", "ini", "input", "ic", "index", "In", "name", "on", "inner", "image", "c", "this", "a", "i", "connection", "n", "again", "sin", "config", "diff", "win", "update", "inn", "min", "pin", "get", "cin", "work", "lin", "init", "data", "inside", "kin", "part", "as", "f"], "out": ["exec", "net", "external", "v", "base", "OUT", "client", "outs", "cache", "project", "call", "output", "bin", "app", "io", "inc", "path", "goal", "x", "outside", "one", "remote", "input", "conn", "ext", "obj", "dot", "name", "image", "c", "err", "off", "no", "this", "Out", "self", "at", "connection", "root", "b", "ex", "n", "object", "again", "o", "parent", "null", "block", "with", "outer", "option", "resource", "version", "p", "point", "user", "other", "page", "vert", "line", "up", "init", "work", "group", "part"], "source": ["ource", "position", "url", "feature", "base", "project", "status", "scope", "view", "site", "use", "force", "id", "proxy", "family", "internal", "alt", "name", "secure", "Source", "prefix", "missing", "username", "format", "component", "type", "reference", "pe", "class", "route", "parent", "sin", "dest", "direction", "uri", "service", "resource", "attribute", "iter", "from", "subject", "secret", "src", "origin", "unit", "size", "ce", "SOURCE"], "target": ["template", "address", "url", "master", "base", "token", "alias", "arget", "project", "output", "site", "force", "current", "wrong", "path", "goal", "alt", "pattern", "host", "name", "top", "tail", "prefix", "next", "format", "Target", "component", "reference", "root", "route", "null", "parent", "dest", "direction", "config", "service", "resource", "detail", "point", "src", "about", "value", "cat", "origin", "home"], "files": ["objects", "ins", "classes", "groups", "assets", "flows", "tools", "docs", "iles", "children", "ions", "users", "filename", "s", "sections", "cells", "lines", "ls", "jobs", "resources", "results", "items", "models", "images", "plugins", "apps", "blocks", "fs", "links", "Files", "obs", "pages", "data", "ports", "keys", "names", "f", "features"], "file": ["fp", "url", "FILE", "base", " File", "local", "el", "e", "id", "feed", "current", "load", "child", "path", "folder", "function", "filename", "name", "string", "binary", "ile", "fe", "lib", "entity", "layer", "File", "live", "b", "object", "directory", "parent", "per", "future", "uri", "resource", "it", "single", "l", "line", "entry", "data", "dir", "page", "letter", "part", "unit", "f", "item", "le"], "inCh": ["outCH", "inChan", "INCh", " inch", "outChan", "InChannel", "inCH", "outch", "INChan", "INChannel", "Inch", "inChannel", "InCH", " inChan", " inChannel", "InChan", " inCH", "InCh", "INCH", "inch", "outChannel"], "outCh": ["outCH", "outputCh", "outputChan", "inChan", "OutCh", "OutCH", " outCH", "outChan", "outch", "inCH", "outputCH", " outChannel", " outch", "inChannel", "Outch", "OutChan", "OutChannel", "inch", "outChannel", "outputch"]}}
{"id1": "17557289", "id2": "13783549", "code1": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyfile", "Copyfile", " copyFiles", "transferFile", "transferStream", "CopyFiles", "copyfile", "transferFiles", "copyFiles", " copyStream", "CopyFile", "CopyStream", "copyStream", "transferfile"], "source": ["resource", "temp", "use", "site", "Source", "input", "copy", "ource", "core", "path", "sc", "from", "slice", "this", "object", "unit", "connection", "base", "out", "server", "clone", "size", "sl", "link", "iter", "e", "SOURCE", "image", "start", "sin", "remote", "reader", "target", "id", "parent", "stream", "src", "name", "file"], "dest": ["folder", "dc", "temp", "done", "dat", "dist", "d", "src", "master", "destroy", "desc", "south", "die", "dir", "comb", "db", "orig", "tmp", "delete", "flat", "home", "Dest", "transfer", "test", "output", "data", "obj", "target", "null", " destination", "de", "wb", "dep", "later", "file", "end"], "srcChannel": ["srcChan", " srcStream", "srcConnection", "srcchannel", "distChan", "destChannel", "sourceContext", "srcButton", "destStream", "destchannel", "rcButton", "distConnection", "destConnection", "rcContext", "sourceButton", "rcChan", "srcStream", "destChan", " srcConnection", "srcContext", " srcContext", " srcButton", " srcChan", "sourcechannel", " srcchannel", "rcChannel", "rcchannel", "sourceChannel", "distStream", "rcConnection", "sourceChan", "sourceConnection", "distChannel"], "dstChannel": ["dstsChan", "dstContext", "ddestchannel", "dstStream", "ddestContext", "DdestChan", "dDestChan", "drcChan", "drcchannel", "drdContext", " dstStream", " dndStream", "DstChan", "drdChannel", "dutStream", " dstContext", "DdestChannel", " dndContext", "DstStream", "drdchannel", "drdChan", "dutchannel", "dutChannel", "dndChannel", "ddestChan", "ddestStream", "drcChannel", "ddstChannel", " dndchannel", " dstchannel", "dndchannel", "ddestChannel", "ddstchannel", "dDestchannel", "ddrdContext", "dstsChannel", "dDestChannel", "ddstChan", "dstChan", "dstsStream", "ddrdchannel", "ddrdChannel", "dndContext", "dstchannel", "Dstchannel", "DdestStream", "ddrdChan", "Ddestchannel", "drcContext", "dstschannel", "dndStream", "dutContext", "ddstContext", "dDestStream", "DstChannel", " dndChannel"]}}
{"id1": "5551393", "id2": "1862616", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public static String fetch(String reference) throws IOException {\n        URL url = new URL(reference);\n        HttpURLConnection c = (HttpURLConnection) url.openConnection();\n        c.setRequestMethod(\"GET\");\n        c.setDoOutput(true);\n        c.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n        return parseISToString(c.getInputStream());\n    }\n", "label": 0, "substitutes": {"getMD5": ["getSHA4", " getM512", " getM4", "getMD4", "getSHA256", "getmd5", "getSHA5", "getM256", "getSHA512", "getM5", "getM4", "getmd512", " getMD512", "getmd4", "getMD256", "getM512", " getMD4", " getMD256", "getMD512", " getM5", " getM256", "getmd256"], "source": ["ource", "template", "address", "url", "result", "base", "output", "security", "proxy", "SOURCE", "input", "target", "start", "string", "seed", "name", "length", "secure", "Source", "sm", "code", "info", "text", "object", "dest", "config", "slice", "message", "buffer", "service", "resource", "bytes", "content", "data", "file", "style", "src", "unit", "size", "expected", "temp"], "tmp": ["foo", "emp", "test", "result", "stuff", "fp", "params", "cache", "output", "metadata", "zip", "current", "tt", "vt", "default", "py", "meta", "obj", "binary", "storage", "code", "sb", "html", "b", "buf", "body", "ignore", "dest", "buffer", "var", "array", "rb", "copy", "data", "vm", "src", "nm", "Temp", "bf", "part", "cpp", "txt", "cb", "mp", "cmp", "temp"], "md": ["mad", "MD", "cm", "mc", "ms", "rm", "pm", "bd", "zip", "amd", "mo", "meta", "mb", "mt", "ind", "oda", "cmd", "hd", "mi", "rpm", "mand", "editor", "m", "dd", "gd", "sd", "od", "mg", "mm", "ma", "ad", "pd", "cd", "mmm", "wd", "nd", "mac", "mn", "mod", "di", "ld", "d", "mag", "nm", "vd", "dm", "bf", "mu", " MD", "mp"]}}
{"id1": "13563706", "id2": "18211588", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String selectedPage = request.getParameter(\"SelectedPage\");\n        Page page = null;\n        PortalRequest portalRequest = PortalRequest.getCurrentRequest();\n        if (selectedPage == null) {\n            try {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n            } catch (PersistentModelException e) {\n                myLogger.info(\"Page could not be found due to an exception\");\n                response.sendError(response.SC_NOT_FOUND);\n                return;\n            }\n        }\n        myLogger.info(\"Handling Page Request for Page \" + selectedPage);\n        try {\n            if (page == null) {\n                try {\n                    page = Page.getPage(Long.parseLong(selectedPage));\n                } catch (NumberFormatException e) {\n                    List<Page> possiblePage = Page.findByName(selectedPage);\n                    if (possiblePage.size() > 0) {\n                        page = possiblePage.get(0);\n                    } else {\n                        response.sendError(response.SC_NOT_FOUND);\n                        return;\n                    }\n                }\n            }\n            if (!page.isVisibleTo(portalRequest.getCurrentUser())) {\n                Property pageProp = Property.getProperty(\"HomePage\");\n                selectedPage = pageProp.getValue();\n                page = Page.getPage(Long.parseLong(selectedPage));\n            }\n            try {\n                Property property = Property.getProperty(\"LogPageRequests\");\n                if (property.getValue().toLowerCase().equals(\"true\")) {\n                    String referer = request.getHeader(\"Referer\");\n                    if (referer == null || referer.indexOf(portalRequest.getRequest().getServerName()) > 0) {\n                        referer = \" \";\n                    } else {\n                        if (referer.length() >= 200) {\n                            referer = referer.substring(0, 198);\n                        }\n                    }\n                    PageRequest.createRequest(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), portalRequest.getRequest().getRemoteAddr(), referer);\n                }\n            } catch (PersistentModelException e) {\n                myLogger.log(Level.WARNING, \"Log Page Requests property was not found.\", e);\n            }\n            if (page.isVisibleTo(portalRequest.getCurrentUser())) {\n                HttpSession session = request.getSession();\n                if (session != null) {\n                    RecentlyViewedManager rvm = (RecentlyViewedManager) session.getAttribute(\"ipoint.RecentlyViewedManager\");\n                    if (rvm == null) {\n                        rvm = new RecentlyViewedManager();\n                    }\n                    rvm.add(page);\n                    session.setAttribute(\"ipoint.RecentlyViewedManager\", rvm);\n                }\n                PageCacheEntry entry = null;\n                if (!portalRequest.isPost() && !page.isEditableBy(portalRequest.getCurrentUser())) {\n                    try {\n                        int pageCacheTime = 60000;\n                        try {\n                            Property pageCacheTimeProperty = Property.getProperty(\"PageCacheTime\");\n                            pageCacheTime = Integer.parseInt(pageCacheTimeProperty.getValue());\n                            pageCacheTime *= 1000;\n                        } catch (PersistentModelException pme) {\n                            myLogger.warning(\"Ignoring Exception when retrieving PageCacheTime property\");\n                        } catch (NumberFormatException nfe) {\n                        }\n                        entry = PageCacheEntry.find(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), pageCacheTime);\n                    } catch (PersistentModelException e) {\n                        myLogger.log(Level.WARNING, \"An error occurred finding a page cache entry\", e);\n                    }\n                }\n                response.setContentType(\"text/html\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n                boolean processed = false;\n                if (entry != null) {\n                    String tempFile = entry.getTempFile();\n                    File file = new File(tempFile);\n                    if (file.exists() && file.isFile() && file.canRead()) {\n                        FileReader reader = new FileReader(file);\n                        BufferedReader br = new BufferedReader(reader);\n                        PrintWriter out = response.getWriter();\n                        out.write(\"<!-- Starting to output cached page in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        while (br.ready()) {\n                            out.write(br.readLine() + \"\\n\");\n                        }\n                        out.write(\"<!-- Cached output produced in \" + portalRequest.elapsedTime() + \" ms -->\\n\");\n                        reader.close();\n                        processed = true;\n                        portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), portalRequest.elapsedTime(), true);\n                    } else {\n                        entry.delete();\n                    }\n                }\n                if (!processed) {\n                    PrintWriter out = response.getWriter();\n                    out.write(\"<!-- Output produced by iPoint Portal -->\\n\");\n                    PageRenderer renderer = new PageRenderer(page);\n                    long startTime = System.currentTimeMillis();\n                    request.setAttribute(ELConstants.IPOINT_USER, portalRequest.getCurrentUser());\n                    request.setAttribute(ELConstants.IPOINT_PAGE, page);\n                    request.setAttribute(ELConstants.IPOINT_TEMPLATE, page.getTemplate());\n                    request.setAttribute(ELConstants.IPOINT_PORTAL_PROPERTIES, Property.getPropertiesMap());\n                    request.setAttribute(ELConstants.IPOINT_USER_PROPERTIES, portalRequest.getCurrentUser().getProperties());\n                    renderer.preProcess();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PagePreProcess, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    long renderStart = System.currentTimeMillis();\n                    renderer.render();\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageRender, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - renderStart, false);\n                    portalRequest.getMBeans().incrementStatistics(ManagementMBeans.StatisticsType.PageTotal, page.getName() + \"-\" + page.getID(), System.currentTimeMillis() - startTime, false);\n                    out.write(\"<!-- output produced in \" + PortalRequest.getCurrentRequest().elapsedTime() + \" ms -->\\n\");\n                    if (!page.isEditableBy(portalRequest.getCurrentUser())) {\n                        if (response instanceof CachingResponseWrapper) {\n                            CachingResponseWrapper crw = (CachingResponseWrapper) response;\n                            crw.flushBuffer();\n                            Property tempProperty = Property.getProperty(\"UploadLocation\");\n                            File tempDirectory = new File(tempProperty.getValue());\n                            if (tempDirectory.exists() && tempDirectory.canWrite()) {\n                                File file = File.createTempFile(\"iPointPage\", \".html\", tempDirectory);\n                                try {\n                                    FileWriter fw = new FileWriter(file);\n                                    fw.write(crw.getOutput());\n                                    fw.flush();\n                                    fw.close();\n                                    PageCacheEntry.create(portalRequest.getCurrentHREF(), page, portalRequest.getCurrentUser(), file.getAbsolutePath());\n                                } catch (IOException e) {\n                                }\n                            } else {\n                                myLogger.warning(\"Can not write to directory \" + tempProperty.getValue());\n                            }\n                        }\n                    }\n                }\n            } else {\n                myLogger.info(\"Current User is Forbidden from seeing this Page\");\n                response.sendError(response.SC_FORBIDDEN);\n            }\n        } catch (PersistentModelException e) {\n            myLogger.log(Level.INFO, \"Unable to find page \" + selectedPage, e);\n            response.sendError(response.SC_NOT_FOUND);\n        } catch (PresentationException pe) {\n            pe.printStackTrace();\n            throw new ServletException(\"Error processing the page\", pe);\n        }\n    }\n", "code2": "    public static boolean copyTextFile(File src, File dst) {\n        try {\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(src));\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(dst));\n            byte[] buf = new byte[1024];\n            int readsize = 0;\n            while ((readsize = bis.read(buf)) != -1) {\n                bos.write(buf, 0, readsize);\n            }\n            bos.flush();\n            bos.close();\n            bis.close();\n        } catch (IOException e) {\n            ServerConsoleServlet.printSystemLog(e.toString() + \" \" + e.getMessage(), ServerConsoleServlet.LOG_ERROR);\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"doGet": ["handleGet", "didGET", "handleget", "didPut", "didGet", "handleGET", "handlePut", " doPut", "doPut", "didget", " doget", "doGET", "doget", " doGET"], "request": ["p", "method", "message", "create", "remote", "result", "buffer", "current", "client", "instance", "frame", "config", "info", "model", "view", "event", "input", "image", "complete", "req", "data", "object", "resource", "QUEST", "document", "url", "server", "Response", "query", "connection", "string", "queue", "attribute", "user", "type", "xml", "Request", "report", "application"], "response": ["message", "result", "re", "output", "json", "client", "model", "view", " Response", "image", "application", "resp", "writer", "service", "object", "resource", "reply", "location", "description", "document", "wa", "subject", "reason", "server", "Response", "pool", "query", "res", "body", "index", "api", "onse", "connection", "header", "respond", "collection", "results", "feed", "site", "error", "report", "status", "http"], "selectedPage": ["selectedSite", "lectedLine", "lectedButton", "lectedpage", "lectedSite", "lectedAction", "electedpage", "selectedHour", "selectionHour", " selectedAction", "selectionpage", " selectedItem", "selectionLine", "selectedAction", "namedPage", "selectedpage", "selectionFile", "electedPage", "electedButton", "namedLine", "selectionAction", "electedLine", "selectionPage", " selectedSite", " selectedButton", " selectedLine", "selectedLine", "namedFile", "selectedFile", "selectedItem", "namedpage", "lectedHour", "lectedPage", " selectedHour", "namedSite", " selectedFile", " selectedpage", "lectedFile", "selectionButton", "lectedItem", "selectedButton", "selectionItem"], "page": ["message", "cache", "instance", "project", "image", "location", "proxy", "ip", "url", "display", "article", "pool", "sp", "je", "rule", "channel", "profile", "queue", "pp", "type", "section", "result", "position", "client", "model", "view", "po", " Page", "item", "module", "age", "ice", "peer", "Page", "plugin", "site", "unit", "user", "parent", "account", "me", "language", "point", "pl", "pg", "resource", "document", "number", "block", "html", "office", "node", "p", "phone", "port", "f", "per", "menu", "photo", "record", "change", "server", "ge", "fe", "address", "child", "connection", "handler", "route", "row", "layout"], "portalRequest": [" portialRequest", "portugalOrder", "portialPage", "portialResponse", "portugalRequest", "portpalPage", "portortalRequest", "portbalQuery", "portugalResponse", "portalOrder", "portALEvent", "portelRequest", "PortortalEvent", " portialQuery", "portALUser", "portortalServer", "portortalPage", " portialResponse", "PortalServer", " portalQuery", "portallingAccess", "PortalOrder", "portugalServer", "portpalRequest", "PortalRequest", "portalServer", "portallRequest", "portelQuery", "portailResponse", "portallServer", "PortortalRequest", "portALResponse", "portalAccess", "PortortalPage", "PortortalAccess", "portugalUser", " portalResponse", "portalEvent", "portallResponse", "PortalUser", "portalUser", "PortortalOrder", "portallingRequest", "portpalResponse", "portelPage", "portbalResponse", "portpalAccess", "portelResponse", "portALRequest", "portallingResponse", "PortalCommand", "portortalResponse", "portalResponse", "portortalOrder", "portelCommand", " portalPage", "PortalAccess", "portallUser", "portialRequest", "PortortalUser", "portalQuery", "PortalEvent", "portortalEvent", "PortortalCommand", "PortalPage", "portbalRequest", " portialPage", "PortortalServer", "portalCommand", "portortalUser", "portortalAccess", "portugalEvent", "portallingPage", "portailUser", "portortalCommand", "PortortalResponse", "portbalPage", "portialQuery", "portailOrder", "PortalResponse", "portallingCommand", "portailRequest", "portalPage"], "pageProp": ["pagePro", " pagePro", "agePro", "projectProperty", "pluginProperty", "pluginPro", "parentObj", "PagePro", "resourceProp", "pageProperty", "ageprop", "resourcePro", "pageObj", "Pageprop", "PageProperty", "parentPro", " pageStr", "parentProperty", "projectPro", "PageObj", "resourceProperty", "ageProp", "peerPro", "peerStr", "PageStr", "parentProp", " pageProperty", " pageObj", "pluginProp", "projectprop", "resourceprop", "peerProperty", "pageStr", "PageProp", "peerProp", "ageProperty", "projectProp", "pluginprop", "pageprop"], "possiblePage": ["PossiblePages", "pablePages", "puredItem", "Possibilitypage", "possiblyItem", "PossibilityPages", "possiblyPage", "patchingItem", "patchingpage", "PossibleOrder", "PossibleItem", "possiblepage", "PossiblePage", "pablePage", "PossiblyOrder", "patchedLine", "puredPage", "patchedPage", "PossibilityPage", "patchingGroup", "patchedOrder", "PossiblyLine", "possiblePages", "possibilityLine", "possiblyLine", "permanentLine", "possiblyOrder", "permanentOrder", "pablepage", "possibleItem", "PossiblyPage", "patchedpage", "possibleOrder", "PossibleLine", "possiblyPages", "PossibleGroup", "possiblypage", "puredGroup", "permanentPage", "pableLine", "patchingPage", "possibilityPage", "permanentpage", "PossibilityLine", "PossiblyItem", "possibleLine", "possibleGroup", "PossiblyGroup", "puredpage", "Possiblypage", "possibilitypage", "Possiblepage", "possiblyGroup", "possibilityPages"], "property": ["p", "binding", "result", "expression", "prop", "perties", "set", "table", "feature", "language", " Property", "f", "config", "project", "uration", "data", "duration", "object", "resource", "binary", "operator", "integer", "Property", "class", "character", "name", "label", "entity", "function", "number", "address", "notation", "term", "variable", "header", "string", "prefix", "section", "profile", "future", "layer", "attribute", "value", "properties", "key", "t", "type", "maximum"], "referer": ["Refender", "referers", "refiner", "Referers", " refere", " referen", "deferer", "ferer", "defrer", "Refre", " refre", "afferer", "refeline", "defere", "refender", "diffiner", "Refiner", "diffender", "Refrer", "fere", "Refber", "affere", "reiner", "Referen", "diffrer", "refre", "rere", "refber", "refrer", "ferers", "redber", "rederer", " refrer", "refere", "defender", "referen", "Referer", " refber", "differer", "redeline", "reere", "Refere", "affrer", "reerer", "defber", " refiner", "rerer", " refender", " refeline", "Refeline", "redrer", "afferen", " referers", "frer"], "e": ["p", "me", "message", "se", "f", "this", "event", "i", "ie", "d", "one", "de", "ed", "exc", "ele", "or", "E", "a", "null", "fe", "see", "element", "ee", "ae", "eme", "es", "err", "er", "o", "type", "esi", "error", "ception", "ea"]}}
{"id1": "20365090", "id2": "7372311", "code1": "        public HttpResponseExchange execute() throws Exception {\n            HttpResponseExchange forwardResponse = null;\n            int fetchSizeLimit = Config.getInstance().getFetchLimitSize();\n            while (null != lastContentRange) {\n                forwardRequest.setBody(new byte[0]);\n                ContentRangeHeaderValue old = lastContentRange;\n                long sendSize = fetchSizeLimit;\n                if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) {\n                    sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1);\n                }\n                if (sendSize <= 0) {\n                    break;\n                }\n                lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength());\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_RANGE, lastContentRange);\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sendSize));\n                forwardResponse = syncFetch(forwardRequest);\n                if (sendSize < fetchSizeLimit) {\n                    lastContentRange = null;\n                }\n            }\n            return forwardResponse;\n        }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 0, "substitutes": {"execute": [" poll", " future", " work", " pull", " parse", " await", " transfer", " resolve", " async", " open", " flush", " dispatch", " produce", " feed", " refresh", " current", " serve", " fulfill", " perform", " prepare", " initialize", " generate", " end", " proceed", " go", " exec", " ping", " handle", " finish"], "forwardResponse": ["forwardServer", "wardRequest", "publicRequest", "publicResponse", "wardResp", " forwardAnswer", " backwardServer", " backwardRequest", " forwardServer", "wardresponse", " forwardResp", "publicServer", " forwardRequest", "ForwardRequest", "forwardresponse", "Forwardresponse", "forwardView", "forwardRequest", "wardView", " backwardResponse", " forwardresponse", "forwardAnswer", "ForwardResponse", "publicAnswer", "forwardResp", " forwardView", " backwardAnswer", "ForwardView", "wardResponse", "ForwardResp"], "fetchSizeLimit": ["fatchLengthLim", "fetchSizeRange", "fetchLimitGlobal", "faitLimitLock", "fetchsizeLim", "fetchLengthRange", "fetchRangeLimit", "faitSizeBlock", "fatchLengthPosition", "fetchCountRange", "fetchLimitRange", "fetchLengthUnit", "fatchSizeLimited", "fetchCountBlock", "fetchLengthLim", "fatchSizeLimit", "fetchRangePage", "fetchsizeLock", "fatchSizePosition", "fetchSizeUnit", "fetchLengthBlock", "fetchLimitPosition", "faitLimitGlobal", "fatchLengthLock", "fushCountPage", "fetchSizePosition", "faitSizeLimit", "fushSizeUnit", "faitSizeLock", "fetchsizeLimited", "faitLimitLimit", "fatchSizeBlock", "fetchCountLimit", "fetchLengthLock", "fatchSizeLock", "fushSizePage", "fetchsizeBlock", "fetchLengthPosition", "fetchLimitLock", "fetchsizeGlobal", "faitSizeGlobal", "fetchSizeLim", "fetchSizeLimited", "fetchSizeBlock", "fetchRangeUnit", "faitLimitBlock", "fatchSizeLim", "fetchLimitLimit", "fushSizeLimit", "fetchSizeLock", "fetchLimitBlock", "fatchLengthLimit", "fetchLengthGlobal", "fushCountLimit", "fatchLengthLimited", "fetchsizeLimit", "fetchLengthPage", "fatchSizeRange", "fushCountUnit", "fetchSizePage", "fetchCountPosition", "fushCountRange", "fatchLengthRange", "fetchRangeRange", "fetchLengthLimit", "fatchLengthBlock", "fetchCountUnit", "fetchCountPage", "fetchSizeGlobal", "fetchLengthLimited", "fushSizeRange"], "lastContentRange": [" lastSizeRange", "lastCharacterRange", "lastContentRow", "lastMessageResource", "lastContentLine", "latestContentRow", " lastContentArea", " lastHeaderRegion", "latestFileRange", " lastContentInfo", "LastMessageResource", " lastContentResource", "lastMessageSpace", "lastReadRegion", "lastCharacterRegion", "lastHeaderResource", "lastVersionrange", "lastResourceRow", "lastCurrentLine", "lastCharacterOrigin", " lastContentRow", "lastFileRow", "lastMessageRow", "latestContentRange", " lastContentOrigin", " lastReadInfo", "lastVersionRange", "lastCurrentSpace", "lastReadResource", "lastResourceRange", "lastHeaderRange", "latestContentResource", "lastContentInfo", "lastCharacterRow", "LastContentLine", " lastContentrange", "lastResourceRegion", "lastResourcerange", " lastHeaderOrigin", " lastContentSpace", "latestFileResource", "lastContentSpace", "lastSizeRange", "lastResourceSpace", "lastReadRow", "LastContentResource", "lastContentRegion", "lastSizeRegion", "lastResourceArea", " lastSizeArea", "lastSizeSpace", " lastSizeSpace", "lastSizeArea", "lastReadrange", "lastReadSpace", "lastReadRange", "LastContentRange", "LastContentSpace", "lastVersionResource", " lastReadrange", "LastMessageSpace", "lastCurrentRange", " lastSizeRegion", "latestFileRow", "lastFileResource", "lastResourceResource", " lastReadRange", "lastContentResource", "lastHeaderRegion", " lastContentRegion", " lastHeaderRange", "LastMessageLine", "lastHeaderSpace", "lastMessageRange", "lastVersionInfo", "lastReadArea", " lastReadResource", "lastHeaderLine", "lastHeaderRow", "lastResourceInfo", "lastContentrange", "lastHeaderOrigin", " lastHeaderRow", "lastContentOrigin", "LastMessageRange", "lastMessageLine", "lastReadInfo", "lastCurrentResource", "lastResourceOrigin", "lastContentArea", "lastFileRange"], "old": ["val", "from", "string", "original", "base", "past", "list", "add", "now", "OLD", "slice", "current", "inner", "older", "later", "l", "el", "existing", "ld", "last", "la", "form", "client", "part", "less", "after", "expected", "before", "Old", " Old", "diff", "common", "other", "build", "small", "file", "local", "object", "ant", "ore", "format", "or", "plugin", "folder", "normal", "to", "full", "low", "update", "ext", "obj", "future", "and", "prev", "handle", "element", "orig", "arrow", "front"], "sendSize": ["sentLength", "transferRange", "sendSIZE", "drawLength", " sendLen", "writeRange", "endLength", "endSIZE", " sendTime", "sendLength", "loadSize", "forceSIZE", " sendLength", "loadSIZE", "transferSize", "SendStorage", " sendSIZE", "updateSIZE", "endTime", "forceSize", "drawLimit", "sentLimit", "SendSize", "transferLength", "sendOffset", "sendRange", " sendLimit", " sendStorage", "forceLength", "sendLimit", "writeLength", "sendStorage", "pushSIZE", "updateLen", "endEnd", "sendTime", "drawSize", "loadTime", " sendEnd", "SendEnd", "sendEnd", "sentSize", "forceTime", "updateSize", "pushLen", "transferOffset", "loadOffset", "sendLen", "pushTime", "endStorage", "updateLimit", "endLimit", "pushLimit", "endSize", "drawSIZE", "writeSize", "pushLength", "loadRange", "loadLength", "SendLength", "sentSIZE", "writeOffset", "pushSize"]}}
{"id1": "7764011", "id2": "10158738", "code1": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"readScalarpvviewerDocument": ["readScalarpvvieweString", "readScalarpvvieweDocument", "readScalarpvViewerdocument", "readScalarpvViewersdocument", "readScalarpvviewerString", "readScalarpvviewedDocument", "readScalarpvviewersString", "readScalarpvviewedData", "readScalarpvViewersDocument", "readScalarpvViewerString", "readScalarpvViewerDocument", "readScalarpvviewedocument", "readScalarpvViewersString", "readScalarpvviewerData", "readScalarpvvieweData", "readScalarpvviewerdocument", "readScalarpvviewersdocument", "readScalarpvviewersData", "readScalarpvvieweddocument", "readScalarpvviewersDocument", "readScalarpvViewersData", "readScalarpvViewerData", "readScalarpvviewedString"], "url": ["page", "uri", "ssl", "resource", "image", "server", "connection", "remote", "io", "data", "link", "entry", "input", "URL", "href", "job", "bel", "xml", "source", "reader", "config", "filename", "stream", "l", "base", "user", "object", "address", "string", "file", "name", "service", "sl", "host", "path", "Url", "location", "buffer", "http"], "xmlData": ["rssdata", " xmlString", "xmlString", "wsDATA", "xfData", "mlCode", "xmlCode", "xfText", "rssData", "xmlPart", "textDATA", "wsString", "parseData", "xmlDATA", "phpDATA", "parsedata", "parseText", "textData", " xmlCode", "mlContent", " xmldata", "mldata", "mlText", "phpPart", "xmlText", "rssString", "rssDATA", "xfDATA", "textPart", "phpContent", "wsData", "xmlContent", "textContent", " xmlText", "parseCode", "phpData", "mlData", "xmldata", " xmlContent", "wsdata", "mlDATA", " xmlDATA", "xfContent", " xmlPart"], "in": ["rec", "m", "ins", "ssl", "In", "b", "connection", "data", "this", "inc", "socket", "f", "input", "din", "IN", "lin", "inn", "h", "out", "s", "i", "kin", "win", "source", "reader", "a", "stream", "l", "login", "nin", "inner", "min", "r", "bin", "c", "file", "con", "ini", "buffer", "again", "serv", "doc"], "line": ["one", "letter", "data", "single", "part", "phrase", "entry", "split", "cl", "row", "pass", "l", "string", "file", "non", "on", "page", "pe", "text", "unit", "message", "e", "cell", "link", "no", "error", "el", "code", "plugin", "parse", "point", "object", "c", "word", "lc", "content", "LINE", "log", "none", "sync", "rule", "str", "lin", "lines", "end", "job", "comment", "section", "user", "character", "Line", "sl", "value", "chain", "block", "lf", "write", "le", "item", "range", "edge", "strip", "nl", "inline", "ip", "base", "name", "auto", "ine"], "cont": ["resp", "text", "CONT", "circ", "ct", "const", " continuous", "parent", "count", "complete", "dest", "prev", "form", "cell", "cart", "expl", "feat", "collect", "cond", "result", "cor", "str", "acc", "coll", "contin", "sect", "ent", " Cont", "comb", "ci", "out", " CONT", "rest", " cur", "progress", "multi", "keep", " cond", "ctr", "tr", "det", "match", "mult", "err", "Cont", "continue", "left", "full", "clean", "content", "lc", "comp", "ident", "close", "contract", "feed", "ont", "ext", "char", "com"], "readAdp": ["ReadAxps", " readads", "loadADp", "readEllp", "readAdr", "readEdps", " readAdr", "readAxps", "readADp", "readadps", " readAbpi", " readAbr", "readADb", "readAxP", "readEdpi", "readEllpi", "loadAdp", " readadpi", "readAblp", "ReadAxpi", "readAds", "readads", "readPromp", "loadAdpi", "readAdc", " readAdP", "readAdb", "loadADb", " readAds", "ReadAdc", "readAbb", "loadADpi", "readEdc", "readAbr", "readAxpi", "readadP", "readAdP", "readAxp", "readadpi", "readPromlp", "readPromb", "readADlp", "readAdlp", "loadAdlp", "readadp", "readAdps", " readAbp", "loadADlp", "readElllp", "readAdpi", " readAdpi", "readADs", "ReadAdp", "readadc", "readAxs", "readAxc", "readADr", "readAbpi", " readAblp", "loadAdb", "ReadAxp", " readAdlp", "readEllr", "readADpi", "readADP", "ReadAdpi", " readadp", "readAbp", "readPrompi", "ReadAdps", "ReadAxc", "readEdp", " readadP"], "scalarpvviewerData_Adaptor": ["scalarpvviewerDataLocalAdaptors", "scalarpvviewerData_Uploadive", "scalarpvviewerDataLocaladaptor", "scalarpvviewerDataerAdaptors", "scalarpvviewerData_Connectors", "scalarpvviewerDataeradapter", "scalarpvviewerData_Selectors", "scalarpvviewerData_Collectutor", "scalarpvviewerData_AdaptOR", "scalarpvviewerData_Creative", "scalarpvviewerDataLocalAdaptator", "scalarpvviewerData_Uploadator", "scalarpvviewerData_Collector", "scalarpvviewerData_adaptator", "scalarpvviewerData_adaptive", "scalarpvviewerDataeradaptors", "scalarpvviewerData_Adaptractor", "scalarpvviewerDataLocaladaptOR", "scalarpvviewerData_adaptractor", "scalarpvviewerDataeradaptator", "scalarpvviewerDataLocaladaptator", "scalarpvviewerData_Adaptator", "scalarpvviewerDataeradaptor", "scalarpvviewerData_Creator", "scalarpvviewerData_Creators", "scalarpvviewerData_Connectutor", "scalarpvviewerData_Adaptors", "scalarpvviewerData_adaptors", "scalarpvviewerDataerAdaptutor", "scalarpvviewerData_Collectator", "scalarpvviewerData_Collectractor", "scalarpvviewerData_Creatutor", "scalarpvviewerData_Adaptive", "scalarpvviewerData_adapter", "scalarpvviewerData_Uploador", "scalarpvviewerData_Creater", "scalarpvviewerData_Selectator", "scalarpvviewerData_CollectOR", "scalarpvviewerData_Adaptutor", "scalarpvviewerDataerAdaptator", "scalarpvviewerData_Selector", "scalarpvviewerData_adaptor", "scalarpvviewerData_Collectors", "scalarpvviewerDataerAdaptractor", "scalarpvviewerData_adaptOR", "scalarpvviewerData_ConnectOR", "scalarpvviewerData_Uploadors", "scalarpvviewerDataLocalAdaptOR", "scalarpvviewerDataerAdaptor", "scalarpvviewerData_adaptutor", "scalarpvviewerDataerAdapter", "scalarpvviewerDataeradaptutor", "scalarpvviewerData_Connector", "scalarpvviewerData_Connectator", "scalarpvviewerDataLocalAdaptor", "scalarpvviewerData_Creatator", "scalarpvviewerData_Connecter", "scalarpvviewerData_Selecter", "scalarpvviewerData_Adapter", "scalarpvviewerDataeradaptractor", "scalarpvviewerDataLocaladaptors"], "params_font": ["params_layout", "paramsinglarge", " params_layout", "ams_large", "pins_text", "ams_font", " params_Font", "params_password", "paramsingpen", "ams_fat", "ams_pen", "params_theme", "params_pen", "paramsingfont", "pins_password", "paramsingfat", "params_chart", "params_shadow", "pins_font", "ams_chart", "params_Font", "pins_fat", "params_fat", "params_text", "ams_theme", "params_large", " params_shadow"], "font_size": ["font\u00b7number", "text_size", " font_handle", "font\u00b7size", "font_type", "font_scale", "fontBlocktype", "fontBlockalign", "text_Size", "font_align", "font_Size", " font_number", "text_align", "font_handle", "font\u00b7handle", " font_scale", "text_type", "fontBlocksize", " font_Size", "font_number", "fontBlockSize"], "style": [" size", "css", "font", "padding", "pad", "length", "count", "offset", "Style", "letter", "thin", "height", "profile", "depth", "weight", "scale", "margin", "shape", " Style", "family", "shadow", "type", "class", "theme", "size", "width", "position", "layout", "name", "color", "pattern", "grade", "order", "level", "estyle", "format", "force", "styles"], "font_Family": ["style_Style", " font_fam", "fontNamefamily", "style_Family", "font_Format", "fontNameFamily", "font_family", "style_family", " font_family", "fontingfamily", "fontingStyle", "fontingFamily", " font_Format", "fontNameStyle", "font_fam", "font_Style"], "globalFont": ["globalfont", "parentFont", "Globalfont", "globalFontSize", " globalfont", "generalFontSize", "localText", "GlobalFont", " globalText", " globalFontSize", "GlobalFontSize", "localFont", "generalText", "globalText", "parentFontSize", "parentfont", "GlobalText", "generalFont", "parentText", "localFontSize"], "params_pts": ["params_erts", "params_tds", "params__ptm", "params_ptp", "params_rtn", "params_PTp", "params_ptn", "params_fontss", "params__pts", "params_PTe", "params_fontn", "params_eptss", "params_erta", "params__cts", "params_pta", "params_pte", "params__ctn", "params_rts", "params_erte", "params_PTm", "params_fonts", "params_ctm", "params_PTa", "params_eptn", "params_tde", "params_PTs", "params__ptn", "params_rtm", "params_fontp", "params__ctm", "params_epts", "params_PTss", "params_ctn", "params_PTn", "params_ptm", "params_tda", "params_cts", "params_eptp", "params_ptss"], "params_data": ["params\n", "Parameters\n", "paramsname", "Parametersname", " params\n", "paramname", "param\n", " paramsname"]}}
{"id1": "10385815", "id2": "4750967", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"copy": ["zip", "Copy", "replace", "cmp", "move", "write", "clone", "split", "sync", "upload", "open", "file", "Cop", "get", "put", "delete", "exec", "change", "send", "update", " Copy", "create", "Transfer", "paste", "process", "transfer", "download"], "fileFrom": ["FileStart", "ioFrom", "FileTo", "ioSource", "FileSource", "mailFrom", "FileIn", "ioTo", "fileIn", "FileAs", " fileStart", " fileAs", "fileStart", "mailAs", " fileSource", "mailIn", "ioStart", "mailTo", "fileSource", "fileAs", "FileFrom", " fileIn"], "fileTo": [" fileFile", "fpTo", "fileTO", "FileTo", "FileFile", "fpTO", "FileTO", " fileTarget", "resourceTo", "resourceFile", "fpto", "Fileto", "FileTarget", "fileFile", "resourceTarget", "fileTarget", "fpFrom", " fileTO", "fileto", "resourceFrom", " fileto", "FileFrom"], "inputStream": ["InputContext", " inputFile", "outputSteam", "InputSync", "inputSteam", "inputSync", "inputFile", " inputSync", " inputstream", "InputFile", "outputstream", " inputSteam", "InputChannel", "outputContext", " inputContext", "inputContext", "outputSync", "Inputstream", "outputFile", "inputstream", "InputSteam", "InputStream"], "outputStream": ["inputSocket", "OutputChannel", "outputSteam", "inputSteam", "fourStreamer", "outputSocket", "fourStream", "OutputStreamer", "outputPath", "inputChan", "referenceSteam", "inputPath", "OutputSteam", "referenceSocket", "outputStreamer", "OutputStream", " outputPath", " outputStreamer", "writeChannel", "referenceChannel", "fourChannel", " outputChan", "writeSteam", "writeSocket", "writeStream", "outputChan", "OutputChan", " outputSteam", "referenceStream", "OutputPath", "fourSteam"], "inputChannel": ["parentStream", "butChan", "InputContext", "audioChannel", "inputSocket", "inputPassword", " inputCam", "outputSocket", "butContext", " inputSocket", "InputSocket", "inputChan", "butCommand", "outputPassword", "audioCam", "outputCam", " inputPassword", " inputClient", "inputClient", "InputChannel", "inputCam", "audioClient", "inputCommand", "parentPassword", "parentChannel", "butChannel", "outputClient", " inputChan", "outputCommand", "outputContext", " inputContext", "parentChan", "outputChan", "inputContext", "audioStream", "InputChan", " inputCommand", "InputStream"], "outputChannel": ["Outputchannel", "inputchannel", " outputchannel", "OutputQueue", " outputQueue", "OutputChannel", "outContext", "OutputContext", "outputQueue", "inputChan", "outStream", "outChan", "OutputStream", " outputContext", "outputchannel", " outputChan", "outputContext", "inputContext", "outputChan", "OutputChan", "inputQueue", "outChannel"]}}
{"id1": "16804988", "id2": "20310134", "code1": "    public void init() {\n        String filename = getParameter(\"filename\");\n        if (filename == null) {\n            Error(\"Illegal filename\");\n            return;\n        }\n        Dimension dim = DEFAULT_SIZE;\n        try {\n            int w = Integer.parseInt(getParameter(\"width\"));\n            int h = Integer.parseInt(getParameter(\"height\"));\n            dim = new Dimension(w, h);\n        } catch (Exception e) {\n        }\n        InputStream in;\n        try {\n            File ff = new File(filename);\n            in = new FileInputStream(ff);\n        } catch (Exception ignore) {\n            try {\n                URL url = new URL(filename);\n                in = url.openStream();\n            } catch (Exception e) {\n                Error(\"Graph viewer: Failed to open: \" + filename + \"\\n\" + e);\n                return;\n            }\n        }\n        getContentPane().add(getWindow(in));\n        resize(dim);\n        repaint();\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"init": [" startup", "parse", "activate", "load", " Init", "start", " initialized", "image", "setup", "build", "format", "launch", "construct", "info", "Init", "show", "config", "layout", "Initialized", "update", " initialization", "ize", "close", "it", "create", "draw", "initial"], "filename": ["fp", "params", "title", "jpg", "dll", "metadata", "kl", "fil", "which", "ename", "path", "utf", "folder", "nil", "location", "string", "name", "length", "binary", "word", "doi", "prefix", "upload", "database", "files", "journal", "username", "SourceFile", "ssl", "ppa", "directory", "n", "online", "config", "loc", "loader", "uri", "license", "kn", "content", "Filename", "fd", "phrase", "l", "txt", "fn", "file", "fax", "password", "download", "sf", "size", "f", "il"], "dim": ["im", "cm", "thin", "img", "imm", "wid", "Dim", "marg", "project", "gm", "sam", "ims", "div", "val", "index", "py", "fm", "ext", "param", "image", "multi", "spec", "dem", "si", "mi", "m", "format", "info", "g", "dat", "shape", " reim", "span", "iframe", "config", "slice", "diff", "grad", "du", "p", "scale", "min", "dom", "fi", "mod", "grid", "dr", "di", "wm", "width", "dist", "d", "num", "dimension", "dm", "lim", "part", " Dim", "size", "fac"], "w": ["wt", "v", "z", "wa", "k", "e", "x", "q", "u", "s", "max", "hw", "c", "rw", "y", "m", "en", "t", "a", "i", "r", "b", "n", "o", "ow", "weight", "ew", "win", "wh", "height", "p", "wd", "l", "W", "width", "fw", "d", "sw", "f"], "h": ["H", "v", "z", "k", "rh", "e", "x", "gh", "q", "hr", "s", "u", "kh", "hd", "uh", "c", "hs", "y", "t", "en", "j", "ph", "b", "n", "th", "o", "height", "p", "hm", "sh", "l", "bh", "d", "ih", "ah", "oh", "ht", "f", "ha"], "in": ["fp", "serv", "gin", "cf", "ins", "cl", "reader", "din", "IN", "login", "el", "bin", "id", "io", "inc", "ini", "fb", "input", "out", "In", "conn", "stream", "err", "fe", "ax", "lib", "read", "ssl", "i", "r", "connection", "b", "n", "again", "fc", "socket", "nin", "win", "inn", "resource", "min", "pin", "is", "l", "data", "source", "file", "cgi", "kin", "src", "ac", "amin", "impl", "as", "f", "fac"], "ff": ["uf", "fp", "cf", "iff", "xff", "ouf", "bb", "feed", "ulp", "ffe", "df", "ctx", "fb", "fl", "fff", "aff", "fe", "ef", "buff", "fx", "library", "buf", "eff", "back", "fc", "FF", "fed", "af", "fd", "lf", "file", "bf", "pp", "sf", "cb", "f", "cmp"], "url": ["fp", "base", "ob", "e", "feed", "io", "URL", "zip", "path", "sl", "fl", "Url", "fb", "string", "ls", "stream", "image", "ssl", "connection", "b", "ll", "www", "fr", "uri", "resource", "http", "l", "source", "file", "web", "server", "download", "src", "open", "sf", "f"]}}
{"id1": "17817568", "id2": "20426057", "code1": "    public Reader getGETReader_bak(URL url) {\n        Reader reader = null;\n        if (Navigator.isVerbose()) System.out.println(\"Web3DService.getGETReader caching \" + url);\n        int contentLength = -1;\n        URLConnection urlc;\n        try {\n            urlc = url.openConnection();\n            urlc.setReadTimeout(Navigator.TIME_OUT);\n            if (getEncoding() != null) {\n                urlc.setRequestProperty(\"Authorization\", \"Basic \" + getEncoding());\n            }\n            urlc.connect();\n            String content_type = urlc.getContentType();\n            if (content_type == null || content_type.equalsIgnoreCase(\"x-world/x-vrml\") || content_type.equalsIgnoreCase(\"model/vrml\") || content_type.equalsIgnoreCase(\"model/vrml;charset=ISO-8859-1\")) {\n                InputStream is = urlc.getInputStream();\n                DataInputStream d = new DataInputStream(is);\n                contentLength = urlc.getContentLength();\n                byte[] content = new byte[contentLength];\n                if (d != null) {\n                    d.readFully(content, 0, contentLength);\n                }\n                is.close();\n                d.close();\n                ByteArrayInputStream bais = new ByteArrayInputStream(content);\n                reader = new InputStreamReader(bais);\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip\")) {\n                InputStream is = urlc.getInputStream();\n                BufferedInputStream bis = new BufferedInputStream(is);\n                GZIPInputStream gis = new GZIPInputStream(bis);\n                StringBuffer sb = new StringBuffer();\n                BufferedReader zipReader = new BufferedReader(new InputStreamReader(gis));\n                char chars[] = new char[10240];\n                int len = 0;\n                contentLength = 0;\n                while ((len = zipReader.read(chars, 0, chars.length)) >= 0) {\n                    sb.append(chars, 0, len);\n                    contentLength += len;\n                }\n                chars = null;\n                gis.close();\n                zipReader.close();\n                bis.close();\n                is.close();\n                reader = new StringReader(sb.toString());\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(cis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    cis.close();\n                    bufReader.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"model/vrml.gzip.encrypted\")) {\n                InputStream is = urlc.getInputStream();\n                StringBuffer sb = new StringBuffer();\n                Cipher pbeCipher = createCipher();\n                if (pbeCipher != null) {\n                    CipherInputStream cis = new CipherInputStream(is, pbeCipher);\n                    GZIPInputStream gis = new GZIPInputStream(cis);\n                    BufferedReader bufReader = new BufferedReader(new InputStreamReader(gis));\n                    char chars[] = new char[1024];\n                    int len = 0;\n                    contentLength = 0;\n                    while ((len = bufReader.read(chars, 0, chars.length)) >= 0) {\n                        sb.append(chars, 0, len);\n                        contentLength += len;\n                    }\n                    chars = null;\n                    bufReader.close();\n                    gis.close();\n                    cis.close();\n                    reader = new StringReader(sb.toString());\n                }\n            } else if (content_type.equalsIgnoreCase(\"text/html;charset=utf-8\")) {\n                System.out.println(\"text/html;charset=utf-8\");\n            } else {\n                System.err.println(\"ContentNegotiator.startLoading unsupported MIME type: \" + content_type);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return reader;\n    }\n", "code2": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "label": 0, "substitutes": {"getGETReader_bak": ["getGETReader_bcaz", "getGETReader_abak", "getGETReader_cunk", "getGETReader_bunk", "getGETReader_bck", "getGETReader_bcunk", "getGETReader_ck", "getGETReader_abaz", "getGETReader_bk", "getGETReader_bcak", "getGETReader_abk", "getGETReader_abunk", "getGETReader_cak", "getGETReader_baz", "getGETReader_caz"], "url": ["resource", "pull", "stream", "string", "host", "http", "str", "service", "www", "URL", "path", "ll", "ur", "api", "feed", "gl", "Url", "rl", "client", "user", "address", "bug", "loc", "lr", "build", "l", "connection", "base", "rc", "server", "location", "coll", "config", "loader", "sl", "f", "link", "image", "html", "ssl", "page", "r", "uri", "buffer", "source", "org", "name", "file", "lc"], "reader": ["resource", "entry", "row", "library", "instance", "http", "oder", "inner", "service", "input", "io", "feed", "driver", "object", "handler", "er", "rc", "server", "dr", "loader", "read", "Reader", "rer", "iter", "per", "writer", "ser", "data", "rr", "r", "parser", "rar", "buffer", "source", "client"], "contentLength": ["ContentLen", "encSize", " contentSize", "messageSize", " contentlength", "messageLength", "contentOffset", "Contentlength", "resourceLength", "ContentLength", "contentLen", "contentlength", "ContentSize", "loadlength", " contentOffset", "resourceLen", "resourcelength", "enclength", "contentSize", "outputlength", "ContentOffset", "outputLength", "resourceType", "resourceSize", "messageType", "ContentType", "loadLength", "resourceOffset", "contentType", " contentType", "encLength", "loadSize", "messageLen", "messagelength", "loadType", " contentLen", "outputType", "outputLen"], "urlc": ["urlac", "relC", "webci", "urlf", "URLi", " urlci", "UrlC", "URLcb", "urlp", "certcase", "blogf", " urli", "Urlci", "blogd", " urln", "relc", "looklc", "Urle", "urld", "httpc", " urlac", "Urlf", " urlf", "Urlc", "urlcb", "relcase", "runC", "urllc", "httpac", "urlci", "blogac", "runcase", " urld", "URLp", "webp", "methodc", "httpd", "lln", "certc", "httpi", "llc", "lookf", "urle", "Urlac", "urln", " urlcase", "looki", "Urln", "runcs", "urcb", "Urld", "relcs", "urlcs", "methodd", "methode", " urle", "urll", "URLC", "URLci", " urll", "urlC", "urc", "URLcase", "URLe", "blogc", "urlcase", "urli", " urlp", "certe", "llf", "URLc", "Urli", "httpf", "lookc", " urllc", "runc", "httplc", "webcs", " urlcs", "lli", "certl", " urlC", "urC", "URLac", "URLl", "methodci", "webc", " urlcb", "urp", "URLcs"], "content_type": ["contentEsize", "documentaltype", "contentEversion", "Content_Type", "content_info", "Content_name", "document_key", "content_token", "document_type", "contentaltoken", "content__type", "Content_types", "content64type", "Content_block", "contentFileversion", " content_types", "content64key", "document_state", "content64token", "contentalkey", "contentEtype", "content__Type", "content_name", "content_Type", " content_size", "content_size", "contentTypeinfo", "content_block", "content__family", "contentTypetypes", "Content_platform", " content_info", "contentFilekey", "content__name", "document_token", "contentTypestyle", "contentalstate", "content_platform", " content_style", "contentEkey", "contentaltype", "content_state", "documentaltoken", "content_key", "content_style", "content64state", "content_family", "Content_type", "contentTypetype", " content_version", "Content_family", "documentalkey", "content_types", "contentFiletype", "contentFilesize", "content_version", " content_key", "documentalstate"], "is": ["ics", "dis", "si", "isa", "ios", "ois", "im", "ii", "isl", "ir", "ide", "was", "iris", "has", "as", "ais", "os", "IS", "ins", "ri", "are", "address", "ie", "it", "isin", "init", "s", "qs", "Is", "vs", "iss", "iso", "its", "idis", "iter", "isi", "isc", "sis", "i", "ori", "iri", "alis", "sin", "mis", "lis", "nis", "ps", "tis", "id", "es", "info", "iv", "ris"], "d": ["dc", "df", "done", "did", "g", "c", "m", "dat", "dos", "dist", "dl", "da", "di", "fd", "z", "bd", "ad", "p", "dd", "l", "w", "cd", "del", "s", "dh", "dr", "dt", "f", "nd", "e", "dump", "director", "i", "ds", "gd", "q", "dom", "h", "dm", "ded", "der", "v", "dad", "data", "dig", "md", "sd", "b", "de", "id", "D", "dim", "db"], "content": ["resource", "status", "media", "section", "stream", "c", "current", "cache", "xml", "script", "comment", "cover", "layer", "desc", "cont", "json", "child", "address", "header", "default", "document", "device", "model", "exec", "server", "Content", "load", "x", "config", "complete", "read", "array", "children", "enc", "code", "value", "image", "page", "result", "output", "data", "raw", "message", "source", "buffer", "text", "body", "version", "core", "dec"], "bais": ["BAiss", "dais", "xaiss", "caiss", "cai", "baiss", "baas", "haiss", "xaish", "BAis", "daiss", "BAas", "BAi", "haas", "xais", "xai", "hai", "cais", "bai", "hais", "baish", "caish", "BAish", "dai", "daas"], "bis": ["ses", "ios", "bs", "bps", "ii", "ois", "cus", "bin", "uds", "abi", "ubis", "series", "di", "abs", "ais", "slice", "dies", "ri", "boot", "bos", "bi", "fs", "isin", "gb", "pins", "vs", "onis", "iss", "cos", "alis", "sin", "mis", "lis", "nis", "nas", "esi", "tis", "bus", "rb", "lins", "las", "ris", "phis"], "gis": ["gris", " gids", "cfgis", "jios", "jist", "gids", "jis", "giss", "Giss", "jos", "gos", "ghios", "bios", "ghist", "bos", " giss", "ghos", "cfgris", "Gris", "ghis", "gist", " gris", "gios", "cfgids", "Gids", "cfgiss", "Gis", "bist"], "sb": ["ib", "mb", " eb", "usb", "erb", "sth", "nb", "bs", "B", "bps", "pb", "sm", "sf", "dB", "src", "stab", "bg", "obb", "bp", "SB", "eb", "orb", "xb", "abb", "lb", "gb", "rob", "bc", "lp", "zb", " SB", "kb", "BB", "cb", "ssl", "bb", "sg", "b", "bf", "fb", "buffer", "wb", "ab", "bm", "rb", "db", "sq"], "zipReader": ["archiveReader", " zipperRunner", "Zipreader", " zipperRead", "gzWriter", "ZipParser", " zipParser", "archiveWriter", "archiveParser", " zipWriter", "gzRead", " zipreader", " zipperWriter", "zipParser", "archivereader", "ZipWriter", "zipreader", " zipRunner", "zipRead", " zipRead", "gzReader", "zipRunner", "ZipReader", " zipperReader", "zipWriter", "gzRunner"], "chars": ["quapters", "characters", " Ch\n", "chacters", "Chars", "Chaks", "charans", "chashes", "clars", "charars", "Ch\n", "cheacters", "charts", "Chans", "quaks", "charapters", "shapes", "Charts", "chararts", "chans", "clacters", "shars", "cheashes", "clarts", " chapters", "clashes", "chears", "shacters", "quarts", "chapters", " charts", "ch\n", " ch\n", "chapes", " chans", "Chapters", "charapes", "quars", " chacters", "chaks", "sharts", " chapes", "charashes", " chaks", "chearts"], "len": ["span", "lt", "n", "fin", "dl", "ann", "ler", "le", "fun", "Len", "ll", "la", "num", "length", "min", "seq", "lit", "count", "ie", "err", "rel", "cl", "l", "part", "pos", "lin", "del", "all", "ls", "size", "sl", "f", "li", "lim", "ind", "el", "split", "led", "val", "nt", "data", "elt", "fl", "hl", "en", "lf", "rev", "lon", "id", "ln", "lc", "end"]}}
{"id1": "6742637", "id2": "22752444", "code1": "    private static List<Properties> findExtensions() {\n        URL url = null;\n        try {\n            List<Properties> extensions = new ArrayList<Properties>();\n            Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\");\n            while (res.hasMoreElements()) {\n                url = res.nextElement();\n                Properties prop = new Properties();\n                prop.load(url.openStream());\n                extensions.add(prop);\n            }\n            return extensions;\n        } catch (IOException ioe) {\n            String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm();\n            throw new RuntimeException(msg, ioe);\n        }\n    }\n", "code2": "    public synchronized String encrypt(String plainText) {\n        String hash = null;\n        try {\n            MessageDigest md = null;\n            try {\n                md = MessageDigest.getInstance(\"SHA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new NoSuchAlgorithmException();\n            }\n            try {\n                if (plainText != null) md.update(plainText.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new UnsupportedEncodingException();\n            }\n            byte raw[] = md.digest();\n            hash = (new BASE64Encoder()).encode(raw);\n        } catch (NoSuchAlgorithmException e) {\n            MessageLog.writeErrorMessage(e, this);\n        } catch (UnsupportedEncodingException e) {\n            MessageLog.writeErrorMessage(e, this);\n        }\n        return Util.stripChars(hash);\n    }\n", "label": 0, "substitutes": {"findExtensions": ["findAppensions", "findAppension", "getextension", "getextensions", "findExtension", "findExtends", "getextends", "findDistends", "findextension", "getExtends", "findAppends", "findextends", "getExtensions", "getExtension", "findDistension", "findextensions", "findDistensions"], "url": ["resource", "il", "entry", "ch", "fr", "pull", "ver", "zip", "http", "service", "src", "URL", "path", "log", "ur", "api", "org", "io", "feed", "gl", "Url", "rl", "impl", "address", "bel", "bug", "loc", "lr", "err", "rel", "cl", "l", "connection", "base", "rc", "element", "ls", "server", "location", "load", "coll", "config", "sl", "f", "link", "ul", "image", "remote", "page", "result", "ssl", "html", "bb", "data", "r", "id", "web", "uri", "source", "buffer", "re", "name", "file"], "extensions": ["fends", "intends", "intension", "extencies", "fensions", "exps", "xtps", "xtensions", "exras", "exension", "exensions", "Extensions", "Extencies", "xtension", "exencies", "exends", "appencies", "extras", "fension", "extension", "intensions", "intps", "appensions", "xtends", "Extension", "Extras", "fps", "appras", "extps", "appension"], "res": ["resource", "rss", "rus", "ch", "js", "pres", "rest", "rez", "rh", "ex", "results", "http", "request", "is", "Rs", "response", "os", "details", "mr", "gr", "ret", "err", "resp", "Res", "rc", "out", "rex", "RES", "ries", "RE", "rem", "vers", "ros", "resolution", "result", "vals", "hr", "raw", "rr", "req", "r", "ps", "RS", "ras", "rev", "es", "rs", "ver", "re", "ris", "fr", "ress", "rows"], "prop": ["property", "resource", "mp", "class", "project", "pr", "op", "pb", "opt", "option", "exp", "priv", "api", "key", "pac", "attr", "properties", "lit", "def", "p", "proc", "app", "part", "base", "pos", "cp", "j", "tmp", "config", "f", "comp", "feature", "val", "fp", "ext", "result", "Prop", "data", "term", "obj", "feat", "style", "b", "fb", "point", "ps", "info", "pro", "ref"], "msg": ["mb", "mg", "status", "ug", "ms", "g", "string", "cfg", "m", "urg", "ko", "str", "title", "gs", "log", "bg", "agg", "printf", "me", "gr", "eg", "loc", "err", "db", "s", "tag", "cmd", "mn", "mag", "rag", "Msg", "gm", "format", "ext", "error", "kg", "sg", "req", "bf", "comm", "message", "info", "mt", "og", "text", "mid", "reason"]}}
{"id1": "11716816", "id2": "7122523", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request);\n        if (delegate == null) {\n            ActionErrors errors = new ActionErrors();\n            errors.add(null, new ActionError(\"errors.session\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"fail\");\n        }\n        AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla();\n        TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion();\n        String urlSonido = traAyudaPantalla.getUrlSonido();\n        if (urlSonido == null) {\n            return null;\n        }\n        URL url = new URL(urlSonido);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.connect();\n        String tipoMime = urlConnection.getContentType();\n        log.debug(\"Tipo Mime: \" + tipoMime);\n        Map audioOptions = new HashMap();\n        if (tipoMime.indexOf(\"audio\") != -1 || tipoMime.indexOf(\"asf\") != -1 || tipoMime.equals(\"unknown/unknown\")) {\n            audioOptions.put(\"id\", \"MediaPlayer\");\n            audioOptions.put(\"codeBase\", \"http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,7,1112\");\n            audioOptions.put(\"classId\", \"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\");\n            audioOptions.put(\"mimeType\", \"application/x-mplayer2\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/\");\n        } else if (tipoMime.indexOf(\"real\") != -1) {\n            audioOptions.put(\"id\", \"RVOCX\");\n            audioOptions.put(\"codeBase\", \"\");\n            audioOptions.put(\"classId\", \"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\");\n            audioOptions.put(\"mimeType\", \"audio/x-pn-realaudio-plugin\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"\");\n        }\n        request.setAttribute(\"audioOptions\", audioOptions);\n        log.debug(\"entra success\");\n        return mapping.findForward(\"success\");\n    }\n", "label": 0, "substitutes": {"updateFile": ["copyFile", "copyFolder", "upFolder", "upDirectory", "upFile", "importFolder", "updateDirectory", "updateFolder", "copyDirectory", "importBody", "upBody", "importFile", "copyBody", "updateBody", "importDirectory"], "file": ["get", "image", "db", "full", "files", "up", "class", "queue", "object", "socket", "load", "input", "future", "e", "parent", "handler", "File", "cache", "info", "connection", "content", "http", "path", "resource", "fp", "single", "io", "line", "FILE", "part", "dir", "f", "url", "this", "base", "model", "zip", "data", "type", "pe", "log", "b", "local", "name", "l", "lock", "current", "source", "filename"], "IOException": ["TimeoutProblem", "Downloadception", " IOProblem", "TimeoutException", "Timeoutception", "IOception", "DownloadException", "DownloadProblem", "IOProblem", " IOception"], "destFile": ["srcFiles", " destFull", " destPath", "destroyfile", "destroyTable", " destDir", "DestFile", "destroyDir", "sourceFiles", " destinationFull", "origTable", "destDir", "Destfile", "destFolder", "destfile", "destFiles", "flatfile", "sourceFolder", "sourceFile", "srcFile", "srcFolder", "DestPath", "DestFolder", " destfile", "origfile", " destinationFile", "destPath", " destTable", "origDir", "destFull", "DestDir", "destTable", "sourceDir", " destinationDir", "DestFiles", "flatDir", "origFile", "destroyFile", "flatFile", "flatFiles", " destFolder", "DestFull", " destFiles", " destinationFiles", "srcPath"], "in": ["r", "image", "client", "p", "pin", "sync", "inn", "gin", "isin", "i", "socket", "s", "init", "cin", "el", "input", "on", "id", "cf", "din", "conn", "ax", "connection", "a", "inner", "io", "pull", "nin", "con", "ini", "work", "inside", "min", "f", "this", "pass", "login", "err", "with", "b", "cl", "ins", "bin", "In", "l", "reader", "IN", "again", "as", "c", "lock", "re", "win", "source", "up", "ac", "inc"], "out": ["Out", "timeout", "client", "writer", "sync", "obj", "off", "n", "i", "output", "socket", "ou", "user", "ex", "option", "outside", "to", "conn", "cookie", "connection", "exp", "ext", "resource", "io", "nin", "at", "of", "url", "o", "no", "exec", "channel", "this", "pass", "lib", "err", "login", "b", "w", "net", "call", "name", "co", "bin", "In", "password", "OUT", "again", "point", "outs", "extra", "outer", "up", "c", "inc"]}}
{"id1": "16232202", "id2": "11865906", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "code2": "    @Test\n    public void testIdentification() {\n        try {\n            String username = \"muchu\";\n            String password = \"123\";\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(password.getBytes());\n            LogService logServiceMock = EasyMock.createMock(LogService.class);\n            DbService dbServiceMock = EasyMock.createMock(DbService.class);\n            userServ.setDbServ(dbServiceMock);\n            userServ.setLogger(logServiceMock);\n            logServiceMock.info(DbUserServiceImpl.class, \">>>identification \" + username + \"<<<\");\n            IFeelerUser user = new FeelerUserImpl();\n            user.setUsername(username);\n            user.setPassword(new String(md5.digest()));\n            EasyMock.expect(dbServiceMock.queryFeelerUser(username)).andReturn(user);\n            EasyMock.replay(logServiceMock, dbServiceMock);\n            Assert.assertTrue(userServ.identification(username, password));\n            EasyMock.verify(logServiceMock, dbServiceMock);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"doPost": ["doPOST", " doPut", "doSend", "doingPost", "didSend", "didPut", "doPut", "doingPOST", " doPOST", "doingSend", "doingPut", "didPost", "didPOST", " doSend"], "request": ["reader", "save", "er", "data", "current", "get", "self", "q", "error", "session", "complete", "QUEST", "method", "type", "press", "create", "remote", "info", "application", "web", "state", "event", "load", "xml", "req", "page", "register", "user", "rf", "instance", "query", "e", "client", "subject", "external", "list", "condition", "row", "parse", "image", "select", "child", "submit", "parent", "object", "project", "order", "next", "Request", "url", "enter", "context", "view", "server", "hello", "post", "route", "rate", "store", "message", "upload", "result", "input", "resource", "initial", "queue", "join", "report", "you", "re", "use"], "response": ["fire", "su", "tree", "ception", "pool", "error", "session", "respond", "complete", "body", "application", "web", "ae", "en", "Response", "status", "model", "page", "output", "writer", "shell", "query", "e", "subject", "reply", "service", "we", "image", "wa", "feed", "api", "parent", "environment", "object", "next", "exit", "document", "view", "server", "uri", "http", " Response", "index", "message", "result", "resource", "res", "report", "onse", "forward", "re", "esi", "serv", "de", "resp", "site"], "cu": ["ul", "cur", "su", "aca", "loc", "CU", "cum", "uu", "cca", "ca", "cin", "ru", "rc", "lc", "cci", "u", "agu", "U", "asu", "usa", "lu", "Cu", "cli", "ci", "cc", "vc", "uc", "cf", "ucc", "xc", "ku", "ue", "ui", "UC", "du", "uci", "c", "eu", "ce", "VC", "hu", "chu", "co", "tc", "cul", "coll", "ou", "mc", "CA", "cy", "CI", "ac", "uni", "cus", "nu", "tu", "gu"], "ud": ["UD", "df", "su", "vd", "util", "ub", "udi", "gb", "uu", "ur", "dd", "ut", "da", "ck", "ru", "pub", "utils", "rc", "ug", "wik", "usc", "u", "user", "bug", "asu", "usa", "um", "lu", "uli", "cli", "ci", "storage", "db", "ada", "uc", "ku", "uds", "uda", "ui", "ue", "li", "uri", "du", "uv", "eu", "au", "chu", "upload", "uf", "uid", "ou", "us", "usr", "pd", "auth", "ad", "od", "stri", "cus", "tu", "gu"], "returnTo": ["replyto", "replyTO", "returnTO", "exitTo", "outputto", "replyTo", "outputTO", "outputTo", "ReturnTo", "accessFrom", "returnto", "exitFrom", "ReturnTO", "accessTo", "backTO", "returnFrom", "Returnto", "backTo", "accessTO", "backto", "replyFrom", "accessto", "outputFrom", "exitTO", "exitto", "backFrom", "ReturnFrom"], "password": ["wallet", "login", "data", "name", "email", "wd", "encrypted", "user", "Password", "mac", "mask", "account", "key", "patch", "address", "secret", "crypt", "padding", "sword", "phrase", "PASS", "sum", "ass", "code", "null", "params", "word", "pa", "message", "sha", "token", "diff", "pad", "auth", "pg", "string", "confirmed", "username"], "md": [" Md", "meta", "df", "bd", "vd", "f", "mag", "mg", "cd", "rm", "wd", "mad", "dd", "m", "ma", " MD", "mt", "dig", "mb", "am", "mac", "managed", "cmd", "dm", "mn", "sm", "d", "dc", "MD", "db", "mo", "amd", "mp", "rpm", "mm", "sha", "diff", "mc", "ms", "od", "mand", "hd", "pg"], "hash": ["rh", "tag", "hed", "version", "char", "array", "hex", "base", "dig", "cache", "user", "mac", "her", "kh", "dot", "key", "secret", "row", "block", "db", "h", "confirmed", "url", "no", "sum", "ass", "number", "code", "raw", "sha", "ash", "diff", "total", "ref", "auth", "Hash", "sh"], "pass": ["sl", "login", " Pass", "wd", " passed", " def", " mac", "gen", "Pass", "az", "conn", "user", "text", "conf", "mess", " login", "mac", "r", "key", "secret", "row", "db", "ask", " secret", "phrase", "PASS", "sum", "ass", "sign", " auth", "id", "pos", "pa", " mess", "ss", "fail", "diff", "def", "ref", "auth", "push", "string", "strip", "act"], "vis": ["VIS", "su", "qa", "keep", "name", "fac", "tri", "type", "press", "na", "state", "ex", "mit", "miss", "lab", "class", "status", "san", "feat", "nav", "nat", "vest", "vert", "Vis", "acc", "travel", "shape", "vid", "att", "see", "circ", "design", "secret", "dc", "style", "mis", "wa", "spot", "nic", "cross", "sign", "view", "ravis", "c", "act", "id", "stat", "lit", "coll", "virt", "host", "ref", "exp", "visible", "skip", "access", "ip", "rib", "gu"]}}
{"id1": "20310134", "id2": "8932510", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyChannel", "copyFiles", "copyfile", "transferChannel", "transferFile", " copyChannel", "transferFiles", "CopyChannel", "CopyFile", "Copyfile"], "in": ["image", "m", "buffer", "ic", "query", "inn", "i", "input", "id", "ex", "diff", "lin", "inner", "index", "io", "work", "file", "min", "url", "base", "login", "data", "ins", "name", "bin", "In", "l", "reader", "IN", "as", "again", "lock", "source", "config", "c", "inc"], "out": ["Out", "plain", "image", "writer", "p", "n", "off", "output", "default", "user", "write", "ex", "page", "server", "cache", "conn", "connection", "ext", "resource", "io", "img", "file", "x", "dot", "o", "prefix", "exec", "base", "b", "v", "w", "call", "name", "again", "string", "point", "outs", "external", "OUT", "c"], "inChannel": ["outStream", "insStream", "InQueue", "inputChannel", "InGate", "inchannel", " inchannel", "INStream", "iniChannel", "INChan", "outchannel", "loginchannel", "outChan", "binChannel", " inChan", "iniStream", "inQueue", "iniGate", "InStream", "inputConnection", "binchannel", "INChannel", "InChan", "inputChan", "inChan", "binChan", "loginChan", "outQueue", "InChannel", "inConnection", "loginChannel", "Inchannel", "insChan", "inGate", "INchannel", " inQueue", "INConnection", "loginStream", "binGate", "insConnection", "insChannel", "iniChan", "inputStream", "binStream", "inStream"], "outChannel": ["outGate", "outStream", " outchannel", "inchannel", " outGate", "netStream", "OutChan", "outchannel", "outChan", "OutChannel", "outputChan", "outputStream", "OutConnection", " outChar", "outputchannel", "ouGate", " outChan", "outputChannel", " outConnection", " outStream", "Outchannel", "ouChan", "outChar", "inChan", "outConnection", "inConnection", "netChan", "ouChannel", "inGate", "outputChar", "netChannel", "inChar", "ouchannel", "netGate", "outputGate", "inStream"]}}
{"id1": "344764", "id2": "19251426", "code1": "    static HttpURLConnection connect(String url, String method, String contentType, String content, int timeoutMillis) throws ProtocolException, IOException, MalformedURLException, UnsupportedEncodingException {\n        HttpURLConnection conn = (HttpURLConnection) (new URL(url).openConnection());\n        conn.setRequestMethod(method);\n        conn.setConnectTimeout(timeoutMillis);\n        byte[] bContent = null;\n        if (content != null && content.length() > 0) {\n            conn.setDoOutput(true);\n            conn.setRequestProperty(\"Content-Type\", contentType);\n            bContent = content.getBytes(\"UTF-8\");\n            conn.setFixedLengthStreamingMode(bContent.length);\n        }\n        conn.connect();\n        if (bContent != null) {\n            OutputStream os = conn.getOutputStream();\n            os.write(bContent);\n            os.flush();\n            os.close();\n        }\n        return conn;\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 0, "substitutes": {"connect": ["remote", "close", "input", "output", "add", "con", "connected", "socket", "find", "run", "Connect", "write", "read", "client", "select", " Connect", "sync", "construct", "load", "connection", "login", "build", "open", "config", "bind", "request", "get", "log", "init", "complete", "start", "exec", "send", "call", "update", "create", "sign", "process", "download"], "url": ["remote", "path", "address", "ssl", "base", "string", "server", "uri", "resource", "user", "http", "l", "host", "location", "URL", "client", "email", "source", "proxy", "q", "connection", "file", "route", "web", "page", "href", "name", "image", "full", "sl", "Url", "www", "b", "f", "this", "download", "loc"], "method": ["path", "class", "resource", "direction", "subject", "message", "version", "end", "mode", "host", "length", "manager", "Method", "time", "sort", "METHOD", "post", "type", "session", "use", "operation", "text", "attr", "request", "format", "verb", "header", "status", "send", "function", "call", "position", "this", "sign", "process", "cmd", "module", "property", "loc"], "contentType": ["contentLength", "ContentType", " contenttype", "resourceName", "ContentClass", "ContentLength", "mediaClass", "resourceType", "resourcetype", "Contenttype", " contentLength", "contentClass", "mediaLength", "contentName", " contentClass", "contenttype", "mediaType", " contentName", "resourceLength", "ContentName", "mediaName"], "content": ["string", "path", "address", "buffer", "temp", "input", "server", "output", "resource", "response", "accept", "enc", "results", "message", "sequence", "version", "cont", "current", "document", "result", "host", "condition", "password", "Content", "raw", "client", "source", "load", "cache", "value", "connection", "media", "model", "config", "data", "text", "file", "body", "parent", "page", "empty", "object", "request", "size", "format", "header", "exec", "image", "ext", "create", "comment", "script", "code"], "timeoutMillis": ["timeoutMi", "timeoutMinus", "timeoutMilli", "TimeoutMini", "timeoutMIS", "TimeoutMinus", "TimeoutMinIS", "TimeoutMinis", "timeoutMinix", "timeoutmillis", "timeoutMilIS", "timeoutmillus", "timeoutMilix", "TimeoutMilus", "TimeoutMillIS", "timeoutMis", "timeoutMillix", "TimeoutMilix", "TimeoutMili", "timeoutMilis", "timeoutMillIS", "TimeoutMillix", "timeoutMini", "timeoutmilli", "timeoutMinIS", "timeoutMillus", "TimeoutMillus", "timeoutMilus", "timeoutMus", "timeoutMili", "timeoutMinis", "TimeoutMillis", "timeoutmillix", "TimeoutMilis", "TimeoutMilli"], "conn": ["Connection", "close", "ssl", "core", "Conn", "cc", "n", "cmp", "cf", "enc", "rc", "http", "ns", "con", "c", "oa", "act", "pub", "cb", "ctrl", "col", "fn", "fp", "co", "dc", "nc", "ec", "client", "sync", "nt", "cm", "cp", "uc", "ct", "connection", "ch", "cat", "open", "conv", "config", "ca", "init", "coll", "ci", "exec", "oss", "ann", "cr", "jp", "pc", "mc", "ctx", "comm", "auth", "conf", "obj", "cn", "cs", "cli", "cmd", "cur", "pg", "org", "api"], "bContent": ["lBody", "BCopy", " bcontent", "rContent", "oValue", "lbValue", "oContent", "iContent", "bBody", "bContents", "lbContent", " bMessage", "oContents", "bMessage", " bContents", "vCopy", "vContent", "ocontent", "rbContent", "sbCopy", "rebMessage", "sbContent", "rbWork", "lbcontent", "rebContent", "lbContents", "Bcontent", "bValue", " bCopy", "rContents", "lMessage", "bWork", "bCopy", " bCode", "sbWork", "icontent", "iContents", "rBody", "sbcontent", "vcontent", "rbCopy", "BCode", "rebContents", "rcontent", "bCode", "bcontent", " bWork", "iBody", "rbcontent", "rebBody", "lContent", "BContent", " bValue", "lContents", "vCode", " bBody"], "os": ["bis", "ou", "i", "oses", "fs", "Os", "acs", "op", "opens", "http", "gets", "ns", "oa", "c", "et", "ks", "dos", "OS", "o", "outs", "s", "bs", "is", "oos", "ms", "ros", "bos", "ops", "nos", "ob", "ens", "out", "object", "ips", "p", "es", "des", "or", "vs", "aos", "obs", "oss", "io", "ot", "pos", "ios", "us", "obj", "ds", "los", "osi", "cos"]}}
{"id1": "9267602", "id2": "18164929", "code1": "    public static void main(String[] args) throws IOException {\n        String urltext = \"http://www.vogella.de\";\n        URL url = new URL(urltext);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        while ((inputLine = in.readLine()) != null) {\n            System.out.println(inputLine);\n        }\n        in.close();\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"urltext": ["urlbr", "URLobject", "urlobject", "urlTEXT", "feedbr", "filebr", "urlfeed", "lltext", "llTEXT", "filename", "URLTEXT", " urlbr", "urlname", "feedtext", " urlobject", "feedname", " urlname", "URLtext", "feedfeed", "llobject", "filefeed", " urlTEXT", " urlfeed", "filetext"], "url": ["image", "log", "URL", "base", "resource", "service", "feed", "this", "Url", "ball", "open", "ref", "http", "zip", "queue", "l", "b", "page", "string", "r", "bel", "buffer", "db", "uri", "plug", "out", "blog", "name", "socket", "ssl", "server", "id", "file", "data", "user", "sl", "i", "lib", "connection", "jar", "source", "web", "f", "address"], "in": ["ini", "kin", "err", "login", "stream", "gin", "inn", "inner", "input", "In", "inc", "cms", "l", "bin", "b", "read", "r", "IN", "buffer", "source", "line", "nin", "min", "out", "client", "ins", "is", "into", "as", "loader", "init", "ssl", "inside", "data", "file", "id", "isin", "reader", "i", "din", "f", "lin", "s"], "inputLine": ["InputLine", "outputBlock", "execData", "InputByte", "outputL", "Inputline", "outputByte", "inputData", "execline", "inputStream", " inputStream", " inputByte", "outputline", " inputL", "inputByte", " inputData", "InputBlock", "inputline", "InputL", "execLine", "rawL", "outputLine", "inputString", " inputline", "inputL", " inputBlock", "rawLine", "inputBlock", "rawString", "outputStream", "InputString", "outputData", "rawline", " inputString", "execStream"]}}
{"id1": "13886238", "id2": "4461350", "code1": "    public void init() throws GateException {\n        if (reportFile == null) throw new GateException(\"No report file set!\");\n        boolean restarting = false;\n        if (!reportFile.getParentFile().exists() && !reportFile.getParentFile().mkdirs()) {\n            throw new GateException(\"Could not create directories for \" + reportFile.getAbsolutePath());\n        }\n        File backupFile = new File(reportFile.getAbsolutePath() + \".bak\");\n        if (reportFile.exists()) {\n            restarting = true;\n            logger.info(\"Existing report file found at \\\"\" + reportFile.getAbsolutePath() + \"\\\", attempting to restart\");\n            if (!reportFile.renameTo(backupFile)) {\n                try {\n                    byte[] buff = new byte[32 * 1024];\n                    InputStream in = new BufferedInputStream(new FileInputStream(reportFile));\n                    try {\n                        OutputStream out = new BufferedOutputStream(new FileOutputStream(backupFile));\n                        try {\n                            int read = in.read(buff);\n                            while (read != -1) {\n                                out.write(buff, 0, read);\n                                read = in.read(buff);\n                            }\n                        } finally {\n                            out.close();\n                        }\n                    } finally {\n                        in.close();\n                    }\n                } catch (IOException e) {\n                    throw new GateException(\"Could not restart batch\", e);\n                }\n            }\n        }\n        try {\n            reportWriter = staxOutputFactory.createXMLStreamWriter(new BufferedOutputStream(new FileOutputStream(reportFile)));\n            reportWriter.writeStartDocument();\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.setDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"cloudReport\");\n            reportWriter.writeDefaultNamespace(Tools.REPORT_NAMESPACE);\n            reportWriter.writeCharacters(\"\\n\");\n            reportWriter.writeStartElement(Tools.REPORT_NAMESPACE, \"documents\");\n        } catch (XMLStreamException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        } catch (IOException e) {\n            throw new GateException(\"Cannot write to the report file!\", e);\n        }\n        if (restarting) {\n            try {\n                Set<String> completedDocuments = new HashSet<String>();\n                logger.debug(\"Processing existing report file\");\n                InputStream bakIn = new BufferedInputStream(new FileInputStream(backupFile));\n                XMLEventReader xer = staxInputFactory.createXMLEventReader(bakIn);\n                try {\n                    XMLEvent event;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                    List<XMLEvent> events = new LinkedList<XMLEvent>();\n                    String currentReturnCode = null;\n                    String currentDocid = null;\n                    while (xer.hasNext()) {\n                        event = xer.nextEvent();\n                        events.add(event);\n                        if (event.isStartElement() && event.asStartElement().getName().getLocalPart().equals(\"processResult\")) {\n                            currentReturnCode = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"returnCode\")).getValue();\n                            currentDocid = event.asStartElement().getAttributeByName(new QName(XMLConstants.NULL_NS_URI, \"id\")).getValue();\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"processResult\")) {\n                            if (currentReturnCode.equals(\"SUCCESS\") && currentDocid != null) {\n                                completedDocuments.add(currentDocid);\n                                for (XMLEvent evt : events) {\n                                    Tools.writeStaxEvent(evt, reportWriter);\n                                }\n                            }\n                            events.clear();\n                            currentReturnCode = null;\n                            currentDocid = null;\n                        }\n                        if (event.isEndElement() && event.asEndElement().getName().getLocalPart().equals(\"documents\")) {\n                            break;\n                        }\n                    }\n                } catch (Exception e) {\n                    logger.debug(\"Exception while parsing old report file - probably \" + \"reached the end of old report\", e);\n                } finally {\n                    xer.close();\n                    bakIn.close();\n                    backupFile.delete();\n                }\n                List<String> unprocessedDocs = new ArrayList<String>();\n                unprocessedDocs.addAll(Arrays.asList(documentIDs));\n                unprocessedDocs.removeAll(completedDocuments);\n                unprocessedDocumentIDs = unprocessedDocs.toArray(new String[unprocessedDocs.size()]);\n            } catch (XMLStreamException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            } catch (IOException e) {\n                throw new GateException(\"Cannot write to the report file!\", e);\n            }\n        } else {\n            unprocessedDocumentIDs = documentIDs;\n        }\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 0, "substitutes": {"init": ["rest", "info", "setup", "reset", " reload", "activate", "construct", "load", "art", "build", "open", "strap", "config", "check", "launch", " Init", "destruct", "initialized", "test", "start", "it", "update", "parse", " discover", "Init", "error"], "backupFile": ["backupsFile", "backrapFiles", "backupFILE", "backrapDir", "backrapFile", "BackupStream", "BackdownStream", "lookupfile", "backacyFILE", "backupDir", "backupStream", "lookupFILE", "backbookF", "backoutFolder", "backupsDir", "lookoutFILE", "lookupFile", "backupfile", "BackupSourceFile", "backUPStream", "lookoutFile", "BackupDir", "BackureFile", "backupFiles", "backoutFILE", "backupsSourceFile", "BackureFiles", "backbackFolder", "backUPF", "backbookStream", "backureFile", "backureDir", "BackdownF", "backbookFile", "backupsFiles", "backUPFiles", "backupSourceFile", "backdownFile", "BackdownFile", "backbackfile", "backureSourceFile", "backupF", "lookoutFolder", "backdownFiles", "BackupFiles", "backrapSourceFile", "backoutFile", "backacyFolder", "lookupFolder", "BackdownFiles", "backUPFile", "backacyfile", "BackupFile", "backbackFILE", "BackureSourceFile", "BackupF", "backbackFile", "backureFiles", "lookoutfile", "backdownF", "backdownStream", "backupFolder", "backoutfile", "backbookFiles", "backacyFile", "BackureDir"], "buff": ["zip", "uff", "buffer", "fe", "bf", "feed", "oct", "now", "slice", "cb", "grab", "length", "gg", "ff", "ffff", "pb", "char", "uf", "bg", "txt", "gb", "comp", "mb", "utf", "cp", "rb", "comb", "load", "pp", "sb", "back", "buf", "cond", "ch", "ob", "build", "bind", "fb", "cast", "bb", "gz", "font", "Buff", "flush", "app", "shape", "comment", "b", "bound", "ph", "fab", "cod", "pad", "cmd", "boot"], "in": ["IN", "pin", "ssl", "i", "input", "id", "n", "serv", "ini", "gin", "con", "c", "inner", "socket", "slice", "l", "ins", "s", "el", "bin", "pass", "part", "reader", "up", "login", "min", "diff", "connection", "r", "inside", "old", "inc", "data", "get", "or", "again", "e", "exec", "image", "isin", "In", "nin", "url", "stream", "lin", "b", "ac", "cin", "inn", "f", "win", "din"], "out": ["IN", "ex", "output", "copy", "n", "serv", "user", "net", "OUT", "inner", "socket", "o", "outs", "ins", "line", "co", "bin", "pass", "client", "sync", "part", "one", "reader", "doc", "lib", "up", "inc", "file", "gen", "conn", "again", "exec", "Out", "io", "writer", "exp", "ax", "prefix", "ext", "conf", "err", "b", "win"], "read": ["index", "roll", "max", "Read", "run", "ride", "en", "raw", "build", "open", "get", "row", "lex", "readable", "buffer", "id", "feed", "lock", "add", "ind", "end", "find", "next", "sync", "use", "load", "r", "work", "level", "ip", "search", "fill", "exec", "skip", "reach", "b", "connect", "play", "close", "i", "n", "reading", "ok", "se", "length", "write", "ad", "sleep", "iter", "reader", "d", " Read", "bind", "start", "wait", "ink", "view", "input", "copy", "current", "child", "reads", "pass", "last", "select", "ask", "seek", "data", "text", "check", "x", "size", "log", "send", "k", "parse", "count", "READ", "block"], "reportWriter": [" reportReader", "reportHelper", "summaryJournal", "reportReader", "reportedTime", " reportDriver", "commentWrite", "exportJournal", "reportedWriter", "reviewWrite", "ReportWs", "reportWs", "reportWalker", "commentStream", "exportWrite", "resultStream", " reportHelper", "reportedDriver", "summaryWriter", "exportWriter", "ReportWriting", "exportHelper", "ReportReader", "reviewTime", "exportApplication", "reportApplication", " reportWriting", "summaryStream", "reportedReader", "reportedWriting", "exportPublisher", "reviewWriter", " reportWalker", "exportWalker", "commentWriter", " reportPublisher", "reportWrite", " reportTime", "reviewEditor", "reportedWs", "ReportWrite", "reportedEngine", "reportWriting", "resultWriter", "ReportWriter", "reportedHelper", "ReportApplication", " reportWrite", "reportJournal", " reportJournal", "reportTime", "reportedWalker", " reportEngine", "reportEditor", "reportStream", "reportPublisher", "reviewEngine", " reportApplication", "summaryWrite", "reportEngine", "reportedEditor", " reportWs", "resultPage", "summaryPublisher", "resultWrite", "summaryPage", "reviewDriver", " reportEditor", "reportPage", "exportReader", "reportDriver", "reportedWrite", "commentPage"], "restarting": ["restrupted", "restarmING", "restarmed", "restartting", "Restriting", "Restrited", "restarted", "restritating", "restartsing", "Restarting", "restarsing", "restartable", "restartING", "Restritating", "restritING", "Restartting", "Restarted", "RestartING", "restrited", "Restritable", "restriting", "restarsING", "restartsting", "restarmable", "Restartating", "restartating", "restritting", "Restartable", "restruptING", "restartsating", "restruptable", "restarming", "restarsting", "RestritING", "restritable", "restartsING", "restarsating", "Restritting", "restrupting"]}}
{"id1": "1508930", "id2": "19276022", "code1": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 1, "substitutes": {"httpRequestByPOST": ["httpRequestNoPut", "httpRequestWithPOST", "httpRequestAsGET", "httpRequestWithGET", "httpPostWithpost", "httpRequestNoGET", "httpRequestWithpost", "httpPostWithPut", "httpRequestNoPOST", "httpRequestByPut", "httpRequestAsPut", "httpRequestAsPOST", "httpPostBypost", "httpPostByPut", "httpRequestWithPut", "httpPostWithPOST", "httpRequestAspost", "httpPostByGET", "httpRequestNopost", "httpRequestBypost", "httpRequestByGET", "httpPostByPOST", "httpPostWithGET"], "url": ["request", "domain", "email", "html", "queue", "host", "route", "page", "id", "server", "json", "address", "connection", "http", "location", "URL", "resource", "path", "ssl", "date", "file", "str", "Url", "api", "base", "download", "name", "l", "string", "uri", "www", "username"], "timeout": ["blocking", "size", "max", "socket", "delay", "page", "limit", "cache", "cookie", "connection", "time", "URL", "resource", "sleep", "Timeout", "ssl", "out", "until", "token", "wait", "method", "password", "random", "duration", "length"], "params": ["request", "ip", "Par", "details", "words", "query", "attr", "Param", "server", "json", "properties", "ams", "http", "param", "services", "posts", "terms", "resources", "results", "ras", "apps", "options", "Parameters", "relations", "api", "data", "pins", "names", "settings", "password", "prop", "parts", "ps", "list", "source"], "response": ["request", "next", "image", "service", "tree", "full", "output", "reply", "object", "feed", "page", "server", "json", "example", "answer", "more", "result", "connection", "content", "array", "resource", "report", "message", "location", "reason", "Response", "value", "resp", "str", "api", "model", "data", "collection", "status", "application", "res", "site", "respond", "string", "uri"], "httpClient": ["HttpPost", " httpStore", "serverStore", "httpStore", "httpsClient", "httpServer", "HttpClient", "httpContract", "serverContract", "serverPost", "HttpContract", "HttpServer", "serverServer", "httpsContract", "httpsPost", "serverClient", "HttpStore", "httpsServer", " httpServer"], "httpPost": [" httppost", "HttpPost", "httpsPut", "HttpPut", "httpPOST", " httpPOST", "httpAdd", "HttpThread", "HttpDo", "Httppost", " httpThread", "httpRequest", " httpRequest", "htmlPost", "ttpThread", "httpPut", "HttpPOST", "httppost", "htmlDo", "HttpRequest", "httpThread", "httpDo", "httpsAdd", "ttpRequest", "ttpPost", "ttpDo", "httpsPOST", "httpsDo", "htmlPut", " httpAdd", "HttpAdd", "httpsPost", "httpspost", "htmlPOST", " httpDo"], "serverResponse": ["httpResp", "statusResponse", "httpStatus", " serverSession", "statusSession", "statusResp", "erverResp", "httpServer", "erverServer", "ServerClient", " serverResp", "serverResp", "httpSession", "erverClient", "ServerResponse", "statusStatus", "ServerServer", "serverServer", "serverStatus", "serverSession", "ServerResp", " serverStatus", "statusClient", "serverClient", " serverClient", "erverResponse", "httpResponse"], "statusLine": ["resourceLine", "syncLine", "responseEntity", "StatusPass", "httpLine", "progressLine", "statusNode", "syncEntity", "statusPage", "responseLin", "statusL", "statusFile", "StatusLink", "StatusNode", "StatusFile", "httpCode", "responseCode", "statusCode", "resourceL", "syncLin", "errorError", "errorCode", "StatusLine", "contentNode", "responseError", "errorLink", "progressLin", "StatusPage", "serverFile", "StatusCode", "StatusL", "syncCode", "errorLine", "contentFile", "contentLine", "contentPage", "statusError", "serverLine", "responseLine", "responseLink", "resourcePass", "resourceCode", "progressCode", "progressEntity", "serverPage", "statusLink", "statusEntity", "statusPass", "httpL", "httpPass", "StatusError", "serverNode", "statusLin"], "inputStream": ["tempContent", "InputBuffer", "Inputstream", "loadStream", " inputSteam", "tempStreamer", "pullBuffer", "inContent", "loadSteam", " inputStreamer", " inputstream", "InputSteam", " inputContent", "tempSteam", "pullReader", "inReader", "instream", "InputReader", "inputSteam", "InputStream", "inputBuffer", "inputContent", "inStream", "pullStream", "InputContent", "tempStream", "inSteam", "loadContent", "pullSteam", "inBuffer", "loadStreamer", "inputStreamer", "inputstream"], "inputReader": ["outputBuilder", "outputER", "outputStream", "outputStreamer", "readerReader", "requestBuffer", "regularReader", "readerStream", "regularStream", "outputReader", "requestStream", "readerStreamer", " inputBuilder", "inputER", "requestBuilder", "regularStreamer", "inputBuffer", "requestReader", "inputBuilder", " inputBuffer", "outputBuffer", "readerER", "inputStreamer", "regularER"], "bufferedReader": ["buffedStream", " buffaredRead", "buffererContainer", "buffaredRead", "bufferedRead", "bufferedStream", "BufferedWriter", "bufferingReader", "bufferingWriter", "BufferedReader", "bufferingStream", "buffaredContainer", "buffedWriter", "BufferedContainer", "buffedReader", " bufferedRead", "buffererStream", "buffererReader", "bufferingRead", " buffaredReader", "buffererWriter", "bufferedWriter", "buffaredStream", "BufferingStream", " buffaredStream", "bufferingContainer", "BufferedStream", "buffedRead", "bufferedContainer", "BufferingReader", " bufferedStream", "buffaredWriter", "BufferingContainer", " buffaredWriter", "BufferingWriter", " bufferedWriter", "buffaredReader"], "buffer": ["request", "pause", "image", "writer", "queue", "output", "surface", "feed", "bb", "copy", "slave", "page", "Buffer", "limit", "cache", "server", "sb", "source", "result", "array", "fb", "message", "resource", "audio", "buff", "ignore", "report", "ob", "out", "row", "translation", "uffer", "iter", "buf", "binary", "null", "base", "data", "builder", "type", "loader", "b", "bar", "wave", "document", "background", "reader", "string", "header", "loop", "layer"], "line": ["ip", "sl", "lf", "sync", "entry", "block", "i", "key", "cell", "object", "el", "comment", "character", "feed", "parse", "e", "page", "lc", "lines", "Line", "lin", "code", "content", "message", "row", "file", "str", "liner", "iter", "link", "end", "letter", "pass", "base", "unit", "inline", "data", "char", "LINE", "number", "text", "cl", "name", "l", "body", "string", "header", "le", "source", "column"], "lastErrorCode": [" lastErrorName", "lastHeaderMessage", "currentStatusCause", "currentStatusCode", "lastHttpCode", "lastStatusText", "lastErrorInfo", " lastHeaderName", "lastSuccessText", "currentStatusText", "currentStatusMessage", "lastErrorName", " lastHeaderInfo", " lastErrorInfo", "lastSuccessCause", "lastWarningCode", "lastStatusCause", "currentErrorMessage", "lastHeaderCode", "lastHeaderName", "lastStatusMessage", " lastHeaderMessage", "lastSuccessCode", "lastWarningName", "currentErrorCode", "lastHttpCause", "currentErrorCause", "lastWarningMessage", "lastStatusCode", "lastHttpMessage", "lastHeaderInfo", "currentErrorText", "lastErrorText", " lastHeaderCode", "lastStatusName", "lastWarningInfo", "lastStatusInfo", "lastHttpText", "lastErrorCause", "lastSuccessMessage"], "lastErrorMessage": ["lastHeaderMessage", "lastCodeException", "lastErrorSummary", " lastHeaderSummary", "lastHeaderSummary", " lastErrorDetails", "lastWarningSummary", "lastStatusStatus", " lastWarningStatus", "lastCodeSummary", "lastStatusDetails", "lastWarningDetails", "lastWarningCode", "lastHeaderCode", "lastCodeCode", " lastWarningDescription", "lastStatusMessage", "lastStatusDescription", " lastWarningMessage", "lastWarningException", " lastHeaderMessage", " lastHeaderException", "lastWarningStatus", " lastErrorDescription", "lastErrorException", "lastWarningMessage", "lastErrorDescription", "lastWarningDescription", "lastErrorStatus", " lastErrorException", " lastErrorStatus", " lastErrorSummary", " lastHeaderCode", "lastErrorDetails", "lastHeaderException", "lastCodeMessage", " lastWarningDetails"]}}
{"id1": "6418781", "id2": "18433984", "code1": "    public static void main(String[] args) {\n        FTPClient client = new FTPClient();\n        try {\n            client.connect(\"192.168.1.10\");\n            client.login(\"a\", \"123456\");\n            String[] names = client.listNames();\n            for (String name : names) {\n                System.out.println(\"Name = \" + name);\n            }\n            FTPFile[] ftpFiles = client.listFiles();\n            for (FTPFile ftpFile : ftpFiles) {\n                if (ftpFile.getType() == FTPFile.FILE_TYPE) {\n                    System.out.println(\"FTPFile: \" + ftpFile.getName() + \"; \" + FileUtils.byteCountToDisplaySize(ftpFile.getSize()));\n                }\n            }\n            client.logout();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                client.disconnect();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"client": ["console", "image", "parent", "cloud", "socket", "cl", "conn", "class", "cli", "queue", "cache", "pc", "patch", "file", "net", "front", "secure", "quit", "resource", "server", "call", "cp", "connection", "remote", "cell", "cart", "and", "plugin", "i", "builder", "config", "command", "con", "c", "handler", "close", "util", "url", "end", "ci", "out", "api", "co", "web", "hard", "app", "clean", "force", "manager", "http", "open", "p", "ssl", "google", "ce", "project", "session", "connect", "cm", "contact", "Client", "base", "company", "grid", "host", "contract", "request"], "names": ["Names", "keys", "people", "letters", "modules", "users", "ns", "data", "headers", "apps", "terms", "groups", "named", "devices", "objects", "results", "works", "tools", "nets", "files", "resources", "ids", "versions", "ames", "list", "blocks", "ans", "types", "words", "members", "paces", "services", "nam", "strings", "items"], "name": ["NAME", "ame", "e", "one", "parent", "n", "_", "connection", "an", "info", "data", "part", "member", "f", "str", "named", "family", "key", "out", "type", "pass", "action", "api", "Name", "size", "a", "l", "filename", "base", "user", "company", "id", "string", "v", "file", "am", "path", "x", "word", "nam", "common"], "ftpFiles": ["ctfiles", "ftnFiles", "fttpFile", "fttpKeys", "fttpFiles", "ftfKeys", "fdtpFiles", "ftpiles", "fdtpTokens", "ftpTokens", "ftartTokens", "fdtpfiles", "ctfKeys", "ctpFiles", "ftpointFile", "ftartFiles", "ctpFile", "fdpTokens", "ctpKeys", "ftnFile", "ftartfiles", "fttpTokens", "fdpFiles", "ftpKeys", "ftfFiles", "ftpointKeys", "ftnfiles", "ftfiles", "ftpfiles", "ctfFile", "fdpfiles", "fttpiles", "ftfFile", "ctpiles", "ftpointFiles", "fdpFile", "ftnTokens", "ftartFile", "fdtpFile", "fttpfiles", "ctfFiles", "ftpointiles"], "ftpFile": ["lfpfile", "lfpEntry", "ftapDir", "lfpFile", " ftlFiles", "lfapfile", "ftpaBlock", "lflFiles", "flFile", "lfapFile", " ftpBlock", "ftlDirectory", "lfpDir", "ftPFiles", "ftPEntry", "ftlFile", "ftfPath", "ftlFiles", " ftlUrl", "ftapFiles", "lfpPath", "ftPFile", "ftpPath", " ftpUrl", "flDirectory", "ftpEntry", "ftpaEntry", "ftfpFile", "ftpaFile", "lflPath", "ftlPath", "ftPPath", "lfapFiles", "ftpaUrl", "ftpDir", "ftapiDir", "flFiles", "lfpFiles", "fpEntry", " ftlFile", "ftpDirectory", "ftfDir", "ftffile", "ftfpFiles", "ftapFile", "ftlEntry", "ftfFiles", "ftlUrl", "ftapiFiles", "ftpfile", "ftfpUrl", "ftapiFile", "ftfEntry", " ftlBlock", "ftpBlock", "ftapifile", "lflFile", "flEntry", "fpFile", "ftfFile", "lfapDir", "ftpaDirectory", "fpFiles", "ftpUrl", "fpDirectory", "ftfpBlock", "ftapfile", "ftpaFiles", "ftfDirectory", "lflEntry", "ftlBlock"]}}
{"id1": "13012591", "id2": "17111859", "code1": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 1, "substitutes": {"getPasswordHash": ["getPasswordhash", "getHashSum", " getPasswordSum", " getPasswordSecret", "getHashHash", "getPasswordSecret", "getStringhash", "getPasswordSum", "getpasswordHash", " getPasswordhash", " getpasswordHash", "getStringSum", "getStringHash", "getpasswordhash", "getHashSecret", " getpasswordhash", "getpasswordSum", "getpasswordSecret", "getStringSecret", "getHashhash", " getpasswordSum", " getpasswordSecret"], "password": ["pass", "attribute", "token", "username", "words", "sword", "string", "cache", "word", "secret", "input", "Password", "PASS", "path", "key", "number", " passwords", "auth", "database", "email", "wd", "user", "content", "address", "p", "prefix", "phrase", "security", "config", "array", "confirmed", "code", "data", "account", "message", "pattern", "buffer", "crypt", "text", "source", "name", "padding"], "md": ["dc", "mb", "mg", "mp", "pd", "mage", "pm", "ms", "od", "mand", "cm", "mac", "map", "m", "mem", "sm", " MD", "d", "sha", "hm", "MD", "bd", "meta", "alg", "hd", "ad", "dd", "ld", "mc", "amp", "gb", "mod", "cmd", "dh", "dr", "ma", "mag", "pkg", "arm", "gd", "gm", "dm", "material", "nm", "amd", "dig", "mm", "metadata", "vd", "mt", "mu", "bm", "db", "mo"], "hash": ["body", "row", "mask", "bh", "hed", "sh", "mac", "cache", "map", "Hash", "host", "secret", "total", "cover", "sha", "sum", "search", "match", "hex", "key", "number", "ashes", "length", "address", "square", "header", "kh", "build", "count", "batch", "carry", "ha", "url", "query", "ash", "array", "index", "code", "image", "h", "check", "dot", "html", "filter", "handle", "diff", "error", "data", "dig", "message", "block"], "buf": ["bh", "nb", "aux", " buffer", "cas", "pb", "cv", "bin", "src", "conv", "abi", "ctx", "abs", "box", "pad", "cf", "bp", "ab", "book", "br", "bag", "ff", "tmp", "bc", "sb", "Buffer", "f", "array", "af", "pkg", "home", "uf", "cap", "h", "cb", "fp", "v", "bb", "img", "data", "Buff", "b", "fb", "buff", "bf", "buffer", "va", "rb", "db", "ref"], "i": ["hi", "si", "chi", "qi", "ip", "u", "multi", "k", "c", "ii", "m", "pi", "o", "d", "abi", "ci", "di", "io", "vi", "ui", "ji", "ri", "length", "bi", "p", "it", "l", "phi", "s", "j", "I", "eni", "x", "uli", "fi", "index", "f", "field", "e", "oi", "li", "h", "v", "gi", "ti", "data", "ai", "r", "b", "xi", "t", "id", "uri", "mu", "end"]}}
{"id1": "3430784", "id2": "22536033", "code1": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"decodeBody": ["decodesFile", "decodedPart", " decodedFile", "decodeStream", "decodesStream", "decodedFile", " decodedStream", "decodesBody", "decodedStream", "decodeFile", "decodingBody", "decodePart", "decodingFile", "decodingStream", "decodedBody", " decodeFile", " decodePart", "decodingPart", " decodedBody", " decodeStream", "decodesPart", " decodedPart"], "in": ["exec", "serv", "url", "gin", "ins", "din", "reader", "IN", "login", "bin", "id", "isin", "inc", "load", "request", "ini", "input", "session", "In", "conn", "inner", "image", "err", "c", "inas", "read", "m", "i", "connection", "r", "b", "ex", "again", "body", "config", "socket", "loader", "nin", "win", "buffer", "resource", "inn", "version", "min", "it", "content", "get", "is", "into", "cin", "source", "data", "file", "work", "init", "inside", "src", "pass", "con", "ac", "as", "f"], "contentTransferEncoding": ["contentTransferEasing", "contentTransferCaming", "contentRestEnoding", "contentTransferCoding", "contentTransferEcording", "contentRestEncording", "contentRestEncoding", "contentTransferencoding", "contentTransferencitting", "contentPartEncasing", "contentTransferCasing", "contentTransferEndoder", "contentPartEncryption", "contentTransferEngoding", "contentTransferencoder", "contentTransferAcosing", "contentTransferEncoded", "contentTransferencording", "contentTransferEoder", "contentTransferEncording", "contentTransferEoding", "contentPartEoding", "contentTransferEnosing", "contentPartEncoder", "contentRestEnording", "contentTransferCoded", "contentTransferEngasing", "contentTransferCoder", "contentTransferEosing", "contentRestEnoder", "contentTransferEnaming", "contentPartEncoding", "contentTransferEncoder", "contentTransferEnoding", "contentTransferEndoded", "contentTransferEcaming", "contentTransferCearing", "contentTransferEnearing", "contentTransferEnitting", "contentTransferEnording", "contentTransferEndasing", "contentTransferEncaming", "contentTransferEryption", "contentTransferEcoding", "contentTransferEncasing", "contentTransferEngoded", "contentTransferEnasing", "contentTransferAcasing", "contentPartEasing", "contentRestEncoder", "contentRestEncaming", "contentTransferEnoded", "contentTransferEcitting", "contentTransferEncryption", "contentTransferAcoder", "contentTransferEnoder", "contentTransferCording", "contentRestEnaming", "contentTransferEncitting", "contentTransferEngearing", "contentTransferEncearing", "contentPartEoder", "contentPartEryption", "contentTransferEndoding", "contentTransferCryption", "contentTransferEnryption", "contentTransferAcoding", "contentTransferEncosing", "contentTransferEcoder"], "tempBody": ["outputbody", "tmpBody", "TempBody", "TempFile", "tempLife", "outputBody", "tmpFile", "tempFile", "tempCore", "TempCore", "tmpCore", " tempbody", "Tempbody", "tmpLife", "tmpbody", "tempbody", "outputLife", " tempCore", " tempLife", "outputFile", " tempFile"], "out": ["exec", "base", "OUT", "client", "outs", "cache", "output", "bin", "app", "io", "raw", "path", "conn", "obj", "ext", "inner", "err", "c", "off", "this", "Out", "extra", "writer", "connection", "a", "i", "user", "ex", "object", "body", "null", "o", "again", "parent", "socket", "sync", "resource", "copy", "line", "data", "page", "file", "source", "channel", "init", "pool", "temp"]}}
{"id1": "6009527", "id2": "12039034", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    public static ArrayList<RoleName> importRoles(String urlString) {\n        ArrayList<RoleName> results = new ArrayList<RoleName>();\n        try {\n            URL url = new URL(urlString);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            StringBuffer buff = new StringBuffer();\n            String line;\n            while ((line = in.readLine()) != null) {\n                buff.append(line);\n                if (line.equals(\"</RoleName>\")) {\n                    RoleName name = ProfileParser.parseRoleName(buff.toString());\n                    results.add(name);\n                    buff = new StringBuffer();\n                } else {\n                    buff.append(NL);\n                }\n            }\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        } catch (ParsingException e) {\n        }\n        return results;\n    }\n", "label": 0, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadInstment", "doFinishloadAttments", "doFinishLoadInstortion", "doFinishloadAttachortion", "doFinishLoadInstachment", "doFinishLoadAttachortion", "doFinishloadAttachachment", "doFinishLoadAssment", "doFinishLoadAssachment", "doFinishLoadInstments", "doFinishloadAttachment", "doFinishLoadAssments", "doFinishLoadAttachachment", "doFinishLoadAttment", "doFinishLoadAttments", "doFinishloadAttment", "doFinishloadAttachments", "doFinishLoadAttachments", "doFinishloadAttortion", "doFinishLoadAttortion", "doFinishLoadAssortion"], "attachmentId": ["attentionPath", "attimageInfo", "adachmentPath", "adociationPath", "AttachmentID", "attlementId", "attimagePath", "ttociationID", "attociationID", "attlementType", "attentionType", "attimageID", "attociationPath", "adachmentInfo", "attociationInfo", "attociationId", "attentionID", "adachmentID", "adociationInfo", "ttociationId", "attachmentType", "adociationID", "ttachmentId", "attlementid", "attachmentPath", "AttachmentType", "attplementationid", "ttachmentID", "attachmentID", "attentionInfo", "attentionId", "attentionid", "attachmentid", "ttachmentid", "attociationid", "attplementationID", "attachmentInfo", "AttachmentId", "attplementationId", "Attachmentid", "adociationId", "attimageId", "attlementID", "ttociationid", "adachmentId"], "attachment": ["appachment", "attachached", "instention", "assached", "attruction", "attociation", "attention", "instachment", "attached", " adaptment", " adaptachment", " attention", "assment", "instruction", "attment", "adention", " attociation", "attachruction", " adaptociation", " attment", "adached", "appention", "appment", "association", "assention", "attachachment", "adment", "attachention", "appruction", "adachment", " adaptention", "instment", "assachment"], "attachmentUri": ["attachmentIURI", "attachmentARI", "attachmentCuURI", "attachmentAuri", "attachmentSuuri", "attachedUti", "attachmentAti", "attachmentUURI", "attachmentEti", "attmentUri", "attachmentUti", "attachmentIuri", "attachmentSuURI", "attmentIri", "attachmentURI", "attmentIris", "attachedAti", "attachedAuri", "attachmentSuri", "attachmentCuris", "attachmentCuri", "attmentUURI", "attachmentIris", "attachmentUuri", "attachedUri", "attmentUris", "attachmentCuuri", "attachedARI", "attachmentEuri", "attmentUuri", "attachmentUris", "attachmentEri", "attachmentERI", "attachmentAri", "attachedUuri", "attachmentSuti", "attmentIURI", "attachmentSuRI", "attachedAri", "attachmentIri", "attmentIuri", "attachedURI", "attachmentSuris"], "contentUri": ["contentIi", "resourceUi", " contentUdi", " contentUris", "contentCdi", "resourceIRI", "contentSuris", "contentCRI", "contentUsri", "contentIri", "contentURris", "resourceUri", "contentCri", "resourceIris", "contentCuri", "contentSudi", "contentUuri", "contentFileris", "contentFileuri", "contentUsris", "contentUdi", " contentSuri", "resourceIi", "contentUsdi", "contentURri", "resourceIri", "contentUi", "contentUsRI", " contentSuRI", "resourceUuri", "contentCris", "resourceURI", "contentFileRI", " contentURI", "contentSuRI", "contentURuri", "resourceUris", "contentUsuri", " contentSudi", "contentIris", "contentUris", " contentSuris", "contentSuri", "contentIuri", "contentCi", "contentURi", "contentIRI", "contentFileri", "resourceIuri", "contentURI"], "file": ["get", "image", "auto", "buffer", "upload", "stream", "files", "up", "output", "socket", "object", "use", "view", "load", "input", "copy", "ger", "handler", "picture", "File", "cache", "child", "to", "connection", "content", "path", "resource", "fp", "io", "single", "line", "work", "FILE", "book", "f", "url", "letter", "this", "unit", "base", "binary", "zip", "model", "data", "pe", "create", "b", "local", "log", "via", "name", "entity", "reader", "le", "folder", "uri", "source", "filename", "able"], "in": ["r", "image", "m", "pin", "sync", "inn", "gin", "i", "socket", "s", "init", "input", "e", "copy", "id", "cli", "din", "conn", "or", "connection", "a", "inner", "io", "pull", "nin", "ini", "con", "f", "url", "binary", "this", "o", "login", "data", "err", "ac", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "client", "writer", "sync", "one", "i", "output", "socket", "view", "s", "init", "copy", "on", "cli", "page", "ex", "cache", "to", "conn", "connection", "inner", "ext", "resource", "io", "nin", "line", "o", "this", "null", "base", "exec", "data", "err", "b", "log", "net", "bin", "In", "by", "again", "OUT", "IN", "outs", "outer", "lock", "source", "up", "inc"], "intent": ["request", "category", "animate", "anim", "intention", "term", "ctx", "element", "entry", "concept", "impact", "ink", "focus", "object", "action", "context", "Activity", "init", "eng", "vent", "agent", "android", "content", "inst", "response", "xml", "ant", "feat", "acc", "enc", "this", "feature", "activate", "ents", "spirit", "ani", "contact", " Intent", "ent", "activity", "it", "text", "language", "advert", "document", "activation", "anc", "entity", "event", "act", "effect"]}}
{"id1": "14773782", "id2": "9857412", "code1": "    public void testJPEGRaster() throws MalformedURLException, IOException {\n        System.out.println(\"JPEGCodec RasterImage:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            JPEGImageDecoder dec = JPEGCodec.createJPEGDecoder(istream);\n            Raster raster = dec.decodeAsRaster();\n            int width = raster.getWidth();\n            int height = raster.getHeight();\n            istream.close();\n            System.out.println(\"w: \" + width + \" - h: \" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "label": 0, "substitutes": {"testJPEGRaster": [" testJPEGWatter", " testJPPGRasters", " testJPEGRotasters", " testJPEGRotast", " testJPPGrast", " testJPEGrasters", " testJPEGRotatter", " testJPEGratter", " testJPEGRasters", " testJPPGrasters", " testJPEGRast", " testJPPGraster", " testJPEGRatter", " testJPEGWasters", " testJPEGraster", " testJPEGrast", " testJPPGratter", " testJPPGRaster", " testJPEGWast", " testJPEGRotaster", " testJPPGRatter", " testJPEGWaster", " testJPPGRast"], "IOException": ["IPError", " IOError", "IPception", "OSception", "IOError", "OSException", "IOception", "OSError", "IPException", " IOception"], "start": ["base", "in", "end", "offset", "step", "pre", "art", "order", "load", "use", "info", "speed", "style", "left", "set", "scale", "pos", "starting", "from", "stage", "shift", "Start", "started", "diff", "ish", "min", "first", "length", "size", "init", "sum", "id", "data", "date", "get", "delay", "time", "source", "f"], "i": ["ini", "image", "mi", "index", "j", "oi", "yi", "hi", "inner", "phi", "ii", "ix", "fi", "slice", "key", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "abi", "li", "ci", "p", "ie", "uni", "si", "xi", "ni", "io", "multi", "v", "eni", "ai", "bi", "x", "ip", "qi", "ti", "id", "e", "iu", "f", "u", "di", "m", "I", "zi"], "url": ["image", "URL", "base", "in", "resource", "feed", "www", "download", "Url", "ls", "hub", "channel", "ref", "http", "src", "filename", "l", "href", "page", "string", "route", "album", "path", "fb", "source", "org", "uri", "img", "ur", "name", "id", "file", "data", "sl", "connection", "config", "location", "web", "f", "address"], "istream": ["ISTrib", "instep", "ISTstream", "stream", "step", "irstream", "istsore", "irstound", "ishream", "isep", "istsream", "istestream", "istep", "istsREAM", "istore", "instead", "stead", "istrib", "isagram", "stagram", "isead", "istound", "irstREAM", "ISTream", "istsep", "isream", "istsound", "isteream", "istsstream", "ishREAM", "iststream", "ISTep", "ishound", "instagram", "instream", "ishore", "istREAM", "irstore", "isterib", "isteep", "istagram", "istsrib", "istead"], "dec": ["enc", "de", " DEC", "des", "ode", "fr", "func", "vec", "dc", "cam", "draw", "dig", "exp", "sec", "rev", "rec", "DEC", "da", " decode", "c", "code", "r", "der", "oder", "next", "doc", "div", " Dec", "deg", "out", "img", "decl", "ra", "dir", "director", "neg", "data", "valid", "desc", "ec", "inc", "Dec", "s"], "raster": ["Raster", "arascal", "Roder", "rap", " rascal", "hatter", "araster", "Rap", "ratter", "eratter", "Rascal", "hap", "erasters", "eraster", "hasters", " rasters", "rascal", "rasters", " rap", "haster", " roder", "Ratter", "Rasters", "roder", "eroder", " ratter", "aroder", "arasters"], "width": ["z", "image", "flow", "ize", "dim", "wb", "shape", "Width", "density", "w", "duration", "write", "window", "age", "fw", "widget", "lon", "area", "full", "wd", "page", "left", "style", "scale", "wa", "d", "work", "en", "p", "gender", "frame", "x", "min", "img", "wn", "length", "wm", "size", "h", "layout", "weight", "west", "value", "n", "f"], "height": ["th", "dim", "right", "shape", "depth", "density", "deep", "w", "hd", "head", "window", "stroke", "dy", "pad", "rows", "padding", "work", "d", "k", "build", "v", "x", "rh", "img", "y", "length", "ady", "size", "crop", "thin", "h", "volume", "han", "angle", "inches", "Height", "max"], "stop": ["hide", "address", "shape", "change", "end", "step", "check", "ops", "skip", "output", "b", "speed", "hop", "page", "fill", "set", "summary", "cut", "exit", "drop", "clip", "sort", "remove", "snap", "sleep", "Stop", "number", "sign", "rest", "trip", "pop", "block", "pause", "keep", "spot", "roll", "limit", "comment", "zero", "wait", "delay", "save"]}}
{"id1": "22993368", "id2": "7458833", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeStringToFiles", "decodeFileAsFiles", "decodeStringToFile", "decodeFileAsStream", "decodeString2Stream", "decodeFileFromStream", "decodeFileFromFiles", "decodeStringToString", "decodeFile2File", "decodeFileAsString", "decodeFileFromFile", "decodeStringToStream", "decodeFileToString", "decodeString2String", "decodeFile2String", "decodeFile2Files", "decodeFileToStream", "decodeFileToFiles", "decodeFileAsFile", "decodeString2File", "decodeString2Files", "decodeFileFromString", "decodeFile2Stream"], "infile": [" infp", " instream", "minbase", "Inbase", "inputfilename", "infp", "minstream", "outfiles", " infiles", "minFile", "inputfp", "inputfiles", "minfile", "outfilename", "Infile", "inbase", " inbase", "outfp", " infilename", "instream", "InFile", "inFile", "inputfile", " inFile", "Instream", "infiles", "infilename"], "outfile": ["outputpath", "outfolder", " outdatabase", "inputFile", "outputFile", "inputdatabase", " outFile", "outfilename", "inputpath", " outfilename", " outfolder", "outpath", " outpath", "outputdatabase", "inFile", "inputfile", "infolder", "outputfolder", "outFile", "outputfile", "outputfilename", "infilename", "outdatabase"], "in": ["In", "inas", "pass", "again", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "pin", "ins", "ac", "min", "conn", "inn", "into", "err", "isin", "init", "win", "s", "rin", "lin", "gin", "thin", "inside", "i", "nin", "a", "socket", "sin", "login", "reader", "data", "r", "b", "inc", "id", "source", "re"], "out": ["timeout", "In", "or", "pass", "exit", "line", "again", "cache", "channel", "o", "ex", "inner", "bin", "Out", "copy", "outer", "log", "io", "outs", "co", "post", "sync", "conn", "no", "err", "up", "net", "base", "exec", "work", "name", "session", "off", "home", "image", "lib", "socket", "to", "writer", "output", "error", "ou", "write", "obj", "OUT", "point", "job", "inc", "parent", "client", "one", "file"], "buffer": ["seed", "channel", "cache", "uffer", "limit", "padding", "bin", "input", "layer", "wave", "feed", "buf", "queue", "slice", "length", "address", "count", "batch", "base", "server", "url", "size", "Buffer", "iter", "value", "split", "bytes", "transfer", "result", "border", "bb", "reader", "data", "write", "type", "raw", "null", "b", "buff", "flush", "offset", "binary", "source", "reference"], "read": ["reads", "pass", "run", "tell", " Read", "use", "ip", " skip", "send", "n", " write", "current", "reading", "fill", "limit", "select", "copy", "READ", "lex", "io", "feed", "add", "slice", "sync", "length", " count", "count", "seek", "play", "Read", "ad", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "len", "i", "allow", "ind", "_", "start", "ride", "check", "connect", "next", "reader", " copy", "parse", "write", "se", "raw", "r", "inc", "id", "sleep", "end"], "success": ["rolled", "done", "pass", "status", "again", "initial", "method", "results", "failed", "comment", "winner", " Success", "continue", "response", "func", "right", "fast", "path", "open", "Success", "primary", "ceed", "first", "warning", "construct", "content", "ccess", "positive", "growth", "roll", "good", "valid", "successful", "flash", " successful", "default", "danger", "model", "fail", " succeed", "complete", " succ", "value", "rolling", "result", "better", "true", "follow", "data", "error", "xx", "null", "successfully", "message", "cess"]}}
{"id1": "771802", "id2": "9824814", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public void run() {\n        if (status == COMPLETE) {\n            return;\n        }\n        waitRandom();\n        RandomAccessFile file = null;\n        InputStream inputStream = null;\n        boolean success = false;\n        URL url = null;\n        try {\n            BeatportAccessor beatportAccessor = new BeatportAccessor();\n            if (sessionCookies == null) {\n                sessionCookies = beatportAccessor.getSessionCookies(user, password);\n            }\n            url = new URL(new BeatportAccessor().getTrackDownloadUrl(downloadId, sessionCookies));\n            log.info(\"Open (DownloadWorker.run): \" + url);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"User-Agent\", BeatportAccessor.userAgent);\n            connection.setRequestProperty(\"Cookie\", sessionCookies);\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                log.error(\"Unexpected response from server: \" + connection.getResponseCode());\n                error();\n                return;\n            }\n            if (connection.getContentType().indexOf(\"text\") >= 0) {\n                log.error(\"Tried to request: \" + url.toString());\n                log.error(\"Unexpected file content type from server: \" + connection.getContentType());\n                log.error(\"Server replied:\\n\" + getContentAsString(connection));\n                error();\n                return;\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                log.error(\"Invalid content length: \" + connection.getContentLength());\n                error();\n                return;\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            } else if (size != contentLength) {\n                changeTotal(0, contentLength - size);\n            }\n            if (new File(tmpFileName(fileName)).exists()) {\n                if (!new File(tmpFileName(fileName)).delete()) {\n                    throw new Exception(\"Could not delete file: \" + tmpFileName(fileName));\n                }\n            }\n            file = new RandomAccessFile(tmpFileName(fileName), \"rw\");\n            file.seek(downloaded);\n            inputStream = connection.getInputStream();\n            if (started == 0) {\n                started = System.currentTimeMillis();\n                time = started;\n            }\n            statusChangedObserver.statusChanged(status);\n            byte buffer[] = new byte[MAX_BUFFER_SIZE];\n            while (status == DOWNLOADING) {\n                if (size - downloaded < MAX_BUFFER_SIZE) {\n                    buffer = new byte[(int) (size - downloaded)];\n                }\n                int read = inputStream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                changeTotal(read, 0);\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                stopped = System.currentTimeMillis();\n                status = COMPLETE;\n            }\n            statusChangedObserver.statusChanged(status);\n            stateChanged();\n            success = true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            error();\n        } finally {\n            try {\n                file.close();\n            } catch (Exception e) {\n            }\n            if (success) {\n                try {\n                    if (!new File(tmpFileName(fileName)).renameTo(new File(fileName))) {\n                        throw new Exception(\"Rename Failed\");\n                    }\n                } catch (Exception e) {\n                    log.error(\"Error moving temp file \" + tmpFileName(fileName) + \" file: \" + fileName, e);\n                }\n            } else {\n                try {\n                    new File(tmpFileName(fileName)).delete();\n                } catch (Exception e) {\n                    log.error(\"Error deleting erroneous temp file: \" + tmpFileName(fileName), e);\n                }\n            }\n            try {\n                inputStream.close();\n            } catch (Exception e) {\n                log.error(\"Error closing input stream of: \" + url + \" / \" + fileName, e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"createOutputStream": [" createInputReader", "createInputFile", " createIOReader", "createInputSteam", " createOutputReader", " createIOFile", " createByteReader", "createOutputReader", "createInputStream", " createOutputSteam", " createByteFile", "createOutputFile", " createInputSteam", " createIOStream", " createOutputFile", "createInputReader", " createInputStream", " createByteStream", " createInputFile", "createOutputSteam", " createIOSteam", " createByteSteam"], "inFile": ["sourceFiles", "sourceStream", "inputFile", "incFile", "outStream", "infile", "insfile", "inputStream", "incfile", "sourcefile", "inStream", "insFile", "incStream", "sourceFile", "inputFiles", "incFiles", "insStream", "outfile", "inFiles", "outFiles", "insFiles", "inputfile"], "outFile": ["workingfile", "outDir", "inputDir", "workFile", "targetFile", "inputFile", "workTime", "workingStream", "targetfile", "outStream", "workfile", " outfile", "infile", "outDirectory", "inTime", "workDir", "inputTime", " outStream", " outDirectory", "targetStream", "targetDirectory", "outTime", "outfile", "workingFile", "inDir", "workingDirectory", "inputfile"], "k_blockSize": ["k_lockCount", "k_BlockLength", "k_BlockCode", "k_byteCode", "k_byteLength", "k_lineInfo", "k_BlockSize", "k_blockCount", "k_blocksSize", "k_byteLen", "k_bitSize", "k_lineCount", "k_blocksCount", "k_bitCount", "k_lockLength", "k_lockLen", "k_BlockCount", "k_blockLen", "k_byteSize", "k_blocksLen", "k_bitInfo", "k_blockInfo", "k_blockCode", "k_byteCount", "k_lockCode", "k_blocksLength", "k_lineSize", "k_lockSize", "k_byteInfo", "k_blockLength"], "byteCount": [" bytecount", "blockSum", "byteSize", "bytecount", "byteLength", "flushCount", " byteSize", "flushcount", "characterCount", "blockSize", "blockCount", "characterLength", "blockLength", "Bytecount", "ByteSize", "byteSum", "flushLength", "ByteCount", " byteLen", "byteLen", "characterSize", "ByteLength", "ByteSum", " byteSum", "ByteLen", "flushSize", "characterLen", " byteLength"], "buf": ["vec", "uf", "Buffer", "cap", "result", "base", "img", "exc", "tmp", "cv", "feed", "brace", "font", "ctx", "fb", "border", "seq", "cmd", "queue", "len", "alloc", "bag", "Buff", "batch", "b", "background", "loc", "config", "buffer", "la", "bytes", "rb", "flush", "cas", "fd", "feat", "rc", "ucc", "data", "append", "bh", "src", "bf", "cb", "buff"], "ofp": ["fort", "afc", "Ofnp", "afp", "OFl", "forc", "ofnp", "Oft", "oftp", "forp", "OFt", "Ofp", "OFp", "oft", "ofl", "afl", "ofc", "afnp", "fortp", "OFc", "OFnp", "Ofc", "Oftp", "Ofl", "OFtp"], "zos": ["osi", "outs", "kos", "core", "zon", "budget", "zes", "os", "modules", "ozo", "zyk", "los", "ossus", "cos", "jas", "inos", "robe", "ZI", "zik", "utils", "zy", "enos", "soon", "ls", "zen", "zona", "zn", "iframe", "zi", "css", "rons", "zag", "hz", "abi", "forge", "bes", "obb", "ros", "oS", "bitcoin", "zar", "ZA", "zh", "zip", "zers", "oda", "liquid", "tz", "zl", "webkit", "bos", "owicz", "js", "za", "lins", "oses", "zx", "nz", "rez", "gz", "lol", "dylib", "z", "zin", "ws", "uz", "ses", "cfg", "iffs", "zer", "ops", "zo", "fits", "zig", "ogl", "obs", "zb", "packs", "nox", "bs"], "osw": ["lsx", "osww", "ishell", "esow", "bwo", "ossww", "essw", "oshell", "esw", "lsws", "oswo", "esnow", "osssw", "lswo", " osow", "bx", "osnow", "bsws", "osow", "ossw", "bsw", "bws", "esfw", "osswd", "isy", "isnow", "isw", "ossnow", "ossd", "esd", "osy", "osshell", " osww", "osws", "esww", "isd", "esy", "lsw", "ossow", "eswd", "iswd", " osfw", "ossfw", "issw", "ossy", "bswo", "osfw", "eshell", "bsx", "osx", "osd", "oswd"], "bw": ["lbwh", "abW", "bbz", "bbw", "abw", "bW", "bbew", "bbwa", " bwh", " bws", "lwa", "lbw", "bwa", "Bws", "baw", "bbws", " bwa", "owa", "bx", "fbwd", "bwu", "ebwd", "bwd", "lx", "bsw", "Bwa", "bwh", "bz", "bws", "lbws", "ebw", "fsw", "fbwe", "lbwa", "Bew", "fbW", "fx", "fwh", "bwe", "lbr", " bwu", "Bw", "lw", "bbwu", "lbx", "ow", "owu", "lsw", "fr", "fwa", "lbsw", "abwe", "bew", " baw", "lbz", "ebwe", "fbw", "fw", "bbaw", " bz", " bew", "ebW", "oaw", "bbwh", "abwd"], "zot": ["jot", "zott", " zor", "jori", "Ziot", "azit", "zerot", "jit", "Zor", "zita", "azita", "zeros", " ziot", "azot", "zor", "jos", "azott", "zerott", "zerita", " zori", "aziot", "Zott", "zori", "Zot", "azor", "zerori", "ziot", "Zita", "Zit", "zerit"], "ifp": ["ipl", "ipc", "iff", " ifb", "Iff", " ifi", "IFi", "ifb", "Ifi", "IFf", " ifl", "IFb", "ifi", "ipp", " ifc", "IFp", "ifc", "ipb", "IFl", "Ifc", "IFc", "ifl", "Ifp", " iff"], "zis": ["zipis", "xib", " zits", " zisi", "zeis", "xis", "zip", "zeip", " zib", "jit", " zIS", "Zits", "Ziss", "jits", "zenIS", "xits", "zeits", "zenib", "xais", "zais", "jisi", "xisi", "zenais", "Zis", "jis", "zipiss", "zib", "zIS", "zipits", "zisi", "xIS", "zipip", "zenis", "zeiss", "Zip", "zits", "xit", " zais", "ziss"], "isr": ["IScr", "isrs", "risr", " issr", "issrs", "risrc", "isrc", "rispr", "isrb", "isscr", "ISsr", "irpr", "ISrs", "isssr", "irrb", "ispr", "ISrc", "ISrb", "ISpr", " isrs", "irrc", "risrb", "ISr", " iscr", "iscr", "issr", "irr"], "br": ["yr", "bc", "obl", "img", "mr", "sr", "str", "ob", "bp", " Br", "ibr", "ber", "HR", "arr", "div", "hr", "rib", "bsp", "obi", "bro", "err", "bl", "Br", "r", "b", "kr", "browser", "bar", "body", "tr", " dr", "fr", "lr", "ibl", "rb", " fr", " BR", "BR", "ch", "bh", "gr", "cro", "sp", "ctr", "rs", "shr", "ocr"], "zit": ["zenits", "zenitter", " zits", "zipit", "zipitter", "zenit", "zip", "zenith", "xi", "jita", " zip", "zipita", "jit", "zipith", "zeit", "jits", " zite", "zith", "jith", "zita", "zeits", "zIT", "zeIT", "zeith", "zipIT", "zitter", "jite", "zi", "xith", "xic", " zic", " zith", "zeitter", "zite", "jip", "zipits", "zipite", "jic", "zipip", "ji", "zits", "xit", "zic", "jIT", "zeita", " zi"]}}
{"id1": "17716716", "id2": "19147281", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"plainToMD": [" stringToHash", " string2DER", " string2MD", " stringTOString", " input2Hash", " stringtoMD", " inputToDER", " stringToDER", " inputToMD", " stringToString", " input2MD", " stringtoString", " stringtoHash", " stringtoDER", " string2String", " stringTOMD", " input2String", " stringTOHash", " input2DER", " stringToMD", " stringTODER", " inputToString", " inputToHash", " string2Hash"], "loggerCol": ["progingColumn", "loggercol", "pluggingcol", "loggeCol", "loggingDr", "pluggercol", "pluggingDr", "loggecol", "loggeeDr", "loggeeCor", "progingCol", "pluggingCor", "logorerCollection", "pluggingCol", "pluggerCor", "progercol", "loggingCollection", "loggerColumn", "loggeCor", "loggingcol", "logorercol", "loggerDr", "pluggerDr", "loggerCor", "loglercol", "loglerCol", "loggingColumn", "loggeecol", "progerCol", "loglerCollection", "progerCollection", "progerColumn", "loggingCol", "loggeDr", "loggeeCol", "logorerColumn", "progingcol", "loggingCor", "loglerColumn", "loggerCollection", "logorerCol", "pluggerCol", "progingCollection"], "input": ["url", "base", "reader", "audio", "IN", "str", "output", "dict", "model", "raw", "container", "Input", "path", "request", "xml", "string", "context", "state", "cmd", "image", "format", "ssl", "connection", "null", "text", "empty", "config", "list", "buffer", "alpha", "inf", "plus", "form", "in", "data", "source", "file", "password", "instance", "temp"], "byteHash": ["stringArray", "blockSum", "byteBlock", "Bytehash", "bitBlock", "byteshash", "bytesHash", " bytehash", "wordArray", "ByteBlock", "bytehash", "ByteHash", "blockBlock", "stringhash", "byteSum", "stringHash", " byteSalt", "bithash", "wordSum", "bitHash", "bitArray", "stringSalt", " byteArray", " byteBlock", "wordhash", "blockHash", "byteSalt", "bytesSalt", "wordHash", "bytesArray", "bitSum", "byteArray", " byteSum", "ByteSum", "blockhash"], "md": ["MD", "hash", "cm", "mc", "dig", "ms", "metadata", "rm", "pm", "bd", "amd", "am", "df", "mo", "um", "meta", "mb", "mt", "cmd", "doc", "cc", "sm", "pkg", "rpm", "mand", "m", "dd", "ph", "Cmd", "Msg", "mg", "mm", "ma", "ad", "cd", "pd", "mac", "mn", "hm", "dr", "di", "mod", "dh", "d", "mag", "nm", "dm", "f", "mu", " MD", "mp", "msg"], "md5result": [" md5Result", "md5Result", " md25result", "md7result", " md25data", "md53results", "md7report", "md5results", "md6result", "md6package", "md305runner", " md5results", " md5report", "mddownresult", " md5package", " md7Result", "md25Result", "md512report", "md6report", "md4response", "mddownResult", " md5runner", "md512results", "md53runner", "md512Result", " md5data", "md4result", "md5report", " md305result", " md7result", " md25Result", "md5runner", "md25package", "md5data", "md7Result", "md305response", "md25result", " md305results", "md25data", " md305runner", "md305results", "md305result", "md6Result", "md4results", "md53response", " md7results", " md305response", " md5response", "md6results", "md512result", "md5response", "md53result", "mddowndata", " md25package", "md5package", "md6data", " md7report", "md7results", "md4runner", "mddownpackage"], "i": ["qi", "v", "z", "ai", "ti", "I", "e", "id", "io", "xi", "x", "index", "length", "u", "s", "li", "hi", "ui", "multi", "c", "ci", "si", "ii", "j", "r", "b", "n", "o", "bi", "zi", "ri", "uri", "p", "key", "gi", "h", "fi", "l", "oi", "di", "d", "ji", "mu", "f", "pi"]}}
{"id1": "17296916", "id2": "2465747", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(buffer.getPayload().toString().replaceAll(\"\\r\\n|\\n|\\r\", \"\"));\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 0, "substitutes": {"logging": ["Logting", "loging", " loging", "bloging", " logting", "Logging", "blogging", "Logger", "blogting", "logting", "Loging", " logger", "logger", "blogger"], "wrap": ["wa", "wire", "util", "cache", "w", "now", "parse", "flash", "war", "handle", "use", "force", "cover", "ws", "default", "div", "binary", "stream", "word", "image", "lock", "widget", "self", "build", "rap", "bag", "we", "format", "or", "box", "transform", "b", "handler", "pipe", "ow", "nw", "wb", "message", "ad", "api", "p", "wrapper", "get", "h", "wp", "process", "work", "init", "create", "frame", "wra", " Wrap", "sw", "web", " wrapped", "f", "run"], "buffer": ["Buffer", "template", "bc", "url", "result", "uf", "header", "base", "uffer", "reader", "cache", "builder", "flash", "bb", "ob", "view", "bin", "transfer", "pause", "feed", "nb", "cover", "surface", "shell", "bm", "log", "manager", "fb", "bridge", "binary", "queue", " buf", "image", "code", "layer", " buffers", "reference", "writer", "print", "report", "batch", "b", "bar", "buf", "player", "null", " receive", "loader", "table", "iter", "message", "BU", "wrapper", "copy", "document", "source", "pb", "server", "ref", "frame", "reply", "board", "comment", "cb", "buff", "response", "msg"], "encoding": ["coder", "Encet", "unicode", "decoding", "decode", "encoder", "coding", "enoding", "packoded", "cet", "Encoded", "decoder", "Encryption", "encoded", "unicoded", "ecoding", "unicoder", "decoded", "encryption", "unicoding", "Encoder", "ecoder", "enoded", "packet", "packoding", "enode", "packoder", "ecoded", "coded", "ecryption", "encet", "decryption", "Encoding", "encode", "enoder"], "getEncoding": ["getCocol", " getEnasing", "getencoding", "getCasing", "getEnocol", " getEnoder", " getEncocol", "getEnoded", "getEnasing", "getencoded", " getEnocol", " getEncoder", "getCoder", " getEncasing", "getEnoder", " getEncoded", "getCoded", "getEnoding", "getencocol", "getCoding", "getEncocol", "getEncoded", "getencoder", " getEnoding", "getEncasing", "getEncoder", " getEnoded", "getencasing"], "headers": ["workers", "objects", "header", "ppers", "params", "ers", "types", "relations", "ints", "groups", "str", "ids", "dict", "ters", "host", "s", "values", "lines", "files", "strings", "properties", "vals", "breaks", "options", "head", "body", "caps", "bits", "plugins", "padding", "frames", "parts", "blocks", "wrapper", "content", "h", "links", "http", "fields", "ports", "keys", "details", "names", "heads", "rs", "features", "writers", "ings", "settings"], "is": ["us", "\u00eds", "las", "ais", "ins", "ms", "tis", "ois", "isol", "iso", "isa", "was", "io", "are", "has", "aos", "IS", "bis", "ws", "Is", "sis", "es", "oss", "abs", "out", "cms", "ui", "s", "ris", "isl", "ios", "iss", "os", "ses", "nis", "bas", "or", "ori", "i", "js", "ops", "so", "lis", "isi", "fs", "api", "iris", "its", "http", "in", "obs", "ists", "as", "bs", "mis"], "bos": ["shadow", "mos", "bott", "bc", "las", "osi", "base", "mobi", "osa", "tis", "outs", "ois", "ob", "bin", "aos", "bis", "ws", "opus", "zos", "cms", "obi", "oks", "oes", "bot", "ios", "obos", "os", "bo", "bas", "ses", "org", "oos", "obo", "beans", "ops", "so", "zo", "bi", "bits", "fits", "flo", "bots", "oses", "pins", "ubs", "los", "fs", "lins", "uds", "obs", "cos", "abi", "bh", "bes", "ubis", "bones", "home", "ros", "ko", "oops", "bs", "mis"], "e": ["oe", "de", "esi", "error", "exc", "re", "ise", "one", "x", "ea", "je", "er", "ee", "err", "c", "E", "fe", "ec", "type", "ie", "i", "a", "pe", "ite", "ce", "ception", "o", "ale", "ae", "p", "me", "l", "ev", "ke", "se", "d", "ze", "f", "be"]}}
{"id1": "14303294", "id2": "15202804", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"getServerHash": ["getSessionHash", "getServerAddress", " getServerAddress", "getSecureSalt", "getServerSalt", "getserverAddress", " getSecureAddress", "getserverHash", "getSessionAddress", "getserverSHA", "getSecureSHA", "getSecureHash", "getSecureAddress", "getserverSalt", "getSessionSalt", "getSessionSHA", " getServerSHA", " getSecureSalt", " getSecureHash", "getServerSHA", " getServerSalt", " getSecureSHA"], "passwordHash": ["passwordhash", " PasswordHash", " passwordCode", "PasswordHash", "passwordPass", "PasswordPassword", " passwordhash", "PasswordPass", " passwordPass", "privatePassword", " PasswordPass", " PasswordCode", "privatehash", "passwordCode", "privateHash", " passwordSalt", "passwordSalt", "privateSalt", " passwordPassword", "Passwordhash", "PasswordCode", "passwordPassword"], "PasswordSalt": [" PasswordHash", "password256", " passwordSecret", "PasswordHash", "PasswordPassword", "passwordSecret", "PasswordSecret", "PASSSalt", "PASSPassword", "PASSHash", " Password256", " passwordSalt", "passwordSalt", "Password256", "PASS256", " passwordPassword", " PasswordPassword", " PasswordSecret", "passwordPassword"], "hash": ["row", "sh", "string", "cache", "mac", "Hash", "sha", "response", "sum", "copy", "log", "search", "hex", "number", "key", "auth", "content", "user", "address", "kh", "build", "crypt", "ha", "base", "url", "work", "ash", "size", "array", "pool", "code", "value", "password", "her", "image", "h", "check", "result", "change", "html", "error", "data", "dig", "message", "update", "buffer", "block"], "digest": ["hashener", "digener", " digall", "generall", "hashest", " diger", "digusher", "mdest", "Digener", " digher", "Digester", " digusher", "integested", "mdested", "signest", "Digested", "integest", " digger", "digested", "digester", "signer", "Digusher", " digester", " digested", "Digher", "generest", "mdusher", "signester", "hasher", "hashester", "signher", "generester", "Diger", "diger", "Digger", "integester", "generested", " digener", "integall", "digger", "mdester", "Digest", "digher", "digall", "signger"]}}
{"id1": "7872659", "id2": "23273706", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndmovieindexfile", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndmovieIndexfile", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieIndexPath"], "completePath": [" CompleteHome", "successPath", " completePoint", "completeDir", "completeCh", "correctPoint", "progressLoader", "itepath", "progresspath", "completeFile", "correctRoot", " CompleteFile", "donePath", "execLoader", " completepath", "donepath", "successMusic", " completeCorp", " completeRoot", "CompletePath", "completeLoader", "completepath", "flatPoint", "itePath", "progressVol", "successpath", "correctCorp", "iteCh", " completeDir", "execPath", " completeMusic", "CompleteFile", "execVol", "doneLoader", "completeVol", "completeMusic", "completeRoot", "iteMusic", "execpath", "flatCorp", "completeCorp", "CompleteDir", "correctPath", " CompleteDir", "flatPath", " completeFile", " completeHome", "progressPath", "completePoint", " CompletePath", "flatRoot", "CompleteHome", "doneVol", "successCh", " completeCh", "completeHome"], "masterFile": ["cacheFILE", "masterName", "mastersFILE", "MasterFilename", "configName", "masterFilename", "MasterName", "mastersFile", "MasterFile", "configPath", "configFilename", "MasterPath", "mastersPath", "masterFILE", "masterPath", " masterPath", "cacheFile", "masterFiles", "configFile", "cacheFiles", "MasterFiles", "mastersFiles", " masterFilename", "cachePath", "MasterFILE", " masterName"], "CustRatingFileName": ["CustRateFilenameSize", "CustIndexFileName", "CustIndexFileVersion", "CustRatingLineName", "CustIndexFilesName", "CustRateFilePath", "CustIndexFileType", "CustRatingLineVersion", "CustRateFilenameDesc", "CustRatingClassPath", "CustIndexFilesType", "CustRatingFullDesc", "CustRatingFileType", "CustRatingFullPath", "CustRatingLinePath", "CustRatingLineType", "CustRatingFilenamePath", "CustRatingClassVersion", "CustRateFileSize", "CustRatingFilenameName", "CustRatingFileSize", "CustRatingClassName", "CustRatingFileDesc", "CustRateFilenameName", "CustRatingFilesPath", "CustRatingFilesDesc", "CustRatingFilesType", "CustRatingFilesName", "CustRatingFullSize", "CustRateFileName", "CustRateFileDesc", "CustIndexFilesVersion", "CustRatingClassType", "CustRatingFilesSize", "CustRateFilenamePath", "CustIndexFilePath", "CustRatingFilenameSize", "CustRatingFullName", "CustRatingFileVersion", "CustRatingFilePath", "CustIndexFilesPath", "CustRatingFilesVersion", "CustRatingFilenameDesc"], "MovieIndexFileName": ["MovieEditFUrl", "MovieConfigFileName", "MovieIndexFolderFile", "MovieIndexFName", "MovieIndexFSize", "MovieEditFileName", "MovieConfigFileFile", "MovieIndexClassSize", "MovieConfigFileVersion", "MovieIndexFolderName", "MovieIndexFILEFile", "MovieEditFileUrl", "MovieIndexFUrl", "MovieIndexClassName", "MovieConfigFolderVersion", "MovieEditFSize", "MovieIndexPlaceVersion", "MovieEditFileSize", "MovieIndexPlaceFile", "MovieIndexClassname", "MovieIndexFileFile", "MovieIndexFileVersion", "MovieEditFname", "MovieIndexClassUrl", "MovieIndexFileUrl", "MovieIndexFilesName", "MovieEditFilename", "MovieConfigFileHandle", "MovieIndexFilesname", "MovieConfigFolderName", "MovieIndexFilesUrl", "MovieIndexPlaceName", "MovieConfigFolderFile", "MovieIndexPlaceHandle", "MovieIndexFilename", "MovieIndexFILEHandle", "MovieIndexFname", "MovieIndexFileHandle", "MovieIndexFILEVersion", "MovieIndexFolderHandle", "MovieIndexFolderVersion", "MovieEditFName", "MovieIndexFILEName", "MovieIndexFileSize", "MovieConfigFolderHandle", "MovieIndexFilesSize"], "inFile": ["outfile", "outSourceFile", "incSourceFile", "inputFile", " infile", "outC", "InSourceFile", "inputSourceFile", "inF", " inF", "infile", "incC", "Infile", "InF", "InFile", "inputfile", " inSourceFile", "inSourceFile", "outFile", "inputF", "incFile", "incfile"], "inC": ["inCI", "outCL", " inCL", " inCC", "inputFile", "inputC", "innerCI", "outC", "inB", "InB", " inB", "inF", " inF", "inCC", "innerCC", "InCI", "InF", "innerC", "outF", "InFile", "outCC", "InC", "outFile", "InCC", "inputF", "inputCC", "outCI", "inCL", "outB", "innerFile", "InCL"], "outFile1": ["outPath1", "againCFirst", "outPlace1", "outputfileId", "outF2", "outputfile2", "outputFileId", "outFilesFirst", "outPath2", "outfile1", "outFName", "againFile2", "outFiles3", "outFiles2", "outFId", "againC3", "outPathFirst", "outfile2", "againC1", "outputFileName", "outputfile1", "outPlaceId", "outF1", "outFiles1", "outFileId", "outFileName", "outputFile1", "outC3", "outputfileName", "againC2", "outPlace2", "outPlaceName", "againFile3", "againFile1", "outCFirst", "outfileId", "outFile3", "outFileFirst", "againFileFirst", "outfileName", "outputFile2", "outPath3"], "outC1": ["outF8", "newc81", "outFOne", "againB2", "outCFOne", "outB2", "outF2", "outB8", "outDOne", "newC81", "againB8", "outcFirst", "newcOne", "outD81", "outCOne", "againC8", "outD1", "outB1", "outD8", "newc1", "againC1", "outBOne", "outC81", "outF1", "newC1", "newCFirst", "outD2", "againC2", "outDFirst", "outc81", "againCOne", "newCOne", "outCFFirst", "againB1", "outCFirst", "outCF1", "outC8", "newcFirst", "againBOne", "outc1", "outCF81", "outcOne"], "outFile2": ["againLine2", "outputfileTwo", "outputFile5", "outChannel1", "outfile5", "outFiles4", "outFilesTwo", "outChannel6", "outputfile2", "outLine6", "outLine1", "againFileTwo", "outFiles6", "outDirectory5", "outputfile5", "outDirectoryTwo", "outFiles2", "outDirectory2", "outChannel2", "againFile2", "againLine1", "outFile5", "outfile4", "againFile6", "outfile2", "outFile6", "outfileTwo", "outFiles1", "outChannelTwo", "againLineTwo", "outFiles5", "outputFileTwo", "outFile4", "againFile1", "outputfile4", "outLineTwo", "outFileTwo", "outLine2", "againLine6", "outDirectory4", "outputFile4", "outputFile2"], "outC2": ["OutC4", "OutC1", "againB4", "againB2", "outB2", "outF2", "againCTwo", "outCache4", "againC4", "outC4", "OutCII", "outFileII", "outB1", "outCII", "againC1", "outF1", "outCache1", "outB4", "outFII", "againC2", "outCache2", "outBTwo", "OutFII", "outFile4", "outCTwo", "againB1", "outCacheII", "OutF1", "OutF4", "OutC2", "outFileTwo", "OutF2", "againBTwo", "outF4", "outFTwo"], "fileSize": [" fileAddress", "fileSIZE", " fileLength", "resourceSIZE", " fileMode", "bufferSize", "bufferLength", "fileLength", "imageSIZE", "FileAddress", "resourceSize", "resourceAddress", "FileSIZE", " fileSIZE", "imageSize", "FileSize", "FileMode", "bufferMode", "FileLength", "fileAddress", "fileMode", "imageLength"], "totalNoDataRows": ["totalNoPageRues", "totalNoDataLues", "totalNoPageLrows", "totalNoDataLrows", "totalNoPageLues", "totalNoDataCues", "totalNoDataChrows", "totalNoPageLOWS", "totalNoDataRues", "totalNoPageLows", "totalNoDataChues", "totalNoPageROWS", "totalNoDataCrows", "totalNoDataLows", "totalNoPageRows", "totalNoDataChows", "totalNoDataCows", "totalNoDataChOWS", "totalNoDataRrows", "totalNoDataLOWS", "totalNoDataROWS", "totalNoPageRrows", "totalNoDataCOWS"], "mappedBuffer": ["mappedStream", "mapedBuffer", "machedChannel", "machedbuffer", "MappingChannel", "mapedStream", "MachedURL", "machedBuffer", "mashedChannel", "MappedURL", "mapedURL", "mippedStream", "machedURL", "MappedBuff", "MappingFile", "mppedStream", "MappingBuffer", "mactedbuffer", "mippedBuffer", "mappingBuffer", "MachedStream", "machedStream", "mactedBuffer", "mippedBuff", "machedFile", "Machedbuffer", "mactedBuff", "MachedBuff", "mappedbuffer", "mippedURL", "machedBuff", "mappingChannel", "MappingBuff", "MappedChannel", "mashedFile", "mactedStream", "MappedBuffer", "MappedStream", "MachedBuffer", "mashedBuffer", "mapedFile", "mappingbuffer", "Mappedbuffer", "mappingStream", "mappingFile", "MappedFile", "mappedChannel", "mapedBuff", "mappedFile", "MachedChannel", "mappedURL", "mppedBuff", "mappingBuff", "MachedFile", "mppedBuffer", "mappedBuff", "mashedBuff", "mppedChannel"], "startIndex": ["startindex", "startOffset", "initInfo", "endindex", "endSection", "useindex", "stopIndex", "startingIndex", "startingPosition", "startCode", " startindex", "StartInfo", "useIndex", " startSection", "usePosition", "stopRow", " startCode", " startPoint", " startInfo", "startInfo", "StartIndex", "startSection", "endInfo", "StartPosition", "startingSection", "initIndex", " startRow", "startingPoint", "StartOffset", "endIndex", "endCode", "stopindex", "initOffset", "endPosition", "startPosition", "endPoint", "Startindex", "initindex", "useInfo", "stopCode", "startPoint", " startPosition", "startRow", "endRow", " startOffset"], "count": ["group", "c", "current", "cache", "col", "call", "depth", "limit", "total", "more", "self", "sum", "time", "old", "Count", "number", "key", "force", "add", "first", "list", "length", "child", "weight", "part", "order", "all", "coll", "find", "thread", "max", "size", "index", "pool", "other", "code", "len", "i", "allow", "ind", "start", "close", "counter", "test", "follow", "type", "found", "id", "loop", "name", "keep"], "currentMovie": ["currentlyMusic", " currentMusic", "parentMovie", "currentFilm", "validMovie", "thismovie", "reportedMusic", "currentmovie", "currentPicture", "CurrentFilm", "parentFilm", "CurrentTheme", "CurrentMovie", "reportedFilm", "reportedMovie", "Currentmovie", "thisMovie", "defaultImage", "validFilm", "currentTheme", "reportedPicture", "defaultMovie", "reportedTheme", "validmovie", "currentImage", "defaultFilm", "parentPicture", "reportedImage", "currentMusic", "reportedmovie", "currentlyMovie", "defaultMusic", " currentFilm", " currentPicture", "thisPicture", "currentlyPicture", " currentImage", "thisFilm", "parentmovie", " currentmovie", "validTheme"], "movieName": ["moviename", "camFamily", " movieInfo", " movieId", "filmFamily", "filmname", "movieId", "filmName", "voiceId", "moneyNumber", "voiceInfo", "movieInfo", " movieFamily", "MovieName", "filmNumber", " moviename", "camName", "moneyName", "movieNumber", "movieFamily", "voicename", "camname", "MovieInfo", "voiceName", "MovieNumber", "MovieFamily", "Moviename", "MovieId", "moneyFamily"], "customer": ["ustomor", "ustomers", " customeri", " customER", "mixER", "CustomER", "ustomer", "Customers", "Customer", "customER", "customor", "mixor", " customers", "ustomER", "customers", "mixer", "customeri", "Customor", "ustomeri", "Customeri", "mixers"], "rating": ["resource", "Rating", "setting", "attribute", "ranking", "string", "packing", "reading", "http", "ruby", "comment", "number", "rage", "ring", "ing", "missing", "alpha", "including", "rate", "rc", "url", "score", "rank", "rice", "value", "feature", "rolling", "writer", "RC", "rated", "reader", "range", "type", "data", "writing", "error", "rr", "r", "rates", "id", "info", "radius", "padding"], "outBuf1": ["outBum1", "outFuf1", "outBuf01", "outBbuf11", "outDuff3", "outBummerCloud", "outBiff1", "outDuf3", "outBuff0", "outBaf1", "outKbuffOne", "outBuffn", "outBuff2", "outBbufOne", "outDuffn", "outBuf3", "outCuf1", "outCuf0", "outBummerOne", "outBalth2", "outKbuf1", "outBbuffOne", "outFufOne", "outKuf1", "outBuff1", "outBbuf1", "outBafOne", "outBufOne", "outKbuff1", "outBufn", "outKbuff8", "outKuf2", "outDuf11", "outFuf91", "outBuf8", "outBaf8", "outBbufn", "outFafOne", "outBbuf91", "outBaf3", "outFuf01", "outBaft1", "outBuffCloud", "outBum91", "outBbuff0", "outBuff8", "outBuff3", "outBuff11", "outBbuff1", "outCuff0", "outFaf1", "outFbuf01", "outBafCloud", "outBbuf2", "outKbuf2", "outBum01", "outBbuff8", "outBalth1", "outCuffOne", "outBuf0", "outKbuff3", "outBiff01", "outKufOne", "outFufCloud", "outBummer1", "outKbuf3", "outBiff91", "outBiffOne", "outBuf91", "outFbuf91", "outKuf3", "outFbufOne", "outBumOne", "outBalth3", "outKuf8", "outDuff11", "outBaf0", "outFbuf1", "outDufn", "outCufOne", "outBuf11", "outDuff1", "outBbuff3", "outBaftn", "outBbuf01", "outCuff1", "outBufCloud", "outBaft3", "outBaft11", "outBbuf3", "outDuf1", "outFafCloud", "outBuffOne"], "outBuf2": ["outFbuff2", "outFufB", "outFuf4", "outBuf12", "outBuf200", "outWBuff8", "outWBuff4", "outFbuff1", "outFuf1", "outBuf20", "outBum82", "outFuf20", "outBait4", "outFuf12", "outWBuff2", "outWBuf0", "outBbufTwo", "outBbuffer4", "outFbuffTwo", "outWBuf4", "outBuff0", "outBoff8", "outWBbuff8", "outBbuff4", "outFbuf12", "outFbuff4", "outWBuf8", "outFuf8", "outBuff2", "outBuf4", "outWBbuff2", "outBait200", "outBbuff2", "outWBbuffTwo", "outBbuffTwo", "outFbuff8", "outFbuff82", "outBbuff200", "outBuffTwo", "outBbuf12", "outBait2", "outFuf2", "outBbuff20", "outBufB", "outBuff1", "outBum8", "outBbuf1", "outBufTwo", "outBuf8", "outBbufB", "outFbuff20", "outBbuffer2", "outBbuff0", "outBuff8", "outBait8", "outBbuff1", "outBum20", "outBbuf2", "outBbuff8", "outBuf0", "outBoffTwo", "outBuber82", "outWBuff0", "outFufTwo", "outBuff4", "outWBuf2", "outBum2", "outBoff2", "outFbufB", "outBbuff82", "outBbufferB", "outFuf82", "outBuber8", "outBoff200", "outBuber2", "outBbuffer12", "outBuf82", "outBaitTwo", "outBait0", "outFbuf4", "outFbuf2", "outWBbuff200", "outBbuf4", "outWBuf200", "outWBufTwo", "outBuff12", "outBuffB", "outBuber20"], "endOfIndexFile": ["endOfindexfile", "endOfLinkDir", "endOfindexTime", "endOfindexFolder", "endofIndexDir", "endofLinkFile", "endedfile", "endOfClientTime", "endOfClientFile", "endOfIndexfile", "endOfImageTime", "endOfindexFiles", "endOfIndexFolder", "endofindexFile", "endOfDataFile", "endOfLinkFiles", "End\n", "endOfindexDir", "end\n", "endofIndexFiles", "endOfIndexTime", "endOfindexFile", "endfile", "Endfile", "endOfLinkFile", "endofIndexTime", "endOfLinkfile", " end\n", "endofindexTime", "endofLinkTime", "endOfIndexDir", "endOfImageFiles", "endOfDataTime", "endOfImageFile", "endOfClientFiles", "endOfLinkTime", " endfile", "endofLinkDir", "endofindexFolder", "endofindexFiles", "endofIndexFolder", "endOfImageFolder", "endOfDatafile", "endofLinkFiles", "ended\n", "endOfIndexFiles", "endofIndexFile", "endOfClientDir", "endOfDataDir"]}}
{"id1": "20717531", "id2": "8064604", "code1": "    public static String encrypt(String plainText) {\n        if (TextUtils.isEmpty(plainText)) {\n            plainText = \"\";\n        }\n        StringBuilder text = new StringBuilder();\n        for (int i = plainText.length() - 1; i >= 0; i--) {\n            text.append(plainText.charAt(i));\n        }\n        plainText = text.toString();\n        MessageDigest mDigest;\n        try {\n            mDigest = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            return plainText;\n        }\n        mDigest.update(plainText.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"encrypt": [" enccrypt", " decress", " encipher", "Enccrypt", "Encrypt", " deccrypt", " encress", "encipher", "encress", "enccrypt", " decrypt", "Encipher", " decipher", "Encress"], "plainText": ["fullTime", "protectedText", "simpleTime", "externalString", "originaltext", "binaryString", "publicTEXT", "plainTEXT", " plainContent", "fullData", "flatData", "singleString", "batContent", " plainData", "flattext", "publicText", "singleText", "externalKey", "simpletext", "protectedTEXT", "plainTarget", "externalText", " plainTEXT", "fullText", "originalTEXT", "externaltext", "fullTEXT", " plainString", "fulltext", "protectedTextColor", "flatTEXT", " plainTarget", "flatTime", "batText", "simpleText", "binaryText", "plainPart", "plainTextColor", "plainContent", "protectedString", "protectedtext", "originalText", "batTEXT", "originalTextColor", " plainKey", "plaintext", "plainData", " plainPart", "flatContent", " plainTextColor", "flatTarget", "protectedKey", "battext", "publictext", "singlePart", "plainString", "simpleTEXT", "publicTarget", "protectedContent", "binaryPart", "plainTime", "flatText", "binarytext", "plainKey", "singletext", " plaintext"], "text": ["ext", "data", "event", "str", "letter", "b", "output", "math", "txt", "contract", "writer", "password", "key", "off", "address", "test", "buffer", "service", "source", "image", "value", "feed", "Text", "builder", "path", "object", "editor", "struct", "port", "pattern", "context", "url", "width", "code", "form", "config", "post", "null", "id", "word", "message", "result", "input", "append", "out", "TEXT", "print", "length", "string", "tx", "use", "font"], "i": ["x", "ji", "f", "y", "si", "it", "ti", "ri", "s", "slice", "m", "j", "p", "info", "pi", "k", "field", "ind", "ie", "ix", "hi", "I", "bi", "di", "u", "multi", "b", "qi", "l", "fi", "e", "o", "key", "ini", "temp", "abi", "ci", "z", "t", "h", "xi", "oi", "mi", "ui", "v", "li", "uri", "n", "ii", "io", "c", "in", "ni", "id", "index", "iu", "chi", "mu", "vi", "eni", "ai", "gi", "phi", "ip"], "mDigest": ["mdigester", "mDigger", "mdigest", "MDigester", "mDigEST", "mdigex", " mDigusher", "mdiger", "cmDigested", "mDger", "MDex", "mCompest", "mDiger", " mDigester", " mDester", "MDest", "mHashEST", "mHashester", "mdigger", "mHashger", "mDigse", "mdigests", "mCompester", "mCompests", "mEdester", "mdigse", "MDests", "mDester", " mHashger", "MDigex", "cmDiger", "mDEST", "mHashusher", "mDigusher", "mDer", "mDigex", "mdigEST", "mHashest", " mHashester", "cmdigester", "mCompex", "cmdigest", "mEder", "cmdigested", "mDested", "mDest", "mDse", " mDest", "mDigester", " mDigEST", "mEdested", " mDigse", "mdigusher", "MDigest", " mDse", "mDigests", "cmDigester", "MDigests", "mDex", "cmdiger", "mEdest", "cmDigest", " mDEST", " mDigger", "mdigested", "mHashse", " mHashest", "mDigested", " mHashusher", "mDests", "mDusher", "MDester"], "d": ["x", "did", "f", "data", " data", "cd", "sd", "ds", "s", "dl", "D", "dd", "m", " D", "p", "dn", "da", "str", "dig", "ld", "di", "u", "b", "bytes", "l", "e", "dim", "md", "dr", "dc", "db", "z", "t", "ded", "h", "v", "n", "c", "id", "dh", "a", "fd", "dat", "string", "dt", "dos"], "hash": ["bin", "f", "ha", "hed", "version", "string", "array", "str", "hex", "log", "base", "carry", "b", "output", "user", "size", "kh", "her", "mac", "dot", "key", "secret", "buffer", "bar", "build", "image", "block", "square", "db", "h", "v", "url", "sum", "history", "number", "code", "ashes", "memory", "ssh", "shadow", "message", "sha", "result", "header", "ash", "cover", "print", "Hash", "html", "sh"]}}
{"id1": "7044685", "id2": "2910383", "code1": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "code2": "    public String downloadAndOpen(JProgressBar bar) {\n        long size = 0;\n        try {\n            size = photo.getSize();\n        } catch (ServiceException ex) {\n            ex.printStackTrace();\n        }\n        try {\n            bar.setMaximum((int) size);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        bar.setValue(0);\n        image = new File(\"TMP/\" + photo.getTitle().getPlainText());\n        try {\n            if (!image.exists()) {\n                image.createNewFile();\n                image.deleteOnExit();\n                URL url = null;\n                BufferedOutputStream fOut = null;\n                try {\n                    url = new URL(photo.getMediaContents().get(0).getUrl());\n                    InputStream html = null;\n                    html = url.openStream();\n                    fOut = new BufferedOutputStream(new FileOutputStream(image));\n                    byte[] buffer = new byte[32 * 1024];\n                    int bytesRead = 0;\n                    int in = 0;\n                    while ((bytesRead = html.read(buffer)) != -1) {\n                        in += bytesRead;\n                        bar.setValue(in);\n                        fOut.write(buffer, 0, bytesRead);\n                    }\n                    html.close();\n                    fOut.close();\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                }\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return image.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"encrypt": ["enccrypt", "encipher", "encress", "deccrypt", "decipher", " enccrypt", "enrypt", "enress", "decrypt", " encress", " encipher", "decress", "enipher"], "plaintext": ["plainsource", "flatsource", " plainText", " plaincontent", " PlainText", "plainTEXT", "fcbinary", " plainbinary", " plainsource", "flattext", " Plaintext", " Plaincontent", "plainText", " Plainbinary", "flatTEXT", "plainbinary", "broadTEXT", "fcText", "broadsource", "fccontent", "broadText", "flatText", "plaincontent", "broadtext", " plainTEXT", "fctext"], "d": ["mad", "md", "de", "da", "dl", "e", "id", "bd", "dict", "db", "ded", "c", "mand", "m", "dd", "t", "gd", "r", "g", " dd", "b", "n", "dat", "o", "sd", "D", "did", "od", "dad", "ds", "ad", "dc", "pd", "cd", "p", "nd", "h", "fd", "dn", "dt", "di", "l", "data", "dr", "mod", "dh", "ld", "ed", "f", "dig", "rd"]}}
{"id1": "7468827", "id2": "8801182", "code1": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "code2": "    private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception {\n        Properties list = new Properties();\n        list.load(new FileInputStream(fileWithListOfImages));\n        long current = 0;\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir);\n        System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\");\n        System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\");\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\");\n        }\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            URL url = new URL(uriPrefix + urlString);\n            File file = new File(outputDir + \"/\" + imageNameToFileName(urlString));\n            current++;\n            if (!file.exists()) {\n                try {\n                    BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000);\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000);\n                    int c;\n                    while ((c = in.read()) != -1) {\n                        out.write(c);\n                    }\n                    out.close();\n                    in.close();\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                    System.out.println(\"saved\");\n                } catch (Exception e) {\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage());\n                }\n            } else {\n                System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                System.out.println(\"already exists\");\n            }\n            if (current / 100 == current / 100.0) {\n                long delta = (System.currentTimeMillis() - startTime);\n                System.out.println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\");\n            }\n        }\n        long delta = (System.currentTimeMillis() - startTime);\n        System.out.println(\"Total time \" + delta + \" ms, \" + (delta / list.size()) + \" ms/file\");\n    }\n", "label": 0, "substitutes": {"run": ["running", "url", "resource", "server", "call", "build", "Run", "loop", "check", "test", "download", "process", "stop", "create", "web", "work", "login", "exec", "submit", "start", "get", "runner", "update", "execute", "close", "open"], "con": ["conv", "cons", "ex", "un", "url", "cn", "plain", "uc", "conf", "cp", "connection", "en", "rc", "init", "CON", "Con", "ocon", "socket", "bc", "connect", "fa", "ran", "cl", "out", "cur", "conn", "Conn", "ver", "ctrl", "client", "don", "co", "web", "sub", "login", "fun", "can", "pc", "c", "exec", "file", "re", "fc", "ob", "cf", "clean", "ca", "close", "fe", "http", "on", "open", "com"], "encodedPassword": ["enoderPassword", "enodedpassword", "encodedData", "encoderPass", "enccodedPass", "encapedData", "Encryptedpassword", "encryptedData", "encoderPassword", "encapedPass", "encoderData", "EncodedPass", "Encodedpassword", "enodedPassword", "EncryptedPass", "encapedpassword", "enccodedpassword", "encapedPassword", "EncodedSecret", "EncodedPassword", "enodedData", "encoderSecret", "enodedPass", "encryptedPassword", "EncryptedPassword", "enoderPass", "encryptedPass", "encodedPass", "EncryptedSecret", "enoderpassword", "enoderData", "encryptedpassword", "encryptedSecret", "encodedpassword", "enccodedSecret", "enccodedPassword", "encodedSecret", "encoderpassword"], "encoder": ["decode", "enoder", "decoding", "enoded", "encode", " encoded", "Encode", "decoder", " encoding", "decoded", "enoding", "enode", "Encoded", "encoded", "Encoder", "encoding", " encode", "Encoding"], "in": ["ins", "url", "In", "b", "init", "io", "socket", "inc", "gin", "f", "input", "vin", "din", "IN", "lin", "inn", "out", "conn", "pass", "cin", "i", "rin", "win", "kin", "reader", "source", "is", "nin", "login", "inner", "bin", "c", "file", "pin", "ini", "as", "again", "isin", "cgi"], "fos": ["infose", "fis", "lfis", "dos", "fose", "Foos", "fOS", " faos", "boes", "Fos", " foos", "foos", "foses", "faos", "infos", "Foss", "bis", "daos", "bos", "infoos", "infoses", "infoss", " foses", " fOS", "infOS", " fose", " foss", "Faos", "Foses", "doss", "doses", "bOS", " fis", "Fose", "foss", "lfoes", "foes", "FOS", "lfos", "lfOS", " foes"], "bout": ["bbouter", "bouts", "bio", "fio", "fin", "fout", "Bio", "bbio", "fouts", "b4", "bbin", "Bout", "bcache", "bbout", " bin", "fouter", "bOut", " bio", "bbouts", " bOut", " b4", "Bcache", "bbcache", " bouter", "bbOut", "bin", "bouter", "Bin", " bouts", "bb4", "BOut", " bcache", "f4"], "data": ["DATA", "sample", "partial", "pad", "message", "image", "one", "length", "body", "info", "raw", "part", "result", "zip", "input", "d", "dat", "batch", "read", "bytes", "key", "i", "memory", "reader", "size", "media", "number", "div", "address", "string", "cache", "video", "alpha", "start", "xxx", "next", "response", "xxxx", "content", "buffer", "value", "zero", "feed", "block"], "x": ["m", "pe", "ex", "u", "z", "X", "rx", "b", "n", "en", "num", "lex", "xy", "tx", "pos", "no", "f", "index", "d", "val", "code", "wx", "i", "y", "max", "size", "xp", "width", "xx", "dx", "xi", "number", "fx", "xc", "id", "my", "v", "wa", "c", "xs", "t", "w", "ix", "xxx", "ww", "p"], "lastIteraction": ["lastExecate", "lastIterAction", "lastExecation", "prevGenerATION", "lastGeneration", "prevIterAction", "lastGenerAction", "prevIterate", "prevGenerate", "lastGenerate", "lastIterate", "prevIterATION", "lastExecATION", "prevGeneration", "lastExecAction", "lastIteration", "lastGenerATION", "lastIterATION", "prevIteration", "prevGenerAction"], "e": ["pe", "ee", "u", "esi", "one", "se", "b", "g", "n", "event", "ge", "this", "ie", "no", "f", "it", "es", "edge", "oe", "ise", "o", "d", "ae", "error", "me", "type", "s", "element", "i", "ze", "a", "ne", "er", "E", "r", "ure", "c", "ke", "be", "re", "t", "ite", "or", "fe", "exc", "p", "ception"]}}
{"id1": "13122204", "id2": "22264586", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["unpackModel", "UnzipModel", "unzipProject", "UnarchiveModel", "UnarchiveFile", "unpatchFile", "unarchivemodel", "Unzipmodel", "unarchiveFile", "UnzipProject", "Unarchivemodel", "unpatchmodel", "unpackFile", "unarchiveModel", "unpatchModel", "unzipmodel", "unpackProject", "unpatchProject", "unzipFile", "UnarchiveProject", "UnzipFile", "unpackmodel", "unarchiveProject"], "filename": ["File", "folder", "model", "module", "download", "src", "l", "utf", "string", "txt", "files", "fd", "path", "kl", "fil", "Filename", "source", "uri", "SourceFile", "fp", "FILE", "il", "nil", "name", "title", "file", "fn", "username", "database", "fits", "bf", "jet", "loc", "location", "f", "url", "directory"], "tempdir": ["tempath", "TempDir", "tmpdirectory", "tmppath", "temdirectory", "temDir", "TempDIR", "tmpdir", "tempDir", "tmpDir", " tempdirectory", "tmpfolder", "tempdirectory", " tempfolder", "tempDIR", "Tempdirectory", "temfolder", "Tempdir", "temppath", " tempDIR", " tempDir", "tmpDIR", "Tempfolder", "tempfolder", "temdir", " temppath"], "dest": ["folder", "log", "wb", "die", "de", "tar", "temp", "nt", "cont", "walker", "done", "default", "inner", "dc", "dat", "transform", " Dest", "trans", "target", "src", "zip", "sync", "output", "later", "ui", "sup", "home", "comb", "txt", "builder", "usr", "exit", "walk", "export", "dist", "store", "cdn", "session", "st", "handler", "result", "opt", "proc", "flat", "prop", "rest", "dir", "std", "tmp", "test", "Dest", "file", "transfer", "gen", "desc", "delete", "di", "loc", "source", "obj"], "fis": ["filebis", "flisa", "flis", "fbis", " fid", "fsiss", "liss", "fi", "fileis", " fi", "lis", "li", "flbis", "fileid", "fid", "filei", " fiss", "fsisa", "lid", "fisa", "fliss", "fiss", "fsbis", "fileisa", "fsis", "fileiss"], "BUFFER": ["MAPER", " BUFER", " BUFIX", "CUVER", "CUVEN", "TAFFER", " BUUCK", "BUFIX", " BUPER", "SAVER", "TAPER", "BUPER", " BUVER", "TAUCK", "UPFF", "SAFFER", "BOFFER", "MAFIX", "BOFER", "SAPER", "UPVER", "SAUCK", "BOPER", "UPVEN", "TAVER", "BOFIX", "CUFFER", "MAFFER", " BUVEN", "MAFER", "BUFER", "CUUCK", "BUUCK", "CUFF", "BUFF", "UPFFER", " BUFF", "BUVER", "BUVEN", "CUPER"], "zis": ["jis", " ziss", " zisa", "zos", "zists", "jists", "yIS", " zIS", "zbis", "diss", "yis", "yin", "dis", " zas", "zin", "xii", " zbis", "zisa", " zii", "xbis", "zipins", "xists", "dbis", "Zisa", "xi", " zists", " zi", "Zis", "Zas", "zas", "zipas", "ji", " zos", "zipisa", "zi", " zin", "zins", "zipin", "xos", "zipIS", "zipis", "zIS", "jos", "yisa", " zins", "dii", "ziss", "xis", "xiss", "Zins", "zii"], "entry": ["ident", "image", "ou", "de", "lc", "her", "module", "nt", "feed", "end", "inner", "je", "ry", "match", "zip", "Entry", "info", "cat", "element", "pe", "cel", "ace", "spec", "rc", "next", "way", "li", "ie", "source", "part", "line", "record", "result", "ent", "se", "si", "porter", "row", "ce", "la", "pack", "name", "ge", "archive", "server", "file", "ries", "jo", "e", "valid", "id", "iterator", "reader", "enter", "or", "connection", "inc"], "count": ["_", "log", "index", "base", "in", "feed", "end", "coll", "current", "val", "write", "add", "cache", "key", "use", "list", "b", "writer", "read", "code", "pos", "c", "buffer", "core", "next", "ind", "line", "type", "part", "counter", "allow", "len", "number", "length", "start", "size", "name", "sum", "low", "file", "id", "weight", "e", "limit", "cond", "last", "i", "Count", "iter", "time", "f", "max"], "data": ["image", "body", "index", "base", "raw", "feed", "content", "dat", "format", "input", "write", "alpha", "load", "message", "media", "bytes", "info", "read", "pos", "array", "buffer", "next", "d", "DATA", "shift", "record", "result", "len", "number", "block", "length", "size", "start", "name", "pack", "la", "a", "id", "str", "zero", "reader", "value", "batch"], "fos": ["dfops", " fops", "fOS", "afops", " foos", " foes", "bops", "bos", "afis", "afos", "afOS", "dfoes", "dfos", "dfoos", "foes", "xops", "bis", "foos", "xoos", "fops", "xos", "xoes", " fOS", "bOS"]}}
{"id1": "324679", "id2": "16621503", "code1": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "code2": "    public static ArrayList<String> loadURLToStrings(URL url, int maxLines, String userAgent, int timeout) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (userAgent != null && userAgent.trim().length() > 0) {\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n        } else {\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (compatible; astrominer/1.0;)\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n        }\n        connection.connect();\n        return loadURLToStrings(connection, maxLines);\n    }\n", "label": 0, "substitutes": {"import_hints": ["import_hins", "import_vits", "import2hint", "import_shints", "import_pints", "import2hints", "import_vints", "import_pint", "import_hint", "import_vins", "import_vint", "import2shits", "import_shits", "import2hins", "import_hits", "import2hits", "import_shins", "import2shint", "import_pits", "import_pins", "import2shins", "import_shint", "import2shints"], "filename": ["that", "Filename", "rl", "files", "username", "title", "sheet", "il", "directory", "File", "metadata", "json", "phrase", "sf", "location", "path", "fp", "params", "FILE", "fn", "file", "which", "kn", "f", "prefix", "nil", "login", "download", "wl", "fil", "database", "kl", "SourceFile", "document", "name", "figure", "string", "href", "utf", "uri", "source", "length", "dll", "txt"], "pieceId": ["ieceid", "towerName", "ieceID", "pieId", "blockName", " pieceCount", "pieid", "componentType", "caseName", "pocketID", "pageId", "pieID", "pocketId", "caseID", "pieceid", "towerId", "pageID", "componentid", "caseid", "pieceID", "quoteID", " pieceid", "caseId", "componentCount", "componentId", "pieceName", "blockId", "quoteid", " pieceID", " pieceType", "componentID", "pageType", " pieceName", "blockID", "pieceCount", "pocketid", "towerid", "towerID", "quoteName", "blockid", "pieceType", "quoteId", "ieceCount", "ieceId", "pageid"], "i": ["ai", "ip", "j", "p", "ie", "eni", "is", "key", "multi", "fi", "slice", "phi", "id", "ci", "gi", "loc", "ui", "info", "zi", "li", "index", "ii", "io", "ori", "iu", "line", "ini", "uni", "bi", "end", "x", "pi", "f", "start", "xi", "ti", "ri", "u", "ni", "ji", "mi", "oi", "it", "di", "l", "hi", "si", "chi", "qi", "uri", "I", "c"], "col": ["cal", "flo", "left", "pos", "block", "cel", "cell", "view", "character", "year", "cat", "Col", "section", "lc", "cy", "core", "coll", "loc", "group", "index", "num", "cur", "cor", "city", "con", "count", "fc", "x", "ch", "channel", "keep", "offset", "foot", "collection", "cl", "ct", "pixel", "width", "co", "COL", "c", "month", "field", "separ", "win", "column", "length", "inc"], "row": ["r", "grow", "position", "ner", "ow", "pos", "block", "key", "cell", "view", "order", "rc", "ro", "slice", "year", "height", "ry", "page", "coll", "loc", "group", "right", "index", "cur", "num", "our", "rr", "line", "step", "x", "hour", "range", "rel", "offset", "w", "rows", "wheel", "round", "stroke", "month", "tr", "roll", "Row", "column", "length"], "rotation": ["reloration", " rotion", "coloration", "relate", "rotion", "Rototation", " rotoration", "relation", " rototation", "polotation", "Rotation", "orientotation", "Rotating", "polating", "Rotion", "poloration", "polation", "colate", "Rotoration", "polion", "orientation", "colation", "rotate", "rotoration", " rotating", " rotate", "relating", "colating", "orientate", "Rotate", "rotating", "rototation", "orientoration", "polate"], "number": ["position", "Number", "size", "ner", "shape", "note", "n", "numbered", "phone", "amount", "key", "object", "nn", "year", "version", "reference", "section", "page", "source", "span", "division", "code", "num", "message", "resource", "zero", "work", "change", "line", "step", "maximum", "book", "part", "x", "area", "letter", "no", "null", "unit", "none", "type", "language", "other", "width", "total", "name", "counter", "string", "resolution", "network", "outer", "layer", "length", "umber", "non"], "temppiece": ["memppiece", "timphart", "tempoart", "templence", "temppedrice", "temptence", "timppoint", "timppart", "temppart", "templpiece", "temploint", "templrice", "temspiece", "templacket", "tempplruit", "temppedawn", "tempopiece", "typtacket", "temppell", "tempiece", " temppore", " tempppiece", "temppaint", "temphoint", "temppedell", "typpiece", "temptacket", "tempoore", "memppedrice", "typpacket", "temppprice", "temppence", "temptaint", "temprice", "temspence", "tempperuit", "memppediece", "memppell", "typpaint", "typtiece", "temppeiece", "tempoiece", "temphell", " tempore", "temppacket", "temphrice", "temppliece", "temppawn", "temppedruit", "temppedoint", " tempiece", "temphiece", "tempppawn", "timphoint", "templore", "temppruit", "templruit", "templell", "typpence", "memppedell", "timphrice", "mempprice", "temppeawn", "tempplrice", "temppore", "templiece", "templaint", "typtence", "timppiece", "tempooint", "typtaint", "temspaint", "tempppiece", "timphiece", "tempppruit", "memppedoint", "templawn", "temppediece", "tempore", "temphart", " tempprice", "temptiece", "timpprice", "memppoint", "temppoint", "temspacket", "tempprice", " temprice", "templart", "temporice", "tempperice", "tempplawn"], "lineread": ["lindata", "linread", "Lineread", "lineRead", "lineload", " lineRead", "LINEreader", "rowread", "rowload", "linedata", "ledata", "Linedata", "linebreak", "blockwrite", "linwrite", "leload", " linereader", "Linebreak", "Linereader", "linRead", " linewrite", "rowwrite", "rowreader", "filereader", "linekey", "leRead", " lineload", "LINERead", "leread", "fileread", "linereader", "blockread", "LINEread", " linedata", "blockreader", "linbreak", "linkey", "filekey", "linreader", "blockload", "linewrite", "blockbreak", "rowkey", "linload", "rowbreak", "Linewrite", "filebreak", " linebreak"], "tok": ["protoke", "atik", " tak", "etract", "untang", "ttoca", "Tak", " toks", " toko", "toololl", "tik", "ataken", "antok", "protore", "itook", "etok", "artok", "otoca", "toolok", "ttik", "itoker", "utoker", "utoken", "utunk", "antoke", "protaken", " taken", "toca", "took", "Tok", "Tock", "toko", "theaken", "tract", "tore", "artoll", " tock", "Token", "otunk", "ttoks", "ttak", "Toks", "artoke", "ttock", "etaken", "toker", "itok", "itorp", "itoken", "untoker", "tunk", "untok", "Toca", "tock", "utorp", "antract", "utok", "itunk", "utang", "atoks", "ttoke", "ttaken", " tract", "taken", "itang", "toke", "ttract", "utook", "ttoken", "untoken", "otok", "theore", "tak", "otook", "etoko", "toks", "theoke", "otoken", "toll", "antoll", "theok", "ttoko", "ttore", "toolract", "artract", "torp", "atok", "otorp", "otak", "token", "protok", "ttok", "tang", " tik", "tooloke"], "entree": ["etrain", "Entrie", "ettree", "artreen", "Entree", "settrees", "artee", "Entode", "etee", "ntrain", "Entrain", "entlock", "etree", "Enttree", "etreen", "settree", "Entlock", "ntrie", "ntee", "ntree", "enttree", "entrie", "entrees", "antrees", "settode", "Entee", "antrue", "ntlock", "entrue", "etrie", "antree", "Entrees", "entode", " entrain", "antode", "Entrue", "settrue", "entee", "artree", "artrie", "ntreen", " entlock", "entreen", "nttree", "entrain", " entrie"], "byurl": ["orfile", "orstr", "orURL", "viaURL", " byfile", "viafile", "orurl", "byfile", "viastr", "Byfile", " byURL", "ByURL", "byURL", "viaurl", "bystr", "Byurl", " bystr", "Bystr"], "url": ["image", "blog", "fr", "sl", "ul", "stream", "key", "feed", "user", "ls", "id", "page", "server", "bel", "open", "connection", "http", "hub", "URL", "resource", "pull", "ob", "ssl", "file", "link", "f", "Url", "base", "plug", "update", "gl", "loader", "log", "ll", "l", "browser", "string", "web", "ur", "uri", "source", "www"], "in": ["r", "image", "client", "fr", "n", "inn", "stream", "gin", "is", "socket", "input", "din", "a", "inner", "resource", "out", "con", "ini", "fc", "file", "part", "f", "serv", "login", "data", "ac", "err", "b", "ins", "bin", "In", "ar", "body", "IN", "reader", "as", "win", "source", "c", "inc"]}}
{"id1": "16820041", "id2": "16549995", "code1": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "code2": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"encodePassword": ["encodeString", "enodePassword", "enodedPassword", "enccodepassword", "encodepassword", "enoderSecret", "enodedpassword", "enccodeString", "enodedString", "enoderpassword", "enodeSecret", "enccodePassword", "enoderPassword", "enodeString", "enccodeSecret", "enodedSecret", "enodepassword", "enoderString", "encodeSecret"], "_originalPassword": ["_Originalpassword", "_OriginalPass", " _actualPassword", "_actualPass", "theoriginalpassword", "_encryptedPass", "theorigPass", "_originalPass", "theorigpassword", "_OriginalPassword", "_originalSalt", "_actualSecret", "theorigPassword", "_encryptedPassword", "_encryptedpassword", "theoriginalSalt", "theoriginalPass", "_editedPass", " _originalSecret", "_origSalt", "_origpassword", " _actualSecret", "_OriginalSalt", "_originalSecret", "_editedPassword", " _actualPass", "_actualPassword", "_origPassword", "theorigSalt", " _originalPass", "_originalpassword", "theoriginalPassword", "_encryptedSalt", "_origPass", "_editedSecret", "_OriginalSecret"], "md": ["mand", "hm", "alg", "mm", "mp", "mod", "amd", "Cmd", "pad", "hash", "dig", "cmd", "dm", "mb", "meta", "mg", "sd", "data", "m", "ph", "ad", "metadata", "mad", "mac", "sm", "ms", "vd", "code", "kg", "pd", "sha", "gd", "dr", " MD", "gb", "ld", "od", "dd", "mn", "cm", "mo", "mt", "hd", "cd", "MD", "dh", "mc", "ma", "df", "id", "mag", "pm", "db", "d", "bd", "dc"], "encodedPassword": ["encapedPassword", "encodedSecret", "encoderPassword", "encoredSecret", "ecodedPassword", "encodedString", "ecodedSecret", "enccodedpassword", "encoderpassword", "enodedPassword", "encachedString", "encapedPass", "encryptedString", "enoderSecret", "ecryptedPassword", "encapedpassword", "enoderPass", "enryptedpassword", "enodedpassword", "encoredPassword", "encryptedSecret", "enryptedString", "encryptedPass", "enodedString", "encryptedPassword", "encoderString", "encodedPass", "ecodedString", "enoderpassword", "enodedPass", "encidedPassword", "encoredString", "encidedPass", "enryptedPass", "enryptedPassword", "enccodedSecret", "encapedString", "enoderPassword", "encidedSecret", "enccodedPass", "encoderPass", "ecryptedSecret", "encachedSecret", "encidedpassword", "ecryptedString", "enccodedPassword", "enodedSecret", "encodedpassword", "encoderSecret", "encryptedpassword", "encachedPassword"]}}
{"id1": "18374478", "id2": "17729554", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 0, "substitutes": {"updateUser": ["createUsers", "updateRole", "editUsers", " updateMember", "addUsers", "addUser", "deleteRole", "updateuser", "editUser", "deleteUsers", "updatedWord", "updateUsers", "deletePassword", " updateAccount", "createRole", "adduser", "deleteMember", "UpdateUsers", "deleteUser", "editRole", "updatedUsers", "updatePassword", " updateUsers", "updatedUser", "updateMember", "addWord", "updateduser", "editAccount", "deleteWord", "UpdatePassword", "deleteuser", " updateWord", "updateWord", "UpdateWord", " updatePassword", "createAccount", " updateRole", "updateAccount", "UpdateRole", "createUser", "UpdateUser", "Updateuser", "UpdateMember", " updateuser"], "user": ["job", "account", "match", "client", "self", "app", "p", "creator", "User", "full", "author", "profile", "you", "object", "use", "view", "USER", "ro", "character", "instance", "version", "bug", "used", "parent", "page", "rule", "server", "per", "group", "module", "result", "connection", "ver", "content", "response", "resource", "message", "pool", "manager", "row", "str", "post", "this", "null", "model", "session", "data", "update", "system", "contact", "log", "users", "record", "name", "auth", "me", "site", "member", "plugin", "project", "string", "custom", "current", "person", "config", "username"], "conn": ["ha", "db", "pt", "client", "connect", "ca", "Conn", "h", "sync", "ctx", "n", "oss", "cond", "cp", "host", "rc", "cn", "cc", "pg", "el", "socket", "ou", "cat", "cr", "cli", "nt", "ci", "core", "coll", "cache", "server", "cb", "ann", "loc", "reg", "connection", "nc", "dc", "ob", "cm", "pool", "con", "conf", "uc", "part", "pub", "util", "col", "ch", "enc", "serv", "exec", "sql", "url", "close", "ac", "api", "log", "org", "ct", "pc", "co", "mc", "sth", "Connection", "lock", "act", "config", "c", "pr", "ec"], "autoCommit": ["autoDebmit", " autoDebitting", "autoCommits", "autoBlIT", "autoRebit", "automaticCommit", "autoComend", "autoCommite", "autoComIT", "autoDebend", " autoCommite", "automaticCommmit", "autoComite", " autoCommitting", "autoDebits", "autoAbit", "autoBlend", "automaticDebmit", " autoComite", " autoDebmit", "autoCommend", " autoCommmit", "autoDebit", "autoCommmit", "autoCit", "autoCmit", "autoRebite", "autoCommited", " autoComits", "autoComit", "autoDebitting", "autoDebIT", " autoCommits", "autoAbmit", " autoCommited", "autoCommitting", "autoComits", "autoCommIT", "autoBlmit", "automaticCommend", "autoDebited", "autoDebite", "automaticDebend", "autoCited", " autoComit", "automaticCommIT", "automaticDebIT", " autoDebited", "autoBlit", "autoAbitting", " autoDebit", "autoCitting", "autoRebits", "automaticDebit", "autoAbited"], "deleteRoles": ["deleteGrols", "deleteRooles", "deleteNols", "insertRoases", "deleteColes", "deleteRodes", "deleteSlases", "deleteRole", "insertRases", "deleteCodes", "delLole", "insertRooles", "deleteGroles", "deleteRoases", "insertRoules", "deleteLole", "deleteDoots", "deleteDases", "deleteNoles", "delLases", "deleteRoole", "delRodes", "delLodes", "insertRules", "destroyRols", "delRoles", "deleteCole", "deleteRoots", "deleteSloles", "deleteLoles", "destroyNoots", "destroyNols", "deleteNoots", "deleteRsole", "deleteNils", "deleteRsases", "deleteRases", "deleteRils", "deleteRsoles", "deleteCases", "deleteSlodes", "deleteDils", "deleteSlole", "destroyRils", "deleteRules", "deleteDole", "insertRole", "delRole", "deleteGroots", "destroyNoles", "destroyRoles", "deleteRoules", "deleteLases", "deleteDoles", "deleteDols", "deleteRsules", "delLoles", "deleteGrils", "destroyNils", "insertRoole", "deleteRols", "delRases", "destroyRoots", "deleteLodes", "deleteDules"], "insertRoles": ["insertGows", "insertSloots", "updateRols", "insertRsules", "copyRules", "copyGules", "insertRanges", " insertRules", "deleteSloles", "insertRows", "insertShole", "deleteRanges", "deleteSlodes", "insertLows", "deleteSloots", "insertRoots", "insertGules", "insertSloles", "copyRows", "insertLols", " insertShole", "insertGoots", "deleteRodes", " insertShodes", "insertSoles", "updateLoles", "insertRodes", " insertRole", "deleteRoots", "insertSlanges", "copyGoots", "updateLles", "insertSodes", "insertRsanges", "insertLules", "updateLols", "insertShodes", "insertRsows", "insertLles", "insertRles", "insertShules", "copyRoots", "insertGoles", "insertRules", "updateRles", "copyGoles", "insertRsoles", "copyRoles", "insertRsles", "insertSole", "deleteSlanges", "insertSules", "insertRols", " insertRodes", "insertLoots", "updateLules", "updateRules", "copyGows", "insertSholes", "insertSlodes", "insertRsodes", " insertShules", " insertSholes", "updateRoles", "insertLoles", "insertRole", "insertRsoots", "insertRsols"], "role": ["error", "de", "service", "Role", "one", "entry", "rl", "label", "tool", "key", "relation", "profile", "guard", "ro", "repl", "roller", "ole", "rol", "slave", "route", "rule", "val", "to", "group", "alias", "or", "module", "resource", "zone", "function", "row", "link", "base", "type", "range", "shadow", "tag", "force", "l", "member", "string", "le", "username"]}}
{"id1": "8778962", "id2": "23666867", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "14794404", "id2": "19206412", "code1": "    private String encryptPassword(String password) throws NoSuchAlgorithmException {\n        StringBuffer encryptedPassword = new StringBuffer();\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.reset();\n        md5.update(password.getBytes());\n        byte digest[] = md5.digest();\n        for (int i = 0; i < digest.length; i++) {\n            String hex = Integer.toHexString(0xFF & digest[i]);\n            if (hex.length() == 1) {\n                encryptedPassword.append('0');\n            }\n            encryptedPassword.append(hex);\n        }\n        return encryptedPassword.toString();\n    }\n", "code2": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encryptPassword": ["encryptSecret", "EncipherPassword", "EncryptPassword", "encryptString", "encryptedpassword", "EncipherSecret", "Encryptpassword", "encipherSecret", "EncipherString", "encressString", "encryptpassword", "encressPassword", "encipherPassword", "Encipherpassword", "encressSecret", "encipherString", "encresspassword", "EncryptSecret", "EncryptString", "encipherpassword", "encryptedSecret", "encryptedString"], "password": ["resource", "pass", "attribute", "token", "username", "words", "sword", "description", "string", "cache", "channel", "word", "secret", "input", "Password", "PASS", "path", "params", " passwords", "database", "email", "wd", "content", "object", "address", "p", "connection", "device", "prefix", "phrase", "definition", "array", "enc", "data", "message", "pattern", "buffer", "crypt", "text", "name", "padding"], "encryptedPassword": [" encryptedpassword", "ryptedpassword", "lockedPassword", "encryptedpassword", "protectedpassword", "protectedPass", "encryptedCode", "ryptedPass", " encryptedCode", "protectedCode", "ryptedPassword", "ryptedString", " encryptedPass", "lockedPass", "encryptedPass", "lockedpassword", " encryptedString", "ryptedCode", "protectedString", "encryptedString", "protectedPassword", "lockedString"], "md5": ["MD2", "MD5", "MD6", " MD3", " mddown", " md6", "mddown", "md2", " md3", "MDdown", "dig45", "dig4", " md4", "md4", "dig5", " md2", " MD5", "dig3", "md6", "amd6", "amd4", "MD45", "md512", "MD4", " MD2", " md512", "MD512", "amd2", "md45", "md3", "dig2", " MD512", "MD3", "amd5", "digdown", " md45"], "digest": ["mdment", "mdash", "encment", "Digace", "mdest", " digher", " digests", "Digester", "mdested", "Digested", "signest", "digested", "digester", "digace", "digenge", " digester", "Digenge", "Digher", "signester", "digment", "mdests", "mdace", " digash", "signests", " digenge", "signested", " digace", "Digests", "mdenge", "mdester", "digests", "mdher", "Digest", "encester", "digash", " digment", "digher", "encash", "encest"], "i": ["hi", "si", "qi", "ip", "u", "multi", "k", "ii", "c", "pi", "o", "d", "ci", "di", "io", "ui", "length", "ri", "bi", "ie", "p", "it", "l", "phi", "s", "j", "I", "x", "index", "f", "e", "oi", "li", "h", "v", "gi", "ti", "ai", "r", "b", "zi", "t", "id", "xi", "uri", "ix"], "hex": ["temp", "ctr", "ip", "nexus", "zip", "string", "utf", "rh", "ex", "exp", "ix", "shift", "str", "pixel", "bin", "stick", "di", "bits", "char", "none", "bit", "slice", "num", "length", "coord", "letter", "lit", "alpha", "oct", "prefix", "pex", "mix", "enc", "comp", "serial", "rex", "sex", "hash", "check", "closure", "ext", "data", "digit", "null", "pack", "buff", "id", "pattern", "sign", "binary", "text"]}}
{"id1": "23666973", "id2": "5759961", "code1": "    private InputStream openStreamRaw(String filename) {\n        InputStream stream = null;\n        if (filename == null) return null;\n        if (filename.length() == 0) {\n            return null;\n        }\n        try {\n            URL url = new URL(filename);\n            stream = url.openStream();\n            return stream;\n        } catch (MalformedURLException mfue) {\n        } catch (FileNotFoundException fnfe) {\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        ClassLoader cl = getClass().getClassLoader();\n        stream = cl.getResourceAsStream(\"data/\" + filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        stream = cl.getResourceAsStream(filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        return stream;\n    }\n", "code2": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "label": 0, "substitutes": {"openStreamRaw": ["openstreamSource", "openFileAsync", "createSteamRaw", "createSteamAsync", "openstreamRaw", "createStreamSource", "openstreamAsync", "openStreamInternal", "openFileInternal", "openstreamInternal", "openStreamSource", "createStreamRaw", "openSteamInternal", "createSteamInternal", "openSteamSource", "openSteamAsync", "openSteamRaw", "openFileSource", "createStreamAsync", "openFileRaw", "createStreamInternal", "createSteamSource", "openStreamAsync"], "filename": ["resource", "txt", "il", "class", "subject", "username", "fax", "n", "string", "SourceFile", "href", "utf", "lua", "word", "jpg", "sf", "title", "Filename", "actual", "path", "kn", "fd", "fil", "database", "ppa", "length", "download", "sql", "rl", "fn", "sound", "l", "prefix", "ename", "phrase", "location", "license", "size", "loader", "f", "FILE", "undle", "dll", "password", "journal", "fp", "login", "nil", "directory", "data", "acl", "kl", "wl", "uri", "source", "src", "name", "which", "file"], "stream": ["resource", "stage", "full", "current", "rest", "view", "http", "log", "pair", "impl", "valid", "w", "port", "sl", "pool", "image", "socket", "draft", "ssl", "parent", "body", "file", "clean", "continue", "feed", "slice", "length", "steam", "video", "model", "cur", "thread", "value", "output", "null", "message", "iv", "hook", "row", "pull", "live", "class", "channel", "instance", "host", "transform", "open", "sync", "content", "trans", "upload", "coll", "load", "size", "f", "enc", "callback", "uc", "reader", "raw", "stack", "loop", "client", "cont", "temp", "accept", "zip", "string", "context", "method", "input", "response", "path", "download", "object", "child", "sample", "sw", "Stream", "event", "server", "control", "session", "wrapper", "through", "result", "bb", "back", "source", "buffer", "form", "ream", "core"], "url": ["resource", "line", "string", "channel", "http", "www", "URL", "path", "ll", "api", "feed", "Url", "loc", "rel", "l", "base", "server", "plug", "coll", "loader", "sl", "f", "e", "ul", "el", "image", "lib", "page", "ssl", "data", "fl", "b", "id", "web", "source", "uri", "name", "file"], "cl": ["ctrl", " CL", "class", "ml", "sh", "c", "col", "pl", "ll", "con", "ctx", "sc", "gl", "ct", "client", "scl", "loc", "bl", "cc", "l", "cr", "comb", "ocl", "decl", "pe", "ls", "coll", "shell", "loader", "bc", "sl", "cli", "hell", "cle", "el", "lib", "uc", "Cl", "ssl", "fl", "acl", "kl", "ec", "sel", "lock", "CL", "cont", "cel", "lc"], "cn": ["dc", "cdn", "arn", "auc", "nic", "cm", "ain", "act", "n", "uh", "ca", "abc", "cone", "Ns", "dn", "kn", "con", "xc", "ains", "bn", "cf", "ct", "wcs", "conn", "fn", "kin", "cr", "cc", "nat", "mc", "net", "mn", "coll", "sn", "gin", "enc", "ns", "CN", "gn", "hn", "cb", "rn", "ae", "ln", "nam", "cy", "nc", "ec", "jc", "icon", "CA", "core", "lc", "CW"]}}
{"id1": "18793482", "id2": "7425022", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"modifyApplicationMessage": ["modifyapplicationmessage", "modifyApplicationMsg", "modifyApplicationContent", "modifiedApplicationMessage", "modifyAppContent", "modifiedapplicationMessage", "modifyapplicationContent", "modifiedApplicationContent", "modifiedApplicationMsg", "modifyExternalMessage", "modifyapplicationMessage", "modifiedapplicationContent", "modifyExternalmessage", "modifyAppMsg", "modifyapplicationMsg", "modifyExternalMsg", "modifiedapplicationMsg", "modifiedapplicationmessage", "modifyExternalContent", "modifiedApplicationmessage", "modifyApplicationmessage", "modifyAppmessage", "modifyAppMessage"], "locale": ["localales", "locationale", "localALE", "placeame", "localue", "localame", "locame", "localator", "locator", "localale", "placeALE", "locales", "Locator", " locator", "locue", "Locales", "Locame", "locationales", " locame", "LocALE", "Locale", "placeales", "placeale", "locationue", " locales", "Locue", "locALE", "locationALE"], "messageName": ["reasonValue", "msgKey", "phraseType", "MessageKey", "messagename", "MessageValue", "msgName", " messagename", "msgType", "reasonname", "MessageName", "MessageType", "Messagename", "messageType", "phraseValue", "reasonType", "msgValue", "reasonName", "phraseKey", "messageKey", " messageType", " messageKey", "phraseName"], "messageValue": ["messageVal", " messageVal", "MessageValue", "msgName", "MessageVal", "msgType", "MessageName", "MessageType", "responseName", "responseVal", "messageType", "msgValue", "responseType", "msgVal", " messageType", "responseValue"], "properties": ["prop", "Property", "data", "options", "py", "perties", "settings", "ips", "xml", "Pro", "conf", "txt", "ops", " props", "api", "stats", " Properties", "property", "config", "ps", "metadata", "params", "pro", "resources", "json", "obj", "pb", "tmp"], "i18nPath": ["i11fCorp", "i32ninUrl", "i18fUrl", "i18nFile", "i18napath", "i18nsFile", "i18onLocation", "i18bStr", "i32nUrl", "i18bPart", "i32nPath", "i18nepath", "i18nStr", "i18fPath", "i18onPath", "i18ninUrl", "i16npath", "i16nsPart", "i11fUrl", "i18npath", "i16nPath", "i11fPath", "i18ninFile", "i32ninPath", "i18nsPath", "i32ninFile", "i32ninLocation", "i18nsUrl", "i11npath", "i11fpath", "i18neUrl", "i18nsCorp", "i18ninPath", "i16nsStr", "i16nsPath", "i18nLocation", "i18bPath", "i18naPath", "i16nPart", "i11nUrl", "i18fCorp", "i18nsLocation", "i18onFile", "i18naStr", "i18nCorp", "i11nPath", "i18nePath", "i18nspath", "i18naPart", "i18onUrl", "i18nUrl", "i18fpath", "i18ninLocation", "i18nPart", "i18nsPart", "i16nspath", "i11nCorp", "i32nLocation", "i18bpath", "i18nsStr", "i16nStr", "i32nFile", "i18neCorp"], "englishFile": ["propertiesPath", "propertiesFile", "ianaJar", " englishJar", "Englishfile", "EnglishFolder", "EnglishPath", "EnglishFiles", " englishPath", "englishPath", "propertiesfile", "ianaFile", "EnglishFile", " englishfile", "languageJar", "ianaDir", "englishJar", "examplefile", "englishFiles", "englishfile", "examplePath", "exampleFolder", "languageFiles", " englishFiles", "englishDir", "ianaPath", "languagefile", "exampleFile", " englishDir", "languagePath", "propertiesFolder", "englishFolder", "languageDir", "languageFile"], "propertiesFilePath": ["propertiesFilesUrl", "propertiesFileName", "propertiesFilesName", "propertiesDirpath", "propertiesSourceFilePath", "propertiesSourceFileURL", "pertiesfileURL", "propertiesFileUrl", "propertiesDirUrl", "propertiesfilePath", "propertiesFileURL", "propertiesFilespath", "pertiesfilepath", "pertiesFilepath", "pertiesfileName", "propertiesfileName", "propertiesSourceFilepath", "propertiesSourceFileName", "pertiesDirName", "propertiesfileURL", "propertiesfilepath", "pertiesDirpath", "propertiesFilesPath", "propertiesFilesURL", "pertiesfilePath", "pertiesDirPath", "pertiesFileURL", "pertiesDirUrl", "propertiesDirPath", "propertiesfileUrl", "propertiesDirName", "pertiesFileName", "pertiesFileUrl", "propertiesFilepath", "pertiesFilePath"], "file": ["lock", "le", "data", "name", "book", "language", "field", "letter", "binary", "class", "format", "die", "b", "single", "buffer", "source", "ile", "path", "h", "property", "url", "function", "module", "message", "resource", "directory", "it", "File", "socket", "handler", "play", "stream", "fe", "log", "page", "entity", "content", "zip", "or", "parent", "up", "folder", "php", "word", "use", "reader", "f", "p", "one", "model", "part", "show", "http", "FILE", "fp", "full", "connection", "force", "application", "base", "future", "text", "files", "l", "child", "filename", "object", "unit", "pe", "string", "media"], "in": ["reader", "bin", "isin", "sin", "er", "f", "login", "into", "it", "ri", "s", "ins", "pin", "p", "cin", "In", "inside", "kin", "b", "inner", "again", "rin", "win", "l", "r", "din", "IN", "err", "plus", "ini", "d", "i", "init", "image", "inc", "nin", "or", "n", "io", "inn", "ic", "lin", "input", "con", "gin"], "out": ["full", "bin", "ext", "f", "socket", "error", "s", "sync", "to", "p", "ex", "outs", "one", "plain", "part", "w", "b", "output", "again", "inner", "by", "r", "work", "err", "and", "o", "OUT", "i", "lib", "cli", "image", "inc", "builder", "outer", "exec", "v", "n", "io", "net", "up", "word", "co", "ou", "home", "exp", "Out", "string", "write", "end"], "c": ["x", "abc", "cur", "arc", "f", "char", "sc", "C", "ct", "p", "dec", "cont", "k", "enc", "ec", "pc", "rc", "lc", "b", "w", "size", "cr", "l", "r", "o", "esc", "ice", "dc", "d", "i", "pointer", "ci", "cc", "ch", "t", "cf", "uc", "h", "xc", "v", "character", "cl", "code", "n", "cu", "ce", "a", "con", "ac", "col", "bc", "cy"], "is": ["iter", "ais", "Is", "iss", "get", "si", "it", "ri", "does", "s", "ins", "stream", "info", "has", "str", "os", "isa", "IS", "its", "i", "isu", "api", "bis", "ui", "ir", "ps", "ris", "as", "iso", "id", "are", "es", "res", "us", "ios", "re", "serv", "ib"], "breader": ["feedamer", "breadler", "breadr", "feediter", " cakeER", "brewr", " cakeler", " Breader", "weber", " breadler", " Breadler", " cakeer", "breadER", " breaders", "brewiter", "feedr", " breadER", " BreadER", "webiter", " Breaders", "breaders", "webamer", "webr", "feeder", "brewer", " cakeers", "breadamer", "breaditer", "brewamer"], "line": ["le", "sl", "data", "name", "side", "error", "lo", "el", "body", "sync", "one", "str", "definition", "letter", "log", "rule", "status", "base", "inline", "page", "part", "text", "lc", "model", "liner", "section", "l", "cell", "key", "lines", "lf", "row", "comment", "style", "parse", "block", "entry", "feed", "value", "Line", "response", "phrase", "band", "lined", "character", "url", "no", "next", "plugin", "li", "code", "pass", "nl", "split", "LINE", "word", "message", "frame", "lin", "header", "item", "link", "day", "string", "write", "ip", "end", "look", "strip"], "strBuilder": [" strBuffer", " strbuilder", "brbuilder", "strBlock", "stringbuilder", "brBuffer", "stringBuilder", "strBuilding", "StrBlock", "stringBuffer", "stringBuilding", "StrBuilding", "brBuilding", "StrBuild", "stringBuild", " strBuilding", "StrBuffer", "StrBuilder", "brBuild", "strbuilder", "strBuffer", " strBlock", "brBlock", " strBuild", "Strbuilder", "brBuilder", "strBuild"], "pieces": ["cuts", "pages", "vals", "values", "pots", "blocks", "sections", "nets", "tips", "piece", "phones", "groups", "services", "cards", "ips", "forms", "cells", "items", "words", "parts", "planes", "circle", "bits", "features", "bytes", "files", "ops", "flows", "apps", "lines", "steps", "letters", "strings", "pins", "places", "packs", "marks", "rings", "tops", "objects", "lists", "names", "styles", "boxes", "keys", "split", "seconds", "bones"], "found": ["full", "missing", "required", "matched", "f", "loaded", "true", "fixed", "fl", " Found", "made", "got", "first", "created", "successfully", "fall", "identified", "not", "filled", "used", "find", "given", "letter", "all", "successful", "built", "old", "left", "l", "val", "based", "err", "changed", "lost", "updated", "printed", "expected", "normal", "Found", "count", "defined", "temp", "finding", "null", "search", "valid", "still", "result", "sent", "failed", "confirmed", "broken"]}}
{"id1": "16851955", "id2": "11032546", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "label": 1, "substitutes": {"testTrainingBackprop": ["testTrainingFrontprop", "testTrainBackdrop", "testTrainingFrontdrop", "testTrainingBACKpointer", "testTrainingBACKdrop", "testTrainingBackpointer", "testTrainingBACKpressure", "testTrainBACKpressure", "testTrainBackprop", "testTrainingFrontpointer", "testTrainBackpressure", "testTrainingBackpressure", "testTrainBACKprop", "testTrainBackpointer", "testTrainingBACKprop", "testTrainBACKdrop", "testTrainingBackdrop", "testTrainBACKpointer", "testTrainingFrontpressure"], "temp": ["folder", "txt", "wrap", "pipe", "local", "pdf", "container", "full", "zip", "clean", "cache", "current", "dat", "ex", "http", "input", "copy", "path", "io", "empty", "this", "dest", "form", "archive", "base", "out", "storage", "model", "tmp", "tem", "config", "fake", "f", "flat", "session", "emp", "writer", "v", "test", "output", "Temp", "data", "directory", "save", "stable", "porary", "mount", "parent", "buffer", "lock", "font", "cel", "file", "template"], "layers": ["lobs", " lients", "lowers", "slowers", "dlayers", "nlayers", "slays", "licikes", "placks", "Layers", "lasks", "backs", " languages", "lacks", "liayers", "slacks", "fllements", "planguages", "languages", "blayers", " lowers", "bowers", "players", "flasses", "lients", "lagers", "liacks", "liores", "gients", "lasses", " lays", "dlasks", "flanguages", "flayers", "liibraries", "likes", "licayers", "dlacks", "gayers", "Lobs", " likes", " lasks", "licagers", "bllements", " lobs", "Lients", "lores", "blanguages", "nlibraries", " lagers", "llements", "nlagers", "slayers", " libraries", "dlores", "licibraries", " lasses", "gobs", "lays", "nlikes", "plasks", "bays", "bayers", "libraries", "dlibraries", " lores", "dlanguages", " llements", " lacks", "blasses"], "fann": ["larn", "sfannon", "fain", "xfanny", "elfnn", "gana", "garn", "elfann", "fanny", "lnn", "fana", "fnn", "lann", "Fannon", "xfann", "xfannon", "lana", "xfain", "elfana", "sfann", "Fanny", "gann", "farn", "elfarn", "Fann", "gnn", "sfanny", "sfain", "Fain", "fannon"], "trainer": ["strainer", "tacker", "striner", "tracer", "rain", "Triner", "retacer", "traacer", "Tracker", "tracker", "triner", "stracker", "racker", "racer", "Trainer", "retiner", "traacker", "traainer", " tracker", "strayer", "rainer", "trayer", "stracer", " train", "tacer", "train", "retainer", "retayer", "trarain", " tracer", "trrain", "strain", "Tracer", "Trrain", "Trayer", "tainer"], "desiredError": ["desirableSize", "deservedOrder", "desciredError", "despectedProblem", "DesireException", "desidedFailure", "desizedException", "desiringError", "DesireSize", "reservedOrder", "desivedError", "desiredEvent", "descirederror", "desirableOrder", "desivedSize", "descidedFailure", "deservedError", "despectederror", "DesiredException", "reservedEvent", "resiredOrder", "desiredException", "despectedError", "descidederror", "resiredError", "desiringFailure", "designedError", "desiredFailure", "desciredFailure", "desizedSize", "descidedError", "desidedProblem", "DesiredSize", "designedOrder", "desivedException", "desirableEvent", "desirederror", "desireError", "resiredEvent", "desiredProblem", "descidedProblem", "desidedError", "desciredProblem", "despectedFailure", "desizedError", "DesiredError", "desirableError", "desiredOrder", "deservedEvent", "reservedSize", "desiredSize", "desireSize", "desireException", "DesireError", "desidederror", "desiringerror", "desiringProblem", "resiredSize", "deservedSize", "designedSize", "designedEvent", "reservedError"], "mse": ["fmce", "gmse", "fmte", "mce", " mSE", " mce", "gmge", "mte", "fmze", "Mte", "MSE", "Mze", "fSE", "fce", " mge", "fse", " mte", "mge", "gmSE", "Mse", "Mce", "fmse", "mze", " mze", "gmce", "fge", "Mge", "mSE"]}}
{"id1": "3375724", "id2": "22875895", "code1": "    public void importarEmissoresDosTitulosFinanceiros(File pArquivoTXT, Andamento pAndamento) throws FileNotFoundException, SQLException {\n        int numeroDoRegistro = -1;\n        Scanner in = null;\n        Statement stmtLimpezaInicialDestino = conDestino.createStatement();\n        String sql = \"TRUNCATE TABLE TMP_TB_EMISSOR_TITULO\";\n        stmtLimpezaInicialDestino.executeUpdate(sql);\n        sql = \"INSERT INTO TMP_TB_EMISSOR_TITULO(SIGLA, NOME, CNPJ, DATA_CRIACAO) VALUES(:SIGLA, :NOME, :CNPJ, :DATA_CRIACAO)\";\n        OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n        stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n        final int TAMANHO_DO_CABECALHO_DO_ARQUIVO = 0;\n        final int TAMANHO_DO_RODAPE_DO_ARQUIVO = 0;\n        final int TAMANHO_DOS_METADADOS_DO_ARQUIVO = TAMANHO_DO_CABECALHO_DO_ARQUIVO + TAMANHO_DO_RODAPE_DO_ARQUIVO;\n        final int TAMANHO_MEDIO_POR_REGISTRO = 81;\n        long tamanhoDosArquivos = pArquivoTXT.length();\n        int quantidadeDeRegistrosEstimada = (int) (tamanhoDosArquivos - TAMANHO_DOS_METADADOS_DO_ARQUIVO) / TAMANHO_MEDIO_POR_REGISTRO;\n        String registro;\n        String[] campos;\n        try {\n            in = new Scanner(new FileInputStream(pArquivoTXT), Constantes.CONJUNTO_DE_CARACTERES_DOS_ARQUIVOS_TEXTO_DA_BOVESPA.name());\n            int quantidadeDeRegistrosImportada = 0;\n            numeroDoRegistro = 0;\n            String vSIGLA, vNOME;\n            BigDecimal vCNPJ;\n            java.sql.Date vDATA_CRIACAO;\n            final int QTDE_CAMPOS = CampoDoArquivoDosEmissoresDeTitulosFinanceiros.values().length;\n            final String SEPARADOR_DE_CAMPOS_DO_REGISTRO = \",\";\n            final String DELIMITADOR_DE_CAMPOS_DO_REGISTRO = \"\\\"\";\n            while (in.hasNextLine()) {\n                ++numeroDoRegistro;\n                registro = in.nextLine();\n                stmtDestino.clearParameters();\n                registro = registro.substring(1, registro.length() - 1);\n                if (registro.endsWith(DELIMITADOR_DE_CAMPOS_DO_REGISTRO)) {\n                    registro = registro + \" \";\n                }\n                campos = registro.split(DELIMITADOR_DE_CAMPOS_DO_REGISTRO + SEPARADOR_DE_CAMPOS_DO_REGISTRO + DELIMITADOR_DE_CAMPOS_DO_REGISTRO);\n                int quantidadeDeCamposEncontradosIncluindoOsVazios = campos.length;\n                if (quantidadeDeCamposEncontradosIncluindoOsVazios != QTDE_CAMPOS) {\n                    throw new CampoMalDelimitadoEmRegistroDoArquivoImportado(registro);\n                }\n                vSIGLA = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.SIGLA.ordinal()];\n                vNOME = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.NOME.ordinal()];\n                String cnpjTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.CNPJ.ordinal()];\n                if (cnpjTmp != null && cnpjTmp.trim().length() > 0) {\n                    vCNPJ = new BigDecimal(cnpjTmp);\n                } else {\n                    vCNPJ = null;\n                }\n                String dataDaCriacaoTmp = campos[CampoDoArquivoDosEmissoresDeTitulosFinanceiros.DATA_CRIACAO.ordinal()];\n                if (dataDaCriacaoTmp != null && dataDaCriacaoTmp.trim().length() > 0) {\n                    int dia = Integer.parseInt(dataDaCriacaoTmp.substring(6, 8)), mes = Integer.parseInt(dataDaCriacaoTmp.substring(4, 6)) - 1, ano = Integer.parseInt(dataDaCriacaoTmp.substring(0, 4));\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    vDATA_CRIACAO = new java.sql.Date(calendario.getTimeInMillis());\n                } else {\n                    vDATA_CRIACAO = null;\n                }\n                stmtDestino.setStringAtName(\"SIGLA\", vSIGLA);\n                stmtDestino.setStringAtName(\"NOME\", vNOME);\n                stmtDestino.setBigDecimalAtName(\"CNPJ\", vCNPJ);\n                stmtDestino.setDateAtName(\"DATA_CRIACAO\", vDATA_CRIACAO);\n                int contagemDasInsercoes = stmtDestino.executeUpdate();\n                quantidadeDeRegistrosImportada++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportada / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoTXT.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = numeroDoRegistro;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            in.close();\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    private void readVersion() {\n        URL url = ClassLoader.getSystemResource(\"version\");\n        if (url == null) {\n            return;\n        }\n        BufferedReader reader = null;\n        String line = null;\n        try {\n            reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((line = reader.readLine()) != null) {\n                if (line.startsWith(\"Version=\")) {\n                    version = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Revision=\")) {\n                    revision = (line.split(\"=\"))[1];\n                }\n                if (line.startsWith(\"Date=\")) {\n                    String sSec = (line.split(\"=\"))[1];\n                    Long lSec = Long.valueOf(sSec);\n                    compileDate = new Date(lSec);\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"importarEmissoresDosTitulosFinanceiros": [" importarEmissoresDosTitulasF", " importarEmissoresDosTitULoFe", " importarEmissoresDosTitulof", " importarEmissoresDosTitularF", " importarEmissoresDosTitulosFe", " importarEmissoresDosTitULoF", " importarEmissoresDosTitULosf", " importarEmissoresDosTitULof", " importarEmissoresDosTitULosPF", " importarEmissoresDosTitularPF", " importarEmissoresDosTitULosF", " importarEmissoresDosTitularFe", " importarEmissoresDosTitULoPF", " importarEmissoresDosTituloF", " importarEmissoresDosTitulasf", " importarEmissoresDosTitulosPF", " importarEmissoresDosTitularf", " importarEmissoresDosTituloFe", " importarEmissoresDosTitulosF", " importarEmissoresDosTitulosf", " importarEmissoresDosTitULosFe", " importarEmissoresDosTituloPF", " importarEmissoresDosTitulasFe", " importarEmissoresDosTitulasPF"], "pArquivoTXT": ["pArquivDLS", "pArquivoBBT", "pArquivoQxt", "pArquivoBxt", "pArquivoOTEMP", "pArquivoDEXT", "pArquivoOTXT", "pArquivoDLS", "pArquivaTEXT", "pArquivoTTP", "pArquivoOTTP", "pArquivTXT", "pArquivoLxt", "pArquivoLBT", "pArquivoOTxt", "pArquivaFBT", "pArquivoBEMP", "pArquivoBXT", "pArquivoDBT", "pArquivaTxt", "pArquivDxt", "pArquivoDXT", "pArquivaFTP", "pArquivoFxt", "pArquivaFEMP", "pArquivoDxt", "pArquivoLLS", "pArquivaTBT", "pArquivaTXT", "pArquivaFxt", "pArquivoTxt", "pArquivoBLS", "pArquivoFXT", "pArquivoQXT", "pArquivTLS", "pArquivoFBT", "pArquivTxt", "pArquivTBT", "pArquivoTEMP", "pArquivoQBT", "pArquivoTEXT", "pArquivoQEXT", "pArquivaTTP", "pArquivoTBT", "pArquivoTLS", "pArquivaFXT", "pArquivoFEXT", "pArquivoBTP", "pArquivoFTP", "pArquivaFEXT", "pArquivoLXT", "pArquivoFEMP", "pArquivDXT", "pArquivaTEMP", "pArquivDBT"], "pAndamento": [" pOramentO", " pOramentoo", " pAndementos", " pOrementO", " pOrementos", " pAndamentoo", " pAndentionO", " pAndmentO", " pAndentiono", " pAndamentO", " pAndemento", " pOramentos", " pAndmentoo", " pOramento", " pAndamentos", " pAndentionoo", " pAndentionos", " pAndmentos", " pAndmento", " pAndementoo", " pOremento", " pOrementoo", " pAndementO"], "numeroDoRegistro": ["numeroDoregestros", "numeroDoRegpectrano", "numeroDoRegestorno", "numeroDoregistros", "numeroDoRegpectro", "numeroDoRegpectros", "numeroDoRegistros", "numeroDoregestorno", "numeroDoregestro", "numeroDoRegestros", "numeroDoRegistorno", "numeroDoregistrano", "numeroDoRegpectorno", "numeroDoRegiftorno", "numeroDoregistorno", "numeroDoRegiftros", "numeroDoregistro", "numeroDoRegiftrano", "numeroDoRegiftro", "numeroDoRegestrano", "numeroDoRegestro", "numeroDoRegistrano", "numeroDoregestrano"], "in": ["span", "m", "ex", "ln", "ins", "url", "In", "b", "g", "n", "connection", "scan", "conf", "data", "session", "ner", "inc", "part", "f", "IN", "inn", "cl", "out", "s", "cin", "i", "rin", "kin", "is", "reader", " IN", "with", "config", "nin", " out", "l", "login", "slice", "r", "con", "c", "err", "bin", "t", "ini", "query", "again"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialdestino", "stmtLimpezaIniciaDestania", "stmtLimpezaInicioCombaco", "stmtLimpezaInicialCombania", "stmtLimpezaInicialCombario", "stmtLimpezaInicialdestao", "stmtLimpezaInicialdestania", "stmtLimpezaInicioDestino", "stmtLimpezaInicialdestination", "stmtLimpezaInicialDesino", "stmtLimpezaInicialDestario", "stmtLimpezaInicialDestination", "stmtLimpezaInicialdestaco", "stmtLimpezaInicialdestario", "stmtLimpezaInicialDesario", "stmtLimpezaInicialCombino", "stmtLimpezaInicialCombao", "stmtLimpezaInicioDestario", "stmtLimpezaInicioCombario", "stmtLimpezaInicioCombao", "stmtLimpezaInicioDestao", "stmtLimpezaInicialDesaco", "stmtLimpezaInicioDestaco", "stmtLimpezaInicialDestaco", "stmtLimpezaIniciaDestination", "stmtLimpezaInicialCombaco", "stmtLimpezaInicialCombination", "stmtLimpezaInicialDestao", "stmtLimpezaInicioCombino", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialDestania", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialDesao"], "sql": ["ls", "expr", "description", "statement", "sol", "log", "fn", "url", "ssl", "lua", "install", "sf", "html", "details", " SQL", "body", "cmd", "software", "term", "sv", "acl", "data", "msg", "sys", "shell", "socket", "csv", "QL", "sb", "search", "spec", "result", "zip", "liquid", "sn", "stat", "nl", "s", "el", "sq", "dl", "comment", "rl", "filename", "l", "seed", "sg", "db", "eps", "util", "id", "kl", "layout", "string", "err", "params", "select", "sl", "json", "query", "setup", "where", "http", "SQL", "ql"], "stmtDestino": ["stmtdestin", "stmdDestin", "stmtdestino", "stmtdestinos", "stmtDistaco", "stmdDestinos", "stmDestaco", "stmdDestino", "stmDestania", "stmCampaco", "stmtDestin", "stmtDistania", "stmtDestorno", "stmtdestaco", "stmtDestinos", "stmDestino", "stmtCampino", "stmtCamporno", "stmtdestorno", "stmtdestania", "stmtDestaco", "stmCampania", "stmtDistorno", "stmtCampania", "stmCampino", "stmtDistinos", "stmtDestania", "stmtDistino", "stmtCampaco", "stmCamporno", "stmDestorno", "stmtDistin", "stmdDestorno"], "TAMANHO_DO_CABECALHO_DO_ARQUIVO": ["TAMANHO_DO_CABECALLHI", "TAMANHO_DO_CABECALLHOU", "TAMANHO_DO_CABISCALHOU", "TAMANHO_DO_CABECULHO", "TAMANHO_DO_CABECALSHOU", "TAMANHO_DO_CABISCALHI", "TAMANHO_DO_CABOCALHO", "TAMANHO_DO_CABECALSHI", "TAMANHO_DO_CABECALHOU", "TAMANHO_DO_CABISCALLHI", "TAMANHO_DO_CABECALSHO", "TAMANHO_DO_CABECALHI", "TAMANHO_DO_CABECALLHO", "TAMANHO_DO_CABECALHO", "TAMANHO_DO_CABECARCO", "TAMANHO_DO_CABECULHI", "TAMANHO_DO_CABECALLCO", "TAMANHO_DO_CABOCALSCO", "TAMANHO_DO_CABECALCO", "TAMANHO_DO_CABOCALCO", "TAMANHO_DO_CABISCALLHO", "TAMANHO_DO_CABISCALLHOU", "TAMANHO_DO_CABECARHO", "TAMANHO_DO_CABOCALSHOU", "TAMANHO_DO_CABISCALHO", "TAMANHO_DO_CABOCALSHO", "TAMANHO_DO_CABECULHOU", "TAMANHO_DO_CABOCALHOU", "TAMANHO_DO_CABECARHOU", "TAMANHO_DO_CABECALSCO"], "TAMANHO_DO_RODAPE_DO_ARQUIVO": ["TAMANHO_DO_RODAPEJDo", "TAMANHO_DO_RODAPEECPO", "TAMANHO_DO_RODAPEJDO", "TAMANHO_DO_RODAPEJdo", "TAMANHO_DO_RODAPJdo", "TAMANHO_DO_RODAPJDo", "TAMANHO_DO_RODAPE_do", "TAMANHO_DO_RODAPEECDo", "TAMANHO_DO_RODAPE__Do", "TAMANHO_DO_RODAPJTO", "TAMANHO_DO_RODAP_DO", "TAMANHO_DO_RODAPE_DO", "TAMANHO_DO_RODAPJDO", "TAMANHO_DO_RODAPE_PO", "TAMANHO_DO_RODAPE_TO", "TAMANHO_DO_RODAP_do", "TAMANHO_DO_RODAPEJTO", "TAMANHO_DO_RODAPJPO", "TAMANHO_DO_RODAPE__TO", "TAMANHO_DO_RODAPE__DO", "TAMANHO_DO_RODAPE_Do", "TAMANHO_DO_RODAP_Do", "TAMANHO_DO_RODAP_TO", "TAMANHO_DO_RODAPEJPO", "TAMANHO_DO_RODAPEECDO", "TAMANHO_DO_RODAPE__do", "TAMANHO_DO_RODAP_PO"], "TAMANHO_DOS_METADADOS_DO_ARQUIVO": ["TAMANHO_DOS_METADADOPS___", "TAMANHO_DOS_METADADOSAD", "TAMANHO_DOS_METADADOTSAD", "TAMANHO_DOS_METADADosAD", "TAMANHO_DOS_METADADIES_", "TAMANHO_DOS_METADANDOSAD", "TAMANHO_DOS_METADADOPS_", "TAMANHO_DOS_METADANDOS_", "TAMANHO_DOS_METADADOSJ", "TAMANHO_DOS_METADADIESJ", "TAMANHO_DOS_METADANDOS___", "TAMANHO_DOS_METADADOTS_", "TAMANHO_DOS_METADADos_", "TAMANHO_DOS_METADADOS_", "TAMANHO_DOS_METADANDOAD", "TAMANHO_DOS_METADADO___", "TAMANHO_DOS_METADADO_", "TAMANHO_DOS_METADANDO_", "TAMANHO_DOS_METADADOS___", "TAMANHO_DOS_METADADIES___", "TAMANHO_DOS_METADANDO___", "TAMANHO_DOS_METADANDOSJ", "TAMANHO_DOS_METADADOAD", "TAMANHO_DOS_METADADOJ", "TAMANHO_DOS_METADADOPSJ", "TAMANHO_DOS_METADANDOJ"], "TAMANHO_MEDIO_POR_REGISTRO": ["TAMANHO_MEDIO_PORPREGIS", "TAMANHO_MEDIO_POR_RegIT", "TAMANHO_MEDIO_PORPRegIT", "TAMANHO_MEDIO_POR_REGES", "TAMANHO_MEDIO_POR_RegIES", "TAMANHO_MEDIO_POR_RegIS", "TAMANHO_MEDIO_PORPREGIC", "TAMANHO_MEDIO_PORPREGIES", "TAMANHO_MEDIO_POR_GAS", "TAMANHO_MEDIO_POR_REGIC", "TAMANHO_MEDIO_POR_RegES", "TAMANHO_MEDIO_POR_RegAS", "TAMANHO_MEDIO_PORPRECAS", "TAMANHO_MEDIO_POR_RegIC", "TAMANHO_MEDIO_POR_RECAS", "TAMANHO_MEDIO_PORPREGIT", "TAMANHO_MEDIO_POR_GIC", "TAMANHO_MEDIO_POR_RECIES", "TAMANHO_MEDIO_POR_RECIC", "TAMANHO_MEDIO_PORPREGAS", "TAMANHO_MEDIO_POR_EGIT", "TAMANHO_MEDIO_POR_REGIES", "TAMANHO_MEDIO_PORPREGES", "TAMANHO_MEDIO_PORPRegES", "TAMANHO_MEDIO_POR_EGES", "TAMANHO_MEDIO_POR_REGAS", "TAMANHO_MEDIO_POR_GIS", "TAMANHO_MEDIO_PORPRECIS", "TAMANHO_MEDIO_POR_EGIES", "TAMANHO_MEDIO_POR_RECIS", "TAMANHO_MEDIO_POR_REGIS", "TAMANHO_MEDIO_POR_GIES", "TAMANHO_MEDIO_POR_REGIT", "TAMANHO_MEDIO_PORPRegIS", "TAMANHO_MEDIO_PORPRegIES", "TAMANHO_MEDIO_PORPRECIES", "TAMANHO_MEDIO_PORPRECIC", "TAMANHO_MEDIO_POR_EGIS"], "tamanhoDosArquivos": ["tamanhoDosArQUivlos", "tamanhoDosArqivos", "tamanhoDosArqivoes", "tamanhoDosArquIVo", "tamanhoDosArquivalo", "tamanhoDosArqIVos", "tamanhoDosArQUervos", "tamanhoDosArquievOs", "tamanhoDosArquivOs", "tamanhoDosArQUervlos", "tamanhoDosArquievos", "tamanhoDosArQUervOs", "tamanhoDosArQUivo", "tamanhoDosArquivaloes", "tamanhoDosArquievlos", "tamanhoDosArquIVoes", "tamanhoDosArquivo", "tamanhoDosArqIVo", "tamanhoDosArqivlos", "tamanhoDosArqIVlos", "tamanhoDosArquervos", "tamanhoDosArquervo", "tamanhoDosArquivalos", "tamanhoDosArquivoes", "tamanhoDosArqIVoes", "tamanhoDosArquIVlos", "tamanhoDosArquivallos", "tamanhoDosArQUivOs", "tamanhoDosArQUervo", "tamanhoDosArQUivos", "tamanhoDosArqivo", "tamanhoDosArquievo", "tamanhoDosArquivlos", "tamanhoDosArquervoes", "tamanhoDosArquervOs", "tamanhoDosArquIVOs", "tamanhoDosArquervlos", "tamanhoDosArquIVos"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstivado", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstipadas", "quantidadeDeRegistrosEstimmante", "quantidadeDeRegistrosEstipada", "quantidadeDeRegistrosEstimante", "quantidadeDeRegistrosEstivante", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstipado", "quantidadeDeRegistrosEstipante", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstimmado"], "registro": ["regastration", "regustros", " regestros", " regestration", "registration", "regustulo", " registulo", "regestration", "regastulo", "regestros", "regestulo", " regestulo", "registulo", " registration", "regastro", "regestro", "registros", "regustro", " registros", " regestro", "regastros", "regustration"], "campos": ["Campo", "Campas", " campOS", " casOS", "campas", "campOS", " campo", "Campos", " campas", "CampOS", " caso", " casos", " casas", "campo"]}}
{"id1": "22993368", "id2": "15409512", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "18097962", "id2": "5148212", "code1": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 0, "substitutes": {"getVersion": ["parseVersions", " getVersions", "parseVersion", "getVersions", "showRelease", "parseVERSION", "parseRelease", " getVERSION", "showVersion", "showVersions", "showVERSION", "getRelease", "getVERSION", " getRelease"], "version": ["feature", "ver", "name", "ception", "type", "versions", "python", "language", "install", "VERSION", "array", "latest", "info", "release", "status", "position", "model", "description", "format", "text", "output", "vert", "instance", "section", "content", "bug", "line", "vision", "secret", "comment", "source", "build", "image", "value", "project", "driver", "object", "v", "update", "server", "unit", "Version", "message", "action", "resource", "result", "cover", "string", "option", "element"], "version_url": ["versioningfile", "versioningurl", "version_URL", "version_feed", "ver_url", "versioningUrl", "version_file", " version_feed", "ver_Url", "ver_file", " version_str", "versioningresource", "ver_resource", "version_str", "version_resource", "version_Url", " version_URL"], "url": ["connection", "open", "sl", "f", "fl", "channel", "socket", "stream", "web", "download", "ll", "ssl", "base", "bb", "log", "ls", "conn", "page", "zip", "l", "fr", "client", "Url", "URL", "api", "cl", "server", "uri", "http", "c", "file", "www", "bel", "host", "resource", "rl"], "con": ["connection", "bin", "open", "cur", "login", "f", "cn", "cos", "channel", "socket", "un", "ins", " conn", "stream", "enc", "pub", "en", "pc", "plain", "log", "rc", "conn", "b", "win", "l", "IN", "Con", "ran", "init", "inc", "ch", "CON", "connect", "uc", "exec", "close", "conv", "Conn", "c", "http", "co", "coll", "ln", "Connection", "fc"], "in": ["reader", "bin", "connection", "isin", "login", "f", "data", "fac", "s", "ins", "hel", "pin", "stream", "cin", "ex", "In", "rec", "ssl", "kin", "is", "conn", "b", "inner", "again", "rin", "r", "din", "IN", "ini", "i", "init", "inc", "nin", "inn", "c", "file", "as", "impl", "lin", "on", "input", "out", "gin"], "inputLine": ["outputLine", "inputFile", "InputPart", " inputStream", "inputValue", "outputStream", " inputValue", "tempStream", "outputFile", "outputline", "inputL", "templine", " inputline", "outputPart", " inputPart", "InputLine", "InputValue", "rawLine", "tempLine", " inputFile", "InputL", " inputL", "Inputline", "inputStream", "InputFile", "rawline", "inputline", "rawValue", "inputPart", "rawL"]}}
{"id1": "21995302", "id2": "21656668", "code1": "        public void open(Input input) throws IOException, ResolverException {\n            if (!input.isUriDefinitive()) return;\n            URI uri;\n            try {\n                uri = new URI(input.getUri());\n            } catch (URISyntaxException e) {\n                throw new ResolverException(e);\n            }\n            if (!uri.isAbsolute()) throw new ResolverException(\"cannot open relative URI: \" + uri);\n            URL url = new URL(uri.toASCIIString());\n            input.setByteStream(url.openStream());\n        }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"open": ["Open", "create", "init", "opening", "oc", "re", "set", "parse", "load", " close", "update", " opened", "use", " Open", "to", "build", "process", "close", "resource", "fix", " opening", "add", " opener", "change", "it", "initial", " transfer", " OPEN", "res", "stream", "ize", " reopen", "write", " start", "en", "un", "end", "o", "get", "start", "xml", "handle"], "input": ["text", "source", "form", "buffer", "output", "out", "client", "current", "inner", "instance", "PUT", "config", "this", "state", "event", "Input", "command", "i", "socket", "keep", "image", "data", "argument", "object", "resource", "in", "io", "accept", "class", "document", "base", "inf", "ink", "exec", "upload", "container", "connection", "stream", "element", "file", "temp", "request", "pull", "ssl", "feed", "reader", "type", "inc", "error", "audio", "context", "http"], "uri": ["source", "uni", "uid", "bridge", "result", "str", "absolute", "path", "username", "instance", "info", "gi", "state", "via", "i", " URI", "manager", "image", "ci", "data", "abi", "definition", "service", "object", "resource", "directory", "io", "next", "base", "si", "database", "document", "picture", "ui", "address", "api", "pi", "li", "iri", "ki", "string", "verb", "connection", "origin", "mi", "prefix", "di", "direction", "qi", "element", "eni", "file", "route", "cli", "response", "URI", "id", "doi", "adi", "ri", "http"], "url": ["ls", "text", "source", "ref", "char", "buffer", "browser", "path", "Url", "plug", "f", "config", "ball", "state", "link", "i", "l", "socket", "data", "resource", "io", "base", "bel", "b", "server", "URL", "sl", "address", "api", "li", "string", "connection", "channel", "stream", "layer", "coll", "impl", "file", "ssl", "feed", "ob", "id", "http"]}}
{"id1": "2113444", "id2": "6188784", "code1": "    private VelocityEngine newVelocityEngine() {\n        VelocityEngine velocityEngine = null;\n        InputStream is = null;\n        try {\n            URL url = ClassPathUtils.getResource(VELOCITY_PROPS_FILE);\n            is = url.openStream();\n            Properties props = new Properties();\n            props.load(is);\n            velocityEngine = new VelocityEngine(props);\n            velocityEngine.init();\n        } catch (Exception e) {\n            throw new RuntimeException(\"can not find velocity props file, file=\" + VELOCITY_PROPS_FILE, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n        return velocityEngine;\n    }\n", "code2": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"newVelocityEngine": ["newVelocityInstance", "newVelysicsServer", "newvelocityServer", "newVelysicsInstance", "newVelysicsEngine", "newVelantomServer", "newVelocityDriver", "newVelocityServer", "newVelysicsDriver", "newvelantomDriver", "newvelocityEngine", "newvelantomInstance", "newVelisionInstance", "newVelisionServer", "newVelantomEngine", "newVelantomInstance", "newvelocityDriver", "newVelantomDriver", "newVelisionDriver", "newvelantomServer", "newvelantomEngine", "newVelisionEngine", "newvelocityInstance"], "velocityEngine": ["explosityModule", "velisionCase", "collisionImpl", "explocityEngine", "velocolServer", "velocolController", "velantomServer", "velosityServer", " velisionController", "collisionEngine", "explosityServer", "velotionModel", "veloModel", "velvelCore", " velocityController", "velisionImpl", "velisionServer", "velocityImpl", "velocityCase", "veloDriver", "explocityModule", "veloEngine", " velisionEngine", "VelocityModel", "collocityImpl", "VelocityEngine", " velisionCore", "VeloDriver", "velvelImpl", "velvelCase", "velocityNode", "velosityController", "collocityEngine", "velocityServer", "explocityNode", "veloService", "velocityModule", "velosityCase", "velosityModule", "velityDriver", "velotionService", "velocityController", "collisionServer", "velityEngine", "VelocityDriver", "velvelServer", "collocityServer", "velosityEngine", "explosityEngine", "velotionEngine", "velocityDriver", "velosityCore", "velocolEngine", "velvelNode", " velisionCase", "velvelModule", "velvelController", "velityModel", " velocityCore", "VeloService", "velocityService", "velantomModule", "velisionController", "velocityModel", "velocityCore", "VeloEngine", "VeloModel", "velocolImpl", "explosityNode", "collocityController", "collisionController", "velisionCore", "velosityNode", "velantomEngine", "velisionEngine", "velvelEngine", "VelocityService", "velityService", "velotionDriver", "explocityServer", "velantomNode", " velocityCase"], "is": ["us", "address", "ais", "im", "ip", "ai", "ib", "ois", "does", "iso", "ar", "was", "io", "isa", "id", "has", "IS", "bis", "Is", "es", "res", "out", "abs", "ui", "state", "stream", "s", "ris", "err", "isl", "si", "ios", "iss", "os", "nis", "or", "ie", "i", "info", "ori", "lis", "ps", "il", "isc", "isi", "uri", "iter", "resource", "api", "close", "fs", "it", "get", "its", "iris", "http", "in", "init", "src", "as", "mis"], "url": ["address", "base", "str", "e", "id", "feed", "io", "URL", "path", "xml", "sl", "Url", "host", "location", "string", "stream", "image", "ssl", "i", "r", "b", "config", "loc", "loader", "ur", "uri", "service", "resource", "api", "http", "l", "page", "source", "file", "server", "data", "src", "f", "il"], "props": ["propfs", "probs", "prob", "propperties", "prfs", "Prods", "profs", " properties", "promds", "crofs", "propPS", "protb", "protfs", " proPS", "protperties", "preds", "crops", "propps", "promcs", "Procs", "Props", "properties", " probs", "promps", "Probs", "procs", "propbs", "prperties", "proPS", "prb", "preps", "crods", "croperties", "protps", "preperties", " profs", "propb", "propcs", " procs", "ProPS", "prombs", "prefs", " prods", "prods", "prps"]}}
{"id1": "10131427", "id2": "19096138", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", " copyChannel", "copyfile", "CopyChannel", "copyFiles", "CopyFile", "copyChannel", "transferfile", "transferFile", "transferChannel", "Copyfile", "CopyFiles", " copyfile", " copyFiles"], "in": ["work", "source", "buffer", "copy", "inn", "inner", "c", "ac", "config", "at", "ex", "i", "input", "image", "or", "IN", "data", "m", "ini", "resource", "io", "a", "url", "base", "name", "b", "min", "index", "ins", "In", "inc", "again", "file", "login", "id", "reader", "diff", "bin"], "out": ["p", "x", "source", "buffer", "copy", "cache", "output", "client", "c", "point", "at", "w", "ex", "OUT", "conn", "image", "data", "writer", "object", "dest", "io", "n", "base", "name", "exec", "string", "connection", "external", "prefix", "Out", "outs", "off", "file", "temp", "part", "o", "v", "target"], "sourceChannel": ["SourceQueue", " sourceManager", "srcQueue", "sourceConnection", "SourceChan", "ourceChannel", " sourcechannel", "sourceChan", "SourceConnection", " sourceConnection", "SourceManager", "SourceSocket", "srcConnection", " sourceStream", "sourceQueue", "sourceSocket", "srcSocket", "srcChannel", "targetchannel", "ourceStream", " sourceChan", "targetChan", "srcChan", "sourceManager", " sourceSocket", "sourcechannel", "srcManager", "sourceStream", "ourcechannel", "ourceChan", "targetStream", "SourceChannel", "SourceStream", "srcStream", "Sourcechannel", " sourceQueue", "targetChannel"], "destinationChannel": ["DestinationChannel", "destinationchannel", "destinatedChannel", "DestinatorCh", "destationchannel", "DestinationConnection", "destinateConnection", "destinationCh", "destationChannel", "destinationStream", "destinateChannel", "DestinatorChannel", "destinatedCh", "destinationschannel", "destationChan", "DestinatorConnection", "DestinationCh", "destinationChan", "DestinationStream", "destinatorConnection", "destinatedChan", "destinationConnection", "destinationsStream", "destinatedConnection", "DestinatorChan", "destationCh", "destinatorChan", "DestinatorStream", "destinationsChannel", "destationConnection", "DestinationChan", "Destinationchannel", "destinatechannel", "Destinatorchannel", "destinatorCh", "destinateStream", "destinationsConnection", "destinatorchannel", "destinatorChannel", "destinatorStream"]}}
{"id1": "13783898", "id2": "4716110", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeStringToStream", "encodeFiletoStream", "encodeString2Stream", "encodeFiletoFile", "encodeStringToString", "encodeString2String", "encodeFileToStream", "encodeFileToString", "encodeFileFromFiles", "encodeFile2Files", "encodeStringToFiles", "encodeFile2String", "encodeStringToFile", "encodeFileFromString", "encodeString2Files", "encodeFileFromFile", "encodeFiletoString", "encodeFile2Stream", "encodeFileToFiles", "encodeFiletoFiles", "encodeString2File", "encodeFile2File", "encodeFileFromStream"], "infile": ["inputFile", "inputfilename", "Infiles", "outfilename", "infilename", "inputfile", "outFile", "inputfiles", "outfiles", "infp", "inputfp", "outfp", " infilename", " infp", " infiles", "infiles", "Infilename", "InFile", "Infile", "inFile"], "outfile": ["newFile", "outputfilename", "Outfile", "outfilename", "infilename", "outFile", "Outfolder", " outfp", " outfilename", "infp", "newfolder", "outname", "outfp", " outname", " outFile", "Outname", " outfolder", "outputfp", "newname", "newfile", "outputfile", "infolder", "OutFile", "outputfolder", "outfolder"], "in": ["reader", "bin", "isin", "sin", "login", "data", "into", "socket", "inas", "s", "ins", "pin", "m", "cin", "min", "In", "vin", "base", "is", "inside", "conn", "b", "inner", "again", "rin", "win", "r", "din", "IN", "err", "ini", "i", "source", "init", "image", "inc", "nin", "pass", "thin", "inn", "as", "id", "a", "ic", "input", "con", "re", "ac", "gin"], "out": ["job", "bin", "name", "point", "socket", "error", "session", "sync", "to", "ex", "outs", "one", "timeout", "In", "base", "copy", "conn", "cache", "again", "output", "inner", "writer", "work", "line", "err", "off", "client", "o", "OUT", "lib", "source", "image", "inc", "or", "exec", "parent", "outer", "exit", "no", "post", "io", "net", "file", "up", "co", "on", "ou", "home", "Out", "write", "obj"], "buffer": ["offset", "reader", "border", "uffer", "iter", "data", "batch", "slice", "type", "reference", "seed", "layer", "buff", "Buffer", "binary", "base", "bb", "cache", "b", "size", "bytes", "address", "flush", "count", "source", "padding", "limit", "value", "feed", "url", "transfer", "server", "raw", "null", "split", "wave", "len", "queue", "input", "result", "length", "write", "fb", "buf"], "read": ["x", "reader", "READ", "iter", "f", "current", " count", "start", "_", "ride", "get", "Read", "allow", "play", "slice", "sync", "send", "se", "ip", "load", "find", "ind", "reads", "add", "copy", " write", "check", "size", "work", " skip", "count", "i", "run", "seek", "parse", "feed", "limit", "lex", " copy", " Read", "exec", "select", "connect", "fill", "next", "close", "tell", "reading", "n", "pass", "raw", "inc", "io", "id", "len", "input", "sleep", "length", "ad", "write", "use", "end", "wait"], "success": [" successful", "open", "rolling", "data", "true", " succ", "cess", "error", "modified", "complete", "successfully", "method", "first", "results", " succeed", "good", "fast", "winner", "status", "model", "roll", "successful", "again", "content", "ceed", "rolled", "done", "better", "respons", "construct", "comment", "warning", "growth", "continue", "value", "response", "path", "Success", "default", "ccess", "pass", "null", "danger", "xx", "func", "primary", "right", "valid", "message", "flash", "follow", "result", "fail", "initial", " Success", "failed"]}}
{"id1": "12454178", "id2": "8942491", "code1": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "    public static URLConnection openProxiedConnection(URL url) throws IOException {\n        if (proxyHost != null) {\n            System.getProperties().put(\"proxySet\", \"true\");\n            System.getProperties().put(\"proxyHost\", proxyHost);\n            System.getProperties().put(\"proxyPort\", proxyPort);\n        }\n        URLConnection cnx = url.openConnection();\n        if (proxyUsername != null) {\n            cnx.setRequestProperty(\"Proxy-Authorization\", proxyEncodedPassword);\n        }\n        return cnx;\n    }\n", "label": 0, "substitutes": {"alterar": [" cryar", " cryAr", " crea", " crya", " celebra", " cultivar", " celebraran", " crearan", " crear", " cultivaran", " cryaran", " cultiva", " creAr", " cultivAr", " celebrAr", " celebrar"], "t": ["at", " mt", "rt", "to", "att", "m", "bolt", "u", "e", "wt", "xt", "n", "st", "tc", "flat", "ot", "this", "ut", "you", "tm", "in", "pt", "f", "it", "tool", "tt", "o", "nt", "d", "tower", "ta", "unt", "template", "type", "s", "tf", "the", "let", "T", "tools", "te", "i", "y", "l", "target", "tree", "tr", "et", "table", "det", "trans", "ti", "tp", "v", "c", "qt", "ts", "ant", "tw", "x", "p", "dt"], "stmt": ["strmn", "swmd", "stmr", "Strm", "putau", " stnt", "formrm", "tmr", "stdb", "istdb", "formmm", "stnt", "istmt", "putmt", "ctgr", "Stv", "tpt", " stmm", "Stmb", "smr", "spt", " stmn", "ctmt", "strm", "stmb", "Stgr", "strmt", " stbm", " stdb", "istmn", " stv", "strau", "stmd", "ustmd", " stct", "stpt", " stau", "ustau", " stpt", "Stct", " stgr", "swbm", "sdb", "tmt", "stau", " stmb", "stct", "Stbm", "istau", "Stau", "swmt", "stmm", "ctmb", "stbm", "formmt", " stmd", "stv", "stgr", "putmd", "ctct", "stmn", "Stmd", "Stmt", "ustnt", "smt", "swau", " strm", "putnt", "ustmt", "Stmm", "strdb", "tdb", "formv", " stmr"], "sql": ["ls", "sol", "statement", "log", "url", "details", " SQL", "cmd", "lock", "shell", "QL", "limit", "result", "zip", "stat", "job", "s", "conn", "sq", "dl", "pr", "plan", "seed", "lambda", "expression", "db", "base", "string", "params", "printf", "sl", "up", "mt", "query", "insert", "setup", "where", "q", "database", "serv", "SQL", "ql"], "id_disciplina": ["id_distrequini", "id_Disciplinea", "id_disciplini", "id_discomplina", "id_distciplinea", "id_disrequINA", "id_disciino", "id_disciplana", "id_Disciplissa", "id_disciplinea", "id_disciplineini", "id_Disciplini", "id_Disciplina", "id_distciina", "id_distciini", "id_disciinea", "id_distciplina", "id_distciino", "id_discomplana", "id_disrequina", "id_disciplineino", "id_disciINA", "id_distciplini", "id_disciplissa", "id_disciina", "id_distrequina", "id_disciplineana", "id_discomplino", "id_disciplineINA", "id_discomplinea", "id_disciana", "id_discomplini", "id_distrequinea", "id_Disciplineini", "id_disciini", "id_disguinea", "id_disguini", "id_disciplino", "id_disguina", "id_disrequinea", "id_distciplINA", "id_disciplineissa", "id_disciplineinea", "id_distciplino", "id_discomplissa", "id_distciana", "id_disguissa", "id_Disciplineina", "id_distciplana", "id_distrequINA", "id_Disciplineissa", "id_disciplINA", "id_Disciplineinea", "id_disciplineina", "id_disrequini"], "item": ["at", "m", "page", "pe", "request", "url", "unit", "e", "server", "parent", "event", "info", "data", "entry", "it", "result", "site", "area", "o", "index", "container", "type", "instance", "i", "source", "action", "hop", "reader", "article", "er", "ip", "edit", "bar", "queue", "r", "object", "id", "seller", "v", "Item", "name", "other", "service", "order", "or", "q", "items", "p"]}}
{"id1": "11341711", "id2": "149935", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"makeBackup": ["makeBackups", "makeCleanups", "createBackUp", "createBackdown", "makePickup", "makebackup", "makeCleanup", "createBackups", "makePickups", "createbackup", "createbackdown", "makebackdown", "createBackup", "makebackUp", "makeCleanUp", "makePickUp", "createbackups", "createbackUp", "makeCleandown", "makeBackdown", "makeBackUp", "makePickdown", "makebackups"], "dir": ["log", "direction", "url", "module", "build", "dest", "rc", "init", "DIR", "io", "data", "store", "md", "director", "folder", "group", "dep", "zip", "Directory", "d", "run", "done", "wd", "dict", "download", "pkg", "source", "config", "directory", "work", "db", "base", "cache", "desc", "ir", "file", "dist", "name", "up", "root", "lib", "diff", "path", "Dir", "manager", "doc"], "sourcedir": ["asourcedir", "sortedore", "seedir", "sodedirs", "ssodedIR", "seeddir", "asourcedore", "sourcedIR", "asortedirs", "ssodedir", "sourcedore", "sodedore", "ssourceddir", "sourcesiri", "sodeddir", "sodedir", "sodediri", "ssodeddir", "asortedore", "sourceddir", "sourcesore", "sourcesdir", "sourcesirs", "sourcesir", "ssourcediri", "sortedir", "asourcedirs", "sortedirs", "ssourcedIR", "sortedIR", "sourcedirs", "seedIR", "seediri", "ssourcedir", "ssodediri", "asortedir", "sourcesIR", "asourcedIR", "sodedIR", "sourcediri", "asortedIR"], "destinationdir": ["Destinationfolder", "Destificationdirection", "DestificationDir", "destinatorfile", "dominationDir", "destinationsfile", "destinatorDIR", "dominatorDir", "destinatefolder", "destinationsDir", "destinatordir", "destinatefile", "destificationdirection", "desturationDir", "destinationDIR", "dominatordir", "destificationfolder", "Destinationdirection", "destinationfolder", "destificationdir", "desturationdirection", "dominationfile", "destinatorDir", "destinationsdir", "dominationDIR", "destinatedirection", "destinateDIR", "destinationDir", "destinationdirection", "desturationdir", "dominatorDIR", "destinationfile", "Destificationdir", "destinationsDIR", "dominationdir", "destificationDir", "desturationfolder", "destinateDir", "destinatedir", "DestinationDir", "Destinationdir", "dominatorfile", "Destificationfolder"], "destinationDirEnding": ["destinationDirEndning", "destinationDirEndining", "destinationDirENDning", "destinationDirENDging", "destinationDirectoryEndING", "destinationPathEndning", "destinationDirSigning", "destinationDirPassging", "destinationPathBegining", "destinationDirSignING", "destinationPathEndING", "destinationDirLeadening", "destinationDirectorySignING", "destinationDirEndging", "destinationDirLeadining", "destinationDirPassing", "destinationDirENDing", "destinationDirectoryEndening", "destinationPathEnding", "destinationDirectorySignening", "destinationDirBeginging", "destinationDirPassING", "destinationDirLeading", "destinationDirEndening", "destinationDirSignening", "destinationPathEndging", "destinationDirectoryEndining", "destinationPathBeginging", "destinationDirSignining", "destinationDirLeadING", "destinationDirEndING", "destinationDirectoryEnding", "destinationDirENDING", "destinationDirPassning", "destinationDirBeginening", "destinationPathBeginning", "destinationDirectorySigning", "destinationDirBeginining", "destinationDirBeginING", "destinationDirBegining", "destinationDirBeginning", "destinationDirectorySignining", "destinationPathBeginING"], "files": ["ls", "fields", "keys", "log", "ins", "rows", "books", "modules", "ps", "users", "links", "data", "reports", "output", "sections", "planes", "groups", " Files", "parents", "features", "split", "classes", "projects", "index", "lines", "balls", "fs", "children", "ips", "docs", "objects", "xml", "results", "flows", "images", "thumbnails", "l", "resources", "pages", "ids", "names", "models", "file", "errors", "tests", "bugs", "locks", "actions", "iles", "rules", "blocks", "Files", "words", "types", "boxes", "events", "uploads", "services", "strings", "items", "its", "runs"], "checkdir": [" checklog", "ckfolder", "searchdirectory", "checkdirectory", "calldir", "calldirectory", "blockdirectory", "searchdir", "workFolder", "lockDir", "workdir", "blockdir", "Checkdir", "blockdraft", "workfolder", "workDIR", "ckd", "checkfolder", " checkDIR", "checkDir", "workfile", "callfolder", "worklog", "CheckDir", "checkd", "blockDir", " checkdirectory", "workdraft", "checkFolder", "locklog", "checkDIR", " checkfolder", "workDir", "ckDir", "ckdirectory", "calld", "workdirectory", "searchDir", " checkDir", "checkdraft", " checkd", "searchdraft", " checkfile", "checklog", "ckfile", " checkFolder", "Checkfile", "lockFolder", "lockdir", "CheckDIR", "checkfile", "ckdir"], "date": ["at", "m", "log", "e", "image", "late", " Date", "event", "tag", "data", "ge", "md", "mate", "zone", "now", "set", "d", "dat", "time", "open", "config", "ime", "contact", "month", "sign", "de", "user", "change", "day", "ate", "file", "Date", "start", "name", "age", "mu", "state", "update", "doc", "dt", "rate"], "msec": ["css", "rsecond", "rss", " minsec", "dsecond", "dsec", " minsc", " minSec", "Msecond", "msecond", "lsecond", "lsec", "misec", " msc", "mss", "dseconds", "mnsc", "rseconds", "Msec", "fmsec", "mnsec", "mnSec", "msc", "fmseconds", "mSec", "lseconds", "csec", "fmisec", "mnif", "cseconds", " mif", "disec", "mif", " minif", "mseconds", "Mseconds", "fmsecond", "Misec", "lss", "rsec", "csecond", " mSec"], "checkFile": ["CheckFile", " checkLine", "controlFile", "ckFiles", "changefile", "changeFile", "ckDirectory", "checkLine", " checkFiles", "controlfile", "workFile", " checkFilename", "checkDir", "workfile", "controlFilename", "checkFilename", "CheckDirectory", "changeLine", "CheckDir", "checkDirectory", "workFiles", " checkDirectory", "workDir", "ckFile", " checkDir", "checkFiles", "CheckFiles", " checkfile", "ckfile", "Checkfile", "changeFilename", "controlLine", "checkfile"], "i": ["m", "p", "u", "uri", "e", "j", "b", "n", "fi", "io", "info", "si", "ie", "part", "field", "index", "ci", "iu", "oi", "key", "ji", "is", "multi", "y", "li", "di", "im", "ip", "pi", "xi", "hi", "eni", "slice", "vi", "id", "ti", "gi", "v", "ix", "I", "ai", "phi", "ini", "ii", "ui", "bi", "x", "mu", "qi", "ri"], "f": ["fd", "m", "fn", "u", "fl", "fr", "e", "j", "sf", "b", "n", "fi", "fb", "info", "folder", "o", "d", "feed", "h", "fs", "l", "fun", "fx", "r", "v", "file", "fc", "t", "w", "cf", "F", "q", "fe", "fp", "p", "df"], "g": ["gar", "m", "og", "eg", "u", "e", "G", "gn", "b", "n", "pg", "erg", "ge", "msg", "reg", "ig", "group", "gd", "gin", "ga", "d", "gc", "rg", "vg", "ng", "gg", "go", "mg", "s", "h", "tg", "gm", "bg", "gh", "sg", "l", "ger", "r", "gi", "file", "gb", "gu", "global", "t", "w", "gp", "gs", "q", "p"], "destinationFile": ["destacementfile", "destationfile", "DestationFilename", "DestificationDir", "DestificationFile", "destiningDir", "Destationfile", "DestinationLocation", "destificationFile", "DestationDir", "destationFilename", "destinationsDir", "destinationsDirectory", "destiningfile", "destinationsFile", "DestinationFile", "DestificationLocation", "destinationDirectory", "destinatorDir", "destacementDir", "destacementFile", "destinationDir", "DestificationDirectory", "destinatorLocation", "destificationDirectory", "destacementFilename", "destinatorFile", "destinationsLocation", "destinationfile", "destificationDir", "destationDir", "DestinationDirectory", "DestationFile", "Destinationfile", "destinationFilename", "destificationLocation", "destinationLocation", "destationFile", "destiningFilename", "DestinationFilename", "destiningFile", "DestinationDir", "destinatorDirectory"], "sourceFile": ["SourceFile", "ourceDir", " sourceDir", "ourceFile", "ourceDirectory", "srcModule", "sourceDirectory", "inputFile", "srcDir", "Sourcefile", " sourceFiles", " sourceDirectory", "srcfile", "sourceModule", "sourcefile", "ourceFiles", "inputDirectory", "inputDir", " sourceModule", "SourceModule", "sourceFiles", " sourcefile", "inputFiles", "srcFile", "SourceDir", "sourceDir"], "infile": ["difffile", "InFile", "inputf", "winstream", "windir", "inputFile", "diffdir", "instream", "indata", "outdir", "inFile", "diffFile", " inFile", "inf", "indir", " indata", "Infile", "Inf", "Instream", "outdata", "winFile", "outf", "inputfile", "outstream", "outFile", "winfile", "inputdata", "inputstream", " instream", "diffstream"], "outfile": ["intstream", "againFile", "outfunction", "againpage", "inputFile", " outpage", " outFile", "intlive", "exFile", "intFile", "outline", "intfile", "Outline", "expage", "againfile", "inputfunction", "exstream", " outline", "inputfile", "outstream", "outFile", "Outstream", " outfunction", "Outfile", "Outlive", " outlive", "againstream", "outlive", "Outfunction", "OutFile", "inputline", " outstream", "outpage", "exfile"], "c": ["k", "m", "u", "ct", "z", "esc", "e", "col", "uc", "C", "b", "n", "rc", "dec", "channel", "in", "ec", "o", "d", "ch", "index", "cl", "ci", "h", "end", "code", "comment", "cu", "cm", "ice", "a", "l", "r", "xc", "id", "ac", "v", "pc", "string", "character", "abc", "t", "w", "cont", "x", "lc", "cy", "pointer", "enc", "cr", "p", "char"]}}
{"id1": "18891988", "id2": "11341711", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"getFile": ["loadFilename", "downloadfile", "getfile", "downloadFile", "GetFile", "getFilename", "loadString", "Getfile", "downloadString", "loadfile", "GetFilename", "loadFile", "GetString", "getString", "downloadFilename"], "serviceName": ["ServiceType", "ServicePath", "ServiceName", "Servicename", "projectPath", "packagePath", "packagename", " servicePath", "servicePath", "packageName", "projectName", "ServiceUrl", "projectType", "serviceUrl", "servicename", "serviceType", "packageUrl", " serviceType", " servicename", " serviceUrl", "projectUrl"], "wsdlLocation": ["wsdlUrl", "wsslLocation", "wllFile", "wsllUrl", "wddlLocation", "awslFile", "wddlDirectory", "wsdlFile", "wdlDirectory", "wslLocation", "awsdlLocation", "wllFolder", "wsdlFolder", "wsllAddress", "wslpDirectory", "wslpLocation", "wddlFile", "wslFolder", "awslDirectory", "wsslFile", "wssdFolder", "awsdlDirectory", "wdlLocation", "wllLocation", "wdlFile", "wdlFolder", "wssdFile", "wsllFile", "wslUrl", "wslDirectory", "wsdlDirectory", "wslpFile", "wsslAddress", "awsdlUrl", "awslUrl", "wssdAddress", "wsllFolder", "wllAddress", "wsDLUrl", "wddlFolder", "wsslFolder", "wslFile", "awsdlFile", "wslpFolder", "awslLocation", "wdlAddress", "wsDLDirectory", "wsllLocation", "wsdlAddress", "wsDLLocation", "wsllDirectory", "wsDLFile", "wssdLocation"], "endpoint": ["enpointer", "endPoint", "ENDPoint", "endpo", "enaddress", " endpointer", "endsword", "endspoint", "endsocol", " endPoint", "Endpoint", " endpo", "endpoints", "enination", "startpoint", " endocol", "Endword", "endocol", "enPoint", "ENDination", "startPoint", "Endocol", "enpoint", " endaddress", "EndPoint", "endspo", "endination", " endword", "startaddress", "ENDpoints", "Endpo", "Endination", "ENDpoint", "startpointer", "endaddress", "Endpoints", "endpointer", "endword", "enpoints"], "fileLocation": ["FILEUrl", "FileLocation", "FILEURI", "FileUrl", " fileUrl", " fileDirectory", "fileUrl", "FILELocation", " fileURI", "fileURI", "FILEDirectory", "FileURI", "fileDirectory", "FileDirectory"], "tempDir": [" tempDirectory", "tempDirectory", "tempPath", "tempVer", " tempdir", " temporaryDir", " temporaryPath", " temporaryVer", "TempDir", "tmpVer", " tempPath", "TempPath", "TempDirectory", "tempdir", "tmpDirectory", "tmpPath", "Tempdir", "tmpDir", " tempVer", " temporaryDirectory", "tmpdir"], "url": ["ul", "connection", "open", "sl", "f", "fl", "channel", "socket", "ur", "el", "stream", "web", "download", "log", "ssl", "base", "ll", "ls", "conn", "l", "client", "address", "pull", "Url", "service", "URL", "source", "image", "path", "config", "server", "uri", "io", "http", "file", "www", "coll", "host", "contact", "string"], "WSDLFile": ["WSDLLFiles", "WSDlSourceFile", "WDDLPath", "WSDLFiles", "WINDLFolder", "WSDLLfile", "WSDDLBase", "WINDELFile", "WSDELFile", "WDDlfile", "WSDLFolder", "WINDLPath", "WINDLFiles", "WINDELFiles", "WDDlPath", "WINDLFile", "WSDDLFile", "WSDlFile", "WSDELPath", "WSDDLPath", "WSDlBase", "WDDLFile", "WDDLfile", "WSDlFolder", "WDDLSourceFile", "WSDlPath", "WSDlfile", "WSDLLFolder", "WINDELFolder", "WSDLLBase", "WSDLLSourceFile", "WDDLFolder", "WDDlBase", "WSDLLPath", "WDDlSourceFile", "WSDDLFolder", "WDDlFile", "WSDLPath", "WDDLBase", "WSDLBase", "WSDDLSourceFile", "WSDDLFiles", "WSDDLfile", "WSDLLFile", "WDDlFolder", "WSDLSourceFile", "WSDELFolder", "WINDELPath", "WSDELFiles", "WSDLfile"], "tmpWSDLFile": ["tmpWSDlFolder", "tmpWDDELFile", "tmpWSDLLFile", "tmpWDDLFiles", "tmpWSDELLocation", "tmpWSDELFolder", "tmpWSDLLFiles", "tmpWSDDLUrl", "tmpWSDLUrl", "tmpWSDELFiles", "tmpWSDDLFile", "tmpWSDlUrl", "tmpWSDLLFolder", "tmpWDDELUrl", "tmpWDDlUrl", "tmpWDDELLocation", "tmpWDDlFolder", "tmpWSDLFiles", "tmpWDDELFiles", "tmpWSDlLocation", "tmpWSDELUrl", "tmpWDDlFiles", "tmpWSDDLLocation", "tmpWDDlFile", "tmpWDDLFile", "tmpWSDLLUrl", "tmpWSDlFile", "tmpWDDLLocation", "tmpWSDLLocation", "tmpWSDLFolder", "tmpWSDlFiles", "tmpWDDLUrl", "tmpWSDDLFiles", "tmpWDDLFolder", "tmpWSDELFile"], "inputFile": ["tempPage", "InputUrl", "requestFiles", "InputBase", "tempBase", " inputStream", "tempFactory", "infile", "inputfile", "outputFile", "inDir", "InputPage", "inputFactory", "outputDir", "inputPage", "requestFile", "InputFactory", "InputStream", " inputFactory", " inputfile", "tempfile", "tempPlace", " inputFiles", "requestStream", "InputBuffer", "InputDir", "inputDir", "tempBuffer", "inPage", "requestfile", " inputPage", "inputBase", "inputUrl", " inputUrl", " inputBuffer", " inputPlace", "outputFiles", " inputBase", "inputFiles", "inputBuffer", "outputfile", "inputStream", "InputFile", "InputPlace", "tempUrl", " inputDir", "Inputfile", "tempFile", "InputFiles", "inputPlace", "inFile"], "tmpFile": ["tempPage", "tempDirectory", "TempFiles", "tempDocument", "tmpPage", "inputDocument", "uploadFile", "tempStream", "TempFile", " tmpPage", "tmpStream", " tmpDirectory", "uploadDocument", "uploadFiles", "uploadStream", "TempPage", "inputFiles", "TempDirectory", "tmpDirectory", "tempFiles", "inputStream", "tmpFiles", " tmpFiles", "tempFile"], "in": ["connection", "bin", "reader", "lock", "login", "f", "data", "socket", "ins", "pin", "m", "p", "In", "is", "ssl", "conn", "inner", "again", "win", "din", "l", "r", "IN", "client", "source", "image", "init", "inc", "inn", "c", "file", "up", "id", "impl", "on", "lin", "input", "gin"], "out": ["connection", "bin", "name", "socket", "channel", "error", "sync", "to", "outs", "timeout", "In", "log", "copy", "conn", "part", "inner", "output", "again", "conf", "cache", "can", "line", "writer", "IN", "err", "o", "client", "OUT", "source", "image", "inc", "ch", "outer", "parent", "conv", "group", "server", "io", "net", "c", "file", "up", "co", "on", "input", "Out"], "con": ["connection", "open", "cn", "socket", "nc", "channel", "un", "gin", "ins", "sync", "en", "plain", "rec", "ssl", "kin", "rc", "conn", "inner", "conf", "win", "can", "IN", "Con", "ran", "client", "connect", "ch", "CON", "uc", "inc", "close", "conv", "thin", "Conn", "c", "com", "co", "cm", "ctrl", "fc", "bc"], "fileLength": ["contentlength", "channelSize", "contentLen", "contentSize", "contentLength", "filelength", "fileLen", " filelength", "fileWidth", " fileLen", " fileWidth", " fileSize", "channelLen", "fileSize", "Filelength", "FileLen", "FileSize", "channelLength", "FileLength", "channelWidth", "FileWidth"], "channelIn": ["resourceOut", "resourceIn", "connectionin", "Channelin", "channelIN", "characterIn", "connectionIn", "channelConn", "channelin", "ChannelIn", "connectionOut", " channelin", "characterin", " channelConn", "ChannelConn", " channelIN", "characterOut", "ChannelOut", "characterIN", "connectionConn", "resourceIN", "resourcein", "ChannelIN"], "channelOut": ["chanOUT", "canOUT", " channelOutput", "chanOut", " channelout", "canOut", "Channelout", "connectionOutside", "ChannelOutput", "channelout", "connectionIn", "channelOUT", "ChannelIn", "connectionOut", "ChannelOUT", "connectionOutput", "ChannelOutside", "connectionout", "chanOutside", "chanout", "canIn", "channelOutput", "chanIn", "ChannelOut", "channelOutside", "canOutside"], "tmpDocument": ["newFile", "mpDocument", "tmDocument", "tempDocument", "newContent", " tmpNode", "tempdocument", " tmpdocument", "tempContent", "mpDoc", "mpFile", "tempDoc", "tmpContent", "newDocument", "tmpNode", "tmNode", " tmpDoc", "tmFile", " tmpContent", "tempNode", "tmdocument", "mpNode", "tempFile", "tmpDoc", "tmpdocument", "newdocument"], "nl1": ["ln11", "arl5", "dl2", "NL0", "NL1", "jl1", "nl6", "nlone", "NL2", "nl0", "arlFirst", "nn1", "kl5", "NL11", "klFirst", "jlone", "nn6", "NL6", "nl5", "klone", "nl2", "kl1", "arlone", "dl0", "nlFirst", "jl5", "nn0", "nn2", "arl1", "nl11", "jlFirst", "nn11", "ln6", "ln1", "ln2", "dl1"], "i": ["ji", "f", "y", "si", "it", "ti", "ri", "slice", "m", "p", "j", "info", "pi", "ie", "ix", "hi", "I", "bi", "di", "b", "u", "multi", "part", "qi", "l", "fi", "e", "o", "uli", "ini", "abi", "d", "ci", "z", "xi", "v", "mi", "ui", "oi", "yi", "li", "uri", "n", "ii", "io", "ni", "id", "iu", "index", "chi", "mu", "eni", "ai", "gi", "phi", "ip"], "node1": ["node0", " node0", "package91", "packageOne", " node91", "layer2", " nodeone", "layer1", "n1", " node2", "nodeone", "shapeOne", "nOne", "Node1", "NodeOne", "shape1", "n0", "nodeOne", "shapeone", "node91", "node2", "package1", "Node91", "packageone", "n2", "layerOne", "Node0", " nodeOne", "Node2", "shape91", "layer91"], "tmpOut": ["vmOUT", "tempout", "cacheOUT", " tmpout", "tempIn", "cacheIn", "ptyout", "txtOutput", "cacheFile", "tempOutput", "txtout", "tmpIn", "ptyOut", "tempOut", "tmpOUT", " tmpWriter", "tmpout", "vmOut", "tmpWriter", " tmpOUT", "ptyOutput", " tmpOutput", "ptyIn", "vmIn", "vmout", "tmpOutput", "tempOUT", " tmpIn", "cacheOut", "txtWriter", "tempWriter", "tempFile", "txtOut"], "retVal": ["RETval", "retRet", "valval", "valVal", "valRet", "retval", " retRet", "RETRet", "RETVal", "valObj", "retObj", " retObj", "RETObj", " retval"]}}
{"id1": "20751378", "id2": "7372311", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 1, "substitutes": {"hashPassword": ["cryptPassword", "signPassword", " hashPass", " hashWord", "cryptpassword", "signpassword", "hashpassword", "signPass", "hashPass", "cryptPass", "signWord", "hashWord", " hashpassword", "cryptWord"], "password": ["plain", "mac", "pad", "words", "p", "crypt", "key", "pattern", "user", "input", "sword", "cache", "phrase", "address", "padding", "Password", "code", "content", "path", "message", "word", "description", "wd", "prefix", "pass", "security", "data", "token", "secret", "w", "sha", "number", " passwords", "text", "database", "name", "auth", "python", "string", "seed", " Password", "command", "encrypted", "PASS", "username"], "hash": ["error", "key", "address", "history", "sh", "replace", "bolt", "handle", "format", "value", "Hash", "build", "root", "base", "security", "update", "tag", "search", "text", "string", "kh", "dump", "length", "ha", "html", "user", "cache", "json", "check", "array", "index", "message", "rh", "pool", "ashes", "alt", "gh", "math", "ruby", "hed", "mac", "ssh", "msg", "ash", "host", "copy", "pkg", "id", "oh", "phrase", "result", "proof", "sum", "work", "url", "uild", "log", "put", "number", "auth", "memory", "addr", "match", "h", "dig", "square", "version", "height", "code", "her", "secret", "sha", "call", "mod", "style", "hex"], "md": ["km", "mm", "mac", "der", "sd", "m", "Cmd", "dig", "kg", "grad", "mad", "pd", "metadata", "ME", "ma", "od", "mb", "amd", "nm", "gb", "df", "wd", "dh", "mand", "gd", "bd", "f", "sm", "mg", "dm", "xd", "pm", "sha", "nd", "mt", "MD", "mc", "hd", "mag", "mod", "d", "vd", "ms", "meta", "am", "cmd", "dd", " MD", "hm"]}}
{"id1": "8770016", "id2": "3945236", "code1": "    public InputStream loadResource(String location) throws GenericConfigException {\n        URL url = getURL(location);\n        try {\n            return url.openStream();\n        } catch (java.io.IOException e) {\n            throw new GenericConfigException(\"Error opening URL resource at location [\" + url.toExternalForm() + \"]\", e);\n        }\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"loadResource": ["newURL", "readFile", "newResource", "createURL", "newFile", "loadUrl", "newUrl", "createFile", "createResource", "readUrl", "loadURL", "readResource", "readURL", "loadFile", "createUrl"], "location": ["property", "resource", "timeout", "local", "route", "description", "position", "string", "href", "pointer", "area", "region", "language", "response", "URL", "path", "layer", "operation", "length", "content", "address", "loc", "l", "base", "layout", "Location", "ocation", "config", "loader", "link", "localhost", "filename", "remote", "directory", "level", "type", "point", "target", "uri", "source", "uration", "collection", "name", "file", "reference"], "url": ["resource", "route", "external", "ob", "string", "site", "http", "xml", "URL", "log", "path", "layer", "this", "Url", "rl", "object", "address", "loc", "build", "rel", "l", "connection", "base", "element", "event", "server", "plug", "config", "loader", "sl", "f", "link", "e", "i", "image", "remote", "page", "ssl", "null", "jar", "job", "web", "source", "buffer", "uri", "org", "name", "file", "ref"]}}
{"id1": "23246123", "id2": "4798332", "code1": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 0, "substitutes": {"createDialogArea": ["createButtonGroup", "createMessageArea", " createButtonGroup", " createDialogPanel", " createHelpArea", "createButtonArea", " createDialogarea", "createEditorarea", "createControlarea", "createControlArea", "createButtonarea", "createHelpGroup", "createMessagePanel", "createHelpArea", " createButtonarea", "createEditorGroup", " createDialogGroup", "createEditorArea", "createDialogPanel", "createHelpPanel", "createDialogGroup", "createHelparea", " createButtonArea", " createHelparea", "createControlPanel", "createMessagearea", " createHelpPanel", "createDialogarea"], "parent": ["page", "component", "menu", "message", "image", "resource", "null", "g", "connection", "panel", "Parent", "this", "child", "parser", "port", " scene", "document", "parents", "cl", "clip", "container", "instance", "builder", "class", "client", "section", " sup", "self", "object", "c", "sup", "root", "ctx", "host", "context", "wrapper", "current", "comp", " child", "p"], "composite": ["Complexiting", "comvalitive", "compositionites", "complexiting", "comppositionited", "comPOSitable", "Complexite", "compositionitive", "comppositor", "compositor", "comPOSite", "comppositionitor", "Composites", "comppositionite", "compposite", "complexitable", "composites", "comPOSited", "complexites", "compposites", "composited", "Compositable", "compositionitable", "comosited", "complexitor", "compositing", "compositionite", "comppositable", "Compositing", "comositable", "comvalitor", "comvalites", "comPOSites", "comosites", "compositionited", "compposited", "compositable", "Composite", "compositionitor", "comPOSiting", "compositive", "comppositive", "comppositionites", "complexitive", "Complexites", "comosite", "comvalite", "complexite", "comppositionitable", "comppositionitive", "compositioniting", "Complexitable"], "content": ["activity", "page", "component", "ez", "message", "report", "image", "server", "html", "resource", "copy", "complete", "connection", "cell", "version", "child", "title", "output", "folder", "application", "document", "model", "container", "Content", "conn", "code", "plugin", "xml", "comment", "cm", "create", "config", "section", "header", "client", "media", "cms", "source", "control", "object", "scroll", "address", "load", "exec", "file", "app", "loader", "host", "context", "layer", "json", "cont", "format", "feed"], "ncol": ["nblock", "numcolumn", " ncolumn", "pCol", "Ncol", "numCol", "nbcolumn", "pcol", " nblock", "Nblock", "numrow", " nCol", "nCol", "nbcol", "numcol", "nbCol", "pblock", "ncolumn", "nbrow", "Ncolumn", "nrow", "NCol", "pcolumn", " nrow"], "layout": ["font", "widget", "padding", "closure", "nav", "flow", "board", "image", "build", "offset", "view", "lock", "flat", "data", " layouts", "scale", "mount", "follow", "group", "shape", "model", "figure", "draw", "entry", "zip", "shadow", "translation", "split", "nl", " Layout", "container", "inline", "xml", "config", "section", "l", "edit", "Layout", "base", "design", "control", "position", "scroll", "address", "holder", "alpha", "list", "grid", "lay", "layer", "location", "ui", "lc", "where", "feed", "block", "join"], "numColumns": ["numcolumnes", "nbcolumnes", "numColumnows", "nbColumnes", "numControln", "numcolumnn", "nbColumns", "nbcolumnn", "numControls", "numColn", "nbColumnows", "nbcolumnows", "numColumnn", "numColows", "nbcolumns", "numColes", "numControles", "numControlows", "numcolumnows", "numCols", "numcolumns", "nbColumnn", "numColumnes"], "browser": ["css", "river", "page", "roller", "Browser", "book", "js", "vert", "report", "image", "server", "mobile", "ssl", "uri", "html", "nav", "remote", "google", "fox", "io", "session", "cart", "iframe", "cookie", "fire", "editor", "proxy", "finder", "shadow", "coll", "facebook", "graph", "test", "ver", "plugin", "jar", "comment", "theme", "driver", "chrome", "config", "agent", "client", "flash", "web", "ger", "design", "sim", "feature", "bar", "br", "http", "window", "platform", "loader", "binary", "root", "host", "webkit", "bot", "runner", "front", "box", "manager", "feed", "lib", "open", "img"], "text": ["font", "writer", "txt", "vert", "message", "image", "report", " Text", "struct", "unit", "connection", "letter", "term", "atter", "form", "off", "info", "data", "port", "title", "output", "entry", "it", "editor", "str", "input", "test", "plugin", "element", "comment", "source", "driver", "config", "client", "pdf", "inner", "user", "TEXT", "object", "string", "desc", "name", "select", "service", "binary", "context", "path", "ext", "format", "abs", "label", "feed", "ut", "Text"], "url": ["ur", "page", "ssl", "uri", "resource", "server", "image", "connection", "rel", "io", "f", "zip", "www", "URL", "ref", "bel", "download", "source", "pull", "api", "config", "l", "web", "lr", "base", "user", "id", "address", "string", "gl", "file", "re", "service", "sl", "host", "path", "Url", "http", "feed", "open"], "in": ["rec", "p", "ins", "fr", "resource", "image", "In", "b", "dr", "rc", "init", "data", "on", "inc", "f", "gin", "it", "input", "str", "o", "din", "IN", "d", "inn", "lin", "rb", "out", "s", "conn", "el", "pass", "xml", "i", "rin", "is", "reader", "ar", "nin", "l", "er", "login", "stream", "inner", "a", "min", "br", "bin", "err", "c", "ic", "re", "w", "pin", "ini", "x", "or", "arin", "again", "serv", "ri"], "r": ["kr", "ur", "rt", "m", "p", "res", "rss", "fr", "R", "rx", "ro", "rob", "b", "ru", "dr", "nr", "rc", "mr", "rs", "rel", "rh", "ner", "rar", "f", "vr", "o", "d", "rb", "h", "out", "rg", "rf", "rw", "i", "pr", "reader", "rl", "ar", "l", "er", "rr", "lr", "br", "ir", "err", "c", "re", "sr", "gr", "hr", "or", "cr", "ri", "right"], "sb": ["buf", "kb", "sth", "ls", "bsp", "lp", "ssl", "rob", "sf", "b", "sv", "fb", "bp", "bh", "si", "usb", "xb", "lb", "bc", "sn", "pb", "SB", "storage", "rb", "nl", "lab", "cb", "mb", "s", "bf", "bm", "src", "library", "erb", "ruby", "sg", "db", "lr", "ib", "bj", " SB", "abb", "sa", "sm", "gb", "ob", "sr", "binary", "obb", "sp", "wb", "buffer", "abs", "ab", "eb", "bs", "bb"], "line": ["page", "LINE", "pe", "lf", "col", "message", "le", "se", "b", "n", "letter", "cell", "data", "ge", "part", "entry", "f", "str", "split", "lin", "cl", "lines", "nl", "key", "end", "row", "el", "code", "inline", "pass", "i", "comment", "source", "cle", "record", "header", "li", "ne", "l", "base", "object", "id", "string", "character", "stroke", "obj", "Line", "name", "sl", "lc", "block", "char"], "e": ["ve", "ale", "pe", "ee", "ev", "esi", "one", "se", "le", "en", "ce", "ue", "ge", "je", "ie", "ec", "ele", "f", "oe", "es", "ise", "o", "d", "ae", "error", "me", "i", "te", "ze", "ime", "ne", "er", "E", "de", "err", "ke", "be", "ite", "ea", "or", "ef", "fe", "exc", "p", "ception"]}}
{"id1": "2834524", "id2": "494226", "code1": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "code2": "    public static void main(String[] args) throws Exception {\n        String linesep = System.getProperty(\"line.separator\");\n        FileOutputStream fos = new FileOutputStream(new File(\"lib-licenses.txt\"));\n        fos.write(new String(\"JCP contains the following libraries. Please read this for comments on copyright etc.\" + linesep + linesep).getBytes());\n        fos.write(new String(\"Chemistry Development Kit, master version as of \" + new Date().toString() + \" (http://cdk.sf.net)\" + linesep).getBytes());\n        fos.write(new String(\"Copyright 1997-2009 The CDK Development Team\" + linesep).getBytes());\n        fos.write(new String(\"License: LGPL v2 (http://www.gnu.org/licenses/old-licenses/gpl-2.0.html)\" + linesep).getBytes());\n        fos.write(new String(\"Download: https://sourceforge.net/projects/cdk/files/\" + linesep).getBytes());\n        fos.write(new String(\"Source available at: http://sourceforge.net/scm/?type=git&group_id=20024\" + linesep + linesep).getBytes());\n        File[] files = new File(args[0]).listFiles(new JarFileFilter());\n        for (int i = 0; i < files.length; i++) {\n            if (new File(files[i].getPath() + \".meta\").exists()) {\n                Map<String, Map<String, String>> metaprops = readProperties(new File(files[i].getPath() + \".meta\"));\n                Iterator<String> itsect = metaprops.keySet().iterator();\n                while (itsect.hasNext()) {\n                    String section = itsect.next();\n                    fos.write(new String(metaprops.get(section).get(\"Library\") + \" \" + metaprops.get(section).get(\"Version\") + \" (\" + metaprops.get(section).get(\"Homepage\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Copyright \" + metaprops.get(section).get(\"Copyright\") + linesep).getBytes());\n                    fos.write(new String(\"License: \" + metaprops.get(section).get(\"License\") + \" (\" + metaprops.get(section).get(\"LicenseURL\") + \")\" + linesep).getBytes());\n                    fos.write(new String(\"Download: \" + metaprops.get(section).get(\"Download\") + linesep).getBytes());\n                    fos.write(new String(\"Source available at: \" + metaprops.get(section).get(\"SourceCode\") + linesep + linesep).getBytes());\n                }\n            }\n            if (new File(files[i].getPath() + \".extra\").exists()) {\n                fos.write(new String(\"The author says:\" + linesep).getBytes());\n                FileInputStream in = new FileInputStream(new File(files[i].getPath() + \".extra\"));\n                int len;\n                byte[] buf = new byte[1024];\n                while ((len = in.read(buf)) > 0) {\n                    fos.write(buf, 0, len);\n                }\n            }\n            fos.write(linesep.getBytes());\n        }\n        fos.close();\n    }\n", "label": 1, "substitutes": {"write": ["rite", "zip", "output", "end", "run", "all", "save", "post", "sync", "load", "after", "open", "file", "out", "check", "append", "delete", "writer", "Write", "flush", "update", " rewrite", "create", "parse", "println", "process", "handle", "download"], "jarOut": ["garIn", "jarOutput", "tarOUT", "jarIn", "sheetOutput", "tarOut", "jarout", " jarCatalog", "jarCatalog", "jarOUT", "garout", " jarOutput", "serOUT", "javaout", "tarOutput", "serOut", " jarOUT", " jarout", "javaOUT", "javaCatalog", "sheetIn", "garOut", "JarOutput", "JarOUT", "JarIn", " jarIn", "serIn", "sheetOUT", "javaOutput", "serout", "garOUT", "JarCatalog", "JarOut", "javaIn", "tarout", "javaOut", "sheetOut", "Jarout"], "allEntries": ["allentories", "allenties", " allEnties", " allEntories", "allChrys", "Allentries", "allTrys", "allEntry", "AllEntries", "AllEntry", "allChories", "allEntrs", "allentry", "allAddries", "allTry", "allEntrys", "Allentrs", "allChries", "allentries", "allentrs", "allEntories", "allAddry", "allentrys", "allEnties", "allTrs", "AllEntrys", "allTries", "allAddrys", "Allentrys", " allEntrys", "Allentry", "AllEntrs", "allChies"], "iterator": ["order", "handler", "loader", "i", "outer", "cmp", "uri", "ators", "starter", "division", "entry", "now", "ie", "slice", "heid", "inter", "inner", "end", "started", "oper", "walker", "later", "ter", "set", "instance", "gener", "done", "query", "keeper", "inst", "engine", "iter", "next", "loop", "er", "pie", "filter", "Iterator", "reader", "running", "river", "collection", "parser", "section", "ator", "Iter", "size", "init", "or", "creator", "start", "consider", "eni", "runner", "ski", "skip", "stream", "processor", "finder", "step", "former", "basic", "list"], "jar": ["zip", "base", "audio", "pkg", "job", "ssl", "mag", "drop", "entry", "json", "java", "tar", "jo", "record", "tag", "keeper", "sheet", "zone", "magic", "in", "ler", "bag", "er", "docker", "bar", "Jar", "tab", "binary", "dir", "browser", "config", "file", "archive", "war", "pod", "star", "style", "plugin", "folder", "start", "image", "pack", "ski", "jam", "url", "ser", "parse", "cookie", "container", "ar", "module", "space"], "jarEntries": ["jarEntryorts", "jarTies", "jarErrys", "jarAires", "jarErorts", "jarAories", "jarIntriers", " jarEntories", "jarAries", "JarEnties", "parseEntories", "jarEntrs", "jarEories", "jarEnires", "jarErries", "jarEntriers", "jarEnries", "parseEntries", "jarErs", "parseEries", "parseEriers", " jarEnties", "jarEnies", "JarEntorts", "jarEntorts", "JarEntrys", "JarEntries", "jarTories", "parseErs", "jarEnories", "jarTires", "parseEntrs", "jarTries", "parseEories", "parseEntriers", "jarEntires", "jarEntrys", " jarEnries", "jarIntrs", "jarEntryies", "jarEntryrys", "jarEriers", "jarIntries", "jarIntories", "jarEries", "jarAies", " jarEnies", " jarEnires", "jarEntryries", "jarEnties", " jarEntires", " jarEnories", "jarEntories"], "o1": ["O1", "opart", "Opart", "opOne", "oinf", "oaone", "oa11", "so1", "O11", "oe11", "oa91", " oOne", " o3", "soOne", "po11", "o91", "op3", "O0", "oa0", " o0", "oone", "o3", "oe3", "po1", "so3", "oe1", "oe91", "oeone", "oeinf", " o11", "O3", "oa4", "op1", "oepart", " o91", "OOne", "oaOne", "o4", "o11", " o4", "oa1", "o0", " oone", "oainf", "oOne", " oinf", "po4", " opart"], "entryStream": ["entrySteam", "zipString", "inputSteam", "connectionReader", "connectionStream", "zipstream", " entrystream", "EntryString", "entryString", " entryString", "connectionSteam", "entrystream", "inputStream", "EntrySteam", " entrySteam", "entryReader", "zipStream", "Entrystream", "zipSteam", " entryReader", "EntryStream", "inputReader"]}}
{"id1": "16378239", "id2": "16142024", "code1": "    public static DigitalObjectContent byReference(final InputStream inputStream) {\n        try {\n            File tempFile = File.createTempFile(\"tempContent\", \"tmp\");\n            tempFile.deleteOnExit();\n            FileOutputStream out = new FileOutputStream(tempFile);\n            IOUtils.copyLarge(inputStream, out);\n            out.close();\n            return new ImmutableContent(tempFile);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        throw new IllegalStateException(\"Could not create content for input stream: \" + inputStream);\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"byReference": ["Byref", "ofReference", "orref", "orLink", "toLink", "ofExternal", "ofLink", "ByExternal", "toReference", "toExternal", "ByReference", "ByLink", "orReference", "toref", "ofref", "orExternal"], "inputStream": ["outputStream", "inputSteam", "inSteam", "InputFile", "outputString", "InputString", "outputstream", "tempReader", "inputFile", "inReader", "inStream", " inputString", " inputObject", "instream", "inputObject", "inputReader", "outputFile", "Inputstream", "tempStream", "InputObject", "InputReader", "outputObject", "outputSteam", "InputSteam", "tempSteam", "inputstream", "inputString", "tempstream", " inputstream", "InputStream"], "tempFile": [" tempDir", "fakePage", "TempContent", "tmpfile", "tmpContent", "fakeDir", " tempFiles", "tmpFiles", "TempFiles", "fakeFiles", "tempFiles", "tempPage", "fakeStream", " tempContent", "Tempfile", "tempF", "tmpStream", "tempStream", "tempContent", "fakeFile", "fakeF", "tempfile", "tmpF", " tempfile", "tmpPage", "tempDir", " tempPage", "fakefile", " tempStream", "tmpDir", " tempF", "TempFile", "tmpFile"], "out": ["to", "ex", "array", "writer", "url", "resource", "write", "server", "plain", "copy", "null", "image", "connection", "init", "io", "outer", "data", "this", "later", "sync", "part", "output", "in", "f", "result", "o", "Out", " in", "conn", "temp", "instance", "source", "flush", "client", "a", "base", "outs", "user", "object", "exec", "file", "obj", "err", "extra", "OUT", "path", "pool", "again", "line", "ext"]}}
{"id1": "18451704", "id2": "9479502", "code1": "    public boolean isValidPage(BookPage page) {\n        boolean isValid = false;\n        try {\n            if (page.getType() == BookPage.TYPE_RESOURCE) {\n                BookPagePreviewPanel panel = new BookPagePreviewPanel(dControl, true);\n                panel.setCurrentBookPage(page);\n                isValid = !page.getUri().equals(\"\") && panel.isValid();\n            } else if (page.getType() == BookPage.TYPE_URL) {\n                URL url = new URL(page.getUri());\n                url.openStream().close();\n                isValid = true;\n            } else if (page.getType() == BookPage.TYPE_IMAGE) {\n                if (page.getUri().length() > 0) isValid = true;\n            }\n        } catch (Exception e) {\n            isValid = false;\n        }\n        return isValid;\n    }\n", "code2": "    private File unpackZIP(URL url, String dirName) {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof JarURLConnection) {\n                File destDir = new File(getExtensionsDirectory() + EGEConstants.fS + dirName);\n                destDir.mkdirs();\n                EGEIOUtils.unzipFile(((JarURLConnection) connection).getJarFile(), destDir);\n                return destDir;\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Could not unzip jar file.\", e);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"isValidPage": ["IsValidContent", "isAvailableBook", "isAvailablepage", "isLegalBook", "isAvailablePage", "IsInvalidPage", "IsInvalidpage", "isAvailableContent", "isLegalpage", "isLegalPage", "isValidpage", "isInvalidpage", "IsValidBook", "IsValidPage", "isLegalContent", "IsValidpage", "isInvalidBook", "isValidBook", "isValidContent", "isInvalidPage", "isInvalidContent", "IsInvalidBook", "IsInvalidContent"], "page": ["resource", "route", "current", "view", "http", "pl", "manager", "book", "p", "image", "html", "filter", "next", "parent", "version", "file", "pages", "player", "cache", "pb", "request", "comment", "facebook", "about", "this", "user", "profile", "pe", "model", "office", "admin", "button", "data", "module", "message", "block", "class", "section", "project", "instance", "channel", "pg", "xml", "language", "www", "display", "content", "frame", "document", "f", "home", "type", "menu", "account", "client", "chart", "name", "site", "wiki", "title", "platform", "object", "child", "app", "base", "server", "config", "settings", "Page", "article", "e", "result", "change", "plugin"], "panel": ["pan", "group", "row", "window", "paper", "player", "map", "channel", "table", "view", "board", "area", "tool", "circle", "wall", "screen", "label", "list", "conference", "square", "book", "browser", " Panel", "frame", "part", "layout", "coll", "server", "settings", "bean", "pal", "bar", "tab", "journal", "el", "plan", "widget", "button", "filter", "Panel", "menu", "data", "plugin", "info", "flower", "plane", "chart", "block"], "isValid": ["itvalid", "hasvalid", " isOpen", "isActive", "osVal", "ISValid", " isInvalid", " isVal", "osValid", "ISvalid", "osvalid", "asActive", "asValid", "isOk", "isaValid", " isLegal", "isaActive", "IsValid", " isOk", "itValid", " isvalid", "ISVal", "sValid", "hasInvalid", "isvalid", "idLegal", "hasValid", "IsLegal", "isInvalid", "ISInvalid", "isaInvalid", "itInvalid", "isOpen", "sInvalid", "IsInvalid", " isActive", "isLegal", "Isvalid", "svalid", "hasLegal", "asOpen", "ISLegal", "idValid", "idvalid", "sLegal", "isVal", "asOk", "osInvalid", "asInvalid", "asLegal", "asvalid", "isaOpen", "idOk"], "url": ["resource", "large", "album", "blog", "channel", "string", "http", "www", "URL", "path", "layer", "open", "feed", "Url", "user", "object", "address", "bel", "browser", "l", "connection", "base", "server", "location", "plug", "sl", "f", "control", "image", "ssl", "follow", "fl", "ball", "r", "b", "web", "uri", "stream", "source", "file"]}}
{"id1": "12128591", "id2": "20208819", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\", nsae);\n            }\n        }\n        try {\n            digest.update(data.getBytes(\"utf-8\"));\n        } catch (UnsupportedEncodingException e) {\n            log.error(e);\n        }\n        return encodeHex(digest.digest());\n    }\n", "code2": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["sum", "copy", "add", " Hash", "hex", " hashing", "Hash", "component", "str", "build", "text", "check", "h", "get", "log", "pack", "dump", "update", "parse", "SHA", " hashes", "print", " fingerprint", "crypt", "code"], "data": ["string", "info", "address", "buffer", "class", "input", "base", "output", "response", "message", "result", "hex", "s", "length", "memory", "database", "in", "alpha", "content", "source", "cache", "value", "media", "connection", "str", "DATA", "text", "body", "p", "style", "format", "name", "template", "image", "bytes", "a", "missing", "padding", "pad", "dat", "api"], "digest": ["Digester", "signester", "DigEST", "Diger", "mdast", "signEST", "signest", "signusher", "bigest", "peder", "generester", "decest", " diger", "decit", "digit", " digusher", "generests", "logenge", "logester", " dige", "mdest", " digger", "pede", "digester", "digests", "mdester", "Digenge", "digger", "decester", "Digest", "decests", "mdenge", "bigusher", "Digusher", "digusher", "diger", "digenge", "pedester", " digEST", " digester", "bigester", "Digger", " digests", "Digast", "dige", "generit", "generest", "pedest", "digast", " digit", "logest", "logast", "Dige", "digEST", "bigger"]}}
{"id1": "21232043", "id2": "1473212", "code1": "    @Override\n    public File call() throws IOException {\n        HttpURLConnection conn = null;\n        ReadableByteChannel fileDownloading = null;\n        FileChannel fileWriting = null;\n        try {\n            conn = (HttpURLConnection) url.openConnection();\n            if (size == -1) {\n                size = conn.getContentLength();\n            }\n            fileDownloading = Channels.newChannel(conn.getInputStream());\n            fileWriting = new FileOutputStream(file).getChannel();\n            long left = size;\n            long chunkSize = BLOCK_SIZE;\n            for (long downloaded = 0; downloaded < size; left = size - downloaded) {\n                if (left < BLOCK_SIZE) {\n                    chunkSize = left;\n                }\n                fileWriting.transferFrom(fileDownloading, downloaded, chunkSize);\n                downloaded += chunkSize;\n                setProgress(downloaded);\n            }\n        } finally {\n            if (file != null) {\n                file.deleteOnExit();\n            }\n            if (conn != null) {\n                conn.disconnect();\n            }\n            if (fileDownloading != null) {\n                try {\n                    fileDownloading.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0441\u043a\u0430\u0447\u0438\u0432\u0430\u043d\u0438\u044f\", ioe);\n                }\n            }\n            if (fileWriting != null) {\n                try {\n                    fileWriting.close();\n                } catch (IOException ioe) {\n                    Helper.logger.log(Level.SEVERE, \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u0437\u0430\u043a\u0440\u044b\u0442\u044c \u043f\u043e\u0442\u043e\u043a \u0437\u0430\u043f\u0438\u0441\u0438 \u0432 \u0444\u0430\u0439\u043b\", ioe);\n                }\n            }\n        }\n        return file;\n    }\n", "code2": "    @Test\n    public void test_validate_geo_getEvents() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=geo.getevents&location=madrid&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetEvents_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"call": ["exec", " flush", "url", "send", " invoke", "output", "transfer", " method", "request", "connect", "start", " upload", "next", "write", "upload", " end", "Call", " complete", "Upload", "close", "copy", "work", "process", "execute", "download", " request", "open", "run"], "conn": ["net", "exec", "fp", "url", "cm", "cf", "client", "ca", "ai", "uc", "ann", "reg", "cb", "db", "log", "connect", "conv", "ls", "cp", "lock", "c", "ci", "cc", "rt", "ct", "ssl", "connection", "Connection", "n", "config", "enc", "sync", "socket", "nt", "loc", "loader", "co", "dc", "api", "p", "pg", "dn", "http", "rc", "cli", "col", "channel", "ch", "cn", "act", "init", "server", "coll", "con", "nc", "Conn", "open", "conf", "ctx", "f", "cmp", "po"], "fileDownloading": ["FileUploaduing", "fileFieldING", "filedownloadancing", "resourceDownloadging", "fileMonitording", " fileProcessting", "FileDownloading", "fileDownloadbing", "fileDownloadging", " fileDownloadting", "filePulling", "fileUploading", " fileProcessing", "fileFieldging", "fileMonitors", "fileProcessing", "fileUploadding", "fileUploads", " fileDownloadancing", "FileDownloaduing", "fileUploadING", "filedownloading", "fileDownloads", "FileDownloadbing", "fileFunding", "fileReviewING", "resourceDownloading", " fileProcessancing", "FileUploading", "fileProcesser", "fileUploadcing", "filePullging", "fileSpawning", "filedownloadging", "fileDownloadING", "fileSpawnancing", "fileFieldding", "fileFundting", "fileReviewbing", "fileProcessting", "fileDownloader", "FileUploadING", "fileSpawnging", "filedownloadING", " fileProcesser", "fileReviewuing", "fileMonitoring", "fileDownloadding", "FileDownloadING", "FileUploadbing", "fileFunder", " fileDownloadging", "fileDownloaduing", " fileDownloads", "fileMonitorcing", "fileUploaduing", "fileDownloadcing", "fileProcessancing", "fileFundancing", "filePullancing", "filedownloadding", "fileDownloadting", " fileDownloadcing", "filedownloadting", " fileDownloadING", "resourceDownloadancing", "filedownloader", "resourceDownloader", " fileDownloader", "fileReviewing", "fileFielding", "filePuller", " fileDownloadding", "fileDownloadancing", "fileUploadbing", "fileSpawner"], "fileWriting": ["resourceWriter", "FileWriting", "FileReading", " fileWrit", " fileWritten", "urlWriting", "resourceWriting", " fileSetting", " fileWriter", "fWriter", "mailWriter", "urlWriter", "fileWorking", "resourcewriting", "ioWorking", " filewriting", "placeWriter", "FileLoading", "FileWriter", "fileCreating", "iowriting", "FileCreating", "fileLoading", "ioWriting", "fileSetting", "urlLoading", " fileReading", "fWriting", "fileWriter", "fwriting", " fileCreating", "mailWriting", "placeSetting", "fCreating", "ioReading", "fileWritten", "fileWrit", "FileWritten", "resourceWrit", "fileReading", "placeWriting", " fileLoading", "mailWrit", "filewriting", " fileWorking", "FileSetting", "FileWorking", "mailwriting", "Filewriting", "placeWritten"], "size": ["address", "level", "cache", "clean", "mini", "Size", "length", "name", "string", "time", "offset", "max", "six", "si", "storage", "large", "code", "small", "count", "body", "empty", "SIZE", "sized", "speed", "loc", "sync", "uri", "timeout", "ize", "close", "scale", "content", "fee", "page", "data", "file", "low", "width", "password", "limit", "capacity", "unit", "sum", "zero"], "left": ["two", "position", "less", "cl", "loading", "needed", "own", "found", "right", "lo", "child", "available", "fl", "label", "auto", "length", "offset", "inner", "L", "missing", "led", "lower", "next", "failed", "pl", "limited", "small", "lost", "used", "empty", "sized", "little", "loc", "diff", "Left", "loader", "leave", "la", "loaded", "scale", "l", "held", "last", "shift", "low", "spread", "limit", "coll", "fail", "lim", "second", "ell", "le", "partial"], "chunkSize": ["chrawsize", "chacketSize", "chobLength", "coprawsize", "chumpize", "chacketsize", "chunkNum", "coprawSize", "ChunkSize", "chicaLen", "chumpSize", "chunkLen", "chicaSize", "copunksize", "coprawBreak", " chacketsize", "chumpLength", "crunkSize", "chunkssize", "ChunkLen", "coprawLength", "ChunkLength", "chunksLength", "crgroupsize", " chacketLength", "copunkBreak", "changeLength", "copunkLength", " chacketSize", " chunkNum", "chunksize", "chgroupsize", " chacketNum", "crgroupize", "crunkLength", "chicasize", "changesize", "chunksBreak", "changeSize", "chunksLen", "crunksize", "chacketLength", "chicaLength", "chobSize", "chgroupize", "chobsize", "chunkize", " chunkLength", "crunkize", " chunksize", "chunkBreak", "chrawLength", "chrawSize", "chunkLength", "changeBreak", "copunkSize", "chunksNum", "chacketNum", "chunksSize", "chobNum", "chrawBreak", "chumpsize", "crgroupSize", "crgroupLength", "chgroupSize", "Chunksize", "chgroupLength"], "downloaded": ["weightloaded", "upled", "downsloader", "defload", "ownloading", "ownload", " download", "downsloading", "ownled", "uploader", " downwritten", "downswritten", "Download", "defloading", "downled", "Downloaded", "downsloaded", "uploading", "upload", "Downloading", " downled", "Downloader", "downwritten", "uploaded", "weightwritten", "downloader", " downloader", "defloaded", "downsload", "weightled", "downsled", "weightload", "defloader", "Downled", " downloading", "download", "ownloader", "downloading", "ownloaded"]}}
{"id1": "16308040", "id2": "16092702", "code1": "    public boolean update(String dbName, Query[] queries) throws ServiceException {\n        Connection con = null;\n        PreparedStatement pstmt = null;\n        int rows = 0;\n        try {\n            con = getDbConnection().getConnection(dbName);\n            con.setAutoCommit(false);\n            for (int i = 0; i < queries.length; i++) {\n                Query query = queries[i];\n                System.out.println(query.getSql());\n                pstmt = con.prepareStatement(query.getSql());\n                addParametersToQuery(query, pstmt);\n                rows += pstmt.executeUpdate();\n            }\n            con.commit();\n            return rows > 0;\n        } catch (DbException e) {\n            log.error(\"[DAOService::update]  \" + e.getMessage(), e);\n            log.error(\"[DAOService::update] Execute rollback \" + e.getMessage(), e);\n            try {\n                con.rollback();\n            } catch (SQLException e1) {\n                log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e);\n                throw new ServiceException(e.getMessage());\n            }\n            throw new ServiceException(e.getMessage());\n        } catch (SQLException e) {\n            log.error(\"[DAOService::update]  \" + e.getMessage(), e);\n            try {\n                con.rollback();\n            } catch (SQLException e1) {\n                log.error(\"[DAOService::update] Errore durante il rollback \" + e.getMessage(), e);\n                throw new ServiceException(e.getMessage());\n            }\n            throw new ServiceException(e.getMessage());\n        } finally {\n            closeConnection(con, pstmt, null);\n        }\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"update": ["save", "where", "database", "create", "method", "sync", "set", "add", "all", "updated", "Update", "run", "build", "db", "delete", "id", "ql", "result", "replace", "UPDATE", "sql", "execute", "insert", "write", "end", "apply"], "dbName": ["DbName", "DBname", "tablename", "DBFamily", "dbname", "dbFamily", " dbNames", "connectionRef", "databaseRef", "DbFamily", "dbNames", "tableName", "tableFamily", "databaseNames", " dbname", "connectionName", "DBName", "databasename", "databaseName", " dbRef", "connectionNames", "connectionname", "Dbname", "dbRef"], "queries": ["quotes", "quources", "shqs", " quicks", "questqs", " quqs", "sheries", "qicks", "qqs", "quos", "quicks", "shos", "questeries", "shands", "qotes", "quqs", "Queries", "qos", "votes", "vqs", "qands", "quands", "Quands", "qeries", "Quicks", "questands", "qources", "vands", "Quources", "questos", "Quotes", "veries", " quources", "Quqs"], "con": ["connection", "lock", "cur", "ver", "cn", "reg", "fac", "cos", "socket", "un", "session", "ca", "non", "syn", "pub", "en", "pc", "ann", "rc", "log", "pl", "fun", "conn", "cache", "user", "conf", "can", "cr", "win", "Con", "ran", "client", "row", "ci", "cc", "db", "connect", "uc", "CON", "cf", "cond", "h", "exec", "xc", "mon", "close", "cl", "pen", "conv", "core", "Conn", "c", "an", "fa", "com", "co", "cas", "crit", "coll", "cm", "mc", "cons", "cp", "ac", "col", "fc", "bc", "act"], "pstmt": ["pctdt", "pctm", " pppm", "Pstql", " pstmp", "pactlt", "pstnt", " pactmt", " pppmd", "pptmp", " pstmd", "Pstdt", "ppput", "pptmit", "Pstmit", "pastm", "pctmd", "pstrmt", "pctut", " pactlt", " pstut", "pstql", "Pstmp", "pssnt", "pctamp", "pptmt", "pstlt", "pstmit", "pastmt", "pctmt", "pqlt", " ppput", "Pstm", "pctql", "pastmd", "pstamp", "pqmt", "pqmp", "pstdt", "psthmit", " pactamp", "Pstmd", " pppmt", "pactmp", " pactmp", "Pctmt", "pprm", "pppmt", "Pstmt", "pprql", "pprnt", "pssm", "pstmd", "pstrm", "pssdt", "pssmt", "psthmd", "Pctql", "pctlt", "Pctmp", "psthmp", "pctmit", "pstrnt", "Pctmit", "pstmp", "pstut", "pactamp", " pstlt", "pctmp", "pastut", "pactmt", "pqamp", "Pctdt", "pppm", "pprmt", " pstamp", " pstm", "Pstnt", "psthmt", "pptmd", "Pctnt", "pppmd", "pstm", "pstrdt", "Pctm", "Pctmd", "pctnt"], "rows": ["heads", "pages", "values", "ues", "blocks", "times", "issues", "s", "ins", "results", "ries", "acks", "ips", "ures", "gets", "reads", "roots", "files", "flows", "rs", "ends", "posts", "runs", "lines", "orders", "row", "ks", "tracks", "count", "ails", "ings", "loads", "objects", "odes", "errors", "checks", "fields", "keys", "locks", "users", "projects", "tests", "bugs", "ches", "length", "rors", "rown", "ows"], "i": ["x", "f", "y", "si", "ti", "ri", "q", "type", "slice", "m", "p", "j", "info", "pi", "k", "ori", "hi", "bi", "I", "u", "b", "di", "multi", "part", "qi", "l", "e", "o", "ini", "ci", "z", "h", "xi", "v", "oi", "ui", "mi", "yi", "li", "n", "uri", "ii", "io", "c", "in", "ni", "id", "index", "ai", "gi", "ip"], "query": ["feature", "connection", "statement", "f", "name", "question", "scan", "q", "error", "database", "sc", "command", "qq", "m", "table", "sync", "comment", "rule", "commit", "qu", "model", "check", "user", "iq", "qi", "bug", "engine", "e", "key", "sq", "row", "service", "quer", "eight", "entry", "call", "child", "parse", "condition", "request", "block", "exec", "ctx", "parent", "general", "dq", " Query", "server", "unit", "code", "script", "search", "module", "ic", "action", "ql", "result", "eries", "sql", "select", "Query"]}}
{"id1": "8135072", "id2": "17996547", "code1": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"setImg": ["setImgm", "setImageg", "getImagevg", "getImagegs", "setImagegs", "setAmg", "getImageg", "getImgs", "setIMgs", "getImvg", "getImgm", "setIMgm", "setAmvg", "setImagevg", "getImagegm", "setImgs", "setImagegm", "setAmgs", "setAmgm", "setImvg", "setIMg", "getImg", "setIMvg"], "jFileChooser1": ["jFileCloserOne", "jFileChooser3", "jFileChooseone", "jFileChoose2", "jFileCloser3", "jFileChooserone", "jFileChoosing3", "jFileChoosing2", "jFileChoiser2", "jFileChoosen1", "jFileChoouter1", "jFileChooserOne", "jFileChoosen3", "jFileChoosingL", "jFileChooseL", "jFileChoitcher2", "jFileClose2", "jFileChoitcher3", "jFileClose01", "jFileChoosing1", "jFileChoose3", "jFileChoicker3", "jFileCloserL", "jFileChoickerOne", "jFileCloser1", "jFileChoouter2", "jFileChoosingOne", "jFileChoosen2", "jFileChoosen01", "jFileChoicker1", "jFileChoitcher1", "jFileChoitcherone", "jFileChoiser3", "jFileChoiser1", "jFileCloseOne", "jFileChoickerL", "jFileChoose01", "jFileCloser2", "jFileChooser01", "jFileChoosenone", "jFileCloser01", "jFileChooseOne", "jFileChooserL", "jFileChoouter3", "jFileChoose1", "jFileChooser2", "jFileChoouter01", "jFileChoiserOne", "jFileClose3", "jFileClose1", "jFileCloseL"], "separator": ["terminate", "seator", "separated", "generating", "separate", "separinator", "locating", "decigator", "escapate", "generate", "locoder", " separators", " separate", "escapators", "separner", " separner", "escapigator", "escapator", "locator", "location", "separoder", "variated", "seoder", "peration", "decators", "decate", "variation", "locate", "separigator", " separar", "separation", "generator", " separinator", "terminator", " separoder", "seate", "locinator", " separated", " separigator", "seinator", "perner", "separar", "separating", "variator", "terminar", "terminner", "perar", "perate", "variate", "generation", "decator", " separation", " separating", "perated", "perator", "separators"], "dirImg": ["dirImagesg", " dirImgs", " dirImimg", "dirImgb", "dirimg", "dirIMgd", "dirImvg", "dirIMgb", "directoryImgs", "folderImgs", "dirSeg", "dirImgs", "dirImgd", "directoryImagesg", "dirAnimgd", "dirSevg", "dirIMimg", "dirSegs", "folderImvg", " dirImgd", "dirAmog", "directoryImageg", "directoryImagegs", "dirUrg", "dirImog", "homeIMg", "dirImagegb", "directoryImgb", "homeImvg", "dirImsg", "directoryImg", "dirImagegs", "dirAnimvg", "dirimsg", "dirAnimm", "dirUrimg", "dirIMvg", "dirAmgs", "dirImimg", "folderImg", "dirUrgd", "folderImog", "dirAmg", "homeIMm", "dirIMgs", "dirIMm", "dirimgb", "dirAmvg", "dirImm", "dirImageg", "dirimgs", "homeIMvg", "dirSeog", "dirAnimg", "homeIMgd", "dirUrgs", "dirIMsg", "dirIMg", "directoryImagegb", "homeImm", "homeImg", "directoryImsg", "homeImgd"], "index": ["ind", "position", "match", "level", "size", "pos", "key", "i", "default", "action", "slice", "id", "page", "section", "address", "loc", "diff", "num", "path", "weight", "line", "value", "part", "len", "end", "x", "active", "axis", "type", "offset", "number", "Index", "name", "string", "point", "field", "length", "inc", "condition"], "imgName": [" imgType", "imgname", "imagePath", " imgPath", "iconType", "imgPart", "imageName", "iconPath", "iconName", " imgname", "imageType", "iconname", "ngPart", "imagename", "ngName", "imgType", " imgPart", "ngPath", "ngname", "imagePart", "imgPath"], "newPath": ["newFile", "NewPath", "oldPath", "NewFile", "workingName", "NewLocation", "Newpath", " newLocation", "nextFile", "nextLocation", "workingFile", "nextpath", "newpath", "oldpath", "newName", " newUrl", " newName", "workingpath", "nextPath", "oldFile", "nextUrl", "NewName", "workingPath", " newFile", " newpath", "newLocation", "newUrl", "NewUrl", "oldLocation"], "inputFile": ["InputFile", " inputPage", "InputFolder", "outputPath", "viewFile", "InputDirectory", " inputFolder", "InputFiles", " inputDirectory", "inputFolder", " inputStream", "InputDir", " inputFiles", "viewFolder", " inputPath", "outputFiles", "InputStream", "InputPage", "inPath", "inputDirectory", "viewDirectory", "inDir", "viewPath", "inputFiles", "InputPath", " inputDir", "inFile", "inputDir", "inputPage", "inputStream", "inputPath", "outputPage", "inStream"], "outputFile": ["outputDirectory", " outputFolder", "OutputDirectory", "targetFolder", "writefile", "outputPath", "writeFile", "outputDir", "targetPath", "outputStream", "inputFolder", "OutputFiles", " outputStream", " outputDirectory", "outputFolder", " outputfile", "outputFiles", "targetFiles", "OutputFile", "OutputPath", "inputDirectory", "inputfile", "writeStream", " outputDir", "inputFiles", "writeDir", " outputPath", "inputDir", " outputFiles", "targetFile", "outputfile", "inputStream", "inputPath"], "in": ["r", "h", "pin", "n", "inn", "fa", "isin", "i", "is", "socket", "init", "cin", "input", "id", "ex", "sin", "din", "conn", "plus", "diff", "lin", "connection", "a", "inner", "io", "nin", "ini", "into", "part", "inside", "f", "o", "login", "err", "ins", "bin", "In", "l", "reader", "IN", "as", "again", "lock", "win", "source", "up", "inc"], "out": ["Out", "plain", "error", "client", "writer", "sync", "off", "i", "output", "socket", "copy", "ex", "cache", "conn", "to", "plus", "inner", "io", "line", "file", "part", "down", "o", "lib", "exec", "err", "ins", "other", "net", "co", "name", "bin", "OUT", "again", "IN", "point", "outs", "outer", "up", "inc"], "c": ["r", "C", "sc", "m", "p", "ic", "n", "cp", "i", "ce", "rc", "cc", "character", "dec", "e", "cr", "cy", "ci", "lc", "t", "cu", "code", "nc", "bc", "pointer", "dc", "cm", "xc", "uc", "esc", "x", "f", "col", "cent", "o", "enc", "ch", "abc", "k", "ac", "b", "arc", "v", "cl", "ct", "pc", "l", "d", "ec"], "bckImg": ["bccImf", "bckIngl", "bckIngs", "bckInf", "bckImgl", "bccPg", "bckimg", "bccPgl", "bckimf", "bckImf", "bckPgs", "bckPg", "bckPgl", "bccPf", "bckPf", "bckimgs", "bckimgl", "bckImgs", "bccImg", "bccImgs", "bccImgl", "bckIng", "bccPgs"]}}
{"id1": "9805906", "id2": "18114701", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    public InputSource resolveEntity(String publicId, String systemId) {\n        String resolved = getResolvedEntity(publicId, systemId);\n        if (resolved != null) {\n            try {\n                InputSource iSource = new InputSource(resolved);\n                iSource.setPublicId(publicId);\n                URL url = new URL(resolved);\n                InputStream iStream = url.openStream();\n                iSource.setByteStream(iStream);\n                return iSource;\n            } catch (Exception e) {\n                catalogManager.debug.message(1, \"Failed to create InputSource (\" + e.toString() + \")\", resolved);\n                return null;\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"dump": ["df", "println", "zip", "copy", "export", "files", "download", "dir", "store", "all", "out", " dumping", "load", "f", " dumped", "Dir", "transfer", "save", "diff", "data", " dumps", "ump", "flush", "info", "update", "ln", "db"], "source": ["resource", "scene", "slave", "use", "string", "current", "Source", "view", "http", "service", "core", "input", "ource", "series", "from", "slice", "this", "address", "unit", "connection", "base", "s", "server", "iter", "SOURCE", "start", "sin", "remote", "se", "ources", "parent", "stream", "uri", "src", "site", "file"], "target": ["resource", "large", "root", "project", "effect", "host", "table", "pointer", "path", "platform", "enemy", "force", "dest", "arget", "database", "object", "address", "alias", "it", "goal", "connection", "base", "replace", "out", "port", "settings", "office", "top", "Target", "to", "result", "next", "output", "follow", "null", "parent", "master", "src", "file", "template"], "is": ["ics", "or", "us", "isa", "ses", "ios", "ip", "im", "ens", "ois", "bs", "isl", "opens", "was", "iris", "oss", "has", "as", "gets", "abs", "ais", "io", "IS", "ui", "in", "ins", "bos", "obs", "s", "Is", "ls", "iso", "iss", "ops", "its", "ws", "cs", "isi", "i", "ori", "oses", "mis", "bis", "lis", "ai", "nis", "ps", "es", "info", "ists", "ris"], "os": ["or", "ks", "us", "ios", "bs", "osi", "ens", "ies", "o", "dos", "oa", "oss", "as", "io", "ais", "outs", "aos", "boot", "bos", "oes", "acs", "oos", "fs", "ose", "obs", "s", "pos", "nos", "vs", "los", "ops", "cos", "its", "cs", "Os", "i", "ori", "ues", "ds", "ros", "oses", "ips", "ols", "ss", "ps", "es", "OS", "ows"], "done": ["ready", "did", "started", "dirty", "gone", "defined", "got", "current", "after", "empty", "none", "die", "progress", " Done", " finished", "enabled", "part", "running", "disabled", "nice", "future", "expected", "complete", "confirmed", "foo", "due", "Done", "finished", "made", "dad", "odo", "next", "checked", "data", "last", "doing", "yes", "de", "always", "one", "later", "loaded", "once"]}}
{"id1": "22441244", "id2": "812803", "code1": "    public void send(org.hibernate.Session hsession, Session session, String repositoryName, int ideIdint, String to, String cc, String bcc, String subject, String body, Vector attachments, boolean isHtml, String charset, InternetHeaders headers, String priority) throws MailException {\n        try {\n            if (charset == null) {\n                charset = MimeUtility.javaCharset(Charset.defaultCharset().displayName());\n            }\n            if ((body == null) || body.trim().equals(\"\")) {\n                body = \" \";\n            }\n            Email email = null;\n            if (isHtml) {\n                email = new HtmlEmail();\n            } else {\n                email = new MultiPartEmail();\n            }\n            email.setCharset(charset);\n            Users user = getUser(hsession, repositoryName);\n            Identity identity = getIdentity(hsession, ideIdint, user);\n            InternetAddress _returnPath = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _from = new InternetAddress(identity.getIdeEmail(), identity.getIdeName());\n            InternetAddress _replyTo = new InternetAddress(identity.getIdeReplyTo(), identity.getIdeName());\n            InternetAddress[] _to = MessageUtilities.encodeAddresses(to, null);\n            InternetAddress[] _cc = MessageUtilities.encodeAddresses(cc, null);\n            InternetAddress[] _bcc = MessageUtilities.encodeAddresses(bcc, null);\n            if (_from != null) {\n                email.setFrom(_from.getAddress(), _from.getPersonal());\n            }\n            if (_returnPath != null) {\n                email.addHeader(\"Return-Path\", _returnPath.getAddress());\n                email.addHeader(\"Errors-To\", _returnPath.getAddress());\n                email.addHeader(\"X-Errors-To\", _returnPath.getAddress());\n            }\n            if (_replyTo != null) {\n                email.addReplyTo(_replyTo.getAddress(), _replyTo.getPersonal());\n            }\n            if ((_to != null) && (_to.length > 0)) {\n                HashSet aux = new HashSet(_to.length);\n                Collections.addAll(aux, _to);\n                email.setTo(aux);\n            }\n            if ((_cc != null) && (_cc.length > 0)) {\n                HashSet aux = new HashSet(_cc.length);\n                Collections.addAll(aux, _cc);\n                email.setCc(aux);\n            }\n            if ((_bcc != null) && (_bcc.length > 0)) {\n                HashSet aux = new HashSet(_bcc.length);\n                Collections.addAll(aux, _bcc);\n                email.setBcc(aux);\n            }\n            email.setSubject(subject);\n            Date now = new Date();\n            email.setSentDate(now);\n            File dir = new File(System.getProperty(\"user.home\") + File.separator + \"tmp\");\n            if (!dir.exists()) {\n                dir.mkdir();\n            }\n            if ((attachments != null) && (attachments.size() > 0)) {\n                for (int i = 0; i < attachments.size(); i++) {\n                    ByteArrayInputStream bais = null;\n                    FileOutputStream fos = null;\n                    try {\n                        MailPartObj obj = (MailPartObj) attachments.get(i);\n                        File file = new File(dir, obj.getName());\n                        bais = new ByteArrayInputStream(obj.getAttachent());\n                        fos = new FileOutputStream(file);\n                        IOUtils.copy(bais, fos);\n                        EmailAttachment attachment = new EmailAttachment();\n                        attachment.setPath(file.getPath());\n                        attachment.setDisposition(EmailAttachment.ATTACHMENT);\n                        attachment.setDescription(\"File Attachment: \" + file.getName());\n                        attachment.setName(file.getName());\n                        if (email instanceof MultiPartEmail) {\n                            ((MultiPartEmail) email).attach(attachment);\n                        }\n                    } catch (Exception ex) {\n                    } finally {\n                        IOUtils.closeQuietly(bais);\n                        IOUtils.closeQuietly(fos);\n                    }\n                }\n            }\n            String mid = getId();\n            if (headers != null) {\n                Header xheader;\n                Enumeration xe = headers.getAllHeaders();\n                for (; xe.hasMoreElements(); ) {\n                    xheader = (Header) xe.nextElement();\n                    if (xheader.getName().equals(RFC2822Headers.IN_REPLY_TO)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    } else if (xheader.getName().equals(RFC2822Headers.REFERENCES)) {\n                        email.addHeader(xheader.getName(), xheader.getValue());\n                    }\n                }\n            } else {\n                email.addHeader(RFC2822Headers.IN_REPLY_TO, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n                email.addHeader(RFC2822Headers.REFERENCES, \"<\" + mid + \".JavaMail.duroty@duroty\" + \">\");\n            }\n            if (priority != null) {\n                if (priority.equals(\"high\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"1\");\n                } else if (priority.equals(\"low\")) {\n                    email.addHeader(\"Importance\", priority);\n                    email.addHeader(\"X-priority\", \"5\");\n                }\n            }\n            if (email instanceof HtmlEmail) {\n                ((HtmlEmail) email).setHtmlMsg(body);\n            } else {\n                email.setMsg(body);\n            }\n            email.setMailSession(session);\n            email.buildMimeMessage();\n            MimeMessage mime = email.getMimeMessage();\n            int size = MessageUtilities.getMessageSize(mime);\n            if (!controlQuota(hsession, user, size)) {\n                throw new MailException(\"ErrorMessages.mail.quota.exceded\");\n            }\n            messageable.saveSentMessage(mid, mime, user);\n            Thread thread = new Thread(new SendMessageThread(email));\n            thread.start();\n        } catch (MailException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new MailException(e);\n        } catch (java.lang.OutOfMemoryError ex) {\n            System.gc();\n            throw new MailException(ex);\n        } catch (Throwable e) {\n            throw new MailException(e);\n        } finally {\n            GeneralOperations.closeHibernateSession(hsession);\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"send": ["open", "get", "create", "from", "set", "add", "text", "mail", "export", "address", "Send", "reply", "parse", "build", "submit", "exec", "delete", "transfer", "post", "message", "sent", "append", "execute", "write", "start", "end"], "hsession": ["HSessions", "openssession", "hsess", "opensessions", "hsSession", "hmession", "hhsession", "hhessions", "hession", "hsort", "hessions", "HSsession", "hmsession", "HSSession", "hsessions", "hhSession", "hessession", "hSession", "opensort", "hmSession", "hhess", "opensession", "hhort", "HSession", "opensSession", "hhession", "hssession", "hesort", "opensess", "hesession", "hmessions", "hesess"], "session": ["connection", "sl", "manager", "application", "state", "event", "class", "Session", "cache", "mail", "essions", "client", "proxy", "port", "project", "response", "parent", "context", "document", "server", "ession", "message", "chat", "resource", "host", "security", "site"], "repositoryName": ["repoositoryAddress", "repositoryFamily", "reposicleFamily", "repoositoryNAME", "repoitoryPath", "repositoryPath", "reposicleName", "repoitoryAddress", "reposessionNAME", "reposositoryNAME", "reposositoryPath", "reposicleAddress", "reposositoryName", "repoitoryEmail", "reposositoryFamily", "reposicationFamily", "reposicationName", "repoositoryName", "reposicationAddress", "reposositoryEmail", "repoitoryName", "repositoryAddress", "repoitoryFamily", "reposicleEmail", "reposessionName", "reposessionPath", "repositiveEmail", "repositoryNAME", "repositoryEmail", "repoositoryPath", "repositiveNAME", "reposositoryAddress", "reposicationEmail", "repoositoryFamily", "repositiveName", "reposessionEmail", "repoositoryEmail", "repoitoryNAME", "repositivePath"], "ideIdint": ["ideAuthints", "ideIdInt", "ideNameint", "ideidints", "IDEIdints", "ideIdints", "ideTimeInt", "ideAuthn", "ideidInt", "ideInn", "ideInint", "IDEidInt", "IDENameout", "IDEidint", "ideTimeout", "IDEIdInt", "ideIdout", "ideNameInt", "ideidn", "IDEIdout", "IDEidints", "IDENamenumber", "ideidint", "ideInfoout", "ideIdnumber", "IDENameint", "ideTimeint", "IDEIdn", "ideInfoint", "IDENameInt", "IDEIdnumber", "ideAuthint", "ideNameout", "ideInInt", "IDEIdint", "ideNamenumber", "ideAuthInt", "ideInints", "IDEidn", "ideInfonumber", "ideIdn", "ideTimenumber", "ideInfoInt"], "to": ["office", "name", "phone", "TO", "options", "from", "settings", "To", "top", "summary", "with", "mail", "by", "account", "client", "address", "reply", "sub", "source", "template", "mobile", "response", "tel", "uri", "title", "prefix", "message", "po", "token", "target", "about", "contact", "location", "company", "site"], "cc": ["cb", "cn", "phone", "nc", "card", "sc", "cca", "ca", "from", "ct", "ck", "ec", "rc", "cs", "lc", "cr", "account", "password", "client", "address", "dc", "comment", "ci", "uc", "cf", "CC", "cl", "code", "c", "ce", "tc", "contact", "company", "ac", "cus"], "bcc": ["abc", "pck", " bc", " brc", "fck", "bbrc", "pc", " bce", "bce", " bck", "pcc", "brc", "fcc", "bbck", "abcc", "bbc", "pce", "frc", "abce", "abck", "bck", "fc", "bc", "bbcc"], "subject": ["phone", "reason", "head", "method", "state", "format", "description", "mail", "content", "reply", "comment", "sub", "Subject", "template", "ject", "request", "response", "object", "filename", "uri", "author", "title", "prefix", "message", "header", "host", "username"], "body": ["connection", "lock", "data", "tree", "name", "reason", "how", "string", "plain", "base", "summary", "description", "part", "text", "inner", "wrapper", "content", "zip", "left", "line", "shell", "password", "normal", "secret", "comment", "style", "source", "template", "money", "response", "bound", "object", "foot", "url", "code", "view", "empty", "pass", "Body", "function", "message", "header", "resource", "length", "html", "media", "pod"], "attachments": ["embedings", "attachents", "messents", "embedment", "attachings", "Attachings", "embedments", "Attachents", "Attachments", "messment", "embedents", "Attachment", "messings", "messments"], "isHtml": ["isPhttp", "isChtml", "isPhhtml", " isChhtml", "isCtml", "isHive", " isHttp", " isWhail", "isWhtml", " isWhive", "isWhail", "isChhtml", " isWhhtml", "isCive", " isHail", "isCail", "isHhtml", "isChive", "isPhtml", " isWhtml", " isChail", "isHaail", "isWhive", "isChail", "isHattp", " isChtml", " isHhtml", "isHatml", "isHahtml", "isChttp", "isHail", "isWhhtml", " isHive", " isChttp", "isPhail", "isHttp"], "charset": ["charsET", "chaseset", "chasET", "chanset", "chaseting", "CharsET", "chasets", "chanspace", "chARSetting", "chearsete", "chansetter", "chearspace", "cheanset", "chansete", "chearsetter", "chARSET", "chARSeting", "Charseting", "charsetting", "chashesetter", "chARSets", "cheansET", "chackset", "charsetter", "chansetting", "chasheset", "chacksET", "chasetter", "Charsetting", "chaset", "cheansete", "chasetting", "cheansetter", "Charsets", "chacksetting", "chaseseting", "chaspace", "cheanspace", "chARSete", "Charset", "chearset", "charsets", "chearsET", "chashesET", "chansET", "cheansetting", "charsete", "charseting", "chARSet", "charspace", "chashespace", "chacksete", "chasesetting", "chearsetting", "chasesET"], "headers": ["mails", "options", "groups", "settings", " cookies", "status", "files", "content", "authors", "lines", "writers", " messages", "strings", " emails", " recipients", "classes", "comments", "names", "errors", "metadata", "params", "users", "header", "properties", "types", "ers"], "priority": ["phone", "reason", "language", "theme", "state", "mode", "status", "class", " title", "lang", "reply", "secret", "comment", "template", " severity", " recipients", "quote", "comments", "level", "code", "date", "author", "title", "prefix", "queue", "security", "length"], "email": ["office", "gmail", "ext", "data", "name", "oe", "ilo", "note", "create", "el", "auto", "em", "info", "install", "event", "en", "xml", "Email", "letter", "base", "ssl", "model", "text", "mail", "output", "online", "article", "entity", "zip", "line", "engine", "export", "account", "password", "e", "address", "external", "service", "fax", "test", "lex", "business", "template", "generic", "example", "response", "object", "url", "update", "enter", "document", "view", "server", "default", "core", "pm", "message", "contact", "result", "international", "print", "html", "liner", "element", "username"], "user": ["connection", "er", "profile", "data", "name", "type", "creator", "info", "ip", "me", "plugin", "model", "people", "account", "e", "member", "client", "User", "mobile", "object", "role", "character", "friend", "USER", "consumer", "author", "person", "id", "users", "uid", "resource", "token", "unknown", "string", "use", "username"], "identity": ["ethnicifier", "identication", "authorentity", "authority", "idITY", "ethnicity", "electricITY", "authoronymous", "authentonymous", "idifier", "authorities", "entityity", "IDENTity", "personITY", "idity", "personentity", "IdentITY", "authorication", "ethniciciary", "identiciary", "electriconymous", "ethnicITY", "installITY", "Identity", "IDENTities", "IDENTITY", "personity", "entityifier", "installonymous", "electricity", "authentITY", "publicity", "authentization", "authoriciary", "idization", "ethnicentity", "electricentity", "identonymous", "installentity", "authentication", "authentity", "idication", "publicITY", "entityonymous", "publicentity", "identization", "Identities", "Idententity", "IDENTentity", "entityization", "ethnicication", "identITY", "publiciciary", "authorifier", "idonymous", "authentifier", "idententity", "authorITY", "identifier", "identities", "installity", "personifier"], "_returnPath": ["_correctId", "_returnMid", "_resultPath", "_responseType", " _returnTo", " _backHalf", "_resultTo", "_returnHalf", " _returnUrl", "_resultHalf", "_displayPath", "_displayPart", "_backHalf", "_responsepath", "_backpath", "_displayUrl", "_inputMid", "_returnNode", "_returnPart", "_backName", "_returnText", "_inputPath", "_backType", "_returnDirectory", "_displayNode", "_successText", " _backTo", "_addType", "_backPath", "_backPart", " _backUrl", "_relationPath", "_backUrl", "_successId", "_resultName", "_returnTo", "_addPath", "_correctText", "_successPath", "_replyUrl", " _backPath", "_relationId", " _backPart", "_returnType", " _backName", "_replyMid", "_returnId", "_replyNode", "_correctPath", "_returnUrl", "_inputUrl", "_backTo", "_returnpath", "_relationDirectory", "_successDirectory", "_replyPart", "_addpath", "_correctDirectory", " _returnHalf", "_replyPath", "_displayMid", "_relationText", " _returnName", "_responsePath", "_returnName", "_inputNode", " _returnPart"], "_from": ["_for", "placeowner", "workwho", "worksource", "blockFrom", "_From", "_with", "blockerror", " _error", " _source", "workfrom", "blockto", " _owner", "existingto", "_source", "_who", "existingfrom", "_error", "blockfrom", "_owner", " _for", " _with", "existingowner", "placefrom", "workto", " _who", "placefor", " _From", "placeto", "existingfor"], "_replyTo": ["_replyFrom", "_returnUrl", "_respondTo", "_returnTo", "_respondTO", "_returnOf", " _returnTo", "_addFrom", "_reasonUrl", " _replyTO", "_closeTO", "_replyUrl", " _returnTO", "_reasonTo", "_replyTO", "_addAddress", "_commentOf", " _replyFrom", "_reasonTO", "_respondAddress", "_commentFrom", "_respondFrom", "_commentTO", "_replyAddress", "_commentTo", "_respondPoint", " _returnFrom", "_replyPoint", "_replyOf", " _replyUrl", "_returnAddress", " _returnUrl", "_returnPoint", "_addTo", "_respondUrl", "_returnFrom", "_addPoint", "_returnTO", "_closeTo", "_reasonFrom", "_closeOf", "_closeFrom"], "_to": [" _target", "_target", " _about", "Jfrom", "Jabout", "Jtarget", "_about", "Jto"], "_cc": [" _cd", " _ce", " _cf", "_cd", "_ce", "_cf"], "_bcc": [" _abc", " _bce", "_rbcs", " _bcs", "_abce", "_rbc", "_sbcs", "_sbc", " _bc", " _abcs", "_abcs", "_sbcc", "_abc", "_rbce", "_bce", "_bcs", "_rbcc", " _abce", "_sbce", "_bc", "_abcc", " _abcc"]}}
{"id1": "11477906", "id2": "9236363", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadApplicationSettings", "loaddefaultParameters", "loadGlobalSettings", "loadApplicationParameters", "loadGlobalConfiguration", "getdefaultsettings", "getDefaultSettings", "getdefaultSettings", "loadDefaultParameters", "getDefaultParameters", "loaddefaultsettings", "getDefaultsettings", "loaddefaultConfiguration", "getdefaultParameters", "loadApplicationsettings", "loadDefaultsettings", "getdefaultConfiguration", "loadApplicationConfiguration", "loaddefaultSettings", "loadGlobalParameters", "loadGlobalsettings", "getDefaultConfiguration", "loadDefaultConfiguration"], "configFileName": ["configFullLocation", "ConfigModuleName", "configFullUrl", "configModuleName", "configPlaceName", "configFilesTime", "ConfigFileString", "fileFILELocation", "configFileType", "ConfigModuleString", "ConfigFileUrl", "ConfigFileLocation", "configFileUrl", "fileFileType", "configFILETime", "configFILEType", "configFilenameName", "configModuleUrl", "configModuleString", "fileFILETime", "configFilenameType", "configFILELocation", "configFileString", "fileFileName", "configFilesType", "ConfigModuleUrl", "fileFileLocation", "fileFileTime", "configFilenameLocation", "configFilesName", "configPlaceLocation", "fileFILEName", "configFilesLocation", "ConfigModuleLocation", "configFileTime", "configFILEName", "ConfigFileName", "configModuleLocation", "configFilenameTime", "configFullString", "configFullName", "configPlaceUrl", "fileFILEType", "configPlaceString", "configFileLocation"], "in": ["reader", "bin", "login", "f", "data", "it", "socket", "ins", "pin", "m", "stream", "cin", "In", "pc", "base", "is", "log", "inside", "ssl", "conn", "inner", "again", "din", "r", "work", "IN", "err", "plus", "pull", "this", "ini", "i", "source", "init", "inc", "nin", "url", "config", "n", "read", "pass", "inn", "as", "up", "id", "a", "resource", "input", "con", "diff"], "out": ["connection", "bin", "ext", "f", "data", "name", "point", "it", "version", "socket", "error", "s", "sync", "to", "ex", "outs", "one", "timeout", "able", "set", " file", "log", "copy", "conn", "user", "again", "output", "instance", "all", "writer", "and", "err", "password", "o", "off", "client", "OUT", "back", " back", "this", "d", "lib", "image", "inc", "t", "exec", "object", "parent", "default", " output", "view", "server", "config", "null", "io", "net", "c", "up", "file", "prefix", "ou", "exp", "Out", "string", "write", "obj"]}}
{"id1": "15510198", "id2": "23677147", "code1": "    protected static Parser buildParser(URL url) throws IOException, ParserException {\n        Parser parser;\n        URLConnection connection = openConnection(url);\n        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {\n            parser = new Parser(connection);\n        } else {\n            parser = null;\n        }\n        return parser;\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 0, "substitutes": {"buildParser": ["constructParser", "constructReader", "makeReader", "makeWriter", "buildWriter", "newHandler", "makeParser", "newReader", "newParser", "constructHandler", "buildHandler", "newWriter", "constructWriter", "buildReader", "makeHandler"], "url": ["path", "address", "base", "loader", "class", "ssl", "server", "uri", "resource", "http", "c", "location", "l", "host", "URL", "source", "proxy", "str", "open", "config", "data", "file", "channel", "page", "object", "null", "name", " URL", "image", "io", "link", "sl", "Url", "bug", "www", "obj", "this", "service", "loc"], "ParserException": ["IOError", "IOExc", "SSLError", " IOExc", "SSLException", "SSLExc", " IOException", " IOError", "ParserError", "ParserExc", "IOException"], "parser": ["root", "handler", "class", "arser", "loader", "server", "builder", "master", "http", "slave", "result", "se", "instance", "library", "api", "pool", "php", "fp", "manager", "ler", "pard", "er", "type", "reader", "cache", "seed", "parent", "data", "au", "config", "object", "x", "p", "null", "style", "plugin", "test", "fruit", "writer", "worker", "jp", "pc", "angler", "pe", "parse", "processor", "xml", "Parser", "pd", "this", "jack"], "connection": ["directory", "Connection", "event", "handler", "class", "server", "resource", "response", "uri", "http", "document", "con", "c", "communication", "connected", "socket", "message", "character", "instance", "j", "relation", "database", "condition", "client", "session", "reader", "lc", "proxy", "ion", "application", "collection", "open", "config", "section", "channel", "object", "context", "conn", "image", "io", "function", "pointer", "link", "db", "service", "position", "bc", "connect", "reference", "this", " Connection", "loc"]}}
{"id1": "364438", "id2": "19134229", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["conversion", "CONvert", " deconversion", "Converting", "unverted", "subvert", "CONverted", "subverting", "Convert", "CONversion", "unception", "converted", "subversion", "oconvert", "Conversion", "Conception", "oconverting", " deconverted", "oconversion", "unversion", "conception", "converting", "CONception", "subverted", "unvert", " deconverting", " deconvert", "oconverted", "CONverting", "Converted"], "src": ["SourceFile", "buf", "sth", "fn", "prot", "component", "req", "url", "uri", "ssl", "resource", "st", "cmp", "loc", "Dest", "rc", "back", "username", "sys", "sb", "impl", "inst", "Source", "spec", "input", "sn", "cpp", "storage", "ref", "rb", "supp", "href", "attr", "cb", "s", "download", "code", "sin", "source", "reader", "config", "filename", "tmp", "stream", "rl", "slice", "sc", "video", "sit", "string", "load", "ource", "file", "obj", "upload", "gb", "name", "RC", "gz", "dist", "stage", "sel", "ctx", "proc", "path", "secure", "scene", "fp", "img", "feat"], "dest": [" dst", "std", "fn", "txt", "disk", "null", "Dest", "dat", "test", " destination", "home", "temp", "source", "class", "dir", "tmp", "di", "target", "bin", "obj", "dist", "dc", "path", "cont", "orig", "lib", "img"], "in": ["ex", "ins", "In", "n", "ps", "io", "data", "inc", "f", "input", "din", "IN", "d", "inn", "inas", "val", "inf", "pass", "i", "is", "source", "win", "reader", "a", "stream", "login", "r", "bin", "err", "file", "t", "up", "pin", "ini", "as", "doc", "isin"], "p": ["m", "pe", "np", "lp", "e", "j", "g", "b", "cp", "ps", "pg", "bp", "parser", "part", "f", "py", "P", "pa", "pb", "d", "o", "h", "s", "pr", "i", "pd", "l", "wp", "pi", "r", "po", "pc", "v", "c", "t", "per", "sp", "pre", "op", "pm", "jp", "pp", "fp", "tp", "cop"], "ds": ["des", "ths", "rs", "data", "ded", " DS", "vs", "dat", "ys", "dm", "models", "nas", "cs", "utils", "ups", "bs", "ks", "ipes", "df", "dos", "js", "ads", "DS", "obs", "parts", "gd", "dl", "qs", " sd", "eps", "dds", " ps", "dp", "ls", "points", "ps", "sys", "uds", "sts", "sync", "dd", "groups", "ges", "Ds", "d", "lines", "s", "pd", "db", "da", "ils", "icks", "ld", "ts", "gs", "services", "ants", "cons", "ins", "lp", "ss", " props", "os", "ns", "dates", "plugins", "hs", "amps", "docs", "posts", "tools", "vals", "di", "scripts", "dist", "tests", "dc", "xs", "ays", "ans", "words", "els", "dt", "styles"], "format": ["filter", "at", "fd", "prefix", "fn", "url", "frame", "unit", "struct", "style", "form", "letter", "act", "atter", "tag", "data", "version", "scale", "parser", "part", "model", "f", "spec", "template", "type", "sche", "plugin", "source", "class", "api", "config", "record", "nat", "filename", "table", "layout", "string", "language", "handler", "file", "Format", "name", "t", "magic", "pattern", "host", "function", "ant", "path", "fp", "feat"], "hasPixelData": ["hasByteStyle", " hasPixeldata", "hasPixelStyle", "hasPixeldata", "showsByteStyle", "haspixelSize", "haspixeldata", "hasByteDATA", "hasPicturedata", "showsPixelData", "showsPixeldata", "hasByteData", " hasPixelSize", "hasPixelDATA", "showsPixelStyle", "hasPixelSize", "hasByteSize", "showsBytedata", "showsPixelDATA", "hasPictureData", "hasPictureSize", "hasBytedata", "showsByteDATA", "haspixelData", "showsByteData"], "inflate": ["inflated", "infolATE", "invenode", "inFlation", "Inflace", "insvenATE", "InFlace", "inffated", "infloated", "inflation", "Inflation", "insvenode", "Inflated", "infloate", "inflating", "infolating", "inffate", "inadequate", "infloace", "insflate", "inflode", "inadequATE", "insflATE", "InFlated", "invenating", "inFlated", "infolode", "insflating", "inflace", "Inflate", "inadequode", "InFlation", "inFlate", "infface", "invenate", "inadequating", "inffation", "insvenating", "infloation", "inflATE", "invenATE", "insvenate", "inFlace", "insflode", "InFlate", "infolate"], "pxlen": ["fxden", "txlon", "pxcount", "camln", "txlen", "pnglen", "txlin", "pglen", "pxden", "xplength", "axlon", "pxLen", "mxln", "mxdata", "pgden", "ppl", "axlin", "fxLen", "campos", "pxlon", "pgLen", "xplen", "camdata", "mxsize", "pcln", "mxlen", "ppLen", "pxlin", "xpsize", "pxlength", "pgl", "fxlen", "fxln", "pnglength", "pclon", "mxcount", "mxpos", "pxpos", "ppden", "axlen", "pplen", "pxl", "mxlength", "camlen", "pclen", "axln", "fxl", "fxdata", "pngsize", "pxsize", "pxln", "fxpos", "pclin", "xpcount", "pngcount", "txln", "pxdata"], "out": ["page", "pad", "gen", "log", "server", "copy", "parent", "lock", "io", "store", "sys", "step", "session", "output", "group", "Out", "error", "conn", "cli", "work", "co", "dump", "point", "outs", "user", "cache", "v", "err", "obj", "list", "re", "up", "inter", "OUT", "query", "state", "again", "line", "lib", "post"]}}
{"id1": "11183087", "id2": "8064604", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "label": 1, "substitutes": {"doPost": ["handlePut", "handlePOST", "doingPut", "doingPOST", "handleSearch", " doPOST", "doSearch", " doPut", "doPut", "handlePost", "doingSearch", "doPOST", " doSearch", "doingPost"], "request": ["event", "remote", "info", "order", "buffer", "input", "Request", "server", "resource", "rf", "user", "report", "http", "subject", "message", "have", "current", "project", "result", "join", "instance", "child", "forward", "press", "query", "queue", "req", "post", "er", "client", "rate", "type", "use", "q", "the", "model", "r", "application", "config", "data", "parent", "route", "web", "get", "object", "context", "view", "complete", "hello", "e", "QUEST", "image", "frame", "call", "pull", "url", "pe", "create", "right", "xml", "state", "error", "external", "enter", "initial"], "response": ["server", "resource", "output", "http", "report", "results", "message", "document", "res", "site", "onse", "result", "pool", "next", "client", "resp", "connection", "model", "application", "parent", "body", "page", "object", "web", "reply", "template", "writer", "status", "Response", "respond", "guide", "api", "view"], "senha": ["suitha", "senca", " senwa", "sensha", "zenha", "zensha", "senaka", "zenca", " senHa", "zenHa", "renha", "tonlah", " senaka", "sanha", "suitla", "tonwa", "renca", "sanwa", "tonha", "renHa", "tonHa", "senwa", "snsha", "senhi", "suitsha", "sanlah", "snla", " senca", "zenaka", "suithi", "senHa", "snha", "renaka", "snhi", " senlah", "sanHa", "senla", "zenla", "zenhi", "senlah"], "email": ["letter", "string", "zip", "address", "server", "id", "username", "user", "mail", "message", "account", "line", "Email", "password", "login", "model", "alias", "data", "file", "ip", "environment", "language", "hello", "name", "example", "e", "home", "label", "mobile", "url", "fax", "secret", "xml", "business", "office", "phrase", "service"], "messageDigest": ["medigher", " messageDEST", "medigester", " messagedigEST", "messagedigest", " messagedigest", "messagedigester", " messageDest", "messageDigester", "medigest", "messagedigEST", "messageMailest", " messageDigester", "messageDEST", "messageMailester", "messageMailEST", "messageDher", "messageDend", " messageDester", "messageDigher", " messageDend", "messagedigend", "messageDest", "meDigher", "meDigest", "messageDigend", "messageDester", "meDigester", "messageDigEST", " messageDigend", " messagedigester", "meDigEST", "medigEST", "messagedigher", " messageDigEST", "messageMailend"], "usuario": ["ususillo", " usuiarium", "uslurio", "usueariat", "suluario", "usituario", " usurio", "usuiasio", " ususarius", "usuarium", "usuitrio", "usuitarium", "usuirio", "usuarius", "ususario", " ususario", "usluasio", " usuasio", " usuarius", " ususillo", "sulurio", "usuillo", "usurio", " usuariat", "usueillo", "ussuarial", "usuasio", "ussurio", "usuarial", "usuitasio", " usuirio", "usuiario", " usuarium", "usueario", "usguarius", "usuitario", "ussuasio", "suluarial", " usuiasio", "suuario", "ussuario", "usguario", "suurio", "suuarial", "ussuarium", "ususarius", " usuillo", "usuariat", "suluasio", "usuearius", "usluarial", "suuasio", "usiturio", "usluario", "ususariat", "usguillo", "usuiarium", " usuiario", "usituasio", "usguariat", " ususariat", "usituarial"], "redirect": ["redRECT", "Redroute", " redrict", "predrict", " redurl", " reduce", "indirect", "predRECT", "Redition", "reduce", "rerict", "reroute", "redirection", "redrict", "redroute", "predroute", " redRECT", "predirect", "RedRECT", "indrict", "reirection", "indirection", "edirection", "edition", "Redrict", "redurl", " redition", "induce", "edirect", "edurl", "reirect", "Redirection", " redirection", "Redirect", "preduce", "predirection", "Redurl", "redition"], "session": ["event", "info", "ssl", "ession", "node", "input", "server", "user", "http", "site", "message", "document", "system", "result", "child", "sid", "query", "client", "use", "cache", "proxy", "browser", "connection", "group", "config", "data", "page", "object", "flash", "Session", "image", "person", "sl", "app", "comment", "sp", "cookie", "state", "service", "view", "storage"]}}
{"id1": "539195", "id2": "13783549", "code1": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["csv", "change", "delete", "paste", "rm", "transfer", "php", "zip", "io", "load", "Copy", "put", "replace", "py", "cp", "write", " cp", "cop", "it", "get", "file", "download", "create", "split", "cat", "clone", "opy", "cmp"], "src": ["sys", "url", "sit", "img", "sup", "gb", "id", "sub", "cur", "path", "remote", "sl", "target", "filename", "string", "name", "s", "secure", "stream", "archive", "image", "upload", "ruby", "code", "sel", "ssl", "sb", "desc", "sin", "config", "loc", "sync", "slice", "inst", "uri", "resource", "rb", "rc", "href", "source", "sc", "file", "dist", "RC", "txt", "rs"], "dest": ["rest", "test", "prop", "delete", "output", "tmp", "comb", "replace", "folder", "default", "target", "filename", "flat", "end", "them", "Dest", "dat", "orig", "desc", "const", "text", "tern", "loc", "slice", "wb", "done", "du", "wd", "feat", "source", "data", "destroy", "dir", "dist", "d", " destination", "coord", "die", "later", "home", "opt", "txt", " Dest", "buff", "temp"], "ifp": [" ifpp", "dfb", "ppp", "upcp", "upp", " ifb", "ifpp", "ifo", "Iftp", "ifpa", "ifcp", "ipli", "ipltp", "ifb", "pppa", "IFo", "Ifi", "ibi", " ifo", "iplp", "dfpa", "ifi", " ifap", "IFpp", "ibpa", "IFp", "ibp", " ifcp", "iftp", "dfp", "ppap", "dfap", "ifap", "ibtp", "ppb", " ifpa", "uppp", "Ifp", "iplpa", "upo", "Ifpa", "IFcp"], "ofp": ["ippy", "ofy", "ippps", "OFps", " ofc", "Ofp", " ofy", "ippp", "OFp", "off", "ofi", "ofc", " ofps", " off", "ovc", "ippc", "Ofi", "ovi", "ovp", "OFc", "OFy", "Off", " ofi", "Ofc", "ovf", "ofps"], "fis": ["his", "hps", "fais", " fiss", "fus", "cfis", "flis", " fais", "fls", "fps", "cfi", " fbis", "infis", "cfais", "hus", " fi", " fps", "infiss", "ofos", "hs", "cfiss", "flps", "ofbis", "cfbis", " fus", "fbis", "fs", " fs", "fiss", "fi", "ofais", "cfos", "ofis", "infi", "infos", "flus"], "fos": ["foes", "fpos", "poes", "poses", "ifops", "bis", "Foses", " foses", "Fos", "Fis", "fios", " fops", "bpos", "Foes", "bos", "pis", "Fios", "bops", "bios", "foser", "ifis", "ifoser", " fpos", " fios", "Fpos", "fops", "foses", "pos", " foes", "boser", "ifos", " foser"], "b": ["v", "base", "xb", "ib", "bb", "ob", "gb", "e", "br", "nb", "emb", "bis", "db", "boot", "ba", "mb", "binary", "c", "bound", "buff", "sb", "i", "a", "lb", "r", "buf", "bi", "abb", "wb", "buffer", "ab", "eb", "p", "rb", "h", "l", "d", "B", "bf", "bs", "f"]}}
{"id1": "11477906", "id2": "6171406", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadApplicationConfiguration", "getDefaultParameters", "loadApplicationSettings", "getDefaultConfiguration", "getdefaultParameters", "loadGlobalSettings", "loaddefaultsettings", "loadGlobalParameters", "loadDefaultConfiguration", "getDefaultsettings", "loadApplicationParameters", "loadGlobalsettings", "getDefaultSettings", "loadApplicationsettings", "loadGlobalConfiguration", "loadDefaultParameters", "loadDefaultsettings", "getdefaultConfiguration", "loaddefaultConfiguration", "getdefaultSettings", "loaddefaultParameters", "getdefaultsettings", "loaddefaultSettings"], "configFileName": ["configModuleLocation", "configPlaceUrl", "configFullUrl", "configPlaceString", "configFilesType", "configFilesLocation", "configFileUrl", "configFullLocation", "fileFILETime", "configFILEName", "configFILETime", "fileFILEType", "configFilesTime", "fileFileType", "ConfigFileLocation", "configFileString", "configFullName", "configFilenameName", "configFileLocation", "configModuleString", "ConfigFileString", "configPlaceName", "configFilenameType", "fileFILEName", "configModuleUrl", "ConfigModuleLocation", "configPlaceLocation", "configFileType", "ConfigFileName", "configModuleName", "fileFileTime", "configFILELocation", "configFILEType", "configFilesName", "fileFILELocation", "ConfigModuleName", "configFilenameLocation", "ConfigFileUrl", "fileFileLocation", "configFullString", "configFilenameTime", "ConfigModuleString", "configFileTime", "fileFileName", "ConfigModuleUrl"], "in": ["work", "source", "as", "init", "inn", "pin", "inner", "f", "config", "this", "plus", "pass", "i", "input", "socket", "conn", "inside", "read", "IN", "data", "m", "con", "ini", "resource", "n", "up", "a", "url", "base", "din", "pc", "log", "it", "is", "nin", "ins", "cin", "stream", "In", "inc", "again", "pull", "err", "r", "login", "ssl", "id", "reader", "diff", "bin"], "out": [" output", "copy", "output", "set", "sync", "client", " back", "net", "c", "instance", " file", "point", "config", "all", "back", "f", "view", "timeout", "s", "ex", "one", "this", "to", "socket", "OUT", "conn", "image", "default", "data", "writer", "object", "able", "up", "io", "and", "log", "name", "null", "ou", "ext", "server", "it", "exec", "obj", "password", "string", "connection", "exp", "prefix", "Out", "write", "outs", "inc", "again", "off", "file", "lib", "version", "err", "t", "o", "user", "parent", "bin", "error", "d"]}}
{"id1": "7143591", "id2": "324679", "code1": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "code2": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"getWebByUrl": ["getwebbyUrl", "getwebByurl", "getwebByLocation", "getWebFromUrl", "getWebByIdUrl", "getWebbyUrl", "getWebByIdurl", "getwebbyurl", "getWebByIdLocation", "getwebbyURL", "getWebByurl", "getWebFromURL", "getWebByLocation", "getWebFromurl", "getWebFromLocation", "getwebbyLocation", "getWebByIdURL", "getwebByUrl", "getWebbyurl", "getwebByURL", "getWebbyLocation", "getWebbyURL", "getWebByURL"], "strUrl": ["arrUrl", "srurl", "STRUrl", "strLink", "arrUr", "srURL", "stUrl", " strRoute", "STRURL", "arrPath", "STRFile", " strFile", "objUr", "objFile", "strURL", "StrPath", "strPath", "sturl", "stEmail", " strBase", "StrLink", "slUrl", "stURL", " strurl", "stFile", "slUr", "wrUrl", "StrUr", " strPath", "StrFile", "srLink", "arrURL", "wrEmail", "objURL", "strUr", "strRoute", "strFile", "StrUrl", "StrBase", " strURL", "arrurl", "wrUr", "srUrl", "StrEmail", "arrRoute", "strurl", "stUr", "STRUr", "Strurl", "StrURL", "objUrl", "StrRoute", "strBase", "slBase", " strLink", "slURL", " strUr", "strEmail", "wrURL"], "charset": ["chARSet", " Charsetting", " Charset", "chasetting", "chactersec", " ChARSet", " ChARSetting", "chacterset", "chactersetting", " ChARSec", "chasET", "chARSetting", "chasec", "chaset", "charsET", "chactersET", "charsec", "chARSET", "chARSec", " Charsec", " CharsET", "charsetting", " ChARSET"], "fileIndex": ["fileName", "FileNumber", "fileindex", "fileNumber", " fileName", "fullNumber", "FilePath", "FileIndex", " fileNumber", "fullindex", "FileVersion", "webVersion", "FileName", " fileVersion", "fileVersion", " fileindex", "Fileindex", "webIndex", "fullIndex", "webindex", "fullPath", "webName"], "url": ["link", "image", "ib", "URL", "base", "resource", "service", "www", "serv", "download", "Url", "open", "ls", "http", "zip", "l", "b", "api", "bb", "page", "string", "bel", "r", "path", "fl", "org", "uri", "blog", "client", "ur", "loader", "ssl", "proxy", "server", "host", "file", "ll", "id", "str", "sl", "connection", "config", "source", "web", "f", "address"], "conn": ["enc", "conv", "nt", "serv", "config", "w", "cli", "Url", "nc", "open", "Connection", "http", "ca", "sync", "api", "ch", "b", "l", "ann", "cb", "c", "r", "sn", "ci", "conf", "client", "ssl", "ac", "con", "cn", "server", "connect", "Conn", "n", "ctx", "cp", "connection", "loc", "exec", "f"], "is": ["err", "ib", "its", "in", "serv", "isi", "internet", "mis", "ls", "ii", "http", "src", "ir", "lis", "b", "info", "ui", "IS", "ri", "ps", "was", "li", "ie", "ris", "io", "si", "os", "it", "x", "ai", "out", "isa", "oss", "fs", "ip", "ins", "iss", "il", "as", "iso", "init", "bis", "are", "es", "us", "ssl", "h", "ob", "isc", "ios", "browser", "Is", "i", "im", "ais", "iter", "ar", "jar", "iris", "ab", "s"], "filePath": ["outputHome", "basePath", "FileHome", "FileUrl", "fileHome", "baseIndex", "FileBase", "cacheLocation", "cacheIndex", "FilePath", "cachepath", "pageIndex", " fileUrl", "fileLocation", "outputUrl", "pagepath", "pagePath", "fileUrl", "basepath", "outputBase", "outputPath", "filepath", " fileBase", "baseLocation", "pageLocation", " fileHome", "cachePath", "fileBase"], "pw": [" pv", " pW", " pws", "psw", "pwa", "spW", "Pow", " pow", " pb", "Psw", "spwb", "PW", "ppsw", "Pv", "Pwa", "ppb", "cpw", "pv", "ppW", "Pb", " pwb", "pws", " pwr", "pwr", "cpwr", "pwb", "spw", "pow", "spv", "ppws", " psw", "spow", "pb", "spws", " pwa", "ppw", "Pwb", "pW", "ppow", "cpW", "Pw", "Pwr", "ppwa", "Pws", "cpwa"], "fos": [" fops", "fOS", "fis", "fsaos", "pOS", "FOS", "pos", "fsops", " faos", "faos", "fsos", "Fos", "Fis", "Faos", "fops", "Fops", " fOS", "fsis", "pops", " fis"], "writer": ["writing", "wb", "wave", "walker", "w", "format", "write", "worker", "wer", "output", "ws", "builder", "driver", "null", "r", "wt", "store", "buffer", "wa", "fd", "wr", "handler", "er", "writers", "wrap", "io", "wire", "out", "director", "xml", "riter", "Writer", "file", "war", "reader", "rw", "writ", "angler", "ee", "editor"], "bReader": ["bbWriter", "rRead", "rWriter", "bResource", "rbRead", "bbReader", "bRead", " bWriter", "BRead", " bRead", "bbRead", "bCh", "rReader", "BResource", "bbResource", "rCh", " bResource", "rbWriter", "bWriter", "rbReader", "BWriter", " bCh", "BReader", "rbCh"], "sb": ["ib", "wb", "nb", "bsp", "kb", "bm", "zb", "SB", "sa", "xb", "src", "b", "bb", "cb", "bp", "usb", "lp", "gb", "abb", "wp", "stab", "fb", "lb", "rob", "si", "obb", "sg", "sm", "erb", "sq", "pb", "tmp", "ssl", "lab", "bps", "sf", "sth", "rb", "mb", "bg", "bf", "db", "ab"], "rLine": ["rUrl", "prLin", "rLo", "lrBlock", "rrLine", "rLin", " rBlock", "srLine", "prLine", "rWr", "rtWr", "rRange", "arline", "prBlock", "rrUrl", "rtline", " rWr", "arWr", "lrRange", "srBlock", "rrBlock", "lrLin", "srLin", " rRange", " rUrl", "rBlock", "lrLine", "rtLo", " rLo", " rline", "prRange", " rLin", "srUrl", "arLo", "rtLine", "arLine", "rline", "rrLin"], "tmp_rLine": ["tmp_errLine", "tmp_lLetter", "tmp_prSe", "tmp_brLetter", "tmp_rBlock", "tmp_RSe", "tmp_rbline", "tmp_lFile", "tmp_brLine", "tmp_roRecord", "tmp_prLine", "tmp_errline", "tmp_rLink", "tmp_RValue", "tmp_rnCopy", "tmp_RItem", "tmp_RRecord", "tmp_lPage", "tmp_rbLine", "tmp_nrline", "tmp_rItem", "tmp_rPage", "tmp_rtline", "tmp_rnline", "tmp_vrline", "tmp_vrLine", "tmp_vrLink", "tmp_rnLink", "tmp_rLetter", "tmp_roSe", "tmp_errLink", "tmp_lBlock", "tmp_rRecord", "tmp_nrLine", "tmp_roFile", "tmp_roPage", "tmp_RFile", "tmp_Rline", "tmp_rbItem", "tmp_rline", "tmp_RLine", "tmp_prFile", "tmp_RLetter", "tmp_lLine", "tmp_rbBlock", "tmp_RBlock", "tmp_rtLine", "tmp_rtItem", "tmp_nrFile", "tmp_RPage", "tmp_lRecord", "tmp_roValue", "tmp_roLine", "tmp_errCopy", "tmp_rnLine", "tmp_rValue", "tmp_brFile", "tmp_rtBlock", "tmp_rCopy", "tmp_prValue", "tmp_vrCopy", "tmp_rSe", "tmp_nrBlock", "tmp_roBlock", "tmp_rFile"], "str_len": ["str_length", "str64pos", "str_ln", "str5ler", "stri5ler", "dr_Len", "str5pos", "stri_pos", "dr_length", "str2len", "str5lin", "str64ler", "stri_len", "stri5len", "dr_len", "stri5lin", "stri_ler", "str64len", "str_pos", "str2ler", "stri5pos", "str5len", "str_Len", "str64lin", "str2pos", "stri_lin", "str_ler", "str_lin", "dr_ln", "str2lin"]}}
{"id1": "14053882", "id2": "8917658", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new Exception(e.getMessage());\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new Exception(e.getMessage());\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static void copyAll(URL url, Writer out) {\n        Reader in = null;\n        try {\n            in = new InputStreamReader(new BufferedInputStream(url.openStream()));\n            copyAll(in, out);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            close(in);\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["enccode", " encryptcode", "decrypt", " encryptrypt", "decryption", " enipher", " encryptryption", "deccode", "decipher", "encipher", " enrypt", " enryption", "encryption", " encode", " encryptipher"], "plaintext": ["plainsource", " plaincontent", "encryptedstruct", "givenfont", " plainText", "protectedText", "plainstring", "batsource", "plainfont", "givenstring", "encryptedtext", " plainstring", "plainstruct", "batfont", "protectedstruct", "givensource", " plainfont", "protectedtext", "plaincontent", "plainText", " plainsource", "battext", "batstring", "encryptedText", "protectedcontent", "giventext", " plainstruct", "encryptedcontent"], "md": ["mand", "hm", "alg", "mm", "mp", "mod", "amd", "Cmd", "wd", "dig", "cmd", "dm", "po", "mb", "meta", "material", "mg", "data", "m", "ph", "da", "pg", "mage", "metadata", "ad", "mad", "mac", "nm", "sm", "ms", "code", "kg", "pd", "sha", "dr", " MD", "od", "dd", "cm", "mo", "mt", "hd", "cd", "am", "MD", "dh", "mc", "ma", "df", "mu", "pkg", "mag", "pm", "cb", "d", "bd", "dc"], "raw": ["text", "buffer", "json", "dec", "clean", "empty", "load", "instance", "rew", " RAW", "buf", "unsigned", "input", "image", "shared", "Raw", "data", "unknown", "auth", "binary", "original", "array", "null", "initial", "sha", "hex", "ack", "rc", "string", "stream", "enc", "wrapper", "full", "block", "serial", "pure", "row", "wave", "pack", "response", "feed", "partial", "RAW"], "hash": ["secret", "message", "buffer", "cache", "ashes", "length", "ash", "image", "kh", "data", "auth", "mac", "url", "base", "log", "array", "Hash", "password", "sha", "hex", "index", "h", "header", "sum", "sh", "block", "ha", "html", "version", "key", "response", "href", "her", "id", "rh"]}}
{"id1": "21998571", "id2": "22734545", "code1": "    private String readTwitterFead() {\n        StringBuilder builder = new StringBuilder();\n        HttpClient client = new DefaultHttpClient();\n        HttpGet httpGet = new HttpGet(\"http://twitter.com/statuses/user_timeline/vogella.json\");\n        try {\n            HttpResponse response = client.execute(httpGet);\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n            if (statusCode == 200) {\n                HttpEntity entity = response.getEntity();\n                InputStream content = entity.getContent();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(content));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    builder.append(line);\n                }\n            } else {\n                Log.e(AndroidJsonTestingActivity.class.getName(), \"Failed to download file\");\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return builder.toString();\n    }\n", "code2": "    public void generate(String urlString, String target) throws Exception {\n        URL url = new URL(urlString);\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        BufferedInputStream inputStream = new BufferedInputStream(urlConnection.getInputStream());\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(target));\n        byte[] buf = new byte[10 * 1024];\n        int len;\n        while ((len = inputStream.read(buf, 0, buf.length)) != -1) {\n            outputStream.write(buf, 0, len);\n        }\n        inputStream.close();\n        outputStream.close();\n        urlConnection.disconnect();\n    }\n", "label": 0, "substitutes": {"readTwitterFead": ["downloadFacebookFee", "downloadTwitterFFrequency", "downloadTwitterJrequency", "downloadFacebookFees", "downloadTwitterFlerequency", "downloadTwitterFee", "downloadTwitterFleee", "downloadTwitterFFees", "downloadTwitterFFead", "downloadTwitterFleead", "downloadFacebookJee", "downloadTwitterFead", "downloadFacebookJees", "downloadTwitterFees", "downloadTwitterFleees", "downloadFacebookFead", "downloadTwitterFFee", "downloadFacebookFrequency", "downloadTwitterJees", "downloadTwitterJee", "downloadTwitterJead", "downloadFacebookJrequency", "downloadTwitterFrequency", "downloadFacebookJead"], "builder": ["letter", "string", "base", "Builder", "buffer", "loader", "sf", "editor", "address", "server", "entry", "http", "building", "holder", "message", "board", "result", "instance", "driver", "keeper", "database", "iter", "er", "builders", "sb", "oder", "r", "build", "parser", "store", "object", "row", "null", "built", "writer", "image", "runner", "array", "worker", "db", "layer", "url", "we", "b", "wrapper", "atter", "trace", "container", "block", "f", "bean", "upper"], "client": ["class", "tc", "i", "handler", "server", "resource", "http", "con", "c", "per", "socket", "project", "host", "queue", "session", "ce", "bird", "proxy", "connection", "application", "config", "google", "channel", "https", "request", "get", "cloud", "conn", "plugin", "force", "io", "app", "url", "Client", "connect", "contact", "cli", "method", "service", "api"], "httpGet": [" httpPut", "urlFind", " httpDo", "HttpPut", "ttpPut", "ttpGet", "HTTPSend", "httpDo", "urlget", "httpSplit", " httpSplit", "HTTPGet", "httpPut", "HTTPFind", "urlGet", "ttpDo", " httpFind", " httpget", " httpSend", "HttpDo", "httpFind", "httpget", "HttpSplit", "HTTPget", "HttpGet", "urlSend", "ttpSplit", "httpSend"], "response": ["event", "handler", "server", "resource", "output", "http", "report", "message", "json", "document", "onse", "result", "ception", "session", "resp", "connection", "application", "collection", "wave", "data", "body", "page", "request", "object", "reply", "writer", "status", "success", "full", "received", "Response", "stream", "respond", "successful", "error", "service", "api"], "statusLine": ["StatusLine", "responseResponse", "statusResponse", "statResponse", "statEntry", "contentEntry", "contentLine", "responseEntry", "responseCode", " statusResponse", "contentBlock", "statusBlock", "StatusEntry", "httpStatus", "statLine", "statusStatus", "httpEntry", "statCode", "httpLine", " statusEntry", "StatusStatus", "contentStatus", "responseLine", "StatusBlock", "httpBlock", "statusEntry"], "statusCode": ["StatusLine", "contentCount", "stateType", "statusCount", "contentLine", " statusType", "statusType", "contentType", "statusStatus", "stateStatus", "contentCode", "StatusType", "stateCode", "StatusCode", "StatusCount", "StatusStatus", " statusStatus", " statusCount"], "entity": ["event", "article", "agent", "server", "resource", "Entity", "enc", "entry", "http", "json", "document", "et", "result", "el", "er", "ent", "type", "source", "activity", "connection", "media", "model", "application", "collection", "data", "file", "body", "page", "object", "coll", "e", "status", "writer", "person", "stream", "xml", "element", "code"], "content": ["handler", "buffer", "input", "loader", "resource", "output", "feed", "server", "entry", "json", "message", "cont", "result", "child", "driver", "read", "Content", "raw", "source", "load", "activity", "media", "collection", "data", "file", "text", "body", "channel", "page", "object", "conn", "status", "writer", "image", "pointer", "layer", "stream", "xml"], "reader": ["buffer", "loader", "i", "input", "handler", "resource", "server", "editor", "reading", "per", "ri", "read", "in", "iter", "ler", "er", "bird", "oder", "ner", "r", "parser", "data", "rar", "row", "rr", "or", "rer", "io", "writer", "worker", "ser", "stream", "Reader"], "line": ["letter", "string", "base", "buffer", "i", "id", "lf", "feed", "entry", "message", "LINE", "character", "end", "l", "write", "sheet", "pass", "char", "iter", "key", "sync", "part", "one", "source", "lines", "lc", "connection", "str", "r", "data", "file", "text", "body", "liner", "page", "ip", "le", "object", "inline", "row", "style", "name", "e", "link", "sl", "url", "pe", "comment", "lin", "Line", "block", "code", "point", "cell"]}}
{"id1": "2668634", "id2": "14691829", "code1": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 0, "substitutes": {"inputName": ["InputFile", "Inputname", "imageName", "outputPath", "outputFile", "inputAddress", " inputAddress", "inputUrl", "InputUrl", "imageFile", "imagename", "InputName", " inputPath", " inputFile", "InputAddress", " inputUrl", "outputUrl", "inputFile", " inputname", "InputPath", "imageAddress", "inputname", "inputPath"], "outputName": ["applicationPath", "outputPath", "outputFile", "outputDir", "outputname", "applicationname", "Outputname", " outputname", "applicationName", "OutputDir", "OutputFile", "OutputPath", "applicationDir", " outputFile", "applicationFile", "OutputName", " outputDir", "inputFile", "inputDir", "inputPath"], "stripLoggers": ["stripColters", "stripDebuggers", "stripLogger", "striplogging", "stripDebugging", " stripLogger", "stripColger", "striploggers", "stripDebugger", " stripLogters", " striplogger", "stripColgers", " striplogging", "stripColging", "striplogger", "striplogters", "stripLogters", " striplogters", "stripDebugters", " striploggers", " stripLogging", "stripLogging"], "tempFile": [" temporaryStream", " temporaryfile", "tempDir", "poraryMessage", "TempFiles", "tempPage", " tempMessage", "tmpPage", "TempStream", "TempDir", " tempStream", " tempFiles", " tempfile", "tmpFiles", "tmpfile", "tmpDir", " temporaryFile", "poraryFiles", "tempfile", "tempMessage", "TempFile", " tempPage", "tempFiles", "inputfile", "poraryFile", "poraryfile", "TempMessage", "tmpFile", "tempStream", "inputFile", " temporaryFiles", "inputDir", "inputPage", "Tempfile", " tempDir"], "jin": ["Js", " Jin", "in", "su", "pin", "Mu", "NI", "jan", "gin", "icer", "zin", "hin", "cin", "sit", "jen", "tin", "ln", "nu", "thin", "cli", "pillar", "zon", "din", "arin", "zn", "spin", "sin", "Skin", "lin", "rio", "cos", "ja", "Mos", "Ru", "vin", "raf", "nin", "jl", "Intern", "NJ", "ini", "rin", "nir", "inx", "kin", "unin", "util", "lib", "skin", "zip", "jp", "ni", "jing", "fil", "fen", "jack", "zik", "hn", "bin", "plugin", "Kit", "irin", "lu", "jun", "john"], "jout": [" jOut", "JOut", "jetOUT", " jouter", "nOut", "ujOut", "nOUT", "narray", "jOut", " jOUT", "jouter", "Jout", "nout", "jarray", "ujouter", " jarray", "jOUT", "Jouter", "jetout", "jetarray", "jetOut", "ujout"], "srcChannel": [" srcCh", "srcCh", "rcCh", "srcChan", "sourceChan", "rcChan", " srcchannel", " srcChan", "rcChannel", "sourceCh", "rcchannel", "sourcechannel", "sourceChannel", "srcchannel"], "dstChannel": ["dstCh", "dspCh", "dspchannel", " ddestCh", " ddestChannel", "ddestChannel", " ddestChan", "dndChannel", " dstChan", "dndChan", " ddestchannel", " dstchannel", " dstCh", "dndCh", "dstChan", "ddestCh", "dndchannel", "ddestchannel", "dspChan", "ddestChan", "dspChannel", "dstchannel"], "portletApplicationName": ["portletApplicationUrl", "portletApplicationsInfo", "portalApplicationPath", "portletAppCode", "portletApplicationsPath", "portletPlatformPath", "portalPlatformUrl", "portletapplicationType", "portletApplicationPath", "portletsAppInfo", "portletApplicationInfo", "portletApplicationType", "portletPlatformName", "portletapplicationUrl", "portletapplicationName", "portalPlatformName", "portletAppName", "portletsAppPath", "portletsAppCode", "portletAppUrl", "portalApplicationType", "portletapplicationPath", "portletApplicationCode", "portletsApplicationName", "portalApplicationUrl", "portletsApplicationCode", "portletAppInfo", "portletAppPath", "portalPlatformPath", "portletPlatformCode", "portletPlatformInfo", "portletApplicationsCode", "portletsApplicationInfo", "portletsAppName", "portalApplicationName", "portletPlatformType", "portletApplicationsName", "portalPlatformType", "portletsApplicationPath", "portletPlatformUrl", "portletAppType"], "webXml": ["webWorkli", " webXaml", "webHiel", "webCml", "webXMxml", "webEcML", "contextXlass", "webXul", "webxml", "webXMiel", "WebXpl", "webHml", "contextXul", " webXMML", "WebXMML", "webXMml", "webCrossli", "WebXiel", "webXli", "webXMaml", "WebXML", "contextXxml", "webXaml", "webxlass", "webHML", "webxaml", "webXiel", "WebXMpl", "webEcml", "webEcpl", "webXMML", "contextClass", "webCrossml", "webCrossul", "webHpl", " webXMml", "webXxml", "webClass", "contextCrossli", "webXML", "webCxml", "contextXML", "contextXli", "webxxml", "contextCxml", "webXlass", " webXMxml", "WebXml", "contextCrossul", "webWorkul", "WebXMiel", "webWorkML", "webCrossML", "webCML", "contextCrossml", "contextCml", " webXxml", "webxML", "WebXMml", "contextCML", "webWorkaml", " webXMaml", "contextCrossML", " webXML", "webWorkml", "webEciel", "webWorkxml", "webXpl", "webXMpl"], "portletXml": ["portletHxml", "portletXmos", "portletCML", "portletXaml", "portletSyncxml", "portletSynctml", "portletSyxml", "portletSyml", "portletxxml", "portletEml", "portletxml", "portletXMmal", "portletSytml", "portletSyncaml", "portletXtml", "portleSyaml", "portletXmal", "portletXMng", "portletXMxml", "portletYml", "portletsXml", "portletYng", "portletYML", "portletEng", "portletsYml", "portfileXmos", "portletsYng", "portletXxml", "portletEML", "portletCmos", "portleXml", "portleSyxml", "portletsXML", "portletHML", "portfileXML", "portfileHmos", "portletYmal", "portleXxml", "portletXng", "portfileHml", "portletXMaml", "portleXtml", "portleXaml", "portletCxml", "portletsYmal", "portletXMtml", "portleSytml", "portletxmos", "portletHmos", "portletEmal", "portletsXmal", "portletCml", "portfileXxml", "portfileXml", "portletXMML", "portleSyml", "portletXMml", "portfileHxml", "portletSyncml", "portletsYML", "portletHml", "portfileHML", "portletSyaml", "portletxML", "portletsXng", "portletXML"], "contextXml": ["contextUml", " contextAxml", " contextAxla", "contextExML", "contextHwl", "contextxwl", "contextXMml", "conceptXaml", "contextXwl", " contextXML", "contextXl", " contextAxML", "conceptHwl", "conceptHml", "contextXla", "contextXxml", "conceptXwl", "contextAxml", "contextAxl", "contextXaml", "contextxxml", " contextXla", " contextAxl", "contextxaml", "conceptXml", "contextXMaml", "contextXMwl", "conceptXxml", "contextAxla", "contextExla", "contextAxML", "contextExl", "conceptHaml", "contextUl", "contextUla", "contextHaml", "contextXML", "contextHml", "contextHxml", "contextExml", "contextXMxml", "conceptHxml", "contextxml", " contextXl", "contextUML"], "src": ["r", "in", "sc", "ruby", "sl", "obj", "ie", "ctx", "entry", "rl", "sync", "i", "host", "rc", "socket", "s", "sit", "slice", "rs", "ses", "sn", "sin", "sb", "loc", "result", "rb", "http", "inst", "resource", "cur", "rss", "ssl", "img", "gb", "rin", "dest", "rec", "sup", "Source", "lit", "dist", "secure", "sr", "sel", "prot", "url", "req", "st", "bh", "zip", "rest", "ri", "sq", "rel", "spec", "SOURCE", "comp", "lower", "uc", "href", "ur", "gz", "uri", "jar", "ser", "cont", "ource", "sub", "config", "username"], "source": ["get", "in", "client", "component", "service", "size", "sl", "ie", "stream", "i", "ce", "form", "view", "use", "proxy", "scope", "input", "sit", "slice", "context", "e", "thin", "parent", "sin", "handler", "core", "stack", "from", "result", "connection", "inner", "reason", "resource", "fp", "xml", "resources", "out", "function", "kin", "file", "Source", "secure", "storage", "sr", "iter", "start", "url", "this", "null", "unit", "wrapper", "zip", "session", "rc", "channel", "loader", "spec", "SOURCE", "comp", "token", "status", "text", "driver", "reader", "string", "uri", "gen", "ource", "ources", "sp"], "zipEntries": [" zipEntrys", "sliceEntresses", "zipentlements", "zipEnlines", "zipEries", "ZipEntlements", "sliceEry", "sliceElines", "zipentions", "zipEndries", "sliceEresses", "sliceEntry", "sliceEntries", "zipIntegrys", "zipEntrations", "zipentrys", "zipEndresses", "zipIntegrations", "ZipEntries", "sliceEries", "ZipEntions", "zipEntresses", "zipEresses", "zipCurries", "zipEndry", "zipEnry", "zipEnresses", "zipEnrations", "zipIntegries", "zipEntry", "zipEnrys", "zipCurlements", "zipCurrys", "zipEnries", "zipEntrys", "zipCurions", " zipEntrations", "zipEntlines", "zipIntegry", "zipEry", "zipEntlements", "zipentries", "sliceEntlines", "zipElines", "ZipEntrys", "zipEntions", "zipEndlines", " zipEntry"], "target": ["next", "match", "template", "component", "compatible", "host", "output", "class", "object", "context", "wrong", "theme", "scope", "route", "nt", "address", "loc", "tail", "format", "content", "location", "path", "resource", "top", "value", "dest", "file", "config", "bh", "feat", "prefix", "unit", "platform", "goal", "data", "type", "flat", "Target", "rel", "tag", "it", "method", "hop", "name", "site", "style", "arget", "project", "string", "href", "remote", "external", "current", "filename"], "webRewriter": ["webrewitcher", " webrewitcher", "New", "webrewriter", " webReworter", "webReprite", " webRewitcher", "app", "s", "webRepriter", "webReworter", "webResriter", "http", "webResrite", " webrewriter", "_", " webrewrite", "webRewitcher", "webRewrite", "webResitcher", "this", "webResorter", "webreworter", "application", "Entry", "webReporter", "webrewrite", " webreworter", " webRewrite", "webRepitcher"]}}
{"id1": "10451698", "id2": "19335986", "code1": "    private void copy(File source, File destinationDirectory) throws IOException {\n        if (source.isDirectory()) {\n            File newDir = new File(destinationDirectory, source.getName());\n            newDir.mkdir();\n            File[] children = source.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".svn\")) {\n                    continue;\n                }\n                copy(children[i], newDir);\n            }\n        } else {\n            File newFile = new File(destinationDirectory, source.getName());\n            if (newFile.exists() && source.lastModified() == newFile.lastModified()) {\n                return;\n            }\n            FileOutputStream output = new FileOutputStream(newFile);\n            FileInputStream input = new FileInputStream(source);\n            byte[] buff = new byte[2048];\n            int read = 0;\n            while ((read = input.read(buff)) > 0) {\n                output.write(buff, 0, read);\n            }\n            output.flush();\n            output.close();\n            input.close();\n        }\n    }\n", "code2": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "label": 1, "substitutes": {"copy": ["run", "cop", "paste", "share", "cat", "zip", "rm", "py", "Copy", "move", "process", "ignore", "list", "sync", "download", "archive", "part", "replace", "drop", "cp", "clone", "delete", "get", "load", " cp", "dump", "split", "transfer", "file", "remote", "change", "clip", "write", "type", "parent", "update", "lock", "ssh", "create"], "source": ["folder", "resource", "slave", "root", "plus", "class", "use", "section", "seed", "project", "string", "current", "site", "cache", "Source", "sf", "view", "proxy", "service", "scope", "ource", "path", "from", "slice", "client", "ce", "object", "archive", "unit", "ie", "connection", "document", "storage", "model", "server", "url", "config", "flat", "iter", "filename", "SOURCE", "start", "image", "remote", "result", "directory", "reader", "data", "secure", "target", "null", "parent", "stream", "info", "src", "name", "file"], "destinationDirectory": ["destinationsFolder", "destructionFolder", "destinatorDirectory", "destributionFile", "DestinationDir", "destributionDirectory", "destinatorPath", "destinationHome", "destinationPoint", " destinationDir", "destippingDir", "destinatorPoint", " destinationsDir", "destributionHome", "destructionDir", "destificationDirectory", "destributionFolder", "destributionDir", " destinationsFile", "DestinationDirectory", "destarationPoint", "destinationsDirectory", "DestinationFolder", "destinationPath", " destinationsFolder", "DestributionHome", "destributionPath", "destinationFile", "destarationPath", "destinationsDir", "destarationDirectory", "destructionDirectory", "destributionPoint", "destinationsFile", "destificationDir", "DestinationPath", "DestinationHome", " destinationsDirectory", "DestributionPoint", "destippingFolder", "DestinationPoint", " destinationFolder", "DestributionPath", "destificationFolder", "DestributionDirectory", "destippingDirectory", "destificationHome", "destippingHome", "destinationFolder", "destinationDir", " destinationFile", "DestributionFolder", "destructionFile", "DestributionDir"], "newDir": ["NewFolder", " newFolder", "NewFile", "Newdir", "nextDirectory", "nextFile", "newdir", "newFolder", "NewDirectory", "nextFolder", " newdir", "newDirectory", "nextDir", "nextdir", "NewDir", " newDirectory"], "children": ["names", "pages", "packages", "each", "words", "father", "current", "parents", "opens", "values", "list", "ools", "files", " Children", "ins", "events", "ums", "members", "content", "child", "begin", "loc", "tests", "roots", "when", "url", "ren", "projects", "scenes", "balls", "kids", "other", "blocks", "ul", "iblings", "filename", "uc", "Children", "rules", "data", "items", "mount", "sub", "parent", "web", "iv", "pes", "collection", "which", "sort", "rows"], "i": ["iu", "hi", "si", "qi", "ip", "u", "multi", "n", "ii", "k", "m", "pi", "ini", "o", "y", "d", "inner", "ci", "di", "io", "key", "slice", "ji", "ui", "in", "ri", "ie", "p", "it", "part", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "ori", "q", "start", "h", "gi", "v", "ti", "type", "ai", "mi", "b", "xi", "id", "info", "uri", "iv", "ix", "mu", "lc", "end"], "newFile": ["Newfile", "oldDir", "createFile", "nextSource", "newSource", "oldFiles", "NewFile", " newSourceFile", "nextfile", "newFiles", "createSource", " newfile", "NewFiles", "nextFile", "nextSourceFile", "nextFiles", "NewDirectory", "NewSourceFile", "newDirectory", "newfile", "nextDir", "oldFile", "createDir", "newSourceFile", "NewSource", "NewDir", "createfile", "oldDirectory", " newFiles", " newDirectory"], "output": ["resource", "temp", "application", "external", "again", "current", "ilo", "o", "option", "service", "response", "core", "outer", "after", "display", "operation", "object", "address", "unit", "generation", "connection", "out", "config", "complete", "oper", "other", "control", "image", "socket", "writer", "result", "page", "four", "error", "ou", "write", "kernel", "change", "target", "put", "web", "parent", "generated", "binary", "update", "console", "file", "Output", "flow"], "input": ["resource", "temp", "pull", "plus", "operator", "instance", "current", "context", "request", "http", "inner", "self", "feed", "text", "this", "in", "child", "ack", "print", "audio", "connection", "out", "storage", "exec", "work", "config", "index", "Input", "before", "ink", "image", "socket", "inf", "reader", "data", "error", "raw", "inc", "parent", "stream", "client", "buffer", "form", "keep", "flow"], "buff": ["bound", "txt", "fe", "ob", "cast", "comment", "bin", "uff", "shape", "feed", "char", "buf", "slice", "cod", "pad", "cf", "length", "boot", "count", "bug", "batch", "comb", "ph", "ff", "oct", "gb", "hello", "cp", "cmd", "cur", "load", "f", "gz", "uf", "bind", "cb", "bb", "data", "Buff", "b", "fb", "flush", "pack", "info", "buffer", "back", "text", "rb"], "read": ["reads", "ask", "run", "pass", "use", "ip", "send", "n", "and", " write", "readable", "k", "reading", "fill", "select", "READ", "lex", "io", "open", "feed", "add", "slice", "sync", "skip", "length", " count", "count", "seek", "play", "Read", " load", "rate", "exec", "find", "get", "load", "x", "config", "wait", "size", "f", "iter", "index", "len", "allow", "ink", "ind", "ok", "check", "start", "close", "transfer", "next", "reader", "se", "type", "write", "parse", "b", "en", "id", "loop", "buffer", "text", "end"]}}
{"id1": "14473711", "id2": "3514286", "code1": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"str2md5": ["str2digse", "str2MD5", "str2dig512", "str2dig3", "str2h3", "str2MD3", "str2dig5", "str_MDse", "str2h5", "str_md3", "str_mdse", "str2h512", "str2MDse", "str_md512", "str2MD512", "str_MD3", "str2hse", "str2md3", "str2md512", "str_MD5", "str_md5", "str_MD512", "str2mdse"], "str": ["enc", "err", "dr", "in", "fr", "br", "kr", "hex", "inner", "format", "input", "arr", "exp", "text", "STR", "bytes", "url", "string", "txt", "code", "sp", "r", "spec", "buffer", "t", "tr", "pass", "st", "er", "p", "dict", "source", "result", "name", "test", "sr", "data", "char", "Str", "empty", "i", "msg", "strings", "cr", "f", "obj", "s"], "alga": ["alca", " alqa", "Alga", " alda", "ALja", "elgas", "alsga", "ala", "ALgas", "Algas", " ala", "Alja", "ALsa", "ela", "alsqa", "ALda", "alsca", " alca", " alja", "alsa", "alqa", "elda", "elga", " algas", "ALqa", "ALga", "alda", "Alsa", "ALa", "algas", "alja", "alsda", "ALca", " alsa"], "digesta": ["igza", "badza", "finesta", "badera", "igesta", "igosta", "digza", "codeste", "igera", "codsta", "diffesta", "diffsta", "diffosta", "finsta", "digeste", "codera", "codosta", "digosta", "digsta", "codesta", "diffeste", "fineste", "digera", "badosta", "codza", "badesta", "finosta"]}}
{"id1": "19549489", "id2": "14877116", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "label": 1, "substitutes": {"copy": ["p", "source", "create", " copies", " copied", "sync", " move", "paste", "Transfer", "download", "all", "Cop", "move", "cop", "io", " copying", "clone", "transfer", " transfer", "split", "zip", "upload", "Copy", "write", " Copy", "file", "delete"], "sourceFile": ["searchFile", " sourcefile", " sourceFILE", "sourceFILE", "searchFilename", " sourceFiles", "serviceFilename", "siteFILE", "SourceFILE", "siteFile", "sourceDirectory", "searchFiles", "resourceFile", "sourceFilename", "resourceDirectory", " sourceDirectory", " sourceFilename", "SourceFile", "sourcefile", "resourcefile", "servicefile", "sourceFiles", "resourceFiles", "siteDirectory", "searchfile", "serviceFiles", "SourceDirectory", "serviceFile", "siteFiles", "Sourcefile", "SourceFiles"], "destinationFile": ["destinatedFile", "destationImage", "destationDir", "distinatedDirectory", "DestinatorDir", "destinatorDir", "distinationDirectory", "distinationFiles", "destinatedImage", "distinatedImage", "destationFile", "destationfile", "destinationFiles", "distinationFile", "DestinatorFiles", "Destinationfile", "destationFiles", "distinatedFile", "distinatedFiles", "destinatedfile", "destinatorfile", "destinationDir", "Destinatorfile", "destinatedDirectory", "DestinatorFile", "destinatorImage", "DestinationDir", "destinationImage", "destinationDirectory", "destinatorFiles", "destinatorDirectory", "distinationImage", "DestinationFiles", "DestinationFile", "destationDirectory", "destinatedFiles", "destinatorFile", "destinatedDir", "destinationfile"], "sourceFileChannel": ["sourceDirectoryChannel", " sourceFilesService", "sourceFunctionChannel", " sourceFilesContext", "sourceLibrarySocket", "ourceFileStream", "sourceStreamStream", "targetLibrarySocket", "sourceStreamService", "targetLibraryClient", "ourceStreamchannel", "targetLibraryChannel", "targetFileSocket", "sourceFilesChannel", "sourceLibraryChannel", " sourceFileService", "ourceFileChannel", "sourceStreamChan", "sourceFileConnection", "sourceFileContext", "targetFileChannel", "ourceStreamChannel", "sourceLineChannel", "sourceLineClient", "sourceFunctionContext", "ourceStreamStream", "ourceFileChan", "sourceDirectoryClient", "sourceDirStream", "sourceLineStream", " sourceFilesConnection", "sourceLinechannel", "sourceDirChan", "sourceDirectoryChan", "sourceStreamChannel", "sourceFileChan", "sourceFunctionConnection", "sourceStreamConnection", " sourceFileConnection", "sourceFileStream", "targetFileChan", "sourceLibraryChan", "sourceFilesContext", "sourceLineChan", "ourceStreamChan", "sourceFunctionService", "sourceFileService", " sourceFileContext", "ourceFilechannel", "sourceStreamContext", "sourceStreamchannel", "sourceDirchannel", "sourceDirChannel", " sourceFilesChannel", "targetFileClient", "sourceLineSocket", "targetLibraryChan", "sourceFilesConnection", "sourceFileSocket", "sourceDirectorySocket", "sourceFileClient", "sourceLibraryClient", "sourceFilesService", "sourceFilechannel"], "destinationFileChannel": ["destinationDirectoryHandler", "destinatorFileHandler", "destinationFilesCache", "destinatorFileChan", "destinationFilesClient", "destinatorFilesClient", "destinationFilesChannel", "destinationIOChannel", "destinatorFileClient", "destinationFileChan", "destinationDirectoryChannel", "destinatorFileChannel", "destinationLineHandler", "destinationLineClient", "destinationDirectoryConnection", "destinationFilesHandler", "destinatorFilesHandler", "destinationIOCache", "destinationFilesService", "destinationFileClient", "destinatorFileConnection", "destinationDirectoryChan", "destinatorFileService", "destinationLineConnection", "destinationLineChannel", "destinationDirectoryClient", "destinatorFilesCache", "destinationIOClient", "destinationFileConnection", "destinationDirectoryService", "destinationFileService", "destinatorFilesService", "destinationIOService", "destinationLineChan", "destinatorFilesConnection", "destinatorFilesChan", "destinatorFileCache", "destinationFileCache", "destinationFileHandler", "destinationDirectoryCache", "destinationFilesChan", "destinationLineService", "destinationFilesConnection", "destinatorFilesChannel"]}}
{"id1": "3958807", "id2": "16590954", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadFbinaryStream", "loadFbinaryInput", "loadBatchFile", "loadBinaryContent", "loadFinaryFile", "loadBInputFile", "loadBInputInput", "loadBinaryFile", "loadBatchContent", "loadBinaryInput", "loadBbinaryInput", "loadFinaryStream", "loadBbinaryStream", "loadBatchInput", "loadBInputContent", "loadFinaryInput", "loadBatchStream", "loadBbinaryFile", "loadFinaryContent", "loadBInputStream", "loadFbinaryContent", "loadFbinaryFile", "loadBbinaryContent"], "streamName": ["streamname", "channelKey", "fileName", "fileType", "filePath", "filename", "resourcePath", "StreamPath", " streamname", "streamType", "Streamname", "channelName", "streamPath", "resourceType", "resourceName", "channelPath", " streamType", "streamKey", " streamKey", " streamPath", "StreamName", "resourcename", "fileKey"], "streamToLoad": ["channeltoload", "channelToLoad", "channelToload", "streamtoUpload", "streamWillUse", "objectToUse", " streamToUse", "streamTOLoad", "streamTOAdd", "streamToload", "streamWillUpload", "streamtoload", "streamtoRead", "streamtoLoad", "streamWithAdd", "streamToRead", "streamToAdd", "objectTOUse", "streamWithRead", "objectTOUpload", "objectToLoad", " streamtoRead", " streamtoUse", "streamTOUse", "streamtoAdd", " streamToAdd", "objectTOLoad", "streamWillLoad", "objectTORead", "objectToRead", " streamtoAdd", "streamTORead", "channeltoLoad", "streamtoUse", "channeltoAdd", "streamWillAdd", " streamtoLoad", "channelToAdd", "streamTOUpload", "streamWillRead", " streamToRead", "streamToUpload", "streamWithLoad", "streamTOload", "streamWithUse", "objectToUpload", "streamToUse"], "sz": ["sze", "ssze", "szes", " szip", "szi", "imszes", "szip", " sze", "ssiz", "wszip", "psze", "pszi", " szi", "imsze", "pszip", "siz", " siz", "wsz", "sszes", "wsze", "imsiz", "ssz", "psz", " szes", "imsz", "wszi"], "req": ["err", "q", "rx", "fr", "serv", "download", "input", "ref", "http", "src", "rec", "respond", "conn", "cb", "def", "r", "wx", "ok", "sem", "Request", "require", "progress", "rr", "inv", "proc", "rh", "response", "client", "Resp", "report", "request", "qt", "f", "rss", "rw", "pkg", "res", "ctx", "requ", "exec", "obj"], "resp": ["re", "err", "body", "html", "wb", "circ", "serv", "Response", "download", "rep", "ref", "http", "zip", "rev", "rec", "output", "respond", "conn", "bb", "jp", "par", "page", "remote", "api", "sp", "wp", "wx", "esp", "cmp", "cook", "ret", "proc", "df", "rh", "response", "prev", "client", "fp", "Resp", "comm", "report", "request", "rem", "server", "rup", "e", "rss", "res", "ctx", "rel", "exec", "reply", "obj"], "out": ["log", "base", "o", "in", "pool", "serv", "gz", "ops", "zip", "cache", "output", "OUT", "b", "bin", "conn", "auto", "object", "ws", "null", "buf", "buffer", "again", "outs", "op", "p", "boot", "io", "os", "response", "img", "Out", "tmp", "co", "data", "fn", "binary", "i", "res", "default", "aos", "exec", "copy", "s"], "bos": ["bo", "pins", "lol", "zos", "osa", "zb", "bot", "mis", "osi", "cro", "bas", "bin", "bb", "obo", "ubis", "obs", "biz", "zo", "abi", "bes", "bro", "rob", "boot", "flo", "ros", "obb", "os", "obos", "bi", "bott", "bis", "ko", "oops", "las", "bs", "bare", "bps", "ob", "lo", "ios", "oos", "fits", "bc", "bh", "los", "aos"]}}
{"id1": "255765", "id2": "14191679", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"f": ["x", "inf", "df", "name", "ff", "self", "fen", "s", "g", "m", "p", "j", "fe", "fun", "b", "w", "rf", "F", "l", "r", "fn", "fi", "e", "tf", "fr", "lf", "fold", "this", "d", "fx", "feed", "t", "cf", "path", "h", "filename", "of", "v", "form", "n", "io", "flat", "c", "file", "function", "fa", "folder", "a", "fd", "bf", "sf", "fp", "fo", "fm", "ref", "fc", "fs"], "in": ["lock", "login", "data", "str", "vin", "is", "ssl", "b", "w", "win", "IN", "err", "d", "source", "t", "exec", "c", "it", "socket", "session", "g", "ins", "pin", "m", "fe", "inner", "rin", "init", "nin", "or", "thin", "up", "fa", "gin", "reader", "p", "cin", "In", "part", "with", "r", "ini", "image", "inc", "config", "n", "con", "serv", "connection", "bin", "isin", "get", "ex", "min", "gen", "rec", "again", "l", "din", "v", "pass", "inn", "a", "ic", "lin", "token", "input", "diff", "ac"], "cbuf": ["bault", "bcault", "bbull", "cbull", "bcurs", "CBuff", "rbux", "cbuu", "zbutf", "bcull", "dbuc", "bcuf", "CBuc", "bcux", "zbuu", "cbault", "cfuff", "buff", "dbuff", "rbul", "bbuff", "CBuf", "cfur", "cfuc", "rbbuf", "rbutf", "cburs", "rbull", "rburs", "zbuff", "ebutf", "cbur", "CBul", "ebuff", "ebuf", "rbuu", "dbuf", "bcul", "fbuc", "cbul", "rbuf", "cbuff", "bcuff", "bux", "rbault", "bburs", "cbutf", "fbbuf", "ebuu", "buf", "fbuf", "bcuc", "rbuff", "cbuc", "cbux", "dbur", "cfuf", "cfbuf", "bcur", "fbuff", "bbuf", "rbuc", "cbbuf", "zbuf"], "read": ["iter", "data", "name", "type", "put", "know", "only", "find", "reads", "orig", "loop", "w", "work", "val", "d", "buffer", "select", "want", "fill", "close", "update", "io", "cel", "length", "report", "print", "re", "end", "wait", "READ", "open", "it", "socket", "Read", "error", "allow", "g", "play", "stream", "se", "load", "en", "ind", "log", " write", "ok", "key", "bind", "call", "count", "parse", "build", "level", "oct", "id", "last", "record", "insert", "use", "start", "bit", "x", "reader", "ride", "un", "create", "send", "add", "check", " READ", "old", "r", "each", "ak", "seek", "run", "lex", "ing", "feed", "connect", "inc", "config", "raw", "valid", "full", "er", "readable", "y", "get", "q", "ack", "change", "sync", "k", "used", "hex", "rc", "text", "size", "num", "child", " Read", "reading", "view", "pass", "pe", "ink", "repeat", "index", "ed", "input", "ize", "skip", " reading", "sleep", "draw", "write"], "totRead": ["ntottReader", "tottDraw", "TotaRead", "ntottLoad", "tobyFind", "tollRead", "toyDraw", "totoRead", "TotLoad", "tottFind", "totaLink", "ntotLoad", "tollLoad", "octotoRead", "tottReader", "tcotLoad", "tntRead", "dotReader", "tottLength", "dotWrite", "totoUse", "tottClose", "dottFind", "ntottRead", "octotoWrite", "totalWrite", "totingGet", " totalLink", "totingSearch", "tottSearch", "tottedRead", "nottLoad", "dottLoad", "totLength", "tobyRead", " totalBuild", "ntotReader", "tollReading", "tottedWrite", "totalLoad", "totaReader", "TotSearch", "notLoad", "tochReader", "TottLoad", " totalRead", "tottAccept", "tottConnect", "totiRead", "towAccept", "tatWrite", "tatReader", "TottGet", "totGet", "tottRead", "TottReading", "totoWrite", "TottReader", "tazonClose", "totiBuild", "tetReading", "octotRead", "TottFollow", "tottFollow", "TotConnect", "TotReader", "notWrite", "tntReader", "octotLength", "totoSearch", "totoLength", "tntWrite", "totaBuild", "tatRead", "tottLoad", "intottRead", "totalAccept", "tottReading", "totingRead", "totFollow", "TotWrite", "totDraw", "tntLoad", "TottWrite", "totalRead", "towWrite", "toyRead", "dottUse", "totSearch", "tetLoad", "tottUse", "tottedFollow", "nottRead", "TottRead", "dottReading", "dotReading", "tcotClose", "TottSearch", "totoReading", "tobyUse", "totLink", "TotReading", "totalLink", "towReading", "ntottWrite", "TotGet", "tottedGet", "tetWrite", "totBuild", "tochWrite", "totoFind", "totReader", "totingConnect", "towRead", "totingFollow", "dotRead", "dottReader", "TotaWrite", "intottClose", "tobyLoad", "toyWrite", "totoConnect", "intotBuild", "totAccept", "intotRead", "tazonBuild", "notAccept", "dotLoad", "toyLoad", "totWrite", " totBuild", "TottConnect", "towLoad", "tochLoad", "tazonRead", "TotRead", "TotaLoad", " totWrite", "totoLoad", "totaLoad", "totiLink", "tottWrite", "totClose", "octotoLength", "dotFind", "tetRead", "intotLoad", "octotReading", "ntotRead", "tottBuild", "totalBuild", "towLength", "tollWrite", "tochRead", "octotoReading", "intotClose", "totaDraw", "TotaDraw", "totLoad", "totaWrite", " totalWrite", "nottWrite", "tazonLoad", "tcotRead", "totaRead", "TotDraw", "totingWrite", "tottGet", "totUse", "ntotWrite", "totConnect", "intottLoad", "intottBuild", "totFind", "totiWrite", "dottWrite", "octotWrite", "tatLoad", "notRead", "tcotBuild", "nottAccept", "dotUse", "totReading", "totaReading", "dottRead", "TotFollow", " totLink"], "out": ["x", "connection", "bin", "ext", "socket", "s", "g", "sync", "p", "ex", "outs", "In", "conn", "b", "w", "output", "again", "part", "conf", "l", "r", "fn", "writer", "err", "plus", "o", "off", "client", "OUT", "d", "init", "inc", "t", "h", "exec", "parent", "v", "outer", "n", "io", "net", "c", "file", "up", "a", "exp", "ac", "Out", "obj"], "i": ["data", "current", "name", "ie", "me", "is", "bi", "b", "o", "d", "buffer", "source", "h", "xi", "uri", "io", "c", "gi", "length", "si", "it", "g", "m", "ori", "ind", "ix", "I", "u", "key", "abi", "init", "z", "yi", "mi", "ui", "li", "id", "ai", "start", "x", "ti", "my", "j", "info", "p", "one", "hi", "ei", "multi", "qi", "r", "fi", "e", "ini", "ci", "api", "ik", "oi", "zi", "ii", "ni", "iu", "eni", "phi", "ip", "ji", "y", "ri", "q", "slice", "pi", "k", "di", "l", "v", "index", "chi", "ic", "input"]}}
{"id1": "6625074", "id2": "614099", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"SHA1": ["SHA384", "HA256", "sha1", "sha256", " SHA384", "SHAOne", "HA384", "HA1", "SHA256", " SHA256", "shaOne", "sha384", "HAOne", " SHAOne"], "text": ["font", "txt", "message", "image", " Text", "plain", "struct", "letter", "data", "in", "output", "input", "str", "editor", "hex", "translation", "password", "template", "bytes", "test", "out", "code", "class", "source", "config", "TEXT", "object", "token", "string", "obj", "name", "pattern", "context", "path", "transfer", "word", "content", "value", "format", "buffer", "ext", "contract", "Text"], "sha1hash": ["sha6hash", "sha6Hash", "sha2hex", "SHA1hash", "sha1log", "SHA2Hash", "sha_hex", "SHA1cap", "sha81cap", "sha1hex", "sha6log", "SHA2hash", "sha_Hash", "shaOnetext", "sha1Hash", "SHA2log", "shaOnepassword", "sha2hash", "ha1hash", "sha2Hash", "shaOneHash", "sha81hash", "sha256password", "sha2sum", "ha2Hash", "sha1sum", "sha2cap", "SHA1Hash", "SHA2cap", "SHA1password", "sha2log", "shaOnehash", "ha2hex", "sha1text", "sha_sum", "SHA1text", "sha1password", "sha81log", "SHA1log", "sha_hash", "ha1Hash", "ha1hex", "sha256text", "ha2hash", "sha256hash", "ha2sum", "sha1cap", "ha1sum", "sha256Hash", "sha81Hash", "sha6cap"], "md": ["m", "rm", "hd", " MD", "nd", "mp", "sha", "cmd", "mo", "um", "dig", "dd", "f", "rpm", "hash", "editor", "mc", "mag", "d", "vd", "od", "ms", "meta", "hm", "wd", "mb", "amd", "nm", "dm", "bd", "pkg", "metadata", "pd", "MD", "ad", "de", "mac", "mm", "ma", "gb", "sm", "ld", "pm", "cf", "cd", "mt", "df"]}}
{"id1": "16215393", "id2": "21827619", "code1": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"importSequences": [" importSequements", "importMultipleence", "importInternence", "importsequence", "importMultipleFiles", "importSequence", " importSequence", "importSequements", " importsequences", "importInternements", " importSequFiles", "importInternFiles", "importInternences", " importsequence", " importsequFiles", "importsequFiles", "importMultipleements", " importsequements", "importMultipleences", "importsequements", "importsequences", "importSequFiles"], "names": ["Names", "ports", "they", "paces", "objects", "packages", "codes", "keys", "ans", "lines", "services", "ids", "ns", "ons", "mas", "frames", "views", "files", "pres", "headers", "obs", "ames", "images", "params", "works", "nos", "named", "tags", "hops", "states", "ins", "users", "members", "models", "ens", "modules", "stars", "words", "sheets", "strings"], "sequences": ["equencies", "equence", "variences", "sequence", "contances", "responsences", "occupations", "Sequences", "sequations", "equations", "contencies", "varielines", "sequelines", "responsations", "occupence", "contelines", "variencies", "contences", "sequencies", "variances", "sequances", "responsencies", "equences", "Sequances", "occupencies", "Sequencies", "responsence", "occupences", "Sequelines"], "is": ["its", "in", "isi", "ls", "ir", "lis", "has", "api", "info", "IS", "p", "ris", "os", "it", "isa", "out", "sis", "iss", "ip", "as", "close", "iso", "app", "are", "bis", "es", "us", "init", "h", "isc", "ios", "Is", "i", "ais", "or", "ar", "url", "s"], "helper": ["helpen", " Heller", "hemer", " Helmer", "hyf", "comler", "perpers", "helpmer", "heler", "perler", "helpping", "helppers", "shper", "shler", " helar", "helhel", "Helper", " helping", "thelper", "hyper", "theller", "comhel", "helpper", "compen", "comper", "helf", "Heller", "Helpen", "helpPER", "thelpers", "Helf", "calper", "hypers", "helPER", "thelmer", "helpar", " Helper", "calPER", " Helpers", "Helhel", "helpers", "hepers", "helping", "perf", " helPER", "perper", "heper", "helar", "heller", "Helpers", "shhel", "helmer", "hyler", "helpler", "calping", "shpen", "calar", "permer"], "ch": ["enc", "err", "th", "cmd", "chi", "q", "change", "quote", "sch", "coll", "Ch", "sk", "hex", "cl", "och", "cur", " chunk", "arch", "ech", "qu", "conn", "pr", "code", "c", "chu", "gr", "k", "anch", "ci", "CH", "p", "cmp", "conf", "div", "cht", "se", "cha", "cor", "sh", "ce", "che", "unch", "length", "chan", "ur", "cher", "cho", "col", "cp", "h", "char", "ach", "el", "zh", "bh", "ctx", "ich"], "line": ["lc", "letter", "base", "cle", "end", "nl", "content", "lf", "cl", "lines", "entry", "inline", "LINE", "text", "Line", "sync", "l", "page", "string", "code", "pos", "c", "pass", "job", "part", "frame", "row", "block", "word", "data", "file", "cell", "e", "char", "header", "str", "sl", "iter", "source", "url", "lin"], "tokenizer": ["okeniz", "okenize", "Tokeniz", "tokenizing", " tokeniz", "tokenizers", "Tokenize", "okenizer", "tokeniz", "tokenner", "okenner", " tokenizers", "Tokenizing", " tokenize", "Tokenner", " tokenizing", "tokenize", "Tokenizers", "Tokenizer", "okenizers", " tokenner", "okenizing"], "name": ["letter", "base", "prefix", "NAME", "alias", "filename", "key", "label", "info", "object", "string", "ame", "pass", "next", "Name", "path", "er", "type", "part", "named", "number", "attr", "start", "size", "word", "search", "id", "data", "time", "str", "comment", "n", "non", "default", "connection", "url"], "seq": ["lc", "unit", "conv", "vals", "wave", "feed", "vec", "fast", "sci", "quote", "closure", "sequence", "val", "cl", "feat", "req", "parse", " buf", "zip", "sec", "text", "queue", "que", "list", "info", "cb", "struct", "string", "buf", "c", "resp", "buffer", "iq", "sem", "job", "phrase", "frame", "cas", "length", "chain", "sq", " sequence", "la", "sel", "live", "data", "str", "pkg", "iter", "ctx", "config"]}}
{"id1": "15797402", "id2": "822452", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"parse": ["wrap", "save", "apply", "handle", " serve", "php", "view", "load", "cover", "raw", "replace", "worker", "request", "xml", "patch", " convert", " analyse", " parsing", "set", " rewrite", " process", "rate", "read", "fork", "print", "report", "Parser", "transform", "scan", "arse", "pack", "parser", "service", " parser", "http", "process", "se", "processing", "pc", " split", "split", " transform", " dispatch"], "stream": ["url", "reader", "client", "sample", "handle", "view", "feed", "load", "raw", "remote", "input", "inner", "image", "upload", "down", "Stream", "read", "writer", "video", "through", "loader", "message", "resource", "content", "stack", "document", "iterator", "form", "http", "in", "source", "channel", "server", "data", "file", "download", "src", "draw", "response", "temp"], "handler": ["monitor", "processor", "base", "reader", "client", "handle", "controller", "default", "function", "manager", "host", "pointer", "driver", "layer", "format", "event", "handled", "writer", "info", "connection", "application", "Handler", "parent", "hand", "loader", "parser", "service", "wrapper", "phase", "h", "di", "data", "channel", "server", "collection", "ctx", "response"], "metadata": ["map", "template", "md", "monitor", "processor", "header", "params", "met", "runtime", "xml", "metry", "manager", "plugin", "meta", "mt", "state", "material", "database", "mi", "storage", "mon", "m", "properties", "management", "component", "info", "connection", "directory", "config", "parser", "message", "uri", "attribute", "property", "resource", "adata", "managed", "document", "content", "di", "data", "source", "subject", "mx", "json", "collection", "ctx", "module"], "context": [" Context", "processor", "mc", "reader", "system", "scope", " contexts", "proxy", "command", "tx", "request", "xml", "manager", "environment", "event", "component", "element", "connection", "method", "object", "kernel", "text", "parent", "config", "concept", "message", "resource", "Context", "document", "content", "translation", "data", "entry", "subject", "instance", "collection", "txt", "ctx", "cmp"], "name": ["address", "url", "base", "alias", "job", "call", "comment", "ame", "id", "child", "none", "model", "old", "path", "Name", "default", "label", "filename", "string", "on", "time", "named", "action", "word", "size", "no", "prefix", "image", "missing", "large", "code", "m", "type", "connection", "active", "class", "route", "null", "n", "object", "sync", "message", "resource", "common", "api", "version", "key", "search", "in", "source", "data", "work", "file", "full", "names", "part", "NAME"], "out": ["url", "result", "OUT", "client", "outs", "builder", "output", "bin", "window", "exp", "io", "child", "path", "obj", "conn", "ext", "image", "err", "Out", "plain", "lib", "ray", "extra", "writer", "connection", "user", "null", "object", "again", "ex", "o", "socket", "sync", "resource", "flush", "copy", "in", "line", "data", "source", "file", "server", "page", "pool", "channel", "cos", "instance", "manager", "temp"]}}
{"id1": "14168494", "id2": "300397", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", "transferClass", "copyfile", " copyfile", " copyClass", " copiedClass", "transferfile", " copiedFile", "copyFiles", "copyClass", " copiedFiles", " copiedfile", "transferFiles", "transferFile"], "dest": [" Dest", "txt", "resource", "null", "st", "Dest", "loc", "destroy", "data", "later", "this", "output", "d", "done", "comb", "out", " destination", "temp", "source", "class", "dir", "true", "tmp", "target", "desc", "file", "obj", "dist", "sup", "name", "wb", "path", "transfer", "orig"], "src": ["url", "ssl", "rob", "copy", "master", "st", "loc", "Dest", "rc", "sync", "sb", "inst", "split", "rb", "storage", "cb", "s", "sq", "download", "sin", "source", "config", "tmp", "filename", "sub", "stream", "target", "slice", "sc", "sit", "bin", "file", "dist", "sup", "upload", "gb", "sl", "sel", "img", "ds"], "srcChannel": ["destChannel", "inputChannel", " srcCh", "rcButton", "distStream", " srcButton", "rcCh", "rcChan", "sourceChannel", "srcCh", "srcChan", "distChan", "rcConnection", "srcButton", "distCh", "rcSection", "sourceButton", "inputchannel", "destchannel", "distChannel", " srcchannel", "sourcechannel", "inputConnection", "rcchannel", "destConnection", "srcStream", "rcChannel", "srcchannel", "srcConnection", "sourceChan", "srcSection", "inputSection", " srcSection", " srcConnection", " srcChan", "destChan", "rcStream", " srcStream"], "dstChannel": ["dstsStream", "ddestStream", " dstchannel", "drdChan", "dstchannel", "dsrcVideo", "ddestVideo", "drdchannel", "ddestchannel", " drdchannel", " dstStream", "ddestChannel", "drcVideo", "ddestContext", "dstChan", "dstConnection", "drcchannel", " dstsChannel", "dstsChannel", " dstsConnection", "dDestConnection", "dDestchannel", "dstContext", "dDestStream", "dstschannel", "drcContext", "DstChannel", "DstVideo", "DdestChannel", "DdestVideo", "ddestChan", "dsrcChannel", " drdContext", " dstConnection", " dstschannel", "dstVideo", "drcChan", " dstContext", "drdChannel", " dstsStream", "dsrcchannel", "drcChannel", "dDestChannel", "dstStream", "ddestConnection", "Ddestchannel", " dstChan", " drdChan", "dstsConnection", " drdChannel", "Dstchannel", "drdContext"]}}
{"id1": "14783950", "id2": "22046596", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"compressWithZip": ["compressWithJar", "compressedWithJar", "compresswithSax", "compressedUsingJar", "compressInSax", "compressUsingJar", "compressedUsingSax", "compresswithJar", "compressInZip", "compressedUsingZip", "compressUsingZip", "compresswithZip", "compressUsingSax", "compressedWithZip", "compressedWithSax", "compressWithSax", "compressInJar"], "fileList": ["FileChain", "ziplist", "wordString", "fileStream", "modelList", " fileChain", "Filelist", "stringList", "modelStream", "stringChain", "zipSet", "modelEx", "FileName", "FileSet", "stringName", " fileCollection", "inputEx", "inputStream", " fileSet", "modelCollection", "fileChain", "fileEx", "inputList", " fileStream", "stringlist", "FileString", " fileString", "zipList", "fileCollection", "wordName", "fileString", " fileEx", "FileStream", "zipName", "inputCollection", " filelist", "FileList", "wordList", "fileSet", "wordStream", "filelist"], "zipFileName": ["archiveFileDir", "zipFileNames", "folderGlobalPath", "zipFullNames", "zipFilePath", "archiveDirName", "folderGlobalName", "zipPackageDir", "archiveFilePath", "zipFullname", "zipGlobalPath", "zipDirName", "folderGlobalname", "zipGlobalNames", "zipPackageName", "zipGlobalname", "folderFilePath", "zipFullPath", "folderFileName", "zipDirNames", "archiveDirPath", "archiveFileName", "zipFilename", "archiveDirDir", "zipFullName", "folderGlobalNames", "zipGlobalName", "zipPackagePath", "zipFullDir", "folderFileNames", "folderFilename", "zipFileDir", "zipDirDir", "zipDirname", "zipDirPath"], "fos": ["afaos", " fosh", "flis", "afos", "infis", "Fosh", "Fos", "foS", "Fis", "flosh", "afis", "fosh", "infaos", "afoS", "infoS", "infos", "FoS", "flos", "faos", "Faos"], "zos": ["z", "osi", "outs", "zzy", "onz", "ZA", "zar", "kos", "zip", "seconds", "bis", "zers", "spin", "chini", "es", "zon", "budget", "tz", "uz", "jobs", "zen", "zes", "os", "ses", "bag", "zl", "phi", "webkit", "bos", "zan", "dos", "zer", "iframe", "zo", "ozo", "zi", "LOS", "fits", "lins", "oses", "css", "zx", "nz", "zz", "fi", "zag", "rez", "abi", "cos", "inos", "jas", "zb", "ZI", "gz", "loop", "packs", "bes", "zik", "closure", "obb", "ros", "lol", "zy"], "iter": ["ser", "oper", "test", "ip", "chain", "ter", "upper", "itter", "enter", "parse", "finder", "el", "e", "ator", "inc", "sort", "cher", "index", "er", "former", "keep", "iz", "ir", "end", "inner", "liter", "set", "err", "next", "order", "iner", "Iterator", "ie", "i", "ite", "fer", "loc", "list", "walker", "gener", "ner", "inse", "outer", "slice", "fr", "it", "iterator", "is", "http", "file", "izer", "Iter", "coll", "inter", "f", "ener"], "fileName": ["FileType", " filePart", "FileLine", "fPart", "currentname", "localname", "localPart", "FileUrl", " filePath", "currentData", "localPath", "pageName", "filenameInfo", " fileUrl", "filename", "FileName", "currentUrl", "currentName", "fileOpen", "pagename", "fileLine", "filenamename", " fileFull", "fileData", " fileOpen", "simpleOpen", "filenameName", "fName", " fileData", " fileInfo", "fullPath", "fullOpen", "FileString", "filePart", "fileType", " fileString", "FilePath", "filenameFull", "FilePart", "fileInfo", "fLine", "fileFull", "fullName", "fileString", " filename", "FileFull", " fileLine", " fileType", "fname", "simplePath", "simpleName", "filePath", "FileInfo", "localName", "pageString", "FileData", "fileUrl", "pageType", "Filename"], "ind": ["bind", "mind", "z", "id", "inc", "Ind", "x", "index", "div", "val", "pt", "start", "length", "ded", "pend", "end", "rib", "ci", "len", "ii", "j", "i", "count", "eff", "pull", "loc", "ord", "cond", "fr", "ad", "inn", "wind", "ix", "nd", "in", "vert", "ld", "dir", "mid", "pos", "IND", "d"], "shortName": ["ShortPath", "smallName", "longName", "ShortPart", "fullLine", "smallname", "shortPart", "longPart", "smallPart", "longname", "smallPath", "shortname", "fullString", "fullname", "longPath", " shortString", "fullPath", " shortname", " shortLine", "ShortString", "fullName", "shortString", "Shortname", "shortPath", " shortPath", "longLine", "shortLine", "ShortName"], "fis": [" fiss", "fris", "cfis", "gisa", "afos", "Fos", " fisa", "Fis", "fios", "afis", "cfiss", "pis", "Fiss", "gios", "pris", "Fs", " fios", "fs", "gris", "fiss", " fs", "afiss", "cfos", "gis", "afris", "cfris", "cfs", "pisa", " fris", "pios", "fisa"], "buf": ["vec", "uf", "bc", "v", "uc", "bb", "bin", "tmp", "br", "bd", "cv", "bp", "cur", "fb", "ba", "seq", "queue", "bl", "bag", "box", "batch", "Buff", "lb", "b", "grab", "ff", "loc", "wb", "buffer", "done", "la", "bytes", "rb", "fd", "feat", "rc", "data", "pb", "bh", "bf", "lim", "cb", "buff", "bu"], "bytesRead": [" bytesSkip", "flowsLength", "bitsSkip", "secondsRead", "tesSkip", "secondsNeed", "secondsWrite", "wordsRead", "bitsRead", "secondsLength", "flowsRead", "flowsNeed", "tesWrite", "wordsWrite", "bytesSkip", " bytesUse", " bytesWrite", "bytesWrite", "bytesLength", " bytesLength", "flowsWrite", "bitsLoad", "bitsWrite", "tesLoad", "wordsUse", " bytesNeed", "bytesUse", "tesRead", " bytesLoad", "wordsLength", "bytesNeed", "bitsUse", "bytesLoad", "bitsLength"]}}
{"id1": "12106167", "id2": "18164929", "code1": "    public static void init(Locale lng) {\n        try {\n            Locale toLoad = lng != null ? lng : DEFAULT_LOCALE;\n            URL url = ClassLoader.getSystemResource(\"locales/\" + toLoad.getISO3Language() + \".properties\");\n            if (url == null) {\n                url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n            }\n            PROPS.clear();\n            PROPS.load(url.openStream());\n        } catch (IOException ioe) {\n            try {\n                URL url = ClassLoader.getSystemResource(\"locales/\" + DEFAULT_LOCALE.getISO3Language() + \".properties\");\n                PROPS.clear();\n                PROPS.load(url.openStream());\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(99);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(99);\n        }\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"init": ["ize", "Init", "register", "initial", "loading", "process", "construct", "boot", "strap", "build", "it", "create", "up", "setup", "install", "get", "load", "config", "loader", "start", "check", "reset", "parse", "pack", "info", "launch", "file"], "lng": ["slgn", "sleng", "Lnd", "slang", "leng", " lnd", "lcang", "slong", "lang", "lcong", " lgn", "Lng", "lnd", "Leng", " leng", "lcng", "Lang", "lgn", "lcnd", " lang", "Lgn", "slng"], "toLoad": ["toload", "poAdd", "ToLoader", " toAdd", "poLoader", " toSave", "TOLoader", "ToLoad", "TOLoad", "TOload", "toLoader", "TOSave", "Toload", "toAdd", " toload", "toSave", "TOAdd", "poSave", "poLoad", " toLoader", "ToAdd"], "url": ["resource", "or", "pull", "entry", "class", "stream", "ob", "zip", "string", "blog", "host", "http", "xml", "service", "www", "ource", "URL", "log", "path", "ll", "ur", "layer", "feed", "gl", "Url", "rl", "impl", "object", "user", "address", "orb", "bel", "loc", "lr", "err", "browser", "l", "base", "element", "event", "server", "location", "coll", "loader", "sl", "f", "ul", "el", "image", "page", "ssl", "bb", "fl", "obj", "null", "job", "id", "web", "uri", "source", "buffer", "parent", "org", "name", "file", "ref"]}}
{"id1": "442381", "id2": "6682825", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    KeyStore getKeyStore() throws JarSignerException {\n        if (keyStore == null) {\n            KeyStore store = null;\n            if (providerName == null) {\n                try {\n                    store = KeyStore.getInstance(this.storeType);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                }\n            } else {\n                try {\n                    store = KeyStore.getInstance(storeType, providerName);\n                } catch (KeyStoreException e) {\n                    e.printStackTrace();\n                } catch (NoSuchProviderException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (storeURI == null) {\n                throw new JarSignerException(\"Cannot load the keystore \" + \" error con el keystore\");\n            }\n            try {\n                storeURI = storeURI.replace(File.separatorChar, '/');\n                URL url = null;\n                try {\n                    url = new URL(storeURI);\n                } catch (java.net.MalformedURLException e) {\n                    url = new File(storeURI).toURI().toURL();\n                }\n                InputStream is = null;\n                try {\n                    is = url.openStream();\n                    store.load(is, storePass);\n                } finally {\n                    if (is != null) {\n                        is.close();\n                    }\n                }\n            } catch (Exception e) {\n                throw new JarSignerException(\"Cannot load the keystore \" + storeURI, e);\n            }\n            keyStore = store;\n        }\n        return keyStore;\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVERSIONWork", "doversionTest", "doVersionTest", "doBuildCheck", " doReleaseTest", "doReleasecheck", " doVersionWork", " doBuildTest", "doBuildcheck", "doVERSIONTest", " doBuildWork", "doBuildWork", "doversionCheck", "doReleaseWork", " doBuildcheck", "doVersionWork", " doBuildCheck", "doReleaseCheck", "doBuildTest", "doVERSIONcheck", " doVersioncheck", " doReleasecheck", "doVERSIONCheck", " doVersionTest", "doVersioncheck", " doReleaseCheck", "doReleaseTest", "doversioncheck"], "view": ["body", "image", "model", "html", "box", "q", "change", "can", "this", "self", "event", "form", "input", "edit", "window", "accept", "http", "cache", "widget", "vis", "use", "l", "full", "ui", "object", "page", "show", "views", "update", "display", "style", "session", "buffer", "gui", "div", "v", "row", "out", "client", "block", "see", "gu", "app", "View", "request", "sel", "server", "layout", "cell", "port", "e", "VIEW", "comment", "lock", "reader", "el", "config", "screen"], "url": ["image", "log", "URL", "base", "resource", "service", "stream", "input", "Url", "open", "hub", "channel", "http", "zip", "l", "bb", "string", "bel", "buffer", "path", "uri", "build", "client", "blog", "loader", "ssl", "server", "user", "file", "ll", "ob", "host", "browser", "sl", "lib", "connection", "source", "web", "f", "socket", "address"], "in": ["ini", "resource", "login", "stream", "gin", "inn", "inner", "input", "In", "inc", "b", "IN", "buffer", "source", "nin", "sin", "cin", "out", "ins", "is", "as", "init", "bis", "ac", "con", "data", "file", "binary", "rin", "isin", "reader", "win", "i", "n", "din", "socket", "lin", "s"], "bin": ["kin", "body", "log", "nb", "gin", "inn", "inner", "input", "bot", "din", "inline", "run", "b", "bb", "ruby", "spin", "pin", "IN", "border", "buffer", "abi", "oin", "part", "record", "bi", "cin", "out", "loader", "init", "bn", "con", "ln", "data", "file", "binary", "browser", "lock", "reader", "win", "lib", "fin", "sin", "socket", "lin"], "line": ["look", "link", "lc", "log", "unit", "base", "rule", "letter", "model", "end", "site", "nl", "lf", "cl", "lines", "inline", "entry", "LINE", "up", "day", "text", "message", "parse", "load", "Line", "key", "l", "b", "object", "page", "ine", "string", "code", "style", "home", "definition", "pe", "pass", "split", "job", "part", "row", "layer", "le", "block", "ip", "name", "word", "ge", "data", "file", "valid", "cell", "e", "band", "lo", "id", "str", "el", "i", "no", "comment", "non", "source", "lin"], "develBuild": ["DEVELBuild", "DEvelbuild", "devenBuilt", "desvenBuilt", "dewardBuilder", "deelBuilder", "desvelBuilder", "deployBuilt", "devenbuild", "deviousBuilt", "DEVELBuilt", "deVELBuilder", "DEVELBuilder", "devenRun", "DEvelBuilder", "develRun", "devenBuilder", "DEvelBuild", "dewardbuild", "DEVELbuild", "desvelBuilt", "desvenRelease", "deVELbuild", "deployRun", "deVELBuilt", "dewardBuild", "deelRun", "deelRelease", "desvelRelease", "devenBuild", "deelBuild", "desvelRun", "desvelBuild", "deployBuild", "desvelbuild", "dellRelease", "deVELBuild", "devenRelease", "desvenBuilder", "DEvelBuilt", "develbuild", "dellRun", "develBuilder", "deploybuild", "dewardBuilt", "dellBuild", "desvenRun", "deVELRun", "desvenbuild", "desvenBuild", "deployBuilder", "deviousBuild", "dellBuilder", "deviousbuild", "develBuilt", "develRelease"], "stableBuild": ["stableBuilder", "compatibleBuild", "prettyBuild", "secureBuild", "validbuild", "compatiblebuild", "compatibleBuilder", "staticBuild", "baseBuild", "stablebuild", "stableVersion", "secureBuilder", " stableBuilder", "validBuild", "securebuild", "prettyBuilder", "latestBuilder", "latestbuild", "staticBuilder", "staticbuild", "prettyVersion", "baseBuilder", "latestBuild", "basebuild", " stableVersion", "prettybuild", "baseVersion", "validBuilder", " stablebuild"]}}
{"id1": "5399593", "id2": "3514286", "code1": "    public synchronized String encrypt(String plaintext) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = null;\n        md = MessageDigest.getInstance(\"SHA\");\n        md.update(plaintext.getBytes(\"UTF-8\"));\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 1, "substitutes": {"encrypt": ["encryption", "decryption", " encress", " encryption", "decrypt", "decress", "encipher", "escrypt", "escress", "escipher", "decipher", " encipher", "escryption", "encress"], "plaintext": ["singleText", "ainform", "singletext", "forecontent", "singleTEXT", "plaincontent", " plainform", "ainTEXT", "ainText", "foreText", " plainTEXT", "plainform", "plainTEXT", "foretext", "aintext", "raincontent", " plainText", "raintext", "rainTEXT", "foreTEXT", " plaincontent", "singleform", "rainText", "plainText"], "UnsupportedEncodingException": ["UnsupportedCodingEx", "UnsupportedEncryptionError", "UnsupportedEncgorithmEx", "UnsupportedCodedEx", "UnsupportedEncodedException", "UnsupportedEncryptionEx", "UnsupportedEncryptionException", "UnsupportedEncgorithmError", "UnsupportedEncodingEx", "UnsupportedEncodedError", "UnsupportedEncodedEx", "UnsupportedCodingException", "UnsupportedCodedError", "UnsupportedCodingError", "UnsupportedCodedException", "UnsupportedEncodingError", "UnsupportedEncgorithmException"], "md": ["dc", "mb", "mp", "mg", "hed", "ms", "pm", "od", "mage", "mand", "rm", "mac", "map", "m", "Cmd", "mem", " MD", "d", "sha", "hm", "sum", "MD", "bd", "meta", "wd", "hd", "dd", "mc", "cd", "mod", "cmd", "mn", "ma", "mag", "code", "am", "dm", "material", "nm", "amd", "dig", "mm", "metadata", "po", "bf", "message", "mad", "mt", "me", "mu", "db", "mo"], "raw": ["wrap", "row", "full", "clean", "instance", "aws", "initial", "unknown", "sha", "input", "micro", "empty", "hex", "buf", "original", "ack", "shared", "missing", "alpha", "flash", "ng", "rew", "load", "array", "enc", "Raw", "serial", "blocks", "unsigned", "ghost", "null", "sign", "RAW", "message", "buffer", "block", "dec"], "hash": ["hed", "sh", "mac", "cache", "string", "Hash", "rh", "secret", "ruby", "sha", "sum", "abi", "log", "hh", "hex", "key", "auth", "ashes", "header", "kh", "build", "shared", "alpha", "flash", "ha", "base", "url", "math", "ash", "array", "code", "password", "image", "h", "html", "data", "id", "message", "text", "block", "version"]}}
{"id1": "2808955", "id2": "19296519", "code1": "    @Override\n    public EntrySet read(EntrySet set) throws ReadFailedException {\n        if (!SourceCache.contains(url)) {\n            SSL.certify(url);\n            try {\n                super.setParser(Parser.detectParser(url.openStream()));\n                final PipedInputStream in = new PipedInputStream();\n                final PipedOutputStream forParser = new PipedOutputStream(in);\n                new Thread(new Runnable() {\n\n                    public void run() {\n                        try {\n                            OutputStream out = SourceCache.startCaching(url);\n                            InputStream is = url.openStream();\n                            byte[] buffer = new byte[100000];\n                            while (true) {\n                                int amountRead = is.read(buffer);\n                                if (amountRead == -1) {\n                                    break;\n                                }\n                                forParser.write(buffer, 0, amountRead);\n                                out.write(buffer, 0, amountRead);\n                            }\n                            forParser.close();\n                            out.close();\n                            SourceCache.finish(url);\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }).start();\n                super.setIos(in);\n            } catch (Exception e) {\n                throw new ReadFailedException(e);\n            }\n            return super.read(set);\n        } else {\n            try {\n                return SourceCache.get(url).read(set);\n            } catch (IOException e) {\n                throw new ReadFailedException(e);\n            }\n        }\n    }\n", "code2": "        private long getSize(String url) throws ClientProtocolException, IOException {\n            url = normalizeUrl(url);\n            Log.i(LOG_TAG, \"Head \" + url);\n            HttpHead httpGet = new HttpHead(url);\n            HttpResponse response = mHttpClient.execute(httpGet);\n            if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {\n                throw new IOException(\"Unexpected Http status code \" + response.getStatusLine().getStatusCode());\n            }\n            Header[] clHeaders = response.getHeaders(\"Content-Length\");\n            if (clHeaders.length > 0) {\n                Header header = clHeaders[0];\n                return Long.parseLong(header.getValue());\n            }\n            return -1;\n        }\n", "label": 0, "substitutes": {"read": ["play", "index", "close", "ry", "input", "Read", "feed", "copy", "resource", "reading", "add", "http", "ic", "current", "socket", "find", "run", "weak", "write", "reads", "query", "iter", "content", "next", "select", "reader", "load", "build", "open", "work", "data", "check", "request", "get", "search", "es", "fill", "start", "exec", "send", "skip", "readable", "ping", "update", "stream", "create", "parse", "wait", "print", "process", "scan", "READ", "block", "view"], "set": ["ssl", "base", "server", "id", "setup", "resource", "reset", "spec", "entry", "settings", "site", "et", "end", "sync", "type", "source", "load", "session", "use", "seed", "cache", "rule", "ut", "store", "config", "src", "object", "size", "get", "context", "init", "or", "test", "name", "start", "SET", "sets", "send", "url", "update", "parse", "state", "setting"], "in": ["IN", "pin", "ssl", "i", "input", "id", "resource", "ini", "gin", "on", "ic", "con", "socket", "inner", "ins", "bin", "client", "reader", "cache", "source", "login", "min", "inc", "data", "file", "src", "p", "init", "again", "io", "image", "it", "In", "spin", "pull", "url", "inn", "f", "win"], "forParser": ["forReader", "ofListener", "foreMaster", "forMaster", "ofReader", "ForFile", "withparser", "ForMaster", "ForJar", "ForParser", "forparser", "ofParser", "Forparser", " forJar", " forReader", "foreReader", "ForReader", "withJar", " forListener", " forMaster", "forListener", "withParser", " forparser", " forFile", "ofJar", "foreParser", "foreparser", "ForListener", "forJar", "withFile", "forFile"], "out": ["ssl", "i", "outer", "output", "copy", "ex", "http", "net", "OUT", "socket", "inner", "outs", "o", "co", "bin", "sync", "client", "source", "cache", "up", "inc", "parent", "file", "page", "log", "null", "init", "conn", "again", "exec", "Out", "writer", "io", "image", "to", "url", "app", "ext", "can", "err", "os", "cli"], "is": ["bis", "sin", "i", "iss", "lis", "id", "fs", "IS", "isa", "Is", "as", "ri", "ins", "bs", "s", "does", "ois", "ui", "isl", "its", "ais", "ir", "ip", "has", "or", "ai", "vs", "ris", "ci", "isin", "iris", "ios", "us", "ib", "url", "isi", "are", "os", "ps", "was", "im", "api"], "buffer": ["info", "base", "address", "Buffer", "border", "uffer", "feed", "server", "uri", "sequence", "slice", "slave", "limit", "length", "bin", "memory", "queue", "offset", "iter", "reader", "cache", "source", "binary", "seed", "buff", "delay", "buf", "counter", "data", "channel", "page", "size", "null", "layer", "bytes", "url", "reference", "repeat", "count", "padding", "transfer", "batch", "phrase"], "amountRead": ["amountReader", "weightBuild", "amountLoad", "lengthLoad", " numberWrite", "enoughRead", "enoughStart", "AmountWrite", "weightLoad", "AmountRead", "poolReader", " amountBuild", "numberLoad", "amountHandle", "lengthRead", "numberReader", "numberWrite", "AmountLoad", "poolWrite", "AmountBuild", " amountStart", " numberLoad", " numberHandle", "amountStart", " numberRead", "lengthHandle", " amountWrite", "lengthWrite", "enoughReader", " amountLoad", "weightRead", "weightReader", "poolLoad", "AmountReader", "enoughWrite", "numberRead", "poolRead", "amountBuild", "amountWrite", " amountReader", "AmountHandle", "AmountStart"]}}
{"id1": "6190356", "id2": "9099457", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    public static String hash(String value) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            byte[] md5hash = new byte[32];\n            md.update(value.getBytes(\"iso-8859-1\"), 0, value.length());\n            md5hash = md.digest();\n            return Hex.encodeHexString(md5hash);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForNewMD3", " hashPasswordForNewMD5", " hashPasswordForNewM3", " hashPasswordForOldMC3", " hashPasswordForOldMD512", " hashPasswordForNewM512", " hashPasswordForNewM4", " hashPasswordForOldmd5", " hashPasswordForNewMD4", " hashPasswordForOldmd4", " hashPasswordForOldmd512", " hashPasswordForOldMC5", " hashPasswordForOldMC512", " hashPasswordForOldM5", " hashPasswordForNewMD512", " hashPasswordForNewM5", " hashPasswordForOldMD3", " hashPasswordForOldMD4", " hashPasswordForOldM3", " hashPasswordForOldMC4", " hashPasswordForOldM512", " hashPasswordForOldM4", " hashPasswordForOldmd3"], "password": ["crypt", "secret", "text", "padding", "pad", "array", "auth", "message", " passwords", "data", "username", "sword", "phrase", "result", "hash", "input", "encrypted", "key", "wd", "wallet", "pass", "code", "seed", "address", "token", "string", "account", "name", "pattern", "words", "path", "word", "content", "buffer", "value", "Password", "p", " Password", "PASS"], "md": ["m", "rm", "hd", " MD", "Cmd", "mp", "cmd", "pg", "mo", "um", "dig", "dd", "km", "gd", "f", "managed", "rpm", "mc", "mag", "d", "vd", "od", "mb", "meta", "hm", "wd", "nm", "amd", "dm", "bd", "metadata", "pd", "MD", "di", "mac", "ind", "mand", "mm", "ma", "dc", "am", "pm", "grad", "mt", "cd", "clean", "vm", "mod", "df"], "messageDigest": ["messageModester", "messagedigests", "messageAddse", "MessageDigEST", "MessageDigest", "messageAddester", "messageAddEST", "messageModEST", "messagedigest", " messageModester", " messageModEST", "messageAddests", "MessageModse", "messageDest", "messagedigester", "MessageAddse", "messageDEST", "messageAddest", "MessageDigse", " messageDigester", "messageModest", "MessageModester", " messageModest", "messageModse", "MessageModest", " messageDigEST", "messagedigEST", "messageDigse", "MessageAddester", "MessageAddest", "messagedigse", "messageDigests", "MessageDigester", "messageModests", "messageDigEST", "MessageAddEST", "messageDester", "MessageModEST", " messageDigests", "messageDse", "messageDigester", " messageModests"], "hexString": ["stringSection", "stringService", "crossstring", "stringString", " hexstring", " hexFunction", "crossFunction", "sumstring", "octBuffer", "hexBuffer", "transformStr", " hexFile", "transformString", "tempFile", "hexstring", "hexService", "stringArray", " hexStr", "transformBuffer", "tempString", "hexArray", "hexStr", "hashString", "hashSection", "transformArray", " hexArray", "hashService", "crossStr", "tempStr", "sumString", "sumFile", "tempstring", "octStr", "octString", " hexService", " hexSection", "hexFunction", "octArray", "hexSection", "tempFunction", "hexFile", "hashArray", " hexBuffer", "crossString", "sumStr"], "i": ["k", "m", "p", "u", "uri", "e", "j", "length", "b", "n", "fi", "io", "info", "si", "f", "o", "index", "d", "ci", "h", "oi", "s", "ji", "multi", "li", "a", "l", "di", "ip", "pi", "xi", "slice", "r", "id", "ti", "v", "c", "t", "ix", "I", "ai", "phi", "ii", "ui", "x", "bi", "qi", "ri"], "hex": ["text", "ex", "he", "pack", "default", "hack", "length", "null", "cmp", "letter", "form", "pixel", "none", "rh", "data", "nexus", "bit", "hello", "raw", "cookie", "result", "hash", "str", "exp", "digit", "batch", "shift", "utf", "h", "temp", "pex", "buff", "ip", "oct", "lit", "transform", "cache", "sex", "string", "character", " Hex", "alpha", "binary", "host", "full", "pattern", "json", "path", "comp", "zero", "orig", "serial", "rex", "format", "http", "char"]}}
{"id1": "7425022", "id2": "11334468", "code1": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"transferWSDL": ["transferWDDL", "transferWSDl", "transferWsdl", "transferWsdL", "transferWsdLS", "transferSWsdDL", "transferWSDLS", "transferWNDLS", "transferWDDLS", "transferWDDl", "transferWDDDL", "transferWSDDL", "transferSWsdL", "transferWNDDL", "transferSWSDLS", "transferWNDL", "transferSWsdLS", "transferWNDl", "transferSWsdl", "transferWsdDL", "transferSWSDL", "transferSWSDDL", "transferSWSDl"], "wsdlURL": ["wllPath", "wsdlPath", "wsdnPath", "wsdnFILE", "wsllPath", "wssdUrl", "wssdFILE", "wdlPath", "wslURL", "wsdlURI", "wdlUrl", "wsdlFILE", "wslUrl", "wsdnURL", "wslPath", "wsllURL", "wsdalURI", "wdlFILE", "wsdlUrl", "wsslURI", "wdlURL", "wsslUrl", "wsllUrl", "wslURI", "wllURL", "wsllFILE", "wssdPath", "wsllURI", "wllFILE", "wsdnUrl", "wsslURL", "wssdURL", "wsdalUrl", "wdlURI", "wllUrl", "wsslPath", "wsdalURL", "wsdalPath"], "userPassword": ["userPass", " userAuth", " userData", "userName", " userPass", "usePassword", "UserPass", "usepassword", " userpassword", "UserData", "userAuth", "usePass", "userData", "UserName", "userpassword", "UserAuth", "userWord", "useData", " userWord", "USERPassword", "Userpassword", "UserPassword", "USERWord", "USERpassword", "UserWord", "useAuth", " userName", "USERName"], "filePath": ["filepath", "transferStr", "fileLocation", "FileStr", "Filepath", " fileStr", "FilePath", "transferPath", "transferpath", " fileLocation", "fileStr", "FileLocation", " filepath", "transferLocation"], "endpoint": ["Endpoints", "adpoint", "Endwall", "adpoints", "endwall", "EndPoint", " endwall", "adwall", " endpoints", "Endpoint", "endpoints", " endPoint", "endPoint", "adPoint"], "conn": ["dc", "ch", "pc", "cm", "n", "c", "Connection", "g", "pg", "ca", "act", "col", "ob", "oa", "inner", "Conn", "ann", "oss", "conv", "ci", "dn", "ctx", "con", "open", "co", "sync", "Connect", "cf", "ct", "auth", "client", "ac", "impl", "sql", "fn", "loc", "p", "adj", "connection", "w", "init", "part", "cn", "rc", "cp", "dh", "exec", "coll", "url", "reg", "ws", "enc", "cli", "ns", "Con", "pub", "h", "close", "cb", "socket", "ssl", "nt", "mc", "comm", "en", "conf", "nc", "ec", "connect", "org"], "is": ["ib", "hi", "serv", "im", "ois", "isl", "est", "rest", "irc", "has", " IS", "sc", "IS", "sr", "ism", "p", "fs", "s", "out", "iss", "iet", "isi", "lis", "ai", "es", "or", "js", "ios", "was", "io", "ais", "ar", "x", "isc", "ps", "iv", "stream", "rx", "ris", "ss", "il", "us", "act", "ir", "os", "ins", "ie", "Is", "ops", "its", "ws", "index", "any", "h", "res", "r", "src", "mes", "rss", "isp", "si", "ip", "as", "in", "ri", "oc", "it", "ipp", "iso", "sec", "i", "bis", "mis", "info", "rs"], "isr": ["isp", "ISr", "isl", "ssp", " isp", " isl", "isrb", "iscp", "ISp", "isw", "iscrb", "issrb", "ISw", "ssrb", "iscrs", "issl", "isrs", "issrs", "ssrs", "iscr", "issr", "issp", " isw", "ISl", "issw", "ssr"], "sw": ["rss", "wrap", "hi", "wh", "wt", "war", "sh", "so", "im", "nw", "wo", "pg", "sm", "sf", "xml", "iw", "tw", "wx", "was", "response", "sc", "wa", "Sw", "ew", "ww", "wp", "cr", "w", "rew", "aw", "x", "wra", "ws", "sl", "SW", "eng", "hw", "rw", "su", "sem", "sb", "wr", "sv", "r", "rx", "wl", "hop", "stream", "wb", "ow"], "buf": ["brace", "bh", "vec", "cas", "shift", "str", "cv", "bin", "func", "bd", "feed", "text", "box", "char", "la", "pad", "seq", "batch", "br", "cr", "bag", "ff", "ha", "err", "base", "rc", "cur", "bc", "Buffer", "pool", "block", "len", "uf", "uc", "bytes", "cb", "bb", "data", "raw", "b", "fb", "buff", "prop", "rx", "buffer", "wb", "rb"], "read": ["reads", "pass", "run", "use", "send", "n", "k", " write", "g", "reading", "select", "sleep", "old", "input", "READ", "copy", "log", "open", "feed", "add", "sync", "need", "skip", "in", "num", "length", "boot", "child", "count", "play", "Read", "default", "w", "find", "get", "load", "work", "wait", "size", "max", "f", "index", "iter", "i", "ok", "check", "start", "ride", "connect", "se", "reader", "parse", "write", "raw", "data", "r", "en", "buffer", "stream", "text", "block", "end"], "outputDir": ["outFolder", "outDirectory", "inputFile", "inputDirectory", "outputFile", "outDir", "OutputFile", " outputFolder", "OutputFolder", "outputPath", "OutputDir", " outputDirectory", "outputFolder", "OutputDirectory", "inputFolder", "outputDirectory", " outputPath", "inputDir", " outputFile", "OutputPath", "tmpDir", "tmpDirectory", "outFile", "tmpPath", "tmpFolder"], "file": ["File", "resource", "folder", "local", "line", "function", "full", "zip", "le", "log", "path", "feed", "files", "object", "content", "dir", "letter", "handler", "build", "unit", "store", "up", "base", "out", "future", "url", "work", "f", "FILE", "filename", "writer", "fp", "output", "directory", "data", "b", "message", "info", "buffer", "stream", "ile", "lock", "parent", "name", "db"], "fos": ["FOs", " fOS", "infos", "faos", "infOs", "f\n", "t\n", " f\n", "fOS", "infOS", "infaos", "F\n", "Fos", " faos", "FOS", "Faos", "fOs", " fOs"]}}
{"id1": "15797402", "id2": "19322946", "code1": "    public void parse(InputStream stream, ContentHandler handler, Metadata metadata, ParseContext context) throws IOException, SAXException, TikaException {\n        String name = metadata.get(Metadata.RESOURCE_NAME_KEY);\n        if (name != null && wanted.containsKey(name)) {\n            FileOutputStream out = new FileOutputStream(wanted.get(name));\n            IOUtils.copy(stream, out);\n            out.close();\n        } else {\n            if (downstreamParser != null) {\n                downstreamParser.parse(stream, handler, metadata, context);\n            }\n        }\n    }\n", "code2": "    @Test\n    public void test_lookupType_FullSearch_MatchingWordInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupType/cluster\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":29055,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":29056,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29065,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":29066,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29069,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":29070,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":29095,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":29096,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":21013,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Capital Sensor Cluster\\\",\\\"icon\\\":\\\"54_03\\\"},{\\\"itemTypeID\\\":21014,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Capital Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":32241,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Drive Cluster EDF-285\\\",\\\"icon\\\":\\\"24_11\\\"},{\\\"itemTypeID\\\":5279,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"F-23 Reciprocal Sensor Cluster Link\\\",\\\"icon\\\":\\\"03_09\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11534,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"37_05\\\"},{\\\"itemTypeID\\\":17340,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Gravimetric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11536,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"37_07\\\"},{\\\"itemTypeID\\\":17333,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Ladar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":11535,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"37_06\\\"},{\\\"itemTypeID\\\":17345,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Magnetometric Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6218,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6222,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected LADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6226,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6230,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected Multi-Frequency Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":6234,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Protected RADAR Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":1},{\\\"itemTypeID\\\":7895,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Gravimetric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7893,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Ladar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7914,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Magnetometric Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7896,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Omni Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":7892,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Prototype ECCM I Radar Sensor Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":11537,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Radar Sensor Cluster\\\",\\\"icon\\\":\\\"37_08\\\"},{\\\"itemTypeID\\\":17336,\\\"itemCategoryID\\\":9,\\\"name\\\":\\\"Radar Sensor Cluster Blueprint\\\",\\\"icon\\\":\\\"03_02\\\"},{\\\"itemTypeID\\\":6242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Gravimetric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6241,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed LADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Magnetometric Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6239,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed Multi-Frequency Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":6225,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Sealed RADAR Backup Cluster\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":0},{\\\"itemTypeID\\\":20238,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20244,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20250,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20260,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Secure Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":2},{\\\"itemTypeID\\\":20240,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20246,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20252,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":20262,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Shielded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":3},{\\\"itemTypeID\\\":21722,\\\"itemCategoryID\\\":17,\\\"name\\\":\\\"Sleeper Nanite Cluster\\\",\\\"icon\\\":\\\"55_15\\\"},{\\\"itemTypeID\\\":20242,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Gravimetric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20248,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Ladar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20254,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Magnetometric Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4},{\\\"itemTypeID\\\":20264,\\\"itemCategoryID\\\":7,\\\"name\\\":\\\"Warded Radar Backup Cluster I\\\",\\\"icon\\\":\\\"04_10\\\",\\\"metaLevel\\\":4}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"parse": [" transform", "wrap", "processing", "pc", "scan", " rewrite", "request", "view", "xml", "http", "cover", "service", "transform", "report", "patch", "process", " split", "print", " parsing", "rate", "replace", " parser", "fork", "Parser", " serve", "load", "read", "php", " analyse", "arse", "set", "worker", "split", " dispatch", "handle", "apply", "se", " convert", "save", "raw", " process", "pack", "parser"], "stream": ["resource", "temp", "draw", "channel", "view", "http", "inner", "src", "input", "response", "down", "feed", "in", "download", "content", "iterator", "sample", "video", "document", "Stream", "upload", "server", "url", "load", "loader", "read", "image", "through", "writer", "handle", "remote", "reader", "data", "raw", "stack", "message", "source", "client", "form", "file"], "handler": ["application", "function", "channel", "host", "pointer", "phase", "service", "response", "layer", "manager", "ctx", "di", "driver", "hand", "Handler", "default", "connection", "base", "event", "server", "loader", "processor", "controller", "wrapper", "writer", "format", "handle", "h", "reader", "data", "handled", "parser", "info", "parent", "client", "collection", "monitor"], "metadata": ["property", "resource", "attribute", "subject", "map", "management", "mx", "m", "xml", "state", "manager", "ctx", "params", "di", "meta", "database", "json", "properties", "content", "header", "runtime", "document", "metry", "connection", "storage", "component", "config", "processor", "adata", "material", "directory", "managed", "data", "mi", "mon", "md", "module", "plugin", "parser", "message", "info", "mt", "uri", "source", "collection", "met", "monitor", "template"], "context": ["resource", "txt", "entry", " Context", "subject", "cmp", "instance", "Context", "environment", "method", "request", "xml", "proxy", "scope", "concept", "manager", "ctx", "content", " contexts", "object", "translation", "command", "document", "mc", "connection", "element", "event", "component", "system", "config", "processor", "tx", "reader", "data", "kernel", "message", "parent", "text", "collection"], "name": ["Name", "names", "resource", "action", "large", "route", "class", "full", "n", "string", "m", "word", "call", "version", "comment", "named", "old", "time", "path", "label", "search", "api", "key", "none", "sync", "in", "active", "on", "no", "object", "address", "child", "missing", "default", "part", "base", "connection", "prefix", "model", "url", "work", "size", "code", "filename", "image", "ame", "NAME", "type", "data", "null", "id", "message", "job", "source", "alias", "file", "common"], "out": ["resource", "temp", "window", "line", "again", "instance", "channel", "o", "ex", "ray", "exp", "bin", "Out", "copy", "path", "manager", "io", "outs", "sync", "in", "object", "conn", "child", "user", "err", "connection", "server", "url", "cos", "pool", "image", "lib", "socket", "writer", "plain", "result", "page", "ext", "output", "data", "obj", "OUT", "null", "flush", "source", "client", "builder", "file", "extra"]}}
{"id1": "14865947", "id2": "13565787", "code1": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static String encryptPassword(String plainPassword) {\n        StringBuffer sb = new StringBuffer();\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(plainPassword.getBytes());\n            byte[] digestBytes = messageDigest.digest();\n            String hex = null;\n            for (int i = 0; i < digestBytes.length; i++) {\n                hex = Integer.toHexString(0xFF & digestBytes[i]);\n                if (hex.length() < 2) sb.append(\"0\");\n                sb.append(hex);\n            }\n        } catch (Exception ex) {\n            System.out.println(ex.getMessage());\n        }\n        return new String(sb);\n    }\n", "label": 1, "substitutes": {"execute": ["exec", "complete", "test", "send", "call", "transfer", "invoke", "load", "command", "start", "action", "launch", "task", "message", "evaluate", "Submit", "ute", "submit", "process", "create", "loop", "open", "exit", "run", " executing"], "event": ["exec", "test", "v", "exc", "Event", "x", "ents", "te", "context", "ext", "image", "ec", "t", "ent", "g", "ex", "object", " EVENT", "vent", "message", "events", "other", " events", "ev", " Event", "ctx", "f"], "shell": ["exec", "sole", "sol", "cl", " Shell", "Shell", "console", "system", "lex", "window", "el", "site", "child", "model", "tools", "cel", "xml", "log", "nl", "environment", "sl", "session", "sql", "ui", "prof", "cmd", "lock", "bot", "lib", "build", "sb", "live", "bash", "null", "kernel", "ll", "gui", "o", "edit", "layout", "sync", "il", "mail", "search", "math", "cli", "l", "sh", "pool", "tty", "server", "help", "pty", "loop", "ml", "home", "dll", "hell", "tool", "cell"], "view": ["flow", "v", " overview", "url", "console", "window", "visual", "model", "container", "VIEW", "plugin", "row", "session", "screen", "ui", "View", "image", "lock", "widget", "sel", " layout", "show", "user", "object", "gui", "list", "layout", " preview", "tree", "display", "service", "views", "version", "iew", "page", "review", "l", "pool", "control", "summary", "web", "book", "f"], "rootFolder": ["rootDirectory", "mainOrg", " rootWindow", "shellWindow", "homeFolder", "parentDirectory", "RootOrg", "mainfolder", "homeCenter", "shellArea", "bottomFolder", "rootOrg", " rootDirectory", "rootCenter", "parentFlow", "rootWindow", " rootArea", "RootDirectory", "RootWindow", "rootFlow", "mainFile", "parentFile", "parentZip", "rootZip", "parentFolder", "RootFolder", " rootZip", "shellFolder", "bottomFlow", "RootZip", "rootArea", " rootfolder", "bottomDirectory", "RootArea", "rootDir", " rootFlow", "RootFile", "rootfolder", "shellDir", "bottomFile", "rootFile", "RootDir", " rootFile", " rootCenter", "mainFolder", " rootDir", "RootCenter", "homeDirectory", " rootOrg", "Rootfolder"], "dialog": ["logogg", "clogg", "protog", "dialogs", "dialogging", "challogue", "logogue", "challect", "diffogue", "logogs", "logog", "challogg", "clog", "challock", "clect", "protect", "diffog", "clogs", "dialect", "challog", "logOG", "dialDialog", "challDialog", "challogs", "clOG", "logDialog", "clogging", "logock", "protogging", "protogg", "challogging", "dialock", "dialOG", "challOG", "dialogue", "diffock", "dialogg", "diffDialog"], "password": ["picture", "hash", "encrypted", "address", "params", "account", "column", "token", "Password", "description", "sword", "command", "volume", "path", "wallet", "session", "patch", "pattern", "string", "language", "name", "cmd", "word", "prefix", "database", "auth", "words", "username", "mode", "crypt", "connection", "confirmed", "definition", "root", "text", "directory", "handler", "config", "diff", "pad", "padding", "message", "resource", "p", "wd", "key", "content", "pg", "phrase", "page", "mac", "data", "channel", "source", "PASS", "secret", "email", "device", "pass", "value", "sum", "size"], "md5": ["mand2", "dd5", "mg5", "MD50", "MD40", "MD512", "dd2", "dd50", "mg40", " mddown", "mddown", "mand5", "md512", "cmd4", "MD4", "MD2", "mg2", "md40", "mand512", " md512", "md2", "MDdown", "mand15", "MD15", " md2", "cmd5", "dd40", "cmd512", "mg50", "md15", "manddown", " md4", "md4", "MD5", "cmd2", "md50", " md15"], "md": ["MD", "hash", " Md", "mc", "sha", "dig", "ms", "metadata", "pm", "bd", "amd", "df", "mo", "meta", " cmd", "mb", "cmd", "M", "pkg", "sm", "mand", "m", "dd", "mode", "html", " dd", " mm", " digest", "sd", "od", "mg", " sd", "mm", "ma", "ad", "pd", " ma", "cd", "kg", "wd", "nd", "mac", "mod", "d", "mag", "nm", "bf", "dm", "sum", " MD", "mp", "msg"]}}
{"id1": "4056444", "id2": "720361", "code1": "        public final String hashPassword(String password) {\n            try {\n                MessageDigest md = MessageDigest.getInstance(\"SHA\");\n                md.update(password.getBytes());\n                byte[] hash = md.digest();\n                return \"{SHA}\" + byteToString(hash, 60);\n            } catch (NoSuchAlgorithmException nsae) {\n                log.error(\"Error getting password hash - \" + nsae.getMessage());\n                return null;\n            }\n        }\n", "code2": "    public static void main(String[] args) throws Exception {\n        int result = 20;\n        if (args.length == 1) {\n            StringBuffer urlString = new StringBuffer(args[0]);\n            if (urlString.lastIndexOf(\"/\") != urlString.length() - 1) {\n                urlString.append('/');\n            }\n            urlString.append(\"GetConfig.jsp\");\n            URLConnection conn = new URL(urlString.toString()).openConnection();\n            System.out.println(Configuration.readObject(conn.getInputStream()));\n            result = 0;\n        } else {\n            System.err.println(\"usage: GetConfig <URL>\");\n        }\n        System.exit(result);\n    }\n", "label": 0, "substitutes": {"hashPassword": ["updateSecret", "updateWord", " hashpassword", "hashWord", "printPassword", " hashWord", "updatepassword", "hashSecret", "hashpassword", " hashSecret", "printWord", "updatePassword", "printpassword", "printSecret"], "password": ["p", "text", "secret", " passwords", "message", "account", "create", "words", "cache", "token", "out", "path", "username", "wd", "param", "pass", "phrase", "word", "input", "padding", "data", "auth", "PASS", "email", "database", "name", "sword", "null", "SHA", "security", "code", "pool", "random", "address", "sha", "string", "crypt", "prefix", "confirmed", "Password", "attribute", "login", "user", " Password"], "md": ["mand", "hm", "mm", "mp", "mod", "amd", "f", "wd", "dig", "cmd", "dm", "mb", "mg", "m", "metadata", "mad", "ad", "mac", "bf", "grad", "rm", "sm", "nd", "sha", "pd", " MD", "od", "di", "dd", "mo", "mt", "hd", "sum", "am", "MD", "dh", "mc", "ma", "rod", "mag", "pm", "d", "bd"], "hash": ["dot", "match", "secret", "style", "hed", "ho", "cache", "length", "check", "username", "ash", "dig", "pass", "dump", "image", "build", "kh", "data", "format", "mac", "shadow", "url", "log", "array", "search", "Hash", "SHA", "code", "number", "sha", "hex", "address", "body", "h", "header", "string", "sum", "sh", "full", "block", "ha", "html", "value", "version", "file", "key", " hashing", "her", "id", "user", "rh", "db"]}}
{"id1": "18782385", "id2": "14450108", "code1": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"saveFile": [" saveFiles", "saveDirectory", " saveImage", "uploadFiles", " saveDirectory", "saveImage", "uploadDirectory", "writeFile", "writeImage", "writeDirectory", "uploadImage", "writeFiles", "uploadFile", "saveFiles"], "window": [" wid", "video", "stage", "image", "flow", " Window", "parent", " host", "gallery", "target", " world", " office", "box", "space", "wa", "w", "draw", "GUI", " video", "visual", "volume", "win", "angular", "client", "widget", "console", "layout", "view", "scope", "input", "dom", "home", "band", "media", "audio", "screen", "scroll", "file", " GUI", "youtube", "feature", "motion", "microsoft", "wx", "command", "event", "button", " widget", "host", "directory", "Window", "time", " wizard", "show", " canvas", "manager", "hw", "doc", "driver", "frame", "remote", "layer", "device", "buffer", "office", "server", "ui", "game", "gui", "img", " container", "session", "system", "document", "browser", "style", "project", "menu", " dialog", "wall", "machine"], "stream": [" resource", "os", " OUT", "output", " webpage", " upload", " temp", " buffer", "io", " w", "out", "file", " bout", " console", " webcam", "f", " this", " prog", "w", " streams", "document", " video", "Stream", " app", " form", "OU"], "outputDoc": [" outputDiv", " outputDocument", "outputFile", "inputDoc", "updateDocument", "targetDocument", "externalDoc", "updateDir", "outputDir", "outputDocument", "OutputDiv", "targetDoc", "externalDocument", "updateDoc", "updateDiv", "OutputDir", "externalFile", "OutputFile", " outputFile", "inputDocument", " outputDir", "inputFile", "externalDiv", "inputDir", "OutputDocument", "targetFile", "outputDiv", "OutputDoc", "targetDiv"], "dtd": ["dTD", "fdTD", "fdtd", "std", " dTD", "sTD", "ddd", "Ddt", " ddt", "sdt", "Ddl", "fddl", "ddl", " ddd", "Dtd", "slt", "DTD", "Dlt", "Ddd", "ddt", "dlt", "fddd", " ddl", " dlt"], "uiElement": ["uiEmail", "uelement", "urielement", "uiDocument", "UIObject", "luEntity", " UIEl", "uielement", "guiE", "uiE", "ouEl", "utilEl", "uriE", "suElement", "unielement", "UIEle", "clielement", "apiEl", "UIDoc", "UIEntry", "uEl", "ioModule", "UISource", "utilDoc", "uiEntry", "uriEl", "apiEntity", "suEntity", "uriEmail", "ioDoc", "cliSource", "ouElement", "volumeEntry", "cliEl", "guiMember", "ioEl", "uniE", "uniEl", "uniMember", "guiDoc", "UIMember", "uiEditor", "guiModule", "ouEle", "guielement", "luEngine", "luEmail", "UIEl", "guiEntity", "guiElement", " UIElement", "UIModule", "UIEditor", "uriElement", "apiElement", "uriEntity", "apiE", "uniEntity", "UIDocument", "uSource", "uiDoc", "uiModule", "ioElement", "luElement", "uiEle", "uElement", "uiMember", "uriEntry", "uiEntity", "volumeDocument", "UIelement", "uriDocument", "cliElement", "UIElement", "UIE", "uiEngine", "uniElement", "uiObject", "uiSource", "volumeObject", "guiEl", "uriEngine", " UIEditor", "ouEditor", "cliEntry", " UIEle", "uiEl", "suEmail", "utilElement", "uriObject", "suEngine"], "currentLFClassName": ["currentLFClassname", "currentLFFileDesc", "currentLDFFileDesc", "currentLFclassAlias", "currentLELFCLASSName", "currentLFClassDesc", "currentLFclassPath", "currentLFCLASSDesc", "currentLFFunctionDesc", "currentLDFFileString", "currentLFclassname", "currentLDFClassDesc", "currentLFFileString", "currentLFClassPath", "currentLFclassName", "currentLFclassDesc", "currentLFclassString", "currentLDFFilename", "currentLELFCLASSDesc", "currentLFClassAlias", "currentLFClassString", "currentLDFClassString", "currentLELFCLASSPath", "currentLFFileName", "currentLDFClassName", "currentLFFilename", "currentLFFunctionName", "currentLFCLASSPath", "currentLFCLASSAlias", "currentLELFClassAlias", "currentLELFClassPath", "currentLFCLASSName", "currentLDFClassname", "currentLELFClassDesc", "currentLFFunctionPath", "currentLFFunctionAlias", "currentLDFFileName", "currentLELFCLASSAlias", "currentLELFClassName"], "systemLFClassName": ["systemLFFullName", "systemLfClassString", "systemLfClassName", "systemLFClassname", "systemLFclassString", "systemLFPackageString", "systemLFClassCode", "systemLfPackageDesc", "systemLfPackageString", "systemLFClassString", "systemLFPackagename", "systemLfPackageName", "systemLfClassDesc", "systemLFclassDesc", "systemLFPackageDesc", "systemLFClassDesc", "systemLfPackagename", "systemLFFullDesc", "systemLFPackageCode", "systemLfClassname", "systemLFPackageName", "systemLFFullString", "systemLFclassName", "systemLfPackageCode", "systemLfClassCode"], "mainWindowElement": ["mainWindowelement", "MainFrameEl", "mainQueueEl", "mainWindowsE", "mainWindowPage", "currentFramePage", "mainHostE", "mainTimeElement", "mainTimeEl", "mainWindowsEl", "mainFrameEnvironment", "mainWindowAddress", "mainFrameE", "centralWindowEl", "mainWheelEl", "mainMenuElement", "currentWindowEl", " mainWebObject", "centralFrameEl", "mainWindowEnvironment", "MainWindowEl", "currentWindowPage", "mainWheelMember", "mainWebE", "mainWebEl", " mainHostAddress", "mainWindowEl", "mainWindowsFrame", "mainStreamEl", "currentWindowElement", "mainStreamContainer", "mainFrameElement", "mainWheelElement", " mainWindowEl", "mainFlowEnvironment", "MainWindowElement", "mainTimeelement", " mainWebEnvironment", " mainWindowBuilder", "mainFlowEngine", "mainWindowObject", " mainWebEngine", "mainWindowE", "mainWindowBuilder", "mainFlowE", "mainFlowBuilder", "currentWindowContainer", " mainWheelMember", " mainWindowEngine", "mainWindowFrame", "MainFrameFrame", " mainHostE", "mainStreamElement", " mainWheelElement", "mainFlowAddress", "mainWebElement", "mainMenuContainer", "mainMenuPage", "mainFlowObject", "mainWindowsElement", "currentFrameContainer", "centralFrameelement", "mainWebBuilder", "mainFrameEl", " mainHostElement", "mainWebMember", "mainQueueFrame", "mainWebEngine", "mainScreenEl", "mainScreenelement", "centralFrameElement", "mainFrameMember", " mainWheelEl", "mainGroupEnvironment", "mainFramePage", "MainFrameElement", "mainFrameFrame", "mainWebAddress", "mainFrameContainer", "mainFlowElement", " mainWindowMember", " mainWindowObject", "mainWindowEngine", "centralWindowelement", "mainWindowContainer", "mainScreenElement", "MainFrameE", " mainWindowEnvironment", "mainStreamPage", "mainFrameelement", " mainWheelEnvironment", " mainWindowE", " mainWebElement", "mainWheelEnvironment", " mainWindowAddress", "MainWindowE", "mainQueueElement", "centralWindowElement", "mainGroupObject", "mainQueueE", "currentFrameEl", "mainWebObject", " mainHostBuilder", "mainWindowMember", "MainWindowFrame", "mainMenuEl", "mainHostAddress", "mainGroupEngine", "mainHostElement", "mainGroupElement", "mainHostBuilder", "mainWebEnvironment", "currentFrameElement"], "volumeElement": [" volumeEl", "VolumeContainer", "audioEntry", "VolumeEl", "soundElement", "VolumeElement", " volumeEngine", "volumeContainer", "VolumeEntry", "volumePart", "audioEl", " volumelement", "voiceContainer", "voiceEntry", "audioPart", " volumeEntry", "soundPart", "soundlement", " volumeLayer", "voiceLayer", "audioEngine", "voiceElement", "voiceEngine", "volumeLayer", " volumePart", "soundEl", "audioElement", "voiceEl", "audiolement", "volumelement", "audioLayer", " volumeContainer", "volumeEntry", "volumeEngine", "volumeEl"], "player": ["video", "position", "db", "aster", "caster", "profile", "apper", "players", "transfer", "par", "app", "roller", "plays", "ader", "ayer", "e", "monitor", "handler", "per", "ler", "ater", "playing", "game", "Player", "audio", "file", "part", "min", "active", "ower", "loader", "er", "live", "mor", "driver", "Play", "ser", "watch", "act", "play", " Player", "layer", "able"]}}
{"id1": "15737836", "id2": "8046691", "code1": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "code2": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"delete": ["de", "create", "del", "write", "process", "sync", "replace", "update", "clear", "sql", " Delete", "drop", "remove", "destroy", "where", "close", "execute", "id", " destroy", "Delete", "connect", " update", "get", " create", "select", "exec", "release", "save"], "site": ["image", "model", "unit", "base", "isite", "module", "section", "course", "sample", "project", "domain", "install", "target", "profile", "license", "cache", "sync", "remote", "environment", "conn", "space", "object", "page", "null", "set", "sql", "class", "status", "session", "item", "node", "note", "source", "type", "line", "result", "si", "se", "network", "blog", "sit", "xml", "ite", "edge", "Site", "name", "zone", "server", "data", "sites", " Site", "theme", "database", "config", "location", "db", "plugin"], "dbo": ["dho", "idebo", "jBo", "jba", " dBo", "fbo", " dBO", "dbi", "gBO", " dbi", "fBo", "gbo", "ideho", "Dbo", "drbi", "dbos", "drbc", "jBO", "drBo", " dbc", "idbl", "fBO", "dBO", "rdbi", "dbl", "pBO", "pba", "DBO", "gbos", " dba", "pBo", "idebl", "Dbos", "rdbc", "Dho", "Dbl", "dBo", "dbc", "ideBo", "rdBo", "fba", "idBo", " dbos", "jbo", "dba", "idbo", "Dba", "idho", "pbo", "drbo", "DBo", "rdbo", "gBo"], "connection": ["image", "unit", "index", "pool", "graph", "resource", "log", "section", "ion", "directory", "function", "channel", "Connection", "cache", "use", "table", "environment", "conn", "ongo", "connected", "management", "application", "builder", "driver", "c", "sql", "position", "condition", "engine", "session", "creator", "collection", "relation", "subject", "query", "node", "handler", "ci", "translation", "result", "io", "container", "response", "client", "character", "context", "manager", "statement", "communication", "con", "loc", "union", "server", "component", "document", "reference", "connect", "instance", "lock", "database", "bc", "ctx", "config", "db", "machine", "library"], "preparedStatement": ["prefixedHeader", "PreparedTransaction", "proparableStat", "prehedScope", "PreparedDocument", "previsedComment", "prepperConnection", "prequalifiedStat", "preciseStat", "eculatedstatement", "proparableStatement", "preppedTransaction", "PrearedService", "preppedComment", "preutedHeader", "preferredString", "partvisedStatement", "proparedStat", "preachedString", "preparableStat", "preformedTransaction", "preparedComment", "preparedInstance", "prefixedComment", "preculatedStatement", "preplacedQuery", "preformedString", "prearedScope", "eculatedTransaction", "preferredComment", "preplacedStat", "prefixedStatement", "preppedQuery", "preppedConnection", "PreparedParent", "prearedString", "psefixedScope", "prepperTransaction", "psefixedStatement", "pseparedComment", "preparedParent", "preparedHeader", "eparedStatement", "preamedString", "eparedConfiguration", "PreparedStatement", "preparableInstance", "preparedDatabase", "preciseStatement", "prequalifiedstatement", "partvisedQuery", "prelyingstatement", "preppedDocument", "prepperDocument", "preparedConnection", "caparedTransaction", "preamedStatement", "preparedOperation", "preparedDocument", "previousComment", "preparedConfiguration", "prefixedOperation", "partparedComment", "PreppedConnection", "eparedTransaction", "psefixedQuery", "preplacedComment", "prehedStatement", "pseparedQuery", "prearedService", "eparedstatement", "preachedDatabase", "partvisedComment", "PrearedString", "preferredStatement", "partparedStatement", "preparedTransaction", "prearedComment", "preamedStat", "PrearedStatement", "prehedComment", "preparedstatement", "proparedStatement", "preculatedTransaction", "PreparedDatabase", "PrearedQuery", "PreppedTransaction", "pseparedScope", "prefixedQuery", "PrearedHeader", "prefixedScope", "PrearedParent", "preciseString", "previsedStatement", "preparedScope", "preferredQuery", "proparedstatement", "PreparedQuery", "partparedQuery", "PreparedOperation", "prearedInstance", "preciseParent", "preplacedStatement", "prearedstatement", "eculatedConfiguration", "calyingTransaction", "preformedService", "preutedQuery", "preformedDatabase", "partparedStat", "preformedStatement", "prehedQuery", "prearedDatabase", "preppedString", "psefixedComment", "prepperStatement", "preppedStatement", "PreparedConnection", "proparableInstance", "prearedStatement", "previousTransaction", "PreparedStat", "prelyingComment", "prearedOperation", "preformedConfiguration", "previousstatement", "PreppedStatement", "prequalifiedStatement", "PrearedDatabase", "preutedStatement", "caparedStatement", "caparedstatement", "preachedStatement", "preamedParent", "PreparedService", "partvisedStat", "proparedInstance", "previousDocument", "preparedString", "preachedService", "previousConnection", "preparablestatement", "prearedStat", "prearedConfiguration", "preparedService", "PrearedStat", "previousStatement", "eculatedStatement", "prearedQuery", "preparedStat", "preculatedConfiguration", "caparedComment", "PreparedComment", "previsedQuery", "pseparedStatement", "calyingComment", "prelyingTransaction", "proparablestatement", "preparedQuery", "PreparedHeader", "PrearedOperation", "prearedParent", "prelyingStatement", "prearedHeader", "PreppedDocument", "preculatedstatement", "prequalifiedInstance", "preutedOperation", "preparableStatement", "PrearedComment", "previsedStat", "prearedTransaction", "calyingStatement", "calyingstatement", "PreparedString", "preformedstatement"], "resultSet": [" resultList", "ResultSource", " resultLine", "resultSource", " resultSource", "resultsLine", "resultGet", "ResultLine", "rowSet", "responseList", "rowSize", "ResultSize", "responseLine", "resultLine", "resultsSource", "ResultGet", "rowSource", "resultsSet", "responseSource", "ResultList", "rowGet", "ResultSet", "responseSet", " resultSize", "resultList", "resultSize", "resultsList", " resultGet"], "chkSql": ["chkPssql", "chksAsq", "chksAsql", "chksAsQL", "chKSsql", "chkPsq", "chkSQL", "chkPresql", "chkOsq", "chkOsql", "chkOssl", "chKSql", "chkRssql", "chksSql", "chkPresQL", "chkPsql", "chKRsq", "chkAsq", "chkSq", "chkRssl", "chkOsQL", "chkPressql", "chKSq", "chksSsql", "chkSsl", "chkOssql", "chkPssl", "chkRsql", "chKSsl", "chkAsQL", "chKRsql", "chksSQL", "chKRssl", "chkPresq", "chKRssql", "chksAssql", "chkSsql", "chkRsq", "chksSq", "chkAsql", "chkAssql"], "selfDefinePath": ["selfDefinedpath", "selfDefinesKey", "selfDeclinedpath", "selfDefenPath", "selfDefinedName", "selfDefineKey", "selfDefiningPath", "selfDeclineKey", "selfDefinedLocation", "selfDeclinepath", "selfDefinespath", "selfDeclineUrl", "selfDefenName", "selfDefinesPath", "selfDeclinedUrl", "selfDefineLocation", "selfDeclinedKey", "selfDefinesName", "selfDefinedKey", "selfDefiningKey", "selfDefinepath", "selfDefinedUrl", "selfDefenLocation", "selfDefiningUrl", "selfDeclinePath", "selfDefinesUrl", "selfDefineUrl", "selfDefinesLocation", "selfDefinedPath", "selfDefenpath", "selfDefiningpath", "selfDeclinedPath", "selfDefineName"], "sqlStr": [" sqlString", " sqlDec", "sqlString", "sqlDec", "sqlBr", "sqlText", "queryText", "SQLBr", "querystr", "SQLText", "SQLDec", "SQLWr", "sqlWr", "qlString", "SQLstr", "queryDec", "SQLStr", "sqlstr", "qlStr", " sqlText", " sqlWr", "SQLString", " sqlstr", "qlBr", "qlWr", " sqlBr", "queryStr"]}}
{"id1": "20247400", "id2": "12766377", "code1": "    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"arguments: sourcefile destfile\");\n            System.exit(1);\n        }\n        FileChannel in = new FileInputStream(args[0]).getChannel(), out = new FileOutputStream(args[1]).getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(BSIZE);\n        while (in.read(buffer) != -1) {\n            buffer.flip();\n            out.write(buffer);\n            buffer.clear();\n        }\n    }\n", "code2": "    public Document index() throws CrawlingException {\n        log.debug(\"BEGINIG indexing page [code=\" + getCode() + \"] ...\");\n        URL url = null;\n        InputStream in = null;\n        String contentType = null;\n        try {\n            url = new URL(getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath());\n            HttpURLConnection pageContent = (HttpURLConnection) url.openConnection();\n            if (pageContent.getResponseCode() != HttpURLConnection.HTTP_OK) {\n                log.debug(\"page pk[\" + getCode() + \",\" + url.toExternalForm() + \"] is invalid\");\n                return null;\n            }\n            String redireccion = pageContent.getHeaderField(\"location\");\n            if (redireccion != null) {\n                log.debug(\"Page \" + url.toExternalForm() + \" redirected to \" + redireccion);\n                recordLink(redireccion);\n                return null;\n            }\n            contentType = pageContent.getContentType();\n            in = new BufferedInputStream(pageContent.getInputStream(), 32768);\n        } catch (MalformedURLException e) {\n            log.error(\"Invalid page address\", e);\n        } catch (ConnectException e) {\n            if (getServer() != null) {\n                log.error(\"Unable to connect to page: \" + getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath(), e);\n            }\n        } catch (UnknownHostException uhe) {\n            log.warn(\"Unknow host indexing page \" + getURL(), uhe);\n        } catch (IOException e) {\n            log.warn(\"Unable to index page \" + getURL(), e);\n        }\n        Document doc = generateDocument(contentType, in);\n        log.debug(\"END indexing page [code=\" + getCode() + \"]\");\n        return doc;\n    }\n", "label": 0, "substitutes": {"in": ["p", "source", "gin", "inn", "token", "client", "inner", "c", "f", "config", "s", "this", "pass", "i", "input", "l", "socket", "image", "IN", "data", "con", "win", "n", "isin", "a", "din", "b", "nin", "ins", "h", "connection", "stream", "In", "inc", "again", "parent", "part", "r", "login", "diff", "reader", "bin"], "out": ["flow", "source", "group", "call", "style", "cache", "output", "str", "client", "inner", "page", "w", "ex", "i", "word", "console", "dump", "OUT", "image", "line", "socket", "conn", "writer", "sys", "comment", "print", "io", "up", "window", "log", "name", "outer", "server", "ext", "obj", "exec", "msg", "pool", "list", "connection", "exp", "channel", "lock", "prefix", "Out", "write", "again", "off", "file", "temp", "err", "r", "o", "debug", "user", "v", "inc", "error"], "buffer": ["flow", "source", "result", "cache", "output", "length", "bar", "f", "config", "buff", "pad", "buf", "fb", "slave", "input", "uffer", "count", "border", "read", "data", "writer", "loader", "abi", "binary", "limit", "document", "base", "window", "b", "null", "server", "transfer", "Buffer", "header", "channel", "size", "queue", "layer", "batch", "reference", "iter", "pause", "wave", "feed", "slice", "reader", "flush", "bin", "offset", "context"]}}
{"id1": "3558512", "id2": "16232202", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        if (request.getParameter(\"edit\") != null) {\n            try {\n                User cu = (User) request.getSession().getAttribute(\"currentuser\");\n                UserDetails ud = cu.getUserDetails();\n                String returnTo = \"editprofile.jsp\";\n                if (!request.getParameter(\"password\").equals(\"\")) {\n                    String password = request.getParameter(\"password\");\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    md.update(new String(password).getBytes());\n                    byte[] hash = md.digest();\n                    String pass = new BigInteger(1, hash).toString(16);\n                    cu.setClientPassword(pass);\n                }\n                ud.setFirstName(request.getParameter(\"fname\"));\n                ud.setLastName(request.getParameter(\"lname\"));\n                ud.setEmailAddress(request.getParameter(\"email\"));\n                ud.setAddress(request.getParameter(\"address\"));\n                ud.setZipcode(request.getParameter(\"zipcode\"));\n                ud.setTown(request.getParameter(\"town\"));\n                ud.setCountry(request.getParameter(\"country\"));\n                ud.setTrackingColor(request.getParameter(\"input1\"));\n                String vis = request.getParameter(\"visibility\");\n                if (vis.equals(\"self\")) {\n                    cu.setVisibility(0);\n                } else if (vis.equals(\"friends\")) {\n                    cu.setVisibility(1);\n                } else if (vis.equals(\"all\")) {\n                    cu.setVisibility(2);\n                } else {\n                    response.sendRedirect(\"error.jsp?id=8\");\n                }\n                em.getTransaction().begin();\n                em.persist(cu);\n                em.getTransaction().commit();\n                response.sendRedirect(returnTo);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                response.sendRedirect(\"error.jsp?id=5\");\n            }\n            return;\n        }\n    }\n", "label": 0, "substitutes": {"serialize": ["erialize", "serialze", "serializable", " serialization", "Serialize", "finalify", "finalize", "serialization", " serializable", "finalized", "normalized", "erialze", "normalify", "erialization", "Serialized", "serialify", "erializable", " serialze", "serialized", "normalize", "normalze", "Serialze", "Serialization", "finalze", "Serialify", "Serializable"], "out": ["string", "buffer", "loader", "temp", "i", "ex", "output", "copy", "server", "report", "filename", "OUT", "o", "outs", "pool", "bin", "content", "raw", "client", "source", "cache", "up", "w", "data", "file", "archive", "parent", "page", "gen", "conn", "name", "exec", "Out", "io", "writer", "image", "dump", "a", "err", "obj", "png"], "parser": ["pillar", "base", "class", "pkg", "arser", "loader", "handler", "server", "copy", "builder", "master", "lp", "per", "as", "system", "instance", "php", "manager", "txt", "er", "cp", "reader", "cache", "pp", "up", "seed", "upload", "parent", "file", "rar", "p", "plugin", "test", "writer", "ss", "worker", "tt", "pe", "parse", "processor", "wrapper", "xml", "Parser"], "on_disk": ["onbootdrive", "onJdrive", "onJdisk", "onbootlock", "onjdrive", "onbootstorage", "on_demand", "onjdisk", "on_drive", "off_disk", "onnetfile", "off_drive", "onbootdisk", "on_storage", "onbookdelete", "on_lock", "onJdemand", "off_lock", "on_space", "onnetdemand", "onbookdisk", "off_storage", "onJlock", "on_delete", "onnetdisk", "onnetspace", "off_delete", "onbookdrive", "onjfile", "off_demand", "onnetdrive", "onjspace", "off_file", "on_file", "off_space"], "in": ["IN", "info", "pin", "i", "input", "inas", "copy", "ini", "con", "c", "socket", "inner", "as", "o", "ins", "bin", "pass", "reader", "thin", "source", "connection", "min", "login", "r", "inc", "data", "file", "rin", "conn", "again", "ax", "In", "kin", "stream", "lin", "ac", "inn", "f", "win", "din"]}}
{"id1": "3024992", "id2": "8921716", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter2nullIn", "testCopy_readerToWriter2Nulls", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter_writers", "testCopy_readerToWriter_null_", "testCopy_readerToWriter_stdin", "testCopy_readerToWriter_Nulls", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter_writerin", "testCopy_readerToWriter_writer_", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_writerIn", "testCopy_readerToWriter_std_", "testCopy_readerToWriter2null_", "testCopy_readerToWriter2nulls", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter_stdIn", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter_stds", "testCopy_readerToWriter_nulls"], "baout": ["Baash", "aeOUT", "BAin", "bonin", "baouts", "BaOut", "BAout", "BAouter", " bain", "bain", "aeouter", " baOut", "Bain", "baOUT", "baash", "bonash", "Baio", "baio", "BAio", "BaOUT", "BAOut", "Baout", "BAouts", "baouter", "Baouter", "bonout", "bonio", "aeout", " baouts", "baOut", "Baouts", "BAOUT", "aeOut", "BAash"], "out": ["Out", "r", "in", "buffer", "flow", "output", "class", "s", "write", "copy", "Writer", "array", "io", "line", "file", "Output", "null", "err", "er", "test", "reader", "outs", "outer", "OUT", "able"], "writer": ["r", "in", "buffer", "worker", "entry", "output", "class", "write", "copy", "ee", "Writer", "pointer", "writers", "io", "work", "file", "riter", "x", "rw", "letter", "null", "unit", "data", "temp", "wer", "builder", "her", "player", "er", "wa", "w", "driver", "writ", "reader", "outer", "writing", "source", "RW"]}}
{"id1": "804637", "id2": "15768167", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRebwrite", "readAndRebrap", "readAndRewwrite", "readAndSwrap", "readAndrewwrite", "readAndRebrite", "readandRewrap", "readandRewrites", "readAndSwwrite", "readandrewrap", "readAndRewrap", "readAndSwrite", "readandrewrites", "readandrewwrite", "readAndRebrites", "readAndRewrites", "readAndrewrite", "readAndSwrites", "readandrewrite", "readAndrewrites", "readAndrewrap", "readandRewwrite", "readandRewrite"], "inFile": [" inSourceFile", "InSourceFile", "oldfile", "outSourceFile", "inputfile", "outfile", " inFiles", "inputFilename", "InFiles", " infile", "infile", "inputFile", "outFiles", "oldFile", "loginFile", " inFilename", "Infile", "inFiles", "inputFiles", "oldFiles", "loginFilename", "loginfile", "loginFiles", "InFile", "oldFilename", "outFilename", "inFilename", "inSourceFile"], "outFile": ["newfile", "outDir", "OutStream", "processFile", "outputFilename", "exFilename", "outputfile", " outfile", "outPlace", "outFILE", "outputFILE", "outfile", "processFilename", "offFILE", "outputPlace", "thisFilename", "outStream", "thisFile", "processPlace", "exfile", "thisFILE", "newDir", "exFILE", "OutDir", "exFile", "processFILE", "newStream", "offPlace", "OutFile", " outStream", "outFilename", "offFilename", "Outfile", " outDir", "outputFile", "newFile", "thisfile", "offFile"], "iis": ["iIS", "Iais", "iIs", "iiris", "iniIs", "iiiss", "iais", "Iis", "ciis", "iiis", " iIs", " iIS", " iais", "ciiss", "Iiss", "ciais", " iiss", "iiss", "iiIS", "iniiss", " iris", "iniis", "ciris", "iniIS", "iniris", "IIS", "iris", "iiIs", "ciIS", "ciIs"], "dcmParser": ["dbmPolicy", "dbmParser", "dmmLoader", "dmissionParser", "dcmInstallation", "dmoduleJar", "dpmLoader", "dmoduleparser", "dhemReader", "dkmParser", "dmissionLanguage", "dCMPlugin", " dpmparser", " dcrParser", "fpmparser", "dhemJar", " dpmPolicy", "dkmPolicy", "dpmParser", "dcmPolicy", "dmissionPlugin", " dcmarser", "dmmPlugin", " dcrPlugin", "DcmInstallation", " dcmLanguage", "dpmHandler", "dmcJar", "dkmPlugin", " dpmParser", "dmoduleReader", " dcrLoader", "fcmReader", "dmissionReader", "dcrParser", "dmcarser", "dbmHelper", "dmLoader", "fpmHandler", "dcrarser", "dhemInstallation", "dmcParser", "dmmparser", "dpmLanguage", "dmodulePlugin", " dcmPolicy", "dpmarser", "dpmReader", "dcmPar", "dpmPar", "dmReader", "dcmparser", "dcrLoader", "dmParser", " dcmLoader", " dcmReader", "fcmparser", "dpmPolicy", "dcrJar", "dcmPlugin", "dpmparser", "fpmReader", "dcmarser", " dpmPlugin", "dbmPlugin", "dpmPlugin", " dpmHelper", "dCMLoader", " dpmLoader", " dpmJar", "dmoduleParser", " dcrReader", "dcmLoader", "fcmParser", "dpmHelper", "dcmReader", " dpmPar", "dCMHandler", "dmPlugin", "dcmJar", "dcrPlugin", "dpmJar", " dcmJar", "fcmHandler", " dcmHelper", "dCMparser", "dcrPar", "DcmParser", " dcmPar", "dcrReader", "fpmParser", " dpmReader", " dcmparser", "dmcPar", " dpmLanguage", "dcmHelper", "dpmInstallation", "dcmHandler", "dCMParser", "dcmLanguage", "dmmParser", "DcmReader", "dCMReader", "dkmHelper", " dcmPlugin", "DcmJar", "dhemParser", " dpmarser"], "ds": ["services", "ys", "uds", "ays", "DS", "iss", "gd", "sys", "Os", "df", "ants", "ns", "tes", "ks", "drivers", "qs", "bs", "s", "ins", "dr", "is", "dc", "rs", "ld", "dt", "parts", "cdn", "sync", "session", "ws", "d", "ros", "eps", "points", "icks", "ads", "data", "gs", "src", "xs", "utils", "vals", "ras", "Ds", "des", "ts", "conn", "vs", "ls", "js", "ss", "db", "ils", "di", "nas", "details", "amps", "Db", "da", "asi", "cs", "dds", "ps", "os", "dat", "pd", "dd", "tx"], "pdReader": ["hdRunner", "pbRunner", "pcReader", "pdRunner", "xdreader", "dsReader", "dsreader", "pbLoader", "hdReader", "hdreader", "dsLoader", "pcLoader", "pbStream", "hdStream", "ddStream", "pcRead", "xdWriter", "ddLoader", "pdLoader", "pdStream", "ddRunner", "pbReader", "hdWriter", "dsRead", "dsWriter", "xdRead", "pcWriter", "xdReader", "hdRead", "hdLoader", "ddReader", "pdreader", "pdRead"], "out": ["ssl", "base", "temp", "output", "net", "as", "s", "in", "at", "lib", "model", "default", "file", "gen", "conn", "Out", "url", "obj", "with", "external", "point", " in", "outer", "ex", "sys", "lock", "builder", "result", "later", "sync", "part", "cache", "up", "oder", "connection", "w", "parent", "store", "page", "object", "device", "again", "name", "exec", "exp", "array", "full", "over", "list", "order", "inner", "outs", "o", "line", "flow", "co", "write", "password", "session", "doc", "diff", "group", "director", "null", "dev", "io", "writer", "image", "to", "word", "cli", "term", "auto", "her", "copy", "user", "OUT", "child", "manager", "pass", "key", "client", "dot", "login", "inc", "down", "data", "db", "layer", "ext", "err", "code", "img"], "dcmEncParam": ["dcmEnParam", "dcmEstParam", "dcmDecParam", "dcmEnParameter", "dcmSecPart", "dcmDecType", "dcmDecPar", "dcmEncType", "dcmEncParameter", "dcmArchParam", "dcmEncPart", "dcmElParameter", "dcmEnPar", "dcmEnPart", "dcmDecArg", "dcmArchArg", "dcmArchParameter", "dcmSecPar", "dcmEnArg", "dcmDecParameter", "dcmDecPart", "dcmSecType", "dcmElParam", "dcmEstPar", "dcmEncPar", "dcmSecParam", "dcmElPar", "dcmEncArg", "dcmElType", "dcmEnType", "dcmEstType", "dcmEstParameter"], "pdWriter": ["dpWrite", "pdOutput", "ddWrite", "pdWriting", "htWriter", "dpReader", "dsReader", "hdReader", "pdWrite", "htWriting", "dpWriting", "PDWrite", "dpWriter", "hdWriter", "dsOutput", "dsWriter", "hdWrite", "htWrite", "PDWriter", "dsWrite", "ddOutput", "PDReader", "ddReader", "htReader", "PDWriting", "ddWriter", "hdOutput"]}}
{"id1": "659316", "id2": "2511579", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"argv": ["paramv", "Argf", "argb", "argver", "argsc", "argumentve", " argV", "ArgV", "argumentc", "argl", "argc", " argf", "interc", "Argve", "argve", " argc", " argl", "argV", "argsf", "Argver", "Argv", " argver", " argb", "interV", "paramV", "Argb", "paramb", "argumentver", "argumentv", "Argc", "interl", "paraml", "argsl", "argf", "Argl", "argsv", "interv", " argve"], "sources": ["psides", "sides", "vesores", " sors", "statences", "sores", "tides", "vesigs", "issors", "issources", "sors", "sresources", "sences", "tource", "statores", "fource", "vesources", "issides", "sesources", "psource", "psources", "issource", "tources", "fources", "psresources", "sesigs", "sesences", "sigs", "tresources", "vesences", "fresources", "statources", "fors", " sides", "sesores", "fides", "statigs"], "targets": ["taxes", "taxets", "tanget", " tokets", "Tanglets", "Targels", " taxes", "tangets", "taxels", " toket", "targends", "targes", "Targlets", "Targens", "tampels", "tiges", "targels", "tagnet", "tanglets", "tampets", "taxens", "tanges", " taxens", "tangels", "tigens", "toket", "tokencies", "targens", " tokencies", "Tangels", " targes", "tokets", " taxets", " tokens", "tigets", "tigends", " targends", "tokens", " taxends", "tamplets", "tagnencies", "tangends", "tangencies", " targens", "tagnens", "taxlets", "targlets", "Targets", "tampens", "taxends", "Tangens", " targencies", "targencies", "tagnets", "Tangets", "tangens"], "srclen": [" srcloen", "srploen", "rsceln", "srselens", "srclens", " srploen", "rscelen", " srclength", "srClEN", "srcln", "srctength", "srcteno", "srseln", "srclEN", "rsclEN", "rscln", "rscelens", "srCLeno", "srceln", "srcloen", " srcleno", "rscelEN", "srCln", "srClens", " srplen", "srclength", "srplength", "srcleno", " srpleno", "srCLoen", "srselEN", "srClen", "srpleno", "srcelen", "srcelens", "rsclens", " srplength", "rsclen", "srcten", "srctoen", "srplen", "srselen", "srCLen", "srcelEN", "srCLength"], "source": ["resource", "use", "seed", "channel", "current", "cache", "Source", "view", "proxy", "service", "scope", "input", "copy", "ource", "self", "path", "slice", "force", "driver", "dest", "in", "client", "unit", "single", "s", "rc", "out", "event", "model", "url", "get", "component", "config", "size", "sl", "link", "image", "start", "SOURCE", "remote", "ssl", "reader", "secure", "type", "ources", "id", "parent", "stream", "uri", "src", "create"], "tgt": ["tnt", "tgz", " tgz", " targ", "ptgt", "lnt", "targ", " tnt", "hgt", "bitgt", "tgs", "tch", "lret", " tbuster", " tkt", "biticket", "tret", "ticket", "tbuster", "Ticket", "lbuster", " tch", " ticket", "Tgs", "bitgh", "hret", "hgz", "tkt", "ptbuster", "rch", "hnt", "rkt", "tgh", "Tgh", "bitarg", "rgs", "lgt", " tret", "Tch", "Tgt", "rgt", " tgs", "lgz", "larg", "Tkt", " tgh", "ptarg", "ptnt", "Targ"], "target": ["resource", "slave", "route", "external", "cross", "project", "channel", "current", "view", "service", "master", "path", "manager", "io", "open", "match", "force", "tail", "driver", "dest", "arget", "download", "conn", "object", "child", "archive", "unit", "handler", "it", "rel", "goal", "connection", "base", "out", "event", "port", "url", "component", "session", "director", "image", "Target", "to", "result", "member", "next", "output", "nt", "remote", "point", "mount", "null", "plugin", "parent", "client", "core"], "deletes": ["kesleted", "degrades", " dedates", "desletes", "deists", "delletes", "deles", "downgrades", "exdates", "disists", "deises", "kesouts", "deleted", "exgrades", "desires", "desles", "Deires", " deouts", "disles", " delete", "desists", "delises", "exletes", "delouts", "kesises", "deires", "delete", "deouts", "exlete", "Deles", "kesletes", "Deletes", " degrades", "disletes", "dedates", "Deists", " deises", "delleted", "downletes", "downlete", "disires", "downdates", " deleted"], "del": ["pull", "local", "Delete", "clean", "d", "dl", "remove", "copy", "delay", "down", "ll", "add", "skip", "download", "dir", "def", " delete", "err", "rel", "bl", "up", "base", "fail", "install", "model", "coll", "delete", "get", "syn", "nl", "ul", "el", " Del", "diff", "se", "data", "change", "fl", "null", "de", "id", "update", "sel", "neg", "lock", "name", "file", "Del", "dec"]}}
{"id1": "8452134", "id2": "2009072", "code1": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "code2": "    public InputStream openInput(Fragment path) throws IOException {\n        int len = path.words().size();\n        String p = Util.combine(\"/\", path.words().subList(1, len));\n        URL url = new URL(\"http\", path.words().get(0), p);\n        InputStream result = url.openStream();\n        return result;\n    }\n", "label": 0, "substitutes": {"exists": ["xist", "resist", "exist", "esist", "actisting", "Existing", "resisting", "resists", "actistent", "esisting", "Existent", "xits", "Exist", "existing", "existent", "esists", "xists", "exits", "xisting", "Exists", "Exits", "actists", "resits", "esistent", "actist"], "fileToCheck": ["filetocheck", "entryTocheck", "stringToTest", "entryToChe", "entryTOChe", "fileTOChe", "entryTOcheck", "fileToChe", "fileToTest", "fileTOCheck", "filetoTest", "filetoChe", "fileTocheck", "entryToCheck", "entryTOCheck", "entryTOTest", "stringToCheck", "fileTOcheck", "filetoCheck", "stringTocheck", "entryToTest", "fileTOTest"], "ftp": ["fftp", "mailpc", "lfps", "oftp", "uft", "ntp", " fta", "ftip", "uffp", "ftfp", " ftpb", "lfp", "FTap", "alttp", "aftpc", " ftpa", " ftb", "FTps", "lftp", " ftt", "ctp", "rtp", "tta", "ftpc", "mailp", "ftap", "rta", "afttp", "fp", "ftw", "nta", "ufp", "ftpb", " ftcp", "ftb", "ftpo", "ft", "ttcp", "fta", "ftbr", "uttp", "ftsp", "cfps", "ffpo", "fcp", "ctpo", "altpc", "ufcp", "ttp", "ktpc", "oftip", "aftp", " ftw", " ftip", "aftcp", " ftpo", "utpc", "rtpc", "cftp", "htip", "cttp", "ntcp", "ftcp", "ctcp", "ffp", "mailtp", "ktp", "ftsps", "kta", "fpc", " ftap", "ffcp", "fttp", " fttp", " ftpc", "altw", "utp", "htpa", " ftfp", "utw", "htp", "htbr", "ftps", "ftpa", "ttps", "ntps", "altp", "ftsb", "rtpb", " ftps", "oftbr", "mailcp", "ktpb", "FTb", "oftpa", "FTp", "cfpo", "ftsap", "ftt", "cfp", " ftbr", "lfpo"], "found": ["first", "defined", "result", "error", "received", "local", "updated", "finder", "left", "connected", "valid", "old", "default", "index", "fl", "flat", "val", "length", "locked", "Found", "bug", "given", "ret", "err", "success", "len", "failed", "read", "checked", "all", "confirmed", "count", "used", "active", "find", "built", "nt", "good", "iter", "loaded", "broken", "search", "fd", "finding", "l", "fixed", "pos", "successful", "full", "f", "sent", "expected", "response"], "reply": ["address", "result", "base", "error", "send", "received", " response", "status", "call", "answer", "comment", "force", "rr", "request", "index", "length", "next", "err", "len", "write", "link", "bot", "prefix", "code", "respond", "read", "reason", "repl", "info", "connection", "report", "Reply", "text", "echo", "query", "sync", "post", "message", "ply", "buffer", "service", "dy", "lying", "match", "resp", "continue", "server", "cause", "data", " replies", " replied", "part", "sent", "zero", "response"]}}
{"id1": "19810820", "id2": "4852691", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"Jive will be unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return toHex(digest.digest());\n    }\n", "label": 0, "substitutes": {"copyFileChannel": ["transferFileChan", "transferfileChannel", "transferFileChannel", "copyDirectoryChannel", "copyStreamChannel", "copyDirectoryStream", "transferFileStream", "copyFileChan", "copyStreamStream", "copyStreamchannel", "copyFilechannel", "transferfileStream", "transferFilechannel", "copyDirectorychannel", "copyFileStream", "transferfileChan", "copyfileStream", "copyfilechannel", "copyStreamChan", "transferfilechannel", "copyDirectoryChan", "copyfileChannel", "copyfileChan"], "src": ["cur", "sl", "sin", "loc", "sup", "RC", "s", "sc", "slice", "stream", "sync", "st", "inst", "download", "sth", "sys", "rc", "ssl", "ls", "conn", "b", "img", "lower", "rs", "dist", "ruby", "SOURCE", "client", "dest", "rb", "sq", "sub", "source", "ctx", "path", "filename", "url", "config", "server", "tmp", "sit", "func", "scene", "upload", "sel", "sb", "input", "Source", "start", "ses", "rest"], "dst": ["fdst", "dost", "Dost", "tst", " dost", "adst", "adST", " ddest", "tart", "tlt", "dST", "fdput", "fdST", "lddest", "ddest", "drc", "stST", "ldst", "DST", "brc", "bST", "dlt", "bput", "bart", "dput", "adput", "Dst", " dST", "Ddest", "stlt", "adrc", "bst", "stst", "tST", "dart", "fdrc", "ldST", "ldost", "start", "blt"], "preserveModificationTime": ["preserveModifyingFile", "preserveModifyingtime", "preserveModifiedtime", "preserveModifiedTime", "preserveModifytime", "preserveModifiedFile", "preserveModificationtime", "preserveModationtime", "preserveMinifiedTime", "preserveMinifiedtime", "preserveModationFile", "preserveMinifiedFile", "preserveMinificationtime", "preserveModifyingTime", "preserveMinificationTime", "preserveModifyTime", "preserveModificationFile", "preserveMinificationFile", "preserveModationTime"], "inputChannel": [" inputSocket", "outputCode", "outputConnection", "imageChan", "binaryChannel", " inputStream", "fileConnection", "outputStream", "outputConsole", "Inputchannel", "outputChan", "errorStream", "requestCode", "inputCode", " inputCode", " inputchannel", "requestChannel", " inputChan", "InputChannel", " inputQueue", "inputSocket", "fileChannel", "errorChannel", "errorChan", "binarychannel", " inputConsole", "errorCache", "requestStream", "InputBuffer", "imageGate", "inputGate", "inputConnection", "fileChan", "imagechannel", " inputCache", "outputBuffer", "outputSocket", "inputChan", "InputSocket", "outputchannel", "outputGate", "outputQueue", "requestChan", "inputBuffer", " inputConnection", "inputStream", "inputCache", "binaryGate", "imageChannel", "InputChan", "fileConsole", "inputchannel", "inputQueue", "outputCache", " inputBuffer", "binaryChan", "InputQueue", "inputConsole"], "outputChannel": ["inputButton", "outputStream", "outputButton", "outStream", "outputChan", "OutputChannel", " outputStream", "OutputQueue", "OutputStream", "outchannel", "writeStream", " outputchannel", " outputButton", " outputChan", "writeQueue", "OutputChan", "outChan", "writeChan", "inputManager", "writeManager", "inputChan", "outputchannel", " outputQueue", "outputQueue", "Outputchannel", "outputManager", "inputStream", "outButton", " outputManager", "writeChannel", "outChannel"], "length": ["full", "lock", "offset", "volume", "sequence", "current", "session", "complete", "type", "head", "Length", "partial", "load", "base", "position", "with", "part", "text", "size", "section", "l", "max", "pull", "buffer", "count", "style", "build", "block", "limit", "child", "value", "form", "next", "sum", "width", "number", "duration", "delay", "id", "php", "len", "last", "result", "join", "available", "slave", "start", "end"], "total": ["full", "offset", "cur", "current", "scale", "error", "complete", "toc", "type", "partial", "info", "used", "set", "base", "part", "all", "otal", "size", "multi", "less", "done", "max", "translation", "key", "found", "count", "i", "limit", "no", "sum", "duration", "id", "Total", "len", "last", "valid", "result", "available", "failed", "always", "start"]}}
{"id1": "3409084", "id2": "10540676", "code1": "    protected String getRequestContent(String urlText) throws Exception {\n        URL url = new URL(urlText);\n        HttpURLConnection urlcon = (HttpURLConnection) url.openConnection();\n        urlcon.connect();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(urlcon.getInputStream()));\n        String line = reader.readLine();\n        reader.close();\n        urlcon.disconnect();\n        return line;\n    }\n", "code2": "    public static void checkForUpgrade(Event event) throws Exception {\n        ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"applyUpgrade\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(false);\n        ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(false);\n        new Command(\"DELETE FROM TBLINSTALLATION WHERE STATUS<>'APPLIED'\").executeNonQuery();\n        String clientAppliedVersion = new Command(\"SELECT MAX(VERSION) FROM TBLINSTALLATION WHERE STATUS='APPLIED'\").executeScalarAsString();\n        if (NullStatus.isNull(clientAppliedVersion)) {\n            clientAppliedVersion = \"20050101\";\n        }\n        String macquery = \"\";\n        String clientMAC = \"\";\n        String clientUNITID = UiUtil.getUNITUID();\n        ArrayList<String> macList = getMacList();\n        for (int i = 0; i < macList.size(); i++) {\n            clientMAC += macList.get(i) + \",\";\n            macquery += \"'\" + macList.get(i) + \"'\";\n            if (i < macList.size() - 1) {\n                macquery += \",\";\n            }\n        }\n        URL urlLICENSEQUERY = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC + \"&tegsoftCOMMAND=LICENSEQUERY\");\n        URLConnection urlConnection = urlLICENSEQUERY.openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String commingList = \"\";\n        String line;\n        while ((line = in.readLine()) != null) {\n            commingList += line;\n        }\n        in.close();\n        String licenseArray[] = commingList.split(\"</ROW>\");\n        if (licenseArray.length > 0) {\n            String fields[] = licenseArray[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        Dataset TBLLICENSE = new Dataset(\"TBLLICENSE\", \"TBLLICENSE\");\n        Command command = new Command(\"DELETE FROM TBLLICENSE WHERE UNITUID={UNITUID} AND (NOTES IN (\");\n        command.append(macquery);\n        command.append(\") OR NOTES IS NULL) \");\n        command.executeNonQuery();\n        for (int i = 1; i < licenseArray.length; i++) {\n            String fields[] = licenseArray[i].split(\"</FLD>\");\n            String LICTYPE = fields[0];\n            String UNIQUEKEY = fields[1];\n            String LICKEY = fields[2];\n            DataRow dataRow = TBLLICENSE.addNewDataRow();\n            dataRow.set(\"LICENSENAME\", LICTYPE);\n            dataRow.set(\"LICENSE\", LICKEY);\n            dataRow.set(\"NOTES\", UNIQUEKEY);\n            TBLLICENSE.save();\n        }\n        URL url = new URL(\"http://www.tegsoft.com/Tobe/forms/TobeOS/upgrade/upgrade_current.jsp?tegsoftCLIENTVERSION=\" + clientAppliedVersion + \"&tegsoftCLIENTUNITID=\" + clientUNITID + \"&tegsoftCLIENTMAC=\" + clientMAC);\n        urlConnection = url.openConnection();\n        in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n        String upgradeList = \"\";\n        while ((line = in.readLine()) != null) {\n            upgradeList += line;\n        }\n        in.close();\n        Dataset TBLINSTALLATION = new Dataset(\"TBLINSTALLATION\", \"TBLINSTALLATION\");\n        String upgrades[] = upgradeList.split(\"</ROW>\");\n        if (upgrades.length > 0) {\n            String fields[] = upgrades[0].split(\"</FLD>\");\n            String STATUS = fields[0];\n            String ERRORMSG = fields[1];\n            if (\"FAIL\".equals(STATUS)) {\n                if (\"NOUNITID\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOCUSTOMER\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_1));\n                    return;\n                }\n                if (\"NOVALIDLICENSE\".equals(ERRORMSG)) {\n                    UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_2));\n                    return;\n                }\n                UiUtil.showMessage(MessageType.ERROR, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_3));\n                return;\n            }\n        }\n        boolean restartRequired = false;\n        boolean updateAvailable = false;\n        for (int i = 1; i < upgrades.length; i++) {\n            String fields[] = upgrades[i].split(\"</FLD>\");\n            String VERSION = fields[0];\n            String ORDERID = fields[1];\n            String UPGRADETYPE = fields[2];\n            String DESCRIPTION = fields[3];\n            String STATUS = \"UNAPPLIED\";\n            String PRDNAME = \"TegsoftCC\";\n            if (\"TEGSOFTJARS\".equals(UPGRADETYPE) || \"TOBEJARS\".equals(UPGRADETYPE) || \"ALLJARS\".equals(UPGRADETYPE) || \"CONFIGASTERISK\".equals(UPGRADETYPE)) {\n                restartRequired = true;\n            }\n            DataRow dataRow = TBLINSTALLATION.addNewDataRow();\n            dataRow.set(\"ORDERID\", ORDERID);\n            dataRow.set(\"PRDNAME\", PRDNAME);\n            dataRow.set(\"UPGRADETYPE\", UPGRADETYPE);\n            dataRow.set(\"VERSION\", VERSION);\n            dataRow.set(\"STATUS\", STATUS);\n            dataRow.set(\"DESCRIPTION\", DESCRIPTION);\n            TBLINSTALLATION.save();\n            updateAvailable = true;\n        }\n        UiUtil.getDataset(\"TBLINSTALLATION\").reFill();\n        if (restartRequired) {\n            ((Component) UiUtil.findComponent(\"restartRequiredHbox\")).setVisible(true);\n            ((Component) UiUtil.findComponent(\"restartRequiredAlert\")).setVisible(true);\n        }\n        if (updateAvailable) {\n            ((Component) UiUtil.findComponent(\"downloadUpgrade\")).setVisible(true);\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_4));\n        } else {\n            UiUtil.showMessage(MessageType.INFO, MessageUtil.getMessage(Upgrade.class, Messages.upgrade_5));\n        }\n    }\n", "label": 0, "substitutes": {"getRequestContent": ["getResponseContent", "getHttpBody", "readRequestText", "readResponseBody", "getrequestString", "getHttpContent", "getRequestString", "getRequestText", "getResponseBody", "getRequestBody", "getrequestText", "readResponseText", "readResponseString", "readRequestString", "getrequestBody", "readResponseContent", "getrequestContent", "getResponseString", "getHttpText", "getResponseText", "getHttpString", "readRequestBody", "readRequestContent"], "urlText": ["httpText", "urltext", " urlString", "urlTEXT", "resourceContent", "resourcetext", "resourceText", "strContent", "urlString", "httpString", " urltext", "resourceTEXT", "pageString", " urlContent", "strText", "strTEXT", "strtext", " urlTEXT", "urlContent", "pageTEXT", "pageText", "httpTEXT"], "url": ["path", "base", "ssl", "server", "resource", "feed", "uri", "user", "http", "c", "lr", "l", "host", "URL", "fl", "client", "connection", "r", "str", "build", "open", "config", "web", "object", "ll", "page", "log", "conn", "or", "ls", "image", "blog", "full", "sl", "rl", "Url", "bc", "www", "ur", "b", "f", "this", "api"], "urlcon": ["urcon", " urlCon", "urlclient", "webconnect", "httpconn", "httpcon", "webann", "urlann", "webcon", "Urlclient", "httprun", " urlrun", "urconn", "urconst", "URLCon", "webCon", "URLclient", " urlann", " urlconst", "Urlfc", " urlconn", "webenc", "httpann", "httpfc", "urlCon", "Urlcon", "UrlCon", "urlfc", "httpCon", " urlconnect", "httpenc", "urlrun", "urlconnect", "httpclient", "httpconnect", " urlenc", "urlenc", "URLcon", "URLfc", "urlconn", "webconn", "urlconst", "httpconst", "urrun"], "reader": ["buffer", "loader", "i", "input", "editor", "her", "handler", "reading", "ker", "per", "inner", "ri", "result", "keeper", "read", "in", "iter", "ler", "er", "bird", "oder", "ner", "r", "parser", "data", "file", "director", "rar", "row", "rr", "or", "rer", "io", "writer", "rx", "worker", "car", "cher", "layer", "ser", "stream", "finder", "Reader"], "line": ["val", "letter", "string", "buffer", "feed", "response", "user", "entry", "message", "LINE", "end", "pass", "read", "char", "content", "email", "lines", "value", "str", "data", "file", "text", "body", "page", "log", "row", "inline", "name", "link", "lin", "Line", "block", "element", "code", "cell"]}}
{"id1": "12197169", "id2": "324679", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"read": ["request", "get", "process", "Read", "stream", "print", "load", "init", "parse", "write", "println", "check", "run", "open", "replace", "ready", "report", "readable", "work", "reading", "start", "end", "download", "continue", "reader", "loop", "create"], "in": ["r", "error", "image", "fr", "buffer", "n", "inn", "stream", "isin", "is", "s", "input", "e", "on", "id", "ex", "din", "server", "conn", "from", "info", "connection", "a", "inner", "path", "index", "io", "nin", "ssl", "out", "ini", "con", "file", "at", "of", "min", "f", "url", "o", "doc", "login", "data", "err", "b", "log", "er", "token", "it", "ins", "bin", "In", "l", "by", "ing", "reader", "IN", "again", "cms", "scan", "source", "c", "inc"], "line": ["ne", "buffer", "sl", "lf", "block", "entry", "key", "cell", "object", "el", "comment", "parse", "e", "id", "page", "lc", "lines", "val", "Line", "lin", "code", "message", "se", "value", "row", "file", "str", "end", "link", "ge", "f", "url", "col", "unit", "inline", "data", "log", "b", "ine", "LINE", "L", "status", "text", "record", "name", "l", "frame", "reader", "string", "le", "source"], "i": ["ai", "ip", "j", "p", "n", "ie", "eni", "is", "fi", "ix", "slice", "e", "phi", "abi", "ci", "gi", "ui", "info", "zi", "li", "index", "ii", "io", "ori", "ini", "uni", "bi", "x", "pi", "f", "o", "xi", "ti", "ri", "u", "ni", "b", "oi", "di", "l", "si", "qi", "ski", "I"], "logDatum": ["exDDam", "exDDatum", "Logdum", "logdum", "logDatata", "logDsatum", "logDatictionary", "LogDict", "logDatam", "Logdata", "LogDatum", "logFictionary", "logDatatum", "logDict", "exDam", "exDData", "logDum", "logDsata", "exDDictionary", "exData", "logDDatum", "exDatum", "logDatict", "logDsum", "logDDam", "LogDum", "logData", "logFatum", "exDictionary", "logDictionary", "logDData", "logdata", "logdict", "Logdict", "logFam", "Logdatum", "logDsict", "logDDictionary", "LogData", "logFata", "logdatum", "logDam"]}}
{"id1": "16820041", "id2": "2525897", "code1": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "code2": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "label": 1, "substitutes": {"encodePassword": ["enodeString", "enodedpassword", "enodeSecret", "enccodePassword", "enoderPassword", "encodepassword", "enodePassword", "enodedPassword", "encodeSecret", "enccodeString", "enodedString", "enoderSecret", "enccodeSecret", "enoderString", "enodedSecret", "enodepassword", "enccodepassword", "enoderpassword", "encodeString"], "_originalPassword": ["_actualPass", "_encryptedPassword", "theoriginalPass", "_OriginalSecret", "_actualSecret", "_origpassword", "_originalpassword", "_originalPass", "_origPassword", "theorigPassword", " _originalSecret", "_editedPass", "_origPass", "_encryptedSalt", " _actualPassword", "theoriginalpassword", "_OriginalPass", "theorigPass", "_actualPassword", " _actualPass", " _originalPass", "_originalSecret", "_editedPassword", "theorigSalt", " _actualSecret", "_originalSalt", "_origSalt", "_encryptedpassword", "_encryptedPass", "theorigpassword", "_Originalpassword", "_editedSecret", "_OriginalSalt", "theoriginalPassword", "theoriginalSalt", "_OriginalPassword"], "md": ["mac", "mm", "pad", "mo", "sd", "m", "Cmd", "dig", "kg", "ph", "db", "mad", "ad", "mn", "id", "pd", "metadata", "ma", "od", "code", "dc", "dr", "alg", "cd", "mb", "cm", "amd", "gb", "df", "dh", "mand", "bd", "gd", "sm", "mg", "dm", "data", "pm", "sha", "mt", "MD", "mp", "mc", "mod", "mag", "hd", "d", "vd", "ld", "ms", "meta", "hash", "cmd", "dd", " MD", "hm"], "encodedPassword": ["encidedSecret", "encachedSecret", "encoderPass", "encapedPassword", "enryptedString", "enodedpassword", "encidedPassword", "enccodedPass", "encoredPassword", "enoderPassword", "encryptedSecret", "enccodedPassword", "encidedPass", "ecryptedString", "enodedPassword", "enryptedpassword", "encoderpassword", "encoredString", "ecodedSecret", "encryptedPassword", "encoredSecret", "enryptedPass", "encryptedpassword", "encodedSecret", "encryptedPass", "enccodedSecret", "enoderPass", "encoderPassword", "enodedString", "encidedpassword", "encodedPass", "enoderSecret", "encodedString", "ecryptedPassword", "enccodedpassword", "encapedString", "encodedpassword", "ecodedPassword", "ecodedString", "encachedString", "encapedpassword", "encachedPassword", "enryptedPassword", "enodedSecret", "encoderString", "ecryptedSecret", "enoderpassword", "encryptedString", "encapedPass", "encoderSecret", "enodedPass"]}}
{"id1": "8046691", "id2": "5836744", "code1": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"retrieveFile": ["retrievingfile", "retriveFile", "retireFile", "RetrievingUrl", "Retrievingfile", "retrievingFile", "retrievefile", "Retrievefile", "retriveFiles", "retrievingUrl", "retrieveUrl", "RetrievingFile", "retirefile", "RetrieveFile", "RetrieveFiles", "retrivefile", "retireFiles", "retrievingFiles", "retireUrl", "retriveUrl", "retrieveFiles", "RetrievingFiles", "RetrieveUrl"], "url": ["image", "buffer", "service", "email", "sl", "html", "stream", "src", "host", "socket", "object", "proxy", "feed", "user", "page", "server", "address", "loc", "connection", "http", "location", "URL", "resource", "path", "io", "ssl", "file", "Url", "channel", "base", "download", "gl", "loader", "log", "contact", "org", "ll", "l", "string", "ur", "uri", "source", "config", "www"], "link": ["image", "error", "sync", "entry", "comment", "links", "address", "open", "info", "http", "build", "post", "config", "base", "linked", "name", "uri", "Link", "feed", "load", "user", "bug", "parse", "route", "cache", "check", "loc", "tail", "path", "li", "message", "pack", "file", "set", "local", "skip", "l", "plugin", "lock", "auto", "service", "ink", "object", "slice", "lc", "low", "ref", "pull", "line", "download", "log", "remote", "add", "source", "layer", "match", "block", "LI", "or", "connection", "code", "location", "model", "inline", "data", "type", "loader", "task", "call", "style", "light", "list", "machine", "self"], "httpConn": ["userConn", "workconn", "transConnection", "baseConn", "serverconn", " httpConnection", "httpCan", "HttpConn", " httpConfig", "HttpConnect", "httpCmd", " httpconn", "urlConnect", " httpCan", "webLoc", "httpConf", "serverMC", "HttpConnection", "webConnection", "phpConnection", " httpLoc", "HttpMC", "workConnection", "HttpLoc", "urlCon", "httpsCan", "userConf", "perCon", "transConnect", "workCon", "httpMC", "httpconn", " httpCon", "serverConnect", "pubConnection", "httpConfig", "userConnect", "httpCur", "urlConnection", "baseConnection", "buildConnection", "buildCmd", "HttpConfig", "pubConn", "buildConn", "perConnection", "httpsCon", "httpConnection", "workConn", "phpCon", "buildconn", "buildCon", "urlConn", "httpsConf", "perConf", "perconn", "perConn", "baseCan", "transConn", "httpsConnect", " httpConf", "transCon", "serverConn", "phpCur", "serverConnection", "baseConf", " httpCur", "httpLoc", "httpsConn", " httpMC", "httpConnect", "pubCmd", "phpConn", "HttpCur", " httpCmd", "webConfig", "phpConnect", " httpConnect", "webConnect", "httpsConnection", "webconn", "pubCon", "perConnect", "httpCon", "userConnection", "webConn"], "outs": ["Out", "locks", "in", "timeout", "ups", "bytes", "qs", "steps", "lets", "files", "output", "socket", "limits", "boxes", "bs", "strings", "its", "overs", "ls", "ns", "events", "INS", "css", "aos", "cache", "lines", "conn", "gets", "cos", "ios", "reports", "services", "io", "results", "out", " out", "states", "abs", "bits", "opens", "sets", "data", "blocks", "pins", "works", "groups", "errors", "ins", "ops", "fits", "utils", "again", "runs", "ports", "rules", "ws", "OUT", "flows", "plugins"], "bins": ["pannels", "pints", "cbas", "bains", "sbkins", "pin", "bkins", "Bannels", "Bains", "Bouts", "wbins", "cbains", "sbains", " bkins", "wbouts", "Bkins", " bints", "wbains", "wbas", "Bints", "cbins", "bas", " bas", "sbouts", " bin", "Bins", "cbouts", "sbins", "bints", "pins", " bannels", "bin", "Bin", "bannels", " bains"], "bouts": ["bborders", "dbuss", "wbgets", "Bout", "bout", "wbins", "Bouts", "Buss", " bgets", "wbouts", "bboxes", "dbout", "bgets", " borders", "Borders", " bboxes", " buss", " bout", "dbouts", "bbins", "buss", "Bins", "borders", "Bboxes", "bbgets", "bbout", "bbouts", "dbboxes", "wbout"], "postData": ["ostBody", "readData", "POSTBytes", "formDATA", "ostdata", "POSTDATA", " postBody", "postBody", "ostDATA", "PostData", "objectDATA", "objectBytes", "postBytes", "readUrl", "PostUrl", "postString", "objectData", " postDATA", "POSTData", "formBody", "readdata", "formData", "ostData", "objectBody", "PostString", "postUrl", "POSTUrl", "readString", "Postdata", "POSTBody", "postDATA", "postdata", " postBytes", "POSTdata", "formdata", "POSTString"], "mimePattern": ["mimesModel", "mimesPattern", "MimesPattern", "MIMEModel", "mileModel", "mIMEModel", "Mimepattern", "mimeFilter", "mimepattern", "mimesString", "milePattern", "mimeString", "mimeModel", "MIMEPattern", "Mimespattern", "mIMEFilter", "MimePattern", "mengepattern", "MIMEpattern", "mimespattern", "MimesFilter", "mengeFilter", "mengePattern", "MimeFilter", "MimeString", "MimeModel", "MimesString", "mimesFilter", "mIMEString", "mengeString", "mIMEpattern", "milepattern", "mIMEPattern"], "matcher": ["patches", "patmatch", "earchers", "earmatch", "matchers", "matmatch", "patchers", "mather", "Matcher", "matches", "earcher", "Matmatch", " mather", "patche", "pather", " matchers", "Matches", "Matchers", "Matche", "earches", " matches", " matche", "patcher", "matche", "Mather"], "byteBuffer": ["ByteArray", "bitBuffer", "dataLength", "bitArray", "byteLength", "ByteHandler", "dataBuffer", "bitBuff", " byteQueue", "ByteLayer", "byteArray", "doubleBuffer", " byteArray", "doubleBuff", "byteHandler", " byteLength", "ByteLength", "ByteBuffer", "ByteBuff", "dataLayer", " byteBuff", " byteHandler", "dataBuff", "bitHandler", "doubleQueue", " byteLayer", "byteLayer", "doubleArray", "byteBuff", "byteQueue", "ByteQueue"], "count": ["ind", "match", "level", "size", "max", "n", "Count", "cond", "label", "key", "i", "old", "all", "e", "parent", "id", "limit", "core", "coll", "cache", "val", "child", "more", "group", "length", "code", "sum", "found", "low", "index", "weight", "num", "path", "pool", "now", "file", "build", "part", "len", "start", "min", "f", "col", "depth", "ch", "base", "type", "b", "keep", "offset", "number", "allow", "call", "name", "string", "list", "current", "c"]}}
{"id1": "8588992", "id2": "823074", "code1": "    public ActionForward perform(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String status = null;\n        HttpSession session = request.getSession();\n        ReportingBean reportingBean = null;\n        NewConceptBean conceptBean = null;\n        String conceptName = null;\n        String primitive = null;\n        MessageResources errorMessages = MessageResources.getMessageResources(\"com.apelon.apps.dts.treebrowser.resources.error_messages\");\n        LogonUtilities logonUtilities = new LogonUtilities();\n        if (logonUtilities.checkSession(session, status, reportingBean, errorMessages)) {\n            reportingBean = (ReportingBean) session.getAttribute(\"reportingBean\");\n            if ((reportingBean.getMessageHtml().indexOf(\"Classify\")) == -1) {\n                reportingBean.setReportingHtml(\"\");\n            }\n            conceptBean = (NewConceptBean) session.getAttribute(\"newConceptEntity\");\n            conceptName = request.getParameter(\"conceptName\");\n            primitive = request.getParameter(\"primitive\");\n            if (primitive == null) {\n                primitive = \"false\";\n            }\n            conceptBean.setConceptName(conceptName);\n            conceptBean.setPrimitive(primitive);\n            String namespace = conceptBean.getConceptNamespace();\n            if (namespace == null) {\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_3\"));\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n                return (mapping.findForward(status));\n            }\n            String[] roleMods = request.getParameterValues(\"some_or_all\");\n            String[] roleGrps = request.getParameterValues(\"role_group\");\n            Vector roles = conceptBean.getRoles();\n            RoleBean[] roleCons = new RoleBean[roles.size()];\n            roles.copyInto(roleCons);\n            if (roleMods != null && roleGrps != null && roleCons != null) {\n                if (roleCons.length == roleMods.length && roleCons.length == roleGrps.length) {\n                    for (int i = 0; i < roleCons.length; i++) {\n                        roleCons[i].setSomeOrAll(roleMods[i]);\n                        roleCons[i].setRoleGroup(roleGrps[i]);\n                    }\n                }\n            }\n            session.setAttribute(\"newConceptEntity\", conceptBean);\n            NewConceptXMLDisplayBean xmlBean = new NewConceptXMLDisplayBean();\n            xmlBean.setNewConceptXml(conceptBean);\n            String data = BrowserUtilities.encodeUrl(\"conceptXml\") + \"=\" + BrowserUtilities.encodeUrl(xmlBean.getNewConceptXml()) + \"&\" + BrowserUtilities.encodeUrl(\"nameSpace\") + \"=\" + BrowserUtilities.encodeUrl(namespace);\n            XMLPropertyHandler configPh = new XMLPropertyHandler(\"dtsbrowserclassify.xml\");\n            Properties configProps = configPh.getProps();\n            String urlString = configProps.getProperty(\"url\");\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuffer buf = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                buf.append(line);\n            }\n            String resultXml = buf.toString();\n            wr.close();\n            rd.close();\n            ClassifiedConceptBean ccBean = new ClassifiedConceptBean();\n            ClassifyResultParser parser = new ClassifyResultParser(resultXml);\n            ResultBuilder rbuilder = new ResultBuilder();\n            rbuilder.setConceptBean(ccBean);\n            rbuilder.setParser(parser);\n            rbuilder.setNamespace(namespace);\n            try {\n                rbuilder.buildResult();\n                ccBean = rbuilder.getConceptBean();\n                ClassifiedConceptDisplayBean displayBean = new ClassifiedConceptDisplayBean();\n                displayBean.setNewConceptHtml(ccBean);\n                session.setAttribute(\"classifyResult\", ccBean);\n                session.setAttribute(\"classifyDisplayResult\", displayBean);\n                status = \"success\";\n            } catch (Exception e) {\n                Categories.dataServer().error(StackTracePrinter.getStackTrace(e));\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_1\") + e.getMessage());\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n            }\n        }\n        return (mapping.findForward(status));\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"perform": ["consubmit", "persubmit", "conroute", "tosubmit", "perroute", "overform", "oversubmit", "conflow", "toflow", "perflow", "toform", "overroute", "overflow", "toroute", "conform"], "mapping": ["tmapping", "rmapper", "smappings", " matching", "tmapper", "mappings", "smapper", " migration", "mailing", "tmatching", " mapper", "matching", "ormigration", "smailing", "ormatching", "rmappings", "Mapper", "Mailing", "ormapping", "migration", "Mappings", "mapper", "smapping", "Mapping", "tmigration", "ormapper", "rmapping", "rmailing"], "form": ["flow", "template", "change", "view", "app", "controller", "model", "command", "path", "forms", " forms", "stream", "Form", "format", "method", "report", "transform", "route", "object", "config", "update", "submit", " submission", "page", "process", " transform", "control", "f"], "request": ["complete", "position", "result", "client", "project", "enter", "re", "view", "QUEST", "use", "current", "child", "model", "path", "xml", "remote", "input", "q", "name", "context", "queue", "image", "event", "report", "method", "user", "application", "route", "object", "join", "query", "press", "post", "message", "resource", "version", "condition", "Request", "document", "submit", "page", "server", "subject", "req", "instance", "create", "frame", "initial", "record"], "response": ["result", "client", "re", "view", "output", "model", "Response", "xml", "res", "report", "method", "application", "object", " Response", "message", "resource", "api", "page", "resp", "server", "reply", "json", "manager"], "status": ["complete", "score", "result", "error", "stat", "Status", "description", "login", "str", "output", "site", "exit", "id", "security", "current", "model", "sort", "xml", "uses", "index", "host", "string", "stats", "state", "name", "action", "prefix", "success", "spec", "step", "code", "reason", "type", "ssl", "notice", "method", "html", "wait", "speed", "sync", "edit", "update", "message", "service", "version", "icon", "date", "source", "server", "subject", " Status", "stage", "warning", "STAT", "json", "msg", "settings"], "session": ["su", "result", "Session", "client", "account", "token", "cache", "local", "scope", "view", "site", "use", "port", "ESSION", "security", "child", "container", "shell", "ess", "input", "temp", "connect", "context", "state", "s", "host", "language", "thread", "image", "lock", "set", "sa", "entity", "sb", "connection", "batch", "user", "application", "gui", "task", "query", "socket", "message", "service", "resource", "api", "mission", "condition", "document", "search", "http", "cookie", "source", "process", "se", "server", "subject", " Session", "ession", "group", "sp", "statement", "manager", "settings"], "reportingBean": ["reportingGuane", "sharingBeean", " reportingBea", "gettingBeoin", "trainingBEbean", "reportingBebean", "reportingBroada", " reportingBoane", " reportingBebean", "reportingBoann", "trainingBeam", "reportingTean", "reportingRoam", "reportingBeam", "trainingBeean", "ReportingBeanned", "reportingCodebean", "gettingBEa", "gettingBEoin", "reportingBoan", "reportingBeean", "sharingBEbean", "ReportingBeean", "gettingBeane", "trainingBEam", "reportingBoa", "ReportingBane", "ReportingBanned", "reportingCodeean", "reportingBEa", "sharingBEean", " reportingBoan", " reportingRobean", "reportingBEan", "ReportingBean", "sharingBebean", "reportingMeean", "reportingBeanc", "ReportingBan", "reportingBleam", " reportingRoan", "reportingBleanan", "sharingBEan", "reportingBea", "sharingBEanc", "reportingBroadan", " reportingBeane", " reportingRoean", "reportingBEanc", "reportingTebean", "trainingBEan", "reportingBbean", "reportingBEoin", "reportingRoanan", "reportingBoean", "trainingBeanc", "reportingTeanc", "reportingGuean", "reportingMean", "reportingBeanned", "reportingGuan", "reportingGuanned", "reportingBoane", "ReportingBeane", "sharingBeanc", "reportingBan", "reportingBroadane", "reportingBooin", " reportingBoann", "reportingBanned", "reportingBlean", "trainingBEann", "reportingBeoin", "trainingBeann", "reportingBEanan", "reportingBEbean", "reportingBanc", "gettingBea", "reportingBeanan", "reportingBEane", " reportingBeann", " reportingRoa", "reportingMea", "reportingBroadoin", "reportingBane", "reportingBEann", "reportingRoean", "reportingBleann", " reportingBeean", "trainingBEean", "reportingRoann", "reportingBoanned", "reportingBeane", "trainingBEanan", "gettingBEane", "reportingRobean", "reportingRoanc", "reportingBEean", "gettingBean", "reportingBEam", "trainingBEanc", "trainingBeanan", "sharingBean", "trainingBean", "reportingRoa", "reportingMebean", "reportingCodeanc", " reportingBoean", "reportingRoan", "reportingBeann", "gettingBEan", "trainingBebean", "reportingCodean", "reportingBann", "reportingTeean"], "conceptBean": [" conceptBan", "conceptClanc", "conceptTeean", "conceptBebean", "conceptModelans", "conceptTean", "projectBeane", "contactBEanc", "conceptFeann", "contractBean", "conceptBoaning", "conceptBa", "contractBeean", "conceptPegan", "conceptTeane", "conceptBegan", "projectBean", "conceptBein", "contractBEean", "conceptEla", "conceptBeann", "reportTeean", "conceptBlen", "conceptBEans", "conceptBane", " conceptBebean", "conceptClan", "reportBean", "conceptBea", "conceptPea", "conceptBlann", "reportTean", "reportBeean", "conceptElean", "conceptClean", "conceptEans", "conceptTeaning", "conceptPean", "conceptBeaning", " conceptFebean", "conceptBEgan", "conceptFeen", "projectBEn", "conceptBbean", " conceptFeen", "contractBEan", "reportBeaning", "conceptEan", "conceptEn", "projectBEans", "conceptEean", "conceptBan", "contractBegan", "conceptElgan", "conceptBeean", "conceptBen", " conceptBane", "contactBein", "conceptModelan", "conceptBlbean", "conceptBeans", "contractBEgan", "contactBEan", "conceptPlean", "conceptElan", " conceptBeann", "conceptBlan", "conceptPlanc", "projectBEane", "projectBeans", " conceptBeen", " conceptBeane", "contactBean", "conceptPeean", "conceptPlin", "contactBEin", "projectBen", " conceptBea", "conceptEane", "contactBeean", "conceptBeen", "conceptBEn", "conceptEa", "conceptPlan", "conceptModelane", "conceptBEean", " conceptBeean", "conceptBEanc", "conceptBEin", "reportTeane", "contactBEean", "conceptBeanc", " conceptFeann", " conceptBa", "contactBeanc", "conceptFean", "projectBEan", "conceptBeane", "conceptFebean", " conceptFean", "conceptBoan", "reportBeane", "conceptBEane", "conceptBEaning", "conceptBoane", "conceptBoean", "conceptBEa", "conceptClin", "conceptBEan", "conceptBann", "conceptModeln", "reportTeaning", "contractBEa", "contractBea"], "conceptName": ["conceptname", " conceptname", " conceptNames", "clientname", " conceptType", "ceptType", "contextType", "ceptname", "conceptType", "conceptNames", "contextname", "contextName", "ceptName", " conceptUnit", "conceptUnit", "contextNAME", " conceptNAME", "ceptUnit", "clientNAME", "clientName", "contextNames", "contextUnit", "ceptNames", "conceptNAME"], "primitive": ["Primitives", "necessitive", "perity", "primical", "Primue", "peritives", "primifier", "primitiveness", "primity", " primifier", "transifier", "quantitive", "Primifier", "quantue", "peritive", "Primitivity", "Primient", "Primitive", "quantitiveness", "transitive", "necessitives", "perical", "penitives", "primitives", "necessity", "penity", "penitive", " primitivity", "penical", "quantity", "Primical", " primity", "primitivity", "quantitives", "transitivity", "perient", "necessitiveness", "Primity", "penient", "transue", "Primitiveness", " primitiveness", "primue", " primue", "primient"], "errorMessages": [" errorMessags", "errormessrors", "errorMessains", "errorMags", "errorMains", "errorScags", " errorMessrors", " errorBodes", " errormessags", " errorBagers", " errorChrors", "errorMagers", " errorMessings", "errorChages", "errorScains", "errorMessrors", " errorMessodes", " errorMessagers", " errormessains", "errorChings", "errorMessags", "errorBages", "errormessings", "errorBodes", "errorScages", "errorBags", "errormessages", "errorMessagers", "errorErags", " errorChages", "errorErings", "errormessagers", "errormessags", "errorMessings", " errorChags", "errorMessodes", "errorBagers", " errorMessains", " errorChings", " errorBags", "errorChags", "errorMages", "errormessains", "errorScagers", "errorChrors", "errorErrors", "errorErages", "errorChodes", " errorBages", "errorChagers", " errormessages", "errormessodes", " errormessagers"], "logonUtilities": [" logonutils", "logonutiles", "logonFacility", " logonutility", "logonUtiles", "logonFacilities", "logronUtilities", " logonMutility", " logonMutils", " logonUtil", "logronutiles", "logonIntilities", "logonUtility", " logonsUtil", " logonsutilities", "logonutility", " logonTil", " logonsutils", " logonMutil", "logonIntiles", "logronutilities", "logonutilities", " logonsUtils", " logonTils", " logonutilities", "logronutils", "logonIntility", "logronutility", "logonUtils", " logonTilities", " logonTility", " logonMutilities", "logronUtiles", "logonFacils", "logronUtils", " logonutil", " logonsUtilities", " logonUtils", " logonsutility", " logonUtility", "logonutils", "logonFaciles", " logonsutil", "logronUtility", "logonIntils", " logonsUtility"], "namespace": ["insename", "Namesig", "inspaced", "nameships", "nspaces", "namespaced", "ships", "nspace", "nsename", "space", "inspace", "namespaces", "Namespaces", "relationspace", "namesename", "relationspaced", "Nameships", "relationspaces", "conspace", "Namespace", "consig", "relationsename", "spaces", "namesig", "inspaces", "conspaces", "nspaced", "conships", "sig"], "roleMods": ["RoleOps", "roleMod", "oleMods", "oleComm", " roleMod", "relationComm", "roleMOD", "RoleMods", " roleOps", "relationMOD", " roleMOD", "relationMods", "RoleMod", "oleMOD", " roleComm", "roleOps", "relationMod", "oleOps", "oleMod", "roleComm"], "roleGrps": ["roleArPs", "roleGps", "roleGrples", " roleChpes", " roleChps", " roleGrp", "rolegrPS", " roleGples", "roleGrp", " roleGps", "roleGrPS", " roleChPS", "roleGrpes", "rolegrps", "roleChps", "roleChPS", "roleArples", "rolegrpes", " roleGrpes", "roleCorPs", "roleCorples", " roleGPs", "roleGPs", "roleGples", "roleGrPs", " roleGrPS", " roleGrples", "roleArp", "roleDroPS", "roleArps", "roleCorps", "rolegrPs", "roleDroPs", " roleChPs", " roleGrPs", "roleDropes", " roleGp", "roleDrops", "roleChPs", "roleGp", "roleCorp", "roleChpes"], "roles": ["proels", "rolls", "rooles", "rolele", "coels", "rolels", "rolules", "rololes", "roleels", "rolle", "rels", "roleoles", "rles", "role", "prols", "rols", "rle", "roules", "prooles", "coles", "roleles", "roels", "rolles", "roleules", "proles", "cooles", "coules"], "roleCons": ["rolCont", " rolecons", "rolCons", "rulecons", "roleMembers", "oleMembers", " roleIns", "rolcons", " roleCont", "ruleContin", "ruleIns", "ruleMembers", "ruleCons", "rolMods", "roleContin", "rolecons", "olecons", " roleContin", "rolMembers", "roleIns", "ruleMods", "oleCons", "ruleCont", "oleContin", " roleMembers", "rolIns", "roleCont"]}}
{"id1": "22536033", "id2": "7911686", "code1": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"setPayload": ["setMessageContent", "setRawload", "setWorkLoad", "setRawloads", "parsePayload", "setPayLoad", "parsePayloads", "setShipContent", "setRawLoad", "setPayloads", "setShipload", " setPayloads", "setMessageloads", "parseShiploads", "setWorkContent", "setPayContent", "setShiploads", "setWorkload", "parsePayContent", "parseShipLoad", "parsePayLoad", "setRawContent", "parseShipload", " setPayLoad", "parseShipContent", "setWorkloads", "setShipLoad", " setPayContent", "setMessageLoad", "setMessageload"], "fos": [" fics", "cfics", "Foc", "bos", "fics", "cfoc", "bics", "boc", "Fis", "cfis", "Fos", "bis", "Fics", "cfos"], "fis": ["fib", "fIS", "eic", " fics", "eoc", "eis", "eIS", "Foc", "fics", "forib", "Fic", "FIS", "foris", " fIS", " fib", "Fis", "foric", "Fib", "Fics", "forics"], "fic": ["fci", " fics", " fac", "cfics", "ufik", "cfirc", "Fci", " firc", "Firc", "firc", "elfics", "Foc", "ufos", "fics", "fik", "Fic", "cfoc", "fac", "elfik", "elfic", "cfic", "Fac", "elfci", " fik", "ufoc", "infci", "Fos", "infik", "infics", "Fics", "ufic", "Fik", "cfac", "infic"], "foc": ["infac", "Focol", "focol", "Foca", "troc", " fac", " fisc", "infocol", "Froc", "focon", "infos", " focon", "fisc", "Foc", " froc", " focol", "tic", "Fic", " foca", "fac", "toca", "infocon", "Fac", "infoc", "Fos", "froc", "infisc", "foca", "Focon", "toc", "infic", "Fisc"], "Index": ["Dim", " index", "Found", "Key", "Number", "Link", "Start", "Depth", "Connection", "Position", "Address", "Path", "Loop", "Entry", "Level", "Code", "Weight", "Len", "Length", "Stage", "Count", "Array", "ID", "Width", "Exp", "Pull", "Version", "Offset", "Url", "Counter", "Order", "Num", "Insert", "First", "Header", "Body", "Location", "Loc", "I", "X", "Mass", "Interest", "x", "Content", "index", "Page", "Input", "Value", "Instance", "Section", "Element", "Flag", "Size", "Rank", "Inf", "Client", "Label", "Row", "Pos"]}}
{"id1": "2461169", "id2": "3266833", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeStringToString", "decodeFileAsStream", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileToStream", "decodeString2String", "decodeFileAsString", "decodeFileAsFiles", "decodeStringToFile", "decodeFile2String", "decodeStringToStream", "decodeFileAsFile", "decodeFileFromString", "decodeString2Stream", "decodeFileFromFile", "decodeFileToString", "decodeFile2File", "decodeString2File", "decodeFileToFiles", "decodeStringToFiles", "decodeString2Files", "decodeFileFromStream", "decodeFile2Files"], "infile": ["minfile", "infp", "outfilename", "infiles", "inFile", "inputfile", " instream", " inbase", " infp", "inputfp", " inFile", "Instream", "minstream", "outfiles", " infilename", "inputfiles", " infiles", "outfp", "Infile", "minFile", "minbase", "InFile", "inbase", "instream", "inputfilename", "infilename", "Inbase"], "outfile": ["outfilename", "outputfile", "inFile", "outFile", "inputfile", "outpath", " outFile", " outpath", "infolder", "outputfolder", "inputFile", "inputpath", " outfolder", "outdatabase", "outfolder", "outputdatabase", "outputfilename", " outdatabase", "inputdatabase", "outputpath", "outputFile", "infilename", " outfilename"], "in": ["IN", "pin", "sin", "i", "input", "inas", "id", "ini", "gin", "into", "ic", "con", "inner", "as", "socket", "ins", "s", "bin", "pass", "is", "reader", "source", "thin", "login", "min", "inside", "r", "inc", "data", "rin", "init", "conn", "again", "m", "re", "isin", "In", "nin", "a", "lin", "err", "b", "ac", "cin", "inn", "win", "din"], "out": ["base", "ou", "job", "ex", "output", "outer", "copy", "timeout", "net", "OUT", "socket", "inner", "outs", "o", "off", "line", "write", "bin", "co", "pass", "exit", "post", "client", "sync", "session", "no", "cache", "one", "lib", "up", "inc", "parent", "work", "file", "channel", "log", "conn", "or", "again", "name", "exec", "Out", "io", "home", "writer", "image", "to", "In", "obj", "err", "error", "point"], "buffer": ["address", "base", "Buffer", "input", "uffer", "feed", "server", "border", "slice", "limit", "result", "length", "write", "bin", "queue", "offset", "iter", "split", "raw", "type", "reader", "cache", "binary", "source", "seed", "buff", "value", "buf", "wave", "data", "channel", "size", "bb", "null", "bytes", "layer", "flush", "url", "b", "reference", "count", "padding", "transfer", "batch"], "read": ["play", "i", "Read", "feed", "n", "copy", "reading", "id", "add", "ind", "slice", "current", "end", "limit", "run", "se", "find", "length", "write", "reads", "ride", "pass", "sleep", "ad", "iter", "next", "raw", "sync", " count", "select", "allow", "use", "load", "reader", "len", " Read", "r", "seek", "work", "inc", "check", " copy", "ip", "size", "x", "get", "fill", "start", "exec", "io", "lex", "send", "tell", "_", "parse", "connect", "wait", "count", "READ", " write", " skip", "f"], "success": ["path", "roll", "error", "response", "rolling", "continue", "results", "ceed", "xx", "message", "primary", "warning", "better", "result", " Success", "ccess", "pass", "failed", "func", "done", "follow", "content", "fail", "construct", "true", "valid", " succeed", "value", "model", "default", "open", "data", "growth", "flash", "null", "cess", "danger", "complete", "again", "status", " successful", "good", "Success", "comment", "positive", "right", "successful", "successfully", "rolled", " succ", "method", "fast", "first", "winner", "initial"]}}
{"id1": "12389873", "id2": "21531069", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public int updateuser(User u) {\n        int i = 0;\n        Connection conn = null;\n        PreparedStatement pm = null;\n        try {\n            conn = Pool.getConnection();\n            conn.setAutoCommit(false);\n            pm = conn.prepareStatement(\"update user set username=?,passwd=?,existstate=?,management=? where userid=?\");\n            pm.setString(1, u.getUsername());\n            pm.setString(2, u.getPasswd());\n            pm.setInt(3, u.getExiststate());\n            pm.setInt(4, u.getManagement());\n            pm.setString(5, u.getUserid());\n            i = pm.executeUpdate();\n            conn.commit();\n            Pool.close(pm);\n            Pool.close(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            Pool.close(pm);\n            Pool.close(conn);\n        } finally {\n            Pool.close(pm);\n            Pool.close(conn);\n        }\n        return i;\n    }\n", "label": 1, "substitutes": {"load": [" reload", "get", "process", "clone", "loading", "save", "sync", "transfer", "init", " loaded", "construct", " Load", "write", " loading", "ready", "Loading", "build", " loads", "link", "download", "Load", "test", "add", "read", "dump", "config", "select"], "conn": ["db", "pt", "client", "connect", "ca", "Conn", "h", "p", "ctx", "n", "cp", "cc", "cn", "pg", "ls", "ns", "cat", "cr", "nt", "ci", "cache", "coll", "sb", "reg", "ann", "loc", "Exec", "dn", "state", "connection", "dc", "nc", "con", "conf", "dh", "pub", "util", "oci", "ch", "enc", "sql", "exec", "col", "session", "rt", "ct", "pc", "co", "mc", "Connection", "act", "config", "c", "pr", "ec"], "stmt": ["strs", "STnt", "Stml", "elrs", "STmn", "astql", "putml", "slr", "Stmc", "STct", "ostmt", "stmd", "slnt", " stor", "putur", "playtr", "stpl", "putmb", "Stmb", "sttor", "str", "actmt", " stmi", "playml", "estmt", "STpl", " stpl", "stpr", "stm", "acttr", "Stnt", " stml", "ostager", "atmt", "tm", "Stbt", "dmt", "stmn", "Stdb", "plb", "themc", " stbl", "Stb", "dmd", "stql", "putbt", "fldo", " stm", "estdo", "stmr", "Stager", "Stmr", "atmn", "plmn", " sttor", " stmn", "stmi", "tmt", "atMT", "flmd", "astmn", "Stmd", "flk", "plmt", "cltr", "slager", "playmt", "stmc", "stur", "Stts", "STager", " sttr", "stMT", "strmt", "estth", " str", " stts", "STmt", "playor", "ostpr", "dnt", "putmi", "clmt", "actbl", "estql", "themt", " stmb", "astk", "Stbl", " stager", "Stmt", "Stmn", "tpl", "stbt", "estk", "putmt", "estmd", "strk", "Stur", " stct", "Stm", " stdb", "osttr", " stpr", " stk", "STql", "dMT", "sttr", "stager", "Sttor", "ostmn", "elml", "atb", "plnt", "ostct", "acttor", " stmc", "strmd", "ostpl", " strs", "strdo", "STmd", "Sttr", "stnt", "Stct", "tct", "estMT", "esttr", "stmb", "puttr", "putmn", "slmn", "stdb", " stmr", " stMT", "STMT", "putts", "stml", "stdo", "clmn", "stbl", "flmt", "elmt", " stb", "STbl", "stts", "slmt", "stor", "plMT", "StMT", "plr", "putrs", "Stql", "estmr", " stbt", "themn", "elmi", "stb", " stql", "Stor", "stct", "stk", " stnt", "STml", "theb", "playmn", " stth", "slk", "Stth", "estct", "stth", "clur", "astmt", "Stpl", "STk", "playpl", "STdb", "Stpr"]}}
{"id1": "12579075", "id2": "6625074", "code1": "    public static XMLConfigurator loadFromSystemProperty(String propertyName) throws IOException {\n        String urlStr = System.getProperty(propertyName);\n        if (urlStr == null || urlStr.length() == 0) {\n            return null;\n        }\n        InputStream in = null;\n        DOMRetriever xmlDoc = null;\n        try {\n            URL url = new URL(urlStr);\n            xmlDoc = new DOMRetriever(in = url.openStream());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (in != null) in.close();\n        }\n        return newInstance(xmlDoc);\n    }\n", "code2": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"loadFromSystemProperty": ["loadFromLocalProperty", "loadFromsystemProperty", "loadFormSystemString", "loadFromSysString", "loadFromLocalString", "loadFromSystemString", "loadFromSysperties", "loadFromSystemproperty", "loadFromSysProperty", "loadFromLocalproperty", "loadFormsystemProperty", "loadFormSystemperties", "loadFromsystemperties", "loadFromLocalperties", "loadFormsystemString", "loadFormSystemProperty", "loadFormSystemproperty", "loadFromSystemperties", "loadFromsystemproperty", "loadFromSysproperty", "loadFromsystemString", "loadFormsystemperties", "loadFormsystemproperty"], "propertyName": ["filePart", "fileName", "PropertyStr", "propertyValue", "propName", "propertyString", "fileNames", "propNames", "fileString", "PropertyValue", " propertyPath", " propertyStr", "propertyNames", "propertyPart", " propertyPart", "propPart", "propertyPath", " propertyValue", "PropertyPath", " propertyNames", "PropertyName", " propertyString", "propString", "propStr", "propPath", "propertyStr", "propValue"], "urlStr": ["urlName", "httpStr", " urlWr", "UrlName", "httpText", "urlstr", "URLName", "URLSt", " urlName", "uriName", " urlString", "httpstr", "urlText", "urlWr", "UrlSt", "Urlstr", "URLStr", "resourceSt", "URLString", "UrlText", "UrlString", "uriWr", "urlSt", "UrlWr", "uristr", "UrlStr", "uriStr", " urlSt", "URLstr", "httpName", "resourceStr", "urlString", "URLWr", " urlstr", " urlText", "resourceString"], "in": ["resource", "In", "again", "serv", "n", "c", "ini", "IN", "m", "cin", "is", "din", "inner", "bin", "input", "ic", "as", "con", "ins", "doc", "ac", "cf", "conn", "min", "inn", "p", "err", "l", "isin", "part", "init", "out", "gin", "fac", "f", "session", "i", "nin", "a", "image", "socket", "login", "ssl", "reader", "data", "r", "inc", "id", "source", "stream", "client", "src", "file"], "xmlDoc": ["webUrl", "domDoc", "mlStr", " xmlConfig", "officeStr", "webDocument", "officeDocument", "externalStr", "mlUrl", "mlDocument", "xmlConfig", "jsonDocument", "externalDocument", "domUrl", "domDocument", "jsonDoc", "mlConfig", "externalConfig", "jsonStr", "externalDoc", "webDoc", "xmlStr", " xmlDocument", "xmlUrl", "xmlDom", "domStr", "webStr", "xmlDocument", "officeDoc", "jsonDom", "officeDom", " xmlStr", " xmlDom", "mlDoc"], "url": ["resource", "fr", "string", "instance", "http", "str", "www", "input", "URL", "ll", "inst", "io", "open", "feed", "gl", "Url", "download", "client", "user", "bel", "browser", "l", "connection", "base", "ls", "server", "config", "sl", "f", "el", "image", "socket", "inf", "ssl", "reader", "data", "b", "id", "web", "uri", "stream", "buffer", "source", "src", "file"]}}
{"id1": "13439950", "id2": "22479286", "code1": "    public String readRemoteFile() throws IOException {\n        String response = \"\";\n        boolean eof = false;\n        URL url = new URL(StaticData.remoteFile);\n        InputStream is = url.openStream();\n        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n        String s;\n        s = br.readLine();\n        response = s;\n        while (!eof) {\n            try {\n                s = br.readLine();\n                if (s == null) {\n                    eof = true;\n                    br.close();\n                } else response += s;\n            } catch (EOFException eo) {\n                eof = true;\n            } catch (IOException e) {\n                System.out.println(\"IO Error : \" + e.getMessage());\n            }\n        }\n        return response;\n    }\n", "code2": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"readRemoteFile": ["loadremoteFile", "loadRemoteResponse", "readStaticFiles", "loadRemoteFiles", "loadRemoteFile", "readremotefile", "readRemoteFiles", "readLocalResponse", "loadremoteFiles", "readRemotefile", "readStaticfile", "readStaticFile", "readLocalFile", "readremoteFile", "readremoteResponse", "readStaticResponse", "loadremoteResponse", "loadremotefile", "readLocalfile", "readremoteFiles", "loadRemotefile", "readRemoteResponse", "readLocalFiles"], "response": ["message", "result", "output", "json", "ss", "out", "uri", "http", "e", "i", "offer", "line", "application", "resp", "data", "example", "service", "object", "resource", "description", "next", "array", "server", "Response", "res", "body", "api", "onse", "string", "respond", "ception", "respons", "value", "answer", "request", "results", "feed", "site", "error", "status", "content", "reply"], "url": ["ls", "org", "ref", "remote", "uri", "str", "browser", "Url", "plug", "f", "i", "l", "web", "resource", "open", "io", "base", "bel", "b", "server", "host", "URL", "rl", "zip", "sl", "fr", "ur", "stream", "impl", "file", "r", "ssl", "ob", "jar", "http"], "is": ["as", "ris", "uri", "IS", "out", "str", "was", "info", "its", "are", "iss", "i", "Is", "src", "or", "iso", "in", "ib", "close", "ir", "sr", "ip", "io", "ar", "os", "b", "it", "fs", "bs", "res", "api", "sp", "fr", "ais", "ios", "es", "r", "id", "bis", "has", "ri", "http"], "br": ["ab", "result", "bro", "bridge", "arr", "bed", "str", "browser", "bh", "bar", "bb", "fb", "buf", "mr", "i", "BR", "bl", "serv", "ib", "sr", "img", "io", "be", "ber", "b", "os", "hr", "obj", "cr", "res", "body", "sp", "rb", "dr", "ch", "gr", "fr", "stream", "orb", "iter", "rt", "tr", "r", "er", "err", "ob", "reader", "cb", "rel", "http"], "s": ["p", "ls", "source", "message", "result", "su", "sb", "ps", "lines", "str", "ss", "session", "c", "f", "sym", "bytes", "e", "i", "input", "l", "services", "single", "data", "m", "strings", "resource", "rs", "ws", "sr", "n", "shell", "g", "si", "ses", "v", "u", "b", "os", "null", "sl", "res", "string", "details", "raw", "sample", "ns", "es", "r", "t", "results", "o", "sv", "site", "S", "ssl", "sf", "js", "d", "status", "content"], "eof": ["eol", "oeoh", "geore", "eeol", "Eof", "eeoh", "yeof", "eif", "EOF", "Eef", "eoh", "oeol", "geif", "yeOF", "Eoh", "ueOF", "eeaf", "Eok", "oeof", " eOF", "Eif", "ueof", "ueaf", "Eaf", "Eol", " eef", " eom", "oeok", "Eore", " eol", "ueom", " eaf", "eOF", "eaf", "yeore", "yeif", "geof", "geOF", "eom", "eeof", "Eom", "eok", "eeok", "eore", "eeef", "eef"]}}
{"id1": "17729554", "id2": "8801182", "code1": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "code2": "    private static void downloadImages(String uriPrefix, String fileWithListOfImages, String outputDir) throws Exception {\n        Properties list = new Properties();\n        list.load(new FileInputStream(fileWithListOfImages));\n        long current = 0;\n        long startTime = System.currentTimeMillis();\n        System.out.println(\"Downloading files from \" + uriPrefix + \" to \" + outputDir);\n        System.out.println(\"Total \" + list.size() + \" files, think of 1 sec per file\");\n        System.out.println(\"Images with the same size as the 'no-image' image are ignored and not displayed\");\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            if (urlString.contains(\"=\")) throw new Exception(\"Symbol '=' found in file names, while it is reserved for denoting '/' in flat-file names\");\n        }\n        for (Iterator<Object> it = list.keySet().iterator(); it.hasNext(); ) {\n            String urlString = it.next().toString().replace('\\\\', '/');\n            URL url = new URL(uriPrefix + urlString);\n            File file = new File(outputDir + \"/\" + imageNameToFileName(urlString));\n            current++;\n            if (!file.exists()) {\n                try {\n                    BufferedInputStream in = new BufferedInputStream(url.openStream(), 64000);\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file), 64000);\n                    int c;\n                    while ((c = in.read()) != -1) {\n                        out.write(c);\n                    }\n                    out.close();\n                    in.close();\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                    System.out.println(\"saved\");\n                } catch (Exception e) {\n                    System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", FAILED, error: \" + e.getMessage());\n                }\n            } else {\n                System.out.print(current + \" /\" + list.size() + \". \" + file.getName() + \", \");\n                System.out.println(\"already exists\");\n            }\n            if (current / 100 == current / 100.0) {\n                long delta = (System.currentTimeMillis() - startTime);\n                System.out.println(\"Total time \" + delta + \" ms, \" + (delta / current) + \" ms/file\");\n            }\n        }\n        long delta = (System.currentTimeMillis() - startTime);\n        System.out.println(\"Total time \" + delta + \" ms, \" + (delta / list.size()) + \" ms/file\");\n    }\n", "label": 0, "substitutes": {"clonarFichero": ["clonarfichero", "clonarFaichero", "clonarfIChern", "clonarFaichern", "clonarFivehern", "clonarFICher", "clonarFIChero", "clonarFivehero", "clonarfICher", "clonarFicher", "clonarFicchio", "clonarficher", "clonarFiveher", "clonarfICchio", "clonarFaicchio", "clonarfichern", "clonarFivechio", "clonarFIChern", "clonarFichern", "clonarFICchio", "clonarfIChero", "clonarFaicher", "clonarficchio"], "rutaFicheroOrigen": ["rutaFichestOrigense", "rutaFicheroOpener", "rutaFichestOrigen", "rutaFicherOriginalener", "rutaFicherOrigens", "rutaFichestOriginened", "rutaFicheroOrigense", "rutaFichestOriginen", "rutaFicheroOpEN", "rutaFicheroOriginaleni", "rutaFicheroOrigener", "rutaFicheroOrigened", "rutaFicheroOpen", "rutaFicheroOpened", "rutaFicheroOrigininen", "rutaFicheroOriginalena", "rutaFicherOriginalEN", "rutaFicheroExtena", "rutaFicherOriginalen", "rutaFicheroOriginen", "rutaFicherOrigen", "rutaFicherOriginalens", "rutaFicheroOriginalEN", "rutaFicheroOriginened", "rutaFicheroOpens", "rutaFicheroOrigena", "rutaFicheroExteni", "rutaFichestOrigininen", "rutaFicheroOpense", "rutaFicheroOriginalened", "rutaFicheroOriginalinen", "rutaFicheroOriginalens", "rutaFicheroOriginalener", "rutaFicheroExtened", "rutaFicheroOpinen", "rutaFicheroOriginense", "rutaFicherOrigEN", "rutaFicheroOpeni", "rutaFichestOrigened", "rutaFicheroExten", "rutaFicheroOriginalense", "rutaFichestOriginense", "rutaFicheroOriginalen", "rutaFicheroOrigens", "rutaFicheroOpena", "rutaFicheroOrigeni", "rutaFicheroOrigEN", "rutaFicherOrigener"], "rutaFicheroDestino": ["rutaFicherRestina", "rutaFicheroDestario", "rutaFicheroDesino", "rutaFicheroDesario", "rutaFicherodestINO", "rutaFicheroRestario", "rutaFicheroRestino", "rutaFicherRestario", "rutaFicherOrigino", "rutaFicheroCampin", "rutaFicherodestin", "rutaFicheroDestINO", "rutaFicheroDesINO", "rutaFicherDestin", "rutaFicherDestino", "rutaFicheroOrigino", "rutaFicheroRestina", "rutaFicheroDestination", "rutaFicherodestino", "rutaFicheroCampination", "rutaFicheroOrigin", "rutaFicherRestino", "rutaFicherDestination", "rutaFicherodestination", "rutaFicherDestario", "rutaFicheroCampINO", "rutaFicherDestINO", "rutaFicherRestINO", "rutaFicherDestina", "rutaFicheroOrigINO", "rutaFicherOrigINO", "rutaFicherOrigin", "rutaFicheroDestin", "rutaFicherOrigination", "rutaFicheroOrigination", "rutaFicheroDestina", "rutaFicheroCampino", "rutaFicheroDesina", "rutaFicheroOrigina", "rutaFicheroOrigario", "rutaFicheroRestINO"], "salida": ["Salica", "palada", "Salidi", "malida", "salido", "salica", "Salanta", " salidas", "balida", "malanta", "slida", "palanta", "malidi", "Salida", "slidas", " salanda", "palidi", "salanta", "Salada", "saliza", "Salido", "sliza", " salica", "Saliza", "balido", "Salidas", "salidas", "salada", "malada", " salido", "balica", "slanda", " saliza", "palida", "salidi", "salanda", "balanda", "Salanda"], "canalOrigen": ["canalOrigensen", "canalsOrigEN", "canalorigens", "canalsOriginaln", "canalOrigened", "canalsOriginalensen", "canalOriginalain", "canalsOrigened", "canelOriginalun", "canalOriginalen", "canalOriginalens", "canalOriginens", "canelOriginalens", "canelOrigun", "canalSequen", "canalOrden", "canalOriginalun", "canalorigain", "canalorigened", "canalOriginen", "canalOriginaline", "canalOriginun", "canalsOriginalened", "canalSequn", "canalOrign", "canalOriginalensen", "canelOrigine", "canelOrigens", "canalOrigine", "canelOriginalen", "canalsOrigens", "canelOriginaline", "canalOrigEN", "canalorigine", "canelOrigen", "canalsOriginalen", "canalorigensen", "canalOriginaln", "canalSequens", "canalOrdn", "canalsOriginalens", "canalorigun", "canalSequEN", "canalsOrigain", "canalsOriginalEN", "canalorigen", "canalOriginine", "canalOrigun", "canalOrdens", "canalsOrigensen", "canalOrigens", "canalsOrigen", "canalOriginalEN", "canalOrigain", "canalsOrign", "canalOrdEN", "canalOriginalened", "canalsOriginalain"], "canalDestino": ["canaldestination", "canpalDestination", "canpaldestino", "canaldestri", "canalDestination", "canaldestini", "canaldestino", "canpalDestini", "canpalDestINO", "canpaldestINO", "canalCombini", "canalDestINO", "canalCombINO", "canalsDestino", "canaldestINO", "canpalDestino", "canalOrigino", "canalDestini", "canalsdestination", "canalCombino", "canalCombination", "canalsDestination", "canalDestri", "canpaldestination", "canalsdestri", "canalsDestINO", "canalsDestri", "canalOrigini", "canalsdestino", "canpaldestini", "canalsdestINO", "canalOrigination", "canalOrigINO"], "estado": ["Estar", " estados", "iestado", "Estaban", "iestada", "estano", "estaban", " estaban", "istano", "estados", " featados", " Estaid", " featada", "apestato", "istato", "Estado", " Estada", " featado", " estano", "gestada", "iestato", " Estado", "iestaban", "istaban", "gestato", " estato", "estada", "gestaban", "estato", " estaid", "apestada", " estada", "istado", "Estada", "estaid", " estar", "apestano", "istada", "istar", "estar", "gestado", " Estados", " feataid", "apestado"]}}
{"id1": "9275622", "id2": "6966398", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFolder", "moveFile", " copyfile", "moveFolder", "copyfile", "transferfile", "moveFiles", "copyFolder", " copyFiles", " copyFolder", "transferFiles", "movefile", "copyFiles", "transferFile"], "_file1": ["_f1", "_mail2", "_resource1", "_mail1", "_fileone", "_zip1", "_mail0", "_resourceFirst", "_zipFirst", "_fFirst", "_file0", "_fOne", "_files2", "_files1", "_File0", "_resourceone", "_files01", "_fileFirst", "_zipOne", "_mail01", "_zipone", "_fone", "_File1", "_files0", "_File2", "_File01", "_file01", "_fileOne", "_resourceOne"], "_file2": [" _files3", "_playsecond", " _files2", " _filesTwo", "_filesecond", "_playTwo", " _files4", "jmodel2", "_model5", " _fileTwo", "_files3", "jmodelsecond", "_files2", "_play1", "jmodel1", "jmodel5", "_Filesecond", "_modelsecond", " _file4", "_files4", "jfilesecond", "jfile1", "_model1", "jfile2", "_filesTwo", "_file5", "_play2", "_model2", "_play4", "_file4", "_File2", "_File1", "_file3", "_fileTwo", "jfile5", "_play5", " _file3", "_File5", "_play3"], "fis": ["Fris", "fais", " fais", " fris", "cfas", "cfis", "fi", " fiss", "fris", "Fils", "lfis", "infis", "infiss", "lfiss", "infos", "lfi", "afis", "afais", "cfos", "lfais", " fi", "Fis", "Fos", "Fas", "afi", "infils", " fas", "fas", "cfiss", "cfris", " fils", "fiss", "afiss", "Fiss", "fils"], "fos": ["gis", " faos", "pOS", "info", " fros", " foos", "lis", "flos", "poes", "infaos", "fros", "infoos", "infus", "feis", "Fus", "foos", "loes", "floes", "feus", "fus", "infos", "infros", " fus", "infios", "pis", "Foos", "gos", "flis", "goses", "foses", "Fis", "Fos", "Fros", "fios", "fo", "pos", "gus", "flOS", "feoses", "lOS", "Fo", "Foses", " fo", "Fios", "los", "feos", "faos", " fios", "foes", "Faos", "fOS"], "canalFuente": ["canalKuence", "canalBuje", "canalBuence", "canalFuje", "canalsFuento", "canalsBuence", "canalsFuente", "canalBuestro", "canalKuencia", "canallBuze", "canalFUje", "canallFuencia", "canalSuente", "canalFUencia", "canaledFuestro", "canallBuence", "canalBuze", "canalsBuencia", "canalFuze", "canalsBuento", "canalFUente", "canalKuento", "canallBuencia", "canalsBuente", "canaledFuze", "canalSuze", "canalCraente", "canalFuestro", "canalFUze", "canalKuze", "canalsFuence", "canalFUestro", "canaledFuje", "canalKuente", "canalBuente", "canaledBuestro", "canalFuence", "canalSuestro", "canaledFuente", "canallFuente", "canaledBuente", "canallBuente", "canalFuento", "canalsFuencia", "canalCraencia", "canaledBuze", "canallFuence", "canalBuencia", "canalCraento", "canalFuencia", "canalBuento", "canalFUence", "canaledBuje", "canallFuze", "canalSuje", "canalCraence"]}}
{"id1": "17158020", "id2": "8788371", "code1": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encryptpassword", "decryptpassword", "decryptPass", "decryptString", "encressPassword", "encipherPassword", "encipherString", "encresspassword", "decipherPass", "encressString", "encipherPass", "encipherpassword", "encryptString", "decipherpassword", "encressPass", "decipherPassword", "decipherString", "decryptPassword", "encryptPass"], "passwordString": ["PasswordString", " passwordBytes", "passText", " passwordPassword", "PasswordText", "passwordText", "PasswordBytes", " passwordText", "PasswordStr", "passPassword", "passwordStr", "passwordBytes", " passwordStr", "passBytes", "PasswordPassword", "passString", "passwordPassword", "passStr"], "digest": [" digested", "mainit", "Digse", "digit", "signEST", "generer", "signest", "heder", "mainest", " digse", "compested", "hedester", "compest", "signse", "digEST", "mainested", "diggest", " digester", "Diggest", "digester", " diggest", " digEST", " digHash", "mainHash", "digse", " digit", "DigEST", "digested", "Diger", "Digester", "digHash", "signester", "diger", "Digest", " diger", "signer", "compHash", "Digested", "genergest", "compit", "hedest", "hedested", "generester", "generest"], "raw": ["dec", "wrap", "unsigned", "clean", "ng", "local", "RAW", "feed", "load", "none", "row", "input", "out", "aws", "binary", "rew", "original", "image", "missing", "hex", "serial", "pure", "Raw", "null", "unknown", "empty", "enc", "block", "buffer", "array", "alpha", "wrapper", "channel", "secret", "shared", "instance", "random", "full", "initial", "temp"], "hash": ["url", "header", "sha", "base", "ash", "cache", "rh", "id", "Hash", "utf", "index", "row", "input", "response", "kh", "image", "hex", "ashes", "ruby", "auth", "html", "hed", "block", "her", "message", "array", "version", "key", "mac", "h", "sh", "data", "secret", "pass", "sum", "ha", "dig"]}}
{"id1": "19944975", "id2": "5299276", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["saveConfig", "writeConfig", " writeConfig", " writeReport", "writeReport", "WriteReport", "WriteConfiguration", "WriteSection", " writeSection", "saveConfiguration", "saveSection", "saveReport", "WriteConfig", "writeSection"], "out": ["err", "pool", "resource", "base", "o", "temp", "prefix", "this", "inner", "flush", "w", "write", "plain", "project", "at", "obj", "window", "exp", "exec", "filename", "output", "OUT", "password", "writer", "conn", "list", "object", "key", "sync", "scope", "string", "c", "IN", "external", "again", "outs", "path", "m", "line", "io", "Out", "client", "xml", "report", "name", "init", "inas", "ext", "dump", "server", "user", "file", "ex", "reader", "res", "lib", "connection", "config", "parent"], "url": ["image", "URL", "base", "resource", "service", "feed", "stream", "Url", "open", "channel", "http", "l", "b", "api", "conn", "object", "page", "string", "r", "path", "io", "rel", "org", "uri", "xml", "location", "ssl", "server", "data", "file", "ll", "ob", "sl", "connection", "config", "source", "web", "f", "address"], "in": ["ini", "err", "kin", "resource", "login", "serv", "stream", "gin", "inner", "inn", "input", "In", "inc", "cms", "bin", "b", "conn", "c", "pin", "r", "IN", "again", "source", "nin", "cin", "min", "ins", "is", "xml", "as", "lin", "socket", "inas", "ssl", "a", "inside", "ac", "data", "rin", "isin", "file", "id", "i", "reader", "win", "n", "din", "f", "copy", "s"]}}
{"id1": "11645260", "id2": "17029388", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "code2": "    public static InputStream getConfigIs(String path, String name) throws ProgrammerException, DesignerException, UserException {\n        InputStream is = null;\n        try {\n            URL url = getConfigResource(new MonadUri(path).append(name));\n            if (url != null) {\n                is = url.openStream();\n            }\n        } catch (IOException e) {\n            throw new ProgrammerException(e);\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"doGet": ["doRead", "doGET", " doGET", " doPut", "partialGet", "handleRead", "doPut", "handlePut", "partialGET", "handleGet", "partialPut", "handleGET", "partialRead", " doRead"], "request": ["next", "image", "position", "in", "client", "require", "service", "query", "hello", "worker", "queue", "key", "host", "order", "object", "view", "current", "context", "user", "input", "instance", "version", "reference", "e", "enter", "server", "complete", "child", "info", "result", "connection", "resource", "report", "message", "path", "xml", "post", "req", "forward", "this", "rest", "model", "data", "type", "session", "subject", "application", "requ", "method", "call", "name", "Request", "external", "reader", "project", "string", "web", "QUEST", "uri", "event", "join", "create", "authorized", "right", "condition"], "response": ["image", "success", "error", "client", "writer", "service", "fire", "host", "output", "reply", "view", "object", "feed", "queue", "respons", "user", "version", "parent", "environment", "page", "server", "json", "complete", "cache", "result", "connection", "http", "resource", "message", "report", "results", "esi", "Response", "function", "manager", "resp", "ception", "this", "api", "onse", "model", "session", "subject", "status", "application", "wave", "document", "res", "site", "body", "respond", "remote", "event", "re"], "target": ["blank", "timeout", "template", "component", "src", "host", "output", "pattern", "object", "context", "parent", "route", "port", "address", "home", "open", "replace", "loc", "result", "format", "location", "content", "path", "resource", "params", "top", "dest", "root", "base", "session", "type", "Target", "range", "rel", "shadow", "token", "test", "force", "it", "name", "bean", "site", "external", "arget", "remote", "href", "project", "follow", "point", "head", "uri", "join", "source"], "requestUrl": [" requestHost", "requestHost", "raiseUrl", "requestEl", " requestURL", "queryURL", "nextLocation", "adjustLocation", "adjustUrl", "nextURL", "nextEl", "queryEl", "adjustHost", "raiseElement", "requestElement", " requestEl", " requestElement", "adjustElement", "queryUrl", "queryLocation", "requestURL", "raiseLocation", "raiseHost", "requestLocation", " requestLocation"], "en": ["env", "ne", "in", "an", "m", "de", "enn", "n", "EN", "eni", "ane", "el", "eng", "een", "fen", "e", "on", "ener", "ens", " e", "es", "ann", "que", "ven", "den", "esi", " EN", "oa", "len", "end", "wen", "enc", "ena", "set", " En", "pe", "ren", "er", "En", "ent", "ern", "un", "et", "ae", "gen", "au", "ec"], "nextUrl": ["NextLine", " nextURL", " nextLine", "nextURL", "nextPage", "newLine", "nextEl", "NextUrl", " nextEl", "NextURL", "NextEl", "NextPage", "nextLine", " nextPage", "newURL", "newEl", "newPage", "newUrl"], "allowedToAccess": ["allowedTooAccess", "allowedtoAuth", "allowedTOAuth", "allowedTOAccess", " allowedtoAccess", " allowedToAuth", " allowedtoaccess", "allowedFromRead", " allowedTOAccess", " allowedTOaccess", " allowedtoRead", "allowedTooAuth", "allowedToRead", "allowedtoaccess", "allowedFromaccess", "allowedToaccess", " allowedToaccess", " allowedtoAuth", " allowedTORead", "allowedTOaccess", "allowedtoRead", "allowedTORead", "allowedTooRead", "allowedtoAccess", " allowedToRead", "allowedFromAccess", "allowedToAuth"], "is": ["get", "image", "os", "in", "ip", "ai", "Is", "us", "p", "ic", "ie", "isl", "iso", "isa", "src", "i", "bs", "s", "app", "its", "was", "ib", "bb", "ls", "id", "ci", "isi", "address", "ris", "conn", "loc", "IS", "info", "ui", "or", "iss", "cos", "ios", "inner", "isc", "ori", "http", "ob", "has", "ir", "ais", "abs", "close", "api", "serv", "ri", "does", "can", "ack", "over", "it", "ins", "ops", "vs", "browser", "as", "ise", "web", "cms", "uri", "iv", "up"], "out": ["Out", "get", "error", "in", "timeout", "client", "writer", "image", "sync", "obj", "off", "block", "gin", "up", "output", "socket", "object", "app", "init", "ou", "parent", "ex", "cache", "to", "conn", "group", "cos", "exp", "path", "inner", "ext", "io", "resource", "not", "pool", "con", "o", "no", "exec", "err", "temp", "log", "can", "co", "name", "bin", "again", "as", "remote", "c", "outs", "outer", "lock", "win", "external", "OUT", "ac", "inc"], "url": ["get", "image", "blog", "client", "sl", "ul", "stream", "host", "rc", "impl", "user", "bug", "page", "server", "loc", "bc", "connection", "http", "URL", "resource", "path", "cur", "ssl", "f", "Url", "channel", "base", "plug", "log", "l", "mount", "web", "ur", "uri", "c", "source", "config", "www"], "uc": ["in", "sc", "client", "su", "union", "auc", "us", "cus", "ul", "cci", "up", "rc", "unic", "cc", "ou", "lc", "ci", "ud", "uca", "conn", "loc", "um", "bc", "nc", "http", "connection", "path", "oc", "con", "fc", "xc", "ub", "UC", "uci", "uu", "unc", "ac", "ucc", "cv", "soc", "pc", "anc", "mc", "usc", "uri", "self", "c", "ec"], "buf": ["pad", "buffer", "cas", "seq", "bytes", "batch", "bf", "br", "ctx", "block", "queue", "ff", "fd", "lb", "rc", "map", "cat", "bb", "cf", "loc", "bc", "rb", "af", "fb", "buff", "pool", "av", "box", "bag", "len", "bd", "bh", "wb", "vec", "data", "b", "cv", "cap", "uf", "ba", "ucc", "bin", "cmd", "cb"], "bytesRead": ["bytesWrite", "BytesHave", "bitsTotal", "bitsWritten", " bytesWritten", "bytesread", "BytesRead", "bitsRead", "unitsWritten", "wordsread", "bytesHave", "tesWritten", "bytesTotal", "secondsWrite", "BytesWrite", "bytesCopy", "unitsRead", "tesTotal", " bytesHave", "tesread", "tesRead", "bitsread", "bytesWritten", "secondsread", "tesCopy", " bytesWrite", "unitsWrite", "wordsWrite", "tesWrite", " bytesread", " bytesTotal", "wordsCopy", "BytesWritten", "unitsHave", "wordsRead", "secondsCopy", "secondsRead"]}}
{"id1": "19335986", "id2": "19687456", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["uncatchedexc", "unchandledexc", "Catchedexc", "uncatchedEvent", "uncatchedException", "CaughtEvent", "unchandledEvent", "unchandledException", "Caughtexc", "uncaughtexc", "uncachedException", "CatchedException", "CatchedEvent", "uncachedexc", "uncachedEvent", "uncaughtEvent", "CaughtException"], "t": [" td", "ty", "n", "c", "g", "m", "te", "d", "title", "tree", " T", "let", "ed", "tr", "ing", "p", "it", "l", "w", "s", "out", "f", "tx", "ts", "type", "r", "T"], "e": ["eu", "fe", "c", "oe", "m", "environment", "o", "d", "ee", "ge", "be", "enter", "ce", "ed", "er", "eb", "ie", "Exception", "err", "p", "ception", "s", "element", "pe", "event", "j", "exc", "f", "E", "ele", "ep", "code", "i", "el", "example", "ne", "se", "error", "data", "ae", "ev", "diff", "r", "esi", "en", "de", "es", "ec", "me", "ace"], "display": ["fe", "dis", "status", "window", "container", "position", "description", "host", "panel", "view", "d", "report", "screen", "platform", "process", "this", "design", "summary", "content", "object", "Display", "play", "p", "profile", "default", "app", "show", "layout", "config", "scroll", "hide", "image", "page", "style", "de", "me", "body", "console", "monitor"], "shell": ["mail", "status", "live", "ml", "container", "sh", "m", "host", "environment", "gui", "xml", "sym", "tool", "copy", "log", "tools", "process", "child", "sound", "Shell", "bash", "cl", "l", "app", "exec", "clone", "server", "math", "system", "help", "sb", "machine", "cli", "hell", "el", "image", "h", "kernel", "echo", "b", "loop", "launch", "lock", "buffer", "body", "console", " Shell", "poll"], "message": [" exception", "mail", "application", "status", "media", "description", "management", "m", "request", " messenger", "view", "xml", "response", "copy", "essage", "msg", "log", "report", "queue", "mess", "summary", "email", "object", "content", "address", "header", "translation", "flash", "document", "model", "event", "server", "Message", "value", "image", "page", "member", "result", "output", "error", "data", "meter", "buffer", "update", "body", "console", "monitor"], "e1": ["exc8", "exc1", "E2", " e2", "e8", "E8", "e2", "exc2", "exc3", " e8", " e3", "e3", "E1", "E3"]}}
{"id1": "15241397", "id2": "3731077", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doGet": ["handlePut", "handleget", " doGET", "didPut", "doget", "doGET", " doPut", " doget", "doPut", "handleGET", "didGET", "handleGet", "didget", "didGet"], "request": ["resource", "application", "subject", "instance", "initial", "context", "method", "xml", "Request", "http", "input", "report", "queue", "user", "object", "er", "connection", "document", "event", "server", "url", "query", "complete", "received", "image", "result", "reader", "data", "type", "req", "QUEST", "message", "info", "uri", "buffer", "client", "web"], "response": ["Response", "resource", "application", "status", "function", "full", "respond", "host", "site", "reply", "results", "view", "version", "report", "wave", "onse", "queue", "json", "object", "resp", "connection", "document", "generation", "out", "model", "server", "pool", "other", "session", "image", "writer", "result", "page", "next", "output", "error", "data", "esi", "message", "parent", "client", "body", "collection"], "rewrittenQueryString": ["rewrittenRequestService", "rewrittenqueryText", "rewwrittenQueryStr", "rewrittenqueryString", "rewrittenUrlLine", "rewwrittenQueryLine", "rewwrittenRequestArray", "rewrittenQuestionList", "rewrittenqueryService", "rewrittenUrlService", "rewrittenRequestString", "rewrittenUrlString", "rewrittenQueryText", "rewwrittenQueryString", "rewrittenPageArray", "rewwrittenRequestService", "rewrittenQuestionLine", "rewwrittenRequestStr", "rewrittenRequestList", "rewrittenPageList", "rewrittenQuestionText", "rewrittenQueryList", "rewrittenRequestText", "rewwrittenRequestText", "rewrittenQueryArray", "rewrittenQuestionArray", "rewwrittenRequestList", "rewrittenqueryStr", "rewwrittenQueryService", "rewwrittenRequestString", "rewrittenRequestLine", "rewrittenQueryStr", "rewrittenQueryService", "rewwrittenQueryList", "rewrittenPageString", "rewrittenQuestionStr", "rewwrittenRequestLine", "rewrittenRequestStr", "rewrittenPageLine", "rewwrittenQueryArray", "rewrittenRequestArray", "rewrittenqueryLine", "rewrittenQuestionString", "rewrittenQueryLine", "rewrittenUrlText", "rewwrittenQueryText"], "rewrittenUrl": ["rewwrittenJar", "RewwrittenJar", "rewrittenJar", "rewcraftedUrl", "RewrittenURL", "RewrittenServer", "RewwrittenServer", "rewardedLocation", "rewriteServer", "rewwrittenLanguage", "rerittenUrl", "rewrittenLanguage", "rerittenUr", "rewedUrl", "rewrittenLocation", "rewwrittenServer", "rewardedInt", "rewriteText", "rewatchedUrl", "rewatchedServer", "rewwrittenLocation", "RewrittenFile", "rewodedLanguage", "RewwrittenURL", "rewwrittenurl", "RewrittenInt", "Rewwrittenurl", "rewrapedFile", "rewatchedText", "rewriteUrl", "rewrittenUr", "rewmatchedFile", "rewrapedUr", "rewcraftedUr", "rewmatchedurl", "RewrittenUrl", "rerittenFile", "rewrittenURL", "rewrittenFile", "RewwrittenFile", "rewcraftedURL", "RewwrittenText", "RewrittenLocation", "rewilledJar", "rewrittenInt", "rewardedUr", "rewrittenText", "rewedFile", "rewmatchedURL", "rerittenLanguage", "rewatchedURL", "RewwrittenUr", "rewilledInt", "rewcraftedLocation", "RewwrittenUrl", "RewrittenText", "RewwrittenInt", "RewwrittenLocation", "rewilledURL", "RewrittenUr", "rerittenURL", "rewilledUrl", "rewriteURL", "rewodedFile", "Rewrittenurl", "rewwrittenURL", "rewardedLanguage", "rewardedFile", "rewedURL", "rewardedURL", "rewmatchedUrl", "rewardedUrl", "rewodedURL", "rewodedUrl", "rewedurl", "rewwrittenInt", "rewwrittenText", "rewrittenServer", "rewwrittenUrl", "rewardedJar", "rewwrittenFile", "rewrittenurl", "RewrittenJar", "rewrapedURL", "rewrapedUrl", "rewwrittenUr", "rewedUr"], "httpURLConnection": ["httpGEConnection", "apacheGEconnection", "apacheURLConnection", "httpurlConnect", "httpStreamconnection", "httpURIConnect", "apacheGEConnect", " httpStreamSession", "httpELConn", "httpURConn", "webURLConn", "httpSSLClient", " httpURLSession", " httpURLCurrent", "webURLClient", "httpGEFlow", "httpSSLConn", "apacheGEConnection", " httpURConn", "HttpURLService", "apacheURLconnection", "webSSLClient", "httpUrlConnect", " httpStreamconnection", "httpURconnection", "httpURLService", "httpurlCode", "httpUrlconnection", " httpURLConnect", "httpChannelConnection", "httpWebConnection", "httpSSLContext", "httpWebConnect", "httpURLSession", "webURLContext", "httpChannelService", "httpWebConn", "httpURLClient", "httpurlCurrent", "httpURIFlow", "httpUrlCode", "httpurlconnection", "httpCLCode", "httpUrlClient", " httpStreamConnection", " httpURLCode", "HttpChannelService", "httpUrlContext", "httpCLConnection", "httpURIClient", " httpURConnect", "httpChannelConnect", "httpGEConnect", "httpURConnect", "httpURLFlow", "httpPathCurrent", "httpURLconnection", "HttpURLConnection", "httpELConnection", "apacheGEFlow", " httpUrlConn", " httpURLConn", "HttpURLConnect", "httpPathconnection", " httpURConnection", " httpURLconnection", "httpELConnect", "HttpChannelConnect", "httpStreamConnection", "HttpURLconnection", "httpurlConnection", "httpurlFlow", "httpurlSession", "httpPathConnection", "apacheURLConnect", "httpChannelconnection", "httpURLContext", "httpURConnection", "httpUrlConn", "httpURLCurrent", "HttpChannelConnection", "httpGEconnection", "httpURIconnection", "httpPathSession", "httpUrlService", "httpURService", "httpCLConn", "httpURLConnect", "httpURIConnection", "httpStreamCurrent", "httpSSLConnection", "webSSLContext", "httpStreamSession", "httpURLConn", "httpUrlConnection", "httpURLCode", "HttpChannelconnection", "webURLConnection", "apacheURLFlow", "webSSLConnection", "httpURIConn", " httpUrlCode", " httpUrlConnection", "webSSLConn", " httpStreamCurrent", "httpurlConn", "httpURIContext"], "header": ["item", "entry", "group", "attribute", "token", "section", "line", "function", "player", "string", "channel", "ter", "character", "cover", "headers", "comment", "layer", "outer", "after", "match", "key", "list", "queue", "driver", "pair", "second", "bridge", "er", "handler", "default", "rule", "document", "part", "Header", "event", "consumer", "server", "component", "dr", "definition", "index", "iter", "date", "field", "director", "head", "feature", "her", "hash", "writer", "filter", "result", "next", "member", "author", "data", "error", "metadata", "message", "info", "buffer", "back", "master", "block", "column", "version", "reference"], "value": ["item", "property", "entry", "attribute", "media", "function", "description", "string", "current", "option", "values", "expression", "version", "comment", "language", "label", "key", "json", "content", "object", "letter", "child", "valid", "default", "document", "hello", "element", "model", "server", "variable", "get", "office", "now", "field", "V", "Value", "set", "password", "format", "val", "v", "gi", "VALUE", "data", "type", "sv", "message", "info", "parent", "text", "name", "end"], "inputStream": ["outputSteam", "outputChannel", "resourceSteam", "pullSteam", "inputChannel", "outputStreamer", "InputChannel", "pullStreamer", "resourceChannel", "inputstream", "pullStream", "inputStreamer", "InputSteam", "resourceStream", "Inputstream", "pullstream", "resourcestream", "InputStreamer", "InputStream", "outputstream", "inputSteam"], "outputStream": ["responseSteam", "Outputstream", "outputSteam", "OutputStream", "outputChannel", "responseFile", "responseStream", "externalstream", " outputChannel", "outputStreamer", "outputFile", "OutputFile", " outputSteam", "inputstream", "OutputStreamer", "inputStreamer", "externalStream", "OutputSteam", "externalSteam", " outputFile", "externalStreamer", "responseChannel", "OutputChannel", "outputstream", "inputSteam"]}}
{"id1": "6906419", "id2": "3187685", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["encryptpassword", "decryptpassword", "encrateHash", "decryptString", "encipherPassword", "decipherHash", "encipherString", "enccryptString", "enccryptpassword", "encratepassword", "encratePassword", "decryptHash", "encryptHash", "enccryptPassword", "encipherpassword", "encipherHash", "encryptString", "decipherpassword", "enccryptHash", "encrateString", "decipherPassword", "decipherString", "decryptPassword"], "password": ["address", "token", "Password", "project", "sword", "path", "input", "pattern", "string", "name", "seed", "word", "prefix", "database", "auth", "words", "username", "crypt", "confirmed", "user", "text", "padding", "buffer", "message", "array", "p", "wd", "key", "content", " passwords", "phrase", "data", "PASS", "secret", "pass"], "digest": [" digested", "diffester", "initText", " digText", "hashest", "signEST", "signest", "initest", "digeter", "digText", " digests", "digEST", " digester", "digester", " digEST", "digests", "DigText", "Digests", "diffEST", "diffest", "diffested", "hasher", "DigEST", "digested", "initests", "Diger", "Digester", "hasheter", "hashester", "signester", " digeter", "diger", "Digest", " diger", "signer", "Digested", "initEST", "Digeter"], "hash": ["map", "address", "url", "header", "sha", "error", "ash", "cache", "handle", "bin", "id", "cover", "check", "Hash", "log", "mask", "index", "kh", "bug", "memory", "image", "hex", "ashes", "build", "code", "auth", "batch", "html", "count", "history", "number", "body", "hed", "query", "diff", "block", "buffer", "array", "message", "version", "wave", "key", "h", "search", "sh", "filter", "char", "match", "bh", "secret", "value", "f", "sum", "ha"], "buf": ["Buffer", "uf", "fp", "bc", "v", "cap", "url", "vec", "img", "uc", "vr", "builder", "bb", "aux", "ob", "bin", "tmp", "port", "cv", "nb", "func", "db", "cur", "ctx", "fb", "ba", "out", "conv", "queue", "pkg", "uv", "bag", "buff", "sb", "box", "Buff", "uber", "b", "abb", "config", "pad", "wb", "buffer", "ab", "la", "rb", "cas", "af", "data", "pb", "append", "bh", "va", "fw", "coll", "bf", "src", "abc", "runner", "home", "cb", "f", "bu", "cmp"], "i": ["qi", "v", "ip", "ai", "ti", "mini", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "length", "li", "u", "ui", "hi", "multi", "ci", "c", "uni", "si", "phi", "ii", "j", "type", "a", "count", "info", "ie", "b", "n", "o", "slice", "ri", "uri", "p", "key", "gi", "h", "ix", "abi", "fi", "l", "oi", "di", "it", "init", "d", "ji", "mu", "f", "pi"], "halfbyte": ["superbit", "halfurl", "thirdsecond", "thirdnumber", "postbit", "quarterurl", "littlebit", " halfbit", " halfreference", "quarterByte", "Halfbit", "littleByte", "littlereference", "thirdbyte", "superchar", "wardurl", " halfnumber", " halfchar", "superbyte", "quarterbyte", "postbyte", "halfnumber", "halfsecond", " halfByte", "quarterbytes", "sideByte", "quartersecond", "sidebyte", "HalfByte", "Halfbyte", "halfbytes", "quarternumber", "wardbyte", " halfurl", "Halfchar", "halfByte", "sidereference", "halfabyte", "sidebit", "postabyte", " halfsecond", "halfbit", "quarterbit", "littlebyte", " halfabyte", "wardbytes", "halfreference", "quarterabyte", " halfbytes", "halfchar"], "two_halfs": ["two_commonrows", "two_halfions", "two_quarterows", "two_hatows", "two_Halfrows", "two_Halfs", "two_thirdbytes", "two_quarters", "two_quarterrows", "two_halfbytes", "two_halfows", "two_halfis", "two_hatrows", "two_parts", "two_commons", "two_partrows", "two_thirdrows", "two_commonions", "two_commonows", "two_hats", "two_partbytes", "two_halfrows", "two_Halfbytes", "two_thirdis", "two_hations", "two_quarterions", "two_thirds", "two_Halfis", "two_partis"]}}
{"id1": "17522011", "id2": "17207832", "code1": "    public static String read(ClassLoader classLoader, String name, boolean all) throws IOException {\n        if (all) {\n            StringMaker sm = new StringMaker();\n            Enumeration enu = classLoader.getResources(name);\n            while (enu.hasMoreElements()) {\n                URL url = (URL) enu.nextElement();\n                InputStream is = url.openStream();\n                String s = read(is);\n                if (s != null) {\n                    sm.append(s);\n                    sm.append(StringPool.NEW_LINE);\n                }\n                is.close();\n            }\n            return sm.toString().trim();\n        } else {\n            InputStream is = classLoader.getResourceAsStream(name);\n            String s = read(is);\n            is.close();\n            return s;\n        }\n    }\n", "code2": "    @Test\n    public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception {\n        Exception e = new UnsuccessfulResponseException(resp);\n        expect(mockBackend.execute(host, req, ctx)).andThrow(e);\n        replay(mockBackend);\n        HttpResponse result = impl.execute(host, req, ctx);\n        verify(mockBackend);\n        assertSame(resp, result);\n    }\n", "label": 0, "substitutes": {"read": ["work", "create", "Read", "reading", "parse", "check", "invoke", "load", "use", "READ", "input", "send", "default", "process", "build", "resources", "readable", "data", "resource", "open", "play", "find", "print", "connect", "class", "add", "exec", "report", "reads", "eval", "write", "include", "feed", "reader", "type", "get", "start", "select", "run"], "classLoader": ["ClassPath", "resourceloader", "fileLoader", "fileDir", "filePath", "ClassLoad", "Classloader", "classLoad", " classloader", " classReader", " classLoad", "resourceReader", " classLoading", "classLoading", "fileloader", "ClassLoader", "classPath", "classloader", "classDir", "resourceLoader", " classDir", " classPath", "classReader", "fileLoad", "ClassDir", "ClassReader", "resourceLoading", "ClassLoading"], "name": ["x", "filename", "large", "str", "path", "ame", "alias", "NAME", "home", "pass", "root", "word", "Name", "image", "none", "default", "data", "names", "resource", "comment", "old", "n", "class", "base", "search", "null", "code", "child", "address", "time", "string", "connection", "size", "prefix", "named", "file", "value", "part", "key", "id", "type", "parent", "no", "active"], "all": ["local", "call", "app", "al", "sync", "at", "f", "this", "not", "with", "pass", "one", "l", "none", "global", "process", "left", "total", "and", "ann", "array", "allow", "All", "each", "ALL", "list", "alpha", "full", "batch", "only", "auto", "both", "sort", "am", "attribute", "named", "part", "partial", "any", "apply", "alls", "active"], "sm": ["source", "hm", "sim", "smith", "sy", "su", "sb", "sw", "so", "im", "ss", "mm", "Sm", "sym", "imm", "ama", "serv", "m", "fm", "nm", "service", "sr", "asm", "sa", "si", "rm", "em", "ms", "vm", "zip", "sl", "api", "gm", "sp", "sk", "tm", "om", "bm", "cm", "mo", "sh", "sum", "sn", "SM", "km", "wm", "sam", "spe", "sf", "sv", "ym"], "enu": ["munun", "ENc", "enus", " enus", "ennu", "Enu", "ENu", "EnU", "enun", "Encu", "anus", " ennu", "anU", "ENus", "Enus", "venus", "Enc", "enou", "anun", "munU", "munus", "Enun", "munu", "ENou", "venou", "Enou", " encu", "encu", "Ennu", "ennnu", "ennus", "anu", "enc", "enncu", "enU", "venc", "venu"], "url": ["ls", "source", "uri", "str", "browser", "path", "Url", "plug", "f", "download", "page", "i", "l", "image", "loc", "loader", "web", "in", "resource", "base", "job", "server", "URL", "zip", "sl", "address", "li", "string", "connection", "ur", "layer", "ll", "impl", "file", "pull", "ssl", "r", "key", "id", "rel", "http"], "is": ["p", "ls", "mis", "as", "ris", "app", "init", "uri", "IS", "isa", "was", "im", "us", "inner", "info", "ii", "ori", "its", "il", "are", "iss", "i", "js", "Is", "ie", "serv", "image", "or", "iso", "ic", "web", "in", "lis", "close", "ir", "vs", "act", "ip", "io", "ar", "si", "os", "it", "esi", "isc", "isl", "api", "isi", "ins", "ais", "ios", "es", "abs", "iris", "ignore", "id", "bis", "has", "ri", "cms", "ops", "ois", "http"], "s": ["p", "ls", "cs", "su", "sb", "ps", "ts", "ss", "se", "lines", "session", "c", "ips", "f", "its", "als", "w", "e", "sg", "i", "l", "services", "ds", "ans", "les", "m", "strings", "rs", "ws", "storage", "n", "g", "ks", "si", "ses", "ms", "os", "u", "spec", "ies", "ments", "sc", "sl", "string", "ins", "h", "ches", "details", "gs", "ings", "outs", "sets", "ns", "ows", "es", "abs", "ssl", "r", "results", "sf", "o", "sv", "comments", "S", "ions", "js", "d", "rows"]}}
{"id1": "15768167", "id2": "17116123", "code1": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyStream", "transferStream", " copyStream", "copyFiles", "copyfile", "CopyStream", "transferFile", "transferFiles", "CopyFile", "Copyfile"], "in": ["image", "m", "buffer", "p", "inn", "isin", "i", "is", "input", "id", "ex", "diff", "inner", "index", "resource", "io", "work", "at", "file", "min", "f", "url", "base", "login", "data", "ac", "b", "ins", "name", "bin", "In", "reader", "IN", "d", "again", "lock", "source", "c", "inc"], "out": ["Out", "image", "client", "writer", "buffer", "p", "obj", "off", "output", "object", "parent", "ex", "server", "cache", "conn", "to", "target", "result", "resource", "io", "line", "file", "dest", "part", "at", "dot", "o", "prefix", "base", "exec", "data", "err", "temp", "b", "v", "w", "name", "project", "string", "again", "outs", "source", "OUT", "c"], "sourceChannel": ["srcLog", "srcChannel", "SourceStream", "srcChan", "ourceChan", "sourceChan", " sourceStream", "resourceContext", "serviceConnection", "inputChannel", " sourceSocket", "resourceChannel", "ourcechannel", "inputContext", " sourceLog", "sourceContext", "targetStream", "sourceBuffer", "srcchannel", "ourceChannel", "targetChannel", "resourceFeed", "sourceLog", "targetchannel", " sourceService", "resourceConnection", "targetChan", " sourceBuffer", "ourceService", "sourceStream", "resourceService", "resourcechannel", "serviceChannel", "sourceConnection", "SourceLog", "inputChan", " sourceChan", "targetBuffer", " sourceContext", "SourceBuffer", " sourcechannel", "SourceChannel", "ourceSocket", " sourceConnection", "servicechannel", "serviceSocket", "sourceService", " sourceFeed", "resourceChan", "targetConnection", "Sourcechannel", "ourceConnection", "inputFeed", "sourceFeed", "sourcechannel", "SourceChan", "sourceSocket"], "destinationChannel": ["DestinationStream", "destinatingConnection", "DestinationChannel", "destinatorUrl", "destionchannel", "destinatedChannel", "destationChan", "desturationchannel", "destinationManager", "DestinatorUrl", "destinatedManager", "destinatingchannel", "DestinationCh", "Destinatorchannel", "destionChan", "destinatedConnection", "DestinationConnection", "destinatorConnection", "destionStream", "destinatedCh", "desturationUrl", "destinationCh", "destinatedchannel", "destationchannel", "DestinationManager", "destinatorchannel", "destinatedUrl", "destationChannel", "destationConnection", "destinationConnection", "DestinatorChannel", "destinatingChannel", "destinatorChannel", "destinationchannel", "Destinationchannel", "destationStream", "DestinatorManager", "DestinationChan", "desturationChan", "DestinatorConnection", "destionChannel", "destinationStream", "destinatorCh", "DestinationUrl", "desturationChannel", "destinatorChan", "destinatingManager", "DestinatorChan", "DestinatorCh", "destinatorManager", "destinationUrl", "destinatedChan", "DestinatorStream", "destinatorStream", "destinationChan"]}}
{"id1": "14819747", "id2": "3514286", "code1": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"debug": ["db", "enabled", "error", " DEBUG", "progress", "details", "console", "display", "help", "develop", "trace", "print", "comment", "bug", "ger", "cache", "reg", "module", " debugger", "show", "development", "real", "date", "file", "root", "build", "store", "active", "depth", "production", "die", "doc", "err", "log", " Debug", "test", "tag", "status", "admin", "quiet", "export", "github", " debugging", "plugin", "remote", "enable", "DEBUG", "play", "dev", "dump", "Debug", "config"], "prologFile": ["PrologFile", "prologfile", " prologfile", "proLogfile", "propathDir", " proLogFile", "ProLogString", "propathSourceFile", "probaseFiles", "proversionPath", "proversionSourceFile", "roLogSource", "ProLogfile", " problogfile", "prologFull", " prologFiles", "rologfile", "defblogDir", "proconfigfile", "proconfigFile", "proversionFILE", " prologHeader", "procatfile", "defblogSourceFile", "prologString", "prollFile", "deflogPath", "proLogStream", "prologHeader", " problogSourceFile", "proLogString", "propathFile", "defLogSourceFile", "rologSource", "proflowFile", "rologFile", "proflowSourceFile", "problogSourceFile", " prologFull", "problogDir", "proconfigSourceFile", "prollPath", "proversionFile", "prolexFile", "prologDir", "deflogFile", "rologPath", "proLogFull", "prolexfile", "prologFiles", "ProLogFile", "proconfigPath", "probaseFile", "proLogFile", "deflogfile", "Prologfile", "PrologString", "prolangFile", "proflowDir", " prologStream", " prologSourceFile", "proLogPath", "proflowfile", "proLogFILE", "proLogFiles", "prolangFull", "prologSourceFile", " proLogFiles", "defLogFILE", "roLogPath", "prologSource", "prolangSourceFile", "defblogfile", "deflogDir", "propathfile", "probaseHeader", "ProLogModule", "proconfigFILE", "deflogFILE", "roLogFile", "prolexString", "defblogFile", "prolangfile", " problogFile", "probaseStream", "proLogSourceFile", "prologFILE", "prologStream", "proconfigModule", "PrologModule", "prologModule", "prollSource", "defLogPath", "deflogSourceFile", "roLogfile", "problogHeader", "problogFiles", "proLogModule", "problogFile", "prologPath", "procatFile", "prolexModule", "problogStream", " proLogHeader", "proLogHeader", "defLogFile", "proLogSource", "problogfile", "procatSource", "proconfigString", " proLogStream", "procatPath", "prollfile", " problogFull", "problogFull"], "targetFile": ["targetDir", "targetDirectory", "outputPath", "outputFile", "sourcefile", "outputDir", "targetPath", "targetfile", " targetfile", "sourceFile", "sourcePath", " targetDirectory", "sourceDirectory", "targetFiles", "TargetDirectory", "sourceDir", "Targetfile", "TargetDir", " targetFiles", "TargetPath", "outputfile", "TargetFiles", "TargetFile", "sourceFiles"], "source": ["position", "template", "buffer", "service", "term", "sl", "src", "i", "class", "view", "comment", "use", "scope", "input", "slice", "proxy", "parse", "id", "json", "stack", "target", "result", "format", "content", "message", "resource", "description", "file", "Source", "str", "options", "unit", "model", "session", "data", "type", "zip", "SOURCE", "text", "language", "name", "style", "body", "string", "uri", "ource", "config"], "myParser": [" myReader", "yourParser", "MyJar", " myJar", "MyParser", "yourJar", "yourProgram", "myJar", "MyProgram", "myReader", "yourReader", "MyReader"], "myProgram": ["yourMath", "yourPlan", "MYprogram", "MyParser", "MYParser", "yourProgram", "myMath", " myprogram", "yourprogram", "MyProgram", "theParser", " myPlan", "theMath", "MyPlan", "theProgram", "myPlan", "Myprogram", " myMath", "yourParser", "theprogram", "MYProgram", "myprogram"], "myVisitor": [" myvisIT", "myVisitors", "MyVisulator", "mySignitors", "myVisIT", " myvisitors", "myDesignIT", "myDesignit", "myvisit", "myExitors", "myVISitable", "myVisulator", "myExiter", " myVisitable", " myvisit", "myAuditable", "myVisitit", "myvisiter", "Myvisitors", "myAudit", "MyVisiter", "myvisitor", "myVisititor", "myvisitable", "mySignitor", "myVisiter", "MyVisitor", "myvisulator", "myVISitor", "myDesignitable", "myvisIT", "myVisititable", "mySignulator", "myAuditor", "MyVisitors", " myvisitable", "myDesignitor", " myVisitors", "Myvisiter", " myVisIT", "myAuditors", "myExitor", "Myvisitor", "mySigniter", "myExulator", "Myvisulator", "myVisititors", "myVISit", " myvisitor", "myVisitable", "myVisit", "myvisitors", " myVisit", "myVISIT"], "adapterLayer": ["adviceFactory", "acaptersFactory", "acapterFactory", "acapterContainer", "adapterFactory", "acapterLayer", "acapterBuffer", "acaptersBuffer", "adptionInfo", "adaptersContainer", "adviceLanguage", "adviceInfo", "admissionContainer", "admissionLanguage", "adptionBuffer", "adviceLayer", "acapterInfo", "adviceBuffer", "adapterInfo", "admissionLayer", "adaptersLanguage", "adviceContainer", "adapterBuffer", "acaptersInfo", "acaptersLanguage", "adapterLanguage", "adaptersFactory", "acaptersLayer", "adaptersLayer", "adapterContainer", "acapterLanguage", "adaptersInfo", "adaptersBuffer", "acaptersContainer", "adptionFactory", "adptionLayer"], "classLoader": ["classPath", "ClassPath", "staticDir", "ClassDir", "classDir", "staticLoader", "classloader", " classDir", "ClassLoader", "staticPath", "staticloader", " classPath", " classloader", "Classloader"], "adapterWriter": ["adAdapterReader", "adapterReader", "attapterWriter", "adAdapterwriter", "adaptersReader", "adapterWrite", "attapterwriter", "adapterwriter", "adapterswriter", "adaptersWriter", "adaptersWrite", "admissionWrite", "attaptersReader", "attaptersWriter", "attapterswriter", "adAdapterWriter", "admissionReader", "attapterReader", "attaptersWrite", "adAdapterWrite", "admissionWriter", "admissionwriter", "attapterWrite"], "annotationGenerator": ["annotationgenators", "annnotationGenoder", "annotationGeneroder", "annotationGcer", "annotationGenerators", "annotationgenator", "annotationGator", "annotationgenoder", "annotationGenoder", "annnotationGenerators", "annotationGenator", "annnotationGenerator", "annnotationGenator", "annnotationGeneroder", "annotationGoder", "annnotationGenercer", "annotationGenercer", "annotationGencer", "annnotationGencer", "annotationgencer", "annnotationGenators", "annotationGenators", "annotationGators"], "out": ["Out", "error", "in", "sync", "obj", "query", "n", "flow", "output", "pre", "print", "chain", "user", "parent", "copy", "cli", "page", "server", "cache", "conn", "group", "diff", "state", "code", "array", "io", "line", "raw", "post", "down", "store", "prefix", "temp", "err", "log", "bar", "v", "net", "OUT", "again", "list", "point", "sys", "outer", "outs", "lock", "gen", "cmd", "dump", "up"]}}
{"id1": "8216539", "id2": "17792212", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    private void createButtonCopyToClipboard() {\n        buttonCopyToClipboard = new Button(shell, SWT.PUSH);\n        buttonCopyToClipboard.setText(\"Co&py to Clipboard\");\n        buttonCopyToClipboard.setLayoutData(SharedStyle.relativeToBottomRight(buttonClose));\n        buttonCopyToClipboard.addSelectionListener(new SelectionAdapter() {\n\n            @Override\n            public void widgetSelected(final SelectionEvent event) {\n                IOUtils.copyToClipboard(Version.getEnvironmentReport());\n            }\n        });\n    }\n", "label": 1, "substitutes": {"getFileContentAsString": ["getFileContentAsStr", "getFilecontentInString", "getFilecontentAsText", "getFilecontentInStream", "getFileContentInText", "getFileContentasStream", "getFileContentasStr", "getFileContentInStream", "getFileContentFromStream", "getFileContentasString", "getFilecontentAsStream", "getFileContentFromString", "getFilecontentInStr", "getFileContentAsText", "getFileContentFromText", "getFileContentAsStream", "getFilecontentAsStr", "getFileContentFromStr", "getFileContentInString", "getFileContentInStr", "getFilecontentInText", "getFileContentasText", "getFilecontentAsString"], "filePath": [" fileStr", "FilePath", "baseLocation", "baseUrl", "resourceName", "fileUrl", "resourceLocation", "basePath", "singlepath", "FileStr", "FileUrl", "resourcepath", "singleLocation", "fileName", "singlePath", " filepath", "fileStr", " fileUrl", "baseName", "baseStr", "filepath", "Filepath", "fileLocation", "FileName", "basepath", "singleUrl", "resourcePath", "FileLocation"], "encoding": ["decoded", "enclocking", "Encoded", "languageging", "Encryption", "languagepling", "encging", "decasing", "equoding", "coding", "encpling", "Encging", "decoding", "Encoding", "casing", "languageoding", "encryption", "coded", "equging", "equpling", "Enclocking", "Encpling", "Encasing", "decryption", "languagelocking", "encasing", "equlocking", "encoded", "cryption"], "testURL": ["testingURL", "appurl", "fileUrl", "testingUR", "TestUR", "fileURL", "fileRL", "testRL", "shortTL", "testingRL", "shorturl", "testUrl", "Testurl", "testTL", "testingurl", "testingURI", "appUR", "testUR", "testingUrl", "fileURI", "TestURL", "shortUrl", "appUrl", " testRL", " testTL", " testurl", "shortURL", "testURI", " testURI", "appURL", "testurl", "testingTL", "TestUrl", " testUrl"], "input": ["path", "error", "ou", "ssl", "i", "temp", "output", "resource", "feed", "qa", "enc", "rc", "entry", "http", "element", "op", "ink", "ack", "act", "current", "socket", "inner", "result", "instance", "flow", "bin", "active", "in", "dc", "raw", "form", "client", "type", "reader", "source", "binary", "Input", "connection", "inf", "inside", "upload", "inc", "config", "data", "text", "out", "parent", "through", "file", "acl", "get", "null", "conn", "init", "exec", "image", "but", "pull", "url", "stream", "audio", "ac", "wrapper", "xml", "this", "api", "img"], "sw": ["nw", "SW", "rw", "sk", "sf", "sc", "wr", "rc", "rew", "wp", "now", "fp", "ew", "wt", "sm", "en", "Sw", "wrap", "ws", "sa", "sb", "wb", "sv", "work", "w", "iw", "web", "WS", "aw", "io", "writer", "cr", "rx", "sl", "tw", "ib", " SW", "sh", "stream", "we", "wrapper", "sn", "hw", "ow", "wx", "ww"]}}
{"id1": "9109613", "id2": "20920051", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fileCopy": ["fileUpload", "folderTransfer", "foldercopy", "Filecopy", "fileTransfer", "folderUpload", "FileTransfer", " fileTransfer", " fileUpload", "folderCopy", "filecopy", "FileUpload", "FileCopy", " filecopy"], "from_name": ["fromTheword", " from_no", " from_space", "fromametime", "from_size", "from__Name", " from_key", "from_Name", "from_no", "fromTheName", "from_time", "fromFullname", "fromqName", "fromFullName", "from__name", " from_alias", "fromqname", "from_path", " from_Name", "from_address", "from_image", "from_alias", "from_filename", " from__alias", "fromFulladdress", " from_time", "from_key", " from__Name", " from_size", "fromThename", " from_image", " from__name", "from_word", " from__address", "fromameno", "from__alias", " from_path", "fromamename", "fromThespace", " from_filename", "fromqpath", " from_address", "fromameName", " from_resource", "from__address", "from_resource", "fromqfilename", "from_space", "fromFullalias", " from_word"], "to_name": ["To_common", "tokname", "to_path", "to_Name", "to_file", "to_names", "To_Name", "from_path", "to_common", "tokcommon", "from_names", "to_key", " to_file", "To_name", "tokName", "from_Name", " to_key"], "fromFile": ["asFile", "FromFile", "oneFile", "fromFolder", "oneDir", "FromLine", "onePage", " fromDirectory", " fromFunction", "sourcePage", "fromPage", "fromFiles", "onefile", "ofFolder", "fromPackage", "oneFunction", "FromFolder", "connectionFile", "autoPage", " fromPage", "toLine", "fromLine", "fromfile", "FromDir", "tofile", "oneModel", " fromFactory", "asFiles", "fromDir", " fromPackage", "oneFolder", "ofFile", " fromFolder", "fromLibrary", " fromFiles", "asfile", "fromModel", "sourceFile", "sourceLibrary", "autoFile", "asFactory", "Fromfile", "FromPage", "FromModel", "connectionPackage", "FromLibrary", " fromfile", " fromModel", "FromDirectory", "connectionfile", "sourceDirectory", "toFactory", "fromFactory", " fromLine", " fromDir", "autoFolder", "FromFiles", "ofPackage", "FromFunction", "connectionFolder", "fromDirectory", "toFiles", "fromFunction", "offile", "autofile", " fromLibrary", "toFunction"], "toFile": [" toFolder", "soPage", "fromFiles", "toLine", "ofTable", "targetfile", "tempFile", " toSourceFile", "toLibrary", "ToPlace", " toPage", "targetSourceFile", " toFunction", "ToDirectory", "toFiles", "nofile", "toPlace", "toFunction", "ofDir", "baseTable", " toFactory", "targetFolder", "noFile", "toTable", "TOPage", "coFile", "baseDir", "TOFile", "aDir", "targetPage", " toFiles", "sofile", "targetFactory", "soLibrary", "TOPlace", " toLine", " toTable", " toDirectory", "targetDir", "basefile", "targetFile", "noLibrary", "tempFolder", "fromDir", "afile", "Tofile", "ToLibrary", "toDir", "cofile", "toPage", "ToPage", "fromDirectory", "offile", "coFunction", "tempFactory", "toFolder", "toDirectory", "ToDir", "aFile", "targetPlace", "ToLine", " tofile", "fromPage", "fromLine", "noPage", "ToFiles", "fromfile", "tofile", "soFile", "ofFile", "ToFactory", "ToFile", "toSourceFile", "ToSourceFile", "aFiles", "ToFunction", "baseFile", "toFactory", " toDir", "tempfile", "coDirectory", "TODir"], "parent": ["address", "test", "pa", "port", "id", "inc", "path", "div", "session", "location", "name", "section", "g", "null", "directory", "option", "api", "p", "col", "data", "file", "server", "full", "Parent", "part", "pr", "complete", "client", "child", "term", "remote", "patch", "string", "or", "pe", "class", "user", "shape", "rule", "guard", "key", "page", "pool", "ac", "lc", "paren", "current", "valid", "pt", "parents", "large", "loc", "resource", "content", "search", "source", "home", "url", "master", "ip", "region", "exp", "owner", "out", "type", "connection", "root", "par", "any", "point", "line", "and", "manager"], "dir": ["url", "dec", "ver", "rel", "dep", "Dir", "exp", "dict", "inc", "container", "cur", "db", "path", "folder", "div", "keep", "name", "out", "ir", "lock", "doc", "lib", "build", "or", "r", "def", "root", "class", "directory", "attr", "rec", "DIR", "per", "loc", "block", "iter", "dc", "dis", "wd", "fd", "mod", "dr", "di", "col", "file", "dist", "d", "director", "coll", "die", "dev", "group", "cat", "home", "manager", "f"], "from": ["cm", "url", "de", "base", "ra", "client", "clean", "bean", "vol", "parse", "left", "e", "view", "ou", "io", "module", "when", "old", "one", "auto", "name", "conn", "out", "cr", "stream", "range", "start", "c", "link", "this", "self", "normal", "or", "component", "connection", "user", "so", "empty", "o", "with", "query", "per", "hand", "without", "flo", "fr", "wh", "api", "add", "by", "form", "get", "in", "who", "source", "channel", "file", "se", "ch", "low", "From", "con", "part", "can", "ce", "po"], "to": ["su", "two", "be", "eto", "base", "ver", "token", "cache", "output", "port", "io", "proxy", "not", "db", "one", "fb", "TO", "target", "auto", "out", "name", "on", "top", "no", "again", "tom", "or", "via", "type", "connection", "go", "b", "object", "To", "so", "o", "see", "co", "with", "sync", "flo", "office", "will", "api", "by", "plus", "copy", "store", "page", "http", "source", "op", "file", "too", "tto", "about", "until", "size", "fat", "pi", "po"], "buffer": ["Buffer", "address", "position", "result", "header", "uffer", "reader", "cache", "transfer", "feed", "vector", "available", "total", "default", "row", "border", "length", "string", "binary", "seed", "memory", "queue", "character", "read", "layer", "duration", "reference", "batch", "shape", "buf", "number", "null", "block", "padding", "table", "message", "iter", "resource", "bytes", "flush", "document", "page", "data", "channel", "server", "variable", "device", "value", "comment", "buff", "texture"], "bytes_read": ["classesavavailable", "bytesESSreceived", " bytes_load", "bytesavavailable", "classes_READ", "bytes___READ", "bytes_READ", "classes_available", "classesavview", " bytes_written", "lines_received", "classes_read", "lines_read", "bytesavview", "bytesavread", "classes_view", "bytesESSput", "bytes_available", "bytesESSread", "bytes_load", "lines_written", "bytes_received", " bytes_write", "bytes_put", "bytes_write", "bytes___view", "bytesavREAD", "bytesESSwritten", "bytes_written", "bytesayput", "lines_put", "bytes___read", "classesavREAD", "classesavread", "bytesayreceived", "bytesayread", "bytes_view", "bytesaywritten", "bytes___available"]}}
{"id1": "13981689", "id2": "3536332", "code1": "    public static String md5Hash(String src) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(src.getBytes());\n            return bytesArrayToHexString(md.digest());\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"md5Hash": ["md5String", "md512hash", "md6hash", "md5Sum", " MD6Hash", "md6Hash", " MD6Sum", "md512String", "md4Hash", "md5hash", " MD6hash", " MD5hash", "md4String", " MD5Sum", "md512Hash", " MD5String", " MD6String", "md4Sum", "md512Sum", "md6Sum", "md6String", " MD5Hash", "md4hash"], "src": ["string", "info", "ssl", "input", "sc", "uri", "Source", "rc", "dest", "s", "length", "URL", "inst", "SOURCE", "gb", "Str", "rb", "source", "lib", "sb", "buf", "str", "RGB", "SourceFile", "data", "file", "text", "ruby", "SB", "tmp", "ptr", "href", "msg", "Bytes", "RC", "sup", "sl", "buster", "bytes", "Url", " source", "obj", "b", "inf", "img"], "md": ["editor", "gd", "mag", "bd", "od", "amd", "mo", "ind", "kg", "ma", "wd", "MD", " MD", "ms", "ad", "material", "mb", "mac", "d", "mp", "hd", "rod", "pm", "pd", "mm", "metadata", "cd", "dig", "m", "km", "dm", "ss", "db", "di", "mc", "mand", "mod", "vd", "rm", "mad", "f", "cmd", "dd", "hash", "code"]}}
{"id1": "1421557", "id2": "19910627", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeString2Stream", "encodeFileFromStream", "encodeFile2Stream", "encodeFileToString", "encodeFileToStream", "encodeFiletoFiles", "encodeFileFromString", "encodeFile2String", "encodeStringToFiles", "encodeStringToString", "encodeStringToStream", "encodeFiletoFile", "encodeFileToFiles", "encodeFiletoString", "encodeString2Files", "encodeString2File", "encodeFile2File", "encodeString2String", "encodeFile2Files", "encodeFileFromFile", "encodeFileFromFiles", "encodeStringToFile", "encodeFiletoStream"], "infile": ["infilename", "Infile", "inputfiles", "outfp", "inputfilename", " infp", "Infilename", "outfiles", "outfilename", "infp", "infiles", " infiles", "inputfile", "Infiles", "inputFile", "outFile", "inFile", "inputfp", " infilename", "InFile"], "outfile": ["infilename", "newfolder", "newFile", " outfilename", "newname", "Outfile", "outfp", "newfile", "outputfilename", "outputfolder", "outfolder", " outname", "Outfolder", "outfilename", " outFile", "infp", "infolder", "outname", "OutFile", "Outname", " outfolder", "outFile", "outputfile", "outputfp", " outfp"], "in": ["r", "image", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "a", "inner", "vin", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "base", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "on", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "work", "file", "line", "post", "o", "no", "exec", "base", "lib", "session", "err", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "source", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "fb", "buff", "raw", "value", "count", "uffer", "len", "iter", "url", "buf", "binary", "null", "base", "data", "type", "b", "border", "offset", "split", "wave", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "input", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "close", "end", "pass", "exec", "wait", "allow", "ride", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "respons", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "content", "failed", "response", "message", "successful", "path", "results", "modified", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "14820302", "id2": "3756429", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"innerProcess": ["binaryprocess", "subWrite", "subProcess", "binaryConnect", "subConnect", " innerConnect", " innerprocess", " innerWrite", "binaryProcess", "subprocess", "innerWrite", "innerprocess", "innerConnect", "binaryWrite"], "curi": [" curl", "pURI", "curl", "ciri", "pri", "Curl", "Ciri", "cURI", "lURI", " capi", " cri", "fui", "lcri", " cURI", "fri", "lcURI", "cgui", "lurl", " cgui", "capi", "furi", "Cgui", "Curi", "lciri", "cui", " cunit", "Capi", "fURI", "firi", "lcgui", "CURI", "Cunit", "lcui", " cui", "papi", "lcuri", "lri", "puri", "Cui", "luri", "cri", "cunit", "lcunit", "Cri"], "regexpr": ["prenexer", "RenexPR", "renexpre", "Renexp", "recreer", "renexpl", "rerepl", "regexr", "regexPR", "rerupr", "Regexpr", "prenexp", "regexper", "regnexpl", "relexp", "relexPR", "regnexpr", "relexpr", "reggexr", "relexpre", "reggexper", "Regexp", "rerup", "renexr", "rerepr", "Renexpre", "recepr", "pregexpl", "rereper", "recrepr", "recrep", "regnexper", "recrepre", "regexpre", "renexpr", "regexp", "reggexpl", "RegexPR", "regnexr", "pregexer", "renexer", "rerupl", "Regexpre", "recrePR", "reruer", "renexp", "pregexpr", "reggexpr", "Renexpr", "regexer", "prenexpl", "recrepl", "recer", "renexper", "rerer", "regexpl", "receper", "pregexp", "renexPR", "recepl", "prenexpr"], "cs": ["os", "sc", "ca", "details", "cas", "sync", "cus", "ctx", "qs", "cp", "ce", "cers", "cc", "bs", "rc", "cells", "cn", "rs", "ls", "cr", "ns", "cons", "lc", "ci", "cf", "css", "cache", "coll", "es", "conn", "CS", "ks", "cases", "bc", "cos", "ios", "cm", "codes", "ches", "ds", "cks", "tc", "wcs", "fs", "icks", "ac", "ars", "spec", "ces", "ced", "pc", "ins", "acts", "vs", "cer", "acks", "ss", "ics", "acs", "js", "ps", "gs", "ms", "cms", "Cs", "cing", "cb", "c", "ec"], "digest": ["hashester", " digested", "signest", " digger", "signests", "igested", "igity", "Digity", "logger", "Digit", "signgest", "digger", "digcher", " digcher", " digests", "digity", "signEST", "diggest", "diger", "hashger", "digests", "Diger", " digEST", "signger", "Digest", "logest", " digit", "Digger", "Digcher", "logester", "biggest", " diger", "bigests", "digit", "Digester", " digester", "hashest", "digester", "digEST", "bigEST", "igester", " diggest", " digity", "signer", "digested", "igest", "bigest", "logit", "Digested", "signested", "hashcher", "signester"], "s": ["S", "r", "su", "os", "h", "p", "bytes", "sl", "sync", "n", "g", "is", "bs", "strings", "rs", "ls", "e", "ns", "ses", "t", "sb", "address", "obs", "sum", "services", "sym", "states", "ds", "str", "abs", "f", "binary", "o", "sets", "data", "u", "ans", "b", "v", "groups", "settings", "l", "ss", "string", "js", "si", "ps", "ms", "gs", "ws", "c"], "m": ["mm", "r", "mo", "match", "p", "man", "map", "e", "om", "M", "fm", "bm", "rm", "cm", "nm", "mr", "ym", "sm", "imm", "dm", "v", "pm", "mi", "tm", "me", "mc", "gm", "string", "ms", "am", "machine", "vm", "c", "hm", "wm"], "newDigestValue": ["newDigestedVal", "newSignestedString", "newDigeterValue", "newDigESTKey", "newSignestedKey", "newDigESTValue", "newDigestedString", "newDigestVal", "newDigeterKey", "newSignestedValues", "newDigestedValue", "newDigesterString", "newDigesterValues", "newSignestKey", "newDigesterValue", "newDigestValues", "newDigesterVal", "newDigeterString", "newDigeterVal", "newDigesterKey", "newDigESTValues", "newDigESTString", "newDigestedKey", "newSignestString", "newSignestValues", "newDigestedValues", "newDigestKey", "newSignestedValue", "newSignestValue", "newDigestString"]}}
{"id1": "19738435", "id2": "13666876", "code1": "    public Resource parse(URL url, IRDFContainer target) throws RDFException, IOException {\n        parseURL = url;\n        URLConnection connection = url.openConnection();\n        if (charset == null) {\n            charset = Charset.forName(\"UTF-8\");\n        }\n        Reader reader = new InputStreamReader(connection.getInputStream(), charset);\n        return internalParse(reader, target);\n    }\n", "code2": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "label": 0, "substitutes": {"parse": ["match", "source", "create", " parser", "set", "se", "arse", "load", "instance", "link", "read", "process", "Parser", "resource", "open", "format", "from", "find", "add", "parser", "replace", "request", "pack", "apply", "get", "start", "run"], "url": ["text", "source", "buffer", "uri", "str", "absolute", " URL", "path", "client", "Url", "config", "page", "link", "e", "input", "l", "src", "conn", "image", "loader", "object", "resource", "location", "proxy", "io", "document", "base", "server", "host", "URL", "address", "api", "string", "channel", "ur", "stream", "element", "file", "request", "ssl", "feed", "r", "entry", "error", "http"], "target": ["source", "result", "output", "current", "path", "config", " Target", "this", "component", "event", "timeout", "root", "pointer", "to", "arget", "project", "resources", "data", "object", "Target", "resource", "context", "format", "document", "class", "host", "address", "container", "reference", "collection", "t", "response", "ctx", "parent", "node", "content"], "parseURL": ["parseResource", "parseType", "parserUrl", "parserType", "readUrl", " parseType", "parserURL", "readType", "readResource", " parseResource", "readURL", "parserResource", "parseUrl", " parseUrl"], "connection": ["text", "source", "relation", "normal", "uri", "client", "out", "connected", "c", "config", "Connection", "timeout", "conn", "or", "writer", "con", "service", "resource", "open", "director", "which", "io", "directory", "connect", "bc", "character", "database", "pool", "function", "body", "container", "channel", "handler", "creator", "response", "ctx", "ion", "section", "db", "context", "application"], "charset": ["charsET", "ChARSect", "choarsET", "chasec", "CharsET", "chipseting", "ChARSET", "Chasetter", "Charset", "charseting", "charsect", "chapterset", "chARSetter", "choarsets", "chipset", "charsets", "choarseting", "choarset", "chansec", "chasetter", "chasET", "chARSect", "Charsect", "chaseting", "chaptersetter", "Chaset", "chARSet", "choipsets", "ChARSet", "chanset", "chipsET", "chaptersET", "Charsec", "chasets", "Chasec", "Charsetter", "chARSec", "choipseting", "chansET", "ChasET", "chansect", "chipsec", "chaset", "chipsets", "charsec", "choipsET", "ChARSec", "choipset", "chARSET", "charsetter", "chipsect", "chaptersec"], "reader": ["x", "source", "reading", "rr", "driver", "per", "i", "ler", "input", "rar", "pointer", "or", "read", "data", "writer", "loader", "in", "object", "resource", "oder", "director", "io", "server", "container", "worker", "channel", "stream", "handler", "parser", "Reader", "iter", "row", "r", "er", "feed", "entry", "keeper", "context"]}}
{"id1": "3558512", "id2": "13946197", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "label": 0, "substitutes": {"serialize": ["erialize", "serialze", "serializable", " serialization", "Serialize", "finalify", "finalize", "serialization", " serializable", "finalized", "normalized", "erialze", "normalify", "erialization", "Serialized", "serialify", "erializable", " serialze", "serialized", "normalize", "normalze", "Serialze", "Serialization", "finalze", "Serialify", "Serializable"], "out": ["string", "buffer", "loader", "temp", "i", "ex", "output", "copy", "server", "report", "filename", "OUT", "o", "outs", "pool", "bin", "content", "raw", "client", "source", "cache", "up", "w", "data", "file", "archive", "parent", "page", "gen", "conn", "name", "exec", "Out", "io", "writer", "image", "dump", "a", "err", "obj", "png"], "parser": ["pillar", "base", "class", "pkg", "arser", "loader", "handler", "server", "copy", "builder", "master", "lp", "per", "as", "system", "instance", "php", "manager", "txt", "er", "cp", "reader", "cache", "pp", "up", "seed", "upload", "parent", "file", "rar", "p", "plugin", "test", "writer", "ss", "worker", "tt", "pe", "parse", "processor", "wrapper", "xml", "Parser"], "on_disk": ["onbootdrive", "onJdrive", "onJdisk", "onbootlock", "onjdrive", "onbootstorage", "on_demand", "onjdisk", "on_drive", "off_disk", "onnetfile", "off_drive", "onbootdisk", "on_storage", "onbookdelete", "on_lock", "onJdemand", "off_lock", "on_space", "onnetdemand", "onbookdisk", "off_storage", "onJlock", "on_delete", "onnetdisk", "onnetspace", "off_delete", "onbookdrive", "onjfile", "off_demand", "onnetdrive", "onjspace", "off_file", "on_file", "off_space"], "in": ["IN", "info", "pin", "i", "input", "inas", "copy", "ini", "con", "c", "socket", "inner", "as", "o", "ins", "bin", "pass", "reader", "thin", "source", "connection", "min", "login", "r", "inc", "data", "file", "rin", "conn", "again", "ax", "In", "kin", "stream", "lin", "ac", "inn", "f", "win", "din"]}}
{"id1": "9236363", "id2": "11377441", "code1": "    private void unJarStart(String jarPath, String jarEntryStart) {\n        String path;\n        if (jarPath.lastIndexOf(\"lib/\") >= 0) path = jarPath.substring(0, jarPath.lastIndexOf(\"lib/\")); else path = jarPath.substring(0, jarPath.lastIndexOf(\"/\"));\n        String relPath = jarEntryStart.substring(0, jarEntryStart.lastIndexOf(\"/\"));\n        try {\n            new File(path + \"/\" + relPath).mkdirs();\n            JarFile jar = new JarFile(jarPath);\n            Enumeration<JarEntry> entries = jar.entries();\n            while (entries.hasMoreElements()) {\n                JarEntry entry = entries.nextElement();\n                String jarEntry = entry.getName();\n                if (jarEntry.startsWith(jarEntryStart)) {\n                    ZipEntry ze = jar.getEntry(jarEntry);\n                    File bin = new File(path + \"/\" + jarEntry);\n                    IOUtils.copy(jar.getInputStream(ze), new FileOutputStream(bin));\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void resolvePlugins() {\n        try {\n            File cacheDir = XPontusConfigurationConstantsIF.XPONTUS_CACHE_DIR;\n            File pluginsFile = new File(cacheDir, \"plugins.xml\");\n            if (!pluginsFile.exists()) {\n                URL pluginURL = new URL(\"http://xpontus.sourceforge.net/snapshot/plugins.xml\");\n                InputStream is = pluginURL.openStream();\n                OutputStream os = FileUtils.openOutputStream(pluginsFile);\n                IOUtils.copy(is, os);\n                IOUtils.closeQuietly(os);\n                IOUtils.closeQuietly(is);\n            }\n            resolvePlugins(pluginsFile.getAbsolutePath());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"unJarStart": ["copyJarRest", "copyServerEnd", "syncServerPath", "copyjarStart", "copyjarEnd", "copyZipPath", "copyZipEnd", "copyJarStart", "copyZipRest", "copyServerPath", "copyJarPath", "copyjarRest", "syncJarEnd", "copyZipStart", "syncServerEnd", "copyServerRest", "syncJarRest", "syncJarPath", "copyjarPath", "syncServerStart", "copyJarEnd", "syncServerRest", "copyServerStart", "syncJarStart"], "jarPath": [" jarContent", "relEntry", "jarFile", "archiveDir", "relpath", "archivepath", "garContent", "badUrl", " jarName", "javaEntry", "jampath", "garText", "garpath", "badpath", "javaLog", "zippath", "zipPath", "jarpath", " jarText", "badPath", "jarCh", "garUrl", "narCh", "jarDir", "javaUrl", "jamLog", "garFile", "badLog", "zipEntry", "narpath", "garPath", "narName", "JarFile", "archiveLog", "javaName", "zipFile", "javaCh", "jarLog", "jarText", "narPath", "jarName", " jarDir", " jarUrl", "Jarpath", "javaFile", "javaPath", "jarUrl", " jarFile", "JarContent", " jarLog", "javaText", " jarpath", "JarPath", "JarCh", "relFile", "archivePath", "javapath", "jamPath", "jarContent", "JarName", "jamDir"], "jarEntryStart": ["tarentryStart", "jarImportFollow", " jarEntryFinish", "jarFilePart", "tarentryName", "jarAttemptPart", "jarImportEnd", " jarFileStart", "jarFileName", "jarAttemptEnd", "jarFileEnd", "tarEntrySource", " jarImportStart", "tarEntryStart", "jarEntryPart", "jarImportName", " jarFileName", "jarFileFollow", "jarEntryFollow", " jarFilePart", " jarEntryName", "jarPartEnd", "jarEntName", " jarEntrySource", "jarFileStart", " jarImportEnd", "jarentryStart", "jarentrySource", "tarEntryPart", "tarentryPart", "jarEntryEnd", "jarEntryFinish", "jarEntPart", "jarFileFinish", "jarImportFinish", "tarEntryName", "jarEntryName", "jarAttemptStart", " jarFileSource", "jarentryPart", "tarentrySource", "jarPartStart", " jarImportPart", "jarPartFinish", "jarEntSource", " jarFileFinish", " jarEntryFollow", "jarEntrySource", "jarAttemptFollow", " jarEntryEnd", "jarPartPart", "jarImportSource", "jarImportStart", " jarImportFollow", "jarFileSource", "jarImportPart", " jarEntryPart", " jarFileEnd", "jarentryName", "jarEntStart"], "path": ["test", "error", "cache", "right", "id", "log", "session", "pattern", "location", "name", "conn", "context", "method", "ph", "route", "directory", "th", "graph", "api", "mount", "p", "ion", "cookie", "data", "file", "ith", "ha", "prop", "left", "folder", "boot", "pointer", "patch", "string", "Path", "prefix", "object", "dest", "key", "template", "base", "system", "zip", "inner", "then", "code", "mode", "parent", "config", "loc", "uri", "resource", "it", "content", "source", "work", "dir", "home", "temp", "url", "PATH", "clean", "output", "request", "default", "host", "archive", "image", "next", "step", "type", "root", "text", "ath", "wd", "pass", "json", "ctx", "po"], "relPath": ["relpath", "relativepath", " relDir", "relativeDir", "relativePath", " relName", "relName", "Relpath", "relativeName", "RelName", " relPos", "RELName", "relativePos", "RelPath", "RELPath", "RELPos", "RelDir", " relpath", "relPos", "relDir", "RELpath"], "jar": ["ser", " module", "url", "drop", "cache", "magic", "car", "sr", "parse", "war", "com", "ar", "zip", " war", "ball", "xml", "folder", "space", "ler", "sl", " archive", "er", "plugin", "ge", "start", "log", "fire", "tab", "archive", "pkg", "tar", "bag", " tar", "keeper", "zone", "ssl", "java", " manifest", "bar", "browser", "gap", " java", " dir", "pipe", "per", "her", "pack", " capsule", "jo", " parser", "dr", "cookie", "sheet", "server", "dir", "spin", "rar", "mag", "sp", "open", "Jar", "module"], "entries": ["entrys", "Entursions", "enders", "quies", "entensions", "quents", "enties", "quries", "ientries", "endries", "entEntry", "Enties", "counters", "endrys", "entories", "countEntry", "adders", "entryEntry", "qulements", "addries", "entryers", "enters", "ientursions", "endories", "entryensions", "entryries", "entlements", "entursions", "ENTents", "antries", "Entlements", "Entrys", "Entry", "ientry", "ENTlements", "iters", "itrys", "ENTries", "antursions", "addEntry", "Entents", "countries", "itories", "Entories", "countensions", "ENTies", "antlements", "Entries", "entents", "ientlements", "itries", "addensions", "Enters", "antry"], "entry": ["oe", "address", "de", "be", "lie", "reader", "enter", "parse", "e", "zip", "cel", "je", "ler", "ge", "name", "obj", "mer", "or", "element", "ie", "r", "ent", " Entry", "Entry", "pack", "la", "resource", "add", "it", "key", "jo", "ry", "se", "server", "ries", "pie", "cat", "part", "ce", "module"], "jarEntry": ["jarFile", "archiveFile", "javaEntry", "celEntry", " jarElement", "javaImport", "javaRule", "carEntry", "javaElement", "celEnt", " jarentry", "serName", "jarRule", "celFile", "serEntry", "jobEntry", "javaEnt", "carElement", "archiveRule", "serElement", "jarentry", "jobImport", " jarEnt", "javaName", "serFile", "archiveElement", "jarName", " jarImport", "javaFile", "carPath", "javaPath", "jarImport", "javaentry", "carEnt", "jarEnt", "archiveEnt", "archiveName", "celRule", "jobPath", "archiveEntry", "jarElement", "jobentry"], "ze": ["zie", "z", "ja", "ipe", "e", "zip", "cel", "je", "sl", "kee", "ge", "te", "li", "zen", "zes", "fe", " je", "code", "ZE", "ide", "ie", "pe", "zer", "zo", "za", "zi", " ace", "jo", "xe", "se", "ke", "ne", "ine", "ce", "aze", "le", "zy", "be"], "bin": ["bn", "base", "bit", "login", "bb", "zip", "proxy", "isin", "bis", "vin", "spin", "log", "boot", "ini", "plugin", "index", "abin", "binary", "inner", "lock", "len", "bank", "bot", "bas", "lib", "zone", "info", "bar", "body", "sin", "win", "resource", "inn", "gi", "pin", "abi", "arin", "di", "in", "data", "file", "cin", "init", "kin", "bi"]}}
{"id1": "4531653", "id2": "8921716", "code1": "    public static String md5(String data) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(MD);\n            md.update(data.getBytes(UTF8));\n            return encodeHex(md.digest());\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"md5": [" md512", "mp512", "md6", "mp5", "mp7", "md7", "MD6", "md512", "MD512", "mp6", " md7", " md6", "MD7", "MD5"], "data": ["DATA", "text", "pad", "message", "image", "script", "sha", "body", "method", "this", "in", "output", "input", "str", "hex", "dat", "template", "bytes", "key", "code", "source", "api", "media", "a", "base", "ata", "address", "cache", "string", "alpha", "name", "content", "buffer", "format", "database"], "md": ["m", "hd", " MD", "mp", "cmd", "material", "mo", "dig", "dd", "gd", "editor", "mc", "mag", "d", "od", "mb", "wd", "meta", "nm", "code", "amd", "mg", "dm", "bd", "metadata", "pd", "MD", "docker", "di", "db", "ad", "mac", "mand", "mm", "ma", "sm", "rod", "pm", "grad", "mt", "cd", "mod", "ds"]}}
{"id1": "7872659", "id2": "7122523", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request);\n        if (delegate == null) {\n            ActionErrors errors = new ActionErrors();\n            errors.add(null, new ActionError(\"errors.session\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"fail\");\n        }\n        AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla();\n        TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion();\n        String urlSonido = traAyudaPantalla.getUrlSonido();\n        if (urlSonido == null) {\n            return null;\n        }\n        URL url = new URL(urlSonido);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.connect();\n        String tipoMime = urlConnection.getContentType();\n        log.debug(\"Tipo Mime: \" + tipoMime);\n        Map audioOptions = new HashMap();\n        if (tipoMime.indexOf(\"audio\") != -1 || tipoMime.indexOf(\"asf\") != -1 || tipoMime.equals(\"unknown/unknown\")) {\n            audioOptions.put(\"id\", \"MediaPlayer\");\n            audioOptions.put(\"codeBase\", \"http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,7,1112\");\n            audioOptions.put(\"classId\", \"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\");\n            audioOptions.put(\"mimeType\", \"application/x-mplayer2\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/\");\n        } else if (tipoMime.indexOf(\"real\") != -1) {\n            audioOptions.put(\"id\", \"RVOCX\");\n            audioOptions.put(\"codeBase\", \"\");\n            audioOptions.put(\"classId\", \"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\");\n            audioOptions.put(\"mimeType\", \"audio/x-pn-realaudio-plugin\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"\");\n        }\n        request.setAttribute(\"audioOptions\", audioOptions);\n        log.debug(\"entra success\");\n        return mapping.findForward(\"success\");\n    }\n", "label": 0, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndmovieindexfile", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndmovieIndexfile", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndMovieIndexPath", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndMovieindexPath"], "completePath": [" completeCh", "iteCh", "completeCorp", "progressPath", "CompleteDir", "donePath", "completeLoader", " completepath", "doneVol", "CompleteHome", "execPath", "flatCorp", "flatPath", " CompletePath", " completeFile", "completeCh", " completeCorp", "correctRoot", "progressLoader", "completePoint", "correctPoint", " CompleteHome", "completeVol", "doneLoader", " completeHome", "completepath", "successMusic", " completeDir", "flatRoot", "successpath", "CompleteFile", " completePoint", "successCh", "completeHome", " CompleteFile", "execpath", "itepath", "completeMusic", "CompletePath", " completeRoot", "iteMusic", "successPath", " CompleteDir", "progressVol", "itePath", "execVol", "correctCorp", "donepath", "completeFile", "progresspath", " completeMusic", "completeRoot", "flatPoint", "completeDir", "execLoader", "correctPath"], "masterFile": [" masterPath", "mastersFILE", "MasterFiles", "MasterFILE", " masterFilename", "MasterFilename", "configFilename", "cacheFILE", "cacheFiles", "configName", "configPath", "MasterFile", "configFile", "MasterName", "cacheFile", "masterName", "masterFILE", "masterFilename", "mastersFiles", "masterFiles", "mastersFile", "mastersPath", "cachePath", " masterName", "masterPath", "MasterPath"], "CustRatingFileName": ["CustIndexFilesPath", "CustRatingFileDesc", "CustIndexFilesType", "CustRateFileName", "CustRatingFilesDesc", "CustRatingFileSize", "CustRateFilenameDesc", "CustRatingClassVersion", "CustRateFilenameName", "CustRatingFilenameName", "CustRatingFilesSize", "CustRatingFullSize", "CustIndexFileType", "CustRatingFilesType", "CustRatingClassType", "CustRateFileSize", "CustRatingFullName", "CustRateFilePath", "CustRatingLineType", "CustIndexFilesName", "CustRatingFullDesc", "CustRateFileDesc", "CustIndexFilesVersion", "CustRatingFilesVersion", "CustRatingFileVersion", "CustRatingFilenamePath", "CustIndexFilePath", "CustRatingLineVersion", "CustRatingFilesPath", "CustRatingFullPath", "CustRatingFilePath", "CustRatingFilenameSize", "CustIndexFileVersion", "CustRateFilenamePath", "CustIndexFileName", "CustRatingFileType", "CustRatingClassPath", "CustRatingLineName", "CustRatingLinePath", "CustRatingFilesName", "CustRatingClassName", "CustRatingFilenameDesc", "CustRateFilenameSize"], "MovieIndexFileName": ["MovieIndexFolderVersion", "MovieIndexFileUrl", "MovieIndexFilename", "MovieConfigFolderVersion", "MovieConfigFileName", "MovieIndexPlaceFile", "MovieEditFSize", "MovieIndexFname", "MovieIndexClassname", "MovieIndexClassName", "MovieIndexFileFile", "MovieIndexFUrl", "MovieEditFName", "MovieIndexFilesname", "MovieIndexClassUrl", "MovieIndexFileSize", "MovieIndexPlaceVersion", "MovieEditFilename", "MovieConfigFolderName", "MovieIndexFSize", "MovieConfigFileFile", "MovieIndexPlaceHandle", "MovieIndexFolderHandle", "MovieConfigFileVersion", "MovieConfigFileHandle", "MovieIndexFileHandle", "MovieEditFUrl", "MovieIndexFilesSize", "MovieIndexFilesName", "MovieIndexClassSize", "MovieEditFileName", "MovieIndexFILEVersion", "MovieIndexPlaceName", "MovieEditFname", "MovieIndexFolderName", "MovieConfigFolderFile", "MovieIndexFileVersion", "MovieIndexFolderFile", "MovieIndexFName", "MovieConfigFolderHandle", "MovieEditFileUrl", "MovieIndexFILEFile", "MovieEditFileSize", "MovieIndexFILEName", "MovieIndexFILEHandle", "MovieIndexFilesUrl"], "inFile": ["outFile", "inputfile", "incSourceFile", "InFile", "inputF", "InF", "inF", " inSourceFile", "outSourceFile", "InSourceFile", "outC", "inputFile", "inputSourceFile", "inSourceFile", "incfile", "incFile", "outfile", " infile", "infile", " inF", "incC", "Infile"], "inC": ["outCC", "innerC", "inCC", "outCL", "inputCC", " inCC", "InCI", "outFile", " inB", "InB", "inputC", "InFile", "inputF", "InF", "inF", "inB", "outC", "inputFile", "outCI", " inCL", "inCI", "InCC", "InCL", "InC", "inCL", "innerCC", "innerFile", "outB", "outF", " inF", "innerCI"], "outFile1": ["outFiles2", "outputfileId", "outPlace2", "outFId", "outputFileId", "outfile2", "outfileId", "outPlaceId", "againC1", "outF2", "outfileName", "outputfile2", "outFileName", "outPathFirst", "outCFirst", "outFiles3", "outputFile2", "outPath2", "againC3", "outfile1", "outFiles1", "outFilesFirst", "againFile1", "outFileId", "againFileFirst", "outF1", "outputFile1", "outPath3", "outC3", "outFile3", "outPath1", "outPlaceName", "againCFirst", "outputfileName", "outPlace1", "againFile3", "againC2", "outputFileName", "outFileFirst", "againFile2", "outputfile1", "outFName"], "outC1": ["outB8", "againC1", "outCOne", "newcOne", "outD2", "outF2", "againB2", "againC8", "outCFirst", "outD81", "outC81", "newCOne", "outF8", "outCF1", "againB8", "newc1", "outC8", "newC81", "outCF81", "outB2", "outF1", "outc1", "newcFirst", "outB1", "againB1", "outc81", "outCFFirst", "newc81", "againCOne", "againBOne", "outFOne", "outcFirst", "outD8", "againC2", "outCFOne", "outDOne", "outcOne", "outD1", "outBOne", "newCFirst", "outDFirst", "newC1"], "outFile2": ["outFiles2", "outputfileTwo", "againLine2", "outChannelTwo", "outfile2", "outFile6", "outfile5", "outDirectory5", "outputfile2", "outDirectory4", "againFileTwo", "outfile4", "againLineTwo", "outLineTwo", "againLine1", "outFiles5", "outputfile4", "outputFile2", "outputFile4", "outFile4", "outFile5", "againFile6", "outFiles1", "outputfile5", "outFilesTwo", "againFile1", "outfileTwo", "outChannel6", "outDirectory2", "outFiles4", "outputFileTwo", "outChannel1", "outChannel2", "outFileTwo", "outDirectoryTwo", "outLine1", "outLine2", "againLine6", "againFile2", "outputFile5", "outFiles6", "outLine6"], "outC2": ["againC1", "outCache2", "outCacheII", "outB4", "outF2", "againB2", "outCTwo", "OutF4", "outCache1", "outF4", "OutF1", "OutFII", "OutCII", "outFile4", "outFTwo", "OutC4", "outB2", "outFileII", "outF1", "outCache4", "OutC1", "againB4", "outB1", "againB1", "outC4", "againC4", "outFileTwo", "againBTwo", "outCII", "OutF2", "OutC2", "outFII", "outBTwo", "againC2", "againCTwo"], "fileSize": ["bufferSize", "resourceAddress", "bufferLength", "FileSIZE", "fileMode", "fileAddress", "imageLength", "FileAddress", "resourceSIZE", "bufferMode", "FileMode", "fileLength", " fileLength", " fileAddress", "resourceSize", "imageSIZE", " fileSIZE", "FileSize", "imageSize", "FileLength", " fileMode", "fileSIZE"], "totalNoDataRows": ["totalNoDataLows", "totalNoPageROWS", "totalNoDataChOWS", "totalNoDataLOWS", "totalNoDataCrows", "totalNoDataCows", "totalNoDataChows", "totalNoDataLrows", "totalNoDataChrows", "totalNoDataCOWS", "totalNoPageRrows", "totalNoDataChues", "totalNoDataCues", "totalNoPageLues", "totalNoPageLOWS", "totalNoDataRrows", "totalNoPageRues", "totalNoDataROWS", "totalNoDataRues", "totalNoPageLows", "totalNoPageLrows", "totalNoDataLues", "totalNoPageRows"], "mappedBuffer": ["Machedbuffer", "mppedBuffer", "mappedURL", "mactedbuffer", "mapedBuffer", "MappedBuffer", "MachedStream", "MachedBuffer", "mappingbuffer", "MappingBuffer", "mappingFile", "Mappedbuffer", "MachedFile", "mippedStream", "mashedFile", "mashedChannel", "machedFile", "mappingChannel", "mapedStream", "machedBuffer", "MachedChannel", "MappingFile", "MappingChannel", "MappedStream", "mactedBuff", "machedStream", "mashedBuffer", "MappedChannel", "MappingBuff", "mappingBuffer", "mippedURL", "mapedFile", "mappedStream", "mppedChannel", "mippedBuff", "mapedURL", "mashedBuff", "mppedBuff", "machedChannel", "machedbuffer", "mappedBuff", "MappedBuff", "MachedURL", "mppedStream", "mappingBuff", "mippedBuffer", "mappingStream", "mapedBuff", "mactedStream", "mappedChannel", "MappedURL", "mactedBuffer", "MappedFile", "mappedbuffer", "machedBuff", "MachedBuff", "mappedFile", "machedURL"], "startIndex": ["useindex", " startindex", "endRow", "stopindex", " startRow", " startPosition", "StartPosition", "endIndex", " startOffset", "useInfo", "stopCode", "startingPosition", "stopIndex", " startCode", "startSection", "startingPoint", "useIndex", "startPoint", "StartOffset", "stopRow", "StartIndex", "endPosition", "endPoint", "initOffset", "initIndex", "endindex", "endInfo", "startInfo", "usePosition", "endCode", "startOffset", "startindex", "startPosition", "Startindex", " startPoint", "StartInfo", " startInfo", "startingSection", " startSection", "startRow", "initindex", "startingIndex", "endSection", "startCode", "initInfo"], "count": ["force", "index", "pool", "child", "other", "depth", "found", "self", "coll", "current", "order", "find", "group", "cache", "add", "total", "key", "list", "code", "c", "more", "ind", "type", "part", "counter", "allow", "len", "all", "number", "loop", "first", "length", "start", "size", "close", "name", "test", "col", "sum", "keep", "id", "follow", "weight", "call", "limit", "thread", "i", "Count", "old", "time", "max"], "currentMovie": ["currentImage", "currentPicture", "currentlyMovie", "defaultFilm", "currentmovie", "CurrentTheme", "defaultImage", "parentPicture", " currentFilm", "validTheme", "reportedTheme", "CurrentFilm", "validFilm", "thisMovie", "Currentmovie", "parentFilm", "currentlyMusic", "defaultMusic", " currentMusic", "reportedMusic", "validmovie", "CurrentMovie", "currentMusic", "currentlyPicture", "reportedmovie", "thismovie", "currentFilm", "defaultMovie", "reportedMovie", " currentImage", "currentTheme", "thisFilm", " currentPicture", "thisPicture", "parentmovie", "reportedPicture", "validMovie", " currentmovie", "reportedFilm", "reportedImage", "parentMovie"], "movieName": ["filmname", "camName", "voiceInfo", "filmNumber", "movieId", "moneyName", " movieId", "MovieNumber", "voiceName", "voicename", " moviename", "Moviename", "filmName", "camFamily", "MovieId", "camname", "moviename", "moneyNumber", "movieNumber", "MovieFamily", " movieFamily", "MovieInfo", " movieInfo", "movieFamily", "voiceId", "MovieName", "movieInfo", "filmFamily", "moneyFamily"], "customer": ["ustomers", "customeri", "Customer", "mixer", "mixers", " customER", "Customor", "Customers", "ustomER", "customers", "mixor", "ustomer", "ustomor", "mixER", "CustomER", "customor", " customers", "Customeri", "customER", "ustomeri", " customeri"], "rating": ["writing", "resource", "rice", "ing", "RC", "rates", "alpha", "http", "reading", "rate", "writer", "info", "ruby", "packing", "including", "string", "setting", "r", "rc", "rage", "padding", "rated", "type", "attribute", "rr", "number", "Rating", "missing", "ring", "id", "data", "range", "score", "radius", "ranking", "value", "comment", "reader", "feature", "error", "rank", "rolling", "url"], "outBuf1": ["outFaf1", "outKbuffOne", "outBuf11", "outKbuf1", "outBbuff1", "outBum1", "outKuf8", "outBbufn", "outBafCloud", "outBum91", "outFuf01", "outDuff3", "outKbuff1", "outBalth3", "outBuf01", "outBuff8", "outFufOne", "outBuff2", "outKuf3", "outCuf1", "outKbuf3", "outDuf3", "outFufCloud", "outBuff3", "outBuff1", "outBiff91", "outBaftn", "outBuf91", "outDuf1", "outBuf0", "outFuf1", "outBuffCloud", "outDufn", "outBafOne", "outBuf8", "outBummerOne", "outFafCloud", "outKbuff8", "outBaf1", "outBufCloud", "outBbuff0", "outKuf2", "outBiff01", "outFbufOne", "outBbuff8", "outBaft3", "outCufOne", "outBum01", "outBuf3", "outBaf0", "outBufOne", "outBaft11", "outCuff1", "outBummerCloud", "outBuffOne", "outBbuf01", "outBbuffOne", "outBbufOne", "outKufOne", "outBiffOne", "outBummer1", "outBuff11", "outCuf0", "outFbuf01", "outBbuf3", "outCuff0", "outBbuf91", "outBiff1", "outBbuf1", "outBbuf11", "outBbuff3", "outKuf1", "outKbuff3", "outBaft1", "outBalth2", "outFuf91", "outBaf8", "outDuff1", "outKbuf2", "outCuffOne", "outDuffn", "outDuf11", "outBaf3", "outBalth1", "outBbuf2", "outBumOne", "outDuff11", "outBufn", "outBuffn", "outFbuf1", "outFafOne", "outBuff0", "outFbuf91"], "outBuf2": ["outFbuff4", "outBbuff1", "outWBuf0", "outBbuffTwo", "outFuf12", "outBbuff82", "outFuf20", "outBbufferB", "outWBuf200", "outBait4", "outBuff8", "outBuff2", "outBufB", "outBuff1", "outFufTwo", "outBoffTwo", "outBbuff4", "outBuber82", "outBbufTwo", "outBuff12", "outBuf0", "outFuf1", "outBait8", "outFbufB", "outWBuf4", "outBuf8", "outFbuff82", "outWBbuff2", "outFbuf4", "outFbuff20", "outWBufTwo", "outBbuff0", "outBbuff8", "outBuffTwo", "outBuf4", "outWBuff8", "outWBuf2", "outBaitTwo", "outWBbuff200", "outBbuff20", "outBbufB", "outBbuf4", "outFbuff8", "outBum82", "outWBuff4", "outBbuffer2", "outBuber8", "outWBuff2", "outBuf20", "outFuf82", "outBum8", "outBait0", "outBufTwo", "outBum2", "outFbuffTwo", "outWBbuff8", "outBbuff2", "outBum20", "outBuf82", "outBuf12", "outBbuffer12", "outFuf2", "outWBuf8", "outBuber2", "outBait2", "outFuf4", "outBuff4", "outBbuf1", "outBait200", "outBbuffer4", "outBoff200", "outBuffB", "outFbuff2", "outBuf200", "outFbuf2", "outBbuff200", "outBoff8", "outFbuff1", "outBoff2", "outBbuf12", "outFufB", "outWBuff0", "outBbuf2", "outFbuf12", "outWBbuffTwo", "outBuff0", "outBuber20", "outFuf8"], "endOfIndexFile": ["endofindexFiles", "endofIndexFiles", "endOfIndexfile", "endofindexFile", "endofLinkFiles", "endOfLinkFiles", "end\n", "endOfLinkTime", " endfile", "endofLinkTime", "endOfIndexDir", "endOfindexTime", "endOfIndexFolder", "endfile", "endOfDatafile", "Endfile", "endOfDataFile", "endOfLinkFile", "endOfDataTime", "endofLinkFile", "endOfDataDir", "End\n", "endOfindexfile", "endofIndexDir", "endOfClientDir", "endOfImageTime", "endedfile", "ended\n", "endofindexFolder", "endOfClientFile", "endOfindexDir", "endOfIndexFiles", "endOfClientTime", "endOfindexFolder", "endOfIndexTime", "endofIndexFolder", "endOfImageFolder", "endofindexTime", "endOfLinkDir", "endofIndexTime", "endOfImageFiles", "endofLinkDir", " end\n", "endOfClientFiles", "endOfLinkfile", "endofIndexFile", "endOfindexFiles", "endOfindexFile", "endOfImageFile"]}}
{"id1": "11183087", "id2": "614099", "code1": "    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String senha = \"\";\n        String email = request.getParameter(\"EmailLogin\");\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(request.getParameter(\"SenhaLogin\").getBytes(), 0, request.getParameter(\"SenhaLogin\").length());\n            senha = new BigInteger(1, messageDigest.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        Usuario usuario = UsuarioBll.getUsuarioByEmailAndSenha(email, senha);\n        String redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"?&msg=3\";\n        if (request.getHeader(\"REFERER\").indexOf(\"?\") != -1) {\n            redirect = request.getHeader(\"REFERER\").replace(\"?msg=3\", \"\").replace(\"&msg=3\", \"\") + \"&msg=3\";\n        }\n        if (usuario.getNome() != null) {\n            HttpSession session = request.getSession();\n            session.setAttribute(\"usuario\", usuario);\n            redirect = \"index.jsp\";\n        }\n        response.sendRedirect(redirect);\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"doPost": ["handlePut", "doPOST", " doPOST", "handleSearch", "doingPost", " doPut", "doPut", "doingPOST", "doingSearch", " doSearch", "doingPut", "handlePost", "doSearch", "handlePOST"], "request": ["resource", "application", "pull", "route", "subject", "use", "external", "project", "join", "instance", "current", "initial", "context", "xml", "view", "Request", "http", "call", "forward", "state", "input", "right", "report", "have", "queue", "post", "enter", "the", "user", "child", "object", "er", "frame", "order", "hello", "rate", "pe", "event", "model", "server", "query", "url", "get", "config", "complete", "e", "q", "image", "remote", "result", "error", "type", "data", "req", "QUEST", "r", "press", "message", "web", "info", "parent", "client", "buffer", "create", "rf"], "response": ["Response", "resource", "application", "status", "respond", "site", "reply", "http", "results", "view", "report", "api", "onse", "object", "guide", "resp", "document", "connection", "model", "server", "pool", "writer", "res", "result", "page", "next", "output", "message", "web", "parent", "client", "body", "template"], "senha": ["senla", " senwa", "zenHa", "suitla", "sanHa", " senca", "sanlah", "senhi", "zensha", "tonHa", "senca", "senlah", "tonlah", "snla", "snhi", "zenha", "renha", "suitsha", "zenaka", "senHa", "zenhi", " senHa", "renca", "tonha", " senlah", "snsha", "tonwa", "sanha", "suitha", "renHa", "senwa", "sensha", "zenca", "suithi", "zenla", "renaka", "snha", "senaka", " senaka", "sanwa"], "email": ["mail", "username", "Email", "ip", "fax", "line", "zip", "string", "environment", "xml", "secret", "service", "language", "label", "user", "address", "letter", "hello", "business", "model", "phrase", "server", "url", "office", "e", "home", "password", "example", "mobile", "login", "data", "account", "message", "id", "alias", "name", "file"], "messageDigest": ["messageDest", "meDigest", "messageDester", " messageDigester", " messageDend", "medigEST", "messagedigest", "messageDigester", "messagedigester", " messageDEST", "messageMailest", "meDigester", " messageDest", " messagedigEST", "messageDigEST", " messageDester", "messagedigEST", "meDigher", "messagedigend", " messagedigest", " messagedigester", "meDigEST", "messageDher", "medigest", "messagedigher", "messageDend", "messageDEST", "medigester", "messageMailester", "messageDigend", " messageDigend", "messageMailEST", "medigher", "messageDigher", "messageMailend", " messageDigEST"], "usuario": ["sulurio", "suuarial", "usituarial", "ussuario", "usuariat", " usuarius", "ususario", "usuasio", "usiturio", "ussuarium", " usurio", " usuiasio", "usituario", "usguario", "usguariat", "suluarial", "usuillo", "suuario", " usuariat", "usueillo", " ususillo", " usuillo", "usuarius", " usuasio", "ususillo", "ussuasio", "suluasio", "uslurio", "ussurio", "usuitario", "usluarial", "usuitarium", "usurio", "usuiasio", " usuiario", "suluario", "usituasio", " ususario", "suurio", " ususarius", "ususarius", "usueariat", " usuirio", "usuarial", "usuiarium", "usuitasio", "usuearius", "usluasio", "usuiario", "usuitrio", "usluario", "suuasio", "usueario", " usuarium", "ususariat", "usguarius", "ussuarial", "usuarium", " usuiarium", "usguillo", " ususariat", "usuirio"], "redirect": ["redurl", "edurl", "rerict", "edirect", " redirection", "redrict", "reirect", " redRECT", "indirection", "predRECT", "Redirect", "Redirection", "induce", " reduce", "reroute", "preduce", "redirection", "indirect", "redition", "Redroute", "redRECT", "predirect", "predroute", "indrict", "Redrict", " redition", " redrict", "predrict", "predirection", "RedRECT", "Redurl", " redurl", "reduce", "edirection", "Redition", "reirection", "edition", "redroute"], "session": ["group", "use", "sid", "cache", "view", "http", "proxy", "comment", "service", "state", "input", "node", "object", "child", "user", "cookie", "browser", "flash", "ession", "app", "connection", "document", "storage", "event", "server", "query", "sp", "system", "config", "sl", "Session", "image", "page", "result", "ssl", "data", "message", "info", "client", "site", "person"]}}
{"id1": "21181542", "id2": "18217985", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    public static String fromHtml(URL url, String defaultEncoding, boolean overrideEncoding) throws IOException, BadDocumentException {\n        URLConnection conn = url.openConnection();\n        String contentType = conn.getContentType();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) {\n            int i = contentType.indexOf(\"charset\");\n            if (i >= 0) {\n                String s = contentType.substring(i);\n                i = s.indexOf('=');\n                if (i >= 0) {\n                    s = contentType.substring(i + 1).trim();\n                    encoding = s.replace(\"\\'\", \"\").replace(\"\\\"\", \"\").trim();\n                    if (encoding.equals(\"\")) {\n                        encoding = defaultEncoding;\n                    }\n                }\n            } else {\n                encoding = defaultEncoding;\n            }\n        }\n        String expected = \"text/html\";\n        if (contentType == null) {\n            DefaultXMLNoteErrorHandler.warning(null, 90190, \"Returned content type for url.openConnection() is null\");\n            contentType = expected;\n        }\n        int index = contentType.indexOf(';');\n        if (index >= 0) {\n            contentType = contentType.substring(0, index).trim();\n        }\n        if (!contentType.equals(expected)) {\n            String msg = translator.translate(\"The content type of url '%s' is not '%s', it is '%s'\");\n            throw new BadDocumentException(String.format(msg, url.toString(), expected, contentType));\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        return fromHtml(in, encoding);\n    }\n", "label": 0, "substitutes": {"deleteRoleType": [" deleteRoletype", "deleteroleType", "deleteRoletype", "deleteResourcetype", " deleteRoleTyp", "deleteFunctionType", "deleteRoleTyp", " deleteroleTypes", "deleteroleTyp", "deleteResourceType", " deleteroleType", "deleteroletype", "deleteroleTypes", "deleteResourceTypes", "deleteFunctiontype", "deleteResourceTyp", " deleteRoleTypes", "deleteRoleTypes", " deleteroletype", "deleteFunctionTypes", "deleteFunctionTyp", " deleteroleTyp"], "id": ["ID", "url", "uri", "kid", "parent", "length", "vid", "view", "connection", "lock", "like", "data", "info", "version", "mid", "sid", "part", "in", "model", "it", "f", "aid", "Id", "index", "pid", "error", "key", "type", "end", "rid", "code", "uid", "source", "i", "is", "section", "edit", "ip", "ids", "object", "address", "string", "start", "name", "path", "ident", "oid", "request"], "namespaceId": ["namespacesInfo", "namespaceContext", "namespacedInfo", "memberspaceId", "asentityName", "namesspaceId", "membersetId", "nspaceid", "namespacedType", "namesaceID", "namesentityName", "asentityInfo", "namesaceInfo", "nspaceId", "namespacesid", "namesenceType", "workspaceType", "memberspaceType", "NamespaceId", "aspaceID", "workspacesid", "workspaceKey", "memberspaceName", "namespaceKey", "namespacesContext", "namespacesID", "namesetid", "namesentityID", "Namespaceid", "workspaceInfo", "namesentityId", "namesaceId", "nspaceID", "aspaceName", "namesplaceid", "namesetId", "namesenceId", "namesspaceKey", "membersetid", "workspacesId", "workspacePath", "worksspacePath", "workspaceId", "namespacesKey", "workspacesType", "namespaceid", "worksspaceId", "namespacedId", "workspaceid", "workspaceContext", "namespacesName", "nsaceid", "namesaceid", "worksspaceInfo", "namespacedName", "NamespacedType", "namesplaceInfo", "NamespaceName", "namesspaceInfo", "namespacedKey", "namesentityInfo", "namesenceid", "NamespaceType", "namesaneName", "namesetID", "namespacePath", "namespaceType", "Namespacedid", "namesaceType", "namespacedid", "nsaceID", "aspaceInfo", "namesplaceId", "membersetName", "NamespacedName", "namespaceInfo", "nspaceInfo", "nsaceInfo", "namespaceID", "namesetInfo", "namesaneId", "namespaceName", "namesetType", "worksspaceKey", "NamespacedId", "namesspacePath", "nsaceId", "workspacesContext", "namesenceContext", "asentityId", "namespacedPath", "namesaneType", "namesaneid", "memberspaceid", "membersetType", "asentityID", "aspaceId", "namesplaceID", "namespacesType", "namespacesId", "namesaceContext", "namespacesPath", "namesetName"], "removeReferencesInRoleTypes": ["removeReferencesFromRoleNames", "removeReferencesInroleRelations", "removeReferencesInRoleType", "removeReferencesInServiceRelations", "removeReferencesedInroleType", "removeReferencesedInroletypes", "removeReferencesInServiceType", "removeReferencesInRoletypes", "removeReferencesInRuleType", "removeReferencesedInRoleTypes", "removeReferencesFromRoleRelations", "removeReferencesedInRoleNames", "removeReferencesInRuleRelations", "removeReferencesFromroleNames", "removeReferencesedInroleTypes", "removeReferencesInServiceNames", "removeReferencesedInroleNames", "removeReferencesInRoleNames", "removeReferencesFromroleTypes", "removeReferencesInRoleRelations", "removeReferencesInroleType", "removeReferencesInServiceTypes", "removeReferencesFromroleRelations", "removeReferencesInRuleTypes", "removeReferencesFromroleType", "removeReferencesInRuleNames", "removeReferencesInroletypes", "removeReferencesInroleTypes", "removeReferencesedInRoletypes", "removeReferencesedInRoleType", "removeReferencesFromRoleTypes", "removeReferencesInroleNames", "removeReferencesInRuletypes", "removeReferencesFromRoleType"], "permit": ["permits", "permmissions", "Permissions", "perMIT", "PERMIT", "PerMIT", "permission", "recmits", "permMIT", " perit", "Perit", "Permit", "permmit", "recmit", "recmission", "Permits", " permission", "Permission", "permissions", " permits", "perit", "PERmission", "permmission", "PERmissions", "recit", "PERmit"], "exist": ["purpose", "icate", "include", "write", "apply", "cmp", "except", "form", "destroy", "know", "stick", "inc", "draw", "check", "fail", "index", "support", "fill", "existence", "create", "add", "ist", "register", "keep", "edit", "delete", "same", "present", "match", "start", "list", "continue", "destruct", "existing", "diff", "existent", "cont", "ident", "front", "update"], "msgBuf": [" msgBuff", "msgEBuff", " msgFuf", "msgPlaf", "messageFbox", "msgPluf", "msgEBuf", " msgFbuf", "messageBbuf", "msgDuff", "msgAUF", "msgBbox", "msgFBUF", "messageFbuf", "msgDBuff", "msgBbuf", "msgFuf", "messageAuf", "msgFundle", "msgFbox", "msgDbuf", "msgDaf", "msgBob", "msgBraf", "msgLuff", "msgBUF", "msgDBuf", "messageAbuf", "msgPluff", " msgLaf", "msgLuf", "msgFBob", "msgEBbuf", "msgFBuff", "msgCuf", " msgLuff", "messageBuf", "msgLUF", "msgCuff", " msgFuff", "msgLaf", "msgLundle", "msgFUF", "msgFBuf", "msgBaf", "msgAraf", "messageBuff", "messageFob", "msgAuf", " msgFraf", "messageFUF", "messageBob", "msgAuff", "msgFbuf", " msgBundle", "messageBbox", "msgAbox", "msgDuf", "msgFob", "msgCob", "msgBundle", "msgLob", "msgAbuf", "msgAob", "msgAbuff", " msgBbuf", " msgFbuff", "msgFaf", " msgLundle", "msgBbuff", "msgFuff", " msgBaf", " msgFaf", "messageFuf", "messageFuff", " msgBbuff", "messageBUF", "msgFbuff", "msgAaf", "messageAuff", "msgBuff", " msgLuf", "messageAUF", "msgDBbuf", "msgFraf", " msgBraf", "msgEBbox", "msgCbuf", "msgDBUF", "msgPlundle"], "objects": ["notes", "values", "keys", "ins", "people", "pins", "kids", "archives", "products", "owners", "points", "os", "obs", "links", "users", "jobs", "parts", "cats", "relations", "archs", "oids", "agents", "apps", "plugins", "groups", "organisms", "parents", "features", "classes", "projects", "lines", "children", "results", "images", "properties", "pps", "files", "resources", "ids", "object", "frames", "names", "articles", "models", "obj", "bugs", "cells", "locks", "actions", "ops", "blocks", "types", "boxes", "members", "phones", "items", "ks", "roots"], "sqlRightId": ["sqlrightId", "sqlRightRef", "sqlRightPoint", "sqlRightType", "SQLRightID", "sqlRestId", "sqlRRef", "sqlRID", "sqlrightPoint", " sqlrightid", "sqlRestID", "SQLRightRef", "SQLRestID", "SQLRestId", "SQLRestid", "sqlLeftid", " sqlRightPoint", "sqlRId", " sqlrightId", "SQLRightid", "SQLRightId", "sqlRightID", "sqlRightid", " sqlrightPoint", "sqlrightid", "SQLRestRef", "sqlRestRef", " sqlrightType", "sqlLeftType", "sqlrightType", "sqlLeftId", "sqlLeftPoint", " sqlRightid", "sqlRestid", "sqlRid", " sqlRightType"], "sqlParent": [" sqlparent", "qlRoot", "suparent", "qlparent", "sqlParents", "suParents", " sqlRoot", "suParent", "qlParent", "suRoot", " sqlParents", "sqlparent", "qlParents", "sqlRoot"], "sql": ["replace", " db", "description", "log", "url", " SQL", "acl", "msg", "link", "session", " params", "error", " session", "conn", "s", "dl", " url", "delete", "db", "select", "repl", "sl", "operation", " msg", "where", "update", "SQL", "ql"], "pstmt": ["pctbl", " pSttr", "pftr", "pStm", " pndmt", "pndmb", "Pcttr", " pstmb", "pstatnt", " pStmt", "pctmb", "pmtbl", "postnt", " pstnt", "New", "pStct", "Security", "pmtmb", " pStm", "Pctct", "pstbl", "_", "pstrtr", "this", "pstm", "All", "pfct", "pStmt", " pStct", "add", "pstrm", "Pctmd", "pstmd", "pctmr", "Pstct", " pstmr", "pctm", "psttr", " pndmb", "pctct", "Pstmd", "postct", "Pctmt", "s", " pndct", " pstbl", "pndct", "pmtct", "pfmt", "pstatmt", "postmr", " postnt", "pmtmd", "pfmd", "pstatct", "Pstmt", "pstmb", "pstatmr", " pstm", "pctmd", "pmtmt", "pstmr", "pndbl", "The", "postmt", " pstct", "Error", "pstct", "pstnt", "pstrmt", "pctnt", "pSttr", "pndmt", " pndbl", "delete", " postmt", " postmr", "pstrct", " psttr", "pmttr", "pctmt", " postct", "Delete", "Psttr", "pcttr"], "typeGid": ["typegID", "linkGid", "linkGID", "TypeCmin", "TypeCID", "linkGoid", "typeGUid", "typeGVID", "typeGUname", "typegname", "TypeGmin", "typeGmin", "typeAccid", "typeWID", "TypeGid", "linkGname", "typeCname", "typeGname", "TypeCname", "TypeGname", "typegid", "typeGoid", "linkGVID", "TypeGID", "typeGVoid", "typeGID", "typeGUoid", "linkGVid", "typeWid", "linkGVoid", "TypeCid", "linkGVname", "typegoid", "typeGUID", "typeCmin", "typeGVid", "typeCID", "typeAccID", "typeAccname", "typeAccmin", "typeWname", "typeWmin", "typeCid", "typeGVname"], "defaultLevel": ["configDepth", "configCl", " defaultCl", "DefaultLevel", "defaultCl", "defaultMode", "configMode", " defaultDepth", "configLevel", "DefaultCl", "defaultDepth", " defaultMode", "DefaultDepth", "DefaultMode"], "success": ["warning", "replace", "resp", "message", "successfully", "complete", "failed", "successful", "data", "reg", "status", "result", "fail", "launch", "batch", "error", "accept", "test", "results", "Success", "progress", "roll", "match", "submit", "continue", "response", "serial"]}}
{"id1": "397240", "id2": "17207832", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @Test\n    public void returnsEnclosedResponseOnUnsuccessfulException() throws Exception {\n        Exception e = new UnsuccessfulResponseException(resp);\n        expect(mockBackend.execute(host, req, ctx)).andThrow(e);\n        replay(mockBackend);\n        HttpResponse result = impl.execute(host, req, ctx);\n        verify(mockBackend);\n        assertSame(resp, result);\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readandrewrites", "readandrewrite", "readAndRebrites", "readandRewrite", "readAndRebrite", "readAndrewrite", "readandRewwrite", "readAndRewrap", "readAndSwrites", "readAndSwwrite", "readAndrewwrite", "readandrewwrite", "readAndRebwrite", "readAndRewrites", "readAndSwrite", "readAndrewrap", "readandRewrap", "readAndrewrites", "readAndRebrap", "readandrewrap", "readAndSwrap", "readandRewrites", "readAndRewwrite"], "inFile": ["InFile", "infile", "oldFile", " inFiles", "inFilename", "oldFiles", "inputFile", " inFilename", " inSourceFile", "outFiles", "loginFiles", "loginfile", "loginFilename", "outfile", "Infile", "inputFilename", "outFilename", "oldfile", "outSourceFile", "InFiles", "oldFilename", "InSourceFile", "inputfile", "loginFile", "inputFiles", "inFiles", "inSourceFile", " infile"], "outFile": ["outFILE", " outfile", "processPlace", " outDir", "thisFilename", "exFILE", "outputPlace", "offFilename", "newfile", "processFilename", "outDir", "thisFILE", "exFilename", "exFile", "newStream", "thisFile", "outputFile", "offFILE", "outStream", "outfile", "outputFILE", " outStream", "outFilename", "offPlace", "thisfile", "newFile", "OutDir", "offFile", "Outfile", "newDir", "processFile", "OutStream", "outputFilename", "OutFile", "processFILE", "outPlace", "outputfile", "exfile"], "iis": ["ciiss", "IIS", "Iis", "iniris", " iais", " iiss", "iniiss", "iais", "ciais", "ciris", "ciIS", "Iiss", " iIS", "iiIs", " iIs", "iiiss", "iiis", "iris", "iiris", "iiIS", " iris", "iIS", "iniIS", "iniIs", "ciIs", "ciis", "iiss", "iniis", "iIs", "Iais"], "dcmParser": ["DcmInstallation", " dcmReader", "dpmPlugin", "dcmPolicy", "dkmHelper", "dbmParser", "dmcarser", "dmissionParser", " dcmparser", "dmoduleParser", "dhemParser", "dcmPlugin", " dcmLoader", "fpmParser", " dcmPolicy", " dcmHelper", "dpmInstallation", " dpmJar", "dcrPlugin", " dcmLanguage", "dCMparser", "dcmLoader", "dcmReader", "dcrParser", "dmissionReader", "dmcParser", "dkmParser", " dcrParser", "dcmparser", "dhemInstallation", "dkmPlugin", " dpmLanguage", "dmmparser", "dmParser", "dpmHandler", "dmissionPlugin", "dcmPar", "dCMReader", "dmoduleJar", "dcrLoader", "dcrJar", "dmmParser", "dbmPolicy", "dmodulePlugin", "dmReader", "dhemJar", " dcrReader", " dpmPar", " dpmPlugin", "fcmHandler", " dcrLoader", "fpmHandler", "dpmarser", "dmLoader", "dpmPolicy", "dbmHelper", "dcrarser", "dpmparser", "dbmPlugin", "dpmLanguage", "fcmReader", "fpmReader", "dcmarser", " dpmparser", " dcmPar", "dmPlugin", " dpmHelper", "dcmHelper", " dpmPolicy", "dmissionLanguage", "dcrPar", "dpmReader", "dCMHandler", "fpmparser", " dpmReader", " dpmarser", "DcmParser", "dpmParser", "dpmPar", "dkmPolicy", "dcmInstallation", "fcmParser", "DcmJar", " dcmJar", "dCMLoader", "fcmparser", "dmmPlugin", "dpmLoader", "dhemReader", "dmoduleReader", "dpmJar", "dCMParser", "dCMPlugin", "DcmReader", "dmcPar", "dmmLoader", "dpmHelper", "dmcJar", " dcmarser", "dcmHandler", " dpmLoader", " dcrPlugin", " dcmPlugin", "dmoduleparser", "dcrReader", "dcmLanguage", "dcmJar", " dpmParser"], "ds": ["ks", "ls", "Db", "ros", "js", "des", "ads", "DS", "ins", "details", "ss", "dr", "cdn", "df", "ps", "rs", "points", "os", "data", "ns", "parts", "sys", "session", "uds", "sync", "dd", "tx", "gd", "vs", "Ds", "amps", "d", "dat", "asi", "ys", "s", "conn", "ws", "is", "drivers", "tes", "src", "pd", "vals", "di", "qs", "db", "Os", "ras", "da", "eps", "ils", "iss", "dds", "icks", "dc", "xs", "ld", "ts", "ays", "nas", "gs", "cs", "utils", "services", "bs", "ants", "dt"], "pdReader": ["ddLoader", "pdLoader", "dsLoader", "pcLoader", "hdStream", "hdLoader", "pcReader", "hdRead", "ddReader", "hdReader", "dsWriter", "hdWriter", "dsreader", "pbRunner", "xdReader", "hdreader", "pdreader", "dsReader", "dsRead", "pdRunner", "pcRead", "ddRunner", "hdRunner", "pbReader", "pdStream", "pcWriter", "pbLoader", "xdRead", "pdRead", "xdWriter", "ddStream", "pbStream", "xdreader"], "out": ["ex", "writer", "default", "flow", "image", "parent", "null", "term", "data", "part", "in", "her", "exp", "o", "password", "conn", "pass", "temp", "cli", "outs", "over", "cache", "exec", "file", "err", "list", "net", "lib", "img", "page", "connection", "dot", "inc", "group", "model", "result", "key", "code", "builder", "point", "object", "w", "down", "layer", "word", "oder", "to", "gen", "url", "io", "outer", "store", "later", "sys", "sync", "Out", "dev", "s", "co", "login", "db", "user", "obj", "up", "device", "order", "diff", "again", "manager", "director", "at", "array", "ssl", "write", "copy", "lock", "child", "session", "external", "output", " in", "with", "client", "inner", "base", "name", "full", "OUT", "auto", "as", "line", "doc", "ext"], "dcmEncParam": ["dcmDecParam", "dcmEstPar", "dcmDecPart", "dcmEnType", "dcmElParameter", "dcmSecParam", "dcmEstParam", "dcmDecPar", "dcmElPar", "dcmDecParameter", "dcmArchParam", "dcmSecPart", "dcmEnParameter", "dcmEncArg", "dcmArchParameter", "dcmEncType", "dcmEnArg", "dcmEstType", "dcmSecType", "dcmEnPar", "dcmEncParameter", "dcmSecPar", "dcmArchArg", "dcmElParam", "dcmEstParameter", "dcmEncPart", "dcmElType", "dcmDecType", "dcmDecArg", "dcmEncPar", "dcmEnPart", "dcmEnParam"], "pdWriter": ["htWriter", "ddReader", "dsOutput", "hdWrite", "hdReader", "hdOutput", "htWriting", "pdWrite", "dsWriter", "ddWrite", "hdWriter", "dsReader", "dsWrite", "PDWriter", "dpWriter", "dpWriting", "PDReader", "PDWrite", "dpReader", "pdWriting", "ddWriter", "pdOutput", "ddOutput", "dpWrite", "htWrite", "htReader", "PDWriting"]}}
{"id1": "9275622", "id2": "9857412", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", " copyfile", " copyFolder", "transferfile", "copyFolder", "transferFolder", "copyFiles", "copyfile", "moveFolder", "transferFile", "moveFiles", "transferFiles", "moveFile", "movefile"], "_file1": ["_fileOne", "_file0", "_files1", "_zipone", "_mail2", "_resourceFirst", "_mail1", "_resourceone", "_File0", "_zipOne", "_fOne", "_File01", "_resource1", "_fone", "_fileone", "_files2", "_fileFirst", "_files01", "_mail0", "_mail01", "_files0", "_file01", "_File1", "_zipFirst", "_resourceOne", "_f1", "_fFirst", "_File2", "_zip1"], "_file2": ["jfile5", "jfile2", " _file3", "jmodelsecond", "_playTwo", "_play4", "_fileTwo", " _files4", "_play2", " _filesTwo", "_play5", "_model1", "_playsecond", "_play3", " _fileTwo", "jfilesecond", "_play1", "_files4", "jmodel2", "_filesTwo", " _files3", "_File5", "_filesecond", "jmodel5", "_files2", "_file5", "_model5", " _files2", " _file4", "_File1", "_file3", "_Filesecond", "jfile1", "_modelsecond", "_model2", "_file4", "_File2", "_files3", "jmodel1"], "fis": ["afais", "cfris", "cfos", "lfiss", "fi", " fas", "infis", " fris", "cfiss", "Fos", "infos", "infils", " fi", "afiss", "infiss", " fiss", "lfi", "cfis", "afis", "Fas", "lfis", "lfais", " fils", "fris", "Fils", " fais", "fiss", "fils", "fas", "Fris", "fais", "afi", "Fis", "cfas", "Fiss"], "fos": ["lis", "Faos", "infros", "Fros", "gus", "feus", "loes", "infus", "pos", "fOS", "foes", "gis", "fros", "fios", "flos", " foos", "pis", "infoos", "faos", "Fus", "fo", "Fos", "infos", "foses", "flis", "Foses", "los", "info", "foos", "infaos", "feoses", "floes", " fus", "goses", " faos", "feis", "Fo", " fo", " fios", "poes", "Fios", "gos", "infios", "flOS", "lOS", " fros", "pOS", "Foos", "fus", "feos", "Fis"], "canalFuente": ["canalBuente", "canalFuestro", "canalBuento", "canalCraencia", "canalBuze", "canaledBuje", "canallBuence", "canalBuencia", "canalFUestro", "canalsBuento", "canalFuencia", "canalFuze", "canallBuze", "canalFuento", "canallBuente", "canallFuencia", "canalKuente", "canaledFuente", "canaledFuje", "canalKuze", "canalCraence", "canalBuestro", "canaledBuente", "canalBuje", "canalFUze", "canaledFuze", "canalsFuento", "canalFuence", "canalsBuence", "canalFuje", "canalFUente", "canalSuente", "canalKuence", "canallFuze", "canallFuence", "canalCraente", "canalsBuente", "canalFUencia", "canallBuencia", "canalCraento", "canaledBuze", "canalFUence", "canalsFuence", "canalsFuencia", "canalBuence", "canalSuze", "canaledBuestro", "canalsBuencia", "canalsFuente", "canallFuente", "canaledFuestro", "canalKuento", "canalSuestro", "canalKuencia", "canalFUje", "canalSuje"]}}
{"id1": "886783", "id2": "14650352", "code1": "    private static void doGet(LNISoapServlet lni, String itemHandle, String packager, String output, String endpoint) throws java.rmi.RemoteException, ProtocolException, IOException, FileNotFoundException {\n        String itemURI = doLookup(lni, itemHandle, null);\n        URL url = LNIClientUtils.makeDAVURL(endpoint, itemURI, packager);\n        System.err.println(\"DEBUG: GET from URL: \" + url.toString());\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.setDoInput(true);\n        fixBasicAuth(url, conn);\n        conn.connect();\n        int status = conn.getResponseCode();\n        if (status < 200 || status >= 300) {\n            die(status, \"HTTP error, status=\" + String.valueOf(status) + \", message=\" + conn.getResponseMessage());\n        }\n        InputStream in = conn.getInputStream();\n        OutputStream out = new FileOutputStream(output);\n        copyStream(in, out);\n        in.close();\n        out.close();\n        System.err.println(\"DEBUG: Created local file \" + output);\n        System.err.println(\"RESULT: Status=\" + String.valueOf(conn.getResponseCode()) + \" \" + conn.getResponseMessage());\n    }\n", "code2": "    boolean checkIfUserExists(String username) throws IOException {\n        try {\n            URL url = new URL(WS_URL + \"/user/\" + URLEncoder.encode(username, \"UTF-8\") + \"/profile.xml\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.connect();\n            InputStream is = conn.getInputStream();\n            is.close();\n            return true;\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"doGet": ["doGET", " doPut", " doget", "doget", "Doget", "DoPut", "doPut", "DoGET", "toGet", "toPut", "toGET", "DoGet", "toget", " doGET"], "lni": ["rii", " lii", "rdi", "ioldi", "Ldi", "lti", "iolii", "Lti", "ldi", "rni", "Lii", "lii", "iolni", " lti", "rti", " ldi", "Lni", "iolti"], "itemHandle": ["pageHandle", "itemHand", "ItemHandle", " itemAddress", "ItemHandler", " itemHand", "itemsFile", "ItemHand", "pagehandle", "Itemhandle", "pageAddress", "itemsHandler", " itemHandler", "ItemAddress", " itemFile", "itemhandle", "itemsHandle", "pageURI", " itemhandle", "itemsHand", "ItemURI", "itemAddress", "itemHandler", "ItemFile", "itemFile"], "packager": ["installager", "installagers", "ackager", "Packagger", "ackatter", "Packatter", "packageager", "packagger", "paramager", "importaging", "packageatter", "Packager", "packatter", "packenger", "Packaging", "paramenger", "importagers", "ackagger", "ackaging", "paramaging", "importenger", "packageaging", "packageagger", "installenger", "installaging", "packagers", "importager", "packaging", "paramagers"], "output": ["office", "connection", "profile", "version", "ilo", "reference", "application", "web", "xml", "log", "control", "summary", "format", "model", "page", "online", "address", "console", "external", "buffer", "source", "image", "response", "path", "filename", "environment", "outer", "il", "config", "document", "null", "file", "module", "prefix", "message", "generated", "debug", "resource", "input", "queue", "target", "header", "written", "string", "write", "Output", "four"], "endpoint": ["restpoint", "endPoint", "endedend", "restend", " Endpoints", "Endpoint", " Endpoint", "Endend", "endpoints", " Endocol", "endpath", " endbase", " Endbase", " endpoints", "Endpath", " endocol", "endedpath", "Endpoints", "endocol", "endend", "Endocol", "endbase", "restPoint", "EndPoint", "endedPoint", "endedpoint", "restpath", "Endbase"], "ProtocolException": ["ProtocolBase", "ProtoException", "ProtocolFailure", "InterocolFailure", "ProtInterfaceException", "ProtoHandler", "InterocolHandler", "ProtportException", "ProtoFailure", "ProtocolHandler", "ProtInterfaceHandler", "InterportBase", "ProtInterfaceFailure", "ProtInterfaceBase", "ProtoBase", "InterocolException", "InterportException", "ProtportHandler", "InterportFailure", "InterocolBase", "InterportHandler", "ProtportFailure", "ProtportBase"], "IOException": [" IOEx", "IOError", "SecurityException", "SecurityError", "RemoteError", "IOEx", "SecurityEx", "RemoteEx", "RemoteException", " IOError"], "FileNotFoundException": ["FileIsAvailableExcept", "FileNotFoundExcept", "FileNotAvailableException", "FileNotfoundExcept", "FileIsAvailableError", "FileIsAvailableException", "FileNotAvailableError", "FileNotfoundError", "FileNotAvailableExcept", "FileIsFoundError", "FileNotFoundError", "FileNotfoundException", "FileIsFoundException", "FileIsFoundExcept"], "itemURI": ["containeruri", " itemRI", "objecturi", "ItemRI", "ItemURL", "containerRI", " itemUrl", "itemUrl", "objectURI", "containerURI", "itemURL", "itemRI", "itemuri", " itemuri", "Itemuri", "ItemURI", "objectURL", "objectUrl", " itemURL", "ItemUrl", "containerURL"], "url": ["connection", "job", "sl", "f", "loc", "org", "channel", "ur", "method", "el", "stream", "web", "download", "base", "ssl", "log", "ls", "ll", "page", "user", "bb", "zip", "l", "key", "client", "address", "Url", "i", "URL", "entry", "source", "image", "db", "hub", "path", "object", "li", "server", "uri", "io", "http", "c", "file", "impl", "id", "resource", "coll", "www", "host", "location", "rl", "ob", "il"], "conn": ["connection", "nt", "open", "cb", "oa", "cn", "socket", "nc", "sn", "error", "oss", "ca", "ct", "sync", "dn", "enc", "not", "en", "ec", "pc", "ann", "rc", "ssl", "conf", "orp", "fn", "err", "client", "dc", "connected", "cli", "ci", "ctx", "connect", "api", "ch", "uc", "db", "exec", "cf", "close", "config", "conv", "n", "server", "rt", "core", "io", "http", "c", "Conn", "co", "po", "coll", "cm", "con", "ai", "adj", "fail", "auth", "cp", "Connection", "col", "sql", "serv", "act"], "status": ["active", "msg", "ity", "login", "current", "version", "si", "error", "reason", "type", "method", "sync", "state", "str", "xml", "grade", "received", "class", "ix", "ssl", "size", "content", "Status", "success", "sex", "zip", "pre", "err", "warning", "source", "cli", "api", "response", "stage", "score", "level", "code", "server", "date", "rate", "id", "index", "sr", "message", "prefix", "stat", "result", "cm", "header", "fail", "progress", "json", "site"], "in": ["reader", "bin", "isin", "login", "data", "socket", "ins", "pin", "stream", "cin", "min", "In", "inside", "inner", "again", "rin", "win", "r", "din", "IN", "o", "pull", "ini", "i", "source", "init", "inc", "nin", "or", "n", "io", "inn", "up", "id", "a", "lin", "input", "con", "gin", "rx"], "out": ["bin", "extra", "ext", "doc", "self", "at", "sync", "ex", "outs", "min", "plain", "log", "copy", "user", "again", "cache", "w", "img", "writer", "line", "err", "plus", "o", "off", "client", "OUT", "temp", "this", "lib", "inc", "ch", "exec", "parent", "outer", "n", "io", "net", "file", "up", "co", "on", "ou", "exp", "Out", "gin", "obj"]}}
{"id1": "19849797", "id2": "4716110", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["transferFiles", "clonefile", " copySource", "copyfile", "copyFiles", "cloneSource", "transferfile", "transferFile", "cloneFiles", "cloneFile", "transferSource", " copyfile", "copySource", " copyFiles"], "sourceFile": ["destDirectory", "sourceDir", "ourceDirectory", "srcFile", "srcfile", "destfile", " sourcefile", " sourceFolder", "sourceDirectory", "ourceFile", "destUrl", "SourceUrl", "ourcefile", "SourceFolder", "SourceDir", "SourceFile", "sourcefile", "sourceFolder", "sourceUrl", "ourceUrl", "srcFolder", "SourceDirectory", "srcDir", " sourceDir", "Sourcefile"], "destFile": ["destDirectory", "sourceDir", "destfile", "srcfile", "srcFile", "DestPoint", "targetfile", " destDir", "destDir", "DestDirectory", " destPoint", "DestDir", "DestFiles", "foreignPath", "destPath", "targetLine", "foreignFiles", "resultfile", "resultDir", "targetDir", "targetFiles", " destFiles", " destDirectory", "targetFile", "destPoint", "resultFile", "srcFiles", "sourceFiles", "srcDirectory", "targetPath", "srcLine", " destfile", "DestFile", "foreignfile", "foreignFile", "sourcePoint", "resultLine", "srcDir", "DestPath", "destFiles", "Destfile", "destLine"], "source": ["remote", "result", "cache", "uri", "current", "client", "table", "output", "session", "inner", "config", "this", "use", "component", "seed", "slave", "view", "root", "ie", "input", "ource", "src", "image", "SOURCE", "manager", "sin", "get", "Source", "service", "object", "resource", "proxy", "ce", "from", "storage", "dest", "core", "si", "url", "null", "server", "secure", "api", "scene", "index", "connection", "scope", "channel", "size", "stream", "wrapper", "reference", "iter", "file", "route", "slice", "id", "unit", "reader", "site", "parent", "start", "target", "status", "context"], "destination": ["identinator", "Destion", "Destribution", "destinated", "domation", "constinator", " destation", "distion", "constribution", "distinated", " destion", "Destinated", "destation", "dominator", "generinator", "generination", " destruction", "Destruction", "destinate", "Destation", "dominated", "distruction", "generinated", " destinator", "Destinate", "participinator", "participinate", " destinated", "Destination", "constination", "destruction", "distination", "destinator", "identinated", "distinator", "participinated", "construction", " destribution", "identination", "generruction", "destion", "destribution", "participination", "Destinator", "domination", "identinate"]}}
{"id1": "7169984", "id2": "19378010", "code1": "    public static String connRemote(JSONObject jsonObject, String OPCode) {\n        String retSrc = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(AZConstants.validateURL);\n            HttpParams httpParams = new BasicHttpParams();\n            List<NameValuePair> nameValuePair = new ArrayList<NameValuePair>();\n            nameValuePair.add(new BasicNameValuePair(AZConstants.ACTION_TYPE, OPCode));\n            nameValuePair.add(new BasicNameValuePair(AZConstants.PARAM, jsonObject.toString()));\n            httpPost.setEntity(new UrlEncodedFormEntity(nameValuePair));\n            httpPost.setParams(httpParams);\n            HttpResponse response = httpClient.execute(httpPost);\n            retSrc = EntityUtils.toString(response.getEntity());\n        } catch (Exception e) {\n            Log.e(TAG, e.toString());\n        }\n        return retSrc;\n    }\n", "code2": "    public static Multimap<String, String> getProteins(final Set<String> queries, final int taxon) throws ParserConfigurationException, XPathExpressionException {\n        final DocumentBuilder parser = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n        final XPathExpression xpe = XPathFactory.newInstance().newXPath().compile(__xpath);\n        final Multimap<String, String> proteins = HashMultimap.create();\n        for (final String query : queries) {\n            HttpURLConnection connection = null;\n            try {\n                final String encoded = URLEncoder.encode(query.trim(), \"UTF-8\");\n                final URL url = new URL(String.format(__urlTempl2, encoded, taxon));\n                connection = (HttpURLConnection) url.openConnection();\n                connection.setConnectTimeout(__connTimeout);\n                connection.setReadTimeout(__readTimeout);\n                connection.setRequestProperty(\"Connection\", \"close\");\n                connection.connect();\n                final InputStream stream = connection.getInputStream();\n                final Document doc = parser.parse(stream);\n                final NodeList nodes = (NodeList) xpe.evaluate(doc, XPathConstants.NODESET);\n                if (nodes != null) {\n                    final int n = nodes.getLength();\n                    for (int i = 0; i < n; i++) {\n                        final Node node = nodes.item(i);\n                        proteins.put(node.getTextContent().trim(), query.trim());\n                    }\n                }\n            } catch (final Exception ex) {\n                continue;\n            } finally {\n                if (connection != null) connection.disconnect();\n            }\n        }\n        return proteins;\n    }\n", "label": 0, "substitutes": {"connRemote": ["execIP", "invokeURL", "execLocal", " execRemote", " executeURL", "invokeIP", " executeRemote", " executeLocal", " executeIP", " execLocal", "execURL", " execURL", "execRemote", " execIP", "invokeRemote", "invokeLocal"], "jsonObject": ["JSONArray", "jsonObj", "jsonOperation", "httpOperation", " jsonString", "JSONBody", "httpObject", "httpArray", "customArray", "jsonArray", "customObject", "jsonBody", "jsonOb", " jsonBody", "javaBody", " jsonOb", "customObj", "JSONOb", "JSONOperation", "javaObject", "jsonString", "httpObj", "JSONString", "javaString", "customOperation", "javaOb", "JSONObject", "JSONObj"], "OPCode": ["OPcode", " OPcode", "OpCode", "OPName", "opName", " OPName", "opCode", "OPAction", "OpAction", " OPAction", "opAction", "opcode", "Opcode", "OPERCode", "OpName", "OPERcode", "OPERName"], "retSrc": [" retSsrc", "retOsrt", "retInrc", "retSrt", "RetAsrc", "retDRC", "retOsRC", "retInuc", "retSuc", " retSrt", "retDrc", "retNRC", "retDuc", "RetAsuc", "RetAsck", "retInck", "retSck", "retSRC", "retPvc", " retSvc", "retSsrc", "RetSuc", "retDck", " retDrc", "retOssrc", "retNrc", "retPRC", "retNsrc", "retNvc", "RetAsRC", "RetSrc", " retDsrc", "retNrt", "retOsrc", "retAsRC", "retPsrc", "RetSRC", " retDRC", " retSRC", "retDrt", "retPrc", " retDrt", "retInRC", "retAsck", "retAsuc", "RetSck", "retAsrc", "retSvc", "retDsrc"], "httpClient": ["HttpClient", "httpsClient", "HttpConnection", "httpsCall", "apiPost", "phpCall", "httpProxy", "httpConnection", "apiCall", "HttpProxy", "xmlClient", " httpProxy", " httpConnection", "httpCall", "httpCase", "xmlProxy", "phpclient", "httpsPost", "xmlCase", "apiclient", "apiClient", "phpPost", "HttpCase", "phpClient", " httpCase", "xmlConnection", "httpclient", "httpsclient"], "httpPost": ["webPost", "workpost", "autoPost", "HttpCopy", "workPre", "HttpPost", " httpPOST", "webpost", "httpPre", "httpsPOST", "htmlPOST", "httpDo", "httpPOST", " httpPre", " httpCopy", "HttpDo", " httpRequest", "autoPOST", "httppost", "httpsPre", "workPost", "httpsPost", "phpPost", "httpRequest", "autoPre", "phpPOST", "workDo", "phpRequest", "httpsCopy", "HttpPOST", "webDo", "HttpPre", "httpCopy", "phpDo", "htmlPost", "autoCopy", "webPre", "htmlDo", "HttpRequest", " httppost", " httpDo", "htmlCopy"], "httpParams": ["httpArgms", "hrParars", "hrPam", "httpCatars", "httpPms", "hrPams", " httpParums", "httpPeram", " httpParars", "httpPerars", "httpCatms", " httpPums", "httpVariums", "httpParums", " httpPam", "httpCatams", "httpPerums", "httpParars", " httpPars", "httpParms", "httpVariars", " httpPams", "hrParams", "httpPars", "httpArgams", "hrPars", "httpPams", "httpVariams", "httpParam", "httpArgam", "httpArgars", "httpPerams", "hrPms", "httpVariam", " httpParam", "hrParam", "httpPam", "httpCatam", "httpPums", "hrParms"], "nameValuePair": ["nameNamePenter", "nameNameLair", "nameValueLolder", "nameValuePhair", "nameValuePatch", "nameVPait", "nameValueSair", "nameNamePiece", "nameNameLolder", "nameValueParait", "nameValueFiece", "nameValueProtenter", "nameValuePointair", "nameValueCait", "nameNamePatch", "nameValueLair", "nameVPair", "nameValuePait", "nameNameProtenter", "nameValueProtpair", "nameNamePore", "nameValueportion", "nameValuepiece", "nameValuePerair", "nameValuepatch", "nameNamePolder", "nameNamepiece", "nameValueProtore", "nameValueFair", "nameValueProtair", "nameNamepair", "nameValuePiece", "nameValueParpair", "nameNameProtair", "nameNameProtpair", "nameValuePeratch", "nameVPpair", "nameValuepolder", "nameValuePpair", "nameValuePore", "nameValueParair", "nameValueSore", "nameValuepair", "nameNameProtore", "nameNamePair", "nameValuepait", "nameValueLatch", "nameValuePointpair", "nameValueFortion", "nameValuePhiece", "nameValueCair", "nameVCait", "nameValuePenter", "nameValueppair", "nameNamePpair", "nameValuePointenter", "nameValueSenter", "nameNameLatch", "nameNameportion", "nameVCair", "nameValuePortion", "nameVCpair", "nameValueCpair", "nameValuePhortion", "nameNamePortion", "nameValuePolder", "nameValuePerolder", "nameValueSpair", "nameValuePointore"], "response": ["message", "method", "result", "output", "json", "session", "f", "environment", "status", "page", "view", " Response", "e", "i", "success", "tree", "application", "resp", "data", "throw", "object", "resource", "reply", "server", "Response", "entity", "api", "res", "body", "jet", "connection", "respond", "channel", "full", "block", "request", "wave", "feed", "site", "v", "http"]}}
{"id1": "15896098", "id2": "21033686", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public File read() throws IOException {\n        URLConnection conn = url.openConnection();\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n        conn.connect();\n        int length = conn.getContentLength();\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        if (tempDir == null) {\n            tempDir = \".\";\n        }\n        File tempFile = new File(tempDir + \"/\" + new GUID() + \".dat\");\n        tempFile.deleteOnExit();\n        InputStream in = null;\n        OutputStream out = null;\n        ProgressMonitor monitor = new ProgressMonitor(parentComponent, \"Downloading \" + url, null, 0, length);\n        try {\n            in = conn.getInputStream();\n            out = new BufferedOutputStream(new FileOutputStream(tempFile));\n            int buflen = 1024 * 30;\n            int bytesRead = 0;\n            byte[] buf = new byte[buflen];\n            ;\n            long start = System.currentTimeMillis();\n            for (int nRead = in.read(buf); nRead != -1; nRead = in.read(buf)) {\n                if (monitor.isCanceled()) {\n                    return null;\n                }\n                bytesRead += nRead;\n                out.write(buf, 0, nRead);\n                monitor.setProgress(bytesRead);\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n            monitor.close();\n        }\n        return tempFile;\n    }\n", "label": 0, "substitutes": {"getSHA256Checksum": ["getSHA256Checsum", "getSHA256Checsumber", "getSHA256Chechecksums", "getSHA256Chcksam", "getSHA256Checksam", "getSHA256Chchecksam", "getSHA256Chchecksums", "getSHA256Chcksums", "getSHA256Checsam", "getSHA256Checksums", "getSHA256Cheicksam", "getSHA256Chechecksum", "getSHA256Chechecksam", "getSHA256Cheicksums", "getSHA256Chcksum", "getSHA256Chchecksum", "getSHA256Cheicksum", "getSHA256Chchecksumber", "getSHA256Chcksumber", "getSHA256Checsums", "getSHA256Chechecksumber", "getSHA256Cheicksumber", "getSHA256Checksumber"], "source": ["buffer", "service", "size", "src", "output", "object", "input", "slice", "cache", "from", "result", "target", "format", "connection", "content", "code", "path", "message", "resource", "fp", "dest", "file", "Source", "url", "base", "data", "SOURCE", "text", "reader", "string", "seed", "uri", "ource", "config", "length", "ources"], "checksum": ["checksums", "cssum", "check256", "checkum", "hssum", "hsam", " checksums", "checksam", "cksums", " checkssum", " checksumption", " checksam", "hexumption", "hexet", "checksup", "checkssum", " checkset", "hexum", "checks256", "cksum", "checkup", "cksam", "checksumption", "ckset", "hexsum", " checksup", "cksumption", "ckssum", " checks256", "csup", "checkset", "csum", "hsum", "cs256", "hsums"], "md": ["mm", "mac", "mo", "ind", "m", "Cmd", "dig", "bf", "grad", "MB", "pd", "metadata", "M", "um", "od", "rm", "mb", "cm", "amd", "nm", "df", "wd", "dh", "mand", "bd", "gd", "f", "sm", "dm", "pm", "mt", "MD", "mp", "mc", "hd", "vd", "mag", "d", "rpm", "ms", "am", "hash", "cmd", "dd", " MD", "vm", "hm"], "byteData": ["ByteArray", "ByteSize", "connectionDATA", "byteInfo", "byteText", "ipDATA", "characterData", "ipArray", "connectionSize", "ByteDATA", " bytedata", "wordInfo", "wordBytes", "ByteData", "byteList", "ipNumber", "byteSize", "bitList", "ByteInfo", "byteArray", "bitText", " byteArray", "numberdata", "ByteBytes", "characterArray", "bitData", "bytedata", "pixelData", " byteNumber", "wordData", " byteBytes", "wordArray", "numberDATA", " byteString", " byteDATA", "numberData", " byteText", " byteInfo", "numberString", "byteNumber", "pixelString", "connectionArray", "byteString", "characterList", "bitDATA", "bitNumber", "pixeldata", "pixelDATA", "characterText", " byteList", "connectionData", "ipData", " byteSize", "byteBytes", "byteDATA", "bitArray"], "sb": ["db", "abb", "bp", "buffer", "bf", "src", "ab", "lb", "bs", "bt", "SB", "bb", "ls", "usb", "sf", "sg", "bc", "rb", "bm", "fb", "kb", "bg", "mb", "ob", "buff", "gb", "pb", "ub", "bh", "bd", "eb", "buf", "binary", "wb", " SB", "BB", "sq", "b", "bsp", "xb", " eb", "si", "nb", "sv", "ws", "cb"], "i": ["r", "ai", "ip", "in", "j", "p", "h", "n", "ie", "key", "is", "q", "multi", "ix", "slice", "e", "phi", "id", "abi", "ci", "gi", "ui", "info", "li", "index", "ii", "io", "ori", "iu", "ini", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "data", "u", "ni", "b", "y", "v", "ji", "w", "oi", "it", "mi", "di", "l", "hi", "d", "si", "qi", "uri", "I", "c"], "hexString": ["formService", " hexArray", "shortBuffer", "charStr", "checkString", " hexStr", "hexstring", "formString", "checkService", "hexArray", " hexService", " hexFile", "hexCode", "charBuffer", "formstring", "shortString", "rawArray", "rawService", "rawstring", "crossBuffer", "charString", "crossStr", "hexFile", "checkCode", "crossFile", "exFile", "checkArray", "shortStr", "rawString", "hashService", "charArray", "exStr", " hexCode", "hashString", "exBuffer", " hexBuffer", "hashCode", "crossString", "hashArray", "exString", "hexBuffer", "hexStr", "shortArray", " hexstring", "hexService", "formArray"], "hex": ["ip", "sync", "alpha", "bit", "form", "character", "serial", "nexus", "id", "ex", "sex", "cookie", "sum", "format", "wh", "exp", "num", "http", "rh", "buff", "pack", "digit", "closure", "cross", "raw", "lit", "str", "pex", "oct", "letter", "null", "none", "zip", "data", "temp", "rex", "char", "comp", "transform", "color", "text", "pixel", "bin", "coord", "string", "utf", "hash", "cmp", "shift", "length"]}}
{"id1": "3514286", "id2": "7087108", "code1": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"getHashedPassword": ["getHashedpassword", "getHashingPassword", "getHashingHash", "getHhedPassword", "getHampedHash", "getHampedpassword", "getHampedPassword", "getMampedPass", "getMampedpassword", "getHashingPass", "getHhedPass", "getHashingpassword", "getHashedHash", "getMashedPassword", "getMampedPassword", "getHashedPass", "getMampedHash", "getHhedpassword", "getHampedPass", "getMashedpassword", "getMashedPass", "getMashedHash", "getHhedHash"], "password": ["account", "buffer", "words", "p", "email", "crypt", "pattern", "user", "input", "attribute", "sword", "cache", "phrase", "address", "padding", "Password", "code", "content", "message", "word", "out", "wd", "prefix", "pass", "confirmed", "wallet", "data", "token", "secret", "number", "text", " passwords", "name", "auth", "string", "seed", " Password", "encrypted", "hash", "PASS", "username"], "digest": ["hashester", " digested", "mdester", "mdend", "hashoder", " digoder", " digend", "digoder", "DigEST", "mdest", "dEST", " digests", "diggest", "diger", "digests", "Diger", " digEST", "mder", "digend", "Digest", "hashher", " diger", "dgest", "Digester", " digester", "hashest", "dest", "Digests", "Digoder", "digester", "dests", "digEST", "mdEST", "Digher", "Digend", " diggest", "mdested", "digher", "digested", "Diggest", "Digested", " digher"], "hashedInt": ["hhedint", "hryptedInt", "rhashedInt", "hhedInt", "haledLong", "hashObj", "hryptedint", "hashInteger", "rhashint", "hashedLong", "haledint", "hachedint", "hashedInteger", "rhashedint", "hachedInt", "hashInt", "hryptedInteger", "haledInt", "haledINT", "hhedInteger", "hachedINT", "rhashedInteger", "HhedLong", "Hhedint", "rhashObj", "hashedObj", "HashedINT", "hashedINT", "Hashedint", "rhashedObj", "hhedLong", "hhedObj", "HhedInt", "hryptedObj", "HashedInt", "HashedLong", "HhedINT", "hashint", "hashedint", "hachedLong", "rhashInteger", "rhashInt", "hhedINT"]}}
{"id1": "18370075", "id2": "4716110", "code1": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 0, "substitutes": {"createPasswordDigest": ["createPassworddigenge", "createPasswordSignester", "createpassworddigenge", "createPasswordSignifier", "createpasswordDigest", "createPassworddigester", "createPassworddigifier", "createpassworddigester", "createPasswordSignest", "createPasswordDigester", "createPasswordModenge", "createPassworddigest", "createPasswordDigenge", "createpasswordDigifier", "createpassworddigest", "createpasswordDigenge", "createPasswordModifier", "createPasswordDigifier", "createPasswordSignenge", "createpassworddigifier", "createPasswordModester", "createPasswordModest", "createpasswordDigester"], "password": ["p", "account", "secret", "text", "message", "source", "filename", "words", "token", "path", "username", "config", "pad", "hash", "wd", "seed", "pass", "phrase", "command", "word", "padding", "data", "auth", "email", "PASS", "database", "name", "sword", "security", "address", "wallet", "Pass", "string", "crypt", "Password", "key", "login", "user", "pattern"], "salt": ["psecret", "sass", "sessecret", "sesALT", " ssecret", "sesalt", "pass", "pALT", "palt", "Sass", "ssALT", "ssass", "SALT", "Salt", "sssecret", "sALT", " sass", " sALT", "sesass", "ssecret", "Ssecret", "ssalt"], "md": ["me", "mand", "message", "mm", "clean", "mod", "amd", "cmd", "dm", "po", "mb", "meta", "ind", "ph", "m", "nm", "ad", "metadata", "mad", "mac", "bf", "ms", "kg", "code", "nd", "zip", "pd", "sha", "gd", " MD", "od", "di", "dd", "ld", "mo", "mn", "mt", "cd", "MD", "mc", "ma", "mag", "pm", "d", "bd", "mail"], "digest": ["generests", "decress", "Digester", "dester", "DigEST", "digress", "hashest", "signcode", "digEST", "dEST", "decests", "digested", " digests", "decest", "hashested", "generester", "dested", "hashester", "dest", "signested", "generest", " digEST", "digests", "signester", "generress", "Digest", " digcode", "decester", " digested", "Digested", "digester", " digress", "hashcode", "digcode", " digester", "signest"]}}
{"id1": "20623709", "id2": "20128728", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"split": ["process", "match", "sort", "sync", "delete", "transfer", "init", "parse", "Split", "copy", "archive", "run", "open", "diff", "share", "format", "build", "part", "start", "exec", "set", "update", "execute", "append", "cmp", "add", "join"], "targetDirectory": ["outputDirectory", "targetDir", " targetDir", "masterDirectory", "targetFolder", " targetFile", " targetPath", "baseDatabase", "outputFile", "baseFolder", "targetRoot", "basePath", "targetDatabase", "outputDir", "currentPath", "masterDatabase", "targetPath", "destDir", "destDirectory", "TargetRoot", "destFolder", "currentDir", "currentFolder", "baseDirectory", " targetRoot", "outputFolder", " targetFolder", "destFile", "TargetDirectory", "TargetFolder", "masterDir", "masterPath", "baseFile", "baseDir", "currentRoot", "TargetDir", "TargetPath", "currentDirectory", "targetFile", "TargetFile", "TargetDatabase"], "prefix": ["domain", "timeout", "template", "queue", "pattern", "pre", "username", "ix", "sequence", "patch", "directory", "cache", "padding", "format", "path", "resource", "index", "fp", "fixed", "root", "config", "prot", "unit", "base", "Pref", "temp", "type", " suffix", "append", "offset", "number", "FIX", "name", "string", "resolution", "folder", "uri", "fix", "first", "filename", "txt"], "maxUnitBases": ["maxUnitBasing", "maxUnitChase", "maxunitAliaches", "maxUnitAliase", "maxunitAliases", "maxUnitAliases", "maxUnitEaches", "maxunitAliasing", "maxUnitBails", "maxUnitBase", "maxUnitEase", "maxUnitQuease", "maxUnitAliues", "maxunitBails", "maxUnitChases", "maxUnitAliaches", "maxUnitEases", "maxUnitQueues", "maxunitAliase", "maxUnitChasing", "maxunitAliails", "maxUnitPlases", "maxUnitAliails", "maxUnitPlails", "maxunitBase", "maxunitBases", "maxUnitChues", "maxunitAliues", "maxUnitQueases", "maxUnitQueasing", "maxUnitPlase", "maxunitBasing", "maxunitBues", "maxUnitEails", "maxUnitPlaches", "maxUnitAliasing", "maxUnitBues", "maxUnitBaches", "maxunitBaches"], "maxUnitEntries": ["maxUnitEntures", "maxUnitCountry", "maxLineEntines", "maxUnitIntresses", "maxLineEntry", "maxUnitErines", "maxUnitEntryures", "maxUnitErrations", "maxUnitEntry", "maxUnitOrdries", "maxUnitIntries", "maxUnitOrdresses", "maxunitEntryresses", "maxunitEntrys", "maxUnitEntrys", "maxUnitEntresses", "maxunitEntryries", "maxUnitCountries", "maxUnitEntrations", "maxUnitAddries", "maxLineEntrations", "maxUnitAddry", "maxUnitEntryry", "maxunitEntries", "maxLineOrdries", "maxUnitEntryries", "maxUnitCountrations", "maxLineOrdrations", "maxUnitIntrys", "maxUnitEntryresses", "maxUnitAddures", "maxUnitEntryies", "maxUnitEnties", "maxUnitEntryrys", "maxunitEntryrys", "maxLineOrdry", "maxUnitErry", "maxLineOrdines", "maxUnitCountines", "maxUnitAddresses", "maxunitEntryies", "maxUnitEntines", "maxUnitOrdies", "maxUnitInties", "maxUnitOrdry", "maxunitEntresses", "maxUnitOrdrations", "maxUnitErries", "maxunitEnties", "maxUnitOrdines", "maxLineEntries", "maxUnitOrdrys"], "fis": ["foris", "fai", "vis", "visa", " fris", "fIs", "vIs", "forai", " fai", "forisa", " fIs", " fisa", "fisc", " fiss", "foriss", "vai", "forris", " fisc", "fris", "forIs", "Fisc", "forisc", "fiss", "Fris", "fisa", "Fis", "Fiss"], "fci": ["hco", "fai", "bis", "dci", "Fii", "efcos", "bco", "efco", "dii", "efai", "hci", "fcos", "vco", "dco", "Fai", "fii", " fai", "hcos", "Fco", "vci", "efci", "vai", "bai", "hai", "Fci", " fii", "doci", "Foci", " foci", "vcos", "foci", "Fis", "bci"], "fos": ["toss", "fso", "ifo", "foes", "fios", "ifios", "infis", "foss", "fo", "Fos", "infoss", "ifcos", "infos", "fcos", "fsos", " fcos", "fsios", "Foss", "toes", "fscos", "tos", " fo", " fios", "ifos", "infoes", "Foes", "Fis", "tis"], "fco": ["hco", " fbo", "dci", "Fico", "fgo", "hgo", "fileico", "hci", "fileci", "fico", "fcos", "dco", " fro", "hcos", " fcos", "Fco", "fro", " fico", "lgo", "dro", "fbo", "lro", "lci", "fileco", "Fci", "lco", "filebo", "dcos", "Fbo", " fgo", "lcos"], "buffer": ["request", "pause", "image", "pad", "position", "timeout", "writer", "rate", "size", "batch", "capacity", "entry", "block", "queue", "read", "transfer", "view", "comment", "feed", "context", "input", "layer", "reference", "copy", "expression", "Buffer", "cache", "server", "info", "source", "result", "bc", "resource", "response", "message", "zero", "buff", "translation", "uffer", "iter", "buf", "binary", "channel", "base", "callback", "null", "scale", "data", "loader", "border", "bar", "offset", "document", "memory", "bin", "reader", "counter", "header", "window", "texture", "flush", "device", "length"], "currentBasesCount": ["currentBasecount", "currentBaseNum", "currentBatchesCounter", "currentBatchescount", "currentBatchesCount", "currentBasesCounter", "currentChasesCounter", "currentChasecount", "currentBasesNum", "currentChasesNum", "currentBasingNum", "currentChaseCount", "currentBatchesNum", "currentBaseCounter", "currentChasescount", "currentBasingCount", "currentBasescount", "currentChasesCount", "currentChaseNum", "currentBaseCount", "currentChaseCounter", "currentBasingcount", "currentBasingCounter"], "currentEntriesCount": ["currentEntursOffset", "currentEntriesOffset", "currentAddriesOffset", "currentAddriesLimit", "currentEnturesLimit", "currentEnturesSize", "currentAdduresOffset", "currentAdduresCount", "currentEntursCount", "currentEntriesLimit", "currentAdduresLimit", "currentEntursLimit", "currentEntrasCount", "currentEntrasSize", "currentEntriesSize", "currentAdduresSize", "currentEnturesCount", "currentAddriesSize", "currentEntrasLimit", "currentEntrasOffset", "currentEnturesOffset", "currentEntursSize", "currentAddriesCount"], "targetCount": ["targetSize", "argetCount", "patternSize", "targetcount", "Targetcount", "argetSize", "TargetCount", "patterncount", "TargetSize", "TargetSum", "patternSum", "argetSum", "targetSum", "argetcount", "patternCount"], "fastaChannel": [" fastaConnection", " fastAChannel", "fastaConnection", "fastAChannel", "fastaqColumn", "fastasContext", "fastaColumn", "fastAColumn", "fastaContext", "fastaContainer", "fastAConnection", "fastasColumn", " fastaColumn", "fastAContainer", "fastaqChannel", "fastABuffer", " fastABuffer", "fastAContext", "fastaqBuffer", " fastAContext", "fastanBuffer", " fastAColumn", " fastaContext", "fastasBuffer", "fastasChannel", "fastaqConnection", "fastanChannel", " fastAConnection", "fastasContainer", " fastAContainer", "fastanContext", " fastaContainer", "fastasConnection", "fastanContainer"], "totalSeqCount": ["totalSeuxCount", "totalSeuxNum", "totalQueQCounter", "totalQueQNum", "totalSeqsCounter", "totalSeQCounter", "totalQueqCount", "totalQueqNum", "totalSeqCounter", "totalSeqsCount", "totalSeQNum", "totalSeqNum", "totalSeqsNum", "totalSeuxcount", "totalSeqcount", "totalSeQcount", "totalQueQcount", "totalSeqscount", "totalQueqCounter", "totalQueqcount", "totalQueQCount", "totalSeuxCounter", "totalSeQCount"], "totalResiduesCount": ["totalResqueuresCount", "totalResqueuresNum", "totalResidurescount", "totalResiduingNum", "totalResiduescount", "totalResiduationCount", "totalResiduingSize", "totalResqueuescount", "totalResqueuesNum", "totalResiduationSize", "totalResiduingCount", "totalResiduationcount", "totalResqueuesCount", "totalResiduesSize", "totalResqueurescount", "totalResqueuresSize", "totalResiduesNum", "totalResiduationNum", "totalResqueuesSize", "totalResiduresNum", "totalResiduresCount", "totalResiduresSize", "totalResiduingcount"], "prevTime": ["PrevSize", "prevValue", "PrevFile", " prevFile", "prevFile", "prevSize", "commitValue", "commitSize", "commitFile", "PrevValue", " prevSize", "commitTime", " prevValue", "PrevTime"], "fastaFileSize": ["fastaLineSize", "fastasFileName", "fastaFileName", "fastaFilesLength", "fastasHeaderName", "fastABufferCount", "fastaFileCount", "fastAFileLength", "fastaBufferCount", "fastaBufferSize", "fastaLineAddress", "fastABufferSize", "fastaFileLength", "fastaFilesAddress", "fastaFilesName", "fastaBlockAddress", "fastaPageLength", "fastaHeaderLength", "fastaBufferLength", "fastaLineLength", "fastaFilesSize", "fastaLineCount", "fastaHeaderSize", "fastAFileSize", "fastasFileSize", "fastaPageAddress", "fastasFileAddress", "fastaBlockSize", "fastABufferAddress", "fastaPageSize", "fastasHeaderSize", "fastaBufferAddress", "fastABufferLength", "fastaFileAddress", "fastasFileLength", "fastAFileCount", "fastaBlockLength", "fastaPageName", "fastasHeaderLength", "fastaBlockCount", "fastAFileAddress", "fastaHeaderAddress", "fastasHeaderAddress", "fastaHeaderName"], "fastaFileReadOffset": ["fastaFileWriteOffset", "fastaDirectoryReadOffset", "fastaBufferWriteLength", "fastaFilereadOff", "fastaDirectoryWriteEntry", "fastaDirectoryReadoffset", "fastaDirectoryWriteOffset", "fastaFilesReadLength", "fastaBufferReadoffset", "fastaFilereadLength", "fastaFileLoadOffset", "fastaFileStartEntry", "fastaBufferReadLength", "fastaFilereadOffset", "fastaFileRunOff", "fastaDirectoryWriteoffset", "fastaBufferWriteOffset", "fastaFileWriteOff", "fastaFileStartOff", "fastaDirectoryReadEntry", "fastaFileLoadAmount", "fastaFilesWriteLength", "fastaDirectoryReadOff", "fastaFileLengthOffset", "fastaFileRunoffset", "fastaBufferWriteoffset", "fastaFileLoadLength", "fastaFileLengthAmount", "fastaFilereadoffset", "fastaFileWriteEntry", "fastaFileWriteAmount", "fastaFilesWriteOff", "fastaFileStartOffset", "fastaFileLengthLength", "fastaBufferReadOffset", "fastaFilesReadOffset", "fastaFileReadAmount", "fastaFileRunEntry", "fastaFileReadoffset", "fastaFileRunOffset", "fastaFileWriteLength", "fastaFilesWriteoffset", "fastaFileReadOff", "fastaFileLengthoffset", "fastaDirectoryWriteOff", "fastaFileReadLength", "fastaBufferReadAmount", "fastaFilesReadOff", "fastaFilesReadoffset", "fastaFileLengthOff", "fastaFileLoadoffset", "fastaFileStartoffset", "fastaBufferWriteAmount", "fastaFileWriteoffset", "fastaFileReadEntry", "fastaFilesWriteOffset"], "partitionStartOffset": ["partitionStartOff", "partitionsStartOffset", "partitionBufferOrder", "partitionEndOff", "partitionEndOrder", "partitionsStartOff", "partitionsEndOff", "partitionStopOffset", "partitionsEndOffset", "partitionStopOrder", "partitionsEndRange", "partitionsStartRange", "partitionBufferRange", "partitionStopRange", "partitionsStartOrder", "partitionBufferOff", "partitionStartRange", "partitionBufferOffset", "partitionStopOff", "partitionStartOrder", "partitionsEndOrder", "partitionEndRange"], "bufferSize": [" bufferC", "bufferC", "bufferCount", "processC", "BufferType", "processType", "queueCount", " bufferCount", "BufferSize", "bufferSIZE", "processSize", "BufferCount", "processSIZE", "queueSize", "bufferType", "BufferC", "BufferSIZE", " bufferType", " bufferSIZE"], "fastaBuffer": ["fastaaBuff", " fastAChannel", "FastaPtr", "FastaChannel", "fastanFile", "fastAFile", "fastAChannel", "fastasQueue", "fastasBuff", "fastasFile", "fastaaPtr", "fastaaBuffer", "FastaStream", " fastaFile", "fastaStream", "fastaContainer", "fastanBuff", "fastAContainer", "fastacePtr", "fastaceChannel", " fastaQueue", "fastaceBuff", "fastABuffer", " fastABuffer", "fastasPtr", "fastaBuff", " fastAQueue", " fastasBuffer", " fastaBuff", "FastaBuffer", "fastanPtr", "FastasStream", "fastAPtr", "fastanBuffer", "fastaPtr", "FastasBuff", "fastanQueue", "fastasBuffer", "fastasChannel", "FastaBuff", "FastasPtr", "fastaFile", "fastasStream", "fastaaStream", " fastABuff", "FastasChannel", "fastanChannel", " fastasChannel", "fastasContainer", " fastasContainer", "fastABuff", " fastAFile", "fastaceBuffer", "fastaQueue", " fastaContainer", "fastAQueue", "FastasBuffer", " fastasFile", "fastanContainer", "fastanStream"], "fastaReadState": ["fastaReadingType", "fastaReadMode", "fastasReaderMode", "fastaReaderstate", "fastaFileMode", "fastaReadingState", "fastasReaderType", "fastasReaderstate", "fastaFilestate", "fastaReadstate", "fastaFileState", "fastaReaderType", "fastasReaderState", "fastaReadingstate", "fastasReadType", "fastasReadState", "fastaReadType", "fastaFileType", "fastaReadingMode", "fastasReadstate", "fastasReadMode", "fastaReaderState", "fastaReaderMode"], "nBytes": ["oBytes", "nParts", " nbytes", "numFiles", "nByte", "oParts", "numBytes", "lenFrames", "lenFiles", "pParts", "nFrames", "Nbytes", "numFrames", "numbytes", "pBytes", "lenBytes", "oFiles", "lenbytes", "NByte", "nFiles", "obytes", "pByte", "NParts", " nFrames", " nFiles", "NBytes", "NFiles", " nByte", "nbytes", "pbytes", " nParts"]}}
{"id1": "21125261", "id2": "15580610", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 1, "substitutes": {"test": [" eval", "tests", " process", "run", "Train", "train", "evaluate", " sample", " simulate", " solve", " tests", " testing", " deploy", " run", "Main", "execute", " evaluate", " validate", " verify", " check", " train", " analyse", " example", "Test"], "is": ["lis", "os", "in", "ai", "mis", "Is", "bis", "iso", "stream", "isa", "src", "i", "s", "its", "ls", "ses", "id", "isi", "es", "ris", "gets", "IS", "info", "iss", "ios", "has", "ir", "out", "iris", "ais", "fs", "serv", "opens", "does", "ins", "res", "ics", "as", "si", "ps", "ists", "ws"], "byteArrayOutputStream": ["byteArrayFileFile", "byteArrayInputFile", "byteStringOutputPath", "byteArrayIOStream", "byteArrayIOFile", "byteArrayOutputPath", "byteArrayByteFile", "byteArrayFileString", "byteStringOutputStream", "byteStringOutputSteam", "byteArrayFileStream", "byteStringOutputFile", "byteArrayoutputSteam", "byteArrayByteSteam", "byteStringInputStream", "byteArrayInputString", "byteArrayByteStream", "byteArrayOutputString", "byteArrayoutputContext", "byteStringInputPath", "byteArrayoutputStream", "byteArrayOutputFile", "byteStringInputSteam", "byteArrayOutputSteam", "byteArrayOutputContext", "byteArrayInputStream", "byteArrayIOString", "byteArrayoutputPath", "byteStringInputString", "byteStringOutputString", "byteArrayFileSteam", "byteArrayFilePath", "byteStringInputFile", "byteArrayByteString", "byteArrayIOSteam", "byteArrayInputSteam", "byteArrayFileContext", "byteStringOutputContext", "byteStringInputContext", "byteArrayInputContext", "byteArrayInputPath"], "def": ["der", "de", "obj", "DE", "entry", "dem", "class", "decl", "bus", "defined", "init", "default", "define", "parse", "e", "id", "md", "info", "Def", "desc", "report", "ref", "df", "conf", "file", "dist", "dir", "f", "this", "base", "definition", "des", "data", "spec", "di", "frame", "d", "pro", "da", "dev", "re", "config", "DEF"], "se": ["ne", "su", "sc", "de", "service", "sl", "inse", "ie", "sec", "entry", "sche", "ce", "ste", "ane", "s", "sk", "sea", "sed", "parse", "e", "ses", "ze", "cle", "es", "per", "sh", "fe", "ase", "be", "ve", "sle", "see", "lex", "SE", "ge", "sel", "ke", "est", "zip", "pe", "ine", "sem", "so", "me", "ade", "site", "ss", "pse", "spe", "si", "le", "te", "ser", "sp"], "linkId": ["feedLength", "LinkInfo", "feedInfo", "lineId", "linkLength", "linkid", "lockId", "lockById", "lineById", "feedId", "LinkLength", "linkInfo", " linkById", " linkInfo", " linkLength", " linkid", "LinkId", "feedid", "lockInfo", "Linkid", "lineInfo", "linkById"], "segmentId": ["segmentsId", "selementID", " segmentType", "negementCount", "segmentID", "selementCount", " segmentsID", " segmentCount", "segmentNumber", "sementInfo", "segmentCount", "negmentCount", "selementId", "segmentsCount", "sementNumber", " segmentsId", "sementCount", "negementNumber", "segementNumber", " segmentID", "negementInfo", "segmentsType", " segmentsType", "segmentsID", "negmentInfo", "negementId", "segmentType", "segementCount", "segementId", "sementType", "negmentNumber", "sementID", "segmentsNumber", "selementType", " segmentsCount", "segementInfo", "segmentsInfo", "sementId", "negmentId", "segmentInfo"], "linkSegments": ["linkConnectgments", "lineSegles", "linkIncreines", "linkSegines", "linkEngines", " linkSegment", "linkFraggments", "linkEngments", "lineSegment", "linkIncregments", " linkEnggments", " linkSegures", "linkEngment", "linkIncrement", "linkFragments", "lineSegments", "linkConnectments", "lineSeggments", "linkFragles", "linkIncrements", " linkEngures", "linkSegment", "linkSegles", "linkSeggments", "lineFragment", "linkIncreles", "linkEnggments", "linkFragures", " linkEngments", "linkConnectures", "lineFragments", " linkSeggments", "lineSegines", "lineFragles", "linkEngures", "linkConnectment", "lineFragines", "linkFragment", "lineFraggments", " linkEngment", "linkFragines", "linkSegures", "linkEngles"], "segments": ["Seggments", "schegment", "gegs", "bements", "segements", "peplings", "begments", "sements", "schegments", "Segments", "geplings", "schements", "gements", "seplings", "begment", "Seggements", "segment", "pegment", "gegment", "pements", "begs", "gegments", "pegs", "Seggment", "pegments", "scheplings", "segs", "pegements", "gegements"], "frameProperties": ["framePropperties", " frameProblems", "frameproblems", "frameproeters", " frameProeters", "frameProproperties", "frameprops", "framePromperties", "framePromps", "framePropeters", " frameProps", " frameproblems", " frameProproperties", "frameProeters", "framePropproperties", "framePrometers", "framePropblems", "frameproproperties", " frameprops", " frameproproperties", "framePropps", "frameProps", " frameproeters", "frameProblems", "framePromproperties", " frameproperties", "frameproperties"], "time": ["image", "video", "timeout", "cost", "rate", "size", "h", "ice", "vel", "TIME", "e", "id", "delay", "port", "t", "weight", "sleep", "change", "work", "count", "step", "file", "clock", "value", "start", "etime", "x", "f", "once", "depth", "money", "end", "Time", "data", "type", "tim", "date", "v", "live", "now", "activity", "times", "name", "age", "speed", "loop", "c", "duration", "event", "play", "ime", "length", "timer"], "vehicle": ["vehish", "venical", "verticles", " vehicles", "vehline", "verticular", "vehometry", "bridical", "bridicle", "vehocity", " vehicular", "Vehicle", " mobish", " vehline", "driocity", "bridocity", "Vehicles", "venicle", "verticle", "Vehicular", " mobicles", " vehology", "bridometry", "driical", "Vehline", "vehicles", "vehicular", " mobline", "driicle", " mobicle", " vehish", "venocity", "vehical", "vehology", "venometry", "Vehish", "Vehology", "driometry", "vertology"]}}
{"id1": "21224967", "id2": "17202158", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "label": 0, "substitutes": {"crear": [" crea", " Creas", "generar", " Crear", "genera", "Creare", "Creas", "Crear", " creare", " Crea", " creas", " Creare", "generare", "Crea", "generas"], "result": ["match", "message", "ret", "out", "length", "feature", "mark", "ver", "date", "status", "event", "page", "success", "count", "cash", "default", "found", "record", "comment", "force", "up", "valid", "limit", "currency", "die", "counter", "number", "function", "grade", "res", "db", "Result", "score", "ure", "value", "df", "err", "response", "results", "sign", "diff", "entry", "rate", "type", "user", "error", "order"], "sql": ["fp", "sync", "session", "script", " SQL", "update", "ql", "seed", "cmd", "serv", "conn", "install", "q", "pg", "where", "dl", "comment", "statement", "up", "action", "job", "url", "base", "SQL", "log", "database", "params", "setup", "exec", "printf", "zip", "query", "sl", "string", "fn", "repl", "sq", "plan", "ssl", "join", "db", "select"], "connection": ["p", "relation", "position", "cache", "table", "client", "connected", "session", "c", "union", "config", "environment", "system", "tc", "Connection", "event", "driver", "socket", "conn", "manager", "condition", "loc", "writer", "con", "pg", "proxy", "which", "communication", "statement", "connect", "document", "error", "database", "log", "bc", "graph", "server", "function", "query", "index", "container", "cond", "lock", "engine", "BC", "collection", "Exception", "ctx", "ion", "section", "db", "context", "application"], "ps": ["p", "pre", "eps", "cs", "pt", "ss", "ups", "ppa", "ips", "po", "pse", "ds", "pos", "hs", "conn", "pps", "pg", "proxy", "PS", "vs", "gres", "cop", "pa", "ks", "pc", "os", "pe", "qs", "proc", "params", "Ps", "query", "bs", "pd", "sp", "ins", "cp", "pr", "jp", "gs", "settings", "ns", "pers", "properties", "changes", "pp", "ports", "posts", "ops"]}}
{"id1": "9261777", "id2": "949327", "code1": "    public static void main(String[] args) {\n        String source, destination;\n        if (args[0].toLowerCase().endsWith(\".gz\")) {\n            source = args[0];\n            destination = source.substring(0, source.length() - 3);\n        } else {\n            source = args[0] + \".gz\";\n            destination = args[0];\n        }\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new GZIPInputStream(new FileInputStream(source));\n            os = new FileOutputStream(destination);\n            byte[] buffer = new byte[8192];\n            for (int length; (length = is.read(buffer)) != -1; ) os.write(buffer, 0, length);\n        } catch (IOException e) {\n            System.err.println(\"Fehler: Kann nicht entpacken \" + args[0]);\n        } finally {\n            if (os != null) try {\n                os.close();\n            } catch (IOException e) {\n            }\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"source": ["resource", "token", "use", "seed", "project", "zip", "string", "Source", "request", "view", "spec", "proxy", "inner", "service", "scope", "comment", "input", "options", "ource", "copy", "path", "empty", "slice", "force", "dest", "in", "original", "address", "shared", "single", "unit", "sample", "missing", "rule", "base", "element", "prefix", "url", "query", "config", "size", "name", "index", "flat", "sl", "session", "strip", "SOURCE", "image", "start", "sin", "result", "secure", "se", "data", "parse", "style", "target", "null", "id", "parent", "uri", "text", "info", "src", "site", "file", "sort", "template"], "destination": ["dominated", "desturation", " destinating", " destipping", "destinations", "domination", " destinator", "dependension", "coordinating", "destinating", "destipping", " destension", "homeignment", "Destinations", "destinator", "Destinator", "Destinating", "coordination", "Destination", "homeinated", "databaseuration", "destinated", "Destinated", "homeination", " destignment", "Destinate", "homeinator", "destinate", "distipping", "Destignment", "coordinate", "dependination", "dependipping", "dependinated", "domuration", "databaseinated", " destinated", "dominations", "destignment", "distension", "distinated", "coordinator", " destinate", "distination", "databaseinations", "databaseination", "Desturation", "destension"], "is": ["ib", "ics", "or", "us", "ip", "isa", "ios", "serv", "zip", "bs", "ens", "isl", "ois", "osi", "ir", "ob", "act", "ii", "was", "iris", "oss", "ci", "as", "ic", "api", "abs", "ais", "IS", "io", "ui", "in", "ins", "ri", "are", "ie", "fs", "obs", "init", "s", "Is", "out", "iss", "iso", "ar", "ops", "eni", "cos", "get", "isi", "isc", "sis", "i", "ori", "sin", "close", "mis", "bis", "se", "lis", "ai", "nis", "esi", "id", "es", "info", "src", "ris"], "os": ["or", "ks", "js", "us", "ol", "ios", "so", "bs", "ens", "ob", "osi", "op", "ies", "o", "mos", "dos", "oa", "oss", "as", "oise", "io", "ais", "sys", "aos", "boot", "bos", "oes", "acs", "ose", "fs", "obs", "s", "nos", "pos", "out", "oS", "vs", "ls", "los", "ops", "cos", "ot", "Os", "i", "ds", "ori", "oses", "ros", "socket", "ou", "es", "ends", "OS", "ss", "ow"], "buffer": ["seed", "position", "string", "channel", "uffer", "limit", "padding", "copy", "layer", "wave", "sequence", "feed", "buf", "slice", "queue", "number", "pad", "address", "header", "batch", "base", "server", "url", "size", "read", "Buffer", "iter", "value", "image", "writer", "bytes", "transfer", "page", "border", "result", "reader", "bb", "data", "null", "b", "buff", "flush", "binary", "reference"], "length": ["distance", "row", "section", "line", "of", "position", "ob", "string", "full", "volume", "depth", "limit", "character", "total", "shape", "lower", "Length", "power", "partial", "division", "match", "sequence", "slice", "number", "feed", "key", "ring", "object", "address", "count", "age", "weight", "l", "part", "url", "get", "load", "left", "size", "index", "code", "len", "value", "strip", "split", "start", "quote", "last", "level", "reader", "type", "data", "range", "point", "style", "duration", "id", "offset", "lock", "block", "width", "end"]}}
{"id1": "15510198", "id2": "11716816", "code1": "    protected static Parser buildParser(URL url) throws IOException, ParserException {\n        Parser parser;\n        URLConnection connection = openConnection(url);\n        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {\n            parser = new Parser(connection);\n        } else {\n            parser = null;\n        }\n        return parser;\n    }\n", "code2": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "label": 0, "substitutes": {"buildParser": ["constructParser", "constructReader", "makeReader", "makeWriter", "buildWriter", "newHandler", "makeParser", "newReader", "newParser", "constructHandler", "buildHandler", "newWriter", "constructWriter", "buildReader", "makeHandler"], "url": ["path", "address", "base", "loader", "class", "ssl", "server", "uri", "resource", "http", "c", "location", "l", "host", "URL", "source", "proxy", "str", "open", "config", "data", "file", "channel", "page", "object", "null", "name", " URL", "image", "io", "link", "sl", "Url", "bug", "www", "obj", "this", "service", "loc"], "ParserException": ["IOError", "IOExc", "SSLError", " IOExc", "SSLException", "SSLExc", " IOException", " IOError", "ParserError", "ParserExc", "IOException"], "parser": ["root", "handler", "class", "arser", "loader", "server", "builder", "master", "http", "slave", "result", "se", "instance", "library", "api", "pool", "php", "fp", "manager", "ler", "pard", "er", "type", "reader", "cache", "seed", "parent", "data", "au", "config", "object", "x", "p", "null", "style", "plugin", "test", "fruit", "writer", "worker", "jp", "pc", "angler", "pe", "parse", "processor", "xml", "Parser", "pd", "this", "jack"], "connection": ["directory", "Connection", "event", "handler", "class", "server", "resource", "response", "uri", "http", "document", "con", "c", "communication", "connected", "socket", "message", "character", "instance", "j", "relation", "database", "condition", "client", "session", "reader", "lc", "proxy", "ion", "application", "collection", "open", "config", "section", "channel", "object", "context", "conn", "image", "io", "function", "pointer", "link", "db", "service", "position", "bc", "connect", "reference", "this", " Connection", "loc"]}}
{"id1": "11562173", "id2": "14231545", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["checkFileStream", " checkOutputChannel", "checkOutputStream", "checkOutputSteam", "checkOutputChannel", "checkIOStream", " checkInputSteam", "checkFileSteam", "checkIOstream", "checkFileChannel", " checkInputChannel", " checkOutputstream", " checkInputstream", "checkOutputstream", " checkOutputSteam", "checkIOChannel", "checkIOSteam", "checkInputSteam", "checkFilestream", " checkOutputStream", "checkInputChannel", "checkInputstream"], "in": ["into", "ins", "image", "In", "connection", "io", "data", "inc", "input", "din", "IN", "inn", "index", "is", "source", "ack", "reader", "src", "login", "inner", "min", "bin", "c", "con", "ic", "up", "ini", "as", "x", "plus", "comp", "again", "p", "isin"], "cmp": ["conv", "asc", "prefix", "np", "roc", "mp", "omp", "cp", "rc", "pixel", "loc", "prev", "cho", "spec", "cpp", "coll", "ch", "index", "sort", "ci", "cb", "clip", "code", "cc", "ctrl", "comment", "upp", "config", "co", "cache", "match", "pc", "amp", "c", "mom", "sup", "up", "ctx", "pre", "diff", "proc", "op", "lc", "comp", "cs", "cup", "fp", "p", "cop", "com"], "all": ["asc", "partial", "array", "default", "one", "call", "parent", "null", "except", "best", "none", "acl", "each", "allow", "not", "valid", "coll", "All", "sum", "cl", "and", "only", "process", "total", "al", "l", "a", "ann", "any", "local", "match", "ALL", "alpha", "list", "am", "global", "full", "both", "auto", "always", "p"], "stream": ["null", "speed", "Stream", "form", "this", "steam", "port", "raw", "socket", "channel", "output", "model", "impl", "document", "result", "input", "stack", "coll", "feed", "test", "temp", "instance", "progress", "source", "ack", "roll", "ream", "client", "reader", "self", "track", "src", "user", "round", "transform", "object", "trans", "string", "v", "platform", "up", "per", "host", "context", "pool", "response", "cont", "wrapper", "comp", "iterator", "sw"], "out": ["prefix", "array", "image", "copy", "null", "parent", "b", "io", "outer", "data", "project", "this", "sync", "inc", "part", "not", "output", "result", "block", "exp", "o", "index", "sum", "Out", "comment", "point", "outs", "user", "v", "bin", "c", "obj", "name", "list", "other", "option", "full", "OUT", "up", "extra", "response", "x", "again", "p"], "i": ["k", "u", "uri", "e", "j", "b", "n", "fi", "init", "io", "info", "si", "f", "it", "index", "d", "end", "key", "type", "ci", "oi", "ji", "h", "abi", "multi", "li", "di", "l", "mi", "hi", "pi", "xi", "slice", "r", "ind", "id", "ti", "v", "gi", "c", "start", "ri", "I", "ai", "ix", "strength", "ini", "ii", "ui", "x", "bi", "qi", "lc", "p"]}}
{"id1": "9275622", "id2": "822452", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copyFile": ["moveFile", "transferFolder", " copyFiles", "copyfile", "copyFolder", " copyfile", "moveFiles", "transferfile", "copyFiles", "moveFolder", " copyFolder", "movefile", "transferFiles", "transferFile"], "_file1": ["_fFirst", "_zipFirst", "_File01", "_files1", "_file0", "_fOne", "_file01", "_resourceFirst", "_fone", "_resourceOne", "_File0", "_fileFirst", "_f1", "_zip1", "_zipone", "_files0", "_File1", "_zipOne", "_files2", "_fileone", "_File2", "_files01", "_mail0", "_mail01", "_resourceone", "_mail1", "_fileOne", "_resource1", "_mail2"], "_file2": ["_model1", "_play1", "jmodel2", "jmodel1", "_file4", " _files4", " _files2", " _fileTwo", "_playsecond", "jfile5", "jfile2", "_model5", "_play4", " _filesTwo", "_File1", "_File5", "_playTwo", "_files2", "jmodelsecond", " _file3", "_file5", "jfilesecond", "_file3", "_File2", "jfile1", "_files4", "_fileTwo", "_files3", "_filesecond", "_modelsecond", "_filesTwo", " _files3", "_play3", " _file4", "_play2", "jmodel5", "_play5", "_Filesecond", "_model2"], "fis": [" fils", "lfis", "Fas", "fais", " fiss", "fi", "Fils", "cfas", "Fos", "lfais", "Fris", "fris", "cfis", "infos", " fi", "Fiss", " fris", "fas", " fas", "fils", "fiss", "afais", "lfiss", "infiss", "infils", "cfiss", "afiss", "cfris", " fais", "infis", "cfos", "afis", "afi", "lfi", "Fis"], "fos": ["fo", " fros", "floes", "Foos", "poes", "goses", "fOS", "lOS", " faos", "lis", "Fos", "flos", "info", " foos", "loes", "foos", "fus", "foses", "pos", "flOS", "faos", "infos", "infaos", "Fo", "gis", "infoos", "pis", "Fus", "feus", "fios", "infus", " fo", "infros", "Faos", "Fios", "infios", "Foses", "flis", "los", "feoses", " fus", "Fros", "feis", "gos", "gus", "foes", " fios", "pOS", "fros", "Fis", "feos"], "canalFuente": ["canalBuze", "canalBuencia", "canalKuente", "canalFuestro", "canaledFuestro", "canalBuente", "canalCraente", "canalFUestro", "canallBuence", "canalFUence", "canalsBuence", "canalsBuencia", "canallBuze", "canalSuente", "canalFuento", "canalFuze", "canalCraencia", "canalSuje", "canalFUze", "canalsFuento", "canallFuencia", "canalsFuente", "canaledFuente", "canalCraento", "canallFuze", "canallFuente", "canallBuente", "canalBuence", "canalKuento", "canalFUencia", "canaledFuze", "canalKuence", "canalCraence", "canalsBuento", "canalBuestro", "canaledBuze", "canalKuze", "canalSuze", "canallFuence", "canalBuento", "canalsFuencia", "canalFuence", "canaledBuje", "canalsBuente", "canalFuje", "canallBuencia", "canalsFuence", "canalKuencia", "canalBuje", "canaledBuente", "canalSuestro", "canalFUente", "canalFUje", "canaledBuestro", "canaledFuje", "canalFuencia"]}}
{"id1": "22560224", "id2": "23517481", "code1": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"hashStringMD5": [" hashStringUTF8", " hashFileMD8", " hashStringMK4", " hashStringM6", " hashStringUTF6", " hashStringM4", " hashFileMD6", " hashStringUTF4", " hashStringMK8", " hashStringM5", " hashStringM8", " hashStringMK5", " hashStringMD4", " hashFileMK8", " hashStringUTF5", " hashFileMK5", " hashFileMK6", " hashFileMD5", " hashStringMD6", " hashFileMD4", " hashStringMD8", " hashStringMK6", " hashFileMK4"], "string": ["STR", "buffer", "writer", "bytes", "p", "service", "script", "object", "map", "strings", "input", "sequence", "version", "slice", "section", "address", "result", "content", "array", "message", "word", "date", "file", "str", "operator", "binary", "letter", "null", "data", "database", "number", "text", "name", "ring", "password", "list", "uri", "source", "filename"], "md": ["km", "mm", "mac", "m", "dig", "bf", "ad", "pd", "metadata", "um", "od", "rm", "amd", "cm", "mb", "nm", "df", "wd", "gd", "mand", "bd", "f", "sm", "mg", "dm", "data", "pm", "MD", "mp", "me", "mc", "rpm", "mag", "hd", "d", "gm", "vd", "ms", "meta", "hash", "am", "cmd", "dd", " MD", "vm", "hm"], "byteData": ["ByteArray", "largeData", "byteInfo", "linedata", "byteLength", "lineBytes", "byteSeries", "ByteDATA", "bytePart", "ByteSeries", "lineInfo", " bytedata", "wordInfo", "ByteData", "ByteString", "byteArray", "ByteInfo", "harddata", "BytePart", " byteArray", "letterLength", " bytePart", " byteLength", "bitdata", "largeDATA", "bitData", "Bytedata", "bytedata", "wordData", " byteBytes", " byteString", "wordArray", "largeSeries", " byteDATA", "wordPart", " byteInfo", "blockString", "hardLength", "bitBytes", "byteString", "letterDATA", "letterData", "blockdata", "hardData", " byteSeries", "largeArray", "blockData", "blockArray", "lineData", "letterdata", "hardDATA", "byteBytes", "byteDATA", "bitInfo"], "sb": ["db", "kB", "abb", "bp", "buffer", "sc", "bf", "BP", "src", "ab", "bs", "SB", "bb", "ls", "usb", "sf", "sg", "bc", "rb", "fb", "bm", "bps", "mb", "buff", "gb", "ssl", "BG", "Bs", "pb", "Buff", "bh", "eb", "buf", " SB", "BB", "sq", "b", "xb", "obb", "nb", "SF", "ruby", "cb"], "i": ["ai", "ip", "in", "m", "j", "p", "h", "ie", "n", "g", "eni", "is", "s", "multi", "fi", "ix", "slice", "e", "phi", "abi", "id", "ci", "gi", "lc", "ui", "info", "li", "index", "ii", "io", "ori", "iu", "ini", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "u", "b", "y", "v", "ji", "w", "oi", "it", "mi", "di", "l", "hi", "d", "si", "yi", "qi", "uri", "field", "I", "c", "sp"], "hexString": ["nullBuffer", " hexArray", "octArray", "shortBuffer", " hexStr", "octStr", "exstring", "hexstring", "hexText", "formString", "hexArray", "formstring", "shortString", "nullstring", "formStr", "exArray", "nullString", "exText", "shortstring", "exStr", " hexBuffer", "exBuffer", "octstring", "exString", "hexBuffer", "hexStr", "shortArray", " hexstring", "nullText", "formArray", "octBuffer", " hexText", "octString"], "hex": ["ip", "h", "shape", "sync", "hello", "alpha", "bit", "xxxxxxxx", "form", "ctr", "character", "cube", "nexus", "id", "ex", "sex", "cf", "xf", "wh", "sum", "exp", "http", "num", "rh", "hess", "buff", "pack", "digit", "cross", "closure", "raw", "lit", "str", "pex", "x", "iter", "oct", "brew", "temp", "alph", "rex", "quad", "char", "text", "he", "coord", "xa", "utf", "hash", " Hex", "cmp", "shift", "kh", "escape", "length"]}}
{"id1": "6625074", "id2": "20365090", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "        public HttpResponseExchange execute() throws Exception {\n            HttpResponseExchange forwardResponse = null;\n            int fetchSizeLimit = Config.getInstance().getFetchLimitSize();\n            while (null != lastContentRange) {\n                forwardRequest.setBody(new byte[0]);\n                ContentRangeHeaderValue old = lastContentRange;\n                long sendSize = fetchSizeLimit;\n                if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) {\n                    sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1);\n                }\n                if (sendSize <= 0) {\n                    break;\n                }\n                lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength());\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_RANGE, lastContentRange);\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sendSize));\n                forwardResponse = syncFetch(forwardRequest);\n                if (sendSize < fetchSizeLimit) {\n                    lastContentRange = null;\n                }\n            }\n            return forwardResponse;\n        }\n", "label": 0, "substitutes": {"SHA1": ["HA384", "SHAOne", " SHAOne", "sha256", "shaOne", "SHA256", "sha384", "HA256", "SHA384", "HA1", "HAOne", " SHA256", " SHA384", "sha1"], "text": ["source", "message", "buffer", "output", "str", " Text", "out", "token", "path", "translation", "config", "font", "bytes", "txt", "word", "input", "image", "data", "TEXT", "in", "object", "format", "context", "editor", "class", "name", "ext", "Text", "code", "obj", "password", "transfer", "letter", "hex", "string", "struct", "test", "value", "template", "contract", "plain", "pattern", "content"], "sha1hash": ["sha256password", "shaOnehash", "SHA1cap", "SHA1text", "sha6Hash", "sha6hash", "sha_Hash", "ha2hash", "sha1hex", "sha2cap", "sha81Hash", "shaOnepassword", "ha1hash", "sha256text", "sha6log", "ha1hex", "sha_sum", "ha2hex", "SHA2cap", "sha6cap", "sha1cap", "ha2Hash", "ha1Hash", "sha1text", "sha2Hash", "sha81log", "sha1Hash", "sha2hash", "shaOnetext", "sha81cap", "sha256Hash", "ha2sum", "SHA2hash", "SHA1Hash", "sha2hex", "sha2sum", "SHA1hash", "sha_hex", "sha81hash", "sha2log", "sha1sum", "SHA2log", "ha1sum", "sha1password", "sha256hash", "shaOneHash", "sha_hash", "sha1log", "SHA1password", "SHA2Hash", "SHA1log"], "md": ["hm", "mm", "mp", "cf", "amd", "f", "hash", "wd", "dig", "cmd", "dm", "de", "mb", "meta", "m", "nm", "metadata", "ad", "mac", "editor", "rm", "ms", "sm", "vd", "um", "nd", "pd", "sha", " MD", "gb", "od", "ld", "dd", "mo", "mt", "hd", "cd", "MD", "mc", "ma", "df", "pkg", "mag", "pm", "d", "rpm", "bd"]}}
{"id1": "17475530", "id2": "942693", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinkOfLink", "testAddLinkstoFile", "testAddLinksToImage", "testAddLinkOfImage", "testAddLinkstoPicture", "testAddLinkOfPicture", "testAddLinkstoImage", "testAddLinkstoLink", "testAddLinkFromImage", "testAddLinkOfFile", "testAddLinktoImage", "testAddLinktoLink", "testAddLinkToLink", "testAddLinkToFile", "testAddLinksToLink", "testAddLinksToFile", "testAddLinkToPicture", "testAddLinktoPicture", "testAddLinkFromPicture", "testAddLinksToPicture", "testAddLinktoFile", "testAddLinkFromLink", "testAddLinkFromFile"], "in": ["resource", "In", "or", "pass", "token", "stream", "again", "serv", "at", "ini", "n", "IN", "m", "cin", "ex", "exp", "xml", "is", "din", "version", "bin", "with", "input", "copy", "as", "path", "con", "pin", "ins", "doc", "ac", "min", "conn", "inn", "err", "isin", "connection", "win", "rin", "out", "exec", "url", "get", "work", "gin", "index", "f", "i", "nin", "el", "image", "socket", "val", "login", "ssl", "reader", "diff", "data", "ax", "r", "inc", "id", "source", "uri", "name", "file"]}}
{"id1": "17475530", "id2": "9327525", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    @Test\n    public void test02_ok() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(chartURL);\n            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);\n            nameValuePairs.add(new BasicNameValuePair(\"ws\", \"getDomainEvolution\"));\n            nameValuePairs.add(new BasicNameValuePair(\"chartTitle\", \"test\"));\n            nameValuePairs.add(new BasicNameValuePair(\"type\", \"chart\"));\n            nameValuePairs.add(new BasicNameValuePair(\"firstDate\", \"20111124\"));\n            nameValuePairs.add(new BasicNameValuePair(\"lastDate\", \"20111125\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParams\", \"type,counting,protocol,unit,proxy,domain,timeScale,period\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParamsValues\", \"chart,volume,all,hits,all,google.com,day,360\"));\n            nameValuePairs.add(new BasicNameValuePair(\"serieTitle\", \"serie\"));\n            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            assertNotNull(entity);\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));\n            System.out.println(reader.readLine());\n            instream.close();\n            assertEquals(\"error :\" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"testAddLinkToImage": ["testAddLinkOfPicture", "testAddLinkToPicture", "testAddLinkFromPicture", "testAddLinktoFile", "testAddLinksToLink", "testAddLinkOfLink", "testAddLinksToPicture", "testAddLinkstoPicture", "testAddLinkFromLink", "testAddLinkOfFile", "testAddLinktoLink", "testAddLinkstoLink", "testAddLinkToLink", "testAddLinkToFile", "testAddLinksToImage", "testAddLinkFromImage", "testAddLinkstoFile", "testAddLinkOfImage", "testAddLinktoImage", "testAddLinkFromFile", "testAddLinkstoImage", "testAddLinksToFile", "testAddLinktoPicture"], "in": ["r", "image", "get", "m", "pin", "n", "inn", "gin", "isin", "stream", "is", "i", "socket", "el", "cin", "input", "version", "copy", "id", "ex", "din", "val", "conn", "diff", "ax", "or", "connection", "exp", "index", "resource", "path", "nin", "xml", "ssl", "out", "ini", "con", "work", "file", "rin", "at", "min", "f", "url", "pass", "exec", "serv", "login", "doc", "data", "err", "with", "token", "ins", "name", "bin", "In", "reader", "IN", "as", "again", "uri", "win", "source", "ac", "inc"]}}
{"id1": "19549489", "id2": "942693", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["Cop", "paste", "cop", " copies", "zip", "Copy", "io", "move", "Transfer", "sync", "download", "p", "create", " Copy", "all", " transfer", "upload", "clone", "delete", " move", "split", "transfer", "write", " copied", "source", " copying", "file"], "sourceFile": ["resourceFile", "sourceFiles", "serviceFilename", " sourcefile", "SourceFile", "sourcefile", " sourceFilename", " sourceDirectory", "resourceFiles", "SourceDirectory", "SourceFiles", "sourceFILE", "sourceFilename", "serviceFiles", "resourceDirectory", "siteFile", "searchFile", "Sourcefile", "sourceDirectory", "servicefile", "siteFILE", "searchFilename", " sourceFILE", "siteDirectory", " sourceFiles", "resourcefile", "searchfile", "searchFiles", "siteFiles", "SourceFILE", "serviceFile"], "destinationFile": ["destinationFiles", "distinationFiles", "destinatorDirectory", "destinatedfile", "DestinationDir", "DestinationFiles", "destinationDirectory", "distinationImage", "Destinatorfile", "destinationfile", "destinationImage", "destationfile", "destinatorDir", "destinatorFiles", "DestinatorFiles", "DestinatorDir", "destinatorFile", "destationImage", "destationDir", "distinatedFiles", "destinatorImage", "distinatedImage", "destinatorfile", "distinatedFile", "distinatedDirectory", "destinatedDirectory", "distinationFile", "destinatedImage", "DestinatorFile", "destationDirectory", "destationFiles", "distinationDirectory", "DestinationFile", "destinatedFiles", "destinatedDir", "destationFile", "Destinationfile", "destinationDir", "destinatedFile"], "sourceFileChannel": ["sourceFilechannel", " sourceFileContext", "sourceDirectoryChan", "sourceFilesChannel", "ourceFileStream", "sourceStreamContext", "sourceDirchannel", " sourceFilesContext", "sourceStreamConnection", "sourceDirectoryClient", "sourceStreamChan", "sourceFileContext", "sourceLibrarySocket", "sourceLibraryChan", "ourceStreamStream", "ourceFilechannel", "sourceFilesService", " sourceFileService", "sourceFileService", "sourceStreamService", "sourceLinechannel", "ourceStreamChan", " sourceFilesService", "sourceDirStream", "sourceDirectorySocket", "sourceDirectoryChannel", "sourceStreamStream", "sourceDirChannel", "sourceLineClient", "sourceFunctionService", "sourceLineChannel", "sourceLibraryClient", "ourceFileChannel", "sourceFunctionChannel", "sourceFilesContext", "targetFileClient", "targetLibraryChan", "sourceFileClient", "targetFileChan", " sourceFilesConnection", "sourceFileStream", "ourceStreamChannel", " sourceFileConnection", "ourceFileChan", "sourceLineStream", "sourceLibraryChannel", "sourceLineChan", "targetLibrarySocket", "sourceFileConnection", "sourceFileChan", "sourceFilesConnection", "sourceLineSocket", "targetFileSocket", "sourceFunctionContext", "sourceFunctionConnection", " sourceFilesChannel", "sourceDirChan", "targetFileChannel", "sourceFileSocket", "targetLibraryClient", "sourceStreamChannel", "ourceStreamchannel", "targetLibraryChannel", "sourceStreamchannel"], "destinationFileChannel": ["destinationIOClient", "destinationFileCache", "destinatorFileHandler", "destinationLineChannel", "destinationFilesService", "destinationIOCache", "destinationFilesHandler", "destinatorFileChan", "destinatorFilesService", "destinationFileChan", "destinationFilesChannel", "destinatorFileCache", "destinatorFileConnection", "destinationDirectoryConnection", "destinationIOService", "destinationDirectoryClient", "destinationDirectoryChan", "destinatorFileService", "destinatorFilesCache", "destinatorFilesChannel", "destinatorFilesClient", "destinationFilesClient", "destinationLineConnection", "destinationIOChannel", "destinationFileClient", "destinationLineHandler", "destinationDirectoryCache", "destinatorFilesConnection", "destinationFilesConnection", "destinationFileConnection", "destinationLineClient", "destinationLineService", "destinatorFilesChan", "destinationDirectoryHandler", "destinationFilesChan", "destinationFilesCache", "destinationFileHandler", "destinationLineChan", "destinationDirectoryService", "destinationDirectoryChannel", "destinatorFilesHandler", "destinatorFileChannel", "destinationFileService", "destinatorFileClient"]}}
{"id1": "7809093", "id2": "12678045", "code1": "    public static String getContent(HttpUriRequest request) throws Exception {\n        StringBuffer sb = new StringBuffer();\n        HttpClient client = new DefaultHttpClient();\n        HttpParams httpParams = client.getParams();\n        HttpConnectionParams.setConnectionTimeout(httpParams, 30000);\n        HttpConnectionParams.setSoTimeout(httpParams, 50000);\n        HttpResponse response = client.execute(request);\n        HttpEntity entity = response.getEntity();\n        if (entity != null) {\n            BufferedReader reader = new BufferedReader(new InputStreamReader(entity.getContent(), \"UTF-8\"), 8192);\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                sb.append(line + \"\\n\");\n            }\n            reader.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    private void addQDInformation() {\n        try {\n            long qdDate = System.currentTimeMillis();\n            if (_local == true) {\n                File qdFile = new File(\"qdinfo.dat\");\n                if (!qdFile.exists()) {\n                    return;\n                }\n                qdDate = qdFile.lastModified();\n            }\n            if (qdDate > this._qdFileDate) {\n                this._qdFileDate = qdDate;\n                for (int ii = 0; ii < this._projectInfo.size(); ii++) {\n                    Information info = getInfo(ii);\n                    if (info != null) {\n                        info._qdValue = null;\n                    }\n                }\n                Reader reader = null;\n                if (_local == true) {\n                    reader = new FileReader(\"qdinfo.dat\");\n                } else {\n                    StringBuffer urlName = new StringBuffer();\n                    urlName.append(\"http://boston.quik.com/rph/\");\n                    urlName.append(\"qdinfo.dat\");\n                    try {\n                        URL url = new URL(urlName.toString());\n                        InputStream stream = url.openStream();\n                        reader = new InputStreamReader(stream);\n                    } catch (MalformedURLException mue) {\n                        mue.printStackTrace();\n                    }\n                }\n                BufferedReader file = new BufferedReader(reader);\n                try {\n                    String line = null;\n                    while ((line = file.readLine()) != null) {\n                        if (line.startsWith(\"pg \")) {\n                            this._qdDate = Long.parseLong(line.substring(3), 16);\n                            this._qdDate = (this._qdDate + 946684800) * 1000;\n                        } else if (line.startsWith(\"pt \")) {\n                            line = line.substring(3).trim();\n                            int pos = -1;\n                            while ((line.length() > 0) && ((pos = line.indexOf(' ')) > 0)) {\n                                int projectNum = 0;\n                                Double value = null;\n                                if (pos > 0) {\n                                    projectNum = Integer.parseInt(line.substring(0, pos));\n                                    line = line.substring(pos).trim();\n                                }\n                                pos = line.indexOf(' ');\n                                if (pos > 0) {\n                                    value = new Double((double) Integer.parseInt(line.substring(0, pos)) / 100);\n                                    line = line.substring(pos).trim();\n                                }\n                                Information info = getInfo(projectNum);\n                                if (info == null) {\n                                    info = createInfo(projectNum);\n                                }\n                                if (info._qdValue == null) {\n                                    info._qdValue = value;\n                                }\n                            }\n                        }\n                    }\n                } finally {\n                    file.close();\n                }\n            }\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"getContent": ["setContent", "requestBody", "setBody", " getData", "GetOutput", "responseBody", "GetContent", "GetData", " getBody", "requestContent", " getEntity", "GetBody", "setEntity", "GetEntity", "responseContent", "getBody", "getEntity", "responseOutput", "responseEntity", "setData", "getData", "requestEntity", "getOutput", "requestOutput"], "request": ["string", "path", "address", "handler", "input", "Request", "resource", "uri", "server", "user", "http", "report", "message", "current", "result", "instance", "query", "queue", "req", "type", "q", "operation", "connection", "r", "application", "data", "route", "object", "name", "e", "QUEST", "position", "url", "reference", "xml", "method"], "sb": ["buffer", "BB", "sf", "bf", "sk", "usb", "bd", "bh", "vm", "sg", "lp", "lb", "eb", "lab", "cb", "fp", "obb", "bs", "su", "pb", "bg", "gb", "abb", "rb", "sa", "ab", "binary", "wb", "bj", "src", "fb", "bb", "zb", "ls", "nb", "db", "sup", "bt", "ib", "bc", "bp", "b", "xb", "bm", "abi", "bsp", "amb", "SB"], "client": ["remote", "ssl", "handler", "tc", "console", "server", "output", "uri", "resource", "builder", "http", "net", "con", "per", "c", "current", "project", "host", "util", "queue", "session", "ce", "cache", "proxy", "bird", "connection", "application", "default", "config", "channel", "https", "cl", "web", "p", "context", "conn", "plugin", "force", "apache", "call", "app", "url", "Client", "connect", "container", "contact", "cli", "service", "api"], "httpParams": ["HTTPPARums", "httpArums", "httpPARams", "httpPARamas", "httpPerparams", "httpPARam", "HTTPParcs", "httpPamer", "httpPoeters", "httpPreters", "HttpParam", "httpPerams", "httpPARparams", "httpParamas", "httpAram", "httpPARcs", "httpArcs", "HTTPPARams", "HTTPPoamer", "HTTPPARcs", "httpPoparams", "httpPareters", "httpPeram", "HTTPParam", "httpPrams", "HTTPPoeters", "httpParums", "httpParparams", "HTTPParamer", "httpPeramas", "httpArams", "httpPARums", "httpPoams", "httpParcs", "httpPeters", "HttpParams", "httpPoamer", "httpPramer", "HTTPParparams", "HTTPPARam", "HTTPPoparams", "HTTPPareters", "httpPams", "httpParam", "HttpParamas", "httpPrparams", "httpPparams", "HTTPPoams", "httpParamer", "HTTPParums", "HTTPParams", "HttpParparams"], "response": ["server", "resource", "output", "feed", "report", "http", "results", "message", "json", "document", "onse", "result", "relation", "resp", "connection", "model", "application", "collection", "data", "body", "page", "object", "reply", "status", "success", "received", "Response", "respond", "successful", "error", "api", "view"], "entity": ["event", "article", "translation", "address", "node", "agent", "server", "resource", "Entity", "output", "entry", "http", "document", "json", "result", "instance", "company", "content", "ent", "type", "source", "ce", "connection", "component", "media", "model", "application", "collection", "data", "file", "body", "channel", "object", "environment", "conn", "creator", "coll", "e", "writer", "person", "pe", "em", "xml", "element", "api"], "reader": ["ry", "buffer", "loader", "i", "input", "handler", "server", "editor", "feed", "reading", "per", "inner", "ri", "driver", "read", "in", "iter", "ler", "er", "source", "bird", "oder", "ner", "r", "parser", "rar", "iterator", "row", "rr", "rer", "io", "writer", "rx", "worker", "ser", "stream", "Reader"], "line": ["val", "string", "base", "non", "job", "sel", "id", "feed", "lf", "user", "entry", "message", "LINE", "character", "ge", "end", "l", "el", "pass", "key", "iter", "content", "char", "sync", "source", "lines", "lc", "no", "len", "model", "r", "str", "data", "li", "cl", "page", "ip", "le", "inline", "row", "name", "header", "word", "link", "sl", "layer", "url", "unit", "comment", "Line", "lin", "block", "definition", "code", "cell"]}}
{"id1": "21348951", "id2": "13499897", "code1": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 1, "substitutes": {"processAddByURLSubmit": ["processAddByURLSummitted", "processAddByURLSsubmitted", "processAddByURLSubmitted", "processAddByURLSsubmitter", "processAddByURLSUBmit", "processAddByURLSUBmission", "processAddByURlsUBmitted", "processAddByURLSUBmitted", "processAddByURlsUBmission", "processAddByURlsubmitted", "processAddByURLSummitter", "processAddByURlsubmitter", "processAddByURLSsubmission", "processAddByURLSummission", "processAddByURLSummit", "processAddByURLSubmission", "processAddByURlsubmit", "processAddByURLSubmitter", "processAddByURlsubmission", "processAddByURLSUBmitter", "processAddByURlsUBmitter", "processAddByURLSsubmit", "processAddByURlsUBmit"], "url": ["string", "path", "address", "base", "ssl", "buffer", "server", "uri", "feed", "resource", "user", "entry", "http", "ref", "l", "location", "host", "URL", "email", "source", "connection", "ug", "str", "ob", "data", "file", "src", "route", "page", "ll", "log", "ls", "e", "image", "io", "link", "sl", "secure", "Url", "www", "stream", "ur", "xml", "org", "loc"], "invalidUrlMsg": ["inbadUrlMsg", "inInvalidUrlMessage", "inbadFileMsg", "inbadUrlMessage", "invalidURLog", "invalidStringMessage", "invalidUrlStr", "invalidUrlMessage", "invalidFileStr", "invalidUrlmsg", "inInvalidUrlUrl", "invalidUrog", "invalidFileMessage", "inbadUrlmsg", "invalidFileUrl", "invalidURLMessage", "invalidTimeMsg", "invalidTimemsg", "inbadFileMessage", "inInvalidUrlmsg", "invalidFileog", "inInvalidURLUrl", "invalidUrlog", "invalidFileMsg", "inbadUrlog", "invalidTimeStr", "invalidTimeMessage", "inInvalidURLMsg", "inInvalidURLMessage", "invalidUrlUrl", "invalidURLUrl", "invalidStringUrl", "invalidFilemsg", "inInvalidUrlMsg", "invalidURLMsg", "inbadFilemsg", "invalidStringMsg", "invalidUrMessage", "inInvalidUrlStr", "inInvalidURLmsg", "invalidStringmsg", "inbadFileog", "invalidURLStr", "invalidURLmsg", "invalidUrmsg", "invalidUrMsg", "inInvalidURLStr"], "xmlSourceWriter": ["jsonStringwriter", "jsonReaderReader", " xmlSourceWritten", "xmlStrReader", "jsonSourceWritten", " xmlourceWritten", "xmlourceString", "xmlInputString", "xmlStrWriter", "xmlSourcewriter", "jsonReaderWriter", "xmlStrwriter", "jsonReaderWritten", "xmlResourceString", "jsonSourcewriter", "xmlSourceWritten", "xmlInputWrite", "xmlResourceWriter", "xmlServiceReader", "jsonStringReader", "xmlResourceWritten", "xmlReaderReader", "jsonReaderWrite", "xmlStringWrite", "xmlResourceReader", "jsonSourceWrite", "xmlInputWriter", "xmlInputWritten", "xmlServiceWritten", "xmlServiceWrite", "xmlourceWritten", "xmlServicewriter", " xmlSourceString", "jsonStringWrite", "jsonStringWriter", "xmlInputReader", "xmlReaderWriter", "xmlStringWriter", "jsonSourceWriter", "xmlSourceWrite", "xmlReaderWrite", "xmlStrWrite", "xmlSourceString", "xmlStringwriter", " xmlourceReader", " xmlourceString", " xmlSourceReader", "xmlReaderWritten", "xmlServiceWriter", "xmlourceWriter", "jsonSourceReader", "xmlSourceReader", "xmlStringReader", "xmlourceReader", " xmlourceWriter"]}}
{"id1": "3731077", "id2": "8778962", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", " copyfile", "copySourceFile", "transferfile", "transferSourceFile", "importFiles", " copySourceFile", "copyFiles", "copyfile", "importfile", "transferFile", "importFile", "transferFiles", "importSourceFile"], "from": ["before", "From", "client", "ca", "original", "left", "src", "form", "ce", "old", "user", "id", "address", "origin", "or", "a", "path", "resource", "io", "se", "at", "file", "of", "part", "start", "f", "url", "o", "this", "base", "data", "with", "range", "name", "by", " form", "d", "front", "without", "as", "remote", "about", "add", "back", "source", "config", "c"], "to": ["auto", "os", "toc", "client", "p", "size", "one", "too", "output", "socket", "object", "parent", "copy", "po", "office", "To", "t", "target", "or", "location", "TO", "top", "io", "into", "at", "file", "dest", "of", "root", "storage", "f", "o", "eto", "null", "until", "api", "base", "this", "temp", "type", "with", "b", "database", "token", "so", "name", "by", "site", "again", "as", "two", "point", "about", "source"], "parentDir": ["parentFile", "rootDir", "parentDirectory", "rootFolder", "ParentDirectory", "ParentFolder", "parentFolder", "currentDir", "currentFolder", "ParentFile", " parentDirectory", "currentdir", "rootDirectory", "rootFile", " parentdir", "outDir", "parentdir", " parentFile", "outFile", "ParentDir", "currentFile", "outFolder", "Parentdir", " parentFolder", "outDirectory"], "in": ["r", "image", "m", "pin", "sync", "ie", "inn", "isin", "gin", "i", "form", "rc", "pre", "init", "cin", "input", "on", "id", "arin", "din", "conn", "diff", "or", "lin", "inner", "vin", "io", "nin", "con", "ini", "fc", "rec", "kin", "work", "part", "inside", "rin", "min", "url", "o", "exec", "login", "err", "with", "trial", "it", "ins", "pc", "bin", "In", "l", "plugin", "again", "IN", "reader", "win", "source", "ac", "inc"], "out": ["Out", "ico", "auto", "client", "writer", "p", "sync", "off", "gin", "output", "init", "app", "cin", "input", "user", "ou", "win", "on", "cy", "ex", "option", "conn", "or", "inner", "io", "op", "at", "ot", "o", "channel", "exec", "vert", "can", "org", "w", "other", "net", "co", "call", "bin", "plugin", "again", "outer", "outs", "about", "c", "OUT", "ac", "inc"], "ic": ["ico", "aic", "ai", "auto", "irc", "cus", "sync", "IC", "i", "ik", "rc", "cc", "cs", "cin", "ix", "input", "ex", "ci", "lc", "conn", "loc", "or", "cu", "bc", "dc", "io", "op", "voc", "uc", "fc", "xc", "pic", "enc", "o", "vc", "ac", "iac", "cl", "nic", "ct", "pc", "co", "anc", "ig", "mc", "ics", "acs", "icc", "c", "inc", "ec"], "oc": ["aic", "toc", "sc", "ca", "cus", "i", "cc", "aco", "cy", "ci", "circ", "OC", "alloc", "loc", "or", "bc", "dc", "cur", "ocol", "io", "ob", "op", "wic", "voc", "uc", "fc", "xc", "oca", "oci", "roc", "o", "enc", "vc", "ac", "can", "ack", "org", "AC", "soc", "nic", "pc", "co", "anc", "mc", "ocon", "acs", "og", "mic", "oco", "c", "inc", "ec"]}}
{"id1": "16550855", "id2": "19549577", "code1": "    public String readPage(boolean ignoreComments) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String inputLine;\n        String html = \"\";\n        if (ignoreComments) {\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.length() > 0) {\n                    if (inputLine.substring(0, 1).compareTo(\"#\") != 0) {\n                        html = html + inputLine + \"\\n\";\n                    }\n                }\n            }\n        } else {\n            while ((inputLine = in.readLine()) != null) {\n                html = html + inputLine + \"\\n\";\n            }\n        }\n        in.close();\n        return html;\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 1, "substitutes": {"readPage": ["readPages", "openpage", "readFile", "openPages", "getFile", "findPage", "getPages", "getPage", "readpage", "findPages", "openFile", "getpage", "findFile", "openPage", "findpage"], "ignoreComments": ["useComments", "includeTags", "includeComments", " ignoreTags", "oreComment", "ignorecomments", "orecomments", "ignoreComment", "oreQuotes", "useTags", " ignoreComment", "useQuotes", "ignoreQuotes", "usecomments", "includeComment", "oreComments", " ignorecomments", "oreTags", "includecomments", " ignoreQuotes", "ignoreTags"], "in": ["IN", "index", "ssl", "buffer", "i", "input", "id", "token", "loader", "user", "ini", "gin", "on", "http", "into", "con", "c", "inner", "socket", "version", "as", "ins", "s", "bin", "is", "client", "reader", "source", "login", "connection", "min", "inside", "r", "inc", "data", "file", "out", "h", "init", "rec", "again", "e", "m", "image", "t", "re", "isin", "it", "In", "nin", "kin", "url", "stream", "lin", "b", "err", "inn", "f", "win", "din"], "inputLine": ["InputText", "incLook", "incL", "InputLook", "requestRow", "inputName", "requestline", "pullLine", "installline", "inputRow", " inputRow", "requestLink", " inputCell", "incLine", "ifLook", "ifline", "InputName", "pullline", "installLook", "imageLine", " inputText", " inputLook", "imageL", "InputLine", "rawLine", "Inputline", "pullLink", "requestLine", "InputLink", "incline", "rawL", "ifLine", " inputName", "ifCo", " inputCo", "inputL", " inputPage", "imageline", "commentline", " inputline", "rawName", "requestLook", "installL", "pullRow", "InputL", "inputCo", "commentLine", "inputCell", "inputText", "inputline", "rawLink", "InputCell", "requestCo", "inputPage", "rawText", "inputLook", " inputL", "commentCell", " inputLink", "installLine", "imageLook", "inputLink", "rawline", "InputPage", "commentPage"], "html": ["article", "base", "temp", "css", "HTML", "output", "bf", "atom", "embed", "gh", "http", "message", "json", "plain", "ht", "result", "hot", "ui", "detail", "strong", "high", "htm", "content", "part", "wrap", "links", "doc", "tml", "source", "live", "show", "str", "data", "attr", "body", "flat", "amp", "war", "web", "h", "page", "flash", "inline", "format", "msg", "title", "template", "rss", "header", "js", "text", "home", "blog", "link", "details", "dump", "url", "tt", "www", "summary", "xml", "tf", "bsp", "f", "hard", "api", "view", "img"]}}
{"id1": "14820302", "id2": "22411381", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"innerProcess": [" innerWrite", "subprocess", "binaryConnect", "innerprocess", "binaryWrite", "binaryprocess", " innerConnect", "subProcess", "innerWrite", "subConnect", "binaryProcess", " innerprocess", "innerConnect", "subWrite"], "curi": ["furi", "lcURI", "cri", "lURI", " cURI", "lcunit", "cgui", "Cui", "CURI", "lcuri", "pri", "fri", "firi", "Curi", "fui", " cui", " cgui", "luri", "Cunit", "lcui", "capi", "Cgui", "Cri", "cURI", "pURI", "Capi", " cri", "lri", "lcri", "cui", "Curl", " capi", "Ciri", "lcgui", "papi", "curl", " cunit", " curl", "ciri", "cunit", "lciri", "fURI", "lurl", "puri"], "regexpr": ["pregexer", "renexpr", "pregexpl", "reggexr", "Regexpre", "reggexper", "Renexpre", "renexper", "reggexpl", "recer", "relexPR", "recrepl", "recreer", "reggexpr", "relexpre", "regnexpr", "regexer", "pregexpr", "rerer", "rerepl", "rereper", "RenexPR", "regexPR", "Regexpr", "regnexr", "renexer", "prenexer", "recrepr", "prenexpl", "recrepre", "Renexp", "renexpl", "pregexp", "recrep", "renexr", "regexp", "recrePR", "renexPR", "reruer", "renexp", "Renexpr", "regexr", "prenexp", "receper", "relexpr", "rerupl", "rerupr", "regexpl", "regnexper", "relexp", "regexpre", "renexpre", "regexper", "recepr", "regnexpl", "Regexp", "RegexPR", "prenexpr", "rerepr", "recepl", "rerup"], "cs": ["Cs", "bc", "lc", "cm", "cf", "ins", "ms", "ca", "cache", "cers", "CS", "cb", "rs", "vs", "tc", "es", "ns", "ks", "conn", "cms", "cr", "ls", "cells", "cing", "cp", "cks", "c", "cc", "ci", "spec", "ios", "os", "ec", "acts", "codes", "cer", "acs", "acks", "js", "ps", "ars", "sync", "ced", "cus", "css", "ces", "ds", "ics", "fs", "cas", "wcs", "rc", "cos", "sc", "cn", "ches", "qs", "icks", "coll", "pc", "ac", "cases", "details", "ss", "bs", "cons", "ctx", "ce", "gs"], "digest": [" digested", "bigEST", " digity", "digit", "hashest", "signEST", "igity", "signest", "Digity", "bigest", " digests", "hashcher", "digcher", "logester", "Digger", " digcher", "digEST", "igest", "signger", "diggest", "biggest", " digester", "digester", " diggest", "Digcher", " digEST", "digests", "igester", "logger", "signests", "signgest", " digit", "digity", "hashger", "digested", "Diger", "Digester", "logit", "hashester", "signester", "diger", "igested", "Digest", " diger", "signer", "digger", "Digested", "logest", "Digit", "bigests", " digger", "signested"], "s": ["su", "v", "address", "services", "ms", "groups", "str", "e", "sets", "rs", "ws", "sl", "ns", "abs", "string", "u", "ls", "binary", "c", "states", "si", "ses", "os", "strings", "t", "sum", "sb", "r", "g", "b", "js", "n", "o", "ans", "ps", "sym", "S", "sync", "ds", "p", "bytes", "h", "obs", "is", "l", "data", "ss", "bs", "f", "gs", "settings"], "m": ["map", "cm", "v", "mc", "imm", "ms", "mr", "gm", "e", "rm", "pm", "am", "bm", "mo", "machine", "string", "fm", "man", "M", "c", "sm", "mi", "ym", "om", "r", "mm", "tm", "p", "hm", "wm", "me", "match", "vm", "nm", "dm"], "newDigestValue": ["newDigesterKey", "newDigestValues", "newDigestedValues", "newSignestValue", "newDigestVal", "newDigESTKey", "newDigestKey", "newSignestedValues", "newDigeterString", "newSignestValues", "newSignestedValue", "newSignestString", "newDigestedKey", "newSignestKey", "newSignestedString", "newDigESTValue", "newDigeterValue", "newDigestedValue", "newDigESTValues", "newDigesterVal", "newSignestedKey", "newDigestedVal", "newDigeterKey", "newDigesterString", "newDigeterVal", "newDigesterValues", "newDigesterValue", "newDigestedString", "newDigESTString", "newDigestString"]}}
{"id1": "8468859", "id2": "17724879", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "label": 0, "substitutes": {"connect": ["close", "add", "on", "con", "connected", "socket", "find", "run", "patch", "Connect", "host", "write", " connection", "read", " reconnect", "en", " disconnect", "select", "client", "stat", "nect", "construct", "login", "connection", "build", "open", "bind", "config", "log", "conn", "init", "start", "exec", "port", "establish", "create", "sign", "download", "boot", "stop"], "status": ["index", "temp", "id", "output", "response", "server", "user", "continue", "site", "version", "current", "result", "standard", "si", "ui", "active", "content", "Status", "fail", "sync", "session", "source", "use", "stat", "type", "login", "min", "str", "parent", "log", "style", "complete", "edit", "success", "full", "skip", "update", "unit", "summary", "wait", "stage", "count", "progress", "state", "step", "speed", "code"], "reply": ["reason", "info", "address", "fee", "dy", "base", "server", "response", " response", "message", "py", "result", "answer", "query", "ret", "next", "post", "sync", "resp", "connection", "Reply", "data", "request", "vote", "action", "send", "call", "link", "prefix", "second", "ping", "bot", "respond", "update", "comment", "random", "state", "count", "repl", "error", "code"], "isConnected": ["isNECTalled", "isaAdapting", "isaConnectified", "IsConnected", "isConnectaged", "isFinalled", "IsConnections", "isConnectionp", "IsConnectionp", "isAcceptted", "isConnects", "isConnectioning", "isConnectted", "isAcceptaged", " isAcceptted", "IsConnectioning", " isConnectioned", "isFinaged", " isConnectable", " isAcceptaged", "isNECTing", "IsConnectp", "isAdapting", "isconnecteded", "isConnectionified", "isConnectified", "isaConnecting", " isConnectted", "isAdaptified", "IsConnects", " isConnecting", "isConnectished", "IsConnectioned", "isconnecteding", "isAdapteded", "isFinished", "isConnectioneded", "isConnectp", "isaAdaptified", "isConnections", " isAcceptable", "isNECTished", "isaAdapteded", "isAdapted", "isaAdapted", " isAccepted", "isAcceptable", " isConnectionished", "isconnectedp", " isConnectalled", " isConnectaged", "isFined", "isConnectionished", "isFinted", "isConnecteded", "isConnectioned", "isConnectionalled", " isConnectionalled", " isConnectioning", "isNECTed", "IsConnecting", "isFinable", " isConnectished", "isAccepted", "isaConnecteded", "isaConnected", "isFining", "isconnecteds", "isConnectalled", "isConnecting", "isConnectable"]}}
{"id1": "9109613", "id2": "13657103", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"fileCopy": ["Filecopy", "folderTransfer", "FileTransfer", " fileUpload", " filecopy", "FileUpload", "FileCopy", "fileUpload", "filecopy", "folderUpload", "fileTransfer", "folderCopy", "foldercopy", " fileTransfer"], "from_name": ["from_address", "fromqname", " from__address", "from__name", "fromqName", "from_resource", "fromqfilename", " from__alias", "from_key", " from_word", " from_space", "from_time", "from_size", " from__Name", "fromThespace", "from_alias", " from_filename", "fromTheName", "from_no", " from__name", "from_word", "fromameno", "from_filename", " from_resource", " from_path", "from__address", "from_space", "fromamename", "fromFullName", " from_Name", "fromameName", "fromTheword", "from_path", " from_address", "fromqpath", "from_image", " from_time", " from_key", "from_Name", "from__Name", "fromFullname", " from_alias", " from_no", " from_image", "from__alias", "fromThename", "fromFullalias", "fromFulladdress", "fromametime", " from_size"], "to_name": ["To_common", "tokName", "to_names", "To_Name", "from_names", " to_key", "to_path", "to_Name", "from_Name", " to_file", "from_path", "to_common", "to_file", "to_key", "To_name", "tokname", "tokcommon"], "fromFile": ["tofile", " fromfile", "autofile", "autoFile", " fromModel", "sourcePage", "oneModel", "fromFactory", " fromPackage", "toFunction", "FromFile", "ofFile", "offile", "autoFolder", "ofPackage", "fromFolder", "sourceLibrary", " fromDirectory", "FromFolder", "onefile", " fromPage", "FromDirectory", "fromfile", "ofFolder", "connectionFile", "FromDir", "fromFiles", " fromLibrary", "fromLibrary", "fromModel", " fromFiles", "FromModel", "fromDirectory", " fromLine", "sourceFile", "Fromfile", "fromPage", "connectionPackage", "fromDir", "oneFunction", "sourceDirectory", "asFiles", " fromFactory", "onePage", "asFactory", "toLine", " fromDir", "FromFunction", " fromFolder", "fromPackage", "connectionFolder", "oneFolder", "oneDir", "asfile", "toFiles", " fromFunction", "fromFunction", "fromLine", "autoPage", "asFile", "connectionfile", "FromFiles", "FromPage", "oneFile", "FromLine", "FromLibrary", "toFactory"], "toFile": [" tofile", "soFile", "toFunction", "basefile", "ToLine", " toFunction", "ToPage", "TODir", "fromDirectory", "ToFunction", "targetFactory", "fromDir", "aFile", " toTable", "baseTable", "baseFile", "cofile", "ofDir", " toLine", "ToPlace", "targetPlace", "targetFolder", "toPlace", "ToDirectory", "offile", "noLibrary", " toFiles", "tempfile", "ToFiles", " toFolder", "targetSourceFile", "toPage", "coDirectory", "TOFile", "TOPlace", "tempFile", " toDirectory", "ofFile", "afile", "ofTable", "toLibrary", "targetfile", " toDir", "nofile", "aDir", "noFile", "tempFolder", " toFactory", "soLibrary", " toPage", "tempFactory", "targetPage", "coFunction", "Tofile", "targetDir", "tofile", "toTable", "aFiles", "ToLibrary", "toDirectory", "fromfile", "fromFiles", "toDir", "soPage", "noPage", "ToFactory", "fromPage", "sofile", " toSourceFile", "toLine", "ToFile", "TOPage", "ToSourceFile", "baseDir", "ToDir", "toFolder", "fromLine", "toFiles", "targetFile", "coFile", "toFactory", "toSourceFile"], "parent": ["shape", "g", "master", "key", "section", "complete", "address", "content", "Parent", "root", "api", "test", "search", "name", "string", "pr", "ip", "client", "large", "p", "full", "pa", "user", "page", "patch", "rule", "home", "loc", "region", "path", "pool", "file", "part", "div", "any", "and", "ac", "inc", "class", "guard", "id", "lc", "directory", "port", "valid", "option", "child", "out", "manager", "line", "url", "null", "pe", "remote", "paren", "point", "source", "pt", "term", "par", "owner", "server", "or", "connection", "location", "exp", "resource", "col", "session", "data", "type", "parents", "current"], "dir": ["r", "db", "attr", "DIR", "block", "def", "class", "fd", "dict", "cat", "dec", "directory", "coll", "home", "per", "loc", "group", "or", "dr", "ver", "dc", "container", "path", "dep", "cur", "exp", "ir", "out", "manager", "rec", "file", "root", "dist", "wd", "director", "f", "url", "col", "lib", "die", "build", "doc", "iter", "div", "rel", "keep", "Dir", "name", "di", "mod", "d", "folder", "lock", "dev", "inc", "dis"], "from": ["when", "get", "auto", "From", "in", "clean", "fr", "client", "de", "component", "flo", "query", "one", "left", "stream", "old", "ce", "form", "view", "ou", "user", "parse", "e", "cr", "po", "per", "conn", "module", "or", "connection", "wh", "low", "io", "se", "cm", "ra", "out", "con", "file", "part", "who", "start", "link", "url", "ch", "o", "this", "base", "normal", "channel", "api", "with", "can", "range", "hand", "so", "name", "bean", "by", "without", "empty", "add", "source", "self", "c", "vol"], "to": ["auto", "db", "su", "size", "sync", "too", "flo", "go", "one", "http", "output", "object", "proxy", "copy", "on", "po", "tto", "office", "page", "To", "cache", "port", "plus", "target", "or", "connection", "fat", "fb", "TO", "ver", "be", "io", "top", "op", "see", "not", "out", "file", "pi", "store", "o", "eto", "until", "base", "api", "no", "will", "type", "with", "b", "token", "via", "tom", "so", "name", "co", "by", "again", "two", "about", "source"], "buffer": ["position", "bytes", "shape", "batch", "block", "queue", "texture", "transfer", "default", "comment", "feed", "character", "reference", "page", "Buffer", "cache", "server", "address", "result", "padding", "message", "resource", "buff", "value", "row", "uffer", "available", "iter", "buf", "binary", "device", "channel", "null", "data", "border", "number", "document", "total", "memory", "table", "reader", "string", "header", "variable", "seed", "vector", "duration", "read", "flush", "layer", "length"], "bytes_read": ["bytesayput", "bytes_received", " bytes_write", "classesavREAD", "classes_READ", "bytesESSput", "bytesESSreceived", "bytesayreceived", "bytes___READ", "classesavread", "classesavview", "lines_read", "classesavavailable", " bytes_load", "bytesavview", "classes_read", "bytes_load", "bytes_write", "bytes___read", "bytes_view", "bytes_available", " bytes_written", "bytes___available", "lines_put", "bytesavavailable", "bytes_put", "bytesavREAD", "bytes___view", "bytesayread", "bytesESSwritten", "bytesaywritten", "bytesavread", "bytesESSread", "bytes_READ", "bytes_written", "classes_available", "lines_received", "classes_view", "lines_written"]}}
{"id1": "18731843", "id2": "20190303", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"doBody": [" doBytes", "handleFile", "handleBody", "DoResponse", "doBytes", "DoFile", "handleResponse", "doResponse", "DoBody", " doFile", "doFile", "handleBytes", "DoBytes", " doResponse"], "req": ["ref", "rx", "rec", "download", "config", "info", "this", "reg", "rr", "src", "conn", "serv", "qt", "qq", "q", "data", "resource", "proc", "requ", "spec", "obj", "query", "res", "rss", "respond", "fr", "jp", "comp", "def", "request", "r", "err", "crit", "cgi", "reader", "rh", "sem", "Request", "report", "http"], "resp": ["p", "pre", "ref", "ret", "result", "rec", "re", "cache", "download", "bb", "rr", "serv", "pos", "exc", "val", "data", "prot", "Resp", "job", "b", "proc", "Response", "obj", "rep", "res", "api", "sp", "inv", "respond", "jp", "respons", "comp", "html", "request", "part", "err", "response", "r", "rev", "cb", "cmp", "report", "reply"], "bis": ["phis", "uds", "mis", "tis", "ris", "bh", "sb", "bits", "obb", "bb", "fb", "bas", "sis", "ori", "iss", "ubis", "sin", "abi", "bian", "lis", "bid", "bps", "binary", "alis", "bi", "isin", "ses", "pins", "b", "os", "obi", "los", "usb", "is", "oris", "bs", "rots", "obos", "ais", "ios", "atis", "lins", "iris", "nis", "obs", "boot", "bin", "ois", "bes"], "bos": ["phis", "tis", "uds", "bh", "bits", "opus", "bones", "obb", "bris", "bas", "mos", "bo", "oops", "ubis", "antis", "bott", "abi", "obo", "bps", "bi", "ros", "bin", "obi", "os", "oks", "los", "oS", "zos", "oros", "bs", "zo", "fits", "obos", "las", "oos", "ios", "aos", "lol", "lins", "osa", "obs", "osi", "boot", "oses", "ois", "bes", "ops"]}}
{"id1": "23246123", "id2": "9687813", "code1": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "code2": "    public static InputStream getFileInputStream(String path) throws IOException {\n        InputStream is = null;\n        File file = new File(path);\n        if (file.exists()) is = new BufferedInputStream(new FileInputStream(file));\n        if (is == null) {\n            URL url = FileUtils.class.getClassLoader().getResource(path);\n            is = (url == null) ? null : url.openStream();\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"createDialogArea": ["createDialogPanel", " createButtonarea", " createHelpPanel", "createControlPanel", "createEditorArea", "createMessagearea", "createDialogGroup", "createHelpArea", " createDialogPanel", " createHelparea", " createButtonGroup", " createButtonArea", "createMessageArea", "createHelparea", "createHelpPanel", " createDialogarea", "createEditorarea", "createButtonarea", "createControlArea", "createEditorGroup", "createDialogarea", "createControlarea", "createHelpGroup", " createDialogGroup", "createMessagePanel", "createButtonArea", " createHelpArea", "createButtonGroup"], "parent": ["cl", "client", "panel", "builder", "sup", "port", "current", "child", "container", "host", "parents", "context", "section", "image", "c", "this", " sup", "comp", "self", "component", "menu", "connection", "g", "class", "null", "object", "root", "parser", "clip", "message", "resource", "p", "wrapper", "document", " child", "page", "instance", "Parent", "ctx", " scene"], "composite": ["Compositing", "complexiting", "comvalitor", "complexitable", "compposites", "compositionitor", "comositable", "Composite", "complexites", "compositive", "Complexitable", "comPOSitable", "Compositable", "compositionited", "compposited", "complexitor", "comosited", "comvalitive", "compositionites", "complexite", "Complexite", "Complexites", "comppositable", "composited", "compositor", "comppositive", "comppositionited", "compposite", "comPOSiting", "comPOSite", "comppositionitor", "compositable", "Composites", "compositing", "comppositionitive", "comvalite", "compositionite", "comppositionitable", "compositionitive", "comosite", "comppositor", "compositionitable", "comppositionite", "comPOSited", "Complexiting", "comvalites", "complexitive", "comPOSites", "compositioniting", "comppositionites", "composites", "comosites"], "content": ["complete", "exec", "cm", "address", "cont", "header", "client", "title", "output", "app", "comment", "feed", "load", "child", "model", "container", "xml", "folder", "plugin", "host", "context", "conn", "cms", "scroll", "section", "image", "code", "layer", "format", "component", "connection", "report", "html", "application", "object", "config", "loader", "message", "media", "resource", "version", "Content", "document", "copy", "page", "ez", "source", "server", "file", "create", "json", "activity", "control", "cell"], "ncol": ["nbCol", "numrow", " nblock", "Ncolumn", "Ncol", " nCol", " nrow", " ncolumn", "numcolumn", "pCol", "nbrow", "ncolumn", "Nblock", "pcol", "NCol", "numCol", "nCol", "nbcolumn", "nbcol", "pcolumn", "numcol", "pblock", "nblock", "nrow"], "layout": ["shadow", "flow", "address", "lc", "position", "base", "follow", "view", "feed", "zip", "model", "container", "xml", "font", "nl", "design", "flat", "holder", "location", "ui", "offset", "scroll", "section", "image", "lock", "widget", "where", "build", "layer", "shape", "join", "config", "edit", "list", "block", "padding", "Layout", "alpha", "mount", "scale", " layouts", "translation", "grid", "l", "lay", "data", "entry", "inline", "nav", " Layout", "figure", "draw", "board", "group", "closure", "split", "control"], "numColumns": ["numColes", "numControles", "nbcolumnows", "nbColumns", "numControln", "numcolumnn", "nbColumnes", "nbColumnn", "numColumnows", "numColumnes", "numColows", "numcolumnes", "numControlows", "nbcolumnn", "nbcolumns", "numcolumnows", "nbcolumnes", "numcolumns", "numColn", "numControls", "numCols", "numColumnn", "nbColumnows"], "browser": ["shadow", "ger", "feature", "test", "chrome", "img", "ver", "client", "flash", "finder", "window", "br", "sim", "comment", "feed", "platform", "proxy", "io", "jar", "fire", "plugin", "design", "remote", "host", "session", "binary", "driver", "image", "bot", "facebook", "lib", "editor", "Browser", "river", "webkit", "ssl", "fox", "box", "report", "html", "root", "bar", "js", "front", "iframe", "mobile", "config", "loader", "graph", "css", "uri", "agent", "http", "cookie", "page", "cart", "vert", "roller", "server", "google", "nav", "coll", "theme", "runner", "open", "web", "book", "manager"], "text": ["atter", "test", " Text", "client", "title", "str", "output", "port", "feed", "term", "path", "font", "plugin", "label", "input", "abs", "string", "name", "ext", "binary", "struct", "driver", "inner", "context", "image", "select", "pdf", "off", "editor", "format", "element", "writer", "info", "connection", "report", "user", "ut", "object", "desc", "config", "message", "service", "it", "form", "Text", "data", "vert", "letter", "source", "entry", "unit", "txt", "comment", "TEXT"], "url": ["address", "base", "rel", "re", "id", "feed", "io", "URL", "zip", "path", "sl", "Url", "host", "string", "gl", "image", "ssl", "connection", "user", "www", "config", "pull", "ur", "uri", "service", "resource", "api", "lr", "bel", "http", "page", "l", "source", "server", "file", "download", "ref", "open", "web", "f"], "in": ["gin", "ins", "reader", "din", "IN", "w", "re", "str", "login", "el", "bin", "ar", "br", "inc", "xml", "x", "ini", "er", "input", "ic", "out", "In", "s", "conn", "inner", "stream", "on", "image", "err", "c", "or", "a", "i", "b", "again", "o", "rec", "nin", "ri", "fr", "resource", "inn", "p", "min", "it", "pin", "rb", "is", "dr", "data", "l", "rc", "lin", "arin", "init", "d", "rin", "pass", "serv", "f"], "r": ["vr", "reader", "rh", "re", "sr", "mr", "rel", "br", "ar", "right", "rr", "rf", "nr", "er", "res", "out", "ir", "hr", "cr", "err", "rw", "c", "rt", "or", "m", "i", "rg", "b", "rx", "kr", "o", "ner", "ri", "fr", "ur", "ru", "lr", "rob", "p", "rb", "h", "dr", "l", "rc", "R", "ro", "gr", "d", "rar", "rss", "f", "rl", "rs", "pr"], "sb": ["bc", "bj", "sv", "xb", "ib", "sr", "bb", "gb", "ob", "bp", " SB", "lp", "db", "bm", "nl", "fb", "mb", "abs", "s", "binary", "ls", "bsp", "sth", "sm", "si", "ruby", "storage", "sa", "sg", "ssl", "SB", "lb", "b", "library", "buf", "abb", "wb", "kb", "buffer", "lr", "rob", "eb", "sn", "ab", "rb", "lab", "usb", "pb", "bh", "src", "bf", "obb", "sp", "erb", "sf", "cb", "bs"], "line": ["cl", "lc", "header", "base", "str", "el", "comment", "id", "le", "nl", "sl", "row", "ge", "string", "name", "li", "Line", "obj", "lines", "end", "character", "code", "LINE", "i", "pe", "b", "n", "object", "block", "cle", "message", "key", "lf", "l", "data", "lin", "page", "col", "entry", "char", "source", "ne", "letter", "inline", "pass", "split", "part", "se", "record", "f", "cell", "stroke"], "e": ["oe", "de", "esi", "error", "exc", "ue", "ele", "ime", "ise", "one", "ea", "ge", "er", "es", "je", "te", "ee", "err", "E", "ef", "fe", "or", "en", "ec", "ie", "i", "pe", "ite", "ce", "ception", "o", "ale", "ae", "p", "ve", "me", "ev", "se", "ke", "d", "ne", "ze", "f", "le", "be"]}}
{"id1": "659316", "id2": "22264586", "code1": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"argv": ["paramv", "Argf", "argb", "argver", "argsc", "argumentve", " argV", "ArgV", "argumentc", "argl", "argc", " argf", "interc", "Argve", "argve", " argc", " argl", "argV", "argsf", "Argver", "Argv", " argver", " argb", "interV", "paramV", "Argb", "paramb", "argumentver", "argumentv", "Argc", "interl", "paraml", "argsl", "argf", "Argl", "argsv", "interv", " argve"], "sources": ["psides", "sides", "vesores", " sors", "statences", "sores", "tides", "vesigs", "issors", "issources", "sors", "sresources", "sences", "tource", "statores", "fource", "vesources", "issides", "sesources", "psource", "psources", "issource", "tources", "fources", "psresources", "sesigs", "sesences", "sigs", "tresources", "vesences", "fresources", "statources", "fors", " sides", "sesores", "fides", "statigs"], "targets": ["taxes", "taxets", "tanget", " tokets", "Tanglets", "Targels", " taxes", "tangets", "taxels", " toket", "targends", "targes", "Targlets", "Targens", "tampels", "tiges", "targels", "tagnet", "tanglets", "tampets", "taxens", "tanges", " taxens", "tangels", "tigens", "toket", "tokencies", "targens", " tokencies", "Tangels", " targes", "tokets", " taxets", " tokens", "tigets", "tigends", " targends", "tokens", " taxends", "tamplets", "tagnencies", "tangends", "tangencies", " targens", "tagnens", "taxlets", "targlets", "Targets", "tampens", "taxends", "Tangens", " targencies", "targencies", "tagnets", "Tangets", "tangens"], "srclen": [" srcloen", "srploen", "rsceln", "srselens", "srclens", " srploen", "rscelen", " srclength", "srClEN", "srcln", "srctength", "srcteno", "srseln", "srclEN", "rsclEN", "rscln", "rscelens", "srCLeno", "srceln", "srcloen", " srcleno", "rscelEN", "srCln", "srClens", " srplen", "srclength", "srplength", "srcleno", " srpleno", "srCLoen", "srselEN", "srClen", "srpleno", "srcelen", "srcelens", "rsclens", " srplength", "rsclen", "srcten", "srctoen", "srplen", "srselen", "srCLen", "srcelEN", "srCLength"], "source": ["resource", "use", "seed", "channel", "current", "cache", "Source", "view", "proxy", "service", "scope", "input", "copy", "ource", "self", "path", "slice", "force", "driver", "dest", "in", "client", "unit", "single", "s", "rc", "out", "event", "model", "url", "get", "component", "config", "size", "sl", "link", "image", "start", "SOURCE", "remote", "ssl", "reader", "secure", "type", "ources", "id", "parent", "stream", "uri", "src", "create"], "tgt": ["tnt", "tgz", " tgz", " targ", "ptgt", "lnt", "targ", " tnt", "hgt", "bitgt", "tgs", "tch", "lret", " tbuster", " tkt", "biticket", "tret", "ticket", "tbuster", "Ticket", "lbuster", " tch", " ticket", "Tgs", "bitgh", "hret", "hgz", "tkt", "ptbuster", "rch", "hnt", "rkt", "tgh", "Tgh", "bitarg", "rgs", "lgt", " tret", "Tch", "Tgt", "rgt", " tgs", "lgz", "larg", "Tkt", " tgh", "ptarg", "ptnt", "Targ"], "target": ["resource", "slave", "route", "external", "cross", "project", "channel", "current", "view", "service", "master", "path", "manager", "io", "open", "match", "force", "tail", "driver", "dest", "arget", "download", "conn", "object", "child", "archive", "unit", "handler", "it", "rel", "goal", "connection", "base", "out", "event", "port", "url", "component", "session", "director", "image", "Target", "to", "result", "member", "next", "output", "nt", "remote", "point", "mount", "null", "plugin", "parent", "client", "core"], "deletes": ["kesleted", "degrades", " dedates", "desletes", "deists", "delletes", "deles", "downgrades", "exdates", "disists", "deises", "kesouts", "deleted", "exgrades", "desires", "desles", "Deires", " deouts", "disles", " delete", "desists", "delises", "exletes", "delouts", "kesises", "deires", "delete", "deouts", "exlete", "Deles", "kesletes", "Deletes", " degrades", "disletes", "dedates", "Deists", " deises", "delleted", "downletes", "downlete", "disires", "downdates", " deleted"], "del": ["pull", "local", "Delete", "clean", "d", "dl", "remove", "copy", "delay", "down", "ll", "add", "skip", "download", "dir", "def", " delete", "err", "rel", "bl", "up", "base", "fail", "install", "model", "coll", "delete", "get", "syn", "nl", "ul", "el", " Del", "diff", "se", "data", "change", "fl", "null", "de", "id", "update", "sel", "neg", "lock", "name", "file", "Del", "dec"]}}
{"id1": "16590954", "id2": "7458833", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"createJAR": [" createJJar", "createJPAR", "createPHAP", "createJARS", " createPHJar", "createJPJar", "createPHAR", "createAMARS", "createJPARS", "createAMAR", " createPHARS", " createJARS", " createJAP", " createPHAR", "createPHJar", "createAMAP", "createJAP", "createJJar", "createAMJar", "createPHARS", " createPHAP", "createJPAP"], "fileString": ["FileStream", "basestring", "FileString", "FileArray", "fileStream", " fileStr", "FileStr", "fileText", " fileName", " fileText", "loadName", "fileStr", "resourceText", "modelString", " fileFile", "modelStream", "modelStr", "fileName", "lineArray", " filestring", "resourceString", "FileText", "modelText", " fileArray", "baseString", "FileFile", "loadstring", "fileFile", "loadString", "Filestring", "baseStr", "fileArray", "FileName", "loadText", "resourceStr", "baseFile", "resourceStream", "lineString", "lineName", "filestring", "linestring"], "ext": ["prot", "text", "req", "ex", "url", "txt", "append", "xt", "ax", "Ext", "EXT", "info", "data", "version", "external", "dep", "zip", "str", "exp", "end", "type", "code", "class", "config", "filename", " Ext", "v", "desc", "dist", "name", "app", "exe", "extra", "path", "x", "content", "format", "enc"], "file": ["wave", "page", "pe", "log", "FILE", "url", "resource", "unit", "ile", "le", "module", "parent", "b", "build", "force", "flat", "single", "socket", "part", "folder", "model", "f", "it", "zip", "output", "h", "test", "let", "jar", "class", "source", "filename", "l", "work", "use", "db", "files", "base", "place", "ger", "queue", "bar", "local", "cache", "change", "name", "up", "binary", "per", "File", "full", "get", "line", "path", "buffer", "fe", "http", "fp", "doc"], "i": ["uri", "j", "ori", "si", "limit", "f", "ni", "it", "index", "ci", "iu", "key", "uni", "abi", "mini", "multi", "li", "di", "l", "mi", "hi", "pi", "ip", "xi", "eni", "slice", "ind", "yi", "v", "c", "I", "ai", "phi", "ini", "ii", "ui", "x", "qi", "p"], "dir": ["prefix", "doc", "direction", "url", "uri", "module", "rel", "loc", "DIR", "info", "data", "folder", "output", " directory", "zip", "area", "str", "coll", "type", "cur", "jar", "pkg", "class", "config", "directory", "filename", "src", "tmp", "db", "base", "id", "div", "string", "ir", "dist", "name", "domain", "path", "Dir", "format", "manager", "lib"], "jarFile": ["javaDir", "jarFolder", " jarFolder", "javafile", "reportSourceFile", "tarF", " jarFiles", " jarLine", "archiveFile", "jarDir", " jarSourceFile", "reportF", " jarfile", "jarF", "sessionfile", "jarSourceFile", "sessionLine", "javaFolder", "archiveFolder", "archiveFiles", "reportfile", " jarDir", "javaF", "tarfile", "archiveDir", "javaFile", "sessionFile", "jarLine", "tarFile", "tarSourceFile", "jarFiles", "javaFiles", "tarLine", "sessionSourceFile", "javaSourceFile", "jarfile", "reportFile"], "fstrm": ["fstrM", "fsrm", "fstrum", "fstrmd", "Fsrmd", "Fsrm", "fbrum", " fstrM", "fbrcm", " fsrm", "fsrmd", "fbrM", "fstrcm", "Fstrm", "fsrcm", "fsrum", "fbrm", "fgrm", "FstrM", "Fstrmd", "fstcm", "fstmd", "fstum", "FsrM", "fstm", " fstrum", "Fsrcm", "fstM", " fstrcm", "fgrmd", "fgrM", " fsrcm", "Fstrcm", " fsrum", "fsrM", "fgrcm", " fsrM"], "in": ["to", "m", "into", "ins", "image", "In", "n", "init", "io", "sync", "inc", "socket", "part", "f", "gin", "input", "din", "IN", "inn", "read", "conn", "s", "rin", "pull", "is", "reader", "inside", "nin", "stream", "l", "login", "inner", "min", "r", "id", "ac", "bin", "c", "up", "binary", "pin", "or", "again", "p"], "out": ["to", "m", "writer", "flow", "resource", "image", "server", "call", "plain", "null", "b", "connection", "init", "off", "io", "outer", "this", "sync", "outside", "inc", "part", "channel", "output", "group", "all", "exp", "Out", "conn", "source", "client", "self", "inner", "outs", "user", "v", "bin", "c", "err", "up", "net", "OUT", "pool", "plus", "again", "line", "doc"], "temp": ["doc", "writer", "unit", " Temp", "server", "dest", "build", "form", "porary", "single", "store", "Temp", "output", "folder", "wrap", "f", "it", "zip", "input", "controller", "archive", "storage", "template", "test", "key", "home", "source", "iter", "api", "Output", "tmp", "config", "directory", "db", "dump", "base", "local", "cache", "pipe", "export", "v", "c", " tmp", "w", "full", "fake", "get", "path", "clean", "or", "buffer", " temporary", "emp", "tem", "p"], "fstrm2": ["fhrms02", "fstrp0", "fhrms1", "fhrm1", "fstrmr2", "fstrmr002", "fstm0", "fhrm02", "fstrms0", "fhrms002", "fstrM0", "fstM1", "fstrm1", "fstm1", "fstrms02", "fstrM1", "fstrms002", "fstrM02", "fhrm002", "fstM2", "fstM0", "fstrms1", "fstrmr1", "fstm2", "fstrm0", "fstrM2", "fhrms2", "fstrmr02", "fhrm2", "fstrM002", "fstrms2", "fstrm002", "fstrp2", "fstrm02", "fstrp1"], "ostrm": ["ophrm", "obrm", "obrt", "oscmr", "oodrem", "oodrob", "otherrm", "ophrt", "obsrm", "ostm", "obmr", "ostrom", "ostrem", "obsrt", "ooprm", "otherrom", "ostrt", "oscrm", "oodrt", "oscrt", "odm", "oopmr", "istrt", "istrom", "istmr", "obrom", "oodrm", "ooprt", "odmr", "odrt", "ophmr", "istrm", "ostrob", "othermr", "otherrt", "oscm", "ophm", "odrm", "ooprom", "obsrem", "obsrob", "ostmr"], "docFile": ["docF", "documentF", " docFiles", " docF", " docDir", "documentFile", "docDir", "docFiles", "DocFiles", "documentDir", "documentFiles", "DocF", "DocDir", "DocFile"]}}
{"id1": "7087108", "id2": "8320469", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 0, "substitutes": {"doGet": ["processGet", "didGet", "processGET", "processPut", "doDownload", "didGET", "didDownload", "didPut", " doPut", "doGET", "doPut", " doDownload", " doGET", "processDownload"], "request": ["event", "info", "error", "buffer", "string", "input", "Request", "server", "resource", "uri", "user", "builder", "self", "report", "http", "subject", "message", "json", "version", "project", "current", "result", "forward", "instance", "child", "host", "query", "condition", "req", "client", "type", "reader", "use", "connection", "target", "model", "application", "config", "data", "parent", "route", "web", "object", "context", "complete", "name", "QUEST", "url", "create", "xml", "method", "this", "external", "view"], "response": ["remote", "server", "output", "resource", "report", "http", "results", "message", "document", "site", "version", "json", "result", "content", "client", "cache", "resp", "connection", "model", "application", "wave", "collection", "out", "body", "page", "object", "reply", "example", "status", "writer", "image", "Response", "respond", "reference", "method", "service", "view"], "path": ["directory", "index", "string", "info", "base", "id", "uri", "output", "resource", "http", "message", "filename", "Path", "location", "key", "pattern", "content", "filter", "cache", "dir", "value", "ath", "config", "data", "text", "route", "out", "object", "p", "format", "name", "folder", "image", "url", "PATH", "method", "point"], "file": ["directory", "zip", "info", "base", "handler", "class", "fe", "resource", "uri", "feed", "lock", "http", "filename", "socket", "fp", "l", "child", "File", "part", "source", "use", "rule", "dir", "up", "lib", "connection", "FILE", "work", "data", "out", "route", "local", "le", "object", "h", "log", "name", "folder", "image", "to", "it", "function", "full", "files", "url", "pe", "b", "f"], "in": ["IN", "pin", "i", "input", "id", "serv", "copy", "resource", "ini", "gin", "con", "c", "socket", "as", "inner", "s", "ins", "bin", "is", "source", "thin", "reader", "binary", "login", "r", "inc", "data", "out", "rin", "init", "ax", "isin", "it", "In", "nin", "kin", "stream", "lin", "b", "ac", "cin", "inn", "f", "win", "din"]}}
{"id1": "841724", "id2": "8815137", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void copyToDir(File dir) {\n        if (!dir.exists()) {\n            dir.mkdirs();\n        } else if (this.file.getParentFile() != null && this.file.getParentFile().equals(dir)) {\n            return;\n        }\n        File file = getEstimatedFileName(dir);\n        try {\n            file.createNewFile();\n            FileOutputStream fileOutputStream = new FileOutputStream(file);\n            FileInputStream fileInputStream = new FileInputStream(this.file);\n            int read = 0;\n            byte[] buffer = new byte[1024];\n            while (read != -1) {\n                fileOutputStream.write(buffer, 0, read);\n                read = fileInputStream.read(buffer);\n            }\n            fileInputStream.close();\n            fileOutputStream.close();\n            this.file = file;\n        } catch (IOException e) {\n            Logger.log(e);\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandrewrites", "readandrewrite", "readAndRebrites", "readandRewrite", "readAndRebrite", "readAndrewrite", "readandRewwrite", "readAndRewrap", "readAndSwrites", "readAndSwwrite", "readAndrewwrite", "readandrewwrite", "readAndRebwrite", "readAndRewrites", "readAndSwrite", "readAndrewrap", "readandRewrap", "readAndrewrites", "readAndRebrap", "readandrewrap", "readAndSwrap", "readandRewrites", "readAndRewwrite"], "inFile": ["InFile", "infile", "oldFile", " inFiles", "inFilename", "oldFiles", "inputFile", " inFilename", " inSourceFile", "outFiles", "loginFiles", "loginfile", "loginFilename", "outfile", "Infile", "inputFilename", "outFilename", "oldfile", "outSourceFile", "InFiles", "oldFilename", "InSourceFile", "inputfile", "loginFile", "inputFiles", "inFiles", "inSourceFile", " infile"], "outFile": ["outFILE", " outfile", "processPlace", " outDir", "thisFilename", "exFILE", "outputPlace", "offFilename", "newfile", "processFilename", "outDir", "thisFILE", "exFilename", "exFile", "newStream", "thisFile", "outputFile", "offFILE", "outStream", "outfile", "outputFILE", " outStream", "outFilename", "offPlace", "thisfile", "newFile", "OutDir", "offFile", "Outfile", "newDir", "processFile", "OutStream", "outputFilename", "OutFile", "processFILE", "outPlace", "outputfile", "exfile"], "iis": ["ciiss", "IIS", "Iis", "iniris", " iais", " iiss", "iniiss", "iais", "ciais", "ciris", "ciIS", "Iiss", " iIS", "iiIs", " iIs", "iiiss", "iiis", "iris", "iiris", "iiIS", " iris", "iIS", "iniIS", "iniIs", "ciIs", "ciis", "iiss", "iniis", "iIs", "Iais"], "dcmParser": ["DcmInstallation", " dcmReader", "dpmPlugin", "dcmPolicy", "dkmHelper", "dbmParser", "dmcarser", "dmissionParser", " dcmparser", "dmoduleParser", "dhemParser", "dcmPlugin", " dcmLoader", "fpmParser", " dcmPolicy", " dcmHelper", "dpmInstallation", " dpmJar", "dcrPlugin", " dcmLanguage", "dCMparser", "dcmLoader", "dcmReader", "dcrParser", "dmissionReader", "dmcParser", "dkmParser", " dcrParser", "dcmparser", "dhemInstallation", "dkmPlugin", " dpmLanguage", "dmmparser", "dmParser", "dpmHandler", "dmissionPlugin", "dcmPar", "dCMReader", "dmoduleJar", "dcrLoader", "dcrJar", "dmmParser", "dbmPolicy", "dmodulePlugin", "dmReader", "dhemJar", " dcrReader", " dpmPar", " dpmPlugin", "fcmHandler", " dcrLoader", "fpmHandler", "dpmarser", "dmLoader", "dpmPolicy", "dbmHelper", "dcrarser", "dpmparser", "dbmPlugin", "dpmLanguage", "fcmReader", "fpmReader", "dcmarser", " dpmparser", " dcmPar", "dmPlugin", " dpmHelper", "dcmHelper", " dpmPolicy", "dmissionLanguage", "dcrPar", "dpmReader", "dCMHandler", "fpmparser", " dpmReader", " dpmarser", "DcmParser", "dpmParser", "dpmPar", "dkmPolicy", "dcmInstallation", "fcmParser", "DcmJar", " dcmJar", "dCMLoader", "fcmparser", "dmmPlugin", "dpmLoader", "dhemReader", "dmoduleReader", "dpmJar", "dCMParser", "dCMPlugin", "DcmReader", "dmcPar", "dmmLoader", "dpmHelper", "dmcJar", " dcmarser", "dcmHandler", " dpmLoader", " dcrPlugin", " dcmPlugin", "dmoduleparser", "dcrReader", "dcmLanguage", "dcmJar", " dpmParser"], "ds": ["ks", "ls", "Db", "ros", "js", "des", "ads", "DS", "ins", "details", "ss", "dr", "cdn", "df", "ps", "rs", "points", "os", "data", "ns", "parts", "sys", "session", "uds", "sync", "dd", "tx", "gd", "vs", "Ds", "amps", "d", "dat", "asi", "ys", "s", "conn", "ws", "is", "drivers", "tes", "src", "pd", "vals", "di", "qs", "db", "Os", "ras", "da", "eps", "ils", "iss", "dds", "icks", "dc", "xs", "ld", "ts", "ays", "nas", "gs", "cs", "utils", "services", "bs", "ants", "dt"], "pdReader": ["ddLoader", "pdLoader", "dsLoader", "pcLoader", "hdStream", "hdLoader", "pcReader", "hdRead", "ddReader", "hdReader", "dsWriter", "hdWriter", "dsreader", "pbRunner", "xdReader", "hdreader", "pdreader", "dsReader", "dsRead", "pdRunner", "pcRead", "ddRunner", "hdRunner", "pbReader", "pdStream", "pcWriter", "pbLoader", "xdRead", "pdRead", "xdWriter", "ddStream", "pbStream", "xdreader"], "out": ["ex", "writer", "default", "flow", "image", "parent", "null", "term", "data", "part", "in", "her", "exp", "o", "password", "conn", "pass", "temp", "cli", "outs", "over", "cache", "exec", "file", "err", "list", "net", "lib", "img", "page", "connection", "dot", "inc", "group", "model", "result", "key", "code", "builder", "point", "object", "w", "down", "layer", "word", "oder", "to", "gen", "url", "io", "outer", "store", "later", "sys", "sync", "Out", "dev", "s", "co", "login", "db", "user", "obj", "up", "device", "order", "diff", "again", "manager", "director", "at", "array", "ssl", "write", "copy", "lock", "child", "session", "external", "output", " in", "with", "client", "inner", "base", "name", "full", "OUT", "auto", "as", "line", "doc", "ext"], "dcmEncParam": ["dcmDecParam", "dcmEstPar", "dcmDecPart", "dcmEnType", "dcmElParameter", "dcmSecParam", "dcmEstParam", "dcmDecPar", "dcmElPar", "dcmDecParameter", "dcmArchParam", "dcmSecPart", "dcmEnParameter", "dcmEncArg", "dcmArchParameter", "dcmEncType", "dcmEnArg", "dcmEstType", "dcmSecType", "dcmEnPar", "dcmEncParameter", "dcmSecPar", "dcmArchArg", "dcmElParam", "dcmEstParameter", "dcmEncPart", "dcmElType", "dcmDecType", "dcmDecArg", "dcmEncPar", "dcmEnPart", "dcmEnParam"], "pdWriter": ["htWriter", "ddReader", "dsOutput", "hdWrite", "hdReader", "hdOutput", "htWriting", "pdWrite", "dsWriter", "ddWrite", "hdWriter", "dsReader", "dsWrite", "PDWriter", "dpWriter", "dpWriting", "PDReader", "PDWrite", "dpReader", "pdWriting", "ddWriter", "pdOutput", "ddOutput", "dpWrite", "htWrite", "htReader", "PDWriting"]}}
{"id1": "9805906", "id2": "22366505", "code1": "    public static boolean dump(File source, File target) {\n        boolean done = false;\n        try {\n            InputStream is = new BufferedInputStream(new FileInputStream(source));\n            OutputStream os = new BufferedOutputStream(new FileOutputStream(target));\n            while (is.available() > 0) {\n                os.write(is.read());\n            }\n            os.flush();\n            os.close();\n            is.close();\n            return true;\n        } catch (IOException e) {\n        }\n        return done;\n    }\n", "code2": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"dump": ["ump", "save", "transfer", "Dir", "zip", "load", "db", "df", " dumps", "export", "out", "ln", " dumping", "files", " dumped", "all", "info", "println", "diff", "update", "flush", "copy", "store", "data", "dir", "download", "f"], "source": ["ource", "slave", "address", "base", "view", "site", "use", "current", "scene", "series", "remote", "input", "start", "core", "string", "s", "stream", "Source", "this", "connection", "parent", "sin", "slice", "ources", "uri", "service", "resource", "iter", "from", "http", "file", "server", "se", "src", "unit", "SOURCE"], "target": ["template", "address", "result", "base", "master", "alias", "arget", "project", "follow", "output", "port", "platform", "force", "replace", "path", "goal", "pointer", "host", "out", "top", "effect", "to", "next", "database", "large", "Target", "connection", "root", "enemy", "null", "object", "parent", "dest", "table", "office", "resource", "it", "file", "src", "settings"], "is": ["us", "im", "ais", "ip", "ins", "ai", "ois", "iso", "isa", "was", "io", "has", "IS", "bis", "ws", "Is", "es", "oss", "abs", "ui", "s", "ris", "ls", "isl", "iss", "ios", "ses", "nis", "or", "bos", "ori", "i", "info", "cs", "ops", "lis", "ps", "isi", "ics", "oses", "opens", "iris", "gets", "obs", "in", "ists", "its", "ens", "as", "bs", "mis"], "os": ["us", "ais", "OS", "osi", "Os", "nos", "outs", "io", "aos", "vs", "boot", "es", "ies", "oss", "ks", "ues", "s", "oes", "ios", "or", "bos", "ori", "i", "oos", "acs", "dos", "cs", "ops", "ose", "o", "ps", "ows", "oses", "ds", "los", "fs", "ols", "its", "ips", "obs", "cos", "oa", "ens", "pos", "ros", "as", "ss", "bs"], "done": ["complete", "foo", "defined", "de", "doing", "odo", "started", "yes", "after", "current", "nice", "progress", "ready", "got", "none", "one", "enabled", "always", "finished", "made", "next", " Done", "dirty", "checked", "confirmed", "running", "gone", "empty", "did", "dad", "future", "disabled", "loaded", " finished", "once", "data", "last", "due", "die", "later", "part", "Done", "expected"]}}
{"id1": "13720140", "id2": "10361370", "code1": "    private void modifyProperty(String valueID, String value, Long userID) throws JspTagException {\n        Property property = new Property(new Long(valueID), userID);\n        String newValue = value;\n        System.out.println(property.getName());\n        if (property.getName().equals(\"Password\")) {\n            try {\n                MessageDigest crypt = MessageDigest.getInstance(\"MD5\");\n                crypt.update(value.getBytes());\n                byte digest[] = crypt.digest();\n                StringBuffer hexString = new StringBuffer();\n                for (int i = 0; i < digest.length; i++) {\n                    hexString.append(hexDigit(digest[i]));\n                }\n                newValue = hexString.toString();\n                crypt.reset();\n            } catch (NoSuchAlgorithmException e) {\n                System.err.println(\"jspShop: Could not get instance of MD5 algorithm. Please fix this!\" + e.getMessage());\n                e.printStackTrace();\n                throw new JspTagException(\"Error crypting password!: \" + e.getMessage());\n            }\n        }\n        property.setValue(newValue);\n    }\n", "code2": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "label": 1, "substitutes": {"modifyProperty": ["modifyproperty", "modateString", "modifiedproperty", "modureProperty", "ModifyAttribute", "modifyString", "modateAttribute", "ModifiedString", "ModifiedAttribute", "modureproperty", "Modifiedproperty", "modureString", "ModifyProperty", "modifiedProperty", "modateProperty", "modifyAttribute", "Modifyproperty", "modifiedAttribute", "modureAttribute", "ModifiedProperty", "modateproperty", "modifiedString", "ModifyString"], "valueID": ["ValueIndex", "ValueID", "propertyid", "ValueId", "propertyIP", "VALUEID", "valueId", "VALUEIndex", "jobId", "jobIP", "contentID", "VALUEid", "valueid", "valueIndex", "ValueIP", "jobid", "Valueid", "valueIP", "jobID", "propertyID", "contentIndex", "contentid", "propertyId"], "value": ["val", "string", "address", "server", "output", "response", "resource", "username", "token", "entry", "message", "description", "document", "result", "number", "key", "pattern", "content", "password", "expression", "Value", "source", "target", "default", "data", "text", "VALUE", "object", "language", "format", "name", "example", "image", "function", "array", "values", "update", "secret", "v", "reference", "command", "padding", "attribute", "phrase", "element", "code"], "userID": [" userId", "userName", "Userid", "authorId", "UserMAC", "authorid", " userMAC", "authorMAC", "userId", "userMAC", " userid", "authorName", " userName", "UserName", "userid", "UserID", "UserId", "authorID"], "property": ["string", "info", "base", "address", "foo", "temp", "resource", "definition", "entry", "option", "message", "profile", "character", "project", "primary", "result", "jo", "key", "password", "expression", "part", "Property", "type", "operation", "connection", "module", "feature", "section", "config", "data", "parent", "tmp", "entity", "variable", "object", "metadata", "p", "prototype", "style", "name", "function", "operator", "prefix", "layer", "position", "update", "this", "pair", "prop", "attribute", "properties", "method", "field", "element", "term"], "newValue": ["nextValue", "currentVal", "newVal", "replaceVal", "oldvalue", "defaultvalue", "currentValue", " newVal", "defaultVALUE", "nextVal", "oldVALUE", " newVALUE", " newvalue", "rawVal", "NewVALUE", "NewVal", "rawVALUE", "defaultValue", "rawValue", "currentvalue", "newString", "replacevalue", "NewValue", "oldVal", "currentVALUE", "nextVALUE", " newString", "nextvalue", "rawString", "replaceVALUE", "oldValue", "defaultVal", "newvalue", "NewString", "replaceValue", "newVALUE"], "crypt": ["ssl", "core", "temp", "cc", "cmp", "copy", "enc", "chip", "con", "c", "python", "hex", "Crypt", "ryption", "prot", "pool", "key", "security", "password", "ec", "comb", "client", "cm", "cp", "mac", "cache", "lib", "binary", "ctr", "ch", "mix", "bec", "conv", "ca", "poly", "utils", " cryptography", "conn", "coll", "chain", "rypt", "cr", "dec", "com", "cook", "auth", "cash", "contract", "coin", "pt", "cmd", "hash", "code"], "digest": ["encress", "Digester", "codress", "designest", " digend", "DigEST", "Diger", "ddest", "signEST", "crist", "signest", "Digress", "signer", "gener", " digist", "digit", "signested", "genested", "crester", "Digoded", "genEST", "cododed", "digester", "ddusher", "digend", "crend", "digested", "Digit", "encester", "crest", "designit", "digress", "Digest", "designester", "digoded", "Digend", "codester", "Digusher", "digusher", "Digist", "diger", "encest", "ddester", "codest", "designusher", "digist", " digester", "genest", "Digested", "encoded", "digEST", "ddit"], "hexString": ["hexBuffer", "cryptArray", "tempSection", "hexArray", "hexSection", "hashStr", "hexstring", "byteBuffer", " hexStr", " hexBuffer", " hexArray", "rexString", "cryptString", " hexSection", "cryptSection", "byteString", "exString", "cryptBuffer", "tempString", "rexBuffer", "hexStr", "hashString", "rexArray", "exBuffer", "tempArray", "exArray", "hashArray", " hexstring", "rexstring", "exstring", "tempBuffer", "byteArray", "byteStr", "hashBuffer"], "i": ["index", "info", "id", "uri", "pi", "mu", "slice", "c", "j", "ri", "o", "l", "s", "si", "ui", "ii", "in", "key", "ti", "d", "phi", "r", "data", "li", "h", "x", "p", "ip", "bi", "u", "init", "oi", "e", "I", "ci", "m", "io", "pos", "it", "xi", "di", "gi", "hi", "k", "v", "b", "abi", "multi", "f", "field", "ix"]}}
{"id1": "17538992", "id2": "530882", "code1": "    public static boolean check(String urlStr) {\n        try {\n            URL url = new URL(urlStr);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            urlConnection.setConnectTimeout(2000);\n            urlConnection.getContent();\n        } catch (Exception e) {\n            logger.error(\"There is no internet connection\", e);\n            return false;\n        }\n        return true;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 0, "substitutes": {"check": ["info", "close", "resource", "checks", "ok", "find", "run", "match", " checking", "checking", "load", "login", " Check", "work", "CHECK", "get", "test", "complete", "start", "exec", " checks", "call", "link", "update", "Check", "process", "checked"], "urlStr": ["httpText", "urlSTR", "URLName", " urlString", "httpName", "URLStr", " urlstr", "httpstr", " urlName", "urlName", "resourceText", "urlString", "httpString", "resourcestr", "URLString", " urlSTR", "urlstr", "httpStr", "urlText", "resourceString", " urlText", "URLSTR", "httpSTR", "resourceStr"], "url": ["impl", "string", "base", "ssl", "address", "server", "resource", "uri", "feed", "user", "http", "c", "l", "host", "URL", "client", "connection", "browser", "str", "r", "build", "open", "config", "data", "channel", "page", "object", "ll", "web", "log", "conn", "ls", " URL", "image", "blog", "sl", "layer", "Url", "www", "b", "obj", "f"], "urlConnection": [" urlC", "Urlconnection", "URLContainer", "httpconnection", "newConnection", "urlSocket", "urlC", "httpconn", "httpConnection", " urlConfig", "UrlConfig", " urlconnection", "URLUrl", "httpContainer", "sslconnection", " urlSocket", "newUrl", "UrlConnection", "urlUrl", "URLConnection", " urlconn", "urlContainer", "httpC", "urlconnection", "URLconnection", "httpSocket", "sslconn", "urlConfig", "newContainer", "UrlSocket", "newconnection", "httpUrl", "sslConnection", "urlconn", "httpConfig", "sslC"]}}
{"id1": "11840277", "id2": "2168610", "code1": "    protected static void clearTables() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"delete from Objects\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (1, 'Money value')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (2, 'Date')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (3, 'Unix path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (4, 'Dos path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (5, 'Time')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (6, 'IP address')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (7, 'Internet hostname')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (8, 'Number')\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Contact contact = (Contact) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_CONTACT\"));\n            pst.setString(1, contact.getName());\n            pst.setString(2, contact.getFirstname());\n            pst.setString(3, contact.getPhone());\n            pst.setString(4, contact.getEmail());\n            if (contact.getAccount() == 0) {\n                pst.setNull(5, java.sql.Types.INTEGER);\n            } else {\n                pst.setInt(5, contact.getAccount());\n            }\n            pst.setBoolean(6, contact.isArchived());\n            pst.setInt(7, contact.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "label": 1, "substitutes": {"clearTables": ["clearContows", "cacheTableations", "clearContaches", "clearStaces", "clearTemings", "clearTows", "clearTableows", "clearContaces", "clearStables", "clearStaches", "cacheTations", "cacheTableables", "cacheTables", "clearTemations", "cacheTings", "createTables", "clearTemables", "clearContables", "clearBows", "createTaches", "clearTings", "clearTemows", "createStaces", "clearBings", "clearBables", "clearBations", "createTows", "clearTations", "clearStows", "clearBaches", "clearTaches", "cacheTows", "cacheTableows", "clearBaces", "clearTableations", "clearTableings", "clearTaces", "createStables", "createTaces", "clearTableables", "createStows", "cacheTableings", "createStaches"], "conn": ["sth", "bb", "log", "ct", "ssl", "cn", "col", "server", "Connect", "conf", "n", "connection", "loc", "cp", "act", "pg", "cmp", "lock", "rc", "ns", "org", "session", "sql", "jc", "oss", "Connection", "cond", "connect", "mc", "nt", "coll", "ch", "nc", "ci", "h", "wd", "cb", "Conn", "cc", "error", "cat", "cm", "oci", "config", "client", "co", "di", "db", "ann", "cache", "ac", "exec", "con", "c", "obj", "dc", "dn", "ob", "ou", "ctx", "ai", "pub", "path", "mt", "cf", "state", "lc", "ca", "close", "enc", "p", "open"], "stmt": ["strMT", "stnt", "actmn", "emt", " stmn", "tm", " str", " stbm", "stprint", " stager", "ctm", " stgr", "Stmi", "ssmn", "dm", "playtx", "actnt", "tct", "stbm", "stmc", "stql", "estmt", "stmn", "Stmd", "ftmt", " stlt", "putlt", "STmc", "puttor", "stager", "ftlt", "ldager", "est", "Stmc", "ctgr", "ctql", "ftbm", "dr", "stswd", "ctmt", "stap", " stma", "stsmt", "STmt", "stwd", "ssmt", "actmi", "ftmn", "Stmn", "playtor", "STprint", "stct", "STmn", "stwt", "stmm", "StMT", "STlt", "putma", "estmm", "putager", " stmi", "stlt", "stgr", "STMT", "putwt", " stmc", "eprint", " stql", "putmn", "ewd", " stct", "Stlt", "Stm", " stm", "strlt", "istmt", "strml", "STmd", "putmt", "playwt", "putm", "Stgr", "strmt", "ssbm", " stwt", "stmd", "str", "Stct", "dmt", "STst", "putMT", "stst", "tmt", "istgr", "ldma", "stMT", "playmt", "ctr", " stmd", "Stnt", "stmi", " stap", "stml", "ldmt", "Sttor", "sttx", " stnt", "puttx", "Stwt", "dql", "STgr", "stsst", "putap", "actmt", "tnt", "istmn", "Stml", "Stap", "ldmn", "putmm", "sswt", "sttor", "putml", "estwt", "STbm", "STwd", "putbm", "stsprint", " stml", "Stmt", "ctmd", "Sttx", "stma", "estm", "Stmm", "stm", "istMT"]}}
{"id1": "8047989", "id2": "12172485", "code1": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"getHashedID": ["getHashingID", "getHachedId", "getHashingUID", "getHashUID", "getShashedIP", "getShashedID", "getHachedID", "getHashingId", "getShashIP", "getShashedUID", "getShashUID", "getHashID", "getHashId", "getShashedId", "getHashedId", "getHachedUID", "getHachedIP", "getHashIP", "getHashedIP", "getHashedUID", "getHashingIP", "getShashID", "getShashId"], "ID": ["JSON", "Id", "Address", "Path", "DB", "IR", "DATA", "IDS", "NAME", "hash", "UID", "VERSION", "IDs", "Name", "INFO", "AD", "STR", "IN", "ENT", "RI", "TEXT", "INT", "name", "SHA", "Hash", "code", "URL", "ED", "Code", "string", "MAC", "prefix", "GET", "API", "MD", "EXT", "URI", "id", "KEY", "IP"], "md5": ["sha2", "sha7", "md4", "md2", "sha4", "id512", "id8", "MD4", "cmd25", "MD8", "md512", " md7", "md8", "sha512", "md7", "sha5", " md2", "MD2", " md25", "cmd512", "MD5", "cmd5", "sha25", "id2", "MD512", "md25", " md4", "cmd7", "id5", " md8", " md512", "MD7"], "digest": ["Digpe", "mdHash", "codse", "digace", "Digester", "Digests", "signace", "mdested", "codpe", "mdse", "longse", "digested", " digests", "mdester", " digse", "mdace", "DigHash", "codests", "digHash", "signested", " digpe", "digests", "Digse", "signester", "Digest", "longests", "longHash", "Digested", "mdest", "digester", "Digace", "digpe", "longest", "signest", "codest", "mdests", "digse"], "bytes": ["ls", "parts", "Bytes", "ps", "units", "words", "lines", "out", "bits", "ips", "keys", "bb", "its", "seconds", "devices", "issues", "services", "ones", "data", "errors", "strings", "proxy", "binary", "vs", "cells", "values", "pieces", "letters", "base", "objects", "files", "is", "zip", "bs", "address", "body", "string", "pages", "codes", "details", "outs", "es", "results", "tes", "items", "maps", "classes", "id", "blocks", "ids", "rows", "content"], "i": ["p", "x", "uri", "z", "field", "c", "inner", "f", "ai", "s", "ii", "info", "gi", "e", "l", "I", "k", "pos", "ci", "val", "uli", "abi", "m", "in", "multi", "n", "bi", "io", "si", "u", "b", "ti", "it", "ui", "pi", "oi", "index", "li", "h", "j", "hi", "di", "qi", "xi", "fi", "r", "t", "mu", "slice", "id", "o", "end", "type", "v", "ri", "d", "phi"]}}
{"id1": "18696387", "id2": "14733078", "code1": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 0, "substitutes": {"input": ["image", "index", "raw", "temp", "prefix", "inner", "current", "inf", "form", "format", "audio", "Input", "version", "text", "table", "string", "initial", "buffer", "path", "first", "context", "xml", "name", "request", "host", "data", "file", "down", "include", "id", "instance", "reader", "default", "connection", "config", "source", "url", "address"], "output": ["writing", "image", "letter", "model", "temp", "outer", "office", "prefix", "done", "self", "current", "point", "write", "target", "version", "filename", "remote", "environment", "string", "application", "display", "exit", "position", "external", "job", "result", "response", "secret", "name", "operation", "Output", "file", "reference", "error", "connection", "config", "source", "web", "url", "address"], "fis": [" fIS", "ofos", "bIS", "bos", "fic", "ofic", "ofIS", "Fic", " fiss", "Fos", "Fis", "fIS", " fic", "bis", "Fiss", "fiss", "biss", "FIS", "ofis"], "in": ["ini", "err", "login", "o", "this", "inner", "inn", "In", "inc", "bin", "url", "read", "pin", "IN", "r", "again", "source", "nin", "io", "cin", "pull", "client", "ins", "is", "init", "con", "isin", "rin", "id", "ex", "reader", "win", "i", "vin", "din", "f", "socket", "lin", "s"], "fos": ["foid", "fo", "fdis", "fdo", " fops", "afis", "fdos", "afos", "info", "infos", "afo", "afoid", "fdoid", "foser", "Foser", "infoser", "infops", "Fos", "Fis", " foser", "infoid", "infis", "fops", "Fops"], "out": ["err", "flow", "log", "o", "temp", "outer", "inner", "debug", "to", "w", "write", "plain", "cli", "net", "up", "cache", "OUT", "list", "writer", "bin", "conn", "b", "key", "print", "class", "exit", "IN", "state", "again", "outs", "work", "part", "line", "io", "Out", "off", "socket", "name", "init", "ext", "report", "sys", "data", "file", "user", "parent", "lock", "error", "ex", "i", "reader", "one", "n", "println", "comment", "console", "inc", "exec", "f", "obj", "copy", "s"], "len": ["num", "base", "nt", "end", "inn", "val", "lf", "cl", "lan", "rev", "lon", "l", "bin", "conn", "pos", "split", "li", "fl", "en", "line", "part", "Len", "lim", "all", "le", "length", "size", "start", "off", "la", "ln", "id", "limit", "el", "n", "fin", "f", "lin"], "buf": ["num", "wb", "pool", "conv", "base", " buffer", " buffers", "vec", "ff", "cur", "feat", "text", "src", "queue", "bag", "uf", "bytes", "cb", "b", "bh", "cap", "pos", "buff", " bu", "border", "buffer", "fd", "Buffer", "fb", "bd", "grab", " cmd", "cas", " buff", "off", "la", "ucc", "map", "auc", "loc", "data", "cv", "rb", "uc", "seq", "batch", "br", "ctx", " data", "bc"], "numRead": ["numberWrite", "noRead", " numWrite", " numread", "NumLength", " numLength", "umReader", "NumReader", "noReader", "noread", "noWrite", "NumUse", "numread", "numberRead", "umRead", "umLength", " numReader", "numReader", "numUse", "umWrite", "numberread", "numLength", "Numread", "numWrite", "NumWrite", "numberUse", "NumRead", " numUse"]}}
{"id1": "1798720", "id2": "15645004", "code1": "    public static void save(String packageName, ArrayList<byte[]> fileContents, ArrayList<String> fileNames) throws Exception {\n        String dirBase = Util.JAVA_DIR + File.separator + packageName;\n        File packageDir = new File(dirBase);\n        if (!packageDir.exists()) {\n            boolean created = packageDir.mkdir();\n            if (!created) {\n                File currentPath = new File(\".\");\n                throw new Exception(\"Directory \" + packageName + \" could not be created. Current directory: \" + currentPath.getAbsolutePath());\n            }\n        }\n        for (int i = 0; i < fileContents.size(); i++) {\n            File file = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(fileContents.get(i));\n            fos.flush();\n            fos.close();\n        }\n        for (int i = 0; i < fileNames.size(); i++) {\n            File fileSrc = new File(Util.JAVA_DIR + File.separator + fileNames.get(i));\n            File fileDst = new File(dirBase + File.separator + fileNames.get(i));\n            BufferedReader reader = new BufferedReader(new FileReader(fileSrc));\n            BufferedWriter writer = new BufferedWriter(new FileWriter(fileDst));\n            writer.append(\"package \" + packageName + \";\\n\");\n            String line = \"\";\n            while ((line = reader.readLine()) != null) writer.append(line + \"\\n\");\n            writer.flush();\n            writer.close();\n            reader.close();\n        }\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"save": ["change", "apply", "transfer", "load", "make", "archive", "setup", "upload", "build", "release", "report", "transform", "Save", "install", "update", "pack", "copy", "store", "data", "process", "move", "stage", "saving", "create", "dump", "open", "clone"], "packageName": ["modulePath", " packagePart", "moduleName", "sourcename", "pluginName", "moduleInfo", "directoryPath", " packagePath", "packagePart", " packagename", "sourceName", "packageInfo", "packagename", "directoryname", "sourcePath", "directoryName", " packageNames", "PackagePath", "PackageName", "directoryInfo", "packageNames", "directoryDir", "directoryPart", "pluginDir", "pluginPart", "PackageDir", "directoryNames", "pluginPath", "packagePath", " packageInfo", "moduleDir", "PackageNames", "sourceDir", "PackageInfo"], "fileContents": ["getContents", "getNames", "FileContent", "imageNames", " fileHours", "imageParts", " fileContent", "ileContents", "fileSources", " fileTextures", "FileContents", "ileNames", "fileContent", "ileTextures", " fileSources", "imageContents", "FileSources", "fileParts", "fileHours", "imageHours", "fileTextures", "FileTextures", "ileSources", "FileNames", "FileHours", "getParts", "getContent", "FileParts", " fileParts"], "fileNames": ["fileTypes", "FileTypes", "fNumbers", "pagenames", "viewTypes", "pageNames", "filenames", "playName", "FileName", "fullContents", "FileContents", "fTypes", "pageTypes", "playContents", "logNames", " fileName", "fName", "logName", "fullNames", "fNames", " filenames", "logTypes", "fullTypes", "fullName", "logContents", "viewnames", "FileNames", "viewNames", "playNames", " fileTypes", "fileNumbers", "fileName", "FileNumbers", " fileNumbers"], "dirBase": ["directoryBased", "packageRoot", "folderBase", "directoryBase", "DirDir", "modulebase", " dirbase", "Dirbase", "dirRoot", "DirKit", " dirRoot", "dirBased", "directoryKit", "moduleBased", "packageBase", " dirPath", "directorybase", "dirbase", "dirDir", "dirPath", "packagebase", "DirBase", "directoryDir", "folderBased", "DirRoot", "moduleKit", "folderbase", "DirPath", "packagePath", "moduleDir", "folderDir", "dirKit", "moduleBase"], "packageDir": ["modulePath", "folderBase", "directoryFolder", " packagePath", "directoryPath", "directoryUrl", "PackageDirectory", "folderPath", "packageDirectory", "packageFolder", "parentFile", "directoryFile", "parentDir", "packageBase", "PackageFile", "PackagePath", "directoryDirectory", " packageBase", "directoryDir", "packageUrl", " packageUrl", "PackageDir", " packageFile", "packagePath", "packageLib", " packageFolder", "folderLib", "moduleDir", "moduleLib", "parentUrl", " packageDirectory", "folderDir", "parentFolder", "packageFile", " packageLib", "moduleBase"], "created": ["result", "controlled", "edited", "required", "established", "needed", "formed", "updated", "left", "found", "activated", "path", "creator", "paid", "Created", "true", "released", "creation", " Created", "made", "aaaa", "generated", "failed", "added", "confirmed", "used", "null", "icated", "produced", "existent", "loaded", "raised", "founded", "owned", " existed", "create", "were", "successful", "worked", "authorized", "called", "ed"], "currentPath": ["newPath", "CurrentDirectory", "newpath", "currentLocation", "CurrentPath", "currentPage", "newLocation", "CurrentRoot", " currentLocation", "CurrentPage", " currentRoot", "currentlypath", "Currentpath", "currentlyDirectory", " currentPage", "currentDirectory", "currentRoot", "currentlyPath", " currentpath", "currentlyPage", "newRoot", "CurrentLocation", " currentDirectory", "currentpath"], "i": ["qi", "v", "z", "k", "ip", "ai", "ti", "I", "e", "id", "io", "current", "iu", "xi", "x", "ini", "index", "eni", "start", "name", "ui", "li", "u", "hi", "inner", "s", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "j", "ie", "info", "ori", "b", "n", "bi", "zi", "slice", "isi", "ri", "uri", "p", "gi", "ix", "it", "h", "fi", "key", "di", "oi", "me", "init", "d", "yi", "ji", "part", "mu", "f", "pi"], "file": ["fp", "base", "place", "feed", "io", "child", "path", "folder", "log", "filename", "out", "name", "s", "play", "ile", "files", "fe", "or", "File", "pe", "b", "rule", "per", "il", "ul", "uri", "resource", "http", "l", "source", "work", "up", "dir", "entry", "letter", "data", "full", "unit", "book", "f", "le"], "fos": ["foes", "ufos", " fosh", "Fou", "vops", "flou", "flis", " fis", "voes", "fou", "flops", " fob", "Fops", "Fosh", "Fos", "ofosh", "Fis", "ofos", " fo", "flosh", "cfob", " fops", "ufob", "fios", "Foes", "Fios", "fosh", "vios", "ufoes", "ufo", "fis", "cfo", " fios", "vos", "ofou", "fo", "cfoes", "cfos", "fops", "flos", " foes", "ofops", "fob"], "fileSrc": ["fileDrs", "fileDrec", "fileSsrc", "fileSrec", "fileAsrec", "FileSrc", "fileAsource", "fileNRC", " fileSrs", "fileDrc", "fileSrs", "fileAsRC", " fileDRC", "fileAssrc", " fileSsrc", "FileSource", "FileDRC", "fileSource", "FileDrec", " fileDsrc", " fileDrs", "fileAsrc", "fileSRC", "fileAsrs", "FileSRC", "fileNrs", "fileDource", " fileSRC", "fileNsrc", "fileDRC", "fileNrc", "FileDrc", "FileSrec", "FileDource", " fileDrc", "fileDsrc"], "fileDst": ["fileDsc", "FileSsc", "FileFst", "fileSsrc", "fileEnsc", "FileSrc", "fileSst", "fileFST", "fileDrc", "fileEnST", "fileNsc", "FileDST", "FileDsc", "fileSST", "fileFst", "FileFST", "fileDaysc", "fileDayrc", "FileDst", "fileFrc", "FileFsc", "fileDST", "fileNst", "FileFrc", "fileNsrc", "fileNrc", "FileDrc", "FileSst", "fileEnrc", "FileDsrc", "FileSsrc", "fileSsc", "fileFsc", "fileDayst", "fileDaysrc", "fileEnst", "fileDsrc"], "reader": ["audio", "builder", "re", "e", "right", "io", "rr", "worker", "rer", "ler", "row", "er", "stream", "driver", "inner", "editor", "read", "Reader", "keeper", "or", "layer", "r", "report", "rx", "handler", "oder", "per", "loader", "ner", "ri", "parser", "iter", "buffer", "rc", "data", "entry", "ro", "ry", "server", "rar", "director", "reading", "book", "author"], "writer": ["ger", "wa", "written", "wire", "master", "maker", "writ", "builder", "w", "output", "e", "war", "worker", "ws", "ler", "er", "out", "inner", "driver", "word", "write", "rw", "widget", "wr", "editor", "words", "element", "Writer", "riter", "r", "connection", "player", "o", "with", "handler", "per", "walker", "socket", "loader", "outer", "parser", "buffer", "message", "office", "wrapper", "key", "document", "writers", "data", "entry", "server", "width", "sheet", "work", "value", "later", "book", "author", "writing"], "line": ["url", "lc", "header", "error", "column", "job", "str", "id", "feed", "model", "log", "le", "ge", "row", "string", "name", "end", "Line", "response", "lines", "word", "cr", "write", "link", "character", "code", "LINE", "look", "type", "connection", "definition", "text", "object", "rule", "block", "sync", "cle", "message", "buffer", "key", "jo", "lf", "page", "data", "lin", "entry", "source", "l", "letter", "char", "style", "inline", "pass", "part", "unit", "comment", "item", "cell", "stroke"]}}
{"id1": "7843322", "id2": "3184073", "code1": "    public void run(IAction action) {\n        int style = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell().getStyle();\n        Shell shell = new Shell((style & SWT.MIRRORED) != 0 ? SWT.RIGHT_TO_LEFT : SWT.NONE);\n        GraphicalViewer viewer = new ScrollingGraphicalViewer();\n        viewer.createControl(shell);\n        viewer.setEditDomain(new DefaultEditDomain(null));\n        viewer.setRootEditPart(new ScalableFreeformRootEditPart());\n        viewer.setEditPartFactory(new TableEditPartFactory());\n        viewer.setContents(getContents());\n        viewer.flush();\n        int printMode = new PrintModeDialog(shell).open();\n        if (printMode == -1) return;\n        PrintDialog dialog = new PrintDialog(shell, SWT.NULL);\n        PrinterData data = dialog.open();\n        if (data != null) {\n            PrintGraphicalViewerOperation op = new PrintGraphicalViewerOperation(new Printer(data), viewer);\n            op.setPrintMode(printMode);\n            op.run(selectedFile.getName());\n        }\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 0, "substitutes": {"run": ["play", "index", "execute", "input", "output", "register", "report", "save", "render", "task", "read", "form", "loop", "select", "use", "load", "running", "show", "build", "work", "config", "launch", "submit", "test", "start", "plot", "exec", "image", "apply", "runner", "call", "app", "update", "Run", "process", "view"], "action": ["ctions", " fn", "act", " c", "ction", " ACTION", "next", "ACTION", " activity", " flow", " f", " result", " act", " Action", " step", " app", " module", " actions", "controller", "it", " controller", "actions", "ctx", "app", "Action", "state", " input", "tx"], "style": ["letter", "info", "css", "profile", "phase", "py", "mode", "styles", "length", "layout", "pattern", "color", "offset", "sty", "like", "type", "rule", "dot", "value", "config", "level", "Style", "file", "background", "size", "inline", "format", "template", "image", "estyle", "normal", "theme", "role", "position", "sh", "shape", "shadow", "print", "state", "script", "element"], "shell": ["hell", "roll", "sel", "buffer", "console", "skin", "server", "sole", "lock", "system", "mode", "o", "window", "child", "l", "pty", "si", "layout", "ui", "clone", "loop", "session", "scroll", "sb", "live", " Shell", "math", "body", "cl", "nl", "ll", "widget", "log", "null", "control", "search", "cel", "lex", "Shell", "sl", "sym", "sql", "sh", "kel", "wrapper", "tty", "xml", "help", "ol", "gui", "cli", "tool"], "viewer": ["looker", "footerver", "lookener", "showoser", "viewar", "Vieworer", "presentaer", "Viewers", "Viewener", "viewter", "Viewter", "lookers", "viewester", "viewsers", "Viewr", " viewaer", "viewsed", "Viewerver", "displayer", "viewerver", "viewitter", "viewaer", "viewser", "lookier", "scaner", "looke", "displayier", "Viewier", "viewsr", " viewener", "Viewar", " viewerver", " vieworer", "Viewner", "footers", "viewER", " viewe", "reviewed", "Viewed", "Viewitter", "presentester", "footorer", "reviewter", " viewER", "presenter", " viewester", " viewitter", "reviewe", "showester", " viewter", " viewier", "Viewer", "reviewer", "lookER", "vieworer", " viewed", "presentoser", "viewoser", "displayner", "displayitter", " viewar", "Viewe", "viewier", "viewers", "scanener", "showaer", " viewr", "shower", " viewner", "viewe", "scanar", "viewed", "viewr", "viewener", "footer", " viewers", "scanner", "ViewER", " viewoser", "viewner"], "printMode": ["PrintRole", "printmode", "patchStyle", " printSize", "logMODE", "PrintMode", "viewMode", "writemode", "writeMODE", "printRole", "printSize", " printMODE", "PrintMODE", "patchMODE", "writeMode", "logMode", "patchmode", "viewSize", "writeRole", " printRole", "printMODE", "patchMode", "logmode", "logStyle", " printStyle", " printmode", "printStyle", "PrintSize", "Printmode"], "dialog": ["demDialog", "slog", "protink", "collOG", "dialoder", "demoder", "Dialoder", "dialOG", "protog", "logogo", "logdr", "DialDialog", "Dialog", "dialogo", "collDialog", "logink", "sldr", "protogo", "demOG", "dialdr", "dialDialog", "collog", "logog", "slink", "protdr", "DialOG", "slogo", "colloder", "demog", "dialink"], "data": ["where", "info", "buffer", "loader", "handler", "input", "output", "response", "resource", "entry", "map", "json", "oper", "inner", "result", "o", "layout", "done", "ui", "next", "raw", "form", "part", "reader", "up", "ops", "operation", "media", "model", "value", "parser", "text", "body", "page", "object", "p", "format", "or", "plugin", "po", "frame", "image", "writer", "to", "area", "di", "a", "processor", "da", "obj", "state", "pad", "dat", "error", "api", "view", "valid"], "op": ["opl", "job", "opa", "oper", "opp", "o", "set", "co", "orb", "dr", "OP", "oop", "post", "comp", "cop", "ap", "proc", "pp", "operation", "ops", "up", "mp", "oc", "ob", "open", " operation", "ip", "object", "p", "init", "or", "hop", "po", "opus", "exp", "pop", "opt", "operator", "Op", "jp", "it", "app", "top", "sp", "obj", "and", "opy", "auto"]}}
{"id1": "771802", "id2": "1188100", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    public void test() throws Exception {\n        StorageStringWriter s = new StorageStringWriter(2048, \"UTF-8\");\n        s.addText(\"Test\");\n        try {\n            s.getOutputStream();\n            fail(\"Should throw IOException as method not supported.\");\n        } catch (IOException e) {\n        }\n        s.getWriter().write(\"ing is important\");\n        s.close(ResponseStateOk.getInstance());\n        assertEquals(\"Testing is important\", s.getText());\n        InputStream input = s.getInputStream();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(input, writer, \"UTF-8\");\n        assertEquals(\"Testing is important\", writer.toString());\n        try {\n            s.getWriter();\n            fail(\"Should throw IOException as storage is closed.\");\n        } catch (IOException e) {\n        }\n    }\n", "label": 1, "substitutes": {"createOutputStream": ["createOutputSteam", " createOutputSteam", " createInputSteam", " createIOSteam", " createByteFile", " createInputFile", "createOutputFile", "createInputReader", " createByteSteam", " createInputReader", " createByteStream", " createInputStream", "createInputFile", "createInputStream", " createIOFile", " createIOReader", " createByteReader", " createOutputFile", " createIOStream", "createOutputReader", " createOutputReader", "createInputSteam"], "inFile": ["incFiles", "infile", "insFile", "insfile", "inputFile", "inStream", "outFiles", "insFiles", "insStream", "incfile", "sourceFile", "outStream", "outfile", "sourcefile", "inputStream", "inputfile", "incStream", "incFile", "sourceFiles", "inputFiles", "inFiles", "sourceStream"], "outFile": [" outfile", "infile", "outTime", "workTime", "inputFile", "inTime", "workingStream", "workFile", "outDir", "targetStream", "workfile", "workingDirectory", "workingfile", "outStream", "outfile", "inDir", " outStream", "targetfile", "outDirectory", "targetFile", "workDir", "inputDir", "workingFile", "targetDirectory", "inputTime", "inputfile", " outDirectory"], "k_blockSize": ["k_byteCode", "k_byteLength", "k_lockCode", "k_lockLen", "k_bitCount", "k_BlockLength", "k_lockLength", "k_blockCode", "k_blockLen", "k_BlockSize", "k_BlockCount", "k_lineCount", "k_lockCount", "k_lineInfo", "k_lockSize", "k_blocksLen", "k_blocksSize", "k_blocksCount", "k_blockInfo", "k_lineSize", "k_blocksLength", "k_BlockCode", "k_byteLen", "k_byteSize", "k_blockCount", "k_blockLength", "k_byteInfo", "k_bitInfo", "k_byteCount", "k_bitSize"], "byteCount": ["ByteSum", " bytecount", "characterLength", " byteSize", "blockSize", " byteLen", "Bytecount", "characterLen", "ByteSize", "ByteLen", "flushcount", "flushCount", "byteSum", " byteSum", "ByteCount", "blockSum", "flushSize", "byteLen", "blockCount", "characterCount", "ByteLength", "flushLength", "byteLength", " byteLength", "blockLength", "bytecount", "characterSize", "byteSize"], "buf": ["fd", "border", "font", "cap", "cv", "uf", "append", "background", "b", "cmd", "loc", "rc", "fb", "data", "bh", "Buffer", "result", "bag", "rb", "batch", "feed", "bytes", "Buff", "cb", "cas", "alloc", "bf", "flush", "src", "config", "tmp", "buff", "len", "base", "queue", "la", "ucc", "vec", "brace", "ctx", "buffer", "exc", "seq", "feat", "img"], "ofp": ["Ofc", "afp", "OFl", "ofc", "fortp", "ofl", "forc", "afc", "fort", "ofnp", "afnp", "OFnp", "Oftp", "OFt", "Ofnp", "afl", "OFtp", "OFp", "OFc", "oft", "Ofl", "forp", "Ofp", "oftp", "Oft"], "zos": ["rons", "ogl", "kos", "core", "zh", "tz", "osi", "iframe", "owicz", "zag", "zers", "rez", "outs", "los", "gz", "zer", "bitcoin", "dylib", "webkit", "zon", "utils", "bs", "ros", "js", "z", "fits", "iffs", "obs", "ossus", "enos", "ozo", "zona", "zip", "bos", "zes", "oses", "zik", "lol", "bes", "zar", "zb", "ZI", "zx", "oda", "zy", "ops", "zi", "budget", "inos", "css", "ls", "zyk", "modules", "zo", "zen", "ses", "nox", "zig", "cfg", "ZA", "os", "jas", "uz", "zn", "nz", "cos", "robe", "liquid", "lins", "zin", "ws", "oS", "abi", "zl", "hz", "za", "forge", "packs", "obb", "soon"], "osw": ["ossnow", "isy", "osy", "esfw", "issw", "lsx", "eshell", "osws", "osow", "osswd", "oswd", "ishell", "lswo", " osfw", "iswd", "isw", "osshell", "osx", "lsws", "osnow", "osfw", "ossw", "isnow", "esw", " osww", "esd", "bx", "ossfw", "bws", "osww", "bwo", "ossd", "ossy", "oswo", "esow", " osow", "oshell", "isd", "bsws", "ossow", "osssw", "essw", "esww", "eswd", "esy", "osd", "bsx", "bsw", "bswo", "ossww", "esnow", "lsw"], "bw": ["bbz", "lbw", " bwa", "lx", "ebW", "fr", "fbW", "bz", "fsw", "lbz", "bwe", "ebwd", " bws", "bW", "ebw", "fbwe", "Bws", "bbwa", "Bw", "lbwa", "bew", "abw", "bbew", " baw", "abW", "Bwa", "bbwu", "lbsw", "ow", "fwa", "bwh", "fbw", "owa", " bwh", "abwe", "ebwe", "bx", "lbx", "bws", "fbwd", "Bew", "fx", " bew", "fw", "lbwh", "bwu", "owu", "fwh", "baw", "lwa", "bbws", "abwd", "bwa", "bbwh", "lbws", " bwu", "lw", "bwd", "bsw", "oaw", "lbr", "bbw", "bbaw", " bz", "lsw"], "zot": ["Zor", "zor", "jot", "Ziot", "zori", " zor", "azita", "azott", "zeros", "aziot", "ziot", "Zit", "jos", "jit", "zerott", "jori", "azor", "zerita", " zori", "zita", "zerori", "zott", "zerit", "Zita", "zerot", "azit", "Zot", "Zott", " ziot", "azot"], "ifp": ["Iff", "ifb", " ifi", "ipb", "IFb", "Ifi", " ifl", "ipp", "Ifc", " ifb", "ifl", "ipc", "ipl", "ifc", "ifi", "iff", "IFc", "IFl", " ifc", " iff", "IFi", "Ifp", "IFp", "IFf"], "zis": ["jits", "zisi", "jisi", "zIS", "zib", "xits", "zipis", "xais", "xit", " zits", "ziss", "xis", "zipits", "zenis", "zenib", "zeip", "zipip", "zipiss", "xisi", "zip", "Ziss", "zeits", "Zis", "jit", "xIS", "zeis", " zisi", "zits", "zenIS", "Zip", " zais", " zIS", "zais", "Zits", "zenais", " zib", "jis", "zeiss", "xib"], "isr": ["IScr", "irrb", "irrc", "irr", "ISr", "rispr", " issr", "ISsr", "risr", "ISrs", "risrc", "issrs", " isrs", "iscr", "ISrb", "risrb", "isrs", "irpr", " iscr", "ISrc", "isrb", "ISpr", "isssr", "isscr", "ispr", "issr", "isrc"], "br": ["kr", "obl", "bsp", "bro", "fr", "arr", "shr", "b", "body", "mr", "rs", "yr", "bh", "bp", "bc", "obi", "str", "HR", "cro", "rb", "ch", " BR", " Br", "BR", "rib", "lr", "ber", "bar", "tr", "r", "ctr", "div", "err", "ocr", " fr", " dr", "sr", "ibl", "gr", "ob", "sp", "hr", "bl", "Br", "ibr", "img", "browser"], "zit": ["jits", "zipita", "zIT", "zeith", "zenith", " zip", "xit", "zenitter", " zits", "zipits", "zitter", "jith", "jite", "xith", "jIT", "zipip", "zic", "zip", "xic", "zeits", " zi", "zipit", " zith", "jit", "zite", "jic", "zipith", "zenit", "zith", "ji", "zits", " zic", "zipite", "zeit", "zita", "zenits", "xi", "jita", " zite", "zipitter", "jip", "zi", "zeIT", "zipIT", "zeitter", "zeita"]}}
{"id1": "14783950", "id2": "18696387", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressUsingJar", "compressUsingZip", "compressInZip", "compresswithZip", "compresswithSax", "compressedWithJar", "compressInSax", "compressedWithZip", "compressWithJar", "compressUsingSax", "compresswithJar", "compressInJar", "compressedWithSax", "compressedUsingJar", "compressedUsingZip", "compressedUsingSax", "compressWithSax"], "fileList": [" fileChain", "wordString", "FileStream", "zipSet", "FileString", "fileStream", "modelCollection", "wordName", "inputEx", "modelEx", "fileCollection", "FileSet", "fileString", "modelList", "wordStream", "modelStream", "FileList", "inputCollection", "fileEx", "FileChain", "filelist", " fileSet", "zipList", "inputList", "inputStream", "wordList", "ziplist", "fileChain", "stringName", " fileEx", "stringlist", " fileStream", "Filelist", " fileCollection", " fileString", "FileName", "stringList", "stringChain", "zipName", "fileSet", " filelist"], "zipFileName": ["folderGlobalPath", "archiveDirDir", "zipFullname", "zipDirname", "zipFileDir", "archiveDirPath", "zipGlobalNames", "zipFullPath", "folderGlobalname", "zipFilename", "archiveFileName", "archiveFilePath", "zipDirDir", "zipPackagePath", "zipFullName", "zipFileNames", "archiveDirName", "folderFileNames", "zipGlobalPath", "folderFileName", "zipFullDir", "zipPackageName", "zipPackageDir", "folderGlobalName", "zipDirNames", "zipDirName", "archiveFileDir", "zipFullNames", "zipGlobalName", "zipDirPath", "zipFilePath", "folderFilename", "folderFilePath", "zipGlobalname", "folderGlobalNames"], "fos": ["Fosh", "infoS", "Fos", "flos", "faos", "infos", "fosh", "infaos", "afoS", "foS", "flis", "Faos", "FoS", " fosh", "afaos", "infis", "flosh", "afis", "afos", "Fis"], "zos": ["css", "zz", "ros", "dos", "closure", "z", "fits", "kos", "tz", "fi", "ZA", "os", "jas", "jobs", "ozo", "osi", "uz", "iframe", "nz", "cos", "loop", "zip", "es", "bis", "bos", "lins", "bag", "chini", "zes", "oses", "zzy", "seconds", "abi", "zik", "lol", "bes", "zar", "zag", "zo", "zers", "zen", "LOS", "outs", "zl", "rez", "ses", "onz", "zb", "ZI", "packs", "gz", "zx", "zer", "zy", "webkit", "obb", "zi", "phi", "zon", "zan", "spin", "budget", "inos"], "iter": ["enter", "inse", "fr", "e", "itter", "ser", "loc", "outer", "oper", "ner", "inc", "ie", "it", "f", "set", "index", "upper", "finder", "sort", "coll", "end", "test", "ener", "el", "gener", "i", "is", "parse", "keep", "ter", "er", "ip", "inner", "Iterator", "former", "walker", "slice", "ir", "file", "err", "fer", "list", "Iter", "inter", "ator", "izer", "next", "ite", "order", "cher", "liter", "iner", "chain", "iterator", "iz", "http"], "fileName": ["filenamename", "pageString", "FileString", " filePart", "FileUrl", "fName", "filePath", " filePath", "localname", "fileOpen", "filenameName", "currentname", "fileData", " fileLine", " fileType", " fileData", "FileFull", "fullOpen", "fileString", " fileFull", "fileType", "FilePart", "simplePath", "filenameInfo", "fileUrl", "currentData", "pageType", "currentName", " fileUrl", "FileLine", "pagename", "localPart", "fileInfo", "filename", "localName", "currentUrl", "simpleOpen", " fileInfo", "Filename", "FileInfo", "FilePath", " filename", "fPart", "fileFull", " fileString", "FileName", "fullPath", "localPath", "filePart", "FileData", "fullName", "fLine", "pageName", "FileType", " fileOpen", "fileLine", "simpleName", "filenameFull", "fname"], "ind": ["bind", "fr", "z", "vert", "nd", "j", "length", "count", "loc", "mid", "ded", "inc", "pos", "in", "cond", "pt", "index", "inn", "d", "ci", "val", "end", "eff", "i", "pull", "dir", "rib", "len", "ad", "id", "div", "ord", "IND", "start", "ld", "ix", "mind", "ii", "x", "Ind", "wind", "pend"], "shortName": ["Shortname", "ShortPath", " shortString", "longName", "smallname", "shortPart", "ShortString", "shortname", "ShortPart", "smallPart", "shortPath", "shortString", "ShortName", "longPart", "shortLine", "smallPath", "fullname", " shortPath", "longLine", "fullString", " shortname", "smallName", "longPath", "longname", "fullPath", "fullName", "fullLine", " shortLine"], "fis": [" fiss", "pisa", "fisa", "Fos", "fris", "cfis", "Fiss", "gisa", " fris", "cfs", " fisa", "gis", "fs", "pis", "fios", "Fs", "gios", "pris", "fiss", "pios", "cfiss", "gris", "afiss", "cfris", "cfos", " fs", "afris", "afis", " fios", "afos", "Fis"], "buf": ["fd", "cv", "uf", "bu", "uc", "b", "loc", "rc", "fb", "data", "bh", "bp", "lb", "feat", "bc", "pb", "bag", "rb", "batch", "done", "bytes", "cb", "Buff", "cur", "bf", "bd", "grab", "tmp", "buff", "ff", "queue", "ba", "br", "v", "lim", "bin", "la", "vec", "wb", "bl", "buffer", "seq", "box", "bb"], "bytesRead": [" bytesLength", "flowsWrite", "tesRead", "flowsRead", "bitsSkip", " bytesWrite", "bitsLength", "bitsRead", " bytesNeed", " bytesLoad", "bytesNeed", "bitsWrite", "tesWrite", "tesSkip", "bitsUse", "secondsRead", "wordsWrite", "bytesUse", "wordsUse", "bitsLoad", "secondsWrite", "bytesSkip", "tesLoad", "wordsRead", "bytesLoad", "bytesLength", "secondsLength", "bytesWrite", "flowsNeed", "secondsNeed", "flowsLength", " bytesUse", "wordsLength", " bytesSkip"]}}
{"id1": "14783950", "id2": "12004824", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "    public HttpResponse executeHttpRequest(HttpRequestBase httpRequest) {\n        HttpResponse response = null;\n        try {\n            HttpParams httpParams = new BasicHttpParams();\n            HttpConnectionParams.setConnectionTimeout(httpParams, maxTime);\n            HttpConnectionParams.setSoTimeout(httpParams, maxTime);\n            httpclient = new DefaultHttpClient(httpParams);\n            response = httpclient.execute(httpRequest);\n            maxTime = 15000;\n        } catch (Exception e) {\n        }\n        return response;\n    }\n", "label": 0, "substitutes": {"compressWithZip": ["compressUsingJar", "compressUsingZip", "compressInZip", "compresswithZip", "compresswithSax", "compressedWithJar", "compressInSax", "compressedWithZip", "compressWithJar", "compressUsingSax", "compresswithJar", "compressInJar", "compressedWithSax", "compressedUsingJar", "compressedUsingZip", "compressedUsingSax", "compressWithSax"], "fileList": [" fileChain", "wordString", "FileStream", "zipSet", "FileString", "fileStream", "modelCollection", "wordName", "inputEx", "modelEx", "fileCollection", "FileSet", "fileString", "modelList", "wordStream", "modelStream", "FileList", "inputCollection", "fileEx", "FileChain", "filelist", " fileSet", "zipList", "inputList", "inputStream", "wordList", "ziplist", "fileChain", "stringName", " fileEx", "stringlist", " fileStream", "Filelist", " fileCollection", " fileString", "FileName", "stringList", "stringChain", "zipName", "fileSet", " filelist"], "zipFileName": ["folderGlobalPath", "archiveDirDir", "zipFullname", "zipDirname", "zipFileDir", "archiveDirPath", "zipGlobalNames", "zipFullPath", "folderGlobalname", "zipFilename", "archiveFileName", "archiveFilePath", "zipDirDir", "zipPackagePath", "zipFullName", "zipFileNames", "archiveDirName", "folderFileNames", "zipGlobalPath", "folderFileName", "zipFullDir", "zipPackageName", "zipPackageDir", "folderGlobalName", "zipDirNames", "zipDirName", "archiveFileDir", "zipFullNames", "zipGlobalName", "zipDirPath", "zipFilePath", "folderFilename", "folderFilePath", "zipGlobalname", "folderGlobalNames"], "fos": ["Fosh", "infoS", "Fos", "flos", "faos", "infos", "fosh", "infaos", "afoS", "foS", "flis", "Faos", "FoS", " fosh", "afaos", "infis", "flosh", "afis", "afos", "Fis"], "zos": ["css", "zz", "ros", "dos", "closure", "z", "fits", "kos", "tz", "fi", "ZA", "os", "jas", "jobs", "ozo", "osi", "uz", "iframe", "nz", "cos", "loop", "zip", "es", "bis", "bos", "lins", "bag", "chini", "zes", "oses", "zzy", "seconds", "abi", "zik", "lol", "bes", "zar", "zag", "zo", "zers", "zen", "LOS", "outs", "zl", "rez", "ses", "onz", "zb", "ZI", "packs", "gz", "zx", "zer", "zy", "webkit", "obb", "zi", "phi", "zon", "zan", "spin", "budget", "inos"], "iter": ["enter", "inse", "fr", "e", "itter", "ser", "loc", "outer", "oper", "ner", "inc", "ie", "it", "f", "set", "index", "upper", "finder", "sort", "coll", "end", "test", "ener", "el", "gener", "i", "is", "parse", "keep", "ter", "er", "ip", "inner", "Iterator", "former", "walker", "slice", "ir", "file", "err", "fer", "list", "Iter", "inter", "ator", "izer", "next", "ite", "order", "cher", "liter", "iner", "chain", "iterator", "iz", "http"], "fileName": ["filenamename", "pageString", "FileString", " filePart", "FileUrl", "fName", "filePath", " filePath", "localname", "fileOpen", "filenameName", "currentname", "fileData", " fileLine", " fileType", " fileData", "FileFull", "fullOpen", "fileString", " fileFull", "fileType", "FilePart", "simplePath", "filenameInfo", "fileUrl", "currentData", "pageType", "currentName", " fileUrl", "FileLine", "pagename", "localPart", "fileInfo", "filename", "localName", "currentUrl", "simpleOpen", " fileInfo", "Filename", "FileInfo", "FilePath", " filename", "fPart", "fileFull", " fileString", "FileName", "fullPath", "localPath", "filePart", "FileData", "fullName", "fLine", "pageName", "FileType", " fileOpen", "fileLine", "simpleName", "filenameFull", "fname"], "ind": ["bind", "fr", "z", "vert", "nd", "j", "length", "count", "loc", "mid", "ded", "inc", "pos", "in", "cond", "pt", "index", "inn", "d", "ci", "val", "end", "eff", "i", "pull", "dir", "rib", "len", "ad", "id", "div", "ord", "IND", "start", "ld", "ix", "mind", "ii", "x", "Ind", "wind", "pend"], "shortName": ["Shortname", "ShortPath", " shortString", "longName", "smallname", "shortPart", "ShortString", "shortname", "ShortPart", "smallPart", "shortPath", "shortString", "ShortName", "longPart", "shortLine", "smallPath", "fullname", " shortPath", "longLine", "fullString", " shortname", "smallName", "longPath", "longname", "fullPath", "fullName", "fullLine", " shortLine"], "fis": [" fiss", "pisa", "fisa", "Fos", "fris", "cfis", "Fiss", "gisa", " fris", "cfs", " fisa", "gis", "fs", "pis", "fios", "Fs", "gios", "pris", "fiss", "pios", "cfiss", "gris", "afiss", "cfris", "cfos", " fs", "afris", "afis", " fios", "afos", "Fis"], "buf": ["fd", "cv", "uf", "bu", "uc", "b", "loc", "rc", "fb", "data", "bh", "bp", "lb", "feat", "bc", "pb", "bag", "rb", "batch", "done", "bytes", "cb", "Buff", "cur", "bf", "bd", "grab", "tmp", "buff", "ff", "queue", "ba", "br", "v", "lim", "bin", "la", "vec", "wb", "bl", "buffer", "seq", "box", "bb"], "bytesRead": [" bytesLength", "flowsWrite", "tesRead", "flowsRead", "bitsSkip", " bytesWrite", "bitsLength", "bitsRead", " bytesNeed", " bytesLoad", "bytesNeed", "bitsWrite", "tesWrite", "tesSkip", "bitsUse", "secondsRead", "wordsWrite", "bytesUse", "wordsUse", "bitsLoad", "secondsWrite", "bytesSkip", "tesLoad", "wordsRead", "bytesLoad", "bytesLength", "secondsLength", "bytesWrite", "flowsNeed", "secondsNeed", "flowsLength", " bytesUse", "wordsLength", " bytesSkip"]}}
{"id1": "2518655", "id2": "12380475", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fnOut": ["fpOUT", "fnFile", "FNOutput", "fnIn", " fnEx", "lsOut", " fnIn", "fpOutput", "fpFile", "lsFile", " fnOUT", "fpOut", " fnFile", "FNIn", "fnOutput", "FNOut", "lsOUT", "fpIn", "fnOUT", "lsOutput", " fnOutput", "fpEx", "fnEx", "FNEx"], "writer": ["wa", "wire", "writ", "reader", "builder", "w", "output", "war", "worker", "ws", "ler", "er", "out", "inner", "driver", "word", "winner", "writing", "write", "widget", "wr", "editor", "layer", "Writer", "riter", "r", "a", "handler", "per", "walker", "socket", "loader", "nw", "outer", "parser", "buffer", "key", "fd", "work", "server", "entry", "file", "usher", "director", "writers", "temp"], "i": ["qi", "v", "z", "k", "ip", "ai", "ti", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "eni", "li", "ui", "u", "s", "hi", "multi", "ci", "c", "si", "mi", "phi", "ii", "m", "j", "type", "ie", "ori", "b", "n", "o", "bi", "ri", "uri", "p", "strength", "key", "gi", "h", "fi", "abi", "ix", "oi", "di", "chi", "ji", "part", "f", "pi"], "fInput": ["sfOutput", "sfinput", "fileinput", " fFormat", "fileFormat", "fFormat", "fileOutput", "fileInput", " fOutput", "fileSource", "fOutput", " fSource", "sfSource", "fSource", " finput", "finput", "sfFormat", "sfInput"], "in": ["gin", "ins", "reader", "din", "IN", "login", "bin", "id", "isin", "inc", "vin", "ini", "input", "out", "In", "s", "conn", "inner", "ln", "c", "inas", "connection", "b", "n", "scan", "again", "sin", "socket", "ner", "nin", "win", "inn", "version", "min", "pin", "line", "lin", "data", "cin", "inside", "kin", "init", "rin", "reading", "f"]}}
{"id1": "21326424", "id2": "596993", "code1": "    public APIResponse delete(String id) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/variable/delete/\" + id).openConnection();\n        connection.setRequestMethod(\"DELETE\");\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            response.setDone(true);\n            response.setMessage(\"Variable Deleted!\");\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Delete Variable Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    private String makeLoginRequest(URL url) throws IOException {\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setDoInput(true);\n        urlConnection.setDoOutput(true);\n        urlConnection.setUseCaches(false);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"Email=\").append(URLEncoder.encode(EMAIL, \"UTF-8\"));\n        content.append(\"&Passwd=\").append(URLEncoder.encode(PASSWORD, \"UTF-8\"));\n        content.append(\"&service=\").append(URLEncoder.encode(SERVICE, \"UTF-8\"));\n        content.append(\"&source=\").append(URLEncoder.encode(\"Google Base data API\", \"UTF-8\"));\n        OutputStream outputStream = urlConnection.getOutputStream();\n        outputStream.write(content.toString().getBytes(\"UTF-8\"));\n        outputStream.close();\n        int responseCode = urlConnection.getResponseCode();\n        InputStream inputStream;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = urlConnection.getInputStream();\n        } else {\n            inputStream = urlConnection.getErrorStream();\n        }\n        return toString(inputStream);\n    }\n", "label": 0, "substitutes": {"delete": ["request", "get", "process", "de", "del", "save", "release", "reply", "load", "Delete", "complete", "replace", "info", "resource", "edit", "post", "set", "update", "clear", "execute", "drop", "remove", "lete", "stop", "list", "destroy", "create"], "id": ["request", "error", "ip", "in", "query", "i", "key", "oid", "version", "Id", "ID", "address", "info", "code", "ident", "path", "resource", "str", "end", "uid", "url", "sid", "nil", "model", "data", "type", "method", "ids", "name", "string", "variable", "and", "aid", "uri", "pid", "kid"], "response": ["request", "next", "image", "error", "success", "client", "service", "offer", "tree", "i", "output", "reply", "object", "relation", "proxy", "view", "user", "version", "instance", "reference", "route", "page", "handler", "server", "json", "example", "result", "http", "array", "resource", "message", "index", "Response", "description", "function", "value", "resp", "f", "ception", "api", "onse", "model", "data", "v", "collection", "status", "application", "site", "body", "respond", "uri"], "connection": ["request", "image", "position", "error", "timeout", "client", "connect", "writer", "union", "creator", "query", "entry", "relation", "socket", "proxy", "context", "character", "bug", "version", "section", "directory", "handler", "server", "cache", "conn", "or", "http", "inner", "resource", "index", "io", "translation", "manager", "function", "description", "connected", "url", "channel", "session", "builder", "log", "database", "collection", "application", "number", "document", "volume", "driver", "ion", "communication", "network", "Connection", "uri", "event", "config", "c", "condition"]}}
{"id1": "10361370", "id2": "16820041", "code1": "    public static byte[] hash(final byte[] saltBefore, final String content, final byte[] saltAfter, final int repeatedHashingCount) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        if (content == null) return null;\n        final MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        if (digestLength == -1) digestLength = digest.getDigestLength();\n        for (int i = 0; i < repeatedHashingCount; i++) {\n            if (i > 0) digest.update(digest.digest());\n            digest.update(saltBefore);\n            digest.update(content.getBytes(WebCastellumFilter.DEFAULT_CHARACTER_ENCODING));\n            digest.update(saltAfter);\n        }\n        return digest.digest();\n    }\n", "code2": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "label": 1, "substitutes": {"hash": ["render", "shadow", "cache", "Hash", "fill", "comment", "sha", "sum", "match", "hex", "key", "header", "build", "dh", "ash", "index", "dump", "password", "ashing", "check", "h", "html", "sign", "update", "crypt", "block", "version"], "saltBefore": ["saultHead", "singALTBefore", "sultBefore", "sultStart", "isaultFrom", "sultHead", "singALTAfter", "sintBefore", "seedAbove", "sertBefore", "saltStart", "sertStart", "sintFrom", "saultStart", "singaltAfter", "sALTStart", "isaltStart", "isaultHead", "saultFrom", "isaultStart", "sALTBefore", "sALTAfter", "sertAbove", "seedAfter", "isaltHead", "seedStart", "sintStart", "saltHead", "singaltAbove", "sertAfter", "saltAbove", "isaultBefore", "singALTAbove", "singaltStart", "saltFrom", "saultBefore", "sALTAbove", "singaltBefore", "isaltFrom", "sultFrom", "isaltBefore", "sintHead", "singALTStart", "seedBefore"], "content": ["resource", "temp", "media", "section", "entity", "string", "cache", "word", "method", "xml", "expression", "str", "character", "script", "comment", "input", "cont", "sequence", "json", "length", "music", "address", "object", "header", "creator", "document", "model", "Content", "url", "size", "code", "value", "password", "filename", "image", "format", "output", "data", "raw", "message", "pattern", "source", "stream", "text", "body", "buffer", "version", "parent"], "saltAfter": ["singALTBefore", "singaltAround", "sALTExtra", "singALTAfter", "sALTafter", " saltExtra", " sALTBefore", "sintBefore", "saltafter", "sertBefore", "singaltEnd", "singaltAfter", " sALTAfter", "sertAround", "saultafter", "sintafter", "sALTBefore", "sALTAfter", " sALTExtra", "sintAfter", "sintExtra", "singALTEnd", " sALTafter", "saltAround", "saltedAfter", "sertEnd", "sertAfter", "singALTAround", "saultBefore", "singaltBefore", "saltExtra", "saltedBefore", "saultExtra", "saltedAround", "saultAfter", "sALTEnd", "sALTAround", "saltEnd", " saltafter", "saltedEnd"], "repeatedHashingCount": ["repeatedHashedcount", "repeatedChashesNumber", "repeatedHashedNumber", "repeatedShashLength", "repeatedHashingcount", "repeatedChashescount", "repeatedHatingCounter", "repeatedShashingCode", "repeatedHashingCounter", "repeatedHumpingCount", "repeatedShashingLength", "repeatedHashingCode", "repeatedHumpingcount", "repeatedHumpingNumber", "repeatedHashesType", "repeatedChashingcount", "repeatedChashesType", "repeatedHashesCount", "repeatedHumpingType", "repeatedShashingCount", "repeatedHashesCounter", "repeatedChashingNumber", "repeatedChashesCount", "repeatedHashedType", "repeatedHashedCount", "repeatedShashCount", "repeatedHatingCount", "repeatedShashCode", "repeatedHashesNumber", "repeatedShashCounter", "repeatedChashingCount", "repeatedHashesCode", "repeatedHashCounter", "repeatedHashCount", "repeatedHashingLength", "repeatedHatingLength", "repeatedHashingNumber", "repeatedHashesLength", "repeatedChashingType", "repeatedHashLength", "repeatedHashingType", "repeatedHashescount", "repeatedShashingCounter", "repeatedHashCode", "repeatedHatingCode"], "digest": ["Diggest", "ngest", " Diger", "signEST", "hexString", "ngested", "mixested", "hashString", "digator", "finester", "logest", "Digator", " Digester", "hashest", " diger", "digusher", "nger", " digator", " digests", "Digester", " digusher", "Digested", "signest", " digger", "digested", " digEST", "digester", " Digator", "mixester", "Digusher", "finests", "DigEST", " digester", "DigString", " digested", "validest", "hexests", "generest", "signester", "mixusher", "finested", " diggest", "valider", "hashests", "mixest", "logester", "digEST", "generester", "finest", "Diger", "diger", " Digest", "Digger", "validested", "generested", "diggest", "signested", "ngester", "Digests", "digger", "hexest", "digests", "hexested", "loger", "Digest", "hashested", "loggest", "validester", "digString", "generests", "signger"], "digestLength": ["digestinglength", "Digestlength", "digestingLen", "digestsType", "digestLen", "DigesterLen", " digesterLen", "digestedLength", "DigestLen", " digestlength", "digestlength", " digesterlength", "DigestLength", "digesterLen", " digestType", "digesterlength", "digestedlength", "digestingLength", "DigesterLength", "Digesterlength", "digestsLength", "digesterType", "digestsLen", "digestingType", "digesterLength", " digesterLength", "digestslength", "digestType", " digesterType", " digestLen", "digestedLen"], "i": ["iu", "si", "qi", "chi", "u", "multi", "n", "ii", "c", "k", "pi", "ini", "o", "d", "ci", "di", "io", "api", "slice", "ui", "ri", "length", "bi", "count", "p", "ami", "l", "phi", "s", "j", "I", "fi", "x", "index", "f", "e", "oi", "li", "anti", "start", "h", "v", "gi", "ti", "wei", "ai", "b", "xi", "t", "id", "zi", "info", "uri", "mu", "lc"]}}
{"id1": "255765", "id2": "17729554", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"f": ["r", "fr", "m", "self", "h", "p", "j", "lf", "bf", "g", "n", "fa", "ff", "fd", "form", "s", "feed", "fi", "fen", "e", "cf", "fo", "t", "fm", "sf", "fe", "inf", "a", "path", "ref", "fp", "io", "df", "function", "fn", "fc", "file", "fold", "fun", "of", "x", "rf", "fs", "this", "flat", "b", "v", "w", "name", "fx", "l", "d", "folder", "tf", "F", "filename", "c"], "in": ["image", "g", "inn", "ex", "fe", "a", "rin", "str", "v", "w", "ins", "In", "reader", "win", "r", "get", "p", "pin", "isin", "gin", "gen", "is", "input", "diff", "inner", "vin", "nin", "part", "err", "b", "l", "d", "again", "lock", "ac", "inc", "m", "ic", "fa", "init", "din", "t", "lin", "ssl", "ini", "min", "pass", "serv", "it", "IN", "source", "up", "c", "n", "socket", "cin", "thin", "or", "connection", "con", "rec", "exec", "login", "session", "data", "with", "token", "bin", "config"], "cbuf": ["bux", "cfuff", "rbuc", "rbbuf", "cfur", "bcur", "zbutf", "bcux", "fbuf", "bbuff", "cfuc", "cbur", "cfuf", "cfbuf", "bcul", "CBuf", "fbbuf", "bcault", "rbault", "bcuf", "cbull", "bbull", "cbuc", "cbbuf", "CBuc", "rbull", "cbault", "bcurs", "bcull", "bbuf", "buff", "CBuff", "cbuff", "cbux", "fbuc", "dbur", "rbutf", "zbuf", "rburs", "cbuu", "cburs", "buf", "dbuc", "ebuf", "bcuc", "rbul", "zbuff", "ebutf", "cbutf", "dbuff", "rbuu", "dbuf", "ebuu", "cbul", "CBul", "fbuff", "zbuu", "bburs", "rbux", "bcuff", "bault", "rbuff", "ebuff", "rbuf"], "read": ["error", "size", "sync", "g", "Read", "cel", "key", "old", "rc", "used", "ak", "open", "last", "seek", "only", "report", "raw", "change", "reading", "build", "end", "x", "iter", "en", "update", "re", "know", "er", "w", "allow", "text", "draw", "name", "reader", "create", "length", "get", "ind", "r", "connect", "ok", "full", "view", "feed", "load", "input", "parse", " write", "check", "val", "index", "num", "io", "sleep", "find", "lex", "close", "ack", "skip", "ing", "d", "repeat", "inc", " reading", " Read", "level", "ize", "stream", "bit", "ink", "q", "use", "print", "id", "valid", "run", "child", "work", "count", "start", "pass", "k", "pe", "log", "y", "put", "each", "wait", "it", "ride", "un", "insert", "add", "play", "buffer", "ed", " READ", "socket", "write", "reads", "want", "READ", "orig", "se", "readable", "send", "fill", "oct", "data", "type", "bind", "record", "call", "loop", "config", "select", "hex"], "totRead": ["tottUse", "totUse", "TottGet", "tntWrite", "tatLoad", "octotLength", "totReader", "ntottWrite", "towAccept", "TotWrite", "totalLoad", "tochReader", "totoFind", "totaLoad", "toyRead", "TotaRead", "towLength", "TottConnect", "octotRead", "tobyFind", "dottReader", " totWrite", "totalWrite", "totoRead", "ntottRead", "TotSearch", "tottReading", "tetReading", "nottLoad", "tottLength", "totaDraw", "totiBuild", "tottedGet", "TotReader", "tetRead", "tntRead", "totoLength", "totalBuild", "totConnect", "totGet", "nottWrite", "totAccept", "totingConnect", "tollWrite", "tottAccept", "TotRead", "tobyLoad", "tottDraw", "tottLoad", "totiWrite", "tottFind", "tottConnect", "tottedRead", "tochWrite", "totiRead", "ntottLoad", "notWrite", "totingRead", "tottBuild", "tottReader", "tazonLoad", "towReading", "dottRead", "TottLoad", "dottLoad", "tottWrite", "tetLoad", "totLength", "TotConnect", "TotReading", "totBuild", " totBuild", "totingSearch", "tcotLoad", "totClose", "ntotWrite", "tobyRead", "totiLink", "tcotClose", "dotReader", "totaReading", "totalRead", "intottLoad", "octotoLength", "tatWrite", "dottReading", "TottWrite", "tottSearch", "TottRead", "totFollow", "intotRead", "totaBuild", "dottUse", "totSearch", "dotReading", "totDraw", "TotaLoad", "octotWrite", "towRead", "ntotLoad", "notRead", " totalBuild", "totoLoad", "totLink", "totalAccept", "octotoRead", " totalWrite", "tottFollow", "ntotReader", "TotaWrite", " totalLink", "totoUse", "TotaDraw", "tollReading", "tazonBuild", "TotGet", "totLoad", "tazonRead", "toyLoad", "tollRead", "intottRead", "totaWrite", "intottClose", "octotoReading", "intotLoad", "notLoad", "totReading", "intotBuild", "dotLoad", "tochLoad", "tazonClose", "totalLink", " totLink", "tntReader", " totalRead", "tottedFollow", "octotoWrite", "tottedWrite", "intotClose", "TotDraw", "nottAccept", "totaRead", "tollLoad", "tetWrite", "tntLoad", "tatReader", "tatRead", "tobyUse", "towWrite", "dottFind", "totoSearch", "dotFind", "ntottReader", "totFind", "tottClose", "tochRead", "totoReading", "totaReader", "TottReading", "totingWrite", "intottBuild", "dottWrite", "dotRead", "totingGet", "tottRead", "toyWrite", "notAccept", "TotLoad", "tottGet", "TotFollow", "TottFollow", "nottRead", "totoConnect", "TottSearch", "octotReading", "dotUse", "totaLink", "ntotRead", "totWrite", "totoWrite", "towLoad", "totingFollow", "TottReader", "tcotRead", "toyDraw", "tcotBuild", "dotWrite"], "out": ["Out", "r", "client", "writer", "h", "p", "obj", "sync", "n", "g", "off", "output", "socket", "s", "init", "parent", "ex", "t", "conn", "plus", "connection", "a", "exp", "ext", "io", "fn", "conf", "file", "part", "x", "o", "exec", "ac", "err", "b", "v", "w", "net", "bin", "l", "In", "d", "again", "OUT", "outs", "outer", "up", "c", "inc"], "i": ["j", "g", "my", "ik", "key", "ci", "gi", "info", "zi", "ei", "x", "api", "u", "v", "name", "yi", "uri", "I", "length", "r", "ind", "ip", "p", "one", "eni", "is", "multi", "fi", "ix", "input", "phi", "li", "index", "io", "iu", "bi", "ti", "b", "mi", "l", "d", "si", "ai", "m", "ic", "q", "init", "slice", "e", "id", "abi", "z", "ini", "start", "o", "xi", "k", "ri", "y", "ji", "oi", "it", "hi", "chi", "source", "c", "buffer", "h", "ie", "ui", "ori", "ii", "pi", "data", "ni", "di", "me", "qi", "current"]}}
{"id1": "5759961", "id2": "16063533", "code1": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "code2": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "label": 1, "substitutes": {"saveUser": ["SaveUser", "SavePerson", "savePerson", " savePerson", "saveuser", "saveAccount", "submitAccount", "submitUser", "submitPerson", "SaveAccount", " saveuser", "Saveuser", " saveAccount", "submituser"], "user": ["result", "base", "account", "ver", "job", "clean", "project", "e", "use", "force", "app", "valid", "model", "replace", "db", "one", "request", "log", "User", "student", "users", "plugin", "creator", "name", "string", "profile", "bug", "word", "this", "facebook", "self", "book", "editor", "or", "username", "you", "used", "class", "object", "parent", "rule", "query", "per", "config", "service", "resource", "person", "content", "me", "usr", "data", "up", "entry", "USER", "password", "style", "tool", "full", "group", "home", "uid", "team", "record", "blog", "author", "module"], "digest": ["digit", "signEST", "signest", "mdEST", "genest", "bigest", "genge", "mdit", "Digge", " digge", "mdest", "digEST", "Digert", "bigester", " digester", "digester", "digert", "digge", " digEST", "mdge", "DigEST", "bigge", " digert", "genit", "Diger", "Digester", "signester", "diger", "Digest", " diger", "signer", "biger", "Digit", "genEST", "bigert"], "hash": ["url", "base", "sha", "ash", "cache", "id", "current", "db", "check", "Hash", "total", "index", "string", "max", "memory", "image", "hex", "build", "code", "count", "html", "fill", "number", "empty", "query", "block", "her", "message", "array", "update", "version", "depth", "key", "mac", "math", "search", "h", "match", "password", "num", "full", "sum"], "bigInt": ["hashInt", "Bigint", "largeInteger", "bigint", "hashUrl", "BigInt", "hugeInteger", "hugeint", "BigInteger", "hashint", "largeint", "bigInteger", "bigString", "bigUrl", " bigUrl", "largeInt", " bigInteger", "hugeInt", "largeString", "hugeUrl", "BigString", " bigint", "hashInteger", " bigString"], "hashtext": ["hashword", "sumText", "sumfeed", "ashstring", " hashword", " hashText", " hashstring", "ashText", " hashpath", "sumtext", "ashpath", " hashTEXT", "hashText", "ashfeed", "sumTEXT", "ashtext", "sumstring", "hashTEXT", "hashfeed", "Hashstring", "Hashpath", "HashTEXT", "hashstring", "HashText", "Hashword", "ashTEXT", "hashpath", "ashword", "sumword", "Hashfeed", "Hashtext"]}}
{"id1": "15896098", "id2": "22479286", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public String md5(String plainText) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(plainText.getBytes());\n        byte[] digest = md.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < digest.length; i++) {\n            plainText = Integer.toHexString(0xFF & digest[i]);\n            if (plainText.length() < 2) {\n                plainText = \"0\" + plainText;\n            }\n            hexString.append(plainText);\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"getSHA256Checksum": ["getSHA256Chechecksam", "getSHA256Chechecksum", "getSHA256Cheicksums", "getSHA256Checksam", "getSHA256Chcksums", "getSHA256Cheicksum", "getSHA256Checksumber", "getSHA256Chechecksumber", "getSHA256Chcksumber", "getSHA256Checsam", "getSHA256Cheicksumber", "getSHA256Chcksum", "getSHA256Checsums", "getSHA256Checksums", "getSHA256Chechecksums", "getSHA256Chchecksumber", "getSHA256Checsumber", "getSHA256Chchecksam", "getSHA256Chcksam", "getSHA256Cheicksam", "getSHA256Checsum", "getSHA256Chchecksums", "getSHA256Chchecksum"], "source": ["ource", "fp", "url", "result", "base", "reader", "cache", "output", "path", "input", "target", "string", "seed", "length", "Source", "code", "format", "connection", "text", "object", "dest", "config", "slice", "ources", "buffer", "message", "uri", "resource", "service", "content", "from", "data", "file", "src", "size", "SOURCE"], "checksum": [" checksums", "hsum", "hsums", "cs256", "csum", "checksup", "cssum", "check256", "cksums", "ckssum", "cksum", "checkssum", " checksumption", "checksam", "csup", " checks256", "hsam", " checkssum", "ckset", "checkum", "checks256", "checksumption", "hexet", " checksam", "checkup", "hssum", "checkset", "cksam", "checksums", " checksup", " checkset", "cksumption", "hexsum", "hexum", "hexumption"], "md": ["MD", "hash", "cm", "mc", "dig", "ms", "metadata", "rm", "pm", "bd", "amd", "am", "df", "mo", "MB", "um", "mb", "mt", "ind", "cmd", "M", "hd", "sm", "rpm", "mand", "m", "dd", "Cmd", "gd", "od", "grad", "mm", "pd", "wd", "mac", "hm", "dh", "vm", "d", "mag", "bf", "vd", "dm", "nm", "f", " MD", "mp"], "byteData": ["numberDATA", "connectionData", "wordBytes", "ipArray", " byteInfo", " byteSize", "bitNumber", "characterText", "wordArray", "characterData", "pixeldata", " byteNumber", "bitList", "wordInfo", "connectionDATA", "byteList", " byteString", "byteNumber", "numberData", "byteString", "ByteSize", "ByteInfo", "ipNumber", " byteDATA", "pixelDATA", "numberdata", " byteList", "connectionSize", "pixelData", "pixelString", "ByteData", " byteBytes", "byteInfo", "bitData", " byteArray", "bitArray", "byteDATA", "characterArray", "ipDATA", "bytedata", "wordData", "numberString", "bitDATA", "ByteBytes", "connectionArray", " byteText", "ByteDATA", "bitText", "byteText", " bytedata", "ByteArray", "ipData", "byteArray", "characterList", "byteBytes", "byteSize"], "sb": ["bc", " eb", "sv", "xb", "bb", "gb", "ob", "bp", " SB", "bd", "nb", "db", "bm", "ws", "fb", "mb", "ls", "binary", "bsp", "si", "sg", "buff", "BB", "SB", "lb", "sq", "b", "buf", "ub", "bg", "bt", "abb", "wb", "kb", "buffer", "ab", "eb", "rb", "pb", "usb", "bh", "src", "bf", "sf", "cb", "bs"], "i": ["qi", "v", "k", "ip", "ai", "ti", "w", "I", "e", "id", "io", "iu", "xi", "x", "ini", "index", "q", "li", "u", "ui", "hi", "multi", "ci", "c", "si", "mi", "phi", "ii", "y", "j", "ie", "r", "info", "ori", "b", "n", "o", "slice", "ri", "uri", "p", "ix", "key", "h", "it", "is", "gi", "l", "oi", "data", "di", "abi", "in", "ni", "d", "ji", "f", "bi", "pi"], "hexString": ["formString", " hexstring", "hexArray", "hexstring", " hexCode", "rawService", " hexStr", " hexService", "hashCode", "hexStr", "exString", "charBuffer", "shortArray", "formstring", "charArray", "rawString", "hexBuffer", "crossFile", "checkString", "rawstring", "shortBuffer", "rawArray", "formArray", "hexFile", "crossString", " hexBuffer", "hexService", "hexCode", " hexArray", "checkArray", "charString", "charStr", "exBuffer", "hashString", "hashService", "formService", "crossBuffer", "shortString", "checkService", "hashArray", "exStr", " hexFile", "exFile", "crossStr", "shortStr", "checkCode"], "hex": ["hash", "lit", "digit", "rex", "ip", "pex", "bit", "rh", "str", "pixel", "bin", "id", "exp", "zip", "raw", "none", "utf", "cross", "string", "length", "comp", "character", "serial", "color", "format", "transform", "ex", "text", "null", "oct", "sync", "pack", "alpha", "wh", "form", "http", "nexus", "cookie", "data", "char", "letter", "shift", "sex", "num", "coord", "closure", "sum", "buff", "cmp", "temp"]}}
{"id1": "5744493", "id2": "19810820", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": [" dofileCopy", " doFileCopy", "newBlockWrite", " doBlockCopy", " dofilecopy", " doFolderProxy", "newBlockcopy", "newFilecopy", " doFolderWrite", "newFileCopy", " dofileWrite", "newBlockProxy", " doBlockProxy", " doFoldercopy", " doFileWrite", "newFileWrite", " doFolderCopy", " dofileProxy", " doBlockcopy", " doFileProxy", "newBlockCopy", "newFileProxy", " doBlockWrite", " doFilecopy"], "in": ["IN", "index", "pin", "base", "i", "input", "id", "ex", "buffer", "lock", "c", "inner", "ins", "bin", "query", "part", "reader", "source", "login", "min", "diff", "inc", "config", "data", "file", "again", "name", "m", "image", "isin", "In", "url", "lin", "b", "err", "inn", "win"], "out": ["string", "base", "buffer", "temp", "server", "output", "copy", "ex", "resource", "user", "pre", "plain", "OUT", "socket", "o", "outs", "off", "write", "part", "source", "cache", "dot", "connection", "target", "default", "file", "page", "conn", "name", "again", "exec", "Out", "io", "writer", "image", "prefix", "ext", "v", "b", "external", "point"], "inChannel": ["binStream", "binSocket", "INSocket", "inSocket", "inputChannel", "INchannel", "inStream", " inchannel", "inputSocket", " inClient", "inchannel", "binChan", "InChan", "inputChan", "Inchannel", "INChan", "outStream", "INClient", "outchannel", "outChan", "inChan", "InChannel", "outSocket", "InStream", "inputStream", "outClient", "binChannel", "INStream", "InSocket", "INChannel", " inStream", "inClient", " inChan", " inSocket"], "outChannel": ["inSocket", "OutStream", "inStream", "againChannel", "againSocket", "intChan", " outButton", "OutChannel", "inchannel", " outContainer", "againChan", "inButton", "OutChan", " outSocket", "outStream", "outContainer", "outchannel", "againStream", "outChan", "inChan", "outSocket", "OutBuffer", "intChannel", "intchannel", "outButton", "inBuffer", "outBuffer", "intButton", " outStream", "inContainer", "OutContainer", " outBuffer", " outchannel", " outChan"], "maxCount": ["MaxLength", " maxLength", "maxcount", "MaxCount", "maxSize", "axcount", "maxLength", "maxSum", "blockCount", " maxcount", "Maxcount", "MaxSum", "MaxSize", "axCount", " maxSum", "axLength", "blockSize", " maxSize", "blockSum", "blockcount", "axSize"], "size": ["capacity", "address", "max", "sum", "fee", "n", "cap", "end", "limit", "volume", "mode", "length", "shift", "time", "en", "offset", "sized", "type", "min", "len", "seek", "data", "small", "empty", "p", "Size", "start", "name", "available", "send", "SIZE", "bytes", "position", "flush", "unit", "shape", "ize", "range", "count", "width", "scale", "transfer", "speed", "loc"], "pos": ["val", "index", "push", "address", "base", "i", "id", "spec", "pose", " position", "slice", "ref", "Pos", "rel", "limit", "o", "slot", "length", "off", "pass", "iter", "offset", "part", "no", "min", "len", "diff", "open", "data", "p", "neg", "po", "start", "port", "pointer", "pid", "position", "unit", "point", "POS", "obj", "count", "os", "block", "pt", "cos", "loc"]}}
{"id1": "7948308", "id2": "19251426", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandGID", "getRandomMUID", "getRandomGuid", "getRandomMUD", "getRandGUID", "getRandomMuid", "getRandGuid", "getRandUUD", "getRandomUUD", "getRandomUID", "getRandomCuid", "getRandUuid", "getRandomGUD", "getRandomGID", "getRandUUID", "getRandomCID", "getRandomCUD", "getRandomCUID", "getRandomMID", "getRandGUD", "getRandomUuid", "getRandUID", "getRandomUUID"], "secure": ["active", "https", "secondary", "force", "depth", "session", "allow", "remote", "seed", "exclusive", "timeout", "smart", "sys", "rc", "ssl", "require", "zip", "forced", "deep", "random", "client", "sensitive", "secret", "external", "proxy", " insecure", "service", "sec", "config", "server", "weak", "Secure", "ce", "script", "unsigned", "accessible", "debug", "safe", "host", "security", "use", "stable"], "md5": [" MDql", "md2", " md64", "MDle", " MD2", "mand4", "cmd64", "mand5", "mandle", "mand3", "mp4", " md3", " md4", "cmd512", "MDql", "mandss", " mdle", "MD4", "MD5", "mdss", " mdss", " md512", "MD11", "mand2", "md512", "md11", "cmd4", " mdql", " MD11", " md2", "MD2", "mp64", "md64", "mdle", "mp5", "MDss", "mdql", "md4", " MD5", "cmd5", " md11", "md3", "mp512", "MD3"], "sbValueBeforeMD5": ["sbValueFirstMT3", "sbValueBeforeMD3", "sbValueBeforeMC5", "sbValueFirstMD50", "sbValueBeforeMT05", "sbValueBeforeMP1", "sbValueBesidesSD20", "sbValueAfterMS65", "sbValueBeforeMP3", "sbValueBesidesMD65", "sbValueAfterAMD8", "sbValueAfterMS5", "sbValueBeforeAMD3", "sbValueBeforeMDFive", "sbValueAfterMC7", "sbValueAfterAMD5", "sbValueAfterAMD3", "sbValueBeforeMS50", "sbValueWithoutMC512", "sbValueBeforeMD05", "sbValueBeforeAMD5", "sbValueAfterAMD25", "sbValueBeforeSHA1", "sbValueBeforeMOD50", "sbValueBeforeM3", "sbValueBeforeMI5", "sbValueBeforeAST20", "sbValueBeforeAMD8", "sbValueBeforeMAC20", "sbValueBeforeMSFive", "sbValueBeforeMAC512", "sbValueBeforeMS20", "sbValueAfterMD20", "sbValueBeforeMS5", "sbValueWithoutMC3", "sbValueFirstMT50", "sbValueAfterMC512", "sbValueAfterMD7", "sbValueAfterMD512", "sbValueFirstMT05", "sbValueBeforeMOD05", "sbValueBeforeM512", "sbValueBeforeSHA5", "sbValueAfterMSFive", "sbValueBeforeMD7", "sbValueBeforeSD3", "sbValueWithoutMD5", "sbValueBeforeMI3", "sbValueBeforeMR25", "sbValueBeforeMI512", "sbValueAfterMD25", "sbValueBeforeMC1", "sbValueBeforeMOD3", "sbValueBesidesSD5", "sbValueBeforeMOD5", "sbValueAfterMC5", "sbValueWithoutMD3", "sbValueAfterMS20", "sbValueBeforeSHA3", "sbValueBesidesSD65", "sbValueBeforeAST5", "sbValueBeforeMT8", "sbValueWithoutMC1", "sbValueAfterMS1", "sbValueAfterMD1", "sbValueBeforeMD20", "sbValueBeforeSHAFive", "sbValueWithoutMC5", "sbValueBeforeMD1", "sbValueBeforeAST65", "sbValueBesidesSD3", "sbValueBeforeMS65", "sbValueBeforeMI20", "sbValueBeforeMT3", "sbValueFirstMD3", "sbValueBeforeM5", "sbValueFirstMT5", "sbValueBeforeMAC65", "sbValueBesidesMD3", "sbValueBeforeMAC5", "sbValueBeforeMI7", "sbValueBeforeAMD25", "sbValueBeforeAST3", "sbValueAfterMD8", "sbValueAfterMC3", "sbValueWithoutMD1", "sbValueFirstMD5", "sbValueBeforeMT5", "sbValueBeforeMT50", "sbValueBeforeMD512", "sbValueBeforeSD20", "sbValueBeforeM1", "sbValueBeforeMD25", "sbValueBeforeMR8", "sbValueAfterMD3", "sbValueBeforeSD65", "sbValueBeforeMD8", "sbValueBeforeMD65", "sbValueBeforeMS05", "sbValueFirstMD05", "sbValueAfterMD65", "sbValueBesidesMD20", "sbValueBeforeMP5", "sbValueAfterMDFive", "sbValueBeforeMC7", "sbValueBeforeMI65", "sbValueBeforeMD50", "sbValueBeforeMS3", "sbValueAfterMS3", "sbValueBeforeMT25", "sbValueBeforeMAC3", "sbValueBeforeMC3", "sbValueAfterMD5", "sbValueBeforeMS1", "sbValueBesidesMD5", "sbValueBeforeMPFive", "sbValueBeforeMC512", "sbValueWithoutMD512", "sbValueBeforeMR3", "sbValueBeforeMAC1", "sbValueBeforeSD5", "sbValueBeforeMR5"], "time": ["etime", "name", "version", "times", "type", "cost", "seed", "mode", "tim", "timeout", "event", "counter", "Time", "size", "clock", "year", "TIME", "work", "random", "tz", "race", "count", "money", "value", "ime", "speed", "date", "rate", "duration", "delay", "id", "timer", "hour", "host", "sleep", "length", "est", "start"], "rand": ["rh", "rol", "loc", "reg", "version", "depth", "q", "range", "seed", "clean", "rank", "min", "gen", "winner", "rc", "rule", "mid", "rage", "win", "year", "r", "root", "cr", "raid", "chance", "max", "random", "rr", "row", "Rand", "count", "live", "chain", "serial", "pattern", "order", "round", "ng", "rate", "delay", "id", "ro", "right", "index", "res", "pick", "alpha", "bit"], "valueBeforeMD5": ["valueAfterMP3", "valueBeforeMC3", "valueAfterMP5", "valueBeforeMP2", "valueBeforeMD3", "valueBeforeMC73", "valueBeforeMD73", "valueBeforemd3", "valueBeforeMP5", "valueBeforeMC5", "valueAfterMD1", "valueAfterMD73", "valueBeforeMP3", "valueAfterMC73", "valueBeforeAMD3", "valueBeforemd5", "valueBeforeAMD5", "valueBeforeMD0", "valueBeforeMP0", "valueAfterMC3", "valueBeforeMD2", "valueAfterMD3", "valueAfterMC1", "valueBeforeDER0", "valueAfterMD0", "valueBeforeMC1", "valueBeforeMD1", "valueBeforeDER5", "valueBeforeDER2", "valueBeforeAMD2", "valueBeforeDER3", "valueBeforemd73", "valueAfterMC5", "valueAfterMD2", "valueAfterMP2", "valueBeforeAMD0", "valueBeforemd1", "valueAfterMP0"], "array": ["feature", "app", "error", "data", "vector", "batch", "archive", "allow", "arr", "range", "Array", "audio", "database", "pair", "any", "binary", "expression", "sample", "instance", "section", "r", "bug", "collection", "shape", "angle", "address", "row", "list", "image", "value", "api", "arrow", "object", "v", "our", "number", "view", "function", "index", "a", "message", "result", "record", "integer", "area", "string", "element", "ray"], "sb": ["SB", "BB", " SB", "bm", "cb", "sl", "ob", "sg", "lp", "bj", "gb", "s", "bs", "sth", "bt", "eb", "lab", "bh", "xb", "bl", "binary", "kb", "bb", "rob", "mb", "erb", "bp", "ruby", "rb", "sq", "buffer", "abb", "db", "lb", "zb", "bg", "lr", "sa", "pb", "ab", "wb", "nb", "src", "bsp", "bf", "sf", "orb", "usb", "obb", "fb", "bc", "ib", "buf", "tmp"], "j": ["x", "ji", "ij", "f", "y", "jj", "bj", "q", "g", "p", "k", "im", "bi", "pr", "jp", "br", "num", "part", "section", "aj", "l", "ja", "e", "key", "o", "dy", "d", "i", "block", "z", "ch", "js", "J", "v", "li", "n", "ii", "uj", "jo", "c", "index", "oj", "jl", "dj", "adj", "length", "obj"], "b": ["x", "BB", "bin", "be", "job", "cb", "f", "y", "bit", "bs", "p", "k", "eb", "base", "bb", "bi", "B", "br", "mb", "l", "bug", "e", "rb", "d", "i", "bar", "db", "lb", "n", "ab", "c", "pb", "wb", "beta", "a", "bf", "orb", "length", "fb", "nb", "ib", "ob"], "valueAfterMD5": ["valueAfterMCql", "valueAfterMP3", "valueAfterMDql", "valueAfterMPql", "valueAfterMP5", "valueBeforeMPql", "valueBeforeMD3", "valueBeforeMP5", "valueBeforeMP3", "valueBeforeMD25", "valueAfterMC3", "valueBeforeMP25", "valueAfterMD3", "valueAfterMD25", "valueAfterMP25", "valueAfterMC25", "valueAfterMC5", "valueBeforeMDql"]}}
{"id1": "19810820", "id2": "13063241", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"copyFileChannel": ["copyFilechannel", "transferfileStream", "copyDirectoryChannel", "copyDirectoryChan", "copyDirectorychannel", "copyStreamChan", "copyfileStream", "transferFilechannel", "transferFileChan", "copyDirectoryStream", "copyfileChan", "transferFileStream", "transferFileChannel", "transferfilechannel", "transferfileChan", "copyStreamChannel", "copyfileChannel", "copyFileChan", "copyStreamStream", "copyStreamchannel", "copyFileStream", "transferfileChannel", "copyfilechannel"], "src": ["path", "rest", "sel", "sin", "ssl", "sc", "server", "input", "sys", "rc", "Source", "lower", "slice", "filename", "sub", "dest", "loc", "s", "inst", "func", "rs", "SOURCE", "sync", "client", "sit", "source", "rb", "sb", "dist", "upload", "config", "ruby", "tmp", "sq", "conn", "ls", "sth", "start", "RC", "sup", "sl", "ctx", "url", "ses", "scene", "stream", "b", "st", "cur", "download", "img"], "dst": ["tst", "drc", " dST", "dart", "adrc", "adST", "ddest", "Ddest", "DST", "adput", "stlt", "bart", "bst", "dST", "Dost", "fdst", "dost", " ddest", "bput", "tart", "fdrc", "ldost", "lddest", "ldST", "dput", "bST", "start", "ldst", "fdput", "Dst", "stst", "stST", "blt", "adst", "dlt", " dost", "fdST", "tlt", "brc", "tST"], "preserveModificationTime": ["preserveModifiedFile", "preserveModifyingTime", "preserveModifytime", "preserveModifyTime", "preserveMinificationFile", "preserveMinificationTime", "preserveModationFile", "preserveModifiedtime", "preserveModifiedTime", "preserveModifyingFile", "preserveMinifiedtime", "preserveMinificationtime", "preserveModificationFile", "preserveMinifiedTime", "preserveMinifiedFile", "preserveModificationtime", "preserveModationTime", "preserveModifyingtime", "preserveModationtime"], "inputChannel": ["errorChannel", "fileConnection", " inputConnection", "outputConnection", " inputBuffer", " inputchannel", "inputchannel", "inputSocket", "InputBuffer", "outputBuffer", "outputGate", "imagechannel", "imageGate", "InputQueue", "binaryGate", "binaryChan", "fileChannel", "outputSocket", " inputSocket", " inputConsole", "InputSocket", "outputQueue", " inputCode", "inputChan", " inputQueue", "fileChan", "inputConsole", "inputBuffer", "binarychannel", "inputConnection", " inputStream", "errorChan", "errorCache", "outputCache", "outputStream", "inputCache", "errorStream", "inputStream", "outputchannel", "InputChannel", "requestStream", "requestCode", "Inputchannel", "fileConsole", "binaryChannel", "outputConsole", " inputChan", " inputCache", "outputChan", "InputChan", "inputGate", "inputQueue", "outputCode", "requestChan", "imageChan", "requestChannel", "imageChannel", "inputCode"], "outputChannel": ["Outputchannel", " outputchannel", "outputManager", "OutputQueue", " outputQueue", "OutputChannel", " outputManager", " outputButton", "outputQueue", "inputChan", "outStream", "outchannel", "outChan", "OutputStream", "writeQueue", " outputStream", "writeChannel", "outputStream", "outputchannel", "inputStream", " outputChan", "outputButton", "outButton", "writeStream", "writeManager", "outputChan", "OutputChan", "writeChan", "outChannel", "inputButton", "inputManager"], "length": ["base", "max", "sum", "buffer", "head", "duration", "id", "lock", "sequence", "slave", "current", "end", "result", "volume", "limit", "l", "join", "php", "child", "number", "last", "offset", "next", "form", "part", "session", "type", "load", "delay", "value", "len", "Length", "build", "section", "text", "size", "style", "complete", "start", "available", "full", "pull", "position", "partial", "with", "count", "block", "width"], "total": ["base", "max", "sum", "i", "translation", "duration", "id", "info", "current", "result", "limit", "set", "all", "otal", "done", "failed", "key", "last", "offset", "part", "less", "type", "no", "Total", "len", "used", "size", "complete", "start", "available", "toc", "full", "always", "partial", "count", "found", "multi", "scale", "error", "cur", "valid"]}}
{"id1": "16931472", "id2": "17901739", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "label": 1, "substitutes": {"handler": ["process", " callback", " fire", " finish", " rewrite", " setup", " handle", " serve", " init", " notify", " success", " complete", "handle", " response", " handling", " on", " processing", "callback", " fn", " next", " load", "Handler", " dispatch", " f", " done", " redirect", " transfer"], "result": ["match", "buffer", "output", "order", "view", "map", "dict", "page", "json", "cache", "complete", "group", "array", "response", "report", "message", "resource", "Result", "results", "manager", "row", "feature", "session", "data", "status", "record", "document", "table", "res", "list", "event", "re", "source"], "target": ["request", "next", "image", "favorite", "client", "template", "that", "the", "html", "master", "output", "class", "object", "layout", "proxy", "host", "theme", "owner", "version", "reference", "parent", "environment", "route", "page", "server", " Target", "tail", "connection", "content", "location", "response", "resource", "http", "manager", "link", "this", "base", "unit", "goal", "session", "data", "download", "type", "Target", "token", "database", "task", "it", "site", "external", "arget", "project", "style", "about", "event", "current", "source", "config"], "url": ["blog", "buffer", "service", "sl", "stream", "socket", "view", "feed", "user", "page", "server", "address", "connection", "http", "URL", "resource", "path", "io", "ssl", "file", "build", "str", "Url", "channel", "base", "loader", "org", "l", "browser", "string", "uri", "source"], "reader": ["iterator", "in", "writer", "buffer", "ner", "worker", "Reader", "stream", "rer", "i", "rc", "feed", "input", "e", "rx", "ry", "server", "ler", "http", "editor", "report", "io", "rr", "row", "reading", "file", "iter", "f", "ri", "err", "builder", "loader", "er", "over", "driver", "parser", "read", "layer", "bird"], "line": ["error", "sync", "lf", "key", "profile", "cell", "comment", "info", "str", "end", "link", "iter", "no", "base", "range", "ine", "text", "name", "body", "string", "non", "sl", "rl", "view", "user", "parse", "lined", "page", "rule", "home", "lines", "strip", "response", "message", "li", "file", "definition", "err", "live", "status", "l", "plugin", "lock", "look", "email", "el", "e", "id", "lc", "limit", "Line", "lin", "row", "liner", "o", "pe", "log", "cl", "frame", "nl", "point", "source", "lo", "side", "buffer", "block", "or", "code", "zip", "inline", "data", "LINE", "site", "style", "header", "le"], "entry": ["match", "writer", "service", "ner", "term", "element", "ie", "key", "cell", "rc", "feed", "owner", "layer", "e", "enter", "section", "page", "ry", "archive", "ener", "per", "or", "connection", "inner", "editor", "resource", "se", "exit", "value", "row", "part", "link", "ge", "data", "builder", "her", "ent", "entity", "Entry", "member", "string", "counter", "uri", "extra", "source"], "fromIndex": ["toOffset", "FromPoint", "fromSection", "sourcePoint", "fromPoint", "FromOffset", " fromLength", "fromLength", "toIndex", " fromPosition", "FromPosition", "toPosition", "fromPosition", "FromSection", " fromPoint", "FromIndex", "startOffset", "startPosition", "startLength", "toPoint", " fromSection", "startIndex", "sourcePosition", " fromOffset", "fromOffset", "FromLength", "sourceIndex", "sourceSection"], "r": ["lr", "fr", "m", "p", "ner", "attr", "rl", "q", "rc", "rs", "cr", "e", "ru", "rb", "array", "rr", "nr", "sr", "mr", "f", "ri", "u", "range", "b", "v", "er", "w", "vr", "l", "rg", "res", "ar", "d", "R", "re", "c", "pr"]}}
{"id1": "13852596", "id2": "2461169", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"execute": ["create", "handle", "ute", "install", "load", "copy", "register", "all", "evaluate", "Exec", "test", "call", "parse", "run", "submit", "process", "exec", "transfer", "code", "server", " perform", " invoke", "report", "invoke", "start", "apply"], "resources": ["ids", "pages", "thumbnails", "images", "maps", "issues", "groups", "services", "results", "events", "relations", "works", "cells", "items", "models", "Resources", "files", "features", "roots", "stores", "apps", "workers", "flows", "writers", "strings", "scripts", "chains", "rates", "archives", "rings", "stars", "objects", "classes", "ions", "series", "locks", "params", "users", "projects", "resource", "rules", "reports", "types", "plugins"], "i": ["f", "si", "ti", "ri", "iri", "s", "ori", "j", "info", "pi", "p", "k", "ie", "is", "hi", "bi", "di", "I", "u", "multi", "ami", "qi", "l", "e", "o", "ini", "abi", "cli", "ci", "we", "h", "xi", "oi", "v", "ui", "li", "ir", "uri", "ani", "ii", "io", "id", "iu", "mu", "vi", "ic", "eni", "gi", "ai", "phi", "esi", "ip", "wei", "isi"], "classFile": ["ClassFILE", "finalUrl", "ClassPath", "fileDirectory", "ruleFiles", "CLASSEntry", "ClassEntry", "connectionStream", "finalFile", "finalfile", "Classfile", "classClass", " classFactory", "classFilename", "sessionEntry", "CLASSImage", "classfile", " classFiles", "serviceFile", "ClassClass", " classfile", "ClassDir", "classFILE", "fileFiles", "customEntry", "ClassFiles", "lassGlobal", " classPage", "classFactory", "sessionFactory", "sessionFile", "lassClass", "ClassLine", "baseFile", "ClassPage", "CLASSFile", "classLine", "ruleFile", "staticfile", "ClassFactory", "sessionFiles", "lassFile", "classPath", "connectionFiles", "classFiles", "packEntry", " classStream", "customFiles", "classImage", "servicefile", "classEntry", "packfile", " classGlobal", "CLASSFILE", "sessionfile", "basefile", "ClassStream", " classFILE", "classStream", "classesFiles", "classLoader", "CLASSUrl", " classFilename", "classesFile", " classClass", "ClassImage", "CLASSfile", "ClassFile", "ClassGlobal", "objectDir", "fileImage", "CLASSLoader", "ClassFilename", "objectFile", "lassFiles", "objectfile", "baseFILE", "CLASSFiles", "CLASSDirectory", " classLine", "ruleFilename", " classLoader", " classPath", "baseUrl", "packFile", "customFILE", "ClassDirectory", "CLASSLine", "fileLine", "finalFILE", "customFile", "CLASSPage", "staticLine", "staticFile", "classPage", "connectionfile", "serviceLine", "staticFILE", "classDirectory", " classDir", "ruleLine", "classesfile", "serviceFILE", "sessionFILE", "classesPath", "fileLoader", "fileFile", "classDir", "connectionFile", " classEntry", "classGlobal", "objectFiles", "packFILE", "filefile", "classUrl"], "inputStream": ["binaryFile", "inputFile", "childstream", " inputstream", "inputSteam", "InputSw", "outputReader", "uploadFile", "outputFile", "initStream", "binaryStream", "initSteam", "outputSw", "childStream", "InputStream", " inputReader", "InputStreamer", "rawStreamer", "inputSw", "inputContext", "binaryStreamer", "outputStreamer", "binarySteam", "uploadSw", "inputStreamer", "childContext", " inputStreamer", "outputContext", "activeStreamer", "childReader", "rawStream", "rawSteam", " inputFile", "uploadStream", "importStream", "activestream", "activeStream", "initstream", "Inputstream", "InputFile", "uploadstream", "importSteam", " inputContext", "outputSteam", "rawFile", "initStreamer", "activeSteam", "InputSteam", "inputstream", "importstream", " inputSteam", "inputReader", "outputstream", "importStreamer"], "reader": ["iter", "er", "director", "manager", "ri", "handler", "book", "worker", "seed", "stream", "sync", "layer", "shared", "ger", "arser", "per", "rc", "copy", "keeper", "inner", "loader", "wrapper", "rer", "parser", "writers", "client", "key", "dr", "rr", "row", "buffer", "source", "ner", "entry", "oder", "war", "builder", "driver", "or", "request", "reflect", "system", "context", "reading", "read", "server", "author", "io", "owner", "http", "draft", "rar", "right", "resource", "input", "riter", "report", "re", "Writer", "ler", "ee", "Reader", "editor", "rx"], "oldSize": ["OldName", "oldName", "prevLength", "oldSc", "OldSize", "oldLength", "prevName", "prevSize", "OldSc", " oldLength", " oldName", "prevSc", " oldSc", "OldLength"], "writer": ["iter", "er", "director", "data", "manager", "widget", "handler", "writ", "worker", "creator", "string", "winner", "dc", "format", "maker", "writing", "w", "loader", "wrapper", "inner", "walker", "her", "r", "engine", "e", "parser", "writers", "row", "buffer", "ner", "service", "player", "oder", "war", "child", "builder", "driver", "write", "rw", "object", "document", "read", "author", "io", "element", "wr", "wire", "draft", "wer", "word", "index", "written", "resource", "token", "riter", "report", "Writer", "ler", "ee", "Reader", "editor"], "b": ["be", "abc", "bin", "bd", "f", "g", "m", "boot", "p", "k", "eb", "binary", "base", "bb", "u", "B", "w", "br", "l", "r", "e", "rb", "buffer", "d", "bar", "emb", "db", "lb", "ba", "h", "object", "null", "ab", "c", "a", "orb", "fb", "pb", "ob"], "outputStream": ["inputSteam", "outstream", "OutputSteam", "dataContainer", "protectedStreamer", "dataStream", " outputView", "outStream", "OutputStreamer", "protectedStream", "inputContainer", "outSteam", "dataStreamer", "inputView", "OutputStream", "outputStreamer", "Outputstream", "inputStreamer", " outputstream", "outStreamer", "protectedstream", "protectedSteam", " outputContainer", " outputSteam", "outputSteam", "outputView", "dataSteam", "inputstream", " outputStreamer", "outputstream", "outputContainer", "OutputView"], "injectedClasses": ["injectionclassies", "injectionClasses", "injectedWritites", "injectedclassites", "injectionClassites", "injectedClassies", "injectedClassites", "injectedProjecties", "injectedWrits", "injectedclasss", "injectionclasss", "injectedProjectes", "injectionClasss", "injectedProjects", "injectedWrites", "injectedWrities", "injectedClasss", "injectionclasses", "injectedProjectites", "injectionclassites", "injectionClassies", "injectedclassies", "injectedclasses"], "newSize": ["NewLength", "NewSize", "newFontSize", "finalLength", " newLength", " newFontSize", "NewFontSize", "finalSize", "newStorage", "finalFontSize", "NewStorage", "newLength", "finalStorage", " newStorage"]}}
{"id1": "947406", "id2": "23510383", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 1, "substitutes": {"copy": ["log", "clone", "download", "write", " Copy", "paste", "cop", "zip", "sync", "replace", "Cop", "cat", "csv", "clip", "split", "p", "cmp", "it", "dump", "Copy", "file", "transfer", "put", "get", "cp", " transfer", " cp"], "src": ["resource", "sub", "config", "stream", "input", "cur", "filename", "use", "href", "js", "string", "txt", "gb", "files", "dist", "rc", "stab", "rob", "sc", "source", "ource", "uri", "sb", "img", "ins", "sq", "sit", "rs", "name", "sel", "id", "data", "fn", "inst", "sl", "rb", "bh", "loc", "sin", "url", "s"], "dest": ["folder", "de", "wb", "die", "des", "temp", "done", "dat", " Dest", "target", "output", "later", "bin", "replace", "wd", "sup", "home", "comb", "txt", "class", "orig", "dist", "d", "st", "result", "opt", "flat", "img", "prop", "rest", "dir", "tmp", "name", "test", "Dest", "thin", "const", "desc", "delete", "destroy", "source", "obj"], "in": ["ini", "err", "kin", "base", "login", "this", "inner", "inn", "gin", "input", "download", "trans", "din", "In", "up", "bin", "b", "conn", "info", "url", "cf", "pin", "r", "IN", "again", "pass", "work", "nin", "it", "cin", "diff", "issue", "pull", "ins", "is", "as", "lin", "init", "a", "thin", "con", "id", "data", "rin", "isin", "lock", "i", "reader", "win", "vin", "lib", "m", "source", "socket", "inc", "s"], "out": ["ou", "err", "log", "index", "image", "o", "outer", "pool", "this", "inner", "w", "write", "plain", "net", "inc", "at", "obj", "our", "up", "exp", "cache", "or", "sync", "output", "OUT", "writer", "conn", "bin", "exit", "again", "outs", "source", "nin", "part", "io", "os", "x", "img", "Out", "client", "off", "app", "init", "ext", "data", "file", "vert", "user", "id", "call", "ex", "no", "timeout", "one", "lib", "aos", "exec", "socket"], "buf": ["num", "nb", "box", "raw", "br", "ff", "cur", "feat", "ref", "count", "queue", "bag", "uf", "b", "bytes", "bin", "cb", "pad", "cap", "bh", "bp", "c", "orig", "buff", "pos", "fab", "buffer", "rc", "fd", "fb", "bf", "bd", "p", "fl", "result", "v", "len", "block", "off", "bn", "data", "cv", "rb", "ctx", "seq", "batch", "loc", "uc", "bc", "f", "ab"], "n": ["z", "nd", "num", "index", "nb", "o", "j", "nt", "N", "w", "write", "nc", "ns", "count", "ne", "l", "b", "un", "c", "sn", "t", "d", "ind", "k", "p", "en", "nin", "v", "x", "number", "len", "nn", "nr", "length", "na", "size", "rn", "dn", "u", "no", "i", "ng", "m", "f", "max"]}}
{"id1": "1954410", "id2": "6403868", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    private File extractUninstallFiles(File _destPath, boolean upgrade, String lastVer) {\n        File oldlog = null;\n        try {\n            boolean oldClassCopied = false;\n            File destPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + VAGlobals.APP_VERSION);\n            if (upgrade) {\n                File lastVerPath = new File(_destPath, \"vai_\" + VAGlobals.APP_NAME + \"_\" + lastVer);\n                if (destPath.equals(lastVerPath)) {\n                    File bkdir = new File(destPath.getAbsolutePath() + \".bak\");\n                    if (!destPath.renameTo(bkdir)) {\n                        throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                    }\n                    oldlog = new File(bkdir.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                    lastVerPath = bkdir;\n                } else {\n                    oldlog = new File(lastVerPath.getAbsolutePath() + System.getProperty(\"file.separator\") + \"uninstall.vai\");\n                }\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n                if (uInfo_.module) oldClassCopied = copyOldSetupClass(lastVerPath, destPath);\n            } else {\n                if ((!destPath.exists()) && (!destPath.mkdirs())) {\n                    throw new IOException(VAGlobals.i18n(\"Setup_NotCreateDirectory\") + \" \" + destPath);\n                }\n            }\n            dirty_ = true;\n            File[] ls = destPath.listFiles();\n            for (int i = 0; i < ls.length; i++) {\n                if (!oldClassCopied) ls[i].delete(); else if (!ls[i].getPath().equals(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\")) ls[i].delete();\n            }\n            byte[] buf = new byte[0];\n            int read = 0;\n            if (!oldClassCopied && (installClassSize_ > 0 || jarOffset_ > 0)) {\n                final File outClassFile = new File(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                if (outClassFile.exists() && !outClassFile.delete()) {\n                    ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outClassFile.getName()));\n                }\n                final FileOutputStream out = new FileOutputStream(outClassFile);\n                final FileInputStream in = new FileInputStream(fileWithArchive_);\n                if (installClassOffset_ > 0) {\n                    in.skip(installClassOffset_);\n                }\n                buf = new byte[0];\n                if (installClassSize_ < 0) buf = new byte[(int) jarOffset_]; else buf = new byte[(int) installClassSize_];\n                read = in.read(buf, 0, buf.length);\n                out.write(buf, 0, read);\n                out.close();\n                in.close();\n            }\n            final FileInputStream in = new FileInputStream(fileWithArchive_);\n            if (jarOffset_ > 0) {\n                in.skip(jarOffset_);\n            }\n            JarInputStream jar = new JarInputStream(in);\n            final File outJarFile = new File(destPath.getAbsolutePath() + File.separator + \"install.jar\");\n            if (outJarFile.exists() && !outJarFile.delete()) {\n                ui_.showError(new Exception(VAGlobals.i18n(\"Setup_FileNotCreated\") + \":\\n\" + outJarFile.getName()));\n            }\n            JarOutputStream outJar = new JarOutputStream(new FileOutputStream(outJarFile));\n            ZipEntry entry = jar.getNextEntry();\n            final int bufSize = 32768;\n            buf = new byte[bufSize];\n            while (entry != null) {\n                String entryName = entry.getName();\n                if (entryName.equals(\"com/memoire/vainstall/resources/vainstall.properties\")) {\n                } else if (entryName.equals(installClassName_ + \".class\") && !oldClassCopied) {\n                    FileOutputStream out = null;\n                    try {\n                        out = new FileOutputStream(destPath.getAbsolutePath() + File.separator + installClassName_ + \".class\");\n                        VAGlobals.copyStream(jar, out, buf);\n                    } catch (IOException e) {\n                        throw e;\n                    } finally {\n                        if (out != null) out.close();\n                    }\n                } else if (!entryName.endsWith(\".zip\")) {\n                    if (VAGlobals.DEBUG) VAGlobals.printDebug(\"jar entry name \" + entryName);\n                    ZipEntry outEntry = new ZipEntry(entryName);\n                    CRC32 crc = new CRC32();\n                    outJar.putNextEntry(outEntry);\n                    int size = 0;\n                    while ((read = jar.read(buf, 0, bufSize)) >= 0) {\n                        size += read;\n                        if (read == 0) {\n                            Thread.yield();\n                        } else {\n                            outJar.write(buf, 0, read);\n                            crc.update(buf, 0, read);\n                        }\n                    }\n                    outEntry.setSize(size);\n                    outEntry.setCrc(crc.getValue());\n                    outJar.flush();\n                    outJar.closeEntry();\n                }\n                jar.closeEntry();\n                entry = jar.getNextEntry();\n            }\n            InputStream pin = getClass().getResourceAsStream(\"resources/vainstall.properties\");\n            Properties prop = new Properties();\n            try {\n                prop.load(pin);\n            } catch (IOException exc) {\n            }\n            if (language == null) language = \"default\";\n            prop.setProperty(\"vainstall.destination.language\", language);\n            ZipEntry outEntry = new ZipEntry(\"com/memoire/vainstall/resources/vainstall.properties\");\n            CRC32 crc = new CRC32();\n            outEntry.setCrc(crc.getValue());\n            outEntry.setSize(prop.size());\n            outJar.putNextEntry(outEntry);\n            prop.store(outJar, VAGlobals.NAME + \" \" + VAGlobals.VERSION);\n            outEntry.setCrc(crc.getValue());\n            outJar.closeEntry();\n            jar.close();\n            outJar.close();\n            in.close();\n        } catch (IOException e) {\n            String message = e.getLocalizedMessage();\n            message += \"\\n\" + VAGlobals.i18n(\"Setup_ErrorUninstallScripts\");\n            e.printStackTrace();\n            exitOnError(new IOException(message));\n        }\n        return oldlog;\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitExecute", "doExecApply", "submitexecuteApply", "doexecuteute", "doSendRun", "doexecuteRun", "submitexecuteRun", "doSendute", "doexecuteutes", "submitExecApply", "doSendutes", "submitExecutes", "doExecutes", "submitexecuteutes", "submitexecuteute", "doExecRun", "doexecuteApply", "doSendApply", "submitExecRun"], "mapping": [" mapper", " matching", "aminding", "matching", "minding", " minding", "finding", "fatching", "amapping", "fapping", "fapper", "mapper", "amatching", "amapper"], "form": ["feed", "builder", "Form", "formation", "flow", "owner", "pattern", "post", "component", "FORM", "config", "page", "object", "forms", " forms", "control", "format", "submit", "template", "transform", "url", "app", "command", "xml", "dom", "method", "field", "definition"], "request": ["path", "address", "input", "Request", "resource", "server", "self", "user", "uri", "add", "report", "message", "json", "HTTP", "current", "result", "instance", "s", "query", "ware", "queue", "req", "client", "Accept", "session", "reader", "type", "use", "q", "model", "application", "parent", "Reply", "data", "route", "Upload", "object", "requ", "context", "hello", "complete", "submit", "name", "format", "QUEST", "frame", "Bytes", "worker", "call", "pull", "url", "Response", "create", "_", "xml", "method", "this", "re", "view"], "response": ["handler", "server", "resource", "output", "report", "res", "message", "json", "result", "req", "client", "resp", "Resp", "model", "application", "data", "page", "object", "reply", "status", "Response", " Response", "v", "xml", " responses", "view"], "errors": ["mess", " messaging", " mess", " messages", " acc", " managers", " commands", " streams", " payload", " status", " session", " management", " problems", " events", " replies", " Messages", " flashes", " updates", " changes", " error", " messenger", " warnings", " calls", " translations", " this", " logger", " failures", " responses", " logs"], "isMultipart": ["isMultompart", "isMultippedart", "isMultompost", "isMultipage", "isMultiipPart", "isMultipound", "isMultipated", "isMultitart", "isMultipPart", "isMultiart", "isMultippedPart", "isMultIPart", "isMultippedost", "isMultiparts", "isMultiIPPart", "isMultompound", "isMultippage", "isMultIPound", "isMultompPart", "isMultiipart", "isMultIPost", "isMultiipound", "isMultitage", "isMultippated", "isMultiIPart", "isMultippedound", "isMultiage", "isMultIPPart", "isMultipparts", "isMultipost", "isMultippart", "isMultiIPound", "isMultiated", "isMultitated", "isMultiipost", "isMultitarts", "isMultiIPost", "isMultiarts"], "mailInstance": [" mailInst", " mailUsage", "mailinstance", " mailManager", "mailInst", " emailInst", "emailInst", " emailinstance", "fileUsage", "emailManager", "emailInstance", " emailUsage", "fileinstance", " emailInstance", "fileInst", " mailinstance", "emailinstance", "fileInstance", "mailManager", "mailUsage", "fileManager"], "fields": ["keys", "services", "maps", "headers", "input", "locks", "checks", "archives", "forces", "pages", "gets", "comments", "features", "holders", "posts", "qs", "s", "packs", "ids", "params", "parts", "changes", "states", "links", "uploads", "lines", "boxes", "flows", "strings", "loads", "ments", "users", "members", "tags", "data", "classes", "facts", "utils", "objects", "models", "plugins", "groups", "forms", "lists", "atts", "types", "cells", "rows", "details", "files", "dates", "acks", "rules", "words", "events", "properties", "views", "field"], "attachments": ["payments", "achresses", "achment", "attachment", "Attachps", "atters", "attps", "attachlements", "attachresses", "attments", "payresses", "suppees", "achparts", "attions", "extments", "Attachlements", "exters", "Attachions", "attachions", "payment", "Attachers", "achments", "attachers", "suppments", "Attachment", "attachparts", " attachment", "suppment", "attachees", "extions", "attlements", " attachresses", "Attachments", "supplements", "extps", "payparts", "attachps", "attment", "Attachees", "attees", " attachparts"], "items": ["keys", "locks", "pages", "results", "ers", "apps", "ins", "qs", "reports", "ids", "apters", "parts", "its", "links", "lines", "ops", "children", "Items", "orders", "data", "names", "objects", "plugins", "ips", "models", "es", "groups", "phones", "lists", "alls", "types", "rows", "files", "events", "list"], "iter": ["ite", "upper", "zip", "order", "event", "i", "itter", "outer", "master", "http", "slice", "inter", "inner", "oper", "end", "walker", "ter", "gener", "el", "loop", "er", "izer", "Iterator", "reader", "ner", "inc", "file", "ir", "li", "page", "ip", "ator", "iterator", "Iter", "keep", "edit", "coll", "chain", "exp", "it", "skip", "cher", "ver", "ser", "err", "ul", "finder", "former", "altern", "list", "enter", "loc"], "item": ["index", "original", "base", "handler", "temp", "resource", "token", "volume", "art", "file", "get", "example", "coll", "it", "url", "obj", "container", "custom", "element", "info", "server", "site", "result", "all", "next", "post", "source", "load", "up", "section", "page", "object", "ip", "plugin", "complete", "hop", "name", "full", "missing", "attribute", "service", "Item", "storage", "val", "event", "order", "i", "atom", "more", "entry", "slice", "inner", "anything", "er", "reader", "other", "or", "issue", "image", "app", "update", "api", "album", "user", "current", "instance", "extra", "type", "data", "li", "entity", "widget", "folder", "area", "layer"], "aux": ["anc", "ou", "pkg", "lang", "cmp", "axe", "ants", "ru", "sub", "abs", "off", "extra", "uf", "union", "ux", "except", "lc", "uc", "cas", "strings", "auc", "buf", "aff", "alias", " auxiliary", "au", "ups", "data", "etc", "ras", "amp", " Aux", "des", "aw", "aos", "offs", "asc", "af", "packages", "array", "frac", "sup", "prefix", "ox", "fax", "abc", "ext", "imp", "aus"], "part": ["val", "base", "class", "info", "id", "pi", "Part", "user", "add", "pre", "on", " Part", "act", "per", "ref", "join", "html", "l", "patch", "instance", "co", "PART", "joined", "key", "parts", "comp", "fact", "type", "back", "one", "player", "no", "art", "connection", "component", "diff", "ch", "group", "section", "parent", "data", "file", "object", "p", "format", "plugin", "po", "start", "change", "name", "but", "action", "pos", "word", "full", "area", "layer", "pair", "partial", "obj", "b", "and", "block", "f", "step", "error", "field", "element", "list", "point"], "baos": ["Bais", "BAos", "bois", "baOs", "pais", "Baosi", "boo", "bais", "hao", "baot", "boOS", "paOS", "haoss", "BAis", "abaos", "BAo", "hais", " bais", "paot", "BAoS", "BAOs", "Bao", "haos", " baoS", "BAoss", "bao", "baosh", " baot", " baOS", "BaoS", "paos", "BaOs", " bao", "baosi", "BAosh", "baoS", "abais", "BAosi", "Baos", "baOS", "abaosi", "boosh", "paosh", " baoss", "baoss", "abaOs", "boos", "pao", "boot"], "body": ["zip", "string", "translation", "fee", "headers", "output", "resource", "message", "description", "document", "json", "end", "html", "length", "shell", "query", "pass", "content", "parts", "params", "type", "source", "binary", "connection", "value", "media", "common", "data", "text", "options", "object", "size", "flash", "null", "Body", "reply", "name", "header", "template", "tree", "port", "full", "url", "comment", "b", "summary", "state"], "preferencesInstance": ["prefirmsClient", "prefeesInstance", "preferencesinstance", "preffeesClient", "prefferencesInstance", "prefirmsInstance", "prefeesinstance", "preferencesClient", "prefferencesClient", "prefeesClient", "prefirmsinstance", "prefferencesinstance", "prefiesClient", "prefiesinstance", "preffeesinstance", "prefiesInstance", "preffeesInstance"]}}
{"id1": "19849797", "id2": "2807585", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"copyFile": ["clonefile", "copyFiles", "transferfile", "copySource", "cloneFiles", "transferSource", " copySource", "transferFiles", " copyfile", "cloneSource", "transferFile", "copyfile", "cloneFile", " copyFiles"], "sourceFile": [" sourceDir", "ourceDirectory", "sourceUrl", "ourceUrl", "srcDir", "srcFile", " sourceFolder", "sourceFolder", "ourceFile", "SourceUrl", "srcfile", " sourcefile", "destfile", "SourceDirectory", "SourceFile", "ourcefile", "sourcefile", "sourceDirectory", "srcFolder", "destUrl", "Sourcefile", "SourceFolder", "destDirectory", "sourceDir", "SourceDir"], "destFile": ["destFiles", "targetFiles", "sourceFiles", "resultDir", "destLine", "DestFiles", " destfile", "destDir", "destPoint", "DestDirectory", "resultfile", "Destfile", "srcFile", "srcDir", "targetDir", "targetFile", "foreignFile", "srcfile", "foreignPath", "DestFile", "destPath", "targetfile", "DestPoint", "destfile", "targetLine", " destFiles", "targetPath", "foreignFiles", "resultFile", "DestDir", " destPoint", "foreignfile", " destDir", "srcDirectory", " destDirectory", "DestPath", "resultLine", "sourcePoint", "destDirectory", "srcFiles", "sourceDir", "srcLine"], "source": ["ource", "slave", "url", "result", "client", "reader", "cache", "status", "scope", "output", "site", "use", "id", "view", "current", "proxy", "scene", "index", "input", "target", "session", "start", "context", "core", "seed", "remote", "stream", "inner", "secure", "image", "Source", "this", "si", "storage", "component", "reference", "connection", "ie", "root", "route", "null", "object", "parent", "sin", "dest", "config", "slice", "table", "uri", "service", "resource", "api", "wrapper", "iter", "get", "from", "channel", "file", "server", "src", "unit", "size", "manager", "ce", "SOURCE"], "destination": ["participinate", "destinator", "generination", "Destinated", "dominated", "constinator", "identination", "distination", "construction", "distion", "participinator", "Destination", "domination", " destribution", "constribution", "domation", "Destribution", "Destruction", "destribution", " destinator", "destation", "Destation", "generruction", "destion", "identinator", "destinate", " destruction", "participinated", " destinated", " destation", "destinated", "participination", "distruction", "destruction", "dominator", "distinated", "distinator", "Destion", " destion", "Destinate", "constination", "generinator", "identinate", "generinated", "Destinator", "identinated"]}}
{"id1": "1362", "id2": "5951961", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            URL url = new URL(args[0]);\n            HttpURLConnection httpCon = (HttpURLConnection) url.openConnection();\n            httpCon.setDoOutput(true);\n            httpCon.setRequestMethod(\"PUT\");\n            OutputStreamWriter out = new OutputStreamWriter(httpCon.getOutputStream());\n            out.write(\"fatal error\");\n            out.close();\n            System.out.println(\"end\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["bubblerCompare", "bubblesOrder", "bubblerOrder", "ubbleSort", "ubbleOrder", "bubblerSort", "ubblingOrder", "ubblesort", "ubblingsort", "ubblingSort", "ubblingCompare", "bubblesort", "bubbleOrder", "bubblessort", "bubblesCompare", "bubblingCompare", "bubblingSort", "bubblersort", "bubblesSort", "bubblingsort", "ubbleCompare", "bubblingOrder", "bubbleCompare"], "a": ["active", "f", "data", "sup", "oa", "at", "something", "s", "ack", "m", "aa", "aaa", "ma", "array", "p", "aux", "auto", "na", "any", "ae", "another", "ama", "ans", "u", "abs", "b", "all", "am", "A", "img", "access", "apps", "aj", "l", "work", "e", "o", "la", "va", "address", "d", "list", "ata", "ba", "empty", "aw", "sa", "an", "ab", "as", "c", "ga", "index", "result", "tta", "ad", "area", "alpha", "ac", "au"], "swapped": ["swoped", "Swoped", " swaped", "wap", "swap", "flapped", "Swaped", "Swap", "wapping", "swaps", " swapping", "rewaps", " swap", "waped", "Swapping", "swapping", " swaps", "rewaped", "rewapping", "swaped", "flap", "floped", "rewapped", "waps", "rewap", "flapping", "Swapped", "rewoped", "wapped"], "i": ["x", "f", "y", "sup", "si", "it", "start", "ti", "ri", "mini", "iv", "m", "p", "j", "info", "pi", "k", "ori", "ind", "ie", "ix", "hi", "I", "bi", "u", "b", "ami", "di", "multi", "qi", "l", "fi", "e", "key", "ini", "d", "anti", "ci", "init", "api", "h", "ki", "xi", "v", "mi", "ui", "oi", "next", "li", "uri", "ii", "io", "in", "ni", "id", "index", "iu", "module", "eni", "ai", "gi", "adi", "uni", "ip"], "tmp": ["x", "f", "sup", "opp", "stuff", "addr", "qq", "m", "emp", "st", "p", "j", "ie", "tv", "bb", "prev", "part", "b", "yy", " ff", "alpha", "txt", "front", "pre", "angle", "dest", "pp", "temp", "test", "xxx", "cmp", "vt", "mmm", "t", "tt", "v", "mp", "amp", "tc", "kk", "append", "pad", "area", "foo", "obj", "nb"]}}
{"id1": "7087108", "id2": "1598693", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    public static String retrieveData(URL url) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"User-agent\", \"MZmine 2\");\n        InputStream is = connection.getInputStream();\n        if (is == null) {\n            throw new IOException(\"Could not establish a connection to \" + url);\n        }\n        StringBuffer buffer = new StringBuffer();\n        try {\n            InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n            char[] cb = new char[1024];\n            int amtRead = reader.read(cb);\n            while (amtRead > 0) {\n                buffer.append(cb, 0, amtRead);\n                amtRead = reader.read(cb);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        is.close();\n        return buffer.toString();\n    }\n", "label": 0, "substitutes": {"doGet": ["processDownload", "processGET", "doGET", " doGET", " doPut", "doPut", "doDownload", "didGET", "didPut", "processGet", "processPut", "didGet", " doDownload", "didDownload"], "request": ["error", "client", "buffer", "self", "query", "host", "view", "object", "use", "context", "user", "input", "instance", "version", "parent", "route", "server", "json", "complete", "child", "info", "result", "target", "connection", "http", "resource", "report", "message", "xml", "url", "req", "forward", "this", "model", "data", "type", "builder", "subject", "application", "method", "name", "Request", "external", "reader", "project", "string", "web", "QUEST", "uri", "event", "current", "create", "config", "condition"], "response": ["image", "client", "writer", "service", "output", "reply", "view", "object", "version", "reference", "page", "server", "json", "cache", "example", "result", "connection", "content", "http", "resource", "message", "report", "results", "Response", "out", "resp", "model", "collection", "status", "application", "wave", "method", "document", "site", "remote", "respond", "body"], "path": ["image", "PATH", "p", "key", "output", "pattern", "object", "route", "id", "directory", "cache", "info", "format", "Path", "location", "content", "http", "message", "resource", "index", "out", "value", "config", "dir", "url", "base", "data", "text", "method", "name", "ath", "string", "filter", "point", "folder", "uri", "filename"], "file": ["image", "h", "full", "files", "up", "class", "socket", "object", "use", "feed", "route", "directory", "handler", "File", "rule", "fe", "info", "to", "child", "connection", "http", "resource", "fp", "out", "function", "FILE", "work", "part", "dir", "f", "url", "lib", "base", "zip", "data", "pe", "b", "log", "local", "it", "name", "l", "le", "folder", "uri", "lock", "source", "filename"], "in": ["r", "pin", "inn", "stream", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "copy", "thin", "id", "din", "ax", "lin", "inner", "resource", "nin", "out", "ini", "con", "kin", "rin", "f", "binary", "serv", "login", "data", "ac", "b", "it", "ins", "bin", "In", "reader", "IN", "as", "win", "source", "c", "inc"]}}
{"id1": "3731077", "id2": "7425022", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private String transferWSDL(String wsdlURL, String userPassword) throws WiseConnectionException {\n        String filePath = null;\n        try {\n            URL endpoint = new URL(wsdlURL);\n            HttpURLConnection conn = (HttpURLConnection) endpoint.openConnection();\n            conn.setDoOutput(false);\n            conn.setDoInput(true);\n            conn.setUseCaches(false);\n            conn.setRequestMethod(\"GET\");\n            conn.setRequestProperty(\"Accept\", \"text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5\");\n            conn.setRequestProperty(\"Connection\", \"close\");\n            if (userPassword != null) {\n                conn.setRequestProperty(\"Authorization\", \"Basic \" + (new BASE64Encoder()).encode(userPassword.getBytes()));\n            }\n            InputStream is = null;\n            if (conn.getResponseCode() == 200) {\n                is = conn.getInputStream();\n            } else {\n                is = conn.getErrorStream();\n                InputStreamReader isr = new InputStreamReader(is);\n                StringWriter sw = new StringWriter();\n                char[] buf = new char[200];\n                int read = 0;\n                while (read != -1) {\n                    read = isr.read(buf);\n                    sw.write(buf);\n                }\n                throw new WiseConnectionException(\"Remote server's response is an error: \" + sw.toString());\n            }\n            File outputDir = new File(wiseProperties.getProperty(\"wise.tmpDir\"));\n            if (!outputDir.exists()) {\n                outputDir.mkdir();\n                wiseProperties.setProperty(\"wise.forceImportObject\", \"true\");\n            }\n            File file = new File(wiseProperties.getProperty(\"wise.tmpDir\"), new StringBuffer(\"Wise\").append(IDGenerator.nextVal()).append(\".xml\").toString());\n            OutputStream fos = new BufferedOutputStream(new FileOutputStream(file));\n            IOUtils.copyStream(fos, is);\n            fos.close();\n            is.close();\n            filePath = file.getPath();\n        } catch (WiseConnectionException wce) {\n            throw wce;\n        } catch (Exception e) {\n            throw new WiseConnectionException(\"Wsdl download failed!\", e);\n        }\n        return filePath;\n    }\n", "label": 1, "substitutes": {"copyFile": ["copyFiles", "transferSourceFile", "transferfile", "importFile", "transferFiles", "copySourceFile", " copyfile", "importSourceFile", "importfile", "transferFile", "importFiles", "copyfile", " copySourceFile", " copyFiles"], "from": ["address", "url", "base", "client", "ca", "left", "id", "io", "old", "path", " form", "of", "remote", "start", "name", "range", "original", "c", "this", "or", "at", "a", "user", "front", "ce", "o", "with", "back", "config", "without", "resource", "add", "by", "form", "source", "before", "file", "se", "data", "From", "d", "src", "about", "origin", "part", "as", "f"], "to": ["two", "eto", "base", "client", "token", "output", "site", "io", "one", "of", "TO", "target", "temp", "location", "auto", "name", "top", "this", "database", "toc", "storage", "os", "or", "t", "at", "type", "root", "b", "null", "parent", "To", "so", "o", "dest", "object", "with", "again", "socket", "office", "api", "p", "by", "copy", "into", "point", "source", "too", "file", "about", "until", "as", "size", "f", "po"], "parentDir": ["ParentFolder", "ParentDir", " parentdir", "rootDirectory", "rootFolder", "parentDirectory", "currentDir", "outDir", "outFolder", " parentFolder", "currentdir", "ParentDirectory", "ParentFile", "Parentdir", "parentFile", "outFile", "outDirectory", " parentDirectory", " parentFile", "currentFolder", "rootDir", "rootFile", "currentFile", "parentdir", "parentFolder"], "in": ["exec", "url", "gin", "ins", "din", "reader", "IN", "login", "bin", "id", "pre", "io", "inc", "isin", "vin", "ini", "plugin", "input", "In", "conn", "on", "inner", "image", "err", "m", "or", "ie", "i", "r", "trial", "again", "o", "rec", "fc", "sync", "diff", "with", "nin", "win", "inn", "min", "it", "pin", "form", "rc", "cin", "l", "source", "work", "lin", "init", "kin", "inside", "arin", "pc", "rin", "con", "ac", "part"], "out": ["net", "exec", "gin", "ico", "OUT", "client", "outs", "cy", "w", "call", "output", "bin", "app", "ot", "io", "inc", "ou", "plugin", "input", "on", "conn", "auto", "inner", "c", "off", "Out", "org", "or", "at", "writer", "user", "again", "ex", "o", "co", "sync", "win", "outer", "option", "p", "other", "cin", "vert", "channel", "op", "init", "about", "ac", "can"], "ic": ["bc", "lc", "cl", "mc", "ico", "ai", "uc", "io", "inc", "input", "iac", "conn", "auto", "IC", "ci", "c", "cc", "or", "ec", "ct", "i", "acs", "irc", "icc", "ex", "cu", "cs", "voc", "o", "co", "enc", "ig", "aic", "fc", "ics", "loc", "anc", "cus", "sync", "dc", "ix", "pic", "cin", "vc", "ik", "op", "rc", "pc", "ac", "nic", "xc"], "oc": ["OC", "bc", "oco", "ocon", "aco", "mc", "cy", "uc", "ca", "can", "oca", "ob", "io", "inc", "circ", "cur", "roc", "oci", "soc", "ci", "c", "cc", "og", "toc", "nic", "wic", "alloc", "org", "or", "ec", "i", "acs", "voc", "o", "co", "fc", "loc", "enc", "mic", "anc", "cus", "aic", "dc", "ocol", "vc", "op", "sc", "pc", "ac", "ack", "AC", "xc"]}}
{"id1": "1180878", "id2": "812803", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["frieveUrldata", "fetchURLDATA", "frieveURLDATA", "fetchJSONData", "frieveUrlDATA", "fetchHTTPDATA", "fetchUrldata", "fetchURLdata", "fetchUrlDATA", "frieveURLdata", "fetchHTTPdata", "fetchUrlData", "frieveURLData", "fetchHTTPData", "fetchJSONdata", "fetchJSONDATA", "frieveUrlData"], "url": ["image", "html", "URL", "base", "resource", "feed", "www", "view", "download", "Url", "ls", "http", "text", "src", "filename", "l", "href", "api", "page", "string", "path", "fl", "source", "uri", "xml", "ur", "name", "location", "ssl", "server", "data", "file", "user", "gl", "username", "sl", "el", "connection", "loc", "host", "f", "address"], "proxyHost": ["cacheHost", " proxyServer", "serverAddress", "serverPath", " proxyAddress", "baseHost", "baseDomain", "remoteAddress", "proxyHead", "baseAddress", "ProxyHead", "remoteDomain", "ProxyHost", " proxyPath", "proxyhost", "serverServer", " proxyhost", "proxyDomain", "baseHead", "ProxyDomain", "ProxyServer", "cachePort", "proxyPath", "remoteHead", "ProxyPath", "proxyAddress", "proxyServer", "cachehost", "cacheAddress", "ProxyPort", "ProxyAddress", "remoteHost", "Proxyhost", "serverHost"], "proxyPort": ["cacheHost", " proxyServer", " proxyport", " proxyAddress", "httpPort", "ProxyHost", "httpServer", "httpAddress", "cachePort", "Proxyport", "ProxyServer", "cacheport", "proxyAddress", "proxyServer", "proxyport", "cacheAddress", "ProxyPort", "ProxyAddress", "httpHost"], "con": ["com", "fa", "ls", "rec", "ch", "c", "cf", "rc", "ci", "per", "uc", "connection", "cr", "f", "login", "cl", "pc", "cur", "ca", "cache", "run", "sync", "conn", "CON", "ran", "co", "ocon", "cone", "connect", "go", "win", "re", "conv", "change", "sub", "fac", "fun", "don", "common", "pre", "cons", "fc", "remote", "un", "an", "x", "out", "xc", "Con", "pub", "cn", "on", "gen", "mc", "cp", "ec", "inc", "exec", "conf", "socket", "ver", "canon", "func", "can", "syn", "open", "pen", "ctrl", "http", "act", "pin", "fl", "en", "part", "ai", "min", "cc", "cas", "close", "cm", "ac", "n", "bc", "fan"], "is": ["ib", "its", "in", "can", "serv", "isi", "vs", "abs", "ops", "mis", "cms", "ir", "lis", "has", "does", "api", "info", "conn", "isu", "ws", "IS", "js", "ri", "act", "sp", "state", "ps", "was", "ie", "p", "ci", "ris", "si", "os", "it", "cs", "oss", "ai", "out", "isa", "isl", "fs", "iss", "cos", "il", "as", "es", "iso", "are", "bis", "us", "ori", "bs", "isin", "id", "isc", "ios", "Is", "i", "im", "get", "ais", "or", "ar", "iris", "ics", "s"], "u": ["ou", "o", "q", "U", "ul", "up", "ue", "http", "cu", "ut", "l", "un", "b", "ui", "uv", "api", "conn", "uci", "c", "m", "p", "io", "su", "uri", "os", "v", "client", "hu", "fu", "ur", "nu", "us", "h", "user", "file", "yu", "tu", "iu", "i", "uc", "ru", "lu", "f"], "proxy": ["force", "pool", "resource", "create", "clone", "phone", "pc", "fe", "http", "zip", "cache", "cop", " Proxy", "l", "api", "remote", "prot", "XY", "c", "pe", "pin", "Proxy", "pa", "plus", "p", "type", "xy", "uri", "x", "roxy", "ip", "client", "pse", "ssl", "bean", "wrapper", "server", "shadow", "port", "timeout", " proxies", "lib", "connection", "config", "host", "web", "f", "socket", "copy", "address"], "baos": ["abis", "baOS", "caas", "caos", "haOS", "bao", "bais", "BAOS", "BAos", "BAis", "pao", "boOS", "hao", "BaOs", "Baos", "boas", "haos", "calos", "caOS", "paOS", "Bais", "balos", "paos", "baas", "boos", "abOs", "abros", "BAo", "baOs", "aas", "bolos", "Baros", "pais", "hais", "alos", "baros", "BAOs", "aos", "aOS", "abos", "BAros"]}}
{"id1": "23161545", "id2": "22135199", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public void testCodingEmptyFile() throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        WritableByteChannel channel = newChannel(baos);\n        HttpParams params = new BasicHttpParams();\n        SessionOutputBuffer outbuf = new SessionOutputBufferImpl(1024, 128, params);\n        HttpTransportMetricsImpl metrics = new HttpTransportMetricsImpl();\n        LengthDelimitedEncoder encoder = new LengthDelimitedEncoder(channel, outbuf, metrics, 16);\n        encoder.write(wrap(\"stuff;\"));\n        File tmpFile = File.createTempFile(\"testFile\", \"txt\");\n        FileOutputStream fout = new FileOutputStream(tmpFile);\n        OutputStreamWriter wrtout = new OutputStreamWriter(fout);\n        wrtout.flush();\n        wrtout.close();\n        FileChannel fchannel = new FileInputStream(tmpFile).getChannel();\n        encoder.transfer(fchannel, 0, 20);\n        encoder.write(wrap(\"more stuff\"));\n        String s = baos.toString(\"US-ASCII\");\n        assertTrue(encoder.isCompleted());\n        assertEquals(\"stuff;more stuff\", s);\n        tmpFile.delete();\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandGID", "getRandGid", "getRandomGCID", "getRandGUID", "getRandUid", "getRandomGid", "getRandUuid", "getRandomGCid", "getRandomGID", "getRandGuid", "getRandomGCuid", "getRandomIGID", "getRandUID", "getRandomUUID", "getRandomIGUID", "getRandomUID", "getRandomGCUID", "getRandUUID", "getRandomIGid", "getRandomUuid", "getRandomIGuid", "getRandomGuid", "getRandomUid"], "secure": ["encrypted", "force", "service", "stable", "depth", "sensitive", "debug", "deep", "Secure", "active", " insecure", "zip", "sec", "random", "remote", "use", "protect", "safe", "session", "external", "pure", "confirmed", "weak", "require", "https", "allow", "ce", "secret", "ssl", "unsigned", "secondary", "proxy", "sr", "smart", "server", "seed", "exclusive", "security", "timeout", "config", "host"], "md5": [" mdql", "MD512", " md500", "MD500", "MD5", " MD500", " MD2", "md512", "cmd5", " md512", "md2", " md2", "mdql", " MD5", "MDql", "md11", " md3", "MD3", "MD2", "md500", "cmdql", "MD11", " MD11", " MD3", "cmd512", " md11", "cmd3", "md3"], "sbValueBeforeMD5": ["sbValueBeforeMS0", "sbValuebeforeSD20", "sbValueGivenmd5", "sbValueBeforeSHA005", "sbValueBeforeMAC0", "sbValueBeforeMS3", "sbValueBeforeMAC55", "sbValueBeforeMI5", "sbValueBeforeMD3", "sbValueBeforeMD20", "sbValueAfterMP3", "sbValueBeforeDER1", "sbValueBeforeD3", "sbValueBeforeSD20", "sbValueGivenmd375", "sbValuebeforeMD5", "sbValueBeforeMD7", "sbValueBeforeMC5", "sbValueAfterMS0", "sbValueBeforeMS95", "sbValuebeforeSD1", "sbValueAfterMD20", "sbValueBeforeMI3", "sbValueAfterMD25", "sbValueGivenMD3", "sbValuebeforeSD5", "sbValueBeforeAMD3", "sbValueBeforeMD512", "sbValueAfterMD65", "sbValueBeforeAMD5", "sbValueBeforeMS512", "sbValueBeforemd3", "sbValueBeforeMP5", "sbValueBeforeDER005", "sbValueAfterMS65", "sbValueBeforeMD005", "sbValueAfterMS20", "sbValueAfterMS25", "sbValueBeforeMS75", "sbValueBeforeSD005", "sbValueAfterMS5", "sbValueBeforeMI7", "sbValueAfterMD3", "sbValueBeforeMD0", "sbValueBeforeMP3", "sbValueBeforeDER3", "sbValueBeforemd375", "sbValueBeforeMD55", "sbValueBeforeMD25", "sbValueBeforemd65", "sbValueAfterMS1", "sbValueGivenmd3", "sbValueBeforeMR3", "sbValueBeforemd512", "sbValueAfterMD1", "sbValueBeforeMS375", "sbValueBeforeAMD20", "sbValuebeforeMD1", "sbValueBeforeMD65", "sbValueAfterMD55", "sbValueBeforeDER55", "sbValueBeforeMD75", "sbValueBeforeSHA20", "sbValueBeforeDER0", "sbValueBeforeMD95", "sbValueAfterMP5", "sbValuebeforeSD005", "sbValueBeforeDER5", "sbValueBeforeMP7", "sbValueBeforeD65", "sbValueAfterMS95", "sbValueAfterMS55", "sbValueGivenmd512", "sbValueBeforeSD5", "sbValueAfterMD75", "sbValueBeforeAMD1", "sbValueBeforeMI1", "sbValueBeforeMS5", "sbValueBeforeMI20", "sbValueBeforeSHA5", "sbValueBeforemd75", "sbValueBeforeMS20", "sbValueBeforeMR25", "sbValueAfterMP1", "sbValueAfterMS75", "sbValueBeforeMR5", "sbValueBeforeSD1", "sbValueBeforeMP1", "sbValueBeforemd95", "sbValueBeforeMD1", "sbValueAfterMP7", "sbValueBeforeMAC5", "sbValueBeforeSHA1", "sbValueBeforeMC512", "sbValueBeforemd25", "sbValueBeforeMC375", "sbValueAfterMD0", "sbValueBeforeD5", "sbValueGivenMD375", "sbValueBeforeDER20", "sbValueBeforemd5", "sbValueAfterMS3", "sbValuebeforeMD20", "sbValueGivenMD5", "sbValueBeforeD75", "sbValuebeforeMD005", "sbValueBeforeMS65", "sbValueBeforeMS55", "sbValueBeforeMS25", "sbValueAfterMD7", "sbValueBeforeMD375", "sbValueAfterMD5", "sbValueBeforeMAC3", "sbValueBeforeMS1", "sbValueBeforeMR95", "sbValueBeforeMC3", "sbValueAfterMD95", "sbValueGivenMD512", "sbValueBeforeMS7"], "time": ["Time", "depth", "offset", "event", "cost", "duration", "version", "mode", "count", "times", "random", "slice", "rate", "speed", "race", "tz", "clock", "TIME", "work", "type", "year", "counter", "length", "size", "start", "name", "ime", "tim", "id", "user", "seed", "money", "value", "error", "etime", "date", "timeout", "timer", "delay", "hour", "loc", "host"], "rand": ["rule", "index", "right", "q", "depth", "root", "bot", "order", "pick", "serial", "version", "alpha", "count", "round", "bit", "random", "rate", "chance", "risk", "r", "rage", "ro", "rc", "winner", "lang", "type", "year", "Rand", "rr", "rh", "min", "raid", "clean", "mid", "id", "range", "seed", "gen", "error", "win", "ng", "rank", "delay", "reg", "rol", "res", "cr", "max"], "valueBeforeMD5": ["valueInsideMD85", "valueBeforeAMD5", "valueBeforeMC5", "valueAfterMD2", "valueBeforeMD2", "valueInsideMD3", "valueBeforemd5", "valueBeforeMD53", "valueBeforeAMD3", "valueInsideMD2", "valueAfterAMD3", "valueBeforemd3", "valueBeforeMP3", "valueBeforemd2", "valueAfterMD53", "valueBeforeMD3", "valueAfterMD3", "valueBeforeMC3", "valueBeforeMC2", "valueBeforeAMD2", "valueAfterAMD53", "valueBeforeMD85", "valueBeforemd85", "valueAfterAMD2", "valueInsideMD5", "valueAfterAMD5", "valueBeforeMP53", "valueBeforeMC85", "valueBeforeAMD53", "valueBeforeMP5", "valueBeforeMP2"], "array": ["image", "shape", "section", "storage", "view", "integer", "sample", "audio", "arr", "function", "our", "message", "cache", "pair", "area", "api", "list", "object", "string", "element", "collection", "vector", "Array", "record", "result", "allow", "number", "row", "any", "expression", "app", "arrow", "ray", "archive", "range", "data", "binary", "instance", "value", "error", "angle", "database", "feature", "batch", "air", "address"], "sb": ["ib", "wb", "nb", "bsp", "kb", "bm", "lr", "eb", "zb", "bl", "SB", "sa", "xb", "src", "bb", "cb", "ruby", "usb", "bp", "lp", "buf", "gb", "abb", "buffer", "stab", "fb", "lb", " SB", "bf", "rob", "si", "obb", "sg", "sv", "nn", "sq", "orb", "pb", "bt", "lab", "bs", "ob", "binary", "sbm", "sf", "sth", "sl", "rb", "mb", "bc", "bh", "bj", "BB", "ab", "s"], "j": ["z", "aj", "num", "index", "o", "q", "end", "jl", "ii", "dy", "key", "l", "ch", "jp", "js", "pr", "code", "c", "uj", "g", "d", "k", "li", "job", "ie", "p", "part", "ja", "v", "x", "ji", "out", "y", "length", "jj", "jo", "J", "e", "adj", "i", "ij", "n", "bj", "br", "f", "obj"], "b": ["ib", "nb", "BB", "eb", "bit", "l", "bb", "bin", "cb", "c", "d", "k", "be", "fb", "job", "p", "lb", "bi", "x", "y", "B", "bug", "orb", "pb", "bar", "a", "bs", "ob", "binary", "e", "i", "rb", "mb", "n", "bc", "bf", "br", "db", "f", "ab"], "valueAfterMD5": ["valueAfterMD2", "valueAfterVM5", "valueAfterMP2", "valueBeforeMD2", "valueAfterAMD7", "valueAfterMP7", "valueAfterAMD3", "valueAfterVM7", "valueAfterMD7", "valueBeforeMP3", "valueAfterVM3", "valueBeforeMD3", "valueBeforeMD7", "valueAfterMD3", "valueAfterVM2", "valueBeforeMP5", "valueAfterMP5", "valueAfterAMD2", "valueAfterAMD5", "valueBeforeMP7", "valueAfterMP3", "valueBeforeMP2"]}}
{"id1": "9275622", "id2": "11334468", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"copyFile": ["moveFolder", "copyFiles", " copyfile", "copyFolder", "transferFile", "transferFolder", "moveFiles", "transferfile", " copyFiles", " copyFolder", "transferFiles", "movefile", "copyfile", "moveFile"], "_file1": ["_files1", "_files01", "_File2", "_fileone", "_resourceOne", "_mail2", "_file0", "_resource1", "_fFirst", "_resourceone", "_zip1", "_zipFirst", "_fileOne", "_zipOne", "_file01", "_fone", "_fOne", "_File0", "_f1", "_mail1", "_File01", "_mail0", "_File1", "_mail01", "_zipone", "_files2", "_files0", "_resourceFirst", "_fileFirst"], "_file2": ["_files4", "_filesecond", "_Filesecond", "_File5", "_File2", "jfile1", "_file4", " _filesTwo", " _files3", "jmodelsecond", "_model1", "_model5", "_file5", "_modelsecond", "_files3", "_file3", "jfile5", "_play2", "jfilesecond", " _file3", "_playTwo", "jmodel1", "jmodel5", "_play1", "_model2", "_playsecond", "_filesTwo", "_fileTwo", "_File1", "_play5", " _files4", "_files2", "_play4", " _file4", " _fileTwo", "jfile2", "_play3", "jmodel2", " _files2"], "fis": ["fiss", "infiss", "lfais", "lfi", "afis", "cfos", " fris", "afais", "cfiss", "lfis", "cfas", "Fils", " fais", "infils", "afiss", "fi", "Fas", "Fis", " fi", "fils", "infos", "Fiss", "fas", " fiss", "afi", " fils", "lfiss", "Fos", "fris", "Fris", "fais", "cfis", "cfris", "infis", " fas"], "fos": ["infaos", "Fo", "fus", "infus", "Foos", "Foses", "foses", "infios", "feos", "floes", "goses", "Fus", "info", " foos", "fOS", "flis", "infros", "gis", "Faos", "Fros", " fus", "gos", "feoses", "foes", "pis", "Fios", "Fis", "infoos", "infos", "fros", "poes", " faos", "pOS", "feus", "fios", "Fos", "pos", "feis", "foos", " fo", "flOS", " fios", "los", "lis", "faos", "lOS", "flos", "fo", " fros", "loes", "gus"], "canalFuente": ["canalBuence", "canalCraencia", "canaledBuje", "canaledBuze", "canalKuze", "canallBuente", "canallFuente", "canalBuento", "canalFuze", "canalsBuence", "canaledBuente", "canalSuente", "canalFuento", "canallBuence", "canalsFuente", "canalBuente", "canalBuje", "canalSuje", "canalFUje", "canaledFuente", "canalSuestro", "canaledFuestro", "canallFuze", "canalsFuence", "canalsBuento", "canalFUestro", "canalFuencia", "canalKuence", "canalsFuencia", "canalFUente", "canalBuencia", "canaledBuestro", "canaledFuje", "canalKuento", "canalsFuento", "canalFuje", "canallBuze", "canallFuence", "canalsBuencia", "canaledFuze", "canalBuestro", "canallFuencia", "canalKuente", "canalKuencia", "canalFuence", "canalFUencia", "canalSuze", "canalCraence", "canalsBuente", "canalFUze", "canalCraente", "canalCraento", "canalFUence", "canalBuze", "canallBuencia", "canalFuestro"]}}
{"id1": "3558512", "id2": "812803", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"serialize": ["Serialze", "finalze", "Serialize", " serialze", "erialize", "Serialized", "erialze", "Serialization", "Serialify", "serialze", " serialization", "serializable", "erialization", "normalify", "normalized", "finalize", "normalze", "serialify", "finalized", "finalify", "erializable", "Serializable", "serialized", "serialization", "normalize", " serializable"], "out": ["exec", "OUT", "png", "outs", "cache", "client", "w", "gen", "output", "bin", "io", "raw", "filename", "name", "string", "obj", "conn", "archive", "image", "err", "Out", "writer", "i", "report", "a", "ex", "parent", "o", "loader", "buffer", "content", "copy", "page", "data", "pool", "file", "up", "source", "server", "dump", "temp"], "parser": ["test", "processor", "base", "master", "reader", "system", "cache", "builder", "parse", "php", "lp", "tt", "worker", "xml", "plugin", "arser", "er", "seed", "cp", "pkg", "upload", "writer", "pe", "Parser", "class", "parent", "handler", "pillar", "per", "loader", "p", "wrapper", "copy", "file", "up", "server", "instance", "rar", "pp", "ss", "as", "txt", "manager"], "on_disk": ["onJdemand", "onnetfile", "onnetspace", "off_space", "off_delete", "onbootlock", "on_lock", "onbookdelete", "off_lock", "on_file", "off_drive", "onjspace", "off_storage", "onbootdrive", "onJdrive", "onbootdisk", "on_drive", "onJlock", "onjdrive", "onJdisk", "onbootstorage", "off_demand", "onbookdrive", "off_disk", "onjfile", "onbookdisk", "on_storage", "onnetdemand", "onjdisk", "on_demand", "onnetdisk", "on_delete", "onnetdrive", "on_space", "off_file"], "in": ["ins", "thin", "din", "reader", "IN", "login", "bin", "inc", "ini", "input", "In", "conn", "inner", "stream", "c", "inas", "ax", "i", "connection", "info", "r", "again", "o", "socket", "win", "inn", "min", "pin", "copy", "data", "lin", "file", "source", "kin", "rin", "pass", "con", "ac", "as", "f"]}}
{"id1": "8430178", "id2": "19109981", "code1": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "code2": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", "transferFile", "CopyFile", "transferPath", " copyfile", "Copyfile", " copyPath", "copyfile", "copyFiles", "copyPath", "CopyPath", "CopyFiles"], "source_name": ["Source_file", "source_key", "source_uri", "source_Name", "src_name", "src_file", "source_names", "sourceCname", "sourceNtype", "source_size", "source_data", "Source_data", "src_alias", "source_alias", "sourceNname", " source_Name", "Source_name", "source_type", "src_uri", "sourceNalias", "src_size", "sourceNfile", "source_path", "sourceCfile", "sourceCtype", "sourceCalias", " source_path", " source_key", " source_names", "src_type"], "dest_name": ["dest_resource", "destappnames", "dest_id", " dest_path", "destFilename", "destFilenamed", " destination_resource", "dest_none", "dest_word", " destinationFresource", " dest_none", "destflabel", "source_Name", "destRdefinition", "target_names", "destJnames", "destPmodel", "destPtype", "source_names", "dest_definition", "Dest_id", "destPpath", "destPword", "target_type", "destapptype", " dest_type", "dest_names", " dest_names", "destRName", " dest_Name", " destinationFpath", "destRpath", "destRname", " destination_name", "dest_label", "destJname", "destJword", " dest_file", " destination_path", "dest_named", "destFname", " dest_named", "Dest_name", "destFpath", "target_model", "destJName", "destFilelabel", "destfnamed", "dest_model", " dest_word", "destffile", " destinationFinfo", "source_path", " dest_label", " dest_definition", "destPnames", "destPname", "destFilefile", "dest_file", "target_name", "Dest_path", "dest_Name", "dest_type", " destinationFname", "destappname", "dest_path", "destFresource", "dest_info", "destfname", "Dest_Name", "destPName", "destFinfo", "destappmodel", " destination_info"], "source_file": ["source_url", "source_File", "ource_line", "sourcefname", "src_name", "source_class", "src_file", " source_class", "source_files", "source_stream", "source__name", "source__class", "sourceffile", "source__base", "source_base", " source_url", "sourcefFile", "source__file", "ource_file", " source_base", " source_cache", "ource_files", " source_File", "src_files", " source_files", "src_stream", "source_line", "source_cache", "sourcefurl", "ource_name"], "destination_file": ["destention_name", "destination_files", "destination_page", "destination2file", "destation_name", "destention4file", "destinate_files", "destation_folder", "destination2name", "destinationablefile", "destination_path", "destention_source", "destination4file", "destinate_base", "destination4source", "destinationablebase", "destention_path", "destation_function", "destination_folder", "destination_name", "destination_source", "destention_file", "destention4source", "destation_file", "destinationablefiles", "destention4path", "destination2source", "destinate_file", "destination4path", "destinationablepage", "destention4name", "destation_files", "destination_function", "destination4name", "destinate_page", "destination2path", "destination_base"], "source": ["image", "resources", "unit", "slave", "ize", "service", "resource", "SOURCE", "index", "site", "storage", "view", "stream", "Source", "current", "inner", "input", "open", "target", "master", "src", "cache", "load", "local", "slice", "output", "remote", "object", "scope", "ources", "via", "class", "from", "spec", "core", "single", "ource", "result", "uri", "dest", "diff", "client", "secure", "ite", "start", "name", "proxy", "search", "server", "file", "reference", "reader", "get", "connection", "config", "parent", "copy"], "destination": ["Destension", "destension", "foreigninated", "constining", "targetinate", "destinator", " destina", "targetination", "destribution", "Destination", "variinator", " destinator", "testribution", "foreigninator", "Destinated", "destina", " destining", "validination", "dependinate", "variinate", "coordination", "foreigninate", "constribution", "descinated", "testinated", "variination", "Destinator", "identination", "validinator", "testinator", "variinated", "identribution", "identinated", "Destining", "coordinated", "dependination", "targetinator", "destinate", "destinated", "testination", "descination", "constination", "coordension", "identina", "dependinator", "foreignination", "constinator", "Destina", " destinated", "coordinator", "dependinated", "Destribution", " destribution", "descinator", "destining", "validinate", "targetinated", "descension", "validinated"], "buffer": ["image", "pool", "temp", "flush", "sequence", "input", "window", "channel", "text", "cache", "queue", "writer", "bin", "buf", "buff", "Buffer", "padding", "uffer", "block", "binary", "transfer", "limit", "reader", "timeout", "iter", "batch", "memory", "header"], "bytes_read": ["bytesUnRead", "Bytes_set", "bytesUnread", "bytes_set", "bytesUnset", "Bytes_found", "bytesUnfound", "bytes_found", "Bytes_read", "Bytes_Read", "bytes_Read"], "in": ["ini", "image", "re", "log", "resource", "login", "temp", "serv", "stream", "inner", "current", "inn", "val", "input", "din", "In", "fe", "rec", "l", "bin", "b", "read", "r", "IN", "session", "again", "token", "path", "p", "doc", "line", "nin", "container", "min", "out", "ins", "is", "as", "ssl", "a", "request", "con", "h", "data", "file", "id", "lock", "reader", "get", "n", "or", "connection", "f", "url", "inc", "s"], "response": ["re", "body", "onse", "image", "model", "answer", "resource", "feed", "question", "view", "sequence", "Response", "respons", "json", "version", "reason", "offer", "text", "message", "reset", "output", "api", "respond", "object", "update", "status", "example", "string", "application", "r", "resp", "next", "success", "line", "result", "uri", "su", "report", "received", "request", "server", "data", "true", "error", "description", "value", "res", "location", "reply", "dict", "header"], "parentdir": ["parentDir", "parentdict", "parentfile", "partlib", " parentdirectory", "rootdir", "parentsDir", "partdirectory", "Parentdir", "parentdiff", "hostdirectory", "rootfile", "partfile", " parentdict", " parentfile", " parentlib", "partdir", "parentlib", "parentsfile", "rootdirectory", "parentsdir", "rootlib", "homefile", "parentsdiff", "hostdir", "homeDir", "homediff", " parentDir", " parentdiff", "Parentdirectory", "homedir", "Parentdict", "hostdict", "parentdirectory"]}}
{"id1": "22552318", "id2": "19251426", "code1": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 0, "substitutes": {"loadDDL": ["loadDSLE", "loadDDLM", "loadingDDDL", "loadDSL", "loadDSDL", "loadCDDL", "loadDSLM", "loadCDLM", "loadDBL", "loadCDLE", "loadCDL", "loadDDLE", "loadDBLE", "loadingDSLE", "loadDBDL", "loadDBLM", "loadingDDL", "loadingDDLM", "loadingDDLE", "loadingDSDL", "loadingDSLM", "loadDDDL", "loadingDSL"], "stmt": ["stmd", "stm", "stsMT", "ostmp", "strmt", "shMT", " stpt", " stdb", "stpt", "stmp", "Stmt", "ostm", "shpr", "stpr", "stsmt", " sttr", "strnt", "estm", "ostmt", "Sttr", "Stmd", " stmn", "shdb", " stmit", "stnt", "StMT", "estmp", "Stnt", " stnt", " stMT", "strmn", "Stmn", "Stmit", "strtr", "Stdb", "estmn", "stmit", "ostmn", " stmp", "stMT", " stmd", "Stpt", "Stm", "ostMT", "Stpr", "stmn", "ostpt", "stsmd", " stpr", " stm", "sttr", "stdb", "shmt", "estmt", "stsmit"], "qry": ["qy", "quty", "dqries", "qri", "qrys", "qries", "qurys", "qty", "dqrys", "quries", "dqry", "requty", "dqri", " qy", "quy", " qty", "quri", "requy", "requry", " qrys", " qri", "qury", "requrys", " qries"], "q": ["n", "c", "k", "qa", "request", "select", "d", "str", " query", "qu", "ue", " msg", "queue", "qq", "iq", "Q", "p", "w", "qs", "qt", "rc", "query", "work", " req", "f", "quest", "e", "i", "h", "v", "dq", "req", "r", "b", "ql", "t", "id", "sq", "eq"]}}
{"id1": "14820302", "id2": "11968328", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"innerProcess": [" innerWrite", "subprocess", "binaryConnect", "innerprocess", "binaryWrite", "binaryprocess", " innerConnect", "subProcess", "innerWrite", "subConnect", "binaryProcess", " innerprocess", "innerConnect", "subWrite"], "curi": ["furi", "lcURI", "cri", "lURI", " cURI", "lcunit", "cgui", "Cui", "CURI", "lcuri", "pri", "fri", "firi", "Curi", "fui", " cui", " cgui", "luri", "Cunit", "lcui", "capi", "Cgui", "Cri", "cURI", "pURI", "Capi", " cri", "lri", "lcri", "cui", "Curl", " capi", "Ciri", "lcgui", "papi", "curl", " cunit", " curl", "ciri", "cunit", "lciri", "fURI", "lurl", "puri"], "regexpr": ["pregexer", "renexpr", "pregexpl", "reggexr", "Regexpre", "reggexper", "Renexpre", "renexper", "reggexpl", "recer", "relexPR", "recrepl", "recreer", "reggexpr", "relexpre", "regnexpr", "regexer", "pregexpr", "rerer", "rerepl", "rereper", "RenexPR", "regexPR", "Regexpr", "regnexr", "renexer", "prenexer", "recrepr", "prenexpl", "recrepre", "Renexp", "renexpl", "pregexp", "recrep", "renexr", "regexp", "recrePR", "renexPR", "reruer", "renexp", "Renexpr", "regexr", "prenexp", "receper", "relexpr", "rerupl", "rerupr", "regexpl", "regnexper", "relexp", "regexpre", "renexpre", "regexper", "recepr", "regnexpl", "Regexp", "RegexPR", "prenexpr", "rerepr", "recepl", "rerup"], "cs": ["Cs", "bc", "lc", "cm", "cf", "ins", "ms", "ca", "cache", "cers", "CS", "cb", "rs", "vs", "tc", "es", "ns", "ks", "conn", "cms", "cr", "ls", "cells", "cing", "cp", "cks", "c", "cc", "ci", "spec", "ios", "os", "ec", "acts", "codes", "cer", "acs", "acks", "js", "ps", "ars", "sync", "ced", "cus", "css", "ces", "ds", "ics", "fs", "cas", "wcs", "rc", "cos", "sc", "cn", "ches", "qs", "icks", "coll", "pc", "ac", "cases", "details", "ss", "bs", "cons", "ctx", "ce", "gs"], "digest": [" digested", "bigEST", " digity", "digit", "hashest", "signEST", "igity", "signest", "Digity", "bigest", " digests", "hashcher", "digcher", "logester", "Digger", " digcher", "digEST", "igest", "signger", "diggest", "biggest", " digester", "digester", " diggest", "Digcher", " digEST", "digests", "igester", "logger", "signests", "signgest", " digit", "digity", "hashger", "digested", "Diger", "Digester", "logit", "hashester", "signester", "diger", "igested", "Digest", " diger", "signer", "digger", "Digested", "logest", "Digit", "bigests", " digger", "signested"], "s": ["su", "v", "address", "services", "ms", "groups", "str", "e", "sets", "rs", "ws", "sl", "ns", "abs", "string", "u", "ls", "binary", "c", "states", "si", "ses", "os", "strings", "t", "sum", "sb", "r", "g", "b", "js", "n", "o", "ans", "ps", "sym", "S", "sync", "ds", "p", "bytes", "h", "obs", "is", "l", "data", "ss", "bs", "f", "gs", "settings"], "m": ["map", "cm", "v", "mc", "imm", "ms", "mr", "gm", "e", "rm", "pm", "am", "bm", "mo", "machine", "string", "fm", "man", "M", "c", "sm", "mi", "ym", "om", "r", "mm", "tm", "p", "hm", "wm", "me", "match", "vm", "nm", "dm"], "newDigestValue": ["newDigesterKey", "newDigestValues", "newDigestedValues", "newSignestValue", "newDigestVal", "newDigESTKey", "newDigestKey", "newSignestedValues", "newDigeterString", "newSignestValues", "newSignestedValue", "newSignestString", "newDigestedKey", "newSignestKey", "newSignestedString", "newDigESTValue", "newDigeterValue", "newDigestedValue", "newDigESTValues", "newDigesterVal", "newSignestedKey", "newDigestedVal", "newDigeterKey", "newDigesterString", "newDigeterVal", "newDigesterValues", "newDigesterValue", "newDigestedString", "newDigESTString", "newDigestString"]}}
{"id1": "6188784", "id2": "8754809", "code1": "    public static void copy(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public void launch(final ILaunchConfiguration configuration, final String mode, final ILaunch launch, final IProgressMonitor monitor) throws CoreException {\n        {\n            Assert.notNull(configuration);\n            Assert.notNull(monitor);\n        }\n        final String projectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PROJECT_NAME, \"\");\n        final IProject prj = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot()).getJavaProject(projectName).getProject();\n        if (NexOpenProjectUtils.isNexOpenProject(prj)) {\n            final IFile pom = prj.getFile(\"pom.xml\");\n            if (!pom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 root pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(pom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    handleRootProfile(doc);\n                }\n            });\n            final IFile bpom = prj.getFile(\"business/pom.xml\");\n            if (!bpom.exists()) {\n                throw new IllegalStateException(\"Not a NexOpen project. Not Maven2 business pom.xml available\");\n            }\n            ContentHandlerTemplate.handle(bpom, new ContentHandlerCallback() {\n\n                public void processHandle(final Document doc) {\n                    try {\n                        handleBusinessProfile(doc, configuration, prj);\n                    } catch (final CoreException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            });\n            final ByteArrayOutputStream output = new ByteArrayOutputStream();\n            try {\n                final Properties props = new Properties();\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                props.setProperty(\"hibernate.dialect\", support.getDialectClass(dialectName));\n                props.setProperty(\"hibernate.connection.driver_class\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_DRIVER, \"com.mysql.jdbc.Driver\"));\n                props.setProperty(\"hibernate.connection.url\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_URL, \"jdbc:mysql://<host><:port>/<database>\"));\n                props.setProperty(\"hibernate.connection.username\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                props.setProperty(\"hibernate.connection.password\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_PASSWORD, \"\"));\n                props.store(output, \"hibernate properties for code generation using NexOpen Tools 1.0.0\");\n                final IFile props_file = prj.getFile(\"business/src/test/resources/hibernate.properties\");\n                if (!props_file.exists()) {\n                    props_file.create(new ByteArrayInputStream(output.toByteArray()), true, monitor);\n                } else {\n                    props_file.setContents(new ByteArrayInputStream(output.toByteArray()), true, false, monitor);\n                }\n            } catch (final IOException e) {\n                Logger.getLog().error(\"I/O exception \", e);\n                throw new RuntimeException(e);\n            } finally {\n                try {\n                    output.flush();\n                    output.close();\n                } catch (IOException e) {\n                }\n            }\n            if (NexOpenProjectUtils.is04xProject(prj)) {\n                final IFile appContext = prj.getFile(\"web/src/main/webapp/WEB-INF/applicationContext.xml\");\n                if (!appContext.exists()) {\n                    throw new IllegalStateException(\"It no exists applicationContext.xml under web/src/main/webapp/WEB-INF, not a NexOpen project\");\n                }\n                ContentHandlerTemplate.handle(appContext, new ContentHandlerCallback() {\n\n                    public void processHandle(final Document doc) {\n                        final Element root = doc.getDocumentElement();\n                        final List<Element> beans = XMLUtils.getChildElementsByTagName(root, \"bean\");\n                        for (final Element bean : beans) {\n                            final String id = bean.getAttribute(\"id\");\n                            if (\"valueListAdapterResolver\".equals(id)) {\n                                try {\n                                    final String pkgName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.NEXOPEN_PACKAGE, \"\");\n                                    final String className = new StringBuilder(pkgName).append(\".vlh.support.AnnotationValueListAdapterResolver\").toString();\n                                    bean.setAttribute(\"class\", className);\n                                    break;\n                                } catch (final CoreException e) {\n                                    if (Logger.getLog().isInfoEnabled()) {\n                                        Logger.getLog().info(\"CoreException\", e);\n                                    }\n                                    throw new RuntimeException(e);\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n            {\n                final String dialectName = configuration.getAttribute(INexOpenLaunchConfigurationConstants.HIBERNATE_DIALECT, \"MySQL5InnoDB\");\n                if (support.isReverseEngineeringFileNeeded(dialectName)) {\n                    try {\n                        final IFile revengFile = prj.getFile(\"business/src/test/resources/\" + support.getReversEngineeringFile(dialectName));\n                        if (!revengFile.exists()) {\n                            final Bundle bundle = HibernateActivator.getDefault().getBundle();\n                            final Path src = new Path(\"resources/\" + support.getReversEngineeringFile(dialectName));\n                            final InputStream in = FileLocator.openStream(bundle, src, false);\n                            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            IOUtils.copy(in, baos);\n                            String str = baos.toString();\n                            str = str.replace(\"${schema}\", configuration.getAttribute(INexOpenLaunchConfigurationConstants.JDBC_USERNAME, \"sa\"));\n                            revengFile.create(new ByteArrayInputStream(str.getBytes()), true, null);\n                        }\n                    } catch (final IOException e) {\n                        if (Logger.getLog().isInfoEnabled()) {\n                            Logger.getLog().info(\"CoreException\", e);\n                        }\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n            final IResource resource = (IResource) prj.getAdapter(IResource.class);\n            final QualifiedName qn = new QualifiedName(\"org.nexopenframework.ide.eclipse.ui\", \"default.profile\");\n            final String profile = resource.getPersistentProperty(qn);\n            resource.setPersistentProperty(qn, \"reverse-engineering\");\n            try {\n                final InstallProjectAction action = new InstallProjectAction();\n                action.scheduleJob(prj, monitor);\n                prj.refreshLocal(2, monitor);\n            } finally {\n                prj.setPersistentProperty(qn, profile);\n            }\n        } else {\n            Logger.getLog().info(\"Not a NexOpen project :: \" + prj);\n        }\n    }\n", "label": 1, "substitutes": {"copy": [" cp", "p", "create", "sync", "download", "Cop", "to", "move", "map", "cop", " copying", "clone", "clip", "change", "transfer", " transfer", "zip", "split", "Copy", "lock", "cp", " Copy", "replace", "put", "file", "cmp"], "source": ["remote", "cache", "sync", "path", "inner", "use", "i", "ie", "input", "ources", "src", "ource", "SOURCE", "sin", "down", "Source", "from", "resource", "up", "base", "name", "ins", "connection", "origin", "stream", "iter", "file", "route", "slice", "site", "reader", "id", "unit", "parent", "start", "target"], "dest": ["style", "flat", "result", " destination", "home", "d", "de", "src", "down", "folder", "done", "which", "later", "img", "sup", "tmp", "cont", "die", "destroy", "dist", "comb", "thin", "exit", "orig", "test", "desc", "coord", "temp", "wb", "Dest", "dir", "bin", "target", "delete", "dc"], "in": ["work", "as", "init", "into", "gin", "inn", "client", "pin", "inner", "c", "ac", "f", "s", "plus", "i", "ie", "input", "socket", "inside", "image", "src", "conn", "sin", "IN", "issue", "m", "con", "win", "ini", "resource", "n", "isin", "up", "url", "base", "din", "pc", "name", "it", "nin", "min", "ins", "connection", "cin", "thin", "plugin", "In", "inc", "again", "file", "parent", "include", "pull", "r", "err", "login", "id", "reader", "bin"], "out": ["call", "buffer", "output", "client", "sync", "net", "inner", "cat", "at", "not", "this", "our", "extra", "w", "timeout", "ex", "i", "one", "socket", "OUT", "conn", "down", "writer", "other", "io", "n", "up", "vert", "name", "ou", "outer", "ext", "exec", "password", "pool", "obj", "connection", "exp", "channel", "prefix", "option", "Out", "write", "outs", "again", "off", "file", "parent", "part", "lib", "err", "o", "id", "plain", "bin", "outside", "no"], "size": ["x", "seek", "shape", "mode", "depth", "sync", "length", "empty", "SIZE", "len", "bytes", "e", "send", "iz", "max", "count", "loc", "close", "open", "ice", "Size", "n", "export", "speed", "si", "name", "small", "width", "add", "sized", "capacity", "transfer", "sec", "number", "address", "time", "izes", "order", "ize", "sum", "scale", "en", "any", "end", "unit", "flush", "start", "clear", "offset", "content"], "buf": ["cv", "cmp", "buffer", "uf", "uc", "cf", "seq", "br", "bag", "feat", "ba", "fb", "buff", "len", "bytes", "src", "ff", "map", "data", "box", "bf", "cas", "bc", "b", "Buffer", "rb", "coll", "ha", "ra", "vec", "BU", "fam", "pkg", "ctx", "bin", "cb", "la", "bd"]}}
{"id1": "692738", "id2": "20275821", "code1": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "code2": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"url": ["connection", "sl", "f", "loc", "name", "ur", "el", "xml", "base", "ll", "ssl", "html", "loader", "href", "l", "fr", "address", "Url", "buffer", "URL", "source", "service", "image", "feed", "path", "filename", "lr", "config", "server", "uri", "null", "io", "http", "file", "id", "resource", "www", "bel", "host", "link", "ref", "location", "rl", "string", "ob"], "in": ["reader", "bin", "isin", "login", "f", "data", "socket", "ins", "pin", "m", "ex", "cms", "min", "In", "xml", "is", "ssl", "inside", "part", "conn", "again", "inner", "rin", "r", "din", "val", "IN", "err", "ini", "this", "i", "source", "init", "image", "inc", "nin", "or", "config", "n", "io", "inn", "c", "file", "as", "id", "impl", "a", "token", "input", "out", "con", "resource", "gin", "serv"]}}
{"id1": "23611770", "id2": "16623181", "code1": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"handle": [" post", " transport", " abort", "Handle", " process", " reload", " append", " redirect", " handles", " rewrite", " execute", " handler", " fn", " shutdown", " rename", " transform", " serve", " manage", "process", "transfer", " upload", " perform", " loop", " work", " restart", " next", " transfer", " operate"], "srcChannel": ["rcClient", "sourceChan", "rcConnection", "destClient", "sourceClient", " srcchannel", "destChan", "sourceChannel", "rcChan", "sourceConnection", " srcConnection", "srcClient", "srcChan", "sourcechannel", "srcchannel", "rcChannel", "destchannel", " srcClient", "srcConnection", " srcChan"], "destChannel": ["DestStream", "srcSocket", "sourceChan", " destHandler", " destSocket", " destStream", "Destchannel", "destStream", "DestCan", "descCan", "distStream", "distChannel", "destChan", "sourceChannel", "distChan", "DestChannel", "destCan", "descHandler", " destchannel", "srcChan", "destSocket", "DestHandler", " destChan", " destCan", "descChan", "destHandler", "sourceSocket", "distchannel", "destchannel", "descChannel", "DestChan"], "destOutFile": ["destPathfile", "destPointFile", "DestInFile", "destOutputFile", "tempOutSite", "destTemplatefile", "destOutSite", "destOutputSite", "destInDir", "DestInDirectory", "destInDirectory", "destoutDir", "destoutCode", " destOutfile", "destLogFilename", "tempOutDir", "DestInFiles", "destoutFiles", " destOutPath", "destPathFile", "DestOutfile", "destPathFiles", "destOutfile", "featOutFile", "featTemplatefile", "destActionfile", "destPointDir", " destOutputPath", "destOutDir", "destOUTCode", "destInFile", "featTemplateFiles", " destOutputFile", "DestInFilename", "featTemplateFile", "destInPath", " destPathFiles", " destOutputFilename", "destOUTSite", " destOutDir", "featOutFiles", "destOUTFile", " destOutputFiles", "destOutFiles", "destPathDir", "destOUTFiles", " destPathDir", "featOutDir", "destOUTDir", "tempOutFiles", "destOutputfile", "DestOutDirectory", "destLogFiles", "destOutputPath", "destInfile", "DestOutFile", "DestOutCode", "tempOutputFiles", "DestInCode", "tempOutputDir", "DestOutFiles", "DestOutFilename", "destInCode", "destOutputDirectory", "DestInfile", "destActionFile", "destInSite", " destOutFilename", "destInFiles", "destOutCode", " destPathFile", "destoutFile", "tempOutFile", " destPathfile", "destLogFile", "tempOutputSite", "destPointFilename", "DestInDir", "destTemplateFile", "destOutputDir", "destOutFilename", "destLogPath", "featTemplateDir", "destActionDir", "featOutfile", "destPointDirectory", "destTemplateDir", "destOutputFiles", "destInFilename", "destOutPath", "tempOutputFile", "destTemplateFiles", " destOutFiles", "destActionFiles", "destOutputFilename", "DestOutDir", "destOutDirectory"], "destOutFileCompressed": ["destOutFileSupression", "destOutFilesExported", "destOutFilesCompacted", "destOutFilesCompressor", "destOutFileExressor", "destOutLineCompressor", "destOutLineExpressed", "destOutFileEncressed", "destOutFilesComposed", "destOutLineExpression", "destOutFileExressed", "destOutFileExposed", "destOutFileSuppressed", "destOutFileExplied", "destOutLineCompacted", "destOutFilesExplied", "destOutFileExpression", "destOutFilesExpress", "destOutFileRepressed", "destOutLineRepressor", "destOutFileExpressed", "destOutLineCompress", "destOutFilecompressed", "destOutFileSuposed", "destOutFileExress", "destOutLineRepressed", "destOutLineRepression", "destOutFileSupressed", "destOutFilesCompression", "destOutFilesComplied", "destOutFileRepression", "destOutFilesExposed", "destOutFileExacted", "destOutFileSuppressor", "destOutLineRepacted", "destOutFileExpacted", "destOutFileComposed", "destOutFilecompression", "destOutFileEncorted", "destOutFileSuppacted", "destOutFileCompress", "destOutFileExosed", "destOutFileExpress", "destOutFileComplied", "destOutFileReposed", "destOutFilesCompressed", "destOutFileExported", "destOutFilecompress", "destOutFileEncress", "destOutFileSupress", "destOutLineExpressor", "destOutFilesCompress", "destOutLineExposed", "destOutLineRepress", "destOutLineCompression", "destOutFileCompression", "destOutFilesExpression", "destOutFileRepressor", "destOutFilesExpressed", "destOutFileCompacted", "destOutFilesExpressor", "destOutFileExorted", "destOutLineCompressed", "destOutFilesComported", "destOutLineComposed", "destOutFileReplied", "destOutFilesExpacted", "destOutFileComported", "destOutFileSuppress", "destOutFilecompacted", "destOutFilecompressor", "destOutFileRepacted", "destOutFileExpressor", "destOutFileRepress", "destOutFileCompressor", "destOutFileEncosed"], "out": ["full", "lock", "bin", "connection", "extra", "ext", "data", "doc", "name", "self", "socket", "error", "sync", "to", "ex", "outs", "one", "plain", "log", "copy", "conn", "w", "b", "output", "user", "again", "inner", "img", "part", "cache", "line", "writer", "cmd", "err", "o", "flush", "client", "OUT", "temp", "this", "key", "source", "image", "inc", "outer", "exec", "parent", "n", "conv", "post", "null", "io", "net", "server", "up", "file", "co", "resource", "exp", "Out", "obj"], "in": ["reader", "bin", "connection", "isin", "sin", "f", "login", "into", "data", "socket", "ins", "pin", "to", "cin", "min", "In", "log", "is", "part", "b", "inner", "again", "rin", "conn", "img", "win", "din", "l", "r", "IN", "err", "o", "pull", "ini", "source", "init", "image", "inc", "nin", "h", "config", "pass", "inn", "c", "up", "wave", "id", "file", "a", "lin", "token", "input", "con", "diff", "resource", "ac", "gin", "serv"], "buf": ["job", "cur", "cb", "bd", "seq", "data", "loc", "ff", "batch", "pool", "buff", "info", "Buffer", "cap", "bh", "rc", "log", "bl", "feat", "bb", "lc", "base", "b", "vec", "br", "num", "bytes", "box", "text", "val", "bag", "off", "la", "rb", "buffer", "block", "map", "ctx", "port", "uc", "lb", "path", "v", "context", "config", "cv", "func", "wb", "wave", "file", "pos", "src", "uf", "cas", "queue", "header", "bf", " buffer", "input", "ref", "pad", "result", "fb", "bc"], "len": ["nt", "lock", "le", "sl", "iter", "f", "data", "loc", "fl", "lim", "el", "rev", "body", "cap", "min", "en", "ind", " length", "ie", "ll", "lc", "part", "size", "num", "l", "line", "val", "pre", " lang", "lf", "la", "count", "limit", "url", "no", "li", "n", "led", "id", "pos", "lin", "fin", "Len", "length", "ln", "ler", "end"]}}
{"id1": "11968328", "id2": "17158020", "code1": "    public static String getMD5(String _pwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(_pwd.getBytes());\n            return toHexadecimal(new String(md.digest()).getBytes());\n        } catch (NoSuchAlgorithmException x) {\n            x.printStackTrace();\n            return \"\";\n        }\n    }\n", "code2": "    public synchronized String encryptPassword(String passwordString) throws Exception {\n        MessageDigest digest = null;\n        digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(passwordString.getBytes(\"UTF-8\"));\n        byte raw[] = digest.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"getMD5": ["getSHA32", "getMD32", " getCD5", "getSHA512", " getMD53", " getSHA5", " getCD32", " getMD32", " getSHA53", " getMC32", " getMC512", " getMC53", " getCD53", "getMD512", "getSHA53", " getCD512", " getMD512", " getSHA32", " getSHA512", "getSHA5", " getMC5", "getMD53"], "_pwd": ["_npass", "_sword", "_nwn", "_nWD", "_swd", "_dpass", "_sWD", "_Pword", "_pwn", "_dwd", "_Ppass", "_pWD", "_Pwn", "_nwd", "_spass", "_dword", "_dWD", "_pword", "_ppass", "_PWD", "_Pwd"], "md": ["mand", "mm", "mp", "amd", "wd", "dig", "cmd", "dm", "po", "mb", "meta", "mg", "ind", "m", "nm", "pg", "metadata", "mad", "ad", "mac", "bf", "editor", "rm", "sm", "vd", "um", "kg", "pd", "sha", " MD", "gb", "od", "dd", "mo", "mt", "hd", "cd", "MD", "dh", "mc", "ma", "df", "mu", "pkg", "mag", "pm", "db", "d", "bd"]}}
{"id1": "6988216", "id2": "16623181", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": ["runRawSearch", "runSimpleQuery", " runBasicSearch", " runBasicFilter", "runSimpleFilter", " runSimpleQuery", " runRawSearch", " runBasicConnect", " runRawQuery", "runRawQuery", " runClientFilter", " runBasicQuery", " runRawFilter", "runRawConnect", " runClientConnect", " runClientQuery", "runRawFilter", " runSimpleSearch", " runSimpleConnect", " runSimpleFilter", " runClientSearch", "runSimpleConnect", " runRawConnect", "runSimpleSearch"], "dummySource": ["duddySite", "dummyType", "pummyService", " dummyOrigin", "dandyClient", "dumbConfig", " dumbSource", "dellyService", "dandySource", "puddyClient", "dellyType", "duddyOrigin", "duddyContent", "dummyClient", "pummySite", "dummySite", "daddyClient", "daddyContent", "dummyService", "dundleContent", "duddyType", "daddyType", "dandySite", "dellyContent", "duddySourceFile", "daddySourceFile", "pummyType", "dumbContent", "dummyOrigin", "puddySource", "dummySourceFile", "daddyService", " dumbContent", "duddyClient", "puddyService", "dummyConfig", "duddyService", " dumbOrigin", "pummySourceFile", " dummyConfig", "dumbOrigin", " dumbConfig", "pummyClient", "dandySourceFile", "puddySite", "dellySource", "pummyContent", "dundleConfig", "daddySource", "puddyType", "puddySourceFile", "dundleSource", "puddyContent", "dumbSource", "daddySite", "duddyConfig", "dundleOrigin", "pummySource", "duddySource"], "os": ["us", "ok", "oos", "oss", "iso", "pos", "uns", "dos", "i", "is", "ose", "bs", "object", "s", "ou", "ls", "ol", "ns", "om", "ows", "ros", "ens", "aos", "es", "css", "conn", "ox", "los", "ks", "or", "obs", "cos", "ios", "ori", "oses", "io", "oc", "op", "out", "ds", "oa", "nos", "OS", "osi", "ols", "o", "fs", "mos", "oS", "ops", "vs", "bos", "ss", "acs", "as", "ps", "ms", "sys", "Os"], "dummyContent": [" dummyOutput", " dellyContents", "dumpingOutput", "dumpercontent", "DummyContent", "DuckyBody", " dummyContents", "dummyContents", " dummycontent", "dellyOutput", "duckyReader", "dumperBody", "duddyContent", "duckyBody", "dumperContents", "dellyContent", "dellycontent", "dumperReader", "duckyContent", "dumperOutput", "duddySource", "duckySource", "DuckyReader", "DummyBody", "dummyReader", "DummyReader", "duddyBody", "dumpingcontent", " dellycontent", "DummySource", "DuckySource", " dellyOutput", "dellyContents", "duddyReader", "dumperSource", "dumperContent", " dellyContent", "dummyBody", "DuckyContent", "dumpingContent", "dummyOutput", "dumpingContents", "dummycontent"], "source": [" Source", "sc", "client", "service", "size", "sl", "sync", "element", "stream", "src", "i", "class", "host", "object", "s", "proxy", "use", "scope", "slave", "e", "parent", "sn", "sin", "core", "cache", "info", "result", "target", "connection", "cos", "resource", "resources", " sources", "Source", "secure", "storage", "url", "unit", "channel", "SOURCE", "search", "text", "node", "site", "reader", "string", "seed", "uri", "ser", "ource", "config", "ources"], "content": ["image", "clean", "match", "service", "children", "size", "html", "Content", "host", "output", "comment", "load", "feed", "input", "title", "version", "comments", "expression", "css", "sol", "server", "address", "child", "target", "result", "code", "media", "cos", "response", "resource", "report", "message", "xml", "music", "value", "description", "cover", "url", "update", "model", "data", "activity", "transform", "text", "document", "news", "body", "header", "cms", "cont", "current", "config"], "qResult": ["qresult", "qResults", "iqResult", " qResponse", "rSource", "iqresult", "kResult", "queryReturn", "QReturn", "queryResult", "qRes", "rResult", "kReturn", "rRes", "qReturn", "kresult", "kSource", "QResult", "queryRes", "QResults", "queryResponse", "iqResults", "iqResponse", "QFilter", "kFilter", "kRes", "qResponse", "rresult", "queryresult", "qFilter", "querySource", "kResults", "qSource", "queryResults", " qResults", "queryFilter", " qresult"], "results": ["items", "details", "children", "qs", "models", "files", "s", "its", "events", "features", "lines", "objects", "result", "vers", "response", "reports", "docs", "successful", "resources", "members", "ions", "pages", "data", "values", "blocks", "RESULTS", "users", "errors", "collection", "groups", "rows", "ins", "ries", "ids", "versions", "res", "shows", "runs", "Results", "tests"], "it": ["rit", "r", "itted", "in", "ip", "the", "p", "ic", "entry", "stat", "i", "you", "ort", "init", "its", "sit", "slice", "id", "ci", "ITS", "t", "info", "or", "ited", " It", "pit", "not", "ite", "mit", "op", "ati", "lit", "edit", "which", "iter", "v", "ait", "split", "ins", "IT", "l", "list", "si", "and", "iti", "It"], "rSrc": ["rSource", " rDsource", "rIsrc", "RIsRC", "RIsrc", "rPsrc", "rAssrc", "rDsRC", "rPssrc", "rAsource", "RIsrec", "rIsrec", "rSRC", "rEsource", " rDsRC", "rIsource", "rAsRC", "rSrec", " rSRC", " rSsrc", " rDsrc", " rEsrc", " rDssrc", "rEsRC", "rPsRC", " rEsource", "rDsource", "rIsRC", "rSsrc", "rEssrc", "rDssrc", "RSRC", "RIsource", "rPsource", "RSrc", "rAsrc", "rAsrec", "RSource", "RSrec", " rSource", " rEssrc", "rEsrc", "rDsrc", " rEsRC"], "rSrcIn": ["rSvcIns", "rAsrcin", "rSsrcIn", "rSvcIn", "rSrcIN", "rAsrcOut", "rSRCIns", "rCrcIns", "rSsrcin", "rSourcein", "rSourceOut", "rSourceIn", "rCsrcIN", "rCrcin", "rSvcin", "rCrcIn", "rAsRCin", "rCRCIn", "rSrcIns", "rSsrcOut", "rSRCin", "rCRCIns", "rSsrcIN", "rCRCOut", "rSRCIN", "rSRCOut", "rCrcIN", "rCsrcin", "rSvcIN", "rSrcin", "rAsRCOut", "rSrcOut", "rSourceIns", "rSRCIn", "rAsRCIn", "rCrcOut", "rCsrcOut", "rAsrcIn", "rCsrcIn", "rSvcOut"], "actualOut": ["eventIn", "nexpectedWin", " actualBridge", "nexpectedOut", "illegalOutput", "publicIn", "operatorIn", " ActualBridge", "publicOutput", " ActualOUT", "illegalOut", "assertIn", "eventOut", " actualout", "eventOUT", " actualOutput", "assertOut", "nexpectedIn", "publicOUT", "assertBridge", "realout", "actualOutput", "assertOUT", " ActualIn", "actualOUT", "illegalOUT", "actualWin", " actualIn", "actualBridge", " actualWin", "eventout", "actualout", "nexpectedout", "operatorout", "realIn", " ActualOut", "operatorOut", " actualOUT", "publicOut", "illegalIn", "realWin", "operatorOUT", "realOut", "actualIn"]}}
{"id1": "15580610", "id2": "7149578", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"trainClassifier": ["trainclassification", "trainModelifier", "trainModelLoader", "trainModelification", " trainclassification", "trainTestify", " trainClassify", "trainTestLoader", "trainClassLoader", "trainClassification", " trainClassLoader", "trainClassify", " trainclassLoader", "trainTestification", "trainclassify", " trainClassification", "trainclassLoader", "trainModelify", "trainclassifier", "trainTestifier", " trainclassify", " trainclassifier"], "dir": ["md", "url", " directory", "base", "project", "output", "window", "Dir", "model", "db", "path", "folder", "div", "target", "filename", "name", "out", "domain", "doc", "database", "files", "lib", "build", "report", "class", "root", "directory", "object", "DIR", "config", "direction", "loc", "uri", "cd", "du", "wd", "fd", "di", "data", "file", "dist", "d", "group", "home", "env", "module"], "command": ["exec", "slave", "error", "sudo", "system", "project", "delete", "force", "which", "child", "model", "volume", "shell", "path", "request", "one", "function", "input", "pattern", "machine", "string", "sequence", "name", "language", "cmd", "word", "action", "archive", "domain", "image", "argument", "database", "this", "clear", "operation", "reason", "event", "menu", "connection", "history", "component", "root", "info", "directory", "program", "category", "config", "query", "message", "array", "attribute", "service", "media", "usage", "document", "cli", "move", "power", "help", "password", "file", "control", "and", "three", "script", "Command", "comment", "module"], "length": ["position", "level", "now", "left", "id", "prime", "zip", "creator", "distance", "sequence", "end", "max", "time", "range", "section", "angle", "word", "inner", "len", "character", "dim", "or", "type", "Length", "duration", "count", "ength", "class", "ph", "number", "shape", "body", "join", "both", "th", "head", "span", "slice", "loc", "padding", "depth", "how", "strength", "form", "l", "match", "last", "power", "letter", "width", "before", "style", "limit", "capacity", "square", "value", "full", "part", "sum", "size"], "process": ["exec", "result", "processor", "master", "share", "cess", "console", "system", "status", "call", "parse", "project", "output", "handle", "app", "use", "child", "proc", "worker", "path", "function", "session", "host", "python", "out", "machine", "thread", "cmd", "this", "component", "connection", "method", "pid", "class", "application", "user", "parent", "program", "task", "sync", "post", "display", "service", "p", "plus", "document", "file", "processing", "Process", "script", "group", "run"]}}
{"id1": "19109981", "id2": "22442270", "code1": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 1, "substitutes": {"startScript": ["startText", "startShell", "endScript", " startText", " startCode", "endCode", "StartCode", "startCode", " startShell", "StartShell", "StartText", "StartScript", "endText", "endShell"], "prop": ["resource", "lit", "ag", "property", "Prop", "exp", "load", "properties", "info", "Property", "object", "jp", "scope", "string", "def", "state", "ps", "path", "op", "p", "type", "part", "proc", "frame", "OP", "pb", "oc", "name", "map", "msg", "data", "str", "reader", "pro", "or", "config", "project", "obj", "owner"], "url": ["image", "log", "URL", "base", "resource", "fr", "feed", "br", "coll", "download", "Url", "ls", "ref", "http", "src", "l", "href", "bb", "page", "style", "string", "rc", "route", "path", "fb", "source", "rel", "uri", "layer", "length", "xml", "location", "ssl", "server", "data", "id", "ll", "file", "ob", "gl", "str", "sl", "rl", "connection", "loc", "host", "f", "address"], "r": ["err", "dr", "lr", "fr", "rx", "vr", "w", "cur", "rt", "ir", "rar", "l", "b", "writer", "ws", "pr", "rg", "ri", "c", "rf", "gr", "rc", "ro", "wr", "er", "p", "rr", "nr", "rh", "mr", "rs", "ur", "hr", "sr", "R", "e", "Reader", "rl", "rb", "rw", "reader", "res", "i", "ar", "br", "cr"], "buffer": ["base", "resource", "feed", "offset", "flush", "input", "entry", "available", "paste", "text", "message", "slice", "queue", "key", "b", "bin", "bb", "writer", "string", "null", "buf", "read", "buff", "border", "fb", "uffer", "job", "line", "number", "row", "layer", "block", "length", "character", "pause", "data", "binary", "seed", "transfer", "ob", "str", "comment", "reader", "value", "timeout", "iter", "batch", "source", "Buffer", "header"], "dialog": ["colag", "dialie", "dlag", "Dialie", "toolect", "toolog", "Dialoc", "toolage", "dialag", "dlect", "Dialag", "cologo", "dlogo", " dialie", "dler", "colog", "dialogue", "dlog", "Dialer", "dlogue", " dialogue", "dialect", "toologo", "dialage", "coler", "dialoc", "confoc", "Dialogue", "confogue", "confog", "dialer", "dlage", "dialogo", " dialoc", "confie", "colect", "colage", "Dialog", "cologue"], "script": ["image", "service", "resource", "module", "escape", "config", "input", "zip", "exec", "process", "style", "code", "stage", "screen", "command", "Script", "request", "proxy", "cript", "file", "document", "javascript", "error", "comment", "scroll", "source", "scripts"]}}
{"id1": "21425787", "id2": "8330057", "code1": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", "transferfile", "transferFiles", "transferFile", "transferStream", "CopyFile", " copyStream", " copyfile", "Copyfile", "copyStream", "copyfile", "CopyStream", "copyFiles", "CopyFiles"], "in": ["ini", "image", "index", "base", "login", "inner", "inn", "input", "In", "at", "up", "bin", "b", "c", "IN", "again", "work", "source", "io", "min", "ins", "name", "a", "ac", "id", "file", "data", "ex", "reader", "i", "or", "connection", "m", "inc", "exec", "url"], "out": ["base", "o", "temp", "prefix", "point", "to", "w", "at", "target", "up", "cache", "output", "OUT", "writer", "conn", "b", "object", "c", "again", "outs", "p", "part", "io", "result", "v", "dest", "x", "Out", "client", "off", "name", "server", "data", "file", "user", "call", "ex", "n", "connection", "source", "exec", "inc"], "sourceChannel": ["SourceStream", "resourceChan", "resourceConnection", " sourceStream", "ourceSocket", "SourceChannel", "targetchannel", "Sourcechannel", " sourceConnection", "SourceChan", "sourcechannel", "targetStream", "srcChan", "srcSocket", " sourceSocket", "ourceChannel", " sourcechannel", "ourcechannel", "sourceSocket", "targetChan", "sourceChan", "resourceChannel", "ourceConnection", "resourcechannel", "sourceConnection", " sourceChan", "targetChannel", "srcChannel", "SourceConnection", "ourceChan", "srcConnection", "sourceStream"], "destinationChannel": ["destinatingChannel", "Destinationchannel", "destinationFile", "DestinationFile", "destinatorManager", "destinatedStream", "DestinatingStream", "destinatingStream", "destinationchannel", "DestinatorChannel", "DestinatorChan", "DestinatingChannel", "destinationConnection", "destinationChan", "DestinationConnection", "destationchannel", "DestinatingChan", "DestinationChannel", "destinatingChan", "destinatorConnection", "destinateChan", "destationConnection", "destructionChan", "destinatorStream", "destationChannel", "destinateChannel", "DestinatorFile", "destationFile", "Destinatorchannel", "destinatorchannel", "destructionChannel", "destinatedManager", "DestinationManager", "destinatorFile", "destinatorChan", "destinatedChan", "destinationStream", "destinatedChannel", "DestinationStream", "destinatedchannel", "destinationManager", "destinateConnection", "destinatorChannel", "destructionConnection", "DestinationChan", "DestinatingManager", "DestinatorConnection", "destinatedFile", "destinatedConnection", "destinatingManager"]}}
{"id1": "19147279", "id2": "9096319", "code1": "    public boolean actualizarDatosFinal(int idJugadorDiv, int idRonda, jugadorxDivxRonda unjxdxr) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET resultado = ?, puntajeRonda = ? \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatementActFinal(unjxdxr);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"actualizarDatosFinal": [" actualizarDataoFinal", " actualizarBatosResult", " actualizarBatosComplete", " actualizarBatocResult", " actualizarBatosFinal", " actualizarDataoTotal", " actualizarBatosTotal", " actualizarDatosComplete", " actualizarDatOSFinal", " actualizarBatocTotal", " actualizarDatosResult", " actualizarDataoResult", " actualizarDatOSResult", " actualizarDataoComplete", " actualizarDatosTotal", " actualizarDatocResult", " actualizarDatOSTotal", " actualizarBatocComplete", " actualizarDatocComplete", " actualizarDatOSComplete", " actualizarDatocFinal", " actualizarBatocFinal", " actualizarDatocTotal"], "idJugadorDiv": ["idJugadorDoc", "idJugaderDec", "idJudadorDIV", "idJubordOrd", "idJubadorOrd", "idJugaderDoc", "idJugrarDec", "idJugaderDIV", "idJubordDiv", "idJugordDIV", "idJubordDec", "idJugadeDIV", "idJubadorDoc", "idJubadorDiv", "idJugordDec", "idJubordDoc", "idJudadorDiv", "idJugaderOrd", "idJugordDiv", "idJugaderDiv", "idJugadeDec", "idJugadeDiv", "idJugrarDoc", "idJugordOrd", "idJugadorDIV", "idJubadorDec", "idJudadeDec", "idJugadorOrd", "idJudadeDiv", "idJugordDoc", "idJudadorDec", "idJudadeDIV", "idJugadorDec", "idJugrarOrd", "idJugrarDiv"], "idRonda": ["idGrado", "idGronda", "pidRora", " idronda", "idRona", "idrona", "idrora", "idRhanna", "idRhora", "idGrona", "idRhado", "idGrora", "pidRhora", "idRanna", " idRora", "idRhona", "pidRhado", "idrado", "pidRona", " idRanna", "idRora", "pidRonda", "idronda", " idranna", "pidRado", "pidRhonda", " idrora", " idRona", "idranna", " idrona", "pidRhona", "idRhonda", "idRado"], "unjxdxr": ["unjxdexr", "unjxdxtr", "unjxdxR", "unjxdxxR", "unjxdxtrs", "unjxdxl", "unjxfexrs", "unjxfxR", "unjddxxR", "unjxdxxer", "unjxfexR", "unjxdexrs", "unjxdxtR", "unjxdxter", "unjxdxrs", "unjxfxrs", "unjddxxl", "unjxdxxl", "unjxdddrs", "unjxfxr", "unjddxl", "unjxdexl", "unjddxR", "unjxdexR", "unjddxxer", "unjxdxxr", "unjxdddr", "unjddxxr", "unjxdxtl", "unjxdxer", "unjddxer", "unjxdddR", "unjddxr", "unjxdexer", "unjxfexr"], "intResult": ["IntRate", "intResponse", "IntResponse", "mintOrder", "longResponse", "longCode", "intCode", "INTResult", " intRes", "intRest", "ntResponse", "longRes", "IntReturn", "mintRate", "intOrder", "intReturn", "longResult", " intRest", "IntRest", "ntResult", "intRes", "IntResult", " intReturn", "ntCode", "IntRes", "INTReturn", "INTRes", "ntRes", "mintReturn", "IntOrder", "mintResult", "IntCode", "intRate", " intRate", "INTRest", " intOrder"], "sql": ["dd", "log", "cmd", "section", "printf", "nl", "plan", "SQL", "sync", "l", "conn", "pr", "url", "string", "params", " SQL", "query", "join", "job", "ql", "eps", "sb", "mt", "sq", "socket", "ssl", "statement", "joined", "msg", "search", "fn", "limit", "str", "sl", "comment", "database", "dl", "select", "db", "pg", "QL"], "connection": ["log", "index", "section", "ion", "function", "Connection", "table", "environment", "conn", "writer", "application", "driver", "c", "engine", "position", "condition", "collection", "session", "relation", "BC", "query", "handler", "container", "client", "cc", "character", "context", "manager", "statement", "communication", "cp", "proxy", "con", "loc", "server", "document", "connect", "database", "reader", "ctx", "connected", "config", "bc", "db", "pg", "socket"], "ps": ["ports", "posts", "syn", "changes", "po", "ops", "Ps", "ls", "pc", "details", "ns", "ping", "pers", "ms", "conn", "mp", "pr", "sp", "pe", "pp", "pps", "params", "pa", "p", "ds", "relations", "os", "eps", "cs", "qs", "ins", "hs", "rs", "ups", "pse", "cp", "gs", "proxy", "ips", "bs", "PS", "ks", "ts", "pg", "ppa"]}}
{"id1": "9257487", "id2": "3184073", "code1": "    public static boolean downloadFile(String from, String to, ProgressMonitor pm) {\n        try {\n            FileOutputStream out = new FileOutputStream(to);\n            URL url = new URL(from);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int read = 0;\n            while ((read = in.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n                if (pm != null) pm.addToProgress(read);\n            }\n            out.close();\n            in.close();\n        } catch (Exception e) {\n            Installer.getInstance().getLogger().log(StringUtils.getStackTrace(e));\n            return false;\n        }\n        return true;\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 0, "substitutes": {"downloadFile": [" downloadfile", "copyFile", " downloadFiles", "Downloadfile", "downloadfile", "DownloadResource", " downloadResource", "copyfile", "DownloadFiles", "downloadResource", "DownloadFile", "copyFiles", "downloadFiles", "copyResource"], "from": ["folder", "resource", "or", "route", "at", "project", "host", "src", "with", "From", "about", "as", "path", "user", "address", "part", "connection", "base", "prefix", "f", "link", "code", "by", "a", "remote", "html", "range", "data", "module", "source", "uri", "form", "name", "file"], "to": ["resource", "temp", "or", "route", "token", "so", "o", "with", "about", "path", "as", "io", "os", "flo", "download", "address", "base", "TO", "prefix", "storage", "location", "To", "addr", "office", "eto", "socket", "remote", "repl", "until", "range", "output", "too", "target", "po", "prot", "uri", "source", "name", "file"], "pm": ["mp", "pc", "cm", "rm", "im", "m", "em", "pr", "PM", "gp", "sm", "pb", "pi", "um", "prem", "pl", "pt", "px", "pp", "mr", "wp", "p", "vm", "cp", "pa", "sp", "pool", "lp", "sem", "fm", "gm", "dm", "dem", "rpm", "mi", "prom", "meter", "jp", "po", "mm", "tm", "wm", "bm", "monitor", "pro"], "out": ["timeout", "temp", "In", "line", "again", "string", "o", "inner", "bin", "Out", "self", "copy", "input", "as", "log", "outer", "io", "outs", "sync", "err", "up", "connection", "net", "w", "cmd", "exec", "cli", "i", "socket", "writer", "file", "login", "ext", "output", "reader", "write", "obj", "OUT", "inc", "parent", "source", "client"], "url": ["resource", "fr", "zip", "c", "channel", "http", "www", "URL", "log", "ll", "con", "ur", "open", "Url", "download", "impl", "bel", "er", "loc", "l", "connection", "base", "server", "sl", "f", "i", "el", "image", "lib", "socket", "ssl", "fl", "b", "fb", "web", "uri", "source", "client", "org", "file"], "conn": ["dc", "ch", "cm", "n", "c", "Connection", "g", "act", "http", "Conn", "apt", "ann", "conv", "ci", "ctx", "con", "open", "cms", "sync", "client", "p", "l", "connection", "mc", "cn", "cp", "exec", "coll", "cur", "f", "enc", "pub", "socket", "close", "cb", "ssl", "b", "en", "nc", "lock", "connect", "lc"], "in": ["In", "again", "ini", "n", "c", "IN", "cin", "is", "inner", "din", "bin", "input", "con", "io", "ins", "impl", "inn", "err", "connection", "init", "win", "s", "lin", "isin", "exec", "f", "inside", "i", "nin", "socket", "login", "ssl", "reader", "data", "r", "b", "inc", "source", "stream", "client", "lock", "file"], "buffer": ["row", "seed", "position", "cache", "uffer", "limit", "bin", "input", "layer", "shape", "wave", "feed", "buf", "slice", "queue", "length", "address", "batch", "base", "size", "Buffer", "iter", "bytes", "result", "memory", "bb", "reference", "reader", "data", "write", "raw", "null", "b", "buff", "flush", "message", "offset", "binary", "source", "padding"], "read": ["reads", "pass", "run", "ask", "use", "send", "k", " write", "readable", "current", "reading", "fill", "select", "input", "old", "READ", "lex", "io", "open", "feed", "add", "slice", "text", "sync", "skip", "number", "length", "download", "count", "seek", "play", "Read", "rate", "exec", "find", "get", "load", "x", "wait", "size", "work", "f", "iter", "index", "allow", "ok", "ind", "check", "start", "connect", "ride", "transfer", "close", "reader", "se", "parse", "write", "raw", "b", "loop", "sleep", "block", "create", "end"]}}
{"id1": "4593011", "id2": "13757855", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "label": 0, "substitutes": {"loadDDL": ["loadODML", "loadDDML", "loadCDL", "loadSDLL", "loadCDML", "LoadCDE", "LoadCDLL", "loadSDL", "loadODLL", "LoadDDL", "LoadDDML", "loadCDLL", "loadCDE", "loadSDML", "loadDDLL", "LoadCDL", "loadSDE", "LoadCDML", "loadODE", "loadODL", "LoadDDE", "LoadDDLL", "loadDDE"], "stmt": ["stgr", "estmt", "STpr", "esttt", "sttr", "rmd", "Stmr", "Stmn", "rm", " stmn", "tmd", "STmb", " stpr", "estmp", "estm", "estmb", "Stmt", " stdb", "estmd", "tdb", "STmr", "stmp", "STgr", "stmd", "estmr", " stm", "Stmb", "STmt", "constmt", " stmd", "rdb", "Stdb", "stpr", "constm", "Sttt", "stmr", " stgr", "stdb", "STtr", " sttr", "tm", "sttt", "strgr", "strpr", "stmn", "STmp", "strtr", " sttt", "constdb", "stm", "tmt", "strmt", "Stm", "stmb", "constmn", "Stmp", "Stmd", "rmt"], "qry": ["equry", " qury", "quRY", "qrys", "qRY", "qries", " qrys", "qri", " qries", "Qri", " qRY", "eqRY", "Qry", "Qries", "qurys", "quries", " qri", "quury", "qury", "Qrys", "eqry", "quri", "eqrys"], "q": ["qa", "f", "qq", "quest", "quant", "p", "k", " sq", "eq", "Q", "req", "qu", "b", "iq", "r", " req", "query", "e", " query", "key", "sq", "d", "i", "requ", "select", "qs", "ch", "t", "request", " p", "v", "config", "dq", "n", "c", "id", "ql", "queue", "qt"]}}
{"id1": "7044153", "id2": "9081749", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 0, "substitutes": {"sendExceptionToServer": ["sendExceptionAsHost", "sendExceptionWithService", "sendExceptiontoserver", "sendExceptiontoService", "sendExceptionWithServer", "sendErrortoHost", "sendExceptionAsServer", "sendErrorToserver", "sendExceptionWithHost", "sendExceptionToserver", "sendErrortoServer", "sendExceptionToHost", "sendExceptiontoServer", "sendErrorToServer", "sendErrortoserver", "sendErrorToService", "sendErrortoService", "sendExceptionAsserver", "sendExceptiontoHost", "sendExceptionWithserver", "sendExceptionToService", "sendErrorToHost", "sendExceptionAsService"], "server": ["ser", "test", "address", "base", "ip", "header", "client", "port", "proxy", "Server", "db", " host", "host", "domain", "prefix", "ssl", "root", "null", "service", "erver", "http", "addr", "email", "json", "serv", "conf"], "ex": ["exec", "su", "rex", "cl", "base", "error", "exc", "pex", "status", "re", "str", "lex", "aux", "throw", "e", "exp", "ace", "none", "Exception", "EX", "tx", "x", "log", "nex", "export", "res", "Ex", "ext", "obj", "Exc", "err", "hex", "ax", "event", "def", "class", "ception", "example", "except", "acer", " exc", "sex", "fail", "con", "full", "rupt", "exit", "temp"], "config": ["address", "base", "client", "console", "app", "Configuration", "proc", "log", "Config", "ext", "cmd", "bug", "cfg", "connection", "options", "text", "Conf", "etc", "service", "rc", "file", "json", "conf", "cb", "settings"], "prob": ["proj", "probs", " probs", "peb", "Proj", "Probs", "Prob", "Probe", " proj", "pebe", "probe", " probe", "pebs", "pej"], "dataSB": ["codeRB", "codeEB", "workPB", "errorSB", "eventSB", "DataHL", "controlSB", "DataLB", "workBB", "uiEl", " dataEl", "execLB", "fileLB", "cacheBL", "eventLB", "fileSB", "loadSB", " dataHL", "pBs", "dataSL", "codeLB", "fullLB", "offSB", " dataMB", "errorPB", "cacheSB", "ifSL", "execBL", "defaultLB", "pSB", " dataRB", "cachesb", "strSB", "postLB", "postSB", " dataBB", "dataHL", "defaultBB", "fullBB", "offSL", "contentOB", "nosb", "datasb", "errorOB", "cacheLB", "codeMB", "codeFB", "controlBL", "ifsb", "innersb", " dataLB", "ifLB", "fullBL", "responseBB", "codeHL", "errorEB", "defaultSB", "responseSB", "datLB", "offBB", "execsb", "dataMB", "psb", "postSL", "DataSB", "dataBL", "Datasb", "datOB", "dataEB", " dataBL", " dataSL", "DataBL", "ifSB", "offsb", " dataFB", "dataRB", "defaultsb", "DataMB", "contentLB", " datasb", "innerSL", "execBB", "dataLB", "filesb", "contentsb", "noLB", "errorBB", "uiSB", "innerSB", "fullSB", "dataPB", "strSL", "workSB", "noSB", "responseLB", "innerLB", " dataEB", "codeBs", "workSL", "dataFB", "fileSL", "dataOB", "DataRB", "loadLB", "strsb", "codeBB", "errorSL", "loadsb", "dataEl", "errorsb", "postsb", "uiLB", "offLB", "dataBB", " dataOB", "eventSL", " dataPB", "controlsb", "DataOB", "datSB", "codesb", "controlBB", "datBB", "contentSB", "noSL", "DataSL", "DataBB", "dataBs", "execSB", "loadBB", "pLB", "codeEl", "controlLB", "errorLB", " dataBs", "codeSB", "DataFB", "strLB", "eventBB", "responseBL"], "trace": ["race", "shadow", " debug", "test", "atter", "result", "flow", "address", "error", " traced", "cache", "bean", "e", " traces", "ace", "cover", "xml", "log", "tx", "string", "out", "profile", "bug", "err", "ray", "t", "ptr", "type", "info", "report", "r", "ctr", "span", " tracing", "tr", "strip", "message", "debug", "buffer", "array", "scale", "track", "stack", "data", "tri", "trip", "details", "runner", "trans", "fake", "temp"]}}
{"id1": "19322941", "id2": "7927042", "code1": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "code2": "    private void loadDynamically(File result, String extraPath) {\n        URL url = null;\n        InputStream is = null;\n        FileOutputStream fos = null;\n        try {\n            url = new URL(homeServerUrl + extraPath);\n            is = url.openStream();\n            fos = new FileOutputStream(result);\n            byte[] buff = new byte[8192];\n            int nbRead;\n            while ((nbRead = is.read(buff)) > 0) fos.write(buff, 0, nbRead);\n        } catch (IOException e) {\n            throw new StellariumException(\"Cannot dynamically load \" + result + \" from \" + url);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n            if (fos != null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    e.printStackTrace(System.out);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"test_lookupResourceType_FullSearch_TwoWordsInMiddle": ["test_lookupResourceType_FullSearch_FourWords", "test_lookupResourceType_FullSearch_Threewords", "test_lookupResourceType_FullSearchWithtwowords", "test_lookupResourceType_FullSearch_TwoWord", "test_lookupResourceType_FullSearchWithtwoWord", "test_lookupResourceType_FullSearch_ThreeWords", "test_lookupResourceType_FullSearch_ThreeW", "test_lookupResourceType_FullSearchWithTwoWord", "test_lookupResourceType_FullSearch_twoWords", "test_lookupResourceType_FullSearchWithtwoWords", "test_lookupResourceType_FullSearch_ThreeWord", "test_lookupResourceType_FullSearchWithTwoW", "test_lookupResourceType_FullSearch_TwoW", "test_lookupResourceType_FullSearchWithTwoWords", "test_lookupResourceType_FullSearch_TwoWords", "test_lookupResourceType_FullSearch_FourW", "test_lookupResourceType_FullSearch_Fourwords", "test_lookupResourceType_FullSearch_twoWord", "test_lookupResourceType_FullSearch_twowords", "test_lookupResourceType_FullSearch_twoW", "test_lookupResourceType_FullSearch_FourWord", "test_lookupResourceType_FullSearchWithTwowords", "test_lookupResourceType_FullSearch_Twowords", "test_lookupResourceType_FullSearchWithtwoW"], "url": ["string", "path", "base", "address", "ssl", "server", "uri", "resource", "feed", "user", "entry", "http", "document", "c", "system", "location", "l", "URL", "client", "config", "file", "channel", "https", "page", "object", "web", "log", "conn", "image", "link", "sl", "Url", "position", "bug", "b", "contact", "f", "method", "org"], "connection": ["Connection", "event", "translation", "handler", "server", "resource", "response", "uri", "entry", "http", "document", "character", "c", "connected", "j", "communication", "result", "number", "version", "l", "con", "location", "relation", "database", "established", "condition", "password", "client", "expression", "session", "use", "cache", "proxy", "ion", "which", "operation", "application", "section", "config", "channel", "body", "object", "context", "conn", "image", "io", "function", "link", "db", "position", "bc", "bug", "b", "connect", "wrapper", "contact", "method", "service", "loc"]}}
{"id1": "5951610", "id2": "10728243", "code1": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "code2": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"testNetworkHTTP": ["testNETSSL", " testNetworkHTML", " testNetworkHttp", "testnetworkSSL", "testNetworkHTML", "testInternetSSL", " testNetworkSSL", " testInternetHTML", "testnetworkHTML", "testNETHTTP", "testInternetHTML", "testInternetHttp", " testInternetSSL", " testInternetHTTP", "testNETHTML", "testNetworkSSL", "testnetworkHTTP", "testnetworkHttp", "testNetworkHttp", " testInternetHttp", "testInternetHTTP", "testNETHttp"], "url": ["URL", "resource", "lr", "www", "impl", "ls", "channel", "group", "page", "job", "control", "layer", "ur", "file", "ll", "call", "el", "lib", "connection", "host", "lc", "log", "service", "cl", "output", "github", "r", "ml", "build", "pull", "il", "loader", "tool", "server", "user", "rl", "dl", "loc", "base", "email", "event", "bl", "entry", "text", "use", "l", "shell", "update", "left", "hl", "path", "large", "blog", "util", "ssl", "ol", "rel", "location", "web", "image", "mail", "feed", "nl", "view", "coll", "ul", "Url", "http", "load", "key", "buffer", "cloud", "pl", "fl", "org", "uri", "gl", "ob", "sl", "bf", "config"], "urlConnection": ["URLConnect", "urConnection", "urlReference", "implReference", "sslUnit", "viewconnection", "httpFactory", "emailconnection", " urlContainer", "uriUnit", "urlFactory", "urlConstruction", "uriComputer", "emailConstruction", "urlConn", " urlPool", "webconnection", "lConnect", " urlconnection", "flconnection", "htmlConstruction", "sslConnector", "termConnection", "UrlContainer", "serviceConn", "numberconnection", "numberConnector", "viewConstruction", "urlComputer", "URLConn", "flConstruction", "glConn", "webConnection", "numberConnect", "glConnect", "lConn", " urlEnvironment", "ulUnit", "serviceConnect", "flConnection", "UrlFunction", " urlUnit", "urlconnection", "httpFunction", "httpComputer", "resourceGate", "implEnvironment", "urFactory", "urlGate", "blogconnection", "uriFunction", "termComputer", "urlContainer", "lengthConnection", "emailClient", " urlReference", "UrlConnection", "numberConnection", "ulConnector", "viewConnect", "UrlConnect", "urlEnvironment", "sslConn", "urConn", "termConn", " urlFactory", "blogConnection", "serviceConnection", "emailConnect", "urFunction", "uriConnection", "emailConnection", "UrlReference", "urlFunction", "urlConnector", "urlClient", "blogConnector", "UrlConn", "implConnection", "lConnection", "lengthConnect", "urlConnect", "htmlConnection", "UrlEnvironment", "lengthconnection", " urlComputer", "webPool", "urlUnit", "emailGate", "lengthConstruction", "glConnection", "resourceClient", "lconnection", "ulConn", " urlClient", "URLConnection", "resourceConnection", "httpConnection", "flConnect", "resourceconnection", "htmlconnection", " urlGate", "glFunction", " urlConnector", "URLPool", "URLconnection", "blogConnect", "UrlComputer", "viewConnection", "flConnector", "urlPool", " urlConn", "httpConn", " urlFunction", " urlConnect", "httpUnit", "termContainer", "sslConnection", "ulConnection", "serviceconnection"], "rd": ["dd", "td", "nd", "dr", "lr", "fr", "rx", " reader", "nor", "rowd", "nl", "dig", "lf", "bl", "arr", "rid", "DR", "xd", "rt", "RD", "RR", "adr", "ld", "ird", "wd", "RW", "respond", "rod", "vd", "rg", "usr", "rf", "r", "RL", "RF", "fd", "wr", "tr", "d", "rob", "bd", "erd", "ds", "rand", "bf", "red", "rr", "addr", "rh", "director", "dj", "gd", "std", "own", "rs", "hr", "rown", "sr", "R", "lt", "dh", "pd", "rn", "sth", "Reader", "reader", "rb", "rw", "rl", "ng", "ru", "rss", "db", "dra"], "line": ["lc", "link", "log", "letter", "unit", "login", "end", "nl", "val", "lf", "cl", "write", "lines", "entry", "inline", "skip", "LINE", "day", "ne", "Line", "key", "l", "ld", "page", "string", "code", "status", "pass", "d", "li", "part", "len", "frame", "row", "response", "number", "le", "block", "name", "la", "col", "word", "sel", "ge", "msg", "data", "id", "lo", "cell", "user", "limit", "file", "el", "sl", "rl", "error", "comment", "loc", "source", "lin"]}}
{"id1": "4223002", "id2": "19206412", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    public static String md5String(String str) {\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] hash = md.digest();\n            final char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n            StringBuffer res = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                res.append(hexChars[(0xF0 & hash[i]) >> 4]);\n                res.append(hexChars[0x0F & hash[i]]);\n            }\n            return res.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getPasswordMD5": ["getPasswordMAC256", "getPasswordSHA5", "getPasswordMAC5", "getPasswordMD512", "getPasswordMD256", "getpasswordMD512", "getPasswordMac1", "getPasswordMAC1", "getPasswordSHA512", "getPasswordMac512", "getpasswordMD1", "getPasswordMac256", "getpasswordSHA1", "getpasswordMD256", "getPasswordSHA256", "getPasswordMAC512", "getPasswordMac5", "getPasswordSHA1", "getpasswordSHA256", "getpasswordMD5", "getpasswordSHA5", "getpasswordSHA512", "getPasswordMD1"], "algorithm": ["Alest", " algorith", "calgorithm", "algebra", " alrator", "aggo", "Alignment", "Algo", "fgorithm", "Algorithm", "Alrator", "omalgo", "calgebra", "alm", " alm", "fgo", "Algorith", "alest", "fgebra", "gegorithm", "agrator", "omalgorithm", "geest", " alignment", "fgorith", "alrator", "calgorith", "alger", "algo", "omalphabet", " algo", "aggorithm", "Alger", "gem", "Alphabet", " alphabet", "Alm", "alignment", "agignment", "omalgorith", "Algebra", "alphabet", "algorith", "geger", "calgo", " alger", " alest"], "messageDigest": ["messagedigester", " messagedigEST", "messageModString", "phrasedigested", "phraseDigest", " messagedigest", "phrasedigest", "messageDigested", "phraseDigester", "MessageModested", "messagedigested", "messageDigester", "MessageModester", "messageModEST", "MessageModEST", "messageMDEST", "phrasedigester", "messageMDester", "messageDigString", "MessageDigest", "phraseDigested", "MessageDigested", "messagedigest", "MessageDigEST", "messageDEST", "messagedigString", " messageDigEST", "messageModester", "phraseDigEST", "messageDested", " messageDigString", "messageModested", "phrasedigEST", "messageMDString", " messagedigString", "MessageModest", "messageDigEST", "messageMDest", " messagedigester", "messageModest", " messageDigester", "MessageDigester", "messageDester", "messagedigEST", "messageDest"], "hexString": ["checkString", "hashStr", "hexstring", "hexArray", "hexLine", " hexArray", " hexStream", " hexBuffer", "shortstring", "textStream", "textArray", "checkStr", "hexBuffer", "shortArray", "hashFunction", "byteStream", "hexStream", "hashString", "byteArray", "checkFunction", "hexFunction", "textLine", " hexStr", "hashBuffer", "textBuffer", "byteString", "textString", " hexFunction", "hexStr", "byteLine", " hexstring", "shortString", "textstring", " hexLine", "checkBuffer", "shortBuffer"], "i": ["x", "volume", "f", "si", "ti", "ri", "s", "type", "slice", "m", "p", "j", "info", "pi", "ix", "hi", "I", "bi", "u", "b", "di", "multi", "l", "r", "fi", "e", "o", "key", "abi", "d", "ci", "t", "h", "xi", "v", "oi", "ui", "mi", "n", "li", "uri", "zi", "ii", "io", "c", "in", "id", "index", "a", "chi", "mu", "ai", "gi", "phi", "end"]}}
{"id1": "1769771", "id2": "812803", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["Copyfile", "copyChannel", "copyFiles", " copyfile", " copyChannel", "transferFile", "CopyChannel", "transferfile", " copyFiles", "transferChannel", "CopyFiles", "CopyFile", "transferFiles", "copyfile"], "in": ["reader", "bin", "lock", "login", "f", "data", "name", "ins", "pin", "m", "ex", "min", "In", "base", "inner", "again", "win", "l", "work", "query", "IN", "i", "source", "image", "inc", "url", "config", "io", "inn", "c", "file", "id", "index", "lin", "input", "diff"], "out": ["x", "extra", "ext", "name", "point", "p", "ex", "outs", "plain", "base", "conn", "b", "again", "output", "w", "user", "cache", "writer", "dot", "o", "off", "OUT", "external", "call", "image", "exec", "v", "default", "n", "server", "io", "c", "file", "up", "prefix", "resource", "target", "Out", "string", "write"], "inChannel": ["InClient", " inchannel", "INChannel", "binClient", "binStream", "INChan", "binchannel", "Inchannel", "outStream", "winStream", "InChan", "InStream", "insChannel", "inchannel", "winChannel", " inChan", "outchannel", "insChan", " inStream", "binChannel", "insStream", "outChan", "winchannel", "inClient", "INchannel", "inputChan", "insClient", "inputChannel", "inChan", "inputStream", "inputchannel", "inStream", "binChan", " inClient", "InChannel", "outClient", "INStream", "winChan"], "outChannel": ["nStream", " outStream", "outputCh", "inConnection", "outputController", "inCh", " outConnection", "outputStream", "outStream", "outputChan", "outManager", "inchannel", " outManager", "outchannel", "OutChan", "nChan", " outChan", "outChan", "inManager", " outCh", "outController", "outConnection", "Outchannel", "OutConnection", "inputChan", "outputchannel", "OutChannel", "inChan", "inputChannel", "outCh", "inputchannel", "inController", "nChannel", "nManager", "inStream", " outchannel", "outputChannel", "inputController"]}}
{"id1": "4223002", "id2": "16549995", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    public static String mysqlPasswordHash(String string) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(HashAlgorithms.SHA1);\n            try {\n                digest.update(string.getBytes(\"UTF-8\"));\n            } catch (UnsupportedEncodingException e) {\n                throw new RuntimeException(e);\n            }\n            byte[] encodedPassword = digest.digest();\n            digest.update(encodedPassword);\n            encodedPassword = digest.digest();\n            String hash = new BigInteger(1, encodedPassword).toString(16).toUpperCase();\n            while (hash.length() < 40) {\n                hash = \"0\" + hash;\n            }\n            return \"*\" + hash;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"getPasswordMD5": ["getPasswordMac5", "getPasswordSHA512", "getpasswordMD5", "getpasswordMD512", "getpasswordSHA5", "getpasswordSHA1", "getpasswordSHA256", "getpasswordMD1", "getPasswordMD256", "getPasswordMAC512", "getPasswordSHA1", "getPasswordMD512", "getPasswordSHA256", "getPasswordMD1", "getpasswordSHA512", "getPasswordMac256", "getPasswordMAC1", "getPasswordSHA5", "getPasswordMAC256", "getPasswordMac512", "getpasswordMD256", "getPasswordMAC5", "getPasswordMac1"], "algorithm": ["alm", " algo", "alger", "Alignment", "omalphabet", "agignment", "fgebra", " alignment", "omalgorithm", " algorith", "Alm", "geger", "aggorithm", "algo", "algorith", " alm", "fgo", " alger", "alrator", "calgebra", "Alger", "calgorith", "Alest", "alphabet", "aggo", "Algo", "Alphabet", "omalgorith", "gegorithm", "calgo", "algebra", "alignment", "gem", "Algebra", "Algorithm", " alrator", "fgorith", "fgorithm", " alphabet", "geest", "omalgo", "calgorithm", "Alrator", "agrator", " alest", "Algorith", "alest"], "messageDigest": ["messageModested", "MessageDigester", "messageMDest", " messagedigEST", "messagedigString", "messageDested", " messagedigString", "messageMDester", "messagedigest", " messagedigest", "messageDigString", "MessageDigEST", "phrasedigester", "messagedigester", "messageDigester", "MessageModEST", "messagedigEST", " messageDigester", "messageDEST", "MessageDigested", "phrasedigest", "phraseDigested", "messageModester", "messageDest", "messageModest", "messageModString", "MessageModester", "messageDester", "messageDigested", "messageDigEST", "messageModEST", "MessageModested", "messageMDEST", "messagedigested", "phraseDigester", "phraseDigEST", "MessageModest", "phrasedigested", "phrasedigEST", "MessageDigest", " messagedigester", "phraseDigest", " messageDigString", " messageDigEST", "messageMDString"], "hexString": ["checkString", "hexBuffer", "textstring", "hexArray", "hexLine", "hashStr", "hexstring", "shortString", " hexStr", "textStream", " hexBuffer", "checkFunction", " hexArray", "hashBuffer", " hexFunction", "hexStream", "textArray", "byteStream", "textString", "byteString", "hashFunction", "shortArray", "textLine", "hexStr", "hashString", " hexStream", "checkBuffer", "hexFunction", "shortBuffer", " hexstring", "textBuffer", "byteLine", "shortstring", "byteArray", "checkStr", " hexLine"], "i": ["index", "info", "id", "n", "pi", "uri", "mu", "slice", "c", "j", "end", "ri", "o", "volume", "l", "s", "fi", "si", "ui", "ii", "in", "key", "type", "ti", "d", "phi", "r", "chi", "li", "h", "x", "p", "mi", "bi", "u", "ai", "oi", "e", "I", "ci", "t", "m", "io", "zi", "xi", "di", "gi", "a", "hi", "v", "b", "abi", "multi", "f", "ix"]}}
{"id1": "19235551", "id2": "14502142", "code1": "    protected BufferedImage handleFCLAException() {\n        if (params.uri.startsWith(\"http://image11.fcla.edu/cgi\")) try {\n            params.uri = params.uri.substring(params.uri.indexOf(\"q1=\") + 3);\n            params.uri = params.uri.substring(0, params.uri.indexOf(\"&\"));\n            params.uri = \"http://image11.fcla.edu/m/map/thumb/\" + params.uri.substring(params.uri.length() - 3, params.uri.length() - 2) + \"/\" + params.uri.substring(params.uri.length() - 2, params.uri.length() - 1) + \"/\" + params.uri.substring(params.uri.length() - 1, params.uri.length()) + \"/\" + params.uri + \".jpg\";\n            URL url = new URL(params.uri);\n            URLConnection connection = url.openConnection();\n            return processNewUri(connection);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"handleFCLAException": [" handlePCLException", " handleFCLA1", " handleFCMAception", " handlePCLAError", " handleFCMA1", " handleFCLAception", " handleFCAError", " handleFCLException", " handleFCLAError", " handleFCMAError", " handleFCLError", " handlePCLAException", " handlePCLAception", " handleFCL1", " handleFCLception", " handlePCLA1", " handleFCA1", " handleFCAception", " handleFCMAException", " handlePCLception", " handlePCL1", " handlePCLError", " handleFCAException"], "params": ["image", "video", "words", "styles", "types", "same", "master", "i", "s", "tags", "global", "features", "http", "images", "apps", "api", "base", "vs", "res", "phys", "rules", "request", "details", "parse", "css", "json", "cache", "es", "module", "media", "param", "posts", "resources", "changes", "spec", "database", "errors", "status", "ops", "settings", "plugin", "as", "parts", "external", "vm", "models", "files", "rs", "ls", "core", "ams", "result", "services", "manager", "Parameters", "relations", "series", "names", "ps", "photos", "source", "plugins", "points", "pos", "server", "results", "members", "options", "model", "data", "type", "temp", "pins", "eps", "site", "list", "config"], "uri": ["image", "detail", "query", "i", "theme", "gi", "archive", "address", "http", "description", "link", "course", "prefix", "api", "mode", "volume", "uin", "href", "folder", "doi", "distance", "domain", "iri", "tile", "component", "eni", "oid", "multi", "URI", "title", "future", "route", "origin", "module", "path", "response", "message", "io", "umi", "unit", "database", "mi", "plugin", "duration", "service", "git", "slice", "nexus", "id", "cli", "directory", "core", "picture", "metadata", "direction", "ini", "ri", "wiki", "remote", "verb", "source", "filename", "containing", "transfer", "nuclear", "sequence", "version", "server", "ui", "location", "ori", "resource", "uni", "pi", "binary", "type", "license", "force", "site", "general", "menu", "username"], "url": ["image", "client", "sl", "object", "proxy", "user", "id", "page", "server", "open", "loc", "conn", "source", "target", "http", "location", "URL", "resource", "path", "li", "ssl", "file", "director", "link", "Url", "channel", "base", "system", "control", "l", "browser", "plugin", "string", "web", "window", "orb", "layer", "config"], "connection": ["image", "db", "client", "connect", "service", "relation", "socket", "object", "i", "proxy", "context", "character", "section", "handler", "server", "conn", "open", "result", "http", "response", "resource", "io", "con", "connected", "close", "channel", "data", "control", "database", "application", "document", "body", "string", "ion", "communication", "Connection", "config", "c", "condition"]}}
{"id1": "7458833", "id2": "8011262", "code1": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void uploadFile() {\n        String end = \"\\r\\n\";\n        String twoHyphens = \"--\";\n        String boundary = \"*****\";\n        try {\n            URL url = new URL(actionUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            con.setRequestProperty(\"Charset\", \"UTF-8\");\n            con.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary);\n            DataOutputStream ds = new DataOutputStream(con.getOutputStream());\n            ds.writeBytes(twoHyphens + boundary + end);\n            ds.writeBytes(\"Content-Disposition: form-data; \" + \"name=\\\"file1\\\";filename=\\\"\" + newName + \"\\\"\" + end);\n            ds.writeBytes(end);\n            FileInputStream fStream = new FileInputStream(uploadFile);\n            int bufferSize = 1024;\n            byte[] buffer = new byte[bufferSize];\n            int length = -1;\n            while ((length = fStream.read(buffer)) != -1) {\n                ds.write(buffer, 0, length);\n            }\n            ds.writeBytes(end);\n            ds.writeBytes(twoHyphens + boundary + twoHyphens + end);\n            fStream.close();\n            ds.flush();\n            InputStream is = con.getInputStream();\n            int ch;\n            StringBuffer b = new StringBuffer();\n            while ((ch = is.read()) != -1) {\n                b.append((char) ch);\n            }\n            showDialog(b.toString().trim());\n            ds.close();\n        } catch (Exception e) {\n            showDialog(\"\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"copyParseFileToCodeFile": [" copyParseFileTocodeFile", " copyParseFileToOutputfile", " copyParseFileToCodeClass", " copyParseFileToMapfile", " copyParseFileTocodeClass", " copyParseFiletoOutputfile", " copyParseFileTocodeFiles", " copyParseFileTocodefile", " copyParseFileToMapFile", " copyParseFiletoCodefile", " copyParseFileToCodefile", " copyParseFiletoOutputClass", " copyParseFiletoOutputFiles", " copyParseFileToMapFiles", " copyParseFiletoCodeFiles", " copyParseFiletoCodeFile", " copyParseFileToMapClass", " copyParseFiletoCodeClass", " copyParseFiletoOutputFile", " copyParseFileToOutputClass", " copyParseFileToOutputFiles", " copyParseFileToOutputFile", " copyParseFileToCodeFiles"], "in": ["ls", "as", "init", "gin", "inn", "pin", "inner", "f", "i", "input", "socket", "inside", "image", "read", "IN", "get", "m", "con", "win", "ini", "up", "n", "io", "din", "is", "nin", "min", "ins", "cin", "stream", "lin", "In", "impl", "inc", "again", "rin", "kin", "pull", "r", "err", "login", "oin", "id", "reader", "bin", "ic"], "out": ["work", "source", "as", "cache", "output", "sync", "client", "net", "inner", "this", "w", "ex", "i", "one", "socket", "OUT", "conn", "image", "writer", "other", "n", "io", "up", "bin", "log", "outer", "ext", "server", "exec", "post", "exp", "plain", "Out", "outs", "again", "file", "err", "o", "user", "parent", "inc"], "buffer": ["sequence", "source", "position", "shape", "cache", "result", "uf", "available", "pad", "buff", "fb", "buf", "event", "input", "uffer", "padding", "count", "read", "data", "duration", "total", "binary", "limit", "document", "base", "array", "null", "server", "capacity", "number", "address", "Buffer", "string", "channel", "queue", "layer", "raw", "batch", "reference", "iter", "pause", "request", "wave", "feed", "slice"], "length": ["sequence", "match", "style", "position", "shape", "Length", "path", "load", "point", "bb", "before", "len", "view", "level", "l", "ength", "count", "line", "duration", "total", "limit", "url", "character", "width", "code", "number", "address", "time", "index", "string", "size", "lock", "repeat", "range", "full", "block", "distance", "weight", "value", "part", "partial", "pull", "feed", "slice", "ob", "end", "id", "row", "type", "start", "offset", "volume"]}}
{"id1": "88047", "id2": "19096138", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void main(String[] args) {\n        String logFileName = args[0];\n        int extractLineEvery = new Integer(args[1]).intValue();\n        String filterToken = \"P0\";\n        if (args.length > 2) {\n            filterToken = args[2];\n        }\n        try {\n            BufferedReader br = new BufferedReader(new FileReader(logFileName));\n            BufferedWriter bw = new BufferedWriter(new FileWriter(new File(logFileName + \".trim\")));\n            String readLine;\n            int x = 0;\n            while ((readLine = br.readLine()) != null) {\n                if ((x++ % extractLineEvery == 0) && readLine.startsWith(filterToken)) {\n                    bw.write(readLine + \"\\n\");\n                }\n            }\n            bw.flush();\n            bw.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readAndRewwrite", "readandRewrite", "readandrewrites", "readAndSwrites", "readAndrewrite", "readAndRebrite", "readandRewwrite", "readAndrewwrite", "readAndRebrites", "readandrewwrite", "readandrewrap", "readAndSwwrite", "readandRewrap", "readandRewrites", "readAndrewrap", "readAndRewrites", "readAndrewrites", "readAndRebrap", "readAndRewrap", "readAndSwrap", "readandrewrite", "readAndSwrite", "readAndRebwrite"], "inFile": ["oldFilename", "InFiles", "Infile", "oldFiles", "loginFilename", "inputFile", "InFile", "InSourceFile", "loginFile", "infile", "oldfile", "inputFiles", "oldFile", " infile", "inputFilename", " inFilename", "loginfile", "outfile", "loginFiles", "inFilename", " inSourceFile", "outSourceFile", "inFiles", "outFiles", "outFilename", "inSourceFile", " inFiles", "inputfile"], "outFile": ["newDir", "thisfile", "outDir", "processPlace", "OutStream", "thisFILE", "OutDir", "outFILE", "newFile", "offFile", "offFILE", "thisFilename", "outputFILE", "outStream", "outputFilename", "offFilename", " outfile", "exfile", "offPlace", "processFILE", "outputPlace", "thisFile", "processFilename", " outStream", " outDir", "outputfile", "newfile", "newStream", "exFilename", "outfile", "exFILE", "outPlace", "OutFile", "processFile", "exFile", "Outfile", "outFilename", "outputFile"], "iis": ["Iis", "iiris", " iiss", "iiIs", "ciIs", "ciIS", "ciis", "Iiss", "Iais", "iniiss", "iniIs", "iiss", "iniris", "ciais", "iiiss", " iIS", "iniIS", " iais", "iIS", " iIs", "iiIS", "iIs", " iris", "iris", "ciiss", "iniis", "iiis", "IIS", "ciris", "iais"], "dcmParser": [" dcrPlugin", "dmParser", " dcmHelper", " dcmarser", "fcmHandler", "dpmPlugin", "dcrPar", "fpmParser", "dCMReader", "dcmLoader", " dcmPlugin", "dpmLanguage", "dkmParser", "fpmparser", "dcmHelper", " dpmLanguage", "dmcParser", "dbmPolicy", "dcrReader", "dmcPar", " dpmParser", "dmissionReader", "dCMHandler", " dcmparser", "dmissionPlugin", "dmPlugin", "dmmparser", "dCMParser", "dpmHandler", "dbmHelper", "dpmReader", "dpmInstallation", " dcrLoader", "dbmPlugin", " dpmarser", "dmmLoader", "dhemJar", "dmoduleparser", "DcmReader", " dcrParser", " dpmJar", "dcmPolicy", "DcmInstallation", "dhemInstallation", "dmcJar", " dpmPolicy", "dpmparser", " dpmHelper", "dmissionLanguage", "dcmPar", " dpmparser", "dcmReader", "dpmPar", "fpmHandler", "dmodulePlugin", "dkmPlugin", "dbmParser", "dcmparser", " dcmPar", "dkmPolicy", "dmoduleParser", "dcrPlugin", "fcmParser", "dCMPlugin", "dmoduleJar", "dmcarser", "dcmPlugin", "dmoduleReader", " dcmPolicy", "DcmJar", "dcrParser", " dpmPlugin", "dCMLoader", " dcrReader", "DcmParser", " dcmLanguage", "dpmJar", "dmissionParser", "dhemParser", "dcmarser", " dcmJar", "dcmInstallation", "dpmParser", "dCMparser", "dmmPlugin", "dcrLoader", "dcrarser", "fpmReader", " dpmPar", "dcrJar", "dpmLoader", " dpmLoader", "dmLoader", "dmmParser", " dpmReader", "dcmJar", "fcmReader", "dhemReader", "dkmHelper", "fcmparser", "dpmarser", "dpmHelper", "dpmPolicy", " dcmLoader", "dcmHandler", "dcmLanguage", "dmReader", " dcmReader"], "ds": ["sys", "services", "da", "Os", "ins", "Ds", "ays", "eps", "xs", "ts", "ils", "db", "vs", "tx", "ws", "nas", "ads", "df", "session", "ns", "ks", "asi", "ls", "s", "conn", "iss", "os", "dd", "Db", "gd", "des", "ys", "dat", "js", "cs", "vals", "drivers", "cdn", "ps", "sync", "pd", "dc", "parts", "uds", "ants", "dt", "dr", "di", "dds", "data", "is", "ld", "qs", "amps", "DS", "d", "src", "icks", "details", "utils", "points", "ss", "bs", "ros", "tes", "rs", "gs", "ras"], "pdReader": ["pcRead", "pcLoader", "dsreader", "hdWriter", "xdReader", "xdRead", "hdRunner", "hdStream", "pcWriter", "hdRead", "ddStream", "dsLoader", "pbRunner", "pcReader", "dsReader", "dsRead", "hdreader", "pbLoader", "hdLoader", "ddRunner", "pdLoader", "pbStream", "pdStream", "pdreader", "pdRunner", "dsWriter", "pbReader", "hdReader", "xdreader", "pdRead", "xdWriter", "ddReader", "ddLoader"], "out": ["external", "outs", "cache", "gen", "inc", "model", "session", "conn", "name", "doc", "ssl", "writer", "at", "null", "with", "data", "file", "full", "group", "part", "as", "client", "child", "term", "db", "dot", "s", "ext", "word", "to", "lock", "write", "down", "Out", "user", "object", "o", "her", "key", "store", "page", "in", "cli", "password", "device", "later", "net", "result", "base", "OUT", "w", "login", "io", "auto", "obj", "inner", "err", "lib", "code", "layer", "again", "parent", "over", "oder", "list", "outer", "copy", "director", "temp", "exec", "flow", "sys", "url", "img", "builder", "output", "exp", "default", "image", "order", "connection", "ex", " in", "co", "sync", "diff", "array", "point", "line", "up", "pass", "dev", "manager"], "dcmEncParam": ["dcmElType", "dcmEnParam", "dcmEstType", "dcmEstPar", "dcmDecPart", "dcmDecParameter", "dcmArchParameter", "dcmEnArg", "dcmEncArg", "dcmElPar", "dcmEncParameter", "dcmDecType", "dcmSecType", "dcmEncPart", "dcmDecParam", "dcmEnType", "dcmSecPart", "dcmEncType", "dcmArchParam", "dcmSecPar", "dcmEnPart", "dcmSecParam", "dcmDecArg", "dcmEnPar", "dcmEstParam", "dcmElParameter", "dcmElParam", "dcmEstParameter", "dcmDecPar", "dcmEnParameter", "dcmArchArg", "dcmEncPar"], "pdWriter": ["PDWrite", "dpWrite", "hdWriter", "htReader", "ddWrite", "dpReader", "pdWriting", "dsOutput", "dsReader", "dpWriter", "hdWrite", "PDWriter", "dpWriting", "PDReader", "htWriting", "dsWriter", "hdReader", "htWrite", "htWriter", "PDWriting", "ddWriter", "ddOutput", "hdOutput", "pdOutput", "dsWrite", "ddReader", "pdWrite"]}}
{"id1": "13852596", "id2": "21608109", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    public static boolean loadContentFromURL(String fromURL, String toFile) {\n        try {\n            URL url = new URL(\"http://bible-desktop.com/xml\" + fromURL);\n            File file = new File(toFile);\n            URLConnection ucon = url.openConnection();\n            InputStream is = ucon.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            ByteArrayBuffer baf = new ByteArrayBuffer(50);\n            int current = 0;\n            while ((current = bis.read()) != -1) {\n                baf.append((byte) current);\n            }\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baf.toByteArray());\n            fos.close();\n        } catch (IOException e) {\n            Log.e(TAG, e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"execute": ["create", "handle", "ute", "install", "load", "copy", "register", "all", "evaluate", "Exec", "test", "call", "parse", "run", "submit", "process", "exec", "transfer", "code", "server", " perform", " invoke", "report", "invoke", "start", "apply"], "resources": ["ids", "pages", "thumbnails", "images", "maps", "issues", "groups", "services", "results", "events", "relations", "works", "cells", "items", "models", "Resources", "files", "features", "roots", "stores", "apps", "workers", "flows", "writers", "strings", "scripts", "chains", "rates", "archives", "rings", "stars", "objects", "classes", "ions", "series", "locks", "params", "users", "projects", "resource", "rules", "reports", "types", "plugins"], "i": ["f", "si", "ti", "ri", "iri", "s", "ori", "j", "info", "pi", "p", "k", "ie", "is", "hi", "bi", "di", "I", "u", "multi", "ami", "qi", "l", "e", "o", "ini", "abi", "cli", "ci", "we", "h", "xi", "oi", "v", "ui", "li", "ir", "uri", "ani", "ii", "io", "id", "iu", "mu", "vi", "ic", "eni", "gi", "ai", "phi", "esi", "ip", "wei", "isi"], "classFile": ["ClassFILE", "finalUrl", "ClassPath", "fileDirectory", "ruleFiles", "CLASSEntry", "ClassEntry", "connectionStream", "finalFile", "finalfile", "Classfile", "classClass", " classFactory", "classFilename", "sessionEntry", "CLASSImage", "classfile", " classFiles", "serviceFile", "ClassClass", " classfile", "ClassDir", "classFILE", "fileFiles", "customEntry", "ClassFiles", "lassGlobal", " classPage", "classFactory", "sessionFactory", "sessionFile", "lassClass", "ClassLine", "baseFile", "ClassPage", "CLASSFile", "classLine", "ruleFile", "staticfile", "ClassFactory", "sessionFiles", "lassFile", "classPath", "connectionFiles", "classFiles", "packEntry", " classStream", "customFiles", "classImage", "servicefile", "classEntry", "packfile", " classGlobal", "CLASSFILE", "sessionfile", "basefile", "ClassStream", " classFILE", "classStream", "classesFiles", "classLoader", "CLASSUrl", " classFilename", "classesFile", " classClass", "ClassImage", "CLASSfile", "ClassFile", "ClassGlobal", "objectDir", "fileImage", "CLASSLoader", "ClassFilename", "objectFile", "lassFiles", "objectfile", "baseFILE", "CLASSFiles", "CLASSDirectory", " classLine", "ruleFilename", " classLoader", " classPath", "baseUrl", "packFile", "customFILE", "ClassDirectory", "CLASSLine", "fileLine", "finalFILE", "customFile", "CLASSPage", "staticLine", "staticFile", "classPage", "connectionfile", "serviceLine", "staticFILE", "classDirectory", " classDir", "ruleLine", "classesfile", "serviceFILE", "sessionFILE", "classesPath", "fileLoader", "fileFile", "classDir", "connectionFile", " classEntry", "classGlobal", "objectFiles", "packFILE", "filefile", "classUrl"], "inputStream": ["binaryFile", "inputFile", "childstream", " inputstream", "inputSteam", "InputSw", "outputReader", "uploadFile", "outputFile", "initStream", "binaryStream", "initSteam", "outputSw", "childStream", "InputStream", " inputReader", "InputStreamer", "rawStreamer", "inputSw", "inputContext", "binaryStreamer", "outputStreamer", "binarySteam", "uploadSw", "inputStreamer", "childContext", " inputStreamer", "outputContext", "activeStreamer", "childReader", "rawStream", "rawSteam", " inputFile", "uploadStream", "importStream", "activestream", "activeStream", "initstream", "Inputstream", "InputFile", "uploadstream", "importSteam", " inputContext", "outputSteam", "rawFile", "initStreamer", "activeSteam", "InputSteam", "inputstream", "importstream", " inputSteam", "inputReader", "outputstream", "importStreamer"], "reader": ["iter", "er", "director", "manager", "ri", "handler", "book", "worker", "seed", "stream", "sync", "layer", "shared", "ger", "arser", "per", "rc", "copy", "keeper", "inner", "loader", "wrapper", "rer", "parser", "writers", "client", "key", "dr", "rr", "row", "buffer", "source", "ner", "entry", "oder", "war", "builder", "driver", "or", "request", "reflect", "system", "context", "reading", "read", "server", "author", "io", "owner", "http", "draft", "rar", "right", "resource", "input", "riter", "report", "re", "Writer", "ler", "ee", "Reader", "editor", "rx"], "oldSize": ["OldName", "oldName", "prevLength", "oldSc", "OldSize", "oldLength", "prevName", "prevSize", "OldSc", " oldLength", " oldName", "prevSc", " oldSc", "OldLength"], "writer": ["iter", "er", "director", "data", "manager", "widget", "handler", "writ", "worker", "creator", "string", "winner", "dc", "format", "maker", "writing", "w", "loader", "wrapper", "inner", "walker", "her", "r", "engine", "e", "parser", "writers", "row", "buffer", "ner", "service", "player", "oder", "war", "child", "builder", "driver", "write", "rw", "object", "document", "read", "author", "io", "element", "wr", "wire", "draft", "wer", "word", "index", "written", "resource", "token", "riter", "report", "Writer", "ler", "ee", "Reader", "editor"], "b": ["be", "abc", "bin", "bd", "f", "g", "m", "boot", "p", "k", "eb", "binary", "base", "bb", "u", "B", "w", "br", "l", "r", "e", "rb", "buffer", "d", "bar", "emb", "db", "lb", "ba", "h", "object", "null", "ab", "c", "a", "orb", "fb", "pb", "ob"], "outputStream": ["inputSteam", "outstream", "OutputSteam", "dataContainer", "protectedStreamer", "dataStream", " outputView", "outStream", "OutputStreamer", "protectedStream", "inputContainer", "outSteam", "dataStreamer", "inputView", "OutputStream", "outputStreamer", "Outputstream", "inputStreamer", " outputstream", "outStreamer", "protectedstream", "protectedSteam", " outputContainer", " outputSteam", "outputSteam", "outputView", "dataSteam", "inputstream", " outputStreamer", "outputstream", "outputContainer", "OutputView"], "injectedClasses": ["injectionclassies", "injectionClasses", "injectedWritites", "injectedclassites", "injectionClassites", "injectedClassies", "injectedClassites", "injectedProjecties", "injectedWrits", "injectedclasss", "injectionclasss", "injectedProjectes", "injectionClasss", "injectedProjects", "injectedWrites", "injectedWrities", "injectedClasss", "injectionclasses", "injectedProjectites", "injectionclassites", "injectionClassies", "injectedclassies", "injectedclasses"], "newSize": ["NewLength", "NewSize", "newFontSize", "finalLength", " newLength", " newFontSize", "NewFontSize", "finalSize", "newStorage", "finalFontSize", "NewStorage", "newLength", "finalStorage", " newStorage"]}}
{"id1": "6625074", "id2": "7948308", "code1": "    public static String SHA1(String text) {\n        byte[] sha1hash = new byte[40];\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n            sha1hash = md.digest();\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Converter.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return convertToHex(sha1hash);\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            logger.error(\"At RandomGUID !!!\", e);\n        }\n    }\n", "label": 1, "substitutes": {"SHA1": ["sha256", "HAOne", "SHA384", " SHA384", "HA384", "SHAOne", " SHA256", " SHAOne", "sha384", "HA256", "shaOne", "sha1", "HA1", "SHA256"], "text": ["letter", "string", "path", "translation", "class", "buffer", "input", "editor", "output", "token", "Text", "message", "TEXT", "plain", "hex", "in", "pattern", "content", "password", "txt", "source", "value", "str", "config", "data", "out", "object", "struct", "context", "format", "test", "name", "template", "image", "font", "word", "bytes", "ext", "contract", "obj", " Text", "transfer", "code"], "sha1hash": ["sha_Hash", "sha256password", "SHA1Hash", "ha2sum", "shaOnetext", "sha256Hash", "shaOneHash", "ha2hex", "sha1text", "sha256hash", "sha81hash", "sha6hash", "sha6cap", "sha_hex", "shaOnehash", "ha1hex", "ha1hash", "sha6log", "SHA2cap", "sha2hex", "ha2hash", "sha1password", "SHA1text", "SHA1log", "ha2Hash", "shaOnepassword", "sha_hash", "sha2Hash", "sha1Hash", "sha81log", "sha6Hash", "sha2cap", "sha256text", "sha1sum", "SHA1hash", "sha1log", "sha2sum", "sha81cap", "SHA2Hash", "SHA1password", "sha1cap", "sha81Hash", "sha2log", "SHA1cap", "SHA2log", "sha2hash", "sha_sum", "ha1sum", "sha1hex", "ha1Hash", "SHA2hash"], "md": ["pkg", "editor", "um", "mag", "bd", "df", "cf", "od", "amd", "mo", "ma", "meta", "wd", "MD", " MD", "ms", "rpm", "ad", "ld", "sm", "gb", "mb", "mt", "d", "mac", "mp", "hd", "sha", "pm", "pd", "de", "mm", "nd", "metadata", "cd", "dig", "m", "hm", "dm", "nm", "mc", "vd", "rm", "f", "cmd", "dd", "hash"]}}
{"id1": "4398382", "id2": "21930714", "code1": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "code2": "    @Test\n    public void testSpeedyShareUpload() throws Exception {\n        request.setUrl(\"http://www.speedyshare.com/upload.php\");\n        request.setFile(\"fileup0\", file);\n        HttpResponse response = httpClient.execute(request);\n        assertTrue(response.is2xxSuccess());\n        assertTrue(response.getResponseHeaders().size() > 0);\n        String body = IOUtils.toString(response.getResponseBody());\n        assertTrue(body.contains(\"Download link\"));\n        assertTrue(body.contains(\"Delete password\"));\n        response.close();\n    }\n", "label": 0, "substitutes": {"digest": ["Digse", "mdested", "mdests", "mdest", "encse", "encester", "digester", "generests", " digse", " digests", "Digester", "generester", "generested", "digests", "digress", " digress", "mdester", "Digress", "encest", "encress", "digested", "generest", " digested", "digse", "Digest", " digester"], "algorithm": ["malgebra", "alignment", "malignment", " algebra", "algo", "aloding", "Alignment", "aroding", " algo", "algebra", "Algebra", "challenge", "Algo", "argebra", " alenge", "challgo", "argorithm", "alenge", "Algorithm", "malgorithm", "Alenge", "challgebra", "maloding", "arignment", "challgorithm", "Aloding"], "text": ["image", "letter", "feed", "config", "content", "sequence", "format", "input", "pattern", "message", "output", "password", "bytes", "object", "struct", "string", "txt", "code", "TEXT", "buffer", "Text", "token", "path", "attribute", "secret", "length", "name", "test", "ext", "word", "data", "username", "str", "value", "connection", "source", "url", "address"], "mDigest": ["mGest", " mGester", "mSignEST", "mGast", "MDiger", "amPostest", "mDester", "MDigEST", "MDigest", " mGge", "amPostested", "mDenge", "mDesigngest", "mDiggest", "mSignast", "mDEST", "mDgest", "mCodener", "mSignge", "mSignest", "mDer", "mGge", "MDigenge", "mDesignest", "mPostested", "mdiger", " mGast", " mDigast", "mdigener", "mDesigner", "mSignester", "MDer", "mDest", "mPostener", "mCodest", " mDigester", "MDester", "MDgest", "mEncge", "mDigener", "mDesignester", "amDigested", "mPostest", "mdigester", "mSignenge", "mDigester", "mDigenge", "mDiger", "mEncast", "mGester", "MDiggest", "mdiggest", "amDigest", " mGest", "MDest", "mDigEST", "mDigast", "mDigge", "mEncest", " mDigge", "mdigested", "mCodested", "mEncester", "mdigest", "mDigested", "amDigener", "amPostener", "MDigester"], "raw": ["image", "Raw", "enc", "feed", "hex", "content", "input", "json", "none", "serial", "message", "output", "full", "null", "array", "buf", "orig", "initial", "buffer", "original", "wrap", "result", "container", "row", "response", "unsigned", "clean", "internal", "data", "binary", "RAW", "instance", "default", "partial", "source"], "encoder": ["decoding", "deccode", "enccode", "Encoding", "eccode", " encoded", "ecoding", " encoding", "encoded", "Encoded", "encoding", "Encoder", "ecoded", "ecoder", "decode", "ecode", "encode", "enoder", "decoder", " encode", "enode", "Encode", "enoding"]}}
{"id1": "10759917", "id2": "17193692", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    public void execUpdate(String sqlStmts[]) throws SQLException {\n        if (conn == null || conn.isClosed()) throw new SQLException(\"The connection has not been established yet.\");\n        if (sqlStmts == null || sqlStmts.length == 0) throw new SQLException(\"SQL-statement is null.\");\n        conn.setAutoCommit(false);\n        try {\n            for (int i = 0; i < sqlStmts.length; i++) {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sqlStmts[i]);\n                logger.debug(sqlStmts[i]);\n                stmt.close();\n            }\n            conn.commit();\n        } catch (SQLException ex) {\n            conn.rollback();\n            throw ex;\n        }\n    }\n", "label": 1, "substitutes": {"delete": ["get", " deletion", "de", "del", "save", "sync", " Delete", " deleting", "load", "write", "id", "Delete", "register", "connection", "post", "link", "exec", "update", "execute", "drop", "database", "remove", " destroy", "destroy", "flush", "dump", "create"], "name": ["client", "size", "one", "n", "label", "key", "class", "old", "object", "comment", "action", "default", "version", "e", "parent", "id", "on", "address", "ame", "info", "alias", "code", "time", "path", "resource", "word", "value", "now", "part", "NAME", "link", "space", "url", "prefix", "no", "null", "none", "pass", "model", "active", "data", "type", "missing", "definition", "base", "false", "database", "Name", "names", "table", "true", "style", "string", "named", "like", "create", "filename"], "CannotDeleteSystemLinkException": ["CannotDeleteSysLinkError", "CannotDeleteSystemLinkError", "CannotDeleteSystemLinkception", "CannotDeleteSystemReferenceEx", "CannotDeleteSystemRelException", "CannotDeleteSystemLinkEx", "CannotDeleteSystemRelception", "CannotDeleteSystemReferenceError", "CannotDeleteSystemRelError", "CannotDeleteSystemLinksApplication", "CannotDeleteClassLinkInformation", "CannotDeleteSysLinkException", "CannotDeleteSystemLinkInformation", "CannotDeleteSystemRelEx", "CannotDeleteSystemlinkApplication", "CannotDeleteSysLinkEx", "CannotDeleteSystemLinkApplication", "CannotDeleteSystemLinksInformation", "CannotDeleteClassLinkException", "CannotDeleteSystemLinksException", "CannotDeleteClassLinkApplication", "CannotDeleteSystemlinkException", "CannotDeleteSysLinkception", "CannotDeleteSystemReferenceception", "CannotDeleteSystemLinksception", "CannotDeleteSystemlinkception", "CannotDeleteSystemReferenceException", "CannotDeleteClassLinkception", "CannotDeleteSystemlinkInformation"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeNotfoundError", "ClassLinkTypeNotSourceError", "ClassLinkTypeNotFoundError", "ClassLinkTypeNotSourceException", "ClassLinkTypeNotfoundException", "ClassLinkTypeNotSourceRequest", "ClassLinkTypeNotfoundRequest", "ClassLinkTypeNotFoundRequest"], "conn": ["orp", "db", "error", "client", "connect", "ca", "Conn", "h", "p", "query", "ctx", "n", "oss", "sync", "cond", "cp", "cn", "cc", "pg", "ou", "cat", "ns", "bb", "cli", "nt", "ci", "po", "core", "cache", "coll", "server", "cb", "loc", "ann", "open", "dn", "lc", "connection", "nc", "dc", "ver", "cur", "cm", "ob", "ssl", "con", "conf", "uc", "pub", "util", "close", "ch", "enc", "serv", "exec", "oci", "session", "ac", "rt", "org", "ct", "pc", "co", "mc", "Connection", "lock", "act", "config", "c", "pr", "ec"], "stmt": [" stm", "stdd", "strnt", "rdmt", "STsql", "istmd", "Stm", "Stdt", "stlt", "estsql", " stdb", "sthdb", " stmn", "strlt", "Stmd", "playnt", "rddd", "STdd", "stdt", "playmt", "strmb", "stmd", "stmp", "strmt", "Stmm", "strdd", " stmd", "ctm", "sthmt", "istmt", "Stmp", " stdd", "strmd", "estlt", "Stmb", "strsql", "strob", "stob", "STmt", "strmm", "strmp", "rdmd", "strm", "STlt", "sthmd", "estmt", "playmd", " stob", "ctmd", "stm", "istnt", " stmm", "istdt", " stnt", "ctmt", "stmm", "Stnt", " stmb", "estdd", " stsql", "ctmb", "stnt", "Stmt", "sthmn", "stsql", "stmn", "Stmn", "playdt", "Stdb", "stmb", " stmp", "stdb", "rdsql", "Stob"], "prepTable": ["supable", "PrepType", " preptable", "parTable", "preptable", " prepable", "parCol", "suptable", "parType", "supTable", "inittable", "prepable", "partable", "Preptable", "PrepTable", "prepType", "initType", " prepType", " prepCol", "supType", "Prepable", "initCol", "initTable", "prepCol"], "objectLinkTable": ["objLinkStore", "objlinkType", "objectlinkChain", "objectlinkType", "objlinkChain", "objectSyncStore", "objectlinkSource", "objectTypeFile", "ObjectLinkTable", "ObjectLineTable", "objectLinkChain", "ObjectLineTab", "ObjectLinkFile", "objectSyncChain", "objectLinkFile", "ObjectLinkSource", "objectLineSource", "objectRelTable", "objectLinkSource", "objLinkType", "objlinkTable", "objectTypeTab", "objectTypeTable", "objectRelChain", "objectTypeSource", "objectLineFile", "objectlinkFile", "objectlinkTab", "objLinkTable", "objectRelType", "ObjectLinkTab", "objlinkStore", "objLinkChain", "objectlinkStore", "ObjectLineSource", "objectLineTab", "objectRelStore", "objectSyncTable", "objectLinkStore", "objectLineTable", "ObjectLineFile", "objectlinkTable", "objectLinkTab", "objectSyncType", "objectLinkType"], "sql": ["db", "su", "term", "query", "sl", "summary", "s", "comment", "ls", "id", "statement", " SQL", "expression", "SQL", "sb", "sg", "sf", "result", "pr", "params", "ssl", "csv", "description", "function", "str", "url", "update", "zip", "sq", "log", "spec", "dl", "shell", "ql", "string", "general", "insert", "sv", "cmd", "join", "select"]}}
{"id1": "4602568", "id2": "22503685", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "label": 0, "substitutes": {"storeImage": ["processIcon", "processVideo", "storeMedia", " storeVideo", "processImage", " storeMedia", "storeVideo", "processMedia", " storeIcon", " transferIcon", "storeIcon", " transferMedia", " transferImage", " transferVideo"], "inStream": [" inReader", "winStream", "winSteam", "winVideo", "inputPath", "inputstream", "inSteam", "inputStream", "winReader", "INStream", "inCh", " instream", "inPath", " inVideo", "INPath", "INCh", " inPath", "inReader", " inSteam", " inCh", "inputSteam", "INstream", "inputReader", "instream", "inputVideo", "inVideo", "inputCh"], "fileName": ["httpname", "fileNames", " filePath", "imageName", "httpName", "filePath", "FILEName", "resourceInfo", "filename", "imageNames", "FileInfo", " fileNames", " filePart", " fileNode", "FILEPath", "FilePart", "FilePath", "fileInstance", "filePart", "imagename", "FILEInstance", "FileName", "FileInstance", "Filename", " fileInstance", " filename", "FileNames", "fileNode", "FILEname", "resourceName", " fileInfo", "httpPath", "resourceNode", "fileInfo", "httpPart", "imagePath", "FILENode", "resourcename", "FILEInfo"], "resize": [" Resized", " Resizes", "resizes", " Resizer", " resizer", " Resize", "resized", "Resize", " resizes", "Resizer", "resizer", " resized", "Resizes", "Resized"], "rightNow": ["thirdThen", "straightAccount", "thirdnow", "thirdCurrent", "dayNOW", "thirdNOW", " rightnow", "thirdNow", "thirdToday", "dayNow", "dayToday", " rightAccount", "RightAccount", "rightNOW", "rightAccount", "straightToday", "dayCurrent", "RightToday", "rightnow", " rightToday", "straightNow", " rightThen", " rightNOW", " rightCurrent", "Rightnow", "RightNow", "rightToday", "straightnow", "RightCurrent", "RightNOW", "rightCurrent", "rightThen"], "dayNamedFolderName": ["dayNestedDirectoryname", "dayNamedFoldername", "dayNamedFolderPath", "dayNamedAreaSize", "dayNamedFolderInfo", "dayNamedfolderName", "dayNamedFolderSize", "dayNestedFolderSize", "dayNestedFolderName", "dayNamedFileKey", "dayNamedFileInfo", "dayNamingFolderName", "dayNamedfolderInfo", "dayNestedDirectorySize", "dayNnamedFolderInfo", "dayNestedDirectoryName", "dayNestedDirectoryPath", "dayNamedDirName", "dayNamingFolderKey", "dayNamedDirInfo", "dayNamingFolderSize", "dayNamedAreaname", "dayNamedAreaName", "dayNnamedFolderSize", "dayNamedDirectoryName", "dayNnamedFolderName", "dayNestedFoldername", "dayNamedFilePath", "dayNamedDirSize", "dayNamedfoldername", "dayNnamedFolderPath", "dayNamedDirectoryname", "dayNamedfolderPath", "dayNamedDirectorySize", "dayNamingFolderInfo", "dayNamedfolderSize", "dayNestedFolderPath", "dayNamedFolderKey", "dayNamedDirectoryPath", "dayNamedFileName", "dayNamedFileSize", "dayNamedAreaPath", "dayNamedDirKey"], "uploadDirRoot": [" uploadFileRoot", "uploadFolderroot", "inputDirName", " uploadDirroot", " uploadDirHome", "uploadFolderBase", "uploadFilePath", "uploadDirectoryBase", "inputDirRoot", "UploadFolderRoot", "uploaddirroot", "uploadBaseroot", "uploadBaseRoot", "uploadDbHome", "UploadDirroot", "uploadBasePath", "inputDirectoryName", "UploadFolderroot", "uploadDirPath", "UploadFolderBase", "uploadFileRoot", "uploadDirectoryPath", "uploadDbRoot", "uploadDirroot", "inputDirectoryHome", "UploadDirPath", "uploadDirectoryRoot", "uploadFolderRoot", "uploadFileHome", "uploadDirHome", "inputDirPath", "inputDirectoryPath", "UploadDirRoot", "uploadDirBase", "uploadDbName", "inputDirHome", "uploaddirHome", "inputDirectoryRoot", "uploadDirectoryHome", "uploadDirName", "uploadBaseBase", "UploadFolderPath", "uploadDbPath", "uploadFileroot", "uploadDirectoryName", "uploadDirectoryroot", "uploaddirRoot", " uploadFileHome", "uploadFolderPath", "uploadFileName", "UploadDirBase", " uploadFileroot"], "file": ["File", "image", "folder", "log", "base", "flow", "unit", "service", "child", "model", "force", "view", "rule", "function", "ile", "entry", "fe", "up", "http", "zip", "local", "b", "full", "object", "auto", "page", "home", "url", "class", "pe", "files", "path", "work", "handler", "p", "line", "part", "out", "fp", "book", "dir", "FILE", "name", "user", "document", "e", "comment", "per", "lib", "connection", "parent", "f", "directory"], "extension": ["exversion", "exion", "extend", "exension", "intension", "xtend", "ExtION", "intION", "EXTdivision", "Extend", "intend", "xtion", "interion", "interension", "exdivision", "EXTversion", "xtION", "extdivision", "extversion", "extION", "interdivision", "Extension", "EXTension", "Extion", "intion", "interversion", "xtension", "extion", "EXTion"], "outFileName": ["outLineLocation", " outFileSystem", "inLinePath", "outPathType", "inFilePath", "inFileKey", "OutDirInfo", "OutFileInfo", "outFileKey", "outPathPath", "outfileLocation", " outFilename", "outDirInfo", "outFileType", "inFileInfo", "outLinePart", "outFolderLine", "outPlaceAddress", "outPlaceSystem", "OutDirLength", "outLinename", "outFileLength", "inLineInfo", " outPlaceLine", "outFieldSystem", " outFilePath", "outFolderInfo", "OutDirName", "outLineSize", "outLineName", "outfileLength", "outPathName", "outFileInfo", "outDirName", "outLineType", "outfileName", "outFolderPath", "inLinePart", " outFileAddress", "outFileLine", "outDirPart", "outPlaceLocation", " outPlaceAddress", "outfileSize", "outFullKey", "OutFileName", "outPlaceSize", "inLineName", "outLinePath", "outLineKey", "outFullPart", "outPathname", "outLineLength", " outPlaceLocation", "outFilePart", "outFieldLine", " outPlacePath", "outFieldAddress", "outfilePath", " outFileSize", "outFilePath", "outFilename", "outDirLength", "outFileSize", "outFileLocation", "OutDirPath", " outFileLine", "inLineKey", " outPlacename", " outPlaceSystem", "outLineInfo", "outPlaceLine", "outFolderName", "inFileLine", "outPlaceName", " outFileType", "outfileInfo", "outFieldName", " outPlaceName", " outPlaceSize", "outPlaceType", "OutFileLength", "outPlacename", "outDirLine", "outDirKey", "outFullPath", "outFolderAddress", "OutFilePath", "inFileName", "inLineLine", "outFolderSystem", "outPlacePath", "outDirPath", "outFileAddress", " outFileLocation", " outPlaceType", "outFileSystem", "inFilePart", "outFullName", "outLineLine"], "outPathAndName": ["outPathANDPath", "outNameOrAddress", "outPathOrRam", "outpathAndTime", "outNameOrName", "outpathOrPath", "outPathANDRam", "outNameOrPath", "outPathandNames", "outPathANDNames", "outPathOrPath", "outNameOrRam", "outpathOrNames", "outPathANDAddress", "outpathAndname", "outPathOrname", "outPathOrTime", "outNameAndRam", "outpathAndName", "outPathANDTime", "outNameAndPath", "outNameAndAddress", "outPathandPath", "outPathOrNames", "outPathOrAddress", "outPathAndPath", "outPathandName", "outPathAndRam", "outPathAndname", "outpathAndNames", "outpathAndPath", "outPathAndNames", "outPathOrName", "outNameAndName", "outPathAndAddress", "outPathAndTime", "outPathANDname", "outPathANDName", "outpathOrName"], "uploadedFile": ["uploadenedFile", "UploadpedFiles", "uploadendedPath", "uploadatedFiles", "UploadedImage", "uploadedImage", "uploadizedImage", "uploadedFull", "uploadededFull", "uploadchedF", "processedF", "uploadedF", "processedPath", "UploadedFolder", "uploadizedFull", "uploadenedFiles", "processchedF", "uploadedfile", "UploadedFull", "UploadpedImage", "uploadendedF", "uploadedFolder", "uploadratedfile", "uploadededImage", "processchedPath", "uploadratedPath", "UploadpedFull", "uploadchedFile", "processedfile", "uploadatedfile", "uploadpedfile", "uploadratedFile", "uploadchedPath", "uploadedPath", "UploadpedFile", "uploadatedFolder", "UploadpedFolder", "processedFile", "UploadedFile", "uploadpedFull", "processchedfile", "Uploadpedfile", "uploadendedfile", "uploadizedFiles", "processchedFile", "uploadedFiles", "uploadpedFile", "uploadenedfile", "uploadatedFile", "uploadededFiles", "uploadededFile", "uploadizedFile", "uploadratedF", "uploadpedFolder", "Uploadedfile", "uploadpedImage", "uploadendedFile", "uploadchedfile", "uploadpedFiles", "UploadedFiles", "uploadenedFolder"], "outStream": ["_", "tempFile", "URL", "format", "outFile", " outFile", "Url", "tempSteam", "inFile", "inSteam", "Type", "Bytes", "Directory", "tempBuffer", "New", "inBuffer", " outBuffer", "outSteam", "tempStream", "Copy", "s", " outSteam", "url", "outBuffer"]}}
{"id1": "2518655", "id2": "8801436", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public static void copy(File from_file, File to_file) throws IOException {\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_file.getName());\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_file.getName());\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_file.getName());\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_file.getName());\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fnOut": ["fpOutput", "fnEx", "lsOutput", "fnIn", "FNOut", "lsOut", "FNIn", "FNOutput", "lsOUT", " fnOUT", "fpEx", "fpOUT", "FNEx", " fnFile", "fnOutput", " fnIn", "fnOUT", "fnFile", "fpFile", " fnOutput", " fnEx", "fpOut", "fpIn", "lsFile"], "writer": ["fd", "widget", "wr", "write", "server", "outer", "writing", "parser", "socket", "writ", "output", "entry", "winner", "editor", "Writer", "key", "out", "ws", "temp", "nw", "builder", "driver", "reader", "war", "riter", "a", "work", "er", "worker", "inner", "usher", "walker", "r", "wa", "handler", "file", "wire", "loader", "w", "per", "writers", "layer", "ler", "word", "buffer", "director"], "i": ["k", "m", "u", "z", "uri", "e", "j", "b", "n", "fi", "ori", "io", "si", "ie", "part", "f", "o", "index", "ci", "h", "type", "s", "iu", "oi", "key", "abi", "ji", "multi", "li", "di", "mi", "ip", "pi", "hi", "xi", "eni", "id", "ti", "v", "gi", "c", "ri", "I", "ai", "ix", "phi", "chi", "ii", "ui", "x", "bi", "ini", "qi", "strength", "p"], "fInput": ["fFormat", " fFormat", "sfinput", "finput", "sfFormat", " fOutput", "fSource", " finput", "fileinput", "fileFormat", "fileInput", "fileSource", "sfInput", "fOutput", "sfSource", "sfOutput", "fileOutput", " fSource"], "in": ["ln", "ins", "In", "b", "n", "connection", "scan", "init", "data", "version", "ner", "reading", "inc", "socket", "f", "gin", "input", "vin", "din", "IN", "inn", "lin", "inas", "out", "s", "conn", "cin", "sin", "kin", "rin", "reader", "win", "inside", "nin", "login", "inner", "min", "id", "bin", "c", "pin", "ini", "again", "line", "isin"]}}
{"id1": "12537270", "id2": "12490144", "code1": "    public Vector parse(String link) {\n        addMessage(\"Parsing: \" + link);\n        links.removeAllElements();\n        URLConnection conn = null;\n        Reader rd = null;\n        EditorKit kit = new HTMLEditorKit();\n        Document doc = kit.createDefaultDocument();\n        doc.putProperty(\"IgnoreCharsetDirective\", Boolean.TRUE);\n        URL url = null;\n        try {\n            url = new URL(link);\n        } catch (MalformedURLException err) {\n            System.out.println(\"Malformed URL\");\n            return links;\n        }\n        try {\n            conn = new URL(link).openConnection();\n            rd = new InputStreamReader(conn.getInputStream());\n        } catch (Exception err) {\n            err.printStackTrace();\n            return links;\n        }\n        try {\n            kit.read(rd, doc, 0);\n            ElementIterator it = new ElementIterator(doc);\n            javax.swing.text.Element elem;\n            while ((elem = it.next()) != null) {\n                SimpleAttributeSet s = (SimpleAttributeSet) elem.getAttributes().getAttribute(HTML.Tag.A);\n                if (s != null) {\n                    if (s.toString().indexOf(\"script\") >= 0) continue;\n                    String lnk = \"\";\n                    try {\n                        lnk = s.getAttribute(HTML.Attribute.HREF).toString();\n                    } catch (Exception err) {\n                        continue;\n                    }\n                    int j = 0;\n                    if ((j = lnk.indexOf('#')) >= 0) lnk = lnk.substring(0, j);\n                    URL urlLink = new URL(url, lnk);\n                    if (!url.getHost().equals(urlLink.getHost())) continue;\n                    String str = urlLink.toString();\n                    if (!str.startsWith(\"http\")) continue;\n                    if (str.endsWith(\".pdf\")) {\n                        continue;\n                    }\n                    for (int i = 0; i < leaveSuffix.length; i++) {\n                        if ((str.endsWith(leaveSuffix[i]))) continue;\n                    }\n                    boolean skip = false;\n                    for (int i = 0; i < suffix.length; i++) {\n                        if ((str.endsWith(suffix[i]))) skip = true;\n                    }\n                    if (!skip) {\n                        try {\n                            conn = urlLink.openConnection();\n                        } catch (Exception err) {\n                        }\n                        String contentType = null;\n                        if (contentType == null) contentType = conn.getContentType();\n                        if (contentType.equals(\"application/pdf\")) {\n                            continue;\n                        } else if (!contentType.equals(\"text/html\")) {\n                            continue;\n                        }\n                    }\n                    if (!links.contains(urlLink.toString())) {\n                        links.addElement(urlLink.toString());\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return links;\n    }\n", "code2": "    private void createJCoPluginProject(IProgressMonitor monitor, String sourceFileName, String pluginName) throws CoreException, IOException {\n        monitor.subTask(MessageFormat.format(Messages.ProjectGenerator_CreatePluginTaskDescription, pluginName));\n        final Map<String, byte[]> files = readArchiveFile(sourceFileName);\n        monitor.worked(10);\n        IProject project = workspaceRoot.getProject(pluginName);\n        if (project.exists()) {\n            project.delete(true, true, new SubProgressMonitor(monitor, 5));\n        } else {\n            monitor.worked(5);\n        }\n        project.create(new SubProgressMonitor(monitor, 5));\n        project.open(new SubProgressMonitor(monitor, 5));\n        IProjectDescription description = project.getDescription();\n        description.setNatureIds(new String[] { JavaCore.NATURE_ID, PLUGIN_NATURE_ID });\n        project.setDescription(description, new SubProgressMonitor(monitor, 5));\n        IJavaProject javaProject = JavaCore.create(project);\n        IFolder binDir = project.getFolder(\"bin\");\n        IPath binPath = binDir.getFullPath();\n        javaProject.setOutputLocation(binPath, new SubProgressMonitor(monitor, 5));\n        project.getFolder(\"jni\").create(true, true, new SubProgressMonitor(monitor, 5));\n        project.getFile(\"sapjco3.jar\").create(new ByteArrayInputStream(files.get(\"sapjco3.jar\")), true, new SubProgressMonitor(monitor, 10));\n        IFolder metaInfFolder = project.getFolder(\"META-INF\");\n        metaInfFolder.create(true, true, new SubProgressMonitor(monitor, 5));\n        StringBuilder manifest = new StringBuilder();\n        manifest.append(\"Manifest-Version: 1.0\\n\");\n        manifest.append(\"Bundle-ManifestVersion: 2\\n\");\n        manifest.append(\"Bundle-Name: SAP Java Connector v3\\n\");\n        manifest.append(MessageFormat.format(\"Bundle-SymbolicName: {0}\\n\", pluginName));\n        manifest.append(\"Bundle-Version: 7.11.0\\n\");\n        manifest.append(\"Bundle-ClassPath: bin/,\\n\");\n        manifest.append(\" sapjco3.jar,\\n\");\n        manifest.append(\" jni/\\n\");\n        manifest.append(\"Bundle-Vendor: SAP AG, Walldorf (packaged using RCER)\\n\");\n        manifest.append(\"Bundle-RequiredExecutionEnvironment: J2SE-1.5\\n\");\n        manifest.append(\"Export-Package: com.sap.conn.jco,\\n\");\n        manifest.append(\" com.sap.conn.jco.ext,\\n\");\n        manifest.append(\" com.sap.conn.jco.monitor,\\n\");\n        manifest.append(\" com.sap.conn.jco.rt,\\n\");\n        manifest.append(\" com.sap.conn.jco.server\\n\");\n        manifest.append(\"Bundle-ActivationPolicy: lazy\\n\");\n        writeTextFile(monitor, manifest, metaInfFolder.getFile(\"MANIFEST.MF\"));\n        final IPath jcoPath = new Path(MessageFormat.format(\"/{0}/sapjco3.jar\", pluginName));\n        IClasspathEntry jcoEntry = JavaCore.newLibraryEntry(jcoPath, Path.EMPTY, Path.EMPTY, true);\n        final IPath jniPath = new Path(MessageFormat.format(\"/{0}/jni\", pluginName));\n        IClasspathEntry jniEntry = JavaCore.newLibraryEntry(jniPath, Path.EMPTY, Path.EMPTY, true);\n        javaProject.setRawClasspath(new IClasspathEntry[] { jcoEntry, jniEntry }, new SubProgressMonitor(monitor, 5));\n        StringBuilder buildProperties = new StringBuilder();\n        buildProperties.append(\"bin.includes = META-INF/,\\\\\\n\");\n        buildProperties.append(\"               sapjco3.jar,\\\\\\n\");\n        buildProperties.append(\"               jni/,\\\\\\n\");\n        buildProperties.append(\"               .\\n\");\n        writeTextFile(monitor, buildProperties, project.getFile(\"build.properties\"));\n        exportableBundles.add(modelManager.findModel(project));\n    }\n", "label": 0, "substitutes": {"parse": ["ize", "raw", "ract", "format", "scan", "patch", "open", "match", "load", "parser", "process", "update", "read", "apply", "split", "se", "build", "Parser", "see", "xml", "report", "pack", "ge", "eval", "arse", " analyse"], "link": ["linked", "image", "html", "URL", "base", "Link", "ink", "match", "inline", "links", "text", "message", "http", "load", "local", "add", "l", "href", "info", "page", "like", "string", "style", "route", "tag", "path", "li", "lang", "line", "type", "rel", "uri", "bug", "xml", "name", "location", "word", "loc", "ln", "data", "file", "id", "e", "lock", "connection", "msg", "source", "address"], "conn": ["enc", "err", "apt", "dr", "cmd", "nt", "config", "pt", "dc", "nc", "pc", "open", "ctrl", "rt", "Connection", "ca", "rec", "ch", "ann", "act", "c", "r", "Config", "ct", "rc", "db", "ci", "er", "p", "io", "ai", "out", "client", "cc", "socket", "ssl", "col", "ac", "con", "cn", "rn", "connect", "Conn", "mc", "n", "ctx", "cp", "connection", "loc", "cr", "pg"], "rd": ["dd", "nd", "dr", "lr", "fr", "rx", "dc", "rog", "rid", "xd", "rt", "RD", "RR", "adr", "ld", "wd", "rg", "r", "rc", "fd", "bd", "ds", "rr", "rh", "ra", "rs", "hr", "sr", "RM", "rn", "rm", "RS", "rss", "rl", "rw", "rb", "reader", "ru", "dra"], "kit": ["kin", "plugin", "base", "nt", "feed", "site", "sci", "ku", "w", "format", "et", "py", "bot", "net", "rt", "kat", "tk", "ut", "api", "b", "ui", "info", "cat", "auto", "tools", "pit", "Kit", "kt", "ct", "wt", "spec", "t", "k", "p", "io", "pot", "os", "sit", "util", "bug", "fit", "loader", "tool", "init", "h", "qt", "browser", "reader", "rot", "lib", "config", "ki", "cr", "f"], "doc": ["Doc", "body", "dec", "de", "html", "base", "in", "dr", "fr", "tt", "DOC", "config", "root", "coll", "dc", "val", "po", "open", "mm", "pc", "text", "http", "ref", "api", "info", "page", "pos", "dom", "d", "div", "out", "dir", "bug", "xml", "pub", "md", "ac", "docs", "loc", "msg", "data", "file", "document", "mc", "tx", "desc", "bc", "di", "m", "tag", "db", "f"], "url": ["image", "log", "html", "URL", "base", "resource", "lr", "www", "feed", "service", "config", "download", "Url", "hub", "http", "src", "github", "href", "l", "page", "cdn", "path", "org", "uri", "pull", "blog", "bug", "util", "xml", "ur", "name", "location", "ssl", "host", "server", "file", "ll", "gl", "sl", "rl", "el", "connection", "loc", "source", "f", "address"], "it": ["IT", "its", "in", "nt", "end", "lit", "et", "edit", "mit", "l", "info", "pit", "r", "t", "ic", "st", "split", "ait", "ci", "p", "stat", "se", "v", "ip", "sit", "ite", "iz", "init", "iti", "id", "iterator", " It", "It", "iter", "or", "you", "dit"], "elem": ["Elements", "elev", "eelement", "selement", "oelement", "selem", "pelement", "eade", "eelem", "Elem", "eler", "seject", "selements", "elements", "element", "Eject", "oelev", " nelem", "eelements", "Elev", "Eler", "peler", "eeject", "pelem", " Eler", "eject", "Element", " nelement", "oelem", " neade", " neler", " Element", "oeler", "pelev", " Elem", " Eade", "Eade"], "s": ["o", "service", "submit", "sch", "ops", "ls", "services", "details", "ns", "sync", "b", "ws", "scope", "js", "string", "set", "c", "r", "spec", "session", "g", "xs", "t", "ps", "params", "d", "ds", "p", "si", "S", "se", "sb", "v", "sv", "attr", "os", "fs", "ses", "rs", "es", "ssl", "a", "gs", "h", "server", "e", "sf", "sym", "u", "sl", "ss", "n", "sets", "ts", "m", "strings", "f", "parts"], "lnk": ["lnks", "nlky", "nnku", "olnke", "gnky", "knK", "dlk", "dlf", "linke", "knk", "lenky", "dlke", "dnf", "gnok", "nlkh", "nlok", "nnk", "lnkr", "lnf", "olnK", "nlk", "nnky", "dlok", "dnk", "nlf", "nlks", "lnke", "linf", "lenke", "gnk", "lenks", "olnkr", "lnK", "olnk", "lenku", "gnke", "lnkh", "dnke", "lnku", "dlky", "lnky", "dlkr", "nnke", "dnky", "nlke", "nlK", "knke", "linky", "olnf", "dnkr", "lnok", "knkh", "dnku", "lenk", "olnkh", "dlks"], "j": ["z", "aj", "index", "jc", "o", "fr", "kj", "syn", "jl", "ii", "ne", "key", "ch", "info", "jp", "js", "pr", "pos", "uj", "g", "ind", "li", "job", "ie", "note", "p", "m", "part", "ni", "si", "ja", "x", "ji", "dj", "y", "jj", "name", "oj", "a", "qi", "jo", "J", "adj", "im", "ij", "n", "br", "obj"], "urlLink": ["urllink", "URLLink", "strLink", " urlLine", "UrlRel", "UrlPath", "urlPath", "filePath", "strLine", "URLRel", "urlUrl", " urllink", "resourcelink", "URLPage", "resourceLink", " urlUrl", " urlPage", "urlRel", "URLUrl", "fileHub", "urlLine", "urlHub", "UrlLink", "urlPage", "strlink", "resourceConnect", "UrlUrl", " urlRel", " urlConnect", "fileUrl", "fileLink", "urlConnect", "strConnect", "resourceLine", "UrlHub", " urlPath", "UrlPage", " urlHub"], "str": ["enc", "dec", "err", "dr", "fr", "spr", "kr", "coll", "inner", "arr", "obj", "text", "l", "STR", "b", "ctr", "js", "pr", "string", "txt", "sp", "r", "pass", "t", "tr", "wr", "strip", "st", "stri", "line", "div", "elt", "name", "hr", "ext", "sr", "sta", "data", "inst", "char", "Str", "sl", "res", "n", "br", "cr", "f"], "i": ["ini", "mi", "index", "o", "in", "yi", "oi", "chi", "uli", "hi", "phi", "ii", "ix", "fi", "slice", "mu", "l", "b", "info", "ui", "ri", "pi", "c", "gi", "abi", "li", "ci", "p", "en", "multi", "si", "ni", "xi", "bi", "v", "x", "ai", "ji", "io", "eni", "y", "ip", "uri", "init", "ori", "qi", "ti", "id", "e", "iu", "f", "u", "vi", "n", "di", "m", "I", "zi"], "skip": [" dup", "fast", "stop", " scan", "scan", "special", "active", "add", "replace", "jump", " bypass", " skipped", " exclude", "sp", " skipping", "Skip", "cmp", "loop", " duplicate", " repeat", "ips", "error", "empty", "complete", "iter", "append", "copy"]}}
{"id1": "8973505", "id2": "15810440", "code1": "    public static void writeFileType(String uriFile, String outputfile, int num) {\n        BufferedWriter writer = null;\n        String uri = null;\n        try {\n            int counter = 1;\n            writer = new BufferedWriter(new FileWriter(outputfile));\n            BufferedReader reader = new BufferedReader(new FileReader(uriFile));\n            uri = null;\n            while (counter < num) {\n                uri = reader.readLine();\n                counter++;\n            }\n            while ((uri = reader.readLine()) != null) {\n                try {\n                    System.err.println(\"working on the [\" + counter + \"]th document.\");\n                    counter++;\n                    URL url = new URL(uri);\n                    URLConnection myConnection = url.openConnection();\n                    BufferedReader myReader = new BufferedReader(new InputStreamReader(myConnection.getInputStream()));\n                    String line = null;\n                    boolean hasOWL = false;\n                    boolean hasRDFS = false;\n                    boolean hasRDF = false;\n                    int linecount = 0;\n                    while ((line = myReader.readLine()) != null) {\n                        if (line.indexOf(\"http://www.w3.org/2002/07/owl\") != -1) hasOWL = true; else if (line.indexOf(\"http://www.w3.org/2000/01/rdf-schema\") != -1) hasRDFS = true; else if (line.indexOf(\"http://www.w3.org/1999/02/22-rdf-syntax-ns\") != -1) hasRDF = true;\n                        linecount++;\n                        if (linecount > 100) break;\n                    }\n                    if (hasOWL) writer.write(uri + \"\\t\" + OWL); else if (hasRDFS) writer.write(uri + \"\\t\" + RDFS); else if (hasRDF) writer.write(uri + \"\\t\" + RDF); else writer.write(uri + \"\\t\" + UNKNOWN);\n                    writer.newLine();\n                    writer.flush();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                    try {\n                        writer.write(uri + \"\\t\" + BROKEN);\n                        writer.newLine();\n                        writer.flush();\n                    } catch (Exception ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "label": 0, "substitutes": {"writeFileType": ["createFiletype", "writeFilestype", "writePageTypes", "writeFiletype", "createFileType", "writePageHeader", "writeFILEType", "createFilesType", "writeFILEHeader", "createFileHeader", "writePagetype", "createFileTypes", "createFilesHeader", "writeFileTypes", "writePageType", "writeFileHeader", "writeFILEtype", "createFilesTypes", "createFilestype", "writeFilesTypes", "writeFilesHeader", "writeFilesType", "writeFILETypes"], "uriFile": ["riFilename", "uriUrl", "uiFile", "riFile", "URIFiles", "riFiles", "URIfile", "uiFiles", "urifile", "uriFilename", "uifile", "uriFiles", "filenameFile", "riUrl", "rifile", "filenamefile", "filenameFilename", "URIFile", "URIUrl", "filenameFiles", "URIFilename", "uiUrl"], "outputfile": [" outputfull", "OutputFile", "resourcefiles", "outputfilename", "outputfiles", "resourcefile", "resourcestring", "outputdir", "inputFile", "unitfile", "Outputdir", "inputfiles", "inputstring", "inputdir", " outputdir", "resourcefilename", "unitstring", " outputFile", "unitfiles", "inputfilename", "unitfilename", "Outputfile", "inputfull", "outputstring", "Outputfull", "outputfull", "outputFile", "inputfile"], "num": ["master", "nb", "inc", "Num", "term", "index", "nam", "name", "length", "offset", "umi", "multi", "no", "len", "dim", "count", "NUM", "batch", "number", "n", "nu", "mult", "span", "amount", "common", "col", "coord", "limit", "loop", "con", "initial", "split", "unit", "sum", "zero"], "writer": ["external", "window", "e", "wl", "xml", "engine", "session", "we", "format", "riter", "method", "report", "null", "message", "document", "data", "server", "part", "author", "written", "wa", "header", "writ", "feed", "wan", "function", "ler", "creator", "er", "lock", "write", "wr", "object", "loader", "wb", "buffer", "wrapper", "key", "page", "later", "wt", "w", "io", "inner", "driver", "editor", "journal", "layer", "per", "walker", "socket", "outer", "office", "wave", "writers", "source", "unit", "book", "temp", "wire", "master", "builder", "output", "worker", "ws", "index", "out", "ee", "rw", "widget", "type", "Writer", "element", "r", "root", "handler", "service", "entry", "style", "width", "manager", "writing"], "uri": ["address", "id", "nil", "filename", "location", "context", "li", "link", "hub", "oid", "mi", "i", "route", "directory", "wiki", "direction", "query", "ri", "message", "attribute", "document", "file", "uid", "course", "token", "term", "folder", "remote", "string", "sequence", "nor", "uni", "prefix", "database", "component", "du", "URI", "http", "cli", "di", "picture", "feature", "base", "eni", "binary", " URI", "range", "winner", "doi", "multi", "username", "resource", "source", "origin", "unit", "pi", "qi", "metadata", "iri", "verb", "plugin", "node", "ui", "ilo", "umi", "element", "reference", "ori", "connection", "handler", "gi", "href", "theme", "collection"], "counter": ["race", "lc", "processor", "result", "master", "ver", "ter", "enter", "comment", "controller", "current", "vector", "worker", "nr", "index", "creator", "repeat", "pointer", "keep", "sequence", "name", "time", "inner", "offset", "book", "step", "expression", "keeper", "trace", "i", "count", "batch", "reference", "number", "info", "parent", "computer", "cpu", "handler", "hello", "loader", "ner", "outer", "parser", "iter", "Counter", "condition", "meter", "page", "continue", "entry", "cookie", "server", "clock", "loop", "instance", "coll", "second", "collection", "timer", "currency", "runner", "record", "inter"], "reader": ["ger", "upper", "finder", "e", "feed", "io", "rr", "worker", "rer", "ler", "row", "er", "ir", "inner", "driver", "stream", "ruby", "editor", "read", "Reader", "bird", "keeper", "layer", "r", "riter", "rx", "handler", "oder", "per", "loader", "ner", "ri", "parser", "iter", "lr", "buffer", "in", "l", "rar", "reading"], "url": ["address", "base", "client", "id", "feed", "io", "URL", "path", "plugin", "sl", "Url", "string", "ls", "li", "stream", "image", "link", "ssl", "connection", "user", "browser", "text", "www", "config", "ri", "resource", "http", "l", "page", "source", "file", "server", "channel", "download", "web", "blog"], "myConnection": ["myconnection", "someConnect", "someConn", "yourConn", "yourconnection", "MyConnection", "someConnection", " myConnect", "yourConnector", " myconnection", "Myconnection", "MyConn", "myConnector", "myConn", "MyConnect", "MyReader", " myConnector", "myConnect", "yourConnection", "MyConnector", " myConn", "someReader"], "myReader": [" myParser", " myWriter", "yourParser", " myRead", "myRead", "myWriter", "MyRead", "MyWriter", "MyReader", "yourReader", "yourRead", "yourWriter", "MyParser", "myParser"], "line": ["lc", "cl", "header", "base", "error", "column", "parse", "el", "use", "id", "feed", "log", "row", "string", "name", "note", "Line", "end", "lines", "range", "word", "no", "link", "code", "LINE", "look", "day", "element", "pe", "user", "text", "rule", "block", "ri", "message", "cell", "du", "key", "point", "non", "lf", "page", "lin", "data", "file", "entry", "source", "letter", "l", "inline", "style", "frame", "pass", "liner", "part", "comment", "response", "le"], "linecount": [" lineindex", "pagecount", "rowsize", " linecache", "linelength", "lettercount", "lineindex", " linesize", "linecache", "lettersize", "linesize", " lineCount", "linenumber", "Lineindex", "pagenumber", "rowcount", "rowlen", " linelen", " linenumber", "Linesize", "letterlen", "Linecount", "pageCount", "rowcache", " linelength", "pageindex", "lineCount", "rowlength", "linelen", "Linecache", "LineCount", "Linenumber", "letterlength"], "hasOWL": ["hasEFLM", " hasEWDL", "hasOWSl", "hasODl", " hasEWLA", "hasBYL", "hasEWl", "hasEWL", "hasOWDL", "hasOWSDL", " hasEWl", "hasEFLA", "hasOULA", "hasOWLM", "hasOWSL", "hasOWl", "hasEWLL", " hasOWLL", " hasOWLM", "HasEWL", "HasOWLA", "hasODLM", " hasOWDL", "hasBYl", "hasEWLM", "hasOUL", " hasEWLL", "hasEWLA", "hasBYLL", "hasODL", "HasOWL", "HasOWLL", " hasOWl", "HasEWLA", "hasEWDL", "hasBYDL", "hasODLA", "HasOWLM", "hasEFL", "hasEFl", "hasOULM", " hasEWL", "hasOULL", "hasOWSLL", "hasOWLL", "HasEWLL", " hasEWLM", " hasOWLA", "hasOWLA", "HasEWLM", "hasODLL"], "hasRDFS": ["hasRFSU", "hasGRUFAST", "hasRDPS", "hasXDFE", "hasGRDFS", "hasRTFs", "hasCDPES", "hasGRDFAST", "hasRDFU", "hasCDFS", "hasRDPES", "hasRDPE", "hasRTFES", "hasXDPs", "hasRDFE", "hasRFES", "hasRdfS", "hasRUFAST", "hasCDPS", "hasRDFSU", "hasRDPSU", "hasXDPE", "hasRTFS", "hasRdfE", "hasRdfs", "hasCDFES", "hasRDFES", "hasRFAST", "hasRFE", "hasRDFAST", "hasGRDFs", "hasRUFSU", "hasRNFE", "hasXDFU", "hasXDPU", "hasRDPAST", "hasCDPE", "hasRDFs", "hasRNFs", "hasRNFS", "hasCDFs", "hasGRUFS", "hasGRUFs", "hasCDFE", "hasRFS", "hasXDPS", "hasCDPs", "hasGRUFSU", "hasXDFS", "hasGRDFSU", "hasRFs", "hasRUFS", "hasRDPs", "hasRdfU", "hasRUFs", "hasRDPU", "hasXDFs", "hasRNFU", "hasRTFE"], "hasRDF": [" hasRFD", "hasSRDP", "hasRRUF", "hasRDEF", "yesDDP", "HasRRDEF", "hasURUF", "hasURMF", " hasRRUF", "hasSRDEF", " hasRRFD", "hasDDF", "hasRRdf", "hasRFD", "yesDDF", "hasUOW", "HasRRDF", "yesDMF", " hasRUF", " hasRMF", "HasRRdf", "hasRRDP", "hasRRMF", "yesROW", "hasUMF", "yesRMF", "hasMRDP", "HasRdf", "hasSRDF", "hasNRDF", "yesRDF", "hasUDF", " hasRRMF", "yesRDP", "hasSRdf", "hasMRDEF", "hasRdf", "hasROW", "hasRRDEF", "hasNRFD", "hasDMF", "hasNRUF", "hasRRFD", "hasURDF", "hasNRMF", "hasDDP", " hasRRDF", "HasRDP", "hasMRDF", "yesDOW", "hasDOW", "HasRDF", "hasRUF", "HasRDEF", "hasUDP", "hasURFD", "hasMRdf", "hasRMF", "hasRDP", "HasRRDP", "hasRRDF"]}}
{"id1": "21979462", "id2": "3809087", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"downloadURLtoString": [" downloadURLintoString", " downloadURLtoStr", " downloadUrltoString", " downloadURLasstring", " downloadUrltoStr", " downloadURLtoLong", " downloadURLintostring", " downloadURLasStr", " downloadURLintoStr", " downloadUrlasStr", " downloadUrlasString", " downloadURL2Str", " downloadURL2string", " downloadURLintoLong", " downloadURLtostring", " downloadURL2String", " downloadUrlasstring", " downloadURL2Long", " downloadUrltoLong", " downloadUrltostring", " downloadURLasLong", " downloadURLasString", " downloadUrlasLong"], "url": ["address", "base", "job", "el", "URL", "path", "sl", "remote", "Url", "name", "gl", "image", "link", "ssl", "connection", "user", "b", "rule", "config", "loc", "loader", "buffer", "uri", "service", "resource", "lr", "bel", "http", "l", "page", "source", "file", "server", "data", "ref", "f"], "in": ["gin", "ins", "din", "reader", "IN", "re", "login", "bin", "isin", "inc", "db", "ini", "fb", "input", "ic", "out", "In", "s", "cms", "inner", "ln", "ilo", "err", "read", "ssl", "at", "i", "r", "b", "rx", "n", "again", "nin", "fr", "buffer", "inn", "min", "it", "h", "af", "is", "into", "lin", "source", "data", "init", "ac", "impl", "as", "f"], "sb": ["bc", " eb", "sv", "xb", "ib", "bb", "gb", "amb", "bp", " SB", "bd", "nb", "db", "bm", "fb", "mb", "s", "ls", "bsp", "sth", "si", "sa", "buff", "sg", "BB", "SB", "lb", "b", "buf", "ub", "bt", "abb", "wb", "kb", "buffer", "lr", "eb", "rb", "lab", "usb", "pb", "bh", "zb", "B", "src", "bf", "Bs", "obb", "erb", "sf", "cb", "bs"], "str": ["result", "cl", "lc", "st", "sr", "br", "exp", "arr", "cur", "sl", "div", "string", "name", "s", "obj", "cr", "err", "doc", "spec", "bl", "wr", "Str", "read", "ct", "i", "r", "b", "text", "n", "tr", "STR", "enc", "list", "fr", "iter", "key", "dr", "line", "l", "data", "char", "stri", "coll", "pass", "sp", "txt", "f", "pr"]}}
{"id1": "15580610", "id2": "6171406", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"trainClassifier": [" trainclassification", "trainModelification", "trainTestifier", "trainclassify", "trainClassification", "trainClassLoader", "trainModelLoader", " trainclassifier", " trainClassify", " trainclassify", "trainclassifier", " trainClassLoader", "trainclassification", " trainclassLoader", "trainTestLoader", "trainModelifier", "trainModelify", " trainClassification", "trainClassify", "trainclassLoader", "trainTestify", "trainTestification"], "dir": ["env", "domain", "db", "DIR", "files", "output", "class", "object", "fd", "directory", "home", "md", " directory", "loc", "group", "module", "target", "cd", "filename", "path", "report", "direction", "out", "wd", "file", "build", "dist", "root", "url", "lib", "base", "doc", "model", "data", "div", "database", "Dir", "name", "di", "du", "d", "project", "folder", "uri", "window", "config"], "command": ["request", "category", "error", "domain", "Command", "image", "component", "service", "query", "script", "one", "argument", "pattern", "help", "comment", "action", "delete", "input", "sequence", "slave", "cli", "attribute", "directory", "archive", "history", "child", "info", "program", "module", "media", "connection", "array", "path", "message", "reason", "word", "operation", "function", "file", "root", "power", "which", "three", "this", "exec", "model", "system", "control", "clear", "usage", "database", "shell", "force", "language", "document", "name", "volume", "password", "project", "string", "and", "menu", "sudo", "cmd", "event", "machine", "config", "move"], "length": ["dim", "position", "before", "match", "both", "level", "size", "shape", "max", "capacity", "left", "creator", "ph", "full", "square", "class", "form", "character", "slice", "sequence", "ength", "section", "id", "limit", "loc", "last", "th", "span", "or", "strength", "Length", "sum", "padding", "inner", "time", "word", "value", "count", "now", "how", "angle", "power", "len", "end", "part", "depth", "letter", "zip", "type", "range", "prime", "number", "width", "l", "style", "body", "head", "duration", "distance", "join"], "process": ["component", "service", "p", "worker", "script", "sync", "console", "cess", "display", "host", "class", "output", "use", "app", "master", "user", "parse", "parent", "run", "plus", "child", "program", "group", "result", "handle", "share", "connection", "path", "proc", "out", "thread", "function", "file", "post", "this", "exec", "session", "system", "task", "status", "application", "processing", "method", "call", "document", "processor", "python", "project", "cmd", "pid", "machine", "Process"]}}
{"id1": "1180878", "id2": "13063241", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchUrldata", "fetchUrlDATA", "fetchHTTPDATA", "fetchHTTPdata", "fetchUrlData", "frieveURLdata", "frieveUrlData", "frieveUrlDATA", "fetchURLdata", "fetchJSONData", "fetchURLDATA", "fetchJSONDATA", "fetchHTTPData", "fetchJSONdata", "frieveURLData", "frieveUrldata", "frieveURLDATA"], "url": ["resource", "username", "string", "host", "href", "view", "http", "xml", "www", "URL", "path", "ur", "api", "feed", "gl", "Url", "download", "user", "address", "loc", "l", "connection", "base", "ls", "server", "location", "sl", "f", "filename", "image", "el", "page", "html", "ssl", "data", "fl", "uri", "source", "text", "src", "name", "file"], "proxyHost": ["ProxyDomain", "Proxyhost", "ProxyServer", " proxyAddress", "cachehost", "proxyHead", "ProxyAddress", "baseHead", "baseHost", " proxyPath", "serverHost", "proxyAddress", "proxyDomain", "ProxyPort", "serverServer", "serverPath", "proxyServer", "baseDomain", "remoteHead", "serverAddress", "cacheHost", "ProxyHead", "ProxyHost", "remoteHost", "baseAddress", " proxyhost", "cachePort", "remoteDomain", "remoteAddress", "cacheAddress", " proxyServer", "proxyPath", "ProxyPath", "proxyhost"], "proxyPort": [" proxyport", "ProxyServer", " proxyAddress", "ProxyAddress", "proxyport", "proxyAddress", "Proxyport", "httpServer", "ProxyPort", "httpPort", "httpHost", "proxyServer", "cacheHost", "ProxyHost", "cachePort", "cacheport", "cacheAddress", "httpAddress", " proxyServer"], "con": ["ch", "ctrl", "pc", "ca", "http", "ci", "can", "out", "fac", "don", "pub", "socket", "gen", "ai", "fl", "ec", "ver", "fa", "an", "c", "cache", "rec", "cone", "fun", "xc", "pin", "cc", "cl", "connection", "mc", "win", "cn", "cp", "ocon", "cur", "x", "per", "pre", "login", "en", "conf", "sub", "connect", "re", "cm", "n", "act", "go", "conv", "open", "co", "sync", "cf", "ac", "min", "cr", "part", "rc", "ls", "f", "Con", "uc", "fan", "com", "run", "fc", "cas", "cons", "func", "canon", "ran", "conn", "on", "exec", "syn", "bc", "CON", "close", "remote", "change", "inc", "pen", "un", "common"], "is": ["ib", "il", "ics", "or", "js", "us", "si", "isa", "ios", "im", "serv", "bs", "isl", "act", "ir", "was", "state", "iris", "oss", "has", "as", "ci", "api", "can", "ais", "os", "IS", "abs", "cms", "in", "ri", "conn", "are", "does", "ie", "it", "p", "fs", "isin", "s", "Is", "out", "vs", "iss", "iso", "ar", "get", "sp", "ops", "cos", "its", "ws", "cs", "isi", "isc", "i", "ori", "bis", "mis", "lis", "ai", "isu", "ps", "id", "es", "info", "ris"], "u": ["iu", "us", "uci", "c", "ru", "m", "o", "http", "U", "ur", "io", "api", "os", "yu", "ue", "ui", "uv", "cu", "user", "conn", "p", "up", "l", "ut", "f", "fu", "su", "i", "q", "ul", "h", "uc", "hu", "file", "v", "ou", "tu", "b", "uri", "nu", "client", "lu", "un"], "proxy": ["resource", "timeout", "fe", "pc", "cop", "plus", "shadow", "ip", "zip", "c", "cache", "host", "http", "roxy", "pse", "copy", "api", "phone", "force", "pin", "xy", "address", " proxies", "p", "l", "connection", "pe", "pa", "port", "server", "Proxy", "clone", "x", "config", "bean", "pool", "f", "wrapper", " Proxy", "lib", "socket", "remote", "ssl", "type", "web", "XY", "uri", "prot", "client", "create"], "baos": ["abis", "caOS", "aas", "caos", "boas", "paOS", "abos", "bao", "Baros", "bolos", "bais", "baas", "balos", "paos", "baOs", "BAOs", "alos", "pais", "aos", "Bais", "BAis", "calos", "boos", "haOS", "Baos", "baOS", "baros", "caas", "hais", "aOS", "BAos", "haos", "hao", "BAOS", "BAros", "abros", "BaOs", "pao", "boOS", "abOs", "BAo"]}}
{"id1": "7872659", "id2": "12306305", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndMovieIndexPath", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndMovieIndexFiles", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndmovieindexfile", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndmovieIndexfile"], "completePath": ["completeHome", " completeRoot", " completeCorp", "execpath", "doneLoader", "successPath", " CompleteDir", "completeCh", " completepath", "CompletePath", "doneVol", "CompleteDir", "completeVol", " completePoint", "itePath", "flatPath", " completeDir", "donePath", "completeCorp", "iteMusic", "successCh", "execLoader", "completeFile", "iteCh", "correctPoint", " CompletePath", "completeMusic", "completeRoot", "donepath", "successMusic", "completepath", "completeLoader", "itepath", "completePoint", "progressLoader", "progresspath", "CompleteHome", " completeCh", "progressPath", " completeHome", "flatRoot", "execPath", "flatCorp", "progressVol", "completeDir", "correctPath", "flatPoint", " CompleteHome", "execVol", "correctCorp", " completeMusic", " completeFile", " CompleteFile", "correctRoot", "CompleteFile", "successpath"], "masterFile": ["masterFiles", " masterName", "MasterFilename", "MasterName", "cacheFiles", "masterName", "MasterPath", "cachePath", "masterPath", "MasterFiles", "configFilename", "mastersFile", " masterPath", "cacheFile", "masterFilename", "MasterFILE", "mastersPath", " masterFilename", "MasterFile", "configPath", "configFile", "mastersFILE", "cacheFILE", "masterFILE", "mastersFiles", "configName"], "CustRatingFileName": ["CustRatingClassPath", "CustIndexFilesVersion", "CustIndexFileName", "CustRatingFilesName", "CustRatingFilenameSize", "CustRatingFilenameName", "CustRateFileName", "CustRateFilenameDesc", "CustRatingFilesDesc", "CustRatingFileVersion", "CustRatingFileSize", "CustIndexFilesType", "CustRateFileSize", "CustIndexFilesName", "CustRatingFilenamePath", "CustRatingFullDesc", "CustRateFilenameName", "CustIndexFilesPath", "CustRateFileDesc", "CustRatingFullPath", "CustRatingLineVersion", "CustRatingClassVersion", "CustRatingFileDesc", "CustRatingLineName", "CustRatingClassName", "CustRatingFilePath", "CustRatingFilesSize", "CustRateFilePath", "CustRatingFullName", "CustRatingLineType", "CustRateFilenamePath", "CustRatingFileType", "CustRatingLinePath", "CustRatingFullSize", "CustIndexFileVersion", "CustRatingClassType", "CustIndexFileType", "CustRatingFilesPath", "CustIndexFilePath", "CustRatingFilenameDesc", "CustRatingFilesType", "CustRateFilenameSize", "CustRatingFilesVersion"], "MovieIndexFileName": ["MovieIndexPlaceFile", "MovieConfigFolderFile", "MovieIndexFileHandle", "MovieIndexClassSize", "MovieIndexFName", "MovieEditFilename", "MovieConfigFolderName", "MovieConfigFileHandle", "MovieConfigFileVersion", "MovieIndexFolderName", "MovieIndexFileVersion", "MovieIndexPlaceName", "MovieIndexClassName", "MovieIndexFSize", "MovieIndexFilesUrl", "MovieEditFname", "MovieIndexClassname", "MovieConfigFolderVersion", "MovieEditFSize", "MovieConfigFileName", "MovieEditFUrl", "MovieIndexClassUrl", "MovieConfigFileFile", "MovieIndexFILEVersion", "MovieIndexFilesname", "MovieIndexFileSize", "MovieIndexFolderHandle", "MovieIndexFilesSize", "MovieConfigFolderHandle", "MovieIndexFILEFile", "MovieIndexFname", "MovieEditFileName", "MovieIndexFolderVersion", "MovieEditFileSize", "MovieIndexFUrl", "MovieIndexFolderFile", "MovieIndexPlaceHandle", "MovieEditFName", "MovieIndexFileFile", "MovieIndexFileUrl", "MovieIndexFILEName", "MovieIndexFILEHandle", "MovieEditFileUrl", "MovieIndexPlaceVersion", "MovieIndexFilename", "MovieIndexFilesName"], "inFile": ["Infile", "inputF", "inputFile", "InFile", "InF", "incFile", "inF", "incC", "InSourceFile", "inputSourceFile", "incSourceFile", "outFile", "infile", "outC", "incfile", " inF", " infile", "outfile", " inSourceFile", "outSourceFile", "inSourceFile", "inputfile"], "inC": ["inB", "InB", "inputF", " inCL", "innerCI", "outCC", "inputFile", "InFile", "InF", "outB", "inF", " inCC", "inCL", "outFile", "outC", "inputC", "innerFile", "inputCC", " inF", "InCI", " inB", "InCC", "innerCC", "outF", "outCL", "InCL", "outCI", "inCC", "innerC", "inCI", "InC"], "outFile1": ["outputFileName", "outFName", "againCFirst", "againC3", "outputFileId", "outPlaceId", "outCFirst", "outF1", "outFileName", "outFile3", "againFile1", "outPathFirst", "outPath1", "outFiles1", "outPath2", "outFilesFirst", "outfile1", "outfileId", "outF2", "outPath3", "outFileFirst", "outPlace1", "outFiles3", "outputFile1", "againFile3", "outC3", "againC1", "outFiles2", "againFile2", "outfileName", "outPlaceName", "outFileId", "outputFile2", "outputfileName", "outputfileId", "outputfile2", "outPlace2", "outFId", "outfile2", "againC2", "againFileFirst", "outputfile1"], "outC1": ["newc1", "outC81", "outD1", "outCFirst", "outD8", "outF1", "outcFirst", "outFOne", "newC81", "outCFFirst", "outD81", "newc81", "newCFirst", "outF2", "outD2", "againB8", "againC8", "outCF81", "outCFOne", "newCOne", "outDOne", "outc1", "outB1", "againB1", "outBOne", "againCOne", "outcOne", "outB8", "newcOne", "newcFirst", "outB2", "againBOne", "outF8", "outc81", "outC8", "newC1", "againC2", "againB2", "outCOne", "outCF1", "outDFirst", "againC1"], "outFile2": ["outFile4", "outputfile5", "outFiles6", "outDirectory4", "outFile5", "againFile6", "againFile1", "outFilesTwo", "againLine1", "outDirectory2", "outFiles1", "outDirectory5", "againFileTwo", "outLineTwo", "outputFile4", "outFileTwo", "outputFile5", "outChannel2", "outChannel1", "outLine2", "outDirectoryTwo", "outChannel6", "againLine2", "outfile4", "outFiles2", "outputFileTwo", "againFile2", "outFiles5", "outLine6", "outputFile2", "outfile5", "outChannelTwo", "againLine6", "outputfile2", "outfileTwo", "outLine1", "outfile2", "outputfileTwo", "againLineTwo", "outFile6", "outFiles4", "outputfile4"], "outC2": ["outFile4", "outFTwo", "outCache1", "outCII", "outF1", "outCache2", "outFII", "outB4", "OutF1", "againC4", "outCache4", "outF2", "OutF2", "OutC1", "outFileTwo", "outCacheII", "outCTwo", "OutCII", "OutC2", "OutC4", "OutFII", "outB1", "againB1", "againCTwo", "againBTwo", "outBTwo", "outF4", "outB2", "outC4", "outFileII", "againC2", "againB2", "againB4", "OutF4", "againC1"], "fileSize": ["bufferMode", " fileMode", " fileAddress", " fileSIZE", "imageLength", "imageSize", " fileLength", "fileAddress", "bufferSize", "fileMode", "bufferLength", "FileLength", "resourceSize", "resourceSIZE", "FileSize", "FileSIZE", "FileAddress", "fileLength", "FileMode", "imageSIZE", "resourceAddress", "fileSIZE"], "totalNoDataRows": ["totalNoPageRues", "totalNoDataChOWS", "totalNoDataRrows", "totalNoPageRrows", "totalNoDataCues", "totalNoPageLOWS", "totalNoDataRues", "totalNoDataLues", "totalNoPageLrows", "totalNoDataCows", "totalNoPageLows", "totalNoDataChows", "totalNoDataLows", "totalNoDataCrows", "totalNoDataChues", "totalNoDataCOWS", "totalNoPageRows", "totalNoDataLrows", "totalNoPageROWS", "totalNoDataROWS", "totalNoDataLOWS", "totalNoDataChrows", "totalNoPageLues"], "mappedBuffer": ["mappedBuff", "mappingBuffer", "mappingFile", "mappingBuff", "mashedBuffer", "Mappedbuffer", "mippedBuff", "mappedbuffer", "MachedURL", "MappedBuff", "machedBuffer", "mappingStream", "MappingChannel", "mapedFile", "MappedStream", "mppedStream", "MachedChannel", "mappingbuffer", "mactedStream", "MappingFile", "mappedURL", "MachedBuff", "mippedURL", "mappedChannel", "MappingBuff", "Machedbuffer", "mippedStream", "mappedFile", "mapedStream", "mapedURL", "MappedBuffer", "machedURL", "MappingBuffer", "MachedBuffer", "machedFile", "MachedFile", "mashedFile", "mashedChannel", "machedStream", "mappedStream", "machedbuffer", "mapedBuff", "MappedFile", "mppedChannel", "mashedBuff", "machedChannel", "mactedBuff", "machedBuff", "mactedbuffer", "mippedBuffer", "mapedBuffer", "mactedBuffer", "MappedURL", "mappingChannel", "MachedStream", "mppedBuff", "mppedBuffer", "MappedChannel"], "startIndex": ["endPoint", "startindex", "startSection", "endInfo", "stopCode", "stopindex", "stopIndex", "StartInfo", "initindex", "useindex", "startRow", " startindex", "endRow", "endCode", "startInfo", "endSection", " startOffset", "startingPosition", "startingIndex", " startCode", "startingPoint", "endIndex", "initIndex", "StartOffset", " startPosition", "startCode", " startInfo", "startPoint", "startPosition", "StartPosition", "initOffset", "endindex", "useIndex", " startPoint", "stopRow", "usePosition", " startRow", "Startindex", " startSection", "startOffset", "StartIndex", "useInfo", "startingSection", "initInfo", "endPosition"], "count": ["first", "test", "cache", "follow", "call", "allow", "found", "id", "force", "current", "child", "old", "total", "Count", "index", "start", "length", "keep", "ind", "time", "more", "thread", "name", "max", "c", "order", "len", "self", "code", "all", "type", "i", "counter", "number", "find", "weight", "list", "depth", "close", "add", "key", "other", "col", "pool", "loop", "coll", "limit", "group", "part", "sum", "size"], "currentMovie": [" currentmovie", "currentFilm", "thismovie", "CurrentTheme", "currentmovie", "defaultMusic", "currentlyPicture", "CurrentMovie", "currentPicture", "parentMovie", "validMovie", "reportedMovie", "reportedFilm", "thisPicture", "thisMovie", "defaultFilm", "validTheme", "reportedImage", "reportedmovie", "defaultMovie", "validFilm", "CurrentFilm", "defaultImage", " currentMusic", "validmovie", "parentmovie", "currentTheme", "Currentmovie", " currentFilm", "thisFilm", "currentMusic", " currentPicture", " currentImage", "currentImage", "currentlyMovie", "reportedMusic", "parentPicture", "reportedPicture", "currentlyMusic", "parentFilm", "reportedTheme"], "movieName": ["Moviename", "filmName", "MovieName", " moviename", "camName", "filmNumber", " movieId", "voiceName", "movieInfo", "moneyName", "moneyFamily", "voicename", "moneyNumber", "voiceId", " movieFamily", "MovieFamily", "moviename", "MovieInfo", "filmname", "MovieId", "voiceInfo", "movieId", "movieNumber", "camFamily", "movieFamily", " movieInfo", "camname", "filmFamily", "MovieNumber"], "customer": ["Customer", "customor", "ustomeri", "mixer", "ustomers", "customER", "CustomER", "Customers", " customER", "mixER", "customers", " customers", " customeri", "ustomer", "mixor", "ustomER", "ustomor", "Customeri", "Customor", "customeri", "mixers"], "rating": ["score", "ring", "url", "feature", "error", "reader", "id", "rr", "string", "ranking", "range", "missing", "ruby", "rate", "type", "writer", "info", "r", "number", "rage", "rated", "Rating", "packing", "setting", "ing", "padding", "alpha", "attribute", "resource", "rolling", "rank", "http", "rc", "data", "RC", "value", "rates", "rice", "including", "reading", "comment", "radius", "writing"], "outBuf1": ["outFufCloud", "outKuf8", "outBafCloud", "outFuf1", "outBummerOne", "outFbuf01", "outBbuff8", "outBbufn", "outBbuf11", "outBaf1", "outBuf3", "outFuf91", "outBaft3", "outBbuff0", "outBuf91", "outBuff8", "outFufOne", "outBuf8", "outCuf0", "outBaf3", "outBuffCloud", "outBalth3", "outBbuf91", "outFbuf1", "outBiff91", "outBaftn", "outKufOne", "outBuf01", "outFafCloud", "outBbuf3", "outBuff3", "outBum91", "outBufOne", "outKbuffOne", "outDuff1", "outKbuff3", "outBufn", "outDuff3", "outKbuff1", "outKuf1", "outBuff1", "outDuf1", "outBaf8", "outFuf01", "outBaf0", "outBbufOne", "outBalth1", "outBaft11", "outCuf1", "outCufOne", "outFafOne", "outKbuf3", "outFbuf91", "outBbuf1", "outBuffOne", "outFbufOne", "outKuf3", "outBbuffOne", "outCuffOne", "outFaf1", "outDuff11", "outKbuff8", "outBbuf2", "outBumOne", "outBuff11", "outBuff2", "outBbuff3", "outBummerCloud", "outBuf0", "outBafOne", "outBbuff1", "outDuf11", "outBiff1", "outBbuf01", "outBiff01", "outBaft1", "outDuf3", "outDuffn", "outBiffOne", "outBuff0", "outKbuf1", "outKuf2", "outBum01", "outCuff1", "outCuff0", "outBummer1", "outDufn", "outBalth2", "outKbuf2", "outBufCloud", "outBuffn", "outBuf11", "outBum1"], "outBuf2": ["outBuf4", "outFbuf2", "outBbuffTwo", "outBuber8", "outFbufB", "outFuf1", "outBoffTwo", "outFuf20", "outBum20", "outBbuff8", "outBuber20", "outBait200", "outBbuff20", "outBbuffer4", "outBbuff0", "outBuff8", "outBuf20", "outFuf8", "outBuf8", "outBbufB", "outBufTwo", "outBum82", "outBuff4", "outWBuf200", "outFbuff20", "outBuffTwo", "outBufB", "outBbufTwo", "outWBuf8", "outFbuff4", "outWBuf2", "outWBbuff200", "outBuff12", "outBbuffer2", "outWBuff4", "outFbuff2", "outBbuff200", "outBuffB", "outBbuff4", "outBum8", "outBait2", "outBait4", "outBbuff82", "outBuber2", "outBuff1", "outFufTwo", "outBuf12", "outFbuf12", "outWBbuffTwo", "outFuf4", "outWBuff0", "outBbuf1", "outBoff8", "outFbuff1", "outBbuf4", "outWBuff8", "outBuber82", "outBait0", "outBbuf2", "outFbuf4", "outBuff2", "outBuf0", "outWBbuff8", "outBbuff1", "outBuf200", "outWBufTwo", "outBaitTwo", "outFbuff8", "outBoff200", "outFuf12", "outFuf82", "outBbuffer12", "outBuff0", "outBum2", "outBbuff2", "outFbuff82", "outBoff2", "outBbuf12", "outWBuf4", "outBuf82", "outFbuffTwo", "outBbufferB", "outFuf2", "outWBuf0", "outFufB", "outWBbuff2", "outBait8", "outWBuff2"], "endOfIndexFile": ["endOfImageFolder", "endOfDataFile", "endofindexTime", "endOfIndexFolder", "endofIndexFile", "endOfindexFile", "endOfImageFiles", "endOfDataDir", "endOfindexFiles", "endofIndexDir", "endofindexFolder", "endofLinkFiles", "endofindexFile", "endOfIndexfile", "end\n", "endOfindexTime", "ended\n", "endfile", "endOfIndexFiles", "endofindexFiles", "endedfile", "endOfIndexTime", "endOfLinkFile", "endOfIndexDir", "endOfLinkfile", " end\n", "endOfClientDir", " endfile", "endOfindexFolder", "endOfDataTime", "endOfClientFiles", "endOfClientTime", "endOfClientFile", "endofIndexFolder", "endOfindexfile", "endOfindexDir", "endOfLinkFiles", "endOfLinkDir", "Endfile", "End\n", "endOfImageTime", "endofLinkDir", "endofLinkTime", "endOfDatafile", "endOfImageFile", "endofLinkFile", "endOfLinkTime", "endofIndexFiles", "endofIndexTime"]}}
{"id1": "9796161", "id2": "2465747", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public static String postRequest(String urlString, HashMap data) {\n        String returnData = \"\";\n        try {\n            URL url = new URL(urlString);\n            URLConnection connection = url.openConnection();\n            connection.setDoOutput(true);\n            connection.setDoInput(true);\n            PrintWriter out = new PrintWriter(connection.getOutputStream());\n            Object[] keySet = data.keySet().toArray();\n            Object[] values = data.values().toArray();\n            for (int count = 0; count < keySet.length; count++) {\n                out.print(URLEncoder.encode((String) keySet[count]) + \"=\" + URLEncoder.encode((String) values[count]));\n                if ((count + 1) < keySet.length) out.print(\"&\");\n            }\n            out.close();\n            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                returnData += inputLine;\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            returnData = null;\n        }\n        return (returnData);\n    }\n", "label": 0, "substitutes": {"getMD5": ["getMD512", "getMD4", " getSHA4", " getSHA512", "getSHAHash", " getSHA5", "getmd4", " getMD512", "getSHA512", "getSHA5", " getSHAHash", "getSHA4", " getMDHash", "getHTMLHash", "getMDHash", "getmdHash", "getHTML5", "getHTML4", "getmd5", " getMD4", "getmd512", "getHTML512"], "s": ["its", "in", "comments", "self", "abs", "input", "ls", "lines", "services", " fails", "ns", "ends", "sync", "als", "l", "b", "bytes", "styles", "ms", "js", "ws", "string", "c", "tests", "g", "ps", "ates", "ows", "p", "ds", "source", "si", "S", "os", "sb", "v", "cs", " ads", "is", "ses", "rs", "es", "ssl", "gs", "a", "ings", "ips", "bs", "data", "e", "sym", "str", "ss", "i", "n", "sets", "ts", "strings", "scripts", "f", "parts"], "m": ["nm", "mi", "bm", "ym", "module", "am", "um", "fm", "arm", "mm", "tm", "mu", "l", "ms", "c", "t", "d", "mand", "p", "om", "pm", "gm", "v", "mr", "sm", "mac", "me", "wm", "manager", "man", "cm", "md", "h", "M", "e", "rm", "dm", "mc", "vm", "i", "em", "im", "hm", "mut", "f", "machine"]}}
{"id1": "6613944", "id2": "3631989", "code1": "    public static String installOvalDefinitions(final String xml_location) {\n        InputStream in_stream = null;\n        try {\n            URL url = _toURL(xml_location);\n            if (url == null) {\n                in_stream = new FileInputStream(xml_location);\n            } else {\n                in_stream = url.openStream();\n            }\n        } catch (IOException ex) {\n            throw new OvalException(ex);\n        }\n        Class<OvalDefinitions> type = OvalDefinitions.class;\n        OvalDefinitions object = _unmarshalObject(type, in_stream);\n        String pid = _getDatastore().save(type, object);\n        return pid;\n    }\n", "code2": "    public void run() {\n        URL url;\n        try {\n            url = new URL(\"http://localhost:8080/glowaxes/dailytrend.jsp\");\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            while ((str = in.readLine()) != null) {\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "label": 0, "substitutes": {"installOvalDefinitions": [" saveOvalRefaults", " saveOvaldefines", " saveOvalFplates", " saveOvalRefines", " saveOvalDefplates", " saveOvalRefplates", " saveOptDefinitions", " saveOvaldefplates", " saveOptDefines", " saveOptDefaults", " saveOvaldefaults", " saveOvalDefaults", " saveOvalRefinitions", " saveOptdefines", " saveOvalDefines", " saveOvalFines", " saveOptDefplates", " saveOptdefinitions", " saveOvalFinitions", " saveOptdefaults", " saveOvaldefinitions", " saveOptdefplates", " saveOvalFaults", " saveOvalDefinitions"], "xml_location": [" xml_path", " xml_area", "http_location", "xml_area", "xml_directory", "xml67loc", "xmlFilelocation", "xmlFilefilename", " xml_type", "xmlFilearea", "xml67path", "xml67location", "xml_filename", "http_loc", " xml_loc", "xml_path", "xml_type", " xml_filename", "xmlFileLocation", "xml_loc", " xml_Location", "xml67type", "http_directory", "xml_Location"], "in_stream": ["inc_cont", "in_channel", "thin67channel", " in_stack", "in67clean", "in67struct", "inc_stream", "in_cont", " in_url", "in_clean", "thin67stream", "in_stack", " in_trans", "thin_stream", "in_trans", "in_sw", "in_ream", "in67channel", "inc_clean", "inc_ream", " in_form", "in67sw", "thin_sw", "in67cont", "in67stream", "thin67struct", "in_form", "thin_struct", "thin_channel", "in67ream", "in_struct", "thin67sw", "in_url"], "url": ["resource", "stream", "ob", "string", "blog", "host", "http", "xml", "str", "www", "URL", "path", "ll", "log", "api", "open", "feed", "Url", "impl", "address", "bel", "bug", "loc", "browser", "l", "connection", "base", "ls", "coll", "location", "server", "sl", "f", "image", "socket", "html", "ssl", "bb", "page", "data", "fl", "obj", "b", "web", "source", "uri", "org", "file", "ref"], "type": ["group", "class", "function", "kind", "instance", "py", "o", "method", "http", "xml", "tool", "copy", "path", "platform", "key", "address", "single", "unit", "handler", "p", "part", "base", "tag", "pe", "element", "model", "port", "like", "category", "python", "link", "TYPE", "types", "format", "pod", "file", "Type", "product", "obj", "style", "module", "plugin", "null", "ype", "parser", "t", "info", "id", "parent", "collection", "name", "core", "ref"], "object": [" error", "class", "function", "project", "string", "instance", "oid", " obj", "o", "pointer", "version", "node", "objects", "os", "number", " python", "address", " structure", "document", "base", "part", "element", "model", "config", "array", "value", "result", "nt", "data", "product", "obj", "target", "id", "info", "parent", "name"], "pid": ["ping", "root", "pc", "pd", "sid", "oid", "pb", "pointer", "pse", "proxy", "ids", "bin", "uid", "abi", "pac", "pin", "pp", "pak", " tid", "p", "proc", "phi", "pos", "pins", "pa", "port", "phrase", "processor", "pkg", "lp", " pin", "iana", "product", "vid", " PID", "plugin", "ps", "jp", "pty", "id", "parent"]}}
{"id1": "10445819", "id2": "15351863", "code1": "    private Reader getReader() throws IOException {\n        if (data != null) {\n            if (url != null) throw new IllegalArgumentException(\"URL for source data and the data itself must never be specified together.\");\n            if (charset != null) throw new IllegalArgumentException(\"Charset has sense only for URL-based data\");\n            return new StringReader(data);\n        } else if (url != null) {\n            InputStream stream = url.openStream();\n            if (charset == null) return new InputStreamReader(stream); else return new InputStreamReader(stream, charset);\n        }\n        return null;\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"getReader": ["getreader", "loadStream", "readreader", "getParser", "newParser", "readStream", "loadParser", "loadreader", "loadReader", "newStream", "newReader", "newreader", "getStream", "readReader", "readParser"], "stream": ["resource", "temp", "draw", "window", "clean", "zip", "channel", "instance", "host", "http", "input", "cont", "feed", "open", "slice", "sync", "impl", "content", "object", "child", "roll", "valid", "trans", "document", "sw", "Stream", "upload", "coll", "url", "port", "read", "sl", "f", "serial", "control", "pool", "wrapper", "draft", "v", "reader", "output", "data", "raw", "null", "source", "body", "form", "ream", "file"]}}
{"id1": "12380475", "id2": "17557289", "code1": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"transport": ["protpoint", "ransports", " transmission", "protports", " transporter", "protmission", "transprocess", "ransmission", "transmission", "protport", "ransport", "transpoint", "ranspoint", " transpoint", "ransporter", " transports", "protporter", "protprocess", "transporter", "ransprocess", " transprocess", "transports"], "file": ["page", "log", "FILE", "url", "resource", "e", "image", "server", "parent", "ile", "connection", "io", "data", "single", "project", "info", "socket", "channel", "folder", "model", "f", "entry", "document", "route", "out", "type", "handle", "source", "class", "comment", "reader", "dir", "directory", "filename", "stream", "use", "db", "base", "user", "queue", "object", "local", "cache", "change", "string", "handler", "name", "service", "full", "File", "path", "line", "auto", "content", "http", "fp"], "files": ["ls", "pes", "keys", "ions", "ins", "books", "users", "sites", "headers", "ums", "f", "bs", "features", "classes", "lines", "balls", "fs", "s", "thumbnails", "objects", "results", "facts", "flows", "images", "dir", "pages", "names", "models", "cells", "iles", "views", "blocks", "Files", "boxes", "ups", "events", "phones", "items", "issues"], "i": ["k", "m", "p", "u", "uri", "e", "col", "j", "b", "n", "io", "info", "si", "f", "it", "ni", "o", "index", "d", "ci", "h", "end", "oi", "key", "abi", "multi", "li", "di", "mi", "ip", "pi", "vi", "xi", "hi", "slice", "id", "ti", "v", "c", "I", "ai", "chi", "ii", "ui", "x", "ini", "ri"], "inChannel": ["InFile", "outchannel", "inputChan", "inputChannel", "InStream", " inStream", "InChan", " inchannel", "InChannel", "inStream", "outMessage", "inChan", "inputCh", "InMessage", "inchannel", " inMessage", "inFile", " inFile", "inCh", " inChan", "inputStream", "outStream", " inCh", "InCh", "Inchannel", "outFile", "inMessage"], "outChannel": ["ioChannel", "outchannel", "inConnection", "outHandler", "OutChan", " outHandler", "inHandler", "inStream", "inChan", " outChan", "ioChan", "ioConnection", "OutChannel", "inchannel", "Outchannel", " outchannel", "ioHandler", "outStream", " outStream", "outChan", "outConnection", "OutStream", " outConnection"]}}
{"id1": "17627195", "id2": "1141361", "code1": "    public Document getContentAsDocument() {\n        synchronized (this.url) {\n            URLConnection connection = this.url.openConnection();\n            if (doReload(connection)) {\n                InputSource inputSource = new InputSource(connection.getInputStream());\n                DocumentBuilderFactory factory = new DocumentBuilderFactoryImpl();\n                this.document = factory.newDocumentBuilder().parse(inputSource);\n            }\n            return this.document;\n        }\n    }\n", "code2": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 0, "substitutes": {"getContentAsDocument": ["getContentasString", "getContentOfDoc", "getConnectionasDocuments", "getConnectionAsDocuments", "getContentInDocument", "getContentasDocument", "getConnectionasDoc", "getContentAsDoc", "getContentAsString", "getContentInDoc", "getConnectionasString", "getConnectionAsDoc", "getContentInString", "getContentOfString", "getConnectionasDocument", "getContentInDocuments", "getConnectionAsString", "getConnectionAsDocument", "getContentOfDocuments", "getContentasDocuments", "getContentOfDocument", "getContentAsDocuments", "getContentasDoc"], "connection": ["reader", "open", "loc", "channel", "socket", "session", "handler", "database", "closed", "application", "lc", "conn", "instance", "section", "collection", "client", "this", "service", "connected", "source", "pointer", "proxy", "db", "connect", "condition", "builder", "driver", "response", "ctx", "image", "ion", "character", "url", "context", "config", "relation", "server", "io", "c", "function", "result", "con", "which", "directory", "Connection", "communication"], "inputSource": ["imageSource", " inputStream", "inputPoint", "InputConnection", "InputReader", "dataStream", "dataPoint", "InputStream", "dataProvider", " inputReader", "InputSource", " inputPoint", "imageStream", "sourceSource", "sourceStream", "inputProvider", "inputConnection", "imageReader", "sourceProvider", "dataSource", " inputProvider", " inputConnection", "inputStream", "imageConnection", "sourcePoint", "inputReader"], "factory": ["fii", "Flesh", "confuture", "confactory", "FFactory", "facuture", "future", "confii", "facound", "confound", "cfound", "confence", "Factory", "cfactory", " fii", "cfence", " flesh", "found", "fFactory", "facactory", "fence", "flesh", "confFactory", "facence", "cfuture", "Fii", " fFactory", "conflesh"], "document": ["director", "layout", "doc", "version", "master", "database", "layer", "application", "xml", "library", "model", "page", "cache", "entity", "content", "root", "collection", "Document", "design", "proxy", "source", "image", "project", "response", "parent", "object", "url", "server", "element", "message", "result", "record", "docs", "html", "media", "graph", "node"]}}
{"id1": "19251426", "id2": "18693224", "code1": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"recurseFiles": [" recursiveItems", "recorderFiles", "reivefiles", "recursiveImages", "recurseImages", "reiveFiles", " recursiveFiles", "reciveFile", " recurseFile", "recursiveFiles", "reciveFiles", "recorderImages", "reiveFile", "recurseChildren", "recivefiles", "recursivefiles", "recursiveItems", "reurseFiles", "reiveImages", "recieveFiles", "recieveItems", "reursefiles", " recursiveFile", " recursiveChildren", "recurseItems", "recieveChildren", "recerveFiles", "recerveItems", "reciveImages", " recurseChildren", "recursiveFile", "recerveChildren", "recursiveChildren", "reurseFile", "recerveFile", "recorderFile", " recurseItems", "recursefiles", "recorderfiles", "recieveFile", "recurseFile", "reurseImages"], "root": ["directory", "zip", "path", "base", "node", "string", "loader", "remote", "server", "output", "resource", "uri", "user", "rew", "project", "result", "ro", "bin", "oot", "back", "reader", "source", "dir", "cover", "rule", "r", "default", "parent", "roots", "archive", "out", "Root", "object", "or", "folder", "name", "tree", "box", "writer", "home", "array", "prefix", "ver", "url", "this", "b", "xml", "f", "module", "ree", "loc"], "file": ["directory", "zip", "path", "base", "class", "info", "letter", "handler", "server", "resource", "uri", "ile", "entry", "http", "auto", "document", "table", "project", "fp", "number", "child", "line", "time", "File", "queue", "content", "type", "source", "cache", "use", "dir", "binary", "model", "FILE", "collection", "work", "parent", "data", "local", "page", "object", "get", "log", "style", "single", "or", "folder", "name", "e", "tree", "image", "force", "function", "leaf", "full", "db", "url", "pe", "comment", "b", "future", "xml", "f", "module", "code"], "zaos": ["zioS", "waoS", "zooss", "zaoS", "ziis", "ziOS", "zioss", "zeoS", "zes", "naos", "zos", "yaos", "zeose", "zeoss", "qaoss", "wao", "zais", "naose", "wais", "zaose", "qaOS", "zeas", "yaes", "zaOS", "zoS", "zeos", "naoss", "zaot", "yaoS", "waoss", "qais", "zeis", "zoose", "zis", "zeo", "naas", "zao", "gaot", "zaoss", "ziot", "gaos", "gaOS", "zaes", "qaoS", "zios", "yao", "zoas", "gaes", "zoos", "qaot", "gao", "qaos", "waOS", "gaoS", "zo", "waos", "zaas"], "absolute": ["total", "base", "physical", "aggressive", "optional", "uri", "relative", "http", "document", "abs", "Abs", "active", "alpha", "offset", "olute", "ative", "use", "exclusive", "international", "based", "atomic", "alias", "al", "able", "fixed", "empty", "append", "encrypted", "multiple", "inline", "reverse", "complete", "negative", "apply", "automatic", "full", "mobile", "always", "compatible", "supported", "required", "positive", "enable", "simple", "attribute", "ical", "external", "auto", "valid"], "files": ["keys", "balls", "fs", "pages", "results", "docs", "ples", "features", "apps", "s", "Files", "qs", "pes", "split", "items", "projects", "links", "iles", "lines", "users", "blocks", "names", "classes", "images", "objects", "models", "plugins", "ips", "sites", "groups", "es", "log", "ls", "alls", "cells", "rows", "books", "events", "f"], "file2": ["filename02", " fileSub", "letter2", "files2", " filetwo", "object1", "filename1", "letter1", "letterSub", "files1", "filenametwo", "filename2", "file1", "filetwo", "objectSub", "filestwo", "object2", "file02", "files02", "fileSub", " file1", " file02"], "filename": ["directory", "letter", "string", "path", "kn", "zip", "uri", "token", "username", "whatever", "kl", "subject", "message", "description", "json", "slice", "fp", "location", "length", "ame", "il", "l", "sheet", "shell", "database", "password", "txt", "utf", "email", "Filename", "binary", "ema", "which", "wb", "connection", "SourceFile", "archive", "append", "metadata", "size", "language", "nil", "title", "name", "folder", "fil", "family", "word", "sl", "url", "summary", "download", "f", "ppa", "phrase", "module", "ename", "loc"], "zae": [" zoda", "zeace", "zaape", "ezcoe", "Zade", "Zae", "ezade", " zanne", "zipoda", " zobe", "zace", "zoe", "zade", "zecoe", "Zoe", "fae", "Zanne", "fade", "zaobe", "zaae", "fanne", " zoe", "foe", "zipobe", " zcoe", "ezae", "zape", "zipae", " zade", " zace", "ezace", "zobe", "zanne", "zeae", "zeade", "zoda", "zipape", "zcoe", " zape", "zaoda"], "fis": ["fais", "lis", " fais", "sfis", " fris", "zwas", "fris", "zais", "fisc", "zisc", " fisc", " fwas", "sfisc", "fisa", "sfwas", "sfais", "cais", "cis", "zis", "lisa", "cris", "lris", "lais", "fwas", " fisa", "cisa"]}}
{"id1": "18217985", "id2": "20735941", "code1": "    public static String fromHtml(URL url, String defaultEncoding, boolean overrideEncoding) throws IOException, BadDocumentException {\n        URLConnection conn = url.openConnection();\n        String contentType = conn.getContentType();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) {\n            int i = contentType.indexOf(\"charset\");\n            if (i >= 0) {\n                String s = contentType.substring(i);\n                i = s.indexOf('=');\n                if (i >= 0) {\n                    s = contentType.substring(i + 1).trim();\n                    encoding = s.replace(\"\\'\", \"\").replace(\"\\\"\", \"\").trim();\n                    if (encoding.equals(\"\")) {\n                        encoding = defaultEncoding;\n                    }\n                }\n            } else {\n                encoding = defaultEncoding;\n            }\n        }\n        String expected = \"text/html\";\n        if (contentType == null) {\n            DefaultXMLNoteErrorHandler.warning(null, 90190, \"Returned content type for url.openConnection() is null\");\n            contentType = expected;\n        }\n        int index = contentType.indexOf(';');\n        if (index >= 0) {\n            contentType = contentType.substring(0, index).trim();\n        }\n        if (!contentType.equals(expected)) {\n            String msg = translator.translate(\"The content type of url '%s' is not '%s', it is '%s'\");\n            throw new BadDocumentException(String.format(msg, url.toString(), expected, contentType));\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        return fromHtml(in, encoding);\n    }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"fromHtml": ["fromHText", "fromBushttp", " fromChText", "fromShhtml", " fromHUrl", "fromPhttp", "fromChText", "fromHttpText", "fromBushtml", " fromChUrl", "fromShUrl", "fromChhtml", " fromChhtml", " fromPhHTML", "fromHttp", "fromHttptml", " fromPhttp", " fromHText", "fromBushHTML", " fromHml", "fromHttpUrl", "fromHhtml", "fromPhml", "fromChUrl", "fromHttpHTML", "fromChtml", "fromHttpml", " fromHhtml", "fromHml", " fromHHTML", " fromPhml", "fromHttpttp", "fromHHTML", "fromHttphtml", "fromPhHTML", " fromChtml", " fromPhtml", "fromHUrl", "fromPhtml", "fromBushml", "fromShtml", " fromHttp", "fromShText"], "url": ["text", "source", "org", "ref", "remote", "uri", "str", "client", "browser", "path", "Url", "download", "config", "f", "page", "domain", "il", "link", "input", "l", "image", "or", "loc", "loader", "blog", "web", "service", "object", "location", "builder", "resource", "open", "email", "www", "base", "name", "server", "host", "article", "URL", "obj", "address", "ch", "sl", "api", "connection", "string", "ur", "lr", "html", "file", "cli", "r", "ssl", "response", "id", "xml", "http"], "defaultEncoding": ["currentEnoding", " defaultEncasing", "defaultencode", "currentEnoded", "defaultChoding", " defaultencoding", "currentEncoding", "defaultCoder", "defaultencasing", " defaultCasing", "defaultEnode", "defaultCoded", "defaultEngoding", "defaultEngoder", " defaultCoding", "defaultEncoder", "defaultEnoding", "defaultChasing", "defaultEnasing", "currentEncoded", " defaultencoder", "defaultEngasing", " defaultCoded", " defaultencoded", " defaultencasing", "defaultEncode", "currentEncasing", "defaultencoder", " defaultCoder", "defaultencoded", "defaultEnoded", " defaultEncoder", "defaultencoding", "defaultCoding", "defaultChoded", "defaultEncasing", "currentEnode", "defaultChode", "currentEnasing", "defaultCasing", " defaultEncoded", "defaultEngoded", "defaultEncoded", "defaultEnoder", "currentEncode"], "overrideEncoding": ["overwriteEncoding", "overrideEnoding", "overrideencoder", "overrideEncoder", "overrideCoding", "overwriteEnoded", "overrideEnasing", "overrideCoded", "overwriteEnoding", "overrideEncoded", "overrideEncasing", "overrideCoder", "overwriteEnasing", "overrideencasing", "overwriteEncoder", "overwriteEncoded", "overwriteEncasing", "overrideencoding", "overrideEnoder", "overwriteEnoder", "overrideEnoded", "overrideCasing", "overrideencoded"], "conn": ["out", "client", "sync", "session", "cb", "c", "config", "f", "dc", "reg", "Connection", "cmd", "nt", "l", "serv", "Conn", "socket", "loc", "con", "close", "open", "ad", "act", "n", "connect", "ann", "conv", "server", "exec", "conf", "ch", "api", "connection", "nc", "cp", "enc", "coll", "sql", "cn", "err", "ssl", "cli", "dn", "ct", "ctx", "db", "co", "http"], "contentType": ["enctype", "resourceName", "contentClass", "ContentLine", " contentFormat", "documentName", "ContentClass", "contentPath", "ContentUnit", "codeFile", "filetype", "languageStyle", " contentText", "inputPath", "wordtype", "inputUnit", " contentUnit", "documentType", "ontentPath", "inputType", "documentInfo", "ContentFile", "encLength", "contentFile", "codeType", "fileType", "contentToken", "contentText", "wordType", "languagetype", " contentLength", "ontentClass", "inputLine", "codetype", "inputtype", "contentName", "ContentLength", "ContentType", "ContentPath", "languageInfo", " contentName", "wordName", "codeInfo", "languageType", " contenttype", "codeStyle", " contentToken", "ontentType", "contentStyle", "fileFile", "ContentText", "contentLength", "ontentName", " contentStyle", " contentClass", " contentLine", "workType", "Contenttype", "contenttype", "resourceLength", "workToken", "codeName", "ContentName", " contentFile", "contentInfo", "filePath", "ContentInfo", "resourceInfo", "contentFormat", "ontentLength", "resourceUnit", "contentLine", "resourcetype", " contentPath", "workLength", "worktype", "documentText", "ontentFormat", "encToken", "encType", "resourceType", "codeUnit", "ContentFormat", " contentInfo", "contentUnit"], "encoding": ["enhoding", "equoding", "enhode", "engoded", "Encoding", "execoded", "encoded", " encapping", "enaching", "encode", "encryption", "encasing", "Encasing", "collasing", "casing", "equapping", "enhryption", "encoder", "ecasing", "enhasing", "Encoded", "colloded", "Encryption", "Encode", "coding", "execoding", " encryption", "engoder", "engapping", "coder", "enoded", "caching", "colloding", "enoding", "execoder", "execasing", " encosing", "encaching", "enosing", "ecoding", "Encaching", "enoder", " encode", "engosing", "ecoded", "colloder", "equosing", "equoded", " encoder", "encosing", " encasing", "engasing", "engoding", "enasing", "Encoder", "encapping", "ecoder", "equoder", "coded"], "i": ["p", "x", "init", "uri", "c", "ni", "f", "ai", "gi", "ii", "ori", "ix", "info", "ei", "e", "ie", "l", "I", "area", "ci", "yi", "abi", "ini", "multi", "ip", "io", "bi", "iu", "si", "u", "lc", "is", "ui", "pi", "api", "ji", "li", "j", "h", "oi", "hi", "mi", "di", "qi", "eni", "xi", "fi", "cli", "t", "mu", "slice", "o", "id", "zi", "adi", "v", "ri", "ti", "phi"], "s": ["p", "ls", "source", "as", "su", "ps", "sb", "ts", "ss", "str", "sync", "session", "c", "f", "sym", "e", "sg", "l", "ds", "m", "service", "strings", "ws", "n", "g", "a", "si", "ses", "u", "os", "b", "fs", "sl", "string", "h", "ins", "enc", "details", "gs", "en", "settings", "ns", "abs", "es", "r", "ssl", "t", "o", "sv", "site", "S", "v", "js", "d"], "expected": [" e", "nexpected", "style", "pecting", " Expect", "current", "reported", "wrong", "actual", "pect", "info", "event", "pected", "e", "ie", "needed", "ed", "default", "updated", "required", "example", "found", "allowed", "format", "email", "yet", "latest", "supported", "force", " ie", " received", "next", " unexpected", "fake", " accepted", "opened", "host", " expecting", "seen", "specified", " expects", "now", "ception", "pretty", "handled", "element", "encrypted", " expect", "received", "provided", "failed", "illegal", " event", " expectation", "response", "entry", "acceptable", "forced", "type", " email", "error", "target"], "index": ["x", "match", "edit", "column", "position", "shape", "current", "output", "length", "update", "point", "date", "info", "all", "page", "ix", "level", "input", "pos", "none", "ind", "loc", "condition", "ini", "object", "open", "where", "find", "connect", "num", "search", "array", "Index", "width", "number", "address", "list", "size", "prefix", "alpha", "option", "element", "sort", "weight", "value", "version", "pull", "key", "slice", "end", "id", "unit", "type", "diff", "inc", "offset", "active"], "msg": ["text", "og", "message", "sim", "Message", "ug", "str", "info", "reg", "title", "rr", "ag", "mr", "cmd", "sg", "agg", "fg", "format", "mess", "g", "log", "name", "ms", "reason", "Msg", "gen", "printf", "mid", "gm", "lang", "dr", "details", "mt", "gs", "mit", "desc", "MS", "ma", "err", "comm", " message", "error", "doc"], "in": ["p", "as", "buffer", "rx", "gin", "inn", "out", "inner", "c", "ax", "input", "inas", "xml", "read", "IN", "data", "ini", "win", "con", "io", "din", "b", "dr", "ins", "connection", "fr", "stream", "In", "impl", "inc", "rin", "r", "err", "login", "id", "reader", "bin", "tin"]}}
{"id1": "19113613", "id2": "8932510", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["replace", "save", "rm", "write", " cp", "cp", "sync", "zip", "archive", "paste", "split", "clone", "clip", "type", "download", "process", "move", "cat", "Copy", "create", "delete", "change", "load", "share", "upload", "get", "ssh", "transfer", "Cop", "put", "update", "p", "opy", "cop"], "in": ["ins", "url", "image", "In", "n", "connection", "init", "thin", "data", "this", "project", "inc", "old", "part", "f", "input", "din", "IN", "inn", "lin", "index", "plugin", "cin", "i", "kin", "win", "reader", "sin", "config", "inside", "client", "work", "a", "login", "inner", "base", "min", "id", "token", "bin", "c", "ic", "name", "diff", "pin", "get", "ini", "as", "again", "update", "on"], "out": ["at", "page", "ex", "vert", "one", "image", "resource", "call", "parent", "b", "null", "n", "connection", "remote", "init", "io", "off", "outer", "dot", "project", "this", "version", "outside", "inc", "external", "part", "output", "no", "group", "input", "block", "o", "Out", "conn", "with", "client", "self", "work", "base", "outs", "point", "user", "object", "app", "cache", "exec", "bin", "c", "v", "err", "obj", "option", "name", "net", "goal", "OUT", "up", "root", "other", "path", "x", "again", "line", "p", "ext"], "source": ["prefix", "proxy", "pe", "component", "attribute", "direction", "subject", "secret", "url", "uri", "unit", "resource", "parent", "dest", "scope", "view", "ce", "username", "project", "status", "Source", "site", "route", "family", "missing", "type", "sin", "iter", "class", "src", "size", "base", "feature", "alt", "internal", "position", "id", "ource", "name", "origin", "service", "reference", "SOURCE", "format", "secure", "force", "use", "from"], "target": ["prefix", "component", "direction", "url", "resource", "parent", "master", "dest", "null", "project", "output", "alias", "site", "route", "about", "template", "home", "cat", "top", "config", "src", "Target", "alt", "base", "point", "wrong", "address", "token", "arget", "detail", "name", "origin", "service", "reference", "root", "pattern", "host", "next", "goal", "path", "current", "value", "tail", "format", "force"], "files": ["ls", "keys", "ions", "ins", "links", "users", "obs", "jobs", "data", "assets", "f", "sections", "apps", "groups", "plugins", "features", "classes", "lines", "fs", "s", "children", "flows", "objects", "results", "docs", "tools", "images", "filename", "ports", "pages", "resources", "names", "models", "cells", "iles", "blocks", "Files", "items"], "file": ["page", "FILE", "url", "e", "resource", "ile", "uri", "parent", "le", "b", "unit", "letter", "item", "data", "single", "child", "part", "folder", "entry", "f", "it", "feed", "live", "el", "fe", "future", "dir", "directory", "filename", "l", "base", "object", "id", "local", "string", "load", "name", "entity", "binary", "per", "File", "layer", "path", "function", "current", " File", "line", "fp", "lib"], "inCh": ["InChan", "INChannel", "inCH", "InChannel", "INCH", "inch", "inChan", "outCH", " inch", "InCH", " inChan", " inCH", "outch", "Inch", "InCh", "outChan", "outChannel", " inChannel", "INChan", "inChannel", "INCh"], "outCh": ["Outch", "OutChan", "OutCH", "inCH", " outChannel", "inch", " outch", "inChan", "outCH", "OutChannel", "outputCh", "outch", "outputChan", "outChan", " outCH", "outChannel", "outputCH", "inChannel", "OutCh", "outputch"]}}
{"id1": "647224", "id2": "4750967", "code1": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 1, "substitutes": {"uploadFile": ["uploadfile", "processFile", "UploadFiles", "UploadDir", " uploadDir", "Uploadfile", "uploadFiles", "uploadDir", " uploadfile", "processDir", "processfile", " uploadFiles", "processFiles", "UploadFile"], "inputFile": ["inputFolder", "targetFolder", "initialFile", "sourceLog", " inputDir", "targetLog", "sourceType", "InputDir", "targetPage", "inputFilename", "inputfile", "sourcePage", " inputfile", " inputType", "sourceFolder", "targetFiles", "initialFilename", "sourceFile", "InputType", "targetfile", "inputLog", "InputFile", " inputFilename", " inputStream", "inputDir", "targetDir", "targetStream", " inputPage", "inputStream", " inputFolder", "inputFiles", "sourcefile", "InputFolder", "inputType", "sourceStream", "targetFilename", " inputLog", "InputFiles", "initialStream", "inputPage", " inputFiles", "initialFolder", "InputStream", "Inputfile"], "targetFile": [" targetFiles", "inputPlace", "targetName", "Targetfile", "sourceDir", "externalPath", "TargetLine", "externalfile", "sourcePath", "TargetPath", "targetPlace", "targetFiles", " targetName", "outputPath", "sourceFile", " targetfile", "targetfile", " targetDir", " targetPlace", "TargetFiles", "inputPath", "TargetDir", "inputDir", "targetDir", "targetPath", "TargetFile", "externalName", "outputFiles", "TargetName", "sourcePlace", "outputName", "outputDir", " targetLine", "outputLine", "targetLine", "externalFile", " targetPath"], "outputFile": ["inputFolder", " targetFiles", "outFolder", "writeUrl", " outputUrl", "outputfile", "outputFolder", " targetQueue", "outPlace", "outFile", "inputfile", "outfile", "OutputFolder", "writePage", "inputUrl", " outputFolder", "currentFolder", "targetFiles", "outputQueue", "outputPlace", "outputPath", "writeFile", "targetfile", "inputPath", " targetDirectory", " outputDirectory", "currentPlace", "inputDir", "targetPath", " outputStream", "OutputDir", " outputPath", "currentfile", "outPath", " outputPage", " outputfile", "outputStream", "inputStream", "inputFiles", " outputFiles", " outputDir", " outputPlace", "outputFiles", "outDirectory", "inputDirectory", "writeStream", "Outputfile", "outputDirectory", "targetDirectory", "outputUrl", "outputDir", "currentFile", "inputQueue", "outputPage", "inputPage", "OutputFile", "targetQueue"], "in": ["IN", "pin", "i", "input", "id", "serv", "ini", "con", "inner", "sub", "ins", "s", "bin", "pass", "is", "read", "reader", "source", "up", "login", "diff", "inside", "r", "inc", "data", "rin", "init", "rec", "issue", "again", "io", "isin", "In", "nin", "kin", "pull", "url", "stream", "lin", "err", "ac", "cin", "inn", "win", "din"], "out": ["base", "console", "ex", "output", "sys", "n", "copy", "user", "lock", "by", "report", "outer", "net", "plain", "table", "OUT", "inter", "inner", "outs", "o", "s", "write", "off", "bin", "co", "sync", "client", "one", "source", "cache", "up", "r", "ger", "inc", "cmd", "file", "data", "page", "log", "conn", "again", "exec", "Out", "io", "writer", "image", "to", "dump", "ext", "err", "println", "print", "state", "error", "this", "point"], "line": ["string", "buffer", "base", "job", "lf", "lock", "entry", "LINE", "limit", "write", "pass", "ine", "char", "split", "sync", "part", "type", "rule", "lines", "lc", "data", "file", "page", "le", "inline", "log", "row", "name", "header", "e", "frame", "word", "link", "url", "pe", "unit", "comment", "lin", "Line", "range", "block", "error", "code", "cell"], "bytes": ["zip", "i", "pages", "tes", "comments", "les", "number", "outs", "steps", "length", "s", "bs", "reads", " lines", "items", "lines", "binary", "blocks", "bps", "len", "eps", "classes", "size", "ips", "es", "groups", "Bytes", "ls", "ones", "cycles", "seconds", "pos", "ines", "rows", "values", "files", "count", " cycles", "units", "words", "os", "bits", "odes", "codes", "code"]}}
{"id1": "15971794", "id2": "7118860", "code1": "    private boolean getWave(String url, String Word) {\n        try {\n            File FF = new File(f.getParent() + \"/\" + f.getName() + \"pron\");\n            FF.mkdir();\n            URL url2 = new URL(url);\n            BufferedReader stream = new BufferedReader(new InputStreamReader(url2.openStream()));\n            File Fdel = new File(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n            if (!Fdel.exists()) {\n                FileOutputStream outstream = new FileOutputStream(f.getParent() + \"/\" + f.getName() + \"pron/\" + Word + \".wav\");\n                BufferedWriter bwriter = new BufferedWriter(new OutputStreamWriter(outstream));\n                char[] binput = new char[1024];\n                int len = stream.read(binput, 0, 1024);\n                while (len > 0) {\n                    bwriter.write(binput, 0, len);\n                    len = stream.read(binput, 0, 1024);\n                }\n                bwriter.close();\n                outstream.close();\n            }\n            stream.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n            return false;\n        }\n        return true;\n    }\n", "code2": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "label": 0, "substitutes": {"getWave": ["readwave", "newWave", "getSound", "readWire", "readSound", " getWire", "readWave", " getwave", "newWire", " getSound", "getWire", "getwave", "newSound", "newwave"], "url": ["Ur", "source", "ref", "F", "filename", "File", "fp", "uri", "path", "Url", "field", "f", "page", "Feed", "word", "l", "image", "ff", "loc", "web", "resource", "base", "name", "inf", "b", "host", "URL", "fl", "fe", "address", "string", "fn", "fr", "lr", "fax", "file", "wave", "feed", "r", "sf", "http"], "Word": ["F", "Message", "Line", "words", "File", "Folder", "Path", "Weight", "Url", "Dir", "Feature", "Str", "Length", "Work", "wd", "Term", "word", "Time", "Name", "Rule", " word", "W", "Writer", "Wire", "Token", "Language", "Tag", "Msg", "Text", "Win", "Function", "Code", "Gender", "Class", "string", "Stream", "Letter", "Field", "Content", "Wave", "Part", "Words", "World", "Eng", "Hack", "Key", "Frame"], "FF": ["DF", "FA", "F", "FW", "fp", "FE", "IF", "FS", "AF", "Client", "Folder", "FB", "Fax", "FP", "Fi", "Feed", "TF", "ff", "DC", "RC", "FILE", "FC", " ff", "P", "IFF", "fd", "CC", "URL", "FD", "ELF", "FL", "FH", "BB", "Field", "LL", "FM", "feed", "IP", "SF"], "url2": [" url3", "l4", "url1", "l1", " urlTwo", " url1", "URLTwo", "URL2", "URLDB", "urlDB", "urlTwo", "f4", "f2", "url3", "pathTwo", "pathDB", "path2", "f1", "f3", "l3", " urlDB", " url4", "URL1", "path1", "url4", "l2"], "stream": ["flow", "source", "form", "video", "sw", "forward", "output", "steam", "client", "path", "flash", "field", "f", "view", "w", "driver", "input", "src", "socket", "ff", "draft", "loader", "writer", "in", "transform", "io", "fd", "host", "server", "thread", "sl", "live", "ack", "string", "Stream", "channel", "fr", "stack", "handler", "coll", "raw", "impl", "file", "temp", "loop", "row", "wave", "feed", "response", "ssl", "roll", "reader", "slice", "pipe", "v", "context", "http"], "Fdel": ["Fidelete", "Fdelete", "fDel", "Ffin", "fdelete", "ffin", "fdestroy", "FiDel", " Ffin", "fdel", " Fdestroy", "Fidel", "Fidestroy", " FDel", "FDel", " Fdelete", "Fdestroy", "Fifin"], "outstream": [" outreader", "outputform", "outchannel", "outputlog", "Outform", "Outfile", " outform", " outfile", "outform", " outStream", "inlog", "inputlog", "outputchannel", "Outstream", "inwriter", "inputstream", "outreader", "instream", "outmodel", " outwriter", "outputStream", "inmodel", "outputfile", "outputreader", "inchannel", "OutStream", "outputstream", "inputStream", "inreader", "outfile", "outwriter", "outStream", "outputmodel", "outputwriter", "outlog", " outmodel", "inStream", "inputchannel"], "bwriter": ["bwrite", "fwrite", "Bwrite", "bbwriters", " bbuilder", "outwriting", "bbWriter", "bbwriter", "fbwrite", "breader", " bwrite", "freader", "bbuilder", "Bbuilder", "fbwriter", " bWriter", "outreader", " bwriters", "fbuilder", " bwriting", "Breader", "fbWriter", "Bwriter", " breader", "bwriting", "bbwriting", "bWriter", "fwriter", "bwr", "bbreader", "outwriter", " bwr", "bwriters", "bbwr", "bbwrite", "fbwriters", "outwr"], "binput": ["bincut", " binstop", "output", "binsell", " binstart", "byteset", "bisplit", "winsell", " binwrite", "binpos", "bipos", "winput", "libcut", " binset", " binpos", "bitput", "binstop", "binlog", "binaryput", "binaryset", "libset", "liblog", "libput", "bitset", "binarycut", "bytesplit", "sinput", "binstart", "sinset", "biwrite", " binsell", "binarylog", "binset", "binsplit", "biset", "binwrite", "byteput", "winstart", "sincut", "winwrite", "sinlog", " binsplit", "outsell", "outstart", "bitwrite", "bitpos", "bistop", "biput", "outwrite", "bytestop"], "len": ["ls", "pre", "lf", "ln", "fun", "seq", "length", "lt", "hl", "lan", "lim", "ie", "l", "pos", "count", "line", "val", "lon", "data", "elt", " lang", "dl", "n", "limit", "base", "ann", "num", "lc", "low", "label", "fin", "fl", "split", "sl", "li", "size", "enc", "coll", "el", "lin", "en", "Len", "iter", "cap", "part", "end", "le", "id", "rev", "bin", "la"]}}
{"id1": "6742637", "id2": "15472181", "code1": "    private static List<Properties> findExtensions() {\n        URL url = null;\n        try {\n            List<Properties> extensions = new ArrayList<Properties>();\n            Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\");\n            while (res.hasMoreElements()) {\n                url = res.nextElement();\n                Properties prop = new Properties();\n                prop.load(url.openStream());\n                extensions.add(prop);\n            }\n            return extensions;\n        } catch (IOException ioe) {\n            String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm();\n            throw new RuntimeException(msg, ioe);\n        }\n    }\n", "code2": "    private InputStream getInputStream(String item) {\n        InputStream is = null;\n        URLConnection urlc = null;\n        try {\n            URL url = new URL(item);\n            urlc = url.openConnection();\n            is = urlc.getInputStream();\n            current_source = url.getProtocol() + \"://\" + url.getHost() + \":\" + url.getPort() + url.getFile();\n        } catch (Exception ee) {\n            System.err.println(ee);\n        }\n        int i = 0;\n        udp_port = -1;\n        udp_baddress = null;\n        while (urlc != null) {\n            String s = urlc.getHeaderField(i);\n            String t = urlc.getHeaderFieldKey(i);\n            if (s == null) {\n                break;\n            }\n            i++;\n            if (\"udp-port\".equals(t)) {\n                try {\n                    udp_port = Integer.parseInt(s);\n                } catch (Exception e) {\n                }\n            } else if (\"udp-broadcast-address\".equals(t)) {\n                udp_baddress = s;\n            }\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"findExtensions": ["findAppensions", "findExtends", "getextension", "findextension", "findAppension", "getextensions", "findExtension", "getExtends", "findextensions", "findDistension", "findDistensions", "findAppends", "getExtension", "findDistends", "findextends", "getExtensions", "getextends"], "url": ["lr", "r", "image", "fr", "buffer", "service", "sl", "ul", "element", "html", "entry", "rl", "src", "rc", "load", "feed", "impl", "bug", "ls", "bb", "il", "id", "page", "server", "coll", "address", "bel", "loc", "result", "ver", "connection", "http", "location", "URL", "resource", "path", "io", "pull", "ssl", "file", "link", "f", "Url", "ch", "api", "base", "zip", "data", "err", "gl", "log", "rel", "org", "cl", "name", "l", "remote", "web", "ur", "uri", "re", "source", "config"], "extensions": ["xtensions", "intends", "exensions", "Extencies", "exras", "xtps", "exencies", "appensions", "appencies", "extps", "Extras", "fension", "extras", "xtension", "Extension", "intps", "appras", "intensions", "fensions", "extension", "fends", "exends", "extencies", "fps", "intension", "exps", "Extensions", "xtends", "appension", "exension"], "res": ["request", "vals", "r", "os", "gr", "ress", "fr", "details", "RS", "is", "rc", "Rs", "RE", "rs", "RES", "pres", "ex", "ros", "es", "ris", "result", "ver", "rss", "http", "vers", "response", "resource", "ras", "rh", "results", "rr", "raw", "out", "ret", "resp", "rez", "hr", "mr", "rev", "req", "ch", "rest", "err", "rex", "rem", "rows", "ries", "Res", "resolution", "js", "ps", "rus", "re"], "prop": ["j", "p", "term", "obj", "attr", "pos", "cp", "def", "class", "key", "tmp", "app", "opt", "properties", "option", "val", "info", "result", "property", "fb", "exp", "ext", "resource", "ref", "op", "fp", "proc", "lit", "Prop", "pb", "part", "feat", "f", "api", "base", "feature", "data", "b", "comp", "pac", "mp", "style", "pro", "project", "ps", "point", "priv", "config", "pr"], "msg": ["gr", "error", "db", "m", "kg", "bf", "g", "s", "ug", "title", "mn", "mid", "urg", "loc", "info", "sg", "format", "bg", "reason", "message", "ext", "mb", "ko", "eg", "str", "req", "mg", "err", "log", "printf", "Msg", "tag", "status", "text", "mt", "cfg", "me", "comm", "mag", "rag", "string", "og", "gs", "gm", "ms", "cmd", "agg"]}}
{"id1": "8468859", "id2": "22611968", "code1": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "code2": "    public Bitmap retrieveBitmap(String urlString) {\n        Log.d(Constants.LOG_TAG, \"making HTTP trip for image:\" + urlString);\n        Bitmap bitmap = null;\n        try {\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setConnectTimeout(3000);\n            conn.setReadTimeout(5000);\n            bitmap = BitmapFactory.decodeStream(conn.getInputStream());\n        } catch (MalformedURLException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, malformed URL\", e);\n        } catch (IOException e) {\n            Log.e(Constants.LOG_TAG, \"Exception loading image, IO error\", e);\n        }\n        return bitmap;\n    }\n", "label": 0, "substitutes": {"connect": ["close", "add", "on", "con", "connected", "socket", "find", "run", "patch", "Connect", "host", "write", " connection", "read", " reconnect", "en", " disconnect", "select", "client", "stat", "nect", "construct", "login", "connection", "build", "open", "bind", "config", "log", "conn", "init", "start", "exec", "port", "establish", "create", "sign", "download", "boot", "stop"], "status": ["index", "temp", "id", "output", "response", "server", "user", "continue", "site", "version", "current", "result", "standard", "si", "ui", "active", "content", "Status", "fail", "sync", "session", "source", "use", "stat", "type", "login", "min", "str", "parent", "log", "style", "complete", "edit", "success", "full", "skip", "update", "unit", "summary", "wait", "stage", "count", "progress", "state", "step", "speed", "code"], "reply": ["reason", "info", "address", "fee", "dy", "base", "server", "response", " response", "message", "py", "result", "answer", "query", "ret", "next", "post", "sync", "resp", "connection", "Reply", "data", "request", "vote", "action", "send", "call", "link", "prefix", "second", "ping", "bot", "respond", "update", "comment", "random", "state", "count", "repl", "error", "code"], "isConnected": ["isNECTalled", "isaAdapting", "isaConnectified", "IsConnected", "isConnectaged", "isFinalled", "IsConnections", "isConnectionp", "IsConnectionp", "isAcceptted", "isConnects", "isConnectioning", "isConnectted", "isAcceptaged", " isAcceptted", "IsConnectioning", " isConnectioned", "isFinaged", " isConnectable", " isAcceptaged", "isNECTing", "IsConnectp", "isAdapting", "isconnecteded", "isConnectionified", "isConnectified", "isaConnecting", " isConnectted", "isAdaptified", "IsConnects", " isConnecting", "isConnectished", "IsConnectioned", "isconnecteding", "isAdapteded", "isFinished", "isConnectioneded", "isConnectp", "isaAdaptified", "isConnections", " isAcceptable", "isNECTished", "isaAdapteded", "isAdapted", "isaAdapted", " isAccepted", "isAcceptable", " isConnectionished", "isconnectedp", " isConnectalled", " isConnectaged", "isFined", "isConnectionished", "isFinted", "isConnecteded", "isConnectioned", "isConnectionalled", " isConnectionalled", " isConnectioning", "isNECTed", "IsConnecting", "isFinable", " isConnectished", "isAccepted", "isaConnecteded", "isaConnected", "isFining", "isconnecteds", "isConnectalled", "isConnecting", "isConnectable"]}}
{"id1": "5142039", "id2": "14619453", "code1": "    public static String uncompress(String readPath, boolean mkdir) throws Exception {\n        ZipArchiveInputStream arcInputStream = new ZipArchiveInputStream(new FileInputStream(readPath));\n        BufferedInputStream bis = new BufferedInputStream(arcInputStream);\n        File baseDir = new File(readPath).getParentFile();\n        String basePath = baseDir.getPath() + \"/\";\n        if (mkdir) {\n            String[] schema = readPath.split(\"/\");\n            String baseName = schema[schema.length - 1].replaceAll(\".zip\", \"\");\n            FileUtils.forceMkdir(new File(basePath + baseName));\n            basePath = basePath + baseName + \"/\";\n        }\n        ArchiveEntry entry;\n        while ((entry = arcInputStream.getNextEntry()) != null) {\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(basePath + entry.getName()));\n            } else {\n                String writePath = basePath + entry.getName();\n                String dirName = FilenameUtils.getPath(writePath);\n                FileUtils.forceMkdir(new File(dirName));\n                BufferedOutputStream bos = new BufferedOutputStream(FileUtils.openOutputStream(new File(writePath)));\n                int i = 0;\n                while ((i = bis.read()) != -1) {\n                    bos.write(i);\n                }\n                IOUtils.closeQuietly(bos);\n            }\n        }\n        IOUtils.closeQuietly(bis);\n        return basePath;\n    }\n", "code2": "    public Set<String> getAvailableRoles() {\n        if (availableRoles == null) {\n            availableRoles = new HashSet<String>();\n            try {\n                Enumeration<URL> resources = org.springframework.util.ClassUtils.getDefaultClassLoader().getResources(ROLE_FILE_LOCATION);\n                while (resources.hasMoreElements()) {\n                    URL url = resources.nextElement();\n                    InputStream is = null;\n                    try {\n                        URLConnection con = url.openConnection();\n                        con.setUseCaches(false);\n                        is = con.getInputStream();\n                        List<String> lines = IOUtils.readLines(is, \"ISO-8859-1\");\n                        if (lines != null) {\n                            for (String line : lines) {\n                                availableRoles.add(line.trim());\n                            }\n                        }\n                    } finally {\n                        if (is != null) {\n                            is.close();\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return availableRoles;\n    }\n", "label": 0, "substitutes": {"uncompress": [" uncompression", " unompress", "uncompzip", " unompressed", "unompress", " uncompressed", " uncompzip", "unompzip", "uncopressed", " unompression", "unompressed", "uncopression", "unCompress", " unompzip", "uncompressed", "unCompzip", "uncopzip", "unCompression", "unompression", "uncopress", "uncompression", "unCompressed"], "readPath": ["loadPo", "scanDir", "readerPath", "baseTree", "writeCase", "baseFile", "readPo", "checkFile", "checkPo", "scanCase", "scanpath", "workPath", "readerFile", "readFile", "readDir", "loadCase", "readerpath", "readpath", "loadDir", "scanPath", "baseWith", "checkDir", "writeFile", "readWith", "writepath", " readFile", " readpath", "basepath", "readTree", " readWith", "workpath", "readerTree", "writeDir", "workFile", "workTree", "readCase", "checkPath", "loadpath", "writePo", "loadPath", "loadWith", "loadFile"], "mkdir": ["kkdir", "mutdir", "muturl", "kkzip", " mkurl", " mkrel", "kkDir", "MKzip", "ckDir", " mkDir", "MKDir", "mkrel", "mutDir", "mutdb", "mkzip", "ckurl", " mkdb", "mkurl", "kkrel", "ckdir", " mkzip", "MKdir", "ckdb", "MKrel", "mkdb", "mkDir"], "arcInputStream": ["arcImportChannel", "arcInputSteam", "cInputSteam", "arcFileSt", "cOutputSteam", "ancOutputFile", "ancOutputForm", "arcFileStream", "arcOutputForm", "ancOutputStream", "arcFileSync", "cOutputStream", "arcInputFile", "arcReadSt", "ancOutputstream", "arcOutputstream", "cOutputSt", "arcInputChannel", "ancInputFile", "ancOutputSteam", "cInputSt", "ancInputForm", "arcHttpSteam", "arcImportStream", "arcReadSync", "arcOutputSt", "ancInputstream", "arcOutputStream", "cOutputSync", "arcReaderstream", "ancInputStream", "arcOutputChannel", "cInputStream", "arcReaderChannel", "arcOutputFile", "arcInputstream", "arcInputSt", "arcInputSync", "arcReadStream", "arcImportstream", "arcReaderStream", "arcHttpStream", "cInputSync", "arcOutputSync", "ancInputSteam", "arcReaderFile", "arcHttpstream", "arcImportFile", "ancInputChannel", "arcInputForm", "arcOutputSteam", "arcReadForm", "arcReadstream", "arcHttpForm", "arcFileSteam", "arcReadSteam", "ancOutputChannel"], "bis": ["isin", "cb", "BUS", "cos", "oss", "bs", "ins", "boot", "ubs", "raf", "idis", "os", "lins", "binary", "kos", "is", "bb", "bi", "ls", "abs", "parts", "bits", "obs", "lus", "phis", "ubis", "bus", "abi", "ras", "pins", "bid", "mis", "phys", "uds", "alis", "vs", "ois", "banks", "bps", "ris", "oris", "ours", "ros", "sis", "ios", "usb", "onis", "obb", "fb", "ses"], "baseDir": ["fileFolder", "rootDir", " baseDirectory", "fileDirectory", "rootFolder", "BaseDirectory", "fileDir", "Basedir", " baseFolder", "baseFolder", "BasePath", "rootDirectory", "filedir", "BaseFolder", "BaseDir", " basedir", "baseDirectory", "basedir", "rootPath"], "basePath": ["basicDir", "BaseCondition", "readInfo", "baseHost", "BaseFile", "baseInfo", "outDir", " baseType", "parentFile", "fileName", "basicInfo", "baseFile", "parentPath", "baseUrl", "BaseUrl", "basicPath", "resourcePath", " basepath", "baseStream", "readUrl", "buildHost", "baseCondition", "basedHost", "outPath", "parentName", "fileDir", "readDir", "writeHome", "viewOrder", "Basepath", "basicCondition", "baseType", " baseHost", "writeStream", "viewHome", " baseFile", "basedDir", "BasePath", "viewStream", " baseStream", "outUrl", "resourcepath", "baseHome", "buildDir", "fileUrl", "filePath", "parentUrl", "viewPath", " baseHome", "outName", "BaseDir", "resourceName", " baseUrl", "basedType", "baseOrder", "buildPath", "writeOrder", "BaseName", "BaseInfo", " baseOrder", "readName", "basedPath", "buildType", "readCondition", "resourceDir", "basepath"], "schema": ["syme", "syaga", "Scheme", " schemar", "chemar", "syma", "mamas", " schemas", "Schemar", "symas", "scheme", "mapa", "scheaga", "cheme", "issme", "issma", "cheaga", "isspa", "schemar", "Schemas", "Scheaga", " scheme", "chemas", "mama", "Schepa", "schemas", "issmas", "chema", "schepa", "Schema", "mame"], "baseName": ["normalPath", " baseInfo", "basPath", "baseInfo", "basInfo", "normalName", "basName", "corePath", " baseTitle", "basicPath", "normalTitle", "areaKey", "coreName", "normalKey", "basicKey", "coreInfo", "baseTitle", "BasePath", "BaseTitle", "areaPath", "basicName", "baseKey", "areaName", "coreDir", "basDir", "BaseKey", "BaseName", " baseKey"], "entry": ["nt", "reader", "connection", "extra", "office", "le", "data", "name", "it", "si", "card", "archive", "install", "ries", "info", "ge", "se", "ae", "letter", "ie", "base", "lc", "add", "Entry", "part", "inner", "entity", "je", "sea", "zip", "her", "ace", "line", "article", "e", "section", "key", "la", "journal", "row", "comment", "parse", "style", "service", "feed", "child", "or", "inc", "path", "editor", "object", "next", "system", "no", "enter", "iterator", "uri", "server", "post", "pe", "index", "valid", "ry", "cel", "result", "record", "obj", "exp", "ent", "de", "element"], "writePath": ["writerEx", "writingPath", "writingDir", " writeEx", "writeName", "writeCase", "WriteDir", "writeEx", " writeCh", "baseStream", "writtenPoint", "writtenName", "readDir", "writeCh", " writeDir", "writerCh", "readPoint", "writeStream", " writePoint", "writePoint", "WriteCh", "readStream", "WriteEx", "writingPoint", "writerDir", "writerPath", "writeDir", "readCase", "writtenStream", "writingCase", " writeCase", "writtenPath", "readName", "WritePath", "basePoint"], "dirName": ["DIRPath", "DirAlias", "dirUrl", "Dirname", "orderUrl", " dirDef", "dirDef", " dirname", "dirAlias", "DirName", "DIRAlias", "ordername", " dirPath", "DIRDef", " dirUrl", " dirAlias", "orderName", "DIRName", "dirname", "dirPath", "DirUrl", "DirPath", "DirDef"], "bos": ["bott", "osa", "opus", "fits", "las", "gb", "bes", "oos", "asio", "bs", "bies", "boot", "ubs", "rots", "os", "lins", "obos", "kos", "atis", "bb", "bi", "ko", "obs", "dies", "oks", "ubis", "nas", "bas", "ois", "uds", "obo", "banks", "osi", "aos", "bo", "ros", "boards", "los", "ios", "zo", "zos", "oids", "obb", "obi", "bc", "bones"], "i": ["x", "ji", "f", "si", "it", "start", "ri", "batch", "mini", "slice", "s", "p", "info", "j", "pi", "is", "hi", "I", "bi", "di", "b", "multi", "inner", "qi", "l", "r", "e", "o", "ini", "abi", "ci", "z", "limit", "exec", "xi", "v", "ui", "li", "zi", "uri", "ii", "io", "c", "in", "ni", "id", "index", "chi", "a", "ai", "phi", "length", "you", "ip"]}}
{"id1": "18731843", "id2": "4118412", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "label": 1, "substitutes": {"doBody": ["DoFile", "DoResponse", "handleBody", "doResponse", "DoBody", " doFile", "DoBytes", " doResponse", "handleResponse", "handleFile", "doFile", "handleBytes", "doBytes", " doBytes"], "req": ["err", "resource", "q", "rx", "fr", "crit", "this", "config", "serv", "download", "cgi", "obj", "ref", "src", "http", "qq", "rec", "respond", "conn", "jp", "info", "def", "r", "spec", "query", "sem", "Request", "rr", "proc", "rh", "comp", "report", "request", "data", "qt", "reader", "res", "reg", "requ", "rss"], "resp": ["re", "err", "html", "serv", "val", "exc", "Response", "respons", "download", "pre", "rep", "ref", "cache", "rev", "rec", "api", "respond", "bb", "jp", "cb", "b", "prot", "pos", "sp", "r", "job", "p", "part", "cmp", "result", "ret", "rr", "inv", "proc", "comp", "response", "Resp", "report", "request", "data", "res", "reply", "obj"], "bis": ["pins", "rots", "atis", "mis", "bits", "iris", "alis", "bid", "lins", "nis", "bas", "lis", "bin", "b", "bb", "usb", "ubis", "obs", "abi", "fb", "bes", "boot", "ris", "obb", "bi", "obos", "sb", "os", "uds", "phis", "sis", "iss", "is", "ses", "bian", "ori", "ois", "bs", "isin", "oris", "bps", "binary", "ios", "ais", "tis", "bh", "los", "sin", "obi"], "bos": ["bo", "lol", "zos", "osa", "ops", "bits", "osi", "lins", "mos", "bas", "bin", "oros", "bris", "bones", "obo", "ubis", "obs", "zo", "abi", "bes", "boot", "ros", "obb", "obos", "os", "oks", "bi", "uds", "phis", "antis", "bott", "oS", "las", "ois", "oops", "bs", "opus", "oses", "bps", "ios", "tis", "oos", "fits", "bh", "los", "aos", "obi"]}}
