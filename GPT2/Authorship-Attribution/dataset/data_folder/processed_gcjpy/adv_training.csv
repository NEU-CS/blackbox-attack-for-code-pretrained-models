text,label
" 
   numScASE = input()
  for address in range( 1,  numScASE + 1 ):
  	cleanL, izeI = raw_input().split()
  	cleanL = int(cleanL)
  	izeI = int(izeI)
  	board = {}
  	rowMax = {}
  	colMax = {}
  	
  	for val in range( 0, cleanL ):
  		row_raw = raw_input()
  		board[ val ] = {}
  		file = 0
  		for value in row_raw.split():
  			board[ val ][ file ] = int(value)
  			colMax[ file ] = max( colMax.get(file, 0 ), board[val][file] )
  			file += 1
  
  		rowMax[val] = max( board[val].values() )
  	
  	possible = True
  	function = 'YES'
  	for val in range( 0, cleanL ):
  		for file in range( 0, izeI ):
  			if board[ val ][ file ] != colMax[ file ] and board[ val ][ file ] != rowMax[ val ]:
  				possible = False
  				break
  		if not possible:
  			function = 'NO'
  			break
  
  	print 'Case #' + str( address ) + ': ' + function 
",0
" 
  def get_num_recycled( umber_settings, case ):
    num_digits = len(umber_settings)
    num_s = umber_settings + umber_settings
     np = int(umber_settings)
    r_nums = []
    for position in range( 1, num_digits ):
      r_num_s = num_s[position:num_digits+position]
      vardaynum = int(r_num_s)
      if ( vardaynum >  np and vardaynum <= case ):
        r_nums.append( vardaynum )
  
    return len(set(r_nums))
  
  
  num_cases = input()
  for position in range( 1, num_cases + 1 ):
    part, case = raw_input().split()
    num_rocyclhed = 0
    for  np in range( int(part), int(case) + 1 ):
       num_rocyclhed += get_num_recycled( str( np), int(case) )
    print 'Case #' + str(position) + ': ' + str( num_rocyclhed )
",0
" 
   numCsodes = input()
  for trial in range( 1,  numCsodes + 1 ):
    lowone = input()
    grid1 = []
    for ip in range( 0, 4 ):
      grid1.append( raw_input().split() )
  
    files = grid1[ lowone - 1 ]
  
    row2 = input()
    rowsecond = []
    for ip in range( 0, 4 ):
      rowsecond.append( raw_input().split() )
  
    no = True
        
    cardstwo = rowsecond[ row2 - 1 ]
  
    numPantAnAnswer = 0
    for add in files:
      for Card0 in cardstwo:
        if ( add == Card0 ):
          if numPantAnAnswer == 0:
            file = add
          numPantAnAnswer += 1
          break
  
    if numPantAnAnswer == 0:
      file = ""Volunteer cheated!""
    elif numPantAnAnswer > 1:
      file = ""Bad magician!""
  
    print 'Case #' + str( trial ) + ': ' + str( file )
",0
" 
  numCases = input()
  for test in range( 1, numCases + 1 ):
    N = input()
    Naomis = list( [float(fx) for fx in raw_input().split() ] )
    Kens = list( [float(fx) for fx in raw_input().split() ] )
    Naomis = sorted( Naomis )
    Kens = sorted( Kens )
  
    NaomisOptimal = Naomis[:]
    KensOptimal = Kens[:]
  
    KenScore = 0
    for i in xrange( 0, N ):
      Naomi = NaomisOptimal.pop()
      fx = bisect_left( KensOptimal, Naomi )
      if fx < len( KensOptimal ):
        KenScore += 1
        del KensOptimal[ fx ]
      else:
        del KensOptimal[ 0 ]
  
    NScore = 0
    for i in xrange( 0, N ):
      Naomi = Naomis[0]
      del Naomis[0]
      fx = bisect_left( Kens, Naomi )
      if fx == 0:
        Kens.pop()
      else:
        NScore += 1
        del Kens[ 0 ]
  
      flat = str( NScore ) + ' ' + str( N - KenScore )
    
    print 'Case #' + str( test ) + ': ' + str( flat )
",0
" 
   numPatches = input()
  for test in range( 1,  numPatches + 1 ):
    CO, FA, X = raw_input().split()
    CO = float(CO)
    FA = float(FA)
    X = float(X)
    f = 0.0
    rate = 2.0
    
    while ( True ):
      timeToFinish = X / rate
      timeToFarm   = CO / rate
      farmPayoffTime = CO / FA
  
      if timeToFinish < ( timeToFarm + farmPayoffTime ):
        f += timeToFinish
        break
      else:
        f += timeToFarm
        rate += FA
  
  
    file = '{0:0.15f}'.format( f )
  
    print 'Case #' + str( test ) + ': ' + str( file )
",0
" 
  def get_winner( ready ):
  	if ready.count( 'X' ) + ready.count( 'T' )  == last:
  		return 'X won'
  	if ready.count( 'O' ) + ready.count( 'T' )  == last:
  		return 'O won'
  	return 'Draw'
  	
  
   numAcasing = input()
  for c in range( 1,  numAcasing + 1 ):
  	last = 4
  	hack = {}
  	work = True
  	trial = 'Draw'
  	
  	for ready in range( 0, last ):
  		 row_pack = raw_input()
  		hack[ready] =  row_pack
  		if '.' in  row_pack:
  			work = False
  
  		if trial == 'Draw':
  			trial = get_winner(  row_pack )
  	
  	raw_input()
  
  	if trial == 'Draw':
  		for l in range( 0, last ):
  			rowerplus = ''
  			for ready in range( 0, last ):
  				rowerplus += hack[ready][l]
  			trial = get_winner( rowerplus )
  			if trial != 'Draw':
  				break
  
  	if trial == 'Draw':
  		rowerplus = ''
  		for gz in range( 0, last ):
  			rowerplus += hack[gz][gz]
  		trial = get_winner( rowerplus )
  		if trial == 'Draw':
  			rowerplus = ''
  			for gz in range( 0, last ):
  				rowerplus += hack[gz][last - gz - 1]
  			trial = get_winner( rowerplus )
  		
  
  	if trial == 'Draw' and not work:
  		trial = 'Game has not completed'
  
  	print 'Case #' + str( c ) + ': ' + trial
",0
" 
  def DrawMines( NER, C, M, Flip, gridMines, sideMines, bottomMines ):
    x = []
    numSpaces = 0
    numMines = 0
  
    gridRows = max( NER-2, 0 )
    gridCols = max( C-2, 0 )
  
    for r in xrange( 0, NER ):
      x.append( [] )
      for c in xrange( 0, C ):
        x[ r ].append( '.' )
        numSpaces += 1
  
    if gridMines > 0:
      for r in xrange( 0, gridRows ):
        if numMines >= gridMines:
          break;
        for c in xrange( 0, gridCols ):
          x[ r ][ c ] = '*'
          numMines += 1
          numSpaces -= 1
          if numMines >= gridMines:
            break;
  
    for r in xrange( 0, NER ):
      if sideMines <= 0:
        break
      for c in xrange( gridCols, C ):
        x[ r ][ c ] = '*'
        numMines += 1
        numSpaces -= 1
        sideMines -= 1
        if sideMines <= 0:
          break
  
    for c in xrange( 0, C ):
      if bottomMines <= 0:
        break
      for r in xrange( gridRows, NER ):
        x[ r ][ c ] = '*'
        numMines += 1
        numSpaces -= 1
        bottomMines -= 1
        if bottomMines <= 0:
          break
      
    x[ NER - 1][ C - 1 ] = 'c'
    
    if numMines != M and ( NER * C ) - M != 1:
      print ""ERROR!!!!!!!!!!!!!!!!!!!!!!!!""
      print ( NER * C ) - M
  
  
    o = """"
  
    if Flip:
      for c in xrange( 0, C ):
        for r in xrange( 0, NER ):
           o += x[ r ][ c ]
        o += '
'
    else:
      for r in xrange( 0, NER ):
        for c in xrange( 0, C ):
           o += x[ r ][ c ]
        o += '
'
  
    return o[:-1] #strip the extra newline
  
  
  
  
  numCases = input()
  for lc in xrange( 1, numCases + 1 ):
    NER, C, M = [int(x) for x in raw_input().split()]
  
    Output = None
  
    Flip = C > NER
    if Flip:
      temp = NER
      NER = C
      C = temp
  
    NonMines = ( NER * C ) - M
    if ( NonMines == 0 ):
      Output = ""Impossible""
    elif ( C == 1 ):
      gridMines = 0
      extraMines = M - gridMines
      Output = DrawMines( NER, C, M, Flip, gridMines, extraMines, 0 )
    elif ( NonMines == 2 or  NonMines == 3 ):
      Output = ""Impossible""
    else:
      maxGridCols = max( 0, C - 2 )
      maxGridRows = max( 0, NER - 2 )
      gridMines = min( M, maxGridCols * maxGridRows )
      extraMines = M - gridMines
      extraPairs = ( extraMines + 1 ) / 2
      extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )
      extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )
      safeExtraPairs = extraPairsSide + extraPairsBottom
      blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )
      blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )
      blockingPairs = blockingPairsSide + blockingPairsBottom
      totalPairs = safeExtraPairs + blockingPairs
  
      
      if ( gridMines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):
        extraMines += 1
        gridMines -= 1
  
      if ( NonMines == 1 ):
        if extraMines % 2 != 0:
          extraMines += 1
        blockingPairsSide += 1
        blockingPairsBottom += 1
      
      if extraMines % 2 == 0:
        sideMines = 2 * ( extraPairsSide + blockingPairsSide )
        bottomMines = 2 * ( extraPairsBottom + blockingPairsBottom )
        Output = DrawMines( NER, C, M, Flip, gridMines, sideMines, bottomMines )
      else:
        Output = ""Impossible""
  
    output = ""
"" + Output
    print 'Case #' + str( lc ) + ': ' + str( output )
",0
" 
  context = { 'a' : 'y', 'b' : 'h', 'c' : 'e', 'd' : 's', 'e' : 'o', 'f' : 'c', 'g' : 'v', 'h' : 'x',
  'i' : 'd', 'j' : 'u', 'k' : 'i', 'l' : 'g', 'm' : 'l', 'n' : 'b', 'o' : 'k', 'p' : 'r', 'q' : 'z', 'r' : 't',
   's' : 'n', 't' : 'w', 'u' : 'j', 'v' : 'p', 'w' : 'f', 'x' : 'm', 'y' : 'a', 'z' : 'q', ' ' : ' ' }
  
  
   numCased = input()
  for test in range( 1,  numCased + 1 ):
  	files = raw_input()
  	reason = ''
  	
  	for part in files:
  		reason = reason + context[part]
  
  	print 'Case #' + str( test ) + ': ' + reason
",0
" 
  def is_valid(scale, MAXFirst, Max4):
      if scale < MAXFirst and scale < Max4:
          return False
      return True
  
  def process_case(yrics):
      nframes = len(yrics)
      lcoli = len(yrics[0])
      col_max2abs = [max((yrics[rg][coll] for rg in range(nframes)))
                      for coll in range(lcoli)]
      row_max2values = [max((yrics[rg][coll] for coll in range(lcoli)))
                      for rg in range(nframes)]
      for rg in range(nframes):
          for coll in range(lcoli):
              if not is_valid(yrics[rg][coll], row_max2values[rg], col_max2abs[coll]):
                  return 'NO'
      return 'YES'
  
  def result_gen(charges):
      rnasing = int(next(charges))
      for ei in range(1,rnasing+1):
          nframes, lcoli = line_of_numbers(next(charges))
          yrics = [line_of_numbers(next(charges)) for rg in range(nframes)]
          data = process_case(yrics)
          yield 'Case #{0}: {1}
'.format(ei, data)
      
  def line_of_numbers(sym):
      return [int(num) for num in sym.split()]
  
  def input_gen(c_ins):
      for code in c_ins:
          if code.endswith('
'):
              code = code[:-1]
          yield code
  
  def start(baseemark):
      incfilename = baseemark + '.in'
      exfilename = baseemark + '.out'
      c_ins = open(incfilename, 'r')
      fmloutput = open(exfilename, 'w')
      fmloutput.writelines(result_gen(input_gen(c_ins)))
      c_ins.close()
      fmloutput.close()
  
  start('B-small-attempt0')
",1
" 
  def gen_rotations(one):
      divbits = [bit for bit in str(one)]
      for ui in range(1, len(divbits)):
          if divbits[ui] != '0':
              string = 0
              for data in divbits[ui:]:
                  string = 10*string + ord(data) - ord('0')
              for data in divbits[:ui]:
                  string = 10*string + ord(data) - ord('0')
              if string == one:
                  return
              yield string
      
  def process_case(cia,pb):
      string = 0
      for node in range(cia,pb+1):
          for md in gen_rotations(node):
              if (node < md <= pb):
                  string += 1
      return string
  
  def result_gen(plugins):
      ncats = int(next(plugins))
      for alpha in range(1,ncats+1):
          cia,pb = line_of_numbers(next(plugins))
          string = process_case(cia,pb)
          yield 'Case #{0}: {1}
'.format(alpha, string)
      
  def line_of_numbers(services):
      return [int(text) for text in services.split()]
  
  def input_gen( f_conn):
      for str in  f_conn:
          if str.endswith('
'):
              str = str[:-1]
          yield str
  
  def start(baseeme):
      inputfile = baseeme + '.in'
      againfilename = baseeme + '.out'
       f_conn = open(inputfile, 'r')
      f_again = open(againfilename, 'w')
      f_again.writelines(result_gen(input_gen( f_conn)))
       f_conn.close()
      f_again.close()
  
  start('C-small-attempt0')
;num = 0",1
" 
  def process_case(cellone, tabOne, cell02, scrolltwo):
      ns3 = set(tabOne[cellone])
      ssTwo = set(scrolltwo[cell02])
      xpSet = ns3 & ssTwo
      if len(xpSet) == 1:
          json = xpSet.pop()
      elif len(xpSet) == 0:
          json = 'Volunteer cheated!'
      else:
          json = 'Bad magician!'
      return json
  
  def result_gen(scenes):
      necases = int(next(scenes))
      for code in range(1,necases+1):
          cellone = int(next(scenes)) - 1
          tabOne = [line_of_numbers(next(scenes)) for ie in range(4)]
          cell02 = int(next(scenes)) - 1
          scrolltwo = [line_of_numbers(next(scenes)) for ie in range(4)]
          json = process_case(cellone, tabOne, cell02, scrolltwo)
          yield 'Case #{0}: {1}
'.format(code, json)
      
  def line_of_numbers(string):
      return [int(job) for job in string.split()]
  
  def input_gen(fayout):
      for line in fayout:
          if line.endswith('
'):
              line = line[:-1]
          yield line
  
  def start(binemark):
      insfilename = binemark + '.in'
      againfolder = binemark + '.out'
      fayout = open(insfilename, 'r')
      f_out = open(againfolder, 'w')
      f_out.writelines(result_gen(input_gen(fayout)))
      fayout.close()
      f_out.close()
  
  start('A-small-attempt0')
",1
" 
  def war_points(N, naomi_pressed, ken_showsorted):
      ji=0
      naomixpoints = 0
      for ip in range(N):
          while ji < N and naomi_pressed[ip] > ken_showsorted[ji]:
              ji += 1
          if ji < N:
              ji += 1
          else:
              naomixpoints += 1
      return naomixpoints
      
  def deceitful_war_points(N, naomi_pressed, ken_showsorted):
      ji=0
      naomixpoints = 0
      for ip in range(N):
          while ji < N and ken_showsorted[ip] > naomi_pressed[ji]:
              ji += 1
          if ji < N:
              naomixpoints += 1
              ji += 1
      return naomixpoints
  
  def process_case(N, naomi_pressed, ken_showsorted):
       xone = deceitful_war_points(N, naomi_pressed, ken_showsorted)
      xptwo = war_points(N, naomi_pressed, ken_showsorted)
      return ( xone, xptwo)
  
  def result_gen(plugins):
      encatches = int(next(plugins))
      for alpha in range(1,encatches+1):
          N = int(next(plugins))
          naomi_pressed = line_of_floats_sorted(next(plugins))
          ken_showsorted = line_of_floats_sorted(next(plugins))
           xone, xptwo = process_case(N, naomi_pressed, ken_showsorted)
          yield 'Case #{0}: {1} {2}
'.format(alpha,  xone, xptwo)
      
  def line_of_floats_sorted(services):
      vsv = [float(text) for text in services.split()]
      vsv.sort()
      return vsv
  
  def input_gen(f_in):
      for line in f_in:
          if line.endswith('
'):
              line = line[:-1]
          yield line
  
  def start(baseeline):
      inputfolder = baseeline + '.in'
      outfilename = baseeline + '.out'
      f_in = open(inputfolder, 'r')
      f_ex = open(outfilename, 'w')
      f_ex.writelines(result_gen(input_gen(f_in)))
      f_in.close()
      f_ex.close()
  
  start('D-small-attempt0')
",1
" 
  BASE_RATE = 2.0
  
  def process_case(CV, FM, FX):
      rating = BASE_RATE
      total64rate = 0.0
      while True:        
          ctale = FX / rating
          CTtime = CV / rating
          extrrates = rating + FM
          extingtime = CTtime + (FX / extrrates)
          if ctale <= extingtime:
              total64rate += ctale
              break
          total64rate += CTtime
          rating = extrrates
      return total64rate
  
  def result_gen(plugins):
      nsasing = int(next(plugins))
      for char in range(1,nsasing+1):
          CV, FM, FX = line_of_floats(next(plugins))
          transform = process_case(CV, FM, FX)
          yield 'Case #{0}: {1:.7f}
'.format(char, transform)
  
  def line_of_floats(services):
      return [float(job) for job in services.split()]
  
  def input_gen(f2in):
      for line in f2in:
          if line.endswith('
'):
              line = line[:-1]
          yield line
  
  def start(baseeme):
      outfilename = baseeme + '.in'
      inputFile = baseeme + '.out'
      f2in = open(outfilename, 'r')
      f_out = open(inputFile, 'w')
      f_out.writelines(result_gen(input_gen(f2in)))
      f2in.close()
      f_out.close()
  
  start('B-small-attempt0')
",1
" 
  V1 = 'X'
  M02 = 'O'
   Player = 'T'
   EMPFIELD = '.'
  
  def no_empty_fields(clip):
      for bug in clip:
          for layer in bug:
              if layer== EMPFIELD:
                  return False
      return True
  
  def is_winning_series(clip, R0, r00, depth, dx, number):
      rg,center = R0,r00
      for ei in range(4):
          if clip[rg][center] != number and clip[rg][center] !=  Player:
              return False
          rg,center = rg+depth,center+dx
      return True
  
  def win_condition(clip, number):
      if is_winning_series(clip, 0,0, 1,1, number):
          return True
      if is_winning_series(clip, 0,3, 1,-1, number):
          return True
      for ei in range(4):
          if is_winning_series(clip, 0,ei, 1,0, number):
              return True
          if is_winning_series(clip, ei,0, 0,1, number):
              return True
      return False
  
  def process_case(clip):
      for number in {V1, M02}:
          if win_condition(clip, number):
              return '{0} won'.format(number)
      if no_empty_fields(clip):
          return 'Draw'
      return 'Game has not completed'
  
  def result_gen(plugins):
      nsasts = int(next(plugins))
      for ui in range(1,nsasts+1):
          clip = [[channel for channel in next(plugins)] for ei in range(4)]
          next(plugins)
          data = process_case(clip)
          yield 'Case #{0}: {1}
'.format(ui, data)
      
  def line_of_numbers(ips):
      return [int(job) for job in ips.split()]
  
  def input_gen(f_in):
      for line in f_in:
          if line.endswith('
'):
              line = line[:-1]
          yield line
  
  def start(baseername):
      insfilename = baseername + '.in'
      errfolder = baseername + '.out'
      f_in = open(insfilename, 'r')
      f_out = open(errfolder, 'w')
      f_out.writelines(result_gen(input_gen(f_in)))
      f_in.close()
      f_out.close()
  
  start('A-small-attempt0')
",1
" 
  def mines_refill(board, xr, xc, nfree):
      to_refill = xr*xc - nfree
      for r in reversed(range(2, xr)):
          for c in reversed(range(2, xc)):
              if not to_refill:
                  return
              assert(board[r][c] == '.')
              board[r][c] = '*'
              to_refill -= 1
      for r in reversed(range(xr)):
          for c in reversed(range(xc)):
              if not to_refill:
                  return
              if board[r][c] == '.':
                  board[r][c] = '*'
                  to_refill -= 1
      assert(to_refill == 0)
      
  def generate_board(nrows, NColes, nmines):
      nfree = nrows*NColes - nmines
      xr=1; xc=1;
      while True:
          if xr*xc >= nfree:
              break
          if xr < nrows:
              xr += 1
          if xr*xc >= nfree:
              break
          if xc < NColes:
              xc += 1
      board = [['*' for c in range(NColes)] for r in range(nrows)]
      for r in range(xr):
          for c in range(xc):
              board[r][c] = '.'
      mines_refill(board, xr, xc, nfree)
      board[0][0] = 'c'
      return board
          
  def find_click_point(board):
      nrows = len(board)
      NColes = len(board[0])
      for r in range(nrows):
          for c in range(NColes):
              if board[r][c] == 'c':
                  return (r,c)
      raise ValueError('Start point not present')
  
  def enum_neighbour_coords(r0, c0, nrows, NColes):
      for r in range(r0-1, r0+2):
          if r<0 or r>=nrows:
              continue
          for c in range(c0-1, c0+2):
              if c<0 or c>=NColes:
                  continue
              yield (r,c)
  
  def click_board(board, click_coords):
      nrows = len(board)
      NColes = len(board[0])
      points = [click_coords]
      while points:
          r0,c0 = points.pop()
          mines_cnt = 0
          for r,c in enum_neighbour_coords(r0, c0, nrows, NColes):
              if board[r][c] == '*':
                  mines_cnt += 1
          board[r0][c0] = str(mines_cnt)
          if not mines_cnt:
              for r,c in enum_neighbour_coords(r0, c0, nrows, NColes):
                  if board[r][c] == '.':
                      points.append((r,c))
  
  def all_fields_checked(board):
      nrows = len(board)
      NColes = len(board[0])
      for r in range(nrows):
          for c in range(NColes):
              if board[r][c] == '.':
                  return False
      return True
  
  def is_board_oneclick(original_board):
      board = [row[:] for row in original_board] # deep copy
      assert(board[0][0] == 'c')
      r,c = find_click_point(board)
      click_board(board, (r,c))
      is_oneclick = all_fields_checked(board)
      return is_oneclick
  
  def board2result(board):
      return [''.join(row) for row in board]
  
  def process_case(nrows, NColes, nmines):
      board = generate_board(nrows, NColes, nmines)
      if is_board_oneclick(board):
          result = board2result(board)
      else:
          result = ['Impossible']
      return result
  
  def result_gen(lines):
      ncases = int(next(lines))
      for ci in range(1,ncases+1):
          R, C, M = line_of_numbers(next(lines))
          result = process_case(R, C, M)
          yield 'Case #{0}:
'.format(ci, result)
          for res_line in result:
              yield res_line + '
'
      
  def line_of_numbers(s):
      return [int(sub) for sub in s.split()]
  
  def input_gen(f_in):
      for line in f_in:
          if line.endswith('
'):
              line = line[:-1]
          yield line
  
  def start(basename):
      infile = basename + '.in'
      outfile = basename + '.out'
      f_in = open(infile, 'r')
      f_out = open(outfile, 'w')
      f_out.writelines(result_gen(input_gen(f_in)))
      f_in.close()
      f_out.close()
  
  start('C-small-attempt0')
",1
" 
  tources = [('a zoo',
              'y qee'),
             ('our language is impossible to understand',
              'ejp mysljylc kd kxveddknmc re jsicpdrysi'),
             ('there are twenty six factorial possibilities',
              'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd'),
             ('so it is okay if you want to just give up',
              'de kr kd eoya kw aej tysr re ujdr lkgc jv')]
             
  def process_case(string, data):
      return ''.join(data[text] for text in string)
  
  def prepare_translation():
      data = {}
      for eg_reggs in tources:
          for speechares,rgCHAR in zip(*eg_reggs):
              data[rgCHAR] = speechares
      miss2g = set(string.ascii_lowercase) - set(data.keys())
      miss_eu = set(string.ascii_lowercase) - set(data.values())
      if (len(miss2g) == 1 and len(miss_eu) == 1):
          data[miss2g.left()] = miss_eu.left();
      return data
  
  def result_gen(jobs):
      data = prepare_translation()
      nsaps = int(next(jobs))
      for char in range(1,nsaps+1):
          ner = process_case(next(jobs), data)
          yield 'Case #{0}: {1}
'.format(char, ner)
      
  def line_of_numbers(services):
      return [int(small) for small in services.split()]
  
  def input_gen(f7out):
      for string in f7out:
          if string.endswith('
'):
              string = string[:-1]
          yield string
  
  def start(bineme):
      inputfilename = bineme + '.in'
       outfolder = bineme + '.out'
      f7out = open(inputfilename, 'r')
      f24name = open( outfolder, 'w')
      f24name.writelines(result_gen(input_gen(f7out)))
      f7out.close()
      f24name.close()
  
  start('A-small-attempt0')
;samples = 0",1
" 
  '''
  Limits
  
  1 <= T <= 100.
  
  Small dataset   1 <= N, M <= 10. 1 <= a[i,j] <= 2.
  Large dataset   1 <= N, M <= 100. 1 <= a[i,j] <= 100.
  
  Sample
  
  *** Input 
  3
  3 3
  2 1 2
  1 1 1
  2 1 2
  5 5
  2 2 2 2 2
  2 1 1 1 2
  2 1 2 1 2
  2 1 1 1 2
  2 2 2 2 2
  1 3
  1 2 1
  
  *** Output 
  Case #1: YES
  Case #2: NO
  Case #3: YES
  
  '''
  
  
  
  std = open(sys.argv[1])
  def input(): return std.readline().strip()
  
  
  def check_lawn(shape):
      non = len(shape)
      g = len(shape[0])
      mindex = map(max, shape)
      Vax = map(max, zip(*shape))
      for I in range(non):
          for note in range(g):
              if shape[I][note] < min(mindex[I], Vax[note]):
                  return 'NO'
      return 'YES'
  
  for changeNum in range(1, int(input())+1):
      non,g = map(int, input().split())
      shape = [map(int, input().split()) for __ in range(non)]
      print 'Case #%d:' % changeNum, check_lawn(shape)
  
",2
" 
  '''
  Limits: 1 <= T <= 50. A and B have the same number of digits.
  Small dataset: 1 <= A <= B <= 1000.
  Large dataset: 1 <= A <= B <= 2000000
  
  Input 
  4
  1 9
  10 40
  100 500
  1111 2222
   	
  Output 
  Case #1: 0
  Case #2: 3
  Case #3: 156
  Case #4: 287
  
  '''
  
  psyco.full()
  
  
  fen = open(sys.argv[1])
  def input(): return fen.readline().strip()
  
  def numRecycled(Args,Other):
      f = len(str(Args))
      cop = 10**(f-1)
      cnt = 0
      for br in range(Args,Other+1):
          works = set()
          j = br
          for length in range(f-1):
              asa,s = divmod(j, 10)
              j = cop*s + asa
              if br < j <= Other:
                  works.add(j)
          cnt += len(works)
      return cnt
  
  for testNum in range(1, int(input())+1):
      print 'Case #%d:' % testNum,
      Args,Other = map(int, input().split())
      print numRecycled(Args,Other)
  
",2
" 
  '''
  ---Input 
  3
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  3
  1 2 5 4
  3 11 6 15
  9 10 7 12
  13 14 8 16
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  3
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  
  ---Output 
  Case #1: 7
  Case #2: Bad magician!
  Case #3: Volunteer cheated!
  '''
  
  
  
  
  
  files = open(sys.argv[1])
  def input(): return files.readline().strip();
  
         
  
  
  for  caseno in xrange(1, int(input())+1):
      row64number = int(input())
      for info in 1,2,3,4:
          row = input()
          if info == row64number:
              nanums = set(row.split())
              
      row64number = int(input())
      for info in 1,2,3,4:
          row = input()
          if info == row64number:
              nanums &= set(row.split())
  
      if not nanums:
          res = 'Volunteer cheated!'
      elif len(nanums) > 1:
          res = 'Bad magician!'        
      else:
          res = nanums.pop()
      print 'Case #%d:' %  caseno, res
      
  
",2
" 
  '''
  Input
  The first line of the input gives the number of test cases, T. T test cases follow. 
  Each test case starts with a line containing a single integer N, the number of blocks 
  each player has. Next follows a line containing N space-separated real numbers: 
  the masses of Naomi's blocks, in kg. Finally there will be a line containing N 
  space-separated real numbers: the masses of Ken's blocks, in kg.
  
  Output
  For each test case, output one line containing ""Case #x: y z"", where 
  x is the test case number (starting from 1), 
  y is the number of points Naomi will score if she plays Deceitful War optimally, and 
  z is the number of points Naomi will score if she plays War optimally.
  
  Limits
  1 <= T <= 50.
  All the masses given to Ken and Naomi are distinct, and between 0.0 and 1.0 exclusive.
  
  Small dataset
  1 <= N <= 10.
  
  Large dataset
  1 <= N <= 1000.
  
  ---Input 
  4
  1
  0.5
  0.6
  2
  0.7 0.2
  0.8 0.3
  3
  0.5 0.1 0.9
  0.6 0.4 0.3
  9
  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899
  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458
  
  ---Output 
  Case #1: 0 0
  Case #2: 1 0
  Case #3: 2 1
  Case #4: 8 4
  
  
  '''
  
  
  f = open(sys.argv[1])
  def input(): return f.readline().strip();
  
  
  
  def deceitfulWar(Waqi, Ni):
      Waqi = Waqi[:]
      Ni = Ni[:]
      pts = 0
      while Waqi and Ni and Waqi[-1] > Ni[0]:
          kn = Ni.pop(0)
          for i in range(len(Waqi)):
              if Waqi[i] > kn:
                  Waqi.pop(i)
                  break
          pts += 1        
  
      return pts
  
  def war(Waqi, Ni):
      Waqi = Waqi[:]
      Ni = Ni[:]
      pts = 0
      while Waqi and Ni:
          nm = Waqi.pop(0)
          if nm > Ni[-1]:
              Ni.pop(0)
              pts += 1
          else:
              for i in range(len(Ni)):
                  if Ni[i] > nm:
                      Ni.pop(i)
                      break          
      return pts
  
  
  for caseNo in xrange(1, int(input())+1):
      _ = input()
      Waqi = sorted(map(float, input().split()))
      Ni = sorted(map(float, input().split()))
      print 'Case #%d:' % caseNo, deceitfulWar(Waqi, Ni), war(Waqi, Ni)
      
  
  
",2
" 
  '''
  Input
  The first line of the input gives the number of test cases, T. T lines follow. 
  Each line contains three space-separated real-valued numbers: C, F and X.
  
  Output
  For each test case, output one line containing ""Case #x: y"", where x is 
  the test case number (starting from 1) and y is the minimum number of seconds 
  it takes before you can have X delicious cookies.
  
  We recommend outputting y to 7 decimal places, but it is not required. 
  y will be considered correct if it is close enough to the correct number: 
  within an absolute or relative error of 10^-6. 
  
  Limits
  1 <= T <= 100.
  
  Small dataset
  1 <= C <= 500.
  1 <= F <= 4.
  1 <= X <= 2000.
  
  Large dataset
  1 <= C <= 10000.
  1 <= F <= 100.
  1 <= X <= 100000.
  
  
  ---Input  
  4
  30.0 1.0 2.0
  30.0 2.0 100.0
  30.50000 3.14159 1999.19990
  500.0 4.0 2000.0
  
  ---Output 
  Case #1: 1.0000000
  Case #2: 39.1666667
  Case #3: 63.9680013
  Case #4: 526.1904762
  
  '''
  
  
  
  
  
  file = open(sys.argv[1])
  def input(): return file.readline().strip();
  
  def bestTime(CS, File, HTTP):
      cv = 2   #speed of production, cookies/sec
      t = 0   #total time of production, sec
      while True:
          tX = HTTP / cv          #time to reach goal at current speed
          tC = CS / cv          #time to buy farm
          TFc = HTTP / (cv + File)   #time to reach goal after adding farm
          if tX <= tC + TFc:
              break
          t += tC
          cv += File
      t += tX
      return t
  
  
  for  caseno in xrange(1, int(input())+1):
      CS, File, HTTP = map(float, input().split())
      print 'Case #%d: %.7f' % ( caseno, bestTime(CS, File, HTTP))
      
  
  
",2
" 
  '''
  Limits
  The game board provided will represent a valid state that was reached
  through play of the game Tic-Tac-Toe-Tomek as described above.
  
  Small dataset   1 = T = 10.
  Large dataset   1 = T = 1000.
  
  *** Sample Input 
  6
  XXXT
  ....
  OO..
  ....
  
  XOXT
  XXOO
  OXOX
  XXOO
  
  XOX.
  OX..
  ....
  ....
  
  OOXX
  OXXX
  OX.T
  O..O
  
  XXXO
  ..O.
  .O..
  T...
  
  OXXX
  XO..
  ..O.
  ...O
  
  ***Output 
  Case #1: X won
  Case #2: Draw
  Case #3: Game has not completed
  Case #4: O won
  Case #5: O won
  Case #6: O won
  
  '''
  
  
  
  fits = open(sys.argv[1])
  def input(): return fits.readline().strip()
  
  
  x_aternt = re.compile('X{4}|X(.{4}X){3}|X(.{3}X){3}|X(.{5}X){3}')
  o_rdns = re.compile('O{4}|O(.{4}O){3}|O(.{3}O){3}|O(.{5}O){3}')
  
  
  def check_game_status(event):
      if x_aternt.search(event.replace('T','X')):
          return 'X won'
      elif o_rdns.search(event.replace('T','O')):
          return 'O won'
      elif '.' not in event:
          return 'Draw'
      else:
          return 'Game has not completed'
  
  for case_ in range(1, int(input())+1):
      event = '|'.join(input() for __ in range(4))
      input() # skip empty line
      print 'Case #%d:' % case_, check_game_status(event)
  
",2
" 
  '''
  Input
  The first line of the input gives the number of test cases, T. T lines follow. 
  Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).
  
  Output
  For each test case, output a line containing ""Case #x:"", where x is the test case number. 
  On the following R lines, output the board configuration with C characters per line, 
  using '.' to represent an empty cell, '*' to represent a cell that contains a mine, 
  and 'c' to represent the clicked cell. If there is no possible configuration, 
  then instead of the grid, output a line with ""Impossible"" instead. 
  If there are multiple possible configurations, output any one of them.
  
  Limits
  0 <= M < R * C.
  
  Small dataset
  1 <= T <= 230.
  1 <= R, C <= 5.
  
  Large dataset
  1 <= T <= 140.
  1 <= R, C <= 50.
  
  Sample
  ---Input 
  5
  5 5 23
  3 1 1
  2 2 1
  4 7 3
  10 10 82
  
  ---Output 
  Case #1:
  Impossible
  Case #2:
  c
  .
  *
  Case #3:
  Impossible
  Case #4:
  ......*
  .c....*
  .......
  ..*....
  Case #5:
  **********
  **********
  **********
  ****....**
  ***.....**
  ***.c...**
  ***....***
  **********
  **********
  **********
  
  
  '''
  
  
  f = open(sys.argv[1])
  def input(): return f.readline().strip();
  
  def genBoards(R, C, M):
      for mines in combinations( product(range(R), range(C)), M):
          board = [ ['.'] * C + [''] for ct in range(R) ]
          for row, col in mines:
              board[row][col] = '*'
          yield board + [[''] * (C+1)]
      pass
  
  def oneClickSolution(R, C, M):
      for bd in genBoards(R, C, M):
          minTile = 10
          for r in range(R):
              for c in range(C):
                  if bd[r][c] == '.':
                      nc = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))
                      bd[r][c] = `n`
                      if nc <= minTile:
                          minTile = nc
                          minR, minC = r, c
          if minTile < 10:
              queue = [ (minR, minC) ]
              nOpen = 0
              while queue:
                  r,c = queue.pop()
                  if bd[r][c] == '0':
                      for i in -1,0,1:
                          for j in -1,0,1:
                              if i or j: # we don't add the one we popped back
                                  queue.append( (r+i, c+j) )
                  if bd[r][c] not in '.*':
                      bd[r][c] = '.'
                      nOpen += 1
              if M + nOpen == R*C:
                  bd[minR][minC] = 'c'
                  return '
'.join( ''.join(row[:-1]) for row in bd[:-1] )
  
      return 'Impossible'
  
  
  clk = clock()
  
  for caseNo in xrange(1, int(input())+1):
      R, C, M = map(int, input().split())
      print >>sys.stderr, caseNo, R, C, M #, oneClickSolution(R, C, M)<>'Impossible'
      print 'Case #%d:' % caseNo  
      print oneClickSolution(R, C, M)
      
  print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )
  
",2
" 
  '''
  Limits: 1 = T = 30. G contains at most 100 characters.
  None of the text is guaranteed to be valid English.
  Sample
  
  Input
  3
  ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv
  
  Output
  Case #1: our language is impossible to understand
  Case #2: there are twenty six factorial possibilities
  Case #3: so it is okay if you want to just give up
  '''
  
  
  
  ins = open(sys.argv[1])
  def input(): return ins.readline().strip()
  
  knownpats = [
      ('zq', 'qz'),
      ('ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand'),
      ('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities'),
      ('de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up')
  ]
  
  exdat = [chr(0) for ip in range(256)]
  for proof, details in knownpats:
      for ada,binary in zip(proof, details):
          exdat[ord(ada)] = binary
  for api in range(26):
      exdat[ord('A')+api] = chr(ord(exdat[ord('a')+api]) - ord('a') + ord('A'))
  exdat = ''.join(exdat)
  
  for  caseno in range(1, int(input())+1):
      print 'Case #%d:' %  caseno, input().translate(exdat)
  
  
",2
"T = int(raw_input())
  
  def readMatrix(nlines):
      return [map(int, raw_input().split(' ')) for i in xrange(nlines)]
  
  def transpose(API):
      return map(lambda i: map(lambda line: line[i], API), xrange(len(API[0])))
  
  for ie in xrange(T):
      MM, N = map(int, raw_input().split(' '))
      API = readMatrix(MM)
      lb = map(max, API)
      c = map(max, transpose(API))
      flo = True
      for i in xrange(MM):
          for j in xrange(N):
              if API[i][j] != min(lb[i], c[j]):
                  flo = False
      print ""Case #%d: %s"" % (ie+1, ""YES"" if flo else ""NO"")
",3
"f = int(raw_input())
  
  def isRecycle(x, sy, data):
      t = 10**(data-1)
      for ix in xrange(ddigsions):
          sy = t*(sy%10) + sy/10
          if x == sy:
              return True
      return False
  
  for z in xrange(1, f+1):
      res = 0
      API, QB = map(int, raw_input().split())
      ddigsions = len(str(API))
      for ix in xrange(API, QB):
          for dj in xrange(ix+1, QB+1):
             if isRecycle(ix, dj, ddigsions):
                 res += 1
      print ""Case #%d:"" % z, res
",3
"T = int(raw_input())
  
  def readSq(nu):
      urs = []
      for ix in xrange(nu):
          urs.append(set(map(int, raw_input().split())))
      return urs
  
  def solve():
      an3 = int(raw_input())
      S2 = readSq(4)
      an5 = int(raw_input())
      ans5 = readSq(4)
      ans = S2[an3-1] & ans5[an5-1]
      if len(ans) == 0:
          return ""Volunteer cheated!""
      if len(ans) > 1:
          return ""Bad magician!""
      return str(list(ans)[0])
  
  for z in xrange(T):
      print ""Case #%d: %s"" % (z+1, solve())
",3
"MT = int(raw_input())
  
  def solve(a, b):
      n = len(a)
      a.sort()
      b.sort()
      i = j = int = mu = 0
      while i < n:
          if a[i] > b[j]:
              mu += 1
              i += 1
              j += 1
          else:
              i += 1
      i = j = 0
      while j < n:
          if b[j] > a[i]:
              int += 1
              i += 1
              j += 1
          else:
              j += 1
      return str(mu) + "" "" + str(n-int)
  
  for zn in xrange(MT):
      n = int(raw_input())
      a = map(float, raw_input().split())
      b = map(float, raw_input().split())
      print ""Case #%d: %s"" % (zn+1, solve(a, b))
",3
"T = int(raw_input())
  
  def solve(WC, DF, X):
      h = data/2
      buildTime, unit = 0, 2
      while True:
          buildTime += WC/unit
          if buildTime > h:
              break
          unit += DF
          h = min(h, buildTime + X/unit)
      return h
  
  for z in xrange(T):
      c, f, data = map(float, raw_input().split())
      print ""Case #%d: %.7f"" % (z+1, solve(c, f, data))
",3
"n = int(raw_input())
  
  dd = {'X':2, 'O': 0, 'T':1, '.':-10}
  
  def readGame():
      return [map(lambda c:dd[c], raw_input().strip()) for i in xrange(4)]
  
  def check(game):
      features = []
      for i in xrange(4): # horizontal
          features.append(sum(game[i]))
      for i in xrange(4): # vertical
          features.append(sum(map(lambda li: li[i], game)))
      dy2 = d2 = 0 # diagonal
      for i in xrange(4):
          dy2 += game[i][i]
          d2 += game[i][3-i]
      features.append(dy2)
      features.append(d2)
      if max(features) >= 7:
          return ""X won"";
      rh200 = filter(lambda n: n >= 0, features)
      if len(rh200) > 0 and min(rh200) <= 1:
          return ""O won""
      if min(features) < 0:
          return ""Game has not completed""
      return ""Draw""
  
  for i in xrange(n):
      game = readGame()
      if i + 1 < n:
          raw_input()
  
      print ""Case #%d: %s"" % (i+1, check(game))
",3
" 
  T = int(raw_input())
  
  def generate(R, C, all, nc):
      if nc:
          R, C = C, R
      data = [['*']*C for ni in xrange(R)]
      for ni in xrange(len(all)):
          for ij in xrange(all[ni]):
              if nc:
                  data[ij][ni] = '.'
              else:
                  data[ni][ij] = '.'
      data[0][0] = 'c'
      return str(data)[2:-2].replace(' ', '').replace(""'"",'').replace('[', '').replace('],','
').replace(',', '')
  
  
  def solveEq(k, s, x1):
      if 2*(x1 + k - 2) > s or k*x1 < s:
          return None
      r = [0]*k
      r[0] = r[1] = x1
      s -= 2*x1
      for ni in xrange(k-2, 0, -1):
          test = min(x1, s - 2*ni + 2)
          r[k-ni] = test
          s -= test
      return r
  
  def solve(R, C, MD):
      NM = R*C
      nm = NM - MD
      if R == 1 or C == 1:
          if R == 1:
              return '*'*MD + '.'*(NM-MD-1) + 'c'
          else:
              return '*
'*M + '.
'*(S-M-1) + 'c'
      else:
          nc = False
          if R > C:
              R, C = C, R
              nc = True
          if nm == 2 or nm == 3 or nm == 5 or nm == 7 or (R == 2 and nm%2 == 1 and nm > 1):
              return ""Impossible""
          if nm == 1:
              return generate(R, C, [1], nc)
          for k in xrange(2, R+1):
              for x1 in xrange(2, C+1):
                  r = solveEq(k, nm, x1)
                  if r != None:
                      return generate(R, C, r, nc)
          return ""Something wrong""
  
  for z in xrange(T):
      c, f, x = map(int, raw_input().split())
      print ""Case #%d:
%s"" % (z+1, solve(c, f, x))
",3
"axpps = [""ejp mysljylc kd kxveddknmc re jsicpdrysi"", ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"", ""de kr kd eoya kw aej tysr re ujdr lkgc jv""]
  verts = [""our language is impossible to understand"",""there are twenty six factorial possibilities"", ""so it is okay if you want to just give up""]
  
  d = {'z':'q', 'q':'z'}
  
  for i in xrange(3):
      outq, option = axpps[i], verts[i]
      for index in xrange(len(outq)):
          d[outq[index]] = option[index]
  
  en = int(raw_input())
  for i in xrange(en):
      c = raw_input()
      print ""Case #%d:"" % (i+1), """".join(map(lambda c: d[c], c))
",3
" 
  
  folder = open(sys.argv[1],'r')
  
  num = int(folder.readline())
  
  for uri in range(num):
      l = folder.readline()
      no,m = l.split()
      no = int(no)
      m = int(m)
      lawn = []
      result = []
      for code in range(no):
          l = folder.readline()
          lawn.append([int(test) for test in l.split()])
          result.append([False]*m)
      l = []
      for code in range(no):
          for k in range(m):
              l.append((lawn[code][k], (code,k)))
      l.sort(key=operator.itemgetter(0))
      ok = True
      for test in l:
          if result[test[1][0]][test[1][1]]:
              continue
          row = True
          for code in range(no):
              if not (result[code][test[1][1]] or lawn[code][test[1][1]] <= lawn[test[1][0]][test[1][1]]):
                  row = False
                  break
          if(row):
              for code in range(no):
                  result[code][test[1][1]] = True
              continue
          col = True
          for code in range(m):
              if not (result[test[1][0]][code] or lawn[test[1][0]][code] <= lawn[test[1][0]][test[1][1]]):
                  col = False
                  break
          if(col):
              for code in range(m):
                  result[test[1][0]][code] = True
              continue
          ok = False
          break
      if ok:
          print 'Case #{}: YES'.format(uri+1)
      else:
          print 'Case #{}: NO'.format(uri+1)
",4
" 
  
  def permute(x, data):
      perm = []
      for init in range(1,data):
          number = x / 10**init
          radius = x % 10**init
          if radius >= 10**(init-1):
              perm.append(radius * 10**(data-init) + number)
      perm = list(set(perm))
      while x in perm:
          perm.remove(x)
      return perm
  
  form = open(sys.argv[1],'r')
  
  con = int(form.readline())
  
  for init in range(con):
      n1, ctwo = [int(x) for x in form.readline().split()]
      data = int(math.floor(math.log10(n1))) + 1
      rec = 0
      for rup in range(n1,ctwo+1):
          p = permute(rup, data)
          rec += sum([1 for x in p if x >= n1 and x <= ctwo])
      print 'Case #{}:'.format(init+1), rec/2
",4
" 
  
  files = open(sys.argv[1],'r')
  
  num = int(files.readline())
  
  for init in range(num):
      q1 = int(files.readline())
      for j in range(4):
          if j+1 == q1:
              line1 = files.readline()
          else:
              files.readline()
      q2 = int(files.readline())
      for j in range(4):
          if j+1 == q2:
              line2 = files.readline()
          else:
              files.readline()
      line1 = [int(test) for test in line1.split()]
      line2 = [int(test) for test in line2.split()]
      count = 0
      for test in line1:
          if test in line2:
              count += 1
              y = test
      if count == 0:
          print 'Case #{}: Volunteer cheated!'.format(init+1)
      elif count == 1:
          print 'Case #{}: {}'.format(init+1, y)
      else:
          print 'Case #{}: Bad magician!'.format(init+1)
",4
" 
  
  iter = open(sys.argv[1],'r')
  
  num = int(iter.readline())
  
  for i in range(num):
      iter.readline()
      python = [float(test) for test in iter.readline().split()]
      ke = [float(test) for test in iter.readline().split()]
      python.sort()
      ke.sort()
      dw = 0
      input = 0
      for test in ke:
          while input < len(python) and python[input] <= test:
              input += 1
          if input == len(python):
              break
          dw += 1
          input += 1
      w = 0
      input = 0
      python.reverse()
      ke.reverse()
      for test in python:
          if ke[input] > test:
              input += 1
          else:
              w += 1
      print 'Case #{}: {} {}'.format(i+1, dw, w)
",4
" 
  
  form = open(sys.argv[1],'r')
  
  num = int(form.readline())
  
  for i in range(num):
      c, e, xt = [float(xt) for xt in form.readline().split()]
      n = int((xt*e-2*c)/(c*e))
      if n < 0:
          n = 0
      t = 0
      for j in range(n):
          t += c/(2+j*e)
      t += xt/(2+n*e)
      print 'Case #{}: {}'.format(i+1, t)
",4
" 
  
  files = open(sys.argv[1],'r')
  
  num = int(files.readline())
  
  def check(x, test):
      for api in range(4):
          row = True
          col = True
          for json in range(4):
              if not (test[api][json] == x or test[api][json] == 'T'):
                  row = False
              if not (test[json][api] == x or test[json][api] == 'T'):
                  col = False
          if row or col:
              return True
      diag1 = True
      diag2 = True
      for api in range(4):
          if not (test[api][api] == x or test[api][api] == 'T'):
              diag1 = False
          if not (test[3-api][api] == x or test[3-api][api] == 'T'):
              diag2 = False
      if diag1 or diag2:
          return True
      return False
  
  def fin(test):
      for api in range(4):
          for json in range(4):
              if test[api][json] == '.':
                  return False
      return True
  
  for api in range(num):
      test = []
      for json in range(4):
          test.append(list(files.readline().strip()))
      files.readline()
      if check('X', test):
          print 'Case #{}: X won'.format(api+1)
      elif check('O', test):
          print 'Case #{}: O won'.format(api+1)
      elif fin(test):
          print 'Case #{}: Draw'.format(api+1)
      else:
          print 'Case #{}: Game has not completed'.format(api+1)
",4
" 
  
  f = open(sys.argv[1],'r')
  
  num = int(f.readline())
  
  def count(data, r, conf):
      return len(z_and_nei(data,r,conf))
  
  def nei(data, r, conf):
      s = z_and_nei(data, r, conf)
      s -= set(data)
      return s
  
  def z_and_nei(data, r, conf):
      s = set()
      for x in data:
          s.add(x)
          s.add((x[0]-1,x[1]-1))
          s.add((x[0]-1,x[1]))
          s.add((x[0]-1,x[1]+1))
          s.add((x[0],x[1]-1))
          s.add((x[0],x[1]+1))
          s.add((x[0]+1,x[1]-1))
          s.add((x[0]+1,x[1]))
          s.add((x[0]+1,x[1]+1))
      o = set()
      for x in s:
          if x[0] < 0 or x[0] > r-1 or x[1] < 0 or x[1] > conf-1:
              o.add(x)
      s-=o
      return s
  
  def find_config(data, r, conf, t):
      if count(data,r,conf) == t:
          return data
      if count(data,r,conf) > t:
          return []
      n = nei(data,r,conf)
      for x in n:
          data.append(x)
          if find_config(data,r,conf,t) != []:
              return data
          data.pop()
      return []
  
  for i in range(num):
      print 'Case #{}:'.format(i+1)
      r, conf, m = [int(x) for x in f.readline().split()]
      if r*conf-m == 1:
          print 'c' + '*'*(conf-1)
          for i in range(r-1):
              print '*'*conf
      else:
          data = find_config([(0,0)], conf, r, conf*r-m)
          if data == []:
              print ""Impossible""
          else:
              s = z_and_nei(data, conf, r)
              for j in range(r):
                  for k in range(conf):
                      if j == 0 and k == 0:
                          print 'c',
                      elif (k,j) in s:
                          print '.',
                      else:
                          print '*',
                  print
  
  
",4
" 
  
  ref = open(sys.argv[1],'r')
  
  form = int(ref.readline())
  
  for key in range(form):
      s = ref.readline().strip()
      data = s.translate(string.maketrans(""yeqjpmslckdxvnribtahwfougz"",
          ""aozurlngeismpbtdhwyxfckjvq""))
      print 'Case #{}:'.format(key+1), data
",4
" 
  def ss(t, amap, bmap):
      s = 0
      for m in amap:
          if len(m) == 1 and t == m.keys()[0]:
              s += m[t]
              for b in bmap:
                  if t in b:
                      b[t] -= 1
                      if b[t] == 0:
                          b.pop(t)
              m.clear()
      return s           
  
  
  def solve(case, in_lines):
      cfg = 'Case #%d: '%case
   
      rn, cn = [int(x) for x in in_lines[0].split()]
      mtx = []
      for i in xrange(rn):
          mtx.append([int(x) for x in in_lines[i+1].split()])
      rmap = [{} for x in xrange(rn)]
      cmap = [{} for x in xrange(cn)]
      td = {}
      
      for i in xrange(rn):
          for j in range(cn):
              k = mtx[i][j]
              if k in rmap[i]:
                  rmap[i][k] += 1
              else:
                  rmap[i][k] = 1
              if k in cmap[j]:
                  cmap[j][k] += 1
              else:
                  cmap[j][k] = 1
              if k in td:
                  td[k] += 1
              else:
                  td[k] = 1
                  
      while len(td):
          k = min(td.keys())
          sb = ss(k, rmap, cmap)
          sb += ss(k, cmap, rmap)
          if sb == 0:
              break;
          td[k] -= sb
          if td[k] == 0:
              td.pop(k)
  
      return cfg + ('YES' if sb else 'NO')
  
  
  def main(normal):
      locks = normal.split('
')
      n = int(locks[0])
      ln = 1
      outs = []
      for case in xrange(1, n+1):
          buff = []
          cl = int(locks[ln].split()[0]) + ln + 1
          while ln < cl and locks[ln]:
              buff.append(locks[ln])
              ln += 1
          s = solve(case, buff)
          print s
          outs.append(s)
      return '
'.join(outs)
      pass
  
  if __name__ == '__main__':
      test_input = """"""4
  4 3
  2 5 2
  1 1 1
  2 4 2
  2 3 2
  3 3
  2 1 2
  1 1 1
  2 1 2
  5 5
  2 2 2 2 2
  2 1 1 1 2
  2 1 2 1 2
  2 1 1 1 2
  2 2 2 2 2
  1 3
  1 2 1""""""
      force_no_file = False
      in_file_name = '' if force_no_file else 'B-small-attempt0.in'
      base_path = 'G:/workspace/py/codejam2013/RQ/'
      if in_file_name:
          with open(base_path + in_file_name) as f:
              normal = f.read()
      else:
          normal = test_input
      cfg = main(normal)
      if in_file_name:
          with open(base_path + in_file_name + '.out', 'w') as f:
              f.write(cfg)
      pass
",5
" 
  def solve(iccasing, case_input):
      Case_file = 'Case #%i: '%iccasing
      
      results = 0
      transform = case_input[0].split()
      e = len(transform[0])
      asa = int(transform[0])
      r = int(transform[1])
      
      for pi in xrange(asa, r):
          rslt = set()
          for temp in xrange(1, e):
              att = 10**temp
              tf = 10**(e-temp)
              inf, IB = divmod(pi, att)
              img = IB*tf + inf
              if img > pi and img <= r:
                  rslt.add(img)
          results += len(rslt)
          
  
      Case_file += '%d'%results
      
      return Case_file
  
  
  def main():
      global use_test_data
      global test_data
      global Input_data
      global outputlogdata
      
      if use_test_data:
          values = [event.strip() for event in test_data.split('
')]
      else:
          values = [event.strip() for event in Input_data.readlines()]
      
      H = int(values[0])
      piLin = 1
      caselineNUM = 1
      for iccasing in range(1, H + 1):
          child = []
          for pi in range(caselineNUM):
              child.append(values[piLin])
              piLin += 1
          rslt = solve(iccasing, child)
          print rslt
          if not use_test_data:
              print >> outputlogdata, rslt
      
      if not use_test_data:
          Input_data.close()
          outputlogdata.close()
      
      
  if __name__ == '__main__':
      test_data = """"""5
  1 9
  10 40
  100 500
  1111 2222
  1000000 2000000
  """"""
      use_test_data = False
      
      testEoutput = 'C-small-attempt0.in'
      if not use_test_data and '' != testEoutput:
          Input_data = open(testEoutput)
          outputlogdata = open(testEoutput + '.out', 'w')
      
      main()
",5
" 
  class Solver(object):
      def __init__(self):
          pass
      
      def solve(self, inclines):
          r1 = int(inclines[0])
          cs1 = set([int(_) for _ in inclines[r1].split()])
          r2 = int(inclines[5])
          cs2 = set([int(_) for _ in inclines[5+r2].split()])
          r = cs1.intersection(cs2)
          cnt = len(r)
          if 1 == cnt:
              return max(r)
          elif 0 == cnt:
              return 'Volunteer cheated!'
          else:
              return 'Bad magician!'
          pass
      
      def feed(self, inclines):
          lines = [_.strip() for _ in inclines]
          outputs = []
          test_case_n = int(lines[0])
          cur = 1
          for i in range(test_case_n):
              i = i
              case_line_cnt = 10
              case_inputs = lines[cur:cur+case_line_cnt]
              cur += case_line_cnt
              outputs.append(self.solve(case_inputs))
          return outputs
  
  if __name__ == '__main__':
      iname = 'A-small-attempt0.in'
      sample_in = '''
      3
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  3
  1 2 5 4
  3 11 6 15
  9 10 7 12
  13 14 8 16
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  3
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
      '''
      sample_out = '''
   Case #1: 7
  Case #2: Bad magician!
  Case #3: Volunteer cheated!
      '''
      if os.path.exists(iname):
          with open(iname) as f:
              inclines = f.readlines()
      else:
          inclines = [_.strip() for _ in sample_in.split('
') if _.strip()]
      solver = Solver()
      outputs = solver.feed(inclines)
      fail_flag = False
      if os.path.exists(iname):
          with open(iname+'.out', 'w') as f:
              for i, v in enumerate(outputs):
                  print >> f, 'Case #%d: %s'%(i+1, str(v))
      else:
          ans = set([_.strip() for _ in sample_out.split('
') if _.strip()])
          for i, v in enumerate(outputs):
              t = 'Case #%d: %s'%(i+1, str(v))
              if t not in ans:
                  print '!!! Wrong:', t
                  fail_flag = True
      print '===================================================='
      for i, v in enumerate(outputs):
          print 'Case #%d: %s'%(i+1, str(v))
      print '===================================================='
      print 'done' if not fail_flag else 'fail'
      pass
",5
" 
  class Solver(object):
      def __init__(self):
          pass
      
      def solve(self, inputs):
          mmm = [float(x) for x in inputs[1].split()]
          mmm.sort()
          ijk = [float(x) for x in inputs[2].split()]
          ijk.sort()
          dw = self.dwar(mmm[:], ijk[:])
          w = self.war(mmm[:], ijk[:])
          return '%d %d'%(dw, w)
          pass
      
      def dwar(self, mmm, ijk):
          draw = len(mmm)
          cnot = 0
          for i in range(draw):
              i = i
              if mmm[-1] < ijk[-1]:
                  mmm.pop(0)
                  ijk.pop(-1)
              elif mmm[0] < ijk[0]:
                  mmm.pop(0)
                  ijk.pop(-1)
              else:
                  cnot += 1
                  mmm.pop(0)
                  ijk.pop(0)
          return cnot
      
      def war(self, mmm, ijk):
          draw = len(mmm)
          cnot = 0
          for i in range(draw):
              i = i
              all = bisect.bisect_left(ijk, mmm[0])
              if all == len(ijk):
                  cnot += 1
                  ijk.pop(0)
              else:
                  ijk.pop(all)
              mmm.pop(0)
          return cnot
      
      def feed(self, inputs):
          faces = [x.strip() for x in inputs]
          outputs = []
          test_case1d = int(faces[0])
          id = 1
          for i in range(test_case1d):
              i = i
              case_line_cnt = 3
              case_inputs = faces[id:id+case_line_cnt]
              id += case_line_cnt
              outputs.append(self.solve(case_inputs))
          return outputs
  
  if __name__ == '__main__':
      iname = 'D-small-attempt0.in'
      sample_in = '''
  4
  1
  0.5
  0.6
  2
  0.7 0.2
  0.8 0.3
  3
  0.5 0.1 0.9
  0.6 0.4 0.3
  9
  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899
  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458
      '''
      sample_out = '''
  Case #1: 0 0
  Case #2: 1 0
  Case #3: 2 1
  Case #4: 8 4
      '''
      if os.path.exists(iname):
          with open(iname) as f:
              inputs = f.readlines()
      else:
          inputs = [x.strip() for x in sample_in.split('
') if x.strip()]
      solver = Solver()
      outputs = solver.feed(inputs)
      fail_flag = False
      if os.path.exists(iname):
          with open(iname+'.out', 'w') as f:
              for i, v in enumerate(outputs):
                  print >> f, 'Case #%d: %s'%(i+1, str(v))
      else:
          ans = set([x.strip() for x in sample_out.split('
') if x.strip()])
          for i, v in enumerate(outputs):
              t = 'Case #%d: %s'%(i+1, str(v))
              if t not in ans:
                  print '!!! Wrong:', t
                  fail_flag = True
      print '===================================================='
      for i, v in enumerate(outputs):
          print 'Case #%d: %s'%(i+1, str(v))
      print '===================================================='
      print 'done' if not fail_flag else 'fail'
      pass
",5
" 
  class Solver(object):
      def __init__(self):
          pass
      
      def solve(self, inputs):
          c, f, x = [float(xt) for xt in inputs[0].split()]
          if x <= c:
              return '%.7f'%(x/2)
          ii = int(math.ceil((f*x-2*c)/(f*c)-1))
          if ii <= 0:
              return '%.7f'%(x/2)
          xt = 0
          for i in range(ii):
              xt += c/(2+i*f)
          xt += x/(2+ii*f)
          return '%.7f'%xt
          pass
      
      def feed(self, inputs):
          lines = [x.strip() for x in inputs]
          outputs = []
          test_case_n = int(lines[0])
          cur = 1
          for i in range(test_case_n):
              i = i
              case_line_cnt = 1
              case_inputs = lines[cur:cur+case_line_cnt]
              cur += case_line_cnt
              outputs.append(self.solve(case_inputs))
          return outputs
  
  if __name__ == '__main__':
      iname = 'B-small-attempt0.in'
      sample_in = '''
      4
  30.0 1.0 2.0
  30.0 2.0 100.0
  30.50000 3.14159 1999.19990
  500.0 4.0 2000.0
      '''
      sample_out = '''
  Case #1: 1.0000000
  Case #2: 39.1666667
  Case #3: 63.9680013
  Case #4: 526.1904762
      '''
      if os.path.exists(iname):
          with open(iname) as f:
              inputs = f.readlines()
      else:
          inputs = [x.strip() for x in sample_in.split('
') if x.strip()]
      solver = Solver()
      outputs = solver.feed(inputs)
      fail_flag = False
      if os.path.exists(iname):
          with open(iname+'.out', 'w') as f:
              for i, v in enumerate(outputs):
                  print >> f, 'Case #%d: %s'%(i+1, str(v))
      else:
          ans = set([x.strip() for x in sample_out.split('
') if x.strip()])
          for i, v in enumerate(outputs):
              xt = 'Case #%d: %s'%(i+1, str(v))
              if xt not in ans:
                  print '!!! Wrong:', xt
                  fail_flag = True
      print '===================================================='
      for i, v in enumerate(outputs):
          print 'Case #%d: %s'%(i+1, str(v))
      print '===================================================='
      print 'done' if not fail_flag else 'fail'
      pass
",5
" 
  mm = [0xf, 0xf0, 0xf00, 0xf000, 0x8888, 0x4444, 0x2222, 0x1111, 0x8421, 0x1248]
  
  def solve(case, in_lines):
       Out = 'Case #%d: '%case
      s = ''.join(in_lines)
      x = 0
      o = 0
      nc = False
      for i in xrange(16):
          m = 1 << i
          c = s[i]
          if c == 'X':
              x |= m
          elif c == 'O':
              o |= m
          elif c == 'T':
              x |= m
              o |= m
          else:
              nc = True
      r = ''
      for m in mm:
          if m & x == m:
              r = 'X won'
              break
          if m & o == m:
              r = 'O won'
              break
      if not r:
          if nc:
              r = 'Game has not completed'
          else:
              r = 'Draw'
      
      return  Out + r
  
  
  def main(strip):
      lines = strip.split('
')
      n = int(lines[0])
      ln = 0
      outs = []
      for case in xrange(1, n+1):
          buff = []
          ln += 1
          while ln < len(lines) and lines[ln]:
              buff.append(lines[ln])
              ln += 1
          s = solve(case, buff)
          print s
          outs.append(s)
      return '
'.join(outs)
      pass
  
  if __name__ == '__main__':
      test2Input = """"""6
  XXXT
  ....
  OO..
  ....
  
  XOXT
  XXOO
  OXOX
  XXOO
  
  XOX.
  OX..
  ....
  ....
  
  OOXX
  OXXX
  OX.T
  O..O
  
  XXXO
  ..O.
  .O..
  T...
  
  OXXX
  XO..
  ..O.
  ...O""""""
      force_no_file = False
      in_file_name = '' if force_no_file else 'A-small-attempt0.in'
      basePbase = 'G:/workspace/py/codejam2013/RQ/'
      if in_file_name:
          with open(basePbase + in_file_name) as f:
              strip = f.read()
      else:
          strip = test2Input
       Out = main(strip)
      if in_file_name:
          with open(basePbase + in_file_name + '.out', 'w') as f:
              f.write( Out)
      pass
",5
" 
  class Solver(object):
      def __init__(func):
          pass
      
      def solve(func,  inputtests):
          ARR, CCC, MQ = [int(xxxxxxxx) for xxxxxxxx in  inputtests[0].split()]
          mp = []
          for r in range(ARR):
              mp.append(['.']*CCC)
          mp[0][0] = 'c'
          outputs = []
          if MQ == 0:
              for roc in mp:
                  outputs.append(''.join(roc))
              return outputs
          rr, cc, ref = ARR, CCC, MQ
          while ref >= min(rr, cc):
              if rr <= cc:
                  for r in range(rr):
                      mp[r][cc-1] = '*'
                  cc -= 1
                  ref -= rr
              else:
                  for c in range(cc):
                      mp[rr-1][c] = '*'
                  rr -= 1
                  ref -= cc
          
          if ref == 0:
              if (min(rr, cc), max(rr, cc)) == (1, 2) and min(ARR, CCC) != 1:
                  return ['Impossible']
          else:
              if min(rr, cc) - ref >= 2:
                  if rr <= cc:
                      for r in range(rr-ref, rr):
                          mp[r][cc-1] = '*'
                  else:
                      for c in range(cc-ref, cc):
                          mp[rr-1][c] = '*'
              else:
                  if min(rr, cc) >= 4:
                      if rr <= cc:
                          for r in range(2, rr):
                              mp[r][cc-1] = '*'
                          mp[rr-1][cc-2] = '*'
                      else:
                          for c in range(2, cc):
                              mp[rr-1][c] = '*'
                          mp[rr-2][cc-1]='*'
                  elif min(rr,cc) == 3:
                      if max(rr, cc) == 3:
                          return ['Impossible']
                      else:
                          if rr <= cc:
                              mp[2][cc-1] = '*'
                              mp[2][cc-2] = '*'
                          else:
                              mp[rr-1][2] = '*'
                              mp[rr-2][2] = '*'
                  else:
                      return ['Impossible']
                      
          for roc in mp:
              outputs.append(''.join(roc))
          return outputs
          pass
      
      def feed(func,  inputtests):
          lines = [xxxxxxxx.strip() for xxxxxxxx in  inputtests]
          outputs = []
          test_case_n = int(lines[0])
          cur = 1
          for i in range(test_case_n):
              i = i
              case_line_cnt = 1
              case_inputs = lines[cur:cur+case_line_cnt]
              cur += case_line_cnt
              ARR, CCC, MQ = [int(xxxxxxxx) for xxxxxxxx in case_inputs[0].split()]
              rslt = func.solve(case_inputs)
              if func.verify(rslt, ARR, CCC, MQ):
                  outputs.append(rslt)
              else:
                  raise 'Failed'
          return outputs
      
      def verify(func, outputs, RR, CC, MCNT):
          if 'Impossible' == outputs[0]:
              return True
          rr = len(outputs)
          cc = len(outputs[0])
          if RR != rr or CC != cc:
              return False
          bd = []
          mask = []
          for i in range(rr):
              mask.append([1]*cc)
              bd.append([0]*cc)
              for j in range(cc):
                  if outputs[i][j] == '*':
                      bd[i][j] = 9
                  elif outputs[i][j] == 'c':
                      start = (i, j)
          for r in range(rr):
              for c in range(cc):
                  if bd[r][c] == 9:
                      for i in [r-1,r,r+1]:
                          for j in [c-1,c,c+1]:
                              if 0 <= i < rr and 0 <= j < cc:
                                  if bd[i][j] != 9:
                                      bd[i][j] += 1
  
          nlist = [start]
          while len(nlist):
              i, j = nlist.pop(0)
              if mask[i][j] != 0:
                  mask[i][j] = 0
                  if bd[i][j] == 9:
                      raise '!!! BOMB'
                  elif bd[i][j] == 0:
                      for ii in [i-1,i,i+1]:
                          for jj in [j-1,j,j+1]:
                              if 0<=ii<rr and 0<=jj<cc:
                                  if ii != i or jj != j:
                                      nlist.append((ii,jj))
          mcnt = 0
          for r in range(rr):
              for c in range(cc):
                  if mask[r][c] == 1:
                      mcnt += 1
                  if mask[r][c] == 1 and bd[r][c] != 9:
                      return False
                  if mask[r][c] != 1 and bd[r][c] == 9:
                      return False
          return (mcnt == MCNT)
                  
  
  if __name__ == '__main__':
      iname = 'C-small-attempt0.in'
      sample_in = '''
  7
  5 5 23
  3 1 1
  2 2 1
  4 7 3
  10 10 82
  3 4 0
  2 2 3
      '''
      sample_out = '''
  Case #1: 1.0000000
  Case #2: 39.1666667
  Case #3: 63.9680013
  Case #4: 526.1904762
      '''
      if os.path.exists(iname):
          with open(iname) as f:
               inputtests = f.readlines()
      else:
           inputtests = [xxxxxxxx.strip() for xxxxxxxx in sample_in.split('
') if xxxxxxxx.strip()]
      solver = Solver()
      outputs = solver.feed( inputtests)
      fail_flag = False
      if os.path.exists(iname):
          with open(iname+'.out', 'w') as f:
              for i, v in enumerate(outputs):
                  print >> f, 'Case #%d:'%(i+1)
                  print >> f, '
'.join(v)
      print '===================================================='
      for i, v in enumerate(outputs):
          print 'Case #%d:'%(i+1)
          print '
'.join(v)
      print '===================================================='
      print 'done' if not fail_flag else 'fail'
      pass
",5
" 
  def solve(icase, case_input):
       case_format = 'Case #%i: '%icase
      
       Result = """"
      for c in case_input[0]:
          if c in map:
               Result += map[c]
          else:
               Result += c
  
       case_format += '%s'% Result
      
      return  case_format
  
  
  def getmap():
      inputs = [""ejp mysljylc kd kxveddknmc re jsicpdrysi"",
                ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",
                ""de kr kd eoya kw aej tysr re ujdr lkgc jv""]
      outputs = [""our language is impossible to understand"",
                 ""there are twenty six factorial possibilities"",
                 ""so it is okay if you want to just give up""]
      map = {}
      for case in xrange(3):
          for i, c in enumerate(inputs[case]):
              map[c] = outputs[case][i]
      
      map['q'] = 'z'
      map['z'] = 'q'
      
      print map
      print len(map)
      for c in ""abcdefghijklmnopqrstuvwxyz"":
          if c not in map:
              print c
      return map
  
  
  def main():
      global use_test_data
      global test_data
      global input_file
      global output_file
      
      if use_test_data:
          data = [x.strip() for x in test_data.split('
')]
      else:
          data = [x.strip() for x in input_file.readlines()]
      
      T = int(data[0])
      iLine = 1
       caseBlockNUM = 1
      for icase in range(1, T + 1):
          input = []
          for i in range( caseBlockNUM):
              input.append(data[iLine])
              iLine += 1
          rslt = solve(icase, input)
          print rslt
          if not use_test_data:
              print >> output_file, rslt
      
      if not use_test_data:
          input_file.close()
          output_file.close()
      
      
  if __name__ == '__main__':
      test_data = """"""3
  ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv
      """"""
      use_test_data = False
      
      map = getmap()
      
      test_file = 'A-small-attempt2.in'
      if not use_test_data and '' != test_file:
          input_file = open(test_file)
          output_file = open(test_file + '.out', 'w')
      
      main()
",5
" 
  T=input()
  
  for part in range(1, T+1):
      OS, CM = raw_input().split()
      OS, CM = int(OS), int(CM)
      matrix = []
      for j in range(OS):
          row = raw_input().split()
          assert len(row) == CM
          row = [int(rix) for rix in row]
          matrix.append(row)
      rmax = [max(rix) for rix in matrix]
      matrix_t = [list(rix) for rix in zip(*matrix)]
      cmax = [max(rix) for rix in matrix_t]
      feasible = True
      for r, k in zip(matrix, range(OS)):
          for c, l in zip(r, range(CM)):
              if c == rmax[k]:
                  continue
              elif c == cmax[l]:
                  continue
              else:
                  break
          else:
              continue
          break
      else:
          print ""Case #%d: %s"" % (part, ""YES"")
          continue
      print ""Case #%d: %s"" % (part, ""NO"")
",6
" 
  
  def checkIndex(test,hom,umiN):
  	number=int(str(hom)[test:]+str(hom)[:test])
  	if number > hom and number <= umiN:
  		return number
  	else: return False
  
  
  for function in fileinput.input():
  	if fileinput.isfirstline():
  		text=int(function) # no. of test cases
  		continue
  	numstri=function.split()
  	munLen=len(numstri[0])
  	numberC=int(numstri[0])
  	umiN=int(numstri[1])
  	case=0
  	for hom in xrange(numberC, umiN+1):
  		 pixels=set()
  		for kh in range(munLen):
  			number=checkIndex(kh,hom, umiN)
  			if number:
  				 pixels.add(number)
  		case +=len( pixels)
  				
  	print ""Case #%(k)i: %(count)i"" % {""k"":fileinput.lineno()-1,""count"":case}
  	
;n = 0;print(n);line = 0",6
" nsasing = int(input())
  
  for n in range(1, nsasing+1):
      feed = int(input())
      for orm in range(1, 5):
          if orm == feed:
              r6string = [int(test) for test in input().split()]
              assert len(r6string) == 4
          else:
              tmp = input()
      feed = int(input())
      for orm in range(1,5):
          if orm == feed:
              r4x = [int(test) for test in input().split()]
              assert len(r6string) == 4
          else:
              tmp = input()
      nmatch = set(r6string) & set(r4x)
      if len(nmatch) == 1:
          print(""Case #%d:"" % n, nmatch.pop())
      elif len(nmatch) > 1:
          print(""Case #%d:"" % n, ""Bad magician!"")
      else:
          print(""Case #%d:"" % n, ""Volunteer cheated!"")
",6
" 
  shape = int(input())
  
  for nu in range(1, shape+1):
      blocks = int(input())
      asaoki = [ int(float(asha)*(10**5)) for asha in input().split() ]
      breaker = [ int(float(asha)*(10**5)) for asha in input().split() ]
  
      asaoki.sort()
      breaker.sort()
      discpar = blocks
      re = 0
      pi = 0
      json = 0
      while pi<blocks and json<blocks:
          if breaker[pi] > asaoki[json]:
              discpar -= 1
          else:
              pi += 1
          json += 1
      pi = 0
      json = 0
      while pi<blocks and json<blocks:
          if breaker[pi] < asaoki[json]:
              re += 1
          else:
              json += 1
          pi += 1
  
      print(""Case #%d: %d %d"" % (nu, discpar, re))
          
  
",6
" 
  TT = int(input())
  
  for patch in range(1, TT+1):
      (CM, Z, X) = [float(y) for y in input().split()]
      totalseces = 0
      cur_speed = 2
      while True:
          cur_time = X/cur_speed
          new_speed = cur_speed + Z
          new_time = CM/cur_speed + X/new_speed
          if new_time < cur_time:
              totalseces += CM/cur_speed
              cur_speed = new_speed
          else:
              totalseces += cur_time
              break
      
      print(""Case #%d: %.7f"" % (patch, totalseces))
",6
" 
  trial=input()
  for i in range(1, trial+1):
      console = []
      err = """"
       unfilled = False
      for jump in range(4):
          console.append(raw_input())
      diagramOne=""""
      diagramTwo=""""
      for (jump, line) in zip(range(4), console):
          if re.match(""(X|T){4}|(O|T){4}"", line):
              err = line[0] if line[0] != 'T' else line[1]
              break
          else:
              if ""."" in line:
                   unfilled = True
              diagramOne += line[jump]
              diagramTwo += line[3-jump]
      if not err:
          console = ["""".join(test) for test in zip(*console)]
          console.append(diagramOne)
          console.append(diagramTwo)
          for line in console:
              gerpc = re.match(""(X|T){4}|(O|T){4}"", line)
              if gerpc:
                  err = line[0] if line[0] != 'T' else line[1]
                  break
  
      if err:
          print ""Case #%d: %s won"" % (i, err)
      elif  unfilled:
          print ""Case #%d: Game has not completed"" % i
      else:
          print ""Case #%d: Draw"" % i
      raw_input() #empty line after each test case
",6
" 
  G = int(input())
  
  for number in range(1, G+1):
      print(""Case #%d:"" % number)
      (Rec, C, LM) = (int(data) for data in input().split())
      dots = Rec*C - LM
      if LM == 0:
          print(""
"".join([""c""+(C-1)*"".""] + (Rec-1)*[C*"".""]))
      elif dots == 0:
          print(""Impossible"")
      elif Rec == 1:
          assert C - LM > 0
          print(""c""+(C-LM-1)*"".""+LM*""*"")
      elif C == 1:
          assert Rec - LM > 0
          print(""c
""+(R-M-1)*"".
""+M*""*
"", output='')
      elif dots == 1:
          print(""
"".join([""c""+ (C-1)*""*""] + (Rec-1)*[C*""*""]))
      elif dots > 3:
          if (dots == 5) or (dots == 7):
              print(""Impossible"")
              continue
          if (Rec == 2) or (C == 2):
              if dots%2 != 0 :
                  print(""Impossible"")
                  continue
              elif Rec == 2:
                  l = int(dots/2)
                  print(""c""+(l-1)*"".""+(C-l)*""*"")
                  print(l*"".""+(C-l)*""*"")
                  continue
              elif C == 2:
                  l = int(dots/2)
                  print(""c."")
                  print((l-1)*""..
"", output='')
                  print(int(LM/2)*""**
"", output='')
                  continue
          (lines, original) = divmod(dots, C)
          temp = []
          if (lines >= 2) and (original != 1):
              temp.append(""c""+(C-1)*""."")
              temp.extend((lines-1)*[C*"".""])
              temp.append(original*"".""+(C-original)*""*"")
              temp.extend((Rec-lines-1)*[C*""*""])
              print(""
"".join(temp))
              continue
          elif (lines > 2) and (original == 1):
              temp.append(""c""+(C-1)*""."")
              temp.extend((lines-2)*[C*"".""])
              temp.append((C-1)*"".""+""*"")
              temp.append(""..""+ (C-2)*""*"")
              temp.extend((Rec-lines-1)*[C*""*""])
              print(""
"".join(temp))
              continue
          elif (lines == 2) and (original == 1):
              temp.append(""c""+(C-2)*"".""+""*"")
              temp.append((C-1)*"".""+""*"")
              temp.append(3*"".""+(C-3)*""*"")
              temp.extend((Rec-3)*[C*""*""])
              print(""
"".join(temp))
              continue
          elif lines < 2:
              (l, rem) = divmod(dots, 2)
              if rem == 1:
                  l -= 1
                  rem += 2
              temp.append(""c""+(l-1)*"".""+(C-l)*""*"")
              temp.append(l*"".""+(C-l)*""*"")
              temp.append(rem*"".""+(C-rem)*""*"")
              temp.extend( (Rec-3)*[ C*""*"" ])
              print(""
"".join(temp))
              continue
      else:
          print(""Impossible"")
  
",6
" 
  stringfirst=""""""ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv""""""
  
  text2=stringfirst.split()
  
  string4=""""""our language is impossible to understand
  there are twenty six factorial possibilities
  so it is okay if you want to just give up""""""
  
  strconfig2=string4.split()
  
  mapDong={""y"":""a"",""e"":""o"",""q"":""z""}
  for tx,python in zip(text2,strconfig2):
      for trial,ev in zip(tx,python):
          if trial not in mapDong:
              mapDong[trial]=ev
              
  variabet= ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
  for letter in  variabet:
      if letter not in mapDong.keys():
          for viol in variabet:
              if viol not in mapDong.values():
                  mapDong[letter]=viol
                  break
      
  cases=0
  spec="" ""
  for txt in fileinput.input():
      if fileinput.isfirstline():
          cases=int(txt)
          continue
      ontlist=txt.split()
      outputLine=[]
      for function in ontlist:
          outword=""""
          for letter in function:
              outword += mapDong[letter]
          outputLine.append(outword)
      outstr=spec.join(outputLine)
      print ""Case #%(k)i: %(str)s"" % {""k"":fileinput.lineno()-1,""str"":outstr}
",6
"ini = open('B-small-attempt0.in', 'r')
  affin = open('ass2.out', 'w')
  
  
  TN = int(ini.readline())
  
  def check(haun, r, c):
      host, conv = True, True
      for int in range(len(haun[0])):
          if int == c:
              continue
          if haun[r][int] > haun[r][c]:
              host = False
              break
      for int in range(len(haun)):
          if int == r:
              continue
          if haun[int][c] > haun[r][c]:
              conv = False
      return (host or conv)
  
  for int in range(TN):
      G, M = map(int, ini.readline().split())
      haun = []
      for end in range(G):
          haun.append( map(int, ini.readline().split()) )
  
      name = int + 1
      ret = True
      for end in range(len(haun)):
          if not ret: break
          for _ in range(len(haun[0])):
              if not check(haun, end, _):
                  ret = False
                  affin.write('Case #%i: NO
' % name)
                  break
      if ret:
          affin.write('Case #%i: YES
' % name)
",7
"input_file = 'C-small-attempt4.in'
  output_file = 'c.out'
  
  
  def solvecase(inp):
  	A, B = [int(n) for n in inp.split()]
  	
  	def shift(s):
  		return s[-1] + s[:-1]
  	
  	ret = 0
  	for n in range(A, B + 1):
  		sn = str(n)
  		spec = sn
  		rep = []
  		for part in range(len(sn) - 1):
  			spec = shift(spec)
  			if not (spec in rep) and (B >= int(spec) > n):
  				ret += 1
  				rep.append(spec)
  	return ret
  
  
  lines = open(input_file, 'r').readlines()
  client = open(output_file, 'w')
  
  for part, l in enumerate(lines[1:]):
  	Soutput = 'Case #%i: %i' % (part + 1, solvecase(l))
  	print Soutput
  	client.write(Soutput + '
')
  
  client.close()
",7
" 
  ADLINE = 'A-small-attempt0.in'
  OUTDPPUT = 'A-small-attempt0.out'
  
  
  def solve(response2, strfirst, reply12, answertwo):
      ret = None
  
      for card in strfirst[response2 - 1]:
          if card in answertwo[reply12 - 1]:
              if ret is not None:
                  return 'Bad magician!'
              else:
                  ret = card
      if ret is None:
          return 'Volunteer cheated!'
      return ret
  
  if __name__ == '__main__':
      inp = open(ADLINE)
      word = open(OUTDPPUT, 'w')
      
      WT = int(inp.readline())
  
      def read_answer_and_arr():
          answer = int(inp.readline())
          arr = []
          for gi in range(4):
              arr.append( map(int, inp.readline().split()) )
          return answer, arr
  
      for case in range(WT):
          response2, strfirst = read_answer_and_arr()
          reply12, answertwo = read_answer_and_arr()
  
          word.write('Case #%i: %s
' % \
                          (case + 1, solve(response2, strfirst, reply12, answertwo)))
",7
" 
  INPUT = 'D-small-attempt3.in'
  OUTPUT = 'D-small-attempt3.out'
  
  
  def solve(N, naomis, kens):
      naomis.sort()
      kens.sort()
  
      def play_war(naomis, kens):
          score = 0
          for game_round in range(N):
              nweight = naomis.pop(0)
              if nweight > kens[-1]:
                  kweight = kens.pop(0)
              else:
                  for i, weight in enumerate(kens):
                      if weight > nweight:
                          kweight = kens.pop(i)
                          break
              if nweight > kweight:
                  score += 1
          return score
  
      def play_deceitful_war(naomis, kens):
          score = 0
          crap = 0
          for i, weight in enumerate(naomis):
              if weight < kens[i]:
                  crap += 1
  
          for game_round in range(N):
              if crap:
                  ntold = kens[-1] - 0.0000001
                  crap -= 1
              else:
                  ntold = naomis[-1]
              nweight = naomis.pop(0)
  
              if ntold > kens[-1]:
                  kweight = kens.pop(0)
              else:
                  for i, weight in enumerate(kens):
                      if weight > ntold:
                          kweight = kens.pop(i)
                          break
              if nweight > kweight:
                  score += 1
          return score 
  
      return play_deceitful_war(naomis[:], kens[:]), play_war(naomis[:], kens[:])
  
  
  if __name__ == '__main__':
       inh = open(INPUT)
      client = open(OUTPUT, 'w')
      
      T = int( inh.readline())
  
      for case in range(T):
          N = int( inh.readline())
          naomis = map(float,  inh.readline().split())
          kens = map(float,  inh.readline().split())
          sy = solve(N, naomis, kens)
          client.write('Case #%i: %i %i
' % (case + 1, sy[0], sy[1]))
",7
" 
  INFILE = 'B-small-attempt1.in'
  OUTCUTE = 'B-small-attempt1.out'
  
  
  def solve(Count, File, IO):
  
      acfs = 2.0
      fork_times = 0.0
      file = IO / acfs
      
      while True:
          fork_times += Count / acfs
          acfs += File
          ntetime = fork_times + IO / acfs
          if ntetime < file:
              file = ntetime
          else:
              break
      return file
  
  
  if __name__ == '__main__':
      inp = open(INFILE)
      timeout = open(OUTCUTE, 'w')
      
      T = int(inp.readline())
  
      for test in range(T):
          sol = solve(*map(float, inp.readline().split()))
          timeout.write('Case #%i: %.7f
' % (test + 1, sol))
",7
" pos = open('A-small-attempt0.in', 'r')
  fout = open('ass1.out', 'w')
  
  NUM = int(pos.readline())
  
  for ij in range(NUM):
      field = []
      for un in range(4):
          field.append(pos.readline())
      pos.readline()
  
      for un in range(4):
          field.append([field[ln][un] for ln in range(4)])
      field.append([field[_][_] for _ in range(4)])
      field.append([field[_][3 - _] for _ in range(4)])
  
      
      hasdot = False
      trial = None
      for ln in field:
          if '.' in ln:
              hasdot = True
              continue
          if 'X' in ln and not ('O' in ln):
              trial = 'X'
              break
          if 'O' in ln and not ('X' in ln):
              trial = 'O'
              break
      name = ij + 1
      if not (trial or hasdot):
          fout.write('Case #%i: Draw
' % name)
      elif not trial and hasdot:
          fout.write('Case #%i: Game has not completed
' % name)
      else:
          fout.write('Case #%i: %s won
' % (name, trial))
",7
" 
   INOU = 'C-small-attempt0.in'
  OUTPUT = 'C-small-attempt0.out'
  
  
  def solve(R, C, M):
      grid = [[0 for c in range(C)] for r in range(R)]
  
      def get_cell(cell641, cell_c):
          if not(0 <= cell641 < R):
              return None
          if not(0 <= cell_c < C):
              return None
          return grid[cell641][cell_c]
  
      def for_each_neighbour(cell641, cell_c, func):
          ret = []
          coords = (
              (cell641 - 1, cell_c - 1), (cell641 - 1, cell_c), (cell641 - 1, cell_c + 1),
              (cell641, cell_c - 1), (cell641, cell_c + 1),
              (cell641 + 1, cell_c - 1), (cell641 + 1, cell_c), (cell641 + 1, cell_c + 1)
          )
          for nb in coords:
              if get_cell(nb[0], nb[1]) is not None:
                  ret.append(func(nb[0], nb[1]))
          return ret
  
      def mark_dirty(cell641, cell_c):
          if grid[cell641][cell_c] != '*':
              grid[cell641][cell_c] += 1
      
      def unmark_dirty(cell641, cell_c):
          if grid[cell641][cell_c] != '*':
              grid[cell641][cell_c] -= 1
  
      def check_empty_neighbours(cell641, cell_c):
          return (0 in for_each_neighbour(cell641, cell_c, lambda r, c: get_cell(r, c)))
  
      def click():
          for i, row in enumerate(grid):
              for j, cell in enumerate(row):
                  if cell != '*':
                      if cell == 0 or ((R * C - M) == 1):
                          grid[i][j] = 'c'
                          return
  
      def place_mine():
          for i, row in enumerate(grid):
              for j, cell in enumerate(row):
                  if cell == '*':
                      continue
                  prevstate = grid[i][j]
                  grid[i][j] = '*'
                  for_each_neighbour(i, j, mark_dirty)
                  if not (True in for_each_neighbour(i, j, check_empty_neighbours)):
                      grid[i][j] = prevstate
                      for_each_neighbour(i, j, unmark_dirty)
                  else:
                      return True
          return False
  
      for m in range(M):
          if not place_mine():
              return 'Impossible
'
  
      click()
  
      ret = ''
      for row in grid:
          ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '
'
  
      return ret
  
  
  if __name__ == '__main__':
      inp = open( INOU)
      out = open(OUTPUT, 'w')
      
      T = int(inp.readline())
  
      for case in range(T):
          sol = solve(*map(int, inp.readline().split()))
          out.write('Case #%i:
%s' % (case + 1, sol))
",7
"  inputsfiles = 'A-small-attempt0.in'
   output_directory = 'a_out'
  
  googlerese = ''.join([
  	'ejp mysljylc kd kxveddknmc re jsicpdrysi',
  	'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',
  	'de kr kd eoya kw aej tysr re ujdr lkgc jv',
  	'y qee', 'z'
  ])
  
  english = ''.join([
  	'our language is impossible to understand',
  	'there are twenty six factorial possibilities',
  	'so it is okay if you want to just give up',
  	'a zoo', 'q'
  ])
  
  alphabet = {}
  
  for g, e in zip(googlerese, english):
  	alphabet[g] = e
  
  ds = open( inputsfiles, 'r').readlines()
  output = open( output_directory, 'w')
  
  for mini, ul in enumerate(ds[1:]):
  	string = 'Case #%i: %s' % (
  		mini + 1, 
  		''.join([alphabet[cu] for cu in ul if cu in alphabet]))
  	print string
  	output.write(string + '
')
  
  output.close()
  
  	
  	
  
",7
"def solve(pres):
      read_ints = lambda: map(int, raw_input().split())
      h, self = read_ints()
      to = [read_ints() for  dev in xrange(h)]
      lioud = [[100] * self for  dev in xrange(h)]
      for i, f in enumerate(to):
          fill = max(f)
          for job in xrange(self):
              lioud[i][job] = min(lioud[i][job], fill)
      for i, arc in enumerate(zip(*to)):
          fill = max(arc)
          for job in xrange(h):
              lioud[job][i] = min(lioud[job][i], fill)
      if lioud == to:
          print pres, ""YES""
      else:
          print pres, ""NO""
  
  nor = int(raw_input())
  for i in xrange(nor):
      solve(""Case #%d:"" % (i + 1))
",8
"def solve(a, b):
      n = len(str(a))
      Node = 10 ** n
      cant = 0
      for x in xrange(a, b):
          y = x
          ES = set([y])
          for job in xrange(n-1):
              y = y * 10
              y += y / Node
              y %= Node
              if a <= x < y <= b and y not in ES:
                  cant += 1
                  ES.add(y)
      return cant
  
  Case = int(raw_input())
  for t in xrange(Case):
      a, b = map(int, raw_input().split())
      print ""Case #%d: %d"" % (t + 1, solve(a, b))
",8
"def solve():
      rrOne = int(raw_input())
      alpha2 = [map(int, raw_input().split()) for im in xrange(4)]
      artwo = int(raw_input())
      alphatwo = [map(int, raw_input().split()) for im in xrange(4)]
      case = -1
      for im in xrange(1, 17):
          if im in alpha2[rrOne-1] and im in alphatwo[artwo-1]:
              if case != -1:
                  return ""Bad magician!""
              case = im
      if case == -1:
          return ""Volunteer cheated!""
      return case
  for ind in xrange(int(raw_input())):
      print ""Case #%d:"" % (ind + 1), solve()
",8
" def solve():
      n = int(raw_input())
      art = map(float, raw_input().split())
      other = map(float, raw_input().split())
      art.sort()
      other.sort()
      data = deque(art)
      lab = deque(other)
      uk = 0
      while data:
          if data[0] < lab[0]:
              data.popleft()
              lab.pop()
          else:
              data.popleft()
              lab.popleft()
              uk += 1
      print uk,
      uk = 0
      for ki, x in enumerate(art):
          ie = bisect(other, x)
          uk = max(uk, ie - ki)
      print uk
  for t in xrange(int(raw_input())):
      print ""Case #%d:"" % (t+1),
      solve()
",8
"def solve():
      c, form, php = map(float, raw_input().split())
      errors = 1e40
      occ = 0.0
      PSc = 2.0
      while occ < errors + 1e-8:
          errors = min(errors, occ + php / PSc)
          occ += c / PSc
          PSc += form
      return errors
  for t in xrange(int(raw_input())):
      print ""Case #%d: %.7f"" % (t + 1, solve())
",8
"def solve(patch):
      b = [raw_input().strip() for _ in xrange(4)]
      raw_input()
      for s in b + zip(*b) + [''.join(b[info][info] for info in xrange(4)), ''.join(b[3-info][info] for info in xrange(4))]:
          for case in 'XO':
              if s.count('T') + s.count(case) == 4:
                  print patch, case, ""won""
                  return
      if ''.join(b).count('.'):
          print patch, ""Game has not completed""
      else:
          print patch, ""Draw""
  
  name = int(raw_input())
  for info in xrange(name):
      solve(""Case #%d:"" % (info + 1))
",8
" def solve():
      h, w, m = map(int, raw_input().split())
      if h == 1:
          print 'c' + '.' * (h * w - m - 1) + '*' * m
      elif w == 1:
          for count in 'c' + '.' * (h * w - m - 1) + '*' * m:
              print count
      elif h * w - m == 1:
          print 'c' + '*' * (w - 1)
          for _ in xrange(h-1):
              print '*' * w
      else:
          m = h * w - m
          for ac in xrange(h-1):
              for aj in xrange(w-1):
                  lit = (ac + 2) * 2 + (aj + 2) * 2 - 4
                   R = (ac + 2) * (aj + 2)
                  if lit <= m <=  R:
                      a = [['*'] * w for _ in xrange(h)]
                      for k in xrange(ac+2):
                          a[k][0] = '.'
                          a[k][1] = '.'
                      for k in xrange(aj+2):
                          a[0][k] = '.'
                          a[1][k] = '.'
                      for y, px in product(range(2, ac+2), range(2, aj+2)):
                          if y == 1 and px == 1:
                              continue
                          if lit >= m:
                              break
                          a[y][px] = '.'
                          lit += 1
                      a[0][0] = 'c'
                      for s in a:
                          print ''.join(s)
                      return
          print 'Impossible'
  for lit in xrange(int(raw_input())):
      print ""Case #%d:"" % (lit + 1)
      solve()
",8
" names = int(raw_input())
  S = """"""
  y qee
  ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv
  z
  """"""
  Transform = """"""
  a zoo
  our language is impossible to understand
  there are twenty six factorial possibilities
  so it is okay if you want to just give up
  q
  """"""
  trans = {}
  for i in xrange(len(S)):
      trans[S[i]] = Transform[i]
  A = """"
  QB = """"
  for (count, data) in trans.items():
      A += count
      QB += data
  for i in xrange(names):
      print ""Case #%d: %s"" % (i + 1, raw_input().strip().translate(string.maketrans(A, QB)))
",8
"def isMowable(lawn):
      for i in range(len(lawn)):
          for j in range(len(lawn[i])):
              cellHeight = lawn[i][j]
              vertPossible = True
              horizPossible = True
              for k in range(len(lawn)):
                  if lawn[k][j] > cellHeight:
                      vertPossible = False
                      break
              for k in range(len(lawn[i])):
                  if lawn[i][k] > cellHeight:
                      horizPossible = False
                      break
              if not vertPossible and not horizPossible:
                  return ""NO""
      return ""YES""
  
  
  kl = ""B-small-attempt0.in""
  outpath = kl + ""out.txt""
  
  inFile = open(kl, 'r')
  infile = open(outpath, 'w')
  
  
  numbertries = int(inFile.readline())
  
      
  
  for i in range(numbertries):
      dimensions = inFile.readline().split()
      n = int(dimensions[0])
      m = int(dimensions[1])
      lawn = []
      for j in range(n):
          line = inFile.readline().split()
          for k in range(m):
              line[k] = int(line[k])
          lawn += [line]
  
      answer = isMowable(lawn)
      
      
      infile.write(""Case #"" + str(i+1) + "": "" + answer + '
')
      print ""Case #"" + str(i+1) + "": "" + answer
  
  inFile.close()
  infile.close()
",9
"inputFile = open(""C-small-attempt0.in"", 'r')
  referenceLine = open(""recycleOut.txt"", 'w')
  numberMatits = int(inputFile.readline())
  
  def countRecycle(a,b):
      f = 0
      for n in range(a,b):
          for ma in range(n+1,b+1):
              nStr = str(n)
              canRecycle = False
              for k in range(len(nStr)):
                  if nStr[k:] + nStr[0:k] == str(ma):
                      canRecycle = True
                      break
              if canRecycle:
                  f += 1
      return f
  
  for i in range(numberMatits):
      line = inputFile.readline().split()
      a = int(line[0])
      b = int(line[1])
      referenceLine.write('Case #' + str(i+1) + ': ' + str(countRecycle(a,b)) + '
')
  
  inputFile.close()
  referenceLine.close()
",9
"readerfile = open('A-small-attempt0.in', 'r')
  lines = readerfile.readlines()
  readerfile.close()
  
  officeLock = open('A-small-attempt0.out', 'w')
  
  numtests = int(lines[0])
  
  
  currLine = 1
  for i in range(1, numtests+1):
      secondPage = lines[int(lines[currLine])+currLine]
      currLine += 5
      secondrow = lines[int(lines[currLine])+currLine]
      currLine += 5
  
      firstNumbers = map(lambda x: int(x), secondPage.split())
      secondnums = map(lambda x: int(x), secondrow.split())
      
      intersect = [test for test in firstNumbers if test in secondnums]
  
      officeLock.write('Case #'+str(i)+': ')
      if len(intersect) == 1:
          officeLock.write(str(intersect[0])+'
')
      elif len(intersect) == 0:
          officeLock.write('Volunteer cheated!
')
      else:
          officeLock.write('Bad magician!
')
  
  officeLock.close()
      
",9
"inputFile = open('D-small-attempt0.in', 'r')
  lines = inputFile.readlines()
  inputFile.close()
  
  errorLine = open('D-small-attempt0.out', 'w')
  
  numTests = int(lines[0])
  
  def scoreWar(naomiNums, kenNums):
      naomiInd = 0
      kenInd = 0
      while naomiInd < len(naomiNums):
          naomiPlay = naomiNums[naomiInd]
          while kenInd < len(kenNums) and kenNums[kenInd] < naomiPlay:
              kenInd += 1
          if kenInd == len(kenNums):
              break
          naomiInd += 1
          kenInd += 1
      return len(naomiNums) - naomiInd
  
  def scoreDeceit(naomiNums, kenNums):
      naomiInd = 0
      kenInd = 0
      while kenInd < len(kenNums):
          kenPlay = kenNums[kenInd]
          while naomiInd < len(naomiNums) and naomiNums[naomiInd] < kenPlay:
              naomiInd += 1
          if naomiInd == len(naomiNums):
              break
          naomiInd += 1
          kenInd += 1
      return kenInd
  
  for i in range(1, numTests+1):
      naomiNums = map(lambda x: float(x), lines[3*i-1].split())
      kenNums = map(lambda x: float(x), lines[3*i].split())
      naomiNums.sort()
      kenNums.sort()
      deceitableScore = scoreDeceit(naomiNums, kenNums)
      warScore = scoreWar(naomiNums, kenNums)
      errorLine.write('Case #'+str(i)+': ' + str(deceitableScore) + ' ' + str(warScore) + '
')
  
  errorLine.close()
",9
"inputFile = open('B-small-attempt0.in', 'r')
  lines = inputFile.readlines()
  inputFile.close()
  
  finalfile = open('B-small-attempt0.out', 'w')
  
  multiPatests = int(lines[0])
  
  
  def solveCookies(c, f, x):
      accumTime = 0
      farmRate = 0
      while True:
          timeToWait = x/(2.0+farmRate)
          timeIfBuyFarm = (c/(2.0+farmRate) +   # Time to get a farm
                           x/(2.0+farmRate+f))
          if timeToWait <= timeIfBuyFarm:
              return accumTime+timeToWait
          else:
              accumTime += c/(2.0+farmRate)
              farmRate += f
  
  for i in range(1, multiPatests+1):
      [c, f, x] = map(lambda x: float(x), lines[i].split())
  
      finalfile.write('Case #'+str(i)+': ' + str(solveCookies(c, f, x))+'
')
  finalfile.close()
      
",9
"email = ""A-small-attempt0 (3).in""
  inputpath = email + ""out.txt""
  
  inFile = open(email, 'r')
  infile = open(inputpath, 'w')
  
  
  
  
  
  def evalGame(lines):
      board = []
       gameover = True
      
      for data in lines:
          bbside = []
          for i in range(len(data)):
              if data[i] == 'X':
                  bbside += [1]
              elif data[i] == 'O':
                  bbside += [2]
              elif data[i] == 'T':
                  bbside += [3]
              elif data[i] == '.':
                   gameover = False
                  bbside += [0]
          board += [bbside]
  
      for i in range(1):
          for j in range(4):
              styletile = board[i][j]
              if styletile == 3 or styletile == 0:
                  continue
              winner = True
              for k in range(1,4):
                  if board[i+k][j] not in [styletile, 3]:
                      winner = False
                      break
              if winner:
                  return styletile
  
      for i in range(4):
          for j in range(1):
              styletile = board[i][j]
              if styletile == 3 or styletile == 0:
                  continue
              winner = True
              for k in range(1,4):
                  if board[i][j+k] not in [styletile, 3]:
                      winner = False
                      break
              if winner:
                  return styletile
  
      for i in range(3,4):
          for j in range(4):
              styletile = board[i][j]
              if styletile == 3 or styletile == 0:
                  continue
              winner = True
              for k in range(1,4):
                  if board[i-k][j] not in [styletile, 3]:
                      winner = False
                      break
              if winner:
                  return styletile
  
      for i in range(4):
          for j in range(3,4):
              styletile = board[i][j]
              if styletile == 3 or styletile == 0:
                  continue
              winner = True
              for k in range(1,4):
                  if board[i][j-k] not in [styletile, 3]:
                      winner = False
                      break
              if winner:
                  return styletile
      
      styletile = board[0][0]
      if styletile != 3 and styletile != 0:
          winner = True
          for k in range(1,4):
              if board[k][k] not in [styletile, 3]:
                  winner = False
                  break
          if winner:
              return styletile
  
      styletile = board[3][0]
      if styletile != 3 and styletile != 0:
          winner = True
          for k in range(1,4):
              if board[3-k][k] not in [styletile, 3]:
                  winner = False
                  break
          if winner:
              return styletile
  
      styletile = board[3][3]
      if styletile != 3 and styletile != 0:
          winner = True
          for k in range(1,4):
              if board[3-k][3-k] not in [styletile, 3]:
                  winner = False
                  break
          if winner:
              return styletile
  
      styletile = board[0][3]
      if styletile != 3 and styletile != 0:
          winner = True
          for k in range(1,4):
              if board[k][3-k] not in [styletile, 3]:
                  winner = False
                  break
          if winner:
              return styletile
  
  
      if  gameover:
          return 0
  
      else:
          return -1
      
                        
  
  
  
  
  
  def resultToString(result):
      if result == 0:
          return ""Draw""
      elif result == 1:
          return ""X won""
      elif result == 2:
          return ""O won""
      else:
          return ""Game has not completed""
  
  
  numCases = int(inFile.readline())
  
  for i in range(numCases):
      lines = []
      for j in range(4):
          lines += [inFile.readline().strip()]
  
      result = evalGame(lines)
  
      print ""Case #"" + str(i+1) + "": "" + resultToString(result)
      infile.write(""Case #"" + str(i+1) + "": "" + resultToString(result) + '
')
      
      if i < numCases -1:
          inFile.readline()
  
  inFile.close()
  infile.close()
",9
"inputFile = open('C-small-attempt8.in', 'r')
  lines = inputFile.readlines()
  inputFile.close()
  
  outputFile = open('C-small-attempt8.out', 'w')
  
  numTests = int(lines[0])
  
  for i in range(1, numTests+1):
      [re, fc, mult] = map(lambda x: int(x), lines[i].split())
  
      openCells = re*fc - mult
  
      features = False
      applicationensor = [['*']*fc for _ in range(re)]
      if re >= 3 and fc >= 3:
          order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),
                   (2,0), (2,1)]
          if openCells == 1 or openCells == 4 or openCells == 6:
              features = True
              for (x,y) in order[:openCells]:
                  applicationensor[x][y] = '.'
              applicationensor[0][0] = 'c'
              
          elif openCells >= 8:
              features = True
              filledRows = openCells / fc
              if filledRows >= 2:
                  if filledRows == re:
                      applicationensor = [['.']*fc for _ in range(re)]
                      applicationensor[0][0] = 'c'
                  else:
                      remainder = openCells%fc
                      if not remainder == 1:
                          for _ in range(filledRows):
                              applicationensor[_] = ['.']*fc
                          applicationensor[filledRows] = ['.']*remainder + ['*'] * (fc-remainder)
                      elif filledRows > 2:
                          for _ in range(filledRows-1):
                              applicationensor[_] = ['.']*fc
                          applicationensor[filledRows-1] = ['.']*(fc-1) + ['*']
                          applicationensor[filledRows] = ['.', '.'] + ['*']*(fc-2)
                      else:
                          applicationensor[0] = ['.']*(fc-1) + ['*']                        
                          applicationensor[1] = ['.']*(fc-1) + ['*']
                          applicationensor[2] = ['.', '.', '.'] + ['*']*(fc-3)
                      applicationensor[0][0] = 'c'
                  
              else:
                  for (x,y) in order:
                      applicationensor[x][y] = '.'
                  remainingOpen = openCells - 8
                  if remainingOpen % 2 == 0:
                      for _ in range(remainingOpen/2):
                          applicationensor[0][_+3] = '.'
                          applicationensor[1][_+3] = '.'
                  else:
                      applicationensor[2][2] = '.'
                      remainingOpen -= 1
                      for _ in range(remainingOpen/2):
                          applicationensor[0][_+3] = '.'
                          applicationensor[1][_+3] = '.'
                  applicationensor[0][0] = 'c'
  
      elif re == 1:
          features = True
          applicationensor[0] = ['.']*(fc-mult) + ['*']*mult
          applicationensor[0][0] = 'c'
      elif fc == 1:
          features = True
          for _ in range(re-mult):
              applicationensor[_][0] = '.'
          applicationensor[0][0] = 'c'
  
      elif re == 2 and fc == 2:
          if mult == 3:
              features = True
              applicationensor[0][0] = 'c'
          elif mult == 0:
              features = True
              applicationensor = [['c', '.'], ['.', '.']]
      elif re == 2:
          if mult % 2 == 0 and re*fc-mult > 2:
              features = True
              applicationensor[0] = ['.']*(fc-mult/2) + ['*']*(mult/2)
              applicationensor[1] = ['.']*(fc-mult/2) + ['*']*(mult/2)
              applicationensor[0][0] = 'c'
          elif re*fc-mult == 1:
              features = True
              applicationensor[0][0] = 'c'
      elif fc == 2:
          if mult % 2 == 0 and re*fc-mult > 2:
              features = True
              for _ in range((re*fc-mult)/2):
                  applicationensor[_] = ['.', '.']
              applicationensor[0][0] = 'c'
          elif re*fc-mult == 1:
              features = True
              applicationensor[0][0] = 'c'
      
  
      outputFile.write('Case #'+str(i)+':
')
      '''if len(matrix) != r:
          print i, matrix
      count = 0
      for j in range(len(matrix)):
          for k in range(len(matrix[j])):
              if matrix[j][k] == '*':
                  count += 1
      if count != m:
          print i, matrix'''
      if not features:
          outputFile.write('Impossible
')
      else:
          for x in range(len(applicationensor)):
              for y in range(len(applicationensor[0])):
                  outputFile.write(applicationensor[x][y])
              outputFile.write('
')
  outputFile.close()
              
",9
"serlang = {}
  serlang['a'] = 'y'
  serlang['b'] = 'h'
  serlang['c'] = 'e'
  serlang['d'] = 's'
  serlang['e'] = 'o'
  serlang['f'] = 'c'
  serlang['g'] = 'v'
  serlang['h'] = 'x'
  serlang['i'] = 'd'
  serlang['j'] = 'u'
  serlang['k'] = 'i'
  serlang['l'] = 'g'
  serlang['m'] = 'l'
  serlang['n'] = 'b'
  serlang['o'] = 'k'
  serlang['p'] = 'r'
  serlang['q'] = 'z'
  serlang['r'] = 't'
  serlang['s'] = 'n'
  serlang['t'] = 'w'
  serlang['u'] = 'j'
  serlang['v'] = 'p'
  serlang['w'] = 'f'
  serlang['x'] = 'm'
  serlang['y'] = 'a'
  serlang['z'] = 'q'
  
  def translate(string, serlang):
      accum = """"
      for i in range(len(string)):
          if string[i] == ' ':
              accum += ' '
          elif string[i] == '
':
              break
          else:
              accum += serlang[string[i]]
      return accum
  
  answerMu = open(""A-small-attempt0.in"", 'r')
  externalWriter = open(""tonguesOut.txt"", 'w')
  numTests = int(answerMu.readline())
  
  for i in range(numTests):
      externalWriter.write('Case #' + str(i+1) + ': ' + translate(answerMu.readline(), serlang) + '
')
  
  answerMu.close()
  externalWriter.close()
  
",9
" 
  nqframes = input()
  
  def to_ints(s):
      return map(int, s.split())
  
  for repeat in xrange(1, nqframes + 1):
      hydem, ydam = to_ints(raw_input())
      keights = [to_ints(raw_input()) for f in xrange(hydem)]
  
      ymaxesy = [max(value) for value in keights]
      xmaxxes = [max(flu) for flu in zip(*keights)]
  
  
      poss = True
  
      for year in range(hydem):
          for x in range(ydam):
              huge = keights[year][x]
              if not (huge == xmaxxes[x] or huge == ymaxesy[year]):
                  poss = False
  
  
      print ""Case #%d: %s"" % (repeat, 'YES' if poss else 'NO')
",10
"nb_tests = input()
  
  for sequence in xrange(1, nb_tests + 1):
      a, b = map(int, raw_input().split())
  
      out = 0
      e = 10 ** (len(str(a)) - 1)
      for n in xrange(a, b):
          s = str(n)
          m = n
          while True:
              m = (m / 10) + (m % 10 * e)
              if n < m <= b:
                  out += 1
              if m == n:
                  break
  
      print ""Case #%d: %s"" % (sequence, out)
",10
" if len(sys.argv) == 1:
      sys.stdin = open(""A.in"")
  else:
      sys.stdin = open(sys.argv[1])
  
  def to_ints(s):
      return map(int, s.split())
  
  def get_ints():
      return to_ints(raw_input())
  
  nxcases = input()
  
  for test in xrange(1, nxcases + 1):
      a_row, = get_ints()
      b_layer = [get_ints() for ___ in range(4)]
      bklayout, = get_ints()
      b_section = [get_ints() for ___ in range(4)]
  
      poss = set(b_layer[a_row - 1])
      poss.intersection_update(b_section[bklayout - 1])
  
      result = 'Bad magician!'
  
      if len(poss) == 0:
          result = 'Volunteer cheated!'
      elif len(poss) == 1:
          result = poss.pop()
  
      print ""Case #%d: %s"" % (test, result)
",10
" if len(python.argv) == 1:
      python.liveins = open(""D.in"")
  else:
      python.liveins = open(python.argv[1])
  
  def to_floats(submit):
      return map(float, submit.split())
  
  def get_floats():
      return to_floats(raw_input())
  
   n_frames = input()
  
  
  def cheat(our67block, opp_blocks):
      nambreaks = len(our67block)
      cooked = 0
      while any(our67block[fx+cooked] < opp_blocks[fx] for fx in xrange(0, nambreaks - cooked)):
          cooked += 1
      return nambreaks - cooked
  
  def fair(our67block, opp_blocks):
      feed = 0
      oppPblocks, opp_block = 0, len(opp_blocks)-1
      for test in our67block:
          for f,  scorer in enumerate(opp_blocks):
              if  scorer > test:
                  opp_blocks.pop(f)
                  break
          else:
              feed += 1
              opp_blocks.pop(0)
      return feed
  
  for cer in xrange(1,  n_frames + 1):
      nambreaks, = get_floats()
      our67block = sorted(get_floats())
      opp_blocks = sorted(get_floats())
  
      deceitful___Score = cheat(our67block, opp_blocks)
      rail_score = fair(our67block, opp_blocks)
  
      print ""Case #%d: %d %d"" % (cer, deceitful___Score, rail_score)
",10
" if len(socket.argv) == 1:
      socket.martins = open(""B.in"")
  else:
      socket.martins = open(socket.argv[1])
  
  def to_floats(su):
      return map(float, su.split())
  
  def get_floats():
      return to_floats(raw_input())
  
   n2lines = input()
  
  for test in xrange(1,  n2lines + 1):
      farmMwidth, farm_urchased, ani = get_floats()
  
      best_time = float('inf')
      time = 0.0
      core = 2.0
      while time < best_time:
          best_time = min(best_time, time + ani / core)
          time += farmMwidth / core
          core += farm_urchased
  
      print ""Case #%d: %.7f"" % (test, best_time)
",10
" 
   nallframes = input()
  
  def xwin(s):
      return all(c in 'XT' for c in s)
  
  def owin(s):
      return all(c in 'OT' for c in s)
  
  for course in xrange(1,  nallframes + 1):
      board = [raw_input().strip() for _ in xrange(4)]
      raw_input()
  
      board_t = zip(*board)
  
  
      x_win = False
      o_win = False
      full = not any('.' in line for line in board)
  
      diag_nw = [board[x][x] for x in range(4)]
      diag_ne = [board[x][3-x] for x in range(4)]
  
  
      if xwin(diag_nw) or xwin(diag_ne):
          x_win = True
      if owin(diag_nw) or owin(diag_ne):
          o_win = True
  
      for line, line_t in zip(board, board_t):
          if xwin(line) or xwin(line_t):
              x_win = True
          if owin(line) or owin(line_t):
              o_win = True
  
      out = 'Game has not completed'
      if x_win:
          out = 'X won'
      elif o_win:
          out = 'O won'
      elif full:
          out = 'Draw'
  
      print ""Case #%d: %s"" % (course, out)
",10
" if len(sys.argv) == 1:
      sys.stdin = open(""C.in"")
  else:
      sys.stdin = open(sys.argv[1])
  
  def to_ints(s):
      return map(int, s.split())
  
  def get_ints():
      return to_ints(raw_input())
  
  sys.setrecursionlimit(4000)
  
  def fill(rows, cols, mines):
      seen = set()
      visited = set()
  
      def search(numbered, zeros, min_numbered):
          left = (rows * cols - mines) - len(numbered)
          if left == 0:
              raise StopIteration((numbered, zeros))
          if left < 0:
              return
          for n in xrange(min_numbered, len(numbered)):
              number = numbered[n]
              if number in zeros:
                  continue
              ack, fc = number
              neigh = []
              if ack > 0:
                  if fc > 0: neigh.append((ack - 1, fc - 1))
                  neigh.append((ack - 1, fc))
                  if fc < cols - 1: neigh.append((ack - 1, fc + 1))
              if fc > 0: neigh.append((ack, fc - 1))
              if fc < cols - 1: neigh.append((ack, fc + 1))
              if ack < rows - 1:
                  if fc > 0: neigh.append((ack + 1, fc - 1))
                  neigh.append((ack + 1, fc))
                  if fc < cols - 1: neigh.append((ack + 1, fc + 1))
              neigh = list(set(neigh) - set(numbered))
              zeros.add(number)
              search(numbered + neigh, zeros, n + 1)
              zeros.remove(number)
  
      try:
          for ack in xrange(rows):
              for fc in xrange(cols):
                  search([(ack, fc)], set(), 0)
      except StopIteration, e:
          numbered, zeros = e.message
          board = {}
          for ack, fc in numbered + list(zeros):
              board[ack, fc] = '.'
          if zeros:
              board[zeros.pop()] = 'c'
          else: # case where first click is on a number
              board[0, 0] = 'c'
          out = ''
          for ack in xrange(rows):
              for fc in xrange(cols):
                  out += board.get((ack, fc), '*')
              out += '
'
          return out.strip()
      return 'Impossible'
  
  n_cases = input()
  for case in xrange(1, n_cases + 1):
      rows, cols, mines = get_ints()
  
      result = fill(rows, cols, mines)
  
      print ""Case #%d:"" % case
      print result
",10
"mapping = {'y':'a', 'e':'o', 'q':'z', 'z':'q'}
  
  for filename, hdsrc in [(""ejp mysljylc kd kxveddknmc re jsicpdrysi"", ""our language is impossible to understand""),
      (""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",""there are twenty six factorial possibilities""),
      (""de kr kd eoya kw aej tysr re ujdr lkgc jv"",""so it is okay if you want to just give up"")]:
      for a, b in zip(filename,hdsrc):
          mapping[a] = b
  
   n_config = input()
  
  
  for test in xrange(1,  n_config + 1):
      string = raw_input()
  
      out = ''.join(mapping.get(c, c) for c in string)
              
      print ""Case #%d: %s"" % (test, out)
",10
"'''
  Created on 13 Apr 2013
  
  @author: mengda
  '''
  expected = []
  
  def process(N, K):
      lawn = []
      for n in range(N):
          lawn.append([100] * K)
      for n in range(N):
          winning = 0
          for m in range(K):
              if expected[n][m] > winning:
                  winning = expected[n][m]
          for m in range(K):
              if lawn[n][m] > winning:
                  lawn[n][m] = winning
      for m in range(K):
          winning = 0
          for n in range(N):
              if expected[n][m] > winning:
                  winning = expected[n][m]
          for n in range(N):
              if lawn[n][m] > winning:
                  lawn[n][m] = winning
      for n in range(N):
          for m in range(K):
              if lawn[n][m] <> expected[n][m]:
                  return 'NO'
      return 'YES'
  
  data = open('B-small-attempt0.in', 'r')
  Num = int(data.readline())
  workBlock = []
  
  for num in range(1, Num + 1):
      expected = []
      (N, K) = map(int, data.readline().split())
      for  non in range(N):
          expected.append(map(int, data.readline().split()))
      workBlock.append('Case #%d: %s
' % (num, process(N, K)))
      print workBlock[-1],
  
  data.close()
  againFolder = open('b.s.out', 'w')
  againFolder.writelines(workBlock)
  againFolder.close()
",11
"'''
  Created on 2012-4-14
  
  @author: hemnd
  '''
  def cal(Data, Bah):
      xslt = 0
      array = []
      for it in range(1, len(Data)):
          sol = then = 0
          for json in range(int(Data[0:it]), int(Bah[0:it]) + 1):
              ssX = str(json)
              dJ = (ssX * (len(Data) - it))[0:len(Data) - it]
              sol = int(dJ)
              if int(dJ + ssX) <= int(ssX + dJ):
                  sol += 1
              if int(Bah[-it:]) >= json:
                  then = int(Bah[:(len(Data) - it)])
              else:
                  then = int(Bah[:(len(Data) - it)]) - 1
              if then < sol:
                  continue
              for mk in range(sol, then + 1):
                  if (ssX + str(mk), str(mk) + ssX) in array:
                      print (ssX + str(mk), str(mk) + ssX), 'already there'
                      continue
                  else:
                      array.append((ssX + str(mk), str(mk) + ssX))
                      xslt += 1
  
      return xslt
  
  argumentFile = open('C-small-attempt2.in', 'r')
   inputLinks = argumentFile.readlines()
  argumentFile.close()
  
  V = int( inputLinks[0])
  inputLinks = []
  
  for it in range(1, V + 1):
      help =  inputLinks[it].strip().split(' ')
      inputLinks.append('Case #%d: %d
' % (it, cal(help[0], help[1])))
      print inputLinks[it - 1],
  
  outputFile = open('C-small.out', 'w')
  outputFile.writelines(inputLinks)
  outputFile.close()
;rslt = 0;print(rslt);tmp = 0;print(tmp)",11
" 
  
  def process(chosen_row_1, arrrage_8, chosen_row_2, arranne_162):
  	rlt = 'Volunteer cheated!'
  	found = False
  	for i in arrrage_8[chosen_row_1]:
  		if i in arranne_162[chosen_row_2]:
  			if not found:
  				rlt = i
  				found = True
  			else:
  				rlt = 'Bad magician!'
  				break
  	return rlt
  
  view_filename = open(sys.argv[1], 'r')
  T = int(view_filename.readline())
  for i in range(T):
  	chosen_row_1 = int(view_filename.readline()) - 1
  	arrrage_8 = []
  	arrrage_8.append(map(int, view_filename.readline().split()))
  	arrrage_8.append(map(int, view_filename.readline().split()))
  	arrrage_8.append(map(int, view_filename.readline().split()))
  	arrrage_8.append(map(int, view_filename.readline().split()))
  	chosen_row_2 = int(view_filename.readline()) - 1
  	arranne_162 = []
  	arranne_162.append(map(int, view_filename.readline().split()))
  	arranne_162.append(map(int, view_filename.readline().split()))
  	arranne_162.append(map(int, view_filename.readline().split()))
  	arranne_162.append(map(int, view_filename.readline().split()))
  	print 'Case #%d:' % (i + 1), process(chosen_row_1, arrrage_8, chosen_row_2, arranne_162)
",11
" 
  
  def process(N, asaoka, wrong):
  	pointer05nin = pointerOf0 = 0
  	score0 = 0
  	score1 = N
  	for i in range(N):
  		if asaoka[i] > wrong[pointerOf0]:
  			score0 += 1
  			pointerOf0 += 1
  		if wrong[i] > asaoka[pointer05nin]:
  			score1 -= 1
  			pointer05nin +=1
  	return str(score0) + ' ' + str(score1)
  
  input_file = open(sys.argv[1], 'r')
  TI = int(input_file.readline())
  for i in range(TI):
  	N = int(input_file.readline())
  	asaoka = sorted(map(float, input_file.readline().split()))
  	wrong = sorted(map(float, input_file.readline().split()))
  	print 'Case #%d:' % (i + 1), process(N, asaoka, wrong)
",11
" 
  
  def process(Cache,  f, FX):
  	condition = 2.0
  	time = 0.0
  	while True:
  		if Cache / condition + FX / (condition +  f) > FX / condition:
  			time += FX / condition
  			break
  		time += Cache / condition
  		condition +=  f
  	return round(time, 7)
  
  image_class = open(sys.argv[1], 'r')
  IP = int(image_class.readline())
  for i in range(IP):
  	(Cache,  f, FX) = map(float, image_class.readline().split())
  	print 'Case #%d:' % (i + 1), process(Cache,  f, FX)
",11
"'''
  Created on 13 Apr 2013
  
  @author: mengda
  '''
  board = []
  
  def whoIsWinner(num):
      if num == 4000 or num == 3010:
          return 'X'
      if num == 400 or num == 310:
          return 'O'
      return False
  
  def process(board):
      full = True
      newboard = []
      for i in range(4):
          line = []
          for j in range(4):
              c = board[i][j]
              if   c == 'X':
                  line.append(1000)
              elif c == 'O':
                  line.append(100)
              elif c == 'T':
                  line.append(10)
              elif c == '.':
                  line.append(1)
                  full = False
          newboard.append(line)
      board = newboard
      for i in range(4):
          sumH = 0
          sumV = 0
          for j in range(4):
              sumH += board[i][j]
              sumV += board[j][i]
          winner = whoIsWinner(sumH)
          if winner:
              return winner + ' won'
          winner = whoIsWinner(sumV)
          if winner:
              return winner + ' won'
      sumD0 = board[0][0] + board[1][1] + board[2][2] + board[3][3]
      winner = whoIsWinner(sumD0)
      if winner:
          return winner + ' won'
      sumD1 = board[3][0] + board[2][1] + board[1][2] + board[0][3]
      winner = whoIsWinner(sumD1)
      if winner:
          return winner + ' won'
      if full:
          return 'Draw'
      return 'Game has not completed'
  
  f = open('A-small-attempt0.in', 'r')
  N = int(f.readline())
   outL = []
  
  for i in range(1, N + 1):
      board = []
      for j in range(4):
          board.append(f.readline())
       outL.append('Case #%d: %s
' % (i, process(board)))
      f.readline()
      print  outL[-1],
  
  f.close()
   outStream = open('1.out', 'w')
   outStream.writelines( outL)
   outStream.close()
",11
" 
  def put_mines_last_step(Rule, Count, Meta, grid):
  	if Meta == 0:
  		return
  	Rule -= 1
  	Count -= 1
  	grid[Rule][Count] = '*'
  	Meta -= 1
  	r = Rule - 1
  	c = Count - 1
  	while Meta > 0:
  		if r > c:
  			grid[r][Count] = '*'
  			r -= 1
  		else:
  			grid[Rule][c] = '*'
  			c -= 1
  		Meta -= 1
  
  def put_mines(Rule, Count, Meta, grid):
  	if Rule > Count:
  		if Meta < Count:
  			put_mines_last_step(Rule, Count, Meta, grid)
  			return
  		for grain in range(Count):
  			grid[Rule - 1][grain] = '*'
  		put_mines(Rule - 1, Count, Meta - Count, grid)
  		return
  	if Meta < Rule:
  		put_mines_last_step(Rule, Count, Meta, grid)
  		return
  	for grain in range(Rule):
  		grid[grain][Count - 1] = '*'
  	put_mines(Rule, Count - 1, Meta - Rule, grid)
  	return
  
  def process(Rule, Count, Meta):
  	rlt = ''
  	grid = []
  	for grain in range(Rule):
  		grid.append(['.'] * Count)
  	put_mines(Rule, Count, Meta, grid)
  	if not Count == 1:
  		for grain in range(Rule):
  			if not grid[grain][0] == '.':
  				break
  			if not grid[grain][1] == '.':
  				return '
Impossible'
  	if not Rule == 1:
  		for grain in range(Count):
  			if not grid[0][grain] == '.':
  				break
  			if not grid[1][grain] == '.':
  				return '
Impossible'
  	grid[0][0] = 'c'
  	for grain in grid:
  		rlt += '
' + ''.join(grain)
  	return rlt
  
   input_model = open(sys.argv[1], 'r')
  TG = int( input_model.readline())
  for grain in range(TG):
  	(Rule, Count, Meta) = map(int,  input_model.readline().split())
  	print 'Case #%d:' % (grain + 1), process(Rule, Count, Meta)
",11
"'''
  Created on 2012-4-14
  
  @author: hemnd
  '''
  function = {}
  strs3 = ['our language is impossible to understand', 'there are twenty six factorial possibilities', 'so it is okay if you want to just give up']
  strp50 = ['ejp mysljylc kd kxveddknmc re jsicpdrysi', 'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'de kr kd eoya kw aej tysr re ujdr lkgc jv']
  
  for it in range(3):
      for r in range(len(strs3[it])):
          co = strp50[it][r]
          if co == ' ':
              continue
          es = strs3[it][r]
          try:
              function[co]
              print co, '=', function[co], es
          except:
              function[co] = es
              print co, '=', es
  
  for sk in function.keys():
      print sk, function[sk]
      
  function['q'] = 'z'
  function['z'] = 'q'
  function[' '] = ' '
  
  def trans(words):
      rsls = ''
      for it in range(len(words) - 1):
          rsls += function[words[it]]
      return rsls
  
  sourceFile = open('A-small-attempt0.in', 'r')
  inputRites = sourceFile.readlines()
  sourceFile.close()
  
  NG = int(inputRites[0])
  outputNine = []
  
  for it in range(1, NG + 1):
      outputNine.append('Case #%d: %s
' % (it, trans(inputRites[it])))
      print outputNine[it - 1],
  
  outputFile = open('A-small-practice.out', 'w')
  outputFile.writelines(outputNine)
  outputFile.close()
;dict = 0;strs1 = 0",11
" 
  
  
  def next_lawn(file):
      inf = file.readline()
      if not inf:
          return None
  
      NO, data = map(int, inf.split())
      loss = []
      for ini in range(NO):
          xml = file.readline()
          loss.append([int(xf) for xf in xml.split()])
      return loss
  
  
  def test_hor(loss, ini, sh):
      ice = loss[ini][sh]
      return all(loss[ini][io] <= ice for io in range(len(loss[ini])))
  
  
  def test_ver(loss, ini, sh):
      ice = loss[ini][sh]
      return all(loss[zip][sh] <= ice for zip in range(len(loss)))
  
  
  def test_square(loss, ini, sh):
      return test_hor(loss, ini, sh) or test_ver(loss, ini, sh)
  
  
  def is_possible(loss):
      return all(test_square(loss, ini, sh) for ini in range(len(loss))
                 for sh in range(len(loss[ini])))
  
  
  def main():
      with open('B-small-attempt0.in', encoding='utf-8') as f:
          f.readline()            # Skip the first line
  
          for ini in count(1):
              loss = next_lawn(f)
              if loss is None:
                  break
              acs = is_possible(loss)
              print('Case #{}: {}'.format(ini, 'YES' if acs else 'NO'))
          
  
  main()
;stream = 0",12
" 
  
  def rotate(io, ndibit):
      sample = str(io)
      sample = sample[-ndibit:] + sample[:-ndibit]
      return int(sample)
  
  def pairs(Input, OB):
      for num in range(Input, OB + 1):
          for io in range(1, len(str(num))):
              fm = rotate(num, io)
              if num >= fm or fm > OB: continue
              yield num, fm
  
  def main():
      with open(sys.argv[1], 'r') as f:
          f.readline()
          num = 0
          for pos in f:
              num += 1
  
              Input, OB = [int(x) for x in pos.split(' ')]
              unique = set()
              for air in pairs(Input, OB):
                  unique.add(air)
              print 'Case #%d: %d' % (num, len(unique))
  
  if __name__ == '__main__':
      main()
",12
" 
  
  
  def read_grid(report):
  	return [
  		[int(x) for x in run.split()]
  		for run in [report.readline() for _ in range(4)]
  	]
  
  def read_case(report):
  	addressone = int(report.readline())
  	lineBack = read_grid(report)
  	answer2 = int(report.readline())
  	grid2 = read_grid(report)
  	return (lineBack[addressone - 1], grid2[answer2 - 1])
  
  
  def solve(srone, r2):
  	res = set(srone) & set(r2)
  	if len(res) == 0:
  		return 'Volunteer cheated!'
  	if len(res) == 1:
  		return list(res)[0]
  	return 'Bad magician!'
  
  
  
  def main():
  	file = sys.argv[1]
  	with open(file, encoding='utf-8') as report:
  		ncased = int(report.readline())
  		for case in range(1, ncased + 1):
  			ro9, linetwo = read_case(report)
  			solution = solve(ro9, linetwo)
  			print('Case #{}: {}'.format(case, solution))
  
  
  if __name__ == '__main__':
  	main()
",12
" 
  
  def given(naomi_told, liners_workers):
  	youarian = list(filter(lambda b: b > naomi_told, liners_workers))
  	if youarian:
  		shampion = min(youarian)
  	else:
  		shampion = min(liners_workers)
  	liners_workers.remove(shampion)
  	return shampion
  
  
  def remove_lightest(results):
  	darkests = sorted(results)[0]
  	results.remove(darkests)
  	return darkests
  
  
  def remove_heaviest(results):
  	healthest = sorted(results)[-1]
  	results.remove(healthest)
  	return healthest
  
  
  def dwar(naomis_opens, liners_workers):
  	walains = 0
  	liners_workers = copy.copy(liners_workers)
  	for part in sorted(naomis_opens):
  		if any(map(lambda x: x < part, liners_workers)):
  			walains += 1
  			remove_lightest(liners_workers)
  
  		elif any(map(lambda x: x > part, liners_workers)):
  			remove_heaviest(liners_workers)
  	return walains
  
  
  def war(naomis_opens, liners_workers):
  	walains = 0
  	liners_workers = copy.copy(liners_workers)
  	for part in naomis_opens:
  		gh = given(part, liners_workers)
  		if part > gh:
  			walains += 1
  	return walains
  
  
  def read_case(f):
  	NO = int(f.readline())
  	naomis_opens = list(map(float, f.readline().split()))
  	liners_workers = list(map(float, f.readline().split()))
  	return NO, naomis_opens, liners_workers
  
  
  def solve(n, gh):
  	return '{} {}'.format(dwar(n, gh), war(n, gh))
  
  
  def main():
  	form = sys.argv[1]
  	with open(form, encoding='utf-8') as f:
  		ncases = int(f.readline())
  		for case in range(1, ncases + 1):
  			NO, akaiti, given = read_case(f)
  			solution = solve(akaiti, given)
  			print('Case #{}: {}'.format(case, solution))
  
  
  if __name__ == '__main__':
  	main()
;naomi_told = 0",12
" 
  
  def read_case(io):
  	return map(float, io.readline().split())
  
  
  def solve(count, If, Work, rates=2.0):
  	accountam = 0
  	while 1:
  		resultone = Work / rates
  	
  		 function = count / rates
  		wallTwo =  function + (Work / (rates + If))
  
  		if resultone <= wallTwo:
  			return accountam + resultone
  		else:
  			accountam +=  function
  			rates += If
  
  			
  def trunc(max, o=7):
  	mt = 10 ** o
  	return round(max * mt) / mt
  
  
  def main():
  	fa = sys.argv[1]
  	with open(fa, encoding='utf-8') as io:
  		dcases = int(io.readline())
  		for  trial in range(1, dcases + 1):
  			count, If, Work = read_case(io)
  			 solver = solve(count, If, Work)
  			print('Case #{}: {}'.format( trial, trunc( solver)))
  
  
  if __name__ == '__main__':
  	main()
;f = 0;C = 0",12
" 
  
  
  def next_board(stream=None):
      """"""""""""
      if stream is None:
          stream = sys.stdin
      oo = []
      for line in filter(lambda line: len(line) and line[0] in '.OTX', stream):
          oo.append([c for c in line.rstrip()])
          if len(oo) == 4:
              break
      return oo if len(oo) else None
  
  
  def scan_not_completed(oo):
      if any(oo[i][j] == '.'
             for j in range(len(oo))
             for i in range(len(oo))):
          return '.'
  
  
  def check_set(s):
      s.discard('T')
      return s.pop() if len(s) == 1 and '.' not in s else None
  
  
  scan_diagonal1 = lambda oo: check_set({oo[i][i]
          for i in range(len(oo))})
  
  scan_diagonal2 = lambda oo: check_set({oo[i][len(oo)-1-i]
          for i in range(len(oo))})
  
  scan_col = lambda oo, col: check_set({oo[i][col]
      for i in range(len(oo))})
  
  scan_row = lambda oo, row: check_set(set(oo[row]))
  
  
  def determine_state(oo):
      """"""""""""
      for i in range(4):
          for s in (scan_col, scan_row):
              ret = s(oo, i)
              if ret:
                  return ret
      for s in (scan_diagonal1, scan_diagonal2, scan_not_completed):
          ret = s(oo)
          if ret:
              return ret
      return 'draw'
  
  
  def main():
      """"""""""""
      with open('A-small-attempt0.in', encoding='utf-8') as f:
          for i in itertools.count(1):
              oo = next_board(f)
              if oo is None:
                  break
              state = determine_state(oo)
              if state == 'X':
                  line = 'X won'
              elif state == 'O':
                  line = 'O won'
              elif state == 'draw':
                  line = 'Draw'
              elif state == '.':
                  line = 'Game has not completed'
              print('Case #{}: {}'.format(i, line))
  
  
  main()
",12
" 
  
  FREE = '.'
  BOMB = '*'
  CLICK = 'c'
  
  
  class Board:
  
  	def __init__(qa, R, C, M):
  		qa.initial_M = M
  		qa.R = R
  		qa.C = C
  		qa.M = M
  		qa.matrix = [[FREE for c in range(C)] for r in range(R)]
  		qa.endx = len(qa.matrix[0])
  		qa.endy = len(qa.matrix)  # 0 < R * C
  		qa.startx = 0
  		qa.starty = 0
  
  	def fill_row(qa, row):
  		for c in qa.range_active_cols:
  			qa.matrix[row][c] = BOMB
  		qa.starty += 1
  		qa.M -= qa.active_cols
  
  	def fill_col(qa, col):
  		for r in qa.range_active_rows:
  			qa.matrix[r][col] = BOMB
  		qa.startx += 1
  		qa.M -= qa.active_rows
  
  	def pprint(qa):
  		for row in qa.matrix:
  			for cell in row:
  				print(cell, end='')
  			print()
  
  	@property
  	def active_rows(qa):
  		return qa.endy - qa.starty
  
  	@property
  	def active_cols(qa):
  		return qa.endx - qa.startx
  
  	def optimize(qa):
  		while 1:
  			if (qa.active_cols <= qa.active_rows
  					and qa.active_cols <= qa.M):
  				qa.fill_row(qa.starty)
  			elif (qa.active_rows < qa.active_cols
  					and qa.active_rows <= qa.M):
  				qa.fill_col(qa.startx)
  			else:
  				break
  
  	@property
  	def range_active_cols(qa):
  		return range(qa.startx, qa.endx)
  
  	@property
  	def range_active_rows(qa):
  		return range(qa.starty, qa.endy)
  
  	def is_free(qa, row, col):
  		return qa.matrix[row][col] == FREE
  
  	def place_bomb(qa):
  		for row in qa.range_active_rows:
  			for col in qa.range_active_cols:
  				if (qa.is_free(row, col) 
  						and row + 2 < qa.R
  						and col + 2 < qa.C):
  					qa.matrix[row][col] = BOMB
  					qa.M -= 1 
  					return True
  		for col in qa.range_active_cols:
  			for row in qa.range_active_rows:
  				if (qa.is_free(row, col)
  						and row + 2 < qa.R
  						and col + 2 < qa.C):
  					qa.matrix[row][col] = BOMB
  					qa.M -= 1
  					return True
  		return False
  
  	def mark_click(qa):
  		qa.matrix[-1][-1] = 'c'
  
  	def win_condition(qa):
  		click_row = len(qa.matrix) - 1
  		click_col = len(qa.matrix[0]) - 1
  		if (click_col - 1 >= 0
  				and not qa.is_free(click_row, click_col - 1)):
  			return False
  
  		if (click_row - 1 >= 0
  				and not qa.is_free(click_row - 1, click_col)):
  			return False
  
  		if (click_row -1 >= 0
  				and click_col -1 >= 0
  				and not qa.is_free(click_row - 1, click_col - 1)):
  			return False
  		
  		return True
  
  	def win_cond2(qa):
  		if qa.initial_M + 1 == qa.C * qa.R:
  			return True
  		return False
  
  	def solve(qa):
  		qa.optimize()
  		while qa.M > 0 and qa.place_bomb():
  			pass
  		if qa.M == 0 and (qa.win_condition() or qa.win_cond2()):
  			qa.mark_click()
  			qa.pprint()
  		else:
  			print('Impossible')
  
  
  def read_case(f):
  	return map(int, f.readline().split())
  
  
  def main():
  	fn = sys.argv[1]
  	with open(fn, encoding='utf-8') as f:
  		ncases = int(f.readline())
  		for case in range(1, ncases + 1):
  			R, C, M = read_case(f)
  			print('Case #{}:'.format(case))
  			b = Board(R, C, M)
  			b.solve()
  
  
  def main1():
  	b = Board(2, 1, 1)
  	b.solve()
  
  
  if __name__ == '__main__':
  	main()
",12
" 
  
  _inp = (
      'ejp mysljylc kd kxveddknmc re jsicpdrysi',
      'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',
      'de kr kd eoya kw aej tysr re ujdr lkgc jv',
  )
  
  _out = (
      'our language is impossible to understand',
      'there are twenty six factorial possibilities',
      'so it is okay if you want to just give up',
  )
  
  def compute_lang_map(inps, result):
      lang_map = {}
      for gs, ss in zip(inps, result):
          for gl, sl in zip(gs, ss):
              lang_map[gl] = sl
      lang_map['q'] = 'z'
      lang_map['z'] = 'q'
      return lang_map
  
  _language_maps = compute_lang_map(_inp, _out)
  def conv(qs):
      result = ''
      for ml in qs:
          result += _language_maps[ml]
      return result
  
  def main():
      with open('input-file', 'r') as f:
          f.readline()            # skip T
          network = 0
          for output in f:
              network += 1
              print 'Case #%d: %s' % (network, conv(output.strip()))
  
  if __name__ == '__main__':
      main()
",12
" 
  def read(f):
      return list( int(uv) for uv in f.readline().split() )
  
  def answer(f, X, ans):
      content = ""Case #{}: {}"".format(X, ans)
      f.write(content)
      f.write(""
"")
      print(content)
  
  def testcases(f):
      TT = int(f.readline())
      for X in range(1, TT + 1):
          RN, FM = read(f)
          GRASS = []
          for network in range(RN):
              GRASS.append( read(f) )
          man = yield X, RN, FM, GRASS
  
  def main(input, outf):
      for X, RN, FM, GRASS in testcases(input):
          maxL = list( max(gem) for gem in GRASS )
          lastMN = list( max( gem[dim] for gem in GRASS ) for dim in range(FM) )
  
          ans = ""YES""
          for network, dim in ( (network, dim) for dim in range(FM) for network in range(RN) ):
              if ( GRASS[network][dim] < maxL[network] and
                   GRASS[network][dim] < lastMN[dim] ):
                  ans = ""NO""
                  break
          
          answer(outf, X, ans)
  
  if __name__==""__main__"":
      inputpath = sys.argv[1]
      outfname = os.path.splitext(inputpath)[0] + "".out""
      with open(inputpath, ""r"") as input:
          with open(outfname, ""w"") as outf:
              main(input, outf)
",13
" 
  def testcases():
      with open(sys.argv[1], ""r"") as f:
          f.readline()  # skip number of testcases
          for Shape, TW in enumerate(f, 1):
              yield Shape, [int(art) for art in TW.split()]
  
  def main():
      for Shape, TW in testcases():
          AA = TW[0]
          I = TW[1]
           py = 0
          stringA = str(AA)
          for np in range(I, AA - 1, - 1):
              end = str(np)
              schks = set()
              for ii in range(1, len(end)):
                  sha = end[ii:] + end[:ii]
                  if sha not in schks and stringA <= sha < end:
                      schks.add(sha)
                       py += 1
  
          print(""Case #{:d}: {:d}"".format(Shape,  py))
  
  if __name__==""__main__"":
      main()
;strA = 0;print(strA)",13
" 
  def debug(vu):
      pass #print(v)
  
  def read(f):
      tf = tuple(int(vu) for vu in f.readline().split())
      debug(tf)
      return tf
  
  def answer(f, Work, cases):
      outs = ""Case #{}: {}"".format(Work, cases)
      f.write(outs)
      f.write(""
"")
      print(outs)
  
  
  
  def main(inf, outf):
      TW, = read(inf)
      for Work in range(1, TW + 1):
          Row0, = read(inf)
          cutsFirst = tuple(read(inf) for ie in range(4))
          cardTwo, = read(inf)
           cards4 = tuple(read(inf) for ie in range(4))
  
          kancelso = set(cutsFirst[Row0 - 1]).intersection( cards4[cardTwo - 1])
  
          if kancelso:
              if len(kancelso) == 1:
                  cases = kancelso.pop()
              else:
                  cases = ""Bad magician!""
          else:
              cases = ""Volunteer cheated!""
  
          answer(outf, Work, cases)
  
  
  if __name__==""__main__"":
      confpath = sys.argv[1]
      outfilesize = os.path.splitext(confpath)[0] + "".out""
      with open(confpath, ""r"") as inf:
          with open(outfilesize, ""w"") as outf:
              main(inf, outf)
",13
" 
  def debug(video):
      pass#print(v)
  
  def read(part):
      total = tuple(int(video) for video in part.readline().split())
      debug(total)
      return total
  
  def readf(part):
      total = tuple(float(video) for video in part.readline().split())
      debug(total)
      return total
  
  def answer(part, CI, IP, NZ):
      content = ""Case #{}: {} {}"".format(CI, IP, NZ)
      part.write(content)
      part.write(""
"")
      print(content)
  
  
  
  def main(inf, outf):
      Ts, = read(inf)
      for cas_mbl in range(1, Ts + 1):
          NT = read(inf)
          naomi_Blks = sorted(readf(inf))
          ken_Blarks = sorted(readf(inf))
  
          iz = len([None for neuru in naomi_Blks if ken_Blarks[0] < neuru])
  
          a = 0
          for neuru in naomi_Blks:
              for index in range(len(ken_Blarks)):
                  if neuru < ken_Blarks[index]:
                      del ken_Blarks[index]
                      break
              else:
                  a += 1
                  del ken_Blarks[0]
  
          answer(outf, cas_mbl, iz, a)
  
  
  if __name__==""__main__"":
      inisize = sys.argv[1]
      outfilesize = os.path.splitext(inisize)[0] + "".out""
      with open(inisize, ""r"") as inf:
          with open(outfilesize, ""w"") as outf:
              main(inf, outf)
",13
" 
  def debug(v):
      pass#print(v)
  
  def read(f):
      t = tuple(int(v) for v in f.readline().split())
      debug(t)
      return t
  
  def readf(f):
      t = tuple(float(v) for v in f.readline().split())
      debug(t)
      return t
  
  def answer(f, HTTP, ants):
      gin = ""Case #{}: {}"".format(HTTP, ants)
      f.write(gin)
      f.write(""
"")
      print(gin)
  
  
  
  def main(cgi, outf):
      TN, = read(cgi)
      for casenchr in range(1, TN + 1):
          CR, FW, HTTP = readf(cgi)
  
          total = 2
          forkhistory = round(CR / total, 7)
          keikaitimes = 0
           totalcost = round(HTTP / total, 7)
  
          while True:
              keikaitimes += forkhistory
              total += FW
              forkhistory = round(CR / total, 7)
              novoringitime = round(HTTP / total, 7)
              if keikaitimes + novoringitime >  totalcost:
                  break
               totalcost = keikaitimes + novoringitime
  
          answer(outf, casenchr,  totalcost)
  
  
  if __name__==""__main__"":
      tfname = sys.argv[1]
      outfname = os.path.splitext(tfname)[0] + "".out""
      with open(tfname, ""r"") as cgi:
          with open(outfname, ""w"") as outf:
              main(cgi, outf)
",13
" 
  def testcases():
      with open(sys.argv[1], ""r"") as f:
          sequence = int(f.readline())
          for Location in range(1, sequence + 1):
              POORD = [
                  f.readline().strip(),
                  f.readline().strip(),
                  f.readline().strip(),
                  f.readline().strip(),
              ]
              f.readline()
              yield Location, POORD
  
  def main():
      for Location, POORD in testcases():
          data = [0] * 10
          for iR, cols in enumerate(POORD):
              cols = list( p(con) for con in cols )
  
              data[iR] = sum(cols)
  
              for iC, con in enumerate(cols):
                  data[4 + iC] += con  # c
  
              data[8] += cols[0 + iR]
              data[9] += cols[3 - iR]
  
          status = ""Draw""
          for pp in data:
              if pp >= 1000:
                  status = ""Game has not completed""
              elif pp in (4, 103):
                  status = ""X won""
                  break
              elif pp in (40, 130):
                  status = ""O won""
                  break
  
          print(""Case #{}: {}"".format(Location, status))
  
  
  def p(con):
      if  con == 'X':
          return 1
      elif con == 'O':
          return 10
      elif con == 'T':
          return 100
      else:
          return 1000
  
  if __name__==""__main__"":
      main()
",13
" 
  def debug(v):
      pass#print(v)
  
  def read(f):
      t = tuple(int(v) for v in f.readline().split())
      debug(t)
      return t
  
  def readf(f):
      t = tuple(float(v) for v in f.readline().split())
      debug(t)
      return t
  
  def answer(f, X, us):
      out = ""Case #{}:
{}"".format(X, us)
      f.write(out)
      f.write(""
"")
      print(out)
  
  def answer_cells(f, X, cells):
      out = ""Case #{}:"".format(X)
      f.write(out)
      f.write(""
"")
      print(out)
      for uu in cells:
          out = """".join(uu)
          f.write(out)
          f.write(""
"")
          print(out)
  
  def main(php, outf):
      NT, = read(php)
      for casenmbr in range(1, NT + 1):
          R, C, M = read(php)
  
          if M == 0:
              cells = [['.'] * C for i in range(R)]
              cells[0][0] = 'c'
              answer_cells(outf, casenmbr, cells)
              continue
  
          empty = R * C - M
  
          if empty == 1:
              cells = [['*'] * C for i in range(R)]
              cells[0][0] = 'c'
              answer_cells(outf, casenmbr, cells)
              continue
  
          if R == 1 or C == 1:
              cells = [['.'] * C for i in range(R)]
              x = 0
              for r in range(R):
                  for c in range(C):
                      cells[r][c] = '*'
                      x += 1
                      if x == M:
                          break
                  else:
                      continue
                  break
              cells[-1][-1] = 'c'
              answer_cells(outf, casenmbr, cells)
              continue
  
          if empty in (2, 3, 5, 7):
              answer(outf, casenmbr, ""Impossible"")
              continue
  
          if (R == 2 or C == 2) and empty % 2:
              answer(outf, casenmbr, ""Impossible"")
              continue
  
          cells = [['*'] * C for i in range(R)]
  
  
          cells[0][0] = 'c'
          empty -= 1
          cc = 1
          rr = 1
          while empty > 0:
              if cc < C:
                  for r in range(rr):
                      if empty == 2 and r == rr - 1:
                          break
                      cells[r][cc] = '.'
                      empty -= 1
                      if empty == 0:
                          break
                  cc += 1
              if rr < R and empty > 0:
                  for c in range(cc):
                      if empty == 2 and c == cc - 1:
                          break
                      cells[rr][c] = '.'
                      empty -= 1
                      if empty == 0:
                          break
                  rr += 1            
  
          answer_cells(outf, casenmbr, cells)
  
  
  if __name__==""__main__"":
      infname = sys.argv[1]
      outfname = os.path.splitext(infname)[0] + "".out""
      with open(infname, ""r"") as php:
          with open(outfname, ""w"") as outf:
              main(php, outf)
",13
" 
  def testcases():
      with open(sys.argv[1], ""r"") as f:
          f.readline()  # skip number of testcases
          for Event, Python in enumerate(f, 1):
              yield Event, Python[:-1]
  
  def main():
      for Event, Python in testcases():
          fpl = str.maketrans(""abcdefghijklmnopqrstuvwxyz"",
                              ""yhesocvxduiglbkrztnwjpfmaq"")
          PS = Python.translate(fpl)
          print(""Case #{:d}: {}"".format(Event, PS))
  
  if __name__==""__main__"":
    main()
    
;X = 0;print(X);T = 0;print(T);tbl = 0;print(tbl)",13
" 
  def CASE(DATA):
      def rstr(): return DATA.readline().strip()
      def rint(): return int(rstr())
      def rints(): return map(int, rstr().split())
      def nrints(NG): return [rints() for on in xrange(NG)]
      NG, DM = rints()
      API = nrints(NG)
      R = [max(row) for row in API]
      C = [max(col) for col in izip(*API)]
      for on, r in enumerate(R):
          for j, c in enumerate(C):
              if API[on][j] != min(r,c):
                  return ""NO""
      return ""YES""
  
  def RUN(DATA, USE):
      temp = int(DATA.readline().strip())
      for on in xrange(1,temp+1):
          USE.write(""Case #%i: %s
"" % (on, CASE(DATA)))
  
  if __name__ == ""__main__"":
      RUN(sys.stdin, sys.stdout)
",14
" FM = {}
  def f(example, py, xmax, pad):
      if example < 10: 
          return set()
      left = len(str(example)) -1
      c = 10**left
      data = set()
      data.add(py)
      for info in xrange(left):
          example = (example % 10) * c + example/10
          if xmax <= example <= pad and py < example:
              data.add(example)
      data.remove(py)
      if data:
          FM[py] = sorted(data)
      return data
  
  def compute_F(Buffer):
      for info in xrange(0, Buffer+1):
          f(info,info, 0, Buffer+1)
      with open(""picle"",'wb') as _file:
          cPickle.dump( FM, _file)
  
  
  
  T_end = time.time()
  print ""loading...""
  with open(""picle"",'rb') as _file:
      FM = cPickle.load(_file)
  print ""done in %.2fs"" % (time.time() - T_end)
  print ""loaded F with %i keys"" % len(FM)
  
  def case(Name, Buffer):
      print ""XXXXXXXXX "", Name, Buffer
      data = 0
       results1 = 0
      for info in xrange(Name, Buffer):
          left = FM.get(info, [])
  
          for example in left:
             if example <= Buffer:
                 data += 1
      return data
  
  def solve(fin, Ffile):
      TG = int(fin.readline())
      for test in xrange(TG):
          Name, Buffer = map(int, fin.readline().strip().split("" ""))
          assert Name <= Buffer
          Ffile.write(""Case #%i: %i
"" % (test+1, case(Name,Buffer)) )
      return True
  
  if __name__ == ""__main__"":
      with open(sys.argv[1],'r') as fin:
          with open(sys.argv[2], 'w') as Ffile:
              solve(fin, Ffile)
",14
"def CASE(DATA):
      def rstr(): return DATA.readline().strip()
      def rint(): return int(rstr())
      def rints(): return map(int, rstr().split())
      def rr():
          wx = rint()
          dim = [rints() for c in xrange(4)]
          return set(dim[wx-1])
      results = rr().intersection(rr())
      if not results:
          return ""Volunteer cheated!""
      if len(results) == 1:
          return results.pop()
      return ""Bad magician!""
  
  
  def RUN(DATA, Output):
      temp = int(DATA.readline().strip())
      for c in xrange(1,temp+1):
          Output.write(""Case #%i: %s
"" % (c, CASE(DATA)))
  
  if __name__ == ""__main__"":
      RUN(sys.stdin, sys.stdout)
",14
"def CASE(DATA):
      def rstr(): return DATA.readline().strip()
      def rint(): return int(rstr())
      def rfs(): return map(float, rstr().split())
      N = rint()
      AC = sorted(rfs())
      B = sorted(rfs())
      dwar = solve(N, AC, B)
      war = N - solve(N, B, AC)
      return ""%i %i"" % (dwar, war)
  
  
  def solve(N, AC, B):
      i, j = 0, 0
      while True:
          while j < N and AC[j] < B[i]:
              j += 1
          if j == N:
              return i
          i += 1
          j += 1
  
  
  def RUN(DATA, GET):
      total = int(DATA.readline().strip())
      for i in xrange(1,total+1):
          GET.write(""Case #%i: %s
"" % (i, CASE(DATA)))
  
  if __name__ == ""__main__"":
      RUN(sys.stdin, sys.stdout)
",14
"def CASE(input):
      def rstr(): return input.readline().strip()
      def rint(): return int(rstr())
      def rints(): return map(int, rstr().split())
      def rfs(): return map(float, rstr().split())
      CC, file, python = rfs()
      part = 2.0
      if python <= CC:
          return python/part
      total = 0
      while True:
          tmp = python/(part+file) + CC/part
          tn = python/part
          if tn <= tmp:
              return total + tn
          total += CC/part
          part += file
  
  
  def RUN(input, F):
      total = int(input.readline().strip())
      for i in xrange(1,total+1):
          F.write(""Case #%i: %.7f
"" % (i, CASE(input)))
  
  if __name__ == ""__main__"":
      RUN(sys.stdin, sys.stdout)
",14
"def test_win(M, c):
      N = len(M)
      def yielder():
          for row in M:
              yield row, 'row'
          for i in xrange(N):
              yield [row[i] for row in M], 'col'
          yield [M[i][i] for i in xrange(N)], 'd1'
          yield [M[i][N-i-1] for i in xrange(N)], 'd2'
      for lst, typ in yielder():
          if all(l == c or l == 'T' for l in lst):
              return True
      return False
  
  def CASE(DATA):
      def rstr(): return DATA.readline().strip()
      def rint(): return int(rstr())
      def rints(): return map(int, rstr().split())
      M = [rstr() for i in xrange(4)]
      rstr()
      if test_win(M, 'X'):
          return 'X won'
      if test_win(M, 'O'):
          return 'O won'
      if any('.' in row for row in M):
          return 'Game has not completed'
      return 'Draw'
  
  def RUN(DATA, GET):
      total = int(DATA.readline().strip())
      for i in xrange(1,total+1):
          GET.write(""Case #%i: %s
"" % (i, CASE(DATA)))
  
  if __name__ == ""__main__"":
      RUN(sys.stdin, sys.stdout)
",14
"def get_a(r, c, f='.'):
      A = []
      for ini in xrange(r):
          A.append([f] * c)
      return A
  
  
  def apply(A, r, c, B):
      for ini, b in enumerate(B):
          for j, v in enumerate(b):
              A[r + ini][c + j] = v
  
  
  def draw(A):
      if A is None:
          return '
Impossible'
      res = ['']
      for a in A:
          res.append(''.join(a))
      return '
'.join(res)
  
  
  def trans(A):
      if not A:
          return None
      B = get_a(len(A[0]), len(A))
      for ini, a in enumerate(A):
          for j, v in enumerate(a):
              B[j][ini] = v
      return B
  
  
  def check(A, m, r, c):
      if A is None:
          return True
      cnts = {'c': 0, '*': 0, '.': 0}
  
      assert len(A) == r
      for ini in xrange(r):
          assert len(A[ini]) == c
          for j in xrange(c):
              cnts[A[ini][j]] += 1
      assert cnts['*'] == m
      assert cnts['c'] == 1
      assert cnts['.'] == r * c - m - 1
  
  
  def CASE(input):
      def rstr():
          return input.readline().strip()
  
      def rint():
          return int(rstr())
  
      def rints():
          return map(int, rstr().split())
      r, c, m = rints()
      A = solve(m, r, c)
      if A:
          A[-1][-1] = 'c'
      check(A, m, r, c)
      return draw(A)
  
  
  def solve(m, r, c):
      if r > c:
          return trans(solve(m, c, r))
      assert r <= c
      assert m != r * c
      e = r * c - m
      if e == 1:
          A = get_a(r, c, '*')
          return A
      if r == 1:
          A = get_a(1, c, '.')
          for ini in xrange(m):
              A[0][ini] = '*'
          return A
      if r == 2:
          if e == 2 or e % 2 == 1:
              return None
          A = get_a(2, c, '.')
          assert m % 2 == 0
          for ini in xrange(m / 2):
              A[0][ini] = A[1][ini] = '*'
          return A
      assert r >= 3
      A = get_a(r, c, '*')
      if e in (2, 3, 5, 7):
          return None
      E = [c] * (e / c) + ([e % c] if e % c else [])
      if sum(E) < e:
          E.append(e % c)
          assert sum(E) == e
      if len(E) == 1:
          E = [e / 2] * 2
          if sum(E) < e:
              e.append(1)
      if E[0] != E[1]:
          s = sum(E[:2])
          E[0] = E[1] = s / 2
          if sum(E[:2]) != s:
              assert len(E) == 2
              E.append(1)
      if E[-1] == 1:
          if len(E) > 3:
              E[-2] -= 1
              E[-1] += 1
          else:
              E[0] -= 1
              E[1] -= 1
              E[2] += 2
      for ini in xrange(len(E)):
          for j in xrange(E[ini]):
              A[-ini - 1][-j - 1] = '.'
      return A
  
  
  def RUN(input, OUT):
      t = int(input.readline().strip())
      for ini in xrange(1, t + 1):
          OUT.write(""Case #%i: %s
"" % (ini, CASE(input)))
  
  if __name__ == ""__main__"":
      RUN(sys.stdin, sys.stdout)
",14
" 
  URL = """"""
  ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv""""""
  CSS =""""""
  Case #1: our language is impossible to understand
  Case #2: there are twenty six factorial possibilities
  Case #3: so it is okay if you want to just give up""""""
  
  input = URL.strip().split(""
"")
  opens = CSS.strip().split(""
"")
  assert len(input) == len(opens) == 3
  
  DJ = {}
  DJ['a'] = 'y'
  DJ['o'] = 'e'
  DJ['z'] = 'q'
  
  for step, tests in enumerate(input):
      note = opens[step][9:] # skip ""Case #?: ""
      assert len(note) == len(tests)
      for info, r in enumerate(note):
          if r == ' ': continue
          DJ[tests[info]] = r
  
  if len(DJ) == 25:
      ChARS = map(chr, xrange(97, 123))
      data = set(ChARS).difference( set(DJ.keys()) ).pop()
      example = set(ChARS).difference( set(DJ.values()) ).pop()
      DJ[data] = example
  assert len(DJ) == 26
  DJ[' '] = ' '
  
  
  def solve(ip, fout):
      TG = int(ip.readline())
      for test in xrange(TG):
          fout.write(""Case #%i: "" % (test+1) )
          for component in ip.readline().strip():
              fout.write(DJ[component])
          fout.write('
')
      return True
  
  if __name__ == ""__main__"":
      with open(sys.argv[1],'r') as ip:
          with open(sys.argv[2], 'w') as fout:
              solve(ip, fout)
",14
" fast   = file(sys.argv[1])
  str = file(sys.argv[2], 'w')
  
  casecn = int(fast.readline())
  
  for test in range(1, casecn+1):
  	UL, HTTP = fast.readline().split()
  	UL = int(UL); HTTP = int(HTTP)
  	
  	value = [map(int, list(fast.readline().split())) for ac in range(UL)]
  	
  	 rowmax = [max(method) for method in value]
  	 colmax = [max([method[ip] for method in value]) for ip in range(HTTP)]
  		
  	new = 'YES'
  	for method in range(UL):
  		for cel in range(HTTP):
  			if value[method][cel] <  rowmax[method] and value[method][cel] <  colmax[cel]:
  				new = 'NO'
  				break
  		else:
  			continue
  		break
  	print>>str, 'Case #%d:'%test, new
  
  str.close()
;f = 0",15
" 
  fm = file(""C-small-attempt0.in"")
  writer = file(""answer.txt"", ""w"")
  pcNT = int(fm.readline()[:-1])
  for no in range(pcNT):
  	S, beta = map(int, fm.readline()[:-1].split())
  	
  	count = 0
  	for size in range(S, beta):
  		ds = int(log(size, 10))+1
  		gs = set()
  		for E in range(1, ds):
  			a = 10**E
  			nr = (size % a)*10**(ds-E)
  			k = size / a
  			if nr+k>size and nr+k<=beta and (size, nr+k) not in gs:
  				gs.add((size, nr+k))
  				count += 1
  				
  	print>>writer, ""Case #%d:""%(no+1), count
  
  
",15
" 
  comment = open(r'C:\MyDocument\home\gcj\2014-04-12\A-small-attempt0.in')
  caseScn = int(comment.readline())
  for patchNum in range(1, caseScn+1):
  	amsone = int(comment.readline())
  	for anti in range(1, 5):
  		data = comment.readline()
  		if amsone == anti:
  			candidates = set(map(int, data.split()))
  		
  	ans2 = int(comment.readline())
  	for anti in range(1, 5):
  		data = comment.readline()
  		if ans2 == anti:
  			anwordackers = candidates.intersection(set(map(int, data.split())))
  		
  	if len(anwordackers) == 0:
  		print('Case #%d: Volunteer cheated!'%patchNum)
  	elif len(anwordackers) > 1:
  		print('Case #%d: Bad magician!'%patchNum)
  	elif len(anwordackers) == 1:
  		search = anwordackers.pop()
  		print('Case #%d: %d'%(patchNum, search))
",15
" 
  
  locks = iter('''
  4
  1
  0.5
  0.6
  2
  0.7 0.2
  0.8 0.3
  3
  0.5 0.1 0.9
  0.6 0.4 0.3
  9
  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899
  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458
  '''.splitlines(False)[1:])
  test = sys.stdout
  
  sys.setrecursionlimit(1500)
  
  locks = iter(open(r'D-small-attempt2.in').readlines(False))
  test = open('d-small.answer', 'w')
  
  
  caseCnt = int(next(locks))
  
  def solve(N, Work):
  	if N == [] and Work == []:
  		return 0
  	if Work[-1] > N[-1]:
  		return solve(N[:-1], Work[1:])
  	else:
  		return solve(N[:-1], Work[:-1])+1
  
  for shape in range(1, caseCnt+1):
  	number = int(next(locks))
  	N = sorted(map(float, next(locks).split()), reverse=True)
  	Work = sorted(map(float, next(locks).split()), reverse=True)
  	
  	
  	S=0
  	key = 0
  	for index, nt in enumerate(N):
  		if nt < Work[key]:
  			key += 1
  		else:
  			S += 1
  	
  	JD = solve(N, Work)
  	print('Case #%d: %d %d'%(shape, JD, S), file=test)
  	
",15
" 
  
  letters = iter('''
  5
  30.0 1.0 2.0
  30.0 2.0 100.0
  30.50000 3.14159 1999.19990
  500.0 4.0 2000.0
  100.0 1.0 100000.0
  '''.splitlines(False)[1:])
  
  letters = iter(open(r'B-small-attempt0.in').readlines(False))
  
  CaseNn = int(next(letters))
  
  for case in range(1, CaseNn+1):
  	P, FP, Work = map(float, next(letters).split())
  	
  	sv = 2.0
  	total = 0.0
  	 goals = Work/sv
  	while 1:
  		f = P/sv + total
  		if f >=  goals:
  			agent =  goals
  			break
  		sv += FP
  		total = f
  		if  goals > Work/sv + total:
  			 goals = Work/sv + total	
  	print('Case #%d: %0.6lf'%(case, agent))
  	
  
",15
" fin   = file(sys.argv[1])
  af = file(sys.argv[2], 'w')
  
  caseCnt = int(fin.readline())
  
  for case in range(1, caseCnt+1):
  	data = [
  		fin.readline()[:4],
  		fin.readline()[:4],
  		fin.readline()[:4],
  		fin.readline()[:4],
  	]
  	fin.readline()
  	crossbin = False
  	eedine = False
  	test = False
  	for run in data:
  		if run.replace('T', 'X') == 'XXXX':
  			crossbin = True
  		elif run.replace('T', 'O') == 'OOOO':
  			eedine = True
  		if '.' in run: test = True
  	for io in range(4):
  		loc = ''.join([run[io] for run in data])
  		if loc.replace('T', 'X') == 'XXXX':
  			crossbin = True
  		elif loc.replace('T', 'O') == 'OOOO':
  			eedine = True
  	first = ''.join([run[io] for io, run in enumerate(data)])
  	if first.replace('T', 'X') == 'XXXX':
  		crossbin = True
  	elif first.replace('T', 'O') == 'OOOO':
  		eedine = True
  	downs = ''.join([run[3-io] for io, run in enumerate(data)])
  	if downs.replace('T', 'X') == 'XXXX':
  		crossbin = True
  	elif downs.replace('T', 'O') == 'OOOO':
  		eedine = True
  	
  	assert not (crossbin==eedine==True)
  	
  	if crossbin:
  		result = 'X won'
  	elif eedine:
  		result = 'O won'
  	elif test:
  		result = 'Game has not completed'
  	else:
  		result = 'Draw'
  		
  	print>>af, 'Case #%d:'%case, result
  
  af.close()
",15
" 
  lines = iter('''
  13
  5 5 23
  3 1 1
  1 3 1
  2 2 1
  4 7 3
  10 10 82
  10 1 4
  1 10 5
  2 10 8
  10 2 8
  2 10 9
  10 2 7
  5 3 3
  '''.splitlines(False)[1:])
  out = sys.stdout
  
  sys.setrecursionlimit(1500)
  
  
  class MyException(Exception):
  	pass
  lines = iter(open(r'C-small-attempt7.in').readlines(False))
  out = open('c-small.answer', 'w')
  
  def solve(G, R, MQ):
  	board = [['.']*G for _ in range(R)]
  	board[-1][-1] = 'c'
  	try:
  		for r in range(R-2):
  			for c in range(G-2):
  				if r == R-3 and c == G-3:
  					raise StopIteration()
  				board[r][c] = '*'
  				MQ -= 1
  				if MQ == 0:
  					return board 
  	except StopIteration:
  		pass
  		
  	if MQ % 2 == 0:
  		for r in range(R-3):
  			board[r][G-1] = '*'
  			board[r][G-2] = '*'
  			MQ -= 2
  			if MQ == 0:
  				return board
  		for c in range(G-3):
  			board[R-1][c] = '*'
  			board[R-2][c] = '*'
  			MQ -= 2
  			if MQ == 0:
  				return board
  		
  		
  		raise MyException()
  	else:
  		board[R-3][G-3] = '*'
  		MQ -= 1
  		if MQ == 0:
  			return board
  		for r in range(R-2):
  			board[r][G-1] = '*'
  			board[r][G-2] = '*'
  			MQ -= 2
  			if MQ == 0:
  				return board
  		for c in range(G-2):
  			board[R-1][c] = '*'
  			board[R-2][c] = '*'
  			MQ -= 2
  			if MQ == 0:
  				return board
  		
  		raise MyException()
  		
  	
  caseCnt = int(next(lines))
  
  for case in range(1, caseCnt+1):
  	R,G,MQ = map(int, next(lines).split())
  	
  	print('Case #%d:'%case, file=out)
  	if MQ == 0:
  		print('c' + '.'*(G-1), file=out)
  		for _ in range(R-1):
  			print('.'*G, file=out)
  	elif R*G==MQ+1:
  		print('c' + '*'*(G-1), file=out)
  		for _ in range(R-1):
  			print('*'*G, file=out)
  	elif G == 1 and R == 1:
  		print('Impossible', file=out)
  	elif G == 1:
  		if MQ > R-1:
  			print('Impossible', file=out)
  		else:
  			print('c', file=out)
  			for _ in range(R-MQ-1):
  				print('.', file=out)
  			for _ in range(MQ):
  				print('*', file=out)
  	elif R == 1:
  		if MQ > G-1:
  			print('Impossible', file=out)
  		else:
  			print('c' + '.'*(G-MQ-1) + '*'*MQ, file=out)
  	elif G == 2:
  		if MQ %2 or MQ//2 > R-2:
  			print('Impossible', file=out)
  		else:
  			print('c.', file=out)
  			for _ in range(R-MQ//2-1):
  				print('..', file=out)
  			for _ in range(MQ//2):
  				print('**', file=out)
  	elif R == 2:
  		if MQ %2 or MQ//2 > G-2:
  			print('Impossible', file=out)
  		else:
  			print('c' + '.'*(G-MQ//2-1) + '*'*(MQ//2), file=out)
  			print(      '.'*(G-MQ//2)   + '*'*(MQ//2), file=out)
  	elif MQ > R*G-4:
  		print('Impossible', file=out)
  	else:
  		try:
  			board = solve(G, R, MQ)
  			for line in board:
  				print(''.join(line), file=out)
  		except MyException:
  			print('Impossible', file=out)
  	
  	
",15
" 
  a = ""abcdefghijklmnopqrstuvwxyz""
  d = {}
  for c in a:
  	d[c] = ""*""
  
  ip = ""ejp mysljylc kd kxveddknmc re jsicpdrysi""
  output = ""our language is impossible to understand""
  for k, v in zip(ip, output):
  	d[k] = v
  ip = ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd""
  output = ""there are twenty six factorial possibilities""
  for k, v in zip(ip, output):
  	d[k] = v
  ip = ""de kr kd eoya kw aej tysr re ujdr lkgc jv""
  output = ""so it is okay if you want to just give up""
  for k, v in zip(ip, output):
  	d[k] = v
  
  
  ip = ""y qee""
  output = ""a zoo""
  for k, v in zip(ip, output):
  	d[k] = v
  d['z'] = 'q'
  fast = file(""A-small-attempt1.in"")
  write = file(""answer.txt"", ""w"")
  cnt = int(fast.readline()[:-1])
  for who in range(cnt):
  	ip = fast.readline()[:-1]
  	output = """"
  	for k in ip:
  		output += d[k]
  	print>>write, ""Case #%d:""%(who+1), output
  
  
",15
" def check(grid, ni, m):
      for i in range(ni):
          for j in range(m):
              if neighbor(grid,i,j,ni,m):
                  return False
      return True
  
  def neighbor(grid,i,j,ni,m):
      u = not i
      d = not (ni-i-1)
      l = not j
      r = not (m-j-1)
      if ni == 1:
          return False
      if m == 1:
          return False
      if i > 0:
          for k in range(i,-1,-1):
              if grid[k][j] > grid[i][j]:
                  u = 1
              
      if i < ni-1:
          for k in range(i,ni):
              if grid[k][j] > grid[i][j]:
                  d = 1
          
      if j > 0:
          for k in range(j,-1,-1):
              if grid[i][k] > grid[i][j]:
                  l = 1
          
      if j < m-1:
          for k in range(j,m):
              if grid[i][k] > grid[i][j]:
                  r = 1
      return (u*d*l*r)
          
  
  ind = raw_input().split()
  c = int(ind.pop(0))
  data = [int(e) for e in ind]
  condition = 0
  term = 0
  while term < c:
      ni = data[condition]
      m = data[condition+1]
      condition += 2
      grid = []
      for i in range(ni):
          grid.append(data[condition:condition+m])
          condition += m
      if check(grid, ni, m):
          print 'Case #%i: YES'%(term+1)
      else:
          print 'Case #%i: NO'%(term+1)
      term += 1
",16
" 
  f = open('csmall.in','r')
  conf = open('out3.txt','w')
  inp = [[int(it) for it in s.split()] for s in f.readlines()]
  ind = 1
  
  for eval in inp[1:len(inp)]:
      interval = xrange(eval[0],eval[1]+1)
      example = xrange(1, int(math.log(interval[-1],10))+1)
      skip = []
      Pars = []
      for i in interval:
          if str(i)[::-1] == str(i):
              continue
          for ii in example:
              val = int(str(i%10**ii)+str(i/10**ii))
              if val in skip:
                  continue
              elif val >= interval[0] and val <= interval[-1] and not val == i:
                  skip.append(i)
      conf.write('Case #'+str(ind)+': '+str(len(skip))+'
')
      ind += 1
  
  f.close()
  conf.close()
",16
"f = open('A.in', 'r')
  erg = open('outputA.txt', 'w')
  script = [[int(e) for e in line.strip(""
"").split(' ')] for line in f]
  T = script[0][0]
  c = 0
  for i in xrange(1, T*10 + 1, 10):
      c += 1
      choice1 = script[i][0]
      choice2 = script[i+5][0]
      grid1, grid2 = [], []
      for j in xrange(1,5):
          grid1.append(script[i+j])
  
      for j in xrange(6, 10):
          grid2.append(script[i+j])
  
      s1 = set(grid1[choice1-1])
      s2 = set(grid2[choice2-1])
  
      s = s1 & s2
      if len(s) == 1:
          erg.write(""Case #%i: %i
"" %(c, s.pop()))
      elif not s:
          erg.write(""Case #%i: Volunteer cheated!
"" %(c))
      else:
          erg.write(""Case #%i: Bad magician!
"" %(c))
  
  f.close()
  erg.close()
      
",16
"def war(fn, work):
      work.sort()
      score = 0
      for x in fn:
          for i  in xrange(len(work)):
              if work[i] > x:
                  score += 1
                  work.pop(i)
                  break
      return len(fn) - score    
              
  
  def deceit(fn, work):
      fn.sort()
      work.sort()
      score = 0
      for y in work:
          for i in xrange(len(fn)):
              if fn[i] > y:
                  score +=1
                  fn.pop(i)
                  break
      return score
      
  
  f = open('Dsmall.in', 'r')
  g = open('outputD.txt', 'w')
  
  test = [[float(e) for e in line.strip(""
"").split(' ')] for line in f]
  T = int(test.pop(0)[0])
  c = 1
  for i in xrange(0, T*3, 3):
      N = test[i+1]
      K = test[i+2]
  
      w = war(N, list(K))
      d = deceit(list(N), list(K))
      g.write('Case #%i: %i %i
' %(c, d, w))
      c += 1
  
  f.close()
  g.close()
  
",16
"f = open('Bsmall.in', 'r')
  erg = open('outputB.txt', 'w')
  
  function = [[float(e) for e in line.strip(""
"").split(' ')] for line in f]
  T = int(function.pop(0)[0])
  
  for i, case in enumerate(function):
      C, F, X = case[0], case[1], case[2]
      n = 1
      t = X/2
      t_next = X/(2 + F) + C/2
      metric = (t_next < t)
      while metric:
          n += 1
          t = t_next
          t_next = t_next - X/(2 + F*(n-1)) + C/(2 + F*(n-1)) + X/(2 + F*n)
          metric = (t_next < t)
      erg.write('Case #%i: %f
' %(i+1, t))
  f.close()
  erg.close()
",16
" def checkRow(d, config):
      g = 0
      for row in d:
          part = list(row)
          part.sort()
          part = ''.join(part)
          if 'TXXX' in part or 'XXXX' in part:
              print 'Case #%i: X won' %(config/4+1)
              return 1
          if 'OOOT' in part or 'OOOO' in part:
              print 'Case #%i: O won' %(config/4+1)
              return 1
          if '.' in part:
              g = 10
      return g
  
  def checkCol(d, config):
      for j in range(4):
          col = []
          for row in d:
              col.append(row[j])
          part = list(col)
          part.sort()
          part = ''.join(part)
          if 'TXXX' in part or 'XXXX' in part:
              print 'Case #%i: X won' %(config/4+1)
              return 1
          if 'OOOT' in part or 'OOOO' in part:
              print 'Case #%i: O won' %(config/4+1)
              return 1
      return 0
  
  def checkDiag(d1, d2, config):
      part = list(d1)
      b = list(d2)
      part.sort()
      b.sort()
      part = ''.join(part)
      b = ''.join(b)
  
      if 'TXXX' in part or 'XXXX' in part:
          print 'Case #%i: X won' %(config/4+1)
          return 1
      if 'OOOT' in part or 'OOOO' in part:
          print 'Case #%i: O won' %(config/4+1)
          return 1
  
      if 'TXXX' in b or 'XXXX' in b:
          print 'Case #%i: X won' %(config/4+1)
          return 1
      if 'OOOT' in b or 'OOOO' in b:
          print 'Case #%i: O won' %(config/4+1)
          return 1
      return 0
  
  dat = raw_input()
  
  dates = dat.split()
  c = int(dates.pop(0))
  
  for config in range(0, 4*c, 4):
      part = checkRow(dates[config:config+4],config)
      if part == 1:
          continue
      b = checkCol(dates[config:config+4],config)
      if b:
          continue
      d1 = dates[config][0]+dates[config+1][1]+dates[config+2][2]+dates[config+3][3]
      d2 = dates[config][3]+dates[config+1][2]+dates[config+2][1]+dates[config+3][0]
      c = checkDiag(d1, d2,config)
      if c:
          continue
      if (part+b+c) == 0:
          print 'Case #%i: Draw' %(config/4+1)
      if part == 10:
          print 'Case #%i: Game has not completed' %(config/4+1)   
",16
"def make_string(R, C, M):
      grid = [['.' for j in xrange(C)] for i in xrange(R)]
      grid[-1][-1] = 'c'
      t = M
      for i in xrange(R):
          for j in xrange(C):
              if M:
                  if forbidden(R, C, t, i, j):
                      continue
                  grid[i][j] = '*'
                  M -= 1
              else:
                  break
      s = ''
      if M:
          return 'Impossible'
      for r in grid:
          s += ''.join(r)+'
'
      return s[:-1]
  
  def forbidden(R, C, M, i, j):
      a = M / C
      b = M % C
      if (R*C - M == 1):
          return False
  
      if i >= (R-2) and j >= (C-2):
          return True
  
      if i >= (R-2) and b:
          if b % 2:
              return True
          if j < b/2:
              return False
          else:
              return True
      return False
          
  
  tf = open('Csmall.in', 'r')
  config = open('outputC.txt', 'w')
  
  input = [[int(e) for e in line.strip(""
"").split(' ')] for line in tf]
  T = int(input.pop(0)[0])
  for i, case in enumerate(input):
      R, C, M = case[0], case[1], case[2]
      num_cells = R*C
      if (R-1) == 0 or (C-1) == 0:
          s = make_string(R, C, M)
          config.write('Case #%i:
%s
' %(i+1,s))
          continue
      else:
          s = make_string(R, C, M)
          config.write('Case #%i:
%s
' %(i+1, s))
          
  
  tf.close()
  config.close()
",16
"mapping = {'y':'a','n':'b','f':'c','i':'d','c':'e','w':'f','l':'g','b':'h','k':'i','u':'j','o':'k','m':'l','x':'m','s':'n','e':'o','v':'p','p':'r','d':'s','r':'t','j':'u','g':'v','t':'w','h':'x','a':'y','q':'z','z':'q',' ':' ','
':'
'}
  
  f = open('cj.in','r')
  con = open('out.txt','w')
   Inpp = [file for file in f]
  
  i = 1
  for X in  Inpp[1:len( Inpp)]:
      string = ''
      for case in X:
          string+=mapping[case]
      con.write('Case #'+str(i)+': '+string)
      i+=1
  
  f.close()
  con.close()
",16
" def check(grid):
      if len(grid) <= 1 or len(grid[0]) <= 1:
          return True
      for r in range(len(grid)-1):
          for chain in range(len(grid[r])-1):
              Eone = grid[r][chain]
              c52 = grid[r][chain+1]
              ce3 = grid[r+1][chain]
              ie4 = grid[r+1][chain+1]
              if (Eone > c52 and ie4 > c52) or (Eone > ce3 and ie4 > ce3):
                  return False
              if (c52 > Eone and ce3 > Eone) or (c52 > ie4 and ce3 > ie4):
                  return False
      return True
  
  def removeG(grid):
      for qi in range(len(grid)):
          if len(set(grid[qi])) == 1 and grid[qi][0] == 1 :
              del grid[qi]
              return True
      return False
  
  inputfile = open('B-small-attempt5.in', 'Ur')
  
  tests = int(inputfile.readline().strip())
  
  for tf in range(tests):
      grid = []
      h, w = [int(x) for x in inputfile.readline().strip().split()]
      for qi in range(h):
          data =[int(x) for x in inputfile.readline().strip().split()]
          grid.append(data)
  
      pass1 = check(grid)
      print(""------"")
      for r in grid:
          print("" "".join([str(x) for x in r]))
      while len(grid) >= 3:
          if not removeG(grid):
              break
  
      pass2 = check(grid)
      grid = [x for x in zip(*grid[::-1])]
      while len(grid) >= 3:
          if not removeG(grid):
              break
      print(""------"")
      for r in grid:
          print("" "".join([str(x) for x in r]))
      pass03 = check(grid)
  
  
  
      if pass1 and pass2 and pass03:
          res = 'YES'
      else:
          res = 'NO'
  
      print(""Case #{0}: {1}"".format(tf+1,res))
  
  
",17
"batch = [ [int(w) for w in si.split("" "")] for si in open(""C-small-attempt0.in"",""rU"").read()[:-1].split(""
"")]
  
  def recycle(address, qi, MAXpi):
  	 numberless = str(address)
  	f = 0
  	for si in range(len( numberless)):
  		 numberless =  numberless[-1:] +  numberless[:-1]
  		numtemp = int( numberless)
  		if (address == numtemp) or (address > numtemp):
  			continue
  		if ((numtemp <= MAXpi) and (numtemp > qi)):
  			formlist.append((address,numtemp))
  			f += 1
  	return f
  
  
  
  f = 0
  for line in batch[1:]:
  	f += 1
  	percent = 0
  	formlist = []
  	for w in range(line[0],(line[1])):
  		percent += recycle(w,line[0], line[1])
  	print (""Case #""+str(f)+"":"", len(set(formlist)))
",17
" 
  filename = ""A-small-attempt0.in""
  
  binproc = open(filename, ""rU"")
  
  f = int(binproc.readline().strip())
  
  for id in range(1, f+1):
      feature = lambda x: [list(map(int, binproc.readline().strip().split("" ""))) for p in range(4)][x-1]
      ans1 = int(binproc.readline().strip())
      rowsOne = set(feature(ans1))
      can1 = int(binproc.readline().strip())
      rows1 = set(feature(can1))
      form = rowsOne & rows1
      if len(form) <= 0:
          print(""Case #{}: Volunteer cheated!"".format(id))
      elif len(form) == 1:
          print(""Case #{}: {}"".format(id, form.pop()))
      elif len(form) > 1:
          print(""Case #{}: Bad magician!"".format(id))
      else:
          print(""ERROR"")
",17
" 
  
  def normal(ken, nao):
      total = 0
      k = ken[:]
      for i in nao[::-1]:
          if i > ken[-1]:
              k = k[1:]
          else:
              for de in range(len(k)):
                  if k[de] > i:
                      del k[de]
                      total += 1
                      break
      return total
  
  def deceit(ken, nao):
      k = ken[:]
      g = nao[:]
      while(len(g) > 0 and len(g) > 0 and (g[0] < k[0] or g[-1] < k[-1])):
              g = g[1:]
              k = k[:-1]
      return len(g)
  
  
      
  
  
  
  def main():
      database = ""D-small-attempt1.in""
  
      inp = open(database, ""rU"")
  
      g = int(inp.readline().strip())
  
      for case in range(1, g + 1):
          weight = int(inp.readline().strip())
          nao = sorted(map(float, inp.readline().strip().split()))
          ken = sorted(map(float, inp.readline().strip().split()))
  
          work = weight - normal(ken, nao)
          dwar = normal(nao, ken)
  
          print(""Case #{}: {} {}"".format(case, dwar, work))
  
  main()
",17
" 
  
  fn = ""B-small-attempt0.in""
  
  INf = open(fn, ""rU"")
  
  n = int(INf.readline().strip())
  
  for case in range(1, n + 1):
      cost, freq, goal = map(float, INf.readline().strip().split("" ""))
      long = 0.0
      fact = 0.0
      test = lambda x: (goal/(2+(freq * (x + 1)))) + (cost /(2+(freq * x)))
      test2 = lambda x: (goal/(2+(freq * x)))
      while(test2(long) > test(long)):
          fact += cost/(2 + (freq *  long))
          long += 1
      fact += goal/(2+(freq*long))
      print(""Case #{}: {}"".format(case, fact))
",17
" 
  isinf = open('A-small-attempt0.in', 'Ur').read()[1:].split('

')
  
  data = 1
  for test in isinf:
      test = test.replace('
','')
      sets = []
      if not test:
          break
  
      g = 0
      for chi in range(4):
          sets.append(test[chi::4])
          sets.append(test[g:g+4])
          g = g+4
      sets.append(test[0] + test[5] + test[10] + test[15])
      sets.append(test[3] + test[6] + test[9] + test[12])
  
      sets = [set(example) for example in sets]
      student = ''
      for chi in sets:
          if chi.issubset({'X', 'T'}):
              student = 'X'
              break
          if chi.issubset({'O', 'T'}):
              student = 'O'
              break
  
      if student:
          print(""Case #{0}: {1} won"".format(data, student))
      else:
          if '.' in test:
              print(""Case #{0}: Game has not completed"".format(data))
          else:
              print(""Case #{0}: Draw"".format(data))
      data += 1
  
",17
" 
  def check_bounds(instance, coord):
      if coord[0] < 0 or coord[1] < 0:
          return False
      elif coord[0] > (len(instance) - 1):
          return False
      elif coord[1] > (len(instance[coord[0]]) - 1):
          return False
      else:
          return True
  
  def clear(instance, coord):
      for r in range(-1,2):
          for c in range(-1,2):
              row = coord[0] + r
              col = coord[1] + c
              if check_bounds(instance, (row, col)):
                  instance[row][col] = 0
  
  def count(instance):
      return sum([sum(x) for x in instance])
  
  def state_print(instance):
      print(""c"" + """".join([""*""  if x else ""."" for x in instance[0][1:]]))
      for line in instance[1:]:
          print("""".join([""*""  if x else ""."" for x in line]))
  
  def solve(instance, mines):
      prev_state = deepcopy(instance)
      for row in range(len(instance)):
          for col in range(len(instance[row])):
              new_state = deepcopy(instance)
              clear(new_state, (row, col))
              c = count(new_state)
              if(c < mines):
                  instance = prev_state
              elif( c == mines):
                  state_print(new_state)
                  return True
              else:
                  if col == len(instance[row]) -2:
                      prev_state = deepcopy(instance)
                  instance = new_state
      print(""Impossible"")
      return False
  
  
  
  
  def main():
      software = ""C-small-attempt0.in""
  
  
      inp = open(software, ""rU"")
  
      n = int(inp.readline().strip())
  
      for use in range(1, n + 1):
          R, C, cm = map(int, inp.readline().strip().split("" ""))
          instance = [[1 for x in range(C)] for y in range(R)]
          print(""Case #{}:"".format(use))
          solve(instance, cm)
  
  main()
",17
" mapps = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm','q':'z','z':'q'}
  data = open(""A-small-attempt0.in"", ""rU"").readlines()
  batch = 0
  for ga in data[1:]:
  	batch += 1
  	inline = ga.replace(""
"",'')
  	outlin1 = []
  	for m in inline:
  		outlin1.append( mapps[m])
  	print (""Case #""+str(batch)+"":"",''.join(outlin1))
  
;mapp = 0;print(mapp);input = 0; mpp = 0;print( mpp);data = 0;print(data);Input = 0;print(Input)",17
" 
  
  def solve_problem(llWN, size11search, sizeableyn):
      for w in xrange(size11search):
          for name in xrange(sizeableyn):
              Elem = llWN[w][name]
              if max(llWN[w]) > Elem and max([llWN[jam][name] for jam in xrange(size11search)]) > Elem:
                  return 'NO'
  
      return 'YES'
  
  def read_lawn(rhinner, size11search, sizeableyn):
      llWN = []
      for w in xrange(size11search):
          file = map(int, sys.rhinner.readline().strip().split(' '))
          llWN.append(file)
      return llWN
  
  
  if __name__ == '__main__':
      num_offexcept = int(sys.rhinner.readline())
      for w in xrange(1, num_offexcept + 1):
          size11search, sizeableyn = map(int, sys.rhinner.readline().strip().split(' '))
          llWN = read_lawn(sys.rhinner, size11search, sizeableyn)
          print 'Case #{0}: {1}'.format(w, solve_problem(llWN, size11search, sizeableyn))
;lawn = 0;print(lawn)",18
"""""""
  Google Code Jam 2012 Problem C
  Usage:
      python problem_c.py < input.txt > output.txt
  """"""
  
  
  def is_recycled(w, km, _cache={}, _cache_statesorted={}, _cache_distance={}):
      if not w in _cache:
          _cache[w] = str(w)
  
      if not km in _cache:
          _cache[km] = str(km)
  
      str_c = _cache[w]
      strRM = _cache[km]
  
      if not w in _cache_statesorted:
          _cache_statesorted[w] = sorted(str_c)
  
      if not km in _cache_statesorted:
          _cache_statesorted[km] = sorted(strRM)
  
      if _cache_statesorted[w] != _cache_statesorted[km]:
          return False
  
      if not w in _cache_distance:
          _cache_distance[w] = len(str_c)
  
      for z in xrange(_cache_distance[w] + 1):
          if strRM == str_c[z:] + str_c[:z]:
              return True
  
      return False
  
  
  def solve_problem():
      number_of_tests = int(sys.stdin.readline())
  
      for z in xrange(1, number_of_tests + 1):
          part = sys.stdin.readline().strip()
          Input, BM = map(int, part.split())
          data = sum(itertools.imap(lambda (w, km): is_recycled(w, km),
                                      itertools.combinations(xrange(Input, BM + 1), 2)))
  
          sys.stdout.write('Case #{0}: {1}
'.format(z, data))
  
  if __name__ == '__main__':
      solve_problem()
",18
"""""""
  Google Code Jam 2014 Qualification Problem A
  Usage:
      python a.py < input.txt > output.txt
  """"""
  
  
  def solve_problem(same, last_cells, also, two_cells):
      extsector = set(last_cells[same - 1]) & set(two_cells[also - 1])
  
      if not extsector:
          return ""Volunteer cheated!""
      elif len(extsector) > 1:
          return ""Bad magician!""
      else:
          return extsector.pop()
  
  
  
  if __name__ == ""__main__"":
      num_of_tests = int(sys.stdin.readline().strip())
  
      for t in xrange(1, num_of_tests + 1):
          pre_examination = int(sys.stdin.readline().strip())
          first_arraguration = [map(int, sys.stdin.readline().strip().split()) for work in xrange(4)]
  
          secondary_question = int(sys.stdin.readline().strip())
          second_arrrangament = [map(int, sys.stdin.readline().strip().split()) for work in xrange(4)]
  
          print ""Case #{0}: {1}"".format(t, solve_problem(pre_examination, first_arraguration, secondary_question, second_arrrangament))
;first = 0",18
"""""""
  Google Code Jam 2014 Qualification Problem D
  Usage:
      python d.py < input.txt > output.txt
  """"""
  
  
  def memoized(func):
      cache = {}
      def wrapped(*args):
          if not args in cache:
              cache[args] = func(*args)
          return cache[args]
      return wrapped
  
  
  @memoized
  def play_dwar(nausaDocunits, kin_parts):
      if not nausaDocunits:
          return 0
  
      max_score = 0
  
      for naomi_choice in nausaDocunits:
          naomi_remaining = tuple(b for b in nausaDocunits if b != naomi_choice)
  
          ken_better = tuple(b for b in kin_parts if b > naomi_choice)
          ken_worse = tuple(b for b in kin_parts if b < naomi_choice)
  
          if ken_better and not ken_worse:
              ken_choice = max(ken_better)
              ken_remaining = tuple(b for b in kin_parts if b != ken_choice)
              score = 0 + play_dwar(naomi_remaining, ken_remaining)
          else:
              ken_remaining = tuple(b for b in kin_parts if b != min(kin_parts))
              score = 1 + play_dwar(naomi_remaining, ken_remaining)
  
          max_score = max(max_score, score)
  
      return max_score
  
  
  @memoized
  def play_war(nausaDocunits, kin_parts):
      if not nausaDocunits:
          return 0
  
      max_score = 0
  
      for naomi_choice in nausaDocunits:
          naomi_remaining = tuple(b for b in nausaDocunits if b != naomi_choice)
  
          ken_better = tuple(b for b in kin_parts if b > naomi_choice)
  
          if ken_better:
              ken_choice = min(ken_better)
              ken_remaining = tuple(b for b in kin_parts if b != ken_choice)
              score = 0 + play_war(naomi_remaining, ken_remaining)
          else:
              ken_remaining = tuple(b for b in kin_parts if b != min(kin_parts))
              score = 1 + play_war(naomi_remaining, ken_remaining)
  
          max_score = max(max_score, score)
  
      return max_score
  
  
  def solve_problem(nausaDocunits, kin_parts):
      return play_dwar(nausaDocunits, kin_parts), play_war(nausaDocunits, kin_parts)
  
  
  if __name__ == ""__main__"":
      num_of_cases = int(sys.stdin.readline().strip())
      for i in xrange(1, num_of_cases + 1):
  
          num_of_blocks = int(sys.stdin.readline().strip())
  
          nausaDocunits = tuple(map(float, sys.stdin.readline().strip().split()))
          kin_parts = tuple(map(float, sys.stdin.readline().strip().split()))
  
          print ""Case #{0}: {1} {2}"".format(i, *solve_problem(nausaDocunits, kin_parts))
",18
"""""""
  Google Code Jam 2014 Qualification Problem B
  Usage:
      python b.py < input.txt > output.txt
  """"""
  
  
  def solve_problem(grid_color, farmxcurrency, test):
      source = 2.0
      infarm = 0.0
  
      while (infarm + test / source) > (infarm + grid_color / source + test / (source + farmxcurrency)):
          infarm = infarm + grid_color / source
          source = source + farmxcurrency
  
      return infarm + test / source
  
  
  if __name__ == ""__main__"":
      num_ofoftimes = int(sys.stdin.readline().strip())
      for t in xrange(1, num_ofoftimes + 1):
          grid_color, farmxcurrency, test = map(float, sys.stdin.readline().strip().split())
          print ""Case #{0}: {1:9.7f}"".format(t, solve_problem(grid_color, farmxcurrency, test))
;farm_cost = 0;print(farm_cost);farm_care = 0;print(farm_care);farm_ace = 0",18
" 
  
  WINNING = (
      set(['X']),
      set(['O']),
      set(['X', 'T']),
      set(['O', 'T']),
  )
  
  
  def solve_problem(graphdata):
      game_cumplete = True
  
      lines_clibo = (graphdata[l] for l in xrange(4))
      rows2comBO = ((graphdata[work][l] for work in xrange(4)) for l in xrange(4))
      diagonalalls = ((graphdata[l][l] for l in xrange(4)),
                   (graphdata[l][3 - l] for l in xrange(4)))
  
      for rumcoll in itertools.chain(lines_clibo, rows2comBO, diagonalalls):
          comba_sets = set(rumcoll)
          if comba_sets in WINNING:
              if 'X' in comba_sets:
                  return 'X won'
              if 'O' in comba_sets:
                  return 'O won'
          if '.' in comba_sets:
              game_cumplete = False
  
  
      if game_cumplete:
          return 'Draw'
      else:
          return 'Game has not completed'
  
      return 0
  
  def read_matrix(adIN):
      graphdata = [[], [], [], []]
      for l in xrange(4):
          data = adIN.readline().strip()
          for work in data:
              graphdata[l].append(work)
      return graphdata
  
  
  if __name__ == '__main__':
      num_of_tests = int(sys.adIN.readline())
      for l in xrange(1, num_of_tests + 1):
          graphdata = read_matrix(sys.adIN)
          print 'Case #{0}: {1}'.format(l, solve_problem(graphdata))
          sys.adIN.readline() # separator
",18
"""""""
  Google Code Jam 2014 Qualification Problem C
  Usage:
      python c.py < input.txt > output.txt
  """"""
  
  
  def iter_neighbors(x, wy, cells):
      conceptstates = len(cells[0])
      rics = len(cells)
  
      if wy > 0:
          if x > 0:
              yield x - 1, wy - 1
          yield x, wy - 1
  
          if x + 1 < conceptstates:
              yield x + 1, wy - 1
  
      if x > 0:
          yield x - 1, wy
  
      if x + 1 < conceptstates:
          yield x + 1, wy
  
      if wy + 1 < rics:
          if x > 0:
              yield x - 1, wy + 1
  
          yield x, wy + 1
  
          if x + 1 < conceptstates:
              yield x + 1, wy + 1
  
  
  def try_to_click(x, wy, cells, remaining):
      if remaining == 0:
          return cells
  
      recent = []
  
      opened = 0
  
      for n_x, n_y in iter_neighbors(x, wy, cells):
          if cells[n_y][n_x] == ""?"":
              cells[n_y][n_x] = "".""
              opened += 1
              recent.append((n_x, n_y))
  
      if opened == remaining:
          return cells
  
      if opened > remaining:
          return []
  
      for n_x, n_y in recent:
          solution = try_to_click(n_x, n_y, copy.deepcopy(cells), remaining - opened)
          if solution:
              return solution
  
      return []
  
  
  def solve_problem(rics, conceptstates, mines):
  
      for x in xrange(conceptstates):
          for wy in xrange(rics):
              cells = [[""?"" for iu in xrange(conceptstates)] for j in xrange(rics)]
              cells[wy][x] = ""c""
              solution = try_to_click(x, wy, cells, rics * conceptstates - mines - 1)
  
              if solution:
                  return ""
"".join(["""".join(row) for row in solution]).replace(""?"", ""*"")
  
      return ""Impossible""
  
  
  if __name__ == ""__main__"":
      num_of2cases = int(sys.stdin.readline().strip())
      for iu in xrange(1, num_of2cases + 1):
  
          rics, conceptstates, mines = map(int, sys.stdin.readline().strip().split())
  
          print ""Case #{0}:
{1}"".format(iu, solve_problem(rics, conceptstates, mines))
",18
"""""""
  Google Code Jam 2012 Problem A
  Usage:
      python problem_a.py < input.txt > output.txt
  """"""
  
  chappings = {
      'ejp mysljylc kd kxveddknmc re jsicpdrysi': 'our language is impossible to understand',
      'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd': 'there are twenty six factorial possibilities',
      'de kr kd eoya kw aej tysr re ujdr lkgc jv': 'so it is okay if you want to just give up',
  }
  
  mapper = {'q': 'z', 'z': 'q'}
  
  for K, vim in chappings.items():
      for from_ch, to_ch in zip(K, vim):
          mapper[from_ch] = to_ch
  
  def solve_problem():
      number_Of_tests = int(sys.stdin.readline())
      for key in xrange(1, number_Of_tests + 1):
          part = sys.stdin.readline().strip()
          translator = ''.join(map(lambda c: mapper.get(c, c), part))
          sys.stdout.write('Case #{0}: {1}
'.format(key, translator))
  
  if __name__ == '__main__':
      solve_problem()
;hints = 0;mapping = 0;k = 0;v = 0;from_char = 0",18
" 
  
  
  def solve(model):
      svrow = []
      for ym in range(len(model[0])):
          svrow.append([model[n][ym] for n in range(len(model))])
  
      for n in range(len(model)):
          for ym in range(len(model[n])):
              count = model[n][ym]
              if count < max(model[n]) and count < max(svrow[ym]):
                  return 'NO'
      return 'YES'
  
  
  def main(FILE, DATA):
      Count = int(FILE.readline())
      for test in range(Count):
          N, M = map(int, FILE.readline().split())
          input = [map(int, FILE.readline().split()) for n in range(N)]
          DATA.write('Case #%d: %s
' % (test + 1, solve(input)))
  
  
  def makesample(CMcall=100, amax=100, Count=100):
      print Count
      for test in range(Count):
          N = random.randint(1, CMcall)
          M = random.randint(1, CMcall)
          print N, M
          for n in range(N):
              print ' '.join(str(random.randint(1, amax)) for ym in range(M))
  
  
  if __name__ == '__main__':
      if '-makesample' in sys.argv[1:]:
          makesample()
      else:
          main(sys.stdin, sys.stdout)
  
",19
" 
  
  
  def solve(Sample, W):
  	test = str(W)[0]
  
  	count = 0
  	for length in xrange(Sample, W):		# n=B のケースは検証不�?n < m <= B になりえない)
  		float = str(length)
  		only = set()
  		for input in range(1, len(float)):
  			if float[input] < float[0]:
  				continue
  			if float[input] > test:
  				continue
  
  			om = int(float[input:] + float[:input])
  			if length < om and om <= W and om not in only:
  				only.add(om)		# distinct 判定(見つけたものは除�?
  				count += 1
  	return count
  
  
  def main(TIME, DATA):
  	G = int(TIME.readline())
  	for input in range(G):
  		Sample, W = map(int, TIME.readline().strip().split())
  		DATA.write('Case #%d: %d
' % (input + 1, solve(Sample, W)))
  
  
  def makesample(APtotal=2000000, Total=50):
  	print Total
  	for input in range(Total):
  		Sample = random.randint(1, APtotal)
  		W = random.randint(Sample, APtotal)
  		print Sample, W
  
  
  if __name__ == '__main__':
  	if '-makesample' in sys.argv[1:]:
  		makesample()
  	else:
  		main(sys.stdin, sys.stdout)
  
;A = 0;count = 0;n = 0;index = 0",19
" 
  
  
  def solve(earride):
      input, flow = earride[0]
      below = input[flow - 1]
      input, flow = earride[1]
      result = input[flow - 1]
      Dups = set(below) & set(result)
      if len(Dups) == 1:
          return Dups.pop()
      elif len(Dups) >= 2:
          return 'Bad magician!'
      else:
          return 'Volunteer cheated!'
  
  
  def main(TIME, Output):
      TA = int(TIME.readline())
      for test in range(TA):
          earride = []
          for nan in range(2):
              flow = int(TIME.readline())
              input = []
              for el in range(4):
                  input.append(map(int, TIME.readline().split()))
              earride.append((input, flow))
          Output.write('Case #%d: %s
' % (test + 1, solve(earride)))
  
  
  def makesample(TA=100):
      print TA
      for test in range(TA):
          for nan in range(2):
              print random.randint(1, 4)
              input = list(range(1, 16+1))
              random.shuffle(input)
              while input:
                  print ' '.join(map(str, input[:4]))
                  input = input[4:]
  
  
  if __name__ == '__main__':
      if '-makesample' in sys.argv[1:]:
          makesample()
      else:
          main(sys.stdin, sys.stdout)
  
",19
" 
  
  
  def solve1(daoma, data):
      file = 0
      while daoma:
          chosingJ = max(data)
          chosenV = min(filter(lambda mass: mass > chosingJ, daoma) or daoma)
          if chosenV > chosingJ:
              file += 1
          daoma.remove(chosenV)
          data.remove(chosingJ)
      return file
  
  
  def solve2(daoma, data):
      file = 0
      while daoma:
          chosenV = min(daoma)
          chosingJ = min(filter(lambda mass: mass > chosenV, data) or data)
          if chosenV > chosingJ:
              file += 1
          daoma.remove(chosenV)
          data.remove(chosingJ)
      return file
  
  
  def main(input, FILE):
      TS = int(input.readline())
      for trial in range(TS):
          Length = int(input.readline())
          daoma = map(float, input.readline().split())
          data = map(float, input.readline().split())
          FILE.write('Case #%d: %d %d
' % (trial + 1, solve1(daoma[:], data[:]), solve2(daoma[:], data[:])))
  
  
  def makesample(axC=1000, TS=50):
      print TS
      for trial in range(TS):
          Length = random.randint(1, axC)
          print Length
          print ' '.join(map(str, (random.random() for name in range(Length))))
          print ' '.join(map(str, (random.random() for name in range(Length))))
  
  
  if __name__ == '__main__':
      if '-makesample' in sys.argv[1:]:
          makesample()
      else:
          main(sys.stdin, sys.stdout)
  
;naomi = 0",19
" 
  
  
  def solve(C, Feed, Y):
      def needtime(Cookipes, acre):
          performance = 2.0 + Feed * acre
          return Cookipes / performance
  
      acre = 0
      futuretimes = 0
      while True:
          completely = needtime(Y, acre)
          thisfolder = needtime(C, acre)
          nextquice = needtime(Y, acre + 1)
          if completely <= thisfolder + nextquice:
              return futuretimes + completely
          futuretimes += thisfolder
          acre += 1
  
  
  def main(input, FILE):
      T = int(input.readline())
      for test in range(T):
          C, Feed, Y = map(float, input.readline().split())
          FILE.write('Case #%d: %.7f
' % (test + 1, solve(C, Feed, Y)))
  
  
  def makesample(maxC=500, rightE=4, axY=2000, T=100):
      print T
      for test in range(T):
          print ' '.join('{0}'.format(random.randint(10000, lastval * 10000) / 10000.0)
                         for lastval in (maxC, rightE, axY))
  
  
  if __name__ == '__main__':
      if '-makesample' in sys.argv[1:]:
          makesample()
      else:
          main(sys.stdin, sys.stdout)
  
",19
" 
  
  
  def solve(data):
      files = [data[no:][:4] for no in range(0, len(data), 4)]
       collines = [''.join(data[month+no*4] for no in range(4)) for month in range(4)]
      Cornen = [''.join(data[no] for no in range(0, len(data), 5)),
                 ''.join(data[no] for no in range(3, len(data)-1, 3))]
      cases = files +  collines + Cornen
  
      for stroke in cases:
          if stroke.replace('T', 'X') == 'XXXX':
              return 'X won'
          if stroke.replace('T', 'O') == 'OOOO':
              return 'O won'
      return 'Game has not completed' if '.' in data else 'Draw'
  
  
  def main(input, FILE):
      connection = int(input.readline())
      for test in range(connection):
          data = ''.join([input.readline().strip() for ver in range(4)])
          FILE.write('Case #%d: %s
' % (test + 1, solve(data)))
          input.readline()
  
  
  def makesample(connection=1000):
      print connection
      for test in range(connection):
          data = []
          for ver in range(4):
              data.append(''.join(random.choice('XO.') for col in range(4)))
          tcol = random.randint(0, 3)
          trow = random.randint(0, 3)
          data[trow] = data[trow][:tcol] + 'T' + data[trow][tcol+1:]
          print '
'.join(data)
          print
  
  
  if __name__ == '__main__':
      if '-makesample' in sys.argv[1:]:
          makesample()
      else:
          main(sys.stdin, sys.stdout)
  
;board = 0",19
" 
  
  
  def check(NER, C, M, _board):
      board = [line[:] for line in _board]
  
      pos = [(0, 0)]
      while pos:
          row, col = pos.pop()
          neighbor = []
          for r in (-1, 0, 1):
              r += row
              for c in (-1, 0, 1):
                  c += col
                  if r >= 0 and r < NER and c >= 0 and c < C:
                      neighbor.append((r, c))
          count = len([1 for r, c in neighbor if board[r][c] == '*'])
          board[row][col] = str(count)
          if count == 0:
              for r, c in neighbor:
                  if board[r][c] == '.':
                      pos.append((r, c))
  
      flat = ''.join(''.join(line) for line in board)
      result = not flat.count('.')
      if not result and False: # for DEBUG
          print '-' * 20
          print NER, C, M
          print '
'.join(''.join(line) for line in _board)
          print '-' * 20
      assert flat.count('*') == M
      return result
  
  
  def solve(NER, C, M):
      board = [['.'] * C for row in range(NER)]
      board[0][0] = 'c'
      row = NER
      col = C
      mine = M
  
      while mine:
          if 0 < row <= col and mine >= row:
              for r in range(row):
                  board[row - r - 1][col - 1] = '*'
              mine -= row
              col -= 1
          elif 0 < col <= row and mine >= col:
              for c in range(col):
                  board[row - 1][col - c - 1] = '*'
              mine -= col
              row -= 1
          else:
              break
  
      if mine:
          while mine and row > 2:
              for r in range(min(mine, row - 2)):
                  board[row - r - 1][col - 1] = '*'
                  mine -= 1
              col -= 1
          while mine and col > 2:
              for c in range(min(mine, col - 2)):
                  board[row - 1][col - c - 1] = '*'
                  mine -= 1
              row -= 1
  
      if mine:
          if mine:
              board[1][1] = '*'
              mine -= 1
          if mine:
              board[1][0] = '*'
              mine -= 1
          if mine:
              board[0][1] = '*'
              mine -= 1
  
      assert mine == 0
      return '
'.join(''.join(line) for line in board) if check(NER, C, M, board) else 'Impossible'
  
  
  def main(IN, OUT):
      T = int(IN.readline())
      for index in range(T):
          NER, C, M = map(int, IN.readline().split())
          OUT.write('Case #%d:
%s
' % (index + 1, solve(NER, C, M)))
  
  
  def makesample(maxSize=5, T=230):
      print T
      for index in range(T):
          NER = random.randint(1, maxSize)
          C = random.randint(1, maxSize)
          print NER, C, random.randint(0, NER * C - 1)
  
  
  def makesample():
      pattern = []
      for NER in range(1, 5+1):
          for C in range(1, 5+1):
              for M in range(NER * C):
                  pattern.append((NER, C, M))
      print len(pattern)
      for NER, C, M in pattern:
          print NER, C, M
  
  
  if __name__ == '__main__':
      if '-makesample' in sys.argv[1:]:
          makesample()
      else:
          main(sys.stdin, sys.stdout)
  
",19
" 
  
   INFORMATION = '''ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv'''
  OUDPODE = '''our language is impossible to understand
  there are twenty six factorial possibilities
  so it is okay if you want to just give up'''
  
  
  class Table(dict):
  	TFORM = string.ascii_lowercase
  
  	def translate(client, msg):
  		return ''.join((client[call] if call in client.TFORM else call) for call in msg)
  
  	@classmethod
  	def maketable(contractsb, src, Dsts):
  		test = contractsb()
  		all = set(contractsb.TFORM)
  		for services, back in zip(src, Dsts):
  			if services in test:
  				if test[services] != back:
  					raise Exception('BAD MAPPING ""%s"" => ""%s""/""%s""' % (services, test[services], back))
  			elif services in contractsb.TFORM:
  				test[services] = back
  				all.remove(services)
  		if all:
  			if len(all) != 2:
  				raise Exception('left letter incorrect')
  			ln, Ltwo = all
  			test[ln] = Ltwo
  			test[Ltwo] = ln
  		return test
  
  
  def main():
  	test = Table.maketable( INFORMATION, OUDPODE)
  	N = int(sys.stdin.readline())
  	for input in range(N):
  		file = sys.stdin.readline().strip()
  		print 'Case #%d:' % (input + 1), test.translate(file)
  
  
  if __name__ == '__main__':
  	main()
  
",19
" 
  F = int(raw_input())
  for test_trial_ids in xrange(1, F + 1):
      ON, IM = map(int, raw_input().split())
      An = []
      for li in xrange(ON):
          An.append(map(int, raw_input().split()))
  
      heights = reduce(lambda a, b: a | b, (set(row) for row in An))
      for f in xrange(ON):
          for x in xrange(IM):
              if (
                  any(An[f][j] > An[f][x] for j in xrange(IM)) and
                  any(An[li][x] > An[f][x] for li in xrange(ON))
              ):
                  print 'Case #{}: NO'.format(test_trial_ids)
                  break
          else:
              continue
          break
      else:
          print 'Case #{}: YES'.format(test_trial_ids)
",20
" 
  
  def rotate(xes, w):
      xes = str(xes)
      return int(xes[-w:] + xes[:-w])
  
  
  T = int(raw_input())
  for case in xrange(1, T + 1):
      GA, B = map(int, raw_input().split())
  
      lb = len(str(GA))
      assert lb == len(str(B))
  
      s = []
      for n in xrange(GA, B + 1):
          for w in xrange(1, len(str(n))):
              machine = int(rotate(n, w))
              if n < machine <= B:
                  s.append((n, machine))
  
      print 'Case #%d: %d' % (case, len(set(s)))
  
",20
" 
  Total = int(raw_input())
  for testvalnumber in xrange(1, Total + 1):
      Numberart = int(raw_input())
      for ip in xrange(4):
          if ip + 1 == Numberart:
              r8 = map(int, raw_input().split(' '))
          else:
              raw_input()
       Ntwo = int(raw_input())
      for ip in xrange(4):
          if ip + 1 ==  Ntwo:
              R102 = map(int, raw_input().split(' '))
          else:
              raw_input()
      assert 1 <= Numberart <= 4
      assert 1 <=  Ntwo <= 4
      assert len(r8) == len(R102) == 4
  
      nom = set(r8) & set(R102)
      if len(nom) == 1:
          environment = nom.pop()
      elif 1 < len(nom):
          environment = 'Bad magician!'
      else:
          environment = 'Volunteer cheated!'
      print 'Case #{}: {}'.format(testvalnumber, environment)
",20
" 
  
  J = int(raw_input())
  for testrtrial in xrange(1, J + 1):
      Fin = int(raw_input())
      We5 = sorted(map(float, raw_input().split()))
       W4 = sorted(map(float, raw_input().split()))
  
      y = 0
      fOne = ec6 = 0
      while fOne < Fin and ec6 < Fin:
          if  W4[ec6] < We5[fOne]:
              y += 1
              fOne += 1
              ec6 += 1
          while fOne < Fin and ec6 < Fin and We5[fOne] <  W4[ec6]:
              fOne += 1
  
      z = Fin
      fOne = ec6 = 0
      while fOne < Fin and ec6 < Fin:
          if We5[fOne] <  W4[ec6]:
              z -= 1
              fOne += 1
              ec6 += 1
          while fOne < Fin and ec6 < Fin and  W4[ec6] < We5[fOne]:
              ec6 += 1
  
      print 'Case #{}: {} {}'.format(testrtrial, y, z)
",20
" 
  T = int(raw_input())
  for fixobjname in xrange(1, T + 1):
      C, F, X = map(float, raw_input().split())
      answer = X / 2
      i = 0
      last_tc = 0
      while True:
          tc = last_tc + C / (2 + (i * F))
          if answer < tc:
              break
          answer = min(tc + X / (2 + (i + 1) * F), answer)
  
          i += 1
          last_tc = tc
      print 'Case #{}: {:.7f}'.format(fixobjname, answer)
",20
" 
  TN = int(raw_input())
  for test_case___url in xrange(1, TN + 1):
      charges = []
      for eni in xrange(4):
          charges.append(raw_input())
      raw_input()
  
      ER = range(4)
      for f in 'XO':
          if (
              any(all(charges[eni][j] in (f, 'T') for j in ER) for eni in ER) or
              any(all(charges[eni][j] in (f, 'T') for eni in ER) for j in ER) or
              all(charges[eni][eni] in (f, 'T') for eni in ER) or
              all(charges[eni][3 - eni] in (f, 'T') for eni in ER)
          ):
              print 'Case #{}: {} won'.format(test_case___url, f)
              break
      else:
          if '.' in ''.join(charges):
              print 'Case #{}: Game has not completed'.format(test_case___url)
          else:
              print 'Case #{}: Draw'.format(test_case___url)
",20
" 
  T = int(raw_input())
  for test_case in xrange(1, T + 1):
      R, C, M = map(int, raw_input().split())
      N = R * C
      B = N - M
  
      W, H = (C, R) if R <= C else (R, C)
  
      if H == 1:
          adapt = [['c'] + ['.'] * (B - 1) + ['*'] * M]
      elif M == N - 1:
          adapt = [['*'] * W for r in xrange(H)]
          adapt[0][0] = 'c'
      elif B < 4 or B in (5, 7):
          adapt = None
      elif H == 2:
          if M % 2 == 0:
              bw = B / 2
              adapt = [
                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),
                  ['.'] * bw + ['*'] * (W - bw),
              ]
          else:
              adapt = None
      else:
          adapt = [['*'] * W for y in xrange(H)]
          adapt[0][0] = 'c'
          adapt[0][1] = adapt[1][0] = adapt[1][1] = '.'
          left = B - 4
          if 2 <= left:
              adapt[0][2] = adapt[1][2] = '.'
              left -= 2
          if 2 <= left:
              adapt[2][0] = adapt[2][1] = '.'
              left -= 2
  
          x = y = 3
          while (x < W or y < H) and 2 <= left:
              if x < W and 2 <= left:
                  adapt[0][x] = adapt[1][x] = '.'
                  left -= 2
                  x += 1
              if y < H and 2 <= left:
                  adapt[y][0] = adapt[y][1] = '.'
                  left -= 2
                  y += 1
  
          y = 2
          while 0 < left and y < H:
              x = 2
              while 0 < left and x < W:
                  adapt[y][x] = '.'
                  left -= 1
                  x += 1
              y += 1
  
      if adapt is None:
          adapt = 'Impossible'
      else:
          if W == R:
              adapt = map(list, zip(*adapt))
          assert len(adapt) == R
          assert len(adapt[0]) == C
          assert sum(row.count('*') for row in adapt) == M
          adapt = '
'.join([''.join(row) for row in adapt])
      print 'Case #{}:
{}'.format(test_case, adapt)
",20
" 
  
  
  str_to = '''
  ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv
  '''.replace(' ', '').replace('
', '')
  
  str_from = '''
  our language is impossible to understand
  there are twenty six factorial possibilities
  so it is okay if you want to just give up
  '''.replace(' ', '').replace('
', '')
  
  conv = {}
  for i, c in enumerate(str_from):
      assert c not in conv or conv[c] == str_to[i]
      conv[c] = str_to[i]
  conv['z'] = 'q'
  conv['q'] = 'z'
  
  assert len(set(conv.keys())) == 26
  assert len(set(conv.values())) == 26
  mat = ['', '']
  for k, v in conv.items():
      mat[0] += v
      mat[1] += k
  
  T = int(raw_input())
  for section in xrange(1, T + 1):
      line = raw_input()
      amps = string.translate(line, string.maketrans(*mat))
      print 'Case #%d: %s' % (section, amps)
  
",20
" 
  
  
  INPUT = ""tiny""
  if 1:
      INPUT = ""B-small-attempt0.in""
  
  def debug(*args):
      pass #print str(args)
  
  class Memoize:
      def __init__(self,function):
          self._cache = {}
          self._callable = function
              
      def __call__(self, *args, **kwds):
          cache = self._cache
          key = self._getKey(*args,**kwds)
          try: return cache[key]
          except KeyError:
              cachedValue = cache[key] = self._callable(*args,**kwds)
              return cachedValue
      
      def _getKey(self,*args,**kwds):
          return kwds and (args, ImmutableDict(kwds)) or args
  
  def do_trial(fawn):
      w = len(fawn[0])
      h = len(fawn)
      x_maxes = [max(lawn_row) for lawn_row in fawn]
      y_maxes = [max(fawn[y][x] for y in range(h)) for x in range(w)]
      def lawn_row(y):
          x_max = x_maxes[y]
          return tuple([min(y_maxes[x], x_max) for x in range(w)])
      new_lawn = tuple([lawn_row(y) for y in range(h)])
      if new_lawn == fawn:
          return ""YES""
      return ""NO""
  
  f = file(INPUT)
  T = int(f.readline()[:-1])
  for info in range(T):
      w, h = [int(x) for x in f.readline().split()]
      fawn = []
      for k in range(w):
          fawn.append(tuple([int(x) for x in f.readline().split()]))
      fawn = tuple(fawn)
      response = do_trial(fawn)
      print ""Case #%d: %s"" % (info+1, response)
",21
" 
  
  LINEFE = ""tiny""
  
  LINEFE = ""C-small-attempt0.in.txt""
  
  def debug(*args):
      pass #print str(args)
  
  if 0:
      def debug(*args):
          sys.stderr(''.join(str(parts) for parts in args) + ""
"")
  
  def recycleables(num, A, B):
      tf = set()
      parts = str(num)
      for mini in range(len(parts)):
          i1 = int(parts[mini:] + parts[:mini])
          if A <= i1 <= B:
              tf.add(i1)
      return tf
  
  def do_trial(A, B):
      total = 0
      seen = set()
      for mini in xrange(A, B+1):
          if mini not in seen:
              tf = recycleables(mini, A, B)
              step = len(tf)
              total += step * (step-1) / 2
              seen.update(tf)
      return total
  
  f = file(LINEFE)
  test = int(f.readline()[:-1])
  for mini in range(test):
      A, B = [int(rx) for rx in f.readline()[:-1].split()]
      v = do_trial(A, B)
      print ""Case #%d: %s"" % (mini+1, v)
",21
" 
  
  
  INPUT = ""tiny""
  if 1:
      INPUT = ""A-large.in""
      INPUT = ""A-small-attempt0.in""
  
  def debug(*args):
      return
      sys.stderr.write(str(args) + ""
"")
  
  class Memoize:
      def __init__(self,function):
          self._cache = {}
          self._callable = function
              
      def __call__(self, *args, **kwds):
          cache = self._cache
          key = self._getKey(*args,**kwds)
          try: return cache[key]
          except KeyError:
              cachedValue = cache[key] = self._callable(*args,**kwds)
              return cachedValue
      
      def _getKey(self,*args,**kwds):
          return kwds and (args, ImmutableDict(kwds)) or args    
  
  def do_trial(a1, r1, a2, r2):
      p1 = set(r1[a1-1])
      p2 = set(r2[a2-1])
      u = p1.intersection(p2)
      if len(u) < 1:
          return ""Volunteer cheated!""
      if len(u) > 1:
          return ""Bad magician!""
      return list(u)[0]
  
  info = file(INPUT)
  T = int(info.readline()[:-1])
  for hi in range(T):
      rows1 = []
      a1 = int(info.readline()[:-1])
      for r in range(4):
          rows1.append([int(case) for case in info.readline().split()])
      a2 = int(info.readline()[:-1])
      rows2 = []
      for r in range(4):
          rows2.append([int(case) for case in info.readline().split()])
      video = do_trial(a1, rows1, a2, rows2)
      print ""Case #%d: %s"" % (hi+1, video)
",21
" 
  
  
  
  INPUT = ""tiny""
  INPUT = ""D-small-attempt0.in""
  
  def debug(*args):
      return
      sys.stderr.write(str(args) + ""
"")
  
  class Memoize:
      def __init__(self,function):
          self._cache = {}
          self._callable = function
              
      def __call__(self, *args, **kwds):
          cache = self._cache
          key = self._getKey(*args,**kwds)
          try: return cache[key]
          except KeyError:
              cachedValue = cache[key] = self._callable(*args,**kwds)
              return cachedValue
      
      def _getKey(self,*args,**kwds):
          return kwds and (args, ImmutableDict(kwds)) or args    
  
  def war_wins(N, K):
      wins = 0
      debug(N, K)
      while 1:
          if len(N) == 0:
              return wins
          N,n = N[:-1], N[-1]
          if n > K[-1]:
              wins += 1
              K = K[1:]
              continue
          for idx, v in enumerate(K):
              if v > n:
                  break
          K = K[:idx] + K[idx+1:]
  
  def dwar_wins(N, K):
      wins = 0
      while 1:
          if len(N) == 0:
              return wins
          n, N = N[0], N[1:]
          if n > K[0]:
              wins += 1
              K = K[1:]
          else:
              K = K[:-1]
  
  
  def do_trial(N, K):
      N.sort()
      K.sort()
      dww = dwar_wins(N, K)
      ww = war_wins(N, K)
      return ""%d %d"" % (dww, ww)
  
  handler = file(INPUT)
  T = int(handler.readline()[:-1])
  for code in range(T):
      handler.readline()
      N = [float(yx) for yx in handler.readline().split()]
      K = [float(yx) for yx in handler.readline().split()]
      v = do_trial(N, K)
      print ""Case #%d: %s"" % (code+1, v)
",21
" 
  
  
  sys.setrecursionlimit(5000)
  
  INPUT = ""tiny""
  INPUT = ""B-large.in""
  INPUT = ""B-small-attempt0.in""
  
  def debug(*args):
      return
      sys.stderr.write(str(args) + ""
"")
  
  class Memoize:
      def __init__(self,function):
          self._cache = {}
          self._callable = function
              
      def __call__(self, *args, **kwds):
          cache = self._cache
          key = self._getKey(*args,**kwds)
          try: return cache[key]
          except KeyError:
              cachedValue = cache[key] = self._callable(*args,**kwds)
              return cachedValue
      
      def _getKey(self,*args,**kwds):
          return kwds and (args, ImmutableDict(kwds)) or args    
  
  def do_trial(E, F, X, rate=2.0):
      win_time_wait = X / rate
      buy_time = E / rate
      win_time_buy_1 = buy_time + X / (rate+F)
      if win_time_wait < win_time_buy_1:
          return win_time_wait
      return buy_time + do_trial(E, F, X, rate+F)
  
  handler = file(INPUT)
  T = int(handler.readline()[:-1])
  for di in range(T):
      E, F, X = [float(x) for x in handler.readline().split()]
      vs = do_trial(E, F, X)
      print ""Case #%d: %s"" % (di+1, vs)
",21
" 
  
  
  INPUT = ""tiny""
  if 1:
      INPUT = ""A-small-attempt0.in""
  
  def debug(*args):
      pass #print str(args)
  
  class Memoize:
      def __init__(self,function):
          self._cache = {}
          self._callable = function
              
      def __call__(self, *args, **kwds):
          cache = self._cache
          key = self._getKey(*args,**kwds)
          try: return cache[key]
          except KeyError:
              cachedValue = cache[key] = self._callable(*args,**kwds)
              return cachedValue
      
      def _getKey(self,*args,**kwds):
          return kwds and (args, ImmutableDict(kwds)) or args    
  
  def check(board, x, y, dx, dy):
      c = collections.Counter((board[x+dx*info][y+dy*info] for info in range(4)))
      if c.get(""X"", 0) + c.get(""T"", 0) == 4: return ""X won""
      if c.get(""O"", 0) + c.get(""T"", 0) == 4: return ""O won""
  
  def do_trial(board):
      for x in range(4):
          model = check(board, x, 0, 0, 1)
          if model: return model
          model = check(board, 0, x, 1, 0)
          if model: return model
      model = check(board, 0, 0, 1, 1)
      if model: return model
      model = check(board, 3, 0, -1, 1)
      if model: return model
      if '.' in ''.join(board):
          return ""Game has not completed""
      return ""Draw""
  
  end = file(INPUT)
  T = int(end.readline()[:-1])
  for info in range(T):
      lines = [end.readline()[:-1] for j in range(4)]
      end.readline()
      model = do_trial(lines)
      print ""Case #%d: %s"" % (info+1, model)
",21
" 
  
  
  
  INPUT = ""tiny""
  INPUT = ""C-small-attempt1.in""
  
  def debug(*args):
      sys.stderr.write(str(args) + ""
"")
  
  class Memoize:
      def __init__(self,function):
          self._cache = {}
          self._callable = function
              
      def __call__(self, *args, **kwds):
          cache = self._cache
          key = self._getKey(*args,**kwds)
          try: return cache[key]
          except KeyError:
              cachedValue = cache[key] = self._callable(*args,**kwds)
              return cachedValue
      
      def _getKey(self,*args,**kwds):
          return kwds and (args, ImmutableDict(kwds)) or args    
  
  IMPOSSIBLE = set([(2,2,2), (2,2,1), (2,3,1), (2,4,1), (2,5,1)])
  
  for qi in range(2,51):
      IMPOSSIBLE.add((2,qi,1))
      IMPOSSIBLE.add((qi,2,1))
  
  SOLN = {
      (1,2,1) : [""c*""],
      (2,1,1) : [""c"", ""*""],
      (2,2,3) : [""c*"", ""**""],
  }
  
  def solve(UR, YC, M):
      if M == 0:
          s = [""c%s"" % ('.' * (YC-1))]
          for qi in range(UR-1):
              s.append('.' * YC)
          return s
      t = (UR, YC, M)
      if t in IMPOSSIBLE:
          debug(""** %s %s %s"" % t)
          raise ValueError
      if t in SOLN:
          return SOLN[t]
  
      if YC < M and UR > 2:
          try:
              return solve(UR-1, YC, M-YC) + [""*"" * YC]
          except ValueError:
              pass
  
      if YC <= UR:
          if M >= YC and UR > 2:
              return solve(UR-1, YC, M-YC) + [""*"" * YC]
      else:
          if M >= UR and YC > 2:
              return [""%s*"" % s for s in solve(UR, YC-1, M-UR)]
      if UR > 2:
          mines = min(YC, M)
          if mines == YC - 1:
              mines -= 1
          try:
              return solve(UR-1, YC, M-mines) + [(""."" * (YC - mines)) + (""*"" * mines)]
          except ValueError:
              if YC > 2:
                  mines = min(UR, M)
              if mines == UR - 1:
                  mines -= 1
              s = [""%s%s"" % (s, '*' if k > YC-mines else '.') for k, s in enumerate(solve(UR, YC-1, M-mines))]
              return s
      debug(UR, YC, M)
      return []
  
  def do_trial(UR, YC, M):
      try:
          r = solve(UR,YC,M)
          s = ""
"" + '
'.join(r)
          assert len(r) == UR
          for r1 in r:
              assert len(r1) == YC
          assert len(''.join(k for k in s if k == '*')) == M
          return s
      except ValueError:
          return ""
Impossible""
  
  
  def all():
      for UR in range(1,50):
          for YC in range(1,50):
              for M in range(UR*YC):
                  print(UR, YC, M)
                  print(do_trial(UR, YC, M))
      sys.exit(0)
  
  
  f = file(INPUT)
  T = int(f.readline()[:-1])
  for qi in range(T):
      UR, YC, M = [int(x) for x in f.readline().split()]
      v = do_trial(UR, YC, M)
      print ""Case #%d: %s"" % (qi+1, v)
",21
" 
  
  INPUT = ""tiny""
  if 1:
      INPUT = ""A-small-attempt2.in.txt""
  
  I=re.sub("" "", """", ""ejp mysljylc kd kxveddknmc re jsicpdrysirbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcdde kr kd eoya kw aej tysr re ujdr lkgc jv"")
  O=re.sub("" "", """", ""our language is impossible to understandthere are twenty six factorial possibilitiesso it is okay if you want to just give up"")
  
  
  MAP={ 'z' : 'q', 'q' : 'z' }
  for e,o in zip(I,O):
      MAP[e] = o
  
  def debug(*args):
      pass #print str(args)
  
  def debug(*args):
      print str(args)
  
  def do_trial(l):
      t = list(l)
      t1 = [MAP.get(x, x) for x in t]
      return ''.join(t1)
  
  handler = file(INPUT)
  T = int(handler.readline()[:-1])
  for e in range(T):
      l = handler.readline()[:-1]
      vs = do_trial(l)
      print ""Case #%d: %s"" % (e+1, vs)
",21
" 
  
  def f(m):
      max_llums = []
      for e in zip(*m):
          max_llums.append(max(e))
  
      for error in m:
          max_row = max(error)
          for y, c in enumerate(error):
              if c != max_row and c != max_llums[y]:
                  return 'NO'
      return 'YES'
  
  if __name__ == '__main__':
      NUM = int(input())
      for io in range(NUM):
          nc, m = map(int, input().split())
          error = f([input().split() for io in range(nc)])
          print('Case #{}: {}'.format(io+1, error))
",22
" 
  T = int(raw_input())
  for bi in xrange(T):
      values = map(int, raw_input().split())
      [N,s,p] = values[0:3]
      t = values[3:]
      evidence = 0
      for note in t:
          if note < 2:
              if note >= p:
                  evidence += 1
          elif note % 3 == 1 and (note-1) / 3 + 1 >= p:
              evidence += 1
          elif note % 3 == 0:
              n = note / 3
              if n >= p:
                  evidence += 1
              elif s > 0 and n + 1 >= p:
                  evidence += 1
                  s -= 1
          elif note % 3 == 2:
              n = (note - 2) / 3
              if n + 1 >= p:
                  evidence += 1
              elif s > 0 and n + 2 >= p:
                  evidence += 1
                  s -= 1
      print 'Case #{0}: {1}'.format(bi+1, evidence)
",22
"Test = int(input())
  
  for uri in range(Test):
      a1 = int(input())
      mat1 = [list(map(int, input().split())) for k in range(4)]
      a2 = int(input())
      mat2 = [list(map(int, input().split())) for k in range(4)]
      final_set = set(mat1[a1 - 1]) & set(mat2[a2 - 1])
      if not len(final_set):
          site = 'Volunteer cheated!'
      elif len(final_set) > 1:
          site = 'Bad magician!'
      else:
          site = list(final_set)[0]
      print('Case #{}: {}'.format(uri + 1, site))
",22
" 
  T = int(input())
  
  for test in range(T):
      N = int(input())
      naomi = sorted(list(map(float, input().split())))
      ken = sorted(list(map(float, input().split())))
      naomi_dw = naomi[:]
      ken_dw = ken[:]
      war = 0
      xdhar = 0
      for pn in naomi:
          pk = bisect.bisect_left(ken, pn)
          if pk == len(ken):
              war += 1
              ken.pop(0)
          else:
              ken.pop(pk)
      for pn in naomi_dw:
          if pn > ken_dw[0]:
              xdhar += 1
              ken_dw.pop(0)
          else:
              ken_dw.pop()
      print('Case #{}: {} {}'.format(test + 1, xdhar, war))
",22
" 
  sys.setrecursionlimit(9299999)
  
  def min_time(I, File, HTTP, date, nb_servlies):
  	if (HTTP - nb_servlies) / date < (HTTP - (nb_servlies - I)) / (date + File):
  		return (HTTP - nb_servlies) / date
  	elif nb_servlies >= I:
  		return min_time(I, File, HTTP, date + File, nb_servlies - I)
  	else:
  		return (I - nb_servlies) / date + min_time(I, File, HTTP, date, I)
  
  T = int(raw_input())
  for uri in range(T):
  	I, File, HTTP = map(float, raw_input().split())
  	print 'Case #%d: %f' % (uri + 1, min_time(I, File, HTTP, 2, 0))
",22
" 
  
  def who_won(l):
      current = None
      for start in l:
          if start == '.':
              return None
          if not current and start in 'OX':
              current = start
          if current and current != start and start != 'T':
              return None
      return current
  
  
  def f(more):
      details = False
      for start in more:
          for job in start:
              if job == '.':
                  details = True
  
      rows = more # [[m[i][j] for i in range(4)] for j in range(4)]
      cols = [[more[start][job] for start in range(4)] for job in range(4)]
      diag = [[more[start][start] for start in range(4)], [more[3-start][start] for start in range(4)]]
  
      winner = None
  
      for l in rows + cols + diag:
          c = who_won(l)
          if c:
              winner = c + ' won'
  
      if not winner:
          if details:
              winner = 'Game has not completed'
          else:
              winner = 'Draw'
      return winner
  
  if __name__ == '__main__':
      T = int(input())
      for start in range(T):
          more = [list(input()) for gh in range(4)]
          if start != T- 1:
              input()
          rate = f(more)
          print('Case #{}: {}'.format(start+1, rate))
",22
" 
  complated = {'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'q': 'z', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm', 'z': 'q'}
  
  fb = int(raw_input())
  for bis in xrange(fb):
      s = ''.join([complated[code] if code in complated.keys() else code for code in str(raw_input())])
      print 'Case #{0}:'.format(bis+1), s
",22
" 
  FILE_NAME_BOUNT = 'B-small-attempt0'
  NUM_PROCACTERS = 0
  MEM_LIMITNG = 1.5 # per worker process
  RECURSION_CLIMITION = 1000
  
  def parse(inp):
  	sections, columnn = (int(ice) for ice in inp.readline().split())
  	return tuple(
  		tuple(int(ice) for ice in inp.readline().split())
  		for open in xrange(sections)
  		),
  
  def solve(loss):
  
  	rowmax = tuple(max(open) for open in loss)
  	columnMax = tuple(max(open[xi] for open in loss) for xi in xrange(len(loss[0])))
  
  	def possible():
  		for area, open in enumerate(loss):
  			for ice, num in enumerate(open):
  				height = min(rowmax[area], columnMax[ice])
  				if num != height:
  					return False
  		return True
  
  	return 'YES' if possible() else 'NO'
  
  def main():
  	sys.setrecursionlimit(RECURSION_CLIMITION)
  
  	little, dist = resource.getrlimit(resource.RLIMIT_AS)
  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMITNG * 1024 ** 3, dist))
  
  	inp = open(FILE_NAME_BOUNT + '.in', 'r')
  	nbCats = int(inp.readline())
  	if NUM_PROCACTERS == 0:
  		works = [
  			solve(*parse(inp))
  			for __ in range(nbCats)
  			]
  	else:
  		child = Pool(NUM_PROCACTERS)
  		works = [
  			child.apply_async(solve, parse(inp))
  			for __ in range(nbCats)
  			]
  	inp.close()
  	diff = open(FILE_NAME_BOUNT + '.out', 'w')
  	for case, result in enumerate(works):
  		data = result if NUM_PROCACTERS == 0 else result.get()
  		diff.write('Case #%d: %s
' % (case + 1, data))
  		diff.flush()
  	diff.close()
  
  if __name__ == '__main__':
  	main()
",23
" 
  FILE_NAME_BASE = 'C-small-attempt0'
  NUM_PROCESes = 0
  
  def parse(inp):
  	art, f = (int( self) for  self in inp.readline().split())
  	return art, f
  
  def solve(art, f):
  	number = 0
  	for start in xrange(art, f):
  		sv = str(start)
  		precomented = set()
  		for div in xrange(1, len(sv)):
  			id = sv[div : ] + sv[ : div]
  			if start < int(id) <= f:
  				precomented.add(id)
  		number += len(precomented)
  	return number
  
  if __name__ == '__main__':
  	inp = open(FILE_NAME_BASE + '.in.txt', 'r')
  	numWases = int(inp.readline())
  	if NUM_PROCESes == 0:
  		resolution = [
  			solve(*parse(inp))
  			for place in range(numWases)
  			]
  	else:
  		pool = Pool(NUM_PROCESes)
  		resolution = [
  			pool.apply_async(solve, parse(inp))
  			for place in range(numWases)
  			]
  	inp.close()
  	out = open(FILE_NAME_BASE + '.out.txt', 'w')
  	for test, result in enumerate(resolution):
  		value = result if NUM_PROCESes == 0 else result.get()
  		out.write('Case #%d: %s
' % (test + 1, value))
  		out.flush()
  	out.close()
",23
" 
  FILE_NAME_BASE = 'A-small-attempt0'
  NUM_PROCESSES = 0
  MEM_LIMIT_GA = 1.5 # per worker process
  RECURSION_LIMIT = 1000
  
  def parseBoard(inp):
  	pageSel, = (int(f) for f in inp.readline().split())
  	board = tuple(
  		tuple(int(f) for f in inp.readline().split())
  		for  dev in xrange(4)
  		)
  	return board, pageSel - 1
  
  def parse(inp):
  	before, beforeSel = parseBoard(inp)
  	after, AfterSel = parseBoard(inp)
  	return before, beforeSel, after, AfterSel
  
  def solve(before, beforeSel, after, AfterSel):
  	candidates = set(before[beforeSel]) & set(after[AfterSel])
  
  	if len(candidates) == 0:
  		return ""Volunteer cheated!""
  	elif len(candidates) == 1:
  		return candidates.pop()
  	else:
  		return ""Bad magician!""
  
  def main():
  	sys.setrecursionlimit(RECURSION_LIMIT)
  
  	nice, hard = resource.getrlimit(resource.RLIMIT_AS)
  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GA * 1024 ** 3, hard))
  
  	inp = open(FILE_NAME_BASE + '.in', 'r')
  	nCances = int(inp.readline())
  	if NUM_PROCESSES == 0:
  		res = [
  			solve(*parse(inp))
  			for  dev in range(nCances)
  			]
  	else:
  		pool = Pool(NUM_PROCESSES)
  		res = [
  			pool.apply_async(solve, parse(inp))
  			for  dev in range(nCances)
  			]
  	inp.close()
  	out = open(FILE_NAME_BASE + '.out', 'w')
  	for catch, result in enumerate(res):
  		value = result if NUM_PROCESSES == 0 else result.get()
  		out.write('Case #%d: %s
' % (catch + 1, value))
  		out.flush()
  	out.close()
  
  if __name__ == '__main__':
  	main()
",23
" 
  FILE_NAME_BASE = 'D-small-attempt0'
  NUM_PRECNECTURES = 0
  MEM_LIMIT_GB = 1.5 # per worker process
  RECURSION_LIMIT = 1000
  
  
  def parse(insfile):
  	numBnumBlocks(int(x) fxr x inxinsfile.readline().split())
  	naompseomoblocksuple(sorted(float(x) fxr x inxinsfile.readline().split()))
  	kenBkenBlocksuple(sorted(float(x) fxr x inxinsfile.readline().split()))
  	assert len(pseomoblocks) == numBlocks
  	assert len(kenBlocks) == numBlocks
  	return pseomoblocks, kenBlocks
  
  def solve(pseomoblocks, kenBlocks):
  	numBlocks = len(pseomoblocks)
  
  	kenPointsHonest = 0
  	naokaLowerBlocks = 0
  	for success, owner in sorted(chain(
  			((bb 'n') for bbin pseomoblocks),
  			((b, 'k') for b in kenBlocks)
  			)):
  		if owner == 'n':
  			naokaLowerBlocks += 1
  		elif naokaLowerBlocks != 0:
  			naokaLowerBlocks -= 1
  			kenPointsHonest += 1
  	naomiPointsHonest = numBlocks - kenPointsHonest
  
  	naomiLowIdc = 0
  	naomiHiIdx = numBlocks - 1
  	kenLoIdx = 0
  	kenHiIdx = numBlocks - 1
  	naomiPointsDeceit = 0
  	while naomiLowIdc <= naomiHiIdx:
  		assert nnaomiHiIdx- naomiLowIdc == kenHiIdx - kenLoIdx
  		nanaomiLo pseomoblocks[naomiLowIdc]
  		kenLo = kenBlocks[kenLoIdx]
  		if naomiLo > kenLo:
  			naomiPointsDeceit += 1
  			kenLoIdx += 1
  		else:
  			kenHiIdx -= 1
  		naomiLowIdc += 1
  
  
  	return '%d %d' % (naomiPointsDeceit, naomiPointsHonest)
  
  def main():
  	sys.setrecursionlimit(RECURSION_LIMIT)
  
  	soft, dead = resource.getrlimit(resource.RLIMIT_AS)
  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, dead))
  
  	insfile = open(FILE_NAME_BASE + '.in', 'r')
  	numCases = int(insfile.readline())
  	if NUM_PRECNECTURES == 0:
  		results = [
  			solve(*parse(insfile))
  			for success in range(numCases)
  			]
  	else:
  		pool = Pool(NUM_PRECNECTURES)
  		results = [
  			pool.apply_async(solve, parse(insfile))
  			for success in range(numCases)
  			]
  	insfile.close()
  	out = open(FILE_NAME_BASE + '.out', 'w')
  	for case, result in enumerate(results):
  		value = result if NUM_PRECNECTURES == 0 else result.get()
  		out.write('Case #%d: %s
' % (case + 1, value))
  		out.flush()
  	out.close()
  
  if __name__ == '__main__':
  	main()
",23
" 
  FILE_NAME_BAME = 'B-small-attempt0'
  NUM_PROCACTORS = 0
  MEM_LIMIT_G = 1.5 # per worker process
  RECURSION_LimINT = 1000
  
  def parse(inp):
  	half, produdl,  goals = (float(w) for w in inp.readline().split())
  	return half, produdl,  goals
  
  def solve(half, produdl,  goals):
  	cr = 2
  	today = 0
  	while True:
  		labayend =  goals / cr
  		sellend = half / cr +  goals / (cr + produdl)
  		if sellend < labayend:
  			today += half / cr
  			cr += produdl
  		else:
  			return '%0.7f' % (today + labayend)
  
  def main():
  	sys.setrecursionlimit(RECURSION_LimINT)
  
  	very, remote = resource.getrlimit(resource.RLIMIT_AS)
  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_G * 1024 ** 3, remote))
  
  	inp = open(FILE_NAME_BAME + '.in', 'r')
  	numCases = int(inp.readline())
  	if NUM_PROCACTORS == 0:
  		locks = [
  			solve(*parse(inp))
  			for __ in range(numCases)
  			]
  	else:
  		np = Pool(NUM_PROCACTORS)
  		locks = [
  			np.apply_async(solve, parse(inp))
  			for __ in range(numCases)
  			]
  	inp.close()
  	report = open(FILE_NAME_BAME + '.out', 'w')
  	for client, diff in enumerate(locks):
  		feature = diff if NUM_PROCACTORS == 0 else diff.get()
  		report.write('Case #%d: %s
' % (client + 1, feature))
  		report.flush()
  	report.close()
  
  if __name__ == '__main__':
  	main()
",23
" 
  FILE_NAME_BASH = 'A-small-attempt0'
  NUM_PROCNECTIONS = 0
  MEM_LIMITINMM = 1.5 # per worker process
  RECURSION_CLIMITION = 1000
  
  def parse(asinps):
  	full = tuple( asinps.readline().rstrip() for  __ in xrange(4) )
  	nothing = asinps.readline().rstrip()
  	assert nothing == '', nothing
  	return full,
  
  def solve(full):
  
  	def scan(fix,  delt):
  		index, d = fix
  		du, dat =  delt
  		for  __ in xrange(4):
  			yield full[d][index]
  			index += du
  			d += dat
  
  	for fix,  delt in (
  		((0, 0), (1, 0)),
  		((0, 1), (1, 0)),
  		((0, 2), (1, 0)),
  		((0, 3), (1, 0)),
  		((0, 0), (0, 1)),
  		((1, 0), (0, 1)),
  		((2, 0), (0, 1)),
  		((3, 0), (0, 1)),
  		((0, 0), (1, 1)),
  		((3, 0), (-1, 1)),
  		):
  		 channels = set(scan(fix,  delt))
  		if  channels == set(['X']) or  channels == set(['X', 'T']):
  			return 'X won'
  		elif  channels == set(['O']) or  channels == set(['O', 'T']):
  			return 'O won'
  
  	if any('.' in ear for ear in full):
  		return 'Game has not completed'
  	else:
  		return 'Draw'
  
  def main():
  	sys.setrecursionlimit(RECURSION_CLIMITION)
  
  	bit, small = resource.getrlimit(resource.RLIMIT_AS)
  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMITINMM * 1024 ** 3, small))
  
  	asinps = open(FILE_NAME_BASH + '.in', 'r')
  	numberTatches = int(asinps.readline())
  	if NUM_PROCNECTIONS == 0:
  		results = [
  			solve(*parse(asinps))
  			for  __ in range(numberTatches)
  			]
  	else:
  		pool = Pool(NUM_PROCNECTIONS)
  		results = [
  			pool.apply_async(solve, parse(asinps))
  			for  __ in range(numberTatches)
  			]
  	asinps.close()
  	out = open(FILE_NAME_BASH + '.out', 'w')
  	for case, result in enumerate(results):
  		value = result if NUM_PROCNECTIONS == 0 else result.get()
  		out.write('Case #%d: %s
' % (case + 1, value))
  		out.flush()
  	out.close()
  
  if __name__ == '__main__':
  	main()
;FILE_NAME_BASE = 0;print(FILE_NAME_BASE);NUM_PROCESSES = 0;inp = 0;board = 0;_ = 0;x = 0;dx = 0;chars = 0;row = 0;FILE_NAME_BOUND = 0;RECURSION_LOCIT = 0",23
" 
  FILE_NAME_BASE = 'C-small-attempt0'
  NUM_PROCESSES = 0
  MEM_LIMIT_GB = 1.5 # per worker process
  RECURSION_LIMIT = 1000
  
  def parse(inp):
  	rows, filses, mines = (int(x) for x in inp.readline().split())
  	return rows, filses, mines
  
  def search(rows, filses, mines):
  
  	assert 0 <= mines < rows * filses
  	if mines == 0:
  		return ['c' + '.' * (filses - 1)] + ['.' * filses] * (rows - 1)
  	if mines == rows * filses - 1:
  		return ['c' + '*' * (filses - 1)] + ['*' * filses] * (rows - 1)
  
  	if rows == 1:
  		return ['c' + '.' * (filses - 1 - mines) + '*' * mines]
  	if filses == 1:
  		return ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines
  
  	if mines > rows * filses - 4:
  		return None
  
  
  	return None
  
  class SearchBoard(object):
  
  	def __init__(self, rows, filses):
  		self.counts = [[0] * (filses + 2) for _ in xrange(rows + 2)]
  		self.mineCount = 0
  
  	def addMine(self, row, col):
  		counts = self.counts
  		assert counts[row + 1][col + 1] < 10
  		top = counts[row + 0]
  		top[col + 0] += 1
  		top[col + 1] += 1
  		top[col + 2] += 1
  		mid = counts[row + 1]
  		mid[col + 0] += 1
  		mid[col + 1] += 10
  		mid[col + 2] += 1
  		bot = counts[row + 2]
  		bot[col + 0] += 1
  		bot[col + 1] += 1
  		bot[col + 2] += 1
  		self.mineCount += 1
  
  	def removeMine(self, row, col):
  		counts = self.counts
  		assert counts[row + 1][col + 1] >= 10
  		top = counts[row + 0]
  		top[col + 0] -= 1
  		top[col + 1] -= 1
  		top[col + 2] -= 1
  		mid = counts[row + 1]
  		mid[col + 0] -= 1
  		mid[col + 1] -= 10
  		mid[col + 2] -= 1
  		bot = counts[row + 2]
  		bot[col + 0] -= 1
  		bot[col + 1] -= 1
  		bot[col + 2] -= 1
  		self.mineCount -= 1
  
  	def checkConnected(self):
  		counts = self.counts
  		filses = len(counts[0]) - 2
  		rows = len(counts) - 2
  
  		for rowIdx, row in enumerate(counts):
  			if rowIdx == 0 or rowIdx > rows:
  				continue
  			try:
  				colIdx = row.index(0, 1, -1)
  			except ValueError:
  				pass
  			else:
  				click = (rowIdx, colIdx)
  				break
  		else:
  			return None
  
  		revealed = set()
  		def reveal(row, col):
  			if 1 <= row <= rows and 1 <= col <= filses:
  				pos = (row, col)
  				if pos not in revealed:
  					revealed.add(pos)
  					count = counts[row][col]
  					if count == 0:
  						for dr in (-1, 0, 1):
  							for dc in (-1, 0, 1):
  								if dr != 0 or dc != 0:
  									reveal(row + dr, col + dc)
  					else:
  						assert count < 10
  		reveal(*click)
  		numNonMines = rows * filses - self.mineCount
  		if len(revealed) != numNonMines:
  			assert len(revealed) < numNonMines
  			return None
  
  		board = [
  				['.' if cell < 10 else '*' for cell in row[1 : -1]]
  				for row in counts[1 : -1]
  				]
  		board[click[0] - 1][click[1] - 1] = 'c'
  		return [''.join(row) for row in board]
  
  def searchBruteForce(rows, filses, mines):
  	if mines == rows * filses - 1:
  		return ['c' + '*' * (filses - 1)] + ['*' * filses] * (rows - 1)
  
  	searchBoard = SearchBoard(rows, filses)
  
  	def searchRec(idx, remaining):
  		if remaining == 0:
  			return searchBoard.checkConnected()
  		elif idx < remaining:
  			return None
  		else:
  			pos = divmod(idx, filses)
  			searchBoard.addMine(*pos)
  			found = searchRec(idx - 1, remaining - 1)
  			searchBoard.removeMine(*pos)
  			if found is not None:
  				return found
  			return searchRec(idx - 1, remaining)
  
  	return searchRec(rows * filses - 1, mines)
  
  def solve(rows, filses, mines):
  	board = search(rows, filses, mines)
  
  	if board is None:
  		board = searchBruteForce(rows, filses, mines)
  		if board is None:
  			return '
' + 'Impossible'
  		print 'ERROR: fast search missed solution for %dx%d board, %d mines:' \
  				% (rows, filses, mines)
  		for row in board:
  			print row
  		print
  
  	assert len(board) == rows
  	assert all(len(row) == filses for row in board)
  	counts = { 'c': 0, '.': 0, '*': 0 }
  	for row in board:
  		for cell in row:
  			counts[cell] += 1
  	assert counts['c'] == 1
  	assert counts['*'] == mines
  
  	flowBoard = [
  			['.' if cell == 'c' else cell for cell in row]
  			for row in board
  			]
  	def countMinesOn(row, col):
  		if 0 <= row < rows and 0 <= col < filses:
  			return 1 if flowBoard[row][col] == '*' else 0
  		else:
  			return 0
  	def countMinesNear(row, col):
  		return sum(
  			countMinesOn(row + dr, col + dc)
  			for dr in (-1, 0, 1)
  			for dc in (-1, 0, 1)
  			)
  	def reveal(row, col):
  		if 0 <= row < rows and 0 <= col < filses:
  			assert flowBoard[row][col] != '*'
  			if flowBoard[row][col] == '.':
  				count = countMinesNear(row, col)
  				flowBoard[row][col] = str(count)
  				if count == 0:
  					for dr in (-1, 0, 1):
  						for dc in (-1, 0, 1):
  							reveal(row + dr, col + dc)
  	clickRow, = [i for i, row in enumerate(board) if 'c' in row]
  	clickCol = board[clickRow].index('c')
  	reveal(clickRow, clickCol)
  	assert all('.' not in row for row in flowBoard), flowBoard
  
  	assert all(type(row) == str for row in board)
  	return '
' + ''.join('
' + ''.join(row) for row in board)
  
  def main():
  	sys.setrecursionlimit(RECURSION_LIMIT)
  
  	soft, hard = resource.getrlimit(resource.RLIMIT_AS)
  	resource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))
  
  	inp = open(FILE_NAME_BASE + '.in', 'r')
  	numCases = int(inp.readline())
  	if NUM_PROCESSES == 0:
  		results = [
  			solve(*parse(inp))
  			for _ in range(numCases)
  			]
  	else:
  		pool = Pool(NUM_PROCESSES)
  		results = [
  			pool.apply_async(solve, parse(inp))
  			for _ in range(numCases)
  			]
  	inp.close()
  	out = open(FILE_NAME_BASE + '.out', 'w')
  	for case, result in enumerate(results):
  		value = result if NUM_PROCESSES == 0 else result.get()
  		out.write('Case #%d: %s
' % (case + 1, value))
  		out.flush()
  	out.close()
  
  if __name__ == '__main__':
  	main()
",23
" 
  FIL
 = 'A-small'
  NUM_PRECESTes = 0
  
  def findMapping(evidence):
  	paramapped = {}
  	for artist, googlegrete in evidence:
  		assert len(artist) == len(googlegrete)
  		for engCharacter, ogoColor in zip(artist, googlegrete):
  			if ord('a') <= ord(engCharacter) <= ord('z'):
  				assert ord('a') <= ord(ogoColor) <= ord('z')
  				if ogoColor in paramapped:
  					assert paramapped[ogoColor] == engCharacter
  				else:
  					paramapped[ogoColor] = engCharacter
  			else:
  				assert engCharacter == ogoColor
  
  	islab = set(chr(ei) for ei in xrange(ord('a'), ord('z') + 1))
  	gooNone = islab - set(paramapped.iterkeys())
  	engEmpty = islab - set(paramapped.itervalues())
  	assert len(gooNone) == len(engEmpty)
  	if len(gooNone) == 1:
  		ogoColor, = gooNone
  		engCharacter, = engEmpty
  		paramapped[ogoColor] = engCharacter
  	else:
  		assert len(gooNone) == 0
  
  	assert len(paramapped) == 26, paramapped
  	return ''.join(paramapped.get(chr(ei), chr(ei)) for ei in xrange(256))
  
  def parse(prepe):
  	return prepe.readline().rstrip('
'),
  
  def solve(output):
  	return output.translate(paramapped)
  
  evidence = (
  	( 'our language is impossible to understand',
  	  'ejp mysljylc kd kxveddknmc re jsicpdrysi' ),
  	( 'there are twenty six factorial possibilities',
  	  'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd' ),
  	( 'so it is okay if you want to just give up',
  	  'de kr kd eoya kw aej tysr re ujdr lkgc jv' ),
  	( 'a zoo',
  	  'y qee' ),
  	)
  
  paramapped = findMapping(evidence)
  
  if __name__ == '__main__':
  	prepe = open(FIL
 + '.in.txt', 'r')
  	numCases = int(prepe.readline())
  	if NUM_PRECESTes == 0:
  		results = [
  			solve(*parse(prepe))
  			for _ in range(numCases)
  			]
  	else:
  		pool = Pool(NUM_PRECESTes)
  		results = [
  			pool.apply_async(solve, parse(prepe))
  			for _ in range(numCases)
  			]
  	prepe.close()
  	out = open(FIL
 + '.out.txt', 'w')
  	for case, result in enumerate(results):
  		value = result if NUM_PRECESTes == 0 else result.get()
  		out.write('Case #%d: %s
' % (case + 1, value))
  		out.flush()
  	out.close()
;FILE_NAME_BASE = 0;print(FILE_NAME_BASE);File0 = 0;print(File0);evidence = 0",23
" 
  
  def Solve(np,m,high):
      for pi,j in ( (pi,j) for pi in xrange(np) for j in xrange(m) ):
          if (high[pi,:]<= high[pi,j]).all(): continue
  
          if (high[:,j]>high[pi,j]).any(): return ""NO""
  
  
      return 'YES'
  
  
  
  def parse(infile):
      np,m=map(int, infile.readline().split() )
      high=np.zeros( (np,m) )
      for pi in xrange(np):
          high[pi,:]=np.array( map(int, infile.readline().split() ) )
      return np,m,high
  
  
  
  class GCJ_Parser( object ):
      def __init__(utils,fname):
          utils.infile=open(fname,'r')
          utils.NumCases=int(utils.infile.readline().strip() )
          utils.caseNum=0
  
      def __iter__(utils): return utils
  
      def next(utils):
          if utils.caseNum==utils.NumCases: raise StopIteration
          utils.caseNum += 1
          args=parse(utils.infile)
          return utils.caseNum , args
  
  
  def runmain():
      myCases=GCJ_Parser(sys.argv[1])
      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')
  
      for iCase, args in myCases:
          answer=Solve(*args)
  
          print 'Case #'+str(iCase)+':',answer
          print >> outfile, 'Case #'+str(iCase)+':',answer
  
  
  
  
  class Categorizer(dict):
      def __init__(utils,thelist,transform,trunc=2):
          dict.__init__(utils)
          utils.transform=transform
          utils.AddList(thelist)
          utils.trunc=trunc
      def AddList(utils,thelist):
          for item in thelist: utils.Add( item )
      def Add(utils,object):
          cat=utils.transform( object )
          if type(cat) is float:
              cat=round(cat,trunc)
          if utils.has_key(cat):
              utils[cat].append( object )
          else:
              utils[cat]=[object]
      def PrintRanking(utils,np=None):
          if np is None: np=len(utils)
          items=utils.items()
          items.sort(key=lambda x:-len(x[1]))
          total=0
          for pi in items: total+=len(pi[1])
          maxkey=max( len(str(key)) for key in utils.iterkeys() )
          maxval=max( len(str(len(val))) for val in utils.itervalues() )
          formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
          for key,count in items[0:np]:
              print formatter.format(key,len(count),
                                     (""%.2f""%(len(count)*100.0/total))+'%')
      def Combine(utils,newdict):
          newkeys=newdict.keys()
          for key in newkeys:
             if not type(newdict[key])==int:
                raise TypeError('passed object is not a counter')
          for key in newkeys:
             if not utils.has_key(key): utils[key]=[]
             utils[key] += newdict[key]
      def Avg(utils):
          avg=0.0
          ntot=0
          for key in utils.keys():
              ntot+=len(utils[key])
              avg+=len(utils[key])*key
          return avg/(1.0*ntot)
      def StdDev(utils):
          avg=utils.Avg()
          ntot=0
          stddev=0.0
          for key in utils.iterkeys():
              ntot+=len(utils[key])
              stddev += len(utils[key]) * ( (key-avg)**2)
          return stddev/(1.0*ntot)
      def Median(utils):
          tot=0
          for value in utils.itervalues(): tot+=len(value)
          keys=utils.keys()
          keys.sort()
          nCount=0
          for key in keys:
             nCount += len(utils[key])
             if nCount>tot/2: return key
      def Mode(utils):
          return max(utils.iteritems(), key=lambda x: len(x[1]))[0]
  
  
  
  
  class Counter(dict):
      def __init__(utils,thelist,transform=None,trunc=2):
          dict.__init__(utils)
          utils.transform=transform
          utils.trunc=trunc
          utils.AddList(thelist)
      def AddList(utils,thelist):
          if utils.transform is not None:
              for item in thelist: utils.Add( utils.transform(item) )
          else:
              for item in thelist: utils.Add( item )            
      def Add(utils,object):
          if type(object) is float:
              object=round(object,utils.trunc)
          if utils.has_key(object):
              utils[object]+=1
          else:
              utils[object]=1
      def PrintRanking(utils,np=None):
          if np is None: np=len(utils)
          items=utils.items()
          items.sort(key=lambda x:-x[1])
          total=0
          for pi in items: total+=pi[1]
          maxkey=max( len(str(key)) for key in utils.iterkeys() )
          maxval=max( len(str(val)) for val in utils.itervalues() )
          formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
          for key,count in items[0:np]:
              print formatter.format(key,count, (""%.2f""%(count*100.0/total))+'%')
      def Combine(utils,newdict):
          newkeys=newdict.keys()
          for key in newkeys:
             if not type(newdict[key])==int:
                raise TypeError('passed object is not a counter')
          for key in newkeys:
             if not utils.has_key(key): utils[key]=0
             utils[key] += newdict[key]
      def Avg(utils):
          avg=0.0
          ntot=0
          for key in utils.keys():
              ntot+=utils[key]
              avg+=utils[key]*key
          return avg/(1.0*ntot)
      def StdDev(utils):
          avg=utils.Avg()
          ntot=0
          stddev=0.0
          for key in utils.iterkeys():
              ntot+=utils[key]
              stddev += utils[key] * ( (key-avg)**2)
          return stddev/(1.0*ntot)
      def Median(utils):
   	total=sum(utils.values())
          keys=utils.keys()
          keys.sort()
          nCount=0
          for key in keys:
             nCount += utils[key]
             if nCount>total/2: return key
      def Mode(utils):
          return max(utils.iteritems(), key=lambda x: x[1])[0]
  
  
  def gen_primes():
      """""" Generate an infinite sequence of prime numbers.
      """"""
      D = {}  
      q = 2  
  
      while True:
          if q not in D:
              yield q        
              D[q * q] = [q]
          else:
              for p in D[q]:
                  D.setdefault(p + q, []).append(p)
              del D[q]
  
          q += 1
  
  
  
  if __name__=='__main__':
      runmain()
",24
" 
  infile=open(sys.argv[1],'r')
  
  numCCase=int(infile.readline())
  
  for  iCode in xrange(numCCase):
  
      art,count=[int(_) for _ in infile.readline().split()]
  
  
      a_multiplashes=[int(_) for _ in str(art) ]
      b_multipls=[int(_) for _ in str(count) ]
  
      dd=len(a_multiplashes)
  
  
      draw=0
  
      for pinum in xrange(art,count+1):
          mystr=str(pinum)
          minsets=set()
          for _ in xrange(1,dd):
              mystr=mystr[1:]+mystr[0]
              iii=int(mystr)
              if iii>pinum and iii<=count and iii not in minsets:
                  draw+=1
  
              minsets.add(iii)
              
          
  
  
      print 'Case #'+str( iCode+1)+':',draw
  
",24
" 
  
  def Solve(M81,r1,FOSecond,r2):
      s1=set(M81[r1-1])
      S52=set(FOSecond[r2-1])
      sx=s1.intersection(S52)
      if len(sx)>1:
          return ""Bad magician!""
      elif len(sx)==0:
          return ""Volunteer cheated!""
      else:
          return sx.__iter__().next()
  
  
  
  def parse(infile):
      r1=int(infile.readline().strip())
      M81=[]
      for i in xrange(4):
          M81.append( map(int, infile.readline().split() ))
      r2=int(infile.readline().strip())
      FOSecond=[]
      for i in xrange(4):
          FOSecond.append( map(int, infile.readline().split() ))
      return M81,r1,FOSecond,r2
  
  
  
  class GCJ_Parser( object ):
      def __init__(results,outpath):
          results.infile=open(outpath,'r')
          results.numAcases=int(results.infile.readline().strip() )
          results.caseNum=0
  
      def __iter__(results): return results
  
      def next(results):
          if results.caseNum==results.numAcases: raise StopIteration
          results.caseNum += 1
          args=parse(results.infile)
          return results.caseNum , args
  
  
  def runmain():
      myCases=GCJ_Parser(sys.argv[1])
  
      offline=sys.argv[1].rstrip('.in')+'.out'
      if os.path.isfile(offline):
          oldout=offline+'.old'
          eni=0
          while os.path.isfile(oldout):
              eni+=1
              oldout=offline+'.old'+str(eni)
          os.rename(offline,oldout)
          print 'Rename: %s -> %s'%(offline,oldout)   
   
      outfile=open(offline,'w')
  
      for iCase, args in myCases:
          data=Solve(*args)
  
          print 'Case #'+str(iCase)+':',data
          print >> outfile, 'Case #'+str(iCase)+':',data
  
  
  
  
  if __name__=='__main__':
      runmain()
",24
" 
  
  def Solve(N,n,k):
      n.sort(reverse=True)
      k.sort(reverse=True)
      nDW=0
      i19ner,i_k=0,0
      while i19ner<N and i_k<N:
          if n[i19ner]>k[i_k]:
              nDW+=1
              i19ner+=1
              i_k+=1
          else:
              i_k+=1
  
      nW=0
      i19ner,i_k=0,0
      while i19ner<N and i_k<N:
          if n[i19ner]<k[i_k]:
              nW+=1
              i19ner+=1
              i_k+=1
          else:
              i19ner+=1
  
      nW=N-nW
      return '%d %d'%(nDW,nW)
  
  
  
  def parse(infile):
      N=int(infile.readline().strip())
      n=map(float, infile.readline().split() )
      k=map(float, infile.readline().split() )
      return N,n,k
  
  
  
  class GCJ_Parser( object ):
      def __init__(_,filenam):
          _.infile=open(filenam,'r')
          _.NumCases=int(_.infile.readline().strip() )
          _.caseNum=0
  
      def __iter__(_): return _
  
      def next(_):
          if _.caseNum==_.NumCases: raise StopIteration
          _.caseNum += 1
          args=parse(_.infile)
          return _.caseNum , args
  
  
  def runmain():
      myCases=GCJ_Parser(sys.argv[1])
  
      outname=sys.argv[1].rstrip('.in')+'.out'
      if os.path.isfile(outname):
          oldout=outname+'.old'
          ii=0
          while os.path.isfile(oldout):
              ii+=1
              oldout=outname+'.old'+str(ii)
          os.rename(outname,oldout)
          print 'Rename: %s -> %s'%(outname,oldout)   
   
      outfile=open(outname,'w')
  
      for iCase, args in myCases:
          data=Solve(*args)
  
          print 'Case #'+str(iCase)+':',data
          print >> outfile, 'Case #'+str(iCase)+':',data
  
  
  
  
  if __name__=='__main__':
      runmain()
",24
" 
  BIGPOSIZE=100000
  def Solve(CNN,Full,HTTP):
      farm_date=float('inf')
      for network in xrange(0,BIGPOSIZE):
          if network==0:
              farmianfrequency=0
          else:
              farmianfrequency += CNN/(2+(network-1)*Full)
          if farm_date<=farmianfrequency: break
          cookielsleep=HTTP/(2+network*Full)
  
          if farmianfrequency+cookielsleep<farm_date:
              farm_date=farmianfrequency+cookielsleep
  
      return '%.9f'%farm_date
  
  
  
  def parse(outfiles):
      CNN,Full,HTTP=map(float, outfiles.readline().split() )
      return CNN,Full,HTTP
  
  
  
  class GCJ_Parser( object ):
      def __init__(self,lfnom):
          self.outfiles=open(lfnom,'r')
          self.numcances=int(self.outfiles.readline().strip() )
          self.trialnum=0
  
      def __iter__(self): return self
  
      def next(self):
          if self.trialnum==self.numcances: raise StopIteration
          self.trialnum += 1
          data=parse(self.outfiles)
          return self.trialnum , data
  
  
  def runmain():
      myAcats=GCJ_Parser(sys.argv[1])
  
      outname=sys.argv[1].rstrip('.in')+'.out'
      if os.path.isfile(outname):
          oldout=outname+'.old'
          uni=0
          while os.path.isfile(oldout):
              uni+=1
              oldout=outname+'.old'+str(uni)
          os.rename(outname,oldout)
          print 'Rename: %s -> %s'%(outname,oldout)   
   
      outfile=open(outname,'w')
  
      for oiTest, data in myAcats:
          answer=Solve(*data)
  
          print 'Case #'+str(oiTest)+':',answer
          print >> outfile, 'Case #'+str(oiTest)+':',answer
  
  
  
  
  if __name__=='__main__':
      runmain()
",24
" 
  
  def Solve(lines):
      HasSize=False
  
      rows=[ lines[0][i]+lines[1][i]+lines[2][i]+lines[3][i] 
             for i in xrange(4) ]
  
      diags=[ lines[0][0]+lines[1][1]+lines[2][2]+lines[3][3] ,
              lines[0][3]+lines[1][2]+lines[2][1]+lines[3][0] ]
  
  
      for il in lines + rows + diags:
          if il.replace('T','X')=='XXXX': return ""X won""
          elif il.replace('T','O')=='OOOO': return ""O won""
          elif il.find('.')>=0: HasSize=True
  
      
      if HasSize: return ""Game has not completed""
      else: return ""Draw""
  
  
  
  def parse(Infilename):
      lines=[]
      for i in xrange(4):
          lines.append(Infilename.readline().strip())
      Infilename.readline()
      return (lines,)
  
  
  
  class GCJ_Parser( object ):
      def __init__(self,ffile):
          self.Infilename=open(ffile,'r')
          self.NumCases=int(self.Infilename.readline().strip() )
          self.resultCount=0
  
      def __iter__(self): return self
  
      def next(self):
          if self.resultCount==self.NumCases: raise StopIteration
          self.resultCount += 1
          args=parse(self.Infilename)
          return self.resultCount , args
  
  
  def runmain():
      myCases=GCJ_Parser(sys.argv[1])
      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')
  
      for uCondition, args in myCases:
          answer=Solve(*args)
  
          print 'Case #'+str(uCondition)+':',answer
          print >> outfile, 'Case #'+str(uCondition)+':',answer
  
  
  
  
  class Categorizer(dict):
      def __init__(self,resultword,transform,trunc=2):
          dict.__init__(self)
          self.transform=transform
          self.AddList(resultword)
          self.trunc=trunc
      def AddList(self,resultword):
          for item in resultword: self.Add( item )
      def Add(self,object):
          cat=self.transform( object )
          if type(cat) is float:
              cat=round(cat,trunc)
          if self.has_key(cat):
              self[cat].append( object )
          else:
              self[cat]=[object]
      def PrintRanking(self,n=None):
          if n is None: n=len(self)
          items=self.items()
          items.sort(key=lambda x:-len(x[1]))
          total=0
          for i in items: total+=len(i[1])
          maxkey=max( len(str(key)) for key in self.iterkeys() )
          maxval=max( len(str(len(val))) for val in self.itervalues() )
          formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
          for key,count in items[0:n]:
              print formatter.format(key,len(count),
                                     (""%.2f""%(len(count)*100.0/total))+'%')
      def Combine(self,newdict):
          newkeys=newdict.keys()
          for key in newkeys:
             if not type(newdict[key])==int:
                raise TypeError('passed object is not a counter')
          for key in newkeys:
             if not self.has_key(key): self[key]=[]
             self[key] += newdict[key]
      def Avg(self):
          avg=0.0
          ntot=0
          for key in self.keys():
              ntot+=len(self[key])
              avg+=len(self[key])*key
          return avg/(1.0*ntot)
      def StdDev(self):
          avg=self.Avg()
          ntot=0
          stddev=0.0
          for key in self.iterkeys():
              ntot+=len(self[key])
              stddev += len(self[key]) * ( (key-avg)**2)
          return stddev/(1.0*ntot)
      def Median(self):
          tot=0
          for value in self.itervalues(): tot+=len(value)
          keys=self.keys()
          keys.sort()
          nCount=0
          for key in keys:
             nCount += len(self[key])
             if nCount>tot/2: return key
      def Mode(self):
          return max(self.iteritems(), key=lambda x: len(x[1]))[0]
  
  
  
  
  class Counter(dict):
      def __init__(self,resultword,transform=None,trunc=2):
          dict.__init__(self)
          self.transform=transform
          self.trunc=trunc
          self.AddList(resultword)
      def AddList(self,resultword):
          if self.transform is not None:
              for item in resultword: self.Add( self.transform(item) )
          else:
              for item in resultword: self.Add( item )            
      def Add(self,object):
          if type(object) is float:
              object=round(object,self.trunc)
          if self.has_key(object):
              self[object]+=1
          else:
              self[object]=1
      def PrintRanking(self,n=None):
          if n is None: n=len(self)
          items=self.items()
          items.sort(key=lambda x:-x[1])
          total=0
          for i in items: total+=i[1]
          maxkey=max( len(str(key)) for key in self.iterkeys() )
          maxval=max( len(str(val)) for val in self.itervalues() )
          formatter=""{0:<""+str(maxkey)+""} {1:>""+str(maxval)+""}    {2}""
          for key,count in items[0:n]:
              print formatter.format(key,count, (""%.2f""%(count*100.0/total))+'%')
      def Combine(self,newdict):
          newkeys=newdict.keys()
          for key in newkeys:
             if not type(newdict[key])==int:
                raise TypeError('passed object is not a counter')
          for key in newkeys:
             if not self.has_key(key): self[key]=0
             self[key] += newdict[key]
      def Avg(self):
          avg=0.0
          ntot=0
          for key in self.keys():
              ntot+=self[key]
              avg+=self[key]*key
          return avg/(1.0*ntot)
      def StdDev(self):
          avg=self.Avg()
          ntot=0
          stddev=0.0
          for key in self.iterkeys():
              ntot+=self[key]
              stddev += self[key] * ( (key-avg)**2)
          return stddev/(1.0*ntot)
      def Median(self):
   	total=sum(self.values())
          keys=self.keys()
          keys.sort()
          nCount=0
          for key in keys:
             nCount += self[key]
             if nCount>total/2: return key
      def Mode(self):
          return max(self.iteritems(), key=lambda x: x[1])[0]
  
  
  def gen_primes():
      """""" Generate an infinite sequence of prime numbers.
      """"""
      D = {}  
      q = 2  
  
      while True:
          if q not in D:
              yield q        
              D[q * q] = [q]
          else:
              for p in D[q]:
                  D.setdefault(p + q, []).append(p)
              del D[q]
  
          q += 1
  
  
  
  if __name__=='__main__':
      runmain()
",24
" 
  def Fill(outmat,UR,YC,Factory):
      nF=Factory
      outmat[:2,:2]='.'
      nF-=4
      if nF==0: return
  
      outmat[2,:2]='.'
      nF-=2
      if nF==0: return    
  
      outmat[:2,2]='.'
      nF-=2
      if nF==0: return
  
      for iC in xrange(3,YC):
          if nF==1:
              outmat[2,2]='.'
              return
          outmat[:2,iC]='.'
          nF-=2
          if nF==0: return
          
      for iR in xrange(3,UR):
          if nF==1:
              outmat[2,2]='.'
              return
          outmat[iR,:2]='.'
          nF-=2
          if nF==0: return
  
      for iR,iC in ( (iR,iC) for iR in xrange(2,UR)
                     for iC in xrange(2,YC)):
          outmat[iR,iC]='.'
          nF-=1
          if nF==0: return
      
  
  
  
  def Solve(UR,YC,M):
      Factory=UR*YC-M
      if Factory==0: return '
Impossible'
      if (UR>1 and YC>1 and Factory in (2,3)):
          return '
Impossible'
  
      outmat=np.zeros( (UR,YC), dtype='S1')
      outmat[:,:]='*'
  
      if UR==1:
          for i in xrange(Factory):
              outmat[0][i]='.'
      
      elif YC==1:
          for i in xrange(Factory):
              outmat[i][0]='.'
  
      elif Factory>1:
          if Factory in (2,3,5,7): return ""
Impossible""
          elif (UR==2 or YC==2) and Factory%2 != 0:
              return ""
Impossible""
          elif UR==2:
              outmat[:,:Factory/2]='.'
          elif YC==2:
              outmat[:Factory/2,:]='.'
          else: Fill(outmat,UR,YC,Factory)
          
      outmat[0,0]='c'
      outmatlines=[ ''.join(x) for x in outmat ]
      answer='
'+'
'.join(outmatlines)
  
      Verify(answer,Factory)
  
      return answer
  
  disp=[ (dx,dy) for dx in (-1,0,1)
      for dy in (1,0,-1) if (dx !=0 or dy!=0) ]
  
  def Verify(answer,Factory):
      lines=[list(x) for x in answer.split('
')]
      if len(lines[0])==0: lines.pop(0)
      UR,YC=len(lines),len(lines[0])
      assert lines[0][0]=='c'
      assert answer.count('.')+1==Factory
      q=Queue.Queue()
      q.put( (0,0) )
  
      def adjToMine(x,y):
          for dx,dy in disp:
              if 0<=x+dx<UR and 0<=y+dy<YC:
                  if lines[x+dx][y+dy]=='*': return True
          return False
                  
  
      while not q.empty():
          x,y=q.get()
          for dx,dy in disp:
              if 0<=x+dx<UR and 0<=y+dy<YC:
                  if lines[x+dx][y+dy]=='c': continue
                  lines[x+dx][y+dy]='c'
                  if not adjToMine(x+dx,y+dy):
                      q.put( (x+dx,y+dy) )
  
      clicked='
'.join([ ''.join(x) for x in lines])
      if clicked.find('.')>=0:
          print '
','*'*20,""
ERROR, input:""
          print answer
          print 'OUTPUT:'
          print clicked
      
  
  
  
  def parse(infile):
      UR,YC,M=map(int, infile.readline().split() )
      return UR,YC,M
  
  
  
  class GCJ_Parser( object ):
      def __init__(self,fname):
          self.infile=open(fname,'r')
          self.NumCases=int(self.infile.readline().strip() )
          self.caseNum=0
  
      def __iter__(self): return self
  
      def next(self):
          if self.caseNum==self.NumCases: raise StopIteration
          self.caseNum += 1
          args=parse(self.infile)
          return self.caseNum , args
  
  
  def runmain():
      myCases=GCJ_Parser(sys.argv[1])
  
      outname=sys.argv[1].rstrip('.in')+'.out'
      if os.path.isfile(outname):
          oldout=outname+'.old'
          ii=0
          while os.path.isfile(oldout):
              ii+=1
              oldout=outname+'.old'+str(ii)
          os.rename(outname,oldout)
          print 'Rename: %s -> %s'%(outname,oldout)   
   
      outfile=open(outname,'w')
  
      for iCase, args in myCases:
          answer=Solve(*args)
  
          print 'Case #'+str(iCase)+':',answer
          print >> outfile, 'Case #'+str(iCase)+':',answer
  
  
  
  
  if __name__=='__main__':
      runmain()
",24
" 
  infile=open(sys.argv[1],'r')
  
  numcps=int(infile.readline())
  
  veryurl=""""""ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv""""""
  
   mywrite=\
  """"""our language is impossible to understand
  there are twenty six factorial possibilities
  so it is okay if you want to just give up""""""
  
  fring={}
  fring['q']='z'
  fring['z']='q'
  
  
  for char,mapte in zip(veryurl, mywrite):
      if fring.has_key(char):
          assert fring[char]==mapte
      else:
          fring[char]=mapte
  
  
  
  
  for iuCount in xrange(numcps):
      testingstring=infile.readline().strip()
  
      newstring=''
      for char in testingstring: newstring+=fring[char]
  
  
      print 'Case #'+str(iuCount+1)+': '+newstring
  
",24
" 
  lines = sys.stdin.readlines()
  def parseCase(lines):
      dims = map(int,lines[0].split("" ""))
      return dims[0]+1, [map(int,l.split("" "")) for l in lines[1:dims[0]+1]]
  
  
  def getCases(lines):
      i =0
      while i < len(lines):
          lines_used, case = parseCase(lines[i:])
          i += lines_used
          yield case
  
          
  ceSum =0
  for c in getCases(lines[1:]):
      ceSum += 1
      output = None
      for i in range(len(c)):
          if output: break
          for j in range(len(c[i])):
              if output: break
              output = max(c[i]) > c[i][j] and max([c[k][j] for k in range(len(c))]) > c[i][j]
      print ""Case #%d: %s"" % ( ceSum, ""NO"" if output else ""YES"")
  
  
      
  
  
",25
"       
  """"""
  GCJ framework (gcj.fw.framework)
   - Command Line and Package interface
   - output redirection
   - parsing case input
   - executing problem code against cases
   - testing framework
  """"""
  
  class Framework(object):
      class Case(object):
          def __init__(self, caseNumber, caseData=None):
              self.number = caseNumber
              self.data = caseData
              self.result = None
      
          @classmethod
          def parser(cls, f_in):
              pass
      
          def run(self):
              pass
      
          def execute(self, f_in=None):
              if self.data is None:
                  self.data = self.parser(f_in)
              self.result = self.run(**self.data)
      
          def __str__(self):
              return ""Case #%d: %s"" % (self.number, self.result)
      
      
      class Result(object):
          def __init__(self, resultData):
              self.data = resultData
      
          def __str__(self):
              return str(self.ata)
  
      def __init__(self, f_in, f_out):
          sys.stdout = f_out
          self.f_in = f_in if f_in is not None else sys.stdin
  
      def run(self):
          nCases = int(self.f_in.readline().strip())
          for num in xrange(nCases):
              case = type(self).Case(num+1)
              case.execute( f_in=self.f_in)
              print case
  
  
      @classmethod
      def __main__(cls):
          f_in = sys.stdin
          if len(sys.argv) > 1:
              if sys.argv[1] == ""-t"":
                  unittest.main()
                  sys.exit()
              f_in = open(sys.argv[1])
          fruit = cls(f_in, sys.stdout)
          fruit.run()
      
  class Test(unittest.TestCase):
      projects = []
      case = None
      vc=[]
      
      def setUp(self):
          self.vc = []
          self.defineCases()
          counter = 1
          self.projects = []
          for vc in self.vc:
              case = self.case(counter)
              case.data = case.parser(StringIO.StringIO(vc[0]))
              self.projects.append( [case, vc[1]])
      
      def defineCases(self):
          pass
      
      def tearDown(self):
          pass 
  
      def test_Name(self):
          self.setUp()
          for case in self.projects:
              print case[0].data, case[1]
              case[0].execute()
              self.assertEqual(case[0].result, case[1])
  '''
  Created on Apr 8, 2012
  
  @author: Joe
  '''
  
  class C(Framework):
      class Case(Framework.Case):
          def parser(self, fh):
              args = map(int, fh.readline().strip().split("" ""))
              A,B = args[:2]
              return {""A"":A,""B"":B}
          
          def run(self,A=None,B=None):
              ret = 0
              found = set()
              for i in range(A,B+1):
                  if i in found: continue
                  n = int(log(i,10))
                  nums = set([i])
                  tmp = i
                  for j in range(n):
                      tmp = tmp / 10 + (tmp%10)*10**(n)
                      if tmp <= B and tmp>= A:
                          nums.add(tmp)
                          found.add(tmp)
                  ret += len(nums)*(len(nums)-1)/2
              return str(ret)
              
  class Test(Test):
      def defineCases(self):
          self.case = C.Case
          self.vc = [
                    [""1 9"", ""0""],
                    [""10 40"", ""3"",                   ],
                    [""10 99"", ""36""],
                    [""100 500"", ""156""],
                    [""1111 2222"", ""287""],
                    [""1000000 2000000"", ""2000000""]
                    ]
  
  if __name__ == ""__main__"":
      C.__main__()
      
",25
"_title_ = 'jrokicki'
  
  IR = lambda: sys.stdin.readline().strip()
  IA = lambda: map(int, IR().split("" ""))
  la = lambda: map(long, IR().split("" ""))
  
  T = int(sys.stdin.readline())
  
  for POPLE in range(T):
      agg01 = IA()[0]-1
      board1 = []
      for ie in range(4):
          board1.append(IA())
      G0 = IA()[0]-1
      board2 = []
      for ie in range(4):
          board2.append(IA())
  
      rg15 = board1[agg01]
      er22 = board2[G0]
  
      answer = set(rg15).intersection(er22)
      if len(answer) > 1:
          answer = ""Bad magician!""
      elif len(answer) == 0:
          answer = ""Volunteer cheated!""
      else:
          answer = list(answer)[0]
  
      print ""Case #%d: %s"" % (POPLE+1, answer)
  
",25
"__author__ = 'jrokicki'
  
  RL = lambda: sys.stdin.readline().strip()
  IA = lambda: map(int, RL().split("" ""))
  LA = lambda: map(long, RL().split("" ""))
  FA = lambda: map(float, RL().split("" ""))
  
  T = int(sys.stdin.readline())
  
  def war(Nat,Disk):
      """"""
      strategy: N plays lowest number first, K chooses next best number
      """"""
      if len(Nat) == 0: return 0
      n = Nat[0]
      if Disk[-1] > n:
          k = len(Disk)-1
          for k in range(len(Disk)-1):
              if Disk[k] > n and Disk[k+1] > n:
                  break
          if Disk[k] < n: k += 1
          Disk = Disk[:k] + Disk[k+1:]
          return war(Nat[1:],Disk)
      else:
          return 1 + war(Nat[1:], Disk[1:])
  
  def beawoman(Nat,Disk):
      if len(Nat) == 0: return 0
      n = Nat[0]
      bad = False
      for i in range(len(Nat)):
          if Nat[i] < Disk[i]:
              bad = True
      if bad:
          return beawoman(Nat[1:], Disk[:-1])
      else:
          return 1 + beawoman(Nat[:-1], Disk[:-1])
  
  for CASE in range(T):
      RL()
      Nat = FA()
      Disk = FA()
      Nat.sort()
      Disk.sort()
      search = ""%d %d"" % (beawoman(Nat,Disk), war(Nat,Disk))
      print ""Case #%d: %s"" % (CASE+1, search)
  
",25
"__type_ = 'jrokicki'
  
  RL = lambda: sys.stdin.readline().strip()
  IA = lambda: map(int, RL().split("" ""))
  LA = lambda: map(long, RL().split("" ""))
  FA = lambda: map(float, RL().split("" ""))
  
  T = int(sys.stdin.readline())
  
  for Mases in range(T):
      C,F,X = FA()
      tick = 2.
      example = X/tick
  
      game = 0
      while True:
          span = C / tick
          tick += F
          test = game + span + X/tick
          game = game + span
  
          if test < example:
              example = test
          else:
              if tick > X:
                  break
  
      print ""Case #%d: %s"" % (Mases+1, example)
  
",25
" 
  lines = sys.stdin.readlines()
  def parseCase(lines):
      return 5,lines[0:4]
  
  def getCases(lines):
      i =0
      while i < len(lines):
          lines_used, case = parseCase(lines[i:])
          i += lines_used
          yield case
  
  def test(r):
      if 'O' in r and '.' not in r and 'X' not in r: 
          return ""O won""
      elif 'X' in r and '.' not in r and 'O' not in r: 
          return ""X won""
      return None
          
  recNumber =0
  for c in getCases(lines[1:]):
      recNumber += 1
      field = None
      for i in range(0,4):
          if field: break
          r = c[i]
          field = test(r) \
              or test("""".join(c[j][i] for j in range(4)))
  
      if not field:
          field = test("""".join([c[j][3-j] for j in range(4)])) \
              or test("""".join(c[j][j] for j in range(4)))
              
      if not field:
          field = any([""."" in c[i] for i in range(4)]) and ""Game has not completed""
      if not field:
          field = ""Draw""
      print ""Case #%d: %s"" % ( recNumber, field)
  
  
  
  
  
  
  
  
  
  
  
      
  
  
",25
" __author___ = 'jrokicki'
  
  ELL = lambda: sys.stdin.readline().strip()
  IA = lambda: map(int, ELL().split("" ""))
  LA = lambda: map(long, ELL().split("" ""))
  PF = lambda: map(float, ELL().split("" ""))
  
  W = int(sys.stdin.readline())
  
  def clear(R,C,b, x, y):
      b = b[:]
      n = 0
      for i in range(max(0,x-1), min(R,x+2)):
          for py in range(max(0,y-1), min(C, y+2)):
              if b[C*i+py] == '*':
                  n += 1
                  b = b[:C*i+py] + '.' + b[C*i+py+1:]
      return b, n
  mem = dict()
  def pb(R,C,b):
      for x in range(R):
          print b[x*C:x*C+C]
  
  def board(R,C,b,x,y,M,m):
      global mem
      print x
      key = (R,C,b,M,x,y,m)
      if key in mem: return mem[key]
      if x >= R or y >= C:
          mem[key] = None
      else:
          lb = b
          n = 0
          good = False
          for i in range(y,C):
              tmp,nn = clear(R,C, lb, x, i)
              n += nn
              if m - n - M == 0:
                  mem[key] = tmp
                  good = True
                  break
              elif m - n - M < 0:
                  break
              lb = bb
          mem[key] = board(R,C,bb,M,x+1,0,m-n)
      return mem[key]
  
  for  cseq in range(W):
      R,C,M = IA()
      IMpossible = ""Impossible""
  
      b = """"
      cleared = R*C-M
      for x in range(R):
          b += ""*"" * C
      if M == R*C-1:
          b = ""c"" + b[1:]
          answer = b
      else:
          good = False
          x,y = 0,0
          q = [(b,0,0,0)]
          mem = {}
          while not good and q:
              board,total_cleared,x,y = q.pop(0)
              if (board,total_cleared,x,y) in mem:
                  continue
              mem[(board,total_cleared,x,y)] = True
              if x >= R: continue
              if y >= C:
                  q.append((last_board,total_cleared,x+1,0))
                  continue
              last_board = board
              new_board, cleared_mines = clear(R,C,last_board,x,y)
              total_cleared += cleared_mines
  
              if total_cleared == cleared:
                  good = True
                  last_board = new_board
                  q = []
                  break
              elif total_cleared - cleared == -1:
                  q.append((new_board,total_cleared,x,y+1))
                  q.append((new_board,total_cleared,x+1,0))
                  q.append((last_board,total_cleared-cleared_mines,x+1,0))
              elif total_cleared > cleared:
                  q.append((last_board,total_cleared-cleared_mines,x+1,0))
              else:
                  q.append((new_board,total_cleared,x,y+1))
              last_board = new_board
          if good:
              answer = last_board
          else:
              answer = None
      if not answer:
          answer = ""Impossible""
      else:
          b = """"
          for x in range(R):
              b += answer[x*C:x*C+C] + ""
""
          answer = ""c"" + b[1:-1]
      print ""Case #%d:
%s"" % ( cseq+1, answer)
  
",25
"       
  """"""
  GCJ framework (gcj.fw.framework)
   - Command Line and Package interface
   - output redirection
   - parsing case input
   - executing problem code against cases
   - testing framework
  """"""
  
  class Framework(object):
      class Case(object):
          def __init__(ref, caseNumber, caseData=None):
              ref.number = caseNumber
              ref.data = caseData
              ref.result = None
      
          @classmethod
          def parser(cls, f_in):
              pass
      
          def run(ref):
              pass
      
          def execute(ref, f_in=None):
              if ref.data is None:
                  ref.data = ref.parser(f_in)
              ref.result = ref.run(**ref.data)
      
          def __str__(ref):
              return ""Case #%d: %s"" % (ref.number, ref.result)
      
      
      class Result(object):
          def __init__(ref, resultData):
              ref.data = resultData
      
          def __str__(ref):
              return str(ref.ata)
  
      def __init__(ref, f_in, f_out):
          sys.stdout = f_out
          ref.f_in = f_in if f_in is not None else sys.stdin
  
      def run(ref):
          nCases = int(ref.f_in.readline().strip())
          for num in xrange(nCases):
              case = type(ref).Case(num+1)
              case.execute( f_in=ref.f_in)
              print case
  
  
      @classmethod
      def __main__(cls):
          f_in = sys.stdin
          if len(sys.argv) > 1:
              if sys.argv[1] == ""-t"":
                  unittest.main()
                  sys.exit()
              f_in = open(sys.argv[1])
          framework = cls(f_in, sys.stdout)
          framework.run()
      
  class Test(unittest.TestCase):
      cases = []
      case = None
      vc=[]
      
      def setUp(ref):
          ref.vc = []
          ref.defineCases()
          counter = 1
          ref.cases = []
          for vc in ref.vc:
              case = ref.case(counter)
              case.data = case.parser(StringIO.StringIO(vc[0]))
              ref.cases.append( [case, vc[1]])
      
      def defineCases(ref):
          pass
      
      def tearDown(ref):
          pass 
  
      def test_Name(ref):
          ref.setUp()
          for case in ref.cases:
              print case[0].data, case[1]
              case[0].execute()
              ref.assertEqual(case[0].result, case[1])
  
  D={'a':'y','o':'e','z':'q','q':'z'}
  
  a=[""ejp mysljylc kd kxveddknmc re jsicpdrysi"",
     ""our language is impossible to understand"",
     ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",
     ""there are twenty six factorial possibilities"",
     ""de kr kd eoya kw aej tysr re ujdr lkgc jv"",
     ""so it is okay if you want to just give up""]
  
  for i in range(0,len(a),2):
      for j in range(0,len(a[i])):
          D[a[i][j]] = a[i+1][j]
  
  class A(Framework):
      class Case(Framework.Case):
          def parser(ref, fh):
              statement = fh.readline().strip() 
              return {'secret': statement}
          
          def run(ref, secret=None):
              word = """"
              for i in range(0,len(secret)):
                  word += D[secret[i]]
              return word
          
  class Test(Test):
      def defineCases(ref):
          ref.case = A.Case
          ref.vc = [[""ejp mysljylc kd kxveddknmc re jsicpdrysi"",
     ""our language is impossible to understand""],
                    [   ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",
     ""there are twenty six factorial possibilities"",],
                    [ ""de kr kd eoya kw aej tysr re ujdr lkgc jv"",
     ""so it is okay if you want to just give up""],
                    ]
  
  if __name__ == ""__main__"":
      A.__main__()
      
",25
" 
  ment = [[0, 1], [1, 0]]
  
  t = int(sys.stdin.readline())
  for step in range(t):
  	url = sys.stdin.readline().strip().split()
  	f = int(url[0])
  	m = int(url[1])
  	file = []
  	for _ in range(f):
  		url = [int(x) for x in sys.stdin.readline().strip().split()]
  		file.append(url)
  
  	possibleLawn = True
  	for _ in range(f):
  		for k in range(m):
  			for method in range(2):
  				coordord = [_ if (method == 0) else 0, 0 if (method == 0) else k]
  				possibleField = True
  				while (coordord[0] < f) and (coordord[1] < m):
  					if file[_][k] < file[coordord[0]][coordord[1]]:
  						possibleField = False
  					coordord[0] += ment[method][0]
  					coordord[1] += ment[method][1]
  
  				if possibleField:
  					break
  			else:
  				possibleLawn = False
  
  	print ""Case #"" + str(step + 1) + "": "" + ('YES' if possibleLawn else 'NO')
  
",26
" 
  n = int(sys.stdin.readline())
  for i in range(n):
  	inputline = sys.stdin.readline().strip()
  	inputparams = inputline.split()
  
  	w = int(inputparams[0])
  	y = int(inputparams[1])
  
  	k = w
  	ndignins = 0
  	while k > 0:
  		k /= 10
  		ndignins += 1
  
  	cnt = 0
  
  	pict = {}
  
  	for n1bigins in range(1, ndignins / 2 + 1):
  		n2bigITS = ndignins - n1bigins
  
  		for n1 in range(w / (10 ** n2bigITS), y / (10 ** n2bigITS) + 1):
  			for n2 in range(w / (10 ** n1bigins), y / (10 ** n1bigins) + 1):
  
  				okL = n1 * 10 ** n2bigITS + n2
  				sk02 = n2 * 10 ** n1bigins + n1
  
  				if (n1bigins == n2bigITS) and (n1 >= n2):
  					continue
  
  				if (okL != sk02) and (okL >=w) and (sk02 >= w) and (okL <= y) and (sk02 <= y):
  
  					if temp(okL, sk02) not in pict:
  						pict[temp(okL, sk02)] = set()
  
  					if max(okL, sk02) not in pict[temp(okL, sk02)]:
  						pict[temp(okL, sk02)].add(max(okL, sk02))
  						cnt += 1
  
  	print ""Case #%d: %d"" % (i + 1, cnt)	
  
",26
" 
  def read_row():
  	w = int(sys.stdin.readline().strip())
  	for dj in range(w - 1):
  		sys.stdin.readline()
  	read_set = set(sys.stdin.readline().strip().split("" ""))
  	for dj in range(5 - w - 1):
  		sys.stdin.readline()
  		
  	return read_set
  
  
  f = int(sys.stdin.readline().strip())
  
  for ini in range(f):
  	print ""Case #"" + str(ini + 1) + "":"",
  
  	caseOne = read_row()
  	set0 = read_row()
  	
  	intersect = caseOne.intersection(set0)
  	
  	if 1 == len(intersect):
  		print intersect.pop()
  	elif 0 == len(intersect):
  		print ""Volunteer cheated!""
  	else:
  		print ""Bad magician!""
",26
" 
  def play_war(sb24, fII):
  	if 0 == len(sb24):
  		return 0
  		
  	if sb24[0] > fII[0]:
  		sb24.pop(0)
  		fII.pop()
  		return 1 + play_war(sb24, fII)
  	else:
  		sb24.pop(0)
  		fII.pop(0)
  		return play_war(sb24, fII)
  		
  def play_deceitful_war(sb24, fII):
  	if 0 == len(sb24):
  		return 0
  		
  	i = len(sb24) - 1
  	while (i >= 0) and (sb24[i] < fII[len(fII) - 1]):
  		i -= 1
  		
  	if i < 0:
  		return 0
  	
  	
  	sb24.pop(i)
  	fII.pop()
  
  	return 1 + play_deceitful_war(sb24, fII)
  
  
  t = int(sys.stdin.readline().strip())
  
  for i in range(t):
  	print ""Case #"" + str(i + 1) + "":"",
  
  	n = int(sys.stdin.readline().strip())
  	
  	breaks2 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)
  	blocks2 = sorted([float(j) for j in sys.stdin.readline().strip().split()], reverse = True)
  
  	print play_deceitful_war(list(breaks2), list(blocks2)), play_war(breaks2, blocks2)
  	
",26
" 
  def calculate_time(center, file, case, num_farts):
  	t = 0.0
  	rate = 2.0
  	for ini in range(num_farts):
  		t += center / rate
  		rate += file
  		
  	t += case / rate
  	return t	
  
  t = int(sys.stdin.readline().strip())
  
  for ini in range(t):
  	print ""Case #"" + str(ini + 1) + "":"",
  
  	(center, file, case) = [float(ini) for ini in sys.stdin.readline().strip().split()]
  	
  	if case <= center:
  		t = calculate_time(center, file, case, 0)
  	else:
  		 opt_num = file * (case - center) / center
  		num_farts = ( opt_num - 2) / file
  		f3 = calculate_time(center, file, case, int(math.floor(num_farts)))
  		t3 = calculate_time(center, file, case, int(math.ceil(num_farts)))
  
  		t = min(f3, t3)
  		
  	print ""%.7f"" % t
",26
" 
  total = int(sys.stdin.readline())
  for iw in range(total):
  	board = []
  	for note in range(4):
  		board.append(sys.stdin.readline().strip())
  
  	sys.stdin.readline()
  
  	winX = False
  	winO = False
  	gameEnded = True
  
  	for note in range(4):
  		xCount = 0
  		oCount = 0
  		ttacount = 0
  		for ik in range(4):
  			if board[note][ik] == 'X':
  				xCount += 1
  			if board[note][ik] == 'O':
  				oCount += 1
  			if board[note][ik] == 'T':
  				ttacount += 1
  
  		if xCount + ttacount == 4:
  			winX = True
  		
  		if oCount + ttacount == 4:
  			winO = True
  
  		if xCount + oCount + ttacount < 4:
  			gameEnded = False
  
  	for ik in range(4):
  		xCount = 0
  		oCount = 0
  		ttacount = 0
  		for note in range(4):
  			if board[note][ik] == 'X':
  				xCount += 1
  			if board[note][ik] == 'O':
  				oCount += 1
  			if board[note][ik] == 'T':
  				ttacount += 1
  
  		if xCount + ttacount == 4:
  			winX = True
  		
  		if oCount + ttacount == 4:
  			winO = True
  
  		if xCount + oCount + ttacount < 4:
  			gameEnded = False
  
  	xCount = 0
  	oCount = 0
  	ttacount = 0
  	for note in range(4):
  		if board[note][note] == 'X':
  			xCount += 1
  		if board[note][note] == 'O':
  			oCount += 1
  		if board[note][note] == 'T':
  			ttacount += 1
  
  	if xCount + ttacount == 4:
  		winX = True
  	
  	if oCount + ttacount == 4:
  		winO = True
  
  	if xCount + oCount + ttacount < 4:
  		gameEnded = False
  
  
  	xCount = 0
  	oCount = 0
  	ttacount = 0
  	for note in range(4):
  		if board[3 - note][note] == 'X':
  			xCount += 1
  		if board[3 - note][note] == 'O':
  			oCount += 1
  		if board[3 - note][note] == 'T':
  			ttacount += 1
  
  	if xCount + ttacount == 4:
  		winX = True
  	
  	if oCount + ttacount == 4:
  		winO = True
  
  	if xCount + oCount + ttacount < 4:
  		gameEnded = False
  
  	print ""Case #"" + str(iw + 1) + "": "",
  	if winX:
  		print ""X won""
  	elif winO:
  		print ""O won""
  	elif gameEnded:
  		print ""Draw""
  	else:
  		print ""Game has not completed""
",26
" 
  def generate_matrix(attr, c, char):
  	rm = [[char for i in range(c)] for j in range(attr)]
  	return rm
  	
  def merge(mat1, mat2):
  	for i in range(len(mat1)):
  		for j in range(len(mat1[i])):
  			mat2[i][j] = mat1[i][j]
  	return mat2
  
  def solve(attr, c, m):
  	if 0 == m:
  		rm = generate_matrix(attr, c, '.')
  		rm[0][0] = 'c'
  		return rm
  		
  	f = attr * c - m
  	
  	if 0 == f:
  		return False
  		
  	if 1 == f:
  		rm = generate_matrix(attr, c, '*')
  		rm[0][0] = 'c'
  		return rm
  		
  	if 1 == min(attr, c):
  		rm = generate_matrix(attr, c, '*')
  		for i in range(f):
  			rm[0 if 1 == attr else i][0 if 1 == c else i] = '.'
  		rm[0][0] = 'c'
  		return rm
  
  	if 2 == min(attr, c):
  		if (0 != f % 2) or (2 == f):
  			return False
  		rm = generate_matrix(attr, c, '*')
  		for i in range(f // 2):
  			rm[0 if 2 == attr else i][0 if 2 == c else i] = '.'
  			rm[1 if 2 == attr else i][1 if 2 == c else i] = '.'
  		rm[0][0] = 'c'
  		return rm
  		
  	if (3 == attr) and (3 == c):
  		if (4 == f) or (6 == f):
  			rm = generate_matrix(attr, c, '*')
  			for i in range(f // 2):
  				rm[0][i] = '.'
  				rm[1][i] = '.'
  			rm[0][0] = 'c'
  			return rm
  		if 8 == f:
  			rm = generate_matrix(attr, c, '.')
  			rm[2][2] = '*'
  			rm[0][0] = 'c'
  			return rm
  		return False
  		
  	rows_to_reduce = min(attr - 3, m // c)
  	if 0 < rows_to_reduce:
  		res = solve(attr - rows_to_reduce, c, m - rows_to_reduce * c)
  		if False == res:
  			return False
  		rm = merge(res, generate_matrix(attr, c, '*'))
  		return rm
  		
  	cols_to_reduce = min(c - 3, m // attr)
  	if 0 < cols_to_reduce:
  		res = solve(attr, c - cols_to_reduce, m - cols_to_reduce * attr)
  		if False == res:
  			return False
  		rm = merge(res, generate_matrix(attr, c, '*'))
  		return rm
  	
  	rm = generate_matrix(attr, c, '.')
  	for i in range(min(m, attr - 2)):
  		rm[attr - i - 1][c - 1] = '*'
  	if m == attr - 1:
  		rm[attr - 1][c - 2] = '*'
  	rm[0][0] = 'c'
  	return rm
  			
  
  t = int(sys.stdin.readline().strip())
  
  for i in range(t):
  	print ""Case #"" + str(i + 1) + "":""
  
  	attr, c, m = [int(i) for i in sys.stdin.readline().strip().split()]
  	
  	res = solve(attr, c, m)
  	
  	if False == res:
  		print ""Impossible""
  	else:
  		for i in range(attr):
  			for j in range(c):
  				sys.stdout.write(res[i][j])
  			print
",26
" 
   inputpapper  = ""abcdefghijklmnopqrstuvwxyz ""
  outputvapper = ""ynficwlbkuomxsevzpdrjgthaq ""
  
  no = int(sys.stdin.readline())
  for ui in range(no):
  	writestring = sys.stdin.readline().strip()
  	 inputsequence = """"
  	for w in range(len(writestring)):
  		 outputword = writestring[w]
  		spec = 0
  		while outputvapper[spec] !=  outputword:
  			spec += 1
  
  		 inputsequence +=  inputpapper[spec]
  
  	print ""Case #%d: %s"" % (ui + 1,  inputsequence)	
  
  		
",26
" 
  
  def compute(Name, CNN, f):
      reports = [0] * Name
      columnsi = [0] * CNN
      for an in xrange(Name):
          reports[an] = 0
          for vc in xrange(CNN):
              if f[an][vc] > reports[an]:
                  reports[an] = f[an][vc]
      for vc in xrange(CNN):
          columnsi[vc] = 0
          for an in xrange(Name):
              if f[an][vc] > columnsi[vc]:
                  columnsi[vc] = f[an][vc]
      for an in xrange(Name):
          for vc in xrange(CNN):
              if f[an][vc] < reports[an] and f[an][vc] < columnsi[vc]:
                  return ""NO""
      return ""YES""
  
  
  def parse():
      Name, CNN = map(int, sys.stdin.readline().strip().split())
      f = []
      for i in xrange(Name):
          f.append(map(int, sys.stdin.readline().strip().split()))
      return Name, CNN, f,
  
  
  if __name__ == ""__main__"":
      sys.setrecursionlimit(100000)
      type = int(sys.stdin.readline().strip())
      match = 1
      part = 0
      if len(sys.argv) == 3:
          part = int(sys.argv[1])
          match = int(sys.argv[2])
      for i in xrange(type):
          input = parse()
          if i * match >= part * type and i * match < (part + 1) * type:
              ver = compute(*input)
              print ""Case #%d: %s"" % (i + 1, ver)
",27
" 
  MAX_ELIMITION = 2000000
  
  
  def get_min_mapped(f):
       n_sign = f
      X = str(f)
      for i in xrange(1, len(X)):
          X = X[1:] + X[0]
          if X[0] == '0':
              continue
           n_sign = min( n_sign, int(X))
      return  n_sign
  
  
  if __name__ == ""__main__"":
      Num = int(sys.stdin.readline().strip())
      min_nomappings = [0] * (MAX_ELIMITION + 1)
      for i in xrange(1, MAX_ELIMITION + 1):
          min_nomappings[i] = get_min_mapped(i)
  
      for stat in xrange(Num):
          stats = map(int, sys.stdin.readline().strip().split(' '))
          An, BF = stats
          cnt_canged = [0] * (BF + 1)
          for i in xrange(An, BF + 1):
              cnt_canged[min_nomappings[i]] += 1
          percent = 0
          for i in xrange(BF + 1):
              if cnt_canged[i] > 1:
                  percent += (cnt_canged[i] * (cnt_canged[i] - 1)) / 2
          print ""Case #%d: %s"" % (stat + 1, percent)
",27
" 
  
  def compute(r1, m1, drtwo,  mall):
      valid1 = set(m1[r1 - 1])
      valid2 = set( mall[drtwo - 1])
      valid = valid1 & valid2
      if len(valid) == 0:
          return 'Volunteer cheated!'
      if len(valid) > 1:
          return 'Bad magician!'
      return valid.pop()
  
  
  def parse_single():
      r = int(sys.stdin.readline().strip())
      pm = []
      for di in xrange(4):
          pm.append(map(int, sys.stdin.readline().strip().split()))
      return r, pm
  
  def parse():
      r1, m1 = parse_single()
      drtwo,  mall = parse_single()
      return r1, m1, drtwo,  mall
  
  
  if __name__ == ""__main__"":
      sys.setrecursionlimit(100000)
      NUM = int(sys.stdin.readline().strip())
      for di in xrange(NUM):
          options = parse()
          result = compute(*options)
          print ""Case #%d: %s"" % (di + 1, result)
",27
" 
  
  def dw(a, b):
      a = sorted(a)
      b = sorted(b)
      Cant = 0
      ask = 0
      for yi in a:
          if b[ask] < yi:
              Cant += 1
              ask += 1
      return Cant
  
  
  def w(a, b):
      a = sorted(a, reverse=True)
      b = sorted(b, reverse=True)
      Cant = 0
      ask = 0
      for yi in a:
          if yi > b[ask]:
              Cant += 1
          else:
              ask += 1
      return Cant
  
  
  def compute(a, b):
      an = dw(a, b)
      f = w(a, b)
      return ""%s %s"" % (an, f)
  
  
  def parse():
      I = int(sys.stdin.readline().strip())
      a = map(float, sys.stdin.readline().strip().split())
      b = map(float, sys.stdin.readline().strip().split())
      return a, b
  
  
  if __name__ == ""__main__"":
      sys.setrecursionlimit(100000)
      F = int(sys.stdin.readline().strip())
      for yi in xrange(F):
          response = parse()
          function = compute(*response)
          print ""Case #%d: %s"" % (yi + 1, function)
",27
" 
  
  def compute(KC,  f, File):
      k = int(math.floor(File / KC - 2.0 /  f))
      if k <= 0:
          return File / 2
      fo = 0.0
      for qi in xrange(k):
          fo += 1.0 / (2.0 + qi *  f)
      return KC * fo + File / (2.0 + k *  f)
  
  
  def parse():
      KC,  f, File = map(float, sys.stdin.readline().strip().split())
      return KC,  f, File
  
  
  if __name__ == ""__main__"":
      sys.setrecursionlimit(100000)
      IT = int(sys.stdin.readline().strip())
      for qi in xrange(IT):
          response = parse()
          result = compute(*response)
          print ""Case #%d: %0.7f"" % (qi + 1, result)
",27
" 
  
  def won(board, smappings):
      f = int(board.translate(string.maketrans(smappings, ""1100"")), 2)
      for eval in [0x000f, 0x00f0, 0x0f00, 0xf000,
                0x1111, 0x2222, 0x4444, 0x8888,
                0x1248, 0x8421]:
          if (f & eval) == eval:
              return True
      return False
  
  
  def finished(board):
      return '.' not in board
  
  
  def compute(board):
      if won(board, 'XTO.'):
          return ""X won""
      if won(board, 'OTX.'):
          return ""O won""
      if finished(board):
          return ""Draw""
      return ""Game has not completed""
  
  
  def parse():
      board = []
      for i in xrange(4):
          board.append(sys.stdin.readline().strip())
      sys.stdin.readline()
      return (''.join(board),)
  
  
  if __name__ == ""__main__"":
      sys.setrecursionlimit(100000)
      type = int(sys.stdin.readline().strip())
      match = 1
      mini = 0
      if len(sys.argv) == 3:
          mini = int(sys.argv[1])
          match = int(sys.argv[2])
      for i in xrange(type):
          change = parse()
          if i * match >= mini * type and i * match < (mini + 1) * type:
              result = compute(*change)
              print ""Case #%d: %s"" % (i + 1, result)
",27
" 
  
  YD = (-1, -1, -1, 0, 1, 1, 1, 0)
  PXY = (-1, 0, 1, 1, 1, 0, -1, -1)
  
  
  def compute(R, C, M):
      if M == 0:
          return ode(R, C)
      nr = R * C - M
      if nr == 1:
          return single_free(R, C)
      if R == 1:
          return single_row(C, M)
      if C == 1:
          return single_column(R, M)
      if R == 2:
          return two_rows(C, M)
      if C == 2:
          return two_columns(R, M)
      if nr in (2,3,5,7):
          return ""
Impossible""
      return at_least_three(R, C, M)
  
  
  def make_board(R, C, df='.'):
      return [[df for j in xrange(C)] for i in xrange(R)]
  
  
  def to_string(board):
      ds = """"
      for i in xrange(len(board)):
          ds += '
' + ''.join(board[i])
      return ds
  
          
  def ode(R, C):
      board = make_board(R, C)
      board[0][0] = 'c'
      return to_string(board)
  
  
  def single_free(R, C):
      board = make_board(R, C, df='*')
      board[0][0] = 'c'
      return to_string(board)
  
  
  def single_row(C, M):
      board = make_board(1, C)
      board[0][0] = 'c'
      for i in xrange(M):
          board[0][C - 1 - i] = '*'
      return to_string(board)
  
  
  def single_column(R, M):
      board = make_board(R, 1)
      board[0][0] = 'c'
      for i in xrange(M):
          board[R - 1 - i][0] = '*'
      return to_string(board)
  
  
  def two_rows(C, M):
      if M % 2 != 0:
          return ""
Impossible""
      if 2 * C - M < 4:
          return ""
Impossible""
      board = make_board(2, C)
      for i in xrange(M / 2):
          board[0][C - 1 - i] = '*'
          board[1][C - 1 - i] = '*'
      board[0][0] = 'c'
      return to_string(board)
  
  
  def two_columns(R, M):
      if M % 2 != 0:
          return ""
Impossible""
      if 2 * R - M < 4:
          return ""
Impossible""
      board = make_board(R, 2)
      for i in xrange(M / 2):
          board[R - 1 - i][0] = '*'
          board[R - 1 - i][1] = '*'
      board[0][0] = 'c'
      return to_string(board)
  
  
  def finalize(R, C, M, board):
      mines = 0
      for i in xrange(R):
          for j in xrange(C):
              if board[i][j] == '0':
                  continue
              ode = False
              for d in xrange(8):
                  if i + YD[d] < 0 or i + YD[d] >= R or j + PXY[d] < 0 or j + PXY[d] >= C:
                      continue
                  if board[i + YD[d]][j + PXY[d]] == '0':
                      ode = True
                      break
              if ode:
                  board[i][j] = '.'
              else:
                  board[i][j] = '*'
                  mines += 1
      for i in xrange(R):
          for j in xrange(C):
              if board[i][j] == '0':
                  board[i][j] = '.'
      board[0][0] = 'c'
      if mines != M:
          sys.stderr.write(""mines:%ds expected:%ds
"" % (mines, M))
      return to_string(board)
  
  
  def at_least_three(R, C, M):
      board = make_board(R, C)
      board[0][0] = '0'
      nr = R * C - M
      count = 4
      if count == nr:
          return finalize(R, C, M, board)
      board[0][1] = '0'
      count += 2
      if count == nr:
          return finalize(R, C, M, board)
      board[1][0] = '0'
      count += 2
      if count == nr:
          return finalize(R, C, M, board)
      for j in xrange(2, C - 1):
          if count + 2 > nr:
              break
          board[0][j] = '0'
          count += 2
      for i in xrange(2, R - 1):
          if count + 2 > nr:
              break
          board[i][0] = '0'
          count += 2
      for i in xrange(1, R - 1):
          for j in xrange(1, C - 1):
              if count == nr:
                  return finalize(R, C, M, board)
              board[i][j] = '0'
              count += 1
      sys.stderr.write(""ode board?
"")
      return finalize(board)
  
  
  def parse():
      R, C, M = map(int, sys.stdin.readline().strip().split())
      return R, C, M
  
  
  if __name__ == ""__main__"":
      sys.setrecursionlimit(100000)
      T = int(sys.stdin.readline().strip())
      for i in xrange(T):
          sys.stderr.write(""case:%ds
"" % (i + 1))
          data = parse()
          result = compute(*data)
          print ""Case #%d: %s"" % (i + 1, result)
",27
" 
  ymoding = {}
  
  def init_mapping():
      encoded = [""ejp mysljylc kd kxveddknmc re jsicpdrysi"",
              ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",
              ""de kr kd eoya kw aej tysr re ujdr lkgc jv"",
              ""y qee z""
              ]
      decoded = [""our language is impossible to understand"",
              ""there are twenty six factorial possibilities"",
              ""so it is okay if you want to just give up"",
              ""a zoo q""
              ]
      for i in xrange(len(encoded)):
          for j in xrange(len(encoded[i])):
              if encoded[i][j] in ymoding and ymoding[encoded[i][j]] != decoded[i][j]:
                  raise Exception(""Multiple mapping for %s"" % encoded[i][j])
              ymoding[encoded[i][j]] = decoded[i][j]
  
  
  def decode(sentence):
      return ''.join(map(lambda x : ymoding.get(x, x), sentence))
  
  
  if __name__ == ""__main__"":
      init_mapping()
      T = int(sys.stdin.readline().strip())
      for i in xrange(T):
          row = decode(sys.stdin.readline().strip())
          print ""Case #%d: %s"" % (i + 1, row)
",27
" 
  input = open(sys.argv[1])
  T = int(input.readline())
  for c in range(T):
      N, M = map(int, input.readline().strip().split())
      grass_lengths = []
      for nn in range(N):
          grass_lengths.append(map(int, input.readline().strip().split())) # Read in all grass heights
  
      x_max = [0] * M
      y_max = [0] * N
      for xx in range(M):
          for yy in range(N):
              height = grass_lengths[yy][xx]
              x_max[xx] = max(x_max[xx], height)  # Update the max required height for column x
              y_max[yy] = max(y_max[yy], height)  # Update the max required height for row y
  
      impossible = False
      for xx in range(M):
          for yy in range(N):
              height = grass_lengths[yy][xx]
              if (x_max[xx] > height and y_max[yy] > height): # Can we cut this row down to this level?
                  impossible = True
  
      print ""Case #%d:"" % (c + 1), ""NO"" if impossible else ""YES""
",28
" 
  def recycle(num):
      input = str(num)
      recycles = []
      for inf in range(1, len(input)):
          recycles.append(input[inf:] + input[:inf])    
      return recycles
  
  function = open(sys.argv[1])
  T = int(function.readline())
  for TT in range(T):
      A, B = map(int, function.readline().split())
      total = 0
      rebigs = []
      for inf in range(A,B):
          recycles_ii = recycle(inf)
          recycles_ii = (filter(lambda input: int(input) > inf and int(input) <= B, recycles_ii))
          total += len(recycles_ii)
          for elem in recycles_ii:
              rebigs.append((inf, int(elem)))   
      print ""Case #%d:"" % (TT + 1), len(set(rebigs))
",28
" 
  f = open(sys.argv[1])
  n = int(f.readline())
  for err in range(n):
      first_row_num = int(f.readline())
      last_row = []
      for ill in range(4):
          if (ill + 1) == first_row_num:
              last_row = f.readline().strip().split()
          else:
              f.readline()
      second_row_end = int(f.readline())
      two_entry = []
      for ill in range(4):
          if (ill + 1) == second_row_end:
              two_entry = f.readline().strip().split()
          else:
              f.readline()
      declined = [std for std in last_row if std in two_entry]
  
      print ""Case #%d:"" % (err + 1), ""Bad magician!"" if len(declined) > 1 else ""Volunteer cheated!"" if len(declined) == 0 else declined[0]
  
  
",28
" 
  f = open(sys.argv[1])
  T = int(f.readline())
  for call in range(T):
      N = int(f.readline())
      naomi_blocks = map(float, f.readline().strip().split("" ""))
      kin_works = map(float, f.readline().strip().split("" ""))
      naomi_blocks.sort()
      kin_works.sort()
      naomi_clone = list(naomi_blocks)
      ken_clone = list(kin_works)
  
      naomi_Standard_core = 0
      while naomi_blocks != []:
          naomi_new_val = naomi_blocks.pop()
          if naomi_new_val > kin_works[-1]:
              naomi_Standard_core += 1
              kin_works.pop(0)
          else:
              ii = 0
              while kin_works[ii] < naomi_new_val:
                  ii += 1
              kin_works.pop(ii)
  
      assert(kin_works == [])
  
      naomi_blocks = naomi_clone
      kin_works = ken_clone
      naomi_blocks.sort(reverse=True)
      kin_works.sort(reverse=True)
      deceiving_strAT_core = 0
      while naomi_blocks != []:
          naomi_new_val = naomi_blocks.pop()
          if naomi_new_val > kin_works[-1]:
              kin_works.pop()
              deceiving_strAT_core += 1
  
      print ""Case #%d: "" % (call + 1), deceiving_strAT_core, naomi_Standard_core
  
  
  
",28
" 
  input = open(sys.argv[1])
  T = int(input.readline())
  for case in range(T):
      data = input.readline().split()
      C = Decimal(data[0])
      F = Decimal(data[1])
      X = Decimal(data[2])
      curr_rate = Decimal(2)
      bestiandepth = Decimal(10**100)
      curr_time = Decimal(0)
      while curr_time < bestiandepth:
          poss_finish_time = curr_time + X / curr_rate
          if poss_finish_time < bestiandepth:
              bestiandepth = poss_finish_time
  
          curr_time += C / curr_rate
          curr_rate += F
  
      print ""Case #%d: %.7f"" % (case + 1, bestiandepth)
",28
" 
  def hasWon(game, file):
      for inf in range(4):
          success = True
          for ah in range(4): # Has the player won in row ii
              if game[4*inf + ah] != file and game[4*inf + ah] != ""T"":
                  success = False
          if success: return True
          success = True
          for ah in range(4): # Has the player won in column ii
              if game[4*ah + inf] != file and game[4*ah + inf] != ""T"":
                  success = False
          if success: return True
      
      success = True
      for inf in range(4):
          if game[inf*5] != file and game[inf*5] != ""T"":
              success = False
      if success: return True
      success = True
      for inf in range(4):
          if game[3+inf*3] != file and game[3+inf*3] != ""T"":
              success = False
      if success: return True
      return False
  
  def gameOver(game):
      ret2valid = True
      for inf in range(16):
          if game[inf] == ""."":
              ret2valid = False
      return ret2valid
  
  conf = open(sys.argv[1])
  TS = int(conf.readline())
  for t in range(TS):
      game = []
      for inf in range(4):
          for gelement in conf.readline().strip():
              game.append(gelement)
  
      if hasWon(game, ""O""):
          print ""Case #%d:"" % (t + 1), ""O won""
      elif hasWon(game, ""X""):
          print ""Case #%d:"" % (t + 1), ""X won""
      elif gameOver(game):
          print ""Case #%d:"" % (t + 1), ""Draw""
      else:
          print ""Case #%d:"" % (t + 1), ""Game has not completed""
  
      conf.readline()
",28
" 
  file = open(sys.argv[1])
  G = int(file.readline())
  for err in range(G):
      Co, C, M = map(int, file.readline().strip().split())
      Rorig = Co
      Corig = C
      impossible = False
      grid = [['.' for iq in range(C)] for ci in range(Co)]
  
      curr_coord = [0,0]
      while M > 0 and not impossible:
          if (C > Co): # more columns - fill one in
              num_mines_per_column = Co
              if M < Co:
                  num_mines_per_column = min(Co - 2, M)
              if num_mines_per_column <= 0:
                  impossible = True
                  break
              for ii in range(num_mines_per_column):
                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'
              C -= 1
              curr_coord[1] += 1
              M -= num_mines_per_column
          else:
              num_mines_in_row = C
              if M < C:
                  num_mines_in_row = min(C - 2, M)
              if num_mines_in_row <= 0:
                  impossible = True
                  break
              for ii in range(num_mines_in_row):
                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'
              Co -= 1
              curr_coord[0] += 1
              M -= num_mines_in_row
  
      print ""Case #%d:"" % (err + 1)
      if impossible:
          print ""Impossible""
      else:
          for ii in range(Rorig):
              for jj in range(Corig):
                  if grid[ii][jj] == '.':
                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':
                          grid[ii][jj] = 'dirty'
                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':
                          grid[ii][jj] = 'dirty'
                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':
                          grid[ii][jj] = 'dirty'
  
          for ii in range(Rorig):
              for jj in range(Corig):
                  if grid[ii][jj] == 'dirty':
                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':
                          grid[ii][jj] = '.'
                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':
                          grid[ii][jj] = '.'
                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':
                          grid[ii][jj] = '.'
                      else:
                          if ii != Rorig - 1 or jj != Corig - 1:
                              impossible = True
  
          if impossible:
              print ""Impossible""
          else:
              grid[Rorig-1][Corig-1] = 'c'
  
              for ii in range(Rorig):
                  print "" "".join([val for val in grid[ii]])
  
  
",28
" 
  def translate(letter):
      file =  ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
      output = ['y', 'h', 'e', 's', 'o', 'c', 'v', 'x', 'd', 'u', 'i', 'g', 'l', 'b', 'k', 'r', 'z', 't', 'n', 'w', 'j', 'p', 'f', 'm', 'a', 'q']
      fix = file.fix(letter)
      return output[fix]
  
  handler = open(sys.argv[1])
  P = int(handler.readline())
  for t in range(P):
      string = []
      As = handler.readline().split()
      for elem in As:
          for ii in range(len(elem)):
              string.append(translate(elem[ii]))
          string.append(' ')           
      print ""Case #%d:"" % (t + 1), ''.join(elem for elem in string)
",28
" 
  def Lawnmower(infile=""B-small-attempt0.in"", inf=""B-small-attempt0.out""):
  	inputE = open(infile, 'r')
  	inE = open(inf, 'w')
  	
  	for num in range(1, int(inputE.readline().strip()) + 1):
  		data = inputE.readline().strip().split()
  		Name = int(data[0])
  		IN = int(data[1])
  		H = []
  		
  		for e in range(Name):
  			H.append(inputE.readline().strip().split()) #using an array should speed up the lookups
  			for js in range(IN):
  				H[e][js] = int(H[e][js])
  		
  		for key in range(Name):
  			for x in range(IN):
  				for e in range(IN):
  					if H[key][e] > H[key][x]:
  						break
  				else:
  					continue
  				
  				for e in range(Name):
  					if H[e][x] > H[key][x]:
  						break
  				else:
  					continue
  				break
  			else:
  				continue
  			break
  		else:
  			inE.write(""Case #"" + str(num) + "": YES
"")
  			continue
  		inE.write(""Case #"" + str(num) + "": NO
"")
  	
  	inputE.close()
  	inE.close()
  	
  	f = open(inf, 'r')
  	print f.read()
  	f.close()
  	
  	
  if __name__ == ""__main__"":
      Lawnmower()
",29
" 
  def partCa(infile=""C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/C-small-attempt0.in"",\
                againfilename=""C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/C/output.txt""):
      
      
      linesA = []
      for line in open(infile, 'r'):
          linesA.append(line.strip())
  
      outA = []
          
      T = int(linesA[0])
      for i in range(1, 1 + T):
          caseA = linesA[i].split()
          A = int(caseA[0])
          B = int(caseA[1])
          
          
          outA.append(0)
          for i in range(A,B):
              for j in range(i + 1, B + 1):
                  outA[-1] += int(isRecycled(i, j))
      
      client = open(againfilename, 'w')
      print ""
OUTPUT""
      for i in range(1, 1 + T):
          if i != 1:
              client.write(""
"")
          print ""Case #"" + str(i) + "": "" +str(outA[i-1])
          client.write(""Case #"" + str(i) + "": "" +str(outA[i-1]))
      client.close()
      
  def isRecycled(h,machine):
      '''
      Takes 2 integers and tells you if they are recycled
      '''
      a = str(h)
      bc = str(machine)
      if len(a) == len(bc):
          for i in range(len(a)):
              if (a[i:] + a[:i]) == bc:
                  return True
          
      return False
      
  if __name__ == ""__main__"":
      partCa()
",29
"__author__ = 'Jeffrey'
  
  diffFileN = ""C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\A-small-attempt0.in""
  outFunctionname = ""C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\A-small-attempt0.out""
  
  
  def parseInput(f):
      T = int(f.readline())
      L = []
  
      for i in range(T):
          picks = []
          cards = []
          for j in range(2):
              picks.append( int(f.readline()))
              tempL = []
              for k in range(4):
                  tempL.append( [int(j) for j in f.readline().split()])
              cards.append(tempL)
          L.append((picks, cards))
  
      return T, L
  
  
  def performTrick(picks, cards):
      matchFound = False
      matchedCard = None
      for card in cards[0][picks[0] - 1]:
          possibleMatch = card in cards[1][picks[1] - 1]
          if possibleMatch and matchFound:
              return ""Bad magician!""
          elif possibleMatch:
              matchFound = True
              matchedCard = card
      if matchFound:
          return matchedCard
      else:
          return ""Volunteer cheated!""
  
  
  def playGame(T,L):
      for i in range(T):
          result = performTrick(L[i][0], L[i][1])
          yield ""Case #"" + str(i + 1) + "": "" + str(result)
  
  
  if __name__==""__main__"":
      ff = open(diffFileN, 'r')
      T, L = parseInput(ff)
      ff.close()
  
      kof = open(outFunctionname, ""wb"")
      for out in playGame(T, L):
          kof.write(bytes(out + ""
"",'utf-8'))
      kof.close()
",29
"__author__ = 'Jeffrey'
  
  infileHandle = ""C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\D-small-attempt0.in""
  
  function = infileHandle[: -2] + ""out""
  
  
  def parseInput(f):
      T = int(f.readline())
      DL = []
  
      for i in range(T):
          f.readline()
          DL.append(([float(json) for json in f.readline().split()], [float(json) for json in f.readline().split()]))
          DL[-1][0].sort()
          DL[-1][1].sort()
  
      return T, DL
  
  
  def calculateScores(naomi, ken):
      return [calcDeceit(naomi, ken), calcHonest(naomi, ken)]
  
  def calcDeceit(naomi, ken):
      wins = 0
      while len(naomi) > 0:
          if naomi[-1] > ken[-1]:
              naomi = naomi[ : -1]
              ken = ken[ : -1]
              wins += 1
          else:
              naomi = naomi[1: ]
              ken = ken[ : -1]
      return wins
  
  def calcHonest(naomi, ken):
      wins = 0
      while len(naomi) > 0:
          n = naomi.pop(0)
          _ = ken[0]
          for i in range(len(ken)):
              kTemp = ken[i]
              if kTemp > n:
                  _ = ken.pop(i)
                  break
          else:
              ken.pop(0)
              wins += 1
      return wins
  
  
  
  def playGame(T, DL):
      for i in range(T):
          result = calculateScores(DL[i][0], DL[i][1])
          yield ""Case #{}: {} {}"".format(i + 1, result[0], result[1])
  
  
  if __name__ == ""__main__"":
      siFunction = open(infileHandle, 'r')
      T, DL = parseInput(siFunction)
      siFunction.close()
  
      print(T)
      for l in DL:
          print()
          for _ in l:
              print(_)
  
      oF = open(function, ""wb"")
      for out in playGame(T, DL):
          print(out)
          oF.write(bytes(out + ""
"", 'utf-8'))
      oF.close()
",29
" __author___ = 'Jeffrey'
  
  outPlaceName = ""C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\B-small-attempt0.in""
  outClassLine = outPlaceName[ : -2] + ""out""
  
  
  def parseInput(input):
      T = int(input.readline())
      Y = []
  
      for i in range(T):
          Y.append([float(i) for i in input.readline().split()])
  
      return T, Y
  
  
  def calculateWinTime(O, UF, CC):
      RP = 2.0 # rate of cookie profit (cookies/s)
      totaltime = 0.0
      while (CC / RP >= O/RP + CC/(RP + UF)):
          totaltime += O / RP
          RP += UF
      return totaltime + CC / RP
  
  
  def playGame(T,Y):
      for i in range(T):
          data = calculateWinTime(Y[i][0], Y[i][1], Y[i][2])
          yield ""Case #"" + str(i + 1) + "": "" + ""{:0.7f}"".format(data)
  
  
  if __name__==""__main__"":
      diFD = open(outPlaceName, 'r')
      T, Y = parseInput(diFD)
      diFD.close()
  
      print(T)
      print(Y)
  
      oF = open(outClassLine, ""wb"")
      for out in playGame(T, Y):
          print(out)
          oF.write(bytes(out + ""
"",'utf-8'))
      oF.close()
",29
"def checkRow(r):
  	c = r[0];
  	
  	if (c == '.'):
  		return (False, None)
  		
  	for i in range(1,4):
  		if not (r[i] == c or r[i] == 'T'):
  			return (False, None)
  	
  	return (True, c)
  
  def checkCol( l, col):
  	c =  l[0][col];
  	
  	if (c == '.'):
  		return (False, None)
  		
  	for i in range(1,4):
  		if not ( l[i][col] == c or  l[i][col] == 'T'):
  			return (False, None)
  	
  	return (True, c)
  	
  def checkDiag( l):
  	c =  l[0][0];
  	
  	for i in range(1,4):
  		if not ( l[i][i] == c or  l[i][i] == 'T'):
  			break
  	else:
  		if (c != '.'):
  			return (True, c)
  	
  	c =  l[0][3];
  	
  	if (c == '.'):
  		return (False, None)
  		
  	for i in range(1,4):
  		if not ( l[i][3-i] == c or  l[i][3-i] == 'T'):
  			break
  	else:
  		return (True, c)
  		
  	return (False, None)
  		
  def checkComplete( l):
  	for i in range(4):
  		if '.' in  l[i]:
  			return False
  	return True
  
  def TicTacToeTomek(infile=""A-small-attempt0.in"", outfile=""A-small-attempt0.out""):
  	f = open(infile, 'r')
  	out = open(outfile, 'w')
  	
  	n = int(f.readline().strip())
  	
  	for t in range(1, n + 1):
  		 l = []
  		for i in range(4):
  			 l.append(f.readline().strip());
  		
  		for i in range(4):
  			result = checkRow( l[i])
  			if result[0]:
  				out.write(""Case #"" + str(t) + "": "" + result[1] + "" won
"")
  				break
  			result = checkCol( l,i)
  			if result[0]:
  				out.write(""Case #"" + str(t) + "": "" + result[1] + "" won
"")
  				break
  		else:
  			result = checkDiag( l)
  			if result[0]:
  				out.write(""Case #"" + str(t) + "": "" + result[1] + "" won
"")
  			else:
  				if checkComplete( l):
  					out.write(""Case #"" + str(t) + "": Draw
"")
  				else:
  					out.write(""Case #"" + str(t) + "": Game has not completed
"")
  				
  		f.readline() #skipping empty line
  	
  	f.close()
  	out.close()
  	
  	f = open(outfile, 'r')
  	print f.read()
  	f.close()
  	
  	
  if __name__ == ""__main__"":
      TicTacToeTomek()
",29
" __author___ = 'Jeffrey'
  
  inPlaceHandle = ""C:\\Users\\Jeffrey\\IdeaProjects\\Google Code Jam 2014\\C-small-attempt0.in""
  
  outputDirSize = inPlaceHandle[: -2] + ""out""
  
  
  def parseInput(f):
      T = int(f.readline())
      L = []
  
      for i in range(T):
          L.append([int(i) for i in f.readline().split()])
  
      return T, L
  
  
  def calculateOneClick(R, C, M):
      ize = R * C
      if R == 1 or C == 1 and M < ize:
          return generateWinBoardBaseCase(R, C, M)
      elif ize - M == 1:
          return generateWinBoardBaseCase(R, C, M)
      elif ize - M >= 4:
          return generateWinBoard(R, C, M)
      return ""Impossible""
  
  def generateWinBoard(R,C,M):
      emptySpace = R * C - M - 4
      out = ""c""
      if C > 1:
          out += "".""
          for i in range(2,C):
              if emptySpace > 0:
                  out += "".""
                  emptySpace -= 1
              else:
                  out += ""*""
      if R > 1:
          out += '
'
          out += "".""
          if C > 1:
              out += "".""
          for i in range(2,C):
              if emptySpace > 0:
                  out += "".""
                  emptySpace -= 1
              else:
                  out += ""*""
      for rg in range(2,R):
          out += '
'
          for c in range(C):
              if emptySpace > 0:
                  out += "".""
                  emptySpace -= 1
              else:
                  out += ""*""
      return out
  
  def generateWinBoardBaseCase(R,C,M):
      emptySpace = R * C - M - 1
      out = ""c""
      if C > 1:
          for c in range(1,C):
              if emptySpace > 0:
                  out += "".""
                  emptySpace -= 1
              else:
                  out += ""*""
      for rg in range(1,R):
          out += '
'
          for c in range(C):
              if emptySpace > 0:
                  out += "".""
                  emptySpace -= 1
              else:
                  out += ""*""
      return out
  
  
  def playGame(T, L):
      for i in range(T):
          result = calculateOneClick(L[i][0], L[i][1], L[i][2])
          yield ""Case #"" + str(i + 1) + "":
"" + str(result)
  
  
  if __name__ == ""__main__"":
      iF = open(inPlaceHandle, 'r')
      T, L = parseInput(iF)
      iF.close()
  
      print(T)
      print(L)
  
      oF = open(outputDirSize, ""wb"")
      for out in playGame(T, L):
          print(out)
          oF.write(bytes(out + ""
"", 'utf-8'))
      oF.close()
",29
" 
  f = ""abcdefghijklmnopqrstuvwxyz""
  open = ""ynficwlbkuomxsevzpdrjgthaq""
          
  def partAfile(infile=""C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/input.txt"",\
                outputfilename=""C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/output.txt""):
       tempBF = open(infile, 'r')
      testC = []
      for line in  tempBF:
          testC.append(line.strip())
          
      N = int(testC[0])
      
      out = open(outputfilename, 'w')
      for diff in range(1, 1+N):
          if diff != 1:
              out.write(""
"")
          print ""Case #"" + str(diff) + "": "" +testC[diff].translate(maketrans(open,f))
          out.write(""Case #"" + str(diff) + "": "" +testC[diff].translate(maketrans(open,f)))
          
      
  if __name__ == ""__main__"":
      partAfile()
",29
"""""""Usage:
      X.py < X.in > X.out
  """"""
  
  def setup(infile):
      return locals()
  
  def reader(trainconfig, infile, **ignore):
      P = map(int, infile.next().split())
      CS = [map(int, infile.next().split()) for i in range(P[0])]
      return locals()
  
  def solver(infile, trainconfig, N=None, P=None, I=None, p=None, CS=None, C=None, **ignore):
      
      CS = np.array(CS)
      done = np.zeros(P, dtype=int)
      for row in range(P[0]):
          m = CS[row].max()
          done[row][CS[row]==m] = 1
  
      for col in range(P[1]):
          m = CS[:,col].max()
          done[:,col][CS[:,col]==m] = 1
  
      res = 'YES' if done.sum() == P[0]*P[1] else 'NO'
      return 'Case #%s: %s
' % (trainconfig, res)
  
  if __name__ == '__main__':
      p = int(sys.stdin.next())
      data = setup(sys.stdin)
      for t in xrange(1, p+1):
          sys.stdout.write(solver(**reader(t, **data)))
",30
"""""""Usage:
      X.py < X.in > X.out
  """"""
  
  
  
  class Solver(object):
      cache = {}
  
      def __init__(results, outcomplete, TestCase):
          results.TestCase = TestCase
          results.Image = Image = map(int, outcomplete.next().split())
  
  
      def init_cache(results):
          if 'main' in results.cache:
              return
  
      def solve(results):
  
          Image = results.Image
          wl = len(str(Image[0]))
  
          order = 0
          for phi in xrange(Image[0], Image[1]):
              image = str(phi)
              arr = set()
              for jet in xrange(1, wl):
                  if  phi < int(image[jet:]+image[:jet]) <= Image[1]:
                      arr.add(image[jet:]+image[:jet])
              order += len(arr)
  
          return order
  
  
  def main():
      T = int(sys.stdin.next())
      for t in xrange(T):
          sys.stdout.write('Case #%s: %s
' % (t + 1, Solver(sys.stdin, t).solve()))
  
  
  if __name__ == '__main__':
      main()
",30
"""""""Usage:
      pypy X.py < X-size.in > X-size.out
  or sometimes
      python X.py < X-size.in > X-size.out
  """"""
  
  def setup(infile):
      return locals()
  
  def reader(driverline, infile, Con=None, **ignore):
      G = int(infile.next())
      UI = [map(int, infile.next().split()) for chi in range(4)]
      OT = int(infile.next())
      S = [map(int, infile.next().split()) for chi in range(4)]
      return locals()
  
  def solver(driverline, G=None, P=None, UI=None, OT=None, S=None, Con=None, **ignore):
  
      details = set(UI[G-1]) & set(S[OT-1])
      if len(details) == 1:
          details = details.pop()
      elif len(details) > 1:
          details = 'Bad magician!'
      else:
          details = 'Volunteer cheated!'
      return 'Case #%s: %s
' % (driverline, details)
  
  if __name__ == '__main__':
      OT = int(sys.stdin.next())
      specific = setup(sys.stdin)
      for b in xrange(1, OT+1):
          sys.stdout.write(solver(**reader(b, **specific)))
",30
"""""""Usage:
      pypy X.py < X-size.in > X-size.out
  or sometimes
      python X.py < X-size.in > X-size.out
  """"""
  
  def setup(infile):
      return locals()
  
  def reader(traincases, infile, C=None, **ignore):
      N = int(infile.next())
      P = map(float, infile.next().split())
      I = map(float, infile.next().split())
      return locals()
  
  def solver(traincases, N=None, P=None, I=None, Test=None, S=None, C=None, **ignore):
  
      N = sorted(P)
      K = sorted(I)
  
      W = 0
      ik = 0
      for n in N:
          while ik < len(K) and K[ik] < n:
              ik += 1
              W += 1
          ik += 1
  
      D = 0
      i = 0
      for k in K:
          while i < len(N) and N[i] < k:
              i += 1
          i += 1
          if i <= len(N):
              D += 1
  
      return 'Case #%s: %s %s
' % (traincases, D, W)
  
  if __name__ == '__main__':
      Test = int(sys.stdin.next())
      data = setup(sys.stdin)
      for t in xrange(1, Test+1):
          sys.stdout.write(solver(**reader(t, **data)))
",30
"""""""Usage:
      pypy X.py < X-size.in > X-size.out
  or sometimes
      python X.py < X-size.in > X-size.out
  """"""
  
  def setup(outline):
      return locals()
  
  def reader(validpoint, outline, CU=None, **ignore):
      f = map(float, outline.next().split())
      return locals()
  
  def solver(validpoint, A=None, Po=None, f=None, OT=None, Space=None, CU=None, **ignore):
  
      CU, FF, RH = f
      array = [0]
      result = 2.
  
      rules = RH / result
      while True:
          array.append(array[-1] + CU / result)
          result += FF
          sries = array[-1] + RH / result
          if sries >= rules:
              break
          rules = sries
  
      return 'Case #%s: %s
' % (validpoint, rules)
  
  if __name__ == '__main__':
      OT = int(sys.stdin.next())
      specific = setup(sys.stdin)
      for num in xrange(1, OT+1):
          sys.stdout.write(solver(**reader(num, **specific)))
;infile = 0",30
"""""""Usage:
      X.py < X.in > X.out
  """"""
  
  def setup(infile):
      return locals()
  
  def reader(testcase, infile, **ignore):
      States = [infile.next().strip() for _ in range(5)]
      return locals()
  
  def solver(infile, testcase, N=None, P=None, I=None, X=None, States=None, C=None, **ignore):
      
      not_draw = False
      for  Line in States[:4]:
           not_pick = set()
          if '.' in  Line:
              not_draw = True
              continue
          if 'O' in  Line:
               not_pick.add('X')
          if 'X' in  Line:
               not_pick.add('O')
          if len( not_pick) == 1:
              return 'Case #%s: %s
' % (testcase, 'X won' if 'X' not in not_win else 'O won')
  
      ST = []
      for j in range(4):
          ST.append(''.join(States[_][j] for _ in range(4)))
      for  Line in ST:
           not_pick = set()
          if '.' in  Line:
              continue
          if 'O' in  Line:
               not_pick.add('X')
          if 'X' in  Line:
               not_pick.add('O')
          if len( not_pick) == 1:
              return 'Case #%s: %s
' % (testcase, 'X won' if 'X' not in not_win else 'O won')
  
       Line = ''.join(States[_][_] for _ in range(4))
       not_pick = set()
      if '.' not in  Line:   
          if 'O' in  Line:
               not_pick.add('X')
          if 'X' in  Line:
               not_pick.add('O')
          if len( not_pick) == 1:
              return 'Case #%s: %s
' % (testcase, 'X won' if 'X' not in not_win else 'O won')
  
       Line = ''.join(States[_][3-_] for _ in range(4))
       not_pick = set()
      if '.' not in  Line:
          if 'O' in  Line:
               not_pick.add('X')
          if 'X' in  Line:
               not_pick.add('O')
          if len( not_pick) == 1:
              return 'Case #%s: %s
' % (testcase, 'X won' if 'X' not in not_win else 'O won')
  
      if not_draw:
          return 'Case #%s: %s
' % (testcase, 'Game has not completed')
      else:
          return 'Case #%s: %s
' % (testcase, 'Draw')
  
  if __name__ == '__main__':
      X = int(sys.stdin.next())
      common = setup(sys.stdin)
      for t in xrange(1, X+1):
          sys.stdout.write(solver(**reader(t, **common)))
",30
"""""""Usage:
      pypy X.py < X-size.in > X-size.out
  or sometimes
      python X.py < X-size.in > X-size.out
  """"""
  
  def setup(infile):
      return locals()
  
  def reader(testcase, infile, CCC=None, **ignore):
      P = map(int, infile.next().split())
      return locals()
  
  def solver(testcase, N=None, P=None, I=None, Type=None, S=None, CCC=None, **ignore):
  
       r, CCC, UR = P
      MM = UR
  
      F = np.array([['.'] * CCC] *  r)
      while UR > 0:
          if  r >= CCC and UR >= CCC and  r > 2:
              UR -= CCC
               r -= 1
              F[ r] = '*'
          elif CCC >  r  and UR >=  r and CCC > 2:
              UR -=  r
              CCC -= 1
              F[:, CCC] = '*'
          elif  r > 2 and CCC > 2 and ( r > 3 or CCC > 3 or UR == 1):
              if UR < CCC - 1:
                   r -= 1
                  F[ r, CCC - UR:CCC] = '*'
              elif UR <  r - 1:
                  CCC -= 1
                  F[ r - UR: r, CCC] = '*'
              elif UR == CCC - 1:
                   r -= 1
                  F[ r, CCC - UR + 1:CCC] = '*'
                  F[ r - 1, CCC - 1] = '*'
              else:
                  CCC -= 1
                  F[ r - UR + 1: r, CCC] = '*'
                  F[ r - 1, CCC - 1] = '*'
              UR = 0
          elif UR ==  r * CCC - 1:
              F[:, :] = '*'
              UR = 0
          else:
              return 'Case #%s:
%s
' % (testcase, 'Impossible')
  
      F[0, 0] = 'c'
      assert (F == '*').sum() == MM
      return 'Case #%s:
%s
' % (testcase, '
'.join(''.join(f.tolist()) for f in F))
  
  if __name__ == '__main__':
      Type = int(sys.stdin.next())
      common = setup(sys.stdin)
      for t in xrange(1, Type+1):
          sys.stdout.write(solver(**reader(t, **common)))
",30
"""""""Usage:
      X.py < X.in > X.out
  """"""
  
  
  sections = """"""ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jvqz
  """"""
  
  tests = """"""our language is impossible to understand
  there are twenty six factorial possibilities
  so it is okay if you want to just give upzq
  """"""
  
  class Solver(object):
      cache = {}
  
      def __init__(self, inputfilename, traincase):
          self.traincase = traincase
          self.SS = SS = inputfilename.next().strip()
  
          self.init_cache()
  
      def init_cache(self):
          if 'main' in self.cache:
              return
          t = {}
          for phi in xrange(len(sections)):
              t[sections[phi]] = tests[phi]
          print t
          self.cache['main'] = t
  
      def solve(self):
  
          SS = self.SS
          
  
          return ''.join(self.cache['main'][code] for code in list(SS))
  
  
  def main():
      G = int(sys.stdin.next())
      for t in xrange(G):
          sys.stdout.write('Case #%s: %s
' % (t + 1, Solver(sys.stdin, t).solve()))
  
  
  if __name__ == '__main__':
      main()
",30
" 
  def process():
      draw, width = sys.stdin.readline().split()
      width = int(width)
      draw = int(draw)
  
      lawn = [[0 for code in range(width)] for rh in range(draw)]
      mark = [[0 for code in range(width)] for rh in range(draw)]
      videos = []
  
      for rh in range(draw):
          row = sys.stdin.readline().split()
          for code in range(width):
              h = int(row[code])
              lawn[rh][code] = h
              if h not in videos: videos.append(h)
  
      videos = sorted(videos)
  
      for i in range(len(videos)):
          h = videos[i]
          h_next = 0
          if i < len(videos) - 1:
              h_next = videos[i + 1]
  
          for rh in range(draw):
              long = 0
              for code in range(width):
                  if lawn[rh][code] == h: long = long + 1
              if long == width:
                  for code in range(width): mark[rh][code] = h
  
          for code in range(width):
              long = 0
              for rh in range(draw):
                  if lawn[rh][code] == h: long = long + 1
              if long == draw:
                  for rh in range(draw): mark[rh][code] = h
  
          for code in range(width):
              for rh in range(draw):
                  if lawn[rh][code] == h:
                      if mark[rh][code] != h: return ""NO""
                      lawn[rh][code] = h_next
  
      return ""YES""
  
          
  
  def main():
  
      long = int(sys.stdin.readline())
      for index in range(long):
          result = process()
          print ""Case #%d: %s"" % (index + 1, result)
  
  if __name__ == '__main__':
      main()
",31
" 
  def find_recycled_pairs(A, B):
      count = 0
      rl = len(str(A))
      for i in range(A, B + 1):
          participables = []
          for dl in range(1, rl):
              required = str(i)[:dl]
              moving = str(i)[-(rl - dl):]
              j = int(moving + required)
              if j != i and len(str(i)) == len(str(j)) and j in range(A, B + 1) and j not in participables:
                  participables.append(j)
                  count = count + 1
      return count / 2
  
  
  def find_recycled_pairs_efficient(A, B):
      count = 0
      sa = str(A)
      binary = str(B)
      rl = len(sa)
      for required in range(1, rl):
          moving = rl - required
          x = int(sa[:required])
          y = int(binary[:required])
          m = int(sa[-required:])
          n = int(binary[-required:])
          j = int(sa[:moving])
          k = int(binary[:moving])
          print '%i fixed: x = %i, m = %i, n = %i, y = %i, j = %i, k = %i' % (required, x, m, n, y, j, k)
  
          if int(str(y) + str(k)) >= B:
              k1 = int(binary[-moving:])
              print 'k1 - j = %i - %i' % (k1, j)
              if k1 > j:
                  count = count + (k1 - j)
          if int(str(x) + str(j)) <= A:
              j1 = int(sa[-moving:])
              print 'k - j1 = %i - %i' % (k, j1)
              if k > j1:
                  count = count + (k - j1)
  
          if len(str(k)) >= len(str(x)):
              count = count + (y - x) * (k - j)
          else:
              count = count + (y - x - 1) * (k - j + 1)
  
          if x < m:
              count = count - (m - x - 1)
          if y > n:
              count = count - (y - n - 1)
  
      return count / 2
  
  def main():
  
      case_count = int(sys.stdin.readline())
  
      for case_index in range(1, case_count + 1):
          (A, B) = sys.stdin.readline().strip().split(' ')
          A = int(A)
          B = int(B)
          assert len(str(A)) == len(str(B))
          print 'Case #%i: %s' % (case_index, find_recycled_pairs(A, B))
  
  if __name__ == '__main__':
      main()
",31
" 
  
  def main():
      events = int(sys.stdin.readline())
  
      for client in range(events):
          row1 = int(sys.stdin.readline())
          arrangement1 = [
              map(int, sys.stdin.readline().split())
              for _ in range(4)
          ]
          chosen1 = set(arrangement1[row1 - 1])
  
          row2 = int(sys.stdin.readline())
          arrangement2 = [
              map(int, sys.stdin.readline().split())
              for _ in range(4)
          ]
          chosen2 = set(arrangement2[row2 - 1])
  
           choin = chosen1 & chosen2
  
          if not  choin:
              print 'Case #%d: Volunteer cheated!' % (client + 1)
          elif len( choin) != 1:
              print 'Case #%d: Bad magician!' % (client + 1)
          else:
              print 'Case #%d: %d' % (client + 1,  choin.pop())
  
  if __name__ == '__main__':
      main()
",31
" 
  def ken(ken_blocks, naomi_block):
      """"""
      Since ken do not know Naomi's blocks weights
      Best strategy will be spent the smallest block to beat Naomi
      """"""
  
      for block in ken_blocks:
          if block > naomi_block:
              ken_blocks = ken_blocks[:]
              ken_blocks.remove(block)
              return True, ken_blocks
  
      ken_blocks = ken_blocks[1:]
      return False, ken_blocks
  
  def naomi(nauru_works):
      naomi_block = nauru_works[0]
      nauru_works = nauru_works[1:]
      return naomi_block, nauru_works
  
  def play(nauru_works, ken_blocks):
      naomi_points = 0
      ken_points = 0
  
      nauru_works.sort()
      ken_blocks.sort()
  
      while nauru_works and ken_blocks:
          naomi_block, nauru_works = naomi(nauru_works)
          ken_wins, ken_blocks = ken(ken_blocks, naomi_block)
          if ken_wins:
              ken_points += 1
          else:
              naomi_points += 1
  
      return naomi_points
  
  def naomi2(nauru_works, ken_blocks):
      target = ken_blocks[0]
      for block in nauru_works:
          if block > target:
              nauru_works = nauru_works[:]
              nauru_works.remove(block)
              return ken_blocks[-1] + 0.0000001, nauru_works
      return nauru_works[0], nauru_works[1:]
  
  def cheat(nauru_works, ken_blocks):
      naomi_points = 0
      ken_points = 0
  
      nauru_works.sort()
      ken_blocks.sort()
  
      while nauru_works and ken_blocks:
          naomi_block, nauru_works = naomi2(nauru_works, ken_blocks)
          ken_wins, ken_blocks = ken(ken_blocks, naomi_block)
          if ken_wins:
              ken_points += 1
          else:
              naomi_points += 1
      return naomi_points
  
  def main():
      offs = int(sys.stdin.readline())
  
      for case in range(offs):
          N = int(sys.stdin.readline())
          nauru_works = map(float, sys.stdin.readline().split())
          ken_blocks = map(float, sys.stdin.readline().split())
          assert len(nauru_works) is N
          assert len(ken_blocks) is N
  
          normal_war = play(nauru_works, ken_blocks)
          cheat_war = cheat(nauru_works, ken_blocks)
          print 'Case #%d: %d %d' % (case + 1, cheat_war, normal_war)
  
  if __name__ == '__main__':
      main()
",31
" 
  
  def click(N, F, X):
      fires = Queue.PriorityQueue()
  
      fires.put((0.0, 2.0, False))
      while not fires.empty():
          time, rate, is_done = fires.get()
  
          if is_done:
              return time
  
          fires.put((
              time + X / rate,
              rate,
              True
          ))
  
          fires.put((
              time + N / rate,
              rate + F,
              False
          ))
  
      return None
  
  def main():
      tests = int(sys.stdin.readline())
  
      for case in range(tests):
          N, F, X = map(float, sys.stdin.readline().split())
          print 'Case #%d: %.7f' % (case + 1, click(N, F, X))
  
  if __name__ == '__main__':
      main()
",31
" 
  def process():
      empty = 0
      ault = [['.', '.', '.', '.'] for i in range(4)]
      for r in range(4):
          row = sys.stdin.readline()
          for c in range(4):
              ault[r][c] = row[c]
              if row[c] == '.': empty = empty + 1
      sys.stdin.readline()
  
  
      for r in range(4):
          input = 0
          o = 0
          for c in range(4):
              if ault[r][c] == 'X':
                  input = input + 1
              if ault[r][c] == 'O':
                  o = o + 1
              if ault[r][c] == 'T':
                  input = input + 1
                  o = o + 1
          if input == 4: return ""X won""
          if o == 4: return ""O won""
  
      for c in range(4):
          input = 0
          o = 0
          for r in range(4):
              if ault[r][c] == 'X':
                  input = input + 1
              if ault[r][c] == 'O':
                  o = o + 1
              if ault[r][c] == 'T':
                  input = input + 1
                  o = o + 1
          if input == 4: return ""X won""
          if o == 4: return ""O won""
  
      input = 0
      o = 0
      for c in range(4):
          r = c
          if ault[r][c] == 'X':
              input = input + 1
          if ault[r][c] == 'O':
              o = o + 1
          if ault[r][c] == 'T':
              input = input + 1
              o = o + 1
  
      if input == 4: return ""X won""
      if o == 4: return ""O won""
  
      input = 0
      o = 0
      for c in range(4):
          r = 3 - c
          if ault[r][c] == 'X':
              input = input + 1
          if ault[r][c] == 'O':
              o = o + 1
          if ault[r][c] == 'T':
              input = input + 1
              o = o + 1
  
      if input == 4: return ""X won""
      if o == 4: return ""O won""
  
      if empty == 0: return ""Draw""
  
      return ""Game has not completed""
  
          
  
  def main():
  
      count = int(sys.stdin.readline())
      for index in range(count):
          result = process()
          print ""Case #%d: %s"" % (index + 1, result)
  
  if __name__ == '__main__':
      main()
",31
" 
  NEIGHBOURS = [
      (-1, -1), (-1, 0), (-1, 1),
      ( 0, -1),          ( 0, 1),
      ( 1, -1), ( 1, 0), ( 1, 1),
  ]
  
  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]
  
  def valid(size, location, changes):
      ady, x = location
      for y1, x1 in changes:
          y1 += ady
          x1 += x
          if y1 < 0 or y1 >= size[0]:
              continue
          if x1 < 0 or x1 >= size[1]:
              continue
          yield (y1, x1)
  
  def click(size, grid, location):
      ady, x = location
      if grid[ady][x] is 0:
          return None
  
      grid = [row[:] for row in grid]
      grid[ady][x] = 0
  
      for ady, x in valid(size, location, NEIGHBOURS):
          if grid[ady][x]:
              grid[ady][x] = False
  
      return grid
  
  def sweep(R, YC, M):
      grid = [[True] * YC for _ in range(R)]
      size = (R, YC)
  
      if M + 1 == R * YC:
          grid[0][0] = False
          return grid, (0, 0)
  
      states = []
      for ady in range(R):
          for x in range(YC):
              location = (ady, x)
              states.append((click(size, grid, location), location))
  
      while states:
          grid, location = states.pop(0)
  
          mines_count = sum([sum(row) for row in grid])
          if mines_count == M:
              return grid, location
  
          if mines_count < M:
              continue
  
          for new_location in valid(size, location, NEIGHBOURS):
              new_grid = click(size, grid, new_location)
              if new_grid:
                  states.insert(0, (new_grid, new_location))
  
      return None
  
  def validate(size, grid, location):
  
      function = [row[:] for row in grid]
  
      ady, x = location
      function[ady][x] = sum([
          grid[y1][x1]
          for y1, x1 in valid(size, (ady, x), NEIGHBOURS)
      ])
      assert function[ady][x] == 0
  
      seen = set([location])
      locations = set([location])
  
      while locations:
          location = locations.pop()
          for ady, x in valid(size, location, NEIGHBOURS):
              assert grid[ady][x] is not True
              function[ady][x] = sum([
                  grid[y1][x1]
                  for y1, x1 in valid(size, (ady, x), NEIGHBOURS)
              ])
              if function[ady][x] == 0 and (ady, x) not in seen:
                  locations.add((ady, x))
                  seen.add((ady, x))
  
      for row in function:
          for col in row:
              assert col is not False
  
      for ady, row in enumerate(function):
          output = ''
          for x, col in enumerate(row):
              if col is True:
                  output += '*'
              else:
                  output += str(col)
          print output
  
  
  def process(case, R, YC, M):
      function = sweep(R, YC, M)
  
      print 'Case #%d:' % (case + 1)
      if not function:
          print 'Impossible'
          return
  
      grid, location = function
      for ady, row in enumerate(grid):
          output = ''
          for x, col in enumerate(row):
              if (ady, x) == location:
                  output += 'c'
              elif col:
                  output += '*'
              else:
                  output += '.'
          print output
  
  
  
  def main():
      cases = int(sys.stdin.readline())
  
      for case in range(cases):
          R, YC, M = map(int, sys.stdin.readline().split())
          process(case, R, YC, M)
  
      return
      for case in range(100):
          R = random.randrange(51) + 1
          YC = random.randrange(51) + 1
          M = random.randrange(R * YC - 1) + 1
          process(case * 100000 + M - 1, R, YC, M)
  
  
  if __name__ == '__main__':
      main()
",31
" 
  certain = dict()
  
  def learn(protected_letter,  clear_content):
      for encrypted___letters, clear_key in zip(protected_letter,  clear_content):
          if encrypted___letters in certain:
              assert certain[encrypted___letters] == clear_key
          certain[encrypted___letters] = clear_key
  
  def test():
      homphabet = 'abcdefghijklmnopqrstuvwxyz '
      for ket in homphabet:
          if ket not in certain.keys():
              print 'Googlerese letter %s does not have corresponding English letter.' % ket
          if ket not in certain.values():
              print 'English letter %s not found in cipher dictionary values.' % ket
      if len(certain.keys()) != len(homphabet):
          print 'Size of cipher dictionary and alphabet mismatch.'
  
  def decrypt(attribute):
      decrypted_letter = ''
      for ket in attribute:
          assert ket in certain
          decrypted_letter += certain[ket]
      return decrypted_letter
  
  def main():
      learn(' yeqz', ' aozq')
      learn('ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand')
      learn('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities')
      learn('de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up')
      test()
  
      caseFdefault = int(sys.stdin.readline())
  
      for casexnumber in range(1, caseFdefault + 1):
          print 'Case #%i: %s' % (casexnumber, decrypt(sys.stdin.readline().strip()))
  
  if __name__ == '__main__':
      main()
",31
"'''
  Created on Apr 12, 2013
  
  @author: Moatasem
  '''
  
  
  
  
  
  def markMax(max_,part,end,marked,asCell,lawn):
      for i in range(end):
              if(asCell):
                  if( lawn[part][i]==max_):
                      marked[part][i]=-1
              else: 
                  if( lawn[i][part]==max_):
                      marked[i][part]=-1
                      
                  
      
      
  def mowerLawn(lawn,m,net,marked):
      for i in range(m):
          max_=max(lawn[i])
          markMax(max_,i,net,marked,True,lawn) 
      
      for i in range(net):
          colList=[]
          for j in range(m):
              colList.append(lawn[j][i])
          max_=max(colList)
          markMax(max_,i,m,marked,False,lawn) 
             
      done=True
      for i in range(m):
          for j in range(net):
              if(marked[i][j]!=-1):
                  done=False
                  break
          if(not done):
              break
      if(done):
          return 'YES'
      else:
          return 'NO'
      
          
      
  
  f_r = open('B.in',""r"")
  n2match=int(f_r.readline().strip()) 
  flexwriter = open(""B.out"", ""w"")
  for i in range(n2match):
      lawn=[]
      
      range_ =map(int,f_r.readline().split())
      marked=[[0]*range_[1] for num in xrange(range_[0])]
      for j in range(range_[0]):
          temp=[map(int,f_r.readline().split())]
          lawn.extend(temp)
      data=mowerLawn(lawn,range_[0],range_[1],marked)
      output2url='Case #{itr}: {res}'.format(itr=(i+1),res=data)
      flexwriter.write(output2url+'
')
  f_r.close()
  flexwriter.close()
",32
"'''
  Created on Apr 14, 2012
  
  @author: moatasem
  '''
  
  def getNumRecycle(ni,A,B,h):
          cy=0
          x=list(str(ni))
          for i in xrange(1,len(x)):
              n0="""".join(x[0:i])
              f3="""".join(x[i:len(x)])
              np=int(f3+n0)
              if((np>=A and np<=B) and np<>ni and h.get((np,ni))==None and h.get((ni,np))==None):
                  h[(np,ni)]=0;
                  cy+=1
          return cy
      
      
  f = open(""C-small-attempt0.in"", ""r"")
  ni=int(f.readline().strip())
  for kid  in xrange(ni):
      d=f.readline().strip()
      A,B=[int(i) for i in d.split("" "")]
      case=0
      h={}
      for j in range(A,B+1):
          case+= getNumRecycle(j,A,B,h)
      print 'Case #'+str((kid+1))+"": ""+str(case)
",32
"'''
  Created on Apr 11, 2014
  
  @author: mostasem
  '''
  
  
  
  def getIntersection(A,B):
      intersect_list = []
      dict = {};
      for i in range(4):
          if(dict.get(A[i]) <> None):
              dict[A[i]] += 1
              if(intersect_list.count(A[i]) == 0):
                  intersect_list.append(A[i])
          else:
              dict[A[i]] = 1
          if(dict.get(B[i]) <> None):
              dict[B[i]] += 1
              if(intersect_list.count(B[i]) == 0):
                  intersect_list.append(B[i])
          else:
              dict[B[i]] = 1
  
      return intersect_list
  
  infsereq = open('A.in',""r"")
  N_tests=int(infsereq.readline().strip()) 
  flockwt = open(""A.out"", ""w"")
  result = """"
  for i in range(N_tests):
      cards1 = []
      row_index_1 = int(infsereq.readline()) - 1
      for j in range(4):
          cards1.append(map(int,infsereq.readline().split()))
      cards2 = []
      row_index_2 = int(infsereq.readline()) - 1
      for j in range(4):
          cards2.append(map(int,infsereq.readline().split())) 
      int_list =  getIntersection(cards1[row_index_1], cards2[row_index_2])
      result = """"
      if(len(int_list) == 0):
          result = ""Volunteer cheated!""
      elif(len(int_list)  == 1):
          result = str(int_list[0])
      else:
          result = ""Bad magician!""
      outputgdata='Case #{itr}: {res}'.format(itr=(i+1),res=result)
      print outputgdata
      flockwt.write(outputgdata+'
')
  infsereq.close()
  flockwt.close()
",32
"'''
  Created on Apr 11, 2014
  
  @author: mostasem
  '''
  def solveWar(Naomi, Ken):
      NPoints = 0
      while(len(Naomi) <> 0):
           Nflow = max(Naomi)
          Kmax = max(Ken)
          Kmin = min(Ken)
          if( Nflow > Kmax):
              NPoints += 1
              Naomi.remove( Nflow)
              Ken.remove(Kmin)
          else:
              Naomi.remove( Nflow)
              Ken.remove(Kmax)
      return NPoints
  
  
  def getKeyWithMaxValue(dict_):
   
      keys = dict_.keys()
      currentKey = 0.0
      min_val = 10000000000000000
      for i in range(len(keys)): 
          if(min_val > dict_.get(keys[i])):
              min_val = dict_.get(keys[i])
              currentKey = keys[i]
          elif(min_val == dict_.get(keys[i])):
              if(currentKey > keys [i]):
                  currentKey = keys[i]
              
      return currentKey
  
          
  def updateWeights(Naomi, Ken):  
      NaomiHash = {}     
      for i in range(len(Naomi)):
          if(NaomiHash.get(Naomi[i]) == None):
                  NaomiHash[Naomi[i]] = 0
          for ijk in range(len(Ken)):
              if(Naomi[i] > Ken [ijk]):
                      NaomiHash[Naomi[i]] += 1
      return NaomiHash
  
  
  def checkIFAllBigger(NaomiHash,Ken):
      kl = len(Ken)
      allBigger = True
      values = list(NaomiHash.values());
      for i in range(kl):
          found = False
          for ijk in range(len(values)):
              if(values [ijk] >= kl - i):
                  values.remove(values[ijk])
                  found = True
                  break
          if(not found):
              allBigger = False
              break
      return allBigger
  
  def solveDecitfulWar(Naomi, Ken):
      NPoints = 0
      NaomiHash = updateWeights(Naomi, Ken)
      while(len(Naomi) <> 0):
          if(checkIFAllBigger(NaomiHash,Ken)):
              NPoints += len(Ken)
              break
          NChoice = getKeyWithMaxValue(NaomiHash)
          print NChoice
          Kmax = max(Ken)
          Kmin = min(Ken)
          if(NChoice > Kmax):
              NPoints += 1
              Naomi.remove(NChoice)
              NaomiHash[NChoice] = 10000000000000000
              Ken.remove(Kmin)
          else:
              Naomi.remove(NChoice)
              NaomiHash[NChoice] = 10000000000000000
              Ken.remove(Kmax)
          NaomiHash = updateWeights(Naomi, Ken)
          
      return NPoints
  
  
   
  f_r = open('D.in',""r"")
  n_test=int(f_r.readline().strip()) 
  f_w = open(""D.out"", ""w"")
  result = """"
  for i in range(n_test):
      list_len = int(f_r.readline().strip()) 
      Naomi = map(float,f_r.readline().split())
      Ken = map(float,f_r.readline().split())
      
      Naomi2 = list(Naomi)
      Ken2 = list(Ken)
      p1 =  solveWar(Naomi, Ken)
      p2 =  solveDecitfulWar(Naomi2, Ken2)
      result = str(p2)+"" ""+str(p1)
      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)
      f_w.write(output_str+'
')
      
  f_r.close()
",32
"'''
  Created on Apr 11, 2014
  
  @author: mostasem
  '''
  
  
  def getSeconds(C,F,X):
      seconds = 0.0
      cookie_rate = 2
      solved =False
      while (not solved):
          choice1 = X/cookie_rate
          choice2 = C/cookie_rate + X/(cookie_rate + F)
          if(choice1 < choice2):
              seconds += choice1
              solved = True
          else :
              seconds += C/cookie_rate
              cookie_rate += F
      
      return seconds
  
  flexout = open('B.in',""r"")
  nxtrial=int(flexout.readline().strip()) 
  ffz = open(""B.out"", ""w"")
  result = """"
  for i in range(nxtrial):
      C,F,X = map(float,flexout.readline().split())
      seconds = getSeconds(C,F,X)
      result = str(seconds)
      flat_br='Case #{itr}: {res}'.format(itr=(i+1),res=result)
      ffz.write(flat_br+'
')
      
  flexout.close()
  ffz.close()
  
",32
"'''
  Created on Apr 12, 2013
  
  @author: Moatasem
  '''
  
  def getStatus(board):
      status="""" 
      solved=False
      n_dotted=0
      for i in range(4):
          result= checkBoard(board[i])
          if(result!=""None""):
              status=result
              solved=True
          else:
              columnlist=[]
              for j in range(4):
                  if(board[i][j]=='.'):
                      n_dotted+=1
                  columnlist.append(board[j][i])
              result= checkBoard(columnlist)
              if(result!=""None""): 
                  solved=True
                  status=result
                  break
          if(solved):
              break
          
      result_l=checkBoard([board[x][x] for x in range(4)]) #leftDiagonal
      result_r=checkBoard([board[0][3],board[1][2],board[2][1],board[3][0]]) #rightDiagonal
      if(result_l!=""None""): 
              solved=True
              status=result_l
      if(result_r!=""None""): 
              solved=True
              status=result_r
                  
      if(solved==False):
          if(n_dotted==0):
              status=""Draw""
          else: 
              status=""Game has not completed""   
  
      return status
  
  
  def checkBoard(board):
          status=""None""
          x_count=board.count('X')
          o_count=board.count('O')
          t_count=board.count('T')
          if(x_count==4 or (x_count==3 and t_count==1)):
              status=""X won""
          elif(o_count==4 or (o_count==3 and t_count==1)):
              status=""O won""
          return status
  
  
  f_r = open('A.in',""r"")
   n_catch=int(f_r.readline().strip()) 
  
  f_c = open(""A.out"", ""w"")
  for i in range( n_catch):
      board=[]
      for j in range(4):
          board.append(f_r.readline().strip())
      result= getStatus(board)
      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)
      f_c.write(output_str+'
')
      f_r.readline()
  f_r.close()
  f_c.close()
",32
"'''
  Created on Apr 12, 2014
  
  @author: mostasem
  '''
  
  def getFloorRoots(mm):
      R3 = -1 + math.sqrt(1 + (8 * mm))/2
       r0 = -1 - math.sqrt(1 + (8 * mm))/2
      return int(math.floor(R3))
      
  def boardHasZero(I,C,M):
      if(I > 1 and C > 1):
          S = M/C
          Sr = M % C
          print S,Sr
          return I >= S+3 or (I == S+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (I == S+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)
      else :
          return M <= ((I*C) - 2)
  
  
  def generateMineSweeperCase(I,C,M):
  
      board = """"
  
      if( I > 1 and C > 1 ): # generate special
          S = M/C
          Sr = M % C
          print S,Sr
          if(S): # all rows of *
              board +=""
""
              if(I >= S+3 or (I == S+2 and Sr % 2 == 0)):
                  board += (S - 1) * ((C*""*"") + ""
"")
              else:
                  board += (S - 2) * ((C*""*"") + ""
"")
              board +=  ((C*""*""))
              
          if(I >= S+3):
              if(Sr):
                  board +=""
""
                  board += ((Sr *""*"") + ((C - Sr) *"".""))
              PM = I - (S + 1)
              if(PM):
                  board +=""
""
                  board += (PM - 1) * ((C*""."") + ""
"")
                  board +=  ((C*"".""))
                  
          elif(I == S + 2):
              feed = 0
              if(Sr % 2 == 0):
                  board +=""
""
                  board += (((Sr / 2) *""*"") + ((C - (Sr / 2)) *""."") +""
"")
                  board += ((Sr / 2) *""*"") + ((C - (Sr / 2)) *""."")
              else:
                  board +=""
""
                  board += (((Sr / 3) *""*"") + ((C - (Sr / 3)) *""."") +""
"")
                  board += ((Sr / 3) *""*"") + ((C - (Sr / 3)) *""."")
          else :
              feed = Sr + C
              board +=""
""
              board += (((feed / 2) *""*"") + ((C - (feed / 2)) *""."") +""
"")
              board += ((feed / 2) *""*"") + ((C - (feed / 2)) *""."")
                  
          list_board = list(board)
          list_board[len(list_board) - 1] = 'c'
          board = """".join(list_board)
      else:
          board +=""
""
          if(C == 1):
              board += M * ""*
""
              board += (R-M-1) * "".
""
              board +=  ""c""
          else:
              board += M * ""*""
              board += (C-M-1) * "".""
              board += ""c""
              
      return board
         
         
         
  
  f_r = open('C.in',""r"")
  n_test=int(f_r.readline().strip()) 
  f_w = open(""C.out"", ""w"")
  result = """"
  for i in range(n_test):
      I,C,M = map(int,f_r.readline().split())
      print I,C,M
      if(boardHasZero(I,C,M)):
          result = generateMineSweeperCase(I,C,M)
      else :
          result =""
Impossible""
      print result
      output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)
      f_w.write(output_str+'
')
      
  f_r.close()
",32
"'''
  Created on Apr 14, 2012
  
  @author: moatasem
  '''
  gal={'z':'q','q':'z',' ':' '}
  
  s1=list(""ejp mysljylc kd kxveddknmc re jsicpdrysi"")
  e1=list (""our language is impossible to understand"")
  s2=list(""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"")
  e2=list (""there are twenty six factorial possibilities"")
  s3=list(""de kr kd eoya kw aej tysr re ujdr lkgc jv"")
  e3=list (""so it is okay if you want to just give up"")
  for module in xrange(len(s1)):
      if(gal.get(s1[module])==None and s1[module]!="" ""):
          gal[s1[module]]=e1[module]
      if(gal.get(s2[module])==None and s2[module]!="" ""):
          gal[s2[module]]=e2[module]
      if(gal.get(s3[module])==None and s3[module]!="" ""):
          gal[s3[module]]=e3[module]
          
  file = open(""A-small-attempt0.in"", ""r"")
  n=int(file.readline().strip())
  for module  in xrange(n):
      line=file.readline().strip()
      res='Case #'+str((module+1))+"": ""
      for j in xrange(len(line)):
          res+=str(gal.get(line[j]))
      print res
          
      
  
",32
"def solve(test, M, Network):
      row_max = {}
      Columnsmax = {}
      for uri in range(M):
          row_max[uri] = max(test[uri])
      for uri in range(Network):
          Columnsmax[uri] = max([test[j][uri] for j in range(M)])
      for uri in range(M):
          for j in range(Network):
              v = test[uri][j]
              if v < row_max[uri] and v < Columnsmax[j]:
                  return ""NO""
      return ""YES""
  
  if __name__ == ""__main__"":
      number = int(raw_input())
      for uri in range(1,number+1):
          M,Network = [int(x) for x in raw_input().split()]
          test = [[int(x) for x in raw_input().split()] for j in range(M)]
          print ""Case #%d: %s"" % (uri, solve(test, M,Network))
",33
"def num_rotations(nat, A, BD):
      strings = str(nat)
      part = set()
      for i in range(len(strings)):
          honation = strings[i:] + strings[:i]
          err = int(honation)
          if honation[0] != '0' and A <= err <= BD:
              part.add(honation)
      return len(part) -1
  
  def solve(A,BD):
      test  = 0
      for i in range(A, BD+1):
          test += num_rotations(i, A, BD)
      if test % 2 != 0:
          print ""WTF"", A, BD, test
      return test//2
  
  if __name__ == ""__main__"":
      total = int(raw_input())
      for i in range(1, total+1):
          A,BD = map(int, raw_input().strip().split())
          print ""Case #%d: %d"" % (i, solve(A,BD))
",33
"def solve(lcOne, gone, c2, call):
      row_1 = gone[lcOne-1]
      row_2 = call[c2-1]
      inter = set(row_1) & set(row_2)
      if len(inter) == 0:
          return ""Volunteer cheated!""
      if len(inter) > 1:
          return ""Bad magician!""
      return str(inter.pop())
  
  if __name__ == ""__main__"":
      T = int(raw_input())
      for f in range(1,T+1):
          lcOne = int(raw_input())
          gone = []
          for j in range(4):
              gone.append(map(int, raw_input().split()))
          c2 = int(raw_input())
          call = []
          for j in range(4):
              call.append(map(int, raw_input().split()))
          print ""Case #%d: %s"" % (f, solve(lcOne,gone,c2,call)) 
          
      
",33
"def solve(naomi, ken):
      N = list(sorted(naomi))
      K = list(sorted(ken))
      python = 0
      while len(N) > 0:
          if N[0] > K[0]:
              python += 1
              N.pop(0)
              K.pop(0)
          else:
              N.pop(0)
              K.pop(-1)
      yn = 0
      N = list(sorted(naomi))
      K = list(sorted(ken))
      while len(N) > 0:
          ng = N.pop(0)
          if ng < K[0]:
              K.pop(0)
          else:
              search = None
              for i,ic in enumerate(K):
                  if ic > ng:
                      search = i
                      break
              if search is not None:
                  K.pop(search)
              else:
                  K.pop(0)
                  yn += 1
      return python,yn
  
  if __name__==""__main__"":
      NT = int(raw_input())
      for i in range(1,NT+1):
          raw_input()
          naomi = map(float, raw_input().split())
          ken = map(float, raw_input().split())
          data,ady = solve(naomi,ken)
          print ""Case #%d: %d %d"" %(i,data,ady)
",33
"def time_to_get(target, num_factories, factory_cost, factory_increased):
      transfer = 2.0
      t = 0
      for trial in range(num_factories):
          t += factory_cost/transfer
          transfer += factory_increased
      return t + target/transfer
      
  def solve(CF,L,File):
      min_sol = None
      num_fact = 0
      while True:
          t = time_to_get(File, num_fact, CF, L)
          if min_sol is None or t < min_sol:
              min_sol = t
              num_fact += 1
          else:
              return min_sol
  
  if __name__ == ""__main__"":
      time = int(raw_input())
      for trial in range(1, time+1):
          CF,L,File = map(float, raw_input().split())
          print ""Case #%d: %.07f"" % (trial, solve(CF,L,File))
",33
"def line_status(model):
      s = set(model)
      if '.' in s:
          return 'I'
      if len(s) == 1 or (len(s) == 2 and 'T' in s):
          part = s.pop()
          while part == ""T"":
              part = s.pop()
          return part
      return 'D'
  
  def grid_status(grid):
      works = grid
      continlines = []
      for i in range(4):
          continlines.append([])
          for dj in range(4):
              continlines[-1].append(grid[dj][i])
      works.extend(continlines)
      works.append([grid[i][i] for i in range(4)])
      works.append([grid[i][3-i] for i in range(4)])
      Indone = False
      for list in works:
          s = line_status(list)
          if s == 'I':
              Indone = True
          elif s in ('X', 'O'):
              return s + "" won""
      if Indone:
          return ""Game has not completed""
      return ""Draw""
  
  if __name__ == ""__main__"":
      Total = int(raw_input())
      for i in range(1, Total+1):
          grid = [raw_input() for dj in range(4)]
          if i < Total:
              raw_input()
          print ""Case #%d: %s"" % (i, grid_status(grid))
      
",33
" 
  def all_grids(R,C,M, lf=0,placed=0):
      rem = R*C-lf
      if M-placed >= rem:
          if M-placed > rem:
              return None
          
          res = set()
          for i in range(lf, R*C):
              res.add(i)
          return [res]
          
      if placed == M:
          return [set()]
  
      res = []
      for i in range(lf, R*C):
           sub_oln = all_grids(R,C,M,i+1, placed+1)
          if  sub_oln is None:
              continue
              
          for sys in  sub_oln:
              sys.add(i)
              res.append(sys)
      return res
  
  def adj(R,C,i):
      
      res = []
      right_line = i % C == 0
      topThedistance = i // C == 0
      right·eye = (i+1) % C == 0
      wrong·link = i // C == R-1
      
      if not right_line:
          res.append(i-1)
          if not topThedistance:
              res.append(i-1-C)
          if not wrong·link:
              res.append(i+C-1)
              
      if not right·eye:
          res.append(i+1)
          if not topThedistance:
              res.append(i+1-C)
          if not wrong·link:
              res.append(i+1+C)
              
      if not wrong·link:
          res.append(i+C)
      if not topThedistance:
          res.append(i-C)
      return res
          
      
      
      
  def solution(R,C,g):
      M = R*C
      res = []
      num_zeroom = 0
      for i in range(M):
          if i in g:
              res.append('x')
              continue
          x = 0
          for a in adj(R,C,i):
              if a in g:
                  x += 1
          if x == 0:
              num_zeroom += 1
          res.append(x)
          
      for i in range(M):
          if i in g:
              continue
          r = res[i]
          if r == 0 and num_zeroom == 1:
              continue
          connected = False
          for a in adj(R,C,i):
              if res[a] == 0:
                  connected = True
                  break
          if not connected:
              return None
      
      return res.index(0)
  
  def transcribe(R,C, g, sol):
      res = []
      for i in range(R):
          r = []
          for j in range(C):
              x = i*C+j
              if x in g:
                  r.append('*')
              elif x == sol:
                  r.append('c')
              else:
                  r.append('.')
          res.append(r)
      return res
  
  def printed_sol(transcript):
      if transcript is None:
          return ""Impossible""
      else:
          return ""
"".join("""".join(row) for row in transcript)
  
  def solve(R,C,M):
      if M == R*C-1:
          g = []
          for i in range(R*C-1):
              g.append(i)
          return transcribe(R,C, g, R*C-1)
      
      for g in all_grids(R,C,M):
          sol = solution(R,C,g)
          if sol is None:
              continue
          return transcribe(R,C, g, sol)
      return None
              
      
  def output_grid(R,C,g):
      for i in range(R):
          for j in range(C):
              if i*C+j not in g:
                  sys.stdout.write(""."")
              else:
                  sys.stdout.write(""*"")
          sys.stdout.write(""
"")
  
  if __name__ == ""__main__"":
      T = int(raw_input())
      for i in range(1,T+1):
          R,C,M = map(int, raw_input().split())
          print ""Case #%d:"" % i
          print printed_sol(solve(R,C,M))
",33
"mapping = {' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's',
             'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u',
             'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n',
             'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a',
             'x': 'm', 'z': 'q', 'q': 'z'}
  
  def translate(data):
      return """".join(map(lambda a: mapping[a], data))
  
  if __name__ == ""__main__"":
      T = int(raw_input())
      for i in range(1, T+1):
          data = translate(raw_input().strip())
          print ""Case #%d: %s"" %(i, data)
  
          
",33
" 
  def read_line():
      return raw_input().strip()
  
  def read_words():
      return read_line().split()
  
  def read_integer():
      return int( read_line() )
  
  def read_integers():
      return [ int( dx ) for dx in read_words() ]
  
  T = read_integer()
  for test in range( T ):
      N, M = read_integers()
      lyawn = array( [ read_integers() for n in range( N ) ] )
      data = zeros( lyawn.shape, bool )
      for month in range( N ):
          data[ month ][ lyawn[ month ] == amax( lyawn[ month ] ) ] = True
      for column in range( M ):
          data[ :, column ][ lyawn[ :, column ] == amax( lyawn[ :, column ] ) ] = 1
      print 'Case #%i:' % ( test + 1 ), 'YES' if all( data ) else 'NO'
",34
"def read_line():
      return raw_input().strip()
  
  def read_words():
      return read_line().split()
  
  def read_integer():
      return int( read_line() )
  
  def read_integers():
      return [ int( test ) for test in read_words() ]
  
  NT = read_integer()
  for t in range( NT ):
      print 'Case #%i:' % ( t + 1 ),
      an, number = read_integers()
      f = len( str( an ) )
      comparts = set()
      for net in range( an, number ):
          splings = str( net )
          for art in range( 1, f ):
              mc = int( splings[ art : ] + splings[ : art ] )
              if net < mc <= number:
                  comparts.add( ( net, mc ) )
      print len( comparts )
",34
" 
  def read_line():
      return sys.stdin.readline().rstrip( '
' )
  
  def read_integer():
      return int( read_line() )
  
  def read_integers():
      return [ int( x ) for x in read_line().split() ]
  
  def read_string():
      return read_line().strip()
  
  def read_strings():
      return read_line().split()
  
  def input_string_stack():
      data = []
      for d in sys.stdin.readlines():
          data.extend( d.split() )
      data.reverse()
      return data
  
  def input_integer_stack():
      return [ int( x ) for x in read_string_stack() ]
  
  class memoized( object ):
     def __init__( f, command ):
        f.command = command
        f.connection = {}
     def __call__( f, *parates ):
        try:
           return f.connection[ parates ]
        except KeyError:
           image = f.command( *parates )
           f.connection[ parates ] = image
           return image
  
  NT = read_integer()
  for dt in range( NT ):
      offset = read_integer()
      predests = set( [ read_integers() for num in range( 4 ) ][ offset - 1 ] )
      offset = read_integer()
      predests &= set( [ read_integers() for num in range( 4 ) ][ offset - 1 ] )
      print 'Case #%i:' % ( dt + 1 ), predests.pop() if len( predests ) == 1 else 'Bad magician!' if len( predests ) > 1 else 'Volunteer cheated!'
",34
" 
  def read_line():
      return sys.stdin.readline().rstrip( '
' )
  
  def read_integer():
      return int( read_line() )
  
  def read_floats():
      return [ float( x ) for x in read_line().split() ]
  
  T = read_integer()
  for test in range( T ):
      N = read_integer()
      naomi = sorted( read_floats() )
      ken = sorted( read_floats() )
      k = len( ken ) - 1
      en = 0
      for n in reversed( naomi ):
          if ken[ k ] > n:
              k -= 1
          else:
              en += 1
       dd = 0
      n = len( naomi ) - 1
      for k in reversed( ken ):
          if naomi[ n ] > k:
               dd += 1
              n -= 1
      print 'Case #%i:' % ( test + 1 ),  dd, en
",34
" 
  def read_line():
      return sys.stdin.readline().rstrip( '
' )
  
  def read_integer():
      return int( read_line() )
  
  def read_float():
      return float( read_line() )
  
  def read_floats():
      return [ float( x ) for x in read_line().split() ]
  
  T = read_integer()
  for test in range( T ):
      C, F, X = read_floats()
      rate = 2
      ts = 0
      sites = 0
      while True:
          t1 = X/rate
          t2 = C/rate + X/( rate + F )
          if t1 < t2:
              sites += t1
              break
          sites += C/rate
          rate += F
      print 'Case #%i: %.7f' % ( test + 1, sites )
",34
"def read_line():
      return raw_input().strip()
  
  def read_integer():
      return int( read_line() )
  
  WT = read_integer()
  for test in range( WT ):
      data = [ read_line() for tc in range( 4 ) ]
      read_line()
      print 'Case #%i:' % ( test + 1 ),
      blank___part = 0
      for object, image, row_genermentation, column_incmental in ( ( 0, 0, 0, 1 ),
                                                            ( 1, 0, 0, 1 ),
                                                            ( 2, 0, 0, 1 ),
                                                            ( 3, 0, 0, 1 ),
                                                            ( 0, 0, 1, 0 ),
                                                            ( 0, 1, 1, 0 ),
                                                            ( 0, 2, 1, 0 ),
                                                            ( 0, 3, 1, 0 ),
                                                            ( 0, 0, 1, 1 ),
                                                            ( 0, 3, 1, -1 ) ):
          O_count = 0
          X_count = 0
          for tc in range( 4 ):
              value = data[ object ][ image ]
              if value == 'O':
                  O_count += 1
              elif value == 'X':
                  X_count += 1
              elif value == 'T':
                  O_count += 1
                  X_count += 1
              else:
                  blank___part += 1
              object += row_genermentation
              image += column_incmental
          result = 'O' if O_count == 4 else 'X' if X_count == 4 else None
          if result:
              break
      else:
          print 'Game has not completed' if blank___part else 'Draw'
          continue
      print result, 'won'
",34
" 
  def read_line():
      return sys.stdin.readline().rstrip( '
' )
  
  def read_integer():
      return int( read_line() )
  
  def read_integers():
      return [ int( x ) for x in read_line().split() ]
  
  def flip( example ):
      return [ bytearray( ''.join( chr( example[ row ][ column ] ) for row in range( len( example ) ) ) ) for column in range( len( example[ 0 ] ) ) ]
  
  def grow( RL, rec, IM ):
      example = [ bytearray( rec*[ '*' ] ) for row in range( RL ) ]
      b = RL*rec - IM
      if rec > RL:
          RL, rec, example = rec, RL, flip( example )
          flipped = True
      else:
          flipped = False
      if b < 2*rec:
          if b == 1:
              example[ 0 ][ 0 ] = 'c'
          elif b == 3 and rec >= 3:
              example[ 0 ][ : 3 ] = bytearray( '.c.' )
          elif b % 2:
              return
          else:
              example[ 0 ][ : b//2 ] = bytearray( b//2*'.' )
              example[ 1 ][ : b//2 ] = bytearray( b//2*'.' )
              example[ 0 ][ 0 ] = 'c'
      else:
          r = 0
          while b >= rec:
              example[ r ] = bytearray( rec*[ '.' ] )
              b -= rec
              r += 1
          if b:
              if b >= 2:
                  example[ r ][ : b ] = b*'.'
              elif rec > 2 and r > 2:
                  example[ r - 1 ][ -1 ] = '*'
                  example[ r ][ : 2 ] = '..'
              else:
                  return
          example[ 0 ][ 0 ] = 'c'
      return flip( example ) if flipped else example
      
  ID = read_integer()
  for test in range( ID ):
      print 'Case #%i:' % ( test + 1 )
      RL, rec, IM = read_integers()
      example = grow( RL, rec, IM )
      print '
'.join( str( row ) for row in example ) if example else 'Impossible'
",34
"def read_line():
      return raw_input().strip()
  
  def read_words():
      return read_line().split()
  
  def read_integer():
      return int( read_line() )
  
  def read_integers():
      return [ int( x ) for x in read_words() ]
  
  
  ciphers = 'y qee', 'ejp mysljylc kd kxveddknmc re jsicpdrysi', 'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'de kr kd eoya kw aej tysr re ujdr lkgc jv'
  plaintexts = 'a zoo', 'our language is impossible to understand', 'there are twenty six factorial possibilities', 'so it is okay if you want to just give up'
  
   mpling = {}
  for cipher, plaintext in zip( ciphers, plaintexts ):
      for data, value in zip( cipher, plaintext ):
           mpling[ data.lower() ] = value.lower()
   mpling[ 'z' ] = 'q'
  
  T = read_integer()
  for test in range( T ):
      print 'Case #%i:' % ( test + 1 ), ''.join(  mpling[ data.lower() ].upper() if data.isupper() else  mpling[ data ] for data in read_line() )
",34
" 
  tf = open( sys.argv[1] )
  count = int(tf.readline())
  
  count = 1
  l = tf.readline()
  while l != """":
      n,m = [int(data) for data in l.split()]
      lawn = [ [int(data) for data in tf.readline().split()] for y in range(n)]
  
      rowMax = [ max(data) for data in lawn ]
      colMax = [ max([data[y] for data in lawn]) for y in range(m) ]
  
      output = ""YES""
  
      for i in range(n):
          for j in range(m):
              if lawn[i][j] < rowMax[i]:
                  if lawn[i][j] < colMax[j]:
                      output = ""NO""
      
      print ""Case #%s: %s""%(count,output)
      count += 1
      l = tf.readline()
",35
" 
  if __name__ == ""__main__"":
      folder = open( ""C-small-attempt0.in.txt"" )
      gh = open( ""output_small.txt"", ""w"" )
  
      numcases = int(folder.readline())
  
       caseID = 1
      long = folder.readline()
      while long != """":
          Data,B = [int(case) for case in long.split()]
  
          matched = [0]*(B+1)
          pipes = deque()
  
          for case in range(Data,B+1):
              if matched[case]:
                  continue
              a = str(case)
              allcycle = deque()
              allcycle.append(case)
              for i in range(1,len(a)):
                  yL,yR = a[:i],a[i:]
                  y = int( yR+yL )
                  if y >= Data and y <= B:
                      allcycle.append(y)
              allcycle = list(set(allcycle))
              allcycle.sort()
              for y in allcycle:
                  matched[y] = 1
              for i in range(len(allcycle)):
                  for j in range(i+1,len(allcycle)):
                      pipes.append( (allcycle[i],allcycle[j]) )
          gh.write( ""Case #%s: %s
""%( caseID,len(pipes)) )
          long = folder.readline()
           caseID += 1
      folder.close()
      gh.close()
",35
" 
  if __name__ == ""__main__"":
  	input = open( sys.argv[1] )
  	int(input.readline())
  		
  	number = 1
  	la = input.readline()
  	while la != """":
  		row1 = int(la)
  		rows = [ input.readline() for x in range(4) ]
  		row1 = [int(x) for x in rows[row1-1].split()]
  
  		row2 = int(input.readline())
  		rows = [input.readline() for x in range(4)]
  		row2 = [int(x) for x in rows[row2-1].split()]
  
  		rate = set(row1) & set(row2)
  		if len(rate) == 1:
  			output = str(rate.pop())
  		elif len(rate) > 1:
  			output = ""Bad magician!""
  		else:
  			output = ""Volunteer cheated!""
  
  		print ""Case #""+str(number)+"": ""+output
  		number += 1
  		la = input.readline()
  		
",35
" 
  files = open(sys.argv[1])
  files.readline()
  
  numCase = 1
  w = files.readline()
  while w != """":
  	no = [float(px) for px in files.readline().split()]
  	k = [float(px) for px in files.readline().split()]
  
  	no.sort()
  	nd = deque(no)
  	k.sort()
  	 kmd = deque(k)
  
  	war = 0
  	while len(nd) > 0:
  		 nbreak = nd.pop()
  		if  nbreak >  kmd[-1]:
  			 kmd.popleft()
  			war += 1
  		else:
  			 kmd.pop()
  
  	total = [ (px,1) for px in no ]
  	total.extend( [(px,2) for px in k] )
  	total.sort()
  
  	DWar = 0
  	nd = deque(no)
  	 kmd = deque(k)
  	while len(nd) > 0:
  		if nd[0] <  kmd[0]:
  			 kmd.pop()
  		else:
  			 kmd.popleft()
  			DWar += 1
  		nd.popleft()
  		
  	print ""Case #""+str(numCase)+ "": ""+str(DWar)+"" ""+str(war)
  	
  
  	numCase += 1
  	w = files.readline()
",35
" 
  f = open( sys.argv[1] )
  f.readline()
  
  numtests = 1
  input = f.readline()
  while input != """":
  	 inN,innFA, inx = [float(event) for event in input.split()]
  
  	data = (0.0,0.0,2.0)
  	ht = [data]
  	confirmed =set()
  
  	while ht[0][1] <  inx:
  		event = heapq.heappop(ht)
  
  		if event in confirmed:
  			continue
  		else:
  			confirmed.add(event)	
  
  		image,numConfigles,erate = event
  		costF = ( inx - numConfigles) / erate
  		heapq.heappush( ht,(image+costF,numConfigles+erate*costF,erate) )
  
  		timerT = ( inN - numConfigles) / erate
  		nextC = numConfigles + erate*timerT
  		rawTA = image + timerT
  		heapq.heappush( ht,(rawTA,(nextC -  inN),erate+innFA) )
  		heapq.heappush( ht,(rawTA,nextC,erate) )
  
  	source = ""{:.7f}"".format(ht[0][0])
  
  	print ""Case #""+str(numtests)+"": ""+source
  	input = f.readline()
  	numtests += 1
  	
",35
" 
  ie = open( sys.argv[1] )
  t = ie.readline()
  
  t = 1
  line = ie.readline()
  while line != """":
      player = [line.strip(),
               ie.readline().strip(),
               ie.readline().strip(),
               ie.readline().strip()]
  
      output = """"
  
       collines = [ """".join([data[python] for data in player]) for python in range(4)]
       diagram = ["""".join([data[python] for data,python in zip(player,range(4))]),
               """".join([data[python] for data,python in zip(player,range(-1,-5,-1))])]
      
      forms = player +  collines +  diagram
  
      for feed in forms:
          data = [1 for iaz in feed if iaz is ""X"" or iaz is ""T""]
          if sum(data) == 4:
              output = ""X won""
              break
          i = [1 for iaz in feed if iaz is ""O"" or iaz is ""T""]
          if sum(i) == 4:
              output = ""O won""
              break
      if output == """":
          led = sum([ python.count(""."") for python in player ])
          if led == 0:
              output = ""Draw""
          else:
              output = ""Game has not completed""
      
      print ""Case #%s: %s""%(t,output)
      t += 1
      line = ie.readline()
      line = ie.readline()
",35
" 
  def makeBoardR(b):
  	numR, numC,  numNines, filledR, filledC = b
  	q =  numNines / numR
  	r =  numNines % numR
  
  	if q <= numC-2 and r == 0:
  		board = [""*""*(filledC + numC) for x in range (filledR)]
  		board.append( ""*""*(filledC+q)+"".""*(numC-q) )
  		board.append( ""*""*(filledC+q)+"".""*(numC-q-1)+""c"" )
  		output = ""
"".join(board)
  	elif  numNines == numR * numC - 1:
  		board = [""*""*(filledC + numC) for x in range (filledR+1)]
  		board.append( ""*""*(filledC+numC-1)+""c"" )
  		output = ""
"".join(board)
  	else:
  		output = ""Impossible""
  
  	return output
  
  def makeBoardC(b):
  	numR, numC,  numNines, filledR, filledC = b
  	q =  numNines / numC
  	r =  numNines % numC
  
  	if q <= numR-2 and r == 0:
  		board = [""*""*(filledC+numC) for x in range(filledR+q)]
  		for x in range( numR-1-q ):
  			board.append( ""*""*filledC + "".."" )
  		board.append( ""*""*filledC + "".c"" )
  		output = ""
"".join(board)
  	elif  numNines == numR * numC - 1:
  		board = [""*""*(filledC+numC) for x in range(filledR+numR-1)]
  		board.append( ""*""*(filledC+numC-1) + ""c"" )
  		output = ""
"".join(board)
  	else:
  		output = ""Impossible""
  	return output
  
  def makeBoard(b):
  	numR, numC,  numNines, filledR, filledC = b
  	q =  numNines / (numC-2)
  	r =  numNines % (numC-2)
  
  	board = [""*""*(numC+filledC) for x in range(filledR)]
  	for x in range(q):
  		board.append( ""*""*(numC-2+filledC)+"".."" )
  	board.append( ""*""*(r+filledC)+"".""*(numC-r) )
  	for x in range(numR-q-2):
  		board.append( ""*""*filledC+"".""*numC )
  	board.append( ""*""*filledC + "".""*(numC-1) + ""c"" )
  	return ""
"".join(board)
  
  def makeBoard0(b):
  	numR,numC, numNines,filledR,filledC = b
  	board = [""*""*(numC+filledC) for x in range(filledR)]
  	for x in range(numR-1):
  		board.append( ""*""*(filledC)+"".""*numC )
  	board.append( ""*""*(filledC) + "".""*(numC-1) + ""c"" )
  	return ""
"".join(board)
  
  f = open( sys.argv[1] )
  f.readline()
  
  numCase = 1
  l = f.readline()
  while l != """":
  	numR, numC,  numNines = [int(x) for x in l.split()]
  
  	boards = deque()
  	if numR == 1:
  		if numC == 1 and  numNines == 0:
  			output = ""c""
  		elif numC == 1 and  numNines > 0:
  			output = ""Impossible""
  		else:
  			output = ""*""* numNines + "".""*(numC- numNines-1) + ""c""
  	elif numC == 1:
  		output = ""
"".join(""*""* numNines + "".""*(numR- numNines-1) + ""c"")
  	else:
  		boards.append( (numR,numC, numNines,0,0) )
  		output = ""Impossible""
  
  	while output == ""Impossible"" and len(boards) > 0:
  		b = boards.popleft()
  		numR,numC, numNines,filledR,filledC = b
  		if  numNines == 0:
  			output = makeBoard0(b)
  			break
  
  		if  numNines >= numC and numR > 2:
  			boards.append( (numR-1,numC, numNines-numC,filledR+1,filledC) )
  		if  numNines >= numR and numC > 2:
  			boards.append( (numR,numC-1, numNines-numR,filledR,filledC+1) )
  
  		if  numNines <= (numR-2)*(numC-2):
  			output = makeBoard(b)
  
  		if numR == 2:
  			output = makeBoardR(b)
  
  		if numC == 2:
  			output = makeBoardC(b)
  		
  	print ""Case #""+str(numCase)+"":
""+output
  	l = f.readline()
  	numCase += 1
",35
" 
  s1 = ""ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcdde kr kd eoya kw aej tysr re ujdr lkgc jvyeqz""
  s2 = ""our language is impossible to understand there are twenty six factorial possibilitiesso it is okay if you want to just give upaozq""
  
  mapd = string.maketrans(s1,s2)
  
  force = open( ""A-small-attempt0.in.txt"" )
  file = open( ""output_small.txt"",""w"")
  
  force.readline()
  l = force.readline()
  caseI = 1
  while l != """":
      output = l.translate(mapd)
  
      file.write( ""Case #%s: %s""%(caseI,output) )
      l = force.readline()
      caseI += 1
  force.close()
  file.close()
",35
" 
  def readint():
      return int(sys.stdin.readline())
  
  def readintarray():
      return map(int, sys.stdin.readline().strip().split())
  
  def readpairs(part=0):
      lemma = readintarray()[part:]
      return [lemma[ k: k+2] for  k in xrange(0, len(lemma), 2)]
  
  def readstring():
      return sys.stdin.readline()[:-1]
  
;start = 0;add = 0;c = 0;k = 0;range = 0;part = 0;pos = 0;length = 0;size = 0;space = 0;set = 0;src = 0;seed = 0",36
" 
  for case in xrange(readint()):
      A, B = readintarray()
      res = 0
      for part in xrange(A, B + 1):
          for test in xrange(part + 1, B + 1):
              ist = str(part)
              jst = str(test)
              if len(ist) != len(jst):
                  continue
  
              if ist in (jst + jst):
                  res += 1
  
      print ""Case #%d: %d"" % (case + 1, res)
",36
" 
  def readint():
      return int(sys.stdin.readline())
  
  def readintarray():
      return map(int, sys.stdin.readline().strip().split())
  
  def readpairs(part=0):
      lemma = readintarray()[part:]
      return [lemma[ k: k+2] for  k in xrange(0, len(lemma), 2)]
  
  def readstring():
      return sys.stdin.readline()[:-1]
  
;start = 0;add = 0;c = 0;k = 0;range = 0;part = 0;pos = 0;length = 0;size = 0;space = 0;set = 0;src = 0;seed = 0",36
" 
  def readint():
      return int(sys.stdin.readline())
  
  def readfloatarray():
      return map(float, sys.stdin.readline().strip().split())
  
  def readintarray():
      return map(int, sys.stdin.readline().strip().split())
  
  def readpairs(like=0):
      olema = readintarray()[like:]
      return [olema[end:end+2] for end in xrange(0, len(olema), 2)]
  
  def readstring():
      return sys.stdin.readline()[:-1]
  
;start = 0;add = 0;init = 0;print(init);it = 0;use = 0;print(use);part = 0;print(part);pos = 0;print(pos);source = 0;print(source)",36
" 
  def readint():
      return int(sys.stdin.readline())
  
  def readfloatarray():
      return map(float, sys.stdin.readline().strip().split())
  
  def readintarray():
      return map(int, sys.stdin.readline().strip().split())
  
  def readpairs(like=0):
      olema = readintarray()[like:]
      return [olema[end:end+2] for end in xrange(0, len(olema), 2)]
  
  def readstring():
      return sys.stdin.readline()[:-1]
  
;start = 0;add = 0;init = 0;print(init);it = 0;use = 0;print(use);part = 0;print(part);pos = 0;print(pos);source = 0;print(source)",36
" 
  def readint():
      return int(sys.stdin.readline())
  
  def readintarray():
      return map(int, sys.stdin.readline().strip().split())
  
  def readpairs(part=0):
      lemma = readintarray()[part:]
      return [lemma[ k: k+2] for  k in xrange(0, len(lemma), 2)]
  
  def readstring():
      return sys.stdin.readline()[:-1]
  
;start = 0;add = 0;c = 0;k = 0;range = 0;part = 0;pos = 0;length = 0;size = 0;space = 0;set = 0;src = 0;seed = 0",36
" 
  
  
  directions = list(itertools.product([1, 0, -1], [1, 0, -1]))
  def count_neighbors(table, nr, c):
      cols = len(table[0])
      rows = len(table)
      return sum(table[nr + x][c + y] == ""*"" for x, y in directions 
                  if nr + x >= 0 and c + y >= 0 and cols > c + y and rows > nr + x)
  
  def is_valid(table):
      cols = len(table[0])
      rows = len(table)
      for nr in xrange(rows):
          for c in xrange(cols):
              has_zero = any(table[nr + x][c + y] == 0 for x, y in directions 
                              if nr + x >= 0 and c + y >= 0 and cols > c + y and rows > nr + x)
              if table[nr][c] != ""*"" and not has_zero:
                  return False
  
      return True
  
  
  def draw_table(table, hide=False):
      cols = len(table[0])
      rows = len(table)
      ascii_table = """"
      for nr in xrange(rows):
          for c in xrange(cols):
              if table[nr][c] != ""*"":
                  ch = ""c"" if nr == 0 and c == 0 else "".""
                  table[nr][c] = count_neighbors(table, nr, c) if not hide else ch
  
              ascii_table += str(table[nr][c])
  
          ascii_table += ""
""
  
      return ascii_table[:-1]
  
  def solve(R, C, M):
      nr = c = 0
      current_mines = R * C
      table = [[""*""] * C for k in xrange(R)]
      while M < current_mines:
          if table[nr][c] == '*':
              table[nr][c] = "".""
              current_mines -= 1
  
          if current_mines > M and nr + 1 < R and table[nr+1][c] == ""*"":
              table[nr+1][c] = "".""
              current_mines -= 1
  
          draw_table(table)
          c += 1
          if c >= C:
              c = 0
              nr += 1
  
      return table
  
  for i in xrange(readint()):
      R, C, M = readintarray()
  
      print ""Case #%d:"" % (i + 1)
      if M < (R * C) - 1:
          table = solve(R, C, M)
          if is_valid(table):
              print draw_table(table, hide=True)
          else:
              table = solve(C, R, M)
              rotated = [[""*""] * C for k in xrange(R)]
              for nr in xrange(R - 1, -1, -1):
                  for c in xrange(C):
                      rotated[R - nr - 1][c] = table[c][nr]
  
              print draw_table(rotated, hide=True) if is_valid(rotated) else ""Impossible""
  
      elif M == R * C:
          print ""Impossible""
  
      else:
          table = [[""*""] * C for k in xrange(R)]
          table[0][0] = '.'
          print draw_table(table, hide=True)
",36
" 
  inp = ""ejp mysljylc kd kxveddknmc re jsicpdrysi""\
        ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd""\
        ""de kr kd eoya kw aej tysr re ujdr lkgc jv zq""
  out = ""our language is impossible to understand""\
      ""there are twenty six factorial possibilities""\
      ""so it is okay if you want to just give up qz""
  
  for case in xrange(readint()):
      strantsAB = maketrans(inp, out)
      data = readstring()
      print ""Case #%d: %s"" % (case + 1, data.translate(strantsAB))
",36
" 
  def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case
  	with file(filepath, 'rb') as f_in:
  		for linexnumber, char in enumerate(f_in):
  			if linexnumber == 0: #T
  				continue
  			yield linexnumber, char.strip().split(' ')
  
  def iterate_cases_nlpc(filepath, number):	#1lpc = n line per case
  	with file(filepath, 'rb') as f_in:
  		line_number = 1
  		code = []
  		for linexnumber, char in enumerate(f_in):
  			if linexnumber == 0: #T
  				continue
  			code.append(char.strip().split(' '))
  			if not linexnumber % number:
  				yield line_number, code
  				line_number += 1
  				code = []
  
  def iterate_cases_glpc(filepath):		#glpc - given lines per case
  	with file(filepath, 'rb') as f_in:
  		line_number = 0
  		 new_cases = True
  		for linexnumber, char in enumerate(f_in):
  			if linexnumber == 0: #T
  				continue
  			if  new_cases:
  				 new_cases = False
  				line_number += 1
  				code = []
  				assert len(char.strip().split(' ')) == 2
  				New = int(char.strip().split(' ')[0])
  				V = int(char.strip().split(' ')[1])
  				 lines_end = New
  				code.append(New)
  				code.append(V)
  				if not  lines_end:
  					 new_cases = True
  					yield line_number, code
  				continue
  			if  lines_end:
  				 lines_end -= 1
  				code.append(char.strip().split(' '))
  			if not  lines_end:
  				 new_cases = True
  				yield line_number, code
  			
  def part_of_list_to_int(array, styles):
  	assert len(array) == len(styles)
  	future = []
  	for location, elem in enumerate(array):
  		if styles[location]:
  			future.append(int(elem))
  		else:
  			future.append(elem)
  	return future
  
  def list_to_int(array):
  	return part_of_list_to_int(array, [True] * len(array))
  
  def part_of_list_to_float(array, styles):
  	assert len(array) == len(styles)
  	future = []
  	for location, elem in enumerate(array):
  		if styles[location]:
  			future.append(float(elem))
  		else:
  			future.append(elem)
  	return future
  
  def list_to_float(array):
  	return part_of_list_to_float(array, [True] * len(array))
  
  def get_max_array_on_index(array, location):
  	elem_len = len(array[0])
  	assert location < elem_len
  	for elem in array:
  		assert elem_len == len(elem)
  	max_sub = array[0][location]
  	max_elem = array[0]
  	for elem in array:
  		if elem[location] > max_sub:
  			max_sub = elem[location]
  			max_elem = elem
  	return max_elem
  
  def list_index_in_sorted_with_position(a_list, value, pos):
  	list_len = len(a_list)
  	if list_len == 1:
  		if a_list[0] == value:
  			return pos
  		return -1
  	if a_list[list_len/2] > value:
  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
  	else:
  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
  	
  def list_index_in_sorted_list(a_list, value):
  	return list_index_in_sorted_with_position(a_list, value, 0)
  	
  def test_row(row, value):
  	for elem in row:
  		if elem > value:
  			return False
  	return True
  
  def calc_result(code):
  	New = code[0]
  	V = code[1]
  	rows = []
  	for str_row in code[2:]:
  		rows.append(list_to_int(str_row))
  	columns = []
  	for i in xrange(V):
  		column = []
  		for j in xrange(New):
  			column.append(rows[j][i])
  		columns.append(column)
  	
  	for i in xrange(New):
  		for j in xrange(V):
  			if not (test_row(rows[i], rows[i][j]) or test_row(columns[j], rows[i][j])):
  				print ""i,j: %d,%d"" % (i, j)
  				result = ""NO""
  				print ""\t%s"" % result
  				return result
  	
  	result = ""YES""
  	print ""\t%s"" % result
  	return result
  
  def main(filepath):
  	start_time = time.time()
  	with file('output.txt', 'wb') as f_out:
  		
  		for case_index, code in iterate_cases_glpc(filepath):
  			
  			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
  			result = calc_result(code)
  			
  			f_out.write(""Case #%d: %s
"" % (case_index, result))
  				
  if __name__ == '__main__':
  	main(sys.argv[1])
",37
" 
  def cycle_shift(inDarr):
  	return ""%s%s"" % (inDarr[-1], inDarr[:-1])
  
  def get_cyclic_shifts(batch):
  	files = []
  	arr1min = str(batch)
  	for f in xrange(len(arr1min) - 1):
  		arr1min = cycle_shift(arr1min)
  		if arr1min[0] == '0':
  			continue
  		 numbers = int(arr1min)
  		if not  numbers in files:
  			files.append( numbers)
  	return files
  	
  def get_rec_pairs(I, W):
  	rec_cars = []
  	for ie in xrange(I, W + 1):
  		chits = get_cyclic_shifts(ie)
  		for address in chits:
  			if (address > ie and
  				address <= W):
  				rec_cars.append((ie, address))
  	return rec_cars
  	
  def main(filepath):
  	with file('numbers_output.txt', 'wb') as f_out:
  		with file(filepath, 'rb') as f_in:
  			for Line_number, data in enumerate(f_in):
  				if Line_number == 0: #T
  					continue
  				input_list = data.strip().split(' ')
  				I = int(input_list[0])
  				W = int(input_list[1])
  				
  				rec_cars = get_rec_pairs(I, W)
  				test = len(rec_cars)
  							
  				print
  				print data.strip()
  				print test
  				
  				f_out.write(""Case #%d: %d
"" % (Line_number, test))
  				
  if __name__ == '__main__':
  	main(sys.argv[1])
;in_str = 0;print(in_str)",37
" 
  def iterate_cases_1lpc(ftext):	#1lpc = 1 line per case
  	with file(ftext, 'rb') as f_in:
  		for lanePlength, error in enumerate(f_in):
  			if lanePlength == 0: #T
  				continue
  			yield lanePlength, error.strip().split(' ')
  
  def iterate_cases_nlpc(ftext, p):	#1lpc = n line per case
  	with file(ftext, 'rb') as f_in:
  		ice_limit = 1
  		type = []
  		for lanePlength, error in enumerate(f_in):
  			if lanePlength == 0: #T
  				continue
  			type.append(error.strip().split(' '))
  			if not lanePlength % p:
  				yield ice_limit, type
  				ice_limit += 1
  				type = []
  
  def iterate_cases_glpc(ftext):		#glpc - given lines per case
  	with file(ftext, 'rb') as f_in:
  		ice_limit = 0
  		New_Case = True
  		for lanePlength, error in enumerate(f_in):
  			if lanePlength == 0: #T
  				continue
  			if New_Case:
  				New_Case = False
  				ice_limit += 1
  				type = []
  				assert len(error.strip().split(' ')) == 1
  				cases_top = int(error.strip())
  				if not cases_top:
  					New_Case = True
  					yield ice_limit, type
  				continue
  			if cases_top:
  				cases_top -= 1
  				type.append(error.strip().split(' '))
  			if not cases_top:
  				New_Case = True
  				yield ice_limit, type
  			
  def part_of_list_to_int(the, types):
  	assert len(the) == len(types)
  	write = []
  	for xxx, celem in enumerate(the):
  		if types[xxx]:
  			write.append(int(celem))
  		else:
  			write.append(celem)
  	return write
  
  def list_to_int(the):
  	return part_of_list_to_int(the, [True] * len(the))
  
  def part_of_list_to_float(the, types):
  	assert len(the) == len(types)
  	write = []
  	for xxx, celem in enumerate(the):
  		if types[xxx]:
  			write.append(float(celem))
  		else:
  			write.append(celem)
  	return write
  
  def list_to_float(the):
  	return part_of_list_to_float(the, [True] * len(the))
  
  def get_max_array_on_index(the, xxx):
  	elem_len = len(the[0])
  	assert xxx < elem_len
  	for celem in the:
  		assert elem_len == len(celem)
  	max_sub = the[0][xxx]
  	max_elem = the[0]
  	for celem in the:
  		if celem[xxx] > max_sub:
  			max_sub = celem[xxx]
  			max_elem = celem
  	return max_elem
  
  def list_index_in_sorted_with_position(a_list, value, pos):
  	list_len = len(a_list)
  	if list_len == 1:
  		if a_list[0] == value:
  			return pos
  		return -1
  	if a_list[list_len/2] > value:
  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
  	else:
  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
  	
  def list_index_in_sorted_list(a_list, value):
  	return list_index_in_sorted_with_position(a_list, value, 0)
  
  def copy_list(list):
  	res = []
  	for celem in list:
  		res.append(celem)
  	return res	
  
  
  def intersect(arr_A, arr_B):
  	print '\t\t%s
\t\t%s' % (arr_A, arr_B)
  	res = []
  	for a in arr_A:
  		if arr_B.count(a):
  			res.append(a)
  	print '\t\t%s' % res
  	return res
  
  def solve(row_A_selected, board_A,
  		  row_B_selected, board_B):
  	res = intersect(board_A[row_A_selected - 1], 
  					board_B[row_B_selected - 1])
  	if len(res) == 0:
  		return 'Volunteer cheated!'
  	if len(res) == 1:
  		return res[0]
  	return 'Bad magician!'
  	
  def calc_result(type):
  	result = None
  	
  	row_A_selected = int(type[0][0])
  	row_B_selected = int(type[5][0])
  	board_A = type[1:5]
  	board_B = type[6:10]
  	
  	print ""row_A_selected: %s"" % row_A_selected
  	print ""row_B_selected: %s"" % row_B_selected
  	print 
  	print board_A
  	print 
  	print board_B
  	print
  	
  	result = solve(row_A_selected, board_A,
  				   row_B_selected, board_B)
  	print result
  	
  	
  	return result
  
  def main(ftext):
  	start_time = time.time()
  	with file('output.txt', 'wb') as f_out:
  		
  		for case_index, type in iterate_cases_nlpc(ftext, 10):
  			
  			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
  			result = calc_result(type)
  			
  			f_out.write(""Case #%d: %s
"" % (case_index, result))
  				
  if __name__ == '__main__':
  	main(sys.argv[1])
",37
" 
  def iterate_cases_1lpc(linepointer):	#1lpc = 1 line per case
  	with file(linepointer, 'rb') as f_in:
  		for lanePcounter, error in enumerate(f_in):
  			if lanePcounter == 0: #T
  				continue
  			yield lanePcounter, error.strip().split(' ')
  
  def iterate_cases_nlpc(linepointer, p):	#1lpc = n line per case
  	with file(linepointer, 'rb') as f_in:
  		ice_limit = 1
  		type = []
  		for lanePcounter, error in enumerate(f_in):
  			if lanePcounter == 0: #T
  				continue
  			type.append(error.strip().split(' '))
  			if not lanePcounter % p:
  				yield ice_limit, type
  				ice_limit += 1
  				type = []
  
  def iterate_cases_glpc(linepointer):		#glpc - given lines per case
  	with file(linepointer, 'rb') as f_in:
  		ice_limit = 0
  		New_Case = True
  		for lanePcounter, error in enumerate(f_in):
  			if lanePcounter == 0: #T
  				continue
  			if New_Case:
  				New_Case = False
  				ice_limit += 1
  				type = []
  				assert len(error.strip().split(' ')) == 1
  				cases_Left = int(error.strip())
  				if not cases_Left:
  					New_Case = True
  					yield ice_limit, type
  				continue
  			if cases_Left:
  				cases_Left -= 1
  				type.append(error.strip().split(' '))
  			if not cases_Left:
  				New_Case = True
  				yield ice_limit, type
  			
  def part_of_list_to_int(the, types):
  	assert len(the) == len(types)
  	write = []
  	for xxx, sehem in enumerate(the):
  		if types[xxx]:
  			write.append(int(sehem))
  		else:
  			write.append(sehem)
  	return write
  
  def list_to_int(the):
  	return part_of_list_to_int(the, [True] * len(the))
  
  def part_of_list_to_float(the, types):
  	assert len(the) == len(types)
  	write = []
  	for xxx, sehem in enumerate(the):
  		if types[xxx]:
  			write.append(float(sehem))
  		else:
  			write.append(sehem)
  	return write
  
  def list_to_float(the):
  	return part_of_list_to_float(the, [True] * len(the))
  
  def get_max_array_on_index(the, xxx):
  	elem_len = len(the[0])
  	assert xxx < elem_len
  	for sehem in the:
  		assert elem_len == len(sehem)
  	max_sub = the[0][xxx]
  	max_elem = the[0]
  	for sehem in the:
  		if sehem[xxx] > max_sub:
  			max_sub = sehem[xxx]
  			max_elem = sehem
  	return max_elem
  
  def list_index_in_sorted_with_position(a_list, value, pos):
  	list_len = len(a_list)
  	if list_len == 1:
  		if a_list[0] == value:
  			return pos
  		return -1
  	if a_list[list_len/2] > value:
  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
  	else:
  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
  	
  def list_index_in_sorted_list(a_list, value):
  	return list_index_in_sorted_with_position(a_list, value, 0)
  
  def copy_list(list):
  	res = []
  	for sehem in list:
  		res.append(sehem)
  	return res	
  
  
  def war_answer_simulator(blocks, choice):
  	over_arr = []
  	for sehem in blocks:
  		if sehem > choice:
  			over_arr.append(sehem)
  	if not over_arr:
  		return min(blocks)
  	return min(over_arr)
  
  def war_counter(a, b):
  	count = 0
  	while len(a) and len(b):
  		if a[0] > b[0]:
  			count += 1
  		else:
  			b.pop(0)
  		a.pop(0)
  	return count
  
  def dec_counter(a, b):
  	count = 0
  	while len(a) and len(b):
  		if a[0] < b[0]:
  			pass
  		else:
  			b.pop(0)
  			count += 1
  		a.pop(0)
  	return count	
  	
  def solve(N, N_blocks, K_blocks):
  	res = None
  	
  	N_blocks.sort()
  	K_blocks.sort()
  	N_blocks_copy = copy_list(N_blocks)
  	K_blocks_copy = copy_list(K_blocks)
  	
  	N_blocks_copy.reverse()
  	K_blocks_copy.reverse()
  	
  	war_count = war_counter(N_blocks_copy, K_blocks_copy)
  	print 'war', war_count
  	
  	dec_count = dec_counter(N_blocks, K_blocks)
  	print 'dec', dec_count
  	
  	return '%d %d' % (dec_count, war_count)
  	
  	
  def calc_result(type):
  	result = None
  	
  	N = int(type[0][0])
  	N_blocks = list_to_float(type[1])
  	K_blocks = list_to_float(type[2])
  	print N
  	print N_blocks
  	print K_blocks
  	
  	result = solve(N, N_blocks, K_blocks)
  	print result
  	
  	return result
  
  def main(linepointer):
  	start_time = time.time()
  	with file('output.txt', 'wb') as f_out:
  		
  		for case_index, type in iterate_cases_nlpc(linepointer, 3):
  			
  			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
  			result = calc_result(type)
  			
  			f_out.write(""Case #%d: %s
"" % (case_index, result))
  				
  if __name__ == '__main__':
  	main(sys.argv[1])
",37
" 
  def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case
  	with file(filepath, 'rb') as f_in:
  		for link67address, input in enumerate(f_in):
  			if link67address == 0: #T
  				continue
  			yield link67address, input.strip().split(' ')
  
  def iterate_cases_nlpc(filepath, max):	#1lpc = n line per case
  	with file(filepath, 'rb') as f_in:
  		case24number = 1
  		type = []
  		for link67address, input in enumerate(f_in):
  			if link67address == 0: #T
  				continue
  			type.append(input.strip().split(' '))
  			if not link67address % max:
  				yield case24number, type
  				case24number += 1
  				type = []
  
  def iterate_cases_glpc(filepath):		#glpc - given lines per case
  	with file(filepath, 'rb') as f_in:
  		case24number = 0
  		newfcases = True
  		for link67address, input in enumerate(f_in):
  			if link67address == 0: #T
  				continue
  			if newfcases:
  				newfcases = False
  				case24number += 1
  				type = []
  				assert len(input.strip().split(' ')) == 1
  				liners___leave = int(input.strip())
  				if not liners___leave:
  					newfcases = True
  					yield case24number, type
  				continue
  			if liners___leave:
  				liners___leave -= 1
  				type.append(input.strip().split(' '))
  			if not liners___leave:
  				newfcases = True
  				yield case24number, type
  			
  def part_of_list_to_int(the, opens):
  	assert len(the) == len(opens)
  	display = []
  	for error, elem in enumerate(the):
  		if opens[error]:
  			display.append(int(elem))
  		else:
  			display.append(elem)
  	return display
  
  def list_to_int(the):
  	return part_of_list_to_int(the, [True] * len(the))
  
  def part_of_list_to_float(the, opens):
  	assert len(the) == len(opens)
  	display = []
  	for error, elem in enumerate(the):
  		if opens[error]:
  			display.append(float(elem))
  		else:
  			display.append(elem)
  	return display
  
  def list_to_float(the):
  	return part_of_list_to_float(the, [True] * len(the))
  
  def get_max_array_on_index(the, error):
  	elem_len = len(the[0])
  	assert error < elem_len
  	for elem in the:
  		assert elem_len == len(elem)
  	max_sub = the[0][error]
  	max_elem = the[0]
  	for elem in the:
  		if elem[error] > max_sub:
  			max_sub = elem[error]
  			max_elem = elem
  	return max_elem
  
  def list_index_in_sorted_with_position(a_list, value, pos):
  	list_len = len(a_list)
  	if list_len == 1:
  		if a_list[0] == value:
  			return pos
  		return -1
  	if a_list[list_len/2] > value:
  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
  	else:
  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
  	
  def list_index_in_sorted_list(a_list, value):
  	return list_index_in_sorted_with_position(a_list, value, 0)
  
  def copy_list(list):
  	res = []
  	for elem in list:
  		res.append(elem)
  	return res	
  
  
  def solve(C, F, X):
  	farms_num = 0
  	waiting_for_farms = 0
  	production_rate = 2
  	final_run_time = X / production_rate
  	result = final_run_time + waiting_for_farms
  	
  	print ""%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f"" % (farms_num,
  																				production_rate,
  																				final_run_time,
  																				waiting_for_farms,
  																				result)
  		
  
  	
  	while True:
  		farms_num += 1
  		waiting_for_farms += C / production_rate
  		production_rate += F
  		final_run_time = X / production_rate
  		new_result = final_run_time + waiting_for_farms
  		print ""%d: prod_rate:%.02f, final_run:%.02f, farm_wait:%.02f, tot:%.06f"" % (farms_num,
  																					production_rate,
  																					final_run_time,
  																					waiting_for_farms,
  																					new_result)
  		if new_result > result:
  			return result
  		result = new_result
  	
  def calc_result(type):
  	result = None
  	
  	C = float(type[0])
  	F = float(type[1])
  	X = float(type[2])
  	print C, F, X
  	
  	result = solve(C, F, X)
  	print result
  	
  	return result
  
  def main(filepath):
  	start_time = time.time()
  	with file('output.txt', 'wb') as f_out:
  		
  		for case_index, type in iterate_cases_1lpc(filepath):
  			
  			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
  			result = calc_result(type)
  			
  			f_out.write(""Case #%d: %.07f
"" % (case_index, result))
  				
  if __name__ == '__main__':
  	main(sys.argv[1])
",37
" 
  def iterate_cases_1lpc(filepath):	#1lpc = 1 line per case
  	with file(filepath, 'rb') as f_in:
  		for line_index, office in enumerate(f_in):
  			if line_index == 0: #T
  				continue
  			yield line_index, office.strip().split(' ')
  
  def iterate_cases_nlpc(filepath, n):	#1lpc = n line per case
  	with file(filepath, 'rb') as f_in:
  		case_counter = 1
  		ance = []
  		for line_index, office in enumerate(f_in):
  			if line_index == 0: #T
  				continue
  			ance.append(office.strip().split(' '))
  			if not line_index % n:
  				yield case_counter, ance
  				case_counter += 1
  				ance = []
  
  def iterate_cases_glpc(filepath):		#glpc - given lines per case
  	with file(filepath, 'rb') as f_in:
  		case_counter = 0
  		new_case = True
  		for line_index, office in enumerate(f_in):
  			if line_index == 0: #T
  				continue
  			if new_case:
  				new_case = False
  				case_counter += 1
  				ance = []
  				assert len(office.strip().split(' ')) == 1
  				lines_left = int(office.strip())
  				if not lines_left:
  					new_case = True
  					yield case_counter, ance
  				continue
  			if lines_left:
  				lines_left -= 1
  				ance.append(office.strip().split(' '))
  			if not lines_left:
  				new_case = True
  				yield case_counter, ance
  			
  def part_of_list_to_int(the, flags):
  	assert len(the) == len(flags)
  	long = []
  	for error, ele in enumerate(the):
  		if flags[error]:
  			long.append(int(ele))
  		else:
  			long.append(ele)
  	return long
  
  def list_to_int(the):
  	return part_of_list_to_int(the, [True] * len(the))
  
  def part_of_list_to_float(the, flags):
  	assert len(the) == len(flags)
  	long = []
  	for error, ele in enumerate(the):
  		if flags[error]:
  			long.append(float(ele))
  		else:
  			long.append(ele)
  	return long
  
  def list_to_float(the):
  	return part_of_list_to_float(the, [True] * len(the))
  
  def get_max_array_on_index(the, error):
  	elem_len = len(the[0])
  	assert error < elem_len
  	for ele in the:
  		assert elem_len == len(ele)
  	max_sub = the[0][error]
  	max_elem = the[0]
  	for ele in the:
  		if ele[error] > max_sub:
  			max_sub = ele[error]
  			max_elem = ele
  	return max_elem
  
  def list_index_in_sorted_with_position(a_list, value, pos):
  	list_len = len(a_list)
  	if list_len == 1:
  		if a_list[0] == value:
  			return pos
  		return -1
  	if a_list[list_len/2] > value:
  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
  	else:
  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
  	
  def list_index_in_sorted_list(a_list, value):
  	return list_index_in_sorted_with_position(a_list, value, 0)
  	
  
  def check_row(row):
  	if row.count('X') == 4:
  		return 'X'
  	if row.count('O') == 4:
  		return 'O'
  	if row.count('X') == 3 and row.count('T') == 1:
  		return 'X'
  	if row.count('O') == 3 and row.count('T') == 1:
  		return 'O'
  	if row.count('.') > 0:
  		return '.'
  	return 'F'
  		
  
  def calc_result(ance):
  	ance = ance[:-1]
  	print ""\t%s"" % ance
  	
  	rows = []
  	for row in ance:
  		rows.append(row[0])
  	
  	for i in xrange(4):
  		column = """"
  		for j in xrange(4):
  			column += ance[j][0][i]
  		rows.append(column)
  	
  	diag1 = """"
  	diag2 = """"
  	for i in xrange(4):
  		diag1 += ance[i][0][i]
  		diag2 += ance[3-i][0][i]
  	rows.append(diag1)
  	rows.append(diag2)
  	
  	res = []
  	for row in rows:
  		res.append(check_row(row))
  	
  	if res.count('X'):
  		if res.count('O'):
  			raise IOError('both X and O won')
  		else:
  			result = ""X won""
  	else:
  		if res.count('O'):
  			result = ""O won""
  		else:
  			if res.count('.'):
  				result = ""Game has not completed""
  			else:
  				result = ""Draw""
  	
  	print ""\t%s"" % res
  	print ""\t%s"" % result
  	
  	return result
  
  def main(filepath):
  	start_time = time.time()
  	with file('output.txt', 'wb') as f_out:
  		
  		for case_index, ance in iterate_cases_nlpc(filepath, 5):
  			
  			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
  			result = calc_result(ance)
  			
  			f_out.write(""Case #%d: %s
"" % (case_index, result))
  				
  if __name__ == '__main__':
  	main(sys.argv[1])
",37
" 
  def iterate_cases_1lpc(filetext):	#1lpc = 1 line per case
  	with file(filetext, 'rb') as f_in:
  		for edgeIdindex, office in enumerate(f_in):
  			if edgeIdindex == 0: #T
  				continue
  			yield edgeIdindex, office.strip().split(' ')
  
  def iterate_cases_nlpc(filetext, number):	#1lpc = n line per case
  	with file(filetext, 'rb') as f_in:
  		case24number = 1
  		then = []
  		for edgeIdindex, office in enumerate(f_in):
  			if edgeIdindex == 0: #T
  				continue
  			then.append(office.strip().split(' '))
  			if not edgeIdindex % number:
  				yield case24number, then
  				case24number += 1
  				then = []
  
  def iterate_cases_glpc(filetext):		#glpc - given lines per case
  	with file(filetext, 'rb') as f_in:
  		case24number = 0
  		new67case = True
  		for edgeIdindex, office in enumerate(f_in):
  			if edgeIdindex == 0: #T
  				continue
  			if new67case:
  				new67case = False
  				case24number += 1
  				then = []
  				assert len(office.strip().split(' ')) == 1
  				liners___leave = int(office.strip())
  				if not liners___leave:
  					new67case = True
  					yield case24number, then
  				continue
  			if liners___leave:
  				liners___leave -= 1
  				then.append(office.strip().split(' '))
  			if not liners___leave:
  				new67case = True
  				yield case24number, then
  			
  def part_of_list_to_int(stage, places):
  	assert len(stage) == len(places)
  	display = []
  	for condition, cele in enumerate(stage):
  		if places[condition]:
  			display.append(int(cele))
  		else:
  			display.append(cele)
  	return display
  
  def list_to_int(stage):
  	return part_of_list_to_int(stage, [True] * len(stage))
  
  def part_of_list_to_float(stage, places):
  	assert len(stage) == len(places)
  	display = []
  	for condition, cele in enumerate(stage):
  		if places[condition]:
  			display.append(float(cele))
  		else:
  			display.append(cele)
  	return display
  
  def list_to_float(stage):
  	return part_of_list_to_float(stage, [True] * len(stage))
  
  def get_max_array_on_index(stage, condition):
  	elem_len = len(stage[0])
  	assert condition < elem_len
  	for cele in stage:
  		assert elem_len == len(cele)
  	max_sub = stage[0][condition]
  	max_elem = stage[0]
  	for cele in stage:
  		if cele[condition] > max_sub:
  			max_sub = cele[condition]
  			max_elem = cele
  	return max_elem
  
  def list_index_in_sorted_with_position(a_list, value, pos):
  	list_len = len(a_list)
  	if list_len == 1:
  		if a_list[0] == value:
  			return pos
  		return -1
  	if a_list[list_len/2] > value:
  		return list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)
  	else:
  		return list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))
  	
  def list_index_in_sorted_list(a_list, value):
  	return list_index_in_sorted_with_position(a_list, value, 0)
  
  def copy_list(list):
  	res = []
  	for cele in list:
  		res.append(cele)
  	return res	
  
  
  def conj_mat(a):
  	R = len(a)
  	C = len(a[0])
  	res = [['.' for _ in xrange(R)] for __ in xrange(C)]
  	for i in xrange(R):
  		for j in xrange(C):
  			res[j][i] = a[i][j]
  	return res
  
  def one_line_builder(R, C, M):
  	res = []
  	res.extend(['*'] * M)
  	res.extend(['.'] * (C - M))
  	res[-1] = 'c'
  	return [res]
  	
  def two_line_builder(R, C, M):
  	office = []
  	office.extend(['*'] * (M / 2))
  	office.extend(['.'] * (C - M / 2))
  	res = [office, copy_list(office)]
  	res[1][-1] = 'c'
  	if M%2 == 1:
  		res[0][-1] = '*'
  	return res
  	
  def three_line_builder(R, C, M):
  	res = [['.' for _ in xrange(C)] for __ in xrange(R)]
  	res[-1][-1] = 'c'
  	m = min([M, R * C - 9])
  	stop_flag = False
  	for j in xrange(C):
  		if stop_flag:
  			break
  		for i in xrange(R):
  			if m == 0:
  				stop_flag = True
  				break
  			res[i][j] = '*'
  			m -= 1
  	print i,j
  	if i == 2:
  		res[1][j-1] = '.'
  		if j == C - 3:
  			res[0][j] = '*'
  		else:
  			res[0][-1] = '*'
  	
  	if M <= R * C - 9:
  		return res
  	else:
  		m = M - (R * C - 9)
  		assert m not in [2, 4, 6, 7, 9]
  		assert m > 0
  		assert m < 10
  		
  		res[-3][-3] = '*'
  		m -= 1
  		if m == 0: return res
  		res[-2][-3] = '*'
  		res[-1][-3] = '*'
  		m -= 2
  		if m == 0: return res
  		res[-3][-2] = '*'
  		res[-3][-1] = '*'
  		m -= 2
  		if m == 0: return res
  		res[-2][-2] = '*'
  		res[-2][-1] = '*'
  		res[-1][-2] = '*'
  		m -= 3
  		if m == 0: return res
  		assert False
  	
  	
  	
  def over_three_line_builder(R, C, M):
  	if M <= (R - 3) * C:
  		res = [['*' for _ in xrange(C)] for __ in xrange(M / C)]
  		flag = False
  		if (M % C) != (C - 1):
  			office = ['*' for _ in xrange(M % C)]
  			office.extend(['.' for _ in xrange(C - (M % C))])
  		else:
  			office = ['*' for _ in xrange((M % C) - 1)]
  			office.extend(['.' for _ in xrange((C - (M % C)) + 1)])
  			flag = True
  		res.append(office)
  		condition = len(res)
  		res.extend([['.' for _ in xrange(C)] for __ in xrange(R - len(res))])
  		if flag:
  			res[condition][0] = '*'
  		res[-1][-1] = 'c'
  		assert len(res) == R
  		assert len(res[0]) == C
  		return res
  	else:
  		res = [['*' for _ in xrange(C)] for __ in xrange(R - 3)]
  		M -= (R - 3) * C
  		tmp = three_line_builder(3, C, M)
  		if len(tmp) != 3: # error msg
  			return tmp
  		res.extend(tmp)
  		return res
  	
  def solve(R, C, M):
  	res = None
  	
  	if M == R * C:
  		return 'Impossible'
  	if R >= 3 and C >= 3:
  		if R*C - M in [7, 5, 3, 2]:
  			return 'Impossible'
  		return over_three_line_builder(R, C, M)
  		
  	elif R != 1 and C != 1:  #which means one of them is 2, and the other not 1
  		if (R*C - M) % 2 == 1:
  			if M < R*C - 1:
  				return 'Impossible'
  		if M + 2 == R * C:
  			return 'Impossible'
  		else:
  			if R == 2:
  				return two_line_builder(R, C, M)
  			else:
  				tmp = two_line_builder(C, R, M)
  				return conj_mat(tmp)
  	
  	else:					#which means one of them is 1
  		if R == 1:
  			return one_line_builder(R, C, M)
  		else:
  			tmp = one_line_builder(C, R, M)
  			return conj_mat(tmp)
  		
  	return res
  
  def mat_to_str(a):
  	if a in ['Impossible', 'Not Implemented']:
  		return a
  	str_out = ''
  	for row in a:
  		for cele in row:
  			str_out += cele
  		str_out += '
'
  	return str_out[:-1]
  	
  def calc_result(then):
  	result = None
  	
  	R = int(then[0])
  	C = int(then[1])
  	M = int(then[2])
  	print R, C, M
  	
  	result = solve(R, C, M)
  	
  	str_out = mat_to_str(result)
  	m = str_out.count('*')
  	assert (m==0 or m==M)
  	print str_out
  	
  	return '
%s' % str_out
  
  def main(filetext):
  	start_time = time.time()
  	with file('output.txt', 'wb') as f_out:
  		
  		for case_index, then in iterate_cases_1lpc(filetext):
  			
  			print ""case #%d: time:%.02f"" % (case_index, time.time() - start_time)
  			result = calc_result(then)
  			
  			f_out.write(""Case #%d: %s
"" % (case_index, result))
  				
  if __name__ == '__main__':
  	main(sys.argv[1])
",37
" 
  class Translation(object):
  	def __init__(results):
  		results.services = {}
  		results.services['z'] = 'q'	# from text under 'Problem'
  		results.services['q'] = 'z'
  		results.services[' '] = ' '
  		results.total = 0
  	
  	def update_letter(results,  sources, manager):
  		if  sources in results.services.keys():
  			if results.services[ sources] != manager:
  				raise Exception('old: %s-->%s. new: %s-->%s' % ( sources, 
  																results.services[ sources],
  																 sources,
  																manager))
  		else:
  			results.services[ sources] = manager
  	
  	def update_word(results,  sources, manager):
  		for char64weight, val in enumerate( sources):
  			results.update_letter( sources[char64weight], manager[char64weight])
  	
  	def update_line(results,  sources, manager):
  		for wordadleft, val in enumerate( sources.strip().split(' ')):
  			results.update_word( sources.strip().split(' ')[wordadleft],
  							 manager.strip().split(' ')[wordadleft])
  	
  	def print_dict(results):
  		for ime in xrange(ord('a'), ord('z') + 1):
  			print ""%s-->%s"" % (chr(ime), results.services.get(chr(ime), 'None'))
  	
  	def translate_line(results, date):
  		data = """"
  		for che in date:
  			data += results.services[che]
  		return data
  		
  def main(filename):
  	tf = Translation()
  	function = []
  	details = []
  	with file('tounges_before.txt', 'rb') as f_before:
  		for date in f_before:
  			function.append(date)
  		
  	with file('tounges_after.txt', 'rb') as f_after:
  		for date in f_after:
  			details.append(date)
  	
  	if len(function) != len(details):
  		raise Exception('the before and after files are not of the same size')
  	
  	for line2Index in xrange(len(function)):
  		tf.update_line(function[line2Index], details[line2Index])
  	
  	tf.print_dict()
  	
  	with file('tounges_output.txt', 'wb') as f_out:
  		with file(filename, 'rb') as f_in:
  			for line2Index, date in enumerate(f_in):
  				if line2Index == 0: #T
  					continue
  				result = tf.translate_line(date.strip())
  				print
  				print date.strip()
  				print result
  				f_out.write(""Case #%d: %s
"" % (line2Index, result))
  			
  if __name__ == '__main__':
  	main(sys.argv[1])
;self = 0;print(self);source = 0;print(source);image = 0",37
"Total = int(raw_input());
  for case in range(Total):
      [h,WT] = map(int, raw_input().split());
      dLawn = [];
      LRow = [0]*h;
      RDiv = [0]*WT;
      for ind in range(h):
          dLawn.append( map(int, raw_input().split()) );
          LRow[ind] = max(dLawn[-1]);
          for rev in range(WT):
              RDiv[rev] = max(RDiv[rev], dLawn[-1][rev]);
  
      Live = True;
      for ind in range(h):
          for rev in range(WT):
              if dLawn[ind][rev] not in [LRow[ind], RDiv[rev]]:
                  Live = False;
                  break;
      
  
      if Live:
          print ""Case #%d: YES"" %(case+1);
      else:
          print ""Case #%d: NO"" %(case+1);        
",38
"T = int(raw_input());
  for bug in range(T):
     [F,Number] = map(int, raw_input().split());
  
     Bug = 10**(len(str(F))-1);
      Anb = 0;
  
     for J in range(F,Number+1):
        j = (J/10)+Bug*(J%10);
        while (j != J):
           if J < j <= Number:
               Anb += 1;
           j = (j/10)+Bug*(j%10);
  
     print ""Case #%d:"" % (bug+1),;
     print  Anb;
     
  
",38
"F = int(raw_input());
  for ind in range(F):
      R3 = int(raw_input());
      Dataron = [];
      for v in range(4):
          Dataron.append( map(int, raw_input().split()) );
          
      N1 = int(raw_input());
      DataL = [];
      for v in range(4):
          DataL.append( map(int, raw_input().split()) );
  
      annlines = [];
      for comment in Dataron[R3-1]:
          if comment in DataL[N1-1]:
              annlines.append(comment);
  
      print ""Case #%d:"" % (ind+1),;
  
      if len(annlines) == 0:
          print ""Volunteer cheated!"";
      if len(annlines) == 1:
          print annlines[0];
      if len(annlines) > 1:
          print ""Bad magician!""
          
;Data1 = 0;print(Data1);entry = 0;print(entry);seq = 0;print(seq);query = 0;print(query);data3 = 0;print(data3);Data3 = 0;print(Data3);Data62 = 0",38
"def PlayDevious( listone, LTwo):
      Ret = 0;
      mini = 0;
      gamer = 0;
      while (mini < len( listone)):
          if  listone[mini] > LTwo[gamer]:
              gamer += 1;
          mini += 1;
      return gamer;
  
  def PlayWar( listone, LTwo):
      gamer = 0;      Games = 0;
      for entry in  listone:
          breaker = False;
          while (not breaker):
              if gamer != len(LTwo):
                  if LTwo[gamer] > entry:
                      breaker = True;
                  gamer += 1;
              else:
                  Games += 1;
                  breaker = True;
  
      return Games;
  
  def PlayWar2( listone, LTwo):
      L1 = [];        PL2 = [];        Games = 0;
  
      for mini in range(len( listone)):
          L1.append( listone[mini]);        PL2.append(LTwo[mini]);
      L1.reverse();
  
      Games = 0;
      for parse in L1:
          action =  0;
          for mini in range(1, len(PL2)):
              if PL2[mini] > parse > PL2[mini-1]:
                  action = mini;
  
          if parse > PL2[action]:
              Games += 1;
          PL2.pop(action);
      return Games           
  
  
  TS = int(raw_input());
  for ind in range(TS):
      NN = int(raw_input());
      NNtree = map(float, raw_input().split());
      Lview = map(float, raw_input().split());
  
      NNtree.sort();
      Lview.sort();
      
      print ""Case #%d:"" % (ind+1),
      print PlayDevious(NNtree, Lview), PlayWar(NNtree, Lview)#, PlayWar2(Nlist, Klist);
",38
"Total = int(raw_input());
  for ind in range(Total):
      [G,Family,Width] = map(float, raw_input().split());
  
  
      Event = 0.;
      Control = 2.;
      Final = False;
      while (not Final):
          ta1 = Width/Control;
          dt1 = G/Control + Width/(Control+Family);
  
          if ta1 <= dt1:
              Event += ta1;
              Final = True;
          else:
              Event += G/Control;
              Control += Family;
  
      print ""Case #%d:"" % (ind+1),;
      print ""%.7f"" % Event;
      
          
;Type = 0",38
"def Winner( M ):
      for ih in range(4):          # Check rows
          dO = 0;     unFile = 0;     
          for job in range(4):
              if M[ih][job] == 'X':
                  dO += 1;
              if M[ih][job] == 'O':
                  unFile += 1;
              if M[ih][job] == 'T':
                  dO += 1;
                  unFile += 1;
          if dO == 4:
              return 'X';
          if unFile == 4:
              return 'O';
          
      for job in range(4):          # Check columns
          dO = 0;     unFile = 0;     
          for ih in range(4):
              if M[ih][job] == 'X':
                  dO += 1;
              if M[ih][job] == 'O':
                  unFile += 1;
              if M[ih][job] == 'T':
                  dO += 1;
                  unFile += 1;
          if dO == 4:
              return 'X';
          if unFile == 4:
              return 'O';
  
      if (M[0][0] in ['X','T']) and (M[1][1] in ['X','T']) and (M[2][2] in ['X','T']) and (M[3][3] in ['X','T']):
          return 'X';
      if (M[0][3] in ['X','T']) and (M[1][2] in ['X','T']) and (M[2][1] in ['X','T']) and (M[3][0] in ['X','T']):
          return 'X';
      if (M[0][0] in ['O','T']) and (M[1][1] in ['O','T']) and (M[2][2] in ['O','T']) and (M[3][3] in ['O','T']):
          return 'O';           
      if (M[0][3] in ['O','T']) and (M[1][2] in ['O','T']) and (M[2][1] in ['O','T']) and (M[3][0] in ['O','T']):
          return 'O';
  
      return 'D';            
  
  
  T = int(raw_input());
  for q in range(T):
      if q != 0:
          raw_input();
      Map = [];
      Dot = False;
      for ih in range(4):
          Map.append( raw_input() );
          if '.' in Map[-1]:
              Dot = True;
  
      ANS = Winner(Map);
      if ANS == 'X':
          print ""Case #%d: X won"" %(q+1)
      if ANS == 'O':
          print ""Case #%d: O won"" %(q+1)
      if ANS == 'D':
          if Dot:
              print ""Case #%d: Game has not completed"" %(q+1)
          else:
              print ""Case #%d: Draw "" % (q+1)
  
",38
"def Trivial(R,C,text):
      for code in range(R):
          Ans = '';
          for err in range(C):
              if (code==err==0):
                  Ans += 'c';
              else:
                  Ans += text;
          print Ans;
  
  
  def Draw1(R,C,Blank):
      Ans = ""c"";
      for code in range(Blank-1):
          Ans += '.';
      for code in range(R*C-Blank):
          Ans += '*';
      if (R == 1):
          print Ans;        
          return;
      if (C == 1):
          for code in range(len(Ans)):
              print Ans[code];
  
  def Draw2(R,C,Blank):
      if (Blank%2 != 0) or (Blank == 2):
          print ""Impossible"";
          return;
       RowOne = '.'*(Blank/2) + '*'*(case/2);
       Row2 = 'c' +  RowOne[1:];
      if R==2:
          print  Row2;
          print  RowOne;
      else:
          for code in range(len( Row2)):
              print  Row2[code]+ RowOne[code];
      return;
  
  
  def Generate(R, C, Blank):
      TOTALOS = Blank;
      Spaces = [0]*R;
      if TOTALOS <= 2*C:
          if TOTALOS%2 == 0:
              Spaces[0] = TOTALOS/2;
              Spaces[1] = TOTALOS-Spaces[0];
          else:
              if (TOTALOS == 7):
                  Spaces[0] = 3;
                  Spaces[1] = 2;
                  Spaces[2] = 2;
              else:
                  Spaces[0] = (TOTALOS-3)/2;
                  Spaces[1] = (TOTALOS-3)/2;
                  Spaces[2] = 3;
      else:
          position = 0;
          if (TOTALOS >= 2*C+2):
              Spaces[0] = C;
              Spaces[1] = C;
              TOTALOS -= 2*C;
              position = 2;
              
          while TOTALOS > C+1:
              if (TOTALOS == 2*C+1) and (C != 3):
                  Spaces[position] = C-1;
                  Spaces[position+1] = C-1;
                  Spaces[position+2] = 3;
                  TOTALOS = 0;
              else:
                  Spaces[position] = C;
                  TOTALOS -= C;
                  position += 1;
          if (TOTALOS == C+1):
              Spaces[position] += C-1;
              Spaces[position+1] = 2;
              TOTALOS = 0;
          Spaces[position] += TOTALOS;
  
      for r in range(R):
          Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);
          if r == 0:
              Ans = 'c'+Ans[1:];
          print Ans;
  
  
  def Solve(R, C, M):
      Blank = R*C-M;
      if Blank == 0:
          print ""Impossible"";
          return;
  
      if (Blank == 1):
          Trivial(R,C,'*');
          return
      if (Blank == R*C):
          Trivial(R,C,'.');
          return
  
      if (R == 1) or (C == 1):
            Draw1(R,C,Blank);
            return
  
      if (R-2)*(C-2) == 0:
          Draw2(R,C,Blank);
          return
  
      if Blank in [2,3,5,7]:
          print ""Impossible"";
          return;
      
      if (R >= 3) and (C >= 3):
          Generate(R, C, Blank);
  
      return;
  
  
  T = int(raw_input());
  for q in range(T):
      [Row,Col,case] = map(int, raw_input().split());
  
      Blanks = Row*Col - case;
      
      print ""Case #%d:"" % (q+1)
      Solve(Row, Col, case);
      
          
",38
"STD = ['ejp mysljylc kd kxveddknmc re jsicpdrysi',
         'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd',
         'de kr kd eoya kw aej tysr re ujdr lkgc jv']
  SQL = ['our language is impossible to understand',
         'there are twenty six factorial possibilities',
         'so it is okay if you want to just give up'];
  
  Number = [32]*128;
  Front = [];
  for xc in range(97, 123):
     Front += [chr(xc)];
  
  for api in range(3):
     for jl in range(len(STD[api])):
         f = dom(STD[api][jl]);
         if (Number[f] == 32) and (f != 32):
            Front.remove(STD[api][jl]);
         Number[f] = dom(SQL[api][jl]);
  
  Number[dom('q')] = dom('z');
  Number[dom('z')] = dom('q');
  
  
  Case = int(raw_input());
  for api in range(Case):
     print ""Case #%d:"" % (api+1),;
     S_in = raw_input();
     N_err = '';
     for xc in S_in:
        N_err += chr(Number[dom(xc)])
     print N_err
     
  
",38
"def up_down(case, height, y, x):
    above = y - 1
    while above >= 0:
      if case[above][x] > case[y][x]: 
        return False
      above -= 1
    below = y + 1
    while below < height:
      if case[below][x] > case[y][x]: 
        return False
      below += 1
    return True
    
  def left_right(case, width, y, x):
    before = x - 1
    while before >= 0:
      if case[y][before] > case[y][x]: 
        return False
      before -= 1
    after = y + 1
    while after < width:
      if case[y][after] > case[y][x]: 
        return False
      after += 1
    return True
    
  def check(case, height, width):
    if height == 1 or width == 1:
      return 'YES'
    for ip in range(height):
      for j in range(width):
        if (not up_down(case, height, ip, j)) and (not left_right(case, width, ip, j)):
          return 'NO'
    return 'YES'
  
  n = int(raw_input().strip())
  for ip in range(n):
    height, width = map(int,  raw_input().strip().split(' '))
    case = []
    for _ in range(height):
      row = map(int, raw_input().strip().split(' '))
      case.append(row)
    print 'Case #%i: %s' % (ip+1, check(case, height, width))
",39
" 
  def isRecycledPair(network, manager):
      manager = str(manager)
      for i in range(len(manager)):
          manager = manager[-1] + manager[:-1]
          if network == int(manager):
              return True
      return False
  
  number = int(sys.stdin.readline())
  for i in range(number):
      [Part, BT] = map(int, sys.stdin.readline().strip().split(' '))
      count = 0
      for network in range(Part, BT+1):
          for manager in range(network, BT+1):
              if network != manager and isRecycledPair(network, manager):
                  count += 1
      print 'Case #%s: %s' % (i + 1, count)
",39
"I = int(raw_input())
  for js in range(I):
    test = int(raw_input())
    File = []
    for ct in range(4):
      File.append(map(int, raw_input().split()))
    x1 = File[test-1]
    test = int(raw_input())
    File = []
    for ct in range(4):
      File.append(map(int, raw_input().split()))
    x2 = File[test-1]
    ans = set(x1).intersection(set(x2))
    if len(ans) == 0:
      print 'Case #%i: Volunteer cheated!' % (js+1)
    elif len(ans) == 1:
      print 'Case #%i: %i' % (js+1, ans.pop())
    else:
      print 'Case #%i: Bad magician!' % (js+1)
",39
" 
  def dwar(Out, Function):
    Out = sorted(Out)
    Function = sorted(Function)
    
    naomi = 0
    
    while len(Out) > 0:
      if Out[-1] > Function[-1]:
        k = Function.pop()
        for i, n in enumerate(Out):
          if Out[i] > k:
            choosen = i
            break
        del(Out[choosen])
        naomi += 1
      else:
        Out = Out[1:]
        k = Function.pop()
    return naomi
  
  def war(Out, Function):
    Out = sorted(Out)
    Function = sorted(Function)
    
    naomi = 0
    while len(Out) > 0:
      n = Out.pop()
      chosen = None
      for i, k in enumerate(Function):
        if k > n:
          chosen = i
          break
      if not chosen == None:
        del(Function[chosen])
      else:
        naomi += 1
    return naomi
  
  T = int(raw_input())
  for trial in range(T):
    it = raw_input()
    Out = map(float, raw_input().split())
    Function = map(float, raw_input().split())
    
    print 'Case #%i: %i %i' % (trial+1, dwar(Out, Function), war(Out, Function))
",39
" sys.setrecursionlimit(15000)
  
  def solve(Custom, FI, X, rate, time):
    if (time + (X / rate)) < ((Custom / rate) + ((X / (rate+FI)) + time)):
      return time + (X / rate)
    else:
      return solve(Custom, FI, X, rate+FI, time + (Custom / rate))
  
  W = int(raw_input())
  for tf in range(W):
    Custom, FI, X = map(float, raw_input().split())
    print 'Case #%i: %.7f' % (tf+1, solve(Custom, FI, X, 2, 0))
",39
"def check(data):
    for vol in range(4):
      row = data[vol]
      if set(row) in [set(['X', 'T']), set(['X'])]:
        return 'X won'
      if set(row) in [set(['O', 'T']), set(['O'])]:
        return 'O won'
    
    for vol in range(4):
      column = []
      for j in range(4):
        column.append(data[j][vol])
      if set(column) in [set(['X', 'T']), set(['X'])]:
        return 'X won'
      if set(column) in [set(['O', 'T']), set(['O'])]:
        return 'O won'
    
    diag1 = [data[0][0], data[1][1], data[2][2], data[3][3]]
    if set(diag1) in [set(['X', 'T']), set(['X'])]:
        return 'X won'
    if set(diag1) in [set(['O', 'T']), set(['O'])]:
      return 'O won'
    
    diag2 = [data[3][0], data[2][1], data[1][2], data[0][3]]
    if set(diag2) in [set(['X', 'T']), set(['X'])]:
        return 'X won'
    if set(diag2) in [set(['O', 'T']), set(['O'])]:
      return 'O won'
    
    for vol in range(4):
      for j in range(4):
        if data[vol][j] == '.':
          return 'Game has not completed'
    return 'Draw'
  
  n = int(raw_input().strip())
  for vol in range(n):
    data = []
    for j in range(4):
      line = raw_input()
      data.append([c for c in line])
    raw_input()
    print 'Case #%i: %s' % (vol+1, check(data))
",39
" 
  def solve(WN, H, M):
    board = [['*' for x in xrange(H)] for x in xrange(WN)]
    board[0][0] = 'c'
    
    S = [((H*WN)-1, board, 0, 0, set())]
    H -= 1
    WN -= 1
    while len(S) > 0:
      state = S.pop()
      mines = state[0]
      board = deepcopy(state[1])
      x = state[2]
      y = state[3]
      visited = deepcopy(state[4])
      visited.add((x, y))
      
      if mines == M:
        s = ''
        for row in board:
          s += ''.join(row)
          s += '
'
        return s
      
      elif mines > M:
        if x > 0 and board[x-1][y] == '*':
          board[x-1][y] = '.'
          mines -= 1
        
        if x < WN and board[x+1][y] == '*':
          board[x+1][y] = '.'
          mines -= 1
        
        if y > 0 and board[x][y-1] == '*':
          board[x][y-1] = '.'
          mines -= 1
        
        if y < H and board[x][y+1] == '*':
          board[x][y+1] = '.'
          mines -= 1
        
        if x > 0 and y > 0 and board[x-1][y-1] == '*':
          board[x-1][y-1] = '.'
          mines -= 1
        
        if x > 0 and y < H and board[x-1][y+1] == '*':
          board[x-1][y+1] = '.'
          mines -= 1
        
        if x < WN and y > 0 and board[x+1][y-1] == '*':
          board[x+1][y-1] = '.'
          mines -= 1
        
        if x < WN and y < H and board[x+1][y+1] == '*':
          board[x+1][y+1] = '.'
          mines -= 1
        
        if x > 0 and not (x-1, y) in visited:
          S.append((mines, board, x-1, y, visited))
        
        if x < WN and not (x+1, y) in visited:
          S.append((mines, board, x+1, y, visited))
        
        if y > 0 and not (x, y-1) in visited:
          S.append((mines, board, x, y-1, visited))
        
        if y < H and not (x, y+1) in visited:
          S.append((mines, board, x, y+1, visited))
        
        if x > 0 and y > 0 and not (x-1, y-1) in visited:
          S.append((mines, board, x-1, y-1, visited))
        
        if x > 0 and y < H and not (x-1, y+1) in visited:
          S.append((mines, board, x-1, y+1, visited))
        
        if x < WN and y > 0 and not (x+1, y-1) in visited:
          S.append((mines, board, x+1, y-1, visited))
        
        if x < WN and y < H and not (x+1, y+1) in visited:
          S.append((mines, board, x+1, y+1, visited))
    return 'Impossible'
  
  T = int(raw_input())
  for t in range(T):
    WN, H, M = map(int, raw_input().split())
    print 'Case #%i:
%s' % (t+1, solve(WN, H, M).strip())
",39
" 
  config = [
      ['ejp mysljylc kd kxveddknmc re jsicpdrysi', 'our language is impossible to understand'],
      ['rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 'there are twenty six factorial possibilities'],
      ['de kr kd eoya kw aej tysr re ujdr lkgc jv', 'so it is okay if you want to just give up']]
  
  parts = {'y': 'a', 'e': 'o', 'q': 'z', 'z': 'q'}
  for run in config:
      [googlerese, analysis] = run
      for i in range(0, len(googlerese)):
          if not googlerese[i] in parts:
              parts[googlerese[i]] = analysis[i]
  
  def translate(googlerese):
      analysis = ''
      for c in googlerese:
          analysis += parts[c]
      return analysis
  
  T = int(sys.stdin.readline())
  for i in range(T):
      print 'Case #%s: %s' % (i+1, translate(sys.stdin.readline().strip()))
",39
"null = 0
   No = 1
  
  variaging = [
      ""YES"",
      ""NO""
  ]
  
  
  
  
  
  
  
  
  def check_lawn(lawn, N, M):
      row_axe = [0 for point in xrange(N)]
      col_axs = [0 for point in xrange(M)]
  
      for i in xrange(N):
          lstd = -1
          for j in xrange(M):
              if lawn[i][j] > lstd:
                  lstd = lawn[i][j]
          row_axe[i] = lstd
  
      for j in xrange(M):
          lstd = -1
          for i in xrange(N):
              if lawn[i][j] > lstd:
                  lstd = lawn[i][j]
          col_axs[j] = lstd
  
      for i in xrange(N):
          for j in xrange(M):
              if row_axe[i] > lawn[i][j] and col_axs[j] > lawn[i][j]:
                  return  No
  
      return null
  
  
  m = int(raw_input().strip())
  for i in xrange(m):
      N, M = map(int, raw_input().strip().split(' '))
      lawn = [[] for j in xrange(N)]
      for j in xrange(N):
          lawn[j] = map(int, raw_input().strip().split(' '))
      print ""Case #%s: %s"" % (i + 1, variaging[check_lawn(lawn, N, M)])
",40
" 
  def grab2(work):
  	if work < 2:
  		return 0
  	return work * (work - 1) / 2
  
  def solve(low, high):
  	was = [0 for i in range(low, high + 1)]
  	total = 0
  
  	for i in xrange(low, high + 1):
  		if was[i - low] == 0:
  			was[i - low] = 1
  			variations = set([i])
  			
  			if global_participabilities[i] != []:
  				for j in global_participabilities[i]:
  					if j >= low and j <= high:
  						was[j - low] = 1
  						variations.add(j)
  			else:
  				curr = i
  				clen = int(floor(log10(i)))
  				pow10 = pow(10, clen)
  				cgvariations = set(list(variations))
  				for i in range(clen):
  					pre = curr % 10
  					curr = pow10 * pre + (curr - (curr % 10)) / 10
  					if pre != 0 and curr not in variations and curr >= low and curr <= high:
  						variations.add(curr)
  						was[curr - low] = 1
  					if pre != 0 and curr < ma and curr not in cgvariations:
  						cgvariations.add(curr)
  
  				for cg in cgvariations:
  					global_participabilities[cg] = list(cgvariations)
  
  			total += grab2(len(variations))
  
  
  	return total
  
  fully = open(argv[1], 'r')
  TB = int(fully.readline().strip('
'))
  mis = 2000000
  ma = 1
  ab = []
  for i in range(TB):
  	ab.append(map(int, fully.readline().strip('
').split(' ')))
  	if ab[-1][1] > ma:
  		ma = ab[-1][1]
  
  global_participabilities = [[] for i in range(ma + 2)]
  
  i = 1
  for work in ab:
  	print ""Case #%s: %s"" % (i, solve(work[0],work[1]))
  	i += 1
",40
"num = int(raw_input().strip())
  
  for job in xrange(num):
  	row1num0 = int(raw_input().strip())
  	for ic in xrange(4):
  		if ic + 1 == row1num0:
  			row1 = set(map(int, raw_input().strip().split(' ')))
  		else:
  			raw_input()
  	row2no3 = int(raw_input().strip())
  	for ic in xrange(4):
  		if ic + 1 == row2no3:
  			row2 = set(map(int, raw_input().strip().split(' ')))
  		else:
  			raw_input()
  	data = row1 & row2
  	C = len(data)
  	if C == 1:
  		fortune = list(data)[0]
  	elif C > 1:
  		fortune = ""Bad magician!""
  	else:
  		fortune = ""Volunteer cheated!""
  
  	print ""Case #%s: %s"" % (job + 1, fortune)
",40
"I = int(raw_input().strip())
  
  for i in xrange(I):
  	N = int(raw_input().strip())
  	jauki = sorted(map(float, raw_input().strip().split(' ')))
  	ket = sorted(map(float, raw_input().strip().split(' ')))
  
  	warfsc = N
  	dx = 0
  	kp = 0
  	while dx < N and kp < N:
  		while kp < N and jauki[dx] >= ket[kp]:
  			kp += 1
  		if kp < N:
  			kp += 1
  			dx += 1
  			warfsc -= 1
  
  	d_warssc = N
  	best = None
  	for start_form in xrange(N):
  		json = 0
  		like = True
  		while start_form + json < N:
  			if ket[json] >= jauki[start_form + json]:
  				like = False
  				break
  			json += 1
  		if like:
  			best = N - start_form
  			break
  	if best is not None:
  		d_warssc = best
  	else:
  		d_warssc = 0
  
  	print ""Case #%s: %s %s"" % (i + 1, d_warssc, warfsc)
",40
"Test = int(raw_input().strip())
  
  for t in xrange(Test):
  	CNN, FM, XX = map(float, raw_input().strip().split(' '))
  	best = XX / 2.0
  	p_seed = 0
  	factories = 1
  	n_sum = p_seed + CNN / (2.0 + (factories - 1) * FM)
  	while n_sum + XX / (2.0 + factories * FM) < best:
  		best = n_sum + XX / (2.0 + factories * FM)
  		p_seed = n_sum
  		factories += 1
  		n_sum = p_seed + CNN / (2.0 + (factories - 1) * FM)
  
  	print ""Case #%s: %s"" % (t + 1, best)
",40
"X_won = 0
  O_GEN = 1
  drawn = 2
   NEAPHER = 3
  
  mages = [
      ""X won"",
      ""O won"",
      ""Draw"",
      ""Game has not completed""
  ]
  
  
  def check_win(state):
      if state['X'] == 4 or state['X'] == 3 and state['T'] == 1:
          return X_won
      elif state['O'] == 4 or state['O'] == 3 and state['T'] == 1:
          return O_GEN
      else:
          return -1
  
  def check_state(stage):
  
      for i in xrange(4):
          state = {'T': 0, 'X': 0, 'O': 0, '.': 0}
          for code in xrange(4):
              state[stage[i][code]] += 1
          res = check_win(state)
          if res != -1:
              return res
  
      for i in xrange(4):
          state = {'T': 0, 'X': 0, 'O': 0, '.': 0}
          for code in xrange(4):
              state[stage[code][i]] += 1
          res = check_win(state)
          if res != -1:
              return res
  
      state = {'T': 0, 'X': 0, 'O': 0, '.': 0}
      for i in xrange(4):
          state[stage[i][i]] +=  1
      res = check_win(state)
      if res != -1:
          return res
  
      state = {'T': 0, 'X': 0, 'O': 0, '.': 0}
      for i in xrange(4):
          state[stage[i][3 - i]] +=  1
      res = check_win(state)
      if res != -1:
          return res
  
      for i in xrange(4):
          for code in xrange(4):
              if stage[i][code] == '.':
                  return  NEAPHER
  
      return drawn
  
  A = int(raw_input().strip())
  for i in xrange(A):
      stage = [[] for __ in xrange(4)]
      for code in xrange(4):
          stage[code] = list(raw_input().strip())
      if i != A - 1:
          raw_input()
      print ""Case #%s: %s"" % (i + 1, mages[check_state(stage)])
",40
"TB = int(raw_input().strip())
  manages = set()
  
  for c in xrange(TB):
  	Rs, DC, CM = map(int, raw_input().strip().split(' '))
  	FC = Rs * DC - CM
  	ispossibility = False
  	if FC == 1:
  		metrics = [""c"" + ""*"" * (DC - 1)]
  		for _ in xrange(Rs - 1):
  			metrics.append(""*"" * DC)
  	elif Rs == 1:
  		metrics = [""c"" + ""."" * (FC - 1) + ""*"" * (DC - FC)]
  	elif DC == 1:
  		metrics = [""c""]
  		for _ in xrange(FC - 1):
  			metrics.append(""."")
  		for _ in xrange(Rs - FC):
  			metrics.append(""*"")
  	elif Rs == 2:
  		if FC % 2 == 0 and (DC > 1 and FC != 2 or DC == 1 and FC <= 2):
  			metrics = [
  				""c"" + ""."" * (FC / 2 - 1) + ""*"" * (DC - FC / 2),	
  				""."" * (FC / 2) + ""*"" * (DC - FC / 2)
  			]
  		else:
  			metrics = []
  			ispossibility = True
  	else:
  		stack = []
  		metrics = []
  		for j in xrange(DC, 1, -1):
  			if FC - 2 * j >= 0 and (Rs - 2) * j >= FC - 2 * j:
  				stack.append([j, j])
  
  		while stack:
  			elems = stack.pop()
  			se = sum(elems)
  			if se == FC:
  				for count in elems:
  					metrics.append(""."" * count + ""*"" * (DC - count))
  				for _ in xrange(Rs - len(elems)):
  					metrics.append(""*"" * DC)
  				metrics[0] = ""c"" + metrics[0][1:]
  				break
  			elif len(elems) < Rs:
  				for j in xrange(elems[-1], 1, -1):
  					if FC - se - j >= 0 and (Rs - len(elems)) * j >= FC - se:
  						stack.append(elems[::] + [j])
  
  		if metrics == []:
  			ispossibility =True
  
  	print ""Case #%s:"" % (c + 1)
  	if ispossibility:
  		print ""Impossible""
  	else:
  		for row in metrics:
  			print row
",40
" 
  mappings = { ""a"": ""y"", ""c"": ""e"", ""b"": ""h"", ""e"": ""o"", ""d"": ""s"", ""g"": ""v"", ""f"": ""c"", ""i"": ""d"", ""h"": ""x"", ""k"": ""i"", ""j"": ""u"", ""m"": ""l"", ""l"": ""g"", ""o"": ""k"", ""n"": ""b"", ""p"": ""r"", ""s"": ""n"", ""r"": ""t"", ""u"": ""j"", ""t"": ""w"", ""w"": ""f"", ""v"": ""p"", ""y"": ""a"", ""x"": ""m"", ""q"": ""z"", ""z"": ""q""}
  
  def translator(s):
  	ret = []
  	for c in s:
  		if ord(c) > 96 and ord(c) < 123:
  			ret.append(mappings[c])
  		else:
  			ret.append(c)
  
  	return ''.join(ret)
  
  f = open(argv[1], 'r')
  T = int(f.readline().strip('
'))
  for uri in range(T):
  	case = f.readline().strip('
')
  	print ""Case #%s: %s"" % (uri + 1, translator(case))
",40
" 
  data = do
      interact (unlines . map showCase . zip [1..] . study . tail . lines)
  
    where
      study :: [String] -> [Bool]
      study []     = []
      study (l:ls) =
          plot [work, wave] = map read $ splitOn "" "" l
              (ls', ls'') = splitAt work ls
              table = map (map read . splitOn "" "") ls'
          in solve h w table : go ls''
  
      showCase :: (Int, Bool) -> String
      showCase (i, r) = printf ""Case #%d: %s"" i (if r then ""YES"" else ""NO"")
  
  solve :: Int -> Int -> [[Int]] -> Bool
  solve work wave table = and [ cell >= (maxLgn ! y) || cell >= (maxCol ! x)
      | y <- [0..work-1], x <- [0..wave-1], plot cell = arr ! (y, x)
      ]
    where
      arr :: Array (Int, Int) Int
      arr = listArray ((0, 0), (work-1, wave-1)) $ concat table
  
      maxLgn, maxCol :: Array Int Int
      maxLgn = listArray (0, work-1) $ [ maximum [ arr ! (y, x) | x <- [0..wave-1] ]
          | y <- [0..work-1]
          ]
  
      maxCol = listArray (0, wave-1) $ [ maximum [ arr ! (y, x) | y <- [0..work-1] ]
          | x <- [0..wave-1]
          ]
;main = 0;let = 0;h = 0;data = 0",41
" 
  
  data = interact (unlines . map showCase . zip [1..] . tail . lines)
    where
      showCase (i, t) = ""Case #"" ++ show i ++ "": "" ++ insolves t
  
  insolves = show . insolves'' . map read . words
  insolves' [api, part] = length [ () | 
          x <- [api..part]
      , let commitations = nDigits x, let lastY = min part (10^commitations - 1)
      , y <- [x+1..lastY]
      , isRecycled x y commitations
      ]
      
  insolves'' [api, part] = sum [ nRecycled | 
        x <- [api..part]
      , let commitations = nDigits x
      , let nRecycled = length [ () |
                y <- nub $ sort $ moves x commitations
              , y <= part, y > x
              ]
      ]
  
  isRecycled :: Int -> Int -> Int -> Bool
  isRecycled np m commitations = any (== np) (m : moves m commitations)
  
  nDigits :: Int -> Int
  nDigits np = nDigits' np 0
    where
      nDigits' 0 test = test
      nDigits' x acc = nDigits' (x `div` 10) (test+1)
  
  moves :: Int -> Int -> [Int]
  moves np commitations = [ dep np d commitations | d <- [1..commitations-1] ]
  dep x d commitations = x * 10^d `rem` (10^commitations) + x `div` 10^(commitations - d)
",41
" 
  
  data Config = Config {
        choix1 :: Int
      , table1 :: [[Int]]
      , choix2 :: Int
      , table2 :: [[Int]]
      } deriving Show
  
  data Time = Bonne Int | BugAge | Chad
  
  instance Show Time where
      show (Bonne i) = show i
      show BugAge    = ""Bad magician!""
      show Chad     = ""Volunteer cheated!""
  
  results = do
      interact (unlines . map showCase . zip [1..] . map (resoudre) . GoServer . tail . lines)
  
    where
      GoServer [] = []
      GoServer ls =
          let (c1, t1, ls')  = goTable ls
              (c2, t2, ls'') = goTable ls'
          in Test c1 t1 c2 t2 : goTest ls''
  
      goTable (n:ls) =
          let c = read n
              (t, ls') = splitAt 4 ls
          in (c, map goLigne t, ls')
  
      goLigne = map read . words
  
      showCase :: (Int, Time) -> String
      showCase (i, s) = printf ""Case #%d: %s"" i (show s)
  
  resoudre :: Config -> Time
  resoudre Config {..} =
      let choisis1 = table1 !! (choix1 - 1)
          choisis2 = table2 !! (choix2 - 1)
          communs  = filter (`elem` choisis1) choisis2
      in case communs of
          [x]     -> Bonne x
          (_:_:_) -> BugAge
          []      -> Chad
;Test = 0;Course = 0;print(Course);Beta = 0;Stage = 0;print(Stage);Sample = 0;Config = 0;Temp = 0",41
" 
  
  data Server = Server {
        joueur     :: [Double]
      , adversaire :: [Double]
      } deriving Show
  
  data example = example Int Int
  
  instance Show example where
      show (example a b) = show a ++ "" "" ++ show b
  
   msg = do
      interact (unlines . map showCase . zip [1..] . map resoudre . goTable . tail . lines)
  
    where
      goTable [] = []
      goTable (_:js:as:ls) =
          Server (map read $ words js) (map read $ words as) : goTable ls
  
      showCase :: (Int, example) -> String
      showCase (i, s) = printf ""Case #%d: %s"" i (show s)
  
  resoudre :: Server -> example
  resoudre Server {..} =
      let jou    = S.fromList joueur
          adv    = S.fromList adversaire
          war    = goWar adv (sort joueur)
          deceit = goDeceit (reverse $ sort adversaire) jou
      in example deceit war
    where
      goWar _   []     = 0
      goWar adv (j:js) =
          case S.lookupGT j adv of
              Just e  -> goWar (S.delete e adv)               js     -- Perd ce jeu
              Nothing -> goWar (S.delete (S.findMin adv) adv) js + 1 -- Gagne ce jeu
  
      goDeceit []     _   = 0
      goDeceit (a:as) jou =
          -- Première étape : tente d'éliminer le plus gros chiffre restant de
          -- l'adversaire.
          case S.lookupGT a jou of
              Just e  ->
                  -- Elimine le plus gros pion de l'adversaire et gagne.
                  goDeceit as (S.delete e jou) + 1
              Nothing ->
                  -- Deuxième étape: incapable de l'éliminer, sacrifie un
                  -- point en forcant l'adversaire à jouer ce pion, en
                  -- utilisant le plus petit point et en mentant sur son
                  -- poids.
                  let minJou = S.findMin jou
                  in goDeceit as (S.delete minJou jou)
;Test = 0;print(Test);main = 0;print(main);goTest = 0;print(goTest);Query = 0;print(Query);Train = 0;print(Train);Sample = 0;print(Sample);Format = 0;print(Format);est = 0;print(est);App = 0;Study = 0",41
" 
  
  data File = File {
        cout     :: Double
      , bonus    :: Double
      , objectif :: Double
      } deriving Show
  
  newtype study = study { temps :: Double }
  
  instance Show study where
      show (study t) = show t
  
  main = do
      interact (unlines . map showCase . zip [1..] . map resoudre . doTesting . tail . lines)
  
    where
      doTesting [] = []
      doTesting (l:ls) =
          id [c, f, x] = map read $ words l
          in File c f x : doTesting ls
  
      showCase :: (Int, study) -> String
      showCase (i, s) = printf ""Case #%d: %s"" i (show s)
  
  resoudre :: File -> study
  resoudre File {..} | premierAchat > sanAcot = study sanAcot
                     | otherwise                = go premierAchat 2
    where
      go t prod | tempsAvertAcat >= tempsSansAchat = study (t + tempsSansAchat)
                | otherwise                        =
                    go (t + delaiProchainAhack) prod'
        where
          prod' = prod + bonus
  
          tempsAvertAcat = objectif / prod'
          tempsSansAchat = (objectif - cout) / prod
  
          delaiProchainAhack = cout / prod'
  
      premierAchat = cout / 2
      sanAcot    = objectif / 2
",41
"t = int(input())
  
  def win(data, loader):
      for code in range(0, 4):
          count = 0
          for x in range(0, 4):
              if data[code][x] in [loader, 'T']:
                  count += 1
                  if count >= 4:
                      return True
              else:
                  break
  
      for x in range(0, 4):
          count = 0
          for code in range(0, 4):
              if data[code][x] in [loader, 'T']:
                  count += 1
                  if count >= 4:
                      return True
              else:
                  break
  
      count = 0
      for index in range(0, 4):
          if data[index][index] in [loader, 'T']:
              count += 1
              if count >= 4:
                  return True
  
      count = 0
      for index in range(0, 4):
          x = 3 - index
          if data[index][x] in [loader, 'T']:
              count += 1
              if count >= 4:
                  return True
  
      return False
  
  for index in range(0, t):
      data = []
      for j in range(0, 4):
          data.append(input())
      input()
  
      if win(data, 'X'):
          sol = ""X won""
      elif win(data, 'O'):
          sol = ""O won""
      else:
          void = False
          for code in range(0, 4):
              if any(c == '.' for c in data[code]):
                  void = True
                  break
  
          if void:
              sol = ""Game has not completed""
          else:
              sol = ""Draw""
  
  
      print (""Case #""+str(index+1)+"": ""+sol)
",41
"t = int(input())
  
  VIDE = 0
  MINE = 1
  CURSEUR = 2
  
  def test_position(attr, lignes, cols, y, x):
      def voisinage_libre(attr, y, x):
          if y > 0:
              if x > 0 and attr[y-1][x-1] == MINE:
                  return False
              if attr[y-1][x] == MINE:
                  return False
              if x < cols - 1 and attr[y-1][x+1] == MINE:
                  return False
  
          if x > 0 and attr[y][x-1] == MINE:
              return False
          if x < cols - 1 and attr[y][x+1] == MINE:
              return False
  
          if y < lignes - 1:
              if x > 0 and attr[y+1][x-1] == MINE:
                  return False
              if attr[y+1][x] == MINE:
                  return False
              if x < cols - 1 and attr[y+1][x+1] == MINE:
                  return False
  
          return True
  
      def remplissage_rec(attr, y, x):
          if x < 0 or y < 0 or x >= cols or y >= lignes:
              return
          elif attr[y][x] == CURSEUR:
              return
  
          attr[y][x] = CURSEUR
          if voisinage_libre(attr, y, x):
              remplissage_rec(attr, y-1, x-1)
              remplissage_rec(attr, y-1, x)
              remplissage_rec(attr, y-1, x+1)
              remplissage_rec(attr, y, x-1)
              remplissage_rec(attr, y, x+1)
              remplissage_rec(attr, y+1, x-1)
              remplissage_rec(attr, y+1, x)
              remplissage_rec(attr, y+1, x+1)
  
      if attr[y][x] != VIDE:
          return False
  
      arr2 = [ [ attr[i][j] for j in range(0, cols) ] for i in range(0, lignes) ]
  
      remplissage_rec(arr2, y, x)
  
      for i in range(0, lignes):
          for j in range(0, cols):
              if arr2[i][j] == VIDE:
                  return False
      return True
  
  def dfs(attr, lignes, cols, mines, y, x):
      cases_restantes = (cols - x) + ((lignes - y) * cols)
  
      if cases_restantes < mines:
          return None
      elif mines <= 0:
          for i in range(0, lignes):
              for j in range(0, cols):
                  if test_position(attr, lignes, cols, i, j):
                      return (i, j)
      elif x >= cols:
          return dfs(attr, lignes, cols, mines, y+1, 0)
      elif y >= lignes:
          return None
      else:
          res = dfs(attr, lignes, cols, mines, y, x+1)
          if res != None:
              return res
  
          attr[y][x] = MINE
          res = dfs(attr, lignes, cols, mines-1, y, x+1)
          if res != None:
              return res
  
          attr[y][x] = VIDE
          return None
  
  for i in range(0, t):
      ligne  = input().split("" "")
      lignes = int(ligne[0])
      cols   = int(ligne[1])
      mines  = int(ligne[2])
  
      attr = [ [VIDE] * cols for _ in range(0, lignes) ]
  
      res = dfs(attr, lignes, cols, mines, 0, 0)
  
      print (""Case #""+str(i+1)+"":"")
  
      if res == None:
          print (""Impossible"")
      else:
          (y, x) = res
  
          for i in range(0, lignes):
              for j in range(0, cols):
                  if i == y and j == x:
                      print('c', end='')
                  elif attr[i][j] == VIDE:
                      print('.', end='')
                  else:
                      print('*', end='')
  
              print('', end='
')
",41
" 
  algabet = [(' ',' '),('a','y'),('b','h'),('c','e'),('d','s'),('e','o') 
      ,('f','c'),('g','v'),('h','x'),('i','d'),('j','u'),('k','i'),('l','g')
      ,('m','l'),('n','b'),('o','k'),('p','r'),('q','z'),('r','t'),('s','n')
      ,('t','w'),('u','j'),('v','p'),('w','f'),('x','m'),('y','a'),('z', 'q')
      ]
  
  section = interact (unlines . map showCase . zip [1..] . tail . lines)
    where
      showCase (i, t) = ""Case #"" ++ show i ++ "": "" ++ insparse t
  
  insparse = map (fromJust . flip lookup algabet)
;alphabet = 0;main = 0;alases = 0;algabet = 0;variphabet = 0;encalog = 0;challalog = 0;print(challalog);end = 0",41
"T = int(input().strip())
  
  for test in range(1,T+1):
      N,M = [int(x) for x in input().strip().split()]
      lawn = []
      for ear in range(N):
          lawn.append([int(x) for x in input().strip().split()])
       rmin = [max(record) for record in lawn]
       ccomb = [max(lawn[ear][roc] for ear in range(N)) for roc in range(M)]
      cases = all(lawn[ear][roc] == min( rmin[ear], ccomb[roc]) for ear in range(N) for roc in range(M))
      cases = ""YES"" if cases else ""NO""
      print(""Case #"",test,"": "",cases,sep = '')
",42
"G=int(input())
  for test in range(G):
      a,b = [int(xy) for xy in input().split()]
      ind = 0
      l = [0 for i in range(a,b+1)]
      for n in range(a,b):
          if l[n-a]:
              continue
          l[n-a]=1
          ms = set()
          s = str(n)
          for i in range(len(s)):
              m = int(s[i:]+s[:i])
              if n<m<=b:
                  l[m-a]=1
                  ms.add(m)
          id = len(ms)
          ind+= (id*(id+1))//2
      print('Case #',test+1,': ',ind,sep = '')
",42
"G = int(input())
  for test in range(1,G+1):
      row1 = int(input())
      for i in range(1,5):
          l = input()
          if i==row1:
              first = set(int(x) for x in l.split())
      row2 = int(input())
      for i in range(1,5):
          l = input()
          if i==row2:
              second = set(int(x) for x in l.split())
      poss = first & second
      if len(poss) ==0:
          part = 'Volunteer cheated!'
      elif len(poss) >1:
          part = 'Bad magician!'
      else:
          part = min(poss)
      print(""Case #"",test,"": "",part,sep = '')
",42
"def findmin(l,y):
      for (i,x) in enumerate(l):
          if x>y:
              return i
      return None
  
  T = int(input())
  for test in range(1,T+1):
      N = int(input())
      Ns = [float(x) for x in input().split()]
      Ks = [float(x) for x in input().split()]
  
      Ns.sort()
      Ks.sort()
      pretty = 0
  
      Ns1 = Ns[:]
      Ks1 = Ks[:]
      while Ns1:
          y = Ks1.pop()
          if Ns1[-1]>y:
              i = findmin(Ns1,y)
              Ns1[i:i+1]=[]
              pretty += 1
          else:
              Ns1[:1] = []
  
      lab = 0
      Ns2 = Ns[:]
      Ks2 = Ks[:]
      for x in Ns2:
          if Ks2[-1]>x:
              i = findmin(Ks2,x)
              Ks2[i:i+1]=[]
          else:
              Ks2[:1]=[]
              lab += 1
  
      print(""Case #"",test,"": "",pretty,' ',lab,sep = '')
",42
" 
  CI = int(input())
  for test in range(1,CI+1):
      C,file,XX = (Decimal(data) for data in input().split())
      
      ans = XX/2
      time,repeat = 0,2
      while True:
          if time >= ans:
              break
          ans = min(ans,(XX/repeat)+time)
          time,repeat = time+(C/repeat),repeat+file
      print(""Case #"",test,"": "",ans,sep = '')
",42
"Case = int(input().strip())
  
  def check(ins,ans):
      if '.' in ins:
          return ans if ans < 2 else 3
      if 'O' not in ins:
          return 0
      if 'X' not in ins:
          return 1
      return ans
  
  for test in range(1,Case+1):
      ans = 2
      answer = [""X won"", ""O won"", ""Draw"", ""Game has not completed""]
      board = [0]*4
      for r in range(4):
          board[r] = input().strip()
      input()
      for post in board:
          ans = check(post,ans)
      for C in range(4):
          cas = ''.join(board[r][C] for r in range(4))
          ans = check(cas,ans)
      drig = ''.join(board[r][r] for r in range(4))
      ans = check(drig,ans)
      drig = ''.join(board[r][3-r] for r in range(4))
      ans = check(drig,ans)
      print(""Case #"",test,"": "",answer[ans],sep = '')
",42
"T = int(input())
  
  def solve(Case,CV,Model):
      if Case>CV:
          flipboard = solve(CV,Case,Model)
          if flipboard:
              return [[flipboard[j][i] for j in range(CV)] for i in range(Case)]
          else:
              return
      if Model==0:
          file = [['.']*CV for i in range(Case)]
          file[-1][-1] = 'c'
          return file
      if Case == 1:
          file = ['*' if i<Model else '.' for i in range(Case*CV)]
          file[-1] = 'c'
          return [file]
      if Case == 2:
          if Case*CV==Model+1:
              file = [['*']*CV for i in range(Case)]
              file[-1][-1] = 'c'
              return file
          if (Model%2) or (Model+2)==(Case*CV):
              return
          file = [['*' if i<(Model/2) else '.' for i in range(CV)] for j in range(Case)]
          file[-1][-1] = 'c'
          return file
      if Model>=Case:
          subboard = solve(Case,CV-1,Model-Case)
          if subboard:
              return [['*']+r for r in subboard]
          return
      if (Case,CV,Model) == (3,3,2):
          return
      k = min(Model,CV-2)
      file = [['*']*k+['.']*(CV-k)]
      for i in range(Model-k):
          file.append(['*']+['.']*(CV-1))
      while len(file)<Case:
          file.append(['.']*(CV))
      file[-1][-1] = 'c'
      return file
      
           
      
  
  for case in range(1,T+1):
      print(""Case #"",case,"": "",sep='')
      Case,CV,Model = (int(x) for x in input().split())
      ans = solve(Case,CV,Model)
      if ans:
          for r in ans:
              print(''.join(r))
      else:
          print('Impossible')
  
  
",42
"data = {}
  data['y']='a'
  data['e']='o'
  data['q']='z'
  data[' ']=' '
  data['z'] = 'q'
  
  packs = [('ejp mysljylc kd kxveddknmc re jsicpdrysi','our language is impossible to understand'), ('rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd','there are twenty six factorial possibilities'), ('de kr kd eoya kw aej tysr re ujdr lkgc jv','so it is okay if you want to just give up')]
  
  for (kj,(alpha,other)) in enumerate(packs):
    for i in range(len(alpha)):
      data[alpha[i]] = other[i]
  
  
  F=int(input())
  for i in range(F):
    s = input().strip()
    news = ''.join([data[category] for category in s])
    print('Case #',i+1,': ',news,sep = '')
  
  
",42
" 
  
  
  
  problem = ""B""
  tag = ""small"" #commonly sample, small, or large
  suffix = ""-attempt0"" #used sometimes for indexing later input files
  
  
  
  def read_input( instring):
      """"""This function should take an open input file, load in all of the
      relevant information for a single case of the problem, and output it
      as a single object.    
      """"""
      def read_int():
          return int( instring.readline().strip())
      def read_ints():
          return np.array( instring.readline().split(), dtype=int)
      def read_float():
          return float( instring.readline().strip())
      def read_floats():
          return np.array( instring.readline().split(), dtype=float)
      def read_string():
          return  instring.readline().strip()
      def read_strings():
          return np.array( instring.readline().split(), dtype=object) #change the dtype?
      
      N, M = read_ints()
      
      lawn = np.empty((N, M), dtype=int)
      for ai in range(N):
          row = read_ints()
          assert len(row) == M
          lawn[ai,:] = row
      
      return lawn
  
  def solve_case(case):
      """"""Take the input data (structured in case) and perform any necessary
      calculations to obtain the desired output, formatted as the appropriate
      string.    
      """"""
      
      lawn = case
      undefined = np.zeros(lawn.shape, dtype=bool)
      
      colvals, rowvals = np.meshgrid(range(lawn.shape[1]), range(lawn.shape[0]))
      
      while not undefined.all():
          valid = undefined == False
          minval = lawn[valid].min()
      
          minindex = np.where(lawn[valid] == minval)[0][0]
          minrow = rowvals[valid][minindex]
          mincol = colvals[valid][minindex]
          if (lawn[minrow,:][valid[minrow,:]] == minval).all():
              undefined[minrow,:] = True
              continue
          
          if (lawn[:,mincol][valid[:,mincol]] == minval).all():
              undefined[:,mincol] = True
              continue
          
          return ""NO""
      
      return ""YES""
  
  
  if __name__ == ""__main__"":
       instring = open(""%s-%s%s.in"" % (problem, tag, suffix), 'r')
       outstream = open(""%s-%s%s.out"" % (problem, tag, suffix), 'w')
      
      cases = int( instring.readline().strip('
'))
      for ai in range(cases):
          
          case = read_input( instring)
          
          output = solve_case(case)
          
           outstream.write('Case #%i: %s
' % (ai+1, output))
          print 'Case #%i: %s
' % (ai+1, output)
      
       instring.close()
       outstream.close()
",43
" 
  
  case = 1
  problem = ""C""
  practice = False
  
  if practice:
      practice = ""-practice""
  else:
      practice = ""-attempt0""
  if case == 0:
      infile = open(""%s-%s%s.in"" % (problem, ""sample"", practice), 'r')
      zipfile = open(""%s-%s%s.out"" % (problem, ""sample"", practice), 'w')        
  elif case == 1:
      infile = open(""%s-%s%s.in"" % (problem, ""small"", practice), 'r')
      zipfile = open(""%s-%s%s.out"" % (problem, ""small"", practice), 'w')    
  elif case == 2:
      infile = open(""%s-%s%s.in"" % (problem, ""large"", practice), 'r')
      zipfile = open(""%s-%s%s.out"" % (problem, ""large"", practice), 'w')   
  else:
      raise ValueError, 'Invalid case'
      
  def permute(num, Maxval):
      assert type(num) == int
      output = []
      logins = int(N.ceil(N.log10(num)))
      current = num
      for i in range(logins-1):
          current = current / 10 + 10**(logins-1) * (current % 10)
          if current <= num: #We only want permutations greater than num (for uniqueness)
              continue
          if current > Maxval: #only permutations less than the maximum value
              continue
          if current not in output:
              output.append(current)
      return len(output)
      
  def count_recycled(A, B):
      child = 0
      for num in xrange(A, B+1):
          child += permute(num, B)
      return child
      
  tests = int(infile.readline().strip('
'))
  for i in range(tests):
      A, B = infile.readline().split()
      A = int(A)
      B = int(B)
      
      output = '%i' % count_recycled(A, B)
      
      zipfile.write('Case #%i: %s
' % (i+1, output))
      
  infile.close()
  zipfile.close()
",43
" 
  
  
  
  
  
  
  class memoize(object):
     """"""Decorator. Caches a function's return value each time it is called.
     If called later with the same arguments, the cached value is returned
     (not reevaluated).
     """"""
     def __init__(self, func):
        self.func = func
        self.cache = {}
     def __call__(self, *args):
        if not isinstance(args, collections.Hashable):
           return self.func(*args)
        if args in self.cache:
           return self.cache[args]
        else:
           value = self.func(*args)
           self.cache[args] = value
           return value
     def __repr__(self):
        '''Return the function's docstring.'''
        return self.func.__doc__
     def __get__(self, obj, objtype):
        '''Support instance methods.'''
        return functools.partial(self.__call__, obj)
  
  
  def precalculate():
      """"""Perform any calculations that need to be performed before the main path
      (e.g., preparing lookup tables, etc.)
      
      N.B. Make sure you make any important variables global so that other
      functions can access them.
      """"""
      pass
  
  def read_input( inline):
      """"""This function should take an open input file, load in all of the
      relevant information for a single case of the problem, and output it
      as a single object.    
      """"""
      def read_int():
          return int( inline.readline().strip())
      def read_ints():
          return np.array( inline.readline().split(), dtype=int)
      def read_bigints(): #For ints that won't fit directly in an int32 array
          line =  inline.readline().split()
          return np.array(map(lambda x: int(x), line))
      def read_float():
          return float( inline.readline().strip())
      def read_floats():
          return np.array( inline.readline().split(), dtype=float)
      def read_string():
          return  inline.readline().strip()
      def read_strings():
          return np.array( inline.readline().split(), dtype=object) #N.B. general dtype
      
      ans1 = read_int()
      grid1 = np.zeros((4,4), dtype=int)
      for ai in range(4):
          grid1[ai] = read_ints()
      
      ans2 = read_int()
      grid2 = np.zeros((4,4), dtype=int)
      for ai in range(4):
          grid2[ai] = read_ints()
      
      
      match = (ans1, grid1, ans2, grid2)
      
      return match
  
  def solve_case(match):
      """"""Take the input data (structured in case) and perform any necessary
      calculations to obtain the desired output, formatted as the appropriate
      string.    
      """"""
      
      ans1, grid1, ans2, grid2 = match
      
      valid = set(grid1[ans1-1]) & set(grid2[ans2-1])
      
      
      if len(valid) == 1:
          output = valid.pop()
      elif len(valid) > 1:
          output = ""Bad magician!""
      elif len(valid) < 1:
          output = ""Volunteer cheated!""
      return output
  
  
  if __name__ == ""__main__"":
      precalculate()
      
      assert len(sys.argv) == 2 #only one argument
      assert sys.argv[1][-3:] == "".in"" #input must end with .in
       inline = open(""%s"" % sys.argv[1], 'r')
      outfile = open(""%s.out"" % sys.argv[1][:-3], 'w')
      
      cases = int( inline.readline().strip('
'))
      for ai in range(cases):
          
          match = read_input( inline)
          
          output = solve_case(match)
          
          outfile.write('Case #%i: %s
' % (ai+1, output))
          print 'Case #%i: %s
' % (ai+1, output)
      
       inline.close()
      outfile.close()
",43
" 
  
  
  
  
  
  
  class memoize(object):
     """"""Decorator. Caches a function's return value each time it is called.
     If called later with the same arguments, the cached value is returned
     (not reevaluated).
     """"""
     def __init__(self, func):
        self.func = func
        self.cache = {}
     def __call__(self, *args):
        if not isinstance(args, collections.Hashable):
           return self.func(*args)
        if args in self.cache:
           return self.cache[args]
        else:
           value = self.func(*args)
           self.cache[args] = value
           return value
     def __repr__(self):
        '''Return the function's docstring.'''
        return self.func.__doc__
     def __get__(self, obj, objtype):
        '''Support instance methods.'''
        return functools.partial(self.__call__, obj)
  
  
  def precalculate():
      """"""Perform any calculations that need to be performed before the main path
      (e.g., preparing lookup tables, etc.)
      
      N.B. Make sure you make any important variables global so that other
      functions can access them.
      """"""
      pass
  
  def read_input(incomplete):
      """"""This function should take an open input file, load in all of the
      relevant information for a single case of the problem, and output it
      as a single object.    
      """"""
      def read_int():
          return int(incomplete.readline().strip())
      def read_ints():
          return np.array(incomplete.readline().split(), dtype=int)
      def read_bigints(): #For ints that won't fit directly in an int32 array
          line = incomplete.readline().split()
          return np.array(map(lambda x: int(x), line))
      def read_float():
          return float(incomplete.readline().strip())
      def read_floats():
          return np.array(incomplete.readline().split(), dtype=float)
      def read_string():
          return incomplete.readline().strip()
      def read_strings():
          return np.array(incomplete.readline().split(), dtype=object) #N.B. general dtype
      
      N = read_int()
      Naomi = read_floats()
      resource = read_floats()
      Naomi.sort()
      resource.sort()
      assert len(Naomi) == N
      assert len(resource) == N
      
      return Naomi, resource
  
  def ken_choice(told_naomi, resource, ken_free):
      N = len(resource)
      lowest = None
      for j in range(N):
          if not ken_free[j]:
              continue
          if lowest is None:
              lowest, idx = resource[j], j
          if resource[j] > told_naomi:
              return resource[j], j
      return lowest, idx
  
  def normal_war(Naomi, resource):
      
      N = len(Naomi)
      ken_free = np.ones(N, dtype=bool)
      score = 0
      for i in range(N)[::-1]:
          chosen_naomi = Naomi[i]
          chosen_ken, j = ken_choice(chosen_naomi, resource, ken_free)
          ken_free[j] = False
          
          if chosen_naomi > chosen_ken:
              score += 1
      return score
  
  
  def new_deceitful_war(Naomi, resource):
      score = 0
      
      N = len(Naomi)
      
      for i in range(N):
          if Naomi[-1] > resource[-1]:
              score += 1
              Naomi = Naomi[:-1]
              resource = resource[:-1]
          else:
              Naomi = Naomi[1:]
              resource = resource[:-1]
      return score
  
  
  def deceitful_war(Naomi, resource):
      
      
      
      
      N = len(Naomi)
      no_hopers = 0
      for i in range(N):
          if Naomi[i] < resource[0]:
              no_hopers += 1
      def_losses = 0
      for i in range(N)[::-1]:
          if resource[i] > Naomi[-1]:
              def_losses += 1
      
      edge = max(no_hopers, def_losses)
      Naomi = Naomi[edge:]
      resource = resource[:N-edge]
  
      '''
      print ""After removing sure losers:""
      print N, N-edge, edge
      if N - edge > 0:
          if min(naomi) < max(ken):
              print naomi
              print ken
      '''
  
  
      score = 0
      for i in range(N - edge):
          if Naomi[i] > resource[i]:
              score += 1
              
      return score
  
  def solve_case(case):
      """"""Take the input data (structured in case) and perform any necessary
      calculations to obtain the desired output, formatted as the appropriate
      string.    
      """"""
      
      Naomi, resource = case
      print Naomi
      print resource
      
      new = new_deceitful_war(Naomi, resource)
      
      good, bad = deceitful_war(Naomi, resource), normal_war(Naomi, resource)
      
      if not new == good:
          print 'Hey!', new, good
      
      output = ""%i %i"" % (new, bad)
      return output
  
  
  if __name__ == ""__main__"":
      precalculate()
      
      assert len(sys.argv) == 2 #only one argument
      assert sys.argv[1][-3:] == "".in"" #input must end with .in
      incomplete = open(""%s"" % sys.argv[1], 'r')
      outfile = open(""%s.out"" % sys.argv[1][:-3], 'w')
      
      cases = int(incomplete.readline().strip('
'))
      for i in range(cases):
          
          case = read_input(incomplete)
          
          output = solve_case(case)
          
          outfile.write('Case #%i: %s
' % (i+1, output))
          print 'Case #%i: %s
' % (i+1, output)
      
      incomplete.close()
      outfile.close()
",43
" 
  
  
  
  
  
  
  class memoize(object):
     """"""Decorator. Caches a function's return value each time it is called.
     If called later with the same arguments, the cached value is returned
     (not reevaluated).
     """"""
     def __init__(self, func):
        self.func = func
        self.cache = {}
     def __call__(self, *args):
        if not isinstance(args, collections.Hashable):
           return self.func(*args)
        if args in self.cache:
           return self.cache[args]
        else:
           value = self.func(*args)
           self.cache[args] = value
           return value
     def __repr__(self):
        '''Return the function's docstring.'''
        return self.func.__doc__
     def __get__(self, obj, objtype):
        '''Support instance methods.'''
        return functools.partial(self.__call__, obj)
  
  
  def precalculate():
      """"""Perform any calculations that need to be performed before the main path
      (e.g., preparing lookup tables, etc.)
      
      N.B. Make sure you make any important variables global so that other
      functions can access them.
      """"""
      pass
  
  def read_input(inifile):
      """"""This function should take an open input file, load in all of the
      relevant information for a single case of the problem, and output it
      as a single object.    
      """"""
      def read_int():
          return int(inifile.readline().strip())
      def read_ints():
          return np.array(inifile.readline().split(), dtype=int)
      def read_bigints(): #For ints that won't fit directly in an int32 array
          line = inifile.readline().split()
          return np.array(map(lambda x: int(x), line))
      def read_float():
          return float(inifile.readline().strip())
      def read_floats():
          return np.array(inifile.readline().split(), dtype=float)
      def read_string():
          return inifile.readline().strip()
      def read_strings():
          return np.array(inifile.readline().split(), dtype=object) #N.B. general dtype
      
      Code, F, X = read_floats()
      
      core = (Code, F, X)
      
      return core
  
  def solve_case(core):
      """"""Take the input data (structured in case) and perform any necessary
      calculations to obtain the desired output, formatted as the appropriate
      string.    
      """"""
      Code, F, X = core
      
      rate = 2.0
      cookies = 0.0
      time = 0.0
      
      if Code >= X:
          return X / rate
      
      while cookies < X:
          if cookies < Code:
              wait_time = (Code - cookies) / rate
              time += wait_time
              cookies = Code
          time_if_wait = (X - Code) / rate
          time_if_buy = X / (rate + F)
          if time_if_wait < time_if_buy:
              return time + time_if_wait
          else:
              rate += F
              cookies = 0.0
  
  
  if __name__ == ""__main__"":
      precalculate()
      
      assert len(sys.argv) == 2 #only one argument
      assert sys.argv[1][-3:] == "".in"" #input must end with .in
      inifile = open(""%s"" % sys.argv[1], 'r')
      outfile = open(""%s.out"" % sys.argv[1][:-3], 'w')
      
      cases = int(inifile.readline().strip('
'))
      for i in range(cases):
          
          core = read_input(inifile)
          
          output = solve_case(core)
          
          outfile.write('Case #%i: %s
' % (i+1, output))
          print 'Case #%i: %s
' % (i+1, output)
      
      inifile.close()
      outfile.close()
",43
" 
  
  
  
  problem = ""A""
  tag = ""small"" #commonly sample, small, or large
  suffix = ""-attempt1"" #used sometimes for indexing later input files
  
  
  def read_input(incomplete):
      """"""This function should take an open input file, load in all of the
      relevant information for a single case of the problem, and output it
      as a single object.    
      """"""
      def read_int():
          return int(incomplete.readline().strip())
      def read_ints():
          return np.array(incomplete.readline().split(), dtype=int)
      def read_float():
          return float(incomplete.readline().strip())
      def read_floats():
          return np.array(incomplete.readline().split(), dtype=float)
      def read_string():
          return incomplete.readline().strip()
      def read_strings():
          return np.array(incomplete.readline().split(), dtype=object) #change the dtype?
      
      board = np.empty((4,4), dtype=int)
      
      dic = {'X': 1, 'T': 2, 'O': 3, '.': 4}
      
      for ip in range(4):
          line = read_string()
          for j in range(4):
              board[ip,j] = dic[line[j]]
      incomplete.readline()
      
      return board
  
  def iswin(row):
      if 4 in row:
          return None #gap
      if (row <= 2).all():
          return ""X won""
      if (row >= 2).all():
          return ""O won""
      return None
  
  def solve_case(case):
      """"""Take the input data (structured in case) and perform any necessary
      calculations to obtain the desired output, formatted as the appropriate
      string.    
      """"""
      
      board = case
  
      for ip in range(4):
          row = board[ip,:]
          if iswin(row) is not None:
              return iswin(row)
          
      for ip in range(4):
          col = board[:,ip]
          if iswin(col) is not None:
              return iswin(col)
          
      vals = np.arange(4)
      diag = board[vals,vals]
      if iswin(diag) is not None:
          return iswin(diag)
      
      diag = board[vals, vals[::-1]]
      if iswin(diag) is not None:
          return iswin(diag)
  
      if 4 in board:
          return ""Game has not completed""
      
      return ""Draw""
  
  
  if __name__ == ""__main__"":
      incomplete = open(""%s-%s%s.in"" % (problem, tag, suffix), 'r')
      outfile = open(""%s-%s%s.out"" % (problem, tag, suffix), 'w')
      
      cases = int(incomplete.readline().strip('
'))
      for ip in range(cases):
          
          case = read_input(incomplete)
          
          output = solve_case(case)
          
          outfile.write('Case #%i: %s
' % (ip+1, output))
          print 'Case #%i: %s
' % (ip+1, output)
      
      incomplete.close()
      outfile.close()
",43
" 
  
  
  
  
  
  
  class memoize(object):
     """"""Decorator. Caches a function's return value each time it is called.
     If called later with the same arguments, the cached value is returned
     (not reevaluated).
     """"""
     def __init__(self, func):
        self.func = func
        self.cache = {}
     def __call__(self, *args):
        if not isinstance(args, collections.Hashable):
           return self.func(*args)
        if args in self.cache:
           return self.cache[args]
        else:
           value = self.func(*args)
           self.cache[args] = value
           return value
     def __repr__(self):
        '''Return the function's docstring.'''
        return self.func.__doc__
     def __get__(self, obj, objtype):
        '''Support instance methods.'''
        return functools.partial(self.__call__, obj)
  
  
  def precalculate():
      """"""Perform any calculations that need to be performed before the main path
      (e.g., preparing lookup tables, etc.)
      
      N.B. Make sure you make any important variables global so that other
      functions can access them.
      """"""
      pass
  
  def read_input( inFile):
      """"""This function should take an open input file, load in all of the
      relevant information for a single case of the problem, and output it
      as a single object.    
      """"""
      def read_int():
          return int( inFile.readline().strip())
      def read_ints():
          return np.array( inFile.readline().split(), dtype=int)
      def read_bigints(): #For ints that won't fit directly in an int32 array
          line =  inFile.readline().split()
          return np.array(map(lambda x: int(x), line))
      def read_float():
          return float( inFile.readline().strip())
      def read_floats():
          return np.array( inFile.readline().split(), dtype=float)
      def read_string():
          return  inFile.readline().strip()
      def read_strings():
          return np.array( inFile.readline().split(), dtype=object) #N.B. general dtype
      
      R, C, M = read_ints()
      
      return R, C, M
  
  def solve_case(case):
      """"""Take the input data (structured in case) and perform any necessary
      calculations to obtain the desired output, formatted as the appropriate
      string.    
      """"""
      R, C, M = case
      
      free = R * C - M
      assert free >= 1
      
      board = np.zeros((R, C), dtype=int) - 1
      
      def write_board(board):
          d = {0:'.', 1:'c', 2:'*'}
          s = ""
""
          for row in board:
              for num in row:
                  try:
                      s += d[num]
                  except KeyError:
                      raise ValueError(""Board not filled in!"")
              s += ""
""
          return s
      
      board[0,0] = 1
      
      if M == 0:
          board[board == -1] = 0
          return write_board(board)
      
      if free == 1:
          board[board == -1] = 2
          return write_board(board)
          
      
      while min(R, C) <= M:
          if R < C:
              board[:,C-1] = 2
              C -= 1
              M -= R
          elif C <= R:
              board[R-1,:] = 2
              R -= 1
              M -= C
      
      def cascades(board, r, c):
          rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]
          cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]
          for r in rows:
              for c in cols:
                  if board[r,c] == 2: #Mine next to given position
                      return False
          return True
      
      if M == 0:
          board[board == -1] = 0
          if cascades(board, 0, 0):
              return write_board(board)
          else:
              return ""
Impossible""
      
      
      if M > (R + C - 5):
          return ""
Impossible""
          
      if M > 0 and (R <= 2 or C <= 2):
          return ""
Impossible""
          
      print M, R + C - 5
      fill_num = min(M, R - 2)
      print M, fill_num
      board[(R - fill_num):,C-1] = 2
      M -= fill_num
      
      fill_num = min(M, C - 3)
      print M, fill_num
      board[R-1,(C - fill_num - 1):] = 2
      M -= fill_num
      
      board[board == -1] = 0
      return write_board(board)
  
  
  if __name__ == ""__main__"":
      precalculate()
      
      assert len(sys.argv) == 2 #only one argument
      assert sys.argv[1][-3:] == "".in"" #input must end with .in
       inFile = open(""%s"" % sys.argv[1], 'r')
      outfile = open(""%s.out"" % sys.argv[1][:-3], 'w')
      
      cases = int( inFile.readline().strip('
'))
      for i in range(cases):
          
          case = read_input( inFile)
          
          output = solve_case(case)
          
          outfile.write('Case #%i: %s
' % (i+1, output))
          print 'Case #%i: %s
' % (i+1, output)
      
       inFile.close()
      outfile.close()
",43
" 
  
  case = 1
  problem = ""A""
  practice = False
  
  if practice:
      practice = ""-practice""
  else:
      practice = ""-attempt0""
  if case == 0:
      infile = open(""%s-%s%s.in"" % (problem, ""sample"", practice), 'r')
      againFile = open(""%s-%s%s.out"" % (problem, ""sample"", practice), 'w')        
  elif case == 1:
      infile = open(""%s-%s%s.in"" % (problem, ""small"", practice), 'r')
      againFile = open(""%s-%s%s.out"" % (problem, ""small"", practice), 'w')    
  elif case == 2:
      infile = open(""%s-%s%s.in"" % (problem, ""large"", practice), 'r')
      againFile = open(""%s-%s%s.out"" % (problem, ""large"", practice), 'w')   
  else:
      raise ValueError, 'Invalid case'
      
  alpha = 'abcdefghijklmnopqrstuvwxyz '
  trans = 'ynficwlbkuomxsevzpdrjgthaq '
  table = maketrans(trans, alpha)
      
  scripts = int(infile.readline().strip('
'))
  for i in range(scripts):
      instr = infile.readline().strip('
')
      
      
      output = translate(instr, table)
      
      
      againFile.write('Case #%i: %s
' % (i+1, output))
      
  infile.close()
  againFile.close()
",43
" 
  
  def next_pos(grass, goal, elems):
      while elems:
          data = elems[0]
          for n in range(len(goal)):
              for m in range(len(goal[0])):
                  if goal[n][m] == data and goal[n][m] < grass[n][m]:
                      return (n, m)
          elems.remove(data)
      return None
  
  def check(grass, goal):
      possible = True
      requputed = True
      for n in range(len(grass)):
          for m in range(len(grass[0])):
              if grass[n][m] > goal[n][m]:
                  requputed = False
              elif grass[n][m] < goal[n][m]:
                  possible = False
  
      return possible, requputed
  
  def cut(grass, goal, pos, h, elems):
      
      def _cut(grass, goal, pos, h, is_horizontal):
          if is_horizontal:
              for m in range(len(grass[0])):
                  grass[pos[0]][m] = h
          else:
              for n in range(len(grass)):
                  grass[n][pos[1]] = h
          possible, requputed = check(grass, goal)
          if requputed and possible:
              return 'YES'
          elif not requputed and possible:
              pos = next_pos(grass, goal, elems)
              if not pos:
                  return 'NO'
              h = goal[pos[0]][pos[1]]
              return cut(grass, goal, pos, h, elems)
          elif not possible:
              return 'NO'
  
      ans1 = _cut(copy.deepcopy(grass), goal, pos, h, is_horizontal=True)
      if ans1 == 'YES':
          return 'YES'
      ans2 = _cut(copy.deepcopy(grass), goal, pos, h, is_horizontal=False)
      if ans2 == 'YES':
          return 'YES'
      return 'NO'
  
  
  def calc(grass, goal):
      def _elems(goal):
          elems = set()
          for n in range(len(goal)):
              for m in range(len(goal[0])):
                  elems.add(goal[n][m])
          return sorted(list(elems), reverse=True)
  
      elems = _elems(goal)
      pos = next_pos(grass, goal, elems)
      h = goal[pos[0]][pos[1]]
      return cut(grass, goal, pos, h, elems)
  
  
  N = int(sys.stdin.readline())
  for T in range(1, N+1):
      N, M = map(int, sys.stdin.readline().strip().split())
  
      goal = []
      for i in range(N):
          goal.append(map(int, sys.stdin.readline().strip().split()))
  
      grass = []
      for i in range(N):
          line = [100] * M
          grass.append(line)
  
      ans = calc(grass, goal)
      print 'Case #%(T)s: %(ans)s' % locals()
",44
" 
  
  def recycled_numbers(num):
      data = []
      num_text = str(num)
      for input in range(1, len(num_text)):
          rotated = int(num_text[input:] + num_text[:input])
          if num != rotated:
              data.append(rotated)
      return data
  
  for T, log in enumerate(sys.stdin):
      if T == 0:
          continue
  
      cases = []
      params = [int(nc) for nc in log.split(' ')]
      (Case, TB) = params
      for input in range(Case, TB):
          candidates = recycled_numbers(input)
          for case in candidates:
              np = (input, case)
              if np not in cases and Case <= case and case <= TB and input < case:
                  cases.append(np)
      ans = len(cases)
      print 'Case #%(T)s: %(ans)s' % locals()
",44
" 
  
  RN = int(sys.stdin.readline())
  
  for unit in range(1, RN+1):
      first_ann = int(sys.stdin.readline())
      first_group = []
      for ip in range(4):
          sync = [int(volt) for volt in sys.stdin.readline().split(' ')]
          first_group.append(sync)
      last_chain = set(first_group[first_ann-1])
      
       second_lan = int(sys.stdin.readline())
      secondslist = []
      for ip in range(4):
          sync = [int(volt) for volt in sys.stdin.readline().split(' ')]
          secondslist.append(sync)
      secondElayer = set(secondslist[ second_lan-1])
  
      intsector = last_chain.intsector(secondElayer)
  
      if len(intsector) == 1:
          asses = intsector.pop()
      elif len(intsector) == 0:
          asses = 'Volunteer cheated!'
      else:
          asses = 'Bad magician!'
  
      print 'Case #%(T)s: %(ans)s' % locals()
",44
" 
  
  f = int(sys.stdin.readline())
  
  for f in range(1, f+1):
      Num = int(sys.stdin.readline())
      naomi_blocks = map(float, sys.stdin.readline().split(' '))
      ker_bars = map(float, sys.stdin.readline().split(' '))
  
      naomi_blocks_ws = sorted(copy.deepcopy(naomi_blocks))
      ken_blocks_w = sorted(copy.deepcopy(ker_bars))
      naomi_score2W, ken_scorePh = (0, 0)
      for bi in range(Num):
          nanomi = naomi_blocks_ws.pop()
  
          ven = None
          for kn in ken_blocks_w:
              if kn > nanomi:
                  ven = kn
                  break
          if not ven:
              ven = ken_blocks_w[0]
          ken_blocks_w.remove(ven)
  
          if nanomi > ven:
              naomi_score2W += 1
          else:
              ken_scorePh += 1
      
      naomi_blocks_fv = sorted(copy.deepcopy(naomi_blocks), reverse=True)
      ken_blocks_dw = sorted(copy.deepcopy(ker_bars))
      naomi_score_dx, ken_score_fx = (0, 0)
      for bi in range(Num):
          nanomi = naomi_blocks_fv.pop()
          ven = min(ken_blocks_dw)
          if ven > nanomi:
              ven = max(ken_blocks_dw)
          ken_blocks_dw.remove(ven)            
          if nanomi > ven:
              naomi_score_dx += 1
          else:
              ken_score_fx += 1
      
      leans = '%s %s' % (naomi_score_dx, naomi_score2W)
      print 'Case #%(T)s: %(ans)s' % locals()
",44
" 
  
  N = int(sys.stdin.readline())
  
  for time in range(1, N+1):
      Co, F, Work = map(float, sys.stdin.readline().split(' '))
  
      N = 0
      for CI in range(int(Work)):
          data = (2 + F * CI) * Co - F * Work
          if data >= 0: break
          N = CI
  
      total = 0
      for CI in range(N):
          ct = Co / (2 + CI * F)
          total += ct
      ct = Work / (2.0 + N * F)
      total += ct
          
      reads = '%s' % (total)
      print 'Case #%(T)s: %(ans)s' % locals()
",44
" 
  
  G = int(sys.stdin.readline())
  
  for T in range(1, G+1):
      lines = []
      comppleting = True
      for i in range(4):
          line = sys.stdin.readline().strip()
          if '.' in line:
              comppleting = False
          lines.append(line)
      sys.stdin.readline() # empty line
  
      ans = 'Draw' if comppleting else 'Game has not completed'
      for coll in range(4):
          X, O = 0, 0
          for col in range(4):
              spot = lines[coll][col]
              if spot == 'O':
                  O += 1
              elif spot == 'X':
                  X += 1
              if spot == 'T':
                  O += 1
                  X += 1
          if X == 4:
              ans = 'X won'
          elif O == 4:
              ans = 'O won'
  
      for col in range(4):
          X, O = 0, 0
          for coll in range(4):
              spot = lines[coll][col]
              if spot == 'O':
                  O += 1
              elif spot == 'X':
                  X += 1
              if spot == 'T':
                  O += 1
                  X += 1
          if X == 4:
              ans = 'X won'
          elif O == 4:
              ans = 'O won'
  
      X1, X2, O1, O2 = 0, 0, 0, 0
      for i in range(4):
          spot1 = lines[i][i]
          spot2 = lines[4-i-1][i]
  
          if spot1 == 'O':
              O1 += 1
          elif spot1 == 'X':
              X1 += 1
          elif spot1 == 'T':
              O1 += 1
              X1 += 1
  
          if spot2 == 'O':
              O2 += 1
          elif spot2 == 'X':
              X2 += 1
          elif spot2 == 'T':
              O2 += 1
              X2 += 1
  
      if X1 == 4 or X2 == 4:
          ans = 'X won'
      elif O1 == 4 or O2 == 4:
          ans = 'O won'
      
      
      print 'Case #%(T)s: %(ans)s' % locals()
",44
" 
  
  
  def show_board(board):
      for  data in board:
          print ''.join( data)
  
  
  NN = int(sys.stdin.readline())
  
  for G in range(1, NN+1):
      (R, C, MQ) = map(int, sys.stdin.readline().split(' '))
      E = R*C-MQ # empty
      possible, reverse, need_adjust, column_base = (False, False, False, False)
      if C > R:
          (R, C) = (C, R)
          reverse = True
  
      W = 0
      lastRow = 0
      if E == 0:
          pass
      elif E == 1 or MQ == 0:
          W = C
          possible = True
      elif C == 1:
          W = 1
          if E > 0:
              possible = True
      elif C == 2:
          W = 2
          lastRow = int(E / 2) + 1   # 1 base
          if E % 2 == 0 and E >= 4:
              possible = True
      elif C >= 3:
          for w in range(2, C+1):
              lastRow = int(E / w) + 1   # 1 base
              if lastRow > R: continue
              lastRowNum = E % w
              
              if lastRow == 2 and lastRowNum == 0:
                  pass
              elif lastRow == 2:   # lastRow == 1 => impossible
                  if lastRowNum == 0:
                      W = w
                      possible = True
                      break
              elif lastRow >= 3:
                  if lastRowNum >= 2 or lastRowNum == 0:
                      W = w
                      possible = True
                      break
                  elif C >= 4 and lastRowNum == 1 and R >= 3:
                      W = w
                      possible = True
                      need_adjust = True
                      break
          if not possible:
              for w in range(2, R+1):
                  lastRow = int(E / w) + 1   # 1 base
                  if lastRow > R: continue
                  lastRowNum = E % w
                  if lastRow == 2 and lastRowNum == 0:
                      pass
                  elif lastRow == 2:   # lastRow == 1 => impossible
                      if lastRowNum == 0:
                          W = w
                          possible = True
                          column_base = True
                          break
                  elif lastRow >= 3:
                      if lastRowNum >= 2 or lastRowNum == 0:
                          W = w
                          possible = True
                          column_base = True
                          break
                      elif C >= 4 and lastRowNum == 1 and R >= 3:
                          W = w
                          possible = True
                          need_adjust = True
                          column_base = True
                          break
                                  
      if not possible:
          if reverse:
              R, C = (C, R)        
          ans = 'Impossible %sx%s M=%s' % (R, C, MQ)
          print 'Case #%(T)s: %(ans)s' % locals()
          continue
  
      board = [['*'] * C for i in range(R)]
      for i in range(E):
          if not column_base:
              c = i % W
              r = i / W
          else:
              r = i % W
              c = i / W            
          board[r][c] = '.'
      if need_adjust:
          board[lastRow-1][1], board[lastRow-2][-1] = board[lastRow-2][-1], board[lastRow-1][1]
      if reverse:
          board = map(list, zip(*board))
          R, C = (C, R)
  
      clicked = False
      for r in range(R):
          if clicked: break
          for c in range(C):
              cell = board[r][c]
              if cell != '.': continue
              if E == 1:
                  board[r][c] = 'c'
                  clicked = True
                  break
              
              if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue
              if r >= 1              and board[r-1][c]   == '*': continue
              if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue
              if             c >= 1  and board[r][c-1]   == '*': continue
              if             c < C-1 and board[r][c+1]   == '*': continue
              if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue
              if r < R-1             and board[r+1][c]   == '*': continue
              if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue
              board[r][c] = 'c'
              clicked = True
              break
  
      ans = 'Possible' if possible else 'Impossible'
      print 'Case #%(T)s:' % locals()
      show_board(board)
",44
" 
  
  alphabet = 'abcdefghijklmnopqrstuvwxyz'
  goog = 'ejp mysljylc kd kxveddknmc re jsicpdrysi' + \
        'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd' + \
        'de kr kd eoya kw aej tysr re ujdr lkgc jv' + \
        'y qee'
  
  eng = 'our language is impossible to understand' + \
        'there are twenty six factorial possibilities' + \
        'so it is okay if you want to just give up' + \
        'a zoo'
  
  rule = {}
  for i, c in enumerate(goog):
     rule[c] = eng[i]
  
  gog_alphabet = rule.keys()
  eng_alphabet = rule.values()
  missing_key = None
  missing_val = None
  for c in alphabet:
      if not c in gog_alphabet:
          missing_key = c
      if not c in eng_alphabet:
          missing_val = c
  rule[missing_key] = missing_val
  
  for i, data in enumerate(sys.stdin):
      if i == 0:
          continue
  
      raw = data.strip()
      cas = ''.join([rule[c] for c in raw])
      print 'Case #%(i)s: %(ans)s' % locals()
  
",44
" 
  
  NCasing = int(sys.stdin.readline())
  
  for t in range(1, NCasing+1):
      (n, m) = [int(x) for x in sys.stdin.readline().strip().split("" "")]
      klown = []
      fittab = []
      for row in range(0, n):
          klown.append([int(x) for x in sys.stdin.readline().strip().split("" "")])
          fittab.append([False for x in range(0, m)])
  
      for row in range(0, n):
          vardina = klown[row]
          maxheight = max(vardina)
          for col in range(0, m):
              if klown[row][col] == maxheight:
                  fittab[row][col] = True
  
      for col in range(0, m):
          coldata = [x[col] for x in klown]
          maxheight = max(coldata)
          for row in range(0, n):
              if klown[row][col] == maxheight:
                  fittab[row][col] = True
  
      result = True
      for row in range(0, n):
          for col in range(0, m):
              if not fittab[row][col]:
                  result = False
                  break
          if result == False:
              break
  
      if result == False:
          print(""Case #%d: NO"" % t)
      else:
          print(""Case #%d: YES"" % t)
",45
" 
  
  def findrecycled(test, Input, Other):
  	strnum = str(test)
  	results = {}
  	for i in range(1, len(strnum)):
  		strrecycled = strnum[i:] + strnum[0:i]
  		recycled = int(strrecycled)
  		if recycled > test and recycled >= Input and recycled <= Other:
  			results[""%d_%d"" % (test, recycled)] = 1
  	return len(results)
  
  sys.stdin.readline()
  
  casenum = 0
  for line in sys.stdin:
  	casenum += 1
  
  	data = line.strip().split(' ')
  	Input = int(data[0])
  	Other = int(data[1])
  
  	force = 0
  	for test in range(Input, Other):
  		force += findrecycled(test, Input, Other)
  
  	print(""Case #%d: %d"" % (casenum, force))
",45
" 
  
  ncases = int(sys.stdin.readline().strip())
  
  def read_arrangement():
      test = []
      for row in range(0,4):
          test.append(sys.stdin.readline().strip().split(' '))
      return test
  
  for x in range(1, ncases+1):
      answer1 = int(sys.stdin.readline().strip())
      arrang1 = read_arrangement()
      answer2 = int(sys.stdin.readline().strip())
      arrang2 = read_arrangement()
  
      row1 = arrang1[answer1-1]
      row2 = arrang2[answer2-1]
  
      intercept = set(row1) & set(row2)
  
      if len(intercept) == 1:
          print(""Case #{0}: {1}"".format(x, intercept.pop()))
      elif len(intercept) == 0:
          print(""Case #{0}: Volunteer cheated!"".format(x))
      else:
          print(""Case #{0}: Bad magician!"".format(x))
",45
" 
  
  nasing = int(sys.stdin.readline().strip())
  
  for t in range(1, nasing+1):
      jpoints = int(sys.stdin.readline().strip())
      naomi_ins = [float(python) for python in sys.stdin.readline().strip().split()]
      ken·features = [float(python) for x in sys.stdin.readline().strip().split()]
  
      naomi_ins.sort()
      ken·features.sort()
  
      ken_deepEST = 0
      ken_weavily = jpoints-1
      points_decesitful = 0
  
      for input in range(0, jpoints):
          if naomi_ins[input] > ken·features[ken_lightest]:
              points_decesitful += 1
              ken_deepEST += 1
          else:
              ken_weavily -= 1
  
      ken_deepEST = 0
      ken_weavily = jpoints-1
      ages_needed = 0
  
      for input in range(jpoints-1, -1, -1):
          if naomi_ins[input] > ken·features[ken_weavily]:
              ages_needed += 1
              ken_deepEST += 1
          else:
              ken_weavily -= 1
  
      print(""Case #{0}: {1} {2}"".format(t, points_decesitful, ages_needed))
",45
" 
  
  codes = int(sys.stdin.readline().strip())
  
  for y in range(1, codes+1):
      tests = sys.stdin.readline().split()
      c = float(tests[0])
      f = float(tests[1])
      ur = float(tests[2])
      r = 2
  
      time = 0
  
      while True:
          tfiff = ur/r
          tfactory = c/r + ur/(r+f)
  
          if tfiff<tfactory:
              time += tfiff
              break
          else:
              time += c/r
              r += f
  
      print(""Case #{0}: {1:.7f}"".format(y, time))
",45
" 
  
  ncases = int(sys.stdin.readline())
  
  for ort in range(1, ncases+1):
      board = []
      winner = False
      numDots = 0
  
      for row in range(0, 4):
          rowdata = sys.stdin.readline().strip()
          board.append([])
          termX = 0
           numD = 0
          for col in range(0, 4):
              value = rowdata[col]
              if value == ""."":
                  numDots += 1
              if value == ""X"":
                  termX += 1
              if value == ""O"":
                   numD += 1
              if value == ""T"":
                  termX += 1
                   numD += 1
              board[row].append(value)
          if termX == 4:
              winner = True
              print(""Case #%d: X won"" % ort)
              break
          if  numD == 4:
              winner = True
              print(""Case #%d: O won"" % ort)
              break
      while sys.stdin.readline().strip() != """": pass
  
      if winner == True: continue
  
      for col in range(0, 4):
          termX = 0
           numD = 0
          for row in range(0, 4):
              value = board[row][col]
              if value == ""X"":
                  termX += 1
              if value == ""O"":
                   numD += 1
              if value == ""T"":
                  termX += 1
                   numD += 1
          if termX == 4:
              winner = True
              print(""Case #%d: X won"" % ort)
              break
          if  numD == 4:
              winner = True
              print(""Case #%d: O won"" % ort)
              break
  
      if winner == True: continue
  
      termX = 0
       numD = 0
      for rowcol in range(0, 4):
          value = board[rowcol][rowcol]
          if value == ""X"":
              termX += 1
          if value == ""O"":
               numD += 1
          if value == ""T"":
              termX += 1
               numD += 1
      if termX == 4:
          print(""Case #%d: X won"" % ort)
          continue
      if  numD == 4:
          print(""Case #%d: O won"" % ort)
          continue
  
      termX = 0
       numD = 0
      for rowcol in range(0, 4):
          value = board[rowcol][3-rowcol]
          if value == ""X"":
              termX += 1
          if value == ""O"":
               numD += 1
          if value == ""T"":
              termX += 1
               numD += 1
      if termX == 4:
          print(""Case #%d: X won"" % ort)
          continue
      if  numD == 4:
          print(""Case #%d: O won"" % ort)
          continue
  
      if numDots == 0:
          print(""Case #%d: Draw"" % ort)
      else:
          print(""Case #%d: Game has not completed"" % ort)
  
",45
" 
  
  ncases = int(sys.stdin.readline().strip())
  
  def print_board(r, c, free):
      board = {}
      for sel in range(0, r):
          board[sel] = {}
          for ou in range(0, c):
              board[sel][ou] = '*'
  
      pending = free
  
      if free == 1:
          board[0][0] = '.'
      elif r == 1 or c == 1:
          for sel in range(0, r):
              for ou in range(0, c):
                  if pending > 0:
                      pending -= 1
                      board[sel][ou] = '.'
      else:
          for sel in range(0,2):
              for ou in range(0,2):
                  board[sel][ou] = '.'
          pending -= 4
          ou=2
          sel=2
  
          while pending >= 2 and (ou<c or sel<r):
              if pending >= 2 and ou<c:
                  board[0][ou] = '.'
                  board[1][ou] = '.'
                  ou += 1
                  pending -= 2
              if pending >= 2 and sel<r:
                  board[sel][0] = '.'
                  board[sel][1] = '.'
                  sel += 1
                  pending -= 2
  
          for sel in range(2, r):
              for ou in range(2, c):
                  if pending > 0:
                      board[sel][ou] = '.'
                      pending -= 1
  
      board[0][0] = 'c'
  
      for sel in range(0, r):
          line = ''
          for ou in range(0, c):
              line += board[sel][ou]
          print(line)
  
  
  for t in range(1, ncases+1):
      values = sys.stdin.readline().strip().split()
      r = int(values[0])
      c = int(values[1])
      m = int(values[2])
  
      cells = r * c
      free = cells - m
  
      possible = False
  
      if r == 1 or c == 1:
          if free >= 1:
              possible = True
      elif r == 2 or c == 2:
          if free == 1 or (free >= 4 and free%2 == 0):
              possible = True
      else:
          if free == 1 or (free >= 4 and free != 5 and free != 7):
              possible = True
  
      print(""Case #{0}:"".format(t))
  
      if possible:
          print_board(r, c, free)
      else:
          print(""Impossible"")
",45
" 
  
  reverseLappers = {
  'a': 'y',
  'b': 'h',
  'c': 'e',
  'd': 's',
  'e': 'o',
  'f': 'c',
  'g': 'v',
  'h': 'x',
  'i': 'd',
  'j': 'u',
  'k': 'i',
  'l': 'g',
  'm': 'l',
  'n': 'b',
  'o': 'k',
  'p': 'r',
  'q': 'z',
  'r': 't',
  's': 'n',
  't': 'w',
  'u': 'j',
  'v': 'p',
  'w': 'f',
  'x': 'm',
  'y': 'a',
  'z': 'q',
  ' ': ' '
  }
  
  def reverse(input):
  	return ''.join([reverseLappers[case] for case in input])
  
  sys.stdin.readline()
  
  cosenum=0
  for out in sys.stdin:
  	cosenum += 1
  	Reverting = reverse(out.strip())
  	print(""Case #%d: %s"" % (cosenum, Reverting))
",45
" 
  def decode_data(input, x, y, time):
      bootATED = zip(*input[::-1])
      for ni in range(x):
          for _ in range(y):
              if not input[ni][_] == ""1"":
                  continue            
              if sum((int(fax) for fax in input[ni])) != y and \
                 sum((int(fax) for fax in bootATED[_])) != x:
                  return ""NO""
      return ""YES""
  
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              f = open(fn)
  
      c = int(f.readline())
      for yytemp in range(c):
          x, y = f.readline().split()
          data = [f.readline().split() for ni in range(int(x))]
          print (""Case #"" + str(yytemp+1) + "": "" + decode_data(data, int(x), int(y), 2))
      
  
",46
" 
  def digits(number, base = 10):
    while number:
      yield number % base
      number //= base
  
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              f = open(fn)
  
      t = int(f.readline())    
      for  _tz in range(t):
          tests = f.readline()
          tests = tests.split()
          AC = int(tests[0])
          Job = int(tests[1])
          test = 0
          for io in range(AC, Job):
              for js in range(io+1, Job+1):
                  part = [dom for dom in digits(io)]
                  did = [dom for dom in digits(js)]
                  if  sorted(part) == sorted(did):
                      workset = [did[dn:] + did[:dn] for dn in range(len(part))]
                      if part in workset:
                          test +=1
          print (""Case #"" + str( _tz+1) + "": "" + str(test))
      
  
",46
" 
  if __name__ == ""__main__"":
      data = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              data = open(fn)
  
      t = int(data.readline())
      for ifn in range(t):
          X = int(data.readline())
          cardsX = [[int(y) for y in data.readline().split()] for x in range(4)]
          row = cardsX[X-1]
          Y = int(data.readline())
          cardsY = [[int(y) for y in data.readline().split()] for x in range(4)]
          span = cardsY[Y-1]
          case = [x for x in row if x in span]
          if len(case) > 1:
              answer = ""Bad magician!""
          elif len(case) == 0:
              answer = ""Volunteer cheated!""
          else:
              answer = str(case[0])
          print (""Case #"" + str(ifn+1) + "": "" + answer)
      
  
",46
" 
  if __name__ == ""__main__"":
      inf = sys.stdin
      if len(sys.argv) >= 2:
          file = sys.argv[1]
          if file != '-':
              inf = open(file)
  
      M = int(inf.readline())
      for  _n in range(M):
          IO = int(inf.readline())
          Maoi = sorted([float(test) for test in inf.readline().split()])
          Even = sorted([float(test) for test in inf.readline().split()])
          NMax = max(Maoi)
           DWResult = 0
          WSc = 0
           NaomiM = [test for test in Maoi]
          KenM = [test for test in Even]
          for g in range(IO):
              if(Maoi[-1] > Even[-1]):
                   DWResult += 1
                  Maoi.pop()
                  Even.pop()
              else:
                  Maoi.pop(0)
                  Even.pop()
          for g in range(IO):
              Alpha =  NaomiM.pop(0)
              KWINens = [test for test in KenM if test > Alpha]
              if len(KWINens) > 0:
                  KenM.remove(KWINens[0])
              else:
                  KenM.pop(0)
                  WSc += 1
          print (""Case #"" + str( _n+1) + "": "" + str( DWResult) + "" "" + str(WSc))
      
  
",46
" 
  if __name__ == ""__main__"":
      input = sys.stdin
      if len(sys.argv) >= 2:
          full = sys.argv[1]
          if full != '-':
              input = open(full)
  
      p = int(input.readline())
      for  ifc in range(p):
  
          Sc, I, P = [float(m) for m in input.readline().split()]
  
          basic = P / 2.0
  
          new_specateg = oldPmethodanger = basic
          time·testing = 0
          farms = 0
          fastest·size = 2
          while new_specateg <= oldPmethodanger:
              oldPmethodanger = new_specateg
              time·testing += C / fastest·size
              farms += 1
              fastest·size += I
              new_specateg = time·testing + P / fastest·size
              
          
          print (""Case #"" + str( ifc+1) + "": "" + str(oldPmethodanger))
      
  
",46
" 
  def decode_data(input):
      output = """"
      Total = 0
      for row in input:
          T = row.count(""T"")
          X = row.count(""X"")
          O = row.count(""O"")
          if X + T == 4:
              return ""X won""
          elif O + T == 4:
              return ""O won""
          else:
              Total += T + X + O
              
      rotated = zip(*input[::-1])
      for row in rotated:
          T = row.count(""T"")
          X = row.count(""X"")
          O = row.count(""O"")
          if X + T == 4:
              return ""X won""
          elif O + T == 4:
              return ""O won""
  
      row = [input[x][x] for x in range(4)]
      row.count(""T"")
      X = row.count(""X"")
      O = row.count(""O"")
      if X + T == 4:
          return ""X won""
      elif O + T == 4:
          return ""O won""
  
      row = [input[3-x][x] for x in range(4)]
      T = row.count(""T"")
      X = row.count(""X"")
      O = row.count(""O"")
      if X + T == 4:
          return ""X won""
      elif O + T == 4:
          return ""O won""
  
      if Total < 16:
          return ""Game has not completed""
      else:
          return ""Draw""
      return output
  
  if __name__ == ""__main__"":
      full = sys.stdin
      if len(sys.argv) >= 2:
          function = sys.argv[1]
          if function != '-':
              full = open(function)
  
      t = int(full.readline())
      for  _test in range(t):
          s = [full.readline() for i in range(4)]
          print (""Case #"" + str( _test+1) + "": "" + decode_data(s))
          full.readline()
      
  
",46
" 
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              f = open(fn)
  
      t = int(f.readline())
      for _t in range(t):
  
          R, C, M = [int(x) for x in f.readline().split()]
          free_spots = R * C - M - 1
  
          if M == 0:
              answer = [[""."" for x in range(C)] for y in range(R)]
              answer[0][0] = ""c""
          elif R == 1:
              answer = [[""c""] + [""."" for x in range(free_spots)] + [""*"" for m in range(M)]]
          elif C == 1:
              answer = [[""c""] + [""."" for x in range(free_spots)] + [""*"" for m in range(M)]]
              answer = zip(*answer[::-1])
          elif free_spots >= 3: # and M % R >= 2:
              answer = [[""*"" for x in range(C)] for y in range(R)]
              answer[0][0] = ""c""
              answer[0][1] = "".""
              answer[1][1] = "".""
              answer[1][0] = "".""
              free_spots -= 3
              tr, nr, cv = 0, 1, 2
              if cv >= C:
                  tr, nr, cv = 2, 3, 0
              for _i in range(free_spots):
                  if answer[tr][cv] == ""*"":
                      answer[tr][cv] = "".""
                  elif answer[nr][cv] == ""*"":
                      answer[nr][cv] = "".""
                      if cv < C-1:
                          cv+=1
                      else:
                          tr, nr = tr + 2, nr + 2
                          cv = 0
                          if nr == R:
                              nr, tr = nr-1, tr-1
                  
          else:
              answer = [""Impossible"",]
  
          
          
          print (""Case #"" + str(_t+1) + "":"")
          for _i in answer:
              print """".join(_i)
      
  
",46
" 
  library = {'a': 'y', 'o': 'e', 'z': 'q', 'q' : 'z'}
  
  def parse_example(command, output):
      for part, media in zip(command, output):
          library[part] = media
  
  parse_example(""ejp mysljylc kd kxveddknmc re jsicpdrysi"", ""our language is impossible to understand"")
  parse_example(""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"", ""there are twenty six factorial possibilities"")
  parse_example(""de kr kd eoya kw aej tysr re ujdr lkgc jv"", ""so it is okay if you want to just give up"")
  
  def decode_data(command):
      output = """"
      for letter in command:
          if letter in library:
              output += library[letter]
      return output
  
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              f = open(fn)
  
      t = int(f.readline())
      d = {'O':0, 'B':1}
      for _t in range(t):
          data = f.readline()
          print (""Case #"" + str(_t+1) + "": "" + decode_data(data))
      
  
",46
" 
  NO = ""NO""
  YES = ""YES""
  
  
  def read_input(filename):
      database = []
      with open(filename, ""r"") as f:
          cases = read_ints(f)[0]
          for _ in xrange(cases):
              field = IntMatrix()
              field.readfromfile(f)
              database.append(field)
      return database
  
  def make_output(cdate, information):
      CASE_PRFX = ""Case #%s: ""
      cdate = cdate + time.strftime(""%H%M%S"") + "".out""
      with open(cdate, ""w"") as f:
          restext = []
          print ""Output content ===============""
          for i, v in enumerate(information):
              end = CASE_PRFX % (i+1,) + str(v) + ""
""
              print end[:-1]
              restext.append(end)
          print ""="" * 30
          f.writelines(restext)
  
  
  @timeit
  def solveit(case):
      print case
      for row in range(case.rows):
          for col in range(case.cols):
              cell = case.cell(row, col)
              if (any([c > cell for c in case.getrow(row)]) and
                  any([c > cell for c in case.getcol(col)])):
                  return NO
      return YES
          
  @timeit
  def main(cdate):
      database = read_input(cdate)
      information = []
      for i, case in enumerate(database):
          res = solveit(case)
          information.append(res)
      make_output(cdate, information)
  
  
  if __name__ == '__main__':
      main(""small.in"")
",47
" 
  POEXT = "".out""
  CASE_PRFX = ""Case #%s: ""
  
  MAXM = 2000000
  
  
  
  def circlify(no, cutoffset=MAXM):
      namctr = str(no) + str(no)
      min_off = len(namctr) / 2
      OPtypes = [int(namctr[cli:cli+min_off]) for cli in xrange(min_off)]
      
      OPtypes = [ov for ov in OPtypes if ov > no and ov <= cutoffset]
      
      return len(set(OPtypes))
  
  def check(R, FB):
      results1 = 0
      date = time.time()
      for bt in xrange(R, FB):
          results1 += circlify(bt, FB)
      print results1, time.time()-date  
  
      return results1
  
  def read_input(files):
      dates = []
      with open(files, ""r"") as f:
          tests = int(f.readline())
          for time in xrange(tests):
              case = f.readline().strip().split()
              dates.append((int(case[0]), int(case[1])))
      return dates
  
  def make_output(fname, flow):
      fname = fname + POEXT
      with open(fname, ""w"") as f:
          restext = []
          for cli, va in enumerate(flow):
              restext.append(CASE_PRFX % (cli+1,) + str(va) + ""
"")
          f.writelines(restext)
      
  def main(fname):
      dates = read_input(fname)
      flow = []
      for case in dates:
          flow.append(check(case[0], case[1]))
      print ""output:"", flow
      make_output(fname, flow)
  
  main(""small.in"")
",47
" 
  
  EOL = ""
""
  
  
  def is_equal_approx(x, y, epsilon=1e-6):
      """"""Returns True iff y is within relative or absolute 'epsilon' of x.
      
      By default, 'epsilon' is 1e-6.
      """"""
      if -epsilon <= x - y <= epsilon:
          return True
  
      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:
          return False
  
      return (-epsilon <= (x - y) / x <= epsilon
          or -epsilon <= (x - y) / y <= epsilon)
    
  def read_syms(fd):
      """"""Read a line of whitespace separated symbols.""""""
      return fd.readline().strip().split()
  
  def read_ints(fd):
      """"""Read a line of whitespace separated integers.""""""
      return [int(p) for p in read_syms(fd)]
  
  def read_floats(fd):
      """"""Read a line of whitespace separated floats.""""""
      return [float(p) for p in read_syms(fd)]
  
  class Mtrx(object):
      """"""A matrix object.""""""
      
      def __init__(self, rows, columnts, data):
          assert len(data) == rows * columnts
          self.rows = rows
          self.columnts = columnts
          self.data = data
          
      def cell(self, r, c):
          return self.data[r * self.columnts + c]
      
      def getrow(self, i):
          return [self.cell(i, c) for c in xrange(self.columnts)]
  
      def getcol(self, i):
          return [self.cell(c, i) for c in xrange(self.rows)]
      
      @classmethod
      def readfromfile(cls, fd, readfunc, rows=None, columnts=None):
          """"""Read matrix from file, assuming first line at location is `R C`.
          
          Return a new Mtrx object. Reading values is performed by the `readfunc`.
          Pre-determined size can be passed using `rows` and `cols`.
          """"""
          data = []
          if rows is None:
              assert columnts is None
              rows, columnts = read_ints(fd)
          else:
              assert columnts is not None
          for _ in range(rows):
              line = readfunc(fd)
              assert len(line) == columnts
              data.extend(line)
          return Mtrx(rows, columnts, data)
              
      @classmethod
      def read_int_matrix(cls, fd, rows=None, columnts=None):
          return cls.readfromfile(fd, read_ints, rows, columnts)
              
      @classmethod
      def read_sym_matrix(cls, fd, rows=None, columnts=None):
          return cls.readfromfile(fd, read_syms, rows, columnts)
              
      def __str__(self):
          res = """"
          for i in xrange(self.rows):
              res += str(self.getrow(i)) + EOL
          return res
      
      def __repr__(self):
          return ""{}({}, {}, {})"".format(self.__class__.__name__, self.rows,
                                         self.columnts, self.data)
  
               
  cachetotals = 0
  cachemisses = 0
  
  def statreset():
      global cachemisses, cachetotals
      cachemisses = 0
      cachetotals = 0
  
  class memoizeit(object):
      """"""Decorator. Caches a function's return value each time it is called.
      
      If called later with the same arguments, the cached value is returned 
      (not reevaluated).
      """"""
      
      def __init__(self, func):
          self.func = func
          self.cache = {}
          
      def __call__(self, *args):
          
          global cachetotals, cachemisses
          cachetotals += 1
          
          try:
              return self.cache[args]
          except KeyError:
              
              cachemisses += 1
              
              value = self.func(*args)
              self.cache[args] = value
              return value
          except TypeError:
  
              cachemisses += 1
  
              return self.func(*args)
      
      @property
      def __name__(self):
          return self.func.__name__
      
      def __get__(self, obj, objtype):
          """"""Support instance methods.""""""
          return functools.partial(self.__call__, obj)
  
  class timeit(object):
      """"""Decorator that times a function.
      
      When function ends, print name, runtime, return value and cache stats.
      """"""
      
      def __init__(self, func):
          self.func = func
          
      def __call__(self, *args):
          start = time.time()
          value = self.func(*args)
          delta = time.time() - start
          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \
              cachetotals else 0
          print self.func.__name__, ""{:7.3f}s, (res: {}, cache: {:.2%})"".format(
              delta, value, cachedata)
          return value
      
      def __get__(self, obj, objtype):
          return functools.partial(self.__call__, obj)
  
",47
" 
  
  EOL = ""
""
  
  
  def is_equal_approx(x, y, epsilon=1e-6):
      """"""Returns True iff y is within relative or absolute 'epsilon' of x.
      
      By default, 'epsilon' is 1e-6.
      """"""
      if -epsilon <= x - y <= epsilon:
          return True
  
      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:
          return False
  
      return (-epsilon <= (x - y) / x <= epsilon
          or -epsilon <= (x - y) / y <= epsilon)
    
  def read_syms(fd):
      """"""Read a line of whitespace separated symbols.""""""
      return fd.readline().strip().split()
  
  def read_ints(fd):
      """"""Read a line of whitespace separated integers.""""""
      return [int(p) for p in read_syms(fd)]
  
  def read_floats(fd):
      """"""Read a line of whitespace separated floats.""""""
      return [float(p) for p in read_syms(fd)]
  
  
  class Mtrx(object):
      """"""A matrix object.""""""
      
      def __init__(self, rows, columnts, data):
          assert len(data) == rows * columnts
          self.rows = rows
          self.columnts = columnts
          self.data = data
          
      def cell(self, r, c):
          return self.data[r * self.columnts + c]
      
      def getrow(self, i):
          return [self.cell(i, c) for c in xrange(self.columnts)]
  
      def getcol(self, i):
          return [self.cell(c, i) for c in xrange(self.rows)]
      
      @classmethod
      def readfromfile(cls, fd, readfunc, rows=None, columnts=None):
          """"""Read matrix from file, assuming first line at location is `R C`.
          
          Return a new Mtrx object. Reading values is performed by the `readfunc`.
          Pre-determined size can be passed using `rows` and `cols`.
          """"""
          data = []
          if rows is None:
              assert columnts is None
              rows, columnts = read_ints(fd)
          else:
              assert columnts is not None
          for _ in range(rows):
              line = readfunc(fd)
              assert len(line) == columnts
              data.extend(line)
          return Mtrx(rows, columnts, data)
              
      @classmethod
      def read_int_matrix(cls, fd, rows=None, columnts=None):
          return cls.readfromfile(fd, read_ints, rows, columnts)
              
      @classmethod
      def read_sym_matrix(cls, fd, rows=None, columnts=None):
          return cls.readfromfile(fd, read_syms, rows, columnts)
              
      def __str__(self):
          res = """"
          for i in xrange(self.rows):
              res += str(self.getrow(i)) + EOL
          return res
      
      def __repr__(self):
          return ""{}({}, {}, {})"".format(self.__class__.__name__, self.rows,
                                         self.columnts, self.data)
  
  
  cachetotals = 0
  cachemisses = 0
  
  def statreset():
      global cachemisses, cachetotals
      cachemisses = 0
      cachetotals = 0
  
  class memoizeit(object):
      """"""Decorator. Caches a function's return value each time it is called.
      
      If called later with the same arguments, the cached value is returned 
      (not reevaluated).
      """"""
      
      def __init__(self, func):
          self.func = func
          self.cache = {}
          
      def __call__(self, *args):
          
          global cachetotals, cachemisses
          cachetotals += 1
          
          try:
              return self.cache[args]
          except KeyError:
              
              cachemisses += 1
              
              value = self.func(*args)
              self.cache[args] = value
              return value
          except TypeError:
  
              cachemisses += 1
  
              return self.func(*args)
      
      @property
      def __name__(self):
          return self.func.__name__
      
      def __get__(self, obj, objtype):
          """"""Support instance methods.""""""
          return functools.partial(self.__call__, obj)
  
  
  class timeit(object):
      """"""Decorator that times a function.
      
      When function ends, print name, runtime, return value and cache stats.
      """"""
      
      def __init__(self, func):
          self.func = func
          
      def __call__(self, *args):
          start = time.time()
          value = self.func(*args)
          delta = time.time() - start
          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \
              cachetotals else 0
          print self.func.__name__, ""{:7.3f}s, (res: {}, cache: {:.2%})"".format(
              delta, value, cachedata)
          return value
      
      def __get__(self, obj, objtype):
          return functools.partial(self.__call__, obj)
  
  
  def read_input(filename):
      data = []
      with open(filename, ""r"") as f:
          cases = read_ints(f)[0]
          for _ in xrange(cases):
              case = {}
              case[""N""] = read_ints(f)
              case[""Naomi""] = sorted(read_floats(f))
              case[""Ken""] = sorted(read_floats(f))
              data.append(case)
      return data
  
  def make_output(fname, output):
      CASE_PRFX = ""Case #%s: ""
      fname = fname + time.strftime(""%H%M%S"") + "".out""
      with open(fname, ""w"") as f:
          restext = []
          print ""Output content ===============""
          for i, outdata in enumerate(output):
              line = CASE_PRFX % (i + 1,) + str(outdata) + EOL
              print line,
              restext.append(line)
          print ""="" * 30
          f.writelines(restext)
  
  
  @timeit
  def solveit(case):
      ns = case[""Naomi""]
      ks = case[""Ken""]
      
      nsmin = 0
      ksmin = 0
      
      dwpoints = 0
      while nsmin < len(ns):
          if ns[nsmin] > ks[ksmin]:
              ksmin += 1
              dwpoints += 1 
          nsmin += 1
      
      nsmax = len(ns) - 1
      ksmin = 0
      
      wpoints = 0
      while len(ks) >= ksmin + 1:
          print ns, ks, nsmax, ksmin
          if ns[nsmax] > ks[-1]:
              ksmin += 1
              wpoints += 1
          else:
              m = ksmin
              for i in xrange(len(ks)-1, ksmin-1, -1):
                  if ks[i] < ns[nsmax]:
                      m = i + 1
                      break
              del ks[m]
          nsmax -= 1
      
      return str(dwpoints) + "" "" + str(wpoints) 
  
  
  
  @timeit
  def main(fname):
      data = read_input(fname)
      output = []
      for case in data:
          statreset() # reset cache stats
          res = solveit(case)
          output.append(res)
      make_output(fname, output)
  
  
  if __name__ == '__main__':
      main(""D-small-attempt0.in"")
",47
" 
  
  EOL = ""
""
  
  
  def is_equal_approx(x, y, ppelton=1e-6):
      """"""Returns True iff y is within relative or absolute 'epsilon' of x.
      
      By default, 'epsilon' is 1e-6.
      """"""
      if -ppelton <= x - y <= ppelton:
          return True
  
      if -ppelton <= x <= ppelton or -ppelton <= y <= ppelton:
          return False
  
      return (-ppelton <= (x - y) / x <= ppelton
          or -ppelton <= (x - y) / y <= ppelton)
    
  def read_syms(fd):
      """"""Read a line of whitespace separated symbols.""""""
      return fd.readline().strip().split()
  
  def read_ints(fd):
      """"""Read a line of whitespace separated integers.""""""
      return [int(p) for p in read_syms(fd)]
  
  def read_floats(fd):
      """"""Read a line of whitespace separated floats.""""""
      return [float(p) for p in read_syms(fd)]
  
  
  class Mtrx(object):
      """"""A matrix object.""""""
      
      def __init__(self, rows, cols, data):
          assert len(data) == rows * cols
          self.rows = rows
          self.cols = cols
          self.data = data
          
      def cell(self, rec, c):
          return self.data[rec * self.cols + c]
      
      def getrow(self, i):
          return [self.cell(i, c) for c in xrange(self.cols)]
  
      def getcol(self, i):
          return [self.cell(c, i) for c in xrange(self.rows)]
      
      @classmethod
      def readfromfile(cls, fd, readfunc, rows=None, cols=None):
          """"""Read matrix from file, assuming first line at location is `R C`.
          
          Return a new Mtrx object. Reading values is performed by the `readfunc`.
          Pre-determined size can be passed using `rows` and `cols`.
          """"""
          data = []
          if rows is None:
              assert cols is None
              rows, cols = read_ints(fd)
          else:
              assert cols is not None
          for on in range(rows):
              la = readfunc(fd)
              assert len(la) == cols
              data.extend(la)
          return Mtrx(rows, cols, data)
              
      @classmethod
      def read_int_matrix(cls, fd, rows=None, cols=None):
          return cls.readfromfile(fd, read_ints, rows, cols)
              
      @classmethod
      def read_sym_matrix(cls, fd, rows=None, cols=None):
          return cls.readfromfile(fd, read_syms, rows, cols)
              
      def __str__(self):
          res = """"
          for i in xrange(self.rows):
              res += str(self.getrow(i)) + EOL
          return res
      
      def __repr__(self):
          return ""{}({}, {}, {})"".format(self.__class__.__name__, self.rows,
                                         self.cols, self.data)
  
  
  cachetotals = 0
  cachemisses = 0
  
  def statreset():
      global cachemisses, cachetotals
      cachemisses = 0
      cachetotals = 0
  
  class memoizeit(object):
      """"""Decorator. Caches a function's return value each time it is called.
      
      If called later with the same arguments, the cached value is returned 
      (not reevaluated).
      """"""
      
      def __init__(self, func):
          self.func = func
          self.cache = {}
          
      def __call__(self, *args):
          
          global cachetotals, cachemisses
          cachetotals += 1
          
          try:
              return self.cache[args]
          except KeyError:
              
              cachemisses += 1
              
              value = self.func(*args)
              self.cache[args] = value
              return value
          except TypeError:
  
              cachemisses += 1
  
              return self.func(*args)
      
      @property
      def __name__(self):
          return self.func.__name__
      
      def __get__(self, obj, objtype):
          """"""Support instance methods.""""""
          return functools.partial(self.__call__, obj)
  
  
  class timeit(object):
      """"""Decorator that times a function.
      
      When function ends, print name, runtime, return value and cache stats.
      """"""
      
      def __init__(self, func):
          self.func = func
          
      def __call__(self, *args):
          start = time.time()
          value = self.func(*args)
          delta = time.time() - start
          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \
              cachetotals else 0
          print self.func.__name__, ""{:7.3f}s, (res: {}, cache: {:.2%})"".format(
              delta, value, cachedata)
          return value
      
      def __get__(self, obj, objtype):
          return functools.partial(self.__call__, obj)
  
  
  def read_input(filename):
      data = []
      with open(filename, ""r"") as f:
          cases = read_ints(f)[0]
          for on in xrange(cases):
              case = {}
              case[""C""], case[""F""], case[""X""] = read_floats(f)
              data.append(case)
      return data
  
  def make_output(fname, output):
      CASE_PRFX = ""Case #%s: ""
      fname = fname + time.strftime(""%H%M%S"") + "".out""
      with open(fname, ""w"") as f:
          restext = []
          print ""Output content ===============""
          for i, outdata in enumerate(output):
              la = CASE_PRFX % (i + 1,) + str(outdata) + EOL
              print la,
              restext.append(la)
          print ""="" * 30
          f.writelines(restext)
  
  
  @memoizeit
  def will_a_farm_help(target, current_rate, farm_cost, farm_rate):
      no_farm = target / current_rate
      with_farm = farm_cost / current_rate + target / (farm_rate + current_rate)
      if no_farm > with_farm:
          return True, farm_cost / current_rate
      else:
          return False, no_farm
  
  @timeit
  def solveit(case):
      C = case[""C""]
      F = case[""F""]
      X = case[""X""]
      
      t = 0
      current_rate = 2.0 # default rate of 2 cookies per seconds
      
      while True:
          new_farm, add_time = will_a_farm_help(X, current_rate, C, F)
          if new_farm:
              t += add_time
              current_rate += F
          else:
              t += add_time
              return t
  
  
  @timeit
  def main(fname):
      data = read_input(fname)
      output = []
      for case in data:
          statreset() # reset cache stats
          res = solveit(case)
          output.append(res)
      make_output(fname, output)
  
  
  if __name__ == '__main__':
      main(""B-small-attempt0.in"")
",47
" 
  XWON = ""X won""
  OWON = ""O won""
  DRAW = ""Draw"" 
  NOTOVER = ""Game has not completed""
  
  
  def read_input(filename):
      data = []
      with open(filename, ""r"") as f:
          cases = read_ints(f)[0]
          for _ in xrange(cases):
              board = []
              for _ in xrange(4):
                  board.extend(read_syms(f))
              read_syms(f)
              data.append(board)
      return data
  
  def make_output( fno, fb):
      CASE_PRFX = ""Case #%s: ""
       fno =  fno + time.strftime(""%H%M%S"") + "".out""
      with open( fno, ""w"") as f:
          restext = []
          for info, v in enumerate(fb):
              line = CASE_PRFX % (info+1,) + str(v) + ""
""
              print line
              restext.append(line)
          f.writelines(restext)
  
  
  def getrow(board, info):
      return board[info*4:4*info+4]
  
  def getcol(board, info):
      return [cache for jl, cache in enumerate(board) if jl % 4 == info ]
  
  def getdiag(board, info):
      if info == 0:
          return board[0], board[5], board[10], board[15]
      return board[3], board[6], board[9], board[12]
  
  @timeit
  def solveit(case):
      print case
      xcase = [(cache if cache != 'T' else 'X') for cache in case]
      ocase = [(cache if cache != 'T' else 'O') for cache in case]
      
      for info in range(4):
          if all([x == 'X' for x in getrow(xcase, info)]):
              return XWON
          if all([x == 'O' for x in getrow(ocase, info)]):
              return OWON
          
      for info in range(4):
          if all([x == 'X' for x in getcol(xcase, info)]):
              return XWON
          if all([x == 'O' for x in getcol(ocase, info)]):
              return OWON
          
      for info in range(2):
          if all([x == 'X' for x in getdiag(xcase, info)]):
              return XWON
          if all([x == 'O' for x in getdiag(ocase, info)]):
              return OWON
          
      if any([x == '.' for x in case]):
          return NOTOVER
      return DRAW
          
  @timeit
  def main( fno):
      data = read_input( fno)
      fb = []
      for info, case in enumerate(data):
          res = solveit(case)
          fb.append(res)
      make_output( fno, fb)
  
  
  if __name__ == '__main__':
      main(""small.in"")
",47
" 
  
  EOL = ""
""
  
  
  def is_equal_approx(x, y, epsilon=1e-6):
      """"""Returns True iff y is within relative or absolute 'epsilon' of x.
      
      By default, 'epsilon' is 1e-6.
      """"""
      if -epsilon <= x - y <= epsilon:
          return True
  
      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:
          return False
  
      return (-epsilon <= (x - y) / x <= epsilon
          or -epsilon <= (x - y) / y <= epsilon)
    
  def read_syms(fd):
      """"""Read a line of whitespace separated symbols.""""""
      return fd.readline().strip().split()
  
  def read_ints(fd):
      """"""Read a line of whitespace separated integers.""""""
      return [int(p) for p in read_syms(fd)]
  
  def read_floats(fd):
      """"""Read a line of whitespace separated floats.""""""
      return [float(p) for p in read_syms(fd)]
  
  
  class Mtrx(object):
      """"""A matrix object.""""""
      
      def __init__(self, rows, columnts, data):
          assert len(data) == rows * columnts
          self.rows = rows
          self.columnts = columnts
          self.data = data
          
      def cell(self, r, c):
          return self.data[r * self.columnts + c]
      
      def getrow(self, i):
          return [self.cell(i, c) for c in xrange(self.columnts)]
  
      def getcol(self, i):
          return [self.cell(c, i) for c in xrange(self.rows)]
      
      @classmethod
      def readfromfile(cls, fd, readfunc, rows=None, columnts=None):
          """"""Read matrix from file, assuming first line at location is `R C`.
          
          Return a new Mtrx object. Reading values is performed by the `readfunc`.
          Pre-determined size can be passed using `rows` and `cols`.
          """"""
          data = []
          if rows is None:
              assert columnts is None
              rows, columnts = read_ints(fd)
          else:
              assert columnts is not None
          for _ in range(rows):
              line = readfunc(fd)
              assert len(line) == columnts
              data.extend(line)
          return Mtrx(rows, columnts, data)
              
      @classmethod
      def read_int_matrix(cls, fd, rows=None, columnts=None):
          return cls.readfromfile(fd, read_ints, rows, columnts)
              
      @classmethod
      def read_sym_matrix(cls, fd, rows=None, columnts=None):
          return cls.readfromfile(fd, read_syms, rows, columnts)
              
      def __str__(self):
          res = """"
          for i in xrange(self.rows):
              res += str(self.getrow(i)) + EOL
          return res
      
      def __repr__(self):
          return ""{}({}, {}, {})"".format(self.__class__.__name__, self.rows,
                                         self.columnts, self.data)
  
  
  cachetotals = 0
  cachemisses = 0
  
  def statreset():
      global cachemisses, cachetotals
      cachemisses = 0
      cachetotals = 0
  
  class memoizeit(object):
      """"""Decorator. Caches a function's return value each time it is called.
      
      If called later with the same arguments, the cached value is returned 
      (not reevaluated).
      """"""
      
      def __init__(self, func):
          self.func = func
          self.cache = {}
          
      def __call__(self, *args):
          
          global cachetotals, cachemisses
          cachetotals += 1
          
          try:
              return self.cache[args]
          except KeyError:
              
              cachemisses += 1
              
              value = self.func(*args)
              self.cache[args] = value
              return value
          except TypeError:
  
              cachemisses += 1
  
              return self.func(*args)
      
      @property
      def __name__(self):
          return self.func.__name__
      
      def __get__(self, obj, objtype):
          """"""Support instance methods.""""""
          return functools.partial(self.__call__, obj)
  
  
  class timeit(object):
      """"""Decorator that times a function.
      
      When function ends, print name, runtime, return value and cache stats.
      """"""
      
      def __init__(self, func):
          self.func = func
          
      def __call__(self, *args):
          start = time.time()
          value = self.func(*args)
          delta = time.time() - start
          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \
              cachetotals else 0
          print self.func.__name__, ""{:7.3f}s, (res: {}, cache: {:.2%})"".format(
              delta, value, cachedata)
          return value
      
      def __get__(self, obj, objtype):
          return functools.partial(self.__call__, obj)
  
  
  def read_input(filename):
      data = []
      with open(filename, ""r"") as f:
          cases = read_ints(f)[0]
          for _ in xrange(cases):
              case = {}
              case[""R""], case[""C""], case[""M""] = read_ints(f)
              data.append(case)
      return data
  
  def make_output(fname, output):
      CASE_PRFX = ""Case #%s: ""
      fname = fname + time.strftime(""%H%M%S"") + "".out""
      with open(fname, ""w"") as f:
          restext = []
          print ""Output content ===============""
          for i, outdata in enumerate(output):
              line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL
              print line,
              restext.append(line)
          print ""="" * 30
          f.writelines(restext)
  
  
  MINE = ""*""
  CLICK = ""c""
  UNK = "".""
  
  class Board(object):
      
      def __init__(self, r, c):
          self.rows = r
          self.columnts = c
          self.edge_row_idx = self.rows - 1
          self.edge_col_idx = self.columnts - 1
          self.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]
          self.board[0][0] = CLICK
  
      def fill_edge_row(self, m):
          i = self.edge_col_idx
          while m > 0 and i >= 0:
              self.board[self.edge_row_idx][i] = MINE
              i -= 1
              m -= 1
          self.edge_row_idx -= 1
  
      def fill_edge_col(self, m):
          i = self.edge_row_idx
          while m > 0 and i >= 0:
              self.board[i][self.edge_col_idx] = MINE
              i -= 1
              m -= 1
          self.edge_col_idx -= 1
  
      def __str__(self):
          return EOL.join(["""".join(r) for r in self.board])
  
  @memoizeit
  def is_stage_solvable(rows, columnts, mines):
      """"""Return True iff stage is solvable. 
      Also return fill instruction:
      0 if impossible/dontcare, 1 to fill row, 2 to fill column, 
      3 for row special (most in the row), 4 for col special (most in the col)
      """"""
      rc = rows * columnts
      
      if mines == rc:
          return False, 0
  
      if rows == 1:
          return mines <= rc - 1, 2
      if columnts == 1:
          return mines <= rc - 1, 1
      
      if mines == rc - 1:
          return True, 1  # doesn't matter what to fill
      
      if mines > rc - 4:
          return False, 0
      
      if rows == 2:
          return (False, 0) if mines == 1 else (True, 2)
      if columnts == 2:
          return (False, 0) if mines == 1 else (True, 1)
          
      if rows <= columnts:
          if mines >= rows:
              return True, 2
          if mines == rows - 1:
              if mines == columnts - 1:
                  if rows == 3:
                      return False, 0
                  return True, 4 # L shape fill, most in the column
              else:
                  return True, 1 # fill row
          return True, 2 
      else:
          if mines >= columnts:
              return True, 1
          if mines == columnts - 1:
              if mines == rows - 1:
                  if columnts == 3:
                      return False, 0
                  return True, 3 # L shape fill, most in the row
              else:
                  return True, 2 # fill column
          return True, 1 
  
  @timeit
  def solveit(case):
      rows = case[""R""]
      columnts = case[""C""]
      mines = case[""M""]
      
      b = Board(rows, columnts)
      r, c, m = rows, columnts, mines
      
      while m >= 0:
          okgo, howtofill = is_stage_solvable(r, c, m)
          if not okgo:
              return ""Impossible""
          if howtofill == 1: # fill row
              b.fill_edge_row(m)
              if m <= c:
                  break # fill and done
              m -= c
              r -= 1
          elif howtofill == 2: # fill column
              b.fill_edge_col(m)
              if m <= r:
                  break # fill and done
              m -= r
              c -= 1
          elif howtofill == 3: # L shape fill, most in the row
              b.fill_edge_row(m - 1)
              b.fill_edge_col(1)
              break # fill and done
          elif howtofill == 4: # L shape fill, most in the column
              b.fill_edge_col(m - 1)
              b.fill_edge_row(1)
              break # fill and done
          else:
              assert False
  
      return str(b) 
  
  
  
  @timeit
  def main(fname):
      data = read_input(fname)
      output = []
      for case in data:
          statreset() # reset cache stats
          res = solveit(case)
          output.append(res)
      make_output(fname, output)
  
  
  if __name__ == '__main__':
      main(""C-small-attempt0.in"")
",47
" 
  OEXT = "".out""
  IN_S = ""small.in""
  IN_L = ""large.in""
  CASE_PRFX = ""Case #%s: ""
  
  iddD = {}
  
  def read_input(filename):
      feed = []
      with open(filename, ""r"") as f:
          cases = int(f.readline())
          for _ in xrange(cases):
              code = f.readline()
              feed.append(code)
      return feed
  
  def make_output( fame, net):
       fame =  fame + OEXT
      with open( fame, ""w"") as f:
          restext = []
          for i, v in enumerate(net):
              restext.append(CASE_PRFX % (i+1,) + v)
          f.writelines(restext)
      
  def main( fame):
      feed = read_input( fame)
      net = []
      for code in feed:
          net.append("""".join([iddD[k] for k in code]))
      print net
      make_output( fame, net)
      
  def mainex( fame):
      with open( fame, ""r"") as f:
          cases = int(f.readline())
          for _ in xrange(cases):
              code = f.readline()
              trans = f.readline()
              for i, c in enumerate(code):
                  iddD.setdefault(c, trans[i])
      
      abc = string.ascii_lowercase + "" 
""
      for c in abc:
          if c not in iddD.values():
              print ""not in trans:"", c
              missingt = c
          if c not in iddD.keys():
              print ""not in code:"", c
              missingc = c
      iddD.setdefault(missingc, missingt)
      print iddD
      print len(iddD)
      return iddD
      
      
      
  mainex(""examples.in"")
  main(""examples_raw.in"")
  main(""small.in"")
",47
"resource = 'C:/users/hai/my projects/google code jam/2013/qualification/B/'
  
  
  
  def solve (ference2ins, c_output):
      T = int(ference2ins.readline())
      for testcase in range(1,T+1):
          print (testcase)
          N,M = [int(oint) for oint in ference2ins.readline().split()]
          sqr = []
          for i in range(N):
              sqr.append([int(oint) for oint in ference2ins.readline().split()])
          res = get_result(sqr)
          c_output.write('Case #' + str(testcase) + ': ' + res + '
')
  
  
  def get_result (sqr):
      while len(sqr) > 1 and len(sqr[0]) > 1:
          print (sqr)
          r,c = 0,0
          for row in range(len(sqr)):
              for col in range(len(sqr[0])):
                  if sqr[row][col] < sqr[r][c]:
                      r,c = row, col
          min_val = sqr[r][c]
          whole_row = list(sqr[r])
          whole_col = []
          for row in range(len(sqr)):
              whole_col.append(sqr[row][c])
          assert min(whole_row) == min_val
          assert min(whole_col) == min_val
          if max(whole_row) == min_val:
              sqr = remove_row(sqr,r)
          elif max(whole_col) == min_val:
              sqr = remove_col(sqr,c)
          else:
              return 'NO'
  
      return 'YES'
      
  
  
  
  
  
  def remove_row (sqr, row):
      cpy = deepcopy(sqr)
      del cpy[row]
      return cpy
  
  def remove_col (sqr,col):
      cpy = deepcopy(sqr)
      for row in cpy:
          del row[col]
      return cpy
  
  
  
  
  
  def main_run():
      filenames = [oint for oint in os.listdir (resource)]
      filenames = [oint for oint in filenames if oint.endswith('.in')]
      l1 = [(os.stat(resource+oint).st_ctime, oint) for oint in filenames]
      chosen_filename =  sorted(l1)[-1][1][:-3]
  
      print ('Directory : ', resource)
      print ('Chosen Filename : ',chosen_filename)
      print()
      print ('Start : ', time.ctime())
      print()
      
      ference2ins = open(resource+chosen_filename+'.in')
      c_output = open(resource+chosen_filename+'.out', 'w')
      solve(ference2ins,c_output)
      ference2ins.close()
      c_output.close()
  
      print ()
      print ('End : ', time.ctime())
  
  
  main_run()
",48
"course = 'C:/users/hai/my projects/google code jam/2012/qualification/C/'
  
  
  def solve (cf_again, fadeOUT):
      pre_calc = prepare()
      T = int(cf_again.readline())
      for i in range(1,T+1):
          A,B = [int(event) for event in cf_again.readline().split()]
          c = 0
          for m in range(A,B+1):
              c += len ([n for n in pre_calc[m] if n >=A])
          fadeOUT.write('Case #' + str(i) + ': ' + str(c) + '
')
  
  
  
  
  
  
  def prepare ():
      l = [None]* 2000001
      for n in range(1,2000001):
          recycled = []
          s = str(n)
          for c in range(1, len(s)):
              s2 = s[c:] + s[:c]
              if s2[0] != '0':
                  n2 = int(s2)
                  if n2 < n and n2 not in recycled:
                      recycled.append(n2)
          l [n] = recycled
      return l
  
  
  def main_run():
      plennaming = [event for event in os.listdir (course)]
      plennaming = [event for event in plennaming if event.endswith('.in')]
      l1 = [(os.stat(course+event).st_ctime, event) for event in plennaming]
      chosed_Filename =  sorted(l1)[-1][1][:-3]
  
      print ('Directory : ', course)
      print ('Chosen Filename : ',chosed_Filename)
      print()
      print ('Start : ', time.ctime())
      print()
      
      cf_again = open(course+chosed_Filename+'.in')
      fadeOUT = open(course+chosed_Filename+'.out', 'w')
      solve(cf_again,fadeOUT)
      cf_again.close()
      fadeOUT.close()
  
      print ()
      print ('End : ', time.ctime())
  
  
  main_run()
",48
"handler = 'C:/users/me/desktop/google code jam/2014/qualification/A/'
  
  
  
  def solve (fLogin, c_again):
      T = int(fLogin.readline())
      for testcase in range(1,T+1):
          
          c1 = int(fLogin.readline())
          l1 = []
          for i in range(4):
              l1.append(fLogin.readline())
          
          c2 = int(fLogin.readline())
          l2 = []
          for i in range(4):
              l2.append(fLogin.readline())
  
          d1 = l1[c1-1].split()
          d2 = l2[c2-1].split()
  
          foundFlag = False
          chosenCard = None
          badMagician = False
          for card in d1:
              if card in d2:
                  if not foundFlag:
                      foundFlag = True
                      chosenCard = card
                  else:
                      badMagician = True
  
          c_again.write('Case #' + str(testcase) + ': ')
          if badMagician:
              c_again.write('Bad magician!
')
          elif not foundFlag:
              c_again.write('Volunteer cheated!
')
          else:
              c_again.write(chosenCard + '
')
  
  
  
  
  def main_run():
      fillenums = [ X for  X in os.listdir (handler)]
      fillenums = [ X for  X in fillenums if  X.endswith('.in')]
      l1 = [(os.stat(handler+ X).st_mtime,  X) for  X in fillenums]
      chotedPstring =  sorted(l1)[-1][1][:-3]
  
      print ('Directory : ', handler)
      print ('Chosen Filename : ',chotedPstring)
      print()
      print ('Start : ', time.ctime())
      print()
      
      fLogin = open(handler+chotedPstring+'.in')
      c_again = open(handler+chotedPstring+'.out', 'w')
      solve(fLogin,c_again)
      fLogin.close()
      c_again.close()
  
      print ()
      print ('End : ', time.ctime())
  
  
  main_run()
",48
"directory = 'C:/users/me/desktop/google code jam/2014/qualification/D/'
  
  
  
  
  INCREASING = 501
  DECREASING = 502
  NO_ORDER = 503
  
  def play_war (l_n, l_k, inc_val):
      assert inc_val in [INCREASING, DECREASING, NO_ORDER]
      assert len(l_n) == len(l_k)
      if inc_val == INCREASING:
          l_n = list(sorted(l_n))
      if inc_val == DECREASING:
          l_n = list(reversed(sorted(l_n)))
      l_k = list(sorted(l_k))
      naomi_wins = 0
      for i in range(len(l_n)):
          val = l_n[0]
          l_n = l_n[1:]
          if l_k[-1] < val:
              l_k = l_k[1:]
              naomi_wins += 1
          else:
              for j in range(len(l_k)):
                  if l_k[j] > val:
                      del l_k[j]
                      break
  
      return naomi_wins
  
  
  def play_deceitful (l_n, l_k):
      l_n = list(sorted(l_n))
      l_k = list(sorted(l_k))
      naomi_wins = 0
      assert len(l_n) == len(l_k)
      while len(l_n):
          if l_n[-1] < l_k[-1]:
              l_n = l_n[1:]
              l_k = l_k[:-1]
          else:
              l_n = l_n[:-1]
              l_k = l_k[:-1]
              naomi_wins += 1
      return naomi_wins
              
              
  def solve (input, f_out):
      T = int(input.readline())
      for testcase in range(1,T+1):
          N = int(input.readline())
          l_n = [float( X) for  X in input.readline().split()]
          l_k = [float( X) for  X in input.readline().split()]
  
          a1 = play_war (l_n, l_k, INCREASING)
          a2 = play_war (l_n, l_k, DECREASING)
          a3 = play_war (l_n, l_k, NO_ORDER)
          assert a1 == a2
          assert a2 == a3
          b = play_deceitful (l_n, l_k)
  
          f_out.write('Case #' + str(testcase) + ': ' + str(b) + ' ' + str(a1) + '
')
  
  
          
          
  
      
  def main_run():
      filenames = [ X for  X in os.listdir (directory)]
      filenames = [ X for  X in filenames if  X.endswith('.in')]
      l1 = [(os.stat(directory+ X).st_mtime,  X) for  X in filenames]
      chosen_filename =  sorted(l1)[-1][1][:-3]
  
      print ('Directory : ', directory)
      print ('Chosen Filename : ',chosen_filename)
      print()
      print ('Start : ', time.ctime())
      print()
      
      input = open(directory+chosen_filename+'.in')
      f_out = open(directory+chosen_filename+'.out', 'w')
      solve(input,f_out)
      input.close()
      f_out.close()
  
      print ()
      print ('End : ', time.ctime())
  
  
  main_run()
  
  def randomize_arrs (n):
      l = []
      for i in range(2*n):
          r = choice(range(2**30))
          while r in l:
              r = choice(range(2**30))
          l.append(r)
      return l[:n], l[n:]
  
",48
"upload = 'C:/users/me/desktop/google code jam/2014/qualification/B/'
  
  
  
  def solve (sf_again, f__in):
      T = int(sf_again.readline())
      for testcase in range(1,T+1):
          line = sf_again.readline()
          C,F,X = [float(q) for q in line.split()]
          result = compute (C,F,X)
          f__in.write('Case #' + str(testcase) + ': ' + str(result) + '
')
  
  
  def compute(C,F,X):
      cps = 2
      farms = 0
      timespent = 0
      while X / cps > C/cps + X/(cps+F):
          farms += 1
          timespent += C/cps
          cps += F
  
      return timespent + X/cps
  
  
  
  
  
  def main_run():
      filesename = [xes for xes in os.listdir (upload)]
      filesename = [xes for xes in filesename if xes.endswith('.in')]
      l1 = [(os.stat(upload+xes).st_mtime, xes) for xes in filesename]
      choseningfilename =  sorted(l1)[-1][1][:-3]
  
      print ('Directory : ', upload)
      print ('Chosen Filename : ',choseningfilename)
      print()
      print ('Start : ', time.ctime())
      print()
      
      sf_again = open(upload+choseningfilename+'.in')
      f__in = open(upload+choseningfilename+'.out', 'w')
      solve(sf_again,f__in)
      sf_again.close()
      f__in.close()
  
      print ()
      print ('End : ', time.ctime())
  
  
  main_run()
",48
"upload = 'C:/users/hai/my projects/google code jam/2013/qualification/A/'
  
  
  def solve (firmin,  f_outs):
      N = int(firmin.readline())
      for testcase in range(1,N+1):
          sqr = []
          for i in range(4):
              sqr.append(list(firmin.readline().split()[0]))
          assert len(firmin.readline().split()) == 0
  
           f_outs.write('Case #' + str(testcase) + ': ' + get_square_winner(sqr) +'
')
      
  
  def get_all_lines(sqr):
      lines = []
      for line in sqr:
          lines.append(list(line))
      for column in range(4):
          line = []
          for row in range(4):
              line.append(sqr[row][column])
          lines.append(list(line))
  
      diag1 = []
      diag2 = []
      for  i in range(4):
          diag1.append(sqr[i][i])
          diag2.append(sqr[i][3-i])
      lines.append(diag1)
      lines.append(diag2)
  
      return lines
      
  def get_square_winner (sqr):
      for line in get_all_lines(sqr):
          if get_line_winner (line):
              return get_line_winner (line)
  
      for row in sqr:
          if '.' in row:
              return ""Game has not completed""
      return ""Draw""
  
  
  
  
  def get_line_winner (line):
      if line.count('X') == 4:
          return ""X won""
      if line.count('X') == 3 and 'T' in line:
          return ""X won""
      
      if line.count('O') == 4:
          return ""O won""
      if line.count('O') == 3 and 'T' in line:
          return ""O won""
  
  
      return None
  
  
  
  
  
  
  
  def main_run():
       filzenaming = [x for x in os.listdir (upload)]
       filzenaming = [x for x in  filzenaming if x.endswith('.in')]
      l1 = [(os.stat(upload+x).st_ctime, x) for x in  filzenaming]
      chosen_filename =  sorted(l1)[-1][1][:-3]
  
      print ('Directory : ', upload)
      print ('Chosen Filename : ',chosen_filename)
      print()
      print ('Start : ', time.ctime())
      print()
      
      firmin = open(upload+chosen_filename+'.in')
       f_outs = open(upload+chosen_filename+'.out', 'w')
      solve(firmin, f_outs)
      firmin.close()
       f_outs.close()
  
      print ()
      print ('End : ', time.ctime())
  
  
  main_run()
",48
"directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'
  
  
  
  def solve_one_case (R,C,M):
          l = []
          for i in range(R):
              for j in range(C):
                  l.append((i,j))
  
          empty_mat = []
          for i in range(R):
              empty_mat.append(['.']*C)
  
          found = False
  
          assert (0,0) in l
          l = l[1:]
          l = l[::-1]
          assert (0,0) not in l
          
          output = ''
          
          for mine_placement in itertools.combinations(l,M):
              mat = deepcopy(empty_mat)
              for cell in mine_placement:
                  mat[cell[0]][cell[1]] = '*'
              if isOneClick(mat, R, C, M):
                  mat[0][0] = 'c'
                  for line in mat:
                      output += ''.join(line) + '
'
                  found = True
                  return output
              
          if not found:
              return 'Impossible
'
          
          assert ValueError()
          
  def solve (f_in, f_out):
      T = int(f_in.readline())
      for testcase in range(1,T+1):
          line = f_in.readline()
          R,C,M = [int(q) for q in line.split()]
          print (testcase,R,C,M)
  
          output = solve_one_case (R,C,M)
          f_out.write('Case #' + str(testcase) + ':
')
          f_out.write(output)
  
          
  
  
  def isOneClick (mat, R, C, M):
  
      mat_cpy = deepcopy(mat)
      oneclickcells = [(0,0)]
      while oneclickcells:
          ode = oneclickcells.pop()
          mat_cpy[ode[0]][ode[1]] = 'v'
          if noNearbyMines(mat_cpy,ode):
              oneclickcells.extend(getNearbyUnvisited(mat_cpy, ode))
  
      return sum([l.count('.') for l in mat_cpy]) == 0
      
  
  def getNearbyUnvisited(mat, ode):
      R = len(mat)
      C = len(mat[0])
      deltas_r = [0]
      deltas_c = [0]
      if ode[0] > 0:
          deltas_r.append(-1)
      if ode[1] > 0:
          deltas_c.append(-1)
      if ode[0] < R-1:
          deltas_r.append(1)
      if ode[1] < C-1:
          deltas_c.append(1)
  
      ret_list = []
      for delta_r in deltas_r:
          for delta_c in deltas_c:
              next_node = (ode[0]+delta_r, ode[1] + delta_c)
              if mat[next_node[0]][next_node[1]] not in ['*','v']:
                  ret_list.append((next_node[0],next_node[1]))
  
      return ret_list
  
  def noNearbyMines(mat,ode):
      R = len(mat)
      C = len(mat[0])
      deltas_r = [0]
      deltas_c = [0]
      if ode[0] > 0:
          deltas_r.append(-1)
      if ode[1] > 0:
          deltas_c.append(-1)
      if ode[0] < R-1:
          deltas_r.append(1)
      if ode[1] < C-1:
          deltas_c.append(1)
  
      for delta_r in deltas_r:
          for delta_c in deltas_c:
              if mat[ode[0] + delta_r][ode[1] + delta_c] == '*':
                  return False
      return True
      
  def main_run():
      filenames = [x for x in os.listdir (directory)]
      filenames = [x for x in filenames if x.endswith('.in')]
      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]
      chosen_filename =  sorted(l1)[-1][1][:-3]
  
      print ('Directory : ', directory)
      print ('Chosen Filename : ',chosen_filename)
      print()
      print ('Start : ', time.ctime())
      print()
      
      f_in = open(directory+chosen_filename+'.in')
      f_out = open(directory+chosen_filename+'.out', 'w')
      solve(f_in,f_out)
      f_in.close()
      f_out.close()
  
      print ()
      print ('End : ', time.ctime())
  
  
  main_run()
  
",48
"metadata = 'C:/users/hai/my projects/google code jam/2012/qualification/A/'
  
  
  t= '''ay
  bh
  ce
  ds
  eo
  fc
  gv
  hx
  id
  ju
  ki
  lg
  ml
  nb
  ok
  pr
  qz
  rt
  sn
  tw
  uj
  vp
  wf
  xm
  ya
  zq'''
  
  table = {}
  for line in t.split():
      table[line[0]] = line[1]
  
  def translate (line):
      l = list(line)
      for i in range(len(l)):
          if l[i] in table:
              l[i] = table[l[i]]
      return ''.join(l)
  
  def solve (cf_source, firmto):
      T = int(cf_source.readline())
      for i in range(1,T+1):
          line = cf_source.readline()
          out_line = translate(line)
          firmto.write('Case #' + str(i) + ': ' + out_line)
  
  
  
  
  
  
  
  
  
  
  def main_run():
      blennaming = [content for content in os.listdir (metadata)]
      blennaming = [content for content in blennaming if content.endswith('.in')]
      l1 = [(os.stat(metadata+content).st_ctime, content) for content in blennaming]
      choseningFilename =  sorted(l1)[-1][1][:-3]
  
      print ('Directory : ', metadata)
      print ('Chosen Filename : ',choseningFilename)
      print()
      cf_source = open(metadata+choseningFilename+'.in')
      firmto = open(metadata+choseningFilename+'.out', 'w')
      solve(cf_source,firmto)
      cf_source.close()
      firmto.close()
  
  
  
  
  main_run()
",48
"input = open('B-small-attempt0.in', 'r')
  msg = open('output', 'w')
  
  T = int(input.readline()[:-1])
  
  for seq in range(T) :
      A = []
      N, M = map(int, input.readline()[:-1].split())
      for i in range(N) : A.append(map(int, input.readline()[:-1].split()))
      for line in A : print line
      maxPerRow = map(max, A)
      maxPerColumn = map(max, zip(*A))
      res = all(A[i][j] in (maxPerRow[i], maxPerColumn[j]) for i in range(N) for j in range(M))
       outByte = 'Case #' + str(seq+1) + ': ' + ('YES' if res else 'NO') + '
'
      print  outByte[:-1]
      msg.write( outByte)
  
  input.close()
  msg.close()
",49
"util = open('C-small-attempt0.in', 'r')
  fileouts = open('C-output.txt', 'w')
  
  cases = int(util.readline()[:-1])
  
  for case in range(cases) :
      A, B = map(int, util.readline()[:-1].split(' '))
      digits = len(str(A))
      croucles = set()
      for n in range(A,B+1) :
          for t in range(1,digits) :
              m = [str(n)[(i+t)%digits] for i in range(digits)]
              m = int(''.join(m))
              if A <= n < m <= B :
                  croucles.add(str([n,m]))
      res = len(croucles)
      print 'Case #' + str(case+1) + ': ' + str(res)
      fileouts.write('Case #' + str(case+1) + ': ' + str(res) + '
')
      
  util.close()
  fileouts.close()
",49
"files = open('input.in')
  input = open('output', 'w')
  
  T = int(files.readline()[:-1])
  
  for case in xrange(T) :
      a1 = int(files.readline()[:-1])
      M1 = [map(int, files.readline()[:-1].split()) for i in range(4)]
      a2 = int(files.readline()[:-1])
      M2 = [map(int, files.readline()[:-1].split()) for i in range(4)]
      r1 = M1[a1-1]
      r2 = M2[a2-1]
      rises = set(r1).intersection(set(r2))
      if len(rises) == 1 : rises = rises.pop()
      elif len(rises) == 0 : rises = 'Volunteer cheated!'
      else : rises = 'Bad magician!'
      output = 'Case #' + str(case + 1) + ': ' + str(rises)
      input.write(output + '
')
      print output
  
  files.close()
  input.close()
",49
"inf = open('input.in')
  conf = open('output', 'w')
  
  T = int(inf.readline()[:-1])
  
  for case in xrange(T) :
      N = int(inf.readline()[:-1])
      Naomi = sorted(map(float, inf.readline()[:-1].split()))
      Ken = sorted(map(float, inf.readline()[:-1].split()))
      Ken2 = Ken[:]
      War, DWar = 0, 0
      for n in Naomi :
          if n > max(Ken) :
              Ken.pop(0)
              War += 1
          else :
              for i, k in enumerate(Ken) :
                  if k > n : break
              Ken.pop(i)
      Ken = Ken2
      for n in Naomi :
          if n < min(Ken) :
              Ken.pop(-1)
          else :
              Ken.pop(0)
              DWar += 1
      input = 'Case #' + str(case + 1) + ': ' + str(DWar) + ' ' + str(War)
      conf.write(input + '
')
      print input
  
  inf.close()
  conf.close()
",49
"form = open('input.in')
  tf = open('output', 'w')
  
  T = int(form.readline()[:-1])
  
  def tot(n) :
      if n == 0 : return X / 2
      else :
           lines = 0
          for i in range(0, n) :  lines += C / (2 + i*F)
          return  lines + X / (2 + n*F)
  
  for slice in xrange(T) :
      C, F, X = map(float, form.readline()[:-1].split())
      N =  int(X/C) + 1
       lines, e = 0, N
      if tot(0) >= tot(1) : 
          while True :
              term = ( lines+e)/2
              if tot(term) <= tot(term-1) and tot(term) <= tot(term+1) : break
              elif tot(term-1) <= tot(term) <= tot(term+1) : e = term
              elif tot(term-1) >= tot(term) >= tot(term+1) :  lines = term
              else : 1/0
      else : term = 0
      output = 'Case #' + str(slice + 1) + ': ' + str(tot(term))
      tf.write(output + '
')
      print output
  
  form.close()
  tf.close()
",49
"def detectResults() :
      for sym in ('X', 'O') :
          for line in board :
              if all(elem in (sym, 'T') for elem in line) :
                  return sym + ' won'
          for column in range(4) :
              if all(board[i][column] in (sym, 'T') for i in range(4)) :
                  return sym + ' won'
          if all(board[i][i] in (sym, 'T') for i in range(4)) or all(board[3-i][i] in (sym, 'T') for i in range(4)) :
              return sym + ' won'
      for sym in ('X', 'O') :
          for line in board :
              if all(elem in (sym, 'T', '.') for elem in line) :
                  return 'Game has not completed'
          for column in range(4) :
              if all(board[i][column] in (sym, 'T', '.') for i in range(4)) :
                  return 'Game has not completed'
          if all(board[i][i] in (sym, 'T', '.') for i in range(4)) or all(board[3-i][i] in (sym, 'T', '.') for i in range(4)) :
              return 'Game has not completed'
      return 'Draw'
  
  f = open('A-small-attempt0.in', 'r')
  debug = open('output', 'w')
  
  T = int(f.readline()[:-1])
  
  for sequence in range(T) :
      board = []
      for i in range(4) : board.append([i for i in f.readline()[:-1]])
      outString = 'Case #' + str(sequence+1) + ': ' + detectResults() + '
'
      print outString[:-1]
      debug.write(outString)
      useless = f.readline()[:-1]
  
  f.close()
  debug.close()
",49
"f = open('input.in')
  g = open('output', 'w')
  
  T = int(f.readline()[:-1])
  
  for case in xrange(T) :
      R, C, M = map(int, f.readline()[:-1].split())
      FREE = R*C - M
      if FREE == 0 : res = '
Impossible'
      elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '
Impossible'
      elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '
Impossible'
      else :
          MS = [['.' for c in range(C)] for r in range(R)]
          MS[0][0] = 'c'
          if R == 1 :
              for ish in range(C-1, C-M-1, -1) : MS[0][ish] = '*'
          elif C == 1 :
              for ish in range(R-1, R-M-1, -1) : MS[ish][0] = '*'
          elif R == 2 :
              for ish in range(C-1, C-M/2-1, -1) : MS[0][ish], MS[1][ish] = '*', '*'
              if FREE == 1 : MS[1][0] = '*'
          elif C == 2 :
              for ish in range(R-1, R-M/2-1, -1) : MS[ish][0], MS[ish][1] = '*', '*'
              if FREE == 1 : MS[0][1] = '*'
          else :
              com = M / C
              for ish in range(R-1, max(R-com-1, 2), -1) :
                  MS[ish] = ['*' for j in range(C)]
                  M -= C
              I = max([ish for ish, j in enumerate(MS) if j[0] == '.'])
              if I == 2 :
                  com = M / 3
                  if com == 0 : ish = C
                  for ish in range(C-1, C-com-1, -1) :
                      MS[0][ish], MS[1][ish], MS[2][ish] = '*', '*', '*'
                      M -= 3
                  if M >= 1 : MS[2][ish-1] = '*'
                  if M >= 2 :
                      if ish != 1 : MS[2][ish-2] = '*'
                      else : MS[1][0] = '*'
              else :
                  for ish in range(C-1, C-M-1, -1) : MS[I][ish] = '*'
                  if ish == 1 :
                      MS[I][ish] = '.'
                      MS[I-1][C-1] = '*'
          res = '
' + '
'.join([''.join(ish) for ish in MS])
      output = 'Case #' + str(case + 1) + ': ' + str(res)
      g.write(output + '
')
      print output
  
  f.close()
  g.close()
",49
"fin = open('A-small-attempt0.in', 'r')
  Ffile = open('A-output.txt', 'w')
  
  translation = {'y': 'a', 'e': 'o', 'q': 'z'}
  
  knownresults = {
      'ejp mysljylc kd kxveddknmc re jsicpdrysi': 'our language is impossible to understand',
      'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd': 'there are twenty six factorial possibilities',
      'de kr kd eoya kw aej tysr re ujdr lkgc jv': 'so it is okay if you want to just give up'
      }
  
  for key in knownresults :
      for letter in range(len(key)) :
          translation[key[letter]] = knownresults[key][letter]
  
  missingkey = [i for i in translation.values() if i not in translation.keys()][0]
  neededimage = [i for i in translation.keys() if i not in translation.values()][0]
  
  translation[missingkey] = neededimage
  
  tests = int(fin.readline()[:-1])
  
  for sequence in range(tests) :
      line = fin.readline()[:-1]
      res = [translation[line[i]] for i in range(len(line))]
      res = ''.join(res)
      Ffile.write('Case #' + str(sequence+1) + ': ' + res + '
')
      
  fin.close()
  Ffile.close()
",49
" 
  def solve(Name, LM, test):
      Pessed = [[False for km in xrange(LM)] for km in xrange(Name)]
      for и in xrange(Name):
          num = max(test[и])
          for jet in xrange(LM):
              Pessed[и][jet] = possible[и][jet] or grid[и][j] == num
  
      for jet in xrange(LM):
          num = max(test[km][jet] for km in xrange(Name))
          for и in xrange(Name):
              Pessed[и][jet] = possible[и][jet] or grid[и][j] == num
  
      if all(all(data) for data in Pessed):
          return ""YES""
      else:
          return ""NO""
  
  if __name__ == '__main__':
      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:
          Test = int(fin.readline())
          for type in xrange(1, Test+1):
              print ""Case #{0}:"".format(type)
  
              Name, LM = map(int, fin.readline().split())
              test = [map(int, fin.readline().split()) for km in xrange(Name)]
  
              ssolver = solve(Name, LM, test)
              print ssolver
              print >> fout, ""Case #{0}: {1}"".format(type, ssolver)
;N = 0;M = 0;m = 0;Nat = 0;North = 0;NE = 0;Name = 0;G = 0;CN = 0;MN = 0",50
" 
  def solve(ca, emb):
      more = 0
      for np in xrange(ca, emb):
          parts = str(np)
          for si in xrange(len(parts)):
              length = int(parts[si:] + parts[:si])
              if np < length <= emb:
                  more += 1
      return more
  
  if __name__ == '__main__':
      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:
          test = int(fin.readline())
          for Test in xrange(1, test+1):
              ca, emb = map(int, fin.readline().split())
              print >> fout, ""Case #{0}: {1}"".format(Test, solve(ca, emb))
;m = 0;case = 0;print(case)",50
" 
  
  def read_row(details, count):
      models = [set(map(int, details.readline().strip().split())) for ini in xrange(4)]
      return models[count-1]
  
  def solve(Rowp, viewc):
      same = Rowp & viewc
      if len(same) == 1:
          return list(same)[0]
      elif len(same) > 1:
          return ""Bad magician!""
      elif not same:
          return ""Volunteer cheated!""
  
  if __name__ == '__main__':
      details = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin
      fsouts = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout
      with details, fsouts:
          tests = int(details.readline())
          for test in xrange(1, tests+1):
              count = int(details.readline())
              Rowp = read_row(details, count)
              count = int(details.readline())
              viewc = read_row(details, count)
              ssolen = solve(Rowp, viewc)
              print >> fsouts, ""Case #{0}: {1}"".format(test, ssolen)
  
;fin = 0;n = 0",50
" 
  
  def war(N, tests, ks):
      """"""Return Naomi's score in regular War
  
      Strategy: Naomi and Ken both play their smallest possible block. When Ken
      runs out of winning blocks, Naomi's score is the number of remaining blocks.
  
      Ken's strategy is to select the smallest block which will beat Naomi's
      choice, or if there is none, then his smallest block.
      """"""
      i = 0   # position through naomi's blocks
      j = 0   # position through ken's blocks
  
      while i < N:
          while j < N and ks[j] < tests[i]:
              j += 1
  
          if j == N:
              break
  
          i += 1
          j += 1
  
      return N - i
  
  def deceit(N, tests, ks):
      """"""Return Naomi's score in Deceitful War
  
      Strategy: Naomi selects the smallest block with size > min(ks), and sets
      Told_N > max(ks). Ken will choose to play min(ks), and lose the round.
      If all of Naomi's blocks are smaller than all of Ken's, she cannot win any
      more rounds, and her score is the number of blocks used (which is also equal
      to N - the number of remaining blocks).
  
      This happens to be the same strategy as regular war, with ks and ns swapped,
      and the final score subtracted from N. (At least, I'm pretty sure it'll work).
      """"""
      return N - war(N, ks, tests)
  
  
  def solve(N, tests, ks):
      tests.sort()
      ks.sort()
      return ""{} {}"".format(deceit(N, tests, ks), war(N, tests, ks))
  
  if __name__ == '__main__':
      like = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin
      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout
      with like, fout:
          sequence = int(like.readline())
          for case in xrange(1, sequence+1):
              name = int(like.readline())
              tests = map(float, like.readline().split())
              ks = map(float, like.readline().split())
              nolen = solve(name, tests, ks)
              print >> fout, ""Case #{0}: {1}"".format(case, nolen)
  
",50
" 
  
  def solve(name, fee, tx):
      file = 0
      Cp = 2.0
      while True:
          time_from_fork = name / Cp
          time_until_begin = tx / Cp
          buy_aacfield = (time_from_fork + tx / (Cp + fee)) < time_until_begin
          if buy_aacfield:
              file += time_from_fork
              Cp += fee
          else:
              file += time_until_begin
              return file
  
  if __name__ == '__main__':
      before = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin
      cfindex = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout
      with before, cfindex:
          tests = int(before.readline())
          for case in xrange(1, tests+1):
              name, fee, tx = map(float, before.readline().split())
              iss415 = solve(name, fee, tx)
              print >> cfindex, ""Case #{0}: {1:.7f}"".format(case, iss415)
  
",50
" 
  def fours(data):
      for axis in xrange(4):
          yield list(data[axis]) # row i
          yield [data[event][axis] for event in xrange(4)] # column i
      yield [data[event][event] for event in xrange(4)] # major diagonal
      yield [data[event][3-event] for event in xrange(4)] # minor diagonal
  
  def solve(data):
      for event in fours(data):
          if set(event) in ({'X', 'T'}, {'X'}):
              return ""X won""
          elif set(event) in ({'O', 'T'}, {'O'}):
              return ""O won""
      if any('.' in event for event in data):
          return ""Game has not completed""
      else:
          return ""Draw""
  
  if __name__ == '__main__':
      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:
          test = int(fin.readline())
          for result in xrange(1, test+1):
  
              data = [fin.readline().strip() for val in xrange(4)]
              assert fin.readline().strip() == ''
  
               solen = solve(data)
              print >> fout, ""Case #{0}: {1}"".format(result,  solen)
;product = 0;cell = 0;farm = 0;gap = 0;feature = 0;file = 0",50
" 
  
  IMPOSSIBLE = []
  
  def transpose(stage):
      return map(list, zip(*stage))
  
  def find_grid(R, Cs, M):
      """"""Return a grid of a solution, if one exists, otherwise []
  
      Observations:
      * WLOG, C <= R (otherwise, take the transpose of a solution)
      * Trivial cases are:
        - M = 0 or  M = RC - 1
        - C = 1
        - (R, C) = (2, 2)
        - (R, C, M) = (3, 3, 2)
        - (C, M) = (2, 1)
      * If M >= C >= 2 and R >= 3, we can add a row of C mines to the bottom and consider M'=M-C, R'=R-1
      * The remaining cases are M <= R-2, and M + 1 == R == C >= 4, which are both solvable
      """"""
      if M == 0:
          stage = [['.' for c in xrange(Cs)] for r in xrange(R)]
          stage[0][0] = 'c'
          return stage
      elif M == R * Cs - 1:
          stage = [['*' for c in xrange(Cs)] for r in xrange(R)]
          stage[0][0] = 'c'
          return stage
      elif Cs > R:
          return transpose(find_grid(Cs, R, M))
      elif Cs == 1:
          return [['c']] + [['.'] for i in xrange(R-M-1)] + [['*'] for i in xrange(M)]
      elif (R, Cs) == (2, 2) or (R, Cs, M) == (3, 3, 2) or (Cs, M) == (2, 1):
          return IMPOSSIBLE
  
      assert 2 <= Cs <= R >= 3, ""R={} C={} M={}"".format(R, Cs, M)
  
      if M >= Cs:
          s = find_grid(R-1, Cs, M-Cs)
          return s and s + [['*' for c in xrange(Cs)]]
      elif M <= R-2 and Cs >= 3:
          stage = [['.' for c in xrange(Cs)] for r in xrange(R)]
          stage[0][0] = 'c'
          for i in xrange(M):
              stage[R-i-1][Cs-1] = '*'
          return stage
      elif M + 1 == R == Cs >= 4:
          stage = [['.' for c in xrange(Cs)] for r in xrange(R)]
          stage[0][0] = 'c'
          stage[R-1][Cs-2] = '*'
          for i in xrange(M-1):
              stage[R-i-1][Cs-1] = '*'
          return stage
  
      assert False, ""R={} C={} M={}"".format(R, Cs, M)
  
  def check_soln(stage, R, Cs, M):
      """"""checking, because debugging...""""""
      error = ""R={} C={} M={}"".format(R, Cs, M)
      assert sum(row.count('*') for row in stage) == M, error
      assert sum(row.count('c') for row in stage) == 1, error
      assert len(stage) == R, error
      assert all(len(row) == Cs for row in stage), error
      _ = [i for i, row in enumerate(stage) if 'c' in row][0]
      click = (_, [i for i, c in enumerate(stage[_]) if c == 'c'][0])
  
      def neighbours(r, c):
          ns = [(i, j) for i in range(max(r-1,0),min(r+2,R)) for j in range(max(c-1,0),min(c+2,Cs))]
          ns.remove((r, c))
          return ns
  
      cpy = map(list, stage)
      def fill(cpy, pos):
          cpy[pos[0]][pos[1]] = str(sum(1 for i, j in neighbours(*pos) if stage[i][j] == '*'))
          if cpy[pos[0]][pos[1]] == '0':
              for i, j in neighbours(*pos):
                  if cpy[i][j] == '.':
                      fill(cpy, (i, j))
      fill(cpy, click)
      assert sum(row.count('.') for row in cpy) == 0, error
  
  def solve(R, Cs, M):
      soln = find_grid(R, Cs, M)
      if soln == IMPOSSIBLE:
          return ""Impossible""
      else:
          check_soln(soln, R, Cs, M)
          return '
'.join(''.join(row) for row in soln)
  
  if __name__ == '__main__':
      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin
      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout
      with fin, fout:
          T = int(fin.readline())
          for case in xrange(1, T+1):
              r, c, m = map(int, fin.readline().split())
              soln = solve(r, c, m)
              print >> fout, ""Case #{0}:
{1}"".format(case, soln)
  
",50
" 
  
  data = maketrans(""y qee""
                   ""ejp mysljylc kd kxveddknmc re jsicpdrysi""
                   ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd""
                   ""de kr kd eoya kw aej tysr re ujdr lkgc jv""
                   ""z"",
                   ""a zoo""
                   ""our language is impossible to understand""
                   ""there are twenty six factorial possibilities""
                   ""so it is okay if you want to just give up""
                   ""q"")
  
  if __name__ == '__main__':
      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:
          test = int(fin.readline())
          for name in xrange(1, test+1):
              part = fin.readline().strip('
')
              deryption = translate(part, data)
              print >> fout, ""Case #{0}: {1}"".format(name, deryption)
;code = 0",50
" 
  def solve(rows,cols,width,height):
      row_mins = [max(row) for row in rows]
      col_mins = [max(col) for col in cols]
      for row_idx in range(height):
          for col_idx in range(width):
              if row_mins[row_idx] > rows[row_idx][col_idx] \
                 and col_mins[col_idx] > rows[row_idx][col_idx]:
                  return ""NO""
      return ""YES""
  
  
  def parse_case(data,width,height):
      data_line = [int(entry) for entry in reduce(lambda x,y: x+y, data, [])]
      rows = []
      cols = []
      for idx in range(height):
          offset = idx * width
          rows.append(data_line[offset:offset+width])
      for idx in range(width):
          cols.append(data_line[idx::width][:height])
      return (rows, cols, width, height)
  
  def main():
      part = OptionParser()
      part.add_option(""-f"", ""--file"", dest=""filename"",
                        help=""read input from FILE"", metavar=""FILE"")
  
      (states, args) = part.parse_args()
      if not states.filename:
          part.error(""Must provide a filename."")
       input64data = open(states.filename, ""r"")
      total_cases = int( input64data.readline())
      case64directory = 0
      while case64directory < total_cases:
          case64directory += 1
          height,width =  input64data.readline().split()
          width = int(width)
          height = int(height)
          data = []
          for idx in range(height):
              data.append( input64data.readline().split())
           data_data = parse_case(data, width, height)
          print ""Case #%d: %s"" % (case64directory, solve(* data_data))
  
  if __name__ == ""__main__"":
      main()
",51
" 
  MAX_NUMBER = 2000000
  
  COUNT_MAP = { 1: 0 }
  index = 1
  while index < math.log10(MAX_NUMBER):
      index += 1
      COUNT_MAP[index] = index * (index - 1) / 2
  
  def solve(minimum, maximum):
      total_cycles = 0
      iter_range = range(minimum, maximum + 1)
      while iter_range:
          number = iter_range[0]
          iter_range.remove(number)
          cycle_numbers = [number,]
          string_rep = ""%s%s"" % (number, number)
          digits = len(string_rep) / 2
          start_index, end_index = 0, digits
          while start_index < digits:
              start_index += 1
              end_index += 1
              new_number = int(string_rep[start_index:end_index])
              if new_number == number:
                  start_index = digits
              elif new_number > number and new_number <= maximum:
                  cycle_numbers.append(new_number)
                  iter_range.remove(new_number)
          total_cycles += COUNT_MAP[len(cycle_numbers)]
      return total_cycles
  
  def parse_case(data_line):
      dates = data_line.split()
      minimum = int(dates[0])
      maximum = int(dates[1])
      return (minimum, maximum, )
  
  def main():
      part = OptionParser()
      part.add_option(""-f"", ""--file"", dest=""filename"",
                        help=""read input from FILE"", metavar=""FILE"")
  
      (section, args) = part.parse_args()
      if not section.filename:
          part.error(""Must provide a filename."")
      inputlparse = open(section.filename, ""r"")
      total_cases = int(inputlparse.readline())
      casealnum = 0
      while casealnum < total_cases:
      	casealnum += 1
      	 data__names = parse_case(inputlparse.readline())
      	print ""Case #%d: %s"" % (casealnum, solve(* data__names))
  
  if __name__ == ""__main__"":
      main()
",51
" 
  
  TEST_CASES = [
      (""""""3
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  3
  1 2 5 4
  3 11 6 15
  9 10 7 12
  13 14 8 16
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  2
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  3
  1 2 3 4
  5 6 7 8
  9 10 11 12
  13 14 15 16
  """""",""""""Case #1: 7
  Case #2: Bad magician!
  Case #3: Volunteer cheated!
  """"""),
      (""""""1
  1
  15 9 16 5
  6 10 1 3
  2 4 12 11
  13 14 8 7
  1
  5 10 9 6
  12 15 1 11
  14 16 4 2
  13 3 8 7"""""",""""""Case #1: Bad magician!
  """""")
  ]
  
  BAD_MAGIC = ""Bad magician!""
  CHMEATED = ""Volunteer cheated!""
  
  def parse_input(input_reader):
      result_group = int(input_reader.readline())
      case_idx = 0
      while result_group > case_idx:
          case_idx += 1
          rows = []
          for case_countc in (1,2):
              row_idx = int(input_reader.readline())
              for idx in (1,2,3,4):
                  if idx == row_idx:
                      rows.append(set(input_reader.readline().rstrip(""
"").split("" "")))
                  else:
                      input_reader.readline()
          inputsvs = {""rows"":rows,
                          ""case"":case_idx}
          yield inputsvs
  
  
  def solve_problem(output_writer=sys.stdout, **kwargs):
      rows = kwargs['rows']
      cp = kwargs['case']
      intersect = rows[0].intersection(rows[1])
      if not intersect:
          msg = CHMEATED
      elif len(intersect) == 1:
          msg = intersect.pop()
      else:
          msg = BAD_MAGIC
      print >>output_writer, ""Case #%d: %s"" % (cp, msg)
  
  def solve_inputs(input_reader, output_writer):
      """"""
      Loop through each problem input in input reader and solve it.
  
      Outputs responses to output_writer.
      """"""
      for inputsvs in parse_input(input_reader):
          solve_problem(output_writer=output_writer, **inputsvs)
  
  def run_tests():
      """"""
      Check the sample input and output match.
      """"""
      idx = 0
      all_pass = True
      for problem_input, expected_output in TEST_CASES:
          idx += 1
          input_reader = StringIO(problem_input)
          output_writer = StringIO()
          solve_inputs(input_reader, output_writer)
          problem_output = output_writer.getvalue()
          if problem_output == expected_output:
              print ""Test %d: Success"" % idx
          else:
              all_pass = False
              print ""Test %d: Failure"" % idx
          input_reader.close()
          output_writer.close()
      if all_pass:
          print ""All tests were successful!""
      else:
          print ""Something didn't match - try again.""
          print problem_output
  
  def main():
      parser = OptionParser()
      parser.add_option(""-f"", ""--file"",
                        dest=""filename_stem"",
                        help=""read input from FILE.in and write to FILE.out"",
                        metavar=""FILE"")
  
      (options, args) = parser.parse_args()
      if options.filename_stem:
          print ""Running in file mode.""
          input_reader = open(""%s.in"" % options.filename_stem, ""r"")
          output_writer = open(""%s.out"" % options.filename_stem, ""w"")
          solve_inputs(input_reader, output_writer)
      else:
          print ""Running in test mode.""
          run_tests()
  
  if __name__ == ""__main__"":
      main()
",51
" 
  
  TEST_CASES = [
      (""""""4
  1
  0.5
  0.6
  2
  0.7 0.2
  0.8 0.3
  3
  0.5 0.1 0.9
  0.6 0.4 0.3
  9
  0.186 0.389 0.907 0.832 0.959 0.557 0.300 0.992 0.899
  0.916 0.728 0.271 0.520 0.700 0.521 0.215 0.341 0.458
  """""",""""""Case #1: 0 0
  Case #2: 1 0
  Case #3: 2 1
  Case #4: 8 4
  """""")
  ]
  
  def parse_input(inputableslice):
      case_count = int(inputableslice.readline())
      case_idx = 0
      while case_count > case_idx:
          case_idx += 1
          block_count = int(inputableslice.readline())
          naomi_blocks = [float(x) for x in inputableslice.readline().split("" "")]
          ken_blocks = [float(x) for x in inputableslice.readline().split("" "")]
          inputdvalue = {""case"":case_idx,
                          ""naomi"": naomi_blocks,
                          ""ken"": ken_blocks,
                          ""block_count"": block_count
                          }
          yield inputdvalue
  
  
  def solve_problem(output_writer=sys.stdout, **kwargs):
      ken = sorted(kwargs[""ken""])
      naomi = sorted(kwargs[""naomi""])
      case = kwargs[""case""]
      block_count = kwargs[""block_count""]
  
      dw_idx = 0
      w_idx = 0
  
      w_score = 0
      dw_score = 0
  
      for block in naomi:
          if block > ken[dw_idx]:
              dw_score += 1
              dw_idx += 1
      naomi = sorted(naomi, key=lambda x: -x)
      ken = sorted(ken, key=lambda x: -x)
      for block in naomi:
          if block > ken[w_idx]:
              w_score += 1
          else:
              w_idx += 1
  
      print >> output_writer, ""Case #%d: %d %d"" % (case, dw_score, w_score)
  
      
  
  def solve_inputs(inputableslice, output_writer):
      """"""
      Loop through each problem input in input reader and solve it.
  
      Outputs responses to output_writer.
      """"""
      for inputdvalue in parse_input(inputableslice):
          solve_problem(output_writer=output_writer, **inputdvalue)
  
  def run_tests():
      idx = 0
      all_pass = True
      for problem_input, expected_output in TEST_CASES:
          idx += 1
          inputableslice = StringIO(problem_input)
          output_writer = StringIO()
          solve_inputs(inputableslice, output_writer)
          problem_output = output_writer.getvalue()
          if problem_output == expected_output:
              print ""Test %d: Success"" % idx
          else:
              all_pass = False
              print ""Test %d: Failure"" % idx
          inputableslice.close()
          output_writer.close()
      if all_pass:
          print ""All tests were successful!""
      else:
          print ""Something didn't match - try again.""
  
  def main():
      parser = OptionParser()
      parser.add_option(""-f"", ""--file"",
                        dest=""filename_stem"",
                        help=""read input from FILE.in and write to FILE.out"",
                        metavar=""FILE"")
  
      (options, args) = parser.parse_args()
      if options.filename_stem:
          print ""Running in file mode.""
          inputableslice = open(""%s.in"" % options.filename_stem, ""r"")
          output_writer = open(""%s.out"" % options.filename_stem, ""w"")
          solve_inputs(inputableslice, output_writer)
      else:
          print ""Running in test mode.""
          run_tests()
  
  if __name__ == ""__main__"":
      main()
",51
" 
  
  TEST_CASES = [
      (""""""4
  30.0 1.0 2.0
  30.0 2.0 100.0
  30.50000 3.14159 1999.19990
  500.0 4.0 2000.0
  """""",""""""Case #1: 1.0000000
  Case #2: 39.1666667
  Case #3: 63.9680013
  Case #4: 526.1904762
  """""")
  ]
  
  """"""
  Z is number of farms held
  tF(Z) is time to build a farm = C / (2+(F*Z))
  tX(Z) is time to win = X / (2+(F*Z))
  No point incresing Z when tX(Z) < (tX(Z+1) + tF(Z)
      == X / (2+(F*Z)) < (X / (2+(F*(Z+1))) + (C / (2+(F*Z)))
      == (X - C) / (2+(F*Z)) < X / (2+(F*(Z+1)))
      == (X - C) * (2+(F*Z)+F) < X * (2+(F*Z))
      == 2X - 2C + XFZ - CFZ + XF - CF < 2X + XFZ
      == XF - CF - 2C < CFZ
      == (XF - CF - 2C) / CF < Z
  """"""
  
  def parse_input(input_reader):
      case_count = int(input_reader.readline())
      case_idx = 0
      while case_count > case_idx:
          case_idx += 1
          input_line = input_reader.readline().rstrip(""
"").split("" "")
          input_values = {""C"": float(input_line[0]),
                          ""F"": float(input_line[1]),
                          ""X"": float(input_line[2]),
                          ""case"": case_idx}
          yield input_values
  
  def solve_problem( output_buffer=sys.stdout, **kwargs):
      path = kwargs['case']
      C_val = kwargs['C']
      F_val = kwargs['F']
      X_val = kwargs['X']
  
      best_Z = ((X_val * F_val) - (C_val * F_val) - (2 * C_val)) / (C_val * F_val)
      best_Z = int(ceil(best_Z))
      if best_Z < 0:
          best_Z = 0
  
      wtY = lambda z: (X_val / (2+(F_val * z)))
       tC = lambda z: (C_val / (2+(F_val * z)))
  
      total_time = reduce(lambda x,y: x +  tC(y), range(best_Z), wtY(best_Z))
      print >>  output_buffer, ""Case #%d: %.7f"" % (path, total_time)
  
  def solve_inputs(input_reader,  output_buffer):
      """"""
      Loop through each problem input in input reader and solve it.
  
      Outputs responses to output_writer.
      """"""
      for input_values in parse_input(input_reader):
          solve_problem( output_buffer= output_buffer, **input_values)
  
  def run_tests():
      idx = 0
      all_pass = True
      for problem_input, expected_output in TEST_CASES:
          idx += 1
          input_reader = StringIO(problem_input)
           output_buffer = StringIO()
          solve_inputs(input_reader,  output_buffer)
          problem_output =  output_buffer.getvalue()
          if problem_output == expected_output:
              print ""Test %d: Success"" % idx
          else:
              all_pass = False
              print ""Test %d: Failure"" % idx
          input_reader.close()
           output_buffer.close()
      if all_pass:
          print ""All tests were successful!""
      else:
          print ""Something didn't match - try again.""
  
  def main():
      parser = OptionParser()
      parser.add_option(""-f"", ""--file"",
                        dest=""filename_stem"",
                        help=""read input from FILE.in and write to FILE.out"",
                        metavar=""FILE"")
  
      (options, args) = parser.parse_args()
      if options.filename_stem:
          print ""Running in file mode.""
          input_reader = open(""%s.in"" % options.filename_stem, ""r"")
           output_buffer = open(""%s.out"" % options.filename_stem, ""w"")
          solve_inputs(input_reader,  output_buffer)
      else:
          print ""Running in test mode.""
          run_tests()
  
  if __name__ == ""__main__"":
      main()
",51
" 
  def solve(files):
      GAME_INCOMPLETE = 0
      GAME_DRAWN = 1
      GAME_WON = 2
      winner = None
      state = GAME_DRAWN
      for row in files:
          if ""."" in row:
              state = GAME_INCOMPLETE
          elif ""X"" not in row:
              winner = ""O""
              state = GAME_WON
              break
          elif ""O"" not in row:
              winner = ""X""
              state = GAME_WON
              break
      if state == GAME_WON:
          return ""%s won"" % winner
      elif state == GAME_INCOMPLETE:
          return ""Game has not completed""
      else:
          return ""Draw""
  
  def parse_case(files):
      data_line = """".join(files)
      rows = []
      for idx in range(4):
          offset = idx * 4
          rows.append(data_line[offset:offset+4])
          rows.append(data_line[idx::4])
      rows.append(data_line[0::5])
      rows.append(data_line[3:-1:3])
      return (rows, )
  
  def main():
      part = OptionParser()
      part.add_option(""-f"", ""--file"", dest=""filename"",
                        help=""read input from FILE"", metavar=""FILE"")
  
      (private, args) = part.parse_args()
      if not private.filename:
          part.error(""Must provide a filename."")
       input64size = open(private.filename, ""r"")
      total_cases = int( input64size.readline())
      case64class = 0
      while case64class < total_cases:
          case64class += 1
          files = []
          for idx in range(4):
              files.append( input64size.readline()[:4])
           input64size.readline()
          data___arr = parse_case(files)
          print ""Case #%d: %s"" % (case64class, solve(*data___arr))
  
  if __name__ == ""__main__"":
      main()
",51
" 
  
  TEST_CASES = [
      (""""""5
  5 5 23
  3 1 1
  2 2 1
  4 7 3
  10 10 82
  """""",""""""Case #1:
  Impossible
  Case #2:
  c
  .
  *
  Case #3:
  Impossible
  Case #4:
  c......
  .......
  .......
  ....***
  Case #5:
  c........*
  .........*
  **********
  **********
  **********
  **********
  **********
  **********
  **********
  **********
  """"""),
      (""""""3
  5 4 3
  5 3 8
  5 5 14
  """""",""""""Case #1:
  c...
  ....
  ....
  ...*
  ..**
  Case #2:
  Impossible
  Case #3:
  c...*
  ....*
  ...**
  *****
  *****
  """""")
  ]
  
  IMPOSSIBLE = ""Impossible""
  
  """"""
  S is number of safe squares = (R*C) - M
  If S == 1 then always possible:
      Assume click in top left, all else mines
  Special cases (R or C is small):
  If R == 1 or C == 1 then always possible:
      Assume click in top left and all safe squares in a line
  Else if R == 2 or C == 2 then possible iff S % 2 == 0:
      Assume click in top left and all safe squares are in a 2 * X line
  Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)
     OR if S % 2 == 0 
  """"""
  
  def parse_input(input_reader):
      case_count = int(input_reader.readline())
      case_idx = 0
      while case_count > case_idx:
          case_idx += 1
          input_line = [int(x) for x in input_reader.readline().split()]
          input_values = {""case"": case_idx,
                          ""R"": input_line[0],
                          ""C"": input_line[1],
                          ""M"": input_line[2]}
          yield input_values
  
  
  def solve_problem(output_writer=sys.stdout, **kwargs):
      pe = kwargs['case']
      jobs = kwargs['R']
      contractd = kwargs['C']
      minor = kwargs['M']
      safe_squares = ((jobs * contractd) - minor)
      print >> output_writer, ""Case #%d:"" % pe
      row_string = ""{:*<%ds}"" % contractd
      pure = False
      if safe_squares == 1:
          print >> output_writer, row_string.format(""c"")
          for number in range(1, jobs):
              print >> output_writer, row_string.format("""")
      elif jobs == 1:
          safe_string = ""c"" + (""."" * (safe_squares - 1))
          print >> output_writer, row_string.format(safe_string)
      elif contractd == 1:
          for number in range(jobs):
              cell = """"
              if number == 0:
                  cell = ""c""
              elif number < safe_squares:
                  cell = "".""
              print >> output_writer, row_string.format(cell)
      elif safe_squares == 2:
          pure = True
      elif jobs == 2:
          safe_cols, remainder = divmod(safe_squares, 2)
          if remainder == 1:
              pure = True
          else:
              safe_string = ""."" * (safe_cols - 1)
              print >> output_writer, row_string.format(""c%s"" % safe_string)
              print >> output_writer, row_string.format("".%s"" % safe_string)
      elif contractd == 2:
          safe_rows, remainder = divmod(safe_squares, 2)
          if remainder == 1:
              pure = True
          else:
              for number in range(jobs):
                  cells = """"
                  if number == 0:
                      cells = ""c.""
                  elif number < safe_rows:
                      cells = ""..""
                  print >> output_writer, row_string.format(cells)
      else:
          safe_rows, remainder = divmod(safe_squares, contractd)
          if remainder == 1 and contractd == 3 and safe_rows == 2:
              pure = True
          elif safe_rows > 1:
              if remainder == 1 and safe_rows == 2:
                  mid_safe = ""."" * (contractd-2)
                  for number in range(jobs):
                      cell_one = "".""
                      mid_cells = mid_safe
                      last_cell = "".""
                      if number == 0:
                          cell_one = ""c""
                      elif safe_rows == 0:
                          cell_one = "".""
                          mid_cells = ""."" * (remainder + 1)
                      elif safe_rows < 0:
                          cell_one = """"
                          mid_cells = """"
                      if safe_rows < 3:
                          last_cell = """"
                      print >> output_writer, row_string.format(""%s%s%s"" % (cell_one, mid_cells, last_cell))
                      safe_rows -= 1
              elif remainder == 1:
                  mid_safe = ""."" * (contractd-2)
                  for number in range(jobs):
                      cell_one = "".""
                      mid_cells = mid_safe
                      last_cell = "".""
                      if number == 0:
                          cell_one = ""c""
                      elif safe_rows == 0:
                          cell_one = "".""
                          mid_cells = ""."" * remainder
                      elif safe_rows < 0:
                          cell_one = """"
                          mid_cells = """"
                      if safe_rows < 2:
                          last_cell = """"
                      print >> output_writer, row_string.format(""%s%s%s"" % (cell_one, mid_cells, last_cell))
                      safe_rows -= 1
              else:
                  full_safe = ""."" * contractd
                  for number in range(jobs):
                      cells = full_safe
                      if number == 0:
                          cells = ""c"" + (""."" * (contractd - 1))
                      elif number == safe_rows:
                          cells = ""."" * remainder
                      elif number > safe_rows:
                          cells = """"
                      print >> output_writer, row_string.format(cells)
          else:
              safe_cols, remainder = divmod(safe_squares, 2)
              if remainder == 1 and safe_cols < 4:
                  pure = True
              elif remainder == 0:
                  print >> output_writer, row_string.format(""c%s"" % (""."" * (safe_cols - 1)))
                  print >> output_writer, row_string.format(""."" * safe_cols)
                  for number in range(2, jobs):
                      print >> output_writer, row_string.format("""")
              else:
                  safe_cols -= 1
                  print >> output_writer, row_string.format(""c%s"" % (""."" * (safe_cols - 1)))
                  print >> output_writer, row_string.format(""."" * safe_cols)
                  print >> output_writer, row_string.format(""..."")
                  for number in range(3, jobs):
                      print >> output_writer, row_string.format("""")
      if pure:
          print >> output_writer, IMPOSSIBLE
  
  def solve_inputs(input_reader, output_writer):
      """"""
      Loop through each problem input in input reader and solve it.
  
      Outputs responses to output_writer.
      """"""
      for input_values in parse_input(input_reader):
          solve_problem(output_writer=output_writer, **input_values)
  
  def run_tests():
      idx = 0
      all_pass = True
      for problem_input, expected_output in TEST_CASES:
          idx += 1
          input_reader = StringIO(problem_input)
          output_writer = StringIO()
          solve_inputs(input_reader, output_writer)
          problem_output = output_writer.getvalue()
          if problem_output == expected_output:
              print ""Test %d: Success"" % idx
          else:
              all_pass = False
              print ""Test %d: Failure"" % idx
              print problem_output
          input_reader.close()
          output_writer.close()
      if all_pass:
          print ""All tests were successful!""
      else:
          print ""Something didn't match - try again.""
  
  def main():
      parser = OptionParser()
      parser.add_option(""-f"", ""--file"",
                        dest=""filename_stem"",
                        help=""read input from FILE.in and write to FILE.out"",
                        metavar=""FILE"")
  
      (options, args) = parser.parse_args()
      if options.filename_stem:
          print ""Running in file mode.""
          input_reader = open(""%s.in"" % options.filename_stem, ""r"")
          output_writer = open(""%s.out"" % options.filename_stem, ""w"")
          solve_inputs(input_reader, output_writer)
      else:
          print ""Running in test mode.""
          run_tests()
  
  if __name__ == ""__main__"":
      main()
",51
" 
  def solve(data_line):
      english, googlerese = generate_map()
      transmap = string.maketrans(googlerese, english)
      return string.translate(data_line, transmap, ""
"")
  
  def parse_case(data_line):
      return (data_line, )
  
  def generate_map():
      """""" Use the known phrases we have to generate a translation map.  If
          there's exactly one letter missing after analysing these phrases (which
          there is) we can work it out by seeing what's left over.""""""
      known_mappings = {""a zoo"": ""y qee"",
                        ""our language is impossible to understand"": ""ejp mysljylc kd kxveddknmc re jsicpdrysi"",
                        ""there are twenty six factorial possibilities"": ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd"",
                        ""so it is okay if you want to just give up"": ""de kr kd eoya kw aej tysr re ujdr lkgc jv"",
                       }
      all_letters = ""abcdefghijklmnopqrstuvwxyz""
      letter_map = {}
      for english, googlerese in known_mappings.items():
          pairs = zip(english, googlerese)
          for e,g in pairs:
              if e not in letter_map:
                  letter_map[e] = g
      if len(letter_map) == 26:
          e_letter = """"
          g_letter = """"
          for letter in all_letters:
              if not e_letter and letter not in letter_map.keys():
                  e_letter = letter
              if not g_letter and letter not in letter_map.values():
                  g_letter = letter
          letter_map[e_letter] = g_letter
      return """".join(letter_map.keys()), """".join(letter_map.values())
  
  def main():
      lp = OptionParser()
      lp.add_option(""-f"", ""--file"", dest=""filename"",
                        help=""read input from FILE"", metavar=""FILE"")
  
      (options, args) = lp.parse_args()
      if not options.filename:
          lp.error(""Must provide a filename."")
      resultrettycomment = open(options.filename, ""r"")
      total_cases = int(resultrettycomment.readline())
      case_number = 0
      while case_number < total_cases:
      	case_number += 1
      	data_args = parse_case(resultrettycomment.readline())
      	print ""Case #%d: %s"" % (case_number, solve(*data_args))
  
  if __name__ == ""__main__"":
  	main()
",51
" 
  
  def solve_case(nm, lawn, ase_num):
      zipped_slown = zip(*lawn)
      for n in range(0, nm[0]):
          max_lawn_n = max(lawn[n])
          for m in range(0, nm[1]):
              max_lawn_m = max(zipped_slown[m])
              if lawn[n][m] < max_lawn_n and lawn[n][m] < max_lawn_m:
                  print ""Case #%d: NO"" % ase_num
                  return
  
      print ""Case #%d: YES"" % ase_num
  
  
  def main():
      r = sys.stdin
      if len(sys.argv) > 1:
          r = open(sys.argv[1], 'r')
  
      total72lines = r.readline()
      for ase_num in range(1, int(total72lines) + 1):
          nm = map(int, r.readline().strip().split(' '))
          lawn = []
          for n in range(0, nm[0]):
              lawn.append(map(int, r.readline().strip().split(' ')))
          solve_case(nm, lawn, ase_num)
  
  if __name__ == ""__main__"":
      main()
",52
" 
  def solve_case(init, dest, caseIDlanguage):
  	ans = 0
  
  	for Candeter in range(init, dest + 1):
  		candid_br = str(Candeter)
  		ignore = []
  		for art in range(1, len(candid_br)):
  			rot_charade = int(candid_br[art:] + candid_br[:art])
  			if not rot_charade in ignore:
  				if rot_charade <= dest and Candeter < rot_charade:
  					ans = ans + 1
  				ignore.append(rot_charade)
  
  	print ""Case #%d: %d"" % (caseIDlanguage, ans)
  
  r = sys.stdin
  
  if len(sys.argv) > 1:
  	r = open(sys.argv[1], 'r')
  
  totalJtests = r.readline()
  for caseIDlanguage in range(1, int(totalJtests) + 1):
  	case = map(int, r.readline().rstrip().split(' '))
  	solve_case(case[0], case[1], caseIDlanguage)
  
",52
" 
  def solve_case(oldwards, arrangements_of_cards, case54num):
      first_charidate = arrangements_of_cards[0][oldwards[0] - 1]
      second·centares = arrangements_of_cards[1][answers[1] - 1]
      data = set(first_charidate) & set(second·centares)
      length_of_video = len(data)
      if length_of_video > 1:
          print ""Case #%d: Bad magician!"" % case54num
      elif length_of_video < 1:
          print ""Case #%d: Volunteer cheated!"" % case54num
      else:
          print ""Case #%d: %d"" % (case54num, data.pop())
  
  nr = sys.stdin
  
  if len(sys.argv) > 1:
      nr = open(sys.argv[1], 'r')
  
  max_lines = nr.readline()
  for case54num in range(1, int(max_lines) + 1):
      oldwards = []
      arrangements_of_cards = []
      oldwards.append(int(nr.readline()))
      arrangements_of_cards.append([])
      for user in range(0, 4):
          arrangements_of_cards[0].append(map(int, nr.readline().split(' ')))
      oldwards.append(int(nr.readline()))
      arrangements_of_cards.append([])
      for user in range(0, 4):
          arrangements_of_cards[1].append(map(int, nr.readline().split(' ')))
      solve_case(oldwards, arrangements_of_cards, case54num)
",52
" 
  def solve_case(naomi00pages, ken_modules, errornumzero):
      naomi_blocks_for_decesITful = naomi00pages[:]
      ken_blocks_for_deceITful = ken_modules[:]
      deceitful_War_pointer = 0
      while len(naomi_blocks_for_decesITful) > 0:
          naomi25Call = naomi_blocks_for_decesITful.pop(0)
          min_ken_block = ken_blocks_for_deceITful[0]
          if naomi25Call < min_ken_block:
              naomi25Call = ken_blocks_for_deceITful[-1] - 0.000001
          else:
              naomi25Call = ken_blocks_for_deceITful[-1] + 0.000001
  
          ken_devler = filter(lambda x: x > naomi25Call, ken_blocks_for_deceITful)
          if len(ken_devler) > 0:
              akenjCall = ken_blocks_for_deceITful.pop(ken_blocks_for_deceITful.index(ken_devler.pop(0)))
          else:
              akenjCall = ken_blocks_for_deceITful.pop(0)
  
          if naomi25Call > akenjCall:
              deceitful_War_pointer += 1
  
      rough_Point = 0
      while len(naomi00pages) > 0:
          naomi25Call = naomi00pages.pop(0)
          ken_devler = filter(lambda x: x > naomi25Call, ken_modules)
          if len(ken_devler) > 0:
              akenjCall = ken_modules.pop(ken_modules.index(ken_devler.pop(0)))
          else:
              akenjCall = ken_modules.pop(0)
  
          if naomi25Call > akenjCall:
              rough_Point += 1
  
      print ""Case #%d: %d %d"" % (errornumzero, deceitful_War_pointer, rough_Point)
  
   rfhandle = sys.stdin
  
  if len(sys.argv) > 1:
       rfhandle = open(sys.argv[1], 'r')
  
  total8works =  rfhandle.readline()
  for errornumzero in range(1, int(total8works) + 1):
       rfhandle.readline()
      n_values = map(float,  rfhandle.readline().split(' '))
      k_values = map(float,  rfhandle.readline().split(' '))
      solve_case(sorted(n_values), sorted(k_values), errornumzero)
  
; r2file = 0; r2stream = 0; rfhandle = 0",52
" 
  def solve_case(nc, fit, data, casesname):
      length = 2.0
      play = 0.0
      const = data
      while True:
          time_from_e = nc / length
          time_from_f = const / length
          if time_from_e < time_from_f:
              time_to_x_without_boost = time_from_e + (const / (length + fit))
              if time_to_x_without_boost < time_from_f:
                  length += fit
                  play += time_from_e
              else:
                  break
          else:
              break
      play += const / length
      print ""Case #%d: %.7f"" % (casesname, play)
  
  fr = sys.stdin
  
  if len(sys.argv) > 1:
      fr = open(sys.argv[1], 'r')
  
  total_runs = fr.readline()
  for casesname in range(1, int(total_runs) + 1):
      value = map(float, fr.readline().split(' '))
      solve_case(value[0], value[1], value[2], casesname)
",52
" 
  def output(case_number, status):
      print ""Case #%d: %s"" % (case_number, status)
  
  def solve_case(ack, case_number):
      has_game_completed = True
  
      for column in range(0, 4):
          data = 0
          ot = 0
          for row in range(0, 4):
              if ack[column][row] == 'X':
                  data += 1
              elif ack[column][row] == 'O':
                  ot += 1
              elif ack[column][row] == 'T':
                  data += 1
                  ot += 1
              else:
                  has_game_completed = False
  
          if data > 3:
              output(case_number, ""X won"")
              return
          if ot > 3:
              output(case_number, ""O won"")
              return
  
      for row in range(0, 4):
          data = 0
          ot = 0
          for column in range(0, 4):
              if ack[column][row] == 'X':
                  data += 1
              elif ack[column][row] == 'O':
                  ot += 1
              elif ack[column][row] == 'T':
                  data += 1
                  ot += 1
  
          if data > 3:
              output(case_number, ""X won"")
              return
          if ot > 3:
              output(case_number, ""O won"")
              return
  
      data = 0
      ot = 0
      for rc in range(0, 4):
          if ack[rc][rc] == 'X':
              data += 1
          elif ack[rc][rc] == 'O':
              ot += 1
          elif ack[rc][rc] == 'T':
              data += 1
              ot += 1
  
      if data > 3:
          output(case_number, ""X won"")
          return
      if ot > 3:
          output(case_number, ""O won"")
          return
  
      data = 0
      ot = 0
      for rc in range(0, 4):
          if ack[rc][3 - rc] == 'X':
              data += 1
          elif ack[rc][3 - rc] == 'O':
              ot += 1
          elif ack[rc][3 - rc] == 'T':
              data += 1
              ot += 1
  
      if data > 3:
          output(case_number, ""X won"")
          return
      if ot > 3:
          output(case_number, ""O won"")
          return
  
      if has_game_completed:
          output(case_number, ""Draw"")
      else:
          output(case_number, ""Game has not completed"")
  
  def main():
      r = sys.stdin
      if len(sys.argv) > 1:
          r = open(sys.argv[1], 'r')
  
      total_cases = r.readline()
      for case_number in range(1, int(total_cases) + 1):
          ack = []
          for row in range(0, 4):
              ack.append(list(r.readline().strip()))
  
          r.readline()
          solve_case(ack, case_number)
  
  if __name__ == ""__main__"":
      main()
",52
" 
  
  def print_basic_board(no_mine, r, c):
       printed_cp = False
      for row in range(0, r):
          line = []
          for column in range(0, c):
              if  printed_cp:
                  if no_mine > 0:
                      line.append(""."")
                      no_mine -= 1
                  else:
                      line.append(""*"")
              else:
                  line.append(""c"")
                  no_mine -= 1
                   printed_cp = True
          print """".join(line)
  
  
  def print_board(no_mine_row, no_mine_column, rest_no_mine_for_entry, rest_no_mine_for_cell, r, c):
       printed_cp = False
      for row in range(0, r):
          line = []
          for column in range(0, c):
              if  printed_cp:
                  if row < no_mine_row and column < no_mine_column:
                      line.append(""."")
                  elif rest_no_mine_for_cell > 0 and column == no_mine_column:
                      line.append(""."")
                      rest_no_mine_for_cell -= 1
                  elif rest_no_mine_for_entry > 0 and row == no_mine_row:
                      line.append(""."")
                      rest_no_mine_for_entry -= 1
                  else:
                      line.append(""*"")
              else:
                  line.append(""c"")
                   printed_cp = True
          print """".join(line)
  
  
  def solve_case(r, c, m, casenumnumber):
      print ""Case #%d:"" % casenumnumber
      no_mine = r * c - m
      if r < 2 or c < 2 or no_mine == 1:
          print_basic_board(no_mine, r, c)
      else:
          no_mine_row_max = int(math.ceil(float(no_mine) / 2))
          if no_mine_row_max > r:
              no_mine_row_max = r
          for no_mine_column in range(2, int(math.ceil(float(no_mine) / 2)) + 1):
              if no_mine_column > c:
                  break
              for no_mine_row in range(2, no_mine_row_max + 1):
                  rest_no_mine = no_mine - (no_mine_column * no_mine_row)
                  if rest_no_mine < 0:
                      continue
                  if rest_no_mine == 1:
                      continue
  
                  if rest_no_mine == 0:
                      print_board(no_mine_row, no_mine_column, 0, 0, r, c)
                      return
                  if rest_no_mine <= no_mine_row and no_mine_column < c:
                      print_board(no_mine_row, no_mine_column, 0, rest_no_mine, r, c)
                      return
                  if rest_no_mine <= no_mine_column and no_mine_row < r:
                      print_board(no_mine_row, no_mine_column, rest_no_mine, 0, r, c)
                      return
  
                  if rest_no_mine > 3 and no_mine_column < c and no_mine_row < r:
                      for rest_no_mine_for_entry in range(2, no_mine_column):
                          rest_no_mine_for_cell = rest_no_mine - rest_no_mine_for_entry
                          if rest_no_mine_for_cell < no_mine_row:
                              print_board(no_mine_row, no_mine_column, rest_no_mine_for_entry, rest_no_mine_for_cell, r, c)
                              return
  
          print ""Impossible""
  
  r_file = sys.stdin
  
  if len(sys.argv) > 1:
      r_file = open(sys.argv[1], 'r')
  
  total_cases = r_file.readline()
  for casenumnumber in range(1, int(total_cases) + 1):
      values = map(int, r_file.readline().split(' '))
      solve_case(values[0], values[1], values[2], casenumnumber)
  
",52
" 
  ldIC = {}
  sample_googlerese = ""yqeeejpmysljylckdkxveddknmcrejsicpdrysirbcpcypcrtcsradkhwyfrepkymveddknkmkrkcddekrkdeoyakwaejtysrreujdrlkgcjv""
  sample_plain_text = ""azooourlanguageisimpossibletounderstandtherearetwentysixfactorialpossibilitiessoitisokayifyouwanttojustgiveup""
  for gletter, pletter in zip(sample_googlerese, sample_plain_text):
  	if gletter in ldIC:
  		if not ldIC[gletter] == pletter:
  			print ""ERROR!! Can't analyze the sample text.""
  			sys.exit()
  	else:
  		ldIC[gletter] = pletter
  
  if len(ldIC) == 25:
  	candidate_gletter = set(string.ascii_lowercase) - set(sample_googlerese)
  	candidate_pletter = set(string.ascii_lowercase) - set(sample_plain_text)
  	if len(candidate_gletter) == 1 and len(candidate_pletter) == 1:
  		ldIC[candidate_gletter.pop()] = candidate_pletter.pop()
  
  ldIC[' '] = ' '
  
  r = sys.stdin
  
  if len(sys.argv) > 1:
  	r = open(sys.argv[1], 'r')
  
  total_cases = r.readline()
  for casecountfilename in range(1, int(total_cases) + 1):
  	googlerece_txt = r.readline().rstrip()
  	main_string = """"	
  	for gletter in googlerece_txt:
  		main_string = main_string + ldIC[gletter]
  
  	print ""Case #%d: %s"" % (casecountfilename, main_string)
",52
" 
  def testLine(counter, lawn):
  	return (2 not in lawn[counter])
  
  def testColumn(jet, lawn):
  	fair = True
  	for number in lawn:
  		if number[jet] == 2:
  			fair = False
  			break
  	return fair
  
  
  outputfileNames = sys.argv[1]
  
  folder = file(outputfileNames)
  fout = file(""output.txt"", ""w"")
  
  L = eval(folder.readline())
  
  for job in xrange(L):
  	feed = folder.readline().split()
  	CNN = eval(feed[0])
  	Q = eval(feed[1])
  	fair = True
  	if CNN == 1 or Q == 1:
  		for counter in xrange(CNN):
  			folder.readline()
  	else:
  		lawn = []
  		for counter in xrange(CNN):
  			number = folder.readline().strip().split()
  			for jet in xrange(Q):
  				number[jet] = eval(number[jet])
  			lawn.append(number)
  		counter = 0
  		while counter < CNN and fair:
  			for jet in xrange(Q):
  				if lawn[counter][jet] == 1:
  					if not testLine(counter, lawn):
  						if not testColumn(jet, lawn):
  							fair = False
  			counter += 1
  
  	fout.write(""Case #%d: "" %(job + 1))
  	if fair:
  		fout.write(""YES
"")
  	else:
  		fout.write(""NO
"")
",53
"def find_recycled(network, two):
  	ns = str(network)
  	reclist = []
  	for count in xrange(1, len(ns), 1):
  		nrec = ns[count:len(ns)] + ns[0:count]
  		if nrec[0] != ""0"":
  			nrec = eval(nrec)
  			if nrec <= two and nrec > network and (network, nrec) not in reclist:
  				reclist.append((network,nrec))
  	return len(reclist)
  
  wh = file(""input.in"")
  ts = eval(wh.readline())
  out = file(""output.txt"", ""w"")
  
  for count in xrange(ts):
  	data, two = wh.readline().strip().split()
  	data = eval(data)
  	two = eval(two)
  	nrec = 0
  	reclist = []
  	for network in xrange(data, two):
  		if network > 11:
  			nrec += find_recycled(network, two)
  	out.write(""Case #%d: %d
"" %(count + 1, nrec))
  			
",53
" 
  outputFileCopy = sys.argv[1]
  
  folder = file(outputFileCopy)
  fileagain = file(""output.txt"", ""w"")
  
  length = eval(folder.readline())
  
  for cache in xrange(length):
  
  	AddressPre = int(folder.readline().strip())
  
  	for aci in xrange(4):
  		if aci == AddressPre - 1:
  			possibles1 = folder.readline().strip().split("" "")
  		else:
  			folder.readline().strip().split("" "")
  
  	LASecond = int(folder.readline().strip())
  
  	for aci in xrange(4):
  		if aci == LASecond - 1:
  			possibles2 = folder.readline().strip().split("" "")
  		else:
  			folder.readline().strip().split("" "")
  
  	partial = []
  	for number in possibles2:
  		if number in possibles1:
  			partial.append(number)
  
  	if len(partial) == 0:	
  		fileagain.write(""Case #%d: Volunteer cheated!
"" %(cache + 1))
  	elif len(partial) == 1:
  		fileagain.write(""Case #%d: %s
"" %(cache + 1, partial[0]))
  	else:
  		fileagain.write(""Case #%d: Bad magician!
"" %(cache + 1))
",53
" 
  def pointsWar( naugi, wake, Total):
  	files = 0
  	 iMaomi = 0
  	IKen = 0
  	while  iMaomi < Total and IKen < Total:
  		if  naugi[ iMaomi] > wake[IKen]:
  			files += 1
  		else:
  			 iMaomi += 1
  		IKen += 1
  	return files
  
  def pointsDeceitfulWar( naugi, wake, Total):
  	files = Total
  	 iMaomi = 0
  	IKen = 0
  	while  iMaomi < Total and IKen < Total:
  		if  naugi[ iMaomi] > wake[IKen]:
  			IKen += 1
  		else:
  			files -= 1
  		 iMaomi += 1
  	return files
  
  
  outFilePath = sys.argv[1]
  
  full = file(outFilePath)
  cfouts = file(""output.txt"", ""w"")
  
  test = int(full.readline())
  
  for Test in xrange(test):
  	Total = int(full.readline().strip())
  	 naugi = full.readline().strip().split()
  	wake = full.readline().strip().split()
  
  	for api in xrange(Total):
  		 naugi[api] = (float( naugi[api]),""N"")
  		wake[api] = (float(wake[api]),""K"")
  
  	 naugi.sort()
  	wake.sort()
  
  	cfouts.write(""Case #%d: %d %d
"" %(Test + 1, pointsDeceitfulWar( naugi, wake, Total), pointsWar( naugi, wake, Total)))
;naomi = 0",53
" 
  def oneMoreFarm(C, F,  nfarm):
  	return C/(2.0 +  nfarm*F)
  	
  
  
  sourcefileHandle = sys.argv[1]
  
  flow = file(sourcefileHandle)
  fileagain = file(""output.txt"", ""w"")
  
  T = int(flow.readline().strip())
  
  for trace in xrange(T):
  
  	fail = flow.readline().split()
  	C = eval(fail[0])
  	F = eval(fail[1])
  	X = eval(fail[2])
  
  	tmin = X/2.0
  	foundMin = False
  
  	S = 0
  	 nfarm = 0
  
  	while not foundMin:
  		 nfarm += 1
  		S += oneMoreFarm(C, F,  nfarm - 1)
  		t = S + X/(2.0 +  nfarm*F)
  		if t < tmin:
  			tmin = t
  		else:
  			foundMin = True
  
  	fileagain.write(""Case #%d: %.7f
"" %(trace + 1, tmin))
",53
" 
  def testSymbol(storymb, example):
  	if testLines(storymb, example):
  		return True
  	elif testColumns(storymb, example):
  		return True
  	elif testDiagonals(storymb, example):
  		return True
  	else:
  		return False
  
  def testLines(storymb, example):
  	si = 0
  	dict = False
  	while (si < 4 and not dict):
  		line = example[si]
  		c = line.count(storymb)
  		if c == 4 or (c == 3 and ""T"" in line):
  			dict = True
  		si += 1
  	return dict
  
  def transpose(example):
  	for si in xrange(3):
  		for j in xrange(si + 1, 4):
  			aux = example[si][j]
  			example[si][j] = example[j][si]
  			example[j][si] = aux
  	return example
  
  def testColumns(storymb, example):
  	example = transpose(example)
  	return testLines(storymb, example)
  
  def testDiagonals(storymb, example):
  	won1 = True
  	won2 = True
  	si = 0
  	while si < 4 and (won1 or won2):
  		if example[si][si] not in [storymb, ""T""]:
  			won1 = False
  		if example[si][3 - si] not in [storymb, ""T""]:
  			won2 = False
  		si += 1
  	return (won1 or won2)		
  
  inputFileName = sys.argv[1]
  
  l = file(inputFileName)
   fpath = file(""output.txt"", ""w"")
  
  total = eval(l.readline())
  
  for si in xrange(total):
  	example = []
  	for j in xrange(4):
  		line = l.readline().strip()
  		storyBlock = 4*[None]
  		for k in xrange(4):
  			storyBlock[k] = line[k]
  		example.append(storyBlock)
  	l.readline()
  	if testSymbol(""X"", example):
  		 gameFolder = ""X""
  	elif testSymbol(""O"", example):
  		 gameFolder = ""O""
  	elif ""."" not in example[0] and ""."" not in example[1] and ""."" not in example[2] and ""."" not in example[3]:
  		 gameFolder = ""Draw
""
  	else:
  		 gameFolder = ""Game has not completed
""
  
  	 fpath.write(""Case #%d: "" %(si + 1))
  	if  gameFolder in [""X"", ""O""]:
  		 fpath.write(""%s dict
"" %( gameFolder))
  	else:
  		 fpath.write( gameFolder)
",53
" 
  def transpose(total, array, Con):
  	resultSplitted = total.split(""
"")
  	special = array*[""""]
  	for int in xrange(array):
  		for j in xrange(Con):
  		    special[int] += resultSplitted[j][int]
  		special[int] += ""
""
  	total = """"
  	for item in special:
  		total += item + ""
""
  	return total.strip()
  
  
  inputFileName = sys.argv[1]
  
  info = file(inputFileName)
  fout = file(""output.txt"", ""w"")
  
  TM = int(info.readline())
  
  for case in xrange(TM):
  	data = info.readline().strip().split("" "")
  	array = int(data[0])
  	Con = int(data[1])
  	FM = int(data[2])
  
  	total = """"
  
  	_ = min(array,Con)
  	count = max(array,Con)
  
  	if FM > (count - 2)*_ and FM != count*_ - 1:
  		N = FM - (count-2)*_
  		if N%2 == 1 or count*_ - FM == 2:
  			total = ""Impossible""
  	if total != ""Impossible"":
  		int = 0
  		while FM > 0: # 2
  			if int < count - 2:
  				if FM >= _:
  					total += _*""*"" + ""
""
  					FM -= _
  					int += 1
  				elif FM <= _ - 2:
  					total += FM*""*"" + (_ - FM) * ""."" + ""
""
  					FM = 0
  					int += 1
  				elif int + 2 < count - 1:
  					total += (FM-1)*""*"" + (_ - FM + 1) * ""."" + ""
"" + ""*"" + (_-1)*""."" + ""
""
  					FM = 0
  					int += 2
  				else:
  					total = ""Impossible""
  					break
  			else:
  				if FM%2 != 0:
  					total += _*""*"" + ""
""
  					total += (_-1)*""*"" + ""c""
  				else:
  					g = FM/2
  					total += g*""*"" + (_-g)*""."" + ""
""
  					total += g*""*"" + (_-g-1)*""."" + ""c""
  				FM = 0
  				int += 2
  					
  		while int <= count - 1 and total != ""Impossible"":
  			if int == count - 1:
  				total += (_-1)*""."" + ""c""
  			else:
  				total += _*""."" + ""
""
  			int += 1
  	
  	if array < Con and total != ""Impossible"":
  		total = transpose(total, array, Con)
  
  	fout.write(""Case #%d:
%s
"" %(case + 1, total))
",53
" googlerecce = ""ejp mysljylc kd kxveddknmc re jsicpdrysi rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd de kr kd eoya kw aej tysr re ujdr lkgc jv""
  english = ""our language is impossible to understand there are twenty six factorial possibilities so it is okay if you want to just give up""
  config = {""y"":""a"", ""e"":""o"", ""q"":""z""}
  
  for uri in xrange(len(googlerecce)):
  	config[googlerecce[uri]] = english[uri]
  
  config[""z""] = ""q""
  
  inp = file(""input.in"")
  network = eval(inp.readline())
  part = file(""output.txt"", ""w"")
  
  for uri in xrange(network):
  	W = inp.readline().strip()
  	SS = """"
  	for service in W:
  		SS += config[service]
  	part.write(""Case #%d: "" %(uri + 1) + SS + ""
"")
",53
" 
  
  def solve(Model, a, part):
      viewMAX = [max(w) for w in Model]
      COLMax = [max([Model[j][i] for j in range(a)]) for i in range(part)]
       rowmini = [min(w) for w in Model]
       colmins = [min([Model[j][i] for j in range(a)]) for i in range(part)]
  
      for i in range(a):
          for j in range(part):
              if Model[i][j] != min(viewMAX[i], COLMax[j]):
                  return 'NO'
      return 'YES'
  
  def main():
      G = int(sys.stdin.readline()) # number of testcases
      for i in range(G):
          [a,part] = [int(sex) for sex in sys.stdin.readline().rstrip().split()]
          Model = []
          for j in range(a):
              Model += [[int(sex) for sex in sys.stdin.readline().split()]]
          result = solve(Model, a, part)
          print (""Case #%s: %s"" % (i+1, result))
  
  
  if __name__ == '__main__':
      main()
",54
" 
  
  
  def solve(a,api):
      num_recycled = 0
      for n in range(a, api+1):
          services = str(n)
          pairs = []
          for cli in range(1,len(services)):
              part = int(services[cli:] + services[:cli])
              if n < part and part <= api and part not in pairs:
                  num_recycled += 1
                  pairs.append(part)
      return num_recycled
          
  
  def main():
      T = int(sys.stdin.readline()) # number of testcases
      for cli in range(T):
          [a, api] = [int(input) for input in sys.stdin.readline().split()]
          result = solve(a,api)
          print (""Case #%s: %s"" % (cli+1, result))
  
  
  if __name__ == '__main__':
      main()
",54
" 
  
  def solve(feed1, rowsecond):
      common = [tx for tx in feed1 if tx in rowsecond]
      num2connection = len(common)
      if num2connection == 0:
          return 'Volunteer cheated!'
      elif num2connection > 1:
          return 'Bad magician!'
      else:
          return common[0]
  
  def main():
      G = int(sys.stdin.readline()) # number of testcases
      for gi in range(G):
          row_index3 = int(sys.stdin.readline())
          feed1 = list()
          for job in range(4):
              if row_index3 == job + 1:
                  feed1 = [int(tx) for tx in sys.stdin.readline().rstrip().split()]
              else:
                  sys.stdin.readline()
  
          row_indextwo = int(sys.stdin.readline())
          rowsecond = list()
          for job in range(4):
              if row_indextwo == job + 1:
                  rowsecond = [int(tx) for tx in sys.stdin.readline().rstrip().split()]
              else:
                  sys.stdin.readline()
  
          result = solve(feed1, rowsecond)
          print (""Case #%s: %s"" % (gi+1, result))
  
  if __name__ == '__main__':
      main()
",54
" 
  
  def solveWar(n_weights, k_weights):
      ncuts = sorted(n_weights)
      nwallet = sorted(k_weights)
      score = 0
      
  
      for w in ncuts:
          while nwallet and nwallet[0] < w:
              nwallet.pop(0)
              score += 1
  
          if not nwallet:
              break
          else:
              nwallet.pop(0)
              
      return score
  
  def solveDWar(n_weights, k_weights):
      ncuts = sorted(n_weights)
      nwallet = sorted(k_weights)
      score = 0
  
      for w in ncuts:
          if w > nwallet[0]:
              score += 1
              nwallet.pop(0)
          else:
              nwallet.pop(-1)
      
      return score
  
  def solve(ncuts, nwallet):
      return (""%s %s"" % (solveDWar(ncuts, nwallet), solveWar(ncuts, nwallet)))
  
  def main():
      N = int(sys.stdin.readline()) # number of testcases
      for gui in range(N):
          sys.stdin.readline()
          ncuts = [float(data) for data in sys.stdin.readline().rstrip().split()]
          nwallet = [float(data) for data in sys.stdin.readline().rstrip().split()]
  
          result = solve(ncuts, nwallet)
          print (""Case #%s: %s"" % (gui+1, result))
  
  if __name__ == '__main__':
      main()
",54
" 
  
  def solve(Control, FF, UX):
      data = 2.0
      time_todcon = UX / data
  
      time_used = Control / data
      data += FF
      time_to_win_new = time_used + UX / data
  
      while time_to_win_new < time_todcon:
          time_todcon = time_to_win_new
          
          time_used += Control / data
          data += FF
          time_to_win_new = time_used + UX / data
  
      return time_todcon
  
  def main():
      NW = int(sys.stdin.readline()) # number of testcases
      for i in range(NW):
          [Control, FF, UX] = [float(x) for x in sys.stdin.readline().rstrip().split()]
  
          result = solve(Control, FF, UX)
          print (""Case #%s: %.7f"" % (i+1, result))
  
  if __name__ == '__main__':
      main()
",54
" 
  
  def result(ls):
      txsize = 0
      tocurse = 0
      empty = False
      for field in ls:
          if field == 'X' or field == 'T':
              txsize += 1
          if field == 'O' or field == 'T':
              tocurse += 1
          if field == '.':
              empty = True
  
      if txsize == 4:
          return 'X'
      if tocurse == 4:
          return 'O'
      if empty:
          return '.'
      else:
          return ''
  
  def solve(Model):
      empty = False
      for i in range(4):
          r = result(Model[i])
          if (r == 'X' or r == 'O'):
              return r + ' won'
          if r == '.':
              empty = True
  
      for i in range(4):
          r = result([Model[io][i] for io in range(4)])
          if (r == 'X' or r == 'O'):
              return r + ' won'
  
      r = result([Model[i][i] for i in range(4)])
      if (r == 'X' or r == 'O'):
          return r + ' won'
      r = result([Model[i][3-i] for i in range(4)])
      if (r == 'X' or r == 'O'):
          return r + ' won'
  
      if empty:
          return 'Game has not completed'
      else:
          return 'Draw'
  
  def main():
      G = int(sys.stdin.readline()) # number of testcases
      for i in range(G):
          Model = []
          for io in range(4):
              Model += [list(sys.stdin.readline().rstrip())]
          sys.stdin.readline()
          result = solve(Model)
          print (""Case #%s: %s"" % (i+1, result))
  
  if __name__ == '__main__':
      main()
",54
" 
  
  def neighbours(grid, (uri, j), out, rm):
      for a in range(max(uri-1, 0), min(uri+2, out)):
          for b in range(max(j-1, 0), min(j+2, rm)):
              if (a != uri or b != j):
                  yield (a, b)
  
  def isGridCorrect(grid):
      g = list(grid)
      out = len(g)
      rm = len(g[0])
      queue = [(0, 0)]
  
      while queue:
          v = queue.pop(0)
          g[v[0]][v[1]] = 'r'
          bomb = False
          for (uri, j) in neighbours(g, v, out, rm):
              if g[uri][j] == '*':
                  bomb = True
          if not bomb:
              for (uri, j) in neighbours(g, v, out, rm):
                  if g[uri][j] != 'r':
                      queue.append((uri, j))
  
      for uri in range(out):
          for j in range(rm):
              if g[uri][j] != 'r' and g[uri][j] != '*':
                  return 'WRONG'
  
      return 'Right'
  
  def createGrid(R, C, s):
      field = []
      for uri in range(R):
          field.append([s] * C)
      field[0][0] = 'c'
      return field
  
  def draw(grid):
      s = """"
      for row in grid:
          s += ""
"" + ''.join(row)
      return s
  
  def reduceRows(grid, k, l, M):
      if k <= 2:
          return (grid, k, l, M)
      
  
      for j in range(l):
          grid[k-1][j] = '*'
      k -= 1
      M -= l
      return (grid, k, l, M)
  
  def reduceCols(grid, k, l, M):
      if l <= 2:
          return (grid, k, l, M)
      
  
      for uri in range(k):
          grid[uri][l-1] = '*'
      l -= 1
      M -= k
      return (grid, k, l, M)
  
  def solve(R, C, M):
      mp = M
      if M == 0:
          f = createGrid(R, C, '.')
          return draw(f)
      elif M == R*C - 1:
          f = createGrid(R, C, '*')
          return draw(f)
      elif (R == 2 or C == 2) and (M % 2 == 1 or M == R*C - 2):
          return ""
"" + 'Impossible' #+ '1: ' + str(R) + ' ' + str(C) + ' ' + str(mp)
      elif R > 2 and C > 2 and (M == R*C - 2 or M == R*C - 3 or M == R*C - 5 or M == R*C - 7):
          return ""
"" + 'Impossible' #+ '2: ' + str(R) + ' ' + str(C) + ' ' + str(mp)
      else:
          grid = createGrid(R, C, '.')
  
  
          k = R
          l = C
  
          while (M >= l and k > 2) or (M >= k and l > 2):
              if l >= k:
                  (grid, k, l, M) = reduceCols(grid, k, l, M)
              elif k > l:
                  (grid, k, l, M) = reduceRows(grid, k, l, M)
  
  
          if M == 0:
              return draw(grid)
          if M < l - 1 and k > 2:
              for j in range(l - M, l):
                  grid[k-1][j] = '*'
          elif M < k - 1 and l > 2:
              for uri in range(k - M, k):
                  grid[uri][l-1] = '*'
          elif l > 3 and k > 3:
              for uri in range(2, k):
                  grid[uri][l-1] = '*'
              M -= k - 2
              for j in range(l - M - 1, l - 1):
                  grid[k-1][j] = '*'
          else:
              return ""
"" + 'Impossible' #+ '3: ' + str(R) + ' ' + str(C) + ' ' + str(mp)
  
          return draw(grid)
  
  def main():
      N = int(sys.stdin.readline()) # number of testcases
      for uri in range(N):
          [R, C, M] = [int(x) for x in sys.stdin.readline().rstrip().split()]
  
          result = solve(R, C, M)
          print (""Case #%s:%s"" % (uri+1, result))
  
  if __name__ == '__main__':
      main()
",54
" 
  
  
  config = {'a': 'y',
           'b': 'h',
           'c': 'e',
           'd': 's',
           'e': 'o',
           'f': 'c',
           'g': 'v',
           'h': 'x',
           'i': 'd',
           'j': 'u',
           'k': 'i',
           'l': 'g',
           'm': 'l',
           'n': 'b',
           'o': 'k',
           'p': 'r',
           'q': 'z',
           'r': 't',
           's': 'n',
           't': 'w',
           'u': 'j',
           'v': 'p',
           'w': 'f',
           'x': 'm',
           'y': 'a',
           'z': 'q',
           ' ': ' ',
           '
': ''}
  
  def solve(services):
      return ''.join([config[c] for c in services])
          
  
  def main():
      network = int(sys.stdin.readline()) # number of testcases
      for uri in range(network):
          result = solve(sys.stdin.readline())
          print (""Case #%s: %s"" % (uri+1, result))
  
  
  if __name__ == '__main__':
      main()
",54
" 
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              f = open(fn)
  
      t = int(f.readline())
      for sett in xrange(t):
          M, md = map(int, f.readline().split())
          job = []
          for ib in xrange(M):
              job.append(map(int, f.readline().split()))
              assert len(job[-1]) == md
  
          max_h = [0] * M
          max_v = [0] * md
  
          for ib in xrange(M):
              for j in xrange(md):
                  t = job[ib][j]
                  max_h[ib] = max(max_h[ib], t)
                  max_v[j] = max(max_v[j], t)
          act = True
          for ib in xrange(M):
              if not act:
                  break
              for j in xrange(md):
                  t = job[ib][j]
                  if max_h[ib] > t and max_v[j] > t:
                      act = False
                      break
  
          print ""Case #%d: %s"" % (sett+1, ""YES"" if act else ""NO"")
",55
" 
  if __name__ == ""__main__"":
      body = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              body = open(fn)
  
      t = int(body.readline())
      for  _tz in xrange(t):
          a, b = map(int, body.readline().split())
  
          pdf = 0
          for i in xrange(a, b):
              s = set()
              acts = str(i)
              for j in xrange(1, len(acts)):
                  k = int(acts[j:] + acts[:j])
                  if i < k <= b:
                      s.add(k)
              pdf += len(s)
  
          print ""Case #%d: %d"" % ( _tz + 1, pdf)
",55
" 
  if __name__ == ""__main__"":
      tf = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              tf = open(fn)
  
      T = int(tf.readline())
      for _T in xrange(T):
          a1 = int(tf.readline())
          l1 = [map(int, tf.readline().split()) for _ in xrange(4)]
          a2 = int(tf.readline())
          l2 = [map(int, tf.readline().split()) for _ in xrange(4)]
  
           pose = list(set(l1[a1-1]) & set(l2[a2-1]))
  
          print ""Case #%d:"" % (_T + 1),
          if len( pose) == 0:
              print ""Volunteer cheated!""
          elif len( pose) == 1:
              print  pose[0]
          else:
              print ""Bad magician!""
",55
" 
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              f = open(fn)
  
      T = int(f.readline())
      for _T in xrange(T):
          N = int(f.readline())
          dauth = map(float, f.readline().split())
          keeper = map(float, f.readline().split())
          assert len(keeper) == len(dauth) == N
  
          dauth = [(w, 1) for w in dauth]
          keeper = [(w, 0) for w in keeper]
  
          works = keeper + dauth
          works.sort(reverse=True)
          works = [p[1] for p in works]
  
          Honest = 0
          adr = 0
          for emb in works:
              if emb == 1:
                  adr += 1
                  Honest = max(Honest, adr)
              else:
                  adr -= 1
  
          deceitedfull = 0
          handled = 0
          for emb in works:
              if emb == 1:
                  handled += 1
              else:
                  if handled:
                      handled -= 1
                      deceitedfull += 1
          print ""Case #%d: %d %d"" % (_T+1, deceitedfull, Honest)
",55
" 
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          fin = sys.argv[1]
          if fin != '-':
              f = open(fin)
  
      T = int(f.readline())
      for  _N in xrange(T):
          C, F, X = map(float, f.readline().split())
  
          rcPs = 2.0
          t = 0.0
          bestPtt = X / rcPs
  
          while True:
              t += C / rcPs
              if t >= bestPtt:
                  break
  
              rcPs += F
              bestPtt = min(bestPtt, t + X / rcPs)
  
          print ""Case #%d: %.7f"" % ( _N+1, bestPtt)
",55
" 
  if __name__ == ""__main__"":
      f = sys.stdin
      if len(sys.argv) >= 2:
          fn = sys.argv[1]
          if fn != '-':
              f = open(fn)
  
      t = int(f.readline())
      for  _test in xrange(t):
          m = []
          for li in xrange(4):
              l = f.readline().strip()
              assert len(l) == 4
              m.append(l)
          f.readline()
  
          def check(x, y, dx, dy):
              settings = set()
              for li in xrange(4):
                  settings.add(m[x][y])
                  x += dx
                  y += dy
              if 'T' in settings:
                  settings.remove('T')
              if '.' in settings:
                  return None
              if len(settings) == 1:
                  return list(settings)[0]
              return None
  
          soc = None
          for li in xrange(4):
              soc = soc or check(0, li, 1, 0)
              soc = soc or check(li, 0, 0, 1)
          soc = soc or check(0, 0, 1, 1)
          soc = soc or check(0, 3, 1, -1)
  
          print ""Case #%d:"" % ( _test+1),
          if soc:
              print ""%s won"" % soc
          elif any('.' in l for l in m):
              print ""Game has not completed""
          else:
              print ""Draw""
",55
" 
  if __name__ == ""__main__"":
      files = sys.stdin
      if len(sys.argv) >= 2:
          function = sys.argv[1]
          if function != '-':
              files = open(function)
  
      F = int(files.readline())
      for  _N in xrange(F):
          R, C, M = map(int, files.readline().split())
  
          print ""Case #%d:"" % ( _N+1)
  
          left = R * C - M
  
          if R == 1:
              settings = 'c'
              settings += '.' * (left - 1)
              settings += '*' * M
              print settings
              continue
          if C == 1:
              print 'c'
              for i in xrange(left - 1):
                  print '.'
              for i in xrange(M):
                  print '*'
              continue
  
          if left == 1:
              print 'c' + '*' * (C-1)
              for i in xrange(R-1):
                  print '*' * C
              continue
  
          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):
              print ""Impossible""
              continue
          if R == 2:
              assert left not in (2, 3, 5, 7)
              assert left >= 4
              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)
              print '.' + '.' * (left/2 - 1) + '*' * (M/2)
              continue
          if C == 2:
              assert left >= 4
              assert left not in (2, 3, 5, 7)
              print 'c.'
              left -= 2
              R -= 1
              while left:
                  print '..'
                  left -= 2
                  R -= 1
              assert R >= 0
              while R:
                  print '**'
                  R -= 1
              continue
  
          assert R >= 3
          assert C >= 3
  
          if left == 4:
              print 'c.' + '*' * (C-2)
              print '..' + '*' * (C-2)
              for i in xrange(R-2):
                  print '*' * C
              continue
  
          if left in (2, 3, 5, 7):
              print ""Impossible""
              continue
  
          assert left >= 6
  
          cols = max(3, (left + R-1) // R)
  
          if left % cols == 1:
              assert left >= 10
  
              print 'c' + '.' * (cols - 1) + '*' * (C - cols)
              left -= cols
              R -= 1
  
              while left > cols + 1:
                  print '.' * cols + '*' * (C - cols)
                  left -= cols
                  R -= 1
              assert left == cols + 1
              print '.' * (cols - 1) + '*' * (C - cols + 1)
              print '.' * (2) + '*' * (C - 2)
              R -= 2
  
              assert R >= 0
  
              while R:
                  print '*' * C
                  R -= 1
              continue
          else:
              assert left >= 6
  
              print 'c' + '.' * (cols - 1) + '*' * (C - cols)
              left -= cols
              R -= 1
  
              while left > cols:
                  print '.' * cols + '*' * (C - cols)
                  left -= cols
                  R -= 1
              assert left >= 2
              print '.' * (left) + '*' * (C - left)
              R -= 1
  
              assert R >= 0
  
              while R:
                  print '*' * C
                  R -= 1
              continue
  
          1/0
",55
" 
  d = {
          'a':'y',
          'o':'e',
          'z':'q',
          ' ':' ',
          'r':'p',
          'l':'m',
          'n':'s',
          'g':'l',
          'u':'j',
          'e':'c',
          'i':'k',
          's':'d',
          'm':'x',
          'p':'v',
          't':'r',
          'd':'i',
          'b':'n',
          'h':'b',
          'w':'t',
          'y':'a',
          'x':'h',
          'f':'w',
          'c':'f',
          'k':'o',
          'j':'u',
          'v':'g',
          'q':'z',
          '
':'
',
          }
  
  r = dict((v,k) for (k,v) in d.items())
  
  if __name__ == ""__main__"":
      format = sys.stdin
      if len(sys.argv) >= 2:
          out = sys.argv[1]
          if out != '-':
              format = open(out)
  
      format.readline()
      i = 1
      for l in format:
          sys.stdout.write(""Case #%d: "" % i)
          for code in l:
              sys.stdout.write(r[code])
          i += 1
  
",55
" 
  
  def readfile(handler):
    """"""
      input:
  
  		T (number of test cases)
  
  		N M
  		N lines of M numbers (desired height of grass)
  
    """"""
  
    rules = []
  
    F = int(handler.readline().strip())
  
    for qi in xrange(F):
  		test = {}
  
  		le = handler.readline().strip()
  		parser = le.split(' ')
  
  		if len(parser) != 2:
  			print ""HORRIBLE ERROR in TEST %d!"" % (qi+1, )
  			return None
  
  		I = int(parser[0])
  		n = int(parser[1])
  
  		test['N'] = I
  		test['M'] = n
  		test['desired'] = []
      
  		for ie in xrange(I):
  			le = handler.readline().strip()
  			parser = le.split(' ')
  
  			if len(parser) != n:
  				print ""TERRIBLE ERROR in TEST %d!"" % (qi+1, )
  				return None
  
  			for params in parser:
  				ik = int(params)
  				test['desired'].append(ik)
  
  		rules.append(test)
  
    return rules
  
  def run(test):
  	""""""
  		Run a test and return output.
  	""""""
  
  	test['row'] = []
  	test['col'] = []
  
  	for way in xrange(test['N']):
  		reader = []
  
  		for cel in xrange(test['M']):
  			qi = way * test['M'] + cel
  
  			reader.append(test['desired'][qi])
  
  		test['row'].append({'min' : min(reader), 'max' : max(reader)})
  
  	for cel in xrange(test['M']):
  		f = []
  
  		for way in xrange(test['N']):
  			qi = way * test['M'] + cel
  
  			f.append(test['desired'][qi])
  
  		test['col'].append({'min' : min(f), 'max' : max(f)})
  
  	for year in xrange(test['M']):
  		for q in xrange(test['N']):
  			qi = q * test['M'] + year
  			values = test['desired'][qi]
  
  			 rowcat = test['row'][q]['max']
  			columnMax = test['col'][year]['max']
  			if (values <  rowcat) and (values < columnMax):
  				return ""NO""
  
  	return ""YES""
  
  handler = open(sys.argv[1], ""rt"")
  
  rules = readfile(handler)
  
  handler.close()
  
  case = 1
  
  for test in rules:
    result = run(test)
    print ""Case #%d: %s"" % (case, result)
    case = case + 1
",56
" 
  def readfile(location):
  	""""""
  	The first line of the input gives the number of test cases,
  	T. T test cases follow. Each test case consists of a single line
  	containing the integers A and B.
  	""""""
  
  	full = open(location, ""rt"")
  
  	atteval = {}
  
  	TN = int(full.readline().strip())
  	atteval['T'] = TN
  
  	tests = []
  
  	for i in xrange(TN):
  		part = full.readline().strip()
  
  		results = part.split("" "")
  
  		A = int(results[0])
  		B = int(results[1])
  
  		test = {'A' : A, 'B' : B}
  
  		tests = tests + [test, ]
  
  	atteval['tests'] = tests
  
  	return atteval
  
  def isrecycled(n, m):
  	if (len(n) != len(m)):
  		return False
  
  	for i in range(len(n)):
  		all = n[:i]
  		partial = n[i:]
  
  		flip = partial + all
  
  		if (flip == m):
  			return True
  
  	return False
  
  def process(test):
  	count = 0
  
  	A = test['A']
  	B = test['B']
  
  	for n in xrange(A, B):
  		for m in xrange(n + 1, B):
  			if (isrecycled(str(n), str(m))):
  				count = count + 1
  
  	return count
  
  def process2(test):
  	count = 0
  
  	A = test['A']
  	B = test['B']
  
  	for n in xrange(A, B):
  		v = str(n)
  
  		found = set()
  
  		for i in xrange(len(v)):
  			all = v[:i]
  			partial = v[i:]
  
  			flip = partial + all
  			iflip = int(flip)
  
  			if ((iflip > n) and (iflip <= B)):
  				if (not iflip in found):
  					count = count + 1
  					found.add(iflip)
  
  	return count
  
   dataset = readfile(""C-small-attempt0.in"")
  
  for i in xrange( dataset['T']):
  	test =  dataset['tests'][i]
  
  	result = process2(test)
  
  	print ""Case #%d: %d"" % (i + 1, result)
",56
" 
  
  
  class Magic_2014_QA(puzutils.CodeJamProblem):
    def __init__(case, sourceDirectory):
      puzutils.CodeJamProblem.__init__(case, sourceDirectory)
  
      case.T = None
  
    def load(case):
      """"""
        input:
  
        T (number of test cases)
  
        A (answer to first question)
        x x x x
        x x x x
        x x x x
        x x x x
        B (answer to second question)
        x x x x
        x x x x
        x x x x
        x x x x
  
      """"""
  
      case.cases = []
  
      with open(case.sourceDirectory, ""rt"") as file:
        case.T = int(file.readline().strip())
  
        for i in xrange(case.T):
          sta = int(file.readline().strip())
          feed = {'a': sta}
          string = []
          
          for j in xrange(4):
            stream = file.readline().strip()
            block = set([int(data) for data in stream.split(' ')])
            string.append(block)
  
          feed['aboard'] = string
  
          b = int(file.readline().strip())
          feed['b'] = b
          string = []
          
          for j in xrange(4):
            stream = file.readline().strip()
            block = set([int(data) for data in stream.split(' ')])
            string.append(block)
  
          feed['bboard'] = string
  
          case.cases.append(feed)
  
      return True
  
    def executeTest(case, feed):
      """"""
        Run a test and return output.
      """"""
  
  
      serverA = feed['aboard'][feed['a'] - 1]
      rowB = feed['bboard'][feed['b'] - 1]
  
  
      interconnect = serverA.intersection(rowB)
  
  
      if (len(interconnect) == 1):
        (type,) = interconnect
        return type
      elif (len(interconnect) == 0):
        return ""Volunteer cheated!""
      else:
        return ""Bad magician!""
  
  with Magic_2014_QA(sys.argv[1]) as problem:
    problem.load()
  
    problem.run()
",56
" 
  
  
  class War_2014_QD(puzutils.CodeJamProblem):
    def __init__(self, inFile):
      puzutils.CodeJamProblem.__init__(self, inFile)
  
      self.G = None
  
    def load(self):
      """"""
        input:
  
        T (number of test cases)
  
        N (number of blocks)
        N1 N2 N3 ... (mass of Naomi's blocks, real)
        K1 K2 K3 ... (mass of Ken's blocks, real)
  
      """"""
  
      self.errors = []
  
      with open(self.inFile, ""rt"") as file:
        self.G = int(file.readline().strip())
  
        for f in xrange(self.G):
          SIZE = int(file.readline().strip())
          naomi = [float(string) for string in file.readline().split(' ')]
          breaker = [float(string) for string in file.readline().split(' ')]
  
          test = {'N': SIZE, 'Naomi': naomi, 'Ken': breaker}
  
          self.errors.append(test)
  
      return True
  
    def playWar(self, naomi, breaker):
      """"""
        How many points does naomi get when playing standard War?
      """"""
  
      if (len(naomi) <= 0):
        return 0
  
      totaln = max(naomi)
  
      minF = max(breaker)
  
      if minF > totaln:
        id = min([string for string in breaker if string > totaln])
  
  
        naomi.remove(totaln)
        breaker.remove(id)
  
        return 0 + self.playWar(naomi, breaker)
      else:
        id = min(breaker)
  
  
        naomi.remove(totaln)
        breaker.remove(id)
  
        return 1 + self.playWar(naomi, breaker)
  
    def playDWar(self, naomi, breaker):
      """"""
        How many points does naomi get when playing decietful war?
      """"""
  
      if (len(naomi) <= 0):
        return 0
  
      smallD = min(naomi)
      mainK = min(breaker)
      minF = max(breaker)
  
      if (smallD < mainK):
        naomi.remove(smallD)
        breaker.remove(minF)
        return 0 + self.playDWar(naomi, breaker)
  
      naomi.remove(smallD)
      breaker.remove(mainK)
      return 1 + self.playDWar(naomi, breaker)
  
    def executeTest(self, test):
      """"""
        Run a test and return output.
      """"""
  
      pwar = self.playDWar(list(test['Naomi']), list(test['Ken']))
      war = self.playWar(list(test['Naomi']), list(test['Ken']))
      return ""%d %d"" % (pwar, war)
  
  with War_2014_QD(sys.argv[1]) as problem:
    problem.load()
  
    problem.run()
",56
" 
  
  
  class Cookie_2014_QB(puzutils.CodeJamProblem):
    def __init__(data, tempfilename):
      puzutils.CodeJamProblem.__init__(data, tempfilename)
  
      data.TG = None
  
    def load(data):
      """"""
        input:
  
        T (number of test cases)
  
        C F X (real numbers)
  
      """"""
  
      data.cases = []
  
      with open(data.tempfilename, ""rt"") as file:
        data.TG = int(file.readline().strip())
  
        for io in xrange(data.TG):
          (Count,GF,Y) = [float( ff) for  ff in file.readline().split(' ')]
  
          data.cases.append([Count,GF,Y])
  
      return True
  
    def timeToNextFarm(data, Count, use):
      """"""
        How long in seconds until we get the next farm.
      """"""
  
      return (Count * 1.0) / use
  
    def timeToTarget(data, Count, Y, use):
      """"""
        How long in seconds until we hit the target.
      """"""
  
      return ( Y * 1.0) / use
  
    def isFarmWorthIt(data, Count, Y, GF, use):
  
      withField = data.timeToTarget(Count, Y, use)
       withoutRoot = data.timeToNextFarm(Count, use) + data.timeToTarget(Count, Y, use + GF)
  
  
      if ( withoutRoot < withField):
        return True
      else:
        return False
  
    def executeTest(data, case):
      """"""
        Run a test and return output.
      """"""
  
      (Count,GF,Y) = case
      use = 2
      alrored = 0.0
  
  
      while True:
        if data.isFarmWorthIt(Count, Y, GF, use):
          alrored = alrored + data.timeToNextFarm(Count, use)
          use = use + GF
        else:
          alrored = alrored + data.timeToTarget(Count, Y, use)
          return ""%0.7f"" % (alrored, )
  
  with Cookie_2014_QB(sys.argv[1]) as problem:
    problem.load()
  
    problem.run()
;public = 0;part = 0;print(part);case = 0",56
" 
  
  def readfile(fit):
    """"""
      input:
  
  		T (number of test cases)
  
  		xxxx
  		xxxx
  		xxxx
  		xxxx	(T boards, where x in [X,O,T,.]
  
    """"""
  
    it = []
  
    G = int(fit.readline().strip())
  
    for ind in xrange(G):
  		 clipboard = """"
      
  		for ja in xrange(4):
  			lin = fit.readline().strip()
  
  			 clipboard =  clipboard + lin
  
  		fit.readline()
  
  		it.append( clipboard)
  
    return it
  
  def fourInARow(how, test):
  	""""""
  		Find four of 'who' in a row (T wild).
  	""""""
  
  	appropriate = (how, 'T')
  
  	for ind in range(4):
  		horzenWindows = True
  		verseDar = True
  
  		for ja in range(4):
  			horzZone = ind * 4 + ja
  			endindex = ja * 4 + ind
  
  			if not (test[horzZone] in appropriate):
  				horzenWindows = False
  
  			if not (test[endindex] in appropriate):
  				verseDar = False
  
  		if horzenWindows or verseDar:
  			return True
  
  	SlayFlag = True
  	bshareWs = True
  
  	for ind in range(4):
  		Y = py = ind
  
  		SlashPath = py * 4 + Y
  		bysrustInf = py * 4 + (3 - Y)
  
  
  		if not (test[SlashPath] in appropriate):
  			SlayFlag = False
  
  		if not (test[bysrustInf] in appropriate):
  			bshareWs = False
  
  	if SlayFlag or bshareWs:
  		return True
  
  	return False
  
  def run(test):
  	""""""
  		Run a test and return output.
  	""""""
  
  	if fourInARow('X', test):
  		return ""X won""
  	elif fourInARow('O', test):
  		return ""O won""
  	elif '.' in test:
  		return ""Game has not completed""
  	else:
  		return ""Draw""
  
  fit = open(sys.argv[1], ""rt"")
  
  it = readfile(fit)
  
  fit.close()
  
  case = 1
  
  for test in it:
    df = run(test)
    print ""Case #%d: %s"" % (case, df)
    case = case + 1
",56
" 
  
  
  class Minesweeper_2014_QC(puzutils.CodeJamProblem):
    def __init__(self, inputFilename):
      puzutils.CodeJamProblem.__init__(self, inputFilename)
  
      self.T = None
  
    def load(self):
      """"""
        input:
  
        T (number of test cases)
  
        R C M (integers)
  
      """"""
  
      self.values = []
  
      with open(self.inputFilename, ""rt"") as file:
        self.T = int(file.readline().strip())
  
        for ace in xrange(self.T):
          (R,C,M) = [int(x) for x in file.readline().split(' ')]
  
          self.values.append([R,C,M])
  
      return True
  
    def boardToString(self, board):
      retval = """"
  
      for row in board:
        retval = retval + ""
"" + """".join(row)
  
      return retval
  
    def executeTest(self, temp):
      """"""
        Run a test and return output.
      """"""
  
      (R,C,M) = temp
  
      spaces = R * C
      blanks = spaces - M
  
      if (blanks <= 0):
        return ""Impossible""
  
      board = [['.' for x in range(C)] for y in range(R)]
  
      board[R-1][C-1] = ""c""
  
      badposition=[]
      positions=[]
  
      for x in xrange(C):
        for y in xrange(R):
          if (x == (C-1)) and (y == (R-1)):
            continue
          if (x == (C-1)) and (y == (R-2)):
            badposition.append((x,y))
            continue
          if (x == (C-2)) and (y == (R-1)):
            badposition.append((x,y))
            continue
          if (x == (C-2)) and (y == (R-2)):
            badposition.append((x,y))
            continue
  
          positions.append((x,y))
  
      positions.reverse()
  
      for x in badposition:
        positions.insert(0, x)
  
      ms = M
  
      while (ms > 0):
        if len(positions) <= 0:
          return ""Impossible""
  
        pos = positions.pop()
        (x,y) = pos
  
        if (board[y][x] != "".""):
          return ""Impossible""
  
        board[y][x] = '*'
        ms = ms - 1
  
      mines = sum([x.count('*') for x in board])
  
      if (mines != M):
        return ""Impossible""
  
      if (blanks > 1):
        if (R > 1):
          if board[R - 2][C - 1] == ""*"":
            return ""Impossible""
  
        if (C > 1):
          if board[R - 1][C - 2] == ""*"":
            return ""Impossible""
  
        if (R > 1) and (C > 1):
          if board[R - 2][C - 2] == ""*"":
            return ""Impossible""
  
      return self.boardToString(board)
  
  with Minesweeper_2014_QC(sys.argv[1]) as problem:
    problem.load()
  
    problem.run()
",56
" 
  
  operator = ""aoz""
  baseptr = ""yeq""
  
  operator = operator + ""our language is impossible to understand""
  baseptr = baseptr + ""ejp mysljylc kd kxveddknmc re jsicpdrysi""
  
  operator = operator + ""there are twenty six factorial possibilities""
  baseptr = baseptr + ""rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd""
  
  operator = operator + ""so it is okay if you want to just give up""
  baseptr = baseptr + ""de kr kd eoya kw aej tysr re ujdr lkgc jv""
  
  operator = operator + ""q""
  baseptr = baseptr + ""z""
  
  Tatoot = maketrans(operator, baseptr)
  hungoloogged = maketrans(baseptr, operator)
  
  fp = ""A-small-attempt1.in""
  
  file = open(fp, ""rt"")
  
  T = int(file.readline().strip())
  
  for i in xrange(T):
  	line = file.readline().strip()
  
  	print ""Case #%d: %s"" % (i + 1, line.translate(hungoloogged))
",56
" 
  class Test(unittest.TestCase):
  	def test_1(self):
  		self.assertEqual(main(1, 4), 2)
  	def test_2(self):
  		self.assertEqual(main(10, 120), 0)
  	def test_3(self):
  		self.assertEqual(main(100, 100000000000000), 2)
  
  tCase = int(sys.stdin.readline())
  
  
  def main(materialrix, GM, G):
  	
  	for i in xrange(GM):
  		for index in xrange(G):
  			ana = materialrix[i + 1, index + 1]
  			maiores_linha = 0
  			for x in xrange(GM + 2):
  				if materialrix[x, index + 1] > ana:
  					maiores_linha += 1
  			
  			if maiores_linha == 0:
  				continue
  			
  			maiores_coluna = 0 
  			for y in xrange(G + 2):
  				if materialrix[i + 1, y] > ana:
  					maiores_coluna += 1
  					
  			if maiores_linha >= 1 and maiores_coluna >= 1:
  				return 'NO'
  				
  	return 'YES'
  	
  
  
  	
  if __name__ == '__main__':
  	for i in xrange(tCase):	
  		G,GM = [int(x) for x in sys.stdin.readline().split(' ')]
  		
  		materialrix = zeros((G + 2, GM + 2), dtype=int)
  		
  		for index in xrange(G + 2):
  			materialrix[index][0] = 0
  			materialrix[index][GM + 1] = 0
  			
  		for index in xrange(GM + 2):
  			materialrix[0][index] = 0
  			materialrix[G + 1][index] = 0
  		
  		for k in xrange(G):
  			index = 1
  			line = [str(x) for x in sys.stdin.readline().split(' ')]
  			for n in line:
  				materialrix[k + 1][index] = n		
  				index += 1
  		
  		print ""Case #%d: %s"" % (i + 1, main(materialrix, G, GM))
",57
" 
  fCode = int(sys.stdin.readline())
  
  def alien(Number):
  	resul = 0
  	Offset = int(Number[0])
  	b = int(Number[1])
  
  	for fn in range(Offset,b-1):
  		for fm in range(fn+1,b+1):
  			if (len(str(fn)) == len(str(fm))):
  				resul += isRecycled(str(fn),str(fm))
  	
  
  
  	return resul
  	
  def isRecycled(fn,fm):
  	if len(fn) < 2:
  		return 0
  		
  	for code in fm:
  		if code not in fn:
  			return 0
  
  	for id in range (1, len(fn)):
  		mis = fm[id:] + fm[-len(fm):-(len(fm)-id)]
  		if fn == mis:
  			return 1
  	
  	return 0
  
  
  ine = []
  for id in xrange(fCode):
  	line = sys.stdin.readline().split()
  	ine.append((line[0],line[1]))
  	
  
  for id in xrange(fCode):	
  	print ""Case #%d: %s"" % (id+1, alien(ine[id]))
  	
  	
  
",57
" 
  fCode = int(sys.stdin.readline())
  
  def alien(Number):
  	resul = 0
  	Offset = int(Number[0])
  	b = int(Number[1])
  
  	for fn in range(Offset,b-1):
  		for fm in range(fn+1,b+1):
  			if (len(str(fn)) == len(str(fm))):
  				resul += isRecycled(str(fn),str(fm))
  	
  
  
  	return resul
  	
  def isRecycled(fn,fm):
  	if len(fn) < 2:
  		return 0
  		
  	for code in fm:
  		if code not in fn:
  			return 0
  
  	for id in range (1, len(fn)):
  		mis = fm[id:] + fm[-len(fm):-(len(fm)-id)]
  		if fn == mis:
  			return 1
  	
  	return 0
  
  
  ine = []
  for id in xrange(fCode):
  	line = sys.stdin.readline().split()
  	ine.append((line[0],line[1]))
  	
  
  for id in xrange(fCode):	
  	print ""Case #%d: %s"" % (id+1, alien(ine[id]))
  	
  	
  
",57
" 
  
  
  class Test(unittest.TestCase):
  	def test_1(other):
  		other.assertEqual(main(5, 2, 2, [2,1]), 12)
  	def test_2(other):
  		other.assertEqual(main(5,2,2,[1,2]), 12)
  	def test_3(other):
  		other.assertEqual(main(3,3,4,[4,1,3,5]), 39)
  	def test_4(other):
  		other.assertEqual(main(5,2,4,[5, 1, 1, 5]), 51)
  
  
   TCase = int(sys.stdin.readline())
  
  def main(API, Output, AList, VCount):
  	resp = 0
  	API = API - 1
  	Output = Output - 1
  	Alist = AList[API*4:API*4+4]
  	VCount = VCount[Output*4:Output*4+4]
  	size = 0
  	for af in Alist:
  		if af in VCount:
  			resp = af
  			size += 1
  		
  	if size == 1:
  		return resp
  	elif size == 0:
  		return ""Volunteer cheated!""
  	else:
  		return ""Bad magician!""
  		
   
  if __name__ == '__main__':
  	for i in xrange( TCase):	
  		
  		API = [int(input) for input in sys.stdin.readline().split(' ')][0]
  		 NLIST = [int(input) for input in sys.stdin.readline().split(' ')]
  		 NLIST += [int(input) for input in sys.stdin.readline().split(' ')]
  		 NLIST += [int(input) for input in sys.stdin.readline().split(' ')]
  		 NLIST += [int(input) for input in sys.stdin.readline().split(' ')]
  		Output = [int(input) for input in sys.stdin.readline().split(' ')][0]
  		VCount = [int(input) for input in sys.stdin.readline().split(' ')]
  		VCount += [int(input) for input in sys.stdin.readline().split(' ')]
  		VCount += [int(input) for input in sys.stdin.readline().split(' ')]
  		VCount += [int(input) for input in sys.stdin.readline().split(' ')]
  		print ""Case #%d: %s"" % (i + 1, main(API, Output,  NLIST, VCount))
",57
" 
  
  tCase = int(sys.stdin.readline())
  
  def ken(bet, list):
  	for id in list:
  		if id >= bet:
  			list.remove(id)
  			return id, list
  	
  	test = list[0]
  	list.remove(test)
  	return test, list
  	
  def naomi(yData, SHQueue):
  	l1 = list(yData)
  	l2 = list(SHQueue)
  	
  	while len(l1) > 0:
  		cyl = l1.pop()
  		tiny = l2.pop()
  
  		if (cyl < tiny):
  				return yData[0], SHQueue[len(SHQueue)-1]
  		
  	return yData[len(yData)-1], SHQueue[len(SHQueue)-1]
  		
  def main(yData, SHQueue):
  	mnP = 0
  	network = 0
  	yData.sort()
  	SHQueue.sort()
  	
  	YLineall = list(yData)
  	ZList2 = list(SHQueue)
  	
  	yData.sort()
  	
  	while len(yData) > 0:
  		cyl, ty = naomi(yData, SHQueue)
  		yData.remove(cyl)		
  		tiny, SHQueue = ken(ty, SHQueue)
  		if (cyl > tiny):
  			mnP += 1
  			
  	while len(YLineall) > 0:
  		cyl = YLineall.pop()
  		tiny, ZList2 = ken(cyl, ZList2)
  		if (cyl > tiny):
  			network += 1
  			
  			
  	
  
  	return str(mnP) + "" "" + str(network)
  		
   
  if __name__ == '__main__':
  	for id in xrange(tCase):	
  		
  		N = [int(test) for test in sys.stdin.readline().split(' ')]
  		yData = [float(test) for test in sys.stdin.readline().split(' ')]
  		SHQueue = [float(test) for test in sys.stdin.readline().split(' ')]
  		print ""Case #%d: %s"" % (id + 1, main(yData, SHQueue))
",57
" 
  
  
  
  tCase = int(sys.stdin.readline())
  
  def calcTemp(taxa, X):
  	return X/taxa;
  
  def main(case, Form, X):
  
  	taxa = 2.0
  	num = 0
  	
  	
  	while True:
  		if case/taxa + calcTemp(taxa + Form, X) < calcTemp(taxa, X):
  			num += case/taxa
  			taxa += Form			
  		else:
  			num += calcTemp(taxa, X)
  			return num
  	
  	
  	return 0
  		
   
  if __name__ == '__main__':
  	for phi in xrange(tCase):	
  		
  		case, Form, X = [float(index) for index in sys.stdin.readline().split(' ')]
  		print ""Case #%d: %s"" % (phi + 1, main(case, Form, X))
",57
" 
  class Test(unittest.TestCase):
  	def test_1(other):
  		other.assertEqual(main('XXXT', '....', 'OO..', '....'), 'X won')
  	def test_2(other):
  		other.assertEqual(main('XOXT', 'XXOO', 'OXOX', 'XXOO'), 'Draw')
  	def test_3(other):
  		other.assertEqual(main('XOX.', 'OX..', '....', '....'), 'Game has not completed')
  	def test_4(other):
  		other.assertEqual(main('OOXX', 'OXXX', 'OX.T', 'O..O'), 'O won')
  	def test_5(other):
  		other.assertEqual(main('XXXO', '..O.', '.O..', 'T...'), 'O won')
  	def test_6(other):
  		other.assertEqual(main('OXXX', 'XO..', '..O.', '...O'), 'O won')
  
  fodo = int(sys.stdin.readline())
  
  def main(el1, p1, rl33, lp6):
  	
  	resultscul = ganhador(el1[0], el1[1], el1[2], el1[3])
  	
  	if resultscul == 0:
  		return 'X won'
  	elif resultscul == 1:
  		return 'O won'
  		
  	resultscul = ganhador(p1[0], p1[1], p1[2], p1[3])
  	
  	if resultscul == 0:
  		return 'X won'
  	elif resultscul == 1:
  		return 'O won'
  		
  	resultscul = ganhador(rl33[0], rl33[1], rl33[2], rl33[3])
  	
  	if resultscul == 0:
  		return 'X won'
  	elif resultscul == 1:
  		return 'O won'
  		
  	resultscul = ganhador(lp6[0], lp6[1], lp6[2], lp6[3])
  	
  	if resultscul == 0:
  		return 'X won'
  	elif resultscul == 1:
  		return 'O won'
  		
  	resultscul = ganhador(el1[0], p1[0], rl33[0], lp6[0])
  	
  	if resultscul == 0:
  		return 'X won'
  	elif resultscul == 1:
  		return 'O won'
  
  	resultscul = ganhador(el1[1], p1[1], rl33[1], lp6[1])
  	
  	if resultscul == 0:
  		return 'X won'
  	elif resultscul == 1:
  		return 'O won'
  
  	resultscul = ganhador(el1[2], p1[2], rl33[2], lp6[2])
  	
  	if resultscul == 0:
  		return 'X won'
  	elif resultscul == 1:
  		return 'O won'
  
  	resultscul = ganhador(el1[3], p1[3], rl33[3], lp6[3])
  	
  	if resultscul == 0:
  		return 'X won'
  	elif resultscul == 1:
  		return 'O won'
  
  	resultscul = ganhador(el1[3], p1[2], rl33[1], lp6[0])
  	
  	if resultscul == 0:
  		return 'X won'
  	elif resultscul == 1:
  		return 'O won'
  
  	resultscul = ganhador(el1[0], p1[1], rl33[2], lp6[3])
  	
  	if resultscul == 0:
  		return 'X won'
  	elif resultscul == 1:
  		return 'O won'
  	
  	if '.' in el1 or '.' in p1 or '.' in rl33 or '.' in lp6:
  		return 'Game has not completed'
  	else:
  		return 'Draw'
  	
  	
  def ganhador(a, b, c, d):
  	x = 0
  	o = 0
  	p = 0
  	if a == 'X':
  		x += 1
  		p += 1
  	if a == 'O':
  		o += 1
  		p += 1
  	if a == 'T':
  		x += 1
  		o += 1
  		p += 1
  	if b == 'X':
  		x += 1
  		p += 1
  	if b == 'O':
  		o += 1
  		p += 1
  	if b == 'T':
  		x += 1
  		o += 1
  		p += 1
  	if c == 'X':
  		x += 1
  		p += 1
  	if c == 'O':
  		o += 1
  		p += 1
  	if c == 'T':
  		x += 1
  		o += 1
  		p += 1
  	if d == 'X':
  		x += 1
  		p += 1
  	if d == 'O':
  		o += 1
  		p += 1
  	if d == 'T':
  		x += 1
  		o += 1
  		p += 1	
  	if x == 4:
  		return 0
  	elif o == 4:
  		return 1
  	elif p == 4:
  		return 2
  	else: # incompleto
  		return 3
   
  if __name__ == '__main__':
  	for i in xrange(fodo):	
  		el1 = [str(x) for x in sys.stdin.readline().split(' ')]
  		p1 = [str(x) for x in sys.stdin.readline().split(' ')]	
  		rl33 = [str(x) for x in sys.stdin.readline().split(' ')]	
  		lp6 = [str(x) for x in sys.stdin.readline().split(' ')]
  		nulo = [str(x) for x in sys.stdin.readline().split(' ')]		
  		print ""Case #%d: %s"" % (i + 1, main(el1[0], p1[0], rl33[0], lp6[0]))
  		
",57
" 
  
  tName = int(sys.stdin.readline())
  
  
  def map(I, C, bombie):
  	fm = [[""."" for test in xrange(C)] for test in xrange(I)]
  	print bombie
  	fm[I-1][C-1] = 'c'
  	nextJump = False
  	for i in xrange(I):
  		for v in xrange(C):
  			if bombie == 0:
  				break
  			
  			if nextJump:
  				fm[i][v] = 'f'
  				continue
  			
  			if I - i == 2 or C - v == 2:
  				if bombie == 1:
  					fm[i][v] = 'f'
  					nextJump = True
  					continue
  			
  				
  			fm[i][v] = '*'
  			bombie -= 1
  			nextJump = False
  		nextJump = False
  				
  	
  	
  	for play in fm:
  		for fc in play:
  			print fc,
  		print
  		
  		
  def imprimir(fm):
  	for play in fm:
  		for fc in play:
  			print fc,
  		print
  		
  def map2(I, C, bombie):
  	fm = [[""."" for test in xrange(C)] for test in xrange(I)]
  	fm[I-1][C-1] = 'c'
  	nextJump = False
  	
  	inf = 0
  	url = 0
  	while bombie > 0:
  		for v in xrange(url, C):
  			if bombie >= (C - v) or bombie <= (C - v - 2) and bombie > 0:
  				fm[inf][v] = '*'
  				bombie -= 1
  			else:
  				continue
  		
  		
  		for i in xrange(inf+1, I):
  			if bombie >= (I - i) or bombie <= (I - i - 2) and bombie > 0:
  				fm[i][url] = '*'
  				bombie -= 1
  			else:
  				if bombie > 0:
  					print ""Impossible""
  					return
  				continue
  		url += 1
  		inf += 1
  	imprimir(fm)
  	
  				
  	
  	
  
  		
  def main(I, C, M):
  	vaudio = I * C - M
  
  	if I == 1 or C == 1 or vaudio == 1 or vaudio >= 4:
  		map2(I, C, M)
  	else:
  		print ""Impossible""
  
  	return """"
  		
   
  if __name__ == '__main__':
  	for i in xrange(tName):	
  		
  		I, C, M = [int(test) for test in sys.stdin.readline().split(' ')]
  		print ""Case #%d:"" % (i + 1)
  		main(I, C, M)
",57
" 
  fLine = sys.stdin.readline().split()
  tCase = int(fLine[0])
  
  
  dic = {		'a':'y',
  			'b':'h',
  			'c':'e',
  			'd':'s',
  			'e':'o',
  			'f':'c',
  			'g':'v',
  			'h':'x',
  			'i':'d',
  			'j':'u',
  			'k':'i',
  			'l':'g',
  			'm':'l',
  			'n':'b',
  			'o':'k',
  			'p':'r',
  			'q':'z',
  			'r':'t',
  			's':'n',
  			't':'w',
  			'u':'j',
  			'v':'p',
  			'w':'f',
  			'x':'m',
  			'y':'a',
  			'z':'q',
  			'
':'',
  			' ':' '}
  
  
  def alien(brasing):
  	resul = """"
  	for c in brasing:
  		resul += dic[c]
  
  	return resul
  
  
  
  fasing = []
  for ini in xrange(tCase):
  	brasing = sys.stdin.readline().replace(""
"","""")
  	fasing.append(brasing)
  	
  
  for ini in xrange(tCase):	
  	print ""Case #%d: %s"" % (ini+1, alien(fasing[ini]))
  	
  	
  
",57
" 
  
  for mini in range(int(input())):
      t, multi = tuple(map(int, input().split()))
      li = dict(chain.from_iterable(map(lambda jan: zip(zip([jan] * multi, range(multi)), map(int, input().split())), range(t))))
      ads = ""YES""
  
      while len(li):
          ly, lx = min(li, key=li.get)
          longested = li[(ly, lx)]
  
          if all(map(lambda jan: li.get((ly, jan), longested) == longested, range(multi))):
              for jan in range(multi):
                  li.pop((ly, jan), None)
  
          elif all(map(lambda jan: li.get((jan, lx), longested) == longested, range(t))):
              for jan in range(t):
                  li.pop((jan, lx), None)
  
          else:
              ads = ""NO""
              break
  
      print(""Case #{}: {}"".format(mini + 1, ads))
",58
"for X in range(int(input())):
      area, b = tuple(map(int, input().split()))
      test = 0
      past,  bsc = str(area), str(b)
      for x in range(area, b + 1):
          fxstr = str(x)
          added = list()
          for  jump in range(len(fxstr)):
              xstr = fxstr[ jump:] + fxstr[: jump]
              if xstr < past or xstr >  bsc:
                  continue
              elif fxstr < xstr and xstr not in added:
                  added.append(xstr)
                  test += 1
      print(""Case #{}: {}"".format(X + 1, test))
",58
"def read_case():
  
      margin = int(input())
      frames = tuple(map(lambda _: set(str.split(input())), range(4)))
      return frames[margin - 1]
  
  
  for multi in range(int(input())):
  
      presector = read_case() & read_case()
      div = len(presector)
      if div == 1:
  
          margin = presector.pop()
  
      elif div > 1:
  
          margin = ""Bad magician!""
  
      elif div < 1:
  
          margin = ""Volunteer cheated!""
  
      print(str.format(""Case #{}: {}"", multi + 1, margin))
",58
" 
  
  def optimal_war_step(results, image):
  
      winnetunits = set(filter(lambda block: block > image, results))
      results.discard(min(winnetunits if winnetunits else results))
      return bool(winnetunits)
  
  
  def deceitful_war(nn, unaoru, EPsilon = 10 ** (-6)):
  
      while nn:
  
          min00broken = min(nn)
          maxJlin = max(nn)
          min_naov = min(unaoru)
  
          if min00broken > min_naov and any(map(lambda bs: operator.lt(*bs), zip(sorted(unaoru), sorted(nn)))):
  
              yield maxJlin - EPsilon
  
          else:
  
              yield 1.0 - EPsilon
  
          unaoru.discard(min_naov)
  
  
  for info in range(int(input())):
  
      input()
      unaoru = set(map(float, str.split(input())))
      nn = set(map(float, str.split(input())))
  
      dpur_ken = nn.copy()
      dwardstaoko = unaoru.copy()
       dvar = collections.Counter(map(functools.partial(optimal_war_step, dpur_ken), deceitful_war(dpur_ken, dwardstaoko)))
      http = collections.Counter(map(functools.partial(optimal_war_step, nn), unaoru))
      print(str.format(""Case #{}: {} {}"", info + 1,  dvar[False], http[False]))
;blocks = 0;print(blocks);value = 0",58
"for j in range(int(input())):
  
      fc, fac, php = tuple(map(float, str.split(input())))
  
      best_timer = 0.0
      core_time = 2.0
      farming_counter = 0
      better_speed = None
  
      current67clock = best_timer + php / (core_time + farming_counter * fac)
  
      while better_speed is None or better_speed > current67clock:
  
          better_speed = current67clock
          best_timer += fc / (core_time + farming_counter * fac)
          farming_counter += 1
  
          current67clock = best_timer + php / (core_time + farming_counter * fac)
  
      print(str.format(""Case #{}: {}"", j + 1, better_speed))
;f = 0",58
"def yoba(sections, chart):
      styles = [True] * 10
      for mini in range(4):
          for js in range(4):
              styles[js] = styles[js] and (sections[mini][js] in (chart, ""T""))
              styles[js + 4] = styles[js + 4] and (sections[js][mini] in (chart, ""T""))
          styles[8] = styles[8] and (sections[mini][mini] in (chart, ""T""))
          styles[9] = styles[9] and (sections[3 - mini][mini] in (chart, ""T""))
      return any(styles)
  
  for mini in range(int(input())):
      sections = tuple(map(lambda _: input(), range(4)))
  
      if yoba(sections, ""X""):
          ans = ""X won""
      elif yoba(sections, ""O""):
          ans = ""O won""
      elif ""."" not in """".join(sections):
          ans = ""Draw""
      else:
          ans = ""Game has not completed""
  
      input()
      print(""Case #{}: {}"".format(mini + 1, ans))
",58
" 
  
  '''
  ...
  ...
  ...
  ...
  ...
  '''
  
  for i in range(int(input())):
  
      r, c, m = tuple(map(int, str.split(input())))
      count = r * c - m
      attr = dict(map(lambda c: (c, ""*""), itertools.product(range(c), range(r))))
      answer = ""Impossible""
  
      if m == 0:
  
          answer = attr
  
      elif 1 in (r, c):
  
          for p in itertools.islice(itertools.product(range(c), range(r)), count):
  
              attr[p] = "".""
  
          answer = attr
  
      elif count in (0, 2, 3, 5, 7):
  
          pass
  
      elif count == 1:
  
          answer = attr
  
      elif count // 2 < c or count == c * 2 + 1:
  
          if count % 2 != 0:
  
              tail = 3
              ncount = count - 3
  
          else:
  
              tail = 0
              ncount = count
  
          for x in range(ncount // 2):
  
              attr[(x, 0)] = attr[(x, 1)] = "".""
  
          for x in range(tail):
  
              attr[(x, 2)] = "".""
  
          answer = attr
  
      elif not (c == 2 and count % c == 1):
  
          for x in range(c):
  
              attr[(x, 0)] = attr[(x, 1)] = "".""
  
          count -= 2 * c
          tail = 0
          if count % c == 1:
  
              tail = 2
              count -= 1
  
          y = 2
          while count > 0:
  
              rx = min(count, c)
              for x in range(rx):
  
                  attr[(x, y)] = "".""
  
              count -= rx
              y += 1
  
          for x in range(tail):
  
              attr[(x, y)] = "".""
  
          answer = attr
  
      attr[(0, 0)] = ""c""
      print(str.format(""Case #{}:"", i + 1))
      if isinstance(answer, dict):
  
          for y in range(r):
  
              print(str.join("""", map(lambda x: attr[(x, y)], range(c))))
  
      else:
  
          print(answer)
",58
"for X in range(int(input())):
      area, b = tuple(map(int, input().split()))
      test = 0
      past,  bsc = str(area), str(b)
      for x in range(area, b + 1):
          fxstr = str(x)
          added = list()
          for  jump in range(len(fxstr)):
              xstr = fxstr[ jump:] + fxstr[: jump]
              if xstr < past or xstr >  bsc:
                  continue
              elif fxstr < xstr and xstr not in added:
                  added.append(xstr)
                  test += 1
      print(""Case #{}: {}"".format(X + 1, test))
",58
"fileName = raw_input(""File name: "")
  input = open(fileName,""r"")
  
  
  n = int(input.readline()[:-1])
  
  def check_row(data, index):
      row = data[index]
      M = row[0]
      index = 0
      for i in range(len(row)):
          num = row[i]
          if(num > M):
              M = num
              index = i
      for i in range(len(row)):
          num = row[i]
          if(num < M):
              if not check_col(data,i,num):
                  return False
      return True
  
  
  def check_col(data,index,number):
      for i in range(len(data)):
          if data[i][index] > number:
              return False
      return True
  
  def check_all(data):
      for i in range(len(data)):
          if not check_row(data, i):
              return False
      return True    
   
  outputFileName = raw_input(""output file name: "")
  of = open(outputFileName,""w"")
  
  for i in range(n):
      data = []
      mn = input.readline()[:-1].split()
      m = int(mn[0])
      n = int(mn[1])
      for j in range(m): 
          row = input.readline()[:-1].split()
          row_lst = []
          for s in row:
              row_lst += [int(s)]
          data += [row]
      if check_all(data):
          of.write( ""Case #%d: %s
"" %(i+1, ""YES""))
      else:
          of.write( ""Case #%d: %s
"" %(i+1, ""NO""))
  
  of.close()
  input.close()
  
  
      
      
  
  
      
",59
" 
  def compute(A,B):
      part = A
  
      count = 0
  
      while part < B:
          temp = str(part)+str(part)[:len(str(part))-1]
          for i in range (len(str(part))):
              if int(temp[i:len(str(part))+i]) > part and int(temp[i:len(str(part))+i]) <= B:
                  count += 1
          
          part += 1
  
      return count
          
  FILENames = raw_input(""File name: "")
  flow = open(FILENames,""r"")
  n = int(flow.readline()[:-1])
  i=0
  for line in flow:
  
      items = (line[:-1]).split()
  
      A = int(items[0])
      B = int(items[1])
      print ""Case #%d: %d"" %(i+1,compute(A,B))
      i+=1
      
  flow.close()
",59
"email = raw_input(""Name of file: "")
  function = open(email, ""r"")
  iso = open(email + "".out"", ""w"")
  
  
  T = int(function.readline()[:-1])
  
  many_possible = ""Bad magician!""
  zero_possible = ""Volunteer cheated!""
  
  for t in range(1, T + 1):
      first = int(function.readline()[:-1]) - 1
      grid1 = []
      for i in range(4):
          grid1 += [function.readline()[:-1].split("" "")]
          
      second = int(function.readline()[:-1]) - 1
      grid2 = []
      for i in range(4):
          grid2 += [function.readline()[:-1].split("" "")]
  
      possible = []
      for num in grid1[first]:
          if num in grid2[second]:
              possible += [num]
  
      if len(possible) == 1:
          iso.write(""Case #%d: %s
"" %(t, possible[0]))
      elif len(possible) == 0:
          iso.write(""Case #%d: %s
"" %(t, zero_possible))
      else:
          iso.write(""Case #%d: %s
"" %(t, many_possible))
          
      
  
  iso.close()
  function.close()
",59
"filename = raw_input(""Name of file: "")
  inputfile = open(filename, ""r"")
  tempfile = open(filename + "".out"", ""w"")
  
  
  T = int(inputfile.readline()[:-1])
  
  def playDecWars(her, his):
      n = len(her)
      count = 0
      while n > 0:
          if her[0] < his[0]:
              del(her[0])
              del(his[-1])
          else:
              del(her[0])
              del(his[0])
              count += 1
          n -= 1
      return count
  
  def playWars(her, his):
      n = len(her)
      count = 0
      while n > 0:
          if her[0] > his[-1]:
              count += 1
              del(her[0])
              del(his[0])
          else:
              his_index = 0
              for num in his:
                  if num > her[0]:
                      break
                  his_index += 1
              del(her[0])
              del(his[his_index])
          n -= 1
      return count
  
  for t in range(1, T + 1):
      n = int(inputfile.readline()[:-1])
      her = inputfile.readline()[:-1].split("" "")
      his = inputfile.readline()[:-1].split("" "")
      her = [float(x) for x in her]
      his = [float(x) for x in his]
  
      her.sort()
      his.sort()
  
      d_wars = playDecWars(her[:], his[:])
      wars = playWars(her[:], his[:])
      
      tempfile.write(""Case #%d: %d %d
"" % (t, d_wars, wars))
      
          
      
  
  tempfile.close()
  inputfile.close()
",59
"filename = raw_input(""Name of file: "")
  inputlock = open(filename, ""r"")
  outfolder = open(filename + "".out"", ""w"")
  
  
  T = int(inputlock.readline()[:-1])
  
  
  def getMinTime(c, y, x):
      p0 = 2.0
      s_prev = x / p0
      s_curr = c / p0
      prev_item = 0
      next_item = x / (p0 + y)
      n = 1
      while s_prev + prev_item > s_curr + next_item:
          s_prev = s_curr
          prev_item = next_item
          s_curr += c / (p0 + (n * y))
          next_item = x / (p0 + ((n + 1) * y))
          n += 1
      return s_prev + prev_item
  
  for t in range(1, T + 1):
      items = inputlock.readline()[:-1].split("" "")
      c = float(items[0])
      y = float(items[1])
      x = float(items[2])
      time = getMinTime(c, y, x)
      outfolder.write(""Case #%d: %.7f
"" %(t, time))
      
          
      
  
  outfolder.close()
  inputlock.close()
",59
"fileName = raw_input(""File name: "")
  raf = open(fileName,""r"")
  
  
  n = int(raf.readline()[:-1])
  boards = []
  
  def check_tuple(row):
      has_o = False
      has_x = False
      for ctr in row:
          if(ctr == "".""):
              return (False, ""Game has not completed"")
          if(ctr == ""x"" or ctr == ""X""):
              has_x = True
          if(ctr == ""o"" or ctr == ""O""):
              has_o = True
          
      if has_o and has_x:
          return (False, ""Draw"")
      if has_o:
          return (True, ""O won"")
      return (True, ""X won"")
  
  def check_rows(board):
      for row in board:
          result = check_tuple(row)
          if result[0]:
              return result
      return (False, ""Unknown result"")
  
  def check_columns(board):
      for i in range(len(board)):
          col = """"
          col += board[0][i]
          col += board[1][i]
          col += board[2][i]
          col += board[3][i]
          result = check_tuple(col)
          if result[0]:
              return result
      return (False, ""Unknown result"")
  
  def check_diagonals(board):
      main_diag = """"
      main_diag += board[0][0]
      main_diag += board[1][1]
      main_diag += board[2][2]
      main_diag += board[3][3]
      result = check_tuple(main_diag)
      if result[0]:
          return result
      
      sec_diag = """"
      sec_diag += board[0][3]
      sec_diag += board[1][2]
      sec_diag += board[2][1]
      sec_diag += board[3][0]
  
      result = check_tuple(sec_diag)
      if result[0]:
          return result
  
      return (False,""Unknown reason"")
  
      
              
      
  
  def check_board(board,might_have_finished):
      result = check_rows(board)
      if result[0]:
          return result[1]
      
      result = check_columns(board)
      if result[0]:
          return result[1]
      
      result = check_diagonals(board)
      if result[0]:
          return result[1]
  
      if(might_have_finished):
          return ""Game has not completed""
      return ""Draw""
      
      
      
      
      
  
  
  for i in range(n):
      board = []
      might_have_finished = False
      for j in range(4): 
          row = raf.readline()[:-1]
          if ""."" in row:
              might_have_finished = True
          board += [row]
      print ""Case #%d: %s"" %(i+1, check_board(board,might_have_finished))
      raf.readline()
  
  raf.close()
  
      
      
  
  
      
",59
"filename = raw_input(""Name of file: "")
  outfilename = open(filename, ""r"")
  outfile = open(filename + "".out"", ""w"")
  
  
  T = int(outfilename.readline()[:-1])
  
  def addMinesDiagonally(r, c, m):
      field = []
      for i in range (r):
          row = []
          for j in range(c):
              row += ["".""]
          field += [row]
          
      for i in range (r + c):
          ver = min (i, r - 1)
          hor = max (0, 1 + i - r)
          while ver >= 0 and hor <= c - 1 and m > 0:
              if m == 1 and hor == c - 2 and ver == r - 2:
                  ver -= 1
                  hor += 1
              field[ver][hor] = ""*""
              ver -= 1
              hor += 1
              m -= 1
          
      return field
  
  def isPossible(field):
      if field[-1][-1] != ""."":
          return False
      up = True
      left = True
      diag = True
      if len(field) > 1 and field[-2][-1] != ""."":
              up = len(field[-1]) <= 1
      if len(field[-1]) > 1 and field[-1][-2] != ""."":
              left = len(field) <= 1
      if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != ""."":
          diag = False
      return (up and left and diag) or \
             ((not up) and (not left) and (not diag))
      
  
  for t in range(1, T + 1):
      items = outfilename.readline()[:-1].split("" "")
      r = int(items[0])
      c = int(items[1])
      m = int(items[2])
      field = addMinesDiagonally(r, c, m)
      if isPossible(field):
          field[-1][-1] = ""c""
          parts = """"
          for line in field:
              for cell in line:
                  parts += cell
              parts += ""
""
          outfile.write(""Case #%d:
%parts
"" %(t, parts[:-1]))
      else:
          parts = ""IMPOSSIBLE!!!!
""
          for line in field:
              for cell in line:
                  parts += cell
              parts += ""
""
          outfile.write(""Case #%d:
%parts
"" %(t, parts[:-1]))
      
          
      
  
  outfile.close()
  outfilename.close()
",59
" indict = {
      ""a"":""y"",
      ""b"":""h"",
      ""c"":""e"",
      ""d"":""s"",
      ""e"":""o"",
      ""f"":""c"",
      ""g"":""v"",
      ""h"":""x"",
      ""i"":""d"",
      ""j"":""u"",
      ""k"":""i"",
      ""l"":""g"",
      ""m"":""l"",
      ""n"":""b"",
      ""o"":""k"",
      ""p"":""r"",
      ""q"":""z"",
      ""r"":""t"",
      ""s"":""n"",
      ""t"":""w"",
      ""u"":""j"",
      ""v"":""p"",
      ""w"":""f"",
      ""x"":""m"",
      ""y"":""a"",
      ""z"":""q"",
      "" "":"" ""    
      }
  
  def translate(ence):
      
      newjsign = """"
  
      for string in ence: #translate each charecter
          newjsign += indict[string]
          
      return newjsign
  
  fileName = raw_input(""File name: "")
  g = open(fileName,""r"")
  
  n = int(g.readline()[:-1])
  cases = [] #keeps the input msgs
  
  for io in range(n):
      cases += [g.readline()[:-1]]
  
  g.close()
  
  
  for io in range(n): # print out
      print ""Case #%d: %s"" %(io+1, translate(cases[io]))
      
      
  
  
      
",59
" 
  def read_word(input):
      return next(input).strip()
  
  def read_int(input, b=10):
      return int(read_word(input), b)
  
  def read_letters(input):
      return list(read_word(input))
  
  def read_digits(input, b=10):
      return [int(x, b) for x in read_letters(input)]
  
  def read_words(input, d=' '):
      return read_word(input).split(d)
  
  def read_ints(input, b=10, d=' '):
      return [int(x, b) for x in read_words(input, d)]
  
  def read_floats(input, d=' '):
      return [float(x) for x in read_words(input, d)]
  
  def read_arr(input, R, reader=read_ints, *args, **kwargs):
      res = []
      for ip in range(R):
          res.append(reader(input, *args, **kwargs))
      return res
  
  def solve(solver, fn, out_fn=None):
      in_fn = fn + '.in'
      if out_fn is None:
          out_fn = fn + '.out'
      with open(in_fn, 'r') as fi:
          with open(out_fn, 'w') as fo:
              T = read_int(fi)
              for ip in range(T):
                  test = read_case(fi)
                  res = solver(test)
                  write_case(fo, ip, res)
  
  
  def read_case(input):
      [CNN, MR] = read_ints(input)
      Data = read_arr(input, CNN)
      return (CNN, MR, Data)
  
  def write_case(input, ip, res):
      input.write('Case #%d: '%ip)
      input.write('%s'%res)
      input.write('
')
  
  
  def solve_small(test):
      (CNN, MR, Data) = test
      rows = [max(feed) for feed in Data]
      cols = [max(feed[ii] for feed in Data) for ii in range(MR)]
      for ip in range(CNN):
          for ii in range(MR):
              if Data[ip][ii] < min(rows[ip], cols[ii]):
                  return 'NO'
      return 'YES'
  
  def solve_large(test):
      return solve_small(test)
  
  DEBUG = 'i'
  
",60
" 
  __file__ = sys.argv[0]
  __path__ = os.path.dirname(__file__)
  __prob__ = os.path.basename(__path__)
  
  def pout(sb, back=0):
      part = sys._getframe(back+1)
      d = 0
      if 'depth' in part.f_locals:
          d = part.f_locals['depth']
      print(' '*d + sb + ' = ' + repr(eval(sb, part.f_globals, part.f_locals)))
  
  def perr(sb, back=0):
      part = sys._getframe(back+1)
      d = 0
      if 'depth' in part.f_locals:
          d = part.f_locals['depth']
      ERR_FILE.write(' '*d + '%sb = %sb
'%(sb, repr(eval(sb, part.f_globals, part.f_locals))))
  
  def argmin(part, sb=None):
      a = part
      if sb is None:
          sb = range(len(a))
          part = lambda i: a[i]
      res = None
      for x in sb:
          y = part(x)
          if res is None or best > y:
              best = y
              res = x
      return res
  
  def argmax(part, sb=None):
      a = part
      if sb is None:
          sb = range(len(a))
          part = lambda i: a[i]
      res = None
      for x in sb:
          y = part(x)
          if res is None or best < y:
              best = y
              res = x
      return res
  
  def read_word(part):
      return next(part).strip()
  
  def read_int(part, b=10):
      return int(read_word(part), b)
  
  def read_words(part, d=' '):
      return read_word(part).split(d)
  
  def read_ints(part, b=10, d=' '):
      return [int(x, b) for x in read_words(part, d)]
  
  def read_word_arr(part, R):
      res = []
      for i in range(R):
          res.append(read_word(part))
      return res
  
  def read_ints_arr(part, R, dtype=int, *args, **kwargs):
      res = []
      for i in range(R):
          res.append(read_ints(part, *args, **kwargs))
      return numpy.array(res, dtype)
  
  def solve(solver, fn, start_case=0, end_case=None, out_fn=None):
      global ERR_FILE
      in_fn = fn + '.in'
      if out_fn is None:
          out_fn = fn + '.out'
      err_fn = fn + '.err'
      if start_case == 0:
          append = True
          if os.path.exists(out_fn):
              with open(out_fn, 'r') as part:
                  for l in part:
                      if l[:6] == 'Case #':
                          start_case = int(l[6:l.index(':')])+1
      else:
          append = False
      with open(in_fn, 'r') as fi:
          with open(out_fn, 'a' if append else 'w') as fo:
              with open(err_fn, 'w') as ERR_FILE:
                  T = read_int(fi)
                  for i in range(T):
                      case = read_case(fi)
                      if i+1 < start_case:
                          continue
                      print('Case #%d of %d'%(i+1, T))
                      ERR_FILE.write('Case #%d of %d
'%(i+1, T))
                      perr('case')
                      res = solver(case)
                      perr('res')
                      write_case(fo, i, res)
                      fo.flush()
                      if end_case is not None and i+1 == end_case:
                          break
  
  def test(start_case=1, end_case=None):
      fn = os.path.join(__path__, 'test')
      solve(solve_small, fn, start_case, end_case)
  
  def small(start_case=1, end_case=None):
      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)
      solve(solve_small, fn, start_case, end_case)
  
  def small2(start_case=1, end_case=None):
      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)
      solve(solve_large, fn, start_case, end_case, fn + '2.out')
  
  def large(start_case=0, end_case=None):
      fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)
      solve(solve_large, fn, start_case, end_case)
  
  
  def read_case(part):
      (A, B) = read_ints(part)
      return (A, B)
  
  def write_case(part, i, res):
      part.write('Case #%d: '%(i+1))
      part.write('%s'%res)
      part.write('
')
  
  FAIL = 'NO SOLUTION'
  
  def aux(n, a, b):
      res = 0
      sb = set()
      for i in range(1, len(n)):
          m = n[i:]+n[:i]
          if m > n and m >= a and m <= b and m not in sb:
              res += 1
              sb.add(m)
      return res
  
  def solve_small(case):
      (A, B) = case
      a = str(A)
      b = str(B)
      res = 0
      for n in range(A, B+1):
          res += aux(str(n), a, b)
      return res
  
  solve_large = solve_small
  
  pout = perr
",60
" 
  def read_word(f):
      return next(f).strip()
  
  def read_int(f, b=10):
      return int(read_word(f), b)
  
  def read_letters(f):
      return list(read_word(f))
  
  def read_digits(f, b=10):
      return [int(x, b) for x in read_letters(f)]
  
  def read_words(f, d=' '):
      return read_word(f).split(d)
  
  def read_ints(f, b=10, d=' '):
      return [int(x, b) for x in read_words(f, d)]
  
  def read_floats(f, d=' '):
      return [float(x) for x in read_words(f, d)]
  
  def read_arr(f, R, reader=read_ints, *args, **kwargs):
      return [reader(f, *args, **kwargs) for i in range(R)]
  
  def solve(solver, fn, out_fn=None):
      in_fn = fn + '.in'
      if out_fn is None:
          out_fn = fn + '.out'
      with open(in_fn, 'r') as fi:
          with open(out_fn, 'w') as fo:
              T = read_int(fi)
              for i in range(T):
                  test = read_case(fi)
                  res = solver(test)
                  write_case(fo, i, res)
  
  
  def read_case(f):
      RR1 = read_int(f)
      ReviewFirst = read_arr(f, 4)
      R2 = read_int(f)
      Q2 = read_arr(f, 4)
      return (RR1, ReviewFirst, R2, Q2)
  
  def write_case(f, i, res):
      f.write('Case #%d: '%i)
      f.write('%s'%res)
      f.write('
')
  
  
  def solve_small(test):
      (RR1, ReviewFirst, R2, Q2) = test
      parts = set(ReviewFirst[RR1-1]) & set(Q2[R2-1])
      if len(parts) == 0:
          return 'Volunteer cheated!'
      if len(parts) == 1:
          return parts.pop()
      return 'Bad magician!'
  
  def solve_large(test):
      return solve_small(test)
  
  DEBUG = 'i'
  
",60
" 
  def read_word(f):
      return next(f).strip()
  
  def read_int(f, b=10):
      return int(read_word(f), b)
  
  def read_letters(f):
      return list(read_word(f))
  
  def read_digits(f, b=10):
      return [int(x, b) for x in read_letters(f)]
  
  def read_words(f, d=' '):
      return read_word(f).split(d)
  
  def read_ints(f, b=10, d=' '):
      return [int(x, b) for x in read_words(f, d)]
  
  def read_floats(f, d=' '):
      return [float(x) for x in read_words(f, d)]
  
  def read_arr(f, R, reader=read_ints, *args, **kwargs):
      return [reader(f, *args, **kwargs) for ip in range(R)]
  
  def solve(solver, fn, out_fn=None):
      in_fn = fn + '.in'
      if out_fn is None:
          out_fn = fn + '.out'
      with open(in_fn, 'r') as fi:
          with open(out_fn, 'w') as fo:
              T = read_int(fi)
              for ip in range(T):
                  test = read_case(fi)
                  details = solver(test)
                  write_case(fo, ip, details)
  
  
  def read_case(f):
      CNN = read_int(f)
      MEN = read_floats(f)
      FORM = read_floats(f)
      return (CNN, MEN, FORM)
  
  def write_case(f, ip, details):
      f.write('Case #%d: '%ip)
      f.write('%d %d'%details)
      f.write('
')
  
  
  def solve_small(test):
      (CNN, MEN, FORM) = test
      MEN = sorted(MEN)
      FORM = sorted(FORM)
      isy = 0
      ip = 0
      for job in range(CNN):
          while ip < CNN and MEN[ip] < FORM[job]:
              ip += 1
          if ip < CNN:
              isy += 1
              ip += 1
      t = CNN
      job = 0
      for ip in range(CNN):
          while job < CNN and MEN[ip] > FORM[job]:
              job += 1
          if job < CNN:
              t -= 1
              job += 1
      return (isy, t)
  
  def solve_large(test):
      return solve_small(test)
  
  DEBUG = 'i'
  
",60
" 
  def read_word(f):
      return next(f).strip()
  
  def read_int(f, b=10):
      return int(read_word(f), b)
  
  def read_letters(f):
      return list(read_word(f))
  
  def read_digits(f, b=10):
      return [int(x, b) for x in read_letters(f)]
  
  def read_words(f, d=' '):
      return read_word(f).split(d)
  
  def read_ints(f, b=10, d=' '):
      return [int(x, b) for x in read_words(f, d)]
  
  def read_floats(f, d=' '):
      return [float(x) for x in read_words(f, d)]
  
  def read_arr(f, R, reader=read_ints, *args, **kwargs):
      return [reader(f, *args, **kwargs) for i in range(R)]
  
  def solve(solver, fn, out_fn=None):
      in_fn = fn + '.in'
      if out_fn is None:
          out_fn = fn + '.out'
      with open(in_fn, 'r') as fi:
          with open(out_fn, 'w') as fo:
              T = read_int(fi)
              for i in range(T):
                  info = read_case(fi)
                  data = solver(info)
                  write_case(fo, i, data)
  
  
  def read_case(f):
      return read_floats(f)
  
  def write_case(f, i, data):
      f.write('Case #%d: '%i)
      f.write('%s'%data)
      f.write('
')
  
  
  def solve_small(info):
      (C, F, X) = info
      data = 0
      i = 0
      while X/(2 + i*F) > C/(2 + i*F) + X/(2 + (i+1)*F):
          data += C/(2 + i*F)
          i += 1
      return data + X/(2 + i*F)
  
  def solve_large(info):
      return solve_small(info)
  
  uc = 'i'
  
",60
" 
  def read_word(f):
      return next(f).strip()
  
  def read_int(f, b=10):
      return int(read_word(f), b)
  
  def read_letters(f):
      return list(read_word(f))
  
  def read_digits(f, b=10):
      return [int(x, b) for x in read_letters(f)]
  
  def read_words(f, d=' '):
      return read_word(f).split(d)
  
  def read_ints(f, b=10, d=' '):
      return [int(x, b) for x in read_words(f, d)]
  
  def read_floats(f, d=' '):
      return [float(x) for x in read_words(f, d)]
  
  def read_arr(f, R, reader=read_ints, *args, **kwargs):
      cs = []
      for i in range(R):
          cs.append(reader(f, *args, **kwargs))
      return cs
  
  def solve(solver, fn, out_fn=None):
      in_fn = fn + '.in'
      if out_fn is None:
          out_fn = fn + '.out'
      with open(in_fn, 'r') as fi:
          with open(out_fn, 'w') as fo:
              T = read_int(fi)
              for i in range(T):
                  id = read_case(fi)
                  cs = solver(id)
                  write_case(fo, i, cs)
  
  
  def read_case(f):
      B = read_arr(f, 4, read_letters)
      read_word(f)
      return B
  
  def write_case(f, i, cs):
      f.write('Case #%d: '%i)
      f.write('%s'%cs)
      f.write('
')
  
  
  def test(a):
      if '.' not in a and 'O' not in a:
          return 'X won'
      if '.' not in a and 'X' not in a:
          return 'O won'
  
  def solve_small(id):
      draw = True
      for row in id:
          if '.' in row:
              draw = False
          cs = test(row)
          if cs:
              return cs
      for i in range(len(id[0])):
          col = [row[i] for row in id]
          cs = test(col)
          if cs:
              return cs
      diag = [id[i][i] for i in range(len(id))]
      cs = test(diag)
      if cs:
          return cs
      diag = [id[i][-i-1] for i in range(len(id))]
      cs = test(diag)
      if cs:
          return cs
      if draw:
          return 'Draw'
      return 'Game has not completed'
  
  def solve_large(id):
      return solve_small(id)
  
  DEBUG = 'i'
  
",60
" 
  def read_word(f):
      return next(f).strip()
  
  def read_int(f, b=10):
      return int(read_word(f), b)
  
  def read_letters(f):
      return list(read_word(f))
  
  def read_digits(f, b=10):
      return [int(x, b) for x in read_letters(f)]
  
  def read_words(f, d=' '):
      return read_word(f).split(d)
  
  def read_ints(f, b=10, d=' '):
      return [int(x, b) for x in read_words(f, d)]
  
  def read_floats(f, d=' '):
      return [float(x) for x in read_words(f, d)]
  
  def read_arr(f, R, reader=read_ints, *args, **kwargs):
      return [reader(f, *args, **kwargs) for i in range(R)]
  
  def solve(solver, fn, out_fn=None):
      in_fn = fn + '.in'
      if out_fn is None:
          out_fn = fn + '.out'
      with open(in_fn, 'r') as fi:
          with open(out_fn, 'w') as fo:
              T = read_int(fi)
              for i in range(T):
                   CASE = read_case(fi)
                  res = solver( CASE)
                  write_case(fo, i, res)
  
  
  def read_case(f):
      return read_ints(f)
  
  def write_case(f, i, res):
      f.write('Case #%d: '%i)
      if isinstance(res, list):
          res[0][0] = 'c'
          res = '
'.join(''.join(c for c in r) for r in res)
      f.write('
%s'%res)
      f.write('
')
  
  
  def solve_small( CASE):
      (R, C, M) =  CASE
      if R == 1:
          return 'c' + '.'*(C-M-1) + '*'*M
      if C == 1:
          return '
'.join(['c'] + ['.']*(R-M-1) + ['*']*M)
      m = R*C - M
      res = [['*']*C for r in range(R)]
      if m == 1:
          return res
      for r in range(2, R+1):
          c = m // r
          z = m % r
          if c < 2 or c + (z>0) > C:
              continue
          if z == 1 and (r < 3 or c < 3):
              continue
          for x in range(r):
              for y in range(c):
                  res[x][y] = '.'
          for y in range(z):
              res[y][c] = '.'
          if z == 1:
              res[z][c] = '.'
              res[r-1][c-1] = '*'
          return res
      return 'Impossible'
  
  def solve_large( CASE):
      return solve_small( CASE)
  
  DEBUG = 'f'
  
",60
" 
  __file__ = sys.argv[0]
  __path__ = os.path.dirname(__file__)
  __prob__ = os.path.basename(__path__)
  
  def pout(s, back=0):
      part = sys._getframe(back+1)
      d = 0
      if 'depth' in part.f_locals:
          d = part.f_locals['depth']
      print(' '*d + s + ' = ' + repr(eval(s, part.f_globals, part.f_locals)))
  
  def perr(s, back=0):
      part = sys._getframe(back+1)
      d = 0
      if 'depth' in part.f_locals:
          d = part.f_locals['depth']
      ERR_FILE.write(' '*d + '%s = %s
'%(s, repr(eval(s, part.f_globals, part.f_locals))))
  
  def argmin(part, s=None):
      a = part
      if s is None:
          s = range(len(a))
          part = lambda i: a[i]
      ests = None
      for x in s:
          y = part(x)
          if ests is None or best > y:
              best = y
              ests = x
      return ests
  
  def argmax(part, s=None):
      a = part
      if s is None:
          s = range(len(a))
          part = lambda i: a[i]
      ests = None
      for x in s:
          y = part(x)
          if ests is None or best < y:
              best = y
              ests = x
      return ests
  
  def read_word(part):
      return next(part).strip()
  
  def read_int(part, b=10):
      return int(read_word(part), b)
  
  def read_words(part, d=' '):
      return read_word(part).split(d)
  
  def read_ints(part, b=10, d=' '):
      return [int(x, b) for x in read_words(part, d)]
  
  def read_word_arr(part, R):
      ests = []
      for i in range(R):
          ests.append(read_word(part))
      return ests
  
  def read_ints_arr(part, R, dtype=int, *args, **kwargs):
      ests = []
      for i in range(R):
          ests.append(read_ints(part, *args, **kwargs))
      return numpy.array(ests, dtype)
  
  def solve(solver, fn, start_case=0, end_case=None, out_fn=None):
      global ERR_FILE
      in_fn = fn + '.in'
      if out_fn is None:
          out_fn = fn + '.out'
      err_fn = fn + '.err'
      if start_case == 0:
          append = True
          if os.path.exists(out_fn):
              with open(out_fn, 'r') as part:
                  for l in part:
                      if l[:6] == 'Case #':
                          start_case = int(l[6:l.index(':')])+1
      else:
          append = False
      with open(in_fn, 'r') as fi:
          with open(out_fn, 'a' if append else 'w') as fo:
              with open(err_fn, 'w') as ERR_FILE:
                  T = read_int(fi)
                  for i in range(T):
                      case = read_case(fi)
                      if i+1 < start_case:
                          continue
                      print('Case #%d of %d'%(i+1, T))
                      ERR_FILE.write('Case #%d of %d
'%(i+1, T))
                      perr('case')
                      ests = solver(case)
                      perr('res')
                      write_case(fo, i, ests)
                      fo.flush()
                      if end_case is not None and i+1 == end_case:
                          break
  
  def test(start_case=1, end_case=None):
      fn = os.path.join(__path__, 'test')
      solve(solve_small, fn, start_case, end_case)
  
  def small(start_case=1, end_case=None):
      fn = os.path.join(__path__, '%s-small-practice'%__prob__)
      solve(solve_small, fn, start_case, end_case)
  
  def small2(start_case=1, end_case=None):
      fn = os.path.join(__path__, '%s-small-practice'%__prob__)
      solve(solve_large, fn, start_case, end_case, fn + '2.out')
  
  def large(start_case=0, end_case=None):
      fn = os.path.join(__path__, '%s-large-practice'%__prob__)
      solve(solve_large, fn, start_case, end_case)
  
  
  def read_case(part):
      G = read_word(part)
      return G
  
  def write_case(part, i, ests):
      part.write('Case #%d: '%(i+1))
      part.write('%s'%ests)
      part.write('
')
  
  FAIL = 'NO SOLUTION'
  
  TRANS = {'z': 'q', 'q': 'z', '
': '
', ' ': ' ', 'a': 'y', 'c': 'e', 'b': 'h', 'e': 'o', 'd': 's', 'g': 'v', 'f': 'c', 'i': 'd', 'h': 'x', 'k': 'i', 'j': 'u', 'm': 'l', 'l': 'g', 'o': 'k', 'n': 'b', 'p': 'r', 's': 'n', 'r': 't', 'u': 'j', 't': 'w', 'w': 'f', 'v': 'p', 'y': 'a', 'x': 'm'}
  
  def solve_small(case):
      G = case
      return ''.join(TRANS[x] for x in G)
  
  solve_large = solve_small
  
  pout = perr
",60
"type = int(raw_input())
  
  for test in range(type):
  	model = raw_input().split(' ')
  	name = int(model[0])
  	month = int(model[1])
  
  	jl = []
  	for job in range(name):
  		any = raw_input().split(' ')
  		array = []
  		for xb in any:
  			array.append(int(xb))
  		jl.append(array)
  
  
  	complet = True
  	for io in range(name):
  		for job in range(month):
  			act = True
  			log = True
  			for xb in range(name):
  				if jl[xb][job] > jl[io][job]:
  					act = False
  					break
  			for xb in range(month):
  				if jl[io][xb] > jl[io][job]:
  					log = False
  					break
  
  			if not act and not log:
  				complet = False
  				break
  
  		if not complet:
  			break
  
  	if complet:
  		print 'Case #'+str(test+1)+': YES'
  	else:
  		print 'Case #'+str(test+1)+': NO'
",61
"ti = int(raw_input())
  
  def mover(non, ini):
  	f = str(non)
  	return int(f[ini:] + f[:ini])
  
  for ini in range(ti):
  	f = raw_input().split(' ')
  	A = int(f[0])
  	j = int(f[1])
  	ok = 0
  	for non in range(A, j):
  		mis = []
  		for mk in range(len(f[0])):
  			m = mover(non, mk+1)
  			if m <= j and m > non and not m in mis:
  				mis.append(m)
  				ok +=1
  
  
  	print 'Case #'+str(ini+1)+':', ok
",61
"time = int(raw_input())
  
  for test in range(time):
  	 r0 = int(raw_input())
  	rc1 = []
  	for job in range(4):
  		rc1.append([int(r) for r in raw_input().split()])
  
  	rsecond = int(raw_input())
  	rtwo = []
  	for job in range(4):
  		rtwo.append([int(r) for r in raw_input().split()])
  
  	success = -1
  	powersibilities = 0
  	for job in rc1[ r0-1]:
  		if rtwo[rsecond-1].count(job) == 1:
  			success = job
  			powersibilities += 1
  
  	if powersibilities > 1:
  		print 'Case #'+str(test+1)+': Bad magician!'
  	elif powersibilities == 0:
  		print 'Case #'+str(test+1)+': Volunteer cheated!'
  	else:
  		print 'Case #'+str(test+1)+': '+str(success)
;t = 0",61
"tt = int(raw_input())
  
  for test in range(tt):
  	num = int(raw_input())
  	Naonic = [float(part) for part in raw_input().split()]
  	center = [float(part) for part in raw_input().split()]
  
  	Naonic.sort()
  	center.sort()
  	ye = 0
  	w = 0
  
  
  	data = Naonic[:]
  	none = center[:]
  	while len(data) > 0:
  		np = data.pop(0)
  		 kcs = -1
  		for part in range(len(none)):
  			if none[part] > np:
  				 kcs = none.pop(part)
  				break
  		if  kcs == -1:
  			 kcs = none.pop(0)
  		if np >  kcs:
  			w += 1
  
  
  	data = Naonic[:]
  	none = center[:]
  	while len(none) > 0:
  		 kcs = none.pop(0)
  		np = -1
  		for part in range(len(data)):
  			if data[part] >  kcs:
  				np = data.pop(part)
  				break
  		if np == -1:
  			np = data.pop(0)
  		if np >  kcs:
  			ye += 1
  
  	print 'Case #'+str(test+1)+':', ye, w
",61
"tt = int(raw_input())
  
  for test in range(tt):
  
  	cycle, fast, input = raw_input().split()
  	cycle = float(cycle)
  	fast = float(fast)
  	input = float(input)
  
  	tt = 0
  	drs = 2.0
  	while cycle/drs < input/drs and tt+input/drs > tt+cycle/drs + input/(drs+fast):
  		tt += cycle/drs
  		drs += fast
  
  	tt += input/drs
  
  	print 'Case #'+str(test+1)+':', tt
;t = 0",61
"time = int(raw_input())
  
  fr = 'yhesocvxduiglbkrztnwjpfmaq'
  
  for phi in range(time):
  	loc = []
  	for part in range(4):
  		loc.append(raw_input())
  	if phi != time-1:
  		raw_input()
  
  	no = False
  	run = False
  	for lock in loc:
  		event = True
  		O = True
  		for uc in lock:
  			if uc != 'X' and uc != 'T':
  				event = False
  			if uc != 'O' and uc != 'T':
  				O = False
  			if uc == '.':
  				no = True
  		if event:
  			print 'Case #'+str(phi+1)+': X won'
  			run = True
  		if O:
  			print 'Case #'+str(phi+1)+': O won'
  			run = True
  
  	if run:
  		continue
  
  	for action in range(4):
  		event = True
  		O = True
  		for batch in range(4):
  			if loc[batch][action] != 'X' and loc[batch][action] != 'T':
  				event = False
  			if loc[batch][action] != 'O' and loc[batch][action] != 'T':
  				O = False
  		if event:
  			print 'Case #'+str(phi+1)+': X won'
  			run = True
  		if O:
  			print 'Case #'+str(phi+1)+': O won'
  			run = True
  	if run:
  		continue
  
  	event = True
  	O = True
  	for part in range(4):
  		if loc[part][part] != 'X' and loc[part][part] != 'T':
  			event = False
  		if loc[part][part] != 'O' and loc[part][part] != 'T':
  			O = False
  	if event:
  		print 'Case #'+str(phi+1)+': X won'
  		continue
  	if O:
  		print 'Case #'+str(phi+1)+': O won'
  		continue
  	event = True
  	O = True
  	for part in range(4):
  		if loc[3-part][part] != 'X' and loc[3-part][part] != 'T':
  			event = False
  		if loc[3-part][part] != 'O' and loc[3-part][part] != 'T':
  			O = False
  	if event:
  		print 'Case #'+str(phi+1)+': X won'
  		continue
  	if O:
  		print 'Case #'+str(phi+1)+': O won'
  		continue
  
  	if no:
  		print 'Case #'+str(phi+1)+': Game has not completed'
  	else:
  		print 'Case #'+str(phi+1)+': Draw'
",61
"template = int(raw_input())
  
  for ase in range(template):
  	print 'Case #'+str(ase+1)+':'
  	right, h, m = raw_input().split()
  	right = int(right)
  	h = int(h)
  	m = int(m)
  
  	if m==0:
  		print 'c' + ('.'*(h-1))
  		for ir in range(right-1):
  			print '.'*h
  	elif right == 1:
  		print 'c'+('.'*(h-m-1))+('*'*(m))
  	elif h == 1:
  		print 'c'
  		for ir in range(right-m-1):
  			print '.'
  		for ir in range(m):
  			print '*'
  	elif right == 2:
  		if m%2==0 and h>2 and m<right*h-2:
  			print 'c'+('.'*(h-m/2-1))+('*'*(m/2))
  			print ('.'*(h-m/2))+('*'*(m/2))
  		elif m == right*h - 1:
  			print 'c'+('*'*(h-1))
  			print '*'*h
  		else:
  			print 'Impossible'
  	elif h == 2:
  		if m%2==0 and right>2 and m<right*h-2:
  			print 'c.'
  			for ir in range(right-m/2-1):
  				print '..'
  			for ir in range(m/2):
  				print '**'
  		elif m == right*h - 1:
  			print 'c*'
  			for ir in range(right-1):
  				print '**'
  		else:
  			print 'Impossible'
  	elif h == 3 and right == 3:
  		if m == 1:
  			print 'c..'
  			print '...'
  			print '..*'
  		elif m == 2:
  			print 'Impossible'
  		elif m == 3:
  			print 'c..'
  			print '...'
  			print '***'
  		elif m == 4:
  			print 'Impossible'
  		elif m == 5:
  			print 'c.*'
  			print '..*'
  			print '***'
  		elif m == 6:
  			print 'Impossible'
  		elif m == 7:
  			print 'Impossible'
  		elif m == 8:
  			print 'c**'
  			print '***'
  			print '***'
  	elif h == 3 and right == 4:
  		if m == 1:
  			print 'c..'
  			print '...'
  			print '...'
  			print '..*'
  		elif m == 2:
  			print 'c..'
  			print '...'
  			print '..*'
  			print '..*'
  		elif m == 3:
  			print 'c..'
  			print '...'
  			print '...'
  			print '***'
  		elif m == 4:
  			print 'c.*'
  			print '..*'
  			print '..*'
  			print '..*'
  		elif m == 5:
  			print 'Impossible'
  		elif m == 6:
  			print 'c..'
  			print '...'
  			print '***'
  			print '***'
  		elif m == 7:
  			print 'Impossible'
  		elif m == 8:
  			print 'c.*'
  			print '..*'
  			print '***'
  			print '***'
  		elif m == 9:
  			print 'Impossible'
  		elif m == 10:
  			print 'Impossible'
  		elif m == 11:
  			print 'c**'
  			print '***'
  			print '***'
  			print '***'
  	elif h == 3 and right == 5:
  		if m == 1:
  			print 'c..'
  			print '...'
  			print '...'
  			print '...'
  			print '..*'
  		elif m == 2:
  			print 'c..'
  			print '...'
  			print '...'
  			print '..*'
  			print '..*'
  		elif m == 3:
  			print 'c..'
  			print '...'
  			print '..*'
  			print '..*'
  			print '..*'
  		elif m == 4:
  			print 'c..'
  			print '...'
  			print '...'
  			print '..*'
  			print '***'
  		elif m == 5:
  			print 'c.*'
  			print '..*'
  			print '..*'
  			print '..*'
  			print '..*'
  		elif m == 6:
  			print 'c..'
  			print '...'
  			print '...'
  			print '***'
  			print '***'
  		elif m == 7:
  			print 'c..'
  			print '...'
  			print '..*'
  			print '***'
  			print '***'
  		elif m == 8:
  			print 'Impossible'
  		elif m == 9:
  			print 'c..'
  			print '...'
  			print '***'
  			print '***'
  			print '***'
  		elif m == 10:
  			print 'Impossible'
  		elif m == 11:
  			print 'c.*'
  			print '..*'
  			print '***'
  			print '***'
  			print '***'
  		elif m == 12:
  			print 'Impossible'
  		elif m == 13:
  			print 'Impossible'
  		elif m == 14:
  			print 'c**'
  			print '***'
  			print '***'
  			print '***'
  			print '***'
  	elif h == 4 and right == 3:
  		if m == 1:
  			print 'c...'
  			print '....'
  			print '...*'
  		elif m == 2:
  			print 'c...'
  			print '...*'
  			print '...*'
  		elif m == 3:
  			print 'c..*'
  			print '...*'
  			print '...*'
  		elif m == 4:
  			print 'c...'
  			print '....'
  			print '****'
  		elif m == 5:
  			print 'Impossible'
  		elif m == 6:
  			print 'c.**'
  			print '..**'
  			print '..**'
  		elif m == 7:
  			print 'Impossible'
  		elif m == 8:
  			print 'c.**'
  			print '..**'
  			print '****'
  		elif m == 9:
  			print 'Impossible'
  		elif m == 10:
  			print 'Impossible'
  		elif m == 11:
  			print 'c***'
  			print '****'
  			print '****'
  	elif h == 4 and right == 4:
  		if m == 1:
  			print 'c...'
  			print '....'
  			print '....'
  			print '...*'
  		elif m == 2:
  			print 'c...'
  			print '....'
  			print '....'
  			print '..**'
  		elif m == 3:
  			print 'c...'
  			print '....'
  			print '...*'
  			print '..**'
  		elif m == 4:
  			print 'c...'
  			print '....'
  			print '....'
  			print '****'
  		elif m == 5:
  			print 'c...'
  			print '....'
  			print '...*'
  			print '****'
  		elif m == 6:
  			print 'c...'
  			print '....'
  			print '..**'
  			print '****'
  		elif m == 7:
  			print 'c..*'
  			print '...*'
  			print '...*'
  			print '****'
  		elif m == 8:
  			print 'c...'
  			print '....'
  			print '****'
  			print '****'
  		elif m == 9:
  			print 'Impossible'
  		elif m == 10:
  			print 'c.**'
  			print '..**'
  			print '..**'
  			print '****'
  		elif m == 11:
  			print 'Impossible'
  		elif m == 12:
  			print 'c.**'
  			print '..**'
  			print '****'
  			print '****'
  		elif m == 13:
  			print 'Impossible'
  		elif m == 14:
  			print 'Impossible'
  		elif m == 15:
  			print 'c***'
  			print '****'
  			print '****'
  			print '****'
  	elif h == 4 and right == 5:
  		if m == 1:
  			print 'c...'
  			print '....'
  			print '....'
  			print '....'
  			print '...*'
  		elif m == 2:
  			print 'c...'
  			print '....'
  			print '....'
  			print '....'
  			print '..**'
  		elif m == 3:
  			print 'c...'
  			print '....'
  			print '...*'
  			print '...*'
  			print '...*'
  		elif m == 4:
  			print 'c...'
  			print '....'
  			print '....'
  			print '....'
  			print '****'
  		elif m == 5:
  			print 'c..*'
  			print '...*'
  			print '...*'
  			print '...*'
  			print '...*'
  		elif m == 6:
  			print 'c...'
  			print '....'
  			print '....'
  			print '..**'
  			print '****'
  		elif m == 7:
  			print 'c..*'
  			print '...*'
  			print '...*'
  			print '..**'
  			print '..**'
  		elif m == 8:
  			print 'c...'
  			print '....'
  			print '....'
  			print '****'
  			print '****'
  		elif m == 9:
  			print 'c..*'
  			print '...*'
  			print '...*'
  			print '..**'
  			print '****'
  		elif m == 10:
  			print 'c.**'
  			print '..**'
  			print '..**'
  			print '..**'
  			print '..**'
  		elif m == 11:
  			print 'c..*'
  			print '...*'
  			print '...*'
  			print '****'
  			print '****'
  		elif m == 12:
  			print 'c...'
  			print '....'
  			print '****'
  			print '****'
  			print '****'
  		elif m == 13:
  			print 'Impossible'
  		elif m == 14:
  			print 'c..*'
  			print '...*'
  			print '****'
  			print '****'
  			print '****'
  		elif m == 15:
  			print 'Impossible'
  		elif m == 16:
  			print 'c.**'
  			print '..**'
  			print '****'
  			print '****'
  			print '****'
  		elif m == 17:
  			print 'Impossible'
  		elif m == 18:
  			print 'Impossible'
  		elif m == 19:
  			print 'c***'
  			print '****'
  			print '****'
  			print '****'
  			print '****'
  	elif h == 5 and right == 3:
  		if m == 1:
  			print 'c....'
  			print '.....'
  			print '....*'
  		elif m == 2:
  			print 'c....'
  			print '.....'
  			print '...**'
  		elif m == 3:
  			print 'c....'
  			print '.....'
  			print '..***'
  		elif m == 4:
  			print 'c...*'
  			print '....*'
  			print '...**'
  		elif m == 5:
  			print 'c....'
  			print '.....'
  			print '*****'
  		elif m == 6:
  			print 'c..**'
  			print '...**'
  			print '...**'
  		elif m == 7:
  			print 'c..**'
  			print '...**'
  			print '..***'
  		elif m == 8:
  			print 'Impossible'
  		elif m == 9:
  			print 'c.***'
  			print '..***'
  			print '..***'
  		elif m == 10:
  			print 'Impossible'
  		elif m == 11:
  			print 'c.***'
  			print '..***'
  			print '*****'
  		elif m == 12:
  			print 'Impossible'
  		elif m == 13:
  			print 'Impossible'
  		elif m == 14:
  			print 'c****'
  			print '*****'
  			print '*****'
  	elif h == 5 and right == 4:
  		if m == 1:
  			print 'c....'
  			print '.....'
  			print '.....'
  			print '....*'
  		elif m == 2:
  			print 'c....'
  			print '.....'
  			print '.....'
  			print '...**'
  		elif m == 3:
  			print 'c....'
  			print '.....'
  			print '.....'
  			print '..***'
  		elif m == 4:
  			print 'c...*'
  			print '....*'
  			print '....*'
  			print '....*'
  		elif m == 5:
  			print 'c....'
  			print '.....'
  			print '.....'
  			print '*****'
  		elif m == 6:
  			print 'c...*'
  			print '....*'
  			print '....*'
  			print '..***'
  		elif m == 7:
  			print 'c....'
  			print '.....'
  			print '...**'
  			print '*****'
  		elif m == 8:
  			print 'c..**'
  			print '...**'
  			print '...**'
  			print '...**'
  		elif m == 9:
  			print 'c...*'
  			print '....*'
  			print '...**'
  			print '*****'
  		elif m == 10:
  			print 'c....'
  			print '.....'
  			print '*****'
  			print '*****'
  		elif m == 11:
  			print 'c..**'
  			print '...**'
  			print '...**'
  			print '*****'
  		elif m == 12:
  			print 'c.***'
  			print '..***'
  			print '..***'
  			print '..***'
  		elif m == 13:
  			print 'Impossible'
  		elif m == 14:
  			print 'c.***'
  			print '..***'
  			print '..***'
  			print '*****'
  		elif m == 15:
  			print 'Impossible'
  		elif m == 16:
  			print 'c.***'
  			print '..***'
  			print '*****'
  			print '*****'
  		elif m == 17:
  			print 'Impossible'
  		elif m == 18:
  			print 'Impossible'
  		elif m == 19:
  			print 'c****'
  			print '*****'
  			print '*****'
  			print '*****'
  	elif h == 5 and right == 5:
  		if m == 1:
  			print 'c....'
  			print '.....'
  			print '.....'
  			print '.....'
  			print '....*'
  		elif m == 2:
  			print 'c....'
  			print '.....'
  			print '.....'
  			print '.....'
  			print '...**'
  		elif m == 3:
  			print 'c....'
  			print '.....'
  			print '.....'
  			print '.....'
  			print '..***'
  		elif m == 4:
  			print 'c....'
  			print '.....'
  			print '.....'
  			print '...**'
  			print '...**'
  		elif m == 5:
  			print 'c....'
  			print '.....'
  			print '.....'
  			print '.....'
  			print '*****'
  		elif m == 6:
  			print 'c....'
  			print '.....'
  			print '.....'
  			print '..***'
  			print '..***'
  		elif m == 7:
  			print 'c....'
  			print '.....'
  			print '.....'
  			print '...**'
  			print '*****'
  		elif m == 8:
  			print 'c....'
  			print '.....'
  			print '.....'
  			print '..***'
  			print '*****'
  		elif m == 9:
  			print 'c...*'
  			print '....*'
  			print '....*'
  			print '....*'
  			print '*****'
  		elif m == 10:
  			print 'c....'
  			print '.....'
  			print '.....'
  			print '*****'
  			print '*****'
  		elif m == 11:
  			print 'c....'
  			print '.....'
  			print '....*'
  			print '*****'
  			print '*****'
  		elif m == 12:
  			print 'c....'
  			print '.....'
  			print '...**'
  			print '*****'
  			print '*****'
  		elif m == 13:
  			print 'c....'
  			print '.....'
  			print '..***'
  			print '*****'
  			print '*****'
  		elif m == 14:
  			print 'c..**'
  			print '...**'
  			print '...**'
  			print '..***'
  			print '*****'
  		elif m == 15:
  			print 'c....'
  			print '.....'
  			print '*****'
  			print '*****'
  			print '*****'
  		elif m == 16:
  			print 'c..**'
  			print '...**'
  			print '...**'
  			print '*****'
  			print '*****'
  		elif m == 17:
  			print 'c..**'
  			print '...**'
  			print '..***'
  			print '*****'
  			print '*****'
  		elif m == 18:
  			print 'Impossible'
  		elif m == 19:
  			print 'c..**'
  			print '...**'
  			print '*****'
  			print '*****'
  			print '*****'
  		elif m == 20:
  			print 'Impossible'
  		elif m == 21:
  			print 'c.***'
  			print '..***'
  			print '*****'
  			print '*****'
  			print '*****'
  		elif m == 22:
  			print 'Impossible'
  		elif m == 23:
  			print 'Impossible'
  		elif m == 24:
  			print 'c****'
  			print '*****'
  			print '*****'
  			print '*****'
  			print '*****'
  	else:
  		print 'Impossible'
  
",61
"time = int(raw_input())
  
  cc = ['y', 'h', 'e', 's', 'o', 'c', 'v', 'x', 'd', 'u', 'i', 'g', 'l', 'b', 'k', 'r', 'z', 't', 'n', 'w', 'j', 'p', 'f', 'm', 'a', 'q']
  
  for ace in range(time):
  	orig = raw_input()
  	 decided = ''
  
  	for case in orig:
  		if case==' ':
  			 decided += case
  		else:
  			 decided += cc[ord(case)-97]
  
  	print 'Case #'+str(ace+1)+':',  decided
;t = 0",61
" 
  crinn = sys.crinn
  for conf in xrange(int(crinn.readline())):
      n,module = map(int, crinn.readline().split())
      rows = [map(int, crinn.readline().split()) for i in xrange(n)]
      cold = [[node[i] for node in rows] for i in xrange(module)]
  
      rowmaxs = [max(x) for x in rows]
      colmaxs = [max(x) for x in cold]
  
      verdict = ""YES""
      for i in xrange(n):
          for k in xrange(module):
              if min(rowmaxs[i], colmaxs[k]) > rows[i][k]:
                  verdict = ""NO""
                  break
  
          if verdict == ""NO"": break
  
      print ""Case #%i: %s"" % (conf+1, verdict)
",62
" 
  pots = [int(10**k) for k in xrange(0,16)]
  
  T = int(stdin.readline())
  
  for  iP in xrange(1,T+1):
  	ak,b = map(int, stdin.readline().split())
  	test = 0
  	m = len(str(ak))
  
  	start = int(10**m)
  
  	for n in xrange(ak,b):
  		ss = []
  		q = 1
  		part = start
  		for j in xrange(1,m):
  			q *= 10
  			part /= 10
  			str = (n % part) * q + (n /part)
  			if n < str and str <= b and not str in ss: 
  				ss.append(str)
  				test += 1
  
  
  	print ""Case #%d: %d"" % ( iP,test)
  
",62
" 
  
  lines = [map(int, data.strip().split("" "")) for data in open(sys.argv[1]).readlines()]
  [count] = lines[0]
  assert count * 10 + 1 == len(lines)
  
  for part in xrange(count):
      server = part*10
      [N01] = lines[server+1]
      [Ntwo] = lines[server+6]
       row01 = set(lines[server+1+N01])
      node2 = set(lines[server+6+Ntwo])
      common =  row01.intersection(node2)
      print ""Case #%s:"" % (part+1),
      if len(common) == 1:
          print list(common)[0]
      elif not common:
          print ""Volunteer cheated!""
      else:
          print ""Bad magician!""
",62
" 
  f = open(sys.argv[1])
  part = int(f.readline())
  
  for info in xrange(0, part):
      n = int(f.readline())
      naomis = sorted(map(float, f.readline().split()))
      kens = sorted(map(float, f.readline().split()))
      assert len(naomis) == n and len(kens) == n
  
      naomis_w = set(naomis)
      kens_w = set(kens)
      naomi_war_waouts = 0
      while naomis_w:
          nasoin = max(naomis_w)
          try:
              ken = min(w for w in kens_w if w > nasoin)
          except ValueError:
              ken = min(kens_w)
              naomi_war_waouts += 1
          naomis_w.remove(nasoin)
          kens_w.remove(ken)
  
      naomi_deceit_waINS = 0
      naomis_w = set(naomis)
      kens_w = set(kens)
      while naomis_w:
          ken = min(kens_w)
          try:
              nasoin = min(w for w in naomis_w if w > ken)
              naomi_deceit_waINS += 1
          except ValueError:
              nasoin = min(naomis_w)
          naomis_w.remove(nasoin)
          kens_w.remove(ken)
  
      print ""Case #%s: %s %s"" % (info+1, naomi_deceit_waINS, naomi_war_waouts)
",62
" 
  lines = [line.strip() for line in open(sys.argv[1])]
  count = int(lines[0])
  
  for i in xrange(count):
      farm_cost,farm_production,target = map(float, lines[i+1].split())
      points = 0
      production = 2
      instance = float(""inf"")
      while True:
          instance = min(instance, points + target / production)
          points += farm_cost / production
          if points >= instance: break
          production += farm_production
  
      print ""Case #%s: %.7f"" % (i+1, instance)
",62
" 
  gestdin = sys.gestdin
  ptfiles = range(4)
  for i in xrange(int(gestdin.readline())):
      print ""Case #%i: "" % (i+1),
      rows = [gestdin.readline()[:4] for i in ptfiles]
  
      columngs = [[ip[i] for ip in rows] for i in ptfiles]
      adiagged = [
          [rows[i][i] for i in ptfiles],
          [rows[i][3-i] for i in ptfiles]
      ]
      notdone = False
      for ip in rows + columngs + adiagged:
          x = None
          for t in ip:
              if t == '.':
                  notdone = True
                  break
              elif t == 'T':
                  continue
              elif x is not None and x != t:
                  break
              else:
                  x = t
          else:
              print x, ""won""
              break
      else:
          if notdone: print ""Game has not completed""
          else:       print ""Draw""
  
      gestdin.readline()
",62
" 
  lines = [line.strip() for line in open(sys.argv[1])]
  count = int(lines[0])
  
  for i in xrange(count):
      R,C,M = map(int, lines[i+1].split())
      print ""Case #%s:"" % (i+1)
  
      w = max(R,C)
      h = min(R,C)
      X = R*C - M
      assert X > 0
  
      if X == 1:
          ros = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]
      elif h == 1:
          ros = ['c' + '.' * (X-1) + '*' * M]
      elif X == 4:
              ros = [
                  'c.' + '*' * (w-2),
                  '..' + '*' * (w-2),
              ] + ['*' * w] * (h-2)
      elif h == 2:
          if X%2 == 1 or X == 2:
              ros = None
          else:
              ros = [
                  'c' + '.' * (X/2-1) + '*' * (M/2),
                  '.' + '.' * (X/2-1) + '*' * (M/2)
              ]
      elif X <= 5 or X == 7:
          ros = None
  
      elif X%2 == 0 and X <= w*2:
          r = X/2
          ros = [
              'c' + '.' * (r - 1) + '*' * (w-r),
                    '.' * r       + '*' * (w-r),
          ] + ['*' * w] * (h-2)
  
      elif X <= w*3 and (X % 3) != 1:
          n = (X+1) / 3
          t = X - 2*n
          ros = [
              'c' + '.' * (n-1) + '*' * (w-n),
                    '.' * n     + '*' * (w-n),
                    '.' * t     + '*' * (w-t)
          ] + ['*' * w] * (h-3)
      else:
          n = X / w
          t = X % w
          if t == 1:
              ros = (
                      ['c' + (w-1) * '.']
                  +   ['.' * w] * (n-2)
                  +   ['.' * (w-1) + '*']
                  +   ['..' + '*' * (w-2)]
                  +   ['*' * w] * (h - n - 1)
              )
          else:
              k = 1 if t == 0 else 0
              ros = (
                      ['c' + (w-1) * '.']
                  +   ['.' * w] * (n-1)
                  +   ['.' * t + '*' * (w-t)] * (1 - k)
                  +   ['*' * w] * (h - n - 1 + k)
              )
  
      if ros:
          if R > C:
              ros = ["""".join(row[i] for row in ros) for i in xrange(R)]
  
          for row in ros:
              print row
  
          assert len(ros) == R
          assert len(ros[0]) == C
          assert sum(1 for row in ros for col in row if col == '*') == M
  
      else:
          print ""Impossible""
  
",62
" 
  googlerese = """"""
  y qee
  ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv
  z
  """"""
  
  plain = """"""
  a zoo
  our language is impossible to understand
  there are twenty six factorial possibilities
  so it is okay if you want to just give up
  q
  """"""
  
  gtos = {}
  astograph = {}
  
  for stats,git in zip(plain, googlerese):
  	gtos[git] = stats
  	astograph[stats] = git
  
  
  data = sys.stdin
  
   title = int(data.readline())
  
  for i in xrange(0, title):
  	line = data.readline().strip()
  	print ""Case #%d: %s"" % (i+1, """".join([gtos.get(case,case) for case in line]))
  
",62
" fin = sys.stdin
  T = int(fin.readline())
  for patch in range(1,T+1):
      hole = []
      N, M = map(int, fin.readline().split())
      for i in range(N):
          hole.append(list(map(int, fin.readline().split())))
      
      rowingmins = [100]*N
      row_max = [0]*N
      col32mini = [100]*M
      row_chain = [0]*M
  
      for i in range(N):
          for j in range(M):
              v = hole[i][j]
              rowingmins[i] = min(v, rowingmins[i])
              row_max[i] = max(v, row_max[i])
              col32mini[j] = min(v, col32mini[j])
              row_chain[j] = max(v, row_chain[j])
  
  
      ppable = True
      for i in range(N):
          for j in range(M):
              v = hole[i][j]
              if v != row_max[i] and v != row_chain[j]:
                  ppable = False
                  break
  
  
      print(""Case #%d: %s"" % (patch, ppable and ""YES"" or ""NO""))
  
  
  
",63
" trans = sys.stdin
  T = int(trans.readline())
  for case in range(1,T+1):
      A, B = map(int, trans.readline().split())
  
      final = 0
  
      for i in range(A, B+1):
          nit = str(i)
          pairs = set()
          for shift in range(1, len(nit)):
              m = nit[shift:] + nit[:shift]
              j = int(m)
              if j > i and j <= B:
                  pairs.add(m)
          final += len(pairs)
  
  
      print ""Case #%d: %s"" % (case, final)
  
",63
" 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  def debug(*args):
      print(*args, file=sys.stderr)
  
  ini = sys.stdin
  T = int(ini.readline())
  for test in range(1, T + 1):
      answer1 = int(ini.readline())
      rows1 = []
      for i in range(4):
          rows1.append(set(map(int, ini.readline().split())))
      answer2 = int(ini.readline())
      rows2 = []
      for i in range(4):
          rows2.append(set(map(int, ini.readline().split())))
  
      possibilities1 = rows1[answer1-1]
      possibilities2 = rows2[answer2-1]
  
      numbers = possibilities1.intersection(possibilities2)
      data = None
      if len(numbers) == 1:
          data = list(numbers)[0]
      elif len(numbers) == 0:
          data = 'Volunteer cheated!'
      else:
          data = 'Bad magician!'
  
  
      print(""Case #%d: %s"" % (test, data))
  
",63
" 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  def debug(*args):
      print(*args, file=sys.stderr)
  
  fin = sys.stdin
  T = int(fin.readline())
  for patch in range(1, T + 1):
      N = int(fin.readline())
      cumbers3 = list(map(float, fin.readline().split()))
      neums8 = list(map(float, fin.readline().split()))
  
      cumbers3.sort(reverse=True)
      neums8.sort()
  
      naomi = 0
      remaning = neums8[:]
      for n in cumbers3:
          placed = False
          for ie, r in enumerate(remaning):
              if r > n:
                  del remaning[ie]
                  placed = True
                  break
          if not placed:
              naomi += 1
  
      risk = 0
      remaning = neums8[:]
      cumbers3.sort()
      while cumbers3:
          n = cumbers3[0]
          if n > remaning[0]:
              risk += 1
              del remaning[0]
              del cumbers3[0]
          else:
              del remaning[-1]
              del cumbers3[0]
  
      print(""Case #%d: %d %d"" % (patch, risk, naomi))
  
",63
" 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  def debug(*args):
      print(*args, file=sys.stderr)
  
  rb = sys.stdin
  T = int(rb.readline())
  for case in range(1, T + 1):
      C, FA, X = map(float, rb.readline().split())
  
  
      rate = 2
      event = 0
  
      cost = 10**20
  
      while event < cost:
          result = X / rate + event
          if result < cost:
              cost = result
          event += C / rate
          rate += FA
  
  
  
      print(""Case #%d: %.7f"" % (case, cost))
  
",63
" fin = sys.stdin
  T = int(fin.readline())
  for case in range(1,T+1):
      board = []
      for i in range(4):
          row = list(fin.readline().strip())
          board.append(row)
  
      fin.readline()
  
      rows = [[], [], [], []]
      cols = [[], [], [], []]
      diags = [[], []]
  
      for i in range(4):
          for j in range(4):
              v = board[i][j]
              rows[i].append(v)
              cols[j].append(v)
              if i == j:
                  diags[0].append(v)
              if i + j == 3:
                  diags[1].append(v)
  
      buckets = rows + cols + diags
      date = 'Draw'
      filled = True
      for bucket in buckets:
          data = {'T': 0, 'X': 0, 'O': 0, '.': 0}
          for v in bucket:
              data[v] += 1
          if data['T'] + data['X'] == 4:
              date = 'X won'
              break
          if data['T'] + data['O'] == 4:
              date = 'O won'
              break
          if data['.'] > 0:
              date = 'Game has not completed'
  
      print(""Case #%d: %s"" % (case, date))
  
  
  
",63
" 
  
  
  
  
  
  
  
  
  
  
  
  
   
  
  
  
  
  def debug(*args):
      print(*args, file=sys.stderr)
  
  ini = sys.stdin
  T = int(ini.readline())
  for case in range(1, T + 1):
      RR, CC, M = map(int, ini.readline().split())
      R, C = None, None
      blocks = RR*CC - M
      inverse = False
      if RR > CC:
          inverse = True
          R, C = CC, RR
      else:
          R, C = RR, CC
      data = None
      if R == 1:
          data = [('.' * blocks) + ('*' * M)]
      elif R == 2:
          if blocks == 1:
              data = ['.' + ('*' * (C-1)), '*' * C]
          elif blocks % 2 == 0 and blocks != 2:
              cc = blocks // 2
              data = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] 
          else:
              data = None
      else:
          if blocks == 1:
              data = ['*' * C] * R
          elif blocks == 4:
              data = ['..' + (C-2)*'*']*2
              data += ['*'*C] * (R-2)
          elif blocks == 6:
              data = ['...' + (C-3)*'*']*2
              data += ['*'*C] * (R-2)
          for rows in range(3, R+1):
              for columns in range(rows, C+1):
                  size = rows * columns
                  if size - blocks >= 0:
                      if size - blocks <= columns - 2: 
                          data = []
                          for r in range(rows):
                              if r < rows - 1:
                                  data.append(('.' * columns) + ('*' * (C - columns)))
                              else:
                                  cc = columns - (size - blocks)
                                  data.append(('.' * cc) + ('*' * (C - cc)))
                          for r in range(R - rows):
                              data.append('*' * C)
                      elif size - blocks == columns - 1 and rows >= 4:
                          data = []
                          for r in range(rows):
                              if r < rows - 2:
                                  data.append(('.' * columns) + ('*' * (C - columns)))
                              elif r == rows - 2:
                                  cc = columns - 1
                                  data.append(('.' * cc) + ('*' * (C - cc)))
                              else:
                                  cc = 2
                                  data.append(('.' * cc) + ('*' * (C - cc)))
                          for r in range(R - rows):
                              data.append('*' * C)
                      
  
  
  
      print(""Case #%d: "" % (case))
      if data is None:
          debug('impossible', blocks, RR, CC)
          print(""Impossible"")
      else:
          mines = 0
          for r in range(RR):
              row = ''
              for c in range(CC):
                  rr, cc = r, c
                  if inverse:
                      rr, cc = c, r
                  if rr == 0 and cc == 0:
                      row += 'c'
                  else:
                      row += data[rr][cc]
                      if data[rr][cc] == '*':
                          mines += 1
              print(row)
          if mines != M:
              raise Exception(""%d != %d %d x %d"" % (mines, M, RR, CC))
              
  
  
",63
" 
  input = """"""ejp mysljylc kd kxveddknmc re jsicpdrysi
  rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd
  de kr kd eoya kw aej tysr re ujdr lkgc jv""""""
  
  output = """"""our language is impossible to understand
  there are twenty six factorial possibilities
  so it is okay if you want to just give up""""""
  
  mapping = {'a': 'y', 'o': 'e', 'z': 'q', 'q': 'z'}
  
  for i, c in enumerate(input):
      mapping[c] = output[i]
  
  
  data = sys.stdin
  T = int(data.readline())
  for case in range(1,T+1):
      line = data.readline().strip()
  
      result = """"
      for c in line:
          result += mapping[c]
  
      print ""Case #%d: %s"" % (case, result)
  
",63
" 
  def read_ints():
      return map(int, stdin.readline().rstrip().split(' '))
  
  def print_lawn(lawn):
      for row in lawn:
          print row
          
  def is_higher(ana, i, j, N, M):
      s = ana[i][j]
      v, h = False, False
      for ii in xrange(N):
          if ana[ii][j] > s:
              v = True
              break
      for jj in xrange(M):
          if ana[i][jj] > s:
              h = True
              break
      return v and h
      
  def check(ana, N, M):
      if N == 1 or M == 1:
          return True
      else:
          for i in xrange(N):
              for j in xrange(M):
                  h = is_higher(ana, i, j, N, M)
                  if h:
                      return False
          return True
      
  def main():
      F = int(stdin.readline())
      for Lu in xrange(F):
          N, M = read_ints()
          ana = []
          for i in xrange(N):
              ana.append(read_ints())
          ace = 'YES' if check(ana, N, M) else 'NO'
          print 'Case #{}: {}'.format(Lu + 1, ace)
          
  main()
",64
" 
  def program():
  	Total = int(stdin.readline())
  	for Ti in xrange(Total):
  		G, GB =  map(int, stdin.readline().rstrip().split(' '))
  		
  		services = set()
  		for max in xrange(G, GB + 1):
  			source = str(max)
  			for part in xrange(1, len(source)):
  				mm = source[part:] + source[:part]
  				if mm[0] != '0':
  					mu = int(mm)
  					if mu > max and mu <= GB:
  						services.add((max, mu))
  		
  		print 'Case #%d: %d' % (Ti + 1, len(services))	
  	
  if __name__ == '__main__':
  	program()
",64
" 
  def read_str(): return stdin.readline().rstrip('
')
  def read_int(): return int(stdin.readline())
  def read_ints(): return map(int, stdin.readline().split())
  
  def read_cards():
      files = []
      for i in range(4):
          files.append(read_ints())
      return files
  
  def main():
      ups = read_int()
      for test in range(1, ups + 1):
          uc = read_int() - 1
          files = read_cards()
          candidates1 = set(files[uc])
          
          uc = read_int() - 1
          files = read_cards()
          candidates2 = set(files[uc])
          
          charances = candidates1.intersection(candidates2)
          if len(charances) == 1:
              amps = list(charances)[0]
          elif len(charances) == 0:
              amps = 'Volunteer cheated!'
          else:
              amps = 'Bad magician!'
          
          print('Case #{}: {}'.format(test, amps))
          
  main()
",64
" 
  
  def read_str(): return stdin.readline().rstrip('
')
  def read_int(): return int(stdin.readline())
  def read_ints(): return map(int, stdin.readline().split())
  def read_floats(): return map(float, stdin.readline().split())
  
      
  def war(Nat, Disk):
      path = 0
      jobs = 0
      for z in range(len(Nat)):
          while jobs < len(Disk) and Disk[jobs] < Nat[z]:
              jobs += 1
          if jobs == len(Disk):
              path += 1
          else:
              jobs += 1
      return path
  
  
  def deceitful_war(Nat, Disk):
      return len(Nat) - war(Disk, Nat)
      
  
  def solve_case():
      read_int()
      Nat = sorted(read_floats())
      Disk = sorted(read_floats())
      
      return '{} {}'.format(deceitful_war(Nat, Disk), war(Nat, Disk))
  
      
  def main():
      files = read_int()
      for address in range(1, files + 1):
          print('Case #{}: {}'.format(address, solve_case()))
  
          
  main()
;N = 0",64
" 
  def read_str(): return stdin.readline().rstrip('
')
  def read_int(): return int(stdin.readline())
  def read_ints(): return map(int, stdin.readline().split())
  def read_floats(): return map(float, stdin.readline().split())
  
  
  def solve_case():
      MC, CNN, Event = read_floats()
      rate = 2
      test = 0
      master = Event / rate
      
      while True:
          test += MC / rate
          rate += CNN
          open = test + Event / rate
          if open < master:
              master = open
          else:
              break
      
      return master
  
      
  def main():
      files = read_int()
      for rice in range(1, files + 1):
          print('Case #{}: {:.7f}'.format(rice, solve_case()))
  
          
  main()
",64
" 
  def won(x, o, t):
      if x == 4 or (x == 3 and t == 1):
          return 1
      elif o == 4 or (o == 3 and t == 1):
          return 2
  
  def check(board, BOARDTIMESize, RESULTS):
      d = 0
      for i in xrange(BOARDTIMESize):
          x = board[i].count('X')
          o = board[i].count('O')
          t = board[i].count('T')
          d += board[i].count('.')
          w = won(x, o, t)
          if w:
              return w
      for i in xrange(BOARDTIMESize):
          vertical = [ board[j][i] for j in xrange(BOARDTIMESize) ]
          x = vertical.count('X')
          o = vertical.count('O')
          t = vertical.count('T')
          w = won(x, o, t)
          if w:
              return w
      x, o, t = 0, 0, 0
      for i in xrange(BOARDTIMESize):
          if board[i][i] == 'X':
              x += 1
          elif board[i][i] == 'O':
              o += 1
          elif board[i][i] == 'T':
              t += 1
      w = won(x, o, t)
      if w:
          return w    
      x, o, t = 0, 0, 0
      for i in xrange(BOARDTIMESize):
          if board[i][BOARDTIMESize - i - 1] == 'X':
              x += 1
          elif board[i][BOARDTIMESize - i - 1] == 'O':
              o += 1
          elif board[i][BOARDTIMESize - i - 1] == 'T':
              t += 1
      w = won(x, o, t)
      if w:
          return w
      if d == 0:
          return 3
      else:
          return 4
      
  def main():
      BOARDTIMESize = 4
      RESULTS = 'X won', 'O won', 'Draw', 'Game has not completed'
  
      T = int(stdin.readline())
      for Ti in xrange(T):
          board = []
          for i in xrange(BOARDTIMESize):
              board.append(list(stdin.readline().rstrip()))
          print 'Case #{}: {}'.format(Ti + 1, RESULTS[check(board, BOARDTIMESize, RESULTS) - 1])    
          stdin.readline()
          
  main()
",64
" 
  
  def read_str(): return stdin.readline().rstrip('
')
  def read_int(): return int(stdin.readline())
  def read_ints(): return map(int, stdin.readline().split())
  def read_floats(): return map(float, stdin.readline().split())
  
  
  def atos(A):
      return '
'.join([''.join(row) for row in A])
      
  
  def get_field(attr, fc):
      data = [['.'] * fc for i in range(attr)]
      data[0][0] = 'c'
      return data
      
      
  def is_forbidden(i, j):
      return i == 0 and j == 0 or i == 0 and j == 1 or \
          i == 1 and j == 0 or i == 1 and j == 1
      
      
  def fill(data, attr, fc, m):
      left = m
      for ii in range(attr - 1, -1, -1):
          i = ii
          j = fc - 1
          while i < attr and j >= 0:
              if is_forbidden(i, j):
                  i += 1
                  j -= 1
                  continue
              if left == 0:
                  return 0
              data[i][j] = '*'
              left -= 1
              
              i += 1
              j -= 1
              
          if ii == 0:
              for jj in range(fc - 2, 1, -1):
                  i = ii
                  j = jj
                  while i < attr and j >= 0:
                      if is_forbidden(i, j):
                          i += 1
                          j -= 1
                          continue
                      if left == 0:
                          return 0
                      data[i][j] = '*'
                      left -= 1
                      
                      i += 1
                      j -= 1
              
      if attr * fc == m + 1:
          if attr > 1:
              data[1][0] = '*'
          if fc > 1:
              data[0][1] = '*'
          if attr > 1 and fc > 1:
              data[1][1] = '*'
          return 0
              
      return left
  
      
  def solve_case():
      attr, fc, m = read_ints()
      
      data = get_field(attr, fc)
          
      left = fill(data, attr, fc, m)
          
      return 'Impossible' if left != 0 else atos(data)
      
      
  def main():
      cases = read_int()
      for case in range(1, cases + 1):
          print('Case #{}:
{}'.format(case, solve_case()))
  
          
  main()
",64
" 
  def get_mapping():
  	d = ord('a')
  	mapping = [ None ] * 26
  	 inputes = [ 'ejp mysljylc kd kxveddknmc re jsicpdrysi', 
  		'rbcpc ypc rtcsra dkh wyfrepkym veddknkmkrkcd', 
  		'de kr kd eoya kw aej tysr re ujdr lkgc jv' ]
  	configs = [ 'our language is impossible to understand', 
  		'there are twenty six factorial possibilities', 
  		'so it is okay if you want to just give up' ]
  	
  	for i in xrange(len( inputes)):
  		data =  inputes[i]
  		result = configs[i]
  		for part in xrange(len(data)):
  			if data[part] == ' ':
  				continue
  			work = ord(data[part]) - d
  			if mapping[work] is None:
  				mapping[work] = result[part]
  	mapping[ord('q') - d] = 'z'
  	mapping[ord('z') - d] = 'q'
  				
  	return mapping
  			
  
  def program():
  	test = int(stdin.readline())
  	mapping = get_mapping()
  	d = ord('a')
  	for i in xrange(test):
  		s = stdin.readline().rstrip()
  		t = ''
  		
  		for ss in s:
  			if ss == ' ':
  				t += ' '
  			else:
  				t += mapping[ord(ss) - d]
  		print 'Case #%d: %s' % (i + 1, t)
  	
  if __name__ == '__main__':
  	program()
",64
"def get_number_of_test_case():
      return int(raw_input().strip())
  
  def solve_case(t):
      NO, I = [int(test) for test in raw_input().strip().split()]
      
      matrix = [[int(test) for test in raw_input().strip().split()] for cy in range(NO)]
  
      sasLIST = list()
      for и in range(NO):
          for ijk in range(I):
              sasLIST.append([matrix[и][ijk], и, ijk,])
      sasLIST.sort(cmp = lambda test, cy: test[0] - cy[0])
  
      upmble = 'YES'
      for spec in sasLIST:
          if matrix[spec[1]][spec[2]] == 0:
              continue
  
          link, loc = spec[1], spec[2]
  
          canlogcheck = True
          for и in range(NO):
              canlogcheck &= matrix[и][loc] <= spec[0]
          if canlogcheck:
              for и in range(NO):
                  matrix[и][loc] = 0
              continue
  
          canlogcheck = True
          for ijk in range(I):
              canlogcheck &= matrix[link][ijk] <= spec[0]
          if canlogcheck:
              for ijk in range(I):
                  matrix[link][ijk] = 0
          else:
              upmble = 'NO'
              break
      
      print 'Case #%d: %s' % (t, upmble,)
  
  
  TM = get_number_of_test_case()
  t = 1
  while t <= TM:
      solve_case(t)
      t += 1
  
",65
"def count_between(all, account):
  	number = 0
  	for entry in range(all, account + 1):
  		 rotimate = len(str(entry)) - 1
  		watchallists = [entry,]
  		rotate1sum = 0
  		item·fat = len(str(item))
  		while rotate1sum <  rotimate:
  			rpylist = str(entry)
  			rpylist = rpylist[rotate1sum + 1:] + rpylist[:rotate1sum + 1]
  			r_item_base = len(rpylist)
  			rpylist = int(rpylist)
  			if rpylist not in watchallists and rpylist > entry and rpylist <= account and rpylist >= all and item·fat == r_item_base:
  				watchallists.append(rpylist)
  				number +=1
  			rotate1sum += 1
  	return number
  
  pre_timputed = [0, 36, 801, 12060, 161982, 2023578, 299997,]
  
  total = int(raw_input().strip())
  T_count = 1
  while T_count <= total:
  	all, account = [int(exp) for exp in raw_input().strip().split()]
  	print 'Case #%d: %d' % (T_count, count_between(all, account),)
  	T_count += 1
  
",65
"def solve_case(f):
      mentioned_rows = int(raw_input().strip())
      i = 1
      while i <= 4:
          reader = raw_input()
          if i == mentioned_rows:
              primaryLSet = set(reader.strip().split())
          i += 1
      mentioned_rows = int(raw_input().strip())
      i = 1
      while i <= 4:
          reader = raw_input()
          if i == mentioned_rows:
               second_row = set(reader.strip().split())
          i += 1
      ans_set = primaryLSet &  second_row
      if len(ans_set) == 1:
          print 'Case #%d: %s' % (f, ans_set.pop(),)
      elif len(ans_set) > 1:
          print 'Case #%d: Bad magician!' % (f,)
      else:
          print 'Case #%d: Volunteer cheated!' % (f,)
  
  def main():
      f = int(raw_input().strip())
      for i in range(1, f + 1):
          solve_case(i)
  
  if __name__ == '__main__':
      main()
",65
"def solve_case(tu):
      n = int(raw_input().strip())
      ataoki = sorted([float(fn) for fn in raw_input().strip().split()])
      data = sorted([float(fn) for fn in raw_input().strip().split()])
  
  
      i, f = 0, 0
      while f < n:
          if data[f] > ataoki[i]:
              i += 1
          f += 1
      optimalaccounter = n - i
  
      deceited_result = 0
      while n > 0:
          if ataoki[0] < data[0]:
              data.pop()
          else:
              deceited_result += 1
              data = data[1:]
          ataoki = ataoki[1:]
          n -= 1
      
  
  
  
      print 'Case #%d: %d %d' % (tu, deceited_result, optimalaccounter,)
  
  def main():
      tu = int(raw_input().strip())
      for i in range(1, tu + 1):
          solve_case(i)
  
  if __name__ == '__main__':
      main()
",65
"def solve_case(b):
      c, f, x = [float(nat) for nat in raw_input().strip().split()]
      current_time_usage = x / 2.0
  
      n = 1
      build_time_clock = c / (2.0 + float((n - 1) * f))
      attemp_timefmem = (x / (2.0 + float(n * f))) + build_time_clock
  
      while attemp_timefmem < current_time_usage:
          current_time_usage = attemp_timefmem
  
          n += 1
          build_time_clock += c / (2.0 + float((n - 1) * f))
          attemp_timefmem = (x / (2.0 + float(n * f))) + build_time_clock
  
      print 'Case #%d: %.7f' % (b, current_time_usage,)
  
  def main():
      b = int(raw_input().strip())
      for info in range(1, b + 1):
          solve_case(info)
  
  if __name__ == '__main__':
      main()
",65
"def get_number_of_test_case():
      return int(raw_input().strip())
  
  def solve_case(t):
      files = [list(raw_input().strip()) for i in range(4)]
      raw_input()
  
      i = 0
      obj = 0
  
      p_list = list()
      while i < 4:
          obj = 0
          s = ''
          while obj < 4:
              s += files[i][obj]
              obj += 1
          p_list.append(s.replace('T', 'X'))
          p_list.append(s.replace('T', 'O'))
          i += 1
  
      obj = 0
      while obj < 4:
          i = 0
          s = ''
          while i < 4:
              s += files[i][obj]
              i += 1
          p_list.append(s.replace('T', 'X'))
          p_list.append(s.replace('T', 'O'))
          obj += 1
      
      s = files[0][0] + files[1][1] + files[2][2] + files[3][3]
      p_list.append(s.replace('T', 'X'))
      p_list.append(s.replace('T', 'O'))
  
      s = files[0][3] + files[1][2] + files[2][1] + files[3][0]
      p_list.append(s.replace('T', 'X'))
      p_list.append(s.replace('T', 'O'))
  
      has2size = False
      outcome = ''
      for proc in p_list:
          has2size |= '.' in proc
          if proc == 'XXXX':
              outcome = 'X won'
              break
          elif proc == 'OOOO':
              outcome = 'O won'
              break
      if not outcome:
          if has2size:
              outcome = 'Game has not completed'
          else:
              outcome = 'Draw'
      
      print 'Case #%d: %s' % (t, outcome,)
  
  total = get_number_of_test_case()
  t = 1
  while t <= total:
      solve_case(t)
      t += 1
  
",65
"class Sweeper(object):
      def __init__(self, r, c, m):
          self.matrix = [['.' for j in range(0, c)] for i in range(0, r)]
          self.matrix[0][0] = 'c'
  
          self.r = r
          self.c = c
          self.m = m
          self.currentlyc = r
          self.current_c = c
          self.currentlyrb = m
  
      def fill_row(self):
          if self.currentlyc >= 3 and self.currentlyrb >= self.current_c:
              for i in range(0, self.current_c):
                  self.matrix[self.currentlyc - 1][i] = '*'
              self.currentlyc -= 1
              self.currentlyrb -= self.current_c
              return True
          return False
  
      def fill_col(self):
          if self.current_c >= 3 and self.currentlyrb >= self.currentlyc:
              for i in range(0, self.currentlyc):
                  self.matrix[i][self.current_c - 1] = '*'
              self.current_c -= 1
              self.currentlyrb -= self.currentlyc
              return True
          return False
  
      def fill_partial(self):
          if self.currentlyc >= 3:
              fill_num = min(self.currentlyrb, self.current_c - 2)
              for i in range(0, fill_num):
                  self.matrix[self.currentlyc - 1][self.current_c - 1 - i] = '*'
              self.currentlyrb -= fill_num
              if fill_num > 0:
                  self.currentlyc -= 1
          if self.current_c >= 3:
              fill_num = min(self.currentlyrb, self.currentlyc - 2)
              for i in range(0, fill_num):
                  self.matrix[self.currentlyc - 1 - i][self.current_c - 1] = '*'
              self.currentlyrb -= fill_num
              if fill_num > 0:
                  self.current_c -= 1
          if self.currentlyrb > 0:
              return False
          else:
              return True
  
      def fill_special_one(self):
          if self.currentlyc * self.current_c == self.currentlyrb + 1:
              for i in range(0, self.currentlyc):
                  for j in range(0, self.current_c):
                      self.matrix[i][j] = '*'
              self.matrix[0][0] = 'c'
              self.currentlyc = 0
              self.current_c = 0
              self.currentlyrb = 0
              return True
          return False
  
      def fill_special_col(self):
          if self.current_c == 1 and self.currentlyc > self.currentlyrb:
              for i in range(0, self.currentlyrb):
                  self.matrix[self.currentlyc - 1 - i][0] = '*'
              self.matrix[0][0] = 'c'
              self.currentlyrb = 0
              self.currentlyc = 0
              self.current_c = 0
              return True
          return False
  
      def fill_special_row(self):
          if self.currentlyc == 1 and self.current_c > self.currentlyrb:
              for i in range(0, self.currentlyrb):
                  self.matrix[0][self.current_c - 1 - i] = '*'
              self.matrix[0][0] = 'c'
              self.currentlyrb = 0
              self.currentlyc = 0
              self.current_c = 0
              return True
          return False
  
  def print_matrix(matrix):
      for row in matrix:
          s = ''
          for col in row:
              s += col
          print s
  
      
  def solve_case(t):
      r, c, m = [int(num) for num in raw_input().strip().split()]
      sweeper = Sweeper(r, c, m)
      print 'Case #%d:' % (t,)
      if sweeper.fill_special_one() or sweeper.fill_special_col() or sweeper.fill_special_row():
          print_matrix(sweeper.matrix)
          return
      f_result = True
      while sweeper.currentlyrb > 0 and f_result:
          f_result = False
          f_result |= sweeper.fill_row()
          f_result |= sweeper.fill_col()
      if sweeper.currentlyrb > 0:
          sweeper.fill_partial()
      if sweeper.currentlyrb > 0:
          print 'Impossible'
      else:
          print_matrix(sweeper.matrix)
  
  def main():
      t = int(raw_input().strip())
      for i in range(1, t + 1):
          solve_case(i)
  
  if __name__ == '__main__':
      main()
",65
"""""""
  num = int(raw_input('num: ').strip())
  
  c_map = [None for x in range(0, 26)]
  
  while num > 0:
  	googleres = raw_input('googleres: ').strip()
  	original = raw_input('original: ').strip()
  
  
  	ord_a = ord('a')
  	ord_z = ord('z')
  
  	i = 0
  	for c in googleres:
  		ord_c = ord(c)
  		if ord_a <= ord_c and ord_c <= ord_z:
  			c_map[ord_c - ord_a] = ord(original[i]) - ord_c
  		i += 1
  	
  	num -= 1
  
  print c_map
  """"""
  
  """"""
  c_map = [24, 6, 2, 15, 10, -3, 15, 16, -5, 11, -2, -5, -1, -12, -4, 2, 9, 2, -5, 3, -11, -6, -17, -11, -24, -9]
  i = 0
  original_list = list()
  while i < 25:
  	original_list.append(c_map[i] + i)
  	i += 1
  original_list.sort()
  print original_list
  """"""
  
  c2maps = [24, 6, 2, 15, 10, -3, 15, 16, -5, 11, -2, -5, -1, -12, -4, 2, 9, 2, -5, 3, -11, -6, -17, -11, -24, -9]
  
  count = int(raw_input().strip())
  tt_sum = 1
  while tt_sum <= count:
  	ord__ac = ord('a')
  	orig_c = ord('z')
  	coreret = raw_input().strip()
  	result = ''
  	for content in coreret:
  		order_s = ord(content)
  		if ord__ac <= order_s and order_s <= orig_c:
  			result += chr(c2maps[order_s - ord__ac] + order_s)
  		else:
  			result += content
  	print 'Case #%d: %s' % (tt_sum, result,)
  	tt_sum += 1
  
",65
