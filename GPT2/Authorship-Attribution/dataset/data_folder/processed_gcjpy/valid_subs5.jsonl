{"code": " \n  def is_sym( number ):\n  \tnum_str = str( number )\n  \tnum_len = len( num_str )\n  \thalf_len = int( num_len / 2 )\n  \tend = num_str[-half_len:]\n  \trev_end = end[::-1]\n  \tstart = num_str[:half_len]\n  \tequal = rev_end == start \n  \treturn equal\n  \n  f = open( 'palindromes.out' )\n  \n  numbers = [ int(x) for x in f.read().split() ]\n  \n  numCases = input()\n  for case in range( 1, numCases + 1 ):\n  \tmin, max = [ int(x) for x in raw_input().split() ]\n  \tcount = 0\n  \tfor number in numbers:\n  \t\tif min <= number and max >= number:\n  \t\t\tcount += 1\n  \n  \tprint 'Case #' + str( case ) + ': ' + str( count )\n", "substitutes": {"number": ["address", "key", "character", "function", "name"], "num_str": [" num7string", "n_string", " num_string", "num_time", "num1string"], "num_len": ["num64length", "num_start", "num_size", "num__val", "half__val"], "half_len": ["half33den", "quarter_len", "quarter_length", "half_start", "half33length"], "end": ["END", "add", "open", "size", "after"], "rev_end": ["re_len", "re_end", "rev2end", "rev2start", "rev_len"], "start": ["step", "cur", "middle", "open", "new"], "equal": ["neutral", "alpha", "i", "ince", "actual"], "f": ["l", "ff", "fer", "z", "progress"], "numbers": ["cores", "cumbers", "nNumbers", "lNumbers", "colores"], "x": ["ex", "l", "i", "t", "xd"], "numCases": ["numPases", "nbCase", "numRecase", "nbRecase", "nbRecales"], "case": ["section", "Case", "config", "size", "example"], "min": ["step", "size", "Min", "key", "mean"], "max": ["step", "can", "size", "final", "rand"], "count": ["cur", "cond", "note", "size", "key"]}}
{"code": "def build_table():\n  \ttable = []\n  \tfor i in range( 0, 31 ):\n  \t\ttable.append( ( get_max_score( i ), get_max_surprise_score( i ) ) )\n  \n  \treturn table\n  \n  \n  def get_max_score( i ):\n  \treturn max( 0, min( 10, ( i + 2 ) / 3 ) )\n  \n  def get_max_surprise_score( i ):\n  \treturn min( i, max( 0, min( 10, ( i + 4 ) / 3 ) ) )\n  \n  def get_max( x, scores, score_needed, num_surprises ):\n  \tscores = sorted( scores, reverse=True )\n  \tnumPass = 0\n  \ti = 0;\n  \twhile ( i < len(scores) ):\n  \t\tif ( x[scores[i]][0] >= score_needed ):\n  \t\t\tnumPass += 1\n  \t\telse:\n  \t\t\tbreak\n  \t\ti += 1\n  \n  \twhile ( i < len(scores) and num_surprises > 0 ):\n  \t\tif ( x[scores[i]][1] >= score_needed ):\n  \t\t\tnumPass += 1\n  \t\t\tnum_surprises -= 1\n  \t\t\t\n  \t\ti += 1\n  \n  \treturn numPass\n  \n  x = build_table()\n  \n  num_cases = input()\n  \n  for i in range( 1, num_cases + 1 ):\n  \tline = raw_input().split()\n  \tnum_surprises = int(line[1])\n  \tscore_needed = int(line[2])\n  \tscores_raw = line[3:]\n  \n  \tscores = [ int(y) for y in scores_raw ]\n  \n  \tprint 'Case #' + str( i ) + ': ' + str( get_max( x, scores, score_needed, num_surprises ) )\n", "substitutes": {"table": ["key", "model", "chain", "all", "td"], "i": ["l", "key", "ti", "t", "fi"], "x": ["co", "ex", "l", "t", "input"], "scores": ["scheores", "scars", "cores", " scourses", "Scores"], "score_needed": ["core_allowed", "score_ready", "scorePprovided", "core_important", "scoreenallowed"], "num_surprises": ["num_suvey", "num_promacters", "num_merprising", "num_survey", "num_serfaces"], "numPass": ["sumPass", "numberPass", "sumPASS", "sumFail", "nomPASS"], "num_cases": [" num67sections", "numxruns", " num_runs", " numfcases", " num_sections"], "line": ["co", "l", "inline", "feed", "input"], "scores_raw": ["scorer_Raw", "scores_short", "scales_raw", "scores_RAW", "scores_spec"], "y": [" ye", "j", "z", "sys", "yy"]}}
{"code": " \n  \n  def is_palindrome(num):\n      s = str(num)\n      end_idx = len(s)-1\n      for i in range(len(s)//2):\n          if s[i] != s[end_idx-i]:\n              return False\n      return True\n  \n  def is_valid_base(base):\n      return is_palindrome(base) and is_palindrome(base*base)\n  \n  def process_case(lo, hi):\n      cnt = 0\n      base_lo = math.ceil(math.sqrt(lo))\n      base_hi = math.floor(math.sqrt(hi))\n      for base in range(base_lo, base_hi+1):\n          if is_valid_base(base):\n              cnt += 1\n      return cnt\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          lo,hi = line_of_numbers(next(lines))\n          result = process_case(lo, hi)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('C-small-attempt0')\n", "substitutes": {"num": ["text", "missing", "min", "size", "unit"], "s": ["l", "b", "tests", "name", "bis"], "end_idx": ["end_idsxd", "end_Idz", "endxidy", "endxindk", "end_partxs"], "i": ["ai", "l", "ip", "j", "z"], "base": ["based", "l", "alpha", "loc", "b"], "lo": ["small", "l", "LO", "le", "log"], "hi": ["l", "co", "wa", "chi", "cli"], "cnt": ["ncnt", "nrt", " counters", "cno", "ncrt"], "base_lo": ["bas_la", "bas_hi", "bas_loc", "bas_lo", " base_low"], "base_hi": ["root_hy", "base_ha", "base25hi", "root_ha", "base25ha"], "lines": ["log", "l", "elines", "ines", "zip"], "ncases": ["nase", "nsased", "necalls", "ncase", "necases"], "ci": ["ai", "co", "l", "le", "chi"], "result": ["mate", "text", "summary", "new", "obj"], "sub": ["section", "text", "ser", "sec", "desc"], "f_in": ["f_again", "f_In", "fayin", "f_init", " f_ini"], "line": ["l", "inline", "key", "input", "shell"], "basename": ["baseette", " basname", "Baseless", "baseename", "biname"], "infile": ["uppath", " inpath", "insfile", " infilename", "outfilename"], "outfile": [" outfilename", "upformat", "outfolder", "infolder", "outfilename"], "f_out": ["f2Out", " f2again", "f2again", "f_again", " f__in"]}}
{"code": " \n  def threshold(p, maxdiff):\n      minval = max(p - maxdiff, 0)\n      return p + minval + minval\n  \n  def process_case(numdata):\n      N,S,p = numdata[0:3]\n      scores = numdata[3:]\n      thre_normal = threshold(p, 1)\n      thre_surprise = threshold(p, 2)\n      result = 0\n      for tot in scores:\n          if tot >= thre_normal:\n              result += 1\n          elif S > 0 and tot >= thre_surprise:\n              result += 1\n              S -= 1\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          result = process_case(line_of_numbers(next(lines)))\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('B-small-attempt0')\n", "substitutes": {"p": ["l", "pp", "pl", "t", "i"], "maxdiff": ["maxchange", " maxchange", "lastDiff", "Maxdiff", "lastchange"], "minval": [" minVal", "minVal", "minvalue", " minmin", "maxmin"], "numdata": ["sumpos", "tempdata", "sumdat", "npos", "nresults"], "N": ["Q", "P", "Z", "D", "Sc"], "S": ["P", "Q", "section", "Case", "size"], "scores": ["quatters", "cores", " scorer", "Scores", "Scales"], "thre_normal": ["thre_random", "thore_Normal", "thore_common", "thre_general", "thre_norm"], "thre_surprise": ["thre_surce", "thre_purprising", "thre_purprises", "thre_purvey", "thre_Survey"], "result": ["progress", "desc", "i", "scale", "function"], "tot": ["ertoted", "hetots", " tOT", "ttoto", "tots"], "lines": ["log", "l", "text", "es", "ines"], "ncases": ["nase", "nvades", "nvats", "nales", "ncase"], "ci": ["ai", "cell", "dc", "chi", "case"], "s": ["l", "sq", "sec", "services", "sections"], "sub": ["section", "division", "cell", "sq", "sec"], "f_in": ["f_again", "f_id", "fAMout", " f_gin", "fockout"], "line": ["l", "inline", "key", "input", "stroke"], "basename": ["biname", "binename", "offette", "pacername", "Basame"], "infile": ["outzip", "inputzip", " infp", "insfile", " infilename"], "outfile": [" outfilename", "inline", "outfolder", "exline", "againfilename"], "f_out": [" f_err", "f___write", "f_again", "f___outer", "f_outer"]}}
{"code": " \n  '''\n  Limits\n  \n  Small dataset       1 <= T <= 100, 1 <= A <= B <= 1000.\n  First large dataset 1 <= T <= 10000. 1 <= A <= B <= 1014.\n  Second large dataset    1 <= T <= 1000. 1 <= A <= B <= 10100.\n  \n  Sample\n  *** Input \n  3\n  1 4\n  10 120\n  100 1000\n   \t\n  *** Output \n  Case #1: 2\n  Case #2: 0\n  Case #3: 2\n  \n  \n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  pal_sqr_roots = '''1 \n  2 \n  3 \n  11 \n  22 \n  26 \n  101 \n  111 \n  121 \n  202 \n  212 \n  264 \n  307 \n  836 \n  1001 \n  1111 \n  2002 \n  2285 \n  2636 \n  10001 \n  10101 \n  10201 \n  11011 \n  11111 \n  11211 \n  20002 \n  20102 \n  22865 \n  24846 \n  30693 \n  100001 \n  101101 \n  110011 \n  111111 \n  200002 \n  798644 \n  1000001 \n  1001001 \n  1002001 \n  1010101 \n  1011101 \n  1012101 \n  1042151 \n  1100011 \n  1101011 \n  1102011 \n  1109111 \n  1110111 \n  1111111 \n  1270869 \n  2000002 \n  2001002 \n  2012748 \n  2294675 \n  3069307 \n  10000001 \n  10011001 \n  10100101 \n  10111101 \n  11000011 \n  11011011 \n  11100111 \n  11111111 \n  11129361 \n  12028229 \n  12866669 \n  20000002 \n  30001253 \n  64030648 \n  100000001 \n  100010001 \n  100020001 \n  100101001 \n  100111001 \n  100121001 \n  101000101 \n  101010101 \n  101020101 \n  101101101 \n  101111101 \n  110000011 \n  110010011 \n  110020011 \n  110091011 \n  110101011 \n  110111011 \n  111000111 \n  111010111 \n  111091111 \n  111101111 \n  111111111 \n  200000002 \n  200010002 \n  306930693 \n  1000000001 \n  1000110001 \n  1001001001 \n  1001111001 \n  1010000101 \n  1010110101 \n  1011001101 \n  1011111101 \n  1100000011 \n  1100110011 \n  1101001011 \n  1101111011 \n  1110000111 \n  1110110111 \n  1111001111 \n  2000000002 \n  2062386218 \n  2481623254 \n  10000000001 \n  10000100001 \n  10000200001 \n  10001010001 \n  10001110001 \n  10001210001 \n  10010001001 \n  10010101001 \n  10010201001 \n  10011011001 \n  10011111001 \n  10100000101 \n  10100100101 \n  10100200101 \n  10101010101 \n  10101110101 \n  10106064399 \n  10109901101 \n  10110001101 \n  10110101101 \n  10110911101 \n  10111011101 \n  10111111101 \n  10207355549 \n  11000000011 \n  11000100011 \n  11000200011 \n  11000910011 \n  11001010011 \n  11001110011 \n  11010001011 \n  11010101011 \n  11010911011 \n  11011011011 \n  11011111011 \n  11100000111 \n  11100100111 \n  11100910111 \n  11101010111 \n  11101110111 \n  11110001111 \n  11110101111 \n  13579355059 \n  20000000002 \n  20000100002 \n  22865150135 \n  30101273647 \n  30693069307 \n  83163115486 \n  100000000001 \n  100001100001 \n  100010010001 \n  100011110001 \n  100100001001 \n  100101101001 \n  100110011001 \n  100111111001 \n  101000000101 \n  101001100101 \n  101010010101 \n  101011110101 \n  101100001101 \n  101101101101 \n  101110011101 \n  101116809851 \n  110000000011 \n  110001100011 \n  110010010011 \n  110011110011 \n  110100001011 \n  110101101011 \n  110110011011 \n  111000000111 \n  111001100111 \n  111010010111 \n  111100001111 \n  111283619361 \n  112247658961 \n  128817084669 \n  200000000002 \n  1000000000001 \n  1000001000001 \n  1000002000001 \n  1000010100001 \n  1000011100001 \n  1000012100001 \n  1000100010001 \n  1000101010001 \n  1000102010001 \n  1000110110001 \n  1000111110001 \n  1001000001001 \n  1001001001001 \n  1001002001001 \n  1001010101001 \n  1001011101001 \n  1001100011001 \n  1001101011001 \n  1001110111001 \n  1001111111001 \n  1010000000101 \n  1010001000101 \n  1010002000101 \n  1010010100101 \n  1010011100101 \n  1010099010101 \n  1010100010101 \n  1010101010101 \n  1010109110101 \n  1010110110101 \n  1010111110101 \n  1011000001101 \n  1011001001101 \n  1011010101101 \n  1011011101101 \n  1011099011101 \n  1011100011101 \n  1011101011101 \n  1100000000011 \n  1100001000011 \n  1100002000011 \n  1100009100011 \n  1100010100011 \n  1100011100011 \n  1100100010011 \n  1100101010011 \n  1100110110011 \n  1100111110011 \n  1101000001011 \n  1101001001011 \n  1101009101011 \n  1101010101011 \n  1101011101011 \n  1101100011011 \n  1101101011011 \n  1110000000111 \n  1110001000111 \n  1110009100111 \n  1110010100111 \n  1110011100111 \n  1110100010111 \n  1110101010111 \n  1111000001111 \n  1111001001111 \n  1349465117841 \n  2000000000002 \n  2000001000002 \n  2149099165358 \n  2634812417864 \n  3069306930693 \n  6360832925898 \n  10000000000001 \n  10000011000001 \n  10000100100001 \n  10000111100001 \n  10001000010001 \n  10001011010001 \n  10001100110001 \n  10001111110001 \n  10010000001001 \n  10010011001001 \n  10010100101001 \n  10010111101001 \n  10011000011001 \n  10011011011001 \n  10011100111001 \n  10100000000101 \n  10100011000101 \n  10100100100101 \n  10100111100101 \n  10101000010101 \n  10101011010101 \n  10101100110101 \n  10110000001101 \n  10110011001101 \n  10110100101101 \n  10111000011101 \n  11000000000011 \n  11000011000011 \n  11000100100011 \n  11000111100011 \n  11001000010011 \n  11001011010011 \n  11001100110011 \n  11010000001011 \n  11010011001011 \n  11010100101011 \n  11011000011011 \n  11100000000111 \n  11100011000111 \n  11100100100111 \n  11101000010111 \n  11110000001111 \n  20000000000002 \n  30395080190573 \n  69800670077028 \n  98275825201587 \n  100000000000001 \n  100000010000001 \n  100000020000001 \n  100000101000001 \n  100000111000001 \n  100000121000001 \n  100001000100001 \n  100001010100001 \n  100001020100001 \n  100001101100001 \n  100001111100001 \n  100010000010001 \n  100010010010001 \n  100010020010001 \n  100010101010001 \n  100010111010001 \n  100011000110001 \n  100011010110001 \n  100011101110001 \n  100011111110001 \n  100100000001001 \n  100100010001001 \n  100100020001001 \n  100100101001001 \n  100100111001001 \n  100101000101001 \n  100101010101001 \n  100101101101001 \n  100101111101001 \n  100109990011001 \n  100110000011001 \n  100110010011001 \n  100110091011001 \n  100110101011001 \n  100110111011001 \n  100110990111001 \n  100111000111001 \n  100111010111001 \n  101000000000101 \n  101000010000101 \n  101000020000101 \n  101000101000101 \n  101000111000101 \n  101000990100101 \n  101001000100101 \n  101001010100101 \n  101001091100101 \n  101001101100101 \n  101001111100101 \n  101010000010101 \n  101010010010101 \n  101010101010101 \n  101010111010101 \n  101010990110101 \n  101011000110101 \n  101011010110101 \n  101100000001101 \n  101100010001101 \n  101100101001101 \n  101100111001101 \n  101101000101101 \n  101101010101101 \n  101110000011101 \n  101110010011101 \n  110000000000011 \n  110000010000011 \n  110000020000011 \n  110000091000011 \n  110000101000011 \n  110000111000011 \n  110001000100011 \n  110001010100011 \n  110001101100011 \n  110001111100011 \n  110010000010011 \n  110010010010011 \n  110010091010011 \n  110010101010011 \n  110010111010011 \n  110011000110011 \n  110011010110011 \n  110100000001011 \n  110100010001011 \n  110100101001011 \n  110100111001011 \n  110101000101011 \n  110101010101011 \n  110110000011011 \n  110110010011011 \n  111000000000111 \n  111000010000111 \n  111000091000111 \n  111000101000111 \n  111000111000111 \n  111001000100111 \n  111001010100111 \n  111010000010111 \n  111010010010111 \n  111100000001111 \n  111100010001111 \n  129610990752569 \n  200000000000002 \n  200000010000002 \n  210786628549538 \n  314155324482867 \n  1000000000000000 \n  1000000110000000 \n  1000001001000000 \n  1000001111000000 \n  1000010000100000 \n  1000010110100000 \n  1000011001100000 \n  1000011111100000 \n  1000100000010000 \n  1000100110010000 \n  1000101001010000 \n  1000101111010000 \n  1000110000110000 \n  1000110110110000 \n  1000111001110000 \n  1001000000001000 \n  1001000110001000 \n  1001001001001000 \n  1001001111001000 \n  1001010000101000 \n  1001010110101000 \n  1001011001101000 \n  1001100000011000 \n  1001100110011000 \n  1001101001011000 \n  1001110000111000 \n  1010000000000100 \n  1010000110000100 \n  1010001001000100 \n  1010001111000100 \n  1010010000100100 \n  1010010110100100 \n  1010011001100100 \n  1010100000010100 \n  1010100110010100 \n  1010101001010100 \n  1010110000110100 \n  1011000000001100 \n  1011000110001100 \n  1011001001001100 \n  1011010000101100 \n  1011100000011100 \n  1100000000000010 \n  1100000110000010 \n  1100001001000010 \n  1100001111000010 \n  1100010000100010 \n  1100010110100010 \n  1100011001100010 \n  1100100000010010 \n  1100100110010010 \n  1100101001010010 \n  1100110000110010 \n  1101000000001010 \n  1101000110001010 \n  1101001001001010 \n  1101010000101010 \n  1101100000011010 \n  1110000000000110 \n  1110000110000110 \n  1110001001000110 \n  1110010000100110 \n  1110100000010110 \n  1111000000001110 \n  2000000000000000 \n  2201019508986470 \n  2564053868197730 \n  3066446727654240 \n  3107974295870660 \n  3138199296186060'''\n  pal_sqr_roots = map(int, pal_sqr_roots.split())\n  \n  \n  \n  def is_palindrome(n):\n      return str(n)[::-1] == str(n)\n  \n  palindromic_roots = [x for x in pal_sqr_roots if is_palindrome(x)]\n  \n  fair_and_square = [x*x for x in palindromic_roots]\n  \n  \n  def get_num_fair_and_square(a, b):\n      return len([x for x in fair_and_square if a <= x <= b])\n  \n  for caseNo in range(1, int(input())+1):\n      a,b = map(int, input().split())\n      print 'Case #%d:' % caseNo, get_num_fair_and_square(a, b)\n  \n", "substitutes": {"inf": ["zin", "exp", "obj", "cli", "Info"], "pal_sqr_roots": [" sys_sqr_files", " sys_sqr_roots", " sys_sqrt6roots", " sys_sqr6roots", " sys_sqr_name"]}}
{"code": " \n  '''\n  Limits: T in [1,100], S in [0,N], p in [0,10], Ti in [0, 30]\n  At least S of the ti values will be between 2 and 28, inclusive.\n  \n  Small dataset 1 = N = 3.\n  Large dataset 1 = N = 100.\n  \n  Sample Input \n  4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  \n  Output \n  Case #1: 3\n  Case #2: 2\n  Case #3: 1\n  Case #4: 3\n  '''\n  \n  \n  \n  inf = open(sys.argv[1])\n  def input(): return inf.readline().strip()\n  \n  def maxBestDancers(N, S, p, *Ti):\n      cnt = 0\n      for score in Ti:\n          mx = (score + 2) // 3\n          if mx >= p:\n              cnt += 1\n          elif mx >= p-1 > 0 and S>0:\n              S -= 1\n              cnt += 1\n      return cnt\n  \n  for caseNo in range(1, int(input())+1):\n      print 'Case #%d:' % caseNo,\n      lst = map(int, input().split())\n      print maxBestDancers(*lst)\n  \n", "substitutes": {"inf": ["zin", "lo", "magic", "exp", "zz"], "N": ["P", "J", "Q", "z", "Z"], "S": ["P", "Q", "J", "size", "Z"], "p": ["P", "l", "Q", "j", "z"], "cnt": ["cno", " c0", "ucct", "count", "colNT"], "score": ["fee", "nice", "min", "size", "z"], "mx": ["exp", "wm", "py", "ti", "core"], "caseNo": [" caseNO", "CaseNO", " caseNumber", "CaseNum", "trialNo"], "lst": ["llsts", "lST", "elsts", " lsc", " lbl"]}}
{"code": " \n  def generateTable(N):\n      msq = range(1, 4) + [11, 22] + [101, 111, 121, 202, 212]\n      nums = revnums = [1, 2]\n  \n      digsums = [1, 4]\n  \n      for i in xrange(2, N+1):\n          a, b, d = [], [], []\n          p = 10**(i-1)\n          for j in xrange(len(nums)):\n              for k in xrange(3):\n                  n, rn, ds = 10*nums[j] + k, revnums[j] + k*p, digsums[j] + k*k\n                  if ds < 5:\n                      a.append(n)\n                      b.append(rn)\n                      d.append(ds)\n                      msq.append(10*p*n + rn) # even length\n                      if i == N:\n                          continue\n                      for l in xrange(3): # odd length\n                          if 2*ds + l*l < 10:\n                              msq.append(100*p*n + 10*p*l + rn)\n          nums, revnums, digsums = a, b, d\n  \n      msq.sort()\n      return msq\n  \n  def getNum(A, B):\n      return bisect_right(tab2, B) - bisect_right(tab2, A-1)\n  \n  N = 10\n  tab = generateTable(N)\n  tab2 = map(lambda n: n**2, tab)\n  \n  T = int(raw_input())\n  for z in xrange(T):\n      A, B = map(int, raw_input().split())\n      print \"Case #%d: %d\" % (z+1, getNum(A, B))\n", "substitutes": {"N": ["II", "P", "J", "Q", "Z"], "msq": ["Msq", "msqs", "psq", "osqu", " msqu"], "nums": ["cnums", "cumbers", "nummies", "anonumbers", " nummies"], "revnums": ["revrnums", "revnoms", "RevNumes", "RevNums", "Revnumbers"], "digsums": ["dligumes", "drigmas", "dimensums", "digumes", "digmas"], "i": ["P", "ai", "ip", "ji", "chi"], "a": ["ak", "ai", "aa", "ab", "ama"], "b": ["xb", "aa", "ab", "abb", "bl"], "d": ["ld", "deb", "dc", "vd", "D"], "p": ["P", "ip", "per", "pp", "py"], "j": ["bj", "note", "J", "uj", "section"], "k": ["ak", "P", "kk", "pp", "key"], "n": ["obj", "u", "pn", "t", "nan"], "rn": ["nv", "dc", "rf", "kk", "pn"], "ds": ["ld", "dc", "lines", "pn", "df"], "l": ["u", "t", "r", "s", "v"], "A": ["Q", "J", "Ac", "API", "D"], "B": ["P", "Q", "WB", "Ub", "QB"], "tab": ["config", "mm", "cell", "text", "ab"], "tab2": [" tab3", "colB", "tab3", "bb4", "table4"], "T": ["P", "J", "Q", "DT", "TS"], "z": ["step", "ZZ", "Z", "zip", "zz"]}}
{"code": "T = int(raw_input())\n  \n  for z in xrange(1, T+1):\n      a = map(int, raw_input().split())\n      s, p = a[1:3]\n      a = a[3:]\n      A = 0 if p == 0 else 3*p - 2\n      B = 0 if p == 0 else 1 if p == 1 else 3*p-4\n      x = len(filter(lambda x: x >= A, a))\n      y = len(filter(lambda x: x >= B, a)) - x\n      res = x + min(s, y)\n      print \"Case #%d:\" % z, res\n", "substitutes": {"T": ["P", "Q", "TS", "Z", "D"], "z": ["exp", "hz", "j", "Z", "i"], "a": ["ak", "aa", "l", "ai", "wa"], "s": ["l", "es", "sq", "t", "ins"], "p": ["P", "l", "j", "pp", "per"], "A": ["P", "Q", "Ca", "Na", "As"], "B": ["AR", "P", "Q", "J", "WB"], "x": ["l", "ex", "alpha", "t", "i"], "y": ["l", "j", "min", "yy", "i"], "res": ["exp", "vec", "es", "sol", "max"]}}
{"code": " \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  def pal(x):\n      l = list(str(x))\n      l2 = copy.copy(l)\n      l2.reverse()\n      return l == l2\n  \n  for i in range(num):\n      count = 0\n      line = f.readline()\n      a,b = line.split()\n      a = int(a)\n      b = int(b)\n      ma = int(math.sqrt(a))\n      mb = int(math.sqrt(b))+1\n      for j in range(ma,mb+1):\n          q = j*j\n          if q < a or q > b:\n              continue\n          if pal(j) and pal(q):\n              count += 1\n      print 'Case #{}:'.format(i+1), count\n", "substitutes": {"f": ["z", "folder", "t", "u", "feed"], "num": ["mm", "month", "size", "unit", "iter"], "x": ["xb", "ex", "text", "es", "z"], "l": ["le", " L", "z", "pl", "bl"], "l2": ["Lball", "L1", "Ltwo", "b2", "L2"], "i": ["ai", "ip", "ir", "ij", "obj"], "count": ["log", "cond", "comp", "size", "z"], "line": ["LINE", "le", "log", "strip", "cell"], "a": ["ak", "aa", "ai", "wa", "ab"], "b": ["bar", "aa", "ab", "z", "bl"], "ma": ["aa", "mm", "wa", "ama", "mas"], "mb": ["xb", "aa", "mm", "ab", "mt"], "j": ["bj", "J", "mm", "ji", "z"], "q": ["Q", "qu", "mm", "z", "u"]}}
{"code": " \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      res = [int(x) for x in f.readline().split()]\n      nrg, nrsup, score = res[0:3]\n      del res[0:3]\n      nrpass = 0\n      nrsuppass = 0\n      for x in res:\n          if score > 1:\n              if x >= 3*score-2:\n                  nrpass += 1\n              elif x >= 3*score-4:\n                  nrsuppass += 1\n          elif score == 1:\n              if x > 0:\n                  nrpass += 1\n          else:\n              nrpass +=1\n      print 'Case #{}:'.format(i+1), nrpass + min(nrsup, nrsuppass)\n", "substitutes": {"f": ["l", "j", "z", "folder", "rf"], "num": ["size", "unit", "iter", "max", "loc"], "i": ["ex", "l", "ip", "j", "z"], "res": ["progress", "pres", "all", "breaks", "re"], "x": ["ex", "t", "b", "xx", "int"], "nrg": ["cnperse", "ngin", "pnperse", "pnrw", "nzgin"], "nrsup": ["nrssample", "Narsup", " nrsupe", "narsuper", "Nrsuper"], "score": ["sat", "color", "key", "fit", "scale"], "nrpass": ["nlwin", "nlskip", "adrpassword", "nrfail", "nrstep"], "nrsuppass": ["nruppasses", "rsuppress", "nroppasses", "norcompact", "nrcompress"]}}
{"code": " \n  def ss(t, amap, bmap):\n      s = 0\n      for m in amap:\n          if len(m) == 1 and t == m.keys()[0]:\n              s += m[t]\n              for b in bmap:\n                  if t in b:\n                      b[t] -= 1\n                      if b[t] == 0:\n                          b.pop(t)\n              m.clear()\n      return s           \n  \n  \n  def solve(case, in_lines):\n      out = 'Case #%d: '%case\n   \n      rn, cn = [int(x) for x in in_lines[0].split()]\n      mtx = []\n      for i in xrange(rn):\n          mtx.append([int(x) for x in in_lines[i+1].split()])\n      rmap = [{} for x in xrange(rn)]\n      cmap = [{} for x in xrange(cn)]\n      td = {}\n      \n      for i in xrange(rn):\n          for j in range(cn):\n              k = mtx[i][j]\n              if k in rmap[i]:\n                  rmap[i][k] += 1\n              else:\n                  rmap[i][k] = 1\n              if k in cmap[j]:\n                  cmap[j][k] += 1\n              else:\n                  cmap[j][k] = 1\n              if k in td:\n                  td[k] += 1\n              else:\n                  td[k] = 1\n                  \n      while len(td):\n          k = min(td.keys())\n          sb = ss(k, rmap, cmap)\n          sb += ss(k, cmap, rmap)\n          if sb == 0:\n              break;\n          td[k] -= sb\n          if td[k] == 0:\n              td.pop(k)\n  \n      return out + ('YES' if sb else 'NO')\n  \n  \n  def main(raw):\n      lines = raw.split('\n')\n      n = int(lines[0])\n      ln = 1\n      outs = []\n      for case in xrange(1, n+1):\n          buff = []\n          cl = int(lines[ln].split()[0]) + ln + 1\n          while ln < cl and lines[ln]:\n              buff.append(lines[ln])\n              ln += 1\n          s = solve(case, buff)\n          print s\n          outs.append(s)\n      return '\n'.join(outs)\n      pass\n  \n  if __name__ == '__main__':\n      test_input = \"\"\"4\n  4 3\n  2 5 2\n  1 1 1\n  2 4 2\n  2 3 2\n  3 3\n  2 1 2\n  1 1 1\n  2 1 2\n  5 5\n  2 2 2 2 2\n  2 1 1 1 2\n  2 1 2 1 2\n  2 1 1 1 2\n  2 2 2 2 2\n  1 3\n  1 2 1\"\"\"\n      force_no_file = False\n      in_file_name = '' if force_no_file else 'B-large.in'\n      base_path = 'G:/workspace/py/codejam2013/RQ/'\n      if in_file_name:\n          with open(base_path + in_file_name) as f:\n              raw = f.read()\n      else:\n          raw = test_input\n      out = main(raw)\n      if in_file_name:\n          with open(base_path + in_file_name + '.out', 'w') as f:\n              f.write(out)\n      pass\n", "substitutes": {"t": ["l", "z", "target", "u", "ti"], "amap": [" amaps", "amapper", "ramaps", "pmaps", "acapper"], "bmap": ["bcap", " bcap", "wmap", "rblock", " btable"], "s": ["l", "shell", "stats", "breaks", "sh"], "m": ["l", "sm", "mm", "mt", "z"], "b": ["xb", "l", "ab", "z", "bl"], "case": ["exc", "l", "address", "sea", "feed"], "in_lines": ["out_planes", " inxcases", "in_line", "in_planes", " in_cells"], "out": ["IN", "summary", "echo", "Out", "external"], "rn": ["rb", "abc", "dr", "ne", "rar"], "cn": ["cre", "ren", "eni", "cin", "core"], "x": ["rex", "xb", "ex", "l", "z"], "mtx": ["MTxs", "rtax", "mtz", "MTx", "MTX"], "i": ["ai", "l", "ip", "ir", "ji"], "rmap": ["rmaps", "cmaps", "cshare", "rblock", "mmaps"], "cmap": ["lcblock", "lcmap", "rcopen", "cblock", "rconfig"], "td": ["ld", "tc", "chart", "tk", "sh"], "j": ["bj", "J", "uj", "l", "cell"], "k": ["l", "key", "right", "kick", "ko"], "sb": ["abb", "amp", "rb", "shell", "inf"], "raw": ["small", "strip", "RAW", "text", "new"], "lines": ["l", "inline", "tests", "breaks", "liners"], "n": ["l", "un", "z", "size", "pn"], "ln": ["l", "ld", "loc", "lt", "wl"], "outs": ["css", "jobs", "tests", "alls", "breaks"], "buff": ["config", "bash", "ff", "text", "uff"], "cl": ["rl", "lo", "ld", "le", "cel"]}}
{"code": " \n  def solve(icase, case_input):\n      case_output = 'Case #%i: '%icase\n      \n      result = 0\n      raw = [int(x) for x in case_input[0].split()]\n      ts = raw[3:]\n      ct = raw[1]\n      n = raw[2]\n      cc = 0\n      for i in ts:\n          if i > 3*n-3:\n              result += 1\n          elif i > max(3*n-5, 0):\n              cc += 1\n      result += min(cc, ct)\n  \n      case_output += '%d'%result\n      \n      return case_output\n  \n  \n  def main():\n      global use_test_data\n      global test_data\n      global input_file\n      global output_file\n      \n      if use_test_data:\n          data = [x.strip() for x in test_data.split('\n')]\n      else:\n          data = [x.strip() for x in input_file.readlines()]\n      \n      T = int(data[0])\n      iLine = 1\n      caseLineNum = 1\n      for icase in range(1, T + 1):\n          input = []\n          for i in range(caseLineNum):\n              input.append(data[iLine])\n              iLine += 1\n          rslt = solve(icase, input)\n          print rslt\n          if not use_test_data:\n              print >> output_file, rslt\n      \n      if not use_test_data:\n          input_file.close()\n          output_file.close()\n      \n      \n  if __name__ == '__main__':\n      test_data = \"\"\"4\n  3 1 5 15 13 11\n  3 0 8 23 22 21\n  2 1 1 8 0\n  6 2 8 29 20 8 18 18 21\n  \"\"\"\n      use_test_data = False\n      \n      test_file = 'B-small-attempt0.in'\n      if not use_test_data and '' != test_file:\n          input_file = open(test_file)\n          output_file = open(test_file + '.out', 'w')\n      \n      main()\n", "substitutes": {"icase": ["iccace", "ikases", "ikape", "iacace", "ticased"], "case_input": ["case_data", "Case_output", " case_file", "Case_source", "case_source"], "case_output": [" case_Output", " case_write", "case2output", " case_file", "case2Output"], "result": ["character", "function", "runner", "cont", "grade"], "raw": ["RAW", "exp", "shape", "new", "null"], "x": ["ex", "l", "t", "xx", "int"], "ts": ["ths", "tc", "TS", "features", "lines"], "ct": ["config", "tc", "dc", "case", "t"], "n": ["l", "adj", "j", "min", "z"], "cc": ["co", "tc", "dc", "kk", "case"], "i": ["ai", "l", "ip", "j", "iac"], "data": ["step", "config", "image", "reader", "text"], "T": ["P", "Q", "J", "DT", "TS"], "iLine": ["siBlock", "iiDay", "iiCo", "siCo", "siLine"], "caseLineNum": ["caseLineLen", "caseEntryNum", "caseRowLen", "choiceLineLen", "caseLineNo"], "input": ["step", "config", "image", "shape", "text"], "rslt": ["Rsl", "rslet", "rotslett", "rslett", "Rslett"], "test_data": ["test2data", "outputingfile", "case_data", " test_string", "testacdata"], "use_test_data": ["use_case_Data", "use_case_function", "use_testerData", "use_test2dat", "use_testing_Data"], "test_file": ["testingline", " testingfile", " testingdata", "test_type", " testpfolder"], "input_file": ["output_source", "input_table", "input2buffer", "inputPoolfile", "output_data"], "output_file": ["case_files", "outputingfile", "outputinglog", "case_data", " output_log"]}}
{"code": " \n  T = input()\n  \n  for n in range(1, T+1):\n  \n      A, B = raw_input().split()\n      A, B = int(A), int(B)\n  \n      j = 0\n      for i in range(A, B+1):\n          s = str(i)\n          m = int(i**.5)\n          if s[-1] in [\"1\", \"4\", \"5\", \"6\", \"9\"] and \\\n                  (s == \"\".join(reversed(s))) and \\\n                  m**2 == i:\n              s = str(m)\n              if s == \"\".join(reversed(s)):\n                  j += 1\n  \n  \n      print \"Case #%d: %d\" % (n, j)\n", "substitutes": {"T": ["P", "J", "Q", "TS", "Z"], "n": ["l", "adj", "z", "t", "u"], "A": ["Q", "Ac", "API", "D", "Ma"], "B": ["P", "J", "Q", "WB", "QB"], "j": ["P", "J", "l", "uj", "adj"], "i": ["ai", "l", "ip", "min", "z"], "s": ["l", "t", "b", "sa", "tests"], "m": ["l", "sm", "mm", "min", "z"]}}
{"code": " \n  T=0 #no. of Test cases\n  for line in fileinput.input():\n      if fileinput.isfirstline():\n          T=int(line)\n          print \"no. of test cases:\", T\n          continue\n      \n      nums=[int(x) for x in line.split()]\n      N=nums[0] #no. of googlers\n      S=nums[1] #no. of surprising triplets\n      p=nums[2] #max value\n      \n      del nums[:3]\n      count=0\n      for num in nums:\n          quo=num//3\n          rem=num%3\n          if quo >= p:\n              count += 1\n              continue\n          elif quo+1 == p and rem > 0:\n              count += 1\n              continue\n          elif quo+1 ==p and rem == 0 and quo > 0 and S > 0:\n              count += 1\n              S -= 1\n              continue\n          elif quo+2 >= p and rem == 2 and S > 0:\n              count += 1\n              S -= 1\n      \n      print \"Case #%(k)i: %(count)i\" % {\"k\":fileinput.lineno()-1,\"count\":count}\n", "substitutes": {"T": ["LINE", "P", "Q", "DT", "TS"], "line": ["LINE", "log", "section", "l", "text"], "nums": ["rnumbers", "rnults", " nrams", "cumbers", "crams"], "x": ["ex", "l", "section", "text", "z"], "N": ["P", "Q", "J", "Z", "D"], "S": ["P", "Q", "Case", "Z", "D"], "p": ["P", "l", "ip", "j", "pm"], "count": ["cond", "key", "i", "process", "carry"], "num": ["opt", "text", "un", "null", "unit"], "quo": ["quoo", "QuO", "qot", "squo", "qoa"], "rem": ["ex", "progress", "ref", "rest", "right"]}}
{"code": " \n  fin = open('C-small-attempt0.in', 'r')\n  fout = open('ass3.out', 'w')\n  \n  T = int(fin.readline())\n  \n  def perfsq(n):\n      sq = int(math.sqrt(n))\n      if n == sq * sq:\n          return sq\n      return 0\n  \n  def palindrome(n):\n      s = str(n)\n      return (s == s[::-1])\n  \n  def getpal(n):\n      if n == 1:\n          for i in range(10):\n              yield i\n      else:\n          n2 = n / 2\n          for x in xrange(10 ** (n2 - 1), 10 ** n2):\n              s = str(x)\n              if n % 2:\n                  for i in range(10):\n                      ns = s + str(i) + s[::-1]\n                      yield int(ns)\n              else:\n                  ns = s + s[::-1]\n                  yield int(ns)\n  \n  for i in range(T):\n      A, B = map(int, fin.readline().split())\n  \n      ret = 0\n      for j in range(len(str(A)), len(str(B)) + 1):\n          for x in getpal(j):\n              if x < A:\n                  continue\n              if x > B:\n                  break\n              sq = perfsq(x)\n              if sq and palindrome(sq):\n                  ret += 1\n      fout.write('Case #%i: %i\n' % (i + 1, ret))\n", "substitutes": {"fin": ["lo", "fun", "cook", "fer", "final"], "fout": ["FOut", "Finner", "fmwrite", "faout", " fint"], "T": ["P", "J", "Q", "TS", "Z"], "n": ["l", "t", "b", "ot", "ne"], "sq": ["Q", "seq", "inf", "qi", "qq"], "s": ["l", "t", "b", "stats", "sh"], "i": ["l", "ti", "t", "b", "inf"], "n2": ["n82", "c4", "N2", "gTwo", "nb3"], "x": ["ex", "l", "pl", "rax", "t"], "ns": ["es", "lines", "z", "ins", "nos"], "A": ["AR", "P", "Q", "Ac", "Case"], "B": ["P", "Q", "J", "WB", "QB"], "ret": ["best", "Ret", "reg", "det", "fun"], "j": ["bj", "J", "ai", "l", "ip"]}}
{"code": "input_file = 'B-small-attempt1.in'\n  output_file = 'b.out'\n  \n  \n  def solvecase(inp):\n  \tdata = [int(n) for n in inp.split()]\n  \tN, S, p = data[0:3]\n  \tif p == 0:\n  \t\treturn N\n  \tt = data[3:]\n  \tret = 0\n  \tfor br in t:\n  \t\td, r = br / 3, br % 3\n  \t\tif br == 0 or p - d > 2:\n  \t\t\tcontinue\n  \t\tif (d >= p) or (r and (d + 1) >= p):\n  \t\t\tret += 1\n  \t\telif S and (d + max(r, 1)) >= p:\n  \t\t\tret += 1\n  \t\t\tS -= 1\n  \treturn ret\n  \n  lines = open(input_file, 'r').readlines()\n  out = open(output_file, 'w')\n  \n  for i, l in enumerate(lines[1:]):\n  \tsout = 'Case #%i: %i' % (i + 1, solvecase(l))\n  \tprint sout\n  \tout.write(sout + '\n')\n  \n  out.close()\n", "substitutes": {"input_file": ["inputsfile", "inputsresource", "input_resource", "inputingfiles", "inputodefile"], "output_file": ["outputingbase", "outputChanemail", "outputChanfolder", "outputingfile", "outputingfolder"], "inp": ["inping", " infp", "innfile", " INfile", "Infile"], "data": ["config", "text", "alpha", "case", "valid"], "n": ["j", "z", "u", "b", "s"], "N": ["P", "Q", "J", "Col", "Z"], "S": ["rl", "P", "Q", "J", "z"], "p": ["P", "j", "z", "pp", "case"], "t": ["j", "z", "art", "u", "ti"], "ret": ["fun", "ref", "fit", "b", "all"], "br": ["step", "P", " Br", "j", "min"], "d": ["P", "ld", "j", "dc", "z"], "r": ["rl", "P", "ir", "j", "min"], "lines": ["LINE", "log", "lo", "elines", " Lines"], "out": ["log", "image", "engine", "exp", " output"], "i": ["ai", "ip", "j", "z", "chi"], "l": ["rl", "le", "j", "z", "pl"], "sout": ["sgOut", " supdate", "sprintf", "soutput", "sgouts"]}}
{"code": " a = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004, 100000020000001]\n  A = a[:10]\n  def subdfs(pre, mid, d, t, n):\n      if d == t:\n          k = long(''.join([pre, mid, pre[::-1]]))\n          k = k * k\n          if k > n:\n              return [1, 0]\n          sqk = str(k)\n          if sqk == sqk[::-1]:\n              A.append(k)\n              return [0, 1]\n          else:\n              return [0, 0]\n      res = subdfs(pre + '0', mid, d + 1, t, n)\n      if res[0]: return res\n      if not res[1]: return res\n      res2 = subdfs(pre + '1', mid, d + 1, t, n)\n      if res2[0]: return [1, res[1] + res2[1]]\n      return [0, res[1] + res2[1]]\n  \n  def dfs(d, n):\n      subdfs('1', '', 0, d, n)\n      subdfs('2' + '0' * d, '', d, d, n)\n      subdfs('1', '0', 0, d, n)\n      subdfs('1', '1', 0, d, n)\n      subdfs('1', '2', 0, d, n)\n      subdfs('2' + '0' * d, '0', d, d, n)\n      subdfs('2' + '0' * d, '1', d, d, n)\n  \n  def solve(pre):\n      read_ints = lambda: map(int, raw_input().split())\n      l, r = read_ints()\n      cl = bisect_left(A, l)\n      cr = bisect_right(A, r)\n      cl_ = cr_ = 0\n      for i in xrange(40):\n          if a[i] < l: cl_ += 1\n      for i in xrange(40):\n          if a[i] <= r: cr_ += 1\n      print pre, cr - cl\n  \n  for k in xrange(1, 48):\n      dfs(k, 10 ** 100 + 1)\n  A.sort()\n  N = int(raw_input())\n  for i in xrange(1, N + 1):\n      solve(\"Case #%d:\" % i)\n", "substitutes": {"a": ["aa", "ai", "j", "ab", "z"], "A": ["P", "aa", "ai", "Q", "API"], "pre": ["j", "min", "per", "pl", "py"], "mid": ["mm", "middle", "dc", "min", "key"], "d": ["ld", "D", "xd", "b", "de"], "t": ["tc", "j", "mt", "z", "u"], "n": ["b", "ot", "ne", "ln", "name"], "k": ["ak", "j", "kk", "pp", "key"], "sqk": ["isfq", "qks", "iqk", "qkk", "dqK"], "res": ["rest", "right", "pres", "all", "re"], "res2": ["rem5", "ares62", "ares2", "rys4", "results72"]}}
{"code": "T = int(raw_input())\n  for t in xrange(T):\n      line = map(int, raw_input().split())\n      N, S, p = line[0:3]\n      a = line[3:]\n      cnt = 0\n      a.sort(reverse=True)\n      for x in a:\n          if (x + 2) / 3 >= p:\n              cnt += 1\n          elif S > 0 and 2 <= x <= 28 and (x + 4) / 3 >= p:\n              cnt += 1\n              S -= 1\n          else:\n              break\n      print \"Case #%d: %d\" % (t + 1, cnt)\n", "substitutes": {"T": ["P", "Q", "TS", "z", "Z"], "t": ["l", "section", "text", "j", "z"], "line": ["LINE", "log", "l", "section", "strip"], "N": ["Q", "P", "Z", "D", "H"], "S": ["P", "Q", "State", "J", "Na"], "p": ["P", "l", "j", "z", "pp"], "a": ["aa", "ai", "l", "wa", "section"], "cnt": ["ncnt", "lcnc", "pnd", "pct", "cgt"], "x": ["step", "xb", "ex", "l", "P"]}}
{"code": "def isPalindrome(number):\n      strNum = str(number)\n      for i in range(len(strNum)/2 + 1):\n          if strNum[i] != strNum[-1*(i+1)]:\n              return False\n      return True\n  \n  '''for i in range(40):\n      if isPalindrome(i) and isPalindrome(i*i):\n          print i*i\n  '''\n  \n  \n  filename = \"C-small-attempt0.in\"\n  outputname = filename + \"out.txt\"\n  \n  inFile = open(filename, 'r')\n  outFile = open(outputname, 'w')\n  \n  \n  fairAndSquareNums = [1,4,9,121,484]\n  \n  numTests = int(inFile.readline())\n  \n  for i in range(numTests):\n      line = inFile.readline().split()\n      count = 0\n      for j in range(int(line[0]), int(line[1])+1):\n          if j in fairAndSquareNums:\n              count += 1\n      outFile.write(\"Case #\" + str(i+1) + \": \" + str(count) + '\n')\n      print \"Case #\" + str(i+1) + \": \" + str(count)\n  \n  inFile.close()\n  outFile.close()\n", "substitutes": {"number": ["text", "size", "byte", "anything", "unit"], "strNum": ["StrNum", "striVal", "strNumber", " strTon", "striNum"], "i": ["l", "key", "ti", "t", "b"], "filename": ["maximum", "l", "summary", "ppa", "knife"], "outputname": ["outputstring", "writefile", "Outputname", "Outputstring", " outputfile"], "inFile": ["ninLine", " inStream", "outLoop", "inLoop", "insfile"], "outFile": ["OUTFolder", "newStream", "outputFolder", "OutFile", "outputFile"], "fairAndSquareNums": ["fairAndsquarenumeric", "fairAndsquareNumeric", "fairAndsquareNum", "fairAndSquareNumbers", "fairAndSquarenumbers"], "numTests": ["numTenests", "numNcases", "numtesters", "numbertcases", "numbertests"], "line": ["LINE", "log", "l", "section", "strip"], "count": ["key", "connection", "all", "int", "name"], "j": ["note", "J", "l", "ji", "obj"]}}
{"code": "inputFile = open(\"B-small-attempt0 (3).in\", 'r')\n  outputFile = open(\"dancingOutSmall.txt\", 'w')\n  numTests = int(inputFile.readline())\n  \n  def countDancers(n,s,p,totals):\n      guaranteed = 0\n      needSurprise = 0\n      if p == 1:\n          for total in totals:\n              if total != 0:\n                  guaranteed += 1\n          return guaranteed\n      for total in totals:\n          if total >= p*3 - 2:\n              guaranteed += 1\n          elif total >= p*3 - 4:\n              needSurprise += 1\n      if needSurprise > s:\n          return guaranteed + s\n      else:\n          return guaranteed + needSurprise\n  \n  for i in range(numTests):\n      line = inputFile.readline().split()\n      n = int(line[0])\n      s = int(line[1])\n      p = int(line[2])\n      totals = []\n      for j in range(n):\n          totals += [int(line[3+j])]\n      outputFile.write('Case #' + str(i+1) + ': ' + str(countDancers(n,s,p,totals)) + '\n')\n  \n  outputFile.close()\n", "substitutes": {"inputFile": ["sourceDirectory", "outputFiles", "sourceFile", "inputFiles", "inputLine"], "outputFile": ["outputFiles", "inputFiles", "inputFilename", "outputDirectory", " outputfile"], "numTests": [" numTencases", " numTenasks", "numTenests", "numEntester", "numTestasks"], "n": ["P", "l", "min", "z", "size"], "s": ["l", "t", "b", "sa", "stats"], "p": ["l", "pp", "t", "b", "pr"], "totals": ["totall", "totiotal", "totsals", "Tottals", "tfatale"], "guaranteed": ["Guantree", "guantedees", "guantedee", " guarentee", "guanteal"], "needSurprise": ["needSurception", " needSurprises", "needsurvey", "needAsprises", "needCurception"], "total": ["otal", "t", "scale", "all", "completely"], "i": ["ai", "ip", "z", "chi", "page"], "line": ["l", "inline", "key", "loc", "b"], "j": ["note", "J", "l", "adj", "section"]}}
{"code": " \n  n_cases = input()\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  def is_palindrome(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  for case in xrange(1, n_cases + 1):\n      a, b = to_ints(raw_input())\n  \n      nums = range(int(b ** .5) + 2)\n      palins = filter(is_palindrome, nums)\n      squares = [x**2 for x in palins]\n      palin_squares = filter(is_palindrome, squares)\n      range_squares = [x for x in palin_squares if a <= x <= b]\n  \n      print \"Case #%d: %s\" % (case, len(range_squares))\n", "substitutes": {"n_cases": ["n__tests", " nxtimes", "nxtests", "n__cases", " n_times"], "s": ["l", "i", "t", "input", "tests"], "n": ["l", "j", "z", "t", "u"], "case": ["section", "Case", "address", "config", "ab"], "a": ["ai", "aa", "wa", "ab", "alpha"], "b": ["bar", "xb", "l", "aa", "j"], "nums": ["snums", "nonumbers", "snoms", "enoms", " nules"], "palins": ["opalouts", "pin", "aliins", "aliin", " palouts"], "squares": ["scars", "squared", "quars", "sqakes", "Squars"], "x": ["co", "ex", "l", "alpha", "rax"], "palin_squares": ["palin_squapes", "palin_shares", "palin_quapes", "palin_share", "palin_Squaring"], "range_squares": ["range_Squared", "range_square", "range_quare", "range_Squeries", "range_varieries"]}}
{"code": "n_cases = input()\n  \n  for case in xrange(1, n_cases + 1):\n      ins = map(int, raw_input().strip().split())\n      n = ins[0]\n      s = ins[1]\n      p = ins[2]\n      t = ins[3:]\n  \n      out = 0\n      for x in t:\n          if (x + 2) / 3 >= p:\n              out += 1\n          elif s and x > p and p - ((x - p) / 2) <= 2:\n              out += 1\n              s -= 1\n              \n      print \"Case #%d: %s\" % (case, out)\n", "substitutes": {"n_cases": ["nxtests", "nalltests", " n_times", "n_rows", "n_points"], "case": ["exc", "section", "Case", "config", "shape"], "ins": ["includes", "ex", "IN", "ones", "features"], "n": ["l", "j", "z", "i", "r"], "s": ["opt", "l", "ex", "es", "sq"], "p": ["P", "l", "j", "z", "per"], "t": ["step", "l", "j", "z", "u"], "out": ["co", "ex", "key", "path", "b"], "x": ["step", "ex", "l", "j", "z"]}}
{"code": "'''\n  Created on 13 Apr 2013\n  \n  @author: mengda\n  '''\n  \n  ls = []\n  \n  def isP(num):\n      num = str(int(num))\n      for i in range(len(num) / 2):\n          if num[i] <> num[-1 - i]:\n              return False\n      return True\n  \n  def createP(root, half_digits):\n      root = str(root)\n      for i in range(half_digits):\n          ls[i] = root[i]\n          ls[-1 - i] = root[i]\n      return int(''.join(ls))\n  \n  def process(A, B):\n      rlt = 0\n      a = int(math.ceil(math.sqrt(A)))\n      b = int(math.floor(math.sqrt(B)))\n      str_a = str(a)\n      half_digits = int(math.ceil(len(str_a) / 2.0))\n      root = int(str_a[:half_digits])\n      next_root = 10 ** half_digits\n      digits = len(str_a)\n      for _ in range(digits - len(ls)):\n          ls.append('')\n      while True:\n          if root == next_root:\n              if digits % 2 == 0:\n                  next_root *= 10\n                  half_digits += 1\n              else:\n                  root /= 10\n              digits += 1\n              ls.append('')\n          p = createP(root, half_digits)\n          print p,\n          if p > b:\n              print 'too large'\n              break\n          if isP(math.pow(p, 2)):\n              print 'right one!'\n              rlt += 1\n          else:\n              print \n          root += 1\n      return rlt\n  \n  def process1(A, B):\n      rlt = 0\n      a = int(math.ceil(math.sqrt(A)))\n      b = int(math.floor(math.sqrt(B)))\n      for i in range(a, b + 1):\n          if not isP(i):\n              continue\n          power = math.pow(i, 2)\n          if isP(power):\n              rlt += 1\n      return rlt\n  \n  f = open('C-small-attempt1.in', 'r')\n  T = int(f.readline())\n  outLine = []\n  \n  for i in range(1, T + 1):\n      (A, B) = map(int, f.readline().split())\n      outLine.append('Case #%d: %s\n' % (i, process1(A, B)))\n      print outLine[-1],\n  \n  f.close()\n  outFile = open('C-S.out', 'w')\n  outFile.writelines(outLine)\n  outFile.close()\n", "substitutes": {"ls": ["rl", "las", "l", "ld", "es"], "num": ["loc", "dim", "init", "int", "name"], "i": ["l", "ti", "t", "loc", "ih"], "root": ["children", "alpha", "right", "rew", "loc"], "half_digits": ["half_milists", "half_sequbits", "half_Digbits", "half_digitets", "half_multiplets"], "A": ["Ac", "API", "D", "Ma", "au"], "B": ["P", "URL", "Q", "WB", "Ub"], "rlt": ["rLT", "rrbt", "rrlett", "rglett", "rglt"], "a": ["aa", "ai", "l", "aux", "sta"], "b": ["l", "abb", "rb", "t", "abc"], "str_a": ["str__a", "raw___fa", "str___ab", "str___aaa", "str___a"], "next_root": ["next_depth", "next_loc", " next_seed", "next67root", "next54depth"], "digits": ["multiplit", "divbits", "multiplits", " digbits", "milbits"], "_": ["lo", "l", "ow", "s", "x"], "p": ["P", "l", "ip", "j", "pp"], "power": ["P", "ip", "j", "size", "chi"], "f": ["l", "ff", "uf", "z", "rf"], "T": ["P", "TS", "Z", "D", "TH"], "outLine": ["OutRow", "OutList", "sumLine", "againRow", "sumRow"]}}
{"code": "'''\n  Created on 2012-4-14\n  \n  @author: hemnd\n  '''\n  def cal(args):\n      rslt = 0\n      N = int(args[0])\n      S = int(args[1])\n      p = int(args[2])\n      for i in range(N):\n          s = int(args[i + 3])\n          e = s / 3\n          r = s % 3\n          if e >= p:\n              rslt += 1\n          elif r == 1:\n              if e + 1 >= p:\n                  rslt += 1\n          elif r == 0:\n              if e == 0:\n                  continue\n              if S > 0 and e + 1 >= p:\n                  rslt += 1\n                  S -= 1\n          elif r == 2:\n              if e + 1 >= p:\n                  rslt += 1\n              elif S > 0 and e + 2 >= p:\n                  rslt += 1\n                  S -= 1\n      return rslt\n  \n  inputFile = open('B-small-attempt0.in', 'r')\n  inputLines = inputFile.readlines()\n  inputFile.close()\n  \n  T = int(inputLines[0])\n  outputLines = []\n  \n  for i in range(1, T + 1):\n      args = inputLines[i].strip().split(' ')\n      outputLines.append('Case #%d: %d\n' % (i, cal(args)))\n      print outputLines[i - 1],\n  \n  outputFile = open('B-small.out', 'w')\n  outputFile.writelines(outputLines)\n  outputFile.close()\n", "substitutes": {"args": ["l", "mm", "loc", "input", "init"], "rslt": ["RSitt", "rsalt", "arsgt", "rsitt", "rsnat"], "N": ["P", "Q", "J", "Z", "D"], "S": ["Q", "State", "Fs", "D", "Ps"], "p": ["P", "l", "ip", "j", "z"], "i": ["l", "key", "ti", "t", "b"], "s": ["l", "es", "j", "sq", "size"], "e": ["le", "l", "es", "j", "z"], "r": ["rl", "P", "l", "ir", "j"], "inputFile": ["sourceDirectory", "outputFiles", "InputBuffer", "sourceFile", "inputFiles"], "inputLines": ["inputCLues", "inputBlues", " inputLites", "inputSlined", "inputLine"], "T": ["P", "Q", "J", "DT", "TS"], "outputLines": ["outputBine", "responseCLelines", "outputCLine", "outputBines", "outputBlizes"]}}
{"code": " \n  \n  \n  def next_range(stream):\n      line = stream.readline()\n      if not line:\n          return None\n      return [int(x) for x in line.split()]\n  \n  \n  def is_palindrome(n):\n      n = str(n)\n      return all(n[i] == n[len(n)-1-i] for i in range(len(n) // 2))\n  \n  def mysqrt(n):\n      \"\"\"Return -1 if not an integer\"\"\"\n      rt = int(sqrt(n))\n      return rt if rt * rt == n else -1\n  \n  \n  def is_fas(n):\n      rt = mysqrt(n)\n      return rt != -1 and is_palindrome(n) and is_palindrome(rt)\n  \n  \n  def main():\n      with open('C-small-attempt0.in', encoding='utf-8') as f:\n          f.readline()\n  \n          for case in count(1):\n              r = next_range(f)\n              if r is None:\n                  break\n  \n              cnt = 0\n              for n in range(r[0], r[1] + 1):\n                  if is_fas(n):\n                      cnt += 1\n  \n              print('Case #{}: {}'.format(case, cnt))\n  \n  \n  main()\n", "substitutes": {"stream": ["log", "reader", "feed", "iter", "u"], "line": ["LINE", "log", "lo", "l", "co"], "x": ["xb", "ex", "l", "z", "key"], "n": ["l", "t", "b", "all", "ne"], "i": ["ai", "l", "ip", "j", "ij"], "rt": ["art", "t", "right", "lt", "pr"], "case": ["exc", "section", "Case", "sea", "error"], "r": ["rl", "l", "ir", "j", "rf"], "cnt": ["ncnt", "uncret", "cno", "lcNT", "ncct"]}}
{"code": " \n  \n  def best(total):\n      \"\"\"Return the best possible score for the given `total`.  Assume\n      the total is computed by summing exactly three scores (each in the\n      interval of 0 to 10 inclusive) and no score can be 2 points apart\n      \n      Arguments:\n      - `total`:\n      \"\"\"\n      m = total % 3\n      if m == 2:\n          b = total // 3 + 2\n      else:\n          b = total // 3 + 1\n      if b > 10:\n          b = 10\n      return b\n  \n  def best_non_surprising(total):\n      \"\"\"Return the best possible score for the given `total`, but\n      assume that there should be no more than 1 point difference\n      between the scores.\n  \n      Arguments:\n      - `total`:\n      \"\"\"\n      if total % 3 == 0:\n          return total // 3\n      else:\n          return total // 3 + 1\n  \n  def max_num_gte_p(totals, S, p):\n      \"\"\"Return the maximum number of Googlers that could have had a\n      best result of at least p.\n      \n      Arguments:\n      - `totals`:\n      - `S`: number of surprising triplets of scores\n      - `p`:\n      \"\"\"\n      res = 0\n      for total in totals:\n          if total == 0:\n              if p == 0:\n                  res += 1\n              continue\n  \n          if best_non_surprising(total) >= p:\n              res += 1\n          elif S > 0 and best(total) >= p:\n              res += 1\n              S -= 1\n  \n      return res\n  \n  def main():\n      with open(sys.argv[1], 'r') as f:\n          f.readline()            # skip T\n  \n          n = 0\n          for line in f:\n              n += 1\n  \n              line = [int(s) for s in line.split()]\n              N = line[0]\n              S = line[1]\n              p = line[2]\n              totals = line[3:]\n  \n              print 'Case #%d: %d' % (n, max_num_gte_p(totals, S, p))\n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"total": ["otal", "t", "i", "largest", "scale"], "m": ["l", "mm", "j", "mt", "mas"], "b": ["l", "j", "ab", "z", "bl"], "totals": ["totsials", "pottales", "tfatials", "totall", "toballs"], "S": ["Q", "J", "State", "D", "Sign"], "p": ["l", "pp", "t", "i", "pr"], "res": ["exp", "es", "j", "z", "sys"], "n": ["l", "j", "z", "size", "t"], "line": ["co", "l", "inline", "key", "i"], "s": ["opt", "l", "sq", "sec", "size"], "N": ["P", "Q", "Z", "D", " Ne"]}}
{"code": " \n  def read(f):\n      return list( int(v) for v in f.readline().split() )\n  \n  def answer(f, X, ans):\n      out = \"Case #{}: {}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  def testcases(f):\n      T = int(f.readline())\n      for X in range(1, T + 1):\n          A, B = read(f)\n          yield X, A, B\n  \n  def ispalindrome(v):\n      s = str(v)\n      for i in range(len(s) // 2):\n          if s[i] != s[-i-1]:\n              return False\n      return True\n  \n  def main(inf, outf):\n      MAX = 1000\n      fslst = []\n      for i in itertools.count():\n          if ispalindrome(i):\n              squere = i * i\n              print(MAX, squere, ispalindrome(squere))\n              if squere > MAX:\n                  break\n              if ispalindrome(squere):\n                  fslst.append(squere)\n      for X, A, B in testcases(inf):\n          cnt = 0\n          for fs in fslst:\n              if A <= fs <= B:\n                  cnt += 1\n          answer(outf, X, cnt)\n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n", "substitutes": {"f": ["l", "fun", "uf", "fore", "t"], "v": ["l", "nv", "j", "vd", "z"], "X": ["Q", "J", "D", "Code", "OX"], "ans": ["can", "ANN", "Na", "As", "AU"], "out": ["log", "IN", "exp", "text", "Out"], "T": ["Q", "P", "DT", "TS", "Z"], "A": ["AR", "P", "Q", "Case", "Ac"], "B": ["P", "Q", "J", "WB", "QB"], "s": ["l", "es", "lines", "u", "t"], "i": ["l", "iw", "t", "ti", "b"], "inf": ["pl", "pp", "ref", "fit", "fi"], "outf": ["outb", "inF", "upF", "offfe", "offc"], "MAX": ["LINE", "P", "Q", "maximum", "IN"], "fslst": ["sfslsts", "fSlst", "sfsnst", "sfslst", "sfslist"], "squere": ["quere", " queb", "sqiere", " squeb", " squeren"], "cnt": ["Cct", "scnt", "scount", "count", " count"], "fs": ["omp", "As", "Fs", "args", "feed"], "infname": ["Infname", "initname", "infame", "infpath", " infnam"], "outfname": ["wsfword", "outFnam", "outFName", "outlfsize", "outsfName"]}}
{"code": " \n  def testcases():\n      with open(sys.argv[1], \"r\") as f:\n          f.readline()  # skip number of testcases\n          for X, T in enumerate(f, 1):\n              yield X, [int(t) for t in T.split()]\n  \n  def main():\n      for X, T in testcases():\n          N = T[0]   # the number of Googlers\n          S = T[1]   # the number of surprising triplets of scores\n          p = T[2]   # best result of at least\n  \n          y = 0\n  \n          for t in T[3:]:\n              d, m = divmod(t, 3)\n              if m == 0:\n                  if p <= d:\n                      y += 1\n                  elif 0 <= d - 1 <= p <= d + 1 <= 10 and S:\n                      y += 1\n                      S -= 1\n              elif m == 1:\n                  if p <= d + 1:\n                      y += 1\n              else:\n                  if p <= d + 1:\n                      y += 1\n                  elif p <= d + 2 and S:\n                      y += 1\n                      S -= 1\n  \n          print(\"Case #{:d}: {:d}\".format(X, y))\n  \n  if __name__==\"__main__\":\n      main()\n", "substitutes": {"X": ["Q", "P", "J", "z", "Z"], "T": ["P", "Q", "Case", "DT", "TS"], "t": ["opt", "l", "unt", " mt", "j"], "N": ["P", "Q", "j", "z", "Z"], "S": ["Q", "D", "Ps", "YY", "Ds"], "p": ["P", "l", "lp", "ip", "j"], "y": ["l", "i", "b", "phi", "id"], "d": ["P", "l", "ld", "dc", "j"], "m": ["l", "sm", "mm", "j", "mt"]}}
{"code": " \n  def pal(s):\n      for i in xrange(len(s)/2):\n          if s[i] != s[-i-1]:\n              return False\n      return True\n  \n  def pal2(x, s):\n      return pal(s) and pal(str(x*x))\n  \n  def E(k):\n      return 10**k\n  \n  \n  def CREATE_DATABASE(MAX):\n      def init():\n          yield 1\n          yield 2\n          yield 3\n          yield 11\n          yield 22\n          for i in xrange(1, MAX):\n              yield 1*E(2*i) + 1\n              yield 1*E(2*i+1) + 1\n              yield 2*E(2*i) + 2\n              yield 2*E(2*i) + 2 + 1*E(i)\n              yield 2*E(2*i+1) + 2\n              \n              \n      heap = list(sorted(set(init())))\n      for i in heap:\n          print i\n      heapq.heapify(heap)\n      RES = []\n      try:\n          MAX_X = E(MAX)\n          print \"MAX_X\", MAX_X\n          while True:\n              x = heapq.heappop(heap)\n              RES.append(x)\n              if x == 3:\n                  continue\n              if x > MAX_X:\n                  break\n              s = str(x)\n              j = len(s) / 2\n              shift = 1 if len(s) == 2*j else 0\n              for i in xrange(j+1, MAX):\n                  n = E(2*i-shift) + 1 + E(i-j) * x\n                  if pal2(n,str(n)):\n                      heapq.heappush(heap, n)\n                  \n      except KeyboardInterrupt:\n          print \"stopped while x is\", x\n      with open(\"c.database\", 'w') as f:\n          for i in sorted(RES + heap):\n              f.write(\"%i\n\"%i)\n  \n  def READ_DATABASE():\n      with open(\"c.database\", 'r') as f:\n          return sorted(map(lambda x: int(x.strip())**2, f))\n  DB = READ_DATABASE()\n  \n  def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rints(): return map(int, rstr().split())\n      def nrints(N): return [rints() for i in xrange(N)]\n      A, B = rints()\n      i = bisect_left(DB, A) \n      j = bisect_right(DB, B)\n      return j-i\n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          OUT.write(\"Case #%i: %s\n\" % (i, CASE(IN)))\n  \n  if __name__ == \"__main__\":\n      RUN(sys.stdin, sys.stdout)\n", "substitutes": {"s": ["l", "aces", "ices", "b", "sh"], "i": ["l", "IO", "J", "iw", "ti"], "x": ["l", "ex", "key", "xd", "input"], "k": ["Q", "l", "kk", "z", "keys"], "MAX": ["Q", "ALL", "D", "DIR", "MIN"], "heap": [" heaper", "seap", "seaps", "seaper", "HEamp"], "RES": ["Q", "RAW", "P", "VAL", "RESULTS"], "MAX_X": ["MAXNX", " MAX_XP", "MAXNIX", "MAXIDY", "MAX_XP"], "j": ["note", "J", "l", "uj", "adj"], "shift": ["small", "J", "exp", "ff", "size"], "n": ["l", "adj", "z", "size", "nan"], "DB": ["LINE", "IO", "RAW", "D", "database"], "IN": ["URL", "PIN", "RAW", "IO", "ALL"]}}
{"code": " \n  \n  \n  D1 = {} # no suprize\n  D2 = {} # surprize\n  for i in xrange(0, 31):\n      D1[i] = D2[i] = -1\n  \n  def precompute():\n      for a in xrange(0, 11):\n          for b in xrange(a, min(a+3,11)):\n              for c in xrange(b, min(a+3,11)):\n                  t = a+b+c\n                  assert a <= b <= c <= a+2 and c <= 11\n                  if c < a+2:\n                      D1[t] = max(D1[t], c)\n                  else: # that is, c == a+2, we have a suprize\n                      D2[t] = max(D2[t], c)\n  \n  \n  precompute()\n  \n  def case(S, P, ts):\n      res_n = 0\n      res_s = 0\n      for t in ts:\n          if D1[t] >= P:\n              res_n+=1\n          elif D2[t]>=P:\n              res_s+=1\n      return (res_n + min(res_s, S))\n  \n  \n  def solve(fin, fout):\n      T = int(fin.readline())\n      for t in xrange(T):\n          nums = map(int, fin.readline().strip().split(\" \"))\n          N, S, P = nums[:3]\n          ts = nums[3:]\n          assert len(ts) == N    \n          fout.write(\"Case #%i: %i\n\" % (t+1, case(S,P,ts)) )\n      return True\n  \n  if __name__ == \"__main__\":\n      with open(sys.argv[1],'r') as fin:\n          with open(sys.argv[2], 'w') as fout:\n              solve(fin, fout)\n", "substitutes": {"D1": [" DONE", "D3", "Do11", "DSb", "d0"], "D2": ["d8", "D3", "DB", "d0", "S3"], "i": ["ai", "l", "ip", "ir", "j"], "a": ["aa", "ai", "l", "sta", "ab"], "b": ["aa", "l", "ai", "j", "ab"], "c": ["l", "dc", "z", "u", "cc"], "t": ["l", "unt", "tc", "art", "ti"], "S": ["Q", "TS", "D", "ss", "H"], "P": ["Q", "PIN", "WP", "D", "TP"], "ts": ["tc", "ations", "TR", "tests", "alls"], "res_n": ["res_p", "resIds", "resPu", "resPn", "Res_s"], "res_s": ["res_p", "Res_s", "Res_p", "res_ns", " res_c"], "fin": ["fun", "fit", "fi", "inf", "pen"], "fout": ["cfOut", "fouts", "FOut", "Fpass", " fline"], "T": ["Q", "DT", "TS", "Z", "D"], "nums": ["uumbers", "cumbers", " num", "Nums", "cum"], "N": ["Q", "J", "Na", "TS", "Z"]}}
{"code": " f   = file(sys.argv[1])\n  out = file(sys.argv[2], 'w')\n  \n  caseCnt = int(f.readline())\n  \n  Num = [\n  \t0,\n  \t1,\n  \t4,\n  \t9,\n  \t121,\n  \t484,\n  \t10201,\n  \t12321,\n  \t14641,\n  \t40804,\n  \t44944,\n  \t1002001,\n  \t1234321,\n  \t4008004,\n  \t100020001,\n  \t102030201,\n  \t104060401,\n  \t121242121,\n  \t123454321,\n  \t125686521,\n  \t400080004,\n  \t404090404,\n  \t10000200001,\n  \t10221412201,\n  \t12102420121,\n  \t12345654321,\n  \t40000800004,\n  \t1000002000001,\n  \t1002003002001,\n  \t1004006004001,\n  \t1020304030201,\n  \t1022325232201,\n  \t1024348434201,\n  \t1210024200121,\n  \t1212225222121,\n  \t1214428244121,\n  \t1232346432321,\n  \t1234567654321,\n  \t4000008000004,\n  \t4004009004004,\n  ]\n  \n  for case in range(1, caseCnt+1):\n  \tL, H = f.readline().split()\n  \tL = int(L); H = int(H)\n  \tassert L <= H\n  \t\n  \tfor i in range(len(Num)):\n  \t\tif L <= Num[i]:\n  \t\t\tbreak\n  \telse:\n  \t\tprint>>out, 'Case #%d:'%case, 0\n  \t\tcontinue\n  \n  \tlb = i - 1\n  \n  \tfor i in range(1, len(Num)+1):\n  \t\tif H >= Num[len(Num)-i]:\n  \t\t\tbreak\n  \telse:\n  \t\tprint>>out, 'Case #%d:'%case, 0\n  \t\tcontinue\n  \tub = len(Num)-i\n  \t\t\n  \tprint>>out, 'Case #%d:'%case, ub - lb\n  \n  out.close()\n", "substitutes": {"f": ["log", "l", "rf", "sys", "folder"], "out": [" output", "ex", "key", "t", "fi"], "caseCnt": ["casecst", "CaseCourse", "caseDecNT", "caseCner", " casecNT"], "Num": ["Code", "Data", "Len", "Int", "Bu"], "case": ["address", "ce", "path", "b", "ase"], "L": ["TL", "P", "l", "J", " Li"], "H": ["Q", "P", "HL", "J", "Z"], "i": ["l", "iw", "ti", "b", "ih"], "lb": ["rl", "log", "l", "ai", "Ub"], "ub": ["cur", "ai", "Ub", "ab", "pl"]}}
{"code": " \n  f = file(\"B-small-attempt0.in\")\n  w = file(\"answer.txt\", \"w\")\n  cnt = int(f.readline()[:-1])\n  for no in range(cnt):\n  \tl = f.readline()[:-1].split()\n  \tT, s, p = map(int, l[:3])\n  \tts = map(int, l[3:])\n  \tns = p*3-2 if p*3-2 > 0 else 0\n  \tss = p*3-4 if p*3-4 > 0 else 31\n  \tl = filter(lambda x: x<ns, ts)\n  \tc = min([len(filter(lambda x: x>=ss, l)), s])\n  \t\n  \tprint>>w, \"Case #%d:\"%(no+1), T-len(l)+c\n  \n  \n", "substitutes": {"f": ["rf", "z", "folder", "t", "df"], "w": ["log", "view", "wh", "wa", "hw"], "cnt": ["Cnc", " cnn", "Cnn", "dcnd", "conNT"], "no": ["co", "lo", " ip", "i", "error"], "l": ["rl", "log", " L", "lo", "le"], "T": ["P", "Q", "TS", "z", "size"], "s": ["P", "es", "lines", "z", "size"], "p": ["P", "ip", "j", "z", "per"], "ts": ["es", "TS", "z", "t", "ins"], "ns": ["es", "lines", "z", "ins", "nos"], "ss": ["css", "hess", "es", "z", "t"], "c": ["tc", "dc", "size", "z", "t"]}}
{"code": "def check(a,b):\n      c = 0\n      n = 1\n      for i in range(1,4):\n          if i**2 >= a and i**2 <=b:\n              c += 1\n      if 44944 >= a and 44944 <= b:\n          c += 1\n      while n < 10:\n          p1 = int('1'+'1'*n)**2\n          if p1 >= a and p1 <=b:\n              c += 1\n          n += 1\n  \n  \n      if 484 >= a and 484 <= b:\n          c += 1\n  \n      n = 1\n      while True:\n          p2 = int('1'+'0'*n+'1')**2\n          p3 = int('2'+'0'*n+'2')**2\n          if p2 >= a and p2 <= b:\n              c += 1\n          else:\n              break\n          if p3 >= a and p3 <= b:\n              c += 1\n          else:\n              continue\n          n += 1\n  \n      n = 1\n      while True:\n          t = False\n          for m in range(2,5):\n              p4 = int('1'*m+'0'*n+'1'*m)**2\n              if p4 >= a and p4 <= b:\n                  c += 1\n              else:\n                  t = True\n                  break\n          if t:\n              break\n              \n          n += 1\n      return c\n                  \n  dat = raw_input().split()\n  n = int(dat.pop(0))\n  data = [int(e) for e in dat]\n  \n  for i in range(0, n*2, 2):\n      a, b = data[i], data[i+1]\n      print 'Case #%i: '%(i/2+1) + str(check(a,b)) \n  \n      \n", "substitutes": {"a": ["l", "alpha", "art", "am", "au"], "b": ["l", "abb", "rb", "bel", "function"], "c": ["co", "l", "tc", "arc", "ce"], "n": ["l", "ot", "all", "ne", "ln"], "i": ["ai", "l", "ip", "j", "adi"], "p1": ["p151", "cpOne", "jpOne", "P151", "jp6"], "p2": ["ip8", "functionsecond", "ipsecond", "P5", "m1"], "p3": [" p123", "ip183", "p03", "fp3", "cp1"], "t": ["l", "tc", "j", "z", "br"], "m": ["l", "mm", "month", "j", "z"], "p4": ["c4", "password256", "c6", " p256", "password4"], "dat": ["sat", "pl", "abc", "input", "Data"], "data": ["config", "open", "lines", "z", "new"], "e": ["l", "een", "es", "j", "ite"]}}
{"code": "f = open('cj2.in','r')\n  out = open('out1.txt','w')\n  inp = [[int(n) for n in s.split()] for s in f.readlines()]\n  \n  def score_partition(score):\n      poss = []\n      if score == 0:\n          return [[0,0,0]]\n      if score == 1:\n          return [[0,0,1]]\n      if score % 3 == 0:\n          poss.append([score/3,score/3,score/3])\n          poss.append([score/3-1,score/3,score/3+1])\n      if score % 3 == 1:\n          poss.append([score/3, score/3,score/3+1])\n          poss.append([score/3-1,score/3+1,score/3+1])\n      if score % 3 == 2:\n          poss.append([score/3,score/3+1,score/3+1])\n          poss.append([score/3,score/3,score/3+2])\n  \n      return poss\n  \n  \n  s = 0\n  c = 1\n  for e in inp[1:len(inp)]:\n      count = 0\n      surprises = e[1]\n      s = 0\n      p = e[2]\n      for i in e[3:len(e)]:\n          scores = score_partition(i)\n          for j in scores: \n              if max(j) >= p:\n                  if max(j)-min(j) == 2:\n                      if s < surprises:\n                          s +=1\n                          count +=1\n                          break\n                  else:\n                      count += 1\n                      break\n                  \n      out.write('Case #'+str(c)+': '+str(count)+'\n')\n      c += 1\n  \n  out.close()\n  f.close()\n                  \n          \n      \n      \n  \n      \n", "substitutes": {"f": ["l", "fer", "z", "rf", "t"], "out": ["log", "ex", "exp", "co", "opt"], "inp": ["Inps", " inv", "InP", "inps", "INe"], "n": ["l", "z", "t", "u", "r"], "s": ["l", "t", "b", "all", "stats"], "score": ["color", "key", "mean", "fit", "skill"], "poss": ["boss", "toposs", "hosit", "ifower", "apou"], "c": ["cur", "l", "sec", "z", "size"], "e": ["l", "es", "ite", "z", "case"], "count": ["l", "sec", "z", "size", "case"], "surprises": [" surriers", " surprising", "SUriers", " surprise", "surcharges"], "p": ["P", "l", "z", "pp", "py"], "i": ["J", "l", "ip", "z", "chi"], "scores": ["coates", "coors", "Scores", "scents", "switches"], "j": ["note", "J", "l", "adj", "ij"]}}
{"code": " def ispal(num):\n      num = str(num)\n      if num == num[::-1]:\n          return True\n      else:\n          return False\n  \n  def test(bot, top):\n      count = []\n      for i in range(bot,top+1):\n          if not ((int(i**0.5)**2) == i):\n              continue\n          if ispal(i) and ispal(int(i**0.5)):\n              count.append(i)\n      return len(count)\n  \n  case = 1\n  for line in open('C-small-attempt2.in', 'Ur'):\n      if ' ' in line:\n          a,b = line.split()\n          res = test(int(a),int(b))\n          print(\"Case #{0}: {1}\".format(case, res))\n          case += 1\n  \n  \n", "substitutes": {"num": ["loc", "init", "int", "name", "multi"], "bot": ["log", "tip", "br", "plot", "loc"], "top": ["best", "tip", "ip", "min", "size"], "count": ["log", "add", "size", "max", "key"], "i": ["l", "ti", "loc", "fi", "input"], "case": ["section", "Case", "address", "size", "ASE"], "line": ["LINE", "lo", "l", "log", "strip"], "a": ["aa", "ai", "l", "sta", "ab"], "b": ["l", "ab", "abb", "br", "bl"], "res": ["exc", "reg", "progress", "rice", "error"]}}
{"code": " data = [[100],[3,1,5,15,13,11],[3,0,8,23,22,21],[2,0,8,26,20],[1,0,3,30],[2,2,5,6,19],[2,0,9,18,2],[3,0,8,0,22,23],[3,2,4,29,17,28],[2,2,10,6,7],[2,1,1,17,0],[1,0,9,2],[2,0,10,27,27],[1,0,10,12],[2,2,6,20,12],[3,1,2,5,24,15],[3,0,8,29,20,20],[1,1,9,13],[1,1,7,11],[2,0,2,2,2],[1,0,5,11],[1,0,4,8],[1,0,4,1],[3,1,3,10,9,3],[2,2,7,15,2],[2,0,1,26,28],[3,0,10,5,27,9],[2,2,5,21,7],[3,0,1,23,11,26],[3,3,2,23,28,22],[2,1,5,11,11],[2,0,4,16,26],[3,0,10,26,30,18],[3,2,5,15,19,11],[1,0,1,4],[3,0,4,2,3,30],[3,1,2,3,0,3],[2,0,3,21,30],[3,1,6,14,16,14],[1,0,7,17],[3,3,3,22,18,22],[2,1,7,17,17],[2,0,1,19,14],[1,0,1,0],[3,0,4,8,3,25],[2,0,3,5,30],[2,0,6,14,15],[1,0,10,22],[1,0,7,18],[1,0,3,5],[3,3,8,26,17,4],[3,3,0,3,9,21],[3,2,1,14,12,0],[2,0,7,29,18],[2,0,3,6,8],[1,1,8,3],[3,1,9,17,12,14],[2,0,3,22,6],[2,0,8,29,9],[3,3,9,16,26,13],[1,1,0,12],[2,1,7,27,14],[2,0,6,22,19],[1,0,0,0],[2,1,5,18,22],[3,1,9,28,24,23],[3,0,1,4,15,29],[1,0,3,20],[3,0,1,30,21,30],[2,0,9,19,7],[1,0,9,10],[1,0,0,1],[2,1,3,6,6],[3,1,0,11,28,27],[2,0,4,25,8],[1,0,6,15],[3,3,9,12,23,26],[2,1,5,12,12],[3,1,9,28,3,28],[3,1,6,20,14,15],[1,0,10,30],[1,1,9,9],[2,0,9,3,10],[2,0,10,26,26],[2,1,9,23,23],[3,0,2,6,3,22],[1,1,0,27],[3,0,9,23,23,24],[1,1,7,2],[2,1,0,10,3],[1,0,4,1],[1,0,7,12],[3,0,9,23,15,8],[1,0,10,27],[3,0,0,30,30,30],[3,0,3,19,2,14],[3,1,3,6,21,5],[3,0,3,11,16,11],[1,1,8,3],[2,0,10,26,19],[1,0,7,18]]\n  count = 0\n  for line in data[1:]:\n  \tcount += 1\n  \tsupps = line[1]\n  \tscore = line[2]\n  \tmaxes = 0\n  \tnonsuptot = (score*3)-2\n  \tsuptot = (score*3)-4\n  \tif suptot < 0:\n  \t\tsuptot = 1\n  \tfor i in range(3,(len(line))):\n  \t\tif line[i] >= nonsuptot:\n  \t\t\tmaxes += 1\n  \t\t\tcontinue\n  \t\tif (line[i] >= suptot) and (supps > 0):\n  \t\t\tmaxes += 1\n  \t\t\tsupps -= 1\n  \tif score == 0:\n  \t\tmaxes = line[0]\n  \tprint (\"Case #\"+str(count)+\":\", maxes)\n  \t\t\n  \t\t\t\n  \n  \n  \n  \n", "substitutes": {"data": ["image", "format", "config", "shape", "features"]}}
{"code": " \n  \n  def is_palindrome(a):\n      return str(a) == ''.join(reversed(str(a)))\n  \n  \n  def solve_problem(min_num, max_num):\n      count = 0\n      for i in xrange(min_num, max_num + 1):\n          if is_palindrome(i):\n              sqrt = math.sqrt(i)\n              if int(sqrt) == sqrt and is_palindrome(int(sqrt)):\n                  count += 1\n      return count\n  \n  \n  if __name__ == '__main__':\n      num_of_cases = int(sys.stdin.readline())\n      for i in xrange(1, num_of_cases + 1):\n          min_num, max_num = map(int, sys.stdin.readline().strip().split(' '))\n          print 'Case #{0}: {1}'.format(i, solve_problem(min_num, max_num))\n", "substitutes": {"a": ["aa", "ai", "sta", "ab", "alpha"], "min_num": ["minDnum", "miningnon", "miningnu", "min_four", "min_min"], "max_num": ["maxWmun", "maxjn", "max_n", " max_end", " max_size"], "count": ["cond", "add", "size", "case", "key"], "i": ["lo", "ai", "l", "ip", "j"], "sqrt": ["secrect", "secrf", "shr", "squr", " sqrot"], "num_of_cases": ["num_ofxcase", "num_ofaccases", "num_ofxblocks", "num_of_times", "num_offsections"]}}
{"code": "\"\"\"\n  Google Code Jam 2012 Problem B\n  Usage:\n      python problem_b.py < input.txt > output.txt\n  \"\"\"\n  \n  \n  def calc_possible(n):\n      combinations = itertools.combinations_with_replacement(range(n), 3)  # 3 scores\n      return itertools.ifilter(lambda (x, y, z): x + y + z == n, combinations)\n  \n  \n  def calc_surprising(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) == 2, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def calc_normal(n):\n      results = list(itertools.ifilter(lambda scores: max(scores) - min(scores) <= 1, calc_possible(n)))\n      return results[0] if results else None\n  \n  \n  def solve_problem():\n      number_of_cases = int(sys.stdin.readline())\n  \n      for i in xrange(1, number_of_cases + 1):\n  \n          case = sys.stdin.readline().strip()\n          result = 0\n          num_of_googlers, num_of_surprising, desired_score, scores = case.split(' ', 3)\n          num_of_googlers = int(num_of_googlers)\n          num_of_surprising = int(num_of_surprising)\n          desired_score = int(desired_score)\n          scores = map(int, scores.split())\n  \n          possible_scores = []\n  \n          for k in xrange(num_of_googlers):\n  \n              normal = calc_normal(scores[k])\n              surprising = calc_surprising(scores[k])\n  \n              possible_scores.append(((normal if normal else (0, 0, 0), 0), (surprising if surprising else (0, 0, 0), 1)))\n  \n          possible = list(itertools.ifilter(lambda scores: sum(map(lambda x: x[1], scores)) == num_of_surprising, itertools.product(*possible_scores)))\n          result = max(map(lambda scores: sum(map(lambda x: int(max(x[0]) >= desired_score), scores)) if scores else 0, possible))\n  \n          sys.stdout.write('Case #{0}: {1}\n'.format(i, result))\n  \n  \n  if __name__ == '__main__':\n      solve_problem()\n", "substitutes": {"n": ["l", "t", "b", "all", "ne"], "combinations": ["domines", "cominations", "combinators", "clination", "comination"], "results": ["includes", "jobs", "windows", "tests", "stats"], "number_of_cases": ["number_of_fits", "number_ofxcase", "number_ofxsettings", "number_ofxpoints", "number_of_points"], "i": ["l", "ip", "j", "z", "u"], "case": ["condition", "section", "Case", "address", "config"], "result": ["section", "answer", "page", "target", "final"], "num_of_googlers": ["num_of_goongles", "num_of_googsler", "num_of_loogler", "num_of_googglor", "num_of_goongler"], "num_of_surprising": ["num_of_urprise", "num_of_urprising", "num_of_urprises", "num_of_serieving", "num_of_curprise"], "desired_score": ["deserved_match", "desired_match", "desired___match", "desired\u00b7score", "desired_word"], "scores": ["SCorers", "oscopes", "cores", " scourses", "escuries"], "possible_scores": ["possible_clores", "possible_scours", "possible_scored", "possible_hypore", "possible_descored"], "k": [" work", "key", "kick", "b", "ko"], "normal": ["small", "neutral", "fun", "color", "new"], "surprising": ["surprises", "Surprising", "surprisingly", "Surprises", "surprise"], "possible": ["spores", "paored", "possibility", "Possibility", "spossible"]}}
{"code": " \n  \n  \n  def ispalindrome(n):\n      return str(n) == str(n)[::-1]\n  \n  \n  def solve(A, B):\n      solution = []\n      for n in range(int(math.sqrt(A)), int(math.sqrt(B))+1):\n          if ispalindrome(n):\n              m = n ** 2\n              if ispalindrome(m) and A <= m <= B:\n                  solution.append(n)\n      return len(solution)\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          A, B = map(int, IN.readline().split())\n          OUT.write('Case #%d: %s\n' % (index + 1, solve(A, B)))\n  \n  \n  def makesample(T=100, ABmax=1000):\n      print T\n      for index in range(T):\n          A = random.randint(1, ABmax)\n          B = random.randint(A, ABmax)\n          print A, B\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n", "substitutes": {"n": ["l", "adj", "nv", "un", "j"], "A": ["API", "D", "Ma", "Code", "Data"], "B": ["Q", "J", "D", "UB", "Other"], "solution": ["absolver", "solver", "absolution", "dolver", "ssolution"], "m": ["l", "sm", "mm", "j", "min"], "IN": ["II", "LINE", "URL", "PIN", "IO"], "OUT": ["LINE", "Q", "IO", "RAW", "URL"], "T": ["P", "Q", "DT", "TS", "Z"], "index": ["END", "j", "obj", "size", "page"], "ABmax": ["abmax", "ABcache", "AFmax", " ABorig", "AFMax"]}}
{"code": " \n  \n  \n  \n  \n  def solve(S, p, tlist):\n  \tabove = 0\n  \tconsider = 0\n  \n  \tfor t in tlist:\n  \t\tavg = t / 3\n  \t\tmod = t % 3\n  \n  \t\tif mod == 0:\n  \t\t\tif avg >= p:\n  \t\t\t\tabove += 1\n  \t\t\telif avg + 1 >= p and t > 0:\n  \t\t\t\tconsider += 1\n  \n  \t\telif mod == 1:\n  \t\t\tif avg + 1 >= p:\n  \t\t\t\tabove += 1\n  \n  \t\telif mod == 2:\n  \t\t\tif avg + 1 >= p:\n  \t\t\t\tabove += 1\n  \t\t\telif avg + 2 >= p:\n  \t\t\t\tconsider += 1\n  \n  \treturn above + min(S, consider)\n  \n  \n  def main(IN, OUT):\n  \tN = int(IN.readline())\n  \tfor index in range(N):\n  \t\tdata = map(int, IN.readline().strip().split())\n  \t\t(N, S, p), tlist = data[:3], data[3:]\n  \t\tOUT.write('Case #%d: %d\n' % (index + 1, solve(S, p, tlist)))\n  \n  \n  if __name__ == '__main__':\n  \tmain(sys.stdin, sys.stdout)\n  \n", "substitutes": {"S": ["P", "Q", "State", "TS", "SM"], "p": ["l", "pp", "pl", "i", "b"], "tlist": ["pcode", "atset", "dtList", "lbase", "vList"], "above": ["alpha", "profit", "past", "master", "prev"], "consider": ["very", "respect", "require", "integer", "allow"], "t": ["l", "tc", "j", "z", "art"], "avg": ["evG", "umgy", "ajp", "avgen", "afgy"], "mod": [" mods", "fun", "tool", "progress", "dim"], "IN": ["LINE", "Q", "URL", "PIN", "IO"], "OUT": ["LINE", "Q", "P", "END", "RAW"], "N": ["P", "Na", "Z", "D", "Size"], "index": ["include", "obj", "page", "key", "out"], "data": ["missing", "size", "zip", "alpha", "update"]}}
{"code": " \n  N_MAX = 10 ** 7  # for First large dataset\n  \n  \n  def is_palindrome(n):\n      s = str(n)\n      for i in xrange(len(s) / 2):\n          if s[i] != s[-1 - i]:\n              return False\n      return True\n  \n  palindromes = [x for x in xrange(N_MAX) if is_palindrome(x)]\n  palindrome_squares = [x ** 2 for x in palindromes]\n  fair_and_square_palindromes = filter(is_palindrome, palindrome_squares)\n  \n  \n  T = int(raw_input())\n  for test_case_id in xrange(1, T + 1):\n      A, B = map(int, raw_input().split())\n      answer = len([x for x in fair_and_square_palindromes if A <= x <= B])\n      print 'Case #{}: {}'.format(test_case_id, answer)\n", "substitutes": {"N_MAX": ["n_max", "n__max", "NAMmax", "RNMax", "NNMAX"], "n": ["l", "j", "z", "t", "max"], "s": ["l", "ts", "es", "services", "t"], "i": ["ai", "l", "ip", "j", "z"], "palindromes": ["palindchromites", "palendromises", "palindroyis", "palindrocs", "palintromites"], "x": ["co", "ex", "l", "rax", "alpha"], "palindrome_squares": ["palindrome_quares", "palindrome_quare", "palindrome_squars", "palindrome_Squeries", "palindrome_quers"], "fair_and_square_palindromes": ["fair_and_square_palndramES", "fair_and_square_palendromee", "fair_and_square_palendromeals", "fair_and_square_palindramed", "fair_and_square_palindrome"], "T": ["Q", "P", "TS", "Z", "D"], "test_case_id": ["test_test_index", "test_sectionblocknum", "test_section_index", "test_section_num", "test_case__index"], "A": ["P", "El", "Ca", "Na", "As"], "B": ["Q", "P", "Ub", "WB", "QB"], "answer": ["uit", "address", "swers", "size", "issue"]}}
{"code": " \n  \n  poss = dict([(i, {}) for i in xrange(0, 30 + 1)])\n  for a, b, c in itertools.product(range(10 + 1), repeat=3):\n      if a <= b <= c and c - a <= 2:\n          n = a + b + c\n          if c - a == 2:\n              poss[n]['s'] = tuple(sorted((a, b, c)))\n          else:\n              poss[n]['n'] = tuple(sorted((a, b, c)))\n  \n  \n  T = int(raw_input())\n  for case in xrange(1, T + 1):\n      div = map(int, raw_input().split())\n      N, S, p = div[:3]\n      t = div[3:]\n  \n      ans = 0\n      t.sort(reverse=True)\n      for i in xrange(len(t)):\n          na, nb, nc = poss[t[i]]['n']\n          sa, sb, sc = poss[t[i]].get('s', (-1, -1, -1))\n          if p <= nc:\n              ans += 1\n          elif 0 < S and p <= sc:\n              ans += 1\n              S -= 1\n  \n      print 'Case #%d: %d' % (case, ans)\n  \n", "substitutes": {"poss": [" pos", "Pens", " pense", "noss", "npos"], "i": ["ai", "l", "ip", "j", "chi"], "a": ["ak", "aa", "ai", "l", "wa"], "b": ["l", "aa", "j", "ab", "api"], "c": ["cur", "l", "dc", "z", "arc"], "n": ["l", "config", "j", "z", "pn"], "T": ["P", "Q", "TS", "Z", "D"], "case": ["section", "Case", "shape", "ip", "address"], "div": ["cur", "division", "tri", "dc", "min"], "N": ["P", "Q", "Na", "Z", "D"], "S": ["Q", " SS", "D", "Sign", "Ps"], "p": ["P", "l", "ppa", "pp", "amp"], "t": ["l", "unt", "tc", "new", "ti"], "ans": ["ai", "Case", "ents", "can", "Na"], "na": ["aa", "wa", "Na", "chi", "nan"], "nb": ["ai", "adj", "aa", "ab", "abb"], "nc": ["aa", "nv", "dc", "pn", "cc"], "sa": ["aa", "ai", "sta", "ss", "ba"], "sb": ["ai", "ib", "rb", "bb", "src"], "sc": ["dc", "esc", "ci", "cc", "Sc"]}}
{"code": " \n  \n  \n  INPUT = \"tiny\"\n  if 1:\n      INPUT = \"C-small-attempt0.in\"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args\n  \n  def is_palindrome(N):\n      s = str(N)\n      return s == ''.join(reversed(s))\n  \n  def fair_and_square_set(max_N):\n      p = \"squareset_%d\" % max_N\n      try:\n          s = pickle.load(file(p))\n          return s\n      except:\n          pass\n      s = set()\n      for i in range(1,max_N+1):\n          if is_palindrome(i) and is_palindrome(i*i):\n              s.add(i*i)\n      pickle.dump(s, file(p, \"wb\"))\n      return s\n  \n  MAX_N = int(1e7)\n  SQUARE_SET = fair_and_square_set(MAX_N)\n  \n  def do_trial(A, B):\n      count = 0\n      for ss in SQUARE_SET:\n          if A <= ss <= B:\n              count += 1\n      return count\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      A, B = [int(x) for x in f.readline().split()]\n      v = do_trial(A, B)\n      print \"Case #%d: %s\" % (i+1, v)\n", "substitutes": {"INPUT": ["AINLINE", "AINput", "InInput", "InPUT", "INput"], "self": ["co", "right", "connection", "all", "master"], "function": ["fun", "library", "closure", "null", " functions"], "_cache": ["workingconfig", "_data", "_ache", "_session", "workingfunction"], "_callable": ["_Callfunction", "___variation", "_callative", "_Caller", "_variable"], "cache": ["co", "config", "image", "can", "cell"], "key": ["section", "fee", "link", "keys", "size"], "cachedValue": ["cannedValues", "cachedvalue", " cryptedValues", "fachedvalue", "cryptedvalue"], "N": ["P", "Q", "J", "Na", "size"], "s": ["l", "ssh", "t", "b", "tests"], "max_N": ["max_C", "max_n", "maxJK", " maxJL", " max_K"], "p": ["P", "l", "ip", "j", "page"], "i": ["l", "ti", "t", "fi", "ih"], "MAX_N": [" MAXIDS", "MAXIDS", "MAX_K", " MAX_C", "AND_n"], "SQUARE_SET": ["SQUAR_Set", "SQUAREALET", "SQUAREALSet", "SQUARALSet", "SQUAREETET"], "A": ["Ac", "API", "D", "Ma", "Act"], "B": ["P", "Q", "WB", "QB", "DB"], "count": ["l", "add", "size", "z", "case"], "ss": ["css", "mm", " SS", "DB", "Z"], "f": ["l", "fun", "ff", "fff", "z"], "T": ["P", "Q", "Case", "TS", "Z"], "x": ["xb", "l", "ex", "qu", "j"], "v": ["l", "qv", "nv", "j", "vd"]}}
{"code": " \n  \n  INPUT = \"tiny\"\n  \n  INPUT = \"B-small-attempt0.in.txt\"\n  \n  def debug(*args):\n      pass #print str(args)\n  \n  def zdebug(*args):\n      print ''.join(str(s) for s in args)\n  \n  def can_score_p(N, p):\n      low_p = max(p-1, 0)\n      if low_p + low_p + p <= N:\n          return \"Y\"\n      low_p = max(p-2, 0)\n      if low_p + low_p + p <= N:\n          return \"S\"\n      return \"N\"\n  \n  def do_trial(N, S, p, *scores):\n      d = { \"Y\" : 0, \"N\" : 0, \"S\" : 0 }\n      for s in scores:\n          v = can_score_p(s, p)\n          debug(\"score %s p=%s : %s\" % (s, p, v))\n          d[v] = d[v] + 1\n      return d[\"Y\"] + min(d[\"S\"], S)\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      l = [int(x) for x in f.readline()[:-1].split()]\n      v = do_trial(*l)\n      print \"Case #%d: %s\" % (i+1, v)\n", "substitutes": {"INPUT": ["InInput", "SULT", "InPUT", "INLA", "SST"], "s": ["t", "input", "b", "tests", "all"], "N": ["P", "Q", "Na", "min", "z"], "p": ["P", "ip", "j", "z", "pp"], "low_p": ["old_pi", "old_lp", "low9c", "low25pe", "low64ps"], "S": ["P", "Q", "Z", "D", "u"], "d": ["ld", "dc", "j", "z", "vd"], "v": ["P", "qv", "nv", "vd", "j"], "f": ["t", "feed", "rb", "ref", "fit"], "T": ["P", "Q", "DT", "TS", "size"], "i": ["ai", "ip", "j", "z", "u"], "l": ["le", " L", "j", "z", "t"], "x": ["ex", "j", "z", "u", "max"]}}
{"code": " \n  \n  def is_palindromic(i):\n      n = i\n      rev = 0\n      while i > 0:\n          dig = i % 10\n          rev = rev * 10 + dig\n          i = i // 10\n      return n == rev\n  \n  def is_square(i):\n      if i == 1:\n          return True\n      x = i // 2\n      seen = set([x])\n      while x * x != i:\n          x = (x + (i // x)) // 2\n          if x in seen:\n              return False\n          seen.add(x)\n      return True\n  \n  def f(a, b):\n      tot = 0\n  \n      sra = a\n      while not is_square(sra):\n          sra += 1\n      srb = b\n      while not is_square(srb):\n          srb -= 1\n  \n      sra = int(sqrt(sra))\n      srb = int(sqrt(srb))\n  \n      for i in range(sra, srb+1):\n          if is_palindromic(i) and is_palindromic(i ** 2):\n              tot += 1\n  \n      return tot\n  \n  if __name__ == '__main__':\n      T = int(input())\n      for i in range(T):\n          a, b = map(int, input().split())\n          r = f(a, b)\n          print('Case #{}: {}'.format(i+1, r))\n", "substitutes": {"i": ["l", "ti", "t", " I", "fi"], "n": ["l", "adj", "j", "z", "t"], "rev": ["abc", "vision", "dec", "int", "init"], "dig": ["log", "exp", "reg", "tip", "dc"], "x": ["ex", "l", "t", "xd", "abc"], "seen": ["section", "closed", "new", "selected", "connected"], "a": ["ak", "aa", "l", "ai", "wa"], "b": ["bar", "xb", "l", "j", "ab"], "tot": ["ttOT", "eot", "toti", "totaloto", "tempot"], "sra": ["dsara", "zra", "insru", " sla", "zta"], "srb": ["dsrf", "southrt", "dsru", "src", "southru"], "T": ["P", "Q", "TS", "Z", "D"], "r": ["rl", "ir", "br", "ur", "rb"]}}
{"code": " \n  T = int(raw_input())\n  for i in xrange(T):\n      values = map(int, raw_input().split())\n      [N,s,p] = values[0:3]\n      t = values[3:]\n      answer = 0\n      for note in t:\n          if note < 2:\n              if note >= p:\n                  answer += 1\n          elif note % 3 == 1 and (note-1) / 3 + 1 >= p:\n              answer += 1\n          elif note % 3 == 0:\n              n = note / 3\n              if n >= p:\n                  answer += 1\n              elif s > 0 and n + 1 >= p:\n                  answer += 1\n                  s -= 1\n          elif note % 3 == 2:\n              n = (note - 2) / 3\n              if n + 1 >= p:\n                  answer += 1\n              elif s > 0 and n + 2 >= p:\n                  answer += 1\n                  s -= 1\n      print 'Case #{0}: {1}'.format(i+1, answer)\n", "substitutes": {"T": ["P", "J", "Q", "TS", "Z"], "i": ["ip", "j", "z", "chi", "u"], "values": ["versions", "ones", "lines", "keys", "args"], "N": ["P", "J", "Q", "Z", "D"], "s": ["l", "b", "name", "multi", "o"], "p": ["P", "l", "exp", "ip", "j"], "t": ["P", "l", "text", "j", "z"], "answer": ["address", "au", "music", "write", "name"], "note": ["study", "key", "ot", "all", "music"], "n": ["l", "j", "z", "null", "u"]}}
{"code": " \n  \n  FILE_NAME_BASE = 'C-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  def parse(inp):\n  \ta, b = (int(x) for x in inp.readline().split())\n  \treturn a, b\n  \n  def isFair(x):\n  \tl1 = list(str(x))\n  \tl2 = list(l1)\n  \tl2.reverse()\n  \treturn l1 == l2\n  \n  def solve(a, b):\n  \tc = 0\n  \tfor i in xrange(a, b + 1):\n  \t\tr = int(sqrt(i))\n  \t\tif r * r == i and isFair(i) and isFair(r):\n  \t\t\tc += 1\n  \n  \treturn str(c)\n  \n  def main():\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\n  \n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\n  \tnumCases = int(inp.readline())\n  \tif NUM_PROCESSES == 0:\n  \t\tresults = [\n  \t\t\tsolve(*parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \telse:\n  \t\tpool = Pool(NUM_PROCESSES)\n  \t\tresults = [\n  \t\t\tpool.apply_async(solve, parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \tinp.close()\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\n  \tfor case, result in enumerate(results):\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n  \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n  \t\tout.flush()\n  \tout.close()\n  \n  if __name__ == '__main__':\n  \tmain()\n", "substitutes": {"FILE_NAME_BASE": ["FILE_NAME_BEASH", "FILE_NAME_FAME", "FILE_NAME__BASH", "FILE_NAMEPBAME", "FILE_NAME_BUAME"], "NUM_PROCESSES": ["NUM_PROCECes", "NUM_PROCOSSIONS", "NUM_PROCOCS", "NUM_PRECECes", "NUM_PROCESSS"], "MEM_LIMIT_GB": ["MEM_LIMITED_GB", "MEM_LIMITE_MB", "MEM_LIMITED_MM", "MEM_LIMIT2GP", "MEM_LIMITED_GP"], "RECURSION_LIMIT": ["RECURSION_LIGER", "RECURSION_LOBITS", "RECURSION_CLimITS", "RECURSION_CLIMER", "RECURSION_LIGIT"], "inp": ["zinq", " inv", " infp", "insh", "inlp"], "a": ["ak", "aa", "l", "ai", "wa"], "b": ["xb", "l", "aa", "j", "ab"], "x": ["ex", "l", "t", "input", "xx"], "l1": ["ll1", "L1", " lone", "L0", "L13"], "l2": ["L1", "lione", " lone", "Ltwo", "Li4"], "c": ["co", "l", "roc", "dc", "sec"], "i": ["l", "ai", "ip", "ir", "j"], "r": ["rl", "l", "ir", "j", "br"], "soft": ["very", "mm", "ib", "server", "slow"], "hard": ["small", "weak", "adv", "middle", "external"], "numCases": ["numberNakes", "numPases", "numBases", "numConatches", "numConASE"], "results": ["versions", "includes", "values", "features", "RESULTS"], "_": [" the", "ing", "___", "s", " all"], "pool": ["can", "wa", "graph", "rain", "page"], "out": ["log", "ex", "image", "engine", "exp"], "case": ["step", "section", "Case", "address", "config"], "result": ["process", "function", "name", "re", "round"], "value": ["section", "answer", "values", "min", "size"]}}
{"code": " \n  FILE_NAME_BASE = 'B-small-attempt0'\n  NUM_PROCESSES = 0\n  \n  def parse(inp):\n  \tdata = tuple(int(x) for x in inp.readline().split())\n  \tdancers, surprises, points = data[ : 3]\n  \ttotals = data[3 : ]\n  \tassert len(totals) == dancers\n  \treturn totals, surprises, points\n  \n  def totalAtDist():\n  \t'''\n  \tIf a dancer's best result is b, the total can be:\n  \t  distance 0: 3b\n  \t  distance 1: [3b-2..3b-1]\n  \t  distance 2: [3b-4..3b-2]\n  \tNote: distance d is only possible if d <= b.\n  \n  \ttotal 15:\n  \tb = 0..4:  impossible\n  \tb = 5:     dist = 0\n  \tb = 6:     dist = 2\n  \tb = 7..10: impossible\n  \n  \tFor every total we have a number of explanations, which are\n  \t(b, d) pairs where b is the best result and d is the distance.\n  \n  \tThe output of this function shows:\n  \n  \tExcept for 0, 1, 29 and 30, every total t has exactly 2 explanations:\n  \t  ((t+2) div 3, 0|1)  and  ((t+4) div 3, 2)\n  \tIn other words, always one surprise option and one normal option.\n  \tThe surprise option can have a result one higher than the normal one or\n  \tequal to it.\n  \t'''\n  \n  \tprint '  ',\n  \tfor b in xrange(0, 11):\n  \t\tprint 'b=%d' % b,\n  \tprint\n  \tfor total in xrange(0, 31):\n  \t\tprint '%2d' % total,\n  \t\tfor b in xrange(0, 11):\n  \t\t\ts = '0' if total == b * 3 else '.'\n  \t\t\ts += '1' if b >= 1 and b * 3 - 2 <= total <= b * 3 - 1 else '.'\n  \t\t\ts += '2' if b >= 2 and b * 3 - 4 <= total <= b * 3 - 2 else '.'\n  \t\t\tprint s,\n  \t\tprint\n  \n  \n  def solve(totals, surprises, points):\n  \tcountCertain = 0\n  \tcountSurprise = 0\n  \tfor total in totals:\n  \t\tif (total + 2) / 3 >= points:\n  \t\t\tcountCertain += 1\n  \t\telif 2 <= total <= 28 and (total + 4) / 3 >= points:\n  \t\t\tcountSurprise += 1\n  \t\telse:\n  \t\t\tpass\n  \n  \n  \treturn countCertain + min(countSurprise, surprises)\n  \n  if __name__ == '__main__':\n  \tinp = open(FILE_NAME_BASE + '.in.txt', 'r')\n  \tnumCases = int(inp.readline())\n  \tif NUM_PROCESSES == 0:\n  \t\tresults = [\n  \t\t\tsolve(*parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \telse:\n  \t\tpool = Pool(NUM_PROCESSES)\n  \t\tresults = [\n  \t\t\tpool.apply_async(solve, parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \tinp.close()\n  \tout = open(FILE_NAME_BASE + '.out.txt', 'w')\n  \tfor case, result in enumerate(results):\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n  \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n  \t\tout.flush()\n  \tout.close()\n", "substitutes": {"FILE_NAME_BASE": ["FILE_NAME_OBRC", "FILE_NAME_TBASE", "FILE_NAME_WBASE", "FILE_NAME_TBETA", "FILE_NAME_WBBS"], "NUM_PROCESSES": ["NUM_PRCCESSes", "NUM_PRCCITERS", "NUM_PROCECes", "NUM_PROCOSSIONS", "NUM_PRECECes"], "inp": [" inz", "insh", "inf", "inpa", "inpl"], "data": ["aa", "text", "reader", "features", "lines"], "x": ["lo", "ex", "l", "z", "example"], "dancers": ["tances", "Dances", "ad100", "tiders", "Diders"], "surprises": ["useprising", "typrises", "interplex", "urprising", "transprises"], "points": ["windows", "tests", "stats", "breaks", "downs"], "totals": ["totingals", "tigrals", "totsases", "tigrases", "towes"], "b": ["l", "abb", "t", "i", "rb"], "total": ["mm", "t", "i", "volume", "scale"], "s": ["t", "i", "statement", "stats", "us"], "countCertain": ["countGeneral", "sumEverything", " countcertain", "sumGeneral", "CountCertain"], "countSurprise": ["countSusception", "countsurprises", " countsurprises", " countSurprises", " countSurvey"], "results": ["versions", "includes", "features", "values", "fires"], "_": [" the", "Id", "ing", "___", "n"], "pool": ["graph", "wa", "rain", "pl", "max"], "out": ["log", "ex", "image", "exp", "exec"], "case": ["step", "section", "Case", "config", "answer"], "result": ["section", "summary", "text", "page", "desc"], "value": ["format", "section", "answer", "values", "example"]}}
{"code": " \n  def isPalindrome(n):\n      cn=str(n)\n      return (cn==cn[::-1])\n  \n  palinSqrt=[0, 1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002]\n  \n  \n  \n              \n          \n          \n  \n  \n  \n  def Solve(a,b):\n      num=0\n      for p in palinSqrt:\n          if a<= p**2 <=b: num+=1\n      return num\n  \n  \n  \n  def parse(infile):\n      a,b=map(int, infile.readline().split() )\n      return a,b\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n      outfile=open(sys.argv[1].rstrip('.in')+'.out','w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  class Categorizer(dict):\n      def __init__(self,thelist,transform,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.AddList(thelist)\n          self.trunc=trunc\n      def AddList(self,thelist):\n          for item in thelist: self.Add( item )\n      def Add(self,object):\n          cat=self.transform( object )\n          if type(cat) is float:\n              cat=round(cat,trunc)\n          if self.has_key(cat):\n              self[cat].append( object )\n          else:\n              self[cat]=[object]\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-len(x[1]))\n          total=0\n          for i in items: total+=len(i[1])\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(len(val))) for val in self.itervalues() )\n          formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n          for key,count in items[0:n]:\n              print formatter.format(key,len(count),\n                                     (\"%.2f\"%(len(count)*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=[]\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=len(self[key])\n              avg+=len(self[key])*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=len(self[key])\n              stddev += len(self[key]) * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n          tot=0\n          for value in self.itervalues(): tot+=len(value)\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += len(self[key])\n             if nCount>tot/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: len(x[1]))[0]\n  \n  \n  \n  \n  class Counter(dict):\n      def __init__(self,thelist,transform=None,trunc=2):\n          dict.__init__(self)\n          self.transform=transform\n          self.trunc=trunc\n          self.AddList(thelist)\n      def AddList(self,thelist):\n          if self.transform is not None:\n              for item in thelist: self.Add( self.transform(item) )\n          else:\n              for item in thelist: self.Add( item )            \n      def Add(self,object):\n          if type(object) is float:\n              object=round(object,self.trunc)\n          if self.has_key(object):\n              self[object]+=1\n          else:\n              self[object]=1\n      def PrintRanking(self,n=None):\n          if n is None: n=len(self)\n          items=self.items()\n          items.sort(key=lambda x:-x[1])\n          total=0\n          for i in items: total+=i[1]\n          maxkey=max( len(str(key)) for key in self.iterkeys() )\n          maxval=max( len(str(val)) for val in self.itervalues() )\n          formatter=\"{0:<\"+str(maxkey)+\"} {1:>\"+str(maxval)+\"}    {2}\"\n          for key,count in items[0:n]:\n              print formatter.format(key,count, (\"%.2f\"%(count*100.0/total))+'%')\n      def Combine(self,newdict):\n          newkeys=newdict.keys()\n          for key in newkeys:\n             if not type(newdict[key])==int:\n                raise TypeError('passed object is not a counter')\n          for key in newkeys:\n             if not self.has_key(key): self[key]=0\n             self[key] += newdict[key]\n      def Avg(self):\n          avg=0.0\n          ntot=0\n          for key in self.keys():\n              ntot+=self[key]\n              avg+=self[key]*key\n          return avg/(1.0*ntot)\n      def StdDev(self):\n          avg=self.Avg()\n          ntot=0\n          stddev=0.0\n          for key in self.iterkeys():\n              ntot+=self[key]\n              stddev += self[key] * ( (key-avg)**2)\n          return stddev/(1.0*ntot)\n      def Median(self):\n   \ttotal=sum(self.values())\n          keys=self.keys()\n          keys.sort()\n          nCount=0\n          for key in keys:\n             nCount += self[key]\n             if nCount>total/2: return key\n      def Mode(self):\n          return max(self.iteritems(), key=lambda x: x[1])[0]\n  \n  \n  def gen_primes():\n      \"\"\" Generate an infinite sequence of prime numbers.\n      \"\"\"\n      D = {}  \n      q = 2  \n  \n      while True:\n          if q not in D:\n              yield q        \n              D[q * q] = [q]\n          else:\n              for p in D[q]:\n                  D.setdefault(p + q, []).append(p)\n              del D[q]\n  \n          q += 1\n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n", "substitutes": {"n": ["l", "j", "z", "t", "r"], "cn": ["css", "dc", "pn", "cc", "cin"], "palinSqrt": ["palinSQrf", "palinEsQrot", "palinPsQrot", "palinEsqrt", "palinPsqrt"], "a": ["aa", "ai", "l", "wa", "ab"], "b": ["bar", "xb", "l", "j", "ab"], "num": ["dim", "all", "lam", "int", "init"], "p": ["P", "opt", "l", "aa", "ip"], "infile": ["INFile", "INfolder", "inline", "incfile", "outfolder"], "self": ["exc", "co", "l", "hw", "pp"], "fname": ["filefile", "FName", "lfName", "filenames", " ffile"], "NumCases": ["NumChodes", "numAcodes", "numChase", "NumChAS", "NumAcodes"], "caseNum": ["aseNum", " casenum", " caseNumber", "CaseNum", "testnum"], "args": ["loc", "pres", "all", "stats", "int"], "myCases": ["MyCases", "myTats", "myTased", "myCats", "MyAcases"], "outfile": [" outFile", "tempfile", " outfilename", "OutFile", "inline"], "iCase": ["iChance", "iCondition", "jiTest", "jiChance", "uProduct"], "answer": ["address", "feed", "abc", "all", "name"], "thelist": ["theirl", "thetable", " theline", " Thel", "THEbatch"], "transform": ["format", "shape", "text", "size", "target"], "trunc": ["Trunc", "Tracer", "traction", "theunc", "theraction"], "item": ["link", "new", "anything", "page", "obj"], "object": ["config", "text", "obj", "comment", "server"]}}
{"code": " \n  infile=open(sys.argv[1],'r')\n  \n  NumCases=int(infile.readline())\n  \n  for iCase in xrange(NumCases):\n      line=[ int(i) for i in infile.readline().split() ]\n  \n      n=line.pop(0)\n      s=line.pop(0)\n      p=line.pop(0)\n  \n      scores=line\n      assert(len(scores))==n\n  \n      imax=0\n      isurprise=0\n  \n      for score in scores:\n          if score<p: continue\n          if score<3*p-4:\n              pass\n          elif 3*p-2>score>=3*p-4:\n              isurprise+=1\n          else:\n              imax+=1\n  \n      print 'Case #'+str(iCase+1)+':',imax+min(isurprise,s)\n  \n", "substitutes": {"infile": ["innhandle", "inline", "incfile", "outfolder", "infolder"], "NumCases": ["numcased", "NumCasses", "numScase", "NumCased", "numScased"], "iCase": ["iLoop", "iPath", "cCase", " iCourse", "iNumber"], "line": ["l", "inline", "chain", "live", "all"], "i": ["l", "ai", "ip", "j", "z"], "n": ["l", "un", "j", "size", "z"], "s": ["small", "l", "j", "sec", "size"], "p": ["P", "l", "ip", "j", "z"], "scores": ["expores", "SCores", "SCases", "Scores", "escences"], "imax": ["imAX", "IMagic", "imagic", "imaxy", "iamake"], "isurprise": [" isurcise", "issurantine", "isuperprise", "issurprise", "isurergest"], "score": [" result", "path", "int", "ne", "name"]}}
{"code": " \n  lines = sys.stdin.readlines()\n  def parseCase(lines):\n      dims = map(int,lines[0].split(\" \"))\n      return 1, dims\n  \n  def getCases(lines):\n      i =0\n      while i < len(lines):\n          lines_used, case = parseCase(lines[i:])\n          i += lines_used\n          yield case\n  \n  \n  fands = []\n  phash = {1:True}\n  def isPalindrome(p):\n      return p in phash\n  \n  def test(p):\n      square = p**.5\n      return square == int(square) and isPalindrome(int(square))\n  \n  for i in range(1,10**5):\n      if i > 9:\n          small_p = int(i * 10 ** int(math.log(i,10)) + int(\"\".join(reversed(str(i)[:-1]))))\n      else: small_p = i\n      phash[small_p]= test(small_p)\n      if phash[small_p]: fands.append(small_p)\n      big_p = int(i * 10 ** int(math.log(i,10)+1) + int(\"\".join(reversed(str(i)))))\n      phash[big_p] = test(big_p)\n      if phash[big_p]: fands.append(big_p)\n  cNum =0\n  \n  for c in getCases(lines[1:]):\n      cNum += 1\n      answer = []\n      for i in fands:\n          if i < c[0]: continue\n          if i > c[1]: break\n          if phash[i]: answer.append(i)\n      answer = str(len(answer))\n      print \"Case #%d: %s\" % ( cNum, answer)\n  \n  \n      \n  \n  \n", "substitutes": {"lines": ["l", "sticks", "inline", "b", "tests"], "dims": [" dim", "Dim", "drims", "Ddim", " dums"], "i": ["l", "alpha", "iw", "ti", "t"], "lines_used": ["lines_created", "cases_needed", "cases_created", "lines_needed", " lines_use"], "case": ["mate", "section", "Case", "config", "text"], "fands": ["fcanders", "fanded", "panders", "cants", " faps"], "phash": ["Phap", "phashed", "Phashes", "ghashes", "phah"], "p": ["P", "l", "ip", "j", "page"], "square": ["piece", "alpha", "right", "shift", "scale"], "small_p": ["small_data", "small_ps", "real_p", "smalliandata", "small54s"], "big_p": ["big_wp", "bigPp", "big25c", "significant25op", "big25i"], "cNum": ["CNum", "fnum", "pNum", " cNo", " cnum"], "c": ["l", "z", "t", "cc", "u"], "answer": ["address", " result", "name", " explanation", "area"]}}
{"code": " \"\"\"\n  GCJ framework (gcj.fw.framework)\n   - Command Line and Package interface\n   - output redirection\n   - parsing case input\n   - executing problem code against cases\n   - testing framework\n  \"\"\"\n  \n  class Framework(object):\n      class Case(object):\n          def __init__(self, caseNumber, caseData=None):\n              self.number = caseNumber\n              self.data = caseData\n              self.result = None\n      \n          @classmethod\n          def parser(cls, f_in):\n              pass\n      \n          def run(self):\n              pass\n      \n          def execute(self, f_in=None):\n              if self.data is None:\n                  self.data = self.parser(f_in)\n              self.result = self.run(**self.data)\n      \n          def __str__(self):\n              return \"Case #%d: %s\" % (self.number, self.result)\n      \n      \n      class Result(object):\n          def __init__(self, resultData):\n              self.data = resultData\n      \n          def __str__(self):\n              return str(self.ata)\n  \n      def __init__(self, f_in, f_out):\n          sys.stdout = f_out\n          self.f_in = f_in if f_in is not None else sys.stdin\n  \n      def run(self):\n          nCases = int(self.f_in.readline().strip())\n          for num in xrange(nCases):\n              case = type(self).Case(num+1)\n              case.execute( f_in=self.f_in)\n              print case\n  \n  \n      @classmethod\n      def __main__(cls):\n          f_in = sys.stdin\n          if len(sys.argv) > 1:\n              if sys.argv[1] == \"-t\":\n                  unittest.main()\n                  sys.exit()\n              f_in = open(sys.argv[1])\n          framework = cls(f_in, sys.stdout)\n          framework.run()\n      \n  class Test(unittest.TestCase):\n      cases = []\n      case = None\n      c=[]\n      \n      def setUp(self):\n          self.c = []\n          self.defineCases()\n          counter = 1\n          self.cases = []\n          for c in self.c:\n              case = self.case(counter)\n              case.data = case.parser(StringIO.StringIO(c[0]))\n              self.cases.append( [case, c[1]])\n      \n      def defineCases(self):\n          pass\n      \n      def tearDown(self):\n          pass \n  \n      def test_Name(self):\n          self.setUp()\n          for case in self.cases:\n              print case[0].data, case[1]\n              case[0].execute()\n              self.assertEqual(case[0].result, case[1])\n  '''\n  Created on Apr 8, 2012\n  \n  @author: Joe\n  '''\n  \n  \n  class B(Framework):\n      class Case(Framework.Case):\n          def parser(self, fh):\n              args = map(int, fh.readline().strip().split(\" \"))\n              N,S,p = args[:3]\n              scores = args[3:] \n              return {\"N\":N,\"S\":S,\"p\":p,\"scores\":scores}\n          \n          def run(self, N=None,S=None,p=None,scores=None):\n              ret = 0\n              surps = 0\n              for score in scores:\n                  if p > 0 and score == 0: continue\n                  if 3*p-2 <= score:\n                      ret += 1\n                  else:\n                      if 3*p - 4 <= score:\n                          surps += 1\n              return str(ret + min(surps,S))\n              \n  class Test(Test):\n      def defineCases(self):\n          self.case = B.Case\n          self.c = [\n                    [\"3 1 5 15 13 11\",\"3\"],\n                    [\"3 0 8 23 22 21\",\"2\"],\n                    [\"2 1 1 8 0\",\"1\"],\n                    [\"6 2 8 29 20 8 18 18 21\",\"3\"],\n                    [\"1 1 1 1\", \"1\"]\n                    ]\n  \n  if __name__ == \"__main__\":\n      B.__main__()\n      \n", "substitutes": {"self": ["exc", "co", "l", "hw", "progress"], "caseNumber": ["aseNum", "CaseNum", "catchNumber", " caseNo", "aseNumbers"], "caseData": [" casedata", " caseInfo", "catchdata", "trialType", " caseType"], "number": ["note", "address", "division", "size", "database"], "data": ["alpha", "key", "input", "Data", "connection"], "result": ["format", "answer", "obj", "database", "target"], "cls": ["pls", "methods", "CLs", "Clp", "Clses"], "f_in": ["f_bin", "fockIN", "f_In", "F_out", "f_IN"], "resultData": ["exampleData", "responseDat", "errorBody", " resultString", "errorInfo"], "f_out": ["f2Out", "p_again", "f64again", "f2again", "f_again"], "sys": ["exc", "wcs", "hw", "windows", "process"], "stdout": ["stdouts", "STDOut", "stdOut", "STDIN", "streamout"], "nCases": [" nScased", "ncases", "nChakes", " nCased", "nClaces"], "num": ["exp", "tri", "new", "i", "u"], "case": ["address", "key", "i", "sea", "ce"], "framework": ["support", "config", "section", "browser", "example"], "cases": ["ceptions", "ces", "config", "Case", "features"], "c": ["exc", "l", "tc", "desc", "i"], "counter": ["step", "cur", "condition", "exp", "card"]}}
{"code": "def is_palindrome(s):\n  \tif s == '':\n  \t\treturn True\n  \telse:\n  \t\tif (ord(s[0]) - ord(s[len(s)-1])) == 0:\n  \t\t\treturn is_palindrome(s[1 : len(s) - 1])\n  \t\telse:\n  \t\t\treturn False\n  \n  all_fair_and_square = set()\n  for i in range(10000):\n  \torig = str(i)\n  \trev = orig[::-1]\n  \n  \tpalin = orig + rev\n  \tintpalin = int(palin)\n  \tif is_palindrome(str(intpalin * intpalin)):\n  \t\tall_fair_and_square.add(intpalin * intpalin)\n  \n  \tpalin = orig[:-1] + rev\n  \tintpalin = int(palin)\n  \tif is_palindrome(str(intpalin * intpalin)):\n  \t\tall_fair_and_square.add(intpalin * intpalin)\n  \t\n  \n  \n  t = int(sys.stdin.readline().strip())\n  for ii in range(t):\n  \tline = sys.stdin.readline().strip().split()\n  \ta = int(line[0])\n  \tb = int(line[1])\n  \tcount = 0\n  \tfor num in all_fair_and_square:\n  \t\tif (num >= a) and (num <= b):\n  \t\t\tcount += 1\n  \tprint \"Case #\" + str(ii + 1) + \": \" + str(count)\n  \n", "substitutes": {"s": ["l", "tests", "ows", "bis", "o"], "all_fair_and_square": ["all_fair_with_private", "all_fair_and_private", "all_fair_and_Square", "all_fair_with_square", "all_fair_and_quad"], "i": ["ai", "image", "ip", "ir", "j"], "orig": ["exc", "pp", "alpha", "ref", "rb"], "rev": ["cur", "exp", "reg", "inter", "ren"], "palin": ["spolin", "pelin", " pelin", "spatin", "pillin"], "intpalin": ["intpaban", "intpsinning", "ntpparin", "intfarin", "ntpelin"], "t": ["l", "tip", "tc", "z", "size"], "ii": ["II", "note", "ai", "ci", "z"], "line": ["strip", "log", "l", "section", "le"], "a": ["aa", "ai", "l", "wa", "sta"], "b": ["xb", "l", "aa", "j", "ab"], "count": ["note", "log", "size", "z", "case"], "num": ["text", "tri", "nov", "iter", "u"]}}
{"code": " \n  t = int(sys.stdin.readline())\n  for i in range(t):\n  \tinputline = sys.stdin.readline().strip()\n  \tinputparams = inputline.split()\n  \n  \tn = int(inputparams[0])\n  \ts = int(inputparams[1])\n  \tp = int(inputparams[2])\n  \tvalidcount = 0\n  \tsurprisingcount = 0\n  \tfor j in range(n):\n  \t\tscore = int(inputparams[3 + j])\n  \t\tif (p + (p - 1) * 2) <= score:\n  \t\t\tvalidcount += 1\n  \t\telif ((p + (p - 2) * 2) <= score) and (p <= score):\n  \t\t\tsurprisingcount += 1\n  \n  \tprint \"Case #%d: %d\" % (i + 1, validcount + min(surprisingcount, s))\n", "substitutes": {"t": ["l", "tc", "z", "target", "u"], "i": ["lo", "l", "ip", "ij", "z"], "inputline": ["outputline", "inputpage", " inputlin", "inputlin", " inputfile"], "inputparams": ["outputline", "paramparams", "outputshape", "latline", "Inputpar"], "n": ["l", "size", "z", "u", "count"], "s": ["l", "features", "size", "z", "jobs"], "p": ["P", "l", "ip", "z", "per"], "validcount": ["validscore", " validsum", "totallength", "validCount", " validscore"], "surprisingcount": ["syprisingCount", "SurpriseCount", "Surprisec", "surprisecount", "surprisinglysum"], "j": ["bj", "note", "J", "adj", "l"], "score": ["exp", "vec", "size", "z", "case"]}}
{"code": " \n  \n  fairsquares = []\n  \n  \n  def read_fairsquares():\n      global fairsquares\n      f = open('fairsquares.txt')\n      for x in f:\n          fairsquares.append(int(x.strip()))\n  \n  \n  def count_less_than(A):\n      left = 0\n      right = len(fairsquares)\n      while left < right:\n          middle = (left + right) // 2\n          if fairsquares[middle] < A:\n              left = middle + 1\n          else:\n              right = middle\n      return left\n  \n  \n  def compute(A, B):\n      count_b = count_less_than(B + 1)\n      count_a = count_less_than(A)\n      return count_b - count_a\n  \n  \n  def parse():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  \n  if __name__ == \"__main__\":\n      read_fairsquares()\n      T = int(sys.stdin.readline().strip())\n      count = 1\n      part = 0\n      if len(sys.argv) == 3:\n          part = int(sys.argv[1])\n          count = int(sys.argv[2])\n      for i in xrange(T):\n          data = parse()\n          if i * count >= part * T and i * count < (part + 1) * T:\n              result = compute(*data)\n              print \"Case #%d: %s\" % (i + 1, result)\n", "substitutes": {"fairsquares": ["fairsquearing", "fairsqueakes", "fairsquores", "farmssquares", "fairsquare"], "f": ["l", "config", "ff", "rf", "zip"], "x": ["xb", "ex", "config", "l", "exp"], "A": ["API", "D", "alpha", "Ma", "b"], "left": ["l", "path", "all", "list", "mid"], "right": ["rest", "rew", "rank", "round", "through"], "middle": ["quarter", "shift", "nr", "grid", "mid"], "B": ["P", "WB", "DB", "Z", " b"], "count_b": ["count_l", "count67u", "count67B", "count67l", " count_B"], "count_a": ["count_A", "countJA", " count_A", "count_c", " count_f"], "T": ["step", "P", "section", "Q", "DT"], "count": ["P", "size", "key", "t", "error"], "part": ["quarter", "art", "t", "key", "b"], "i": ["l", "key", "ti", "t", "ih"], "data": ["step", "config", "format", "size", "database"], "result": ["new", "obj", "page", "final", "complete"]}}
{"code": " \n  \n  if __name__ == \"__main__\":\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          values = map(int, sys.stdin.readline().strip().split(' '))\n          _N, S, p = values[0:3]\n          t = values[3:]\n          min_normal = p + 2 * max(0, p - 1)\n          min_surprising = p + 2 * max(0, p - 2)\n          cnt_normal = len(filter(lambda x : x >= min_normal, t))\n          cnt_surprising = len(filter(lambda x : x >= min_surprising, t)) - cnt_normal\n          print \"Case #%d: %s\" % (i + 1, cnt_normal + min(cnt_surprising, S))\n", "substitutes": {"T": ["P", "Q", "DT", "TS", "Z"], "i": ["l", "ip", "j", "z", "chi"], "values": ["versions", "VAL", "lines", "keys", "size"], "_N": ["_n", "_C"], "S": ["P", "Q", "J", "sq", "Z"], "p": ["P", "l", "lp", "ip", "j"], "t": ["P", "l", "j", "z", "ti"], "min_normal": ["minernorm", "min_neutral", "max_random", "min48normal", "max_fine"], "min_surprising": ["min_urprisingly", "min_urprise", "min_superprising", "min_generiosity", "min_generprise"], "cnt_normal": ["cnt_regular", "cst_norm", "cnt_total", "cnt10norm", "cnt10normal"], "cnt_surprising": ["cnt_purprising", "cnt_purprise", "cnt_surprise", "cnt_sertaining", "cnt_Surining"]}}
{"code": " \n  def get_generators_up_to_length_n(n):\n      generators = []\n      for ii in range(1, n + 1):\n          generators += get_generators_length_n(ii)\n      return generators        \n  \n  def get_generators_length_n(length):\n      if length % 2 == 0: return get_even_generators_length_n(length)\n      else: return get_odd_generators_length_n(length)\n  \n  def get_odd_generators_length_n(length):\n      if length == 1: return [1, 2, 3]\n      else: \n          n = length / 2\n          generators = []\n          for ii in range(min(n, 4)):\n              for comb in itertools.combinations(range(1, n), ii):\n                  first_half = [\"1\"] + [\"0\"] * (n-1)\n                  for jj in comb:\n                      first_half[jj] = \"1\"\n                  second_half = list(first_half)\n                  second_half.reverse()\n                  palin = first_half + [\"0\"] + second_half\n                  generators.append(int(\"\".join([elem for elem in palin])))\n                  palin[n] = \"1\"\n                  generators.append(int(\"\".join([elem for elem in palin])))\n                  if ii <= 1:\n                      palin[n] = \"2\"\n                      generators.append(int(\"\".join([elem for elem in palin])))\n          generators.append(int(\"\".join([elem for elem in ([\"2\"] + [\"0\"] * (n - 1) + [\"0\"] + [\"0\"] * (n - 1) + [\"2\"])])))\n          generators.append(int(\"\".join([elem for elem in ([\"2\"] + [\"0\"] * (n - 1) + [\"1\"] + [\"0\"] * (n - 1) + [\"2\"])])))\n          generators.sort()\n          return generators\n  \n  def get_even_generators_length_n(length):\n      if length == 2: return [11, 22]\n      n = length / 2\n      generators = []\n      for ii in range(min(n, 4)):\n          for comb in itertools.combinations(range(1, n), ii):\n              first_half = [\"1\"] + [\"0\"] * (n-1)\n              for jj in comb:\n                  first_half[jj] = \"1\"\n              second_half = list(first_half)\n              second_half.reverse()\n              palin = first_half + second_half\n              generators.append(int(\"\".join([elem for elem in palin])))\n      generators.append(int(\"\".join([elem for elem in ([\"2\"] + [\"0\"] * (length - 2) + [\"2\"])])))\n      generators.sort()\n      return generators\n  \n  def is_palin(num):\n      string = str(num)\n      length = len(string)\n      ii = 0\n      while ii < length/2:\n          if string[ii] != string[-(1+ii)]:\n              return False\n          ii += 1\n      return True\n  \n  def gen_fair_and_squares(upper_limit):\n      fair_and_squares = []\n      for ii in range(1, upper_limit + 1):\n          if (is_palin(ii) and is_palin(ii*ii)):\n              fair_and_squares.append(ii)\n      return fair_and_squares\n  \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  gens = get_generators_up_to_length_n(60)\n  squares = map(lambda x: x*x, gens)\n  \n  for t in range(T):\n      A, B = map(int, f.readline().strip().split())\n      total = 0\n      for elem in squares:\n          assert(is_palin(elem))\n          if elem >= A and elem <= B: total += 1\n          if elem > B:\n              break\n  \n      print \"Case #%d:\" % (t + 1), total\n", "substitutes": {"n": ["l", "i", "b", "ne", "init"], "generators": ["Generations", "operator", "genners", "generumers", "iterations"], "ii": ["l", "iw", "i", "ti", "fi"], "length": ["address", "l", "character", "loc", "path"], "comb": ["opt", "union", "exp", " combo", "chi"], "first_half": ["First_quarter", "first_dim", "first_slave", " first_slave", "firstFhalf"], "jj": ["bj", "note", "J", "adj", "uj"], "second_half": ["secondOquarter", " second_name", "second_part", "second_name", "second_size"], "palin": ["harin", "spolin", "pealin", "pillin", "halan"], "elem": ["gelev", "Elee", " elete", "eelee", "pelev"]}}
{"code": " \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for t in range(T):\n      temp = map(int, f.readline().split())\n      N = temp[0]\n      S = temp[1]\n      p = temp[2]\n      scores = temp[3:]\n      non_surprising_scores = len(filter(lambda x: x >= (3*p-2), scores))\n      if (p<=1):\n          surprising_scores = 0\n      else:\n          surprising_scores = len(filter(lambda x: (x >= (3*p-4) and x < (3*p-2)), scores))\n      num_scores = non_surprising_scores + min(surprising_scores, S)   \n      print \"Case #%d:\" % (t + 1), num_scores\n", "substitutes": {"f": ["l", "ff", "folder", "z", "feed"], "T": ["P", "Q", "J", "DT", "TS"], "t": ["P", "l", "j", "z", "i"], "temp": ["tc", "i", "loc", "input", "int"], "N": ["P", "Q", "J", "size", "Z"], "S": ["P", "Q", "J", "size", "Z"], "p": ["P", "l", "ip", "j", "z"], "scores": ["cores", " scorer", "SCores", "secores", "Scores"], "non_surprising_scores": ["non_surprising_missores", "non_surprising_scors", "non_surprising_Scores", "non_surprising_Scatters", "non_surprising_missore"], "surprising_scores": ["surprising_acores", "surprising_qureads", "surprising_acourses", "surprising_passurs", "surprising_suffores"], "num_scores": ["num_accenses", "num_macorer", "num_ancurs", "num_Scored", "num_accore"]}}
{"code": " \n  \n  \t\t\n  \t\n  def isPalindrome(S):\n  \ts = str(S) #so I dont need to make sure its a string\n  \tfor i in range(len(s)//2):\n  \t\tif not s[i] == s[-1 - i]:\n  \t\t\treturn False\n  \treturn True\n  \n  def FairAndSquare(infile=\"C-small-attempt0.in\", outfile=\"C-small-attempt0.out\"):\n  \tinF = open(infile, 'r')\n  \toutF = open(outfile, 'w')\n  \t\n  \tfor t in range(1, int(inF.readline().strip()) + 1):\n  \t\ttemp = inF.readline().strip().split()\n  \t\tA = long(temp[0])\n  \t\tB = long(temp[1])\n  \t\tcount = long(0)\n  \t\t\n  \t\ti = long(math.ceil(math.sqrt(A)))\n  \t\tm = long(math.floor(math.sqrt(B)))\n  \t\twhile i <= m:\n  \t\t\tif isPalindrome(i):\n  \t\t\t\tif isPalindrome(i**2):\n  \t\t\t\t\tcount += 1\n  \t\t\ti += 1\n  \t\t\t\t\t\n  \t\toutF.write(\"Case #\" + str(t) + \": \" + str(count) + \"\n\")\n  \t\n  \tinF.close()\n  \toutF.close()\n  \t\n  \tf = open(outfile, 'r')\n  \tprint f.read()\n  \tf.close()\n  \t\n  \t\n  if __name__ == \"__main__\":\n      FairAndSquare()\n", "substitutes": {"S": ["P", "TS", "SM", "Sample", "H"], "s": ["l", "ts", "lines", "services", "ins"], "i": ["l", "ti", "ih", "b", "qi"], "infile": ["Inbase", "inline", "Infile", "inf", " inbase"], "outfile": [" outFile", " outfilename", "OutFile", "inline", "outfolder"], "inF": ["INFile", " inFD", "inf", "INF", "INf"], "outF": ["OutF", " outFile", "againF", "OutFile", "inE"], "t": ["note", "l", "tc", "j", "z"], "temp": ["l", "tem", "margin", "format", "tc"], "A": ["P", "Ca", "API", "Na", "As"], "B": ["Q", "P", "WB", "QB", "DB"], "count": ["log", "l", "note", "j", "size"], "m": ["l", "sm", "mm", "margin", "size"], "f": ["l", "ff", "j", "uf", "z"]}}
{"code": "data_dict = {}\n  init = False\n  \n  \n  def partB(infile=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/input3.txt\",\\\n                outfile=\"C:/Users/Jeffrey/Dropbox/Google Code Jam/2011/Qualifiers/B/output.txt\"):\n      \n      linesA = []\n      for line in open(infile, 'r'):\n          linesA.append(line.strip())\n  \n      outA = []\n          \n      T = int(linesA[0])\n      for i in range(1, 1 + T):\n          caseA = linesA[i].split()\n          N = int(caseA[0])\n          S = int(caseA[1])\n          P = int(caseA[2])\n          \n          over_norm = 0\n          over_supr = 0\n          \n          for t in [int(conv) for conv in caseA[3:3+N]]:\n              if data_dict[t][0] >= P:\n                  over_norm += 1\n              elif data_dict[t][1] >= P:\n                  over_supr += 1\n          \n          outA.append(over_norm + min(over_supr, S))\n              \n              \n          \n      \n      out = open(outfile, 'w')\n      print \"\nOUTPUT\"\n      for i in range(1, 1 + T):\n          if i != 1:\n              out.write(\"\n\")\n          print \"Case #\" + str(i) + \": \" +str(outA[i-1])\n          out.write(\"Case #\" + str(i) + \": \" +str(outA[i-1]))\n      out.close()\n  \n  def dict_helper(total, depth=0, lowest=10):\n      pass\n  \n  def build_dict():\n      for i in range(31):\n          fullA = []\n          maxN = 0\n          maxS = 0\n          print str(i) + \": \"\n          for a1 in range(0,11):\n              for a2 in range(0,11):\n                  for a3 in range(0,11):\n                      if (a1 + a2 + a3 == i) and (max(a1,a2,a3)-min(a1,a2,a3) <3):\n                          fullA.append((a1,a2,a3))\n                          \n                          print \"\\t\", fullA[-1],\n                          if max(a1,a2,a3)-min(a1,a2,a3) == 2:\n                              print \"*\"\n                              maxS = max(maxN, max(a1,a2,a3))\n                          else:\n                              print\n                              maxN = max(maxN, max(a1,a2,a3))\n          data_dict[i]=[maxN, maxS]\n      init = True\n      \n  if __name__ == \"__main__\":\n      build_dict()\n      partB()\n", "substitutes": {"data_dict": ["data_ict", "input_list", "data__list", "input_df", "data_list"], "init": ["log", "fixed", "format", "config", "size"], "infile": ["infil", "outfil", "outfilename", "inf", "inputfilename"], "outfile": [" outFile", " outfilename", "newname", " outpath", "outfilename"], "linesA": ["linesa", "blocksAs", "blocksT", "inesA", "breaksAs"], "line": ["LINE", "log", "l", "section", "cell"], "outA": ["listC", "lineP", "caseAs", "listS", "lineAs"], "T": ["Q", "J", "DT", "TS", "Z"], "i": ["l", "alpha", "key", "ti", " I"], "caseA": ["dataP", " caseS", "caseS", "codea", "instanceA"], "N": ["Q", "J", "PIN", "Size", "D"], "S": ["Q", "J", "TS", "Z", "D"], "P": ["Q", "J", "PIN", "WP", "API"], "over_norm": ["over__orm", "over___normal", "over\u00b7loop", "hard_normal", "over_gl"], "over_supr": ["over_surrt", "over_suprl", "over_sqro", "over_pprar", "over_sqr"], "t": ["opt", "l", "j", "target", "unit"], "conv": ["Q", " trial", "cell", "det", "tri"], "out": ["log", "ex", "co", "image", "exp"], "total": ["size", "example", "desc", "complete", "iter"], "depth": ["format", "D", "case", "random", "iter"], "lowest": ["smallests", "smallEST", "lower", "older", "lowests"], "fullA": ["quickG", " fullB", "FullB", " fullG", "fullG"], "maxN": ["MaxC", "caseC", "MaxN", " maxP", " maxC"], "maxS": ["maxP", "MaxH", "MaxN", "tempP", " maxH"], "a1": ["aa5", "Aone", "ga3", "a01", "saone"], "a2": ["ga5", "atwo", "sa3", " atwo", "va1"], "a3": ["A4", "A3", "A2", " a83", " a15"]}}
{"code": "\"\"\"Usage:\n      X.py < X.in > X.out\n  \"\"\"\n  \n  def isqrt(x):\n      \"returns int(floor(sqrt(x))) using only integer math\"\n      assert x >= 0, 'Undefined %r' % locals()\n      n = int(x)\n      if n == 0:\n          return 0\n      a, b = divmod(n.bit_length(), 2)\n      x = 2**(a+b)\n      while True:\n          y = (x + n//x)//2\n          if y >= x:\n              return x\n          x = y\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, **ignore):\n      P = map(int, infile.next().split())\n      return locals()\n  \n  def solver(infile, testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      low = isqrt(P[0])\n      high = isqrt(P[1])+1\n  \n      def is_pal(n):\n          n = str(n)\n          for i in range(len(n)/2+1):\n              if n[i]!=n[len(n)-1-i]:\n                  return False\n          return True\n  \n      res = 0\n      for i in range(low, high+1):\n          if P[0]<=i*i<=P[1] and is_pal(i) and is_pal(i*i):\n              res += 1\n  \n      return 'Case #%s: %s\n' % (testcase, res)\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n", "substitutes": {"x": ["ex", "l", "input", "xx", "int"], "n": ["l", "ne", "ln", "zn", "name"], "a": ["l", "aa", "ai", "wa", "j"], "b": ["l", "aa", "j", "ab", "py"], "y": ["l", "j", "z", "yy", "py"], "infile": ["INile", "INFile", "inline", "instream", "insfile"], "testcase": ["Testtest", "Testclass", "trainCase", " testpath", "testsection"], "P": ["Q", "Price", "API", "D", "Ps"], "N": ["Q", "J", "Z", "D", "H"], "I": ["Q", "J", "Z", "D", "H"], "T": ["Q", "DT", "TS", "Z", "Ti"], "S": ["Q", "SF", "TS", "Ps", "H"], "C": ["Cu", "Ca", "D", "Code", "H"], "low": ["small", "lo", "l", "min", "size"], "high": ["maximum", "min", "null", "max", "rest"], "i": ["lo", "l", "ai", "ip", "j"], "res": ["reg", "es", "values", "ins", "complete"], "common": ["small", "union", "specific", "tc", "similar"], "t": ["l", "unt", "text", "tc", "z"]}}
{"code": "\"\"\"Usage:\n      X.py < X.in > X.out\n  \"\"\"\n  \n  \n  \n  class Solver(object):\n      cache = {}\n  \n      def __init__(self, infile, testcase):\n          self.testcase = testcase\n          self.P = P = map(int, infile.next().split())\n  \n      def init_cache(self):\n          if 'main' in self.cache:\n              return\n  \n      def solve(self):\n  \n          N, S, p = self.P[:3]\n          G = sorted(self.P[3:], reverse=True)\n  \n          r = 0\n          s = 0\n          for g in G:\n              if g >= 3 * p - 2 and g >= p:\n                  r += 1\n              elif g >= 3 * p - 4 and g >= p:\n                  if s == S:\n                      break\n                  r += 1\n                  s += 1\n  \n          return r\n  \n  \n  def main():\n      T = int(sys.stdin.next())\n      for t in xrange(T):\n          sys.stdout.write('Case #%s: %s\n' % (t + 1, Solver(sys.stdin, t).solve()))\n  \n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"cache": ["config", "l", "graph", "clear", "case"], "self": ["co", "disk", "ref", "connection", "static"], "infile": [" inclass", "INFile", " infilename", "Infile", "inputfilename"], "testcase": ["serverCase", "trainCase", " testpath", "testcases", "traincases"], "P": ["Q", "J", "PIN", "D", "TP"], "N": ["Q", "J", "Z", "D", "H"], "S": ["Q", "J", "Z", "D", "u"], "p": ["l", "j", "z", "pp", "py"], "G": ["J", "Q", "MG", "Gs", "D"], "r": ["l", "i", "rb", "b", "pr"], "s": ["rl", "l", " rs", "es", "j"], "g": ["l", "reg", "mg", "eg", "j"], "T": ["Q", "DT", "TS", "Z", "D"], "t": ["l", "tip", "unt", "tc", "j"]}}
{"code": " \n  def is_fair(n):\n      n = str(n)\n      for i in range(long(len(n) / 2)):\n          if n[i] != n[len(n) - i - 1]:\n              return False\n      return True\n  \n  def is_square_and_fair(n):\n      if not is_fair(n): return False\n      root = math.sqrt(n)\n      if root != math.floor(root): return False\n      if not is_fair(long(root)): return False\n      return True\n  \n  def process():\n      a, b = sys.stdin.readline().split()\n      a = long(a)\n      b = long(b)\n      \n      count = 0\n      for i in range(a, b + 1):\n          if is_square_and_fair(i): count = count + 1\n  \n      return count\n  \n  def main():\n  \n      count = int(sys.stdin.readline())\n      for index in range(count):\n          result = process()\n          print \"Case #%d: %s\" % (index + 1, result)\n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"n": ["log", "l", "j", "z", "t"], "i": ["ai", "l", "ip", "j", "z"], "root": ["size", "alpha", "null", "ow", "random"], "a": ["aa", "ai", "l", "wa", "sta"], "b": ["xb", "l", "aa", "j", "ab"], "count": ["key", "process", "false", "all", "int"], "index": ["condition", "page", "obj", "key", "out"], "result": ["summary", "page", "obj", "final", "error"]}}
{"code": " \n  \n  def calculate_max_score(scores_sum):\n      if scores_sum % 3 == 1:\n          max_score = (scores_sum + 2) / 3\n          return (max_score, max_score)\n      if scores_sum % 3 == 2:\n          max_score = (scores_sum + 1) / 3\n          return (max_score, max_score + 1)\n      max_score = scores_sum / 3\n      if max_score == 0:\n          return (0, 0)\n      return (max_score, max_score + 1)\n  \n  def find_max_dancers(s, p, *scores_sums):\n      dancers_count = 0\n      for scores_sum in scores_sums:\n          (normal_max, surprise_max) = calculate_max_score(scores_sum)\n          if normal_max >= p:\n              dancers_count = dancers_count + 1\n              continue\n          if surprise_max >= p and s > 0:\n              s = s - 1\n              dancers_count = dancers_count + 1\n              continue\n      return dancers_count\n  \n  def main():\n  \n      case_count = int(sys.stdin.readline())\n  \n      for case_index in range(1, case_count + 1):\n          line = sys.stdin.readline().strip().split(' ')\n          s = int(line[1])\n          p = int(line[2])\n          scores_sums = [int(scores_sum) for scores_sum in line[3:]]\n          print 'Case #%i: %s' % (case_index, find_max_dancers(s, p, *scores_sums))\n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"scores_sum": ["scores_average", "scores_max", "scores__min", "scores6sum", "scoresessession"], "max_score": ["max33call", "maxfulscale", "max48score", "max\u00b7score", "std_live"], "s": ["l", "i", "t", "b", "sa"], "p": ["P", "l", "ip", "j", "pm"], "dancers_count": ["dancers6count", "dores_sum", "dancers6sum", "ders__core", "ders__list"], "normal_max": [" normal_rank", "custom_total", "normalacmin", " normal_first", "normalacbox"], "surprise_max": ["surprise2max", "surprises_max", "surprises_min", "surprise2min", "surprising_max"], "case_count": ["casejindex", "cases_range", "casePrange", " case_total", " case_start"], "case_index": ["caseIDpos", "caseIDlabel", "case_label", "case__ind", " case_id"], "line": ["co", "l", "inline", "key", "shell"], "scores_sums": ["scores_nsessions", "scores_dum", "scores_dubs", "scores_summ", "scores_setsamples"]}}
{"code": "'''\n  Created on Apr 12, 2013\n  \n  @author: Moatasem\n  '''\n  \n  \n  \n  def isPalindrome(word):\n      isPalin=False\n      if(len(word)%2==0):\n          f_half=word[0:len(word)/2];\n          s_half=word[len(word)/2:len(word)][::-1]\n          if( f_half==s_half):\n              isPalin= True\n      else:\n          f_half=word[0:len(word)/2]\n          s_half=word[(len(word)/2)+1:len(word)][::-1]\n          if( f_half==s_half):\n              isPalin= True\n      return isPalin\n      \n  def getNumberOfFairAndSquare(range_):\n      start=range_[0]\n      end=range_[1]\n      count_=0\n      for i in range(start,end+1):\n          root=math.sqrt(i);\n          if(root.is_integer() and isPalindrome(str(int(root))) and isPalindrome(str(i))):\n              count_+=1\n      return count_\n          \n          \n      \n  \n  f_r = open('C.in',\"r\")\n  n_test=int(f_r.readline().strip()) \n  f_w = open(\"C.out\", \"w\")\n  for i in range(n_test):\n      range_ =map(int,f_r.readline().split())\n      result=getNumberOfFairAndSquare(range_)\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n  f_r.close()\n  f_w.close()\n", "substitutes": {"word": ["address", "color", "byte", "key", "way"], "isPalin": [" isMargout", " isMargsin", "isPalnin", "isHamnin", "isSchatin"], "f_half": ["fpsize", "f_right", " f_partial", "ssOsize", " f_both"], "s_half": [" s_part", "soyhalf", "s_pair", "s_far", "savehat"], "range_": [" range2", "range__", "ange2", "rangePool", "framePool"], "start": ["step", "l", "j", "min", "size"], "end": ["END", "ff", "open", "size", "z"], "count_": ["depth__", " count2", "list__", "count2", "depth2"], "i": ["l", "ti", " I", "b", "qi"], "root": ["roc", "ip", "alpha", "null", "ow"], "f_r": ["f24r", "f24ro", "f_right", "f_out", "f24sr"], "n_test": ["n_match", " n_match", " n__test", "n__trial", "N_match"], "f_w": ["f_raw", "f__l", "f7w", "f_out", "fockwa"], "result": ["answer", "example", "case", "error", "df"], "output_str": ["output_string", " output_string", "outputGstr", "Output_str", "outputablestress"]}}
{"code": "'''\n  Created on Apr 14, 2012\n  \n  @author: moatasem\n  '''\n  \n  \n  def isSurprising(t):\n      if(abs(t[0]-t[1])==2 or abs(t[2]-t[1])==2 or abs(t[0]-t[2])==2):\n          return True\n      else:\n          return False\n  \n  \n  def getAllTriplets(n):\n      h=[]\n      for i in xrange(11):\n          for j in xrange(i,11):\n              for  k in xrange(j,11):\n                  if(i+j+k==n and abs(i-j)<3 and abs(k-j)<3 and abs(i-k)<3):\n                      h.append((i,j,k))\n              \n      return  h\n  \n  def getInfo(p,total,S):\n      g= getAllTriplets(total)\n      if(S):\n          s_=len(g)\n          indcies=[]\n          for i in xrange (s_):\n              if(isSurprising(g[i])):\n                  indcies.append(i)\n          for i in xrange (len(indcies)):  \n              g.remove(g[indcies[i]])\n      equ=False\n      sur=False\n      sur_equ=False\n      for i in xrange(len(g)):\n          if(max(g[i])>=p):\n              if(isSurprising(g[i])):\n                  sur_equ=True\n              else:\n                  equ=True\n          elif(isSurprising(g[i])):\n                  sur=True\n      return sur_equ,equ,sur\n             \n  f = open(\"b_.in\", \"r\")\n  n=int(f.readline().strip())\n  for k  in xrange(n):\n      d=f.readline().strip()\n      googlers=[]\n      g=[int(i) for i in d.split(\" \")]\n      N=g[0]\n      S=g[1]\n      noSu=False\n      if(S==0):\n          noSu=True\n      p=g[2]\n      count=0\n      equ_count=0;\n      both_count=0;\n      sur_count=0;\n      first_count=0;\n      googlers=g[3:len(g)]\n      for o in xrange(N):\n          info=getInfo(p,googlers[o],noSu)\n          if(info[0]==True and info[1]==False and S<>0): #101 /100\n              count+=1\n              S-=1\n          elif(info[0]==True and info[1]==True):#110 / 111\n              first_count+=1\n          elif(info[1]==True and info[2]==True):#011\n              both_count+=1\n          elif(info[1]==True):#010\n              count+=1\n          elif(info[2]==True):#001\n              sur_count+=1\n      count+=first_count\n      if(S>0):\n          if(first_count>S):\n              S=0\n          elif(first_count <=S) :\n              S-=first_count\n              if(S>0):\n                   if(both_count>S):\n                      both_count-=S\n                      S=0\n                   else:\n                      both_count=0\n      count+=both_count\n      \n      print 'Case #'+str((k+1))+\": \"+str(count)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n      \n  \n", "substitutes": {"t": ["l", "unt", "z", "u", "r"], "n": ["l", "nv", "un", "cn", "z"], "h": ["l", "oh", "ssh", "z", "auth"], "i": ["l", "iw", "ti", "fi", "ih"], "j": ["ak", "J", "uj", "l", "ip"], "k": ["ak", "l", "kk", "z", "u"], "p": ["P", "l", "ip", "z", "per"], "total": ["mm", "ip", "sq", "size", "chi"], "S": ["P", "J", "Q", "D", "Sc"], "g": ["l", "graph", "b", "dr", "gc"], "s_": ["sDiv", " sDiv", "ns_", "states_", "ions_"], "indcies": ["ndcies", "innger", "ndcy", "infger", "Indcies"], "equ": ["cur", "aqu", "qu", "wh", "answer"], "sur": ["esc", "sea", "loc", "sa", "stream"], "sur_equ": ["Sur_qu", "sur_Equ", "Sur_Equ", "Sur_equ", "Sur_esc"], "f": ["exp", "ff", "fer", "fore", "page"], "d": ["l", "ld", "dc", "z", "vd"], "googlers": ["moogling", "googlasses", "moogglasses", "gonglings", "pooglr"], "N": ["P", "J", "Q", "size", "z"], "noSu": [" Nosu", "noneSu", "nosu", "noSl", "NOCs"], "count": ["size", "case", "iter", "error", "set"], "equ_count": [" equ_size", "equ_sum", " equ_sum", "equ_size"], "both_count": ["both_len", "two_counter", "two_cache", "both_counter", "bothaccount"], "sur_count": ["sur_sum", "equ_sum", "equ_length", "sur_weight", "equ_weight"], "first_count": ["sec_const", "sec_counter", "first_const", "first2const", "first64const"], "o": ["lo", "co", "l", "OO", "ji"], "info": ["ip", "size", "z", "obj", "Info"]}}
{"code": " \n  def isqrt(num):\n      return int(sqrt(num))\n  \n  def is_square(num):\n      return isqrt(num)**2 == num\n  \n  def is_palindrome(num):\n      return str(num) == \"\".join(reversed(str(num)))\n  \n  def is_fair_and_square(num):\n      return is_square(num) and is_palindrome(num) and is_palindrome(isqrt(num))\n  \n  def solve(A,B):\n      count = 0\n      for i in range(A,B+1):\n          if is_fair_and_square(i):\n              count += 1\n      return count\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          A,B = [int(x) for x in raw_input().split()]\n          print \"Case #%d: %d\" % (i, solve(A,B))\n          \n", "substitutes": {"num": ["abc", "input", "b", "inf", "all"], "A": ["API", "alpha", "D", "Ma", "Data"], "B": ["Q", " b", "D", "UB", "Other"], "count": ["cond", "add", "size", "case", "t"], "i": ["ai", "l", "ip", "j", "chi"], "T": ["P", "Q", "TS", "Z", "D"], "x": ["rex", "xb", "ex", "exp", "z"]}}
{"code": "def max_of_triplets(n):\n      a = n//3\n      if (n % 3) == 0:\n          if a == 0 : return (0,0)\n          return (a, a+1)\n      if (n % 3) == 1:\n          return (a+1, a+1)\n      if a == 9: return (10, 10)\n      return (a+1, a+2)\n  \n  def solve(scores, S, p):\n      t = 0\n      for s in scores:\n          a,b = max_of_triplets(s)\n          if a >= p:\n              t += 1\n          elif b >= p and S > 0:\n              t += 1\n              S -= 1\n      return t\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1, T+1):\n          nums = map(int, raw_input().strip().split())\n          N = nums[0]\n          S = nums[1]\n          p = nums[2]\n          scores = nums[3:]\n          if len(scores) != N:\n              print \"WTF\", i\n          print \"Case #%d: %d\" % (i, solve(scores, S, p))\n      \n", "substitutes": {"n": ["l", "un", "j", "size", "z"], "a": ["alpha", "art", "am", "au", "sa"], "scores": ["compens", "expores", " scorer", "squares", "SCores"], "S": ["Q", "D", "Sign", "Ps", "Sin"], "p": ["P", "l", "lp", "ip", "j"], "t": ["l", "j", "z", "null", "u"], "s": ["l", "es", "sq", "z", "size"], "b": ["l", "aa", "j", "ab", "z"], "T": ["P", "Q", "DT", "TS", "Z"], "i": ["P", "ai", "l", "ip", "j"], "nums": ["unubes", "ynums", "tums", " nrams", "cumbers"], "N": ["P", "Q", "J", "Size", "D"]}}
{"code": " \n  def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      A, B = read_integers()\n      A_root = int( ceil( sqrt( A ) ) )\n      B_root = int( floor( sqrt( B ) ) )\n      count = 0\n      for root in range( A_root, B_root + 1 ):\n          word = str( root )\n          if word == word[ : : -1 ]:\n              word = str( root*root )\n              if word == word[ : : -1 ]:\n                  count += 1\n      print 'Case #%i:' % ( t + 1 ), count\n", "substitutes": {"x": ["xb", "ex", " dx", "z", "i"], "T": ["P", "DT", "TIME", "Z", "D"], "t": ["l", "text", "j", "z", "unit"], "A": ["AR", "P", "Ca", "API", "Na"], "B": ["Q", "P", "J", "WB", "API"], "A_root": ["A_roots", " A_row", "A__core", "A__length", " A_length"], "B_root": ["B_bot", "b_root", "B67Root", " B_Root", "B_child"], "count": ["log", "add", "text", "size", "case"], "root": ["step", "division", "case", "key", "ow"], "word": ["byte", "tool", "key", "way", "right"]}}
{"code": "def read_line():\n      return raw_input().strip()\n  \n  def read_words():\n      return read_line().split()\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_words() ]\n  \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 ),\n      line = iter( read_integers() )\n      N = line.next()\n      S = line.next()\n      p = line.next()\n      t = sorted( line )\n      count = 0\n      while t and ( t[ -1 ] + 2 )/3 >= p:\n          t.pop()\n          count += 1\n      if p > 1:\n          while S and t and ( t[ -1 ] + 4 )/3 >= p:\n              t.pop()\n              S -= 1\n              count += 1\n      print count\n", "substitutes": {"x": ["xb", "ex", "l", " dx", "z"], "T": ["P", "Q", "DT", "TS", "Z"], "t": ["l", "i", "b", "ot", "int"], "line": ["l", "inline", "i", "ne", "id"], "N": ["P", "J", "Q", "Z", "D"], "S": ["P", "Q", "Na", "TS", "size"], "p": ["P", "l", "ip", "j", "per"], "count": ["P", "cond", "cur", "l", "new"]}}
{"code": " \n  def isPalindrome(x):\n      x = str(x)\n      if x[0] != x[-1]:\n          return 0\n      y = x[::-1]\n      if x == y:\n          return 1\n      return 0\n  \n  def generate():\n      digits = [str(x) for x in range(0,10)]\n      dplus = digits + [\"\"]\n  \n      for x in range(1,10):\n          y = x**2\n          if isPalindrome(y):\n              print y\n  \n      for x in range(1,10**4):\n          x = str(x)\n          y = x[::-1]\n          pals = [ int(x+z+y)**2 for z in dplus ]\n          for p in pals:\n              if isPalindrome(p):\n                  print p\n  \n  if __name__ == \"__main__\":\n      f = open( sys.argv[1] )\n      sqpals = np.array([int(l) for l in f])\n      sqpals.sort()\n      f.close()\n  \n      f = open( sys.argv[2] )\n      t = int(f.readline())\n      t = 1\n      for l in f:\n          a,b = [int(x) for x in l.split()]\n          mt = sqpals >= a\n          lt = sqpals <= b\n          output = sum( mt&lt )\n          print \"Case #%s: %s\"%(t,output)\n          t += 1\n      \n", "substitutes": {"x": ["ex", "alpha", "rax", "i", "loc"], "y": ["i", "xx", "sky", "yz", " py"], "digits": [" Digbits", " Digitals", "multiplit", "positals", "multiplits"], "dplus": [" dappa", "adraw", " dminus", " dPlus", "dminus"], "pals": ["lale", "palls", "lalls", "lals", "Pales"], "z": ["j", "Z", "zip", "alpha", "za"], "p": ["P", "ip", "j", "pp", "amp"], "f": ["fun", "uf", "i", "feed", "fi"], "sqpals": ["squarepals", "sqPals", "sqiulas", "sqpales", "sqialls"], "l": ["le", " L", "j", "lines", "pl"], "t": ["text", "tc", "j", "i", "u"], "a": ["aa", "ai", "sta", "ab", "alpha"], "b": ["bars", "j", "ab", "abb", "bl"], "mt": ["format", "mm", "sm", "sta", "mr"], "lt": ["log", "ld", "unt", "min", "br"], "output": ["config", "format", "section", "text", "summary"]}}
{"code": " \n  \n  if __name__ == \"__main__\":\n  \n      f = open( \"B-small-attempt1.in.txt\" )\n      g = open( \"output_small.txt\", \"w\" )\n  \n      f.readline()\n      line = f.readline()\n      caseI = 1\n      while line != \"\":\n          line = [ int(x) for x in line.split() ]\n          N = line[0]\n          surprise = line[1]\n          p = line[2]\n          points = line[3:]\n          points.sort()\n          points.reverse()\n  \n          maxp = 0\n          either = 0\n          make_surprise = 0\n          for x in points:\n              this_p = (x+2)/3\n              if x in [0,1,29,30]:\n                  if this_p >= p:\n                      maxp += 1\n              elif this_p >= p:\n                  either += 1\n                  maxp += 1\n              elif this_p == p-1 and (x+2)%3 > 0:\n                  make_surprise += 1\n              else:\n                  either += 1\n  \n          if make_surprise >= surprise:\n              make_surprise -= surprise\n              maxp += surprise\n              make_surprise = 0\n          else:\n              maxp += make_surprise\n  \n          g.write( \"Case #%s: %s\n\"%(caseI,maxp) )\n  \n          line = f.readline()\n          caseI += 1\n  \n      f.close()\n      g.close()\n      \n", "substitutes": {"f": ["log", "l", "j", "uf", "rf"], "g": ["bar", "log", "l", "reg", "graph"], "line": ["l", "inline", "i", "model", "eline"], "caseI": ["Casei", "catchE", " caseN", "caseN", "caseID"], "x": ["ex", "l", "t", "i", "abc"], "N": ["P", " network", "Z", "n", "M"], "surprise": ["syprise", "syprising", "curvey", "Survey", "promprise"], "p": ["P", "l", "j", "z", "pp"], "points": ["P", "format", "elines", "features", "lines"], "maxp": ["maxpt", "Maxpt", " maxP", "Maxi", "MAXp"], "either": ["third", "tri", "anything", "yet", "along"], "make_surprise": ["make_servey", "make_curprise", "make_surprises", "make_Surprising", "make_currance"], "this_p": [" this_point", " this_pre", "this_c", " this_z", " this_c"]}}
{"code": " \n  possibles = [1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001, 1234321, 4008004, 100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, 404090404, 10000200001, 10221412201, 12102420121, 12345654321, 40000800004, 1000002000001, 1002003002001, 1004006004001, 1020304030201, 1022325232201, 1024348434201, 1210024200121, 1212225222121, 1214428244121, 1232346432321, 1234567654321, 4000008000004, 4004009004004]\n  \n  for case in xrange(codejam.readint()):\n      A, B = map(int, codejam.readstring().split())\n      count = 0\n      for possible in possibles:\n          if A > possible:\n              continue\n  \n          if B < possible:\n              break\n  \n          count += 1\n  \n      print \"Case #%d: %d\" % (case + 1, count)\n", "substitutes": {"possibles": [" possibilities", "possIBLE", "posible", "pOSSible", "Possibilities"], "case": ["section", "Case", "address", "ASE", "example"], "A": ["P", "State", "API", "As", "DA"], "B": ["P", "J", "WB", "DB", "D"], "count": ["cond", "size", "i", "key", "error"], "possible": ["possibly", "cpcould", " possibly", "cpossibly", "hpossibility"]}}
{"code": " \n  def readint():\n      return int(sys.stdin.readline())\n  \n  def readintarray():\n      return map(int, sys.stdin.readline().strip().split())\n  \n  def readpairs(start=0):\n      elems = readintarray()[start:]\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\n  \n  def readstring():\n      return sys.stdin.readline()[:-1]\n  \n", "substitutes": {"start": ["step", "l", "add", "middle", "j"], "elems": ["elmas", "elns", " elemas", "elma", "elens"], "i": ["l", "ai", "j", "z", "ki"]}}
{"code": " \n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tyield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tcase_counter = 1\n  \t\tcase = []\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tcase.append(line.strip().split(' '))\n  \t\t\tif not line_index % n:\n  \t\t\t\tyield case_counter, case\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tcase = []\n  \n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tcase_counter = 0\n  \t\tnew_case = True\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tif new_case:\n  \t\t\t\tnew_case = False\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tcase = []\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\n  \t\t\t\tlines_left = int(line.strip())\n  \t\t\t\tif not lines_left:\n  \t\t\t\t\tnew_case = True\n  \t\t\t\t\tyield case_counter, case\n  \t\t\t\tcontinue\n  \t\t\tif lines_left:\n  \t\t\t\tlines_left -= 1\n  \t\t\t\tcase.append(line.strip().split(' '))\n  \t\t\tif not lines_left:\n  \t\t\t\tnew_case = True\n  \t\t\t\tyield case_counter, case\n  \t\t\t\n  def part_of_list_to_int(array, flags):\n  \tassert len(array) == len(flags)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif flags[index]:\n  \t\t\toutput.append(int(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_int(array):\n  \treturn part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  \tassert len(array) == len(flags)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif flags[index]:\n  \t\t\toutput.append(float(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_float(array):\n  \treturn part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  \telem_len = len(array[0])\n  \tassert index < elem_len\n  \tfor elem in array:\n  \t\tassert elem_len == len(elem)\n  \tmax_sub = array[0][index]\n  \tmax_elem = array[0]\n  \tfor elem in array:\n  \t\tif elem[index] > max_sub:\n  \t\t\tmax_sub = elem[index]\n  \t\t\tmax_elem = elem\n  \treturn max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  \tlist_len = len(a_list)\n  \tif list_len == 1:\n  \t\tif a_list[0] == value:\n  \t\t\treturn pos\n  \t\treturn -1\n  \tif a_list[list_len/2] > value:\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  \telse:\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  \t\n  def list_index_in_sorted_list(a_list, value):\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\n  \t\n  def check_palindrome(value):\n  \tval_str = str(value)\n  \tlength = len(val_str)\n  \tfor i in xrange(length):\n  \t\tif val_str[i] != val_str[length - 1 - i]:\n  \t\t\treturn False\n  \treturn True\n  \n  def calc_result(case):\n  \tA = int(case[0])\n  \tB = int(case[1])\n  \t\n  \tA_sqrt = int(math.ceil(math.sqrt(A)))\n  \tB_sqrt = int(math.floor(math.sqrt(B)))\n  \t\n  \tprint \"\\tinterval: %s\" % [A, B]\n  \tprint \"\\tsqrt_int: %s\" % [A_sqrt, B_sqrt]\n  \t\n  \tcount = 0\n  \tfor i in xrange(A_sqrt, B_sqrt + 1):\n  \t\tif check_palindrome(i):\n  \t\t\tif check_palindrome(i * i):\n  \t\t\t\tcount += 1\n  \t\t\t\tprint \"\\tfound: %d, %d\" % (i, i * i)\n  \t\n  \tprint \"\\ttot: %d\" % count\n  \tprint \n  \tresult = \"%s\" % count\n  \treturn result\n  \n  def main(filepath):\n  \tstart_time = time.time()\n  \twith file('output.txt', 'wb') as f_out:\n  \t\t\n  \t\tfor case_index, case in iterate_cases_1lpc(filepath):\n  \t\t\t\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\n  \t\t\tresult = calc_result(case)\n  \t\t\t\n  \t\t\tf_out.write(\"Case #%d: %s\n\" % (case_index, result))\n  \t\t\t\t\n  if __name__ == '__main__':\n  \tmain(sys.argv[1])\n", "substitutes": {"filepath": ["Filetext", " filesize", "baseath", " filePath", "filePath"], "line_index": ["line67index", "link_address", "line6initial", "link_index", "frame24ind"], "line": ["byte", "inline", "key", "character", "input"], "n": ["l", "j", "size", "max", "t"], "case_counter": [" case_manager", "case24count", "case24finder", "cases_current", "case_number"], "case": ["address", "key", "feed", "ce", "character"], "new_case": [" new_Case", "newfCase", "new_change", "new_sea", "New_case"], "lines_left": ["linesaclock", "liners_top", "lines_below", "lines6Left", "line_end"], "array": ["address", "input", "all", "complex", "function"], "flags": ["fires", "windows", "rings", "all", "stats"], "output": ["address", "process", "input", "model", "all"], "index": ["address", "alpha", "key", "loc", "connection"], "elem": ["gelev", "gele", "elev", "eelee", "eelements"]}}
{"code": " \n  class Triplet(object):\n  \tdef __init__(self, i, j, k):\n  \t\tself.i = i\n  \t\tself.j = j\n  \t\tself.k = k\n  \t\tself.max_diff = max((abs(i - j), abs(i - k), abs(j - k)))\n  \t\tself.valid = self.max_diff <= 2\n  \t\tself.surprise = self.max_diff == 2\n  \t\n  \tdef get_tuple(self):\n  \t\treturn (self.i, self.j, self.k)\n  \t\n  \tdef get_redundancies(self):\n  \t\treturn [(self.i, self.j, self.k),\n  \t\t\t\t(self.i, self.k, self.j),\n  \t\t\t\t(self.j, self.i, self.k),\n  \t\t\t\t(self.j, self.k, self.i),\n  \t\t\t\t(self.k, self.i, self.j),\n  \t\t\t\t(self.k, self.j, self.i)]\n  \n  class Googler(object):\n  \tdef __init__(self, total_points):\n  \t\tself.total_points = total_points\n  \t\tself.regular_triplets = []\n  \t\tself.surprise_triplets = []\n  \t\t\n  \t\tfor i in xrange(0, 11):\n  \t\t\tif i > total_points:\n  \t\t\t\tbreak\n  \t\t\tfor j in xrange(i, 11):\n  \t\t\t\tif i + j > total_points:\n  \t\t\t\t\tbreak\n  \t\t\t\tk = total_points - i - j\n  \t\t\t\tif k > 10:\n  \t\t\t\t\tbreak\n  \t\t\t\ttriplet = Triplet(i, j, k)\n  \t\t\t\tself.add(triplet)\n  \t\t\n  \t\tself.can_surprise = len(self.surprise_triplets) > 0\n  \t\tself.actual_triplet = None\n  \t\tself.best_result = -1\n  \t\t\n  \tdef add(self, triplet):\n  \t\tif not triplet.valid:\n  \t\t\treturn\n  \t\tif triplet.surprise:\n  \t\t\tself.add_uniquely(triplet, is_surprise=True)\n  \t\telse:\n  \t\t\tself.add_uniquely(triplet, is_surprise=False)\n  \t\t\t\n  \tdef add_uniquely(self, triplet, is_surprise):\n  \t\tif is_surprise:\n  \t\t\tinput_list = self.surprise_triplets\n  \t\telse:\n  \t\t\tinput_list = self.regular_triplets\n  \t\tfor triplet_redundancy in triplet.get_redundancies():\n  \t\t\tif triplet_redundancy in input_list:\n  \t\t\t\treturn\n  \t\tinput_list.append(triplet.get_tuple())\n  \t\n  \tdef __str__(self):\n  \t\treturn \"regular: %s\nsurprise: %s\" % (self.regular_triplets,\n  \t\t\t\t\t\t\t\t\t\t\t  self.surprise_triplets)\n  \t\n  \tdef set_googler(self, is_surprise=False):\n  \t\tif not is_surprise:\n  \t\t\tself.actual_triplet = self.regular_triplets[0]\n  \t\telse:\n  \t\t\tself.actual_triplet = self.surprise_triplets[0]\n  \t\tself.calc_best_result()\n  \t\n  \tdef calc_best_result(self):\n  \t\tself.best_result = max(self.actual_triplet)\n  \n  \t\t\n  class Contest(object):\n  \tdef __init__(self, num_of_googlers, results):\n  \t\tself.num = num_of_googlers\n  \t\tself.googlers = []\n  \t\tfor i in xrange(self.num):\n  \t\t\tself.googlers.append(Googler(results[i]))\n  \t\n  \tdef calc(self, num_of_surprises, p):\n  \t\tmax_googlers_over_p = 0\n  \t\tfor surprise_perm in self.get_permutations(num_of_surprises):\n  \t\t\tif not self.validate_permutation(surprise_perm):\n  \t\t\t\tcontinue\n  \t\t\tcount = 0\n  \t\t\tfor index, googler in enumerate(self.googlers):\n  \t\t\t\tgoogler.set_googler(index in surprise_perm)\n  \t\t\t\tif googler.best_result >= p:\n  \t\t\t\t\tcount += 1\n  \t\t\tif count >= max_googlers_over_p:\n  \t\t\t\tmax_googlers_over_p = count\n  \t\treturn max_googlers_over_p\n  \t\n  \tdef get_permutations(self, num_of_surprises):\n  \t\tresults = get_perms(0, self.num, num_of_surprises)\n  \t\tif not results:\n  \t\t\treturn [[]]\n  \t\treturn results\n  \t\n  \tdef validate_permutation(self, perm):\n  \t\tfor googler_index in perm:\n  \t\t\tif not self.googlers[googler_index].can_surprise:\n  \t\t\t\treturn False\n  \t\treturn True\n  \n  def get_perms(start_index, finish_index, amount):\n  \tif amount == 0:\n  \t\treturn []\n  \tresult_list = []\n  \tfor i in xrange(start_index, finish_index):\n  \t\tif amount == 1:\n  \t\t\tresult_list.append([i])\n  \t\t\tcontinue\n  \t\tfor result in get_perms(i + 1, finish_index, amount - 1):\n  \t\t\tnew_result = [i]\n  \t\t\tnew_result.extend(result)\n  \t\t\tresult_list.append(new_result)\n  \treturn result_list\n  \t\t\n  def main(filepath):\n  \twith file('dancing_output.txt', 'wb') as f_out:\n  \t\twith file(filepath, 'rb') as f_in:\n  \t\t\tfor line_index, line in enumerate(f_in):\n  \t\t\t\tif line_index == 0: #T\n  \t\t\t\t\tcontinue\n  \t\t\t\tinput_list = line.strip().split(' ')\n  \t\t\t\tnum_of_googlers = int(input_list[0])\n  \t\t\t\tnum_of_surprises = int(input_list[1])\n  \t\t\t\tp = int(input_list[2])\n  \t\t\t\tresults = []\n  \t\t\t\tfor res in input_list[3:]:\n  \t\t\t\t\tresults.append(int(res))\n  \t\t\t\tcontest = Contest(num_of_googlers, results)\n  \t\t\t\tresult = contest.calc(num_of_surprises, p)\n  \t\t\t\t\n  \t\t\t\tprint\n  \t\t\t\tprint line.strip()\n  \t\t\t\tprint result\n  \t\t\t\t\n  \t\t\t\tf_out.write(\"Case #%d: %d\n\" % (line_index, result))\n  \t\t\t\t\n  if __name__ == '__main__':\n  \tmain(sys.argv[1])\n", "substitutes": {"self": ["exc", "co", "l", "graph", "pp"], "i": ["l", "ti", "fi", "b", "ih"], "j": ["J", "uj", "l", "key", "t"], "k": ["l", "key", "right", "kick", "b"], "max_diff": ["maxlexDiff", "max64dist", "max64error", "max64distance", "max_Diff"], "valid": ["open", "same", "Valid", "new", "complete"], "surprise": ["serprising", "serprises", "subprising", "curvey", "suvey"], "total_points": [" total_groups", "totalxpoints", "max67groups", "total__points", "total67groups"], "regular_triplets": ["regular_trippings", "regular_tups", "regular_droplet", "regular_tuplet", "regular_traps"], "surprise_triplets": ["surprise_triples", "surprise_traplet", "surprise_trips", "surprise_triplet", "surprise_tuplet"], "triplet": ["triple", " triplets", "trajet", "traple", "diple"], "can_surprise": ["can_surprising", "can_Survey", "can_Surprising", "can_suprises", "can_subprises"], "actual_triplet": ["actual_promplet", "actual_triplets", "actual_promplets", "actual_trapt", "actual_tuplet"], "best_result": ["best_results", "first_status", "first_results", "first_result", "best_round"], "is_surprise": ["is_subvey", "is_subprises", "is_enterception", "is_curception", "is_syprises"], "input_list": ["input_diff", "inputiptype", "input_type", "inputPlist", "input_List"], "triplet_redundancy": ["triplet_redunency", "triplet_redountancies", "triplet_Redountancies", "triplet_Redountance", "triplet_redunant"]}}
{"code": "def IsPal(n):\n      S = str(n);\n      return S == S[::-1];\n  \n  \n  def Gen():\n      LIM = 10**14;\n      N = 10**7;\n      LIST = [];\n      for i in range(1, N):\n          if IsPal(i):\n              if IsPal(i*i):\n                  LIST.append(i);\n      return LIST\n  \n  PP = Gen();\n  \n  T = int(raw_input());\n  for q in range(1,T+1):\n      [A,B] = map(int, raw_input().split());    \n      ANS = 0;\n      for i in range(len(PP)):\n          if B >= PP[i]**2 >= A:\n              ANS += 1;\n      \n      print \"Case #%d: %d\" %(q, ANS);\n", "substitutes": {"n": ["l", "j", "z", "t", "pn"], "S": ["P", "Q", "TS", "D", "ASS"], "LIM": ["LINK", "LAMP", " LINK", " LOM", "NLOM"], "N": ["Q", "P", "J", "Z", "D"], "LIST": ["IST", "Q", "l", "IN", "API"], "i": ["l", "t", "ti", "input", "b"], "PP": ["P", "Q", "WP", "pp", "TP"], "T": ["Q", "P", "TS", "size", "Z"], "q": ["Q", "P", "l", "qu", "j"], "A": ["AR", "P", "Q", "ai", "API"], "B": ["AR", "P", "Q", "J", "WB"], "ANS": ["\u03b1", "P", "Q", "AR", "ANN"]}}
{"code": "T = int(raw_input());\n  for i in range(T):\n     Data = map(int, raw_input().split());\n     N = Data.pop(0);\n     S = Data.pop(0);\n     p = Data.pop(0);\n     \n     Good = 0;\n     for score in Data:\n        if score >= 3*p-2:\n           Good += 1;\n        else:\n           if (S > 0) and (score >= 3*p-4) and (score >= p):\n              S -= 1;\n              Good += 1;\n  \n     print \"Case #%d:\" % (i+1),;\n     print Good;\n     \n  \n", "substitutes": {"T": ["P", "Q", "DT", "TS", "Z"], "i": ["ai", "l", "ip", "j", "z"], "Data": ["Distance", "Old", "D", "Row", " data"], "N": ["Q", "J", "P", "Na", "Z"], "S": ["P", "Q", "J", "Size", "D"], "p": ["P", "l", "Q", "j", "z"], "Good": ["Some", "Ready", "Better", "Like", " good"], "score": ["key", " scores", "ne", "want", "name"]}}
{"code": " \n  def isPalindrome(s):\n    length = len(s)\n    for i in xrange(length / 2):\n      if s[i] != s[length - 1 - i]: \n        return False\n    return True\n  \n  n = int(raw_input())\n  for i in range(n):\n    a, b = map(int, raw_input().strip().split(' '))\n    count = 0\n    for j in range(a, b+1):\n      if isPalindrome(str(j)):\n        s = math.sqrt(j)\n        if s == int(s) and isPalindrome(str(int(s))):\n          count += 1\n    print 'Case #%i: %i' % (i+1, count)\n", "substitutes": {"s": ["l", "aces", "sports", "t", "input"], "length": ["l", "shape", "size", "z", "zip"], "i": ["l", "ai", "ip", "z", "size"], "n": ["l", "size", "z", "u", "max"], "a": ["ak", "ai", "aa", "l", "ab"], "b": ["l", "abb", "z", "ab", "boot"], "count": ["l", "J", "cond", "size", "z"], "j": ["bj", "note", "J", "uj", "l"]}}
{"code": " \n  T = int(sys.stdin.readline())\n  for i in range(T):\n      line = sys.stdin.readline().strip()\n      values = map(int, line.split(' '))\n      N = values[0]\n      S = values[1]\n      p = values[2]\n      totals = values[3:]\n      ans = 0\n      for total in totals:\n          base = total / 3\n          remainder = total - (base * 3)\n          scores = [base, base, base]\n          j = 0\n          while remainder > 0:\n              scores[j] += 1\n              remainder -= 1\n              j = (j + 1) % 3\n          if max(scores) >= p:\n              ans += 1\n          else:\n              if S > 0:\n                  remainder = total - (base * 3)\n                  if remainder == 0 and base > 0:\n                      if base + 2 >= p:\n                          ans += 1\n                          S -= 1\n                  elif base + min(remainder, 2) >= p:\n                      ans += 1\n                      S -= 1\n      print 'Case #%s: %s' % (i+1, ans)\n", "substitutes": {"T": ["P", "J", "Q", "TS", "Z"], "i": ["lo", "l", "J", "inter", "ip"], "line": ["LINE", "log", "l", "section", "le"], "values": ["versions", "vector", "docs", "ends", "lines"], "N": ["P", "J", "Na", "Z", " I"], "S": ["P", "J", "Q", "State", "TS"], "p": ["P", "l", "z", "per", "pp"], "totals": [" TotALS", "Tfatalls", "tOTal", " TOTales", "totsals"], "ans": ["aning", "mean", "aus", "sa", "ase"], "total": ["otal", "alpha", "t", "scale", "all"], "base": ["based", "fixed", "alpha", "b", "model"], "remainder": ["resaincer", "Remainingser", "remainingnder", "remainingser", "remainingter"], "scores": ["escares", "quatters", " Scares", "escatters", " scors"], "j": ["bj", "P", "J", "l", "adj"]}}
{"code": " \n  \n  LIMIT = 10\n  \n  def check_palindrome(number):\n      rev = 0\n      runner = number\n      while runner > 0:\n          rev = rev * 10 + (runner % 10)\n          runner /= 10\n      if rev == number:\n          return True\n      else:\n          return False\n  \n  def list_to_number(number_list):\n      l = len(number_list)\n      res = 0; rres = 0\n      multi = 1\n      for i in xrange(1, l + 1):\n          res += number_list[l - i] * multi\n          rres += number_list[i - 1] * multi\n          multi *= 10\n      return (res, rres)\n  \n  def gen_one_side(side_length):\n      state = [0 for _ in xrange(side_length)]\n      done = False\n  \n      while not done:\n          if state[-1] != 0:\n              yield state\n          state[-1] += 1\n          curr = side_length - 1\n          while state[curr] == LIMIT:\n              if curr == 0:\n                  done = True\n                  break\n              state[curr] = 0\n              curr -= 1\n              state[curr] += 1\n  \n  def gen_odd_palindrome(side_length):\n      if side_length == 0:\n          for i in xrange(1, 10):\n              yield i\n      else:\n          multi = 10**side_length\n          for one_side in gen_one_side(side_length):\n              number, rnumber = list_to_number(one_side)\n              for i in xrange(LIMIT):\n                  yield number + i * multi + rnumber * multi * 10\n  \n  def gen_even_palindrome(side_length):\n      multi = 10**side_length\n      for one_side in gen_one_side(side_length):\n          number, rnumber = list_to_number(one_side)\n          yield number + rnumber * multi\n  \n  \n  def gen_palindrome():\n      l = 1\n  \n      while True:\n          if l % 2 == 1:\n              for odd_pal in gen_odd_palindrome((l - 1) / 2):\n                  yield odd_pal\n          else:\n              for even_pal in gen_even_palindrome(l / 2):\n                  yield even_pal\n          l += 1\n  \n  \n  cache = []\n  upper = 10**14\n  for pal in gen_palindrome():\n      pal2 = pal**2\n      if pal2 > upper:\n          break\n      if check_palindrome(pal2):\n          cache.append(pal2)\n  \n  cl = len(cache)\n  T = int(raw_input().strip())\n  for i in xrange(T):\n      low_ind = 0\n      high_ind = cl - 1\n      A, B = map(int, raw_input().strip().split(' '))\n  \n      while cache[low_ind] < A:\n          low_ind += 1\n      while cache[high_ind] > B:\n          high_ind -= 1\n  \n  \n      if low_ind <= high_ind:\n          print \"Case #%s: %s\" % (i + 1, high_ind - low_ind + 1)\n      else:\n          print \"Case #%s: 0\" % (i + 1)\n", "substitutes": {"LIMIT": ["DLimITS", "LIMITS", "SLIMITED", "DLimit", "LOBit"], "number": ["address", "loc", "b", "uri", "int"], "rev": ["cur", "j", "min", "z", "obj"], "runner": ["cur", "config", "tri", "rf", "cli"], "number_list": ["letter_info", "number___store", "letter_store", "array_list", "value_list"], "l": ["pl", "t", "loc", "lt", "b"], "res": ["rl", "rex", "roc", "reg", "progress"], "rres": ["rxrem", " rreg", "srresults", "rresult", "rxresults"], "multi": ["progress", "ti", "dim", "scale", "phi"], "i": ["ti", "t", "b", "qi", "phi"], "side_length": ["sidealheight", "side_count", "side_direction", "line_length", "side67count"], "state": ["State", "address", "progress", "key", "loc"], "_": [" r", " p", "n", "r", " num"], "done": ["lo", "fun", "min", "size", "checked"], "curr": ["charri", "urru", "curver", "perR", " curra"], "one_side": ["once_side", "once_ide", "once67loc", "once67day", "eachjteam"], "rnumber": [" rnumbered", "drnum", "erspan", "rrcorrect", "ernum"], "odd_pal": ["odd___color", "odd_side", " odd_panel", "oddCcal", "odd_color"], "even_pal": [" even_pl", "odd_real", "even_ph", " even_sal", "odd_al"], "cache": ["color", "lines", "page", "py", "case"], "upper": ["exc", "fixed", "middle", "alpha", "final"], "pal": ["margin", "adv", "color", "min", "page"], "pal2": ["valtwo", "chal2", "Pal3", "pal5", "bltwo"]}}
{"code": " \n  surprising = [[], [], [(0, 0, 2)], [(0, 1, 2)], [(0, 2, 2)], [(1, 1, 3)], [(1, 2, 3)], [(1, 3, 3)], [(2, 2, 4)], [(2, 3, 4)], [(2, 4, 4)], [(3, 3, 5)], [(3, 4, 5)], [(3, 5, 5)], [(4, 4, 6)], [(4, 5, 6)], [(4, 6, 6)], [(5, 5, 7)], [(5, 6, 7)], [(5, 7, 7)], [(6, 6, 8)], [(6, 7, 8)], [(6, 8, 8)], [(7, 7, 9)], [(7, 8, 9)], [(7, 9, 9)], [(8, 8, 10)], [(8, 9, 10)], [(8, 10, 10)], [], []]\n  regular = [[(0, 0, 0)], [(0, 0, 1)], [(0, 1, 1)], [(1, 1, 1)], [(1, 1, 2)], [(1, 2, 2)], [(2, 2, 2)], [(2, 2, 3)], [(2, 3, 3)], [(3, 3, 3)], [(3, 3, 4)], [(3, 4, 4)], [(4, 4, 4)], [(4, 4, 5)], [(4, 5, 5)], [(5, 5, 5)], [(5, 5, 6)], [(5, 6, 6)], [(6, 6, 6)], [(6, 6, 7)], [(6, 7, 7)], [(7, 7, 7)], [(7, 7, 8)], [(7, 8, 8)], [(8, 8, 8)], [(8, 8, 9)], [(8, 9, 9)], [(9, 9, 9)], [(9, 9, 10)], [(9, 10, 10)], [(10, 10, 10)]]\n  \n  f = open(argv[1], 'r')\n  T = int(f.readline().strip('\n'))\n  for i in range(T):\n  \tboth = 0\n  \tsurp_only = 0\n  \tline = f.readline().strip('\n').split(' ')\n  \tN = int(line[0]) # What for?\n  \tS = int(line[1])\n  \tp = int(line[2])\n  \tts = map(int, line[3:])\n  \tfor t in ts:\n  \t\tif reduce(max, map(max, regular[t])) >= p:\n  \t\t\tboth += 1\n  \t\telif surprising[t] != [] and reduce(max, map(max, surprising[t])) >= p:\n  \t\t\tsurp_only += 1\n  \n  \tprint \"Case #%s: %s\" % (i + 1, both + min(surp_only, S))\n", "substitutes": {"surprising": ["Surprising", "Surplex", "surfacefaces", "serfaces", "surprise"], "regular": ["fixed", "config", "reg", "shape", "external"]}}
{"code": " \n  main = do\n      interact (unlines . map showCase . zip [1..] . map (solve . interval) . tail . lines)\n  \n    where\n      interval :: String -> (Int64, Int64)\n      interval l =\n          let [a, b] = map read $ splitOn \" \" l\n          in (a, b)\n  \n      showCase :: (Int64, Int) -> String\n      showCase (i, r) = printf \"Case #%d: %d\" i r\n  \n  solve :: (Int64, Int64) -> Int\n  solve (a, b) =\n      length $ takeWhile (<= b) $ dropWhile (< a) [ sq\n          | x <- [0..], palindrome x, let sq = x * x, palindrome sq\n          ]\n    where\n      square x = x * x\n      start = truncate $ sqrt $ double a\n  \n  -- | Returns True if s is a palindrome.\n  palindrome s =\n      let s' = show s\n      in s' == reverse s'\n  \n  double :: Int64 -> Double\n  double = fromIntegral\n", "substitutes": {"main": ["log", "section", " result", "j", "obj"], "l": ["rl", "le", " L", "j", "lines"], "let": ["fore", "pl", "lt", "shell", "lit"], "a": ["alpha", "art", "i", "t", "am"], "b": ["aa", "j", "ab", "z", "abb"], "x": ["ex", "key", "i", "t", "xx"], "start": ["step", "cur", "z", "alpha", "unit"]}}
{"code": " \n  main = interact (unlines . map showCase . zip [1..] . tail . lines)\n    where\n      showCase (i, t) = \"Case #\" ++ show i ++ \": \" ++ solve t\n  \n  solve = show . solve' . map read . words\n    where\n      solve' (n:s:p:ts) = \n          let pts = map maxPoints ts\n              directs = filter ((>= p) . fst) pts\n              surps = filter (\\(pd, ps) -> pd < p && ps >= p) pts\n          in length directs + min (length surps) s\n          \n  maxPoints :: Int -> (Int, Int)\n  maxPoints tot = \n      (maxScore $ scores normal, maxScore $ scores surprising)\n    where\n      scores cond = [ (x, y, z) |\n          x <- [0..10], y <- [0..10], z <- [0..10]\n          , x + y + z == tot, cond (x, y, z)\n          ]\n      normal t = bestScore t - badScore t <= 1\n      surprising t = bestScore t - badScore t <= 2\n      maxScore = maximum . map bestScore \n  \n  bestScore (x, y, z) = maximum [x, y, z]\n  badScore (x, y, z) = minimum [x, y, z]\n", "substitutes": {"main": ["log", "ite", "page", "obj", "pl"], "solve": ["solver", "psolves", "asolution", "ssolution", "insolution"], "n": ["l", "adj", "j", "z", "i"], "pts": ["PTses", "inputsv", "ctsets", "pathsi", "strsp"], "directs": [" directments", "directments", "directions", "Directly", "patterns"], "surps": ["interps", "Surpped", "Surpes", "Surfaces", "urps"], "tot": ["twoting", "toti", "dtot", "tots", " tota"], "cond": ["log", "condition", "co", "det", "reg"], "t": ["l", "tc", "ti", "i", "b"], "maxScore": ["maxPoint", "minscore", "MaxValue", "powerGrade", " maxscore"]}}
{"code": "def checkpalin(s):\n      k = len(s)//2\n      for i in range(k):\n          if s[i]!= s[-1-i]:\n              return False\n      return True\n  \n  goods = [1,2,3]\n  \n  for i in range(1000):\n      for j in ['']+list(range(10)):\n          test = str(i)+str(j)+(str(i)[::-1])\n          if checkpalin(str(int(test)**2)):\n              goods.append(int(test))\n  goods = list(set(goods))\n  goods.sort()\n  \n  T = int(input())\n  \n  for case in range(1,T+1):\n      A,B = [int(x) for x in input().split()]\n      ans = 0\n      for n in goods:\n          if A <= n*n <= B:\n              ans += 1\n      print(\"Case #\",case,\": \",ans,sep='')\n", "substitutes": {"s": ["l", "es", "sq", "z", "services"], "k": ["ak", "l", "kk", "z", "t"], "i": ["ai", "l", "ip", "ji", "ij"], "goods": ["indns", "badps", "Goodsites", "tests", "gooders"], "j": ["J", "ai", "l", "ip", "adj"], "test": ["fake", "tri", "example", "py", "t"], "T": ["Q", "P", "Case", "J", "TS"], "case": ["config", "Case", "address", "section", "text"], "A": ["P", "Case", "Ca", "Na", "As"], "B": ["II", "P", "J", "WB", "ab"], "x": ["xb", "ex", "l", "exp", "z"], "ans": ["ai", "ents", "can", "nes", "Na"], "n": ["P", "l", "aa", "Na", "z"]}}
{"code": "T=int(input())\n  for t in range(T):\n    l = [int(x) for x in input().split()]\n    n,huh,p = l[:3]\n    ss = l[3:]\n    nice, maybe = 0,0\n    for s in ss:\n      if s>= p+2*max(p-1,0):\n        nice += 1\n      elif s>= p+2*max(p-2,0):\n        maybe += 1\n    y = nice + min(maybe,huh)\n    print('Case #',t+1,': ',y,sep = '')\n  \n  \n", "substitutes": {"T": ["P", "Q", "J", "TS", "z"], "t": ["j", "z", "u", "max", "iter"], "l": ["rl", "le", " L", "pl", "i"], "x": ["ox", "xb", "ex", "exp", "j"], "n": ["j", "z", "pn", "iter", "u"], "huh": ["Huc", "Hugh", " hih", "huc", "workuh"], "p": ["P", "ip", "j", "min", "z"], "ss": ["css", "hess", "sq", "z", "pp"], "nice": ["small", "wh", "tri", "min", "chi"], "maybe": ["some", "anything", "z", "happy", "api"], "s": ["es", "sq", "lines", "z", "size"], "y": ["j", "idy", "z", "chi", "py"]}}
{"code": " \n  \n  \n  \n  problem = \"C\"\n  tag = \"small\" #commonly sample, small, or large\n  suffix = \"-attempt0\" #used sometimes for indexing later input files\n  table_of_fairs = np.array([0, 1, 4, 9, 121, 484, 676, 10201, 12321, 14641, \n  40804, 44944, 69696, 94249, 698896, 1002001, 1234321, 4008004, 5221225, 6948496, \n  100020001, 102030201, 104060401, 121242121, 123454321, 125686521, 400080004, \n  404090404, 522808225, 617323716, 942060249, 10000200001, 10221412201, 12102420121, \n  12345654321, 40000800004, 637832238736, 1000002000001, 1002003002001, 1004006004001, \n  1020304030201, 1022325232201, 1024348434201, 1086078706801, 1210024200121, \n  1212225222121, 1214428244121, 1230127210321, 1232346432321, 1234567654321, \n  1615108015161, 4000008000004, 4004009004004, 4051154511504, 5265533355625, \n  9420645460249, 100000020000001, 100220141022001, 102012040210201, 102234363432201, \n  121000242000121, 121242363242121, 123212464212321, 123456787654321, \n  123862676268321, 144678292876441, 165551171155561, 400000080000004, \n  900075181570009, 4099923883299904, 10000000200000001, 10002000300020001, \n  10004000600040001, 10020210401202001, 10022212521222001, 10024214841242001, \n  10201020402010201, 10203040504030201, 10205060806050201, 10221432623412201, \n  10223454745432201, 12100002420000121, 12102202520220121, 12104402820440121, \n  12120030703002121, 12122232623222121, 12124434743442121, 12321024642012321, \n  12323244744232321, 12341234943214321, 12343456865434321, 12345678987654321, \n  40000000800000004, 40004000900040004, 94206450305460249, 1000000002000000001, \n  1000220014100220001, 1002003004003002001, 1002223236323222001, 1020100204020010201, \n  1020322416142230201, 1022123226223212201, 1022345658565432201, 1210000024200000121, \n  1210242036302420121, 1212203226223022121, 1212445458545442121, 1232100246420012321, \n  1232344458544432321, 1234323468643234321, 4000000008000000004, 4253436912196343524, \n  6158453974793548516, 100000000020000000001, 100002000030000200001, 100004000060000400001, \n  100020201040102020001, 100022201252102220001, 100024201484102420001, \n  100200120040021002001, 100202122050221202001, 100204124080421402001, \n  100220341262143022001, 100222343474343222001, 102010002040200010201, \n  102012022050220210201, 102014042080240410201, 102030405060504030201, \n  102032425272524230201, 102132537636735231201, 102210100272001012201, 102212122262221212201, \n  102214144272441412201, 102230523292325032201, 102232545484545232201, 102234567696765432201, \n  104190107303701091401, 121000000242000000121, 121002200252002200121, 121004400282004400121, \n  121020021070120020121, 121022221262122220121, 121024421474124420121, 121220122262221022121, \n  121222324272423222121, 121240161292161042121, 121242363484363242121, 121244565696565442121, \n  123210002464200012321, 123212222474222212321, 123230205292502032321, 123232425484524232321, \n  123234645696546432321, 123432124686421234321, 123434346696643434321, 184398883818388893481, \n  400000000080000000004, 400004000090000400004, 522815090696090518225, 906086675171576680609, \n  942064503484305460249, 6916103777337773016196, 10000000000200000000001, 10000220001410002200001, \n  10002002100400120020001, 10002222123632122220001, 10020010200400201002001, 10020230421612403202001, \n  10022014302620341022001, 10022234545854543222001, 10201000020402000010201, 10201222221612222210201, \n  10203022140604122030201, 10203244363836344230201, 10221210222622201212201, 10221432643834623412201, \n  10223234344844343232201, 10224609234443290642201, 12100000002420000000121, 12100242003630024200121,\n  12102202302620320220121, 12102444325852344420121, 12122010222622201022121, 12122252443834425222121, \n  12124214524842541242121, 12321000024642000012321, 12321244225852244212321, 12323222344844322232321, \n  12343210246864201234321, 12384043938083934048321, 12599536942224963599521, 16593841302620314839561, \n  40000000000800000000004, 1000000000002000000000001, 1000002000003000002000001, \n  1000004000006000004000001, 1000020200104010020200001, 1000022200125210022200001, 1000024200148410024200001, 1000200030004000300020001, 1000202030205020302020001, 1000204030408040304020001, 1000220232126212320220001, 1000222232347432322220001, 1002001002004002001002001, 1002003004005004003002001, 1002005006008006005002001, 1002021222306032221202001, 1002023224327234223202001, 1002201232026202321022001, 1002203234227224323022001, 1002221454348434541222001, 1002223456569656543222001, 1020100000204020000010201, 1020102020205020202010201, 1020104040208020404010201, 1020120402306032040210201, 1020122422327232242210201, 1020300010207020100030201, 1020302030406040302030201, 1020304050607060504030201, 1020320414309034140230201, 1020322434528254342230201, 1020324454749474544230201, 1022121002226222001212201, 1022123024227224203212201, 1022141424528254241412201, 1022143446549456443412201, 1022321210249420121232201, 1022323232448442323232201, 1022325254649464525232201, 1210000000024200000000121, 1210002200025200022000121, 1210004400028200044000121, 1210020020107010200200121, 1210022220126210222200121, 1210024420147410244200121, 1210220032026202300220121, 1210222232227222322220121, 1210242254148414522420121, 1210244454369634544420121, 1212201002226222001022121, 1212203204227224023022121, 1212221040509050401222121, 1212223242528252423222121, 1212225444549454445222121, 1212421234248424321242121, 1212423436449446343242121, 1232100000246420000012321, 1232102220247420222012321, 1232120202329232020212321, 1232122422348432242212321, 1232124642369632464212321, 1232322032448442302232321, 1232324252649462524232321, 1234321002468642001234321, 1234323224469644223234321, 1821056104269624016501281, 4000000000008000000000004, 4000004000009000004000004, 4618627222542452227268164, 6942236477330337746322496, 9420645034800084305460249, 40460195511188111559106404, 100000000000020000000000001, 100000220000141000022000001, 100002002010040010200200001, 100002222012363210222200001, 100020001200040002100020001, 100020221222161222122020001, 100022003410262014300220001, 100022223434585434322220001, 100200100020040020001002001, 100200320240161042023002001, 100202104032060230401202001, 100202324254383452423202001, 100220121220262022121022001, 100220341462383264143022001, 100222125432484234521222001, 102010000002040200000010201, 102010222202161202222010201, 102012022032060230220210201, 102012244234383432442210201, 102030201204060402102030201, 102030423426181624324030201, 102032223434282434322230201, 102212100022262220001212201, 102212322442383244223212201, 102214124054282450421412201, 102232321224484422123232201, 121000000000242000000000121, 121000242000363000242000121, 121002202210262012202200121, 121002444212585212444200121, 121022001220262022100220121, 121022243242383242342220121, 121024203630484036302420121, 121220100022262220001022121, 121220342242383242243022121, 121222304234282432403222121, 121242121242484242121242121, 123210000002464200000012321, 123210244202585202442012321, 123212222232484232222212321, 123232201224484422102232321, 123432100024686420001234321, 400000000000080000000000004, 923860899791363197998068329, 4872133543202112023453312784, 9658137819052882509187318569, 10000000000000200000000000001, 10000002000000300000020000001, 10000004000000600000040000001, 10000020200010401000202000001, 10000022200012521000222000001, 10000024200014841000242000001, 10000200021000400012000200001, 10000202021020502012020200001, 10000204021040804012040200001, 10000220221212621212202200001, 10000222221234743212222200001, 10002000102000400020100020001, 10002002102200500220120020001, 10002004102400800420140020001, 10002020304030603040302020001, 10002022304232723240322020001, 10002200143002620034100220001, 10002202143222722234120220001, 10002220345234843254302220001, 10002222345456965454322220001, 10020010000200400200001002001, 10020012002200500220021002001, 10020014004200800240041002001, 10020030220410601402203002001, 10020032222412721422223002001, 10020210221220602212201202001, 10020212223240704232221202001, 10020230441632823614403202001, 10020232443654945634423202001, 10022010100002720000101022001, 10022012102202620220121022001, 10022014104402720440141022001, 10022030322230903222303022001, 10022032324432823442323022001, 10022034326634943662343022001, 10022210341004940014301222001, 10022212343224842234321222001, 10022214345444944454341222001, 10201000000020402000000010201, 10201002020020502002020010201, 10201004040020802004040010201, 10201020402030603020402010201, 10201022422032723022422010201, 10201200001200700210000210201, 10201202021220602212020210201, 10201204041240704214040210201, 10201220403410901430402210201, 10201222423432823432422210201, 10201224443454945434442210201, 10203020102040604020102030201, 10203022122240704222122030201, 10203040506070807060504030201, 10203042526272927262524030201, 10203220123022922032102230201, 10203222143242824234122230201, 10203224163462926436142230201, 10221210000222622200001212201, 10221212022222722222021212201, 10221230422432823422403212201, 10221232444434943444423212201, 10221412221442824412221412201, 10221414243462926434241412201, 10223232102244844220123232201, 10223234124444944442143232201, 12100000000002420000000000121, 12100002200002520000220000121, 12100004400002820000440000121, 12100020020010701002002000121, 12100022220012621002222000121, 12100024420014741002442000121, 12100220023002620032002200121, 12100222223022722032222200121, 12100242243214841234224200121, 12100244443236963234444200121, 12102200102202620220100220121, 12102202302402720420320220121, 12102220124030903042102220121, 12102222324232823242322220121, 12102224524434943442542220121, 12102420145204840254102420121, 12102422345424942454322420121, 12122010000222622200001022121, 12122012202222722220221022121, 12122032240432823404223022121, 12122034442434943424443022121, 12122230223242824232203222121, 12122232425262926252423222121, 12124212102424842420121242121, 12124214304624942640341242121, 12321000000024642000000012321, 12321002220024742002220012321, 12321020202032923020202012321, 12321022422034843022422012321, 12321024642036963024642012321, 12321222023224842232022212321, 12321224243244944234242212321, 12323220102244844220102232321, 12323222322444944422322232321, 12343210000246864200001234321, 12343212222246964222221234321, 16799008923862526832980099761, 40000000000000800000000000004, 40000004000000900000040000004, 44431002775280908257720013444, 98693567900935453900976539689, 1000000000000002000000000000001, 1000000220000014100000220000001, 1000002002001004001002002000001, 1000002222001236321002222000001, 1000020000300004000030000200001, 1000020220302216122030220200001, 1000022002321026201232002200001, 1000022222323458543232222200001, 1000200010020004000200100020001, 1000200230042016102400320020001, 1000202012221206021222102020001, 1000202232243438343422322020001, 1000220012320026200232100220001, 1000220232344238324432320220001, 1000222014541248421454102220001, 1002001000002004002000001002001, 1002001220222016102220221002001, 1002003004005006005004003002001, 1002003224225238325224223002001, 1002021020302206022030201202001, 1002021240524418144250421202001, 1002023024325228225234203202001, 1002201210022026202200121022001, 1002201430264038304620341022001, 1002203214225228225224123022001, 1002221232322248422232321222001, 1020100000000204020000000010201, 1020100222200216120022220010201, 1020102022021206021202202010201, 1020102244221438341224422010201, 1020120200302206022030020210201, 1020120422504418144052240210201, 1020122222343228223432222210201, 1020302010020406040200102030201, 1020302232242418142422322030201, 1020304032241608061422304030201, 1020322212322428242232122230201, 1022121000002226222000001212201, 1022121222422238322242221212201, 1022123024025228225204203212201, 1022141220304428244030221412201, 1022323210022448442200123232201, 1210000000000024200000000000121, 1210000242000036300002420000121, 1210002202201026201022022000121, 1210002444201258521024442000121, 1210022000320026200230002200121, 1210022242322238322232422200121, 1210024202541048401452024200121, 1210220010022026202200100220121, 1210220252044038304402520220121, 1210222212423228223242122220121, 1210242012342048402432102420121, 1212201000002226222000001022121, 1212201242222238322222421022121, 1212203204205228225024023022121, 1212223020322428242230203222121, 1212421210024248424200121242121, 1232100000000246420000000012321, 1232100244200258520024420012321, 1232102222221248421222222012321, 1232122200322248422230022212321, 1232322010022448442200102232321, 1234321000002468642000001234321, 4000000000000008000000000000004, 4844486878939076709398786844484, 6574372239019762679109322734756, 9403095533541415141453355903049, 9659504223792743472973224059569, 9848294822582726272852284928489\n  ])\n  \n  filtered_table = np.array([0, 1, 4, 9, 121, 484, 10201, 12321, 14641, 40804, 44944, 1002001,\n         1234321, 4008004, 100020001, 102030201, 104060401, 121242121,\n         123454321, 125686521, 400080004, 404090404, 10000200001,\n         10221412201, 12102420121, 12345654321, 40000800004, 1000002000001,\n         1002003002001, 1004006004001, 1020304030201, 1022325232201,\n         1024348434201, 1210024200121, 1212225222121, 1214428244121,\n         1232346432321, 1234567654321, 4000008000004, 4004009004004,\n         100000020000001, 100220141022001, 102012040210201, 102234363432201,\n         121000242000121, 121242363242121, 123212464212321, 123456787654321,\n         400000080000004, 10000000200000001, 10002000300020001,\n         10004000600040001, 10020210401202001, 10022212521222001,\n         10024214841242001, 10201020402010201, 10203040504030201,\n         10205060806050201, 10221432623412201, 10223454745432201,\n         12100002420000121, 12102202520220121, 12104402820440121,\n         12122232623222121, 12124434743442121, 12321024642012321,\n         12323244744232321, 12343456865434321, 12345678987654321,\n         40000000800000004, 40004000900040004, 1000000002000000001,\n         1000220014100220001, 1002003004003002001, 1002223236323222001,\n         1020100204020010201, 1020322416142230201, 1022123226223212201,\n         1022345658565432201, 1210000024200000121, 1210242036302420121,\n         1212203226223022121, 1212445458545442121, 1232100246420012321,\n         1232344458544432321, 1234323468643234321, 4000000008000000004,\n         100000000020000000001, 100002000030000200001, 100004000060000400001,\n         100020201040102020001, 100022201252102220001, 100024201484102420001,\n         100200120040021002001, 100202122050221202001, 100204124080421402001,\n         100220341262143022001, 100222343474343222001, 102010002040200010201,\n         102012022050220210201, 102014042080240410201, 102030405060504030201,\n         102032425272524230201, 102212122262221212201, 102214144272441412201,\n         102232545484545232201, 102234567696765432201, 121000000242000000121,\n         121002200252002200121, 121004400282004400121, 121022221262122220121,\n         121024421474124420121, 121220122262221022121, 121222324272423222121,\n         121242363484363242121, 121244565696565442121, 123210002464200012321,\n         123212222474222212321, 123232425484524232321, 123234645696546432321,\n         123432124686421234321, 123434346696643434321, 400000000080000000004,\n         400004000090000400004, 10000000000200000000001,\n         10000220001410002200001, 10002002100400120020001,\n         10002222123632122220001, 10020010200400201002001,\n         10020230421612403202001, 10022014302620341022001,\n         10022234545854543222001, 10201000020402000010201,\n         10201222221612222210201, 10203022140604122030201,\n         10203244363836344230201, 10221210222622201212201,\n         10221432643834623412201, 10223234344844343232201,\n         12100000002420000000121, 12100242003630024200121,\n         12102202302620320220121, 12102444325852344420121,\n         12122010222622201022121, 12122252443834425222121,\n         12124214524842541242121, 12321000024642000012321,\n         12321244225852244212321, 12323222344844322232321,\n         12343210246864201234321, 40000000000800000000004,\n         1000000000002000000000001, 1000002000003000002000001,\n         1000004000006000004000001, 1000020200104010020200001,\n         1000022200125210022200001, 1000024200148410024200001,\n         1000200030004000300020001, 1000202030205020302020001,\n         1000204030408040304020001, 1000220232126212320220001,\n         1000222232347432322220001, 1002001002004002001002001,\n         1002003004005004003002001, 1002005006008006005002001,\n         1002021222306032221202001, 1002023224327234223202001,\n         1002201232026202321022001, 1002203234227224323022001,\n         1002221454348434541222001, 1002223456569656543222001,\n         1020100000204020000010201, 1020102020205020202010201,\n         1020104040208020404010201, 1020120402306032040210201,\n         1020122422327232242210201, 1020302030406040302030201,\n         1020304050607060504030201, 1020322434528254342230201,\n         1020324454749474544230201, 1022121002226222001212201,\n         1022123024227224203212201, 1022141424528254241412201,\n         1022143446549456443412201, 1022323232448442323232201,\n         1022325254649464525232201, 1210000000024200000000121,\n         1210002200025200022000121, 1210004400028200044000121,\n         1210022220126210222200121, 1210024420147410244200121,\n         1210220032026202300220121, 1210222232227222322220121,\n         1210242254148414522420121, 1210244454369634544420121,\n         1212201002226222001022121, 1212203204227224023022121,\n         1212223242528252423222121, 1212225444549454445222121,\n         1212421234248424321242121, 1212423436449446343242121,\n         1232100000246420000012321, 1232102220247420222012321,\n         1232122422348432242212321, 1232124642369632464212321,\n         1232322032448442302232321, 1232324252649462524232321,\n         1234321002468642001234321, 1234323224469644223234321,\n         4000000000008000000000004, 4000004000009000004000004,\n         100000000000020000000000001, 100000220000141000022000001,\n         100002002010040010200200001, 100002222012363210222200001,\n         100020001200040002100020001, 100020221222161222122020001,\n         100022003410262014300220001, 100022223434585434322220001,\n         100200100020040020001002001, 100200320240161042023002001,\n         100202104032060230401202001, 100202324254383452423202001,\n         100220121220262022121022001, 100220341462383264143022001,\n         100222125432484234521222001, 102010000002040200000010201,\n         102010222202161202222010201, 102012022032060230220210201,\n         102012244234383432442210201, 102030201204060402102030201,\n         102030423426181624324030201, 102032223434282434322230201,\n         102212100022262220001212201, 102212322442383244223212201,\n         102214124054282450421412201, 102232321224484422123232201,\n         121000000000242000000000121, 121000242000363000242000121,\n         121002202210262012202200121, 121002444212585212444200121,\n         121022001220262022100220121, 121022243242383242342220121,\n         121024203630484036302420121, 121220100022262220001022121,\n         121220342242383242243022121, 121222304234282432403222121,\n         121242121242484242121242121, 123210000002464200000012321,\n         123210244202585202442012321, 123212222232484232222212321,\n         123232201224484422102232321, 123432100024686420001234321,\n         400000000000080000000000004, 10000000000000200000000000001,\n         10000002000000300000020000001, 10000004000000600000040000001,\n         10000020200010401000202000001, 10000022200012521000222000001,\n         10000024200014841000242000001, 10000200021000400012000200001,\n         10000202021020502012020200001, 10000204021040804012040200001,\n         10000220221212621212202200001, 10000222221234743212222200001,\n         10002000102000400020100020001, 10002002102200500220120020001,\n         10002004102400800420140020001, 10002020304030603040302020001,\n         10002022304232723240322020001, 10002200143002620034100220001,\n         10002202143222722234120220001, 10002220345234843254302220001,\n         10002222345456965454322220001, 10020010000200400200001002001,\n         10020012002200500220021002001, 10020014004200800240041002001,\n         10020030220410601402203002001, 10020032222412721422223002001,\n         10020210221220602212201202001, 10020212223240704232221202001,\n         10020230441632823614403202001, 10020232443654945634423202001,\n         10022012102202620220121022001, 10022014104402720440141022001,\n         10022032324432823442323022001, 10022034326634943662343022001,\n         10022212343224842234321222001, 10022214345444944454341222001,\n         10201000000020402000000010201, 10201002020020502002020010201,\n         10201004040020802004040010201, 10201020402030603020402010201,\n         10201022422032723022422010201, 10201202021220602212020210201,\n         10201204041240704214040210201, 10201222423432823432422210201,\n         10201224443454945434442210201, 10203020102040604020102030201,\n         10203022122240704222122030201, 10203040506070807060504030201,\n         10203042526272927262524030201, 10203222143242824234122230201,\n         10203224163462926436142230201, 10221210000222622200001212201,\n         10221212022222722222021212201, 10221230422432823422403212201,\n         10221232444434943444423212201, 10221412221442824412221412201,\n         10221414243462926434241412201, 10223232102244844220123232201,\n         10223234124444944442143232201, 12100000000002420000000000121,\n         12100002200002520000220000121, 12100004400002820000440000121,\n         12100022220012621002222000121, 12100024420014741002442000121,\n         12100220023002620032002200121, 12100222223022722032222200121,\n         12100242243214841234224200121, 12100244443236963234444200121,\n         12102200102202620220100220121, 12102202302402720420320220121,\n         12102222324232823242322220121, 12102224524434943442542220121,\n         12102420145204840254102420121, 12102422345424942454322420121,\n         12122010000222622200001022121, 12122012202222722220221022121,\n         12122032240432823404223022121, 12122034442434943424443022121,\n         12122230223242824232203222121, 12122232425262926252423222121,\n         12124212102424842420121242121, 12124214304624942640341242121,\n         12321000000024642000000012321, 12321002220024742002220012321,\n         12321022422034843022422012321, 12321024642036963024642012321,\n         12321222023224842232022212321, 12321224243244944234242212321,\n         12323220102244844220102232321, 12323222322444944422322232321,\n         12343210000246864200001234321, 12343212222246964222221234321,\n         40000000000000800000000000004, 40000004000000900000040000004,\n         1000000000000002000000000000001, 1000000220000014100000220000001,\n         1000002002001004001002002000001, 1000002222001236321002222000001,\n         1000020000300004000030000200001, 1000020220302216122030220200001,\n         1000022002321026201232002200001, 1000022222323458543232222200001,\n         1000200010020004000200100020001, 1000200230042016102400320020001,\n         1000202012221206021222102020001, 1000202232243438343422322020001,\n         1000220012320026200232100220001, 1000220232344238324432320220001,\n         1000222014541248421454102220001, 1002001000002004002000001002001,\n         1002001220222016102220221002001, 1002003004005006005004003002001,\n         1002003224225238325224223002001, 1002021020302206022030201202001,\n         1002021240524418144250421202001, 1002023024325228225234203202001,\n         1002201210022026202200121022001, 1002201430264038304620341022001,\n         1002203214225228225224123022001, 1002221232322248422232321222001,\n         1020100000000204020000000010201, 1020100222200216120022220010201,\n         1020102022021206021202202010201, 1020102244221438341224422010201,\n         1020120200302206022030020210201, 1020120422504418144052240210201,\n         1020122222343228223432222210201, 1020302010020406040200102030201,\n         1020302232242418142422322030201, 1020304032241608061422304030201,\n         1020322212322428242232122230201, 1022121000002226222000001212201,\n         1022121222422238322242221212201, 1022123024025228225204203212201,\n         1022141220304428244030221412201, 1022323210022448442200123232201,\n         1210000000000024200000000000121, 1210000242000036300002420000121,\n         1210002202201026201022022000121, 1210002444201258521024442000121,\n         1210022000320026200230002200121, 1210022242322238322232422200121,\n         1210024202541048401452024200121, 1210220010022026202200100220121,\n         1210220252044038304402520220121, 1210222212423228223242122220121,\n         1210242012342048402432102420121, 1212201000002226222000001022121,\n         1212201242222238322222421022121, 1212203204205228225024023022121,\n         1212223020322428242230203222121, 1212421210024248424200121242121,\n         1232100000000246420000000012321, 1232100244200258520024420012321,\n         1232102222221248421222222012321, 1232122200322248422230022212321,\n         1232322010022448442200102232321, 1234321000002468642000001234321,\n         4000000000000008000000000000004], dtype=object)\n  \n  \n  def read_input(infile):\n      \"\"\"This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      \"\"\"\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints():\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #change the dtype?\n      \n      A, B = read_bigints()\n      \n      return (A, B)\n  \n  def is_palindrome(num):\n      digits = []\n      num = int(num)\n      while num > 0:\n          digits.append(num % 10)\n          num = num / 10 #n.b. int division (discard remainder)\n  \n      return digits == digits[::-1]\n  \n      for i in range(len(digits) / 2): #n.b. int division (skips center)\n          if digits[i] != digits[-i+1]:\n              return False\n      return True\n  \n  def solve_case_simple(case):\n      A, B = case\n      \n      if B > table_of_fairs[-1]:\n          raise ValueError, \"Ranges too big for lookup table!\"\n      \n      valid = (A <= filtered_table) * (filtered_table <= B)\n      return valid.sum()\n  \n  def solve_case(case):\n      \"\"\"Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      \"\"\"\n      \n      output = solve_case_simple(case)\n      return output\n  \n  \n  if __name__ == \"__main__\":\n      infile = open(\"%s-%s%s.in\" % (problem, tag, suffix), 'r')\n      outfile = open(\"%s-%s%s.out\" % (problem, tag, suffix), 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n", "substitutes": {"problem": ["ox", "strip", "ex", "unit", "ins"], "tag": ["include", "opt", "target", "unit", "key"], "suffix": ["accprefix", "suffance", " suffixed", " suffance", "descixed"], "table_of_fairs": ["table_of_fpair", "table_of_fair", "table_of_pairs", "table_of_cfays", "table_of_fays"]}}
{"code": " \n  \n  case = 1\n  problem = \"B\"\n  practice = False\n  \n  if practice:\n      practice = \"-practice\"\n  else:\n      practice = \"-attempt0\"\n  if case == 0:\n      infile = open(\"%s-%s%s.in\" % (problem, \"sample\", practice), 'r')\n      outfile = open(\"%s-%s%s.out\" % (problem, \"sample\", practice), 'w')        \n  elif case == 1:\n      infile = open(\"%s-%s%s.in\" % (problem, \"small\", practice), 'r')\n      outfile = open(\"%s-%s%s.out\" % (problem, \"small\", practice), 'w')    \n  elif case == 2:\n      infile = open(\"%s-%s%s.in\" % (problem, \"large\", practice), 'r')\n      outfile = open(\"%s-%s%s.out\" % (problem, \"large\", practice), 'w')   \n  else:\n      raise ValueError, 'Invalid case'\n      \n  lookup = {}\n  \n  def check_total(total, p):\n      assert type(total) == int\n      resid = total % 3\n  \n      min_nosurprise = (total / 3)    \n      max_nosurprise = (total / 3) + min(1, resid)\n      \n      \n      if resid == 1 or max_nosurprise == 10 or (resid == 0 and min_nosurprise == 0):\n          if max_nosurprise >= p:\n              return 1\n          else:\n              return -1\n  \n      if max_nosurprise >= p:\n          return 1\n      elif max_nosurprise == p-1:\n          return 0\n      else:\n          return -1\n      \n  cases = int(infile.readline().strip('\n'))\n  for i in range(cases):\n      print 'case %i of %i' % (i+1, cases)\n      line = infile.readline().split()\n      N = int(line[0])\n      S = int(line[1])\n      p = int(line[2])\n      points = []\n      for item in line[3:]:\n          points.append(int(item))\n      assert N == len(points)\n      assert p <= 10\n      assert p >= 0\n      assert S >= 0\n      assert S <= N\n      \n      always = 0\n      possible = 0\n      \n      for total in points:\n          if (total, p) in lookup:\n              depends = lookup[total, p]\n          else:\n              depends = check_total(total, p)\n          \n          if depends == 1:\n              always += 1\n          elif depends == 0:\n              possible += 1\n      \n      output = '%i' % (always + min(possible, S))\n      \n      outfile.write('Case #%i: %s\n' % (i+1, output))\n      \n  infile.close()\n  outfile.close()\n", "substitutes": {"case": ["step", "section", "Case", "condition", "division"], "problem": ["study", " problems", " situation", "fit", "model"], "practice": ["address", "study", "mm", "piece", "progress"], "infile": ["INFile", "inline", "incfile", "outfolder", "infolder"], "outfile": ["outputline", " outFile", " outfilename", "outputFile", "outfil"], "lookup": ["Lookdown", "LookUp", "setups", "setdown", "lookdown"], "total": ["P", "otal", "open", "size", "null"], "p": ["l", "pp", "pl", "t", "b"], "resid": [" resite", "resnum", "preside", " resident", "rezid"], "min_nosurprise": ["min_nosaurprise", "min_nosubprise", "min_nossurvey", "min_nosurvey", "min_posurprises"], "max_nosurprise": ["max_posureprise", "max_nosourvey", "max_nosubprise", "max_nosurevey", "max_posurparty"], "cases": ["config", "Case", "section", "shape", "es"], "i": ["ip", "j", "adi", "z", "chi"], "line": ["co", "l", "detail", "inline", "key"], "N": ["P", "Q", "J", "Z", "D"], "S": ["P", "J", "Q", "TS", "Z"], "points": ["features", "lines", "values", "sections", "sets"], "item": ["step", "ip", "page", "anything", "amp"], "always": ["Q", "J", "Z", "Ps", "H"], "possible": ["features", "new", "size", "example", "path"]}}
{"code": " \n  \n  def is_palindrome(num):\n      s1 = str(num)\n      s2 = s1[::-1]\n      return s1 == s2\n  \n  fair_numbers = []\n  for i in range(pow(10, 7)+1):\n      if is_palindrome(i):\n          num = i*i\n          if is_palindrome(num):\n              fair_numbers.append(num)\n  \n  N = int(sys.stdin.readline())\n  for T in range(1, N+1):\n      min_val, max_val = map(int, sys.stdin.readline().strip().split())\n  \n      ans = 0\n      for num in fair_numbers:\n          if num < min_val:\n              continue\n          if num > max_val:\n              break\n          ans += 1\n      print 'Case #%(T)s: %(ans)s' % locals()\n", "substitutes": {"num": ["ti", "t", "loc", "dim", "fen"], "s1": ["hs01", "S3", "hs2", "p3", "hs3"], "s2": [" s0", " s_", "ss2", "ss4", "S0"], "fair_numbers": ["fair_nodes", "fairallnotumbered", "fair_longumbers", "fair_notumbered", "fair_gnums"], "i": ["ai", "l", "ip", "j", "z"], "N": ["P", "Size", "D", "Z", "NI"], "T": ["P", "j", "Z", "D", "unit"], "min_val": ["min__val", "max_vals", "min_vals", "min__Val", "min_value"], "max_val": [" max_eval", "max__val", " max_pid", "max2eval", "max\u00b7val"], "ans": ["ents", "can", "Na", "aces", "aning"]}}
{"code": " \n  \n  for i, line in enumerate(sys.stdin):\n      if i == 0:\n          continue\n  \n      params = [int(n) for n in line.split(' ')]\n      (N, S, p) = params[:3]\n      scores = params[3:]\n  \n      (clear, possible) = (0, 0)\n      normal_min = max(p * 3 - 2, 0)\n      suprising_min = max(p * 3 - 4, 0)\n      for score in scores:\n          if p > score:\n              continue\n          elif score >= normal_min:\n              clear += 1\n          elif score >= suprising_min:\n              possible += 1\n  \n      ans = clear + min(possible, S)\n      print 'Case #%(i)s: %(ans)s' % locals()\n", "substitutes": {"i": ["ai", "l", "j", "chi", "z"], "line": ["LINE", "log", "l", "band", "cell"], "params": ["config", "shape", "ip", "es", "lines"], "n": ["l", "j", "z", "pn", "t"], "N": ["P", "Q", "J", "Z", "D"], "S": ["small", "P", "Q", "Z", "D"], "p": ["l", "pp", "t", "b", "rank"], "scores": ["oscases", "swore", "cores", " screens", "oscreens"], "clear": ["adv", "center", "missing", "save", "open"], "possible": ["possibly", "Pierra", " possibly", "npossible", "spossibly"], "normal_min": ["normal_mins", "normal67max", " normal_lower", "normal_lower", "normal67min"], "suprising_min": ["suprising_mins", "suprising_all", "supraising_min", "supraising_diff", "suprising_max"], "score": [" result", "mean", "name", "rank", "ores"], "ans": ["ces", "es", "ins", "cas", "ians"]}}
{"code": " \n  \n  \n  def calculatepalindromes(ndigits):\n      if ndigits == 1:\n          return 3\n  \n      result = 0\n      isEven = ndigits % 2 == 0\n      fillingdigits = math.floor((ndigits - 2)/2)\n  \n      if isEven:\n          result += 1\n      else:\n          result += 3\n  \n      for numones in range(0, min(6, fillingdigits) + 1):\n          combinations = int(math.factorial(fillingdigits) / (math.factorial(fillingdigits-numones) * math.factorial(numones)))\n          result += combinations\n          if not isEven:\n              result += combinations\n  \n      return result\n  \n  \n  def findpalindromes(ndigits):\n      if ndigits == 1:\n          return [1, 2, 3]\n  \n      result = []\n      isEven = ndigits % 2 == 0\n      fillingdigits = math.floor((ndigits - 2)/2)\n  \n      if isEven:\n          result.append(int(\"2\" + \"0\"*(fillingdigits*2) + \"2\"))\n      else:\n          result.append(int(\"2\" + \"0\"*fillingdigits + \"0\" + \"0\"*fillingdigits + \"2\"))\n          result.append(int(\"2\" + \"0\"*fillingdigits + \"1\" + \"0\"*fillingdigits + \"2\"))\n          result.append(int(\"1\" + \"0\"*fillingdigits + \"2\" + \"0\"*fillingdigits + \"1\"))\n  \n      for numones in range(0, min(6, fillingdigits)+1):\n          ones = fillOnes([], fillingdigits, numones)\n          for o in ones:\n              if isEven:\n                  result.append(int(\"1\" + \"\".join(o) + \"\".join(list(reversed(o))) + \"1\"))\n              else:\n                  result.append(int(\"1\" + \"\".join(o) + \"0\" + \"\".join(list(reversed(o))) + \"1\"))\n                  result.append(int(\"1\" + \"\".join(o) + \"1\" + \"\".join(list(reversed(o))) + \"1\"))\n  \n      return result\n  \n  def fillOnes(combination, size, remainingOnes):\n      if len(combination) == size:\n          return [combination]\n      result = []\n      if remainingOnes > 0:\n          c = combination + [\"1\"]\n          result += fillOnes(c, size, remainingOnes - 1)\n      if remainingOnes < size - len(combination):\n          c = combination + [\"0\"]\n          result += fillOnes(c, size, remainingOnes)\n      return result\n  \n  \n  \n  ncases = int(sys.stdin.readline())\n  \n  for t in range(1, ncases+1):\n      fairsquare = 0\n      (a, b) = sys.stdin.readline().strip().split(\" \")\n      intA = int(a)\n      intB = int(b)\n      ndigitsA = len(a)\n      ndigitsB = len(b)\n      ndigitsARooted = math.ceil(ndigitsA/2)\n      ndigitsBRooted = math.ceil(ndigitsB/2)\n  \n      if ndigitsBRooted == ndigitsARooted:\n          palindromes = findpalindromes(ndigitsARooted)\n          for p in palindromes:\n              if p ** 2 >= intA and p ** 2 <= intB:\n                  fairsquare +=1\n      else:\n          palindromes = findpalindromes(ndigitsARooted)\n          for p in palindromes:\n              if p ** 2 >= intA:\n                  fairsquare +=1\n  \n          for i in range(ndigitsARooted + 1, ndigitsBRooted):\n              fairsquare += calculatepalindromes(i)\n  \n          palindromes = findpalindromes(ndigitsBRooted)\n          for p in palindromes:\n              if p ** 2 <= intB:\n                  fairsquare +=1\n  \n      print(\"Case #%d: %d\" % (t, fairsquare))\n", "substitutes": {"ndigits": ["ngigions", "ndiggits", "ngigenits", "mdigets", "ndigbits"], "result": ["progress", "desc", "rest", "all", "function"], "isEven": ["isDown", "isiElectric", "lisDeep", "isoExactly", "sDown"], "fillingdigits": ["falingdigit", "fillingDigbits", "filingmultiplites", "fillingdigites", "fillingdimITS"], "numones": ["ncells", "numtones", "mutcycles", "numbertimes", "numoes"], "combinations": ["Combinates", " combins", "cominations", "combinators", "clination"], "ones": ["ox", "lo", "ubes", "videos", "lines"], "o": ["co", "l", "ot", "bo", "op"]}}
{"code": " \n  \n  def findbest(score):\n  \tif score == 0: return (0, 0)\n  \n  \tbest = math.ceil(score / 3)\n  \tbestsurp = round(score / 3) + 1\n  \n  \treturn (best, bestsurp)\n  \t\n  sys.stdin.readline()\n  \n  casenum = 0\n  for line in sys.stdin:\n  \tcasenum += 1\n  \n  \tdata = line.strip().split(' ')\n  \tmaxsurprising = int(data[1])\n  \tp = int(data[2])\n  \tscores = data[3:]\n  \tmaxgooglers = 0\n  \n  \tfor s in scores:\n  \t\t(best, bestsurp) = findbest(int(s))\n  \t\tif best >= p:\n  \t\t\tmaxgooglers += 1\n  \t\telse:\n  \t\t\tif bestsurp >= p and maxsurprising > 0:\n  \t\t\t\tmaxgooglers += 1\n  \t\t\t\tmaxsurprising -= 1\n  \n  \tprint(\"Case #%d: %d\" % (casenum, maxgooglers))\n", "substitutes": {"score": ["game", "size", "z", "case", "scene"], "best": ["mate", "new", "size", "obj", "alpha"], "bestsurp": ["bestsURper", "bestsarc", "bestsulm", "bestsulpe", "bistsaurP"], "casenum": ["casen", "Casum", "catum", " casen", "casumer"], "line": ["LINE", "log", "section", "l", "reader"], "data": ["alpha", "key", "i", "feed", "input"], "maxsurprising": ["maxcurprises", "maxsimprisingly", " maxsurpiring", "bestcurprise", "bestsurprises"], "p": ["P", "l", "size", "per", "pp"], "scores": ["oscopes", "oscances", "expores", " scorer", "Scores"], "maxgooglers": ["maxnoogling", "maxmoogles", "maxnoogsgers", "maxgooggling", "maxnoogsling"], "s": ["small", "es", "sq", "sec", "server"]}}
{"code": " \n  def is_square(n):\n      if n in square:\n          return True\n      if is_fair(n):\n          root = int(math.sqrt(n))\n          if root**2 != n:\n              return False\n          ss = is_fair(root)\n          if ss: square.add(n)\n          return ss\n      return False\n  \n  def is_fair(n):\n      if n in fair:\n          return True\n      if n in unfair:\n          return False\n      sn = str(n)\n      l = len(sn)\n      mid = math.ceil(n/2)\n      if sn[0:mid] == sn[mid::-1]:\n          fair.add(n)\n          return True\n      else:\n          unfair.add(n)\n          return False\n  \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n              \n      fair = set([1, 2, 3, 4, 5, 6, 7, 8, 9, 11])\n      unfair = set([12, 13, 14, 15, 16, 17, 18, 19, 20, 21])\n      square = set([1, 4])\n  \n      t = int(f.readline())\n      for _t in range(t):\n          s = f.readline()\n          if s:\n              x, y = s.split()\n              Total = sum([is_square(n) for n in range(int(x), int(y)+1)])             \n              print (\"Case #\" + str(_t+1) + \": \" + str(Total))\n      \n  \n", "substitutes": {"n": ["i", "b", "ot", "false", "all"], "root": ["section", "min", "size", "alpha", "null"], "ss": ["ssh", "css", "hess", "es", " SS"], "sn": [" SN", "size", "z", "i", "pn"], "l": ["rl", "le", "lo", "j", "z"], "mid": ["le", "ld", "mm", "middle", "min"], "f": ["fun", "ff", "fore", "df", "i"], "fn": ["fun", "ren", "FN", "pn", "loc"], "fair": ["address", "rough", "right", "rew", "respect"], "unfair": ["nobavored", "uncore", "unavored", "unmarket", "nobfair"], "square": ["rough", "clear", "right", "rew", "respect"], "t": ["tip", "j", "z", "i", "r"], "_t": ["_v", "_f", "_T", " _T", "_tf"], "s": ["ts", "es", "sq", "lines", "aces"], "x": ["ex", "ip", "z", "key", "i"], "y": ["j", "z", "yy", "i", "u"], "Total": ["Mass", "Price", "Net", "Cost", "Size"]}}
{"code": " \n  def decode_data(input):\n      output = \"\"\n      for letter in input:\n          if letter in library:\n              output += library[letter]\n      return output\n  \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())    \n      for _t in range(t):\n          s = f.readline()\n          s = s.split()\n          N = int(s[0])\n          S = int(s[1])\n          p = int(s[2])\n          low_scores = (p - 1) * 2\n          ti = s[3:]\n          ti.sort()\n          r = 0\n          ti = [int(x) for x in ti]\n          for i in ti:\n              score = i - low_scores\n              if p <= i:\n                  if score >= p:\n                      r += 1\n                  elif score >= p - 2 and S > 0:\n                      S -= 1\n                      r +=1\n          print (\"Case #\" + str(_t+1) + \": \" + str(r))\n      \n  \n", "substitutes": {"input": ["include", "config", "image", "library", "reader"], "output": ["config", "library", "format", "text", "summary"], "letter": ["format", "address", "text", "external", "knife"], "f": ["l", "z", "folder", "rf", "df"], "fn": ["fun", "library", "format", "FN", "ren"], "t": ["l", "tc", "j", "z", "size"], "_t": ["_task", "_T", " _T", " _l", "_token"], "s": ["l", "b", "us", "bis", "o"], "N": ["Q", "P", "z", "Z", "size"], "S": ["P", "Q", "TS", "size", "Z"], "p": ["P", "l", "j", "z", "pp"], "low_scores": ["low_Scales", "low_Scores", "low_encores", "low_scorer", "low_encors"], "ti": [" vi", "ita", " chi", "fi", "qi"], "r": ["rl", "P", "l", "ir", "j"], "x": ["xb", "ex", "l", "j", "z"], "i": ["P", "l", "ai", "ip", "ir"], "score": ["ester", "ir", "z", "rice", "case"]}}
{"code": " \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      \"\"\" Returns True iff y is within relative or absolute 'epsilon' of x.\n          By default, 'epsilon' is 1e-6.\n      \"\"\"\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(fd):\n      return [c for c in fd.readline().strip()]\n  \n  def read_ints(fd):\n      return [int(p) for p in fd.readline().strip().split()]\n  \n  def read_floats(fd):\n      return [float(p) for p in fd.readline().strip().split()]\n  \n  class Mtrx(object):\n      \n      def __init__(self, readfunc):\n          self.readfunc = readfunc\n          \n      def cell(self, r, c):\n          return self.data[r * self.cols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in range(self.cols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in range(self.rows)]\n      \n      def readfromfile(self, fd):\n          self.data = []\n          self.rows, self.cols = read_ints(fd)\n          for _ in range(self.rows):\n              line = self.readfunc(fd)\n              assert len(line) == self.cols\n              self.data.extend(line)\n              \n      def __str__(self):\n          res = \"\"\n          for i in xrange(self.rows):\n              res += str(self.getrow(i)) + \"\n\"\n          return res\n               \n  class IntMatrix(Mtrx):\n      def __init__(self):\n          super(IntMatrix, self).__init__(read_ints)\n  \n  class SymMatrix(Mtrx):\n      def __init__(self):\n          super(IntMatrix, self).__init__(read_syms)\n  \n  class memoizeit(object):\n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          try:\n              return self.cache[args]\n          except KeyError:\n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n  class timeit(object):\n      def __init__(self, func):\n          self.func = func\n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          print self.func.__name__, \"{:7.3f}s, (res: {})\".format(delta, value)\n          return value\n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n", "substitutes": {"x": ["l", "ex", "image", "cell", "ip"], "y": ["l", "lon", "j", "z", "sys"], "epsilon": ["apsilon", "epilln", "apsilen", "wpsilan", "apillen"], "fd": ["ld", "l", "cond", "fore", "feed"], "c": ["co", "l", "arc", "t", "ce"], "p": ["P", "l", "ip", "j", "pm"], "self": ["co", "l", "pp", "ref", "b"], "readfunc": ["readerfunc", "readingfunction", "loadfunc", " readfunction", "Readproc"], "r": ["l", "ir", "cell", "j", "u"], "i": ["l", "ai", "cell", "ip", "j"], "data": ["image", "aa", "config", "reader", "cell"], "rows": ["values", "lines", "keys", "features", "ins"], "cols": ["velgs", " coles", "celows", " cold", "Cols"], "_": ["j", "ip", "col", " all", "all"], "line": ["LINE", "log", "l", "section", "cel"], "res": ["css", "pres", "re", "val", "json"]}}
{"code": " \n  OEXT = \".out\"\n  IN_S = \"small.in\"\n  IN_L = \"large.in\"\n  CASE_PRFX = \"Case #%s: \"\n  \n  \n  def avg(L):\n      return 1.0*sum(L)/len(L)\n  \n  triplets = [[0,0,0], [0,0,1], [0,1,1], \n              [0,0,2], [0,2,2], [0,1,2],\n              [10,10,9], [10,9,8], [10,9,9], [10, 10, 8],\n              ]\n  \n  def analyze_sum(sm, tgt):\n      av = 1.0 * sm / 3\n      av_cls = av % 1\n  \n      if av_cls > 0.1:\n          ns_max_val = math.ceil(av)\n      else:\n          ns_max_val = av \n      \n      s_max_val = 0 \n      if sm >= 2 and sm <= 28:\n          if av_cls > 0.5:\n              s_max_val = math.ceil(av) + 1\n          elif av_cls > 0.1:\n              s_max_val = math.ceil(av) \n          else:\n              s_max_val = av + 1\n      \n      if ns_max_val >= tgt:\n          res = [ns_max_val, None]\n          kind = 1\n      elif s_max_val < tgt:\n          res = [None, None]\n          kind = 0\n      else:\n          res = [None, s_max_val]\n          kind = 2\n          \n      print sm, tgt, av, av_cls, ns_max_val, s_max_val, res, kind\n      return res, kind\n  \n  def analyze_triplet(trip, tgt):\n      sm = sum(trip)\n      analyze_triplet(sm, tgt)\n      \n  \n  def read_input(filename):\n      data = []\n      with open(filename, \"r\") as f:\n          cases = int(f.readline())\n          for _ in xrange(cases):\n              case = f.readline().strip().split()\n              case = [int(c) for c in case]\n              data.append({\"ngoog\": case[0], \"ssurp\": case[1], \"ptgt\": case[2],\n                           \"trips\": case[3:]})\n      return data\n  \n  def make_output(fname, output):\n      fname = fname + OEXT\n      with open(fname, \"w\") as f:\n          restext = []\n          for i, v in enumerate(output):\n              restext.append(CASE_PRFX % (i+1,) + str(v) + \"\n\")\n          f.writelines(restext)\n      \n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          ansys = [analyze_sum(c, case[\"ptgt\"]) for c in case[\"trips\"]]\n          non_surp_is_enough = len([k for _, k in ansys if k == 1])\n          surp_needed = len([k for _, k in ansys if k == 2])\n          if surp_needed >= case[\"ssurp\"]:\n              res = non_surp_is_enough + case[\"ssurp\"]\n          else:\n              res = non_surp_is_enough + surp_needed\n          output.append(res)\n      print \"output:\", output\n      make_output(fname, output)\n       \n  \n  main(\"examples.in\")\n  main(\"small.in\")\n", "substitutes": {"OEXT": ["UINFO", "MOEXT", "Hext", "HINTER", "UEXT"], "IN_S": ["In_N", "IN_SU", "In_S", "In_SI", "IN_SI"], "IN_L": ["OutJECTG", "INJECTLI", "IN2L", "IN2CL", "IN2G"], "CASE_PRFX": ["CASE_RELOPS", "CASE_POUN", "CASE_PROOPS", "CASE_PROUN", "CASE_POOP"], "L": ["P", "l", "Q", "LO", "LC"], "triplets": ["Triplets", "triples", " triples", "traples", "triplet"], "sm": ["mm", "amp", "sea", "lim", "am"], "tgt": ["atft", "Tgd", "rtgt", "reticket", "tht"], "av": ["mm", "alpha", "auth", "lim", "am"], "av_cls": ["av_pathains", "av_Clains", "av_sls", "av_CLs", "av_CLls"], "ns_max_val": ["ns_max_max", "ns_maxMlib", "ns_min_Val", "ns_maxgmax", "ns_maxMvals"], "s_max_val": ["s_maxxVal", "s_max_eval", "s_maxqpol", "s_max__val", "s_max64label"], "res": ["progress", "rest", "right", "pres", "id"], "kind": ["desc", "rest", "right", "kick", "init"], "trip": ["strip", "address", "shape", "ip", "tri"], "filename": ["rl", "summary", "save", "knife", "folder"], "data": ["config", "reader", "text", "lines", "database"], "cases": ["config", "Case", "shape", "section", "values"], "_": ["j", " b", "n", " num", "b"], "case": ["tc", "key", "sea", "ce", "character"], "c": [" code", "co", "l", "tc", "dc"]}}
{"code": "directory = 'C:/users/hai/my projects/google code jam/2013/qualification/C/'\n  \n  \n  def is_palindrome (n):\n      l = list(str(n))\n      return list(reversed(l)) == l\n  \n  def prepare ():\n      global fair_and_squares\n      fair_and_squares = []\n      \n      for i in range(1,10**7):\n          if is_palindrome(i):\n              sqr = i**2\n              if is_palindrome(sqr):\n                  fair_and_squares.append(sqr)\n      return\n  \n          \n  def solve (f_in, f_out):\n      prepare()\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          A,B = [int(x) for x in f_in.readline().split()]\n          count = len([x for x in fair_and_squares if (x>=A and x<=B)])\n          f_out.write('Case #' + str(testcase) + ': ' + str(count) + '\n')\n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n", "substitutes": {"directory": ["D", "path", "input", "volume", "connection"], "n": ["j", "z", "t", "u", "r"], "l": ["rl", "le", " L", "lo", "j"], "fair_and_squares": ["fair_and_sqakes", "fair_and_shires", "fair_and_equares", "fair_and_sqared", "fair_and_qares"], "i": ["ai", "ip", "j", "ji", "z"], "sqr": ["ipprr", " sqnr", "sqrage", "aqrt", "ippnr"], "f_in": [" f_din", "f_bin", " floglogin", "f67isin", " f_login"], "f_out": ["f_bin", "fwbin", "f_again", "l_Out", "f2out"], "T": ["Q", "P", "DT", "TS", "size"], "testcase": [" testtrial", "Testtest", "trainCase", "testcases", "xtest"], "A": ["P", "Case", "Ca", "API", "Na"], "B": ["AR", "Q", "P", "WB", "Ub"], "x": ["exc", "co", "ex", "rax", "key"], "count": ["text", "size", "key", "case", "col"], "filenames": ["ilzenamed", "filrenaming", "filennaves", "frenames", "filzenues"], "l1": ["el1", "L1", "lione", "el4", " lone"], "chosen_filename": ["chosing_filename", "chosen_queue", "chosenfqueue", "chosen_token", "chosen_Filename"]}}
{"code": "directory = 'C:/users/hai/my projects/google code jam/2012/qualification/B/'\n  \n  \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      print ('Test cases : ',T)\n      for i in range(1,T+1):\n          line = f_in.readline()\n          nnn = [int(x) for x in line.split()]\n          S = nnn[1]\n          p = nnn[2]\n          t = nnn[3:]\n          if p > 1:\n              A = 0\n              B = 0\n              for t_i in t:\n                  if t_i >=3*p-2:\n                      A += 1\n                  elif t_i >= 3*p-4:\n                      B += 1\n              result = A + min(B,S)\n          if p == 1:\n              result = len([x for x in t if x>=1])\n          if p == 0:\n              result=  len(t)\n          f_out.write('Case #' + str(i) + ': ' + str(result) + '\n')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_ctime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n  \n  \n  \n  main_run()\n", "substitutes": {"directory": ["path", "volume", "connection", "theme", "definition"], "f_in": ["e_in", "f_In", "f_IN", "f_err", " f_ini"], "f_out": [" f_run", " f_output", "f_again", "fayin", " f_write"], "T": ["P", "Q", "J", "DT", "TS"], "i": ["lo", "ai", "inter", "ip", "j"], "line": ["LINE", "log", "section", "l", "lo"], "nnn": ["nv", "tunv", "nnv", "ennb", "lnns"], "x": ["co", "ex", "l", "rax", "key"], "S": ["P", "Q", "TS", "size", "Z"], "p": ["l", "pp", "b", "pr", "ot"], "t": ["l", "b", "ot", "int", "rt"], "A": ["P", "Q", "API", "As", "D"], "B": ["P", "Q", "J", "WB", "Z"], "t_i": ["t__iu", "T_p", "p_I", "T_j", "t_j"], "result": ["P", "format", "answer", "summary", "text"], "filenames": ["fillenetimes", "filrenaming", "filenname", "filernames", "fillename"], "l1": ["ll1", "L1", "ll3", "lione", "ll2"], "chosen_filename": ["chosing_queue", "chosed_username", "chosen_url", "chosen_location", "chained_Filename"]}}
{"code": " \n  def isPalindrome(n) :\n      return str(n) == str(n)[::-1]\n  \n  def findPalindrome(n) :\n      if n % 2 == 0 : return [start*(10**(n/2)) + int(str(start)[::-1]) for start in range(10**(n/2-1),10**(n/2))]\n      if n == 1 : return range(1,10)\n      return [start*(10**(n/2)) + int(str(start)[:-1][::-1]) for start in range(10**(n/2),10**((n+1)/2))]\n  \n  def findPalindromeInRange(a, b) :\n      num = range(len(str(a)), len(str(b)) + 1)\n      allPalindrome = []\n      for n in num : allPalindrome += findPalindrome(n)\n      return filter(lambda x : a <= x <= b, allPalindrome)\n  \n  f = open('C-small-attempt0.in', 'r')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in range(T) :\n      A, B = map(int, f.readline()[:-1].split())\n      a = int(math.ceil(A**0.5))\n      b = int(B**0.5)\n      res = len(filter(lambda x : isPalindrome(x**2), findPalindromeInRange(a, b)))\n      outString = 'Case #' + str(case+1) + ': ' + str(res) + '\n'\n      print outString[:-1]\n      g.write(outString)\n  \n  f.close()\n  g.close()\n", "substitutes": {"n": ["l", "t", "i", "all", "ne"], "start": ["art", "key", "inf", "shift", "scale"], "a": ["aa", "ai", "l", "wa", "Na"], "b": ["l", "abb", "i", "rb", "amb"], "num": ["text", "new", "unit", "max", "loc"], "allPalindrome": ["allEllindome", "allEllindrome", "allPhilinduster", "allPalintome", "allPalandrom"], "f": ["log", "l", "fun", "ff", "j"], "g": ["log", "l", "eg", "j", "game"], "T": ["P", "Q", "J", "Case", "DT"], "case": ["exc", "section", "Case", "text", "size"], "A": ["P", "El", "Ca", "API", "Na"], "B": ["P", "WB", "API", "QB", "DB"], "res": ["rex", "exc", "reg", "es", "sol"], "outString": ["OutputLine", "againSite", " outFile", "outputStr", "outputArray"]}}
{"code": "fin = open('B-small-attempt0.in', 'r')\n  fout = open('B-output.txt', 'w')\n  \n  cases = int(fin.readline()[:-1])\n  \n  for case in range(cases) :\n      line = map(int, fin.readline()[:-1].split(' '))\n      N, S, p = line[:3]\n      T = line[3:]\n      okLimit = p + 2*max(p-1,0)\n      okIfSLimit = p + 2*max(p-2,0)\n      ok = len(filter(lambda x : x >= okLimit, T))\n      okIfS = len(filter(lambda x : okLimit > x >= okIfSLimit, T))\n      res = ok + min(okIfS, S)\n      fout.write('Case #' + str(case+1) + ': ' + str(res) + '\n')\n      \n  fin.close()\n  fout.close()\n", "substitutes": {"fin": ["fun", "cook", "progress", "prem", "fit"], "fout": ["FOut", "fouter", " ffile", "dfouter", "afinner"], "cases": ["Case", "es", "features", "lines", "jobs"], "case": [" code", "nice", "Case", " trial", "address"], "line": ["LINE", "strip", "section", "l", "le"], "N": ["P", "Q", "J", "z", "Z"], "S": ["P", "Q", "J", "TS", "size"], "p": ["P", "l", "ip", "j", "z"], "T": ["P", "Q", "Case", "DT", "TS"], "okLimit": ["pLim", "OKLim", "joblimit", "caseLim", "jobLim"], "okIfSLimit": ["okIfSLimsiter", "okIfSLumit", "okIfSLimsIT", "okIfSlIMits", "okIfSLIMited"], "ok": ["ak", "size", "ise", "max", "oc"], "okIfS": ["errorIFS", "errorIfR", "okifS", "okUnlessS", "okUnlessP"], "res": ["exp", "reg", "es", "features", "min"]}}
{"code": " \n  \n  def palindromes():\n      for digits in count(1):\n          for n in xrange(10**(digits-1), 10**digits):\n              n = str(n)\n              yield int(n + n[-2::-1])\n          for n in xrange(10**(digits-1), 10**digits):\n              n = str(n)\n              yield int(n + n[::-1])\n  \n  def is_palindrome(n):\n      n = str(n)\n      return n == n[::-1]\n  \n  def solve(A, B):\n      count = 0\n      for n in palindromes():\n          square = n**2\n          if square > B:\n              break\n          if square >= A and is_palindrome(square):\n              count += 1\n      return count\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n  \n              A, B = map(int,fin.readline().split())\n              soln = solve(A, B)\n  \n              print >> fout, \"Case #{0}: {1}\".format(case, soln)\n", "substitutes": {"digits": ["digals", "splals", "bigits", "signbits", "signins"], "n": ["l", "t", "i", "b", "all"], "A": ["Ac", "API", "D", "alpha", "i"], "B": ["Q", "J", "D", " b", "UB"], "count": ["cond", "key", "seq", "b", "all"], "square": ["co", "clear", "screen", "right", "qq"], "T": ["P", "Q", "Case", "TS", "Z"], "case": ["step", "section", "Case", "address", "shape"], "soln": ["Soln", "sol", " ssol", "Ssol", "solen"]}}
{"code": " \n  def solve(n, s, p, scores):\n      count = 0\n      for t in scores:\n          if ceil(t/3) >= p:\n              count += 1\n          elif 2 <= t <= 28 and ceil((t+2)/3) >= p and s > 0:\n              count += 1\n              s -= 1\n      return count\n  \n  if __name__ == '__main__':\n      with open(sys.argv[1], 'rU') as fin, open(sys.argv[2], 'w') as fout:\n          T = int(fin.readline())\n          for case in range(1, T+1):\n              line = map(int, fin.readline().split())\n              n, s, p, *scores = line\n              result = solve(n, s, p, scores)\n              print(\"Case #{0}: {1}\".format(case, result), file=fout)\n", "substitutes": {"n": ["l", "j", "z", "u", "i"], "s": ["l", "i", "b", "stats", "us"], "p": ["P", "l", "ip", "j", "pm"], "scores": ["osccore", " scorer", " SCores", "ascorer", "Scores"], "count": ["cond", "l", "key", "i", "b"], "t": ["P", "unt", "l", "tc", "j"], "T": ["step", "P", "section", "Case", "TS"], "case": ["step", "section", "Case", "cell", "size"], "line": ["LINE", "log", "l", "co", "text"], "result": ["mate", "cur", "text", "new", "page"]}}
{"code": " \n  def solve(lower, upper, cache):\n      counter = 0\n      for item in cache:\n          if item > upper:\n              break\n          if item < lower:\n              continue\n          counter += 1\n      return counter\n  \n  def is_palindrome(test_int):\n      str_arg = str(test_int)\n      return str_arg == str_arg[::-1]\n  \n  def generate_cache():\n      \"\"\" Generates a list of 'fair and square' numbers between 1 and 10^100\n  \n      By observation of generating the first few of these numbers it became\n      obvious that the 'roots' fitted a very specific pattern, they are either\n      single digits and 1,2 or 3; multiple digits consisting of only 1s and 0s;\n      multiple digits with a 2 at the beginning and end and 1s and 0s in the\n      middle or an odd number of digits with a single 2 in the centre and 1s and\n      0s elsewhere.\n  \n      This function therefore only looks at these numbers to build a list of all\n      valid results. \"\"\"\n      cache = [9,]\n      counter = 1\n      if upper_bound is None:\n          upper_bound = pow(2,25)\n      while counter < upper_bound:\n          binary_part = \"{0:b}\".format(counter)\n          half_int = binary_part\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          pal_int = int(half_int + half_int[::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          half_int = \"%s%s\" % (binary_part, 2)\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          half_int = \"2%s\" % binary_part[1:]\n          pal_int = int(half_int + half_int[:-1][::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          pal_int = int(half_int + half_int[::-1])\n          pal_square = pal_int * pal_int\n          if is_palindrome(pal_square):\n              cache.append(pal_square)\n          counter += 1\n      return sorted(cache)\n  \n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                        help=\"read input from FILE\", metavar=\"FILE\")\n      parser.add_option(\"-c\", \"--cache\", dest=\"cache_filename\",\n                        help=\"read/write cache from/to CACHE_FILE\", metavar=\"CACHE_FILE\")\n      parser.add_option(\"-g\", \"--generate-cache\", dest=\"generate_cache\",\n                        help=\"generate the cache file\", action=\"store_true\")\n      cache = None\n      (options, args) = parser.parse_args()\n      if options.generate_cache:\n          cache = generate_cache()\n          if not options.cache_filename:\n              output_file = open(options.cache_filename, \"w\")\n              pickle.dump(cache, output_file)\n              output_file.close()\n      else:\n          cache_file = open(options.cache_filename, \"r\")\n          cache = pickle.load(cache_file)\n          cache_file.close()\n      if not options.filename:\n          parser.error(\"Must provide a filename.\")\n      input_file = open(options.filename, \"r\")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n          case_number += 1\n          lower,upper = input_file.readline().split()\n          lower = int(lower)\n          upper = int(upper)\n          data_args = (lower, upper, cache)\n          print \"Case #%d: %s\" % (case_number, solve(*data_args))\n  \n  if __name__ == \"__main__\":\n      main()\n", "substitutes": {"lower": ["small", "l", "middle", "min", "new"], "upper": ["inter", "middle", "older", "alpha", "final"], "cache": ["co", "css", "clear", "menu", "chain"], "counter": ["clear", "progress", "key", "all", "ception"], "item": ["step", "section", "anything", "page", "amp"], "test_int": ["testing_integer", "testing_ind", "Test_arg", "testing_int", "test_integer"], "str_arg": ["str2args", " str1min", "str_slice", " str_args", "str2Arg"], "upper_bound": ["upper_Bound", "upper67bottom", "upperboundlimit", "upper_limit", "outer_Bound"], "binary_part": ["binary00party", "binary2Part", " binary_int", "binary67int", "padding00patch"], "half_int": ["halfWexp", "half_next", "half_hard", "half67ani", "half67inc"], "pal_int": ["apple_uint", "pallint", "bel2int", "half_net", "palhints"], "pal_square": ["al_close", "pal24steel", "palMsingle", "isal_inter", "cellkint"], "parser": ["section", "config", "reader", "upload", "per"]}}
{"code": " \n  def solve(N,S,p,t):\n      if p == 0:\n          return N\n      outright_wins = 0\n      potential_surprises = 0\n      win_cutoff = (p * 3) - 3\n      surprise_cutoff = win_cutoff - 2\n      for score in t:\n          if score == 0:\n              continue\n          elif score > win_cutoff:\n              outright_wins += 1\n          elif score > surprise_cutoff:\n              potential_surprises += 1\n      if potential_surprises < S:\n          return outright_wins + potential_surprises\n      else:\n          return outright_wins + S\n  \n  def parse_case(data_line):\n      bits = data_line.split()\n      N = int(bits[0])\n      S = int(bits[1])\n      p = int(bits[2])\n      t = [int(x) for x in bits[3:]]\n      return N,S,p,t\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                        help=\"read input from FILE\", metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if not options.filename:\n          parser.error(\"Must provide a filename.\")\n      input_file = open(options.filename, \"r\")\n      total_cases = int(input_file.readline())\n      case_number = 0\n      while case_number < total_cases:\n      \tcase_number += 1\n      \tdata_args = parse_case(input_file.readline())\n      \tprint \"Case #%d: %d\" % (case_number, solve(*data_args))\n  \n  if __name__ == \"__main__\":\n  \tmain()\n", "substitutes": {"N": ["P", "J", "Q", "Net", "Na"], "S": ["P", "Q", "TS", "sq", "Z"], "p": ["l", "pp", "pl", "i", "path"], "t": ["P", "l", "format", "opt", "j"], "outright_wins": ["outright_twalls", "outright_weouts", "outright_watches", "outright_twins", "outright_wains"], "potential_surprises": ["potential_surprising", "potential_generprise", "potential_wraacters", "potential_suracters", "potential_turprise"], "win_cutoff": ["win_Cutoffs", "win_CutOff", "win_cutoffer", "win_Cutoff", "win_potoffs"], "surprise_cutoff": ["surprise_cutsout", "surprise_Cutout", "surprise_coff", "surprise_cutsoffs", "surprise_cutOff"], "score": ["key", "path", "fit", "scale", "stats"], "data_line": ["data_entry", "datamatlines", "case_line", "case_block", "case_lin"], "bits": ["address", "piece", "key", "b", "tests"], "x": ["xb", "ex", " ex", "exp", "ip"], "parser": ["config", "section", "reader", "per", "loader"], "options": ["includes", "menu", "stats", "name", "utils"], "args": ["config", "exp", "image", " arg", " params"], "input_file": ["accept_string", "input_string", "inputfulclass", "input_class", "inputfulline"], "total_cases": [" total_frames", "all_cases", "total_posts", "total_frames", "totalalcases"], "case_number": ["case_count", "caseidinfo", "caseIdcount", " case_code", "Case_number"], "data_args": [" data_params", "data____args", "data__options", "data_options", "data____arg"]}}
{"code": " \n  \n  def is_palindrome(x):\n      candidate = list(str(x))\n      while len(candidate) > 1:\n          if candidate.pop(0) != candidate.pop():\n              return False\n      return True\n  \n  \n  def square(x):\n      return x * x\n  \n  \n  def solve_case(ab, case_number):\n      fs = 0\n      root = int(math.sqrt(ab[0]))\n      sq = square(root)\n      if sq < ab[0]:\n          root += 1\n          sq = square(root)\n  \n      while sq <= ab[1]:\n          if is_palindrome(root) and is_palindrome(sq):\n              fs += 1\n  \n          root += 1\n          sq = square(root)\n  \n      print \"Case #%d: %d\" % (case_number, fs)\n  \n  \n  def main():\n      r = sys.stdin\n      if len(sys.argv) > 1:\n          r = open(sys.argv[1], 'r')\n  \n      total_cases = r.readline()\n      for case_number in range(1, int(total_cases) + 1):\n          ab = map(int, r.readline().strip().split(' '))\n          solve_case(ab, case_number)\n  \n  if __name__ == \"__main__\":\n      main()\n", "substitutes": {"x": ["rex", "xb", "ex", "l", "image"], "candidate": [" candidation", "homidated", "indinate", "palider", "confidation"], "ab": ["l", "abb", "rb", "rest", "am"], "case_number": ["caseingnumber", " case_expression", "caseingstring", "case__numbered", "caseIDnumbered"], "fs": ["fee", "ff", "oots", "features", "lines"], "root": ["fixed", "feed", "right", "rew", "b"], "sq": ["qq", "shift", "sky", "area", "rt"], "r": ["rl", "l", "reader", "ir", "br"], "total_cases": ["Total_cs", "totalEtimes", "total_times", "Total_pieces", "totalEpieces"]}}
{"code": " \n  mod_plus_conv_with_s = {0:1, 1:1, 2:2}\n  mod_plus_conv_without_s = {0:0, 1:1, 2:1}\n  \n  def solve_case(s, p, scores,case_number):\n  \tans = 0\n  \tfor score in scores:\n  \t\tif p <= (score / 3) + mod_plus_conv_without_s[score % 3]:\n  \t\t\tans = ans + 1\n  \t\telif s > 0 and (score / 3) > 0: \n  \t\t\tif p <= (score / 3) + mod_plus_conv_with_s[score % 3]:\n  \t\t\t\tans = ans + 1\n  \t\t\t\ts = s - 1\n  \tprint \"Case #%d: %d\" % (case_number, ans)\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n  \tr = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n  \tcase_line = map(int, r.readline().rstrip().split(' '))\n  \tsolve_case(case_line[1], case_line[2], case_line[3:], case_number)\n  \n", "substitutes": {"mod_plus_conv_with_s": ["mod_plus_conv_withrictd", "mod_plus_conv_with_c", "mod_plus_conv_with_ssl", "mod_plus_conv_without_c", "mod_plus_conv_withricts"], "mod_plus_conv_without_s": ["mod_plus_conv_with_c", "mod_plus_conv_with_e", "mod_plus_conv_without_c", "mod_plus_conv_with_f", "mod_plus_conv_without_d"], "s": ["l", "aces", "i", "t", "b"], "p": ["P", "l", "ip", "pp", "per"], "scores": ["SCores", "Scores", "Scales", "Scors", "scales"], "case_number": ["case__numbered", "case_numbered", "case__number", "caseIDlength", "caseidnumbered"], "ans": ["aces", "aning", "am", "ations", "au"], "score": ["desc", "key", "path", " scoreboard", "scale"], "r": ["rl", "ruby", "l", "reader", "ir"], "total_cases": ["total54jobs", "Total_cells", "Total_tests", " total_lines", "total_jobs"], "case_line": ["caselypart", "casebooklines", " case_lines", "casejtext", " case_text"]}}
{"code": " \n  def isPalindrome(n):\n  \tn = str(n)\t\n  \tfor i in xrange(len(n)/2):\n  \t\tif n[i] != n[(-i-1)]:\n  \t\t\treturn False\n  \treturn True\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file(\"output.txt\", \"w\")\n  \n  T = eval(f.readline())\n  \n  for case in xrange(T):\n  \tdata = f.readline().split()\n  \tA = eval(data[0])\n  \tB = eval(data[1])\n  \n  \ti = A\n  \tfound = []\n  \twhile i <= B:\n  \t\tif isPalindrome(i):\n  \t\t\tsqrtI = math.sqrt(i)\n  \t\t\tif sqrtI == int(sqrtI):\n  \t\t\t\tif isPalindrome(int(sqrtI)):\n  \t\t\t\t\tfound.append(i)\n  \t\ti += 1\n  \n  \tfout.write(\"Case #%d: %d\n\" %(case + 1, len(found)))\n", "substitutes": {"n": ["l", "j", "z", "t", "u"], "i": ["l", "ti", "t", "fi", "b"], "inputFileName": ["inputfileName", "inputFilenameName", "outputFilePath", "inputTablePath", "inputFileCopy"], "f": ["l", "z", "obj", "t", "u"], "fout": ["FOut", "fouts", "feouts", "FOUT", " foutput"], "T": ["P", "Q", "TS", "z", "Z"], "case": ["section", "Case", "ite", "size", "ise"], "data": ["config", "aa", "text", "j", "lines"], "A": ["P", "ai", "API", "Na", "As"], "B": ["P", "Q", "J", "WB", "ab"], "found": ["created", "fixed", "l", "missing", "new"], "sqrtI": ["supprtI", "sqrtB", " sqrti", "sqratE", " sqntB"]}}
{"code": "arq = file(\"input.in\")\n  n_cases = eval(arq.readline())\n  out = file(\"output.txt\", \"w\")\n  \n  for case in xrange(n_cases):\n  \n  \tdata = arq.readline()\n  \tdata = data.strip()\n  \tdata = data.split(\" \")\n  \n  \tn = eval(data[0])\n  \ts = eval(data[1])\n  \tp = eval(data[2])\n  \n  \tscores = []\n  \tn_googlers_with_best_result = 0\n  \tcandidates = 0\n  \n  \tfor j in data[3:]:\n  \t\ti = eval(j)\n  \t\tif i%3 == 0:\n  \t\t\tscore = i/3\n  \t\t\tscores.append([score, score, score])\n  \t\telif (i+1)%3 == 0:\n  \t\t\tscore = (i+1)/3\n  \t\t\tscores.append([score-1, score, score])\n  \t\telse: #(i+2)%3 == 0\n  \t\t\tscore = (i+2)/3\n  \t\t\tscores.append([score-1, score-1, score])\n  \n  \tfor score in scores:\n  \t\tif score[2] >= p:\n  \t\t\tn_googlers_with_best_result +=1\n  \t\telif score[2] + 1 == p and score[1] == score[2] and score[2] != 0:\n  \t\t\tcandidates += 1\n  \n  \tn_googlers_with_best_result = n_googlers_with_best_result + min(s, candidates)\n  \n  \tout.write(\"Case #%d: %d\n\" % (case+1, n_googlers_with_best_result))\n", "substitutes": {"arq": ["arqs", "earq", "earQ", "earqual", "iarflow"], "n_cases": ["nb_rows", "nNrows", "nXtests", "nb_trial", "n_rows"], "out": ["log", "image", "ex", "Out", "obj"], "case": [" code", "section", "Case", " trial", "address"], "data": ["key", "feed", " Data", "input", "Data"], "n": ["l", "z", "size", "t", "nu"], "s": ["l", "es", "features", "z", "size"], "p": ["P", "l", "ip", "z", "pp"], "scores": ["Scanners", " scorer", "SCores", "escodes", "Scores"], "n_googlers_with_best_result": ["n_googlers_with_better_score", "n_googlers_with_best_Result", "n_googlers_with_better_match", "n_googlers_with_better_Result", "n_googlers_with_better_results"], "candidates": ["Candles", "candles", "candances", "charores", " candidate"], "j": ["bj", "J", " trial", "l", "adj"], "i": ["l", "ai", "ji", "z", "chi"], "score": ["color", "key", "fit", "ward", "scale"]}}
{"code": " \n  \n  def isPal(n):\n      l = str(n)\n      return l == l[::-1]\n  \n  def solve(a, b):\n      l = int(math.ceil(math.sqrt(a)))\n      u = int(math.floor(math.sqrt(b)))\n  \n      count = 0\n      for x in range(l, u + 1):\n          if isPal(x):\n              if isPal(x*x):\n                  count += 1\n      return str(count)\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          [a,b] = [int(x) for x in sys.stdin.readline().rstrip().split()]\n          result = solve(a, b)\n          print (\"Case #%s: %s\" % (i+1, result))\n  \n  \n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"n": ["j", "z", "t", "pn", "r"], "l": ["rl", " L", "j", "z", "pl"], "a": ["ak", "aa", "ai", "wa", "sta"], "b": ["j", "ab", "z", "bb", "rb"], "u": ["j", "z", "chu", "ur", "ue"], "count": ["size", "z", "case", "max", "key"], "x": ["ex", "t", "input", "xx", "int"], "N": ["P", "Q", "Na", "size", "Z"], "i": ["lo", "ai", "ip", "ir", "j"], "result": ["answer", "text", "new", "obj", "final"]}}
{"code": " \n  \n  \n  def solve(num_surprises, p, ts):\n      s = 0\n      u = 0\n      for t in ts:\n          a = int(t/3)\n          r = t % 3\n          if a+1 >= p and not r == 0:\n              u += 1\n          elif a >= p and r == 0:\n              u += 1\n          elif a > 0 and a+1 >= p and r == 0:\n              s += 1\n          elif a+2 >= p and r == 2:\n              s += 1\n  \n      return min(num_surprises, s) + u\n          \n          \n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          line = [int(x) for x in sys.stdin.readline().split()]\n          num_surprises = line[1]\n          p = line[2]\n          ts = line[3:]\n          result = solve(num_surprises, p, ts)\n          print (\"Case #%s: %s\" % (i+1, result))\n  \n  \n  if __name__ == '__main__':\n      main()\n", "substitutes": {"num_surprises": ["num_projectities", "num__surfaces", "num_disprise", "num_discharges", "num_surcharges"], "p": ["l", "pp", "pl", "b", "pr"], "ts": ["tc", "ations", "tests", "stats", "Ts"], "s": ["l", "es", "sq", "min", "z"], "u": ["l", "z", "ur", "cu", "n"], "t": ["l", "j", "z", "art", "window"], "a": ["aa", "ai", "wa", "sta", "ab"], "r": ["rl", "l", "rad", "ir", "j"], "N": ["P", "Q", "Na", "z", "Size"], "i": ["step", "lo", "l", "ip", "j"], "line": ["LINE", "log", "l", "le", "lo"], "x": ["ex", "l", "inter", "ip", "z"], "result": ["cur", "text", "new", "page", "obj"]}}
{"code": " \n  def ispal(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  def ispalsq(n):\n      sqrt = int(math.sqrt(n) + .01)\n      if sqrt ** 2 != n:\n          return False\n      return ispal(n) and ispal(sqrt)\n  \n  def search(s, l, idx):\n      if l % 2 == 0:\n          m = s + s[::-1]\n      else:\n          m = s[:-1] + s[::-1]\n      assert ispal(m)\n      n = int(m) ** 2\n      if not ispal(n):\n          return 0\n  \n      r = 1 if (a <= n <= b) else 0\n      for i in xrange(idx, len(s)):\n          s2 = list(s)\n          s2[i] = str(int(s2[i])+1)\n          s2 = ''.join(s2)\n          r += search(s2, l, i)\n      return r\n  \n  \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          a, b = map(int, f.readline().split())\n  \n          total = 0\n          for l in xrange(1, 150):\n              if 10 ** (l-1) > b:\n                  break\n              total += search(\"1\" + \"0\" * ((l-1)/2), l, 0)\n          print \"Case #%d: %d\" % (_t+1, total)\n  \n", "substitutes": {"n": ["un", "j", "z", "u", "mn"], "s": ["sa", "tests", "sh", "o", "ans"], "sqrt": ["qrate", "integrate", " sqrot", "sqrate", "shr"], "l": ["le", "j", "z", "size", "pl"], "idx": ["idex", "idy", "midz", "idexs", "idz"], "m": ["sm", "mm", "j", "z", "size"], "r": ["ir", "j", "z", "ur", " R"], "i": ["ai", "ip", "j", "ij", "z"], "s2": ["S62", "a8", "s1", "ss5", " s0"], "f": ["fun", "ff", "uf", "z", "fore"], "fn": ["rl", "fun", "format", "ren", "FN"], "t": ["j", "z", "u", "v", "qt"], "_t": ["_n", "_tt", "_T", "_b", " _T"], "a": ["aa", "ai", "wa", "sta", "ab"], "b": ["bar", "j", "ab", "z", "abb"], "total": ["otal", "ALL", "pl", "key", "au"]}}
{"code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in xrange(t):\n          ns = map(int, f.readline().split())\n          n = ns[0]\n          s = ns[1]\n          p = ns[2]\n          assert len(ns) == n + 3\n          scores = ns[3:3+n]\n  \n          sure = 0\n          if_surprising = 0\n          for x in scores:\n              not_surprising = (x + 2) / 3\n              is_surprising = (x + 4) / 3\n              if not_surprising >= p:\n                  sure += 1\n              elif (2 <= x <= 28) and is_surprising >= p:\n                  if_surprising += 1\n          print \"Case #%d: %d\" % (_t+1, sure + min(if_surprising, s))\n", "substitutes": {"f": ["l", "ff", "uf", "rf", "df"], "fn": ["typ", "fun", "format", "ren", "FN"], "t": ["l", "tc", "j", "z", "size"], "_t": ["_n", "_f", "_tt", " _tp", "_tp"], "ns": ["b", "tests", "int", "ums", "nis"], "n": ["l", "j", "z", "i", "pn"], "s": ["l", "sec", "z", "size", "sys"], "p": ["P", "l", "ip", "j", "z"], "scores": ["oscopes", "oscurs", "SCores", "oscamples", "Scopes"], "sure": ["know", "asty", "shape", "notice", "tri"], "if_surprising": ["if_surprisingly", "if_simprising", "if_simessing", "if_Surprise", "ifnotsurprises"], "x": ["ex", "l", "i", "b", "xx"], "not_surprising": ["not_urprise", "not_serprises", "not_surpiring", "not_urprises", "not_suppprising"], "is_surprising": ["is_urprises", "is_urprising", "is_Suritative", "is_Surprising", "is_urprise"]}}
{"code": " \n  \n  def readfile(file):\n    \"\"\"\n      input:\n  \n  \t\tT (number of test cases)\n  \n  \t\tA B\n  \n    \"\"\"\n  \n    tests = []\n  \n    T = int(file.readline().strip())\n  \n    for i in xrange(T):\n  \t\ttest = {}\n  \n  \t\tline = file.readline().strip()\n  \t\tparts = line.split(\" \")\n  \n  \t\tif len(parts) != 2:\n  \t\t\tprint \"HORRIBLE ERROR IN TEST CASE %d\" % (i+1,)\n  \t\t\treturn None\n  \n  \t\ttest['A'] = int(parts[0])\n  \t\ttest['B'] = int(parts[1])\n      \n  \t\ttests.append(test)\n  \n    return tests\n  \n  def isPalindrome(s):\n  \t\"\"\"\n  \t\tIs s a palindrome.\n  \n  \t\tS must be a string.\n  \t\"\"\"\n  \n  \tl = len(s)\n  \n  \tif (l % 2) == 0:\n  \t\tfrontHalf = s[0:l/2]\n  \t\tbackHalf = s[l/2:]\n  \telse:\n  \t\tfrontHalf = s[0:(l-1)/2]\n  \t\tbackHalf = s[(l+1)/2:]\n  \n  \tbackHalf = backHalf[::-1]\n  \n  \tif frontHalf == backHalf:\n  \t\treturn True\n  \telse:\n  \t\treturn False\n  \n  def isFairAndSquare(n):\n  \n  \tsqrtN = int(math.sqrt(n))\n  \n  \tif (sqrtN * sqrtN) != n:\n  \t\treturn False\n  \n  \tif not isPalindrome(str(n)):\n  \t\treturn False\n  \n  \tif not isPalindrome(str(sqrtN)):\n  \t\treturn False\n  \n  \treturn True\n  \n  def run(test):\n  \t\"\"\"\n  \t\tRun a test and return output.\n  \t\"\"\"\n  \n  \tcount = 0\n  \n  \tfor i in xrange(test['A'], test['B'] + 1):\n  \t\tif isFairAndSquare(i):\n  \t\t\tcount = count + 1\n  \n  \treturn count\n  \n  \ti = int(math.sqrt(test['A']))\n  \n  \tif (i * i) < test['A']:\n  \t\ti = i + 1\n  \n  \twhile i < test['B']:\n  \t\tif not isPalindrome(str(i)):\n  \t\t\ti = i + 1\n  \t\t\tcontinue\n  \n  \t\ts = i * i\n  \n  \t\tif s <= test['B']:\n  \t\t\tif isPalindrome(str(s)):\n  \t\t\t\tcount = count + 1\n  \t\telse:\n  \t\t\tbreak\n  \n  \t\ti = i + 1\n  \n  \treturn \"%s\" % (count, )\n  \n  file = open(sys.argv[1], \"rt\")\n  \n  tests = readfile(file)\n  \n  file.close()\n  \n  case = 1\n  \n  for test in tests:\n    result = run(test)\n    print \"Case #%d: %s\" % (case, result)\n    case = case + 1\n", "substitutes": {"file": ["feed", "path", "input", "connection", "model"], "tests": ["t", "false", "stats", "breaks", "utils"], "T": ["P", "section", "Case", "TS", "Size"], "i": ["iw", "key", "ti", "t", " I"], "test": ["address", "key", "t", "feed", "rest"], "line": ["LINE", "log", "le", "section", "cell"], "parts": ["piece", "arts", "objects", "list", "bis"], "s": ["aces", "sports", "t", "b", "stats"], "l": ["rl", "le", "log", "lo", "z"], "frontHalf": [" frontMade", "baseHalf", "bottomHalf", " frontWall", "backWall"], "backHalf": [" backPart", "frontPart", "BackPart", "Backhalf", "baseHalf"], "n": ["nv", "j", "new", "z", "t"], "sqrtN": ["sqrtA", "sqrectM", "sqRTC", " sqrM", "squrotN"], "count": ["key", "process", "b", "shift", "all"], "case": ["exc", "section", "Case", "config", "size"], "result": ["new", "page", "final", "desc", "key"]}}
{"code": " \n  def readfile(filename):\n  \t\"\"\"\n  \t\tThe first line of the input gives the number of test\n  \t\tcases, T. T test cases follow. Each test case consists of\n  \t\ta single line containing integers separated by single\n  \t\tspaces. The first integer will be N, the number of\n  \t\tGooglers, and the second integer will be S, the number\n  \t\tof surprising triplets of scores. The third integer will\n  \t\tbe p, as described above. Next will be N integers ti:\n  \t\tthe total points of the Googlers.\n  \t\"\"\"\n  \n  \tfile = open(filename, \"rt\")\n  \n  \tretval = {}\n  \n  \tT = int(file.readline().strip())\n  \tretval['T'] = T\n  \n  \ttests = []\n  \n  \tfor i in xrange(T):\n  \t\tline = file.readline().strip()\n  \n  \t\tparts = line.split(\" \")\n  \n  \t\tN = int(parts[0])\n  \t\tS = int(parts[1])\n  \t\tp = int(parts[2])\n  \t\tt = []\n  \n  \t\tfor j in xrange(N):\n  \t\t\tt = t + [int(parts[3 + j]), ]\n  \n  \t\ttest = { 'N' : N, 'S': S, 'p' : p, 't' : t }\n  \t\ttests = tests + [test, ]\n  \n  \tretval['tests'] = tests\n  \treturn retval\n  \n  def spread(triplet):\n  \treturn max(abs(triplet[0] - triplet[1]), abs(triplet[1] - triplet[2]), abs(triplet[2] - triplet[0]))\n  \n  def bestresult(triplet):\n  \tif triplet:\n  \t\treturn max(triplet)\n  \treturn 0\n  \n  def getcombos(points):\n  \t\"\"\"\n  \t\tReturns ([unsurprising possibilities, ], [surprising possibilities])\n  \t\"\"\"\n  \n  \tunsurps = []\n  \tsurps = []\n  \n  \tavg = points / 3.0\n  \n  \tavg = int(avg)\n  \n  \ttested = []\n  \n  \tfor i in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  \t\tfor j in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  \t\t\tfor k in xrange(max(avg - 2, 0), min(avg + 3, 10)+1):\n  \t\t\t\tif (i + j + k) != points:\n  \t\t\t\t\tcontinue\n  \n  \t\t\t\tscores = (i,j,k)\n  \t\t\t\tscores = sorted(scores)\n  \n  \t\t\t\tif scores in tested:\n  \t\t\t\t\tcontinue\n  \t\t\t\ttested.append(scores)\n  \n  \t\t\t\ts = spread((i,j,k))\n  \n  \t\t\t\tif (s < 2):\n  \t\t\t\t\tunsurps.append(scores)\n  \t\t\t\telif (s == 2):\n  \t\t\t\t\tsurps.append(scores)\n  \t\t\t\telse:\n  \t\t\t\t\tcontinue\n  \n  \treturn (unsurps, surps)\n  \n  def getbesttriplet(triplets):\n  \tbest = None\n  \n  \tfor i in triplets:\n  \t\tif best:\n  \t\t\tif (bestresult(i) > bestresult(best)):\n  \t\t\t\tbest = i\n  \t\telse:\n  \t\t\tbest = i\n  \n  \treturn best\n  \t\n  \n  def getmulticombos(peeps):\n  \t\"\"\"\n  \t\tReturn the best surprising and non-surprising possibility for\n  \t\teach person.\n  \t\"\"\"\n  \n  \tret = []\n  \n  \tfor p in peeps:\n  \t\tu,s = getcombos(p)\n  \n  \t\tbestu = getbesttriplet(u)\n  \t\tbests = getbesttriplet(s)\n  \n  \t\tret.append((bestu, bests))\n  \n  \treturn ret\n  \n  def getbestresults(scores, best, numsur):\n  \t\"\"\"\n  \t\tFigure out the maximum number of people that could have gotten\n  \t\ta single score >= best.  Limited to choosing only numsur surprising\n  \t\ttriplets.\n  \t\"\"\"\n  \n  \tpeeps = getmulticombos(scores)\n  \n  \tcount = 0\n  \tsurcount = 0\n  \n  \tfor p in peeps:\n  \t\tif (bestresult(p[0]) >= best):\n  \t\t\tcount = count + 1\n  \t\telif ((bestresult(p[1]) >= best) and (surcount < numsur)):\n  \t\t\tcount = count + 1\n  \t\t\tsurcount = surcount + 1\n  \n  \treturn count\n  \n  def process(test):\n  \tN = test['N']\n  \tS = test['S']\n  \tp = test['p']\n  \tt = test['t']\n  \n  \treturn getbestresults(t, p, S)\n  \n  data = readfile(\"B-small-attempt0.in\")\n  \n  for i in xrange(data['T']):\n  \ttest = data['tests'][i]\n  \n  \tresult = process(test)\n  \n  \tprint \"Case #%d: %d\" % (i+1, result)\n", "substitutes": {"filename": ["rl", "section", "ppa", "knife", "folder"], "file": ["le", "l", "log", "view", "reader"], "retval": ["reteval", "Retvals", "retvalue", "Retval", "rtvals"], "T": ["P", "J", "Q", "DT", "TS"], "tests": ["docs", "features", "values", "lines", "TS"], "i": ["l", "iw", "ti", "b", "qi"], "line": ["strip", "log", "l", "le", "section"], "parts": ["section", "format", "features", "lines", "piece"], "N": ["P", "J", "Q", "Na", "Out"], "S": ["P", "J", "Q", "Size", "D"], "p": ["P", "J", "l", "ip", "z"], "t": ["P", "l", "tc", "z", "target"], "j": ["J", "uj", "l", "b", "pr"], "test": ["step", "trip", "ester", "section", "tri"], "triplet": ["triple", "dipper", "prompper", "traple", "complet"], "points": ["windows", "grades", "breaks", "objects", "point"], "unsurps": ["untype", "Unsurpe", "untypped", "unwrape", "unserpe"], "surps": ["surples", "trip", "strips", "trips", "surplets"], "avg": ["afge", "afga", "abc", "ravgar", " avgn"], "tested": ["handled", "videos", "closed", "rounded", "raped"], "k": ["ak", "ip", "kk", "z", "key"], "scores": ["scriptorer", "cores", " scorer", "SCores", "Scores"], "s": ["l", "es", "sq", "lines", "services"], "triplets": ["dipps", "dropps", " triples", "trips", "Triplet"], "best": [" closest", "hess", "new", "suggest", "null"]}}
{"code": " \n  class Test(unittest.TestCase):\n  \tdef test_1(self):\n  \t\tself.assertEqual(main(1, 4), 2)\n  \tdef test_2(self):\n  \t\tself.assertEqual(main(10, 120), 0)\n  \tdef test_3(self):\n  \t\tself.assertEqual(main(100, 100000000000000), 2)\n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def main(M, N):\n  \tfns = 0\n  \tnum = M\n  \tmaior = math.sqrt(N)\n  \tint_maior = 0\n  \t\n  \tif maior.is_integer():\n  \t\tint_maior = int(maior) - 1\n  \t\tif fair(N):\n  \t\t\tif fair(int(maior)):\n  \t\t\t\tfns += 1\n  \telse:\n  \t\tint_maior = int(maior)\n  \t\t\n  \twhile int_maior >= 1:\n  \t\tif fair(int_maior):\n  \t\t\tquadrado = int_maior * int_maior\n  \t\t\tif quadrado >= M:\n  \t\t\t\tif fair(quadrado):\n  \t\t\t\t\tfns += 1\n  \t\tint_maior -= 1\n  \treturn fns\n  \n  def main2(M, N):\n  \tfns = 0\n  \tnum = M\n  \twhile num <= N:\n  \t\tresult = raiz(num)\n  \t\tif result:\n  \t\t\tif fair(num):\n  \t\t\t\n  \t\t\t\tif fair(result):\n  \t\t\t\t\tfns += 1\n  \t\tnum += 1\n  \treturn fns\n  \t\n  def fair(num):\n  \treturn str(num) == str(num)[::-1]\n  \t\n  def raiz(num):\n  \tresult = math.sqrt(num)\n  \tif result.is_integer():\n  \t\treturn int(result)\n  \telse:\n  \t\treturn False\n  \t\n  if __name__ == '__main__':\n  \tfor i in xrange(tCase):\t\n  \t\t\n  \t\tN,M = [int(x) for x in sys.stdin.readline().split(' ')]\t\n  \t\tprint \"Case #%d: %d\" % (i + 1, main(N,M))\n", "substitutes": {"self": ["l", "ref", "eth", "connection", "driver"], "tCase": ["ttStep", "TCase", "ttCode", " tStep", "tcase"], "M": ["P", "Q", "J", "MO", "EM"], "N": ["Q", "P", "Net", "J", "IN"], "fns": ["fouts", "dfcs", "Fns", "Fls", "cfcs"], "num": ["loc", "lim", "am", "dim", "uri"], "maior": ["maror", " maori", "mair", "hoajor", "masiro"], "int_maior": ["int_kaior", "int_dataor", "int_waor", "int_laajor", "int_dataior"], "quadrado": ["quparao", "coarmao", "quadrad", " quadrabo", "coadrada"], "result": ["alpha", "desc", "false", "function", "master"], "i": ["ip", "j", "ci", "z", "chi"], "x": ["xb", "ex", "l", "z", "u"]}}
{"code": " \n  tCase = int(sys.stdin.readline())\n  \n  def alien(frases,case):\n  \t\n  \tcase = case.replace('(','[')\n  \tcase = case.replace(')',']')\n  \t\n  \tER1 = re.compile(case, re.I)\n  \tcount = 0\n  \tfor frase in frases:\n  \t\tif ER1.search(frase):\n  \t\t\tcount += 1\n  \treturn count\n  \n  \n  for i in xrange(tCase):\t\n  \tlinha = sys.stdin.readline().split()\n  \tP = int(linha[1])\n  \tT = int(linha[2])\n  \tlist = []\n  \tfor j in range (3,len(linha)):\n  \t\tlist.append(int(linha[j]))\n  \tlist.sort(reverse=True)\n  \trealT = T*3 - 2\n  \tsupT = realT - 2\n  \t\n  \tcount = 0\n  \tfor item in list:\n  \t\tif item >= realT:\n  \t\t\tcount += 1\n  \t\telif P > 0 and item >= supT and T >= 2:\n  \t\t\tcount += 1\n  \t\t\tP -= 1\n  \t\telif P > 0 and item >= realT and T == 1:\n  \t\t\tcount += 1\n  \t\t\tP -= 1\n  \t\telif T == 0:\n  \t\t\tcount += 1\n  \t\telse:\n  \t\t\tbreak\n  \t\t\n  \tprint \"Case #%d: %d\" % (i+1, count)\n  \t\n  \t\n  \n", "substitutes": {"tCase": ["TCase", "tTime", "ttCode", " tcase", "ttcase"], "frases": ["arrase", "frased", "brages", "arraces", "arrages"], "case": ["address", "sea", "key", "ce", "rest"], "ER1": ["er1", " ER2", " EROne", "AR2", " ER3"], "count": ["l", "cond", "key", "process", "all"], "frase": ["fASE", " fraser", "Frases", "Fraser", "flASE"], "i": ["ai", "l", "ip", "ij", "z"], "linha": ["elinwa", "ilha", "ilja", "plqa", "milha"], "P": ["Q", "J", "API", "D", "Po"], "T": ["J", "Q", "DT", "TS", "Z"], "list": ["l", "pl", "t", "path", "chain"], "j": ["bj", "J", "uj", "ld", "adj"], "realT": ["imagT", "realP", "realt", "longL", "regularL"], "supT": ["virtualT", " supt", "SUPT", " supM", "SupP"], "item": ["amp", "key", "t", "ti", "character"]}}
{"code": "def sqrt(x, ge):\n      if x == 1:\n          return 1\n      sx = x >> 1\n      step = sx >> 1\n  \n      while step:\n          if sx ** 2 >= x:\n              sx = sx - step\n          else:\n              sx = sx + step\n          step = step >> 1\n  \n      if ge:\n          while not sx ** 2 < x:\n              sx = sx - 1\n          while not sx ** 2 >= x:\n              sx = sx + 1\n      else:\n          while not sx ** 2 > x:\n              sx = sx + 1\n          while not sx ** 2 <= x:\n              sx = sx - 1\n  \n      return sx\n  \n  \n  def get_start_pali(a):\n      s = str(a)\n      ls = len(s)\n      if ls == 1:\n          return s, True\n      elif ls & 1:\n          return s[:ls >> 1 + 1], True\n      else:\n          return s[:ls >> 1], False\n  \n  \n  def get_next_pali(p, m):\n      if len(p) == p.count(\"9\"):\n          if m:\n              return \"1\" + \"0\" * (len(p) - 1), False\n          else:\n              return \"1\" + \"0\" * len(p), True\n      else:\n          return str(int(p) + 1), m\n  \n  \n  def pali_to_num(p, m):\n      if m:\n          return int(p + p[-2::-1])\n      else:\n          return int(p + p[::-1])\n  \n  \n  def is_pali(a):\n      s = str(a)\n      hls = len(s) >> 1\n      return s[:hls] == s[:-hls - 1:-1]\n  \n  for i in range(int(input())):\n      a, b = tuple(map(int, input().split()))\n      sqa, sqb = sqrt(a, True), sqrt(b, False)\n  \n      p, m = get_start_pali(sqa)\n      while pali_to_num(p, m) < sqa:\n          p, m = get_next_pali(p, m)\n  \n      count = 0\n  \n      while True:\n          curr = pali_to_num(p, m)\n          if curr > sqb:\n              break\n          if is_pali(curr ** 2):\n              count = count + 1\n          p, m = get_next_pali(p, m)\n  \n      print(\"Case #{}: {}\".format(i + 1, count))\n", "substitutes": {"x": ["exc", "co", "ex", "l", "t"], "ge": ["le", "min", "z", "ite", "max"], "sx": ["statesX", "dsxc", "statessex", "southx", "sswx"], "step": ["amp", "dimension", "key", "path", "input"], "a": ["l", "alpha", "art", "t", "am"], "s": ["l", "t", "ations", "sa", "tests"], "ls": ["las", "rl", "l", "le", "lo"], "p": ["l", "pp", "pl", "t", "am"], "m": ["l", "sm", "mm", "wm", "middle"], "hls": [" hll", "rhla", "hsls", "shls", " hns"], "i": ["ai", "l", "ip", "j", "z"], "b": ["xb", "l", "j", "abb", "ab"], "sqa": [" sla", " sca", "nscca", " sna", "psma"], "sqb": ["iqb", "qb", "qul", " sql", "dqn"], "count": ["cond", "l", "key", "all", "name"], "curr": [" currer", " curre", "surr", "verre", "currer"]}}
{"code": "def passes(p, t): #normal, surprising\n      q, r = divmod(t, 3)\n      if r == 0:\n          return q >= p, q + 1 >= p and q\n      elif r == 1:\n          return q + 1 >= p, q + 1 >= p and q\n      elif r == 2:\n          return q + 1 >= p, q + 2 >= p\n  \n  for case in range(int(input())):\n      st = input().strip().split()\n      n, s, p, t = int(st[0]), int(st[1]), int(st[2]), list(map(int, st[3:]))\n      result = 0\n      for i in t:\n          normal, surprising = passes(p, i)\n          if normal:\n              result += 1\n          elif surprising and s != 0:\n              result += 1\n              s -= 1\n      print(\"Case #{}: {}\".format(case + 1, result))\n", "substitutes": {"p": ["l", "pp", "pl", "b", "pr"], "t": ["P", "l", "section", "ip", "j"], "q": ["Q", "l", "ce", "b", "qi"], "r": ["rl", "l", "ir", "rf", "ur"], "case": ["section", "Case", "shape", "ip", "tri"], "st": ["ld", "pp", "rest", "input", "lt"], "n": ["l", "z", "pn", "iter", "u"], "s": ["l", "es", "j", "features", "z"], "result": ["cur", "answer", "new", "page", "final"], "i": ["l", "ip", "j", "chi", "z"], "normal": ["note", "notice", "new", "natural", "example"], "surprising": ["urprisingly", "urprising", "urging", "srprising", "Surging"]}}
{"code": "lst = [1,4,9,121,484,10201,12321,14641,40804,44944,1002001,1234321,4008004,\n      100020001,102030201,104060401,121242121,123454321,125686521,400080004,\n      404090404,10000200001,10221412201,12102420121,12345654321,40000800004,\n      1000002000001,1002003002001,1004006004001,1020304030201,1022325232201,\n      1024348434201,1210024200121,1212225222121,1214428244121,1232346432321,\n      1234567654321,4000008000004,4004009004004,100000020000001,100220141022001,\n      102012040210201,102234363432201,121000242000121,121242363242121,123212464212321,\n      123456787654321,400000080000004]\n  \n  \n  def solve(lo,hi):\n      global lst\n      count = 0\n      for i in range(len(lst)):\n          if (lst[i] >= lo and lst[i] <= hi ):\n              count += 1\n      return count\n  \n  fname = raw_input(\"name of file: \")\n  oname = raw_input(\"output file name:\")\n  f = open(fname,\"r\")\n  out = open(oname,\"w\")\n  n = int(f.readline()[:-1])\n  case_num = 1\n  for line in f:\n      args = line[:-1].split()\n      lo = int(args[0])\n      hi = int(args[1])\n      out.write(\"Case #%d: %d\n\" %(case_num,solve(lo,hi)))\n      case_num += 1\n      \n  out.close()\n  f.close()\n      \n", "substitutes": {"lst": ["lrest", "lST", "Lrest", "elrest", "elsts"], "lo": ["LO", "le", "log", "co", "l"], "hi": ["LO", "co", "wa", "ci", "chi"], "count": ["log", "cond", "co", "lines", "size"], "i": ["ai", "l", "ip", "j", "ci"], "fname": ["cename", "cnam", "fcame", " Fname", "fcname"], "oname": ["onname", "Oname", " onam", " onamel", "uniname"], "f": ["l", "j", "fore", "z", "rf"], "out": ["log", "ex", "co", "exp", "l"], "n": ["l", "z", "size", "t", "r"], "case_num": ["case2index", "case_count", "case0index", "Case_index", "Case_id"], "line": ["LINE", "log", "l", "cell", "lines"], "args": ["exc", "ex", " arg", "lines", "obj"]}}
{"code": "fileName = raw_input(\"File name: \")\n  \n  f = open(fileName,\"r\")\n  \n  t = int(f.readline()[:-1])\n  \n  tests = []\n  \n  for i in range (t):\n      tests += [f.readline()[:-1]]\n  \n  f.close()\n  \n  \n  def compute(raw):\n      dataN = [] # keeps the max mark for not surprising\n      dataS = [] # keeps the max marks for surprisings\n      \n      items = raw.split() \n      \n      for i in range (int(items[0])):\n          ti = int(items[3+i])\n          if ti < 1:\n              dataS += [0]\n              dataN += [0]\n          elif ti > 28:\n              dataS += [10]\n              dataN += [10]\n          else:\n              dataN += [int((ti+2)/3)] # put the values for all participants\n              dataS += [int((ti+4)/3)]\n          \n          \n  \n      \n      p = int(items[2])\n      s = int(items[1])\n      \n      n_vals = dataN\n      n_vals.sort()\n      \n  \n      i=0\n      minimum = 0 # how many numbers greater than p are there in \"not surprising\"\n      if n_vals[0] < p:\n          while n_vals[-1-i] >= p:\n              minimum += 1\n              i += 1\n      else:\n          minimum = len(n_vals)\n          \n  \n      s_vals = dataS\n      s_vals.sort()\n      i=0\n      maximum = 0 # how many numbers greater than p are there in \"surprising\"\n      if s_vals[0] < p:\n          while s_vals[-1-i] >= p:\n              maximum += 1\n              i += 1\n      else:\n          maximum = len(n_vals)\n      \n      return min(maximum, minimum+s) \n      \n  \n  for i in range (t):\n      print \"Case #%d: %d\" %(i+1,compute(tests[i]))\n  \n  \n      \n", "substitutes": {"fileName": [" filePath", "filePath", " fileInfo", "fname", " fileDir"], "f": ["l", "ff", "uf", "folder", "rf"], "t": ["l", "tc", "j", "z", "size"], "tests": ["loads", "versions", "docs", "features", "lines"], "i": ["l", "rest", "ih", "b", "qi"], "raw": ["small", "strip", "RAW", "format", "view"], "dataN": [" dataNs", "alphan", "DataL", "Datan", "dataT"], "dataS": ["datI", "dataO", " DataO", " DataI", " dataP"], "items": ["es", "features", "lines", "keys", "values"], "ti": ["reci", "ai", "osi", "mie", "fee"], "p": ["l", "pp", "progress", "b", "pr"], "s": ["l", "es", "sq", "sec", "size"], "n_vals": ["n2als", "n_valid", "n2values", "n__vals", "n_als"], "minimum": ["mine", "dimension", "b", "largest", "uri"], "s_vals": ["s___mas", "siglists", "s_als", "s___vals", "s___val"], "maximum": ["dimension", "significant", "largest", "actual", "model"]}}
{"code": " \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(reader(f, *args, **kwargs))\n      return res\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      return read_ints(f)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%d'%res)\n      f.write('\n')\n  \n  \n  def aux(A, B, x, s):\n      res = 0\n      n = int(''.join(x[::-1]+x))\n      nn = n*n\n      if nn > B:\n          return res\n      if nn >= A:\n          res += 1\n      for c in [0, 1, 2]:\n          if s + c*c < 10:\n              n = int(''.join(x[::-1]+[str(c)]+x))\n              nn = n*n\n              if nn >= A and nn <= B:\n                  res += 1\n          if s + 2*c*c < 10:\n              res += aux(A, B, [str(c)]+x, s + 2*c*c)\n      return res\n  \n  def solve_small(case):\n      [A, B] = case\n      res = 0\n      for n in [1, 4, 9]:\n          if n >= A and n <= B:\n              res += 1\n      for c in [1, 2]:\n          res += aux(A, B, [str(c)], 2*c*c)\n      return res\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n", "substitutes": {"f": ["l", "fun", "fore", "uf", "t"], "b": ["l", "j", "ab", "z", "bl"], "x": ["co", "ex", "l", "t", "input"], "d": ["l", "ld", "dc", "j", "z"], "R": ["P", "Q", "J", "D", " r"], "reader": ["step", "library", "loader", "feed", "df"], "res": ["exc", "co", "css", "rest", "pres"], "i": ["l", "ai", "ip", "ir", "ij"], "solver": ["insver", "sol", "solving", "folution", "insolving"], "fn": ["l", "format", "fun", "FN", "rf"], "out_fn": ["out2fn", "outFilefn", "outningfp", "outningfil", "out_fil"], "in_fn": ["out_fp", "inningfd", "inningfn", "out_conn", "out_fd"], "T": ["P", "Q", "Case", "shape", "text"], "case": ["exc", "co", "config", "Case", "key"], "A": ["AR", "P", "J", "Na", "As"], "B": ["P", "Q", "J", "WB", "DB"], "s": ["small", "l", "es", "sq", "z"], "n": ["l", "t", "ne", "ln", "function"], "nn": ["co", "fee", "aa", "nv", "abb"], "c": ["l", "dc", "z", "cc", "t"]}}
{"code": " \n  __file__ = sys.argv[0]\n  __path__ = os.path.dirname(__file__)\n  __prob__ = os.path.basename(__path__)\n  \n  def pout(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      print(' '*d + s + ' = ' + repr(eval(s, f.f_globals, f.f_locals)))\n  \n  def perr(s, back=0):\n      f = sys._getframe(back+1)\n      d = 0\n      if 'depth' in f.f_locals:\n          d = f.f_locals['depth']\n      ERR_FILE.write(' '*d + '%s = %s\n'%(s, repr(eval(s, f.f_globals, f.f_locals))))\n  \n  def argmin(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best > y:\n              best = y\n              res = x\n      return res\n  \n  def argmax(f, s=None):\n      a = f\n      if s is None:\n          s = range(len(a))\n          f = lambda i: a[i]\n      res = None\n      for x in s:\n          y = f(x)\n          if res is None or best < y:\n              best = y\n              res = x\n      return res\n  \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_word_arr(f, R):\n      res = []\n      for i in range(R):\n          res.append(read_word(f))\n      return res\n  \n  def read_ints_arr(f, R, dtype=int, *args, **kwargs):\n      res = []\n      for i in range(R):\n          res.append(read_ints(f, *args, **kwargs))\n      return numpy.array(res, dtype)\n  \n  def solve(solver, fn, start_case=0, end_case=None, out_fn=None):\n      global ERR_FILE\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      err_fn = fn + '.err'\n      if start_case == 0:\n          append = True\n          if os.path.exists(out_fn):\n              with open(out_fn, 'r') as f:\n                  for l in f:\n                      if l[:6] == 'Case #':\n                          start_case = int(l[6:l.index(':')])+1\n      else:\n          append = False\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'a' if append else 'w') as fo:\n              with open(err_fn, 'w') as ERR_FILE:\n                  T = read_int(fi)\n                  for i in range(T):\n                      case = read_case(fi)\n                      if i+1 < start_case:\n                          continue\n                      print('Case #%d of %d'%(i+1, T))\n                      ERR_FILE.write('Case #%d of %d\n'%(i+1, T))\n                      perr('case')\n                      res = solver(case)\n                      perr('res')\n                      write_case(fo, i, res)\n                      fo.flush()\n                      if end_case is not None and i+1 == end_case:\n                          break\n  \n  def test(start_case=1, end_case=None):\n      fn = os.path.join(__path__, 'test')\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_small, fn, start_case, end_case)\n  \n  def small2(start_case=1, end_case=None):\n      fn = os.path.join(__path__, '%s-small-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case, fn + '2.out')\n  \n  def large(start_case=0, end_case=None):\n      fn = os.path.join(__path__, '%s-large-attempt0'%__prob__)\n      solve(solve_large, fn, start_case, end_case)\n  \n  \n  def read_case(f):\n      Z = read_ints(f)\n      (N, S, p) = Z[:3]\n      t = Z[3:]\n      return (N, S, p, t)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%(i+1))\n      f.write('%s'%res)\n      f.write('\n')\n  \n  FAIL = 'NO SOLUTION'\n  \n  def solve_small(case):\n      (N, S, p, t) = case\n      res = 0\n      for i in range(N):\n          if p >= 2:\n              if t[i] >= 3*p-2:\n                  res += 1\n              elif S > 0 and t[i] >= 3*p-4:\n                  res += 1\n                  S -= 1\n          elif p == 1:\n              if t[i] >= 3*p-2:\n                  res += 1\n          elif p == 0:\n              res += 1\n      return res\n  \n  solve_large = solve_small\n  \n  pout = perr\n", "substitutes": {"__file__": ["__log____", " __path___", "__log__", "__log___", "__name___"], "__path__": ["__log____", " __path___", "__log__", "__dir___", "__method__"], "__prob__": ["__probe____", "__proc___", "__probe__", "__pebe____", "__proot___"], "s": ["input", "inf", "sa", "function", "name"], "back": ["support", "add", "backed", "D", "ce"], "f": ["fun", "uf", "fore", "feed", "ref"], "d": ["ld", "D", "dim", "name", "td"], "a": ["alpha", "am", "input", "au", "another"], "res": ["css", "wcs", "ref", "rest", "right"], "x": ["ex", "key", "abc", "xx", "inf"], "y": ["key", "uy", "sky", "good", "id"], "best": ["key", "rest", "right", "rew", " Best"], "b": ["xb", "j", "ab", "z", "ib"], "R": ["P", "Q", "D", " r", "right"], "i": ["ti", " I", "fi", "ih", "qi"], "append": ["include", "add", "text", "open", "pull"], "pout": ["pdout", "procout", "procinc", "procobj", "pinc"]}}
{"code": "def esPal(x):\n  \treturn str(x) == str(x)[::-1]\n  \n  t = int(raw_input())\n  \n  for case in range(t):\n  \tline = raw_input().split(' ')\n  \ta = int(line[0])\n  \tb = int(line[1])\n  \n  \ti = int(a**.5)\n  \tif i*i != a:\n  \t\ti += 1\n  \tmax = int(b**.5)\n  \tcantidad = 0\n  \twhile i <= max:\n  \t\tif esPal(i) and esPal(i*i):\n  \t\t\tcantidad += 1\n  \t\ti += 1\n  \n  \tprint 'Case #'+str(case+1)+':', cantidad\n", "substitutes": {"x": ["ex", "text", "es", "z", "u"], "t": ["l", "tc", "j", "z", "u"], "case": ["section", "Case", "address", "size", "rice"], "line": ["LINE", "log", "section", "l", "band"], "a": ["aa", "ai", "l", "wa", "sta"], "b": ["l", "aa", "j", "min", "z"], "i": ["ai", "l", "ip", "j", "min"], "max": ["co", "min", "size", "right", "sup"], "cantidad": ["callit\u00e9", "cannity", " captity", "scantsidad", "callidad"]}}
{"code": "t = int(raw_input())\n  \n  max = [0, 1, 1, 2, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 7, 6, 7, 8, 7, 8, 9, 8, 9, 10, 9, 10, 10, 10]\n  \n  for i in range(t):\n  \tline = raw_input().split(' ')\n  \tn = int(line[0])\n  \ts = int(line[1])\n  \tp = int(line[2])\n  \n  \ttotal = 0\n  \n  \tfor j in range(3, len(line)):\n  \t\tt = int(line[j])\n  \t\tif t == 0:\n  \t\t\tif p == 0:\n  \t\t\t\ttotal += 1\n  \t\telif t%3 == 0:\n  \t\t\tif t/3 >= p:\n  \t\t\t\ttotal +=1\n  \t\t\telif t/3 + 1 >= p and s>0:\n  \t\t\t\ttotal +=1\n  \t\t\t\ts -=1\n  \t\telif t%3 == 1:\n  \t\t\tif (t+2)/3 >= p:\n  \t\t\t\ttotal +=1\n  \t\telse:\n  \t\t\tif (t+1)/3 >= p:\n  \t\t\t\ttotal +=1\n  \t\t\telif (t+1)/3 + 1 >= p and s>0:\n  \t\t\t\ttotal +=1\n  \t\t\t\ts -=1\n  \n  \n  \n  \tprint 'Case #'+str(i+1)+':', total\n  \n  \n", "substitutes": {"t": ["l", "art", "ti", "lt", "b"], "max": ["step", "maximum", "min", "size", "out"], "i": ["l", "ai", "ip", "ij", "z"], "line": ["co", "l", "inline", "key", "input"], "n": ["l", "z", "size", "pn", "count"], "s": ["l", "b", "tests", "stats", "downs"], "p": ["l", "pp", "b", "pr", "ot"], "total": ["otal", "alpha", "key", "right", "volume"], "j": ["bj", "note", "J", "uj", "l"]}}
{"code": " \n  def is_palindrome(n):\n      s = str(n)\n      return s == s[::-1] \n  \n  palindromes = [[], [1,2,3,4,5,6,7,8,9], [11,22,33,44,55,66,77,88,99]]\n  all_palindromes = palindromes[1] + palindromes[2]\n  limit = [100]\n  \n  palindromic_squares = []\n  psqtop = 0\n  psqix = 0\n  \n  stdin = sys.stdin\n  for c in xrange(int(stdin.readline())):\n      a,b = map(int, stdin.readline().split())\n  \n      while psqtop < b:\n          while psqix >= len(all_palindromes):\n              ps = []\n              pp = 10 ** (len(palindromes)-1) + 1\n              for i in range(1,10):\n                  for p in palindromes[-2]:\n                      ps.append(i * pp + 10 * p) \n              palindromes.append(ps)\n              all_palindromes.extend(ps)\n  \n          sq = all_palindromes[psqix] * all_palindromes[psqix]\n          if is_palindrome(sq):\n              palindromic_squares.append(sq)\n          psqix  += 1\n          psqtop = sq\n  \n      aix = bisect.bisect_left(palindromic_squares, a)\n      bix = bisect.bisect_right(palindromic_squares, b)\n  \n      print \"Case #%i: %i\" % (c+1, bix-aix) \n", "substitutes": {"n": ["l", "j", "z", "t", "r"], "s": ["es", "lines", "services", "sys", "new"], "palindromes": ["palndchromides", "palindrimides", "palindromeides", "palindrems", "palndchroms"], "all_palindromes": ["all_palendromee", "all_palindronES", "all_palindromee", "all_palindromises", "all_palendromeES"], "limit": ["shape", "ip", "min", "page", "pl"], "palindromic_squares": ["palindromic_squests", "palindromic_Squared", "palindromic_shared", "palindromic_squers", "palindromic_collars"], "psqtop": ["insqbot", "psqbot", "inseqtop", "pswsize", "pesqtops"], "psqix": ["tsqfix", "tsqill", " pseqix", "psqutop", "psquantix"], "stdin": ["putin", "dustout", "stinf", "stdinf", " stdIn"], "c": ["co", "l", "log", "dc", "z"], "a": ["ak", "ai", "aa", "wa", "ab"], "b": ["l", "aa", "j", "ab", "null"], "ps": ["pse", "es", "ppa", "pl", "py"], "pp": ["P", "ff", "ip", "ppa", "j"], "i": ["P", "ai", "l", "ip", "j"], "p": ["P", "ip", "j", "plug", "py"], "sq": ["esc", "seq", "qi", "qq", "sky"], "aix": ["AIX", "Aix", "Aox", " aik", " aius"], "bix": [" bica", " biz", "cica", "bica", "sbox"]}}
{"code": " \n  T = int(stdin.readline())\n  for i in xrange(1,T+1):\n  \tns = map(int, stdin.readline().split())\n  \tN,S,p = ns[0:3]\n  \t\n  \th = 0\n  \tz = 0\n  \n  \tfor n in ns[3:]:\n  \t\tif n <= 1:\n  \t\t\tif n >= p: h += 1\t\n  \t\telif (n+2) // 3 >= p:\n  \t\t\th += 1\n  \t\telif (n+4) // 3 >= p:\n  \t\t\tz += 1\n  \n  \tprint \"Case #%d: %d\" % (i, h + min(S,z))\n  \n  \n", "substitutes": {"T": ["P", "Q", "TS", "Z", "D"], "i": ["l", "inter", "ip", "j", "chi"], "ns": ["features", "lines", "ins", "sts", "eps"], "N": ["P", "Q", "J", "Z", "D"], "S": ["P", "Q", "J", "Z", "D"], "p": ["P", "l", "j", "pp", "api"], "h": ["log", "l", "oh", "j", "min"], "z": ["P", "l", "exp", "wa", "hz"], "n": ["l", "t", "b", "ot", "all"]}}
{"code": " \n  N = 10**4\n  \n  def isp(n):\n      s = str(n)\n      return s == s[::-1]\n  \n  fs = []\n  for i in range(N):\n      s = str(i)\n      n1 = int(s + s[::-1])**2\n      n2 = int(s[:-1] + s[::-1])**2\n  \n      if isp(n1):\n          fs.append(n1)\n      if isp(n2):\n          fs.append(n2)\n  \n  fs.sort()\n  \n  print(fs, file=sys.stderr)\n  \n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      board = []\n      A, B = map(int, fin.readline().split())\n  \n      i = bisect.bisect_left(fs, A)\n      j = bisect.bisect_right(fs, B)\n  \n      print(\"Case #%d: %s\" % (case, j-i))\n  \n  \n", "substitutes": {"N": ["P", "J", "Q", "Z", "D"], "n": ["l", "size", "z", "t", "r"], "s": ["l", "b", "stats", "ows", "o"], "fs": ["jobs", "Fs", "feed", "fle", "tests"], "i": ["l", " ip", "ti", "ce", " I"], "n1": ["yn2", "N2", "null", "nb1", "nb2"], "n2": ["atwo", "iTwo", "N2", "itwo", "n72"], "fin": ["spin", "fun", "fer", "lines", "rf"], "T": ["Q", "J", "Case", " trial", "P"], "case": ["exc", "config", "Case", "section", "ite"], "board": ["ff", "fer", "feed", "cas", "ss"], "A": ["AR", "P", "J", "El", "Ca"], "B": ["P", "J", "Q", "Ub", "WB"], "j": ["J", "l", "uj", "ai", "adj"]}}
{"code": " fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1,T+1):\n      numbers = map(int, fin.readline().split())\n      N, S, p = numbers[:3]\n      T = numbers[3:]\n      normal_limit = p + 2*max(0, (p-1))\n      surpising_limit = p + 2*max(0, (p-2))\n  \n      normal_count = 0\n      surprising_count = 0\n  \n      for t in T:\n          if t >= normal_limit:\n              normal_count += 1\n          elif t >= surpising_limit:\n              surprising_count += 1\n  \n      result = normal_count + min(surprising_count, S)\n  \n      print \"Case #%d: %s\" % (case, result)\n  \n", "substitutes": {"fin": ["fun", "ir", "min", "br", "final"], "T": ["P", "Q", "Case", " trial", "DT"], "case": ["step", "P", "section", " trial", "Case"], "numbers": ["nnotations", "bynums", "neumber", "nNumbers", " nundreds"], "N": ["P", "Q", "Z", "D", "H"], "S": ["P", "Q", "TS", "size", "Z"], "p": ["Q", "l", "pp", "i", "b"], "normal_limit": ["normalslimits", "normalscount", "standard_count", "standard_limit", " normal_length"], "surpising_limit": ["surpicing_limits", "surpisinginglimits", "surpising_lock", "surpise_limit", "surpisingingcount"], "normal_count": ["normal__count", "normal_base", "normallylimit", "normallyoffset", "normalscount"], "surprising_count": ["surtaining_count", "surtaining_length", "surprising67count", "surprising_check", "surprising_total"], "t": ["l", "j", "z", "i", "ti"], "result": ["cur", "answer", "new", "obj", "RESULTS"]}}
{"code": " \n  def read_ints():\n      return map(int, stdin.readline().rstrip().split(' '))\n  \n  def is_palin(n):\n      s = str(n)\n      return s == s[::-1]\n      \n  def find(n, fas):\n      for i in xrange(len(fas)):\n          if fas[i] >= n:\n              return i\n      return len(fas)\n      \n  def gen_fas(max):\n      fas = []\n      fasappend = fas.append\n      square, base, d = 1, 1, 3\n      while square < max:\n          if is_palin(square) and is_palin(base):\n              fasappend(square)\n          square += d\n          d += 2\n          base += 1\n      return fas\n      \n  def main():\n      MAX = 1000\n      fas = gen_fas(MAX)\n      \n      T = int(stdin.readline())\n      for Ti in xrange(T):\n          A, B = read_ints()\n          answer = find(B + 1, fas) - find(A, fas)\n          print 'Case #{}: {}'.format(Ti + 1, answer)\n          \n  main()\n", "substitutes": {"n": ["l", "j", "z", "size", "t"], "s": ["l", "ts", "es", "sq", "features"], "fas": ["sfas", "fingas", " fast", "lras", "sfAS"], "i": ["l", "ai", "ip", "j", "z"], "max": ["step", "shape", "min", "size", "z"], "fasappend": ["facend", "fASpush", "faosend", "fasterpush", " fasreplace"], "square": ["address", "ce", "right", "dim", "qq"], "base": ["based", "l", "address", "shape", "fixed"], "d": ["l", "dc", "min", "z", "D"], "MAX": ["LINE", "Q", "RAW", "END", "Dim"], "T": ["Q", "P", "J", "TS", "Z"], "Ti": ["lo", "ai", "P", "Wi", "ip"], "A": ["AR", "P", "Ac", "Ca", "API"], "B": ["P", "Q", "IO", "WB", "ab"], "answer": ["support", "address", "uit", "text", "new"]}}
{"code": " \n  def program():\n  \tT = int(stdin.readline())\n  \tfor Ti in xrange(T):\n  \t\tnumbers = a = map(int, stdin.readline().rstrip().split(' '))\n  \t\tN, S, p, totals = numbers[0], numbers[1], numbers[2], numbers[3:]\n  \t\t\n  \t\tm = 0\n  \t\tcurr_S = S\n  \t\tfor i in xrange(N):\n  \t\t\tt = totals[i]\n  \t\t\t\n  \t\t\tif t / 3 >= p or (t / 3 == p - 1 and t % 3 > 0):\n  \t\t\t\tm += 1\n  \t\t\telif curr_S > 0 and t > 0:\n  \t\t\t\tif (t / 3 == p - 1 and t % 3 == 0) or (t / 3 == p - 2 and t % 3 == 2):\n  \t\t\t\t\tm += 1\n  \t\t\t\t\tcurr_S -= 1\n  \t\t\n  \t\tprint 'Case #%d: %d' % (Ti + 1, m)\t\n  \t\n  if __name__ == '__main__':\n  \tprogram()\n", "substitutes": {"T": ["P", "Q", "TS", "Z", "D"], "Ti": ["P", "IO", "lo", "Wi", "Na"], "numbers": ["nnotations", "monats", "tums", " nues", " nnotations"], "a": ["P", "l", "Na", "new", "z"], "N": ["P", "Q", "Na", "Z", "D"], "S": ["P", "J", "Q", "Z", "D"], "p": ["P", "l", "lp", "ip", "j"], "totals": ["Tfatalls", "tOTalls", "totsals", "tfatales", "towal"], "m": ["l", "sm", "mm", "j", "mt"], "curr_S": ["currJP", "curR_N", "currs_s", "curr_s", "curr_T"], "i": ["Is", "II", "ai", "Q", "l"], "t": ["l", "tc", "art", "ti", "b"]}}
{"code": " \n  def get_number_of_test_case():\n      return int(raw_input().strip())\n  \n  def solve_case(t):\n      A, B = [int(x) for x in raw_input().strip().split()]\n  \n      print 'Case #%d: %d' % (t, get_number_of_palindrome(B) - get_number_of_palindrome(A - 1),)\n  \n  def get_number_of_palindrome(n):\n      ret = 0\n  \n      nt = int(math.floor(math.sqrt(n)))\n      total_column = int(math.ceil(math.ceil(math.log10(nt + 1)) / 2.0))\n      upper_limit = 10 ** total_column\n  \n      counter = 0\n      while counter < upper_limit:\n          c_str = [c for c in str(counter)]\n          c_str.reverse()\n  \n          number = str(counter)\n          for c in c_str:\n              number += c\n          number = int(number)\n          number = number ** 2\n          if number <= n and is_palindrome(number):\n              ret += 1\n  \n          number = str(counter)\n          for c in c_str[1:]:\n              number += c\n          number = int(number)\n          number = number ** 2\n          if number <= n and is_palindrome(number):\n              ret += 1\n          \n          counter += 1\n  \n      return ret\n  \n  def is_palindrome(n):\n      if n == 0:\n          return False\n      num = str(n)\n      check_len = len(num) / 2\n      ret = True\n      for i in range(check_len):\n          ret &= num[i] == num[-i - 1]\n      return ret\n  \n  T = get_number_of_test_case()\n  t = 1\n  while t <= T:\n      solve_case(t)\n      t += 1\n  \n", "substitutes": {"t": ["l", "art", "b", "ot", "int"], "A": ["AR", "P", "Q", "Ca", "Na"], "B": ["AR", "P", "Q", "J", "WB"], "x": ["xb", "ex", "l", "z", "u"], "n": ["l", "b", "ne", "int", "ln"], "ret": ["sat", "fun", "ref", "rest", "fit"], "nt": ["det", "dc", "out", "col", "count"], "total_column": ["total_layer", " total_layer", "total_row", "total54column", "total54layer"], "upper_limit": ["upper_lim", "lower_limit", "upperflowrow", "upper_limited", "upper_row"], "counter": ["b", "master", "name", "nr", "re"], "c_str": ["c7tree", "coutfr", "c6set", "c_char", "c7url"], "c": ["co", "l", "esc", "arc", "ce"], "number": ["address", " result", "byte", "key", "character"], "num": ["loc", "dim", "init", "int", "name"], "check_len": ["key_pos", "check64min", "key_no", "check64len", "keyacline"], "i": ["ai", "l", "ip", "j", "ji"], "T": ["P", "END", "DT", "Ret", "TS"]}}
{"code": "t = int(raw_input().strip())\n  t_count = 1\n  while t_count <= t:\n  \tline = raw_input().strip().split()\n  \tn = int(line[0])\n  \ts = int(line[1])\n  \tp = int(line[2])\n  \tti_list = line[3:]\n  \tp_min = max(p * 3 - 2, p)\n  \tp_min_surprise = max(p * 3 - 4, p)\n  \tresult = 0\n  \tfor ti in ti_list:\n  \t\tti = int(ti)\n  \t\tif ti >= p_min:\n  \t\t\tresult += 1\n  \t\telif p_min > p_min_surprise and ti >= p_min_surprise and s > 0:\n  \t\t\tresult += 1\n  \t\t\ts -= 1\n  \tprint 'Case #%d: %d' % (t_count, result,)\n  \tt_count += 1\n", "substitutes": {"t": ["l", "tc", "z", "i", "u"], "t_count": ["ticancache", "t_check", "i_cache", " tacset", "p_count"], "line": ["l", "detail", "inline", "key", "feed"], "n": ["l", "size", "i", "pn", "u"], "s": ["l", "ts", "es", "sq", "j"], "p": ["P", "l", "ip", "j", "pp"], "ti_list": [" ti_l", "ti2id", "ti2List", "tu2list", "tu_list"], "p_min": ["t__all", "p__Min", "pammin", "pPcount", "p__all"], "p_min_surprise": ["p_min_curprise", "p_min_surprises", "p_min_urvey", "p_min_surprising", "p_min_urprises"], "result": ["progress", "i", "int", "function", "nr"], "ti": [" vi", "ita", "i", " chi", "qi"]}}
