{"project": "qemu", "commit_id": "340849a9ff2a246bbc9a2da3f079c9fdbd2d5852", "target": 1, "func": "static int check_bind(const char *hostname, bool *has_proto)\n\n{\n\n    int fd = -1;\n\n    struct addrinfo ai, *res = NULL;\n\n    int rc;\n\n    int ret = -1;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = AF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(hostname, NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        if (rc == EAI_ADDRFAMILY ||\n\n            rc == EAI_FAMILY) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    fd = qemu_socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n    if (fd < 0) {\n\n        goto cleanup;\n\n    }\n\n\n\n    if (bind(fd, res->ai_addr, res->ai_addrlen) < 0) {\n\n        if (errno == EADDRNOTAVAIL) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    *has_proto = true;\n\n done:\n\n    ret = 0;\n\n\n\n cleanup:\n\n    if (fd != -1) {\n\n        close(fd);\n\n    }\n\n    if (res) {\n\n        freeaddrinfo(res);\n\n    }\n\n    return ret;\n\n}\n", "idx": 14775, "substitutes": {"hostname": ["addresscode", " hostnames", "hostcode", "portpath", "Hostnames", "hostnum", "portnames", "hostpath", "ipname", "HostName", "ipnum", "Hostpath", "portnum", "portname", "hostnames", "addressnum", "portcode", " hostName", "ipcode", "Hostname", "hostName", "portName", " hostpath", "addressname"], "has_proto": ["has_prebe", "has_propco", "has_propbe", "has_peocol", "has_peto", "has_prob", "has_proocol", "has_perto", "has_prodo", "has_pbe", "has_protb", "has_propb", "has_progo", "has_pocol", "has_propto", "has_perbe", "has_protdo", "has_protocol", "has_perocol", "has_Probe", "has_Prodo", "has_perpo", "has_pego", "has_prof", "has_proco", "has_Progo", "has_pto", "has_protbe", "has_propo", "has_protco", "has_protpo", "has_Prob", "has_Proto", "has_Proocol", "has_Proco", "has_pf", "has_pedo", "has_preto", "has_probe", "has_prepo", "has_preocol", "has_protto", "has_protgo", "has_protf", "has_Prof"], "ai": ["ani", "qi", "ais", "ui", "adi", " ar", "ha", "ru", " info", "qa", "ca", "ni", "config", "ia", "i", "ini", "a", "api", "ra", "ci", "na", " mi", " acc", "AI", "aii", "ati", "air", "iri", "si", " ac", "aa", "uri", "conn", "apache", "an", "rec", "ee", "hai", "ir", "info", " api", "mi", "pa", "af", "ait", "AU", "au", "aaa", "ann", "address", " ca", " li", "ay", "eni", "agi", "ac", "afi", "aur", "attr", " ja", "wa", "bi", "ae", "sa", "pai", "ar", "oci", "aud", "iat", "ami", "fa", "abi"], "res": ["func", "args", "rez", "remote", "ret", "sys", "rr", "self", "rev", "rss", "rus", "Res", "reply", "response", "gr", "core", "complete", "ru", "rs", "ray", "pre", "resources", "ra", "rar", "ass", "respond", "req", "ex", "os", "sr", "rows", "RES", "pres", "ras", "rh", "cr", "obj", "rec", "ris", "resource", "rx", "result", "rm", "resolution", "des", "reset", "arr", "results", "re", "rt", "r", "resp", "ress", "rep", "cache", "rest", "real", "vre", "reg", "rem", "run", "rap", "err"], "rc": ["ror", "RC", "rr", "ret", "rev", "uc", "bc", "rd", "sync", "core", "cc", "pc", "code", "id", "lc", "fun", "rn", "req", "auc", "rg", "ref", " src", "cmp", "ct", "error", "loc", "rh", "conn", "cr", "rank", "rec", "rb", "nc", "ck", "success", "rx", "co", "rin", "result", "ann", "rl", "inc", "c", "dc", "ac", "anc", "cb", "sc", "rt", "ack", "r", "src", "irm", "cur", "fc", "len", "round", "irc", "err"]}}
{"project": "FFmpeg", "commit_id": "8542f9c4f17125d483c40c0c5723842f1c982f81", "target": 1, "func": "static int32_t parse_gain(const char *gain)\n\n{\n\n    char *fraction;\n\n    int  scale = 10000;\n\n    int32_t mb = 0;\n\n    int sign   = 1;\n\n    int db;\n\n\n\n    if (!gain)\n\n        return INT32_MIN;\n\n\n\n    gain += strspn(gain, \" \\t\");\n\n\n\n    if (*gain == '-')\n\n        sign = -1;\n\n\n\n    db = strtol(gain, &fraction, 0);\n\n    if (*fraction++ == '.') {\n\n        while (av_isdigit(*fraction) && scale) {\n\n            mb += scale * (*fraction - '0');\n\n            scale /= 10;\n\n            fraction++;\n\n        }\n\n    }\n\n\n\n    if (abs(db) > (INT32_MAX - mb) / 100000)\n\n        return INT32_MIN;\n\n\n\n    return db * 100000 + sign * mb;\n\n}\n", "idx": 3984, "substitutes": {"gain": ["unit", "group", "gar", "paren", "hack", "gan", "wan", "guide", "dn", "gram", "atten", "ga", "conn", "nn", "go", "align", "gnu", "format", "gross", "bin", "grain", "gate", "gap", "pass", "gin", "g", "kin", "gg", "auc", "scan", "forward", "gn", "password", "inn", "parse", "config", "gam", "gender", "rank", "attr", "wm", "gb", "loss", "win", "ain", "range", "scale", "bridge", "sign", "sort", "clean", "rule", "gen", "wave", "learn", "gp", "shape", "acc", "input", "can"], "fraction": ["fractions", "bletcher", "Fletcher", "Fract", "rfract", "rference", "infraction", "lfractions", "Fancy", "infault", "infancy", "refract", "frequency", "Fraction", "bract", "ofrequency", "infractions", "rfraction", " fractions", "ofractions", "refletcher", "ofraction", "ofancy", " fault", "Fault", "feraction", "ference", "feractions", "fletcher", " fract", "Flux", "bractions", "lflux", "braction", "refractions", "flux", "fract", "inference", "infract", "lfraction", "felux", "Fractions", "Frequency", "fault", "rfractions", "refraction", " fletcher", "lfletcher", "fancy", "feletcher", "Ference", "infrequency"], "db": ["cm", "base", "fd", "ba", "dd", "sd", "sb", "nn", "bm", "ab", "dB", "mb", "ib", "d", "eb", "dl", "ma", "bc", "pg", "pb", "deb", "gg", "rb", "dy", "scan", "DB", "big", "cb", "amb", "sql", "mag", "ds", "bf", "bi", "nb", "dm", "bd", "gb", "mp", "min", "bg", "bb", "scale", "lib", "fb", "b", "Db", "dp", "real"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void arm_mptimer_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = arm_mptimer_realize;\n\n    dc->vmsd = &vmstate_arm_mptimer;\n\n    dc->reset = arm_mptimer_reset;\n\n    dc->no_user = 1;\n\n    dc->props = arm_mptimer_properties;\n\n}\n", "idx": 23277, "substitutes": {"klass": [" kcl", "skclass", "kslass", "kcl", "ksclass", " klasses", "kscl", "Klass", "sklasses", " kclass", "Kcl", "kclass", "sklass", "klasses", " kass", "skass", "Klasses", "kslasses", "kass", "Kass", "Kclass"], "data": ["after", "i", "def", "config", "ui", "this", "input", "Data", "ata", "exec", "info", "da", "cache", "dd", "load", "rc", "DATA", "loader", "session", "di", "parent", "dat", "api"], "dc": ["md", "lc", "bc", "fc", "cd", "cc", "conn", "config", "controller", "db", "cm", "d", "DC", "pc", "ds", "css", "df", "nc", "ga", "ac", "da", "cat", "dd", "design", "mc", "cf", "ctrl", "tc", "dr", "c", "rc", "spec", "dt", "dk", "tk", "gc", "cr", "enter", "fd", "cdn", "loc", "cca", "jc", "di", "doc", "dat", "disc", "ec", " DC", "vc"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_load_dcr (void)\n\n{\n\n    target_ulong val;\n\n\n\n    if (unlikely(env->dcr_env == NULL)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"No DCR environment\\n\");\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_INVAL);\n\n    } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"DCR read error %d %03x\\n\", (int)T0, (int)T0);\n\n        }\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_PRIV_REG);\n\n    } else {\n\n        T0 = val;\n\n    }\n\n}\n", "idx": 23587, "substitutes": {"val": ["reg", "name", "sel", "ee", "ref", "ind", "valid", "arg", "key", "local", "pos", "sol", "al", "entry", "size", "data", "it", "ret", "vals", "slot", "addr", "count", "var", "live", "el", "index", "num", "byte", "pid", "value", "vol", "call", "len", "test", "loc", "VAL", "base", "Val", "doc", "v", "old", "eval", "lit", "x", "prop", "type"]}}
{"project": "qemu", "commit_id": "b0d768c35e08d2057b63e8e77e7a513c447199fa", "target": 1, "func": "static gboolean pty_chr_timer(gpointer opaque)\n\n{\n\n    struct CharDriverState *chr = opaque;\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (s->connected) {\n\n        goto out;\n\n    }\n\n\n\n    /* Next poll ... */\n\n    pty_chr_update_read_handler(chr);\n\n\n\nout:\n\n    s->timer_tag = 0;\n\n    return FALSE;\n\n}\n", "idx": 13035, "substitutes": {"opaque": [" opaques", "ipaques", "oppaques", "oppacity", "opatile", "hopque", "opcode", "oppaque", "oppatile", "opac", "ipque", "operacity", "hopaque", "opaques", "operaque", "opercode", "ipacity", "opacity", "ipaque", "OPacity", " opac", "operque", "OPac", "OPque", " opque", "ipcode", "opque", " opacity", "OPaque", "ipatile", "hopacity", "hopac", " opatile", " opcode"], "chr": ["schr", "echr", "CHrb", "cherb", "ichrb", "chrs", "schsr", " chrs", "chsr", "chelr", "ichrs", "echsr", "cher", "chlr", "corlr", " chra", "Chra", " chrb", "Chr", "chrb", "CHr", "chra", "Chrb", "chrf", "corrf", "chers", "CHra", "CHrs", "echlr", "corr", "echrf", "Chrs", "corsr", "schlr", "schrf", "ichlr", "ichr", "Chlr"], "s": ["secondary", "args", "sys", "ses", "m", "self", "sync", "sg", "t", "sym", "g", "cs", "S", "submit", "new", "os", "si", "js", "sq", "session", "ps", "ss", "o", "w", "u", "p", "e", "http", "sf", "b", "n", "f", "gs", "spec", "c", "ns", "stats", "ssl", "out", "ops", "r", "services", "sie", "ds", "sa", "ts", "comments", "in"]}}
{"project": "qemu", "commit_id": "a9cf98d939c4f6539fad7e7d812ea16d96ba3dc9", "target": 0, "func": "static void arm_timer_recalibrate(arm_timer_state *s, int reload)\n\n{\n\n    uint32_t limit;\n\n\n\n    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {\n\n        /* Free running.  */\n\n        if (s->control & TIMER_CTRL_32BIT)\n\n            limit = 0xffffffff;\n\n        else\n\n            limit = 0xffff;\n\n    } else {\n\n          /* Periodic.  */\n\n          limit = s->limit;\n\n    }\n\n    ptimer_set_limit(s->timer, limit, reload);\n\n}\n", "idx": 14387, "substitutes": {"s": ["sys", "ses", "self", "service", "sync", "t", "sg", "input", "fs", "l", "i", "sym", "rs", "a", "cs", "qs", "S", "settings", "new", "os", "status", "sets", "js", "si", "scope", "es", "session", "ps", "ss", "conf", "o", "request", "w", "p", "e", "options", "info", "plugins", "http", "sf", "sb", "f", "stat", "gs", "spec", "state", "c", "serv", "ns", "xs", "is", "stats", "ssl", "side", "sl", "services", "ds", "sie", "su", "ls", "ts", "aws"], "reload": ["refill", "Reloads", "foreloads", "Refill", "recharge", "Reloader", "foreloader", "breloader", "brefill", "REplay", "refplay", "refload", "replay", "breload", "reloads", "refloader", "refcharge", "rowloader", "rowcharge", "REload", "Reload", "forefill", "REloader", "rowplay", "REcharge", "rowload", "foreload", "breloads", "reloader"], "limit": ["release", "it", "priority", "repeat", "location", "ure", "ignore", "config", "l", "i", "level", "inf", "io", "large", "limited", "source", "use", "limits", "unit", "status", "capacity", "ite", "position", "buffer", "model", "force", "filter", "view", "size", "version", "info", "match", "page", "base", "length", "count", "mode", "line", "skip", "control", "ip", "url", "timeout", "route", "block", "pin", "offset", "target", "Limit", "iter", "cache", "lock", "pos", "len", "lim", "index", "start"]}}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n    int ret = 0;\n\n\n\n    assert(p->devep == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            ret = usb_device_handle_control(s, p, request, value, index,\n\n                                            s->setup_len, s->data_buf);\n\n            if (ret == USB_RET_ASYNC) {\n\n                return USB_RET_ASYNC;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            if (ret > 0)\n\n                return 0;\n\n            return ret;\n\n        }\n\n\n\n        /* return 0 byte */\n\n        return 0;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len)\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            return len;\n\n        }\n\n\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        return USB_RET_STALL;\n\n\n\n    default:\n\n        return USB_RET_STALL;\n\n    }\n\n}\n", "idx": 19133, "substitutes": {"s": ["ns", "spec", "service", "ss", "cs", "d", "new", "qs", "sym", "ks", "h", "us", "sets", "ms", "m", "ts", "sg", "rs", "aws", "ips", "o", "su", "si", "S", "hs", "ds", "native", "bs", "f", "sv", "r", "sb", "as", "this", "l", "ins", "w", "vs", "sync", "c", "ps", "b", "sys", "es", "sq", "sf", "session", "t", "conf", "sp", "services", "n", "plugins", "g", "i", "ls", "ops", "fs", "xs", "is", "site", "e", "ssl", "ses", "js", "support", "gs", "its", "os", "parts", "se", "server", "y", "u"], "p": ["pc", "per", "wp", "m", "j", "t", "data", "fp", "f", "jp", "op", "sp", "vp", "r", "pe", "n", "press", "script", "g", "bp", "i", "cp", "lp", "ap", "pb", "o", "ip", "l", "d", "gp", "pp", "up", "pi", "pre", "e", "pa", "cop", "q", "v", "c", "ps", "post", "mp", "b", "h", "proc", "api", "pro", "tp", "py", "np", "y", "P", "u"], "request": ["require", "session", "work", "data", "user", "name", "call", "buffer", "report", "result", "query", "method", "type", "rf", "claim", "create", "ip", "store", "pair", "header", "complete", "event", "initial", "back", "use", "config", "key", "pull", "response", "queue", "q", "open", "hello", "id", "req", "access", "url", "address", "Request", "condition", "xml", "resource", "requ", "message", "frame", "callback", "desc", "demand", "command", "order", "input"], "value": ["set", "values", "Value", "data", "view", "element", "sample", "volume", "name", "info", "media", "ve", "buffer", "property", "money", "result", "option", "show", "function", "range", "pair", "val", "change", "complete", "rule", "flow", "ue", "length", "response", "key", "wave", "hello", "v", "update", "VALUE", "off", "fee", "resource", "output", "dollar", "wa", "number", "message", "end", "server", "version"], "index": ["part", "offset", "where", "data", "x", "search", "call", "element", "edit", "action", "inc", "input", "num", "i", "match", "type", "in", "Index", "slice", "ind", "pos", "min", "context", "val", "size", "length", "key", "pull", "id", "open", "update", "position", "include", "success", "condition", "address", "area", "append", "weight", "end", "valid", "connect", "len"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,\n\n                                    uint64_t offset,\n\n                                    int n_start, int n_end,\n\n                                    int *num, QCowL2Meta *m)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int l2_index, ret;\n\n    uint64_t l2_offset, *l2_table, cluster_offset;\n\n    int nb_clusters, i = 0;\n\n    QCowL2Meta *old_alloc;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);\n\n    if (ret == 0)\n\n        return 0;\n\n\n\n    nb_clusters = size_to_clusters(s, n_end << 9);\n\n\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    cluster_offset = be64_to_cpu(l2_table[l2_index]);\n\n\n\n    /* We keep all QCOW_OFLAG_COPIED clusters */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COPIED) {\n\n        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,\n\n                &l2_table[l2_index], 0, 0);\n\n\n\n        cluster_offset &= ~QCOW_OFLAG_COPIED;\n\n        m->nb_clusters = 0;\n\n\n\n        goto out;\n\n    }\n\n\n\n    /* for the moment, multiple compressed clusters are not managed */\n\n\n\n    if (cluster_offset & QCOW_OFLAG_COMPRESSED)\n\n        nb_clusters = 1;\n\n\n\n    /* how many available clusters ? */\n\n\n\n    while (i < nb_clusters) {\n\n        i += count_contiguous_clusters(nb_clusters - i, s->cluster_size,\n\n                &l2_table[l2_index], i, 0);\n\n\n\n        if(be64_to_cpu(l2_table[l2_index + i]))\n\n            break;\n\n\n\n        i += count_contiguous_free_clusters(nb_clusters - i,\n\n                &l2_table[l2_index + i]);\n\n\n\n        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        if ((cluster_offset & QCOW_OFLAG_COPIED) ||\n\n                (cluster_offset & QCOW_OFLAG_COMPRESSED))\n\n            break;\n\n    }\n\n    nb_clusters = i;\n\n\n\n    /*\n\n     * Check if there already is an AIO write request in flight which allocates\n\n     * the same cluster. In this case we need to wait until the previous\n\n     * request has completed and updated the L2 table accordingly.\n\n     */\n\n    LIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {\n\n\n\n        uint64_t end_offset = offset + nb_clusters * s->cluster_size;\n\n        uint64_t old_offset = old_alloc->offset;\n\n        uint64_t old_end_offset = old_alloc->offset +\n\n            old_alloc->nb_clusters * s->cluster_size;\n\n\n\n        if (end_offset < old_offset || offset > old_end_offset) {\n\n            /* No intersection */\n\n        } else {\n\n            if (offset < old_offset) {\n\n                /* Stop at the start of a running allocation */\n\n                nb_clusters = (old_offset - offset) >> s->cluster_bits;\n\n            } else {\n\n                nb_clusters = 0;\n\n            }\n\n\n\n            if (nb_clusters == 0) {\n\n                /* Set dependency and wait for a callback */\n\n                m->depends_on = old_alloc;\n\n                m->nb_clusters = 0;\n\n                *num = 0;\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!nb_clusters) {\n\n        abort();\n\n    }\n\n\n\n    LIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);\n\n\n\n    /* allocate a new cluster */\n\n\n\n    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);\n\n\n\n    /* save info needed for meta data update */\n\n    m->offset = offset;\n\n    m->n_start = n_start;\n\n    m->nb_clusters = nb_clusters;\n\n\n\nout:\n\n    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);\n\n\n\n    *num = m->nb_available - n_start;\n\n\n\n    return cluster_offset;\n\n}\n", "idx": 9548, "substitutes": {"bs": ["vs", "base", "bb", "ks", "ds", "bas", "bm", "b", "iss", "sa", "ls", "pb", "cb", "gb", "bits", "us", "rs", "BS", "os", "bc", "js", "obs", "cs", "bl", "bps", "es", "bh", "lb", "bi", "ns", "sb", "ms", "fs", "ses", "ps", "ob", "css", "ss", "bos"], "offset": ["count", "location", "seq", "timeout", "base", "initial", "start", "nb", "len", "prefix", "conn", "id", "shift", "slot", "ron", "config", "ref", "addr", "meta", "fp", "set", "off", "loc", "o", "index", "alloc", "size", "slice", "end", "address", "acl", "part", "position", "error", "type", "pos", "url", "fee", "Offset", "reset"], "n_start": [" n_base", "nunlast", "n_last", "nFlast", " n_last", "nFbase", "nFend", "nFstart", "n_base", "nunbase", "nunend", "nunstart"], "n_end": ["n_info", "n__start", " n2info", "n__all", " n2start", " n_all", " n2all", "nunstop", " n_stop", "nunrange", "n2end", "n2info", " n2end", "n_range", " n_range", "n_all", "n__end", "n__info", "n2all", "n_stop", "n2start", "nunend", "nunstart", " n_info"], "num": ["count", "seq", "dim", "len", "alt", "id", "mult", "mem", "con", "batch", "max", "split", "number", "off", "f", "mid", "multi", "index", "ctr", "Num", "node", "orig", "init", "uni", "fn", "um", "NUM"], "m": ["man", "n", "g", "mr", "bm", "b", "t", "mm", "gm", "mem", "d", "i", "metadata", "c", "p", "meta", "e", "machine", "pm", "f", "manager", "fm", "o", "mp", "v", "mi", "r", "md", "sm", "ms", "tm", "dm", "h", "cm", "mt", "M", "mc", "rm"], "s": ["vs", "sg", "ts", "ks", "sv", "ds", "is", "si", "g", "its", "sites", "stats", "b", "t", "stat", "ops", "gs", "sa", "c", "p", "ls", "se", "e", "ins", "qs", "xs", "rs", "sq", "js", "os", "f", "cs", "sym", "sets", "S", "v", "sync", "states", "sl", "state", "services", "sn", "ns", "storage", "sb", "spec", "ms", "sys", "sim", "ses", "fs", "su", "ps", "y", "ss", "settings"], "l2_index": ["l2acindex", "l96_lock", "l2_region", "l2_dimension", "l2Mdimension", "lao_index", "l2hthread", "l2_slice", "l52Jthread", "l96Jdimension", "l2_length", "lappingJlength", "l2dslice", "l2xinfo", "l4_info", "l2Cposition", "l2Hindex", "l96Jwidth", "l96_width", "laoamcount", "l2_header", "l2kindex", "l2_ini", "l2_module", "l52_module", "l2vkey", "l2vregion", "l2Jlock", "l2amcount", "l2dini", "laoammodule", "l96_dimension", "lapping_index", "l1_length", "l2_shape", "l2_key", "l2_value", "l2dindex", "l4_region", "l2kheader", "l2hmodule", "l2klabel", "l2Mindex", "l96_index", "l2Jlabel", "l2Jthread", "l1_index", "lapping_length", "l2xslice", "l2Mwidth", "l52_thread", "l2vindex", "lappingJindex", "l22dslice", "l2amindex", "l2ammodule", "l22dindex", "l2Celement", "l22dini", "l4_slice", "l4_size", "l52Jindex", "l22_ini", "l22_slice", "l22_element", "l2_Index", "l1_slice", "l2amshape", "ltwo_value", "l2Hwidth", "l2acelement", "l2Jdimension", "l4_Index", "l2_label", "ltwo_index", "l52Jmodule", "l2fheader", "l2hindex", "l2Hdimension", "l2xindex", "l2klength", "l52_index", "lao_count", "l2Jheader", "l4_key", "lappingJlabel", "ltwo_element", "laoamshape", "l2Hlock", "l96Jlock", "lapping_header", "l2Jmodule", "l2acvalue", "l4_index", "lao_module", "l22delement", "lapping_label", "lao_shape", "l2_lock", "l1_size", "ltwo_position", "l52Jpath", "lappingJheader", "l2Mlock", "l2_width", "l2Cvalue", "laoamindex", "l2_thread", "l22_index", "l2acposition", "l2delement", "l2hpath", "l2_path", "l52_path", "l2_count", "l2Jindex", "l2xlength", "l2Cindex", "l2Jlength", "l2findex", "l2_info", "l2flabel", "l2_position", "l2_size", "l2Jwidth", "l96Jindex", "l2_element", "l2xsize", "l2vIndex", "l2Jpath", "l2flength"], "ret": ["count", "arr", "rem", "ext", "len", "val", "alt", "g", "info", "nt", "Ret", "conn", "b", "i", "ref", "obj", "status", "reg", "iter", "rets", "f", "j", "rt", "res", "bf", "det", "al", "opt", "mi", "r", "att", "fun", "en", "hash", "ur", "re", "RET", "back", "result", "rev", "match", "ber", "fi", "success"], "l2_offset": ["l2_type", "l4_offset", "l2xstart", "l4_type", "l2xoffset", "l2xOffset", "l1_Offset", "l1_offset", "l1_start", "l2_size", "l2_Offset", "l4_index", "l2_start", "l4_size", "l2xsize", "l1_size"], "l2_table": ["l2xstable", "l2Ptable", "l02scontainer", "l2jblock", "l2Ptab", "l2Pconfig", "l2stype", "l2scontainer", "l2dtree", "l02_stable", "ltwosfeature", "l2ttable", "l2_page", "l6_module", "lserverstable", "l2Jfeature", "l2_module", "l2_cache", "l2_tab", "l2soffset", "ltwo_view", "lserverscache", "l2_package", "l2_body", "l6_stable", "ltwo_table", "l2_container", "l2Jtable", "l2jmodule", "l2tstable", "l6_body", "l2thestable", "ltwo_body", "lserversoffset", "l2jpackage", "l2_file", "l2Jview", "l2tbody", "l02_table", "l3_size", "l02_page", "l2Jbody", "l6_table", "l2xpackage", "l02sstable", "l3_tree", "l6_tree", "l2xblock", "l2_type", "lserver_table", "l6_time", "lserver_offset", "lserver_type", "ltwo_feature", "l02spage", "l2sfeature", "l6_block", "l2xmodule", "l2thecontainer", "l2sstable", "l3_cache", "l6_file", "l2dtime", "l2tcache", "l2sview", "l2_block", "l2spage", "l2thetable", "ltwosbody", "l6_tab", "l02_container", "l2xtable", "l2jtable", "l2xcontainer", "l2scache", "l6_cache", "l6_index", "l2thepage", "l2Pindex", "ltwostable", "l2_config", "l2_tree", "l6_config", "lserver_cache", "l2_feature", "l6_package", "l02stable", "l2sbody", "l2xpage", "l2_stable", "l2_view", "ltwosview", "l2_size", "l2_time", "l2stable", "l2dfile", "lserverstype", "l2dtable", "l3_table"], "cluster_offset": ["cluster67offset", "clusteracoffset", "clusterLend", "cluster_attribute", "clusterPend", "cluster_entry", "cluster_off", "clusterLoffset", "clusterPpadding", "clinical_Offset", "clard_entry", "cluster67format", "clusterFattribute", "clancPleft", "clrome_url", "clrome67offset", "clusterLpadding", "clusterFpadding", "clrome67shift", "clusterPOffset", "clider_ref", "clrome_position", "clause_off", "clution_padding", "clution_attribute", "cluster_position", "clause_offset", "cluster_ref", "clutionFpadding", "clanc_format", "cluster_option", "cluster67left", "cluster_format", "clutionFattribute", "cluster_count", "clard_start", "cluster_addr", "clinical_limit", "clusterPentry", "clutionFend", "cluster_Offset", "cluster_padding", "clause_addr", "clusterPleft", "clanc_Offset", "clutionFoffset", "clause_Offset", "clancPformat", "cluster_start", "cluster_left", "cluster_size", "clider_offset", "cluster_shift", "clusterFend", "clause_set", "cluster67url", "clusterPstart", "cluster67Offset", "cluster67position", "cluster_area", "clution_end", "clusteracOffset", "clrome67position", "cluster_end", "clanc_offset", "clanc_left", "cluster_set", "clution_offset", "clusterLattribute", "clusteraclimit", "clusterPoffset", "cluster67shift", "clrome67url", "clrome_offset", "cluster_url", "clancPOffset", "clinical_offset", "clause_area", "cluster_limit", "clard_offset", "clider_count", "clinical_option", "clusterFoffset", "clusterPattribute", "clancPoffset", "clusteracoption", "clause_end", "clusterPformat", "clider_size", "clrome_shift"], "nb_clusters": ["nb_declunks", "nb_contusters", "nb00flappers", "nb_pluster", "nb_sclocations", "nb_custers", "nb00sclocations", "nb67decunks", "nb_blancers", "nb_licusters", "nb_combicas", "nb_blroups", "nb_clonents", "nb_chuster", "nb67clayers", "nb00clappers", "nb_slorders", "nb_sclashes", "nb00flroups", "nb_compashes", "nb_combonents", "nb_sclusters", "nb_clients", "nb_zusters", "nb00sclusters", "nb_slusters", "nb_combroups", "nb_lconents", "nb67clorders", "nb_decients", "nb_ciders", "nb_clists", "nb00explists", "nb_declappers", "nb_compusters", "nb_decunks", "nb_flroups", "nb_blitors", "nb_chitors", "nb_bluster", "nb00flusters", "nb__clords", "nb_collodes", "nb_collicas", "nb00sclorders", "nb2chitors", "nb_filunks", "nb_decayers", "nb_plashes", "nb_clurations", "nb00clists", "nb_explusters", "nb00explusters", "nb_plonents", "nb_llorders", "nb2chores", "nb_clorders", "nb_clocations", "nb2chusters", "nb67decorders", "nb_sclores", "nb00clubes", "nb_plores", "nb_clores", "nb_plicas", "nb_chusters", "nb00clroups", "nb_conticas", "nb_clust", "nb_clayers", "nb_condusters", "nb_decusters", "nb_cancers", "nb_clitors", "nb_explubes", "nb_splust", "nb_deciders", "nb_lcust", "nb_condores", "nb_chicas", "nb_clancers", "nb_glorders", "nb_decancers", "nb_chances", "nb_tust", "nb2clusters", "nb67clunks", "nb_turations", "nb_lcroups", "nb_clodes", "nb_explunks", "nb_clords", "nb_chients", "nb__clicas", "nb_blients", "nb_lcappers", "nb_filubes", "nb00clust", "nb_zappers", "nb2clores", "nb_condients", "nb_zust", "nb_glusters", "nb_llusters", "nb_declorders", "nb_clances", "nb_plusters", "nb_bliders", "nb_clunks", "nb_clashes", "nb__clodes", "nb67clusters", "nb_slunks", "nb_licances", "nb_contodes", "nb00clodes", "nb_flusters", "nb67decayers", "nb_plroups", "nb2clients", "nb_explists", "nb2chients", "nb_filusters", "nb_filists", "nb2clitors", "nb_collords", "nb_declroups", "nb_combusters", "nb__chodes", "nb_flust", "nb_cliders", "nb_splusters", "nb_clubes", "nb00explunks", "nb_blances", "nb_scluster", "nb_conditors", "nb_chroups", "nb__chords", "nb_slayers", "nb_llocations", "nb_blores", "nb_tappers", "nb__clusters", "nb_splurations", "nb_lcusters", "nb_lcicas", "nb_sclorders", "nb_declusters", "nb_declayers", "nb_zurations", "nb_glodes", "nb_clicas", "nb_declust", "nb_sclodes", "nb00explubes", "nb_chodes", "nb_tusters", "nb_chords", "nb_clroups", "nb_licuster", "nb_compores", "nb_glocations", "nb00clorders", "nb_licroups", "nb_cluster", "nb__chicas", "nb_splists", "nb_cients", "nb_chores", "nb_compuster", "nb00sclodes", "nb_splubes", "nb_clappers", "nb__chusters", "nb_llodes", "nb_splunks", "nb00clusters", "nb_blusters", "nb00clunks", "nb_decorders", "nb67decusters", "nb_splappers", "nb_contords", "nb00clocations", "nb_flappers", "nb00flust", "nb_collusters"], "old_alloc": ["old__stat", " old_meta", " old_stat", "old_meta", "old2aux", "old2stat", "old__meta", "old2meta", "old2alloc", "old__alloc", "old_aux", "old_stat", " old_aux", "old__aux"]}}
{"project": "qemu", "commit_id": "27915efb974999dd256a6c432a17432d9d84e606", "target": 1, "func": "static int virtio_9p_device_init(VirtIODevice *vdev)\n\n{\n\n    V9fsState *s = VIRTIO_9P(vdev);\n\n    int i, len;\n\n    struct stat stat;\n\n    FsDriverEntry *fse;\n\n    V9fsPath path;\n\n\n\n    virtio_init(VIRTIO_DEVICE(s), \"virtio-9p\", VIRTIO_ID_9P,\n\n                sizeof(struct virtio_9p_config) + MAX_TAG_LEN);\n\n\n\n    /* initialize pdu allocator */\n\n    QLIST_INIT(&s->free_list);\n\n    QLIST_INIT(&s->active_list);\n\n    for (i = 0; i < (MAX_REQ - 1); i++) {\n\n        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);\n\n    }\n\n\n\n    s->vq = virtio_add_queue(vdev, MAX_REQ, handle_9p_output);\n\n\n\n    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);\n\n\n\n    if (!fse) {\n\n        /* We don't have a fsdev identified by fsdev_id */\n\n        fprintf(stderr, \"Virtio-9p device couldn't find fsdev with the \"\n\n                \"id = %s\\n\",\n\n                s->fsconf.fsdev_id ? s->fsconf.fsdev_id : \"NULL\");\n\n        goto out;\n\n    }\n\n\n\n    if (!s->fsconf.tag) {\n\n        /* we haven't specified a mount_tag */\n\n        fprintf(stderr, \"fsdev with id %s needs mount_tag arguments\\n\",\n\n                s->fsconf.fsdev_id);\n\n        goto out;\n\n    }\n\n\n\n    s->ctx.export_flags = fse->export_flags;\n\n    s->ctx.fs_root = g_strdup(fse->path);\n\n    s->ctx.exops.get_st_gen = NULL;\n\n    len = strlen(s->fsconf.tag);\n\n    if (len > MAX_TAG_LEN - 1) {\n\n        fprintf(stderr, \"mount tag '%s' (%d bytes) is longer than \"\n\n                \"maximum (%d bytes)\", s->fsconf.tag, len, MAX_TAG_LEN - 1);\n\n        goto out;\n\n    }\n\n\n\n    s->tag = g_strdup(s->fsconf.tag);\n\n    s->ctx.uid = -1;\n\n\n\n    s->ops = fse->ops;\n\n    s->config_size = sizeof(struct virtio_9p_config) + len;\n\n    s->fid_list = NULL;\n\n    qemu_co_rwlock_init(&s->rename_lock);\n\n\n\n    if (s->ops->init(&s->ctx) < 0) {\n\n        fprintf(stderr, \"Virtio-9p Failed to initialize fs-driver with id:%s\"\n\n                \" and export path:%s\\n\", s->fsconf.fsdev_id, s->ctx.fs_root);\n\n        goto out;\n\n    }\n\n    if (v9fs_init_worker_threads() < 0) {\n\n        fprintf(stderr, \"worker thread initialization failed\\n\");\n\n        goto out;\n\n    }\n\n\n\n    /*\n\n     * Check details of export path, We need to use fs driver\n\n     * call back to do that. Since we are in the init path, we don't\n\n     * use co-routines here.\n\n     */\n\n    v9fs_path_init(&path);\n\n    if (s->ops->name_to_path(&s->ctx, NULL, \"/\", &path) < 0) {\n\n        fprintf(stderr,\n\n                \"error in converting name to path %s\", strerror(errno));\n\n        goto out;\n\n    }\n\n    if (s->ops->lstat(&s->ctx, &path, &stat)) {\n\n        fprintf(stderr, \"share path %s does not exist\\n\", fse->path);\n\n        goto out;\n\n    } else if (!S_ISDIR(stat.st_mode)) {\n\n        fprintf(stderr, \"share path %s is not a directory\\n\", fse->path);\n\n        goto out;\n\n    }\n\n    v9fs_path_free(&path);\n\n\n\n    return 0;\n\nout:\n\n    g_free(s->ctx.fs_root);\n\n    g_free(s->tag);\n\n    virtio_cleanup(vdev);\n\n    v9fs_path_free(&path);\n\n\n\n    return -1;\n\n\n\n}\n", "idx": 24921, "substitutes": {"vdev": ["vpriv", "ldevice", "xconf", "vdd", "gdevice", "ldev", "svconf", "Vdevice", "ddd", "Vpriv", "xdd", "vde", " vprom", "xdevice", " vconf", "vdevice", " vdevice", "pdevice", "vprom", "xdev", "gdev", "Vdev", "vconf", "ppriv", " vde", "lprom", "dconf", "lconf", " vpriv", "gconf", "pde", "gprom", "pdev", "Vde", "svdevice", "svdev", "ddev", "svdd", "ddevice"], "s": ["sys", "w", "server", "ns", "ts", "ps", "secondary", "states", "sync", "self", "es", "gs", "stats", "set", "sym", "xs", "serv", "f", "service", "js", "n", "qs", "fs", "t", "tests", "S", "p", "m", "b", "c", "storage", "ds", "state", "su", "is", "ssh", "ims", "sets", "spec", "aws", "new", "services", "h", "sl", "settings", "its", "g", "side", "rs", "ses", "args", "ss", "d", "data", "conf", "sg", "ks", "e", "session", "hs", "sb", "your", "full", "ssl", "cs", "site", "o", "si", "os", "uns", "sup", "as", "ls", "a", "v", "parts", "l"], "i": ["k", "yi", "p", "info", "m", "c", "name", "b", "d", "ix", "x", "ti", "mi", "type", "phi", "qi", "ri", "id", "u", "e", "key", "li", "gi", "ji", "zi", "multi", "xi", "uri", "start", "ii", "di", "si", "ai", "ini", "ni", "bi", "ci", "fi", "eni", "hei", "sup", "I", "f", "ki", "oi", "n", "j", "index", "chi", "t", "a", "v", "ind", "iu", "pi", "mu", "in", "ui", "l", "hi"], "len": ["seq", "fin", "low", "dim", "dy", "lan", "ld", "en", "mi", "ler", "bl", "non", "lon", "id", "all", "lf", "mem", "li", "el", "Len", "min", "lu", "err", "la", "lit", "lang", "l", "dl", "lin", "fl", "ann", "pl", "le", "ni", "nt", "lib", "lt", "size", "ln", "length", "lc", "il", "lif", "elt", "lp", "count", "n", "limit", "lo", "lim", "ind", "sl", "pos", "val", "fun"], "stat": ["exec", "Stat", "rs", "ctl", "sys", "gen", "STAT", "info", "nat", "name", "cat", "opt", "debug", "def", "sync", "util", "proc", "css", "link", "disk", "stats", "mem", "cmd", "cpu", "nic", "dir", "spec", "mode", "sec", "cache", "task", "lif", "serv", "raf", "dot", "status", "reg", "conn", "nam", "meta", "attr", "block"], "fse": ["fsee", "Fce", "cfze", "fste", " fge", "fce", "rfpe", "Fge", "fke", "rfge", " fsu", "psee", "gde", "vke", "dse", " fpe", "fsp", "sfsp", "fxste", "dpse", " fsee", "fsu", "vze", " fze", "pse", " fses", " fste", "fxses", "cfce", " fce", "vsel", "fpe", "pde", "fbe", "Fpe", "fxse", " fpse", "Fse", " fsp", " fbe", "vste", "ffe", "dfsel", "rfse", " ffe", "rfce", "fxsu", "sfpse", "vce", "dfse", "dsp", "dfbe", "fses", "gsee", "fze", "vse", "vbe", "cfbe", "dfe", "fsel", " fde", " fsel", "sfse", "fge", "gse", "pze", "vses", "fpse", "vsu", "dfke", "cfse", " fke", "fde", "gze", "sffe"], "path": ["ref", "node", " paths", "sc", "code", " Path", "w", "er", "m", "c", "name", "d", "image", "mount", "data", "fn", "ec", "config", "next", "address", "prefix", "ch", "loader", "port", "end", "alias", "self", "url", "id", "key", "home", "cmd", "str", "err", "dir", "uri", "loc", "ath", "mode", "parent", "result", "target", "device", "PATH", "f", "source", "host", "root", "r", "Path", "file"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_decimal(void)\n\n{\n\n    const char *str = \"0123\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 10, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n\n\n    str = \"123\";\n\n    res = 999;\n\n    endptr = &f;\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 123);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 11919, "substitutes": {"str": ["cr", "sp", "tr", "is", "strings", "Str", "txt", "strip", "stri", "er", "st", "code", "ctr", "cur", "spec", "orig", "url", "text", "expr", "ocr", "arr", "id", "fr", "gr", "c", "s", "e", "iter", "f", "zero", "input", "r", "u", "lc", "sc", "exec", "seq", "ext", "hr", "unc", "kr", "data", "STR", "wr", "dr", "cs", "sl", "enc", "vec", "br", "sr", "start", "rr", "doc", "prev", "obj", "rs", "empty", "inst", "name", "pr", "inner", "frac"], "endptr": ["adaddr", " endrot", "endedptr", "endedpointer", "endPtr", "endaddr", "endingpointer", " endpointer", "idproc", "adPtr", "endpt", " endPtr", "startctr", "estpointers", "endedaddr", "adpt", "endingrot", "endprot", "idpt", "endpointer", "entprot", "addptr", "idpointer", "addprot", "endproc", "endedpt", "addwr", "adrot", " endproc", " endpointers", "adpointers", "estptr", "adprot", "startptr", "adproc", "idptr", "endwr", "startprot", "beginprot", "entptr", "addpointer", "beginpointer", "endpointers", "endrot", "entpointer", "startpointer", "entwr", "endedprot", "endctr", "startproc", "estPtr", "endingptr", "adptr", "endedctr", "estpointer", "endingproc", "beginaddr", " endctr", "adpointer", "beginptr", "startwr", "endedproc"], "err": ["later", "cr", "acer", "fg", "ler", "arr", "arm", "g", "rage", "all", "fr", "mr", "rr", "erer", "kr", "gr", "ver", "work", "Error", "attr", "iter", "wr", "act", "ir", "aster", "bug", "er", "f", "lr", "dr", "code", "res", "finder", "order", "magic", "ner", "ar", "r", "ise", "req", "pr", " r", "ger", "error", "rar", " error", "fer", "der", "orer", " Err", "eor", "result", "Er", "br", "resp", "rh", "fi", "ln", "runner"]}}
{"project": "qemu", "commit_id": "d492a75cfefd9a09125ba2b007c817c1417c3820", "target": 0, "func": "void spapr_clear_pending_events(sPAPRMachineState *spapr)\n\n{\n\n    sPAPREventLogEntry *entry = NULL;\n\n\n\n    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {\n\n        QTAILQ_REMOVE(&spapr->pending_events, entry, next);\n\n        g_free(entry->extended_log);\n\n        g_free(entry);\n\n    }\n\n}\n", "idx": 26538, "substitutes": {"spapr": ["spapers", "spampb", "spAPb", "SPapr", "SPapar", "spapb", "scaprs", "smatrc", "scapenr", "scapers", "spapenr", "spatrc", "smatrr", "SPaprs", "SPapb", "smapr", "spAPnr", "spapsb", "spepr", "spapnr", "SPapsr", "spatpr", "spepm", "scapm", "scapr", "spepnr", "spapem", "SPapsrs", "SPapsb", "spAPr", "scaper", "spAPrs", "spamprs", "spatrr", "spAPm", "speprs", "smaprc", "spamprr", "spAPrr", "spAPrc", "spaprc", "scapnr", "spampar", "spaper", "scapem", "smatr", "spampr", "spapsr", "spapar", "spamprc", "smappr", "spapm", "spapsar", "smatpr", "smaprr", "spaprs", "spaprr", "spatr", "spAPpr", "spapsrs", "spAPar", "SPapsar", "spappr", "spamppr"], "entry": ["ger", "her", "import", "element", "er", "expected", "ie", "section", "parse", "info", "server", "card", "se", "ge", "or", "data", "next", "letter", "escape", "reader", "error", "end", "archive", "e", "feed", "line", "Entry", "key", "cell", "extra", "session", "cel", "inner", "ent", "enter", "handler", "nt", "parent", "new", "inc", "sec", "ry", "zip", "child", "index", "row", "inter", "event", "route", "keeper", "try", "result", "connection"]}}
{"project": "FFmpeg", "commit_id": "e22ebd04bcab7f86548794556c28ecca46d9c2ac", "target": 0, "func": "static void hls_transform_tree(HEVCContext *s, int x0, int y0,\n\n                               int xBase, int yBase, int cb_xBase, int cb_yBase,\n\n                               int log2_cb_size, int log2_trafo_size,\n\n                               int trafo_depth, int blk_idx)\n\n{\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n    uint8_t split_transform_flag;\n\n\n\n    if (trafo_depth > 0 && log2_trafo_size == 2) {\n\n        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase);\n\n        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase);\n\n    } else {\n\n        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) = 0;\n\n    }\n\n\n\n    if (lc->cu.intra_split_flag) {\n\n        if (trafo_depth == 1)\n\n            lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[blk_idx];\n\n    } else {\n\n        lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[0];\n\n    }\n\n\n\n    lc->tt.cbf_luma = 1;\n\n\n\n    lc->tt.inter_split_flag = s->sps->max_transform_hierarchy_depth_inter == 0 &&\n\n                              lc->cu.pred_mode == MODE_INTER &&\n\n                              lc->cu.part_mode != PART_2Nx2N &&\n\n                              trafo_depth == 0;\n\n\n\n    if (log2_trafo_size <= s->sps->log2_max_trafo_size &&\n\n        log2_trafo_size >  s->sps->log2_min_tb_size    &&\n\n        trafo_depth     < lc->cu.max_trafo_depth       &&\n\n        !(lc->cu.intra_split_flag && trafo_depth == 0)) {\n\n        split_transform_flag = ff_hevc_split_transform_flag_decode(s, log2_trafo_size);\n\n    } else {\n\n        split_transform_flag = log2_trafo_size > s->sps->log2_max_trafo_size ||\n\n                               (lc->cu.intra_split_flag && trafo_depth == 0) ||\n\n                               lc->tt.inter_split_flag;\n\n    }\n\n\n\n    if (log2_trafo_size > 2) {\n\n        if (trafo_depth == 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase)) {\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n                ff_hevc_cbf_cb_cr_decode(s, trafo_depth);\n\n        }\n\n\n\n        if (trafo_depth == 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase)) {\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =\n\n                ff_hevc_cbf_cb_cr_decode(s, trafo_depth);\n\n        }\n\n    }\n\n\n\n    if (split_transform_flag) {\n\n        int x1 = x0 + ((1 << log2_trafo_size) >> 1);\n\n        int y1 = y0 + ((1 << log2_trafo_size) >> 1);\n\n\n\n        hls_transform_tree(s, x0, y0, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 0);\n\n        hls_transform_tree(s, x1, y0, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 1);\n\n        hls_transform_tree(s, x0, y1, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 2);\n\n        hls_transform_tree(s, x1, y1, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 3);\n\n    } else {\n\n        int min_tu_size      = 1 << s->sps->log2_min_tb_size;\n\n        int log2_min_tu_size = s->sps->log2_min_tb_size;\n\n        int min_tu_width     = s->sps->min_tb_width;\n\n\n\n        if (lc->cu.pred_mode == MODE_INTRA || trafo_depth != 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) ||\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0)) {\n\n            lc->tt.cbf_luma = ff_hevc_cbf_luma_decode(s, trafo_depth);\n\n        }\n\n\n\n        hls_transform_unit(s, x0, y0, xBase, yBase, cb_xBase, cb_yBase,\n\n                           log2_cb_size, log2_trafo_size, trafo_depth, blk_idx);\n\n\n\n        // TODO: store cbf_luma somewhere else\n\n        if (lc->tt.cbf_luma) {\n\n            int i, j;\n\n            for (i = 0; i < (1 << log2_trafo_size); i += min_tu_size)\n\n                for (j = 0; j < (1 << log2_trafo_size); j += min_tu_size) {\n\n                    int x_tu = (x0 + j) >> log2_min_tu_size;\n\n                    int y_tu = (y0 + i) >> log2_min_tu_size;\n\n                    s->cbf_luma[y_tu * min_tu_width + x_tu] = 1;\n\n                }\n\n        }\n\n        if (!s->sh.disable_deblocking_filter_flag) {\n\n            ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_trafo_size,\n\n                                                  lc->slice_or_tiles_up_boundary,\n\n                                                  lc->slice_or_tiles_left_boundary);\n\n            if (s->pps->transquant_bypass_enable_flag &&\n\n                lc->cu.cu_transquant_bypass_flag)\n\n                set_deblocking_bypass(s, x0, y0, log2_trafo_size);\n\n        }\n\n    }\n\n}\n", "idx": 14723, "substitutes": {"s": ["acs", "sys", "ses", "context", "self", "service", "t", "sync", "sg", "l", "rs", "g", "cs", "qs", "S", "settings", "h", "sk", "os", "si", "js", "sq", "session", "ps", "ss", "storage", "o", "u", "p", "e", "sec", "site", "sb", "sf", "f", "gs", "spec", "c", "ns", "xs", "sc", "ssl", "sv", "sl", "r", "ds", "sie", "services", "sa", "su", "ls", "ts", "space", "us", "ctx"], "x0": ["xx1", "y4", "xp1", " x1", " x10", "X1", " xee", "xx0", "xSource", "xy1", "xee", " x4", "rx0", "xxee", "axZero", "y250", "xy0", "ax1", "yNo", "xxNo", "ax10", "yZero", " xZero", " xStart", "rxBase", "x250", "xNo", "xStart", "ax0", "y1", "xp4", "xySource", "xyBase", "y10", "rx1", "rxStart", "XStart", "xZero", " xNo", "x10", "xp250", "x4", "X0", "xp0", "ySource", "x1", "XBase", "yee", " x250", " xSource"], "y0": ["eyElement", "asyItem", "YOrigin", "YSource", "Y3", " y3", "YElement", " y50", "Y1", " y1", "yItem", "ryBase", "yEl", "vy1", " ySource", "Y50", "y50", "y3", " yEl", "YBase", "YEl", "rySource", "yyOrigin", "Y00", "vyBase", " yOrigin", "yy1", "ry1", "asy1", "y1", "y00", "eyItem", "ry0", "Y0", "ry50", "YItem", "yy00", "yElement", " y00", "ey0", "yOrigin", "asyElement", "vy0", "asy0", "ySource", "ey1", "ryEl", "vy3", "yy0"], "xBase": ["ix0", "XSize", "xMax", " xbase", "Xbase", " xMax", "xbase", "yZero", " xZero", " xSize", "ixZero", "ybase", "ySize", "xSize", "xZero", "ixbase", "ixBase", "X0", "yMax", "XBase", "XMax"], "yBase": ["yaByte", " yBack", "YSource", "YBased", " ybase", "eyBuffer", "eybase", "yBased", " ySource", "yaBase", "vyBased", " yBuffer", " yBased", "eyBack", "YBase", "eyBase", "xbase", "yBack", "vyBase", "YByte", "yBuffer", "ybase", "yByte", "YBuffer", "YBack", " yByte", "Ybase", "vy0", "yaSource", "yaBased", "ySource", "vybase", "xBased"], "cb_xBase": ["cb_xUnit", "cb_wUnit", "cb_xEnd", "cb_wEnd", "cb_yUnit", "cb_x0", "cb_yEnd", "cb_eyUnit", "cb_wBase", "cb_eyBase", "cb_y0", "cb_w0", "cb_eyEnd", "cb_ey0"], "cb_yBase": ["cb_xRest", "cb_yScale", "cb_cyRest", "cb_zyRest", "cb_x0", "cb_yRest", "cb_zy0", "cb_cy0", "cb_zyBase", "cb_cyScale", "cb_y0", "cb_cyBase", "cb_zyScale", "cb_xScale"], "log2_cb_size": ["log2_cb_capacity", "log2_bb_capacity", "log2_cb_count", "log2_cb2count", "log2_bb_size", "log2_cb2small", "log2_bb_small", "log2_cb2size", "log2_cb2capacity", "log2_cb_small", "log2_bb_count"], "log2_trafo_size": ["log2_traf_depth", "log2_trafo_depth", "log2_trafi_go", "log2_traf_size", "log2_trafo_weight", "log2_traco_depth", "log2_traf_len", "log2_traf_weight", "log2_trafo_width", "log2_trafo_go", "log2_traf_scale", "log2_traco_width", "log2_trafo_len", "log2_trafo_scale", "log2_traco_size", "log2_trafi_size", "log2_trafi_depth"], "trafo_depth": ["traf_size", "traf_depth", " tra\n", "trafo_size", "trafo_rank", "tratto_scale", "traph_root", "trafi_root", "tra\n", "traph_deep", "trafo_weight", "traf_weight", "traph_size", "tratto_depth", "trafo_deep", "trafo_strength", "traverse_depth", "traverse_height", "traf_distance", "traverse_strength", "traph_uri", "trafo_color", "tratto_size", "tratto_deep", "traf_length", "trafi_size", "trafi_deep", "trafo_count", "trafi_depth", "trafo_scale", "trafo_length", "tratto_rank", "trafo_distance", "traph_color", "traf_root", "trafo_level", "trafo_mode", "trafi_count", "traverse_level", "tratto_level", "tre\n", "trafo_root", "trafo_uri", "traf_mode", "traph_depth", "trafo_height", "ra\n", "traf_deep"], "blk_idx": ["blk1idw", "blk_idsw", "blk_catxs", "blk_pidv", "blk_Idx", "blk1idew", "blk_idev", "blk_Idxs", "blk_idew", "blk_Idw", "blk_idec", "blk_idv", "blk1idec", "blk_catv", "blk_pidw", "blk_idsv", "blk_Idv", "blk_pidx", "blk_idex", "blk_catw", "blk1idv", "blk_idw", "blk_idc", "blk1idex", "blk_pidc", "blk_catx", "blk_idsx", "blk1idev", "blk_idxs", "blk1idx", "blk_Idc", "blk1idc", "blk_idsxs"], "lc": ["mc", "cm", "bc", "hl", "uc", "lin", "rc", "cc", "pc", "l", "lic", "ci", "cs", "ctrl", "dl", "lp", "cci", "cn", "ml", "lang", "si", "ii", "ld", "loc", "conn", "lib", "ll", "la", "lr", "kl", "ku", "nc", "li", "cli", "tc", "lt", "cus", "sb", "lf", "acl", "gb", "spec", "rl", "c", "uci", "cu", "dc", "fc", "lu", "jc", "cas", "sci", "sc", "cf", "ic", "coll", "icc", "lex", "cell", "vc", "CI", "cache", "ga", "ls", "lb", "wl", "lv", "ln", "cl", "ctx", "LC"], "split_transform_flag": ["split_transform\u00b7flag", "split_transfer_flag", "split_transform_only", "split_transfer_only", "split_transform\u00b7bit", "split_transform\u00b7count", "split_transfer_bit", "split_transform_bit", "split_transfer_count", "split_transform_count", "split_transform\u00b7only"]}}
{"project": "FFmpeg", "commit_id": "9340a99588c2bf6209b5c396df15b893c4b576b5", "target": 1, "func": "static int RENAME(swScale)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n\n\n\n\t/* load a few things into local vars to make the code more readable? and faster */\n\n\tconst int srcW= c->srcW;\n\n\tconst int dstW= c->dstW;\n\n\tconst int dstH= c->dstH;\n\n\tconst int chrDstW= c->chrDstW;\n\n\tconst int chrSrcW= c->chrSrcW;\n\n\tconst int lumXInc= c->lumXInc;\n\n\tconst int chrXInc= c->chrXInc;\n\n\tconst int dstFormat= c->dstFormat;\n\n\tconst int srcFormat= c->srcFormat;\n\n\tconst int flags= c->flags;\n\n\tconst int canMMX2BeUsed= c->canMMX2BeUsed;\n\n\tint16_t *vLumFilterPos= c->vLumFilterPos;\n\n\tint16_t *vChrFilterPos= c->vChrFilterPos;\n\n\tint16_t *hLumFilterPos= c->hLumFilterPos;\n\n\tint16_t *hChrFilterPos= c->hChrFilterPos;\n\n\tint16_t *vLumFilter= c->vLumFilter;\n\n\tint16_t *vChrFilter= c->vChrFilter;\n\n\tint16_t *hLumFilter= c->hLumFilter;\n\n\tint16_t *hChrFilter= c->hChrFilter;\n\n\tint32_t *lumMmxFilter= c->lumMmxFilter;\n\n\tint32_t *chrMmxFilter= c->chrMmxFilter;\n\n\tconst int vLumFilterSize= c->vLumFilterSize;\n\n\tconst int vChrFilterSize= c->vChrFilterSize;\n\n\tconst int hLumFilterSize= c->hLumFilterSize;\n\n\tconst int hChrFilterSize= c->hChrFilterSize;\n\n\tint16_t **lumPixBuf= c->lumPixBuf;\n\n\tint16_t **chrPixBuf= c->chrPixBuf;\n\n\tconst int vLumBufSize= c->vLumBufSize;\n\n\tconst int vChrBufSize= c->vChrBufSize;\n\n\tuint8_t *funnyYCode= c->funnyYCode;\n\n\tuint8_t *funnyUVCode= c->funnyUVCode;\n\n\tuint8_t *formatConvBuffer= c->formatConvBuffer;\n\n\tconst int chrSrcSliceY= srcSliceY >> c->chrSrcVSubSample;\n\n\tconst int chrSrcSliceH= -((-srcSliceH) >> c->chrSrcVSubSample);\n\n\tint lastDstY;\n\n        uint8_t *pal=NULL;\n\n\n\n\t/* vars whch will change and which we need to storw back in the context */\n\n\tint dstY= c->dstY;\n\n\tint lumBufIndex= c->lumBufIndex;\n\n\tint chrBufIndex= c->chrBufIndex;\n\n\tint lastInLumBuf= c->lastInLumBuf;\n\n\tint lastInChrBuf= c->lastInChrBuf;\n\n\t\n\n\tif(isPacked(c->srcFormat)){\n\n                pal= src[1];\n\n\t\tsrc[0]=\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= src[0];\n\n\t\tsrcStride[0]=\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= srcStride[0];\n\n\t}\n\n\tsrcStride[1]<<= c->vChrDrop;\n\n\tsrcStride[2]<<= c->vChrDrop;\n\n\n\n//\tprintf(\"swscale %X %X %X -> %X %X %X\\n\", (int)src[0], (int)src[1], (int)src[2],\n\n//\t\t(int)dst[0], (int)dst[1], (int)dst[2]);\n\n\n\n#if 0 //self test FIXME move to a vfilter or something\n\n{\n\nstatic volatile int i=0;\n\ni++;\n\nif(srcFormat==PIX_FMT_YUV420P && i==1 && srcSliceH>= c->srcH)\n\n\tselfTest(src, srcStride, c->srcW, c->srcH);\n\ni--;\n\n}\n\n#endif\n\n\n\n//printf(\"sws Strides:%d %d %d -> %d %d %d\\n\", srcStride[0],srcStride[1],srcStride[2],\n\n//dstStride[0],dstStride[1],dstStride[2]);\n\n\n\n\tif(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)\n\n\t{\n\n\t\tstatic int firstTime=1; //FIXME move this into the context perhaps\n\n\t\tif(flags & SWS_PRINT_INFO && firstTime)\n\n\t\t{\n\n\t\t\tav_log(c, AV_LOG_WARNING, \"SwScaler: Warning: dstStride is not aligned!\\n\"\n\n\t\t\t\t\t\"SwScaler:          ->cannot do aligned memory acesses anymore\\n\");\n\n\t\t\tfirstTime=0;\n\n\t\t}\n\n\t}\n\n\n\n\t/* Note the user might start scaling the picture in the middle so this will not get executed\n\n\t   this is not really intended but works currently, so ppl might do it */\n\n\tif(srcSliceY ==0){\n\n\t\tlumBufIndex=0;\n\n\t\tchrBufIndex=0;\n\n\t\tdstY=0;\t\n\n\t\tlastInLumBuf= -1;\n\n\t\tlastInChrBuf= -1;\n\n\t}\n\n\n\n\tlastDstY= dstY;\n\n\n\n\tfor(;dstY < dstH; dstY++){\n\n\t\tunsigned char *dest =dst[0]+dstStride[0]*dstY;\n\n\t\tconst int chrDstY= dstY>>c->chrDstVSubSample;\n\n\t\tunsigned char *uDest=dst[1]+dstStride[1]*chrDstY;\n\n\t\tunsigned char *vDest=dst[2]+dstStride[2]*chrDstY;\n\n\n\n\t\tconst int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input\n\n\t\tconst int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input\n\n\t\tconst int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input\n\n\t\tconst int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input\n\n\n\n//printf(\"dstY:%d dstH:%d firstLumSrcY:%d lastInLumBuf:%d vLumBufSize: %d vChrBufSize: %d slice: %d %d vLumFilterSize: %d firstChrSrcY: %d vChrFilterSize: %d c->chrSrcVSubSample: %d\\n\",\n\n// dstY, dstH, firstLumSrcY, lastInLumBuf, vLumBufSize, vChrBufSize, srcSliceY, srcSliceH, vLumFilterSize, firstChrSrcY, vChrFilterSize,  c->chrSrcVSubSample);\n\n\t\t//handle holes (FAST_BILINEAR & weird filters)\n\n\t\tif(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;\n\n\t\tif(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;\n\n//printf(\"%d %d %d\\n\", firstChrSrcY, lastInChrBuf, vChrBufSize);\n\n\t\tASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)\n\n\t\tASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)\n\n\n\n\t\t// Do we have enough lines in this slice to output the dstY line\n\n\t\tif(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample))\n\n\t\t{\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf < lastLumSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n//\t\t\t\tprintf(\"%d %d %d %d\\n\", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n//\t\t\t\tprintf(\"%d %d\\n\", lumBufIndex, vLumBufSize);\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->lumMmx2Filter, c->lumMmx2FilterPos, pal);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf < lastChrSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)\n\n\t\t\t\t//FIXME replace parameters through context struct (some at least)\n\n\n\n\t\t\t\tif(!(isGray(srcFormat) || isGray(dstFormat)))\n\n\t\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->chrMmx2Filter, c->chrMmx2FilterPos, pal);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t}\n\n\t\telse // not enough lines left in this slice -> load the rest in the buffer\n\n\t\t{\n\n/*\t\tprintf(\"%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\\n\",\n\n\t\t\tfirstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,\n\n\t\t\tlastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,\n\n\t\t\tvChrBufSize, vLumBufSize);*/\n\n\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf+1 < srcSliceY + srcSliceH)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->lumMmx2Filter, c->lumMmx2FilterPos, pal);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf+1 < (chrSrcSliceY + chrSrcSliceH))\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY < chrSrcSliceH)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)\n\n\n\n\t\t\t\tif(!(isGray(srcFormat) || isGray(dstFormat)))\n\n\t\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->chrMmx2Filter, c->chrMmx2FilterPos, pal);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t\tbreak; //we can't output a dstY line so let's try with the next slice\n\n\t\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t\tb5Dither= dither8[dstY&1];\n\n\t\tg6Dither= dither4[dstY&1];\n\n\t\tg5Dither= dither8[dstY&1];\n\n\t\tr5Dither= dither8[(dstY+1)&1];\n\n#endif\n\n\t    if(dstY < dstH-2)\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n#ifdef HAVE_MMX\n\n\t\tint i;\n\n            if(flags & SWS_ACCURATE_RND){\n\n                        for(i=0; i<vLumFilterSize; i+=2){\n\n                                lumMmxFilter[2*i+0]= (int32_t)lumSrcPtr[i  ];\n\n                                lumMmxFilter[2*i+1]= (int32_t)lumSrcPtr[i+(vLumFilterSize>1)];\n\n                                lumMmxFilter[2*i+2]=\n\n                                lumMmxFilter[2*i+3]= vLumFilter[dstY*vLumFilterSize + i    ]\n\n                                                + (vLumFilterSize>1 ? vLumFilter[dstY*vLumFilterSize + i + 1]<<16 : 0);\n\n                        }\n\n                        for(i=0; i<vChrFilterSize; i+=2){\n\n                                chrMmxFilter[2*i+0]= (int32_t)chrSrcPtr[i  ];\n\n                                chrMmxFilter[2*i+1]= (int32_t)chrSrcPtr[i+(vChrFilterSize>1)];\n\n                                chrMmxFilter[2*i+2]=\n\n                                chrMmxFilter[2*i+3]= vChrFilter[chrDstY*vChrFilterSize + i    ]\n\n                                                + (vChrFilterSize>1 ? vChrFilter[chrDstY*vChrFilterSize + i + 1]<<16 : 0);\n\n                        }\n\n            }else{\n\n\t\tfor(i=0; i<vLumFilterSize; i++)\n\n\t\t{\n\n\t\t\tlumMmxFilter[4*i+0]= (int32_t)lumSrcPtr[i];\n\n\t\t\tlumMmxFilter[4*i+1]= (uint64_t)lumSrcPtr[i] >> 32;\n\n\t\t\tlumMmxFilter[4*i+2]= \n\n\t\t\tlumMmxFilter[4*i+3]= \n\n\t\t\t\t((uint16_t)vLumFilter[dstY*vLumFilterSize + i])*0x10001;\n\n\t\t}\n\n\t\tfor(i=0; i<vChrFilterSize; i++)\n\n\t\t{\n\n\t\t\tchrMmxFilter[4*i+0]= (int32_t)chrSrcPtr[i];\n\n\n\t\t\tchrMmxFilter[4*i+2]= \n\n\t\t\tchrMmxFilter[4*i+3]= \n\n\t\t\t\t((uint16_t)vChrFilter[chrDstY*vChrFilterSize + i])*0x10001;\n\n\t\t}\n\n            }\n\n#endif\n\n\t\tif(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tRENAME(yuv2nv12X)(c,\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, dstW, chrDstW, dstFormat);\n\n\t\t}\n\n\t\telse if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12 like\n\n\t\t{\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t *lumBuf = lumPixBuf[0];\n\n\t\t\t\tint16_t *chrBuf= chrPixBuf[0];\n\n\t\t\t\tRENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW, chrDstW);\n\n\t\t\t}\n\n\t\t\telse //General YV12\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2yuvX)(c,\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, uDest, vDest, dstW, chrDstW);\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB\n\n\t\t\t{\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\t\t\t\tRENAME(yuv2packed1)(c, *lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, chrAlpha, dstFormat, flags, dstY);\n\n\t\t\t}\n\n\t\t\telse if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB\n\n\t\t\t{\n\n\t\t\t\tint lumAlpha= vLumFilter[2*dstY+1];\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n                                lumMmxFilter[2]=\n\n                                lumMmxFilter[3]= vLumFilter[2*dstY   ]*0x10001;\n\n                                chrMmxFilter[2]=\n\n                                chrMmxFilter[3]= vChrFilter[2*chrDstY]*0x10001;\n\n\t\t\t\tRENAME(yuv2packed2)(c, *lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, lumAlpha, chrAlpha, dstY);\n\n\t\t\t}\n\n\t\t\telse //General RGB\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2packedX)(c,\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, dstW, dstY);\n\n\t\t\t}\n\n\t\t}\n\n            }\n\n\t    else // hmm looks like we can't use MMX here without overwriting this array's tail\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\tif(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2nv12XinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, dstW, chrDstW, dstFormat);\n\n\t\t}\n\n\t\telse if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12\n\n\t\t{\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2yuvXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, vDest, dstW, chrDstW);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tyuv2packedXinC(c, \n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, dstW, dstY);\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n\t/* store changed local vars back in the context */\n\n\tc->dstY= dstY;\n\n\tc->lumBufIndex= lumBufIndex;\n\n\tc->chrBufIndex= chrBufIndex;\n\n\tc->lastInLumBuf= lastInLumBuf;\n\n\tc->lastInChrBuf= lastInChrBuf;\n\n\n\n\treturn dstY - lastDstY;\n\n}", "idx": 13204, "substitutes": {"c": ["m", "ch", "mc", "uc", "bc", "cm", "d", "t", "enc", "ca", "rc", "cc", "l", "config", "pc", "C", "lc", "ci", "cs", "g", "cit", "cn", "con", "ct", "conf", "cr", "client", "col", "u", "rec", "p", "e", "nc", "b", "co", "tc", "n", "f", "spec", "cu", "dc", "ac", "cb", "sc", "ce", "cont", "cf", "ic", "coll", "cp", "com", "vc", "xc", "cache", "ec", "cur", "y", "ctx", "in", "cl"], "src": ["sys", "cv", "sync", "rc", "source", "req", "conv", "sr", "sq", "loc", "rec", "rb", "share", "sb", "inst", "scl", "sc", "ssl", "transform", "sl", "sur", "host", "sub", "sel", "scene", "cur", "ctx"], "srcStride": ["srcSTerve", "rcStrip", "srcEstride", "rcShause", "srcStrip", "srcEstrip", "srcSTause", "rcShrip", "srcEstause", "rcSherve", "srcSTride", "srcSherve", "rcStride", "srcShride", "rcStause", "srcShrip", "srcSterve", "srcSTrip", "srcStause", "srcEsterve", "rcSterve", "rcShride", "srcShause"], "srcSliceY": ["srcPlueY", "srcSlueW", "srcPlueI", "srcSlashY", "srcSliceI", "srcSlashD", "srcPliceY", "srcSlueD", "srcSlideW", "srcSlideI", "srcSliceW", "srcPlueD", "srcSliceD", "srcSlideY", "srcSlashI", "srcSlueY", "srcPliceD", "srcPlueW", "srcPliceW", "srcPliceI", "srcSlideD", "srcSlueI", "srcSlashW"], "srcSliceH": ["srcFlashH", "srcSlashY", "srcFliceH", "srcSlashH", "srcSlaseRH", "srcSlaceW", "srcSlaseH", "srcSlaceH", "srcSliceW", "srcSlaceRH", "srcSlashRH", "srcSliceRH", "srcFlashW", "srcFliceW", "srcSlaseY", "srcFlashY", "srcSlaceY", "srcFlashRH", "srcFliceY", "srcSlaseW", "srcFliceRH", "srcSlashW"], "dst": [" dsrc", "idsc", " drc", "Dsc", "idrc", " dsc", "Dst", "dsc", "idsrc", "drc", "dsrc", "Drc", "idst", "Dsrc"], "dstStride": ["dstStide", "dstStrite", "dstScrite", "dscStride", "dscStause", "dstShause", "dstScride", "dstShride", "dstShide", "dstDestride", "dstShrite", "dscStide", "dscDestride", "dstDestause", "dstDestide", "dscDestause", "dstScause", "dscDestide", "dscStrite", "dstDestrite", "dstScide", "dstStause", "dscDestrite"], "vLumFilterPos": ["vLumFeatureLen", "vLumbFilePos", "vLumbFilterEx", "vLumLayerRef", "vLumLayerOff", "vLumMaskEx", "vLumHeaderEx", "vLumFilterLen", "vLumFeaturePosition", "vLumFilterOff", "vLumFeaturePos", "vLumListenerPosition", "vLumeFilterOff", "vLumFilterEx", "vLumeFilterEx", "vLumeFilterPos", "vLumbFilterLen", "vLumFilePos", "vLumbFileEx", "vLumFilterPosition", "vLumeHeaderEx", "vLumeHeaderOff", "vLumbFilePosition", "vLumeHeaderPos", "vLumbFilterPosition", "vLumMaskOff", "vLumMaskRef", "vLumHeaderOff", "vLumbFileLen", "vLumHeaderRef", "vLumListenerEx", "vLumeHeaderRef", "vLumLayerEx", "vLumeFilterRef", "vLumLayerPos", "vLumbFilterPos", "vLumMaskPos", "vLumFilePosition", "vLumFeatureEx", "vLumFilterRef", "vLumListenerLen", "vLumListenerPos", "vLumHeaderPos", "vLumFileEx", "vLumFileLen"], "vChrFilterPos": ["vChrFilPosition", "vChmFilterPosition", "vChrFilPos", "vChrLimitpos", "vChrFlowOffset", "vChrtFilterPosition", "vChmFilterOffset", "vChrLimitOffset", "vChmFPos", "vChrtFilterPref", "vChrFlowPosition", "vChrFilpos", "vChrFilterPref", "vChmFpos", "vChrtFeaturepos", "vChrtFilterPos", "vChrFlowPos", "vChrtFeaturePos", "vChrFOffset", "vChrFeaturePos", "vChrLimitPos", "vChmFilterPos", "vChrtFeaturePref", "vChrFilterPosition", "vChrtFilterpos", "vChrLimitPosition", "vChmFilterpos", "vChrFPosition", "vChrFeaturePref", "vChrtFeaturePosition", "vChrFPos", "vChrFilPref", "vChrFeaturepos", "vChrFilterpos", "vChrFeaturePosition", "vChrFlowpos", "vChmFPosition", "vChrFPref", "vChmFOffset", "vChrFilterOffset", "vChrFpos"], "hLumFilterPos": ["hLumFilepos", "hLmFilepos", "hLumFilePos", "hLumManagerPosition", "hLumLimitMin", "hLmFilePosition", "hLumReaderPos", "hLumContentPos", "hLumLimitSe", "hLumFilterpos", "hLumFilePosition", "hLmFileSe", "hLumLimitPosition", "hLumContentP", "hLmFileMin", "hLumManagerMin", "hLmFilterMin", "hLumManagerPos", "hLumFilterMin", "hLumContentpos", "hLumFileMin", "hLumReaderpos", "hLmFilterpos", "hLumLimitPos", "hLumFileP", "hLumFileSe", "hLumFilterSe", "hLumFilterP", "hLumReaderPosition", "hLumManagerSe", "hLumFilterPosition", "hLmFilterSe", "hLmFilePos", "hLmFilterPos", "hLumContentPosition", "hLmFilterPosition", "hLmFilterP", "hLumReaderP", "hLmFileP"], "hChrFilterPos": ["hChrFlowPos", "hChlFilterPo", "hChrMaskScan", "hChrMaskPos", "hChlMaskLoc", "hChrFilterScan", "hChrFlowpos", "hChrtFilterpos", "hChrMaskPo", "hChrFilterpos", "hChrFilterEx", "hChrtHandlerpos", "hChrHandlerEx", "hChrMaskLoc", "hChrtHandlerStart", "hChrFilterPo", "hChrFactorPos", "hChrSelectScan", "hChrFactorScan", "hChrtHandlerEx", "hChrtFilterEx", "hChrHandlerStart", "hChrFilterLoc", "hChrtFilterPos", "hChrFlowStart", "hChrControlPos", "hChrControlEx", "hChrControlStart", "hChlMaskPo", "hChrHandlerPos", "hChlMaskPos", "hChrFilterStart", "hChrFlowEx", "hChlFilterScan", "hChrtHandlerPos", "hChlFilterLoc", "hChrSelectPos", "hChrControlpos", "hChrSelectLoc", "hChlFilterPos", "hChrFactorLoc", "hChrFactorPo", "hChrHandlerpos", "hChlMaskScan", "hChrtFilterStart", "hChrSelectPo"], "vLumFilter": ["vLumbLimit", "vPlumbLimit", "vBlumFil", "vLumerLimit", "vLumbLayer", "vLumFil", "vPlumLayer", "vLumerName", "vBlumbFil", "vLUMHandler", "vPlumbName", "vLumName", "vBlumbFilter", "vLamLimit", "vLawLimit", "vBlumHandler", "vPlumbLayer", "vLumbName", "vLumbFil", "vLumHandler", "vLumLayer", "vLUMFil", "vPlumLimit", "vLamFilter", "vLawFilter", "vBlumFilter", "vBlumLimit", "vBlumbLimit", "vLumLimit", "vLamName", "vPlumName", "vLumerFilter", "vLawHandler", "vLUMFilter", "vLamLayer", "vLumbHandler", "vBlumbHandler", "vLumerLayer", "vLumbFilter", "vPlumbFilter", "vLUMLimit", "vPlumFilter", "vLawFil"], "vChrFilter": ["vChtSort", "vChnrFilter", "vChrFill", "vChtFilter", "vChrcFill", "vChrtMask", "vPhrMask", "vChrRule", "vChtMask", "vChnrFill", "vChnrResult", "vChrbResult", "vChrtRule", "vChnrSort", "vChrbFill", "vSchrbSort", "vPhrRule", "vChrcSort", "vChrcMask", "vChrtSort", "vPhrcRule", "vSchrbFilter", "vSchrFill", "vPhrcMask", "vChrSort", "vChrbFilter", "vSchrbResult", "vSchrFilter", "vSchrbFill", "vChtRule", "vSchrResult", "vChrResult", "vChrcResult", "vPhrSort", "vPhrFilter", "vPhrcFilter", "vChrcFilter", "vChrMask", "vChrtFilter", "vChrbSort", "vChrcRule", "vPhrcSort", "vSchrSort"], "hLumFilter": ["hLUMFl", "hLumaSelect", "hMumSort", "hClumiFl", "hMumaUrl", "hLmFilter", "hLmSort", "hClumFilter", "hMumaFilter", "hLumifilter", "hLmSelect", "hLrumUrl", "hLumSelect", "hClumifilter", "hMumSelect", "hLrumSort", "hLemFl", "hLumaFilter", "hMumaSort", "hLumSort", "hLrumSelect", "hMumaSelect", "hLemfilter", "hMumFilter", "hLumFl", "hLumaUrl", "hClumiFilter", "hLumaSort", "hMumUrl", "hLUMFilter", "hLumiFilter", "hLumfilter", "hLumUrl", "hLumiFl", "hLemFilter", "hClumFl", "hClumfilter", "hLUMfilter", "hLrumFilter", "hLmUrl"], "hChrFilter": ["hHrbControl", "hChruRequest", "hHrbRequest", "hchrcUser", "hChdUser", "hChdFilter", "hChrHandler", "hChsrControl", "hChruFilter", "hChrbRequest", "hChrRequest", "hchrFactor", "hChrbControl", "hChrUser", "hHrRequest", "hHrbFilter", "hChrbUser", "hChdFactor", "hchrFilter", "hChdSort", "hchrUser", "hChrbSort", "hchrcFactor", "hChsrRequest", "hchrcFilter", "hChrcFilter", "hChrcFactor", "hChrbHandler", "hHrbHandler", "hChruControl", "hHrHandler", "hChrbFactor", "hchrSort", "hChrcSort", "hChsrFilter", "hchrcSort", "hChrFactor", "hHrFilter", "hChrbFilter", "hChruHandler", "hChrcUser", "hChrSort", "hChsrHandler", "hChrControl", "hHrControl"], "lumMmxFilter": ["lumLgrLimit", "lumMmxSort", "lumPuxFile", "lumMmxHeader", "lumMuxFilter", "lumLmxSort", "lumMgrLimit", "lumMxLimit", "lumMmxF", "lumLmxF", "lumPmxFilter", "lumMxFilter", "lumMxSort", "lumMuxHeader", "lumMappingLimit", "lumMgrSort", "lumMexHeader", "lumPuxHeader", "lumMappingFilter", "lumMappingSort", "lumMexFilter", "lumMuxFile", "lumMappingF", "lumMexFile", "lumMaxHeader", "lumLmxLimit", "lumMaxFile", "lumLgrFilter", "lumLgrF", "lumPuxFilter", "lumLmxFilter", "lumMxF", "lumMaxFilter", "lumMmxFile", "lumPmxFile", "lumMgrF", "lumMgrFilter", "lumPmxHeader", "lumLgrSort", "lumMmxLimit"], "chrMmxFilter": ["chrLmxProfile", "chrMoverFilter", "chrMaxFilter", "chrMoverConfig", "chrMoverLayer", "chrMmxConfig", "chrMixFilter", "chrMexLayer", "chrMexProfile", "chrMappingConfig", "chrMixProfile", "chrLexF", "chrLexConfig", "chrMixConfig", "chrRmxF", "chrMmxLayer", "chrLexProfile", "chrRmxFilter", "chrMaxF", "chrMexFilter", "chrRexFilter", "chrRmxLayer", "chrRexConfig", "chrMexF", "chrRexF", "chrLmxFilter", "chrMaxConfig", "chrMaxLayer", "chrMappingProfile", "chrMmxF", "chrRexLayer", "chrMoverF", "chrLmxConfig", "chrMexConfig", "chrRmxConfig", "chrLexFilter", "chrMixF", "chrMappingFilter", "chrMappingF", "chrMmxProfile", "chrLmxF"], "lumPixBuf": ["lumPexBuff", "lumPixBuffuf", "lumPixCuf", "lumPixLlu", "lumPixBof", "lumPixCuff", "lumPexBmp", "lumPixAuf", "lumPixDof", "lumPixBuffuff", "lumPexCmp", "lumPexCuff", "lumPixLuf", "lumPngBlu", "lumPixBuff", "lumPngBum", "lumPixAum", "lumPexCuf", "lumPixDmp", "lumPixBmp", "lumPixDuf", "lumPixBuffmp", "lumPixLum", "lumPixBlu", "lumPixAuff", "lumPixAlu", "lumPexCof", "lumPixCof", "lumPngBuff", "lumPixDuff", "lumPixBum", "lumPixLuff", "lumPixCmp", "lumPngBuf", "lumPixBuffof", "lumPexBof", "lumPexBuf"], "chrPixBuf": ["chrPixAust", "chrPxBust", "chrPixLmp", "chrPxAmp", "chrPixBundle", "chrPixBmp", "chrPixMump", "chrPixelsMump", "chrPixMundle", "chrPixelsBundle", "chrPixelsBob", "chrPixelsMob", "chrPxBuf", "chrPixLuff", "chrPixAuf", "chrPixBuffob", "chrPixBomp", "chrPixMob", "chrPixMuf", "chrPixBuffuf", "chrPixLuf", "chrPxAuf", "chrPixAmp", "chrPixBuff", "chrPixBuffundle", "chrPixBuffump", "chrPixBob", "chrPxBuff", "chrPxBmp", "chrPixBump", "chrPixelsBuf", "chrPixAuff", "chrPixBouf", "chrPxAust", "chrPixBouff", "chrPixBoust", "chrPixelsMuf", "chrPixelsBump", "chrPixelsMundle", "chrPixLust", "chrPixBust", "chrPxAuff"]}}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static int amr_nb_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                               const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    AMRContext *s = avctx->priv_data;\n\n    int written, ret;\n\n    int16_t *flush_buf = NULL;\n\n    const int16_t *samples = frame ? (const int16_t *)frame->data[0] : NULL;\n\n\n\n    if (s->enc_bitrate != avctx->bit_rate) {\n\n        s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);\n\n        s->enc_bitrate = avctx->bit_rate;\n\n    }\n\n\n\n    if ((ret = ff_alloc_packet(avpkt, 32))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");\n\n        return ret;\n\n    }\n\n\n\n    if (frame) {\n\n        if (frame->nb_samples < avctx->frame_size) {\n\n            flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));\n\n            if (!flush_buf)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(flush_buf, samples, frame->nb_samples * sizeof(*flush_buf));\n\n            samples = flush_buf;\n\n            if (frame->nb_samples < avctx->frame_size - avctx->delay)\n\n                s->enc_last_frame = -1;\n\n        }\n\n        if ((ret = ff_af_queue_add(&s->afq, frame)) < 0) {\n\n            av_freep(&flush_buf);\n\n            return ret;\n\n        }\n\n    } else {\n\n        if (s->enc_last_frame < 0)\n\n            return 0;\n\n        flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));\n\n        if (!flush_buf)\n\n            return AVERROR(ENOMEM);\n\n        samples = flush_buf;\n\n        s->enc_last_frame = -1;\n\n    }\n\n\n\n    written = Encoder_Interface_Encode(s->enc_state, s->enc_mode, samples,\n\n                                       avpkt->data, 0);\n\n    av_dlog(avctx, \"amr_nb_encode_frame encoded %u bytes, bitrate %u, first byte was %#02x\\n\",\n\n            written, s->enc_mode, frame[0]);\n\n\n\n    /* Get the next frame pts/duration */\n\n    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,\n\n                       &avpkt->duration);\n\n\n\n    avpkt->size = written;\n\n    *got_packet_ptr = 1;\n\n    av_freep(&flush_buf);\n\n    return 0;\n\n}\n", "idx": 13163, "substitutes": {"avctx": ["avalloc", "ajloc", "abconn", "avlc", "aploc", "raftpkg", "aflc", "akcmp", "afxc", "avalcca", "evconn", "vercf", "avcu", "avallc", " avcontext", "avecmp", "ajcca", "avxc", "evcmp", "afcmd", "avecontext", "avctl", "abctx", "afconn", "abcontext", " avcca", "ajcontext", "abcmp", "apcontext", "afcit", "afcf", "avectx", "avcli", "ajkw", "afcu", "afcontext", "akctrl", "raftcli", "awpkg", "ajcit", "aplc", " avloc", "evcontext", "akctx", "avconn", "avloc", "avectrl", "ajcmp", "avctrl", "verxc", "akcontext", "evctx", "avkw", "avepkg", " avpkg", "avcf", "afkw", "avecu", "ajxc", "apconn", "vercontext", " avxc", "akcf", "ajctx", "apcu", "afloc", "verctx", "avecf", "abcmd", "afctx", "afctl", "raftcontext", "avalcf", "akxc", "ajcf", "afcli", "avalconn", "appkg", " avcit", "raftctx", "avcca", "afcca", "afpkg", "avalctl", " avcmd", "awctx", " avcf", "avcmp", "avekw", "apctl", "avcit", "avalpkg", "afcmp", "apctx", "avalcontext", "avcmd", "avalctx", "ajcmd", "avcontext", "awcli", "avalcmd", "avpkg", "afctrl", "awcontext"], "avpkt": ["avipnt", " avpqt", "avfck", "avjpkg", "avspkt", "avfkt", "avjpki", "avjpwk", "avtpwk", "avjpqt", " avipqt", "appkg", "avfacket", "apjpwk", " avpkg", " avipnt", "avpqt", "avjpnt", "avjpacket", "avjpck", "avtpkt", "avspkg", " avipkt", "avpacket", "avipqt", "avpki", "avtpacket", "avpck", "appwk", " avpacket", " avspacket", "avfnt", " avspkg", " avpck", "appkt", "appacket", "avfkg", "avfki", "avspki", " avspki", " avpki", "avpwk", "avfwk", "avtpkg", "apjpkg", "avipck", " avipck", "avspacket", " avspkt", "avjpkt", "avipkt", "avpkg", "apjpacket", " avpnt", "avfqt", "avpnt", "apjpkt"], "frame": [" Frame", "fl", "sample", "za", "flat", "image", "event", "module", "ace", "vol", "model", "rame", "raise", "flow", "frames", "line", "c", "cb", "fee", "cycle", "window", "dom", "message", "pse", "call", "m", "slice", "series", "fps", "progress", "sequence", "session", "fr", "fake", "fi", "data", "byte", "length", "feed", "function", "el", "header", "thread", "zip", "format", "Frame", "slot", "fram", "config", "iframe", "fb", "cpu", "game", "buffer", "scope", "element", "document", "view", "e", "j", "f", "none", "point", "feature", "state", "fe", "block", "ne", "cf", "que", "video", "node", "ze", "tick", "channel", "board", "code", "up", "object", "orig", "range", "position", "request", "set", "dy", "time", "component", "setup", "next", "file", "target", "process", "forward", "seq"], "got_packet_ptr": ["got_packacket2desc", "got_packacket2ptr", "got_packet2desc", "got_packet2pointer", "got_packet2ptr", "got_packacket_pointer", "got_packet6ptr", "got_packacket2pointer", "got_packet6pointer", "got_packet6desc", "got_packacket2data", "got_packacket_data", "got_packacket_ptr", "got_packet2data", "got_packet_pointer", "got_packet_data", "got_packet_desc", "got_packet6data", "got_packacket_desc"], "s": ["args", "sys", "ses", "m", "parts", "d", "service", "sync", "sg", "t", "fs", "i", "l", "sym", "rs", "a", "ins", "g", "cs", "qs", "S", "sp", "h", "os", "sets", "js", "si", "es", "sq", "scope", "session", "uns", "v", "conf", "ss", "storage", "ps", "o", "set", "ms", "p", "e", "se", "site", "data", "b", "sb", "j", "f", "gs", "spec", "state", "c", "ns", "xs", "is", "stats", "sc", "ssl", "side", "sl", "states", "ops", "ds", "services", "r", "ls", "ts", "us", "vs", "ks", "aws"], "written": ["wrote", "en", "called", "done", "edited", " rewritten", "fd", "printed", "ritten", "weight", "bytes", "unit", "generated", "checked", "writer", "writing", "locked", "created", "output", "ed", "w", "finished", "rawn", "updated", "writers", "mem", "temp", "wait", "data", "byte", "used", "read", "protected", "loaded", "reset", "writ", "wa", "started", "write", "sent", "Written", "ended", "seq", "changed", "run", "len", "won", "WR"], "ret": ["alt", "en", "ft", "rev", "format", "let", "reply", "art", "sat", "val", "code", "back", "bad", "def", "rets", "fun", "status", "ref", "pret", "det", "arg", "lit", "valid", "job", "value", "failed", "obj", "active", "mem", "temp", "fin", "success", "match", "Ret", "used", "result", "att", "reset", "arr", "cat", "nt", "re", "hard", "rt", "r", "resp", "repl", "rot", "real", "RET", "res", "reg", "flag", "run", "len", "red", "err"], "flush_buf": ["flush_vec", "flushPuf", "cleaninguf", "flush2callback", "flushPseq", "flusherpos", "update_pos", "flushingfunc", "fl_uf", "reset_fun", "push_vec", "flushacbuf", "flush_abs", "push_uf", "flushacbox", "flush_uf", "update_uf", "flusherqueue", "push_block", "reset64pool", "clean_br", "copy_brace", "push_buf", "flush_pos", "clean_buffer", "reset_pool", "flush_pool", "flush_fun", "flush64fun", "cleaningbuffer", "clean_cas", "flush_func", "flusheruf", "filter_buf", "filter_ff", "ushingbox", "flushetabs", "push_home", "flushacfunc", "flush_queue", "flush_buffer", "flush67buffer", "flush67bag", "push_wb", "update_queue", "flush_brace", "reset64cur", "reset64fun", "flush2bag", "flush67buf", "ush_loc", "flushingbrace", "flush_block", "fl_seq", "ush_buf", "flush67brace", "flush2buf", "flushinguf", "flush_cur", "flushetexc", "ushingloc", "flushetbuf", "filter_abs", "flush2loc", "push_box", "flushPbuf", "flushingbuffer", "flush_home", "flush_cas", "cleaningbrace", "flush64buf", "filteretbuf", "update_buf", "push_bag", "flush_cap", "flush_box", "flush67home", "flush67vec", "flush_ff", "flush2brace", "flush2vec", "flush_loc", "fl_box", "flushingbuf", "flush_bag", "flush64pool", "fl_buf", "flush_buff", "reset_cur", "filteretabs", "flush67loc", "ush_func", "ush_box", "push_cap", "copy_vec", "flush67cas", "flush67br", "flush2uf", "flushPbox", "flush64cur", "push_buff", "flush67uf", "flushingbox", "push_buffer", "copy_buf", "filter_exc", "filteretff", "clean_uf", "flusherbuf", "push_loc", "clean_brace", "flush67callback", "ushingfunc", "flush_seq", "clean_buf", "flush_callback", "flush67wb", "flush_wb", "filteretexc", "copy_callback", "ushingbuf", "flushetff", "flushingloc", "reset64buf", "flush_exc", "flush_br", "cleaningbuf", "reset_buf", "flushacloc"], "samples": ["Sockets", " sessions", "dplays", "Sipes", " smodels", " samps", "sample", "Splays", "Sessions", "Smodels", "Samples", "Samps", " sockets", "namps", "sockets", " sample", "smodels", "nmodels", "samps", "sesamples", "splays", "Sample", "namples", "sessions", "sesessions", "damples", "nipes", "sesample", " splays", " sipes", "dample", "sesamps", "sipes"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "void ppc_store_xer (CPUPPCState *env, uint32_t value)\n\n{\n\n    xer_so = (value >> XER_SO) & 0x01;\n\n    xer_ov = (value >> XER_OV) & 0x01;\n\n    xer_ca = (value >> XER_CA) & 0x01;\n\n    xer_cmp = (value >> XER_CMP) & 0xFF;\n\n    xer_bc = (value >> XER_BC) & 0x3F;\n\n}\n", "idx": 20716, "substitutes": {"env": ["status", "txt", "en", "obj", "err", "config", "iv", "result", "device", "buffer", "dev", "init", "data", "enc", "dict", "code", "np", "addr", "buf", "settings", "cal", "set", "console", "proc", "ev", "environment", "fi", "ec"], "value": ["status", "member", "begin", "package", "reg", "name", "the", "attribute", "property", "Value", "response", "object", "end", "scale", "result", "non", "val", "message", "key", "lua", "feature", "token", "get", "type", "function", "buffer", "hello", "device", "one", "entry", "address", "size", "data", "program", "use", "fee", "description", "version", "current", "number", "id", "code", "comment", "values", "complete", "source", "document", "beta", "create", "set", "error", "child", "total", "element", "definition", "reference", "expression", "parent", "range", "resource", "image", "server", "block", "variable", "VALUE", "command", "format", "vector"]}}
{"project": "qemu", "commit_id": "d3d250bddb3f6aa6c26e9dadf10e82d9fd8bfce3", "target": 1, "func": "int scsi_bus_legacy_handle_cmdline(SCSIBus *bus)\n\n{\n\n    Location loc;\n\n    DriveInfo *dinfo;\n\n    int res = 0, unit;\n\n\n\n    loc_push_none(&loc);\n\n    for (unit = 0; unit < bus->info->max_target; unit++) {\n\n        dinfo = drive_get(IF_SCSI, bus->busnr, unit);\n\n        if (dinfo == NULL) {\n\n            continue;\n\n        }\n\n        qemu_opts_loc_restore(dinfo->opts);\n\n        if (!scsi_bus_legacy_add_drive(bus, dinfo->bdrv, unit, false, -1)) {\n\n            res = -1;\n\n            break;\n\n        }\n\n    }\n\n    loc_pop(&loc);\n\n    return res;\n\n}\n", "idx": 19243, "substitutes": {"bus": ["board", "plugin", "session", "data", "user", "base", "comment", "las", "series", "usb", "nt", "io", "service", "bridge", "feed", "Bus", "module", "block", "bc", "hub", "this", "object", "controller", "class", "build", "use", "config", "mount", "sync", "cat", "lib", "dev", "driver", "plug", "cache", "BUS", "lock", "http", "product", "boot", "proc", "loop", "serial", "connection", "os", "us", "book", "bug"], "loc": ["util", "spec", "global", "where", "data", "lim", "info", "las", "dir", "reg", "rc", "lit", "rel", "num", "root", "or", "region", "coll", "src", "lex", "ctx", "Loc", "l", "location", "rec", "vol", "tx", "los", "remote", "bas", "voc", "parent", "lc", "c", "lib", "LOC", "col", "error", "la", "route", "loop", "local", " location", "state", "iter", "lang", "desc", "co", "lat", "valid", " Loc"], "dinfo": ["cdinfo", "dsid", "ddata", "vdinit", "cdinf", "lInfo", "dInfo", "dsinfo", "ldinfo", " dafi", "dinit", "dlinf", "ldinf", "Dinfo", "dinf", " did", "cddata", " dinit", "ldafi", " dinf", "dapi", "vdinfo", "dlinit", "vddef", "dsstate", "ldInfo", "dlinfo", "dafi", "dldata", "dstate", "Dafi", "did", "dlstate", "dldef", "Dinf", "lapi", " dapi", "vdapi", "cdstate", "vdInfo", "linfo", "ldid", " ddef", "ddef", " dInfo", "vdinf", "dsInfo", "dsdata", "dsinf", "linf"], "unit": ["uri", "part", "scale", "un", " units", "direction", "element", "name", "base", "category", "component", "file", "num", "nit", "i", "module", "year", "type", "block", "station", "index", "pos", "model", "dim", "min", "nat", "label", "force", "units", "format", "size", "uni", "style", "site", "ui", "no", "value", "rule", "key", "limit", "temp", "Unit", "position", "device", "parent", "condition", "address", "col", "route", "domain", "u", "number", "weight", "connection", "port", "order", "version", "target", "mu"]}}
{"project": "qemu", "commit_id": "95c3df5a24e2f18129b58691c2ebaf0d86808525", "target": 1, "func": "block_crypto_create_opts_init(QCryptoBlockFormat format,\n\n                              QemuOpts *opts,\n\n                              Error **errp)\n\n{\n\n    OptsVisitor *ov;\n\n    QCryptoBlockCreateOptions *ret = NULL;\n\n    Error *local_err = NULL;\n\n\n\n    ret = g_new0(QCryptoBlockCreateOptions, 1);\n\n    ret->format = format;\n\n\n\n    ov = opts_visitor_new(opts);\n\n\n\n    visit_start_struct(opts_get_visitor(ov),\n\n                       NULL, NULL, 0, &local_err);\n\n    if (local_err) {\n\n        goto out;\n\n    }\n\n\n\n    switch (format) {\n\n    case Q_CRYPTO_BLOCK_FORMAT_LUKS:\n\n        visit_type_QCryptoBlockCreateOptionsLUKS_members(\n\n            opts_get_visitor(ov), &ret->u.luks, &local_err);\n\n        break;\n\n\n\n    default:\n\n        error_setg(&local_err, \"Unsupported block format %d\", format);\n\n        break;\n\n    }\n\n    error_propagate(errp, local_err);\n\n    local_err = NULL;\n\n\n\n    visit_end_struct(opts_get_visitor(ov), &local_err);\n\n\n\n out:\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        qapi_free_QCryptoBlockCreateOptions(ret);\n\n        ret = NULL;\n\n    }\n\n    opts_visitor_cleanup(ov);\n\n    return ret;\n\n}\n", "idx": 20840, "substitutes": {"format": ["status", "feat", "platform", "str", "package", "transform", "name", "class", "target", "attribute", "object", "language", "config", "option", "pattern", "text", "layout", "mode", "region", "file", "style", "feature", "plugin", "host", "pretty", "mt", "function", "f", "model", "fp", "path", "term", "op", "cat", "data", "size", "method", "version", "at", "unit", "id", "prefix", "act", "Format", "ant", "filename", "settings", "spec", "title", "source", "form", "value", "brand", "channel", "magic", "atter", "fd", "options", "template", "qt", "fn", "api", "sort", "base", "output", "command", "type", "letter"], "QemuOpts": ["QCryptuLibs", "QCryptoClSpec", "QCryptuClts", "QCryptoCls", "QCryptoClts", "QCryptuClo", "QCryptoOpts", "QCryptoOptSpec", "QCryptuConfigSpec", "QCryptuConfigo", "QCryptuOpts", "QCryptuConfigs", "QCryptuCls", "QCryptuClSpec", "QCryptuOptSpec", "QCryptoClo", "QCryptuOpto", "QCryptuLibts", "QCryptuOptts", "QCryptuConfigts", "QCryptoOptts", "QCryptoOpto", "QCryptuLibSpec", "QCryptuLibo"], "ov": ["sv", "kov", "opp", "vers", "ow", "oo", "own", "adr", "ur", "eu", "iv", "off", "over", "av", "obile", "oyer", "cv", "ott", "oto", "oa", "ou", "ork", "oh", "rf", "ef", "ove", "nov", "obb", "oy", "ob", "gov", "oven", "uv", "o", "ovan", "ood", "ever", "ovo", "oid", "ocr", "vr", "oval", "gr", "OV", "orf", "rov", "ovi", "ova", "lov", "boot", "ko", "erv", "ev", "voc", "oc", "fo", "vo"], "ret": ["status", "ut", "reg", "uf", "def", "ig", "obj", "ref", "gt", "conn", "vt", "result", "val", "arg", "ft", "det", "tr", "Ret", "cur", "f", "fit", "sys", "t", "al", "r", "res", "j", "cat", "full", "rets", "opt", "os", "job", "arr", "fin", "auth", "py", "success", "ext", "out", "cb", "rc", "pro", "match", "pass", "RET", "rt", "mem", "vr", "reply", "rev", "re", "session", "gr", "len", "req", "rs", "boot", "alt", "v", "nt", " result", "eval", "att", "lit", "fi", "Return", "fab", "fun"], "local_err": ["local_sys", "localLoger", " local_orig", "local_orig", "local67message", "localableorig", "local_risk", "externalalrisk", "local67err", "local67orig", "local67error", " local_er", "remote_er", "localalnr", " local_ler", " local_rr", "localWlog", "localappresult", "local67risk", "local67nr", "localableerror", "localLogexc", "external_message", "localalrisk", "local_er", "externalalnr", "remote_err", " local_result", "localapperror", "remote_exc", "localallrisk", "localLogerror", "localallerr", "externalalerr", "local_log", "localableerr", "localLogerr", "localallmessage", " local_log", "localWerror", "local_result", "localalerr", "localalmessage", "local_message", "local67sys", "localallnr", "external_risk", "localWrisk", "externalalmessage", "local_ler", " local_sys", "localapper", "localablesys", "external_nr", "local_error", "localapperr", "remote_error", "local_nr", " local_risk", "local_rr", "local_exc", "localWerr", " local_error", "external_err"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)\n\n{\n\n    int bits = 8, sign = 0, shift = 0;\n\n\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n        sign = 1;\n\n    case AUD_FMT_U8:\n\n        break;\n\n\n\n    case AUD_FMT_S16:\n\n        sign = 1;\n\n    case AUD_FMT_U16:\n\n        bits = 16;\n\n        shift = 1;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n        sign = 1;\n\n    case AUD_FMT_U32:\n\n        bits = 32;\n\n        shift = 2;\n\n        break;\n\n    }\n\n\n\n    info->freq = as->freq;\n\n    info->bits = bits;\n\n    info->sign = sign;\n\n    info->nchannels = as->nchannels;\n\n    info->shift = (as->nchannels == 2) + shift;\n\n    info->align = (1 << info->shift) - 1;\n\n    info->bytes_per_second = info->freq << info->shift;\n\n    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);\n\n}\n", "idx": 3755, "substitutes": {"info": ["this", "txt", "from", "next", "options", "home", "opt", "hi", "private", "f", "comment", "qa", "manager", "start", "name", "ami", "tf", "extra", "image", "ui", "help", "id", "end", "Info", "auth", "api", "off", "update", "parse", "p", "state", "conf", "die", "io", "init", "base", "li", "offset", "INFO", "ii", "fw", "data", "new", "di", "add", "ions", "op", "py", "i", "inner", "util", "back", "result", "afi", "setup", "iso", "app", "note", "about", "obj", "error", "si", "inf", "fo", "check", "http", "def", "show", "it", "now", "tp", "config", "hand", "full", "part", "diff"], "as": ["parser", "to", "nas", "so", "acs", "asu", "http", "ss", "ass", "a", "sa", "ga", "rs", "spec", "alias", "asi", "ans", "ap", "ase", "aws", "ma", "is", "auth", "asp", "api", "off", "ac", "ars", "ras", "ams", "bas", "asc", "address", "func", "pa", "or", "afi", "us", "As", "pas", "AS", "ar", "sys", "s", "at", "asm", "os", "var", "session", "al", "las", "bs", "an", "by", "am", "ast", "se", "ace"]}}
{"project": "FFmpeg", "commit_id": "f0ca6ffa0ae5d5564516ee7a18aa1e234751444a", "target": 1, "func": "static void show_packets(AVFormatContext *fmt_ctx)\n\n{\n\n    AVPacket pkt;\n\n\n\n    av_init_packet(&pkt);\n\n    probe_array_header(\"packets\", 0);\n\n    while (!av_read_frame(fmt_ctx, &pkt))\n\n        show_packet(fmt_ctx, &pkt);\n\n    probe_array_footer(\"packets\", 0);\n\n}\n", "idx": 17554, "substitutes": {"fmt_ctx": ["fmt_context", "fmt_cm", "fmtfpkg", "fmtfctx", "frt_cm", "fmt_conn", "fmt_lc", "fmtfsci", "frt_sci", "fmtfcm", "frt_context", "fmtflc", "frt_conn", "fmt_sci", "frt_cp", "fmt_pkg", "frt_pkg", "frt_lc", "fmt_cp", "frt_ctx", "fmtfcontext", "fmtfconn", "fmtfcp"], "pkt": ["bpkt", "pnt", "Pnt", "wkg", "wacket", "bpnt", "fkt", "Pett", "Pet", "fet", "pett", "bpacket", "wkt", "Packet", "ppct", " pct", "packet", " pet", " packet", " pnt", "ppkt", "ppacket", "facket", "Pkg", "pkg", "fct", "pct", "fkg", "Pkt", "bpct", "Pct", "pet", "ppett", "fett", "wct"]}}
{"project": "FFmpeg", "commit_id": "a91d82b5cc7d828ea9779aae1595f60e7e257d29", "target": 1, "func": "static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)\n\n{\n\n    int i, k, sb = 0;\n\n    int msb = sbr->k[0];\n\n    int usb = sbr->kx[1];\n\n    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;\n\n\n\n    sbr->num_patches = 0;\n\n\n\n    if (goal_sb < sbr->kx[1] + sbr->m[1]) {\n\n        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;\n\n    } else\n\n        k = sbr->n_master;\n\n\n\n    do {\n\n        int odd = 0;\n\n        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {\n\n            sb = sbr->f_master[i];\n\n            odd = (sb + sbr->k[0]) & 1;\n\n        }\n\n\n\n        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);\n\n        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];\n\n\n\n        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {\n\n            usb = sb;\n\n            msb = sb;\n\n            sbr->num_patches++;\n\n        } else\n\n            msb = sbr->kx[1];\n\n\n\n        if (sbr->f_master[k] - sb < 3)\n\n            k = sbr->n_master;\n\n    } while (sb != sbr->kx[1] + sbr->m[1]);\n\n\n\n    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)\n\n        sbr->num_patches--;\n\n\n\n    // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5\n\n    // However the Coding Technologies decoder check uses 6 patches\n\n    if (sbr->num_patches > 6) {\n\n        av_log(ac->avccontext, AV_LOG_ERROR, \"Too many patches: %d\\n\", sbr->num_patches);\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 26862, "substitutes": {"ac": ["acc", "exec", "aic", "acl", "dc", "oc", "auc", "anc", "c", "fac", "acer", "doc", "sac", "soc", "am", "ad", "ct", "bc", "mac", "mic", "fc", "AC", "ic", "cms", "vc", "cc", "Ac", "jac", "rc", "cache", "mc", "aut", "ca", "ack", "tc", "arc", "acs", "iac", "pc", "cam"], "sbr": ["sbe", "ansbl", "opensler", "wsBR", "sesbre", "chesber", " sdr", "lsBR", "jsbar", "opensarr", "tsbr", " shr", "sobi", "opensbr", "lsbro", " soulder", "nsdb", "confbert", "lsstr", "alsdr", " sbar", "soder", "esarr", "ssbridge", "gsbre", "chesbr", "wsbro", "lsbert", "ishr", "esbre", "confbar", "sinbr", "sinbl", "sbert", "opensbridge", "gsbr", "fsbro", "dsBR", "lsbr", "nsstr", "esstr", "esibr", "psber", "wsbl", "wsarr", "sesbridge", "nsbe", "setsbar", "esgr", "dsbar", " sibr", "esbar", "isher", "confbridge", " sfr", "gsfer", "chesbro", "sBR", "asdb", "setsorb", "sysibr", "confbr", "confbre", "ssber", "fsbl", "tsbro", "asibr", "sfer", " soper", "osbridge", "tsbre", "ssbl", "psfer", "ansbre", "gsber", "gsbro", "psbl", "sinbre", "sorb", "dsbl", "ansbr", "lsber", "lsfr", "ssfr", "isdiv", "sesibr", " sbre", "lsarr", " sbridge", "sesbert", "jsbr", "asbr", "psbro", "opensbert", "asbre", "gsdr", "outsbr", "sarr", "esorb", "nsbre", "ssbre", "jsbre", "psstr", "fsbr", "ansgr", "outsbridge", "ansbro", "ssobi", "shr", " sBR", "tsfr", "jsbro", "esbr", "osbert", "sdb", "psbre", "wsbr", "gsoder", "ansarr", " sfer", "sdiv", "dshr", "insbro", " sarr", "sbl", "setsbl", "sher", "setsher", "sgr", " sher", "dsbert", "fsbridge", "sstr", "ssBR", "sibr", "singr", "sshr", "opensibr", "gsbl", "psbr", "lshr", "sysdr", "lsbar", "psher", "alsbert", "outsibr", "confibr", "sfr", "gshr", "sler", "jsbridge", "ssher", "asarr", "ssler", "chesbridge", " sbro", "alsbr", "nsber", " sgr", "isbl", "jsstr", "lsbre", "soulder", "ssbr", " sorb", "tsbl", "sbar", "setsbert", "tsoulder", "outsbert", "ssarr", "anshr", "wsfr", "esbl", "eshr", "sbre", "ssibr", "sbro", "fsbar", "isbre", "sbridge", " soder", " sdiv", "dsbridge", "alsibr", "sesbr", "setsbre", "setsgr", "osibr", "ansBR", " sstr", "esber", "tsBR", "dsbre", "dsbr", "insbl", " sbert", "lsbl", "gsbridge", "ansfr", "isbar", "sysbert", "tsibr", "sdr", "nsbr", "opensobi", "asbl", "wsber", "lsher", "asbe", "setsbr", "sber", " sber", "sysbr", "fshr", "ssoper", "sysoulder", "psdr", "confbl", "ansber", "soper", "osbr", "nsbar", " sbl", "wsbre", " sobi", "jshr", "lsbridge", " sler", "insbr", "sysbl", "isbr", "setsdiv", "inshr"], "i": ["ski", "yi", "b", "m", "p", "c", "ie", "d", "ix", "x", "ti", "mi", "phi", "qi", "it", "ri", "id", "io", "u", "e", "li", "gi", "o", "s", "xi", "ii", "ini", "si", "ai", "bi", "ni", "di", "ci", "ik", "h", "I", "f", "ki", "y", "n", "j", "index", "a", "oi", "chi", "v", "iu", "pi", "ui", "l"], "k": ["mask", "tk", "sk", "kn", "kw", "w", "kk", "z", "b", "m", "p", "c", "kh", "d", "ka", "unk", "x", "kick", "kin", "K", "km", "ad", "isk", "ks", "ch", "jj", "id", "kb", "kt", "u", "ak", "e", "key", "ijk", "o", "uk", "work", "s", "ok", "l", "spec", "ko", "ky", "ik", "mc", "ikk", "kr", "ek", "h", "ack", "f", "y", "ki", "n", "j", "t", "mm", "mk", "q", "kat", "v", "ck", "kid", "ke", "ku", "kl", "dk", "g"], "num_patches": ["num_catches", "num_petrices", "num_batouts", "num_patchchers", "num_pitctions", "num_datches", "num_partches", "num_batches", "num_butched", "num_atencies", "num_natges", "num_butouts", "num_patternters", "num_catched", "num_pathes", "num_petencies", "num_patries", "num_Patched", "num_patctions", "num_pats", "num_batatches", "num_patouts", "num_patchatches", "num_natched", "num_patchencies", "num_patchching", "num_patters", "num_petions", "num_patchche", "num_patns", "num_ations", "num_petched", "num_patche", "num_patatches", "num_aptching", "num_patures", "num_catchers", "num_datters", "num_apthes", "num_natches", "num_pitries", "num_patchions", "num_fetchers", "num_partched", "num_patchhes", "num_parching", "num_petges", "num_patges", "num_catrices", "num_patchters", "num_natrices", "num_fetched", "num_pitches", "num_pits", "num_patencies", "num_atches", "num_fetches", "num_butches", "num_atchers", "num_patternche", "num_patternched", "num_atns", "num_parhes", "num_datched", "num_patrices", "num_Pations", "num_patchures", "num_Patches", "num_aptched", "num_aptchers", "num_pitions", "num_Pats", "num_patched", "num_atures", "num_pations", "num_patchctions", "num_batched", "num_parries", "num_pitchers", "num_datche", "num_patternches", "num_petchers", "num_fetctions", "num_butries", "num_patchches", "num_aptches", "num_parches", "num_aptries", "num_catges", "num_patchouts", "num_partries", "num_patchers", "num_atched", "num_patchries", "num_pitched", "num_petches", "num_patchched", "num_patchns", "num_patching", "num_patchs", "num_partatches", "num_batries", "num_catures", "num_petns"]}}
{"project": "qemu", "commit_id": "b3f7f0c5e6449be7275f1762bccbfa2177395a3b", "target": 1, "func": "static void colo_process_checkpoint(MigrationState *s)\n{\n    QIOChannelBuffer *bioc;\n    QEMUFile *fb = NULL;\n    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n    Error *local_err = NULL;\n    int ret;\n    failover_init_state();\n    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);\n    if (!s->rp_state.from_dst_file) {\n        error_report(\"Open QEMUFile from_dst_file failed\");\n    /*\n     * Wait for Secondary finish loading VM states and enter COLO\n     * restore.\n     */\n    colo_receive_check_message(s->rp_state.from_dst_file,\n                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);\n    if (local_err) {\n    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);\n    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));\n    object_unref(OBJECT(bioc));\n    qemu_mutex_lock_iothread();\n    vm_start();\n    qemu_mutex_unlock_iothread();\n    trace_colo_vm_state_change(\"stop\", \"run\");\n    while (s->state == MIGRATION_STATUS_COLO) {\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n        if (current_time - checkpoint_time <\n            s->parameters.x_checkpoint_delay) {\n            int64_t delay_ms;\n            delay_ms = s->parameters.x_checkpoint_delay -\n                       (current_time - checkpoint_time);\n            g_usleep(delay_ms * 1000);\n        ret = colo_do_checkpoint_transaction(s, bioc, fb);\n        if (ret < 0) {\n        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\nout:\n    /* Throw the unreported error message after exited from loop */\n    if (local_err) {\n        error_report_err(local_err);\n    if (fb) {\n        qemu_fclose(fb);\n    if (s->rp_state.from_dst_file) {\n        qemu_fclose(s->rp_state.from_dst_file);", "idx": 4815, "substitutes": {"s": ["stat", "o", "sets", "sf", "ins", "is", "S", "spec", "sg", "session", "si", "sync", "sys", "ses", "services", "m", "status", "states", "xs", "f", "ns", "state", "stats", "ls", "sl", "args", "iss", "service", "bs", "cs", "ss", "conf", "series", "sis", "e", "sie", "sb", "gs", "ks", "ops", "uns", "bis", "ds", "qs", "t", "secondary", "sim", "ts", "su", "self", "p", "south", "settings", "aws", "sv", "fs", "c", "os", "ssl", "sq", "sym", "site", "es", "se", "ps", "js"], "bioc": [" bioci", "biOC", "miog", "kiocl", "kioc", "bioci", "abiog", "ciocl", "biou", "fioc", "niOC", "diog", "kiOC", " biou", "miou", " biOC", "biocal", "bioco", "biog", "dioco", "abiocol", "abiOC", "biocol", "nioc", "mioc", "abiocal", "fiOC", " biocol", " biocal", " biocl", " biog", "ciou", "abiocl", "dioci", "cioc", "niocal", "biocl", "abioci", "abioco", "miocl", "ciog", " bioco", "dioc", "kioco", "fiocol", "abioc", "fiog", "niog"], "fb": ["fen", "fg", "buff", "lb", "sf", "fw", "obb", "RF", "rb", "tmp", "bg", "ob", "rf", "raf", "orb", "buf", "wb", "f", "usb", "bb", "xb", "fe", "eb", "facebook", "sb", "fn", "ab", "cb", "fp", "bc", "nb", "fa", "fm", "fab", "fs", "bf", "fd", "deb", "cf", "fc", "FB", "ref", "pb", "fi", "ff"], "current_time": ["currentalsleep", "currentacTime", "current00delay", "current_length", "contentalsleep", "currentFfrequency", "current_duration", "current_path", "current_image", "current_delay", "contentalimage", "content_length", " current_path", "total_speed", "current00count", "content_image", "current_speed", "total_runtime", "current_TIME", "currentingtime", "currentalimage", "current00TIME", "current_frequency", "currentacdelay", "currentFcount", "currentacpath", "content_sleep", "current67time", " current_Time", "current00Time", "current_count", " current_TIME", "current00frequency", "current67length", "current_runtime", "total_time", "currentaltime", "currentFTIME", " current_frequency", "current_Time", "contentaltime", "contentallength", " current_count", "current67image", "currentingspeed", "currentactime", "content_time", "currentingduration", "currentFtime", "currentingruntime", "current00path", "current00time", "total_duration", "currentallength", " current_delay", "current_sleep", "current67sleep"], "local_err": ["remote_err", "local_orig", "foreign_progress", "localapperror", "localapper", "localableerr", "local_error", "foreign_dr", "foreignxprogress", "localxdr", "remote_state", "foreignxerr", "global_err", "custom_result", "localamstate", "localxcache", "global_notice", "localamerror", "localipprogress", "local_result", "local_notice", "localiperr", "custom_msg", "localxprogress", "localipdr", "local_dr", "local_msg", "localxerr", "localappnotice", "localableorig", "custom_rr", "foreign_cache", "remote_error", "foreignxdr", "localableer", "foreignxcache", "global_orig", "local_cache", "localamerr", "localipcache", "local_progress", "custom_err", "localapperr", "foreign_err", "global_error", "localableresult", "local_rr", "local_er", "global_result", "global_er", "local_state"], "ret": ["red", "reg", "flag", "rt", "sr", "alt", "count", "try", "nt", "rb", "rot", "val", "rc", "bit", "let", "reply", "pt", " RET", "num", " Ret", "lit", "att", "arg", "res", "ry", "match", "len", "mt", "code", "det", "out", "RET", "pass", "rl", "rev", "result", "Ret", "ft", "re", "fun", "bf", "resp", "success", "ref", "no", "rets"], "delay_ms": ["delay_mins", "delay32ms", "delay_details", "delayFts", "delay__mins", "delay_bytes", "delayingbytes", "pause_loads", "delay32mins", "pausevalyrs", "delayFdetails", "delayacbytes", " delay_details", "delayacmb", "delayingmb", " delay_ts", "delay_loads", "delay32ts", "delayvalmins", "pausevalloads", "pausevalmins", "delayingms", "delayacms", "delay_ts", " delay_mb", "pause_yrs", "pausevalms", "delay_yrs", "delayvalloads", "delay__yrs", " delay_mins", "delayacmins", "pause_mins", "delayFms", " delay_bytes", "delayFmins", "delayvalms", "delay_mb", "delay32details", "delay__ms", "delay__loads", "delayvalyrs", "pause_ms", "delayingmins"]}}
{"project": "qemu", "commit_id": "e2f89926f19d2940eda070542501f39f51a8c81f", "target": 1, "func": "int usb_packet_map(USBPacket *p, QEMUSGList *sgl)\n\n{\n\n    int is_write = (p->pid == USB_TOKEN_IN);\n\n    target_phys_addr_t len;\n\n    void *mem;\n\n    int i;\n\n\n\n    for (i = 0; i < sgl->nsg; i++) {\n\n        len = sgl->sg[i].len;\n\n        mem = cpu_physical_memory_map(sgl->sg[i].base, &len,\n\n                                      is_write);\n\n        if (!mem) {\n\n            goto err;\n\n        }\n\n        qemu_iovec_add(&p->iov, mem, len);\n\n        if (len != sgl->sg[i].len) {\n\n            goto err;\n\n        }\n\n    }\n\n    return 0;\n\n\n\nerr:\n\n    usb_packet_unmap(p);\n\n    return -1;\n\n}\n", "idx": 16211, "substitutes": {"p": ["port", "proc", "m", "po", "d", "t", "pc", "jp", "l", "a", "pre", "g", "sp", "lp", "pp", "post", "ap", "v", "patch", "ps", "o", "bp", "u", "e", "pb", "pa", "data", "b", "op", "j", "n", "f", "point", "wp", "parent", "c", "pe", "per", "pi", "q", "process", "cp", "r", "pr", "pat", "P", "tp"], "sgl": ["sgb", "pssl", "sGl", "psgl", " sbl", "chesgb", "wsdl", "fsgl", "sysGL", "ssbl", "chesgel", "sgn", "opsgl", "wsgl", "anslu", " sdl", "sysdl", " sGL", "sbl", "opsbl", " slu", "fsgb", " sgel", "wsGL", "slu", "fsgel", "sdl", "chesgl", " sGl", "slam", "ansgb", "cheslam", "fslam", "sGL", "ssgb", " splay", "sysplay", "opsdl", "ansgl", " slam", " ssl", "wsplay", "ssl", "sslu", "sgel", "ssgl", "ansbl", " sgb", " sglobal", "opsgn", "sysgl", "sglobal", " sgn", "splay", "psGl", "psglobal"], "len": ["ln", "en", "rev", "part", "lin", "non", "fl", "Len", "ni", "id", "l", "val", "lan", "lic", "lon", "split", "label", "name", " length", "lc", "fun", "low", "dl", "str", "lang", "ie", "lit", "ld", "limit", "lib", " l", "z", "ll", "size", "la", "lif", "fi", "fin", "li", "data", "pl", "base", "min", "ler", "length", "lf", "n", "f", "line", "count", "il", "lu", "afi", "gen", "ell", "cap", "le", "lex", "den", "seq", "pos", "num", "lock", "el", "bl", "del", "lim", "err"], "mem": ["device", "m", "bin", "ram", "val", "l", "memory", "mp", "me", "home", "name", "g", " Mem", "fun", "sp", "mob", "cpu", "pool", "ref", "vm", "buffer", "mm", "loc", "em", "job", "buff", "mb", "conn", "size", "la", "med", "mor", "lif", "fi", "temp", "mi", "buf", "data", "base", "f", "lf", "mo", "ann", "rm", "ip", "dem", "wa", "le", "lex", "cache", "mac", "Mem", "num", "reg", "el", "hw", "nm", "lim", "alloc"], "i": ["en", "val", "oi", "x", "si", "limit", "base", "phi", "c", "ami", "zi", "in", "index", "hi", "m", "d", "t", "xi", "id", "iu", "iv", "io", "api", "ki", "di", "u", "s", "fi", "b", "ti", "ip", "eni", "r", "bi", "el", "mu", "qi", "ni", "ini", "ci", "ie", "o", "z", "e", "info", "li", "ix", "multi", "j", "f", "err", "it", "ui", "adi", "I", "ai", "l", "gi", "ii", "uri", "v", "yi", "mi", "cli", "n", "pi", "all", "ri", "ori", "y", "abi"]}}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME(bgr24ToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_BGR24);\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        int b= src[i*3+0];\n\n        int g= src[i*3+1];\n\n        int r= src[i*3+2];\n\n\n\n        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);\n\n    }\n\n#endif /* COMPILE_TEMPLATE_MMX */\n\n}\n", "idx": 13205, "substitutes": {"dst": [" dsts", "cdsrc", "bsc", "cdsts", "Dst", "Dsts", "sconst", "bsrc", "dsts", " dsrc", "dconst", " dsc", " dconst", " drc", "lconst", "lsts", "ssts", "dsrc", "sst", "lst", "cdsc", "cdst", "dsc", "Dconst", "lrc", "drc", "bsts", "bst", "Dsrc"], "src": ["rib", "proc", "sync", "fl", "dist", "rc", "config", "cv", "enc", "tmp", "supp", "iv", "ctr", "sup", "source", "conv", "sth", "sr", "sq", "dest", "secure", "loc", "storage", "gl", "lib", "impl", "img", "rb", "pack", "buf", "http", "sb", "reflect", "flash", "inst", "scl", "gb", "url", "cb", "sn", "sc", "ssl", "rob", "cont", "transform", "sl", "text", "sur", "rect", "SOURCE", "rest", "sub", "seq", "sel", "stack", "cur", "st", "support", "ctx"], "unused": ["nonferred", "Unuse", "Unchecked", "unchecked", "nonchecked", " unferred", "unuse", "nonused", " unuse", "Unferred", "unferred", "Unused", " unchecked", "nonuse"], "i": ["hi", "qi", "it", "ui", "m", "adi", "I", "d", "t", "ai", "ni", "xi", "id", "ini", "l", "gi", "iu", "oi", "io", "api", "g", "ci", "mu", "di", "x", "si", "ie", "ii", "v", "uri", "o", "u", "z", "iii", "p", "e", "s", "fi", "info", "cli", "li", "k", "b", "ix", "multi", "j", "phi", "n", "f", "ti", "at", "ip", "c", "is", "anti", "hei", "pi", "r", "bi", "ri", "ami", "zi", "index", "start"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,\n\n                                                         PutBitContext *pb, const float *in, float *out,\n\n                                                         const float *scaled, int size, int scale_idx,\n\n                                                         int cb, const float lambda, const float uplim,\n\n                                                         int *bits, const float ROUNDING) {\n\n    int i;\n\n    if (bits)\n\n        *bits = 0;\n\n    if (out) {\n\n        for (i = 0; i < size; i += 4) {\n\n           out[i  ] = 0.0f;\n\n           out[i+1] = 0.0f;\n\n           out[i+2] = 0.0f;\n\n           out[i+3] = 0.0f;\n\n        }\n\n    }\n\n}\n", "idx": 17513, "substitutes": {"s": ["m", "session", "settings", "services", "service", "r", "sb", "ss", "ops", "cs", "bis", "sac", "sc", "ssl", "e", "fts", "ses", "c", "ps", "p", "b", "params", "sys", "os", "sets", "sq", "sa", "sf"], "pb": ["pc", "wp", "ab", "fp", "vp", "pd", "pl", "pm", "sb", "bp", "cpp", "cp", "bc", "lp", "PC", "wb", "abc", "PB", " p", "bps", "pa", "bh", "fb", "rb", "p", "ppa", "proc", "ub"], "in": ["m", "bin", "IN", "data", "x", "f", "image", "ref", "r", "inc", "query", "In", "min", "d", "inf", "ins", "id", "c", "p", "a", "inner", "source", "input"], "out": ["at", "part", "m", "point", "group", "work", "extra", "init", "data", "name", "image", "err", "bit", "call", "plus", "scroll", "r", "io", "inc", "result", "option", "Out", "query", "block", "raw", "pass", "index", "timeout", "password", "copy", "object", "o", "again", "flat", "array", "up", "new", "outs", "no", "hidden", "w", "prefix", "sync", "only", "update", "parent", "post", "p", "binary", "line", "off", "OUT", "b", "cache", "output", "error", "check", "project", "into", "word", "one", "inner", "source", "params", "outer", "wave"], "scaled": ["scased", " scaling", "shaling", "scitched", "escitched", "shaled", "escaling", "escased", "shased", "escaled", " scased", "shitched", " scitched", "scaling"], "size": ["scale", "shape", "code", "small", "mode", "SIZE", "name", "capacity", "time", "cm", "six", "loc", "resolution", "sec", "large", "ize", "sc", "c", "unit", "si", "crop", "shift", "address", "norm", "weight", "Size", "len"], "scale_idx": ["scale_indxs", "scale_ridx", "scale_indx", "scale_Idxs", "scale_Idg", "scale_Idr", "scale_idg", "scale_ridg", "scale_Idx", "scale_idr", "scale_indr", "scale_indg", "scale_idxs", "scale_ridr", "scale_ridxs"], "cb": ["dc", "code", "core", "ctr", "ref", "buffer", "rc", "confirmed", "cf", "bc", "quad", "bb", "nb", " bc", "cond", "nc", "bf", "blocks", "batch", "cl", "b", "fn", "cd", "loop", "repeat", "callback", "CB", "circ", "cc"], "lambda": ["LA", "dc", "func", "fun", "phi", "lu", "mega", "phase", "function", "abc", "appa", "std", "partial", "cl", "lam", "inv", "da", "shift", "pad", "la", " lam", "wa", "beta", "pha", "alpha", " omega", "mu"], "uplim": ["Uplime", "uselime", "uflims", "Uflime", "uplig", "Uplim", "Uflig", "uselims", "uclig", "uclims", "uplime", "uflig", "Uflims", "uflime", "uselim", "Uflim", "uplims", "uselig", "Uplims", "uflim", "uclime", "uclim", "Uplig"], "bits": ["ns", "bugs", "cycles", "planes", "fps", "bs", "pieces", "jobs", "bit", "settings", "weights", "plugins", "dates", "details", "forces", "ips", "ints", "ops", "pos", "offs", "ins", "outs", "gets", "features", "blocks", "bis", "codes", "pins", "batch", "frames", "steps", "acts", "bands", "rows", "b", "hours", "lins", "its", "reads", "bytes", "parts", "groups", "flags", "locks"], "ROUNDING": ["RANGED", "WRECTING", "RANGLESS", "RRECTLESS", "RRECTATING", "RoundingING", "WOUNDLESS", "ROUNDED", "ROUNDATING", "RoundingED", "WOUNDING", "RoundingLESS", "ROUNDLESS", "RANGATING", "RRECTED", "RANGING", "RRECTING", "WRECTATING", "WRECTED", "WRECTLESS", "WOUNDED", "RoundingATING", "WOUNDATING"], "i": ["gi", "ti", "at", "uri", "bi", "iii", "init", "j", "t", "data", "info", "x", "f", "base", "ix", "ini", "qi", "io", "ai", "n", "phi", "ii", "ie", "di", "slice", "ind", "pass", "I", "zi", "is", "o", "ip", "l", "d", "oi", "diff", "pi", "uni", "ui", "ci", "abi", "last", "id", "e", "cli", "v", "c", "ni", "si", "temp", "p", "xi", "b", "uli", "interface", "a", "api", "list", "it", "fi", "inner", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "rdt_free_extradata (PayloadContext *rdt)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MAX_STREAMS; i++)\n\n        if (rdt->rmst[i]) {\n\n            ff_rm_free_rmstream(rdt->rmst[i]);\n\n            av_freep(&rdt->rmst[i]);\n\n        }\n\n    if (rdt->rmctx)\n\n        av_close_input_stream(rdt->rmctx);\n\n    av_freep(&rdt->mlti_data);\n\n    av_free(rdt);\n\n}\n", "idx": 17678, "substitutes": {"i": ["ti", "gi", "uri", "part", "m", "bi", "j", "t", "info", "x", "f", "ix", "ini", "qi", "io", "ai", "mi", "n", "hi", "z", "ii", "ie", "in", "di", "index", "iu", "I", "multi", "zi", "o", "ip", "l", "d", "oi", "yi", "diff", "pi", "ui", "ci", "id", "start", "e", "k", "v", "c", "si", "ri", "p", "xi", "b", "mu", "a", "fi", "y", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "5b0ad91b996506632708dcefc22d2835d04a4dba", "target": 1, "func": "static int img_write_packet(AVFormatContext *s, int stream_index,\n\n                            UINT8 *buf, int size)\n\n{\n\n    VideoData *img = s->priv_data;\n\n    AVStream *st = s->streams[stream_index];\n\n    ByteIOContext pb1, *pb;\n\n    AVPicture picture;\n\n    int width, height, ret, size1;\n\n    char filename[1024];\n\n\n\n    width = st->codec.width;\n\n    height = st->codec.height;\n\n\n\n    switch(st->codec.pix_fmt) {\n\n    case PIX_FMT_YUV420P:\n\n        size1 = (width * height * 3) / 2;\n\n        if (size != size1)\n\n            return -EIO;\n\n        \n\n        picture.data[0] = buf;\n\n        picture.data[1] = picture.data[0] + width * height;\n\n        picture.data[2] = picture.data[1] + (width * height) / 4;\n\n        picture.linesize[0] = width;\n\n        picture.linesize[1] = width >> 1; \n\n        picture.linesize[2] = width >> 1;\n\n        break;\n\n    case PIX_FMT_RGB24:\n\n        size1 = (width * height * 3);\n\n        if (size != size1)\n\n            return -EIO;\n\n        picture.data[0] = buf;\n\n        picture.linesize[0] = width * 3;\n\n        break;\n\n    default:\n\n        return -EIO;\n\n    }\n\n    \n\n    if (get_frame_filename(filename, sizeof(filename), \n\n                           img->path, img->img_number) < 0)\n\n        return -EIO;\n\n\n\n    if (!img->is_pipe) {\n\n        pb = &pb1;\n\n        if (url_fopen(pb, filename, URL_WRONLY) < 0)\n\n            return -EIO;\n\n    } else {\n\n        pb = &s->pb;\n\n    }\n\n    switch(img->img_fmt) {\n\n    case IMGFMT_PGMYUV:\n\n        ret = pgm_save(&picture, width, height, pb, 1);\n\n        break;\n\n    case IMGFMT_PGM:\n\n        ret = pgm_save(&picture, width, height, pb, 0);\n\n        break;\n\n    case IMGFMT_YUV:\n\n        ret = yuv_save(&picture, width, height, filename);\n\n        break;\n\n    case IMGFMT_PPM:\n\n        ret = ppm_save(&picture, width, height, pb);\n\n        break;\n\n    }\n\n    if (!img->is_pipe) {\n\n        url_fclose(pb);\n\n    }\n\n\n\n    img->img_number++;\n\n    return 0;\n\n}\n", "idx": 9842, "substitutes": {"s": ["session", "sg", "ts", "sv", "ds", "si", "g", "sf", "m", "src", "http", "t", "b", "sci", "gs", "service", "c", "serv", "sam", "p", "ls", "sa", "se", "xs", "sq", "f", "op", "cs", "sym", "v", "S", "space", "sie", "sl", "services", "r", "ns", "sb", "storage", "spec", "summary", "self", "api", "ses", "fs", "su", "ps", "a", "ss", "sr", "ssl", "sc"], "stream_index": ["stream_design", "feed_pointer", "streamsindex", "stream_pointer", "stream_Index", " stream_design", "stream_num", "feed_index", "streamernum", "streamsdesign", "streamsIndex", "stream__Index", "feed_Index", "feed_num", "streamerIndex", "streamerpointer", "stream__index", "streamerindex", "stream__pointer", " stream_Index", "stream__num"], "buf": ["uf", "seq", "Buffer", "prefix", "pad", "src", "fd", "b", "wb", "mem", "data", "fb", "batch", "config", "dest", "cb", "fp", "queue", "rb", "loc", "tmp", "bc", "padding", "foo", "pkg", "alloc", "cv", "msg", "rc", "home", "ctx", "desc", "border", "func", "vec", "buff", "cmd", "text", "feat", "bin", "buffer", "box", "uc"], "size": ["count", "area", "scale", "si", "len", "g", "capacity", "source", "speed", "small", "z", "SIZE", "data", "style", "loc", "Size", "sec", "large", "body", "code", "unit", "shape", "cap", "name", "rc", "content", "align", "sn", "desc", "storage", "offset", "enc", "crop", "video", "length", " sizes", "image", "ize", "weight", "buffer"], "img": ["ani", "imag", "movie", "gd", "html", "gif", "ext", "upload", "dom", "media", "info", "src", "iv", "fi", "i", "data", "big", "fb", "config", "p", "obj", "cb", "gb", "plug", "tmp", "f", "ie", "inst", "bl", "bg", "amp", "og", "embed", "input", "rc", "iframe", "jpg", "pic", "im", "audio", "eng", "fig", "icon", "enc", "emb", "cm", "aug", "ng", "url", "image", "pict", "br", "imp"], "st": ["stan", "sp", "sh", "gd", "std", "ds", "str", "si", "stage", "nt", "fr", "src", "rest", "stat", "d", "steam", "sa", "ct", "sam", "obj", "se", "ost", "pt", "ut", "inst", "rt", "cv", "nd", "sts", "sta", "sl", "sm", "sn", "sth", "ste", "sb", "sty", "storage", "sd", "ast", "St", "sim", "ST", "ft", "ss", "td", "fe", "sc"], "pb1": ["refone", "ref4", "p2", "bufone", "PB1", "buf2", "buf4", "db4", "PB4", "buf1", "ref1", "PB3", "db2", "db1", "db3", "ref2", "p1", "PBone", "p3", "pb2", "pbone", "pb3", "PB2", "p4", "pb4"], "pb": ["lp", "dp", "uf", "ib", "bb", "ppa", "pg", "nb", "wp", "bp", "lab", "pl", "prot", "bm", "b", "ab", "bs", "pa", "pp", "wb", "bridge", "cp", "python", "fb", "p", "obj", "cb", "fp", "np", "gb", "pt", "pm", "rb", "cod", "tmp", "bc", "dl", "profile", "bf", "mp", "db", "eb", "bl", "cv", "bps", "bh", "phrase", "pr", "ctx", "lb", "bot", "jp", "sb", "pc", "PB", "avi", "summary", "plugin", "platform", "api", "fc", "ob", "rob", "pkg", "typ", "vp"], "picture": ["media", "imgur", "history", "fb", "config", "uri", "cb", "package", "pixel", "profile", "pic", "study", "widget", "import", "image", "definition", "buffer", "fi", "phot", "wikipedia", "ami", "gui", "large", "slice", "bi", "avi", "storage", "error", "fine", "plugin", "li", "file", "lc", "pict", "bank", "family", "statement", "password", "game", "piece", "photos", "gallery", "data", "cli", "fp", "brush", "mini", "style", "ana", "entry", "query", "feature", "jp", "movie", "imi", "kl", "man", "library", "character", "detail", "gif", "comment", "info", "money", "service", "username", "obj", "manager", "guide", "Picture", "photo", "fat", "ctx", "audio", "summary", "api", "video", "io", "feat", "database"], "height": ["center", "pad", "gpu", "history", "max", "dist", "grow", "lat", "high", "device", "stroke", "duration", "crop", "volume", "image", "three", "definition", "buffer", "depth", "windows", "rank", "dim", "upload", "view", "w", "id", "total", "resolution", "paste", "density", "layout", "padding", "slice", "input", "wall", "ty", "margin", "above", "huge", "gap", "location", "std", "bottom", "data", "gain", "head", "style", "flow", "Height", "png", "shape", "shr", "dark", "kw", "tight", "command", "weight", "through", "level", "rows", "window", "third", "time", "gold", "quality", "gh", "square", "hold", "deep", "ctx", "pull", "h", "length", "arrow", "y", "feat", "direction"], "ret": ["count", "pass", "std", "flag", "str", "ext", "len", "val", "alt", "def", "temp", "nt", "id", "Ret", "mem", "reply", "rl", "ref", "arg", "lit", "output", "status", "split", "final", "gt", "rets", "ut", "rt", "res", "det", "rc", "content", "att", "full", "part", "bit", "re", "cat", "RET", "back", "url", "result", "bin", "ft", "flat", "feat", "match", "let", "pet"], "size1": [" sizeOne", "shapeOne", " size3", "width4", "size3", "size01", "size2", " sizeone", "width1", "Size2", "SIZE4", "widthone", "sizeOne", "Size1", "size4", "iz1", "Sizeone", "shape2", "SIZEone", " size0", " size2", "size0", "any3", "any1", "widthPre", "shape0", "sizeone", " size4", "SIZE1", "ize0", "Size0", "ize1", "iz2", "izPre", " sizePre", "shape3", "width2", "sizePre", "shapeone", "shape1", " size01", "anyOne", "width01", "iz01"], "filename": ["l", "fil", "seq", "byte", "original", "location", "wp", "il", "n", "tif", "prefix", "word", "src", "fd", "files", "b", "path", "login", "data", "fb", "config", "uri", "username", "p", "utf", "fp", "txt", "loc", "Filename", "title", "f", "nm", "binary", "png", "slice", "shape", "nil", "name", "content", "phrase", "jpg", "document", "dll", "bytes", "root", "fn", "file", "out", "image", "length", "url", "directory", "family", "buffer", "ssl", "kl"], "img_number": ["img_header", "imgnumindex", "imgblocknum", "img_index", "image_num", "imgblockheader", "image_index", "img_num", "imgnumnum", "imgblocknumber", "image_header", "imgblockindex", "imgnumheader", "image_number", "imgnumnumber"]}}
{"project": "FFmpeg", "commit_id": "86ab6b6e08e2982fb5785e0691c0a7e289339ffb", "target": 0, "func": "static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)\n\n{\n\n    int t = rc->range * (uint64_t)cumFreq / total_freq;\n\n\n\n    rc->code1 += t + 1;\n\n    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);\n\n\n\n    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {\n\n        unsigned byte = bytestream2_get_byte(gb);\n\n        rc->code = (rc->code << 8) | byte;\n\n        rc->code1 <<= 8;\n\n        rc->range <<= 8;\n\n    }\n\n}\n", "idx": 5457, "substitutes": {"gb": ["gc", "anc", "lb", "hub", "ci", "rb", "bg", "cca", "sync", "bm", "db", "wb", "ga", "usb", "gin", "pc", "gz", "bb", "eb", "sc", "mc", "sb", "gs", "rg", "binary", "storage", "ctx", "bc", "GB", "cb", "gy", "kb", "ub", "bf", "gd", "lc", "gram", "fc", "gg", "vc", "kr", "src", "cd", "ui"], "rc": ["abc", "rn", "dr", "rw", "irc", "anc", "cr", "sr", "rt", "cur", "rr", "roc", "ci", "rb", "config", "nc", "cca", "sync", "auc", "sys", "co", "uc", "loc", "rog", "inc", "ru", "attr", "uci", "ra", "pc", "ack", "cc", "cs", "ck", "sc", "rect", "rg", "inst", "dc", "hl", "ctx", "rx", "bc", "instance", "rl", "ic", "rin", "ec", "usr", "c", "gd", "lc", "asc", "gg", "fc", "ac", "vc", "src", "rs", "rank", "r", "RC", "rec", "isc", "xc"], "cumFreq": [" cumfreue", "cumLeue", "cumFrerequency", "cumFirequency", " cumfreq", "cumLeq", "cumStraference", " cumFreQ", " cumfrequality", "cumStraq", " cumFreference", "cumFreeq", " cumfreqs", "cumLeqs", " cumfreQ", " cumFreqs", " cumFiqs", " cumFirequency", " cumFrerequency", "cumFiqs", "cumFreeqs", "cumFiq", "cumFiference", " cumFrequality", "cumfreq", "cumfrequality", "cumFference", "cumLeQ", "cumFrequency", "cumFrequality", "cumFreequality", "cumFreqs", "cumFreference", " cumFiference", "cumFq", "cumFreeQ", "cumfreqs", "cumfreQ", "cumStrarequency", "cumfreue", " cumFiq", "cumFreue", " cumFreue", "cumFreQ", "cumFqs", "cumStraqs"], "freq": ["luquality", " freQ", "frqs", "freeq", "Frequality", "frquality", "luq", "freece", "faQ", "faquality", "frQ", " frece", "frequality", "Freq", "freequality", "Frece", " frequality", "luQ", "frq", "FreQ", "faq", "faqs", "freeQ", "freQ", "luqs", "frece", "freqs"], "total_freq": ["total_latux", "total_compue", "total_Freance", "total_freeance", "total_Freqs", "total_latf", "total_Freence", "total_freence", "total_freeqs", "total_compq", "total_latq", "total_Frequality", "total_freance", "total_fref", "total_compqs", "total_perf", "total_freux", "total_perq", "total_freeue", "total_freeence", "total_perance", "total_latance", "total_freue", "total_Freue", "total_freeq", "total_freqs", "total_Freq", "total_perux", "total_frequality", "total_freequality", "total_compquality"]}}
{"project": "FFmpeg", "commit_id": "659d4ba5af5d72716ee370bb367c741bd15e75b4", "target": 0, "func": "static void h263_h_loop_filter_mmx(uint8_t *src, int stride, int qscale)\n\n{\n\n    if (CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {\n\n        const int strength = ff_h263_loop_filter_strength[qscale];\n\n        DECLARE_ALIGNED(8, uint64_t, temp)[4];\n\n        uint8_t *btemp = (uint8_t*)temp;\n\n\n\n        src -= 2;\n\n\n\n        transpose4x4(btemp,     src,              8, stride);\n\n        transpose4x4(btemp + 4, src + 4 * stride, 8, stride);\n\n        __asm__ volatile (\n\n            H263_LOOP_FILTER // 5 3 4 6\n\n\n\n            : \"+m\"(temp[0]),\n\n              \"+m\"(temp[1]),\n\n              \"+m\"(temp[2]),\n\n              \"+m\"(temp[3])\n\n            : \"g\"(2 * strength), \"m\"(ff_pb_FC)\n\n            );\n\n\n\n        __asm__ volatile (\n\n            \"movq      %%mm5, %%mm1         \\n\\t\"\n\n            \"movq      %%mm4, %%mm0         \\n\\t\"\n\n            \"punpcklbw %%mm3, %%mm5         \\n\\t\"\n\n            \"punpcklbw %%mm6, %%mm4         \\n\\t\"\n\n            \"punpckhbw %%mm3, %%mm1         \\n\\t\"\n\n            \"punpckhbw %%mm6, %%mm0         \\n\\t\"\n\n            \"movq      %%mm5, %%mm3         \\n\\t\"\n\n            \"movq      %%mm1, %%mm6         \\n\\t\"\n\n            \"punpcklwd %%mm4, %%mm5         \\n\\t\"\n\n            \"punpcklwd %%mm0, %%mm1         \\n\\t\"\n\n            \"punpckhwd %%mm4, %%mm3         \\n\\t\"\n\n            \"punpckhwd %%mm0, %%mm6         \\n\\t\"\n\n            \"movd      %%mm5, (%0)          \\n\\t\"\n\n            \"punpckhdq %%mm5, %%mm5         \\n\\t\"\n\n            \"movd      %%mm5, (%0, %2)      \\n\\t\"\n\n            \"movd      %%mm3, (%0, %2, 2)   \\n\\t\"\n\n            \"punpckhdq %%mm3, %%mm3         \\n\\t\"\n\n            \"movd      %%mm3, (%0, %3)      \\n\\t\"\n\n            \"movd      %%mm1, (%1)          \\n\\t\"\n\n            \"punpckhdq %%mm1, %%mm1         \\n\\t\"\n\n            \"movd      %%mm1, (%1, %2)      \\n\\t\"\n\n            \"movd      %%mm6, (%1, %2, 2)   \\n\\t\"\n\n            \"punpckhdq %%mm6, %%mm6         \\n\\t\"\n\n            \"movd      %%mm6, (%1, %3)      \\n\\t\"\n\n            :: \"r\"(src),\n\n               \"r\"(src + 4 * stride),\n\n               \"r\"((x86_reg)stride),\n\n               \"r\"((x86_reg)(3 * stride))\n\n            );\n\n    }\n\n}\n", "idx": 15804, "substitutes": {"src": ["rib", "bc", "dist", "inf", "supp", "shape", "low", "loc", "ind", "temp", "rb", "spec", "c", "cb", "text", "sc", "transform", "attr", "sl", "sur", "fc", "bis", "slice", "sync", "rc", "seed", "iv", "ctr", "sup", "req", "lower", "conv", "sr", "grad", "img", "s", "data", "b", "length", "inst", "url", "r", "ptr", "gz", "config", "source", "ie", "lit", "secure", "sec", "comp", "gb", "chrom", "sel", "cur", "RC", "input", "tmp", "shift", "stream", "send", "dest", "gl", "buf", "bg", "ssl", "scale", "seq", "start"], "stride": ["strid", "trade", " strine", "strision", "Strine", "strider", "dride", " strid", "striding", "chider", "stides", "Stride", "stided", "staid", "trided", "Strider", "Strade", "spide", "staide", "stidi", "chidi", "strided", " strate", "drision", "spade", "staider", "octide", "briding", "staided", "StrIDE", " strider", "trIDE", "strade", "Strides", "stine", "spides", "spided", "Stridi", "bride", "Strided", "state", "octides", " strides", " stridi", " strIDE", "strIDE", "octided", "slide", "brides", "strides", "slides", "Strid", "drides", "slision", "brision", "sliding", "octate", "chide", "stridi", "trides", "strate", "chided", "tride", "driding", "stide", " strided", "strine"], "qscale": ["qgrade", "dqseed", "qseed", "qtile", " qgrade", "qtscale", " qslice", "eqseed", "qslice", "dqtile", "Qslice", "dqscale", "eqtile", "qtslice", "Qscale", "qtgrade", "Qseed", "qrate", "eqrate", "Qgrade", "dqrate", "Qtile", "Qrate", "eqscale"], "btemp": ["ntmp", "sbtem", "bflat", "sbtmp", "pfont", "ntem", "rtemp", "ptx", "bfont", "Btem", "sbfont", "rtem", "sbtemp", "btx", "ntemp", "bTemp", "lbtmp", "lbfont", "lbtemp", "rflat", " bflat", "btem", "ptemp", "mtem", "sbtx", "sbflat", "btmp", "Bflat", "Btemp", "ptmp", "rtmp", "mflat", "nflat", " btem", "BTemp", "lbtx", "mTemp", "mtemp", " bTemp"], "H263_LOOP_FILTER": ["H263_LOOP_FLTER", "H263_LOOP_ILTE", "H263_LOOP_FLER", "H263_LOOP_FILER", "H263_LOOP_ILTER", "H263_LOOP_AFTER", "H263_LOOP_FLTE", "H263_LOOP_FLVER", "H263_LOOP_ILER", "H263_LOOP_AFER", "H263_LOOP_AFVER", "H263_LOOP_AFTE", "H263_LOOP_FILVER", "H263_LOOP_ILVER", "H263_LOOP_FILTE"], "m": ["mc", "cm", "d", "t", "l", "i", "imm", "a", "fm", "g", "h", "x", "vm", "ym", "v", "tm", "o", "w", "ms", "gm", "mt", "u", "p", "e", "s", "bm", "mi", "b", "j", "n", "f", "c", "pm", "M", "im", "r", "y", "sm", "mu"]}}
{"project": "qemu", "commit_id": "9fbf4a58c90183b30bb2c8ad971ccce7e6716a16", "target": 1, "func": "static int get_physical_address (CPUMIPSState *env, hwaddr *physical,\n\n                                int *prot, target_ulong real_address,\n\n                                int rw, int access_type)\n\n{\n\n    /* User mode can only access useg/xuseg */\n\n    int user_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_UM;\n\n    int supervisor_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_SM;\n\n    int kernel_mode = !user_mode && !supervisor_mode;\n\n#if defined(TARGET_MIPS64)\n\n    int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;\n\n    int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;\n\n    int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;\n\n#endif\n\n    int ret = TLBRET_MATCH;\n\n    /* effective address (modified for KVM T&E kernel segments) */\n\n    target_ulong address = real_address;\n\n\n\n#define USEG_LIMIT      0x7FFFFFFFUL\n\n#define KSEG0_BASE      0x80000000UL\n\n#define KSEG1_BASE      0xA0000000UL\n\n#define KSEG2_BASE      0xC0000000UL\n\n#define KSEG3_BASE      0xE0000000UL\n\n\n\n#define KVM_KSEG0_BASE  0x40000000UL\n\n#define KVM_KSEG2_BASE  0x60000000UL\n\n\n\n    if (kvm_enabled()) {\n\n        /* KVM T&E adds guest kernel segments in useg */\n\n        if (real_address >= KVM_KSEG0_BASE) {\n\n            if (real_address < KVM_KSEG2_BASE) {\n\n                /* kseg0 */\n\n                address += KSEG0_BASE - KVM_KSEG0_BASE;\n\n            } else if (real_address <= USEG_LIMIT) {\n\n                /* kseg2/3 */\n\n                address += KSEG2_BASE - KVM_KSEG2_BASE;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (address <= USEG_LIMIT) {\n\n        /* useg */\n\n        if (env->CP0_Status & (1 << CP0St_ERL)) {\n\n            *physical = address & 0xFFFFFFFF;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        }\n\n#if defined(TARGET_MIPS64)\n\n    } else if (address < 0x4000000000000000ULL) {\n\n        /* xuseg */\n\n        if (UX && address <= (0x3FFFFFFFFFFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0x8000000000000000ULL) {\n\n        /* xsseg */\n\n        if ((supervisor_mode || kernel_mode) &&\n\n            SX && address <= (0x7FFFFFFFFFFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0xC000000000000000ULL) {\n\n        /* xkphys */\n\n        if (kernel_mode && KX &&\n\n            (address & 0x07FFFFFFFFFFFFFFULL) <= env->PAMask) {\n\n            *physical = address & env->PAMask;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0xFFFFFFFF80000000ULL) {\n\n        /* xkseg */\n\n        if (kernel_mode && KX &&\n\n            address <= (0xFFFFFFFF7FFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n#endif\n\n    } else if (address < (int32_t)KSEG1_BASE) {\n\n        /* kseg0 */\n\n        if (kernel_mode) {\n\n            *physical = address - (int32_t)KSEG0_BASE;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < (int32_t)KSEG2_BASE) {\n\n        /* kseg1 */\n\n        if (kernel_mode) {\n\n            *physical = address - (int32_t)KSEG1_BASE;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < (int32_t)KSEG3_BASE) {\n\n        /* sseg (kseg2) */\n\n        if (supervisor_mode || kernel_mode) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else {\n\n        /* kseg3 */\n\n        /* XXX: debug segment is not emulated */\n\n        if (kernel_mode) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 19431, "substitutes": {"env": ["viron", "txt", "db", "session", "code", "global", "cdn", "core", "conf", "esp", "cal", "net", "eu", "ne", "engine", "exc", "cf", "enter", "ou", " environment", "np", "oa", "environment", "ext", "dt", "ctx", "console", "en", "lv", "eng", "her", "enc", "vm", "exec", "pg", "context", "profile", "event", "nc", "args", "site", "Environment", "iss", "ev", "config", "serv", "e", "qt", "v", "inv", "ea", "dev", "osc", "que", "dat", "ec", "et", "ef", "eni", "server", "el", "dict", "conn"], "physical": ["native", "Physical", "phys", "direct", "al", "present", "pixel", "smart", "reference", "ipt", "relative", "protected", "console", "regular", "virtual", "pointer", "ip", "host", "linux", "memory", "network", "prefix", "config", "remote", "primary", "hard", "binary", "address", "secondary", "external", "http", "resource", "intel", "digital", "serial", "local", "port", "specified", "target"], "prot": ["status", "ret", "stat", "phys", "txt", "ocol", "platform", "eth", "mult", "ext", "protected", "phy", "ptr", "normal", "def", "en", "multi", "pos", "prop", "istor", "att", "inet", "format", "reset", "rot", "prefix", "config", "primary", "cl", "selected", "secondary", "binary", "test", "proc", "opt", "pro", "Prot", "port", "server", "transfer", "typ"], "real_address": [" real_addr", "physical_number", "realmemslave", "real_number", "realxaddress", "realerentry", "realmemaddr", "realipnumber", "true_entry", "realxaddr", "trueerlocation", "real67address", "virtual_add", "trueeraddress", "realipaddress", "real67entry", "real_add", "realamslave", "true_location", "virtual_addr", "real_location", "trueeraddr", "real_image", "trueerentry", "physical_address", "realipcondition", "real_slave", "physical_condition", "realeraddress", "virtual_entry", "real67image", "real67addr", "realeraddr", "realximage", "real_entry", " real_name", "realxentry", " real_number", "realmemaddress", "virtual_address", "physical_message", "realamadd", "realamaddress", "true_address", "real_name", "realipmessage", "true_addr", "realmemadd", "virtual_image", "virtual_slave", "real_condition", "realamaddr", "real_message", "real_addr", "realerlocation"], "rw": ["rx", "pattern", "fp", "RW", "pn", "r", "ro", "worker", "sw", "rf", "password", "ww", "ffff", "w", "rot", "prefix", "rb", "slave", "vt", "wh", "proc", "ty", "nn"], "access_type": ["accessvaltype", "accesstypetable", "connection_group", "accessvalgroup", "accessvaltypes", "connection_table", "connection_types", "accesstypetypes", "connection_type", "accesstypegroup", "accesstypetype", "access_table", "connectionvaltable", "access_group", "connectionvalgroup", "access_types", "accessvaltable", "connectionvaltype", "connectionvaltypes"]}}
{"project": "qemu", "commit_id": "12d69ac03b45156356b240424623719f15d8143e", "target": 0, "func": "static void test_source_wait_event_notifier(void)\n\n{\n\n    EventNotifierTestData data = { .n = 0, .active = 1 };\n\n    event_notifier_init(&data.e, false);\n\n    aio_set_event_notifier(ctx, &data.e, event_ready_cb);\n\n    g_assert(g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 0);\n\n    g_assert_cmpint(data.active, ==, 1);\n\n\n\n    event_notifier_set(&data.e);\n\n    g_assert(g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    while (g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    aio_set_event_notifier(ctx, &data.e, NULL);\n\n    while (g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n\n\n    event_notifier_cleanup(&data.e);\n\n}\n", "idx": 7761, "substitutes": {}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)\n\n{\n\n    f->xfer_limit = limit;\n\n}\n", "idx": 18326, "substitutes": {"f": ["m", "fr", "fw", "ff", "j", "t", "fp", "ref", "fe", "file", "n", "feed", "i", "fs", "rf", "o", "lf", "fo", "l", "fx", "d", "df", "inf", "bf", "w", "fd", "e", "fb", "v", "c", "F", "p", "fm", "tf", "h", "ef", "aff", "sf"], "limit": ["limits", "offset", "skip", "lim", "base", "image", "buffer", "io", "limited", "file", "i", "type", "match", "lp", "index", "timeout", "ip", "page", "l", "inf", "format", "size", "path", "length", "policy", "id", "unit", "position", "include", "url", "lock", "rate", "filter", "cache", "route", "Limit", "len", "iter", "source", "target", "pin"]}}
{"project": "qemu", "commit_id": "a718978ed58abc1ad92567a9c17525136be02a71", "target": 1, "func": "static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)\n\n{\n\n    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);\n\n    IDEState *s = bmdma_active_if(bm);\n\n    PCIDevice *pci_dev = PCI_DEVICE(bm->pci_dev);\n\n    struct {\n\n        uint32_t addr;\n\n        uint32_t size;\n\n    } prd;\n\n    int l, len;\n\n\n\n    pci_dma_sglist_init(&s->sg, pci_dev,\n\n                        s->nsector / (BMDMA_PAGE_SIZE / 512) + 1);\n\n    s->io_buffer_size = 0;\n\n    for(;;) {\n\n        if (bm->cur_prd_len == 0) {\n\n            /* end of table (with a fail safe of one page) */\n\n            if (bm->cur_prd_last ||\n\n                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {\n\n                return s->io_buffer_size;\n\n            }\n\n            pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);\n\n            bm->cur_addr += 8;\n\n            prd.addr = le32_to_cpu(prd.addr);\n\n            prd.size = le32_to_cpu(prd.size);\n\n            len = prd.size & 0xfffe;\n\n            if (len == 0)\n\n                len = 0x10000;\n\n            bm->cur_prd_len = len;\n\n            bm->cur_prd_addr = prd.addr;\n\n            bm->cur_prd_last = (prd.size & 0x80000000);\n\n        }\n\n        l = bm->cur_prd_len;\n\n        if (l > 0) {\n\n            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);\n\n\n\n            /* Note: We limit the max transfer to be 2GiB.\n\n             * This should accommodate the largest ATA transaction\n\n             * for LBA48 (65,536 sectors) and 32K sector sizes. */\n\n            if (s->sg.size > INT32_MAX) {\n\n                error_report(\"IDE: sglist describes more than 2GiB.\");\n\n                break;\n\n            }\n\n            bm->cur_prd_addr += l;\n\n            bm->cur_prd_len -= l;\n\n            s->io_buffer_size += l;\n\n        }\n\n    }\n\n\n\n    qemu_sglist_destroy(&s->sg);\n\n    s->io_buffer_size = 0;\n\n    return -1;\n\n}\n", "idx": 3970, "substitutes": {"dma": ["Dda", "mdma", "mdla", "mwa", "mma", " dwa", "bMA", "bma", " dta", "mdwa", "mdMA", "dwa", "Dwa", "mMA", "dta", "Dmm", " dMA", " dda", "dmm", "bta", " dmm", "ldla", "dMA", "mmp", " dmp", "dda", "ldma", "ldMA", "DMA", "bmp", "ldwa", "mmm", "Dma", "dmp", "dla", "Dla", "mta", "mda"], "is_write": ["is_read", "id_writ", "id_mode", "id_write", "is_writ", "id_read", "is_mode"], "bm": ["cm", "base", "vm", "dn", "bh", "bn", "em", "bo", "mc", "sb", "lb", "binary", "fl", "bc", "BM", "mi", "bin", "im", "pb", "mm", "bl", "umi", "y", "lim", "m", "gm", "cb", "sbm", "md", "om", "bf", "gs", "hm", "p", "bi", "nb", "dm", "ym", "bd", "ram", "cache", "wm", "rm", "gb", "rem", "bt", "pm", "obj", "bg", "fm", "bb", "mr", "tm", "nm", "sm", "b", "bp", "module", "bs", "an", "cfg", "am", "gp", "db"], "s": ["sg", "js", "service", "so", "cs", "ss", "rs", "sa", "spec", "ts", "sb", "ings", "qs", "r", "d", "is", "ins", "sl", "ions", "ms", "y", "sis", "g", "m", "ses", "ls", "sync", "ys", "sv", "storage", "ds", "sets", "ps", "gs", "ns", "c", "p", "state", "services", "e", "w", "f", "es", "secondary", "sys", "sq", "conf", "set", "sn", "sr", "o", "stats", "b", "su", "S", "os", "session", "serv", "sim", "t", "bs", "an", "its", "hs", "states", "se", "fs", "si", "sym", "ssl"], "pci_dev": ["pcm_device", "pci__addr", "pdi_div", "pciMdevice", "pci__mode", "pci2div", "pcm_div", "pci2device", "pci__device", "pci_priv", "pci_device", "pci2conn", "pci_addr", "pciMmode", "pciMdiv", "pdi_mode", "pci__dev", "pdi_priv", "pcm_dev", "pdi_device", "pcm_conn", "pci2dev", "pci_div", "pciMdev", "pci_conn", "pdi_dev", "pci2priv", "pci_mode", "pdi_addr"], "prd": ["frdd", " prcd", "sprdm", " prdh", "sprb", " prdt", "perd", "yrdd", "frd", " prt", "prb", "rd", "prs", "rt", " prn", "prr", "erdh", "perr", "parb", "sprdd", "privd", "Prd", "sprd", "parcd", "Prds", "erds", " prb", "sprs", "erd", "prcd", "prdh", "ptrds", " prs", "privs", "sprcd", "perb", "frn", "pert", "ird", "Prdh", "prdm", "ptrn", "sprdy", "trd", "ern", "prdy", " prr", "trds", "rr", " prdd", "pern", "frds", "prt", "ptrs", "prds", "privdt", "pard", "yrd", "irdy", "ptrdy", " prdy", "trs", "prdt", "privds", "ptrdm", "perdy", "ptrb", " prds", "yrds", "sprds", " prdm", "ptrd", "rb", "Prn", "parn", "irs", "prn", "yrb", "trdt", "prdd", "sprn", "irds"], "l": ["ell", "ld", "li", "ol", "jl", "ul", "lp", "lb", "vl", "r", "d", "n", "dl", "lu", "ln", "fl", "lf", "sl", "nl", "i", "j", "m", "ls", "ll", "z", "tl", "c", "p", "L", "e", "lc", "f", "length", "kl", "rl", "El", "u", "la", "el", "il", "en", "o", "v", "b", "lin", "lit", "le"], "len": ["base", "ell", "ld", "li", "lan", "ol", "lp", "elt", "ni", "Len", "url", "loc", "n", "lf", "lu", "ln", "fl", "sl", "dl", "bl", "j", "lim", "pos", "dy", "ll", "lt", "err", "rev", "z", "lon", "L", "ler", "lc", "length", "kl", "f", "size", "la", "el", "il", "en", "v", "hl", "lib", "lin", "full", "line", "low", "val", "count", "limit", "le"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void disas_xtensa_insn(CPUXtensaState *env, DisasContext *dc)\n\n{\n\n#define HAS_OPTION_BITS(opt) do { \\\n\n        if (!option_bits_enabled(dc, opt)) { \\\n\n            qemu_log(\"Option is not enabled %s:%d\\n\", \\\n\n                    __FILE__, __LINE__); \\\n\n            goto invalid_opcode; \\\n\n        } \\\n\n    } while (0)\n\n\n\n#define HAS_OPTION(opt) HAS_OPTION_BITS(XTENSA_OPTION_BIT(opt))\n\n\n\n#define TBD() qemu_log(\"TBD(pc = %08x): %s:%d\\n\", dc->pc, __FILE__, __LINE__)\n\n#define RESERVED() do { \\\n\n        qemu_log(\"RESERVED(pc = %08x, %02x%02x%02x): %s:%d\\n\", \\\n\n                dc->pc, b0, b1, b2, __FILE__, __LINE__); \\\n\n        goto invalid_opcode; \\\n\n    } while (0)\n\n\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define OP0 (((b0) & 0xf0) >> 4)\n\n#define OP1 (((b2) & 0xf0) >> 4)\n\n#define OP2 ((b2) & 0xf)\n\n#define RRR_R ((b1) & 0xf)\n\n#define RRR_S (((b1) & 0xf0) >> 4)\n\n#define RRR_T ((b0) & 0xf)\n\n#else\n\n#define OP0 (((b0) & 0xf))\n\n#define OP1 (((b2) & 0xf))\n\n#define OP2 (((b2) & 0xf0) >> 4)\n\n#define RRR_R (((b1) & 0xf0) >> 4)\n\n#define RRR_S (((b1) & 0xf))\n\n#define RRR_T (((b0) & 0xf0) >> 4)\n\n#endif\n\n#define RRR_X ((RRR_R & 0x4) >> 2)\n\n#define RRR_Y ((RRR_T & 0x4) >> 2)\n\n#define RRR_W (RRR_R & 0x3)\n\n\n\n#define RRRN_R RRR_R\n\n#define RRRN_S RRR_S\n\n#define RRRN_T RRR_T\n\n\n\n#define RRI4_R RRR_R\n\n#define RRI4_S RRR_S\n\n#define RRI4_T RRR_T\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RRI4_IMM4 ((b2) & 0xf)\n\n#else\n\n#define RRI4_IMM4 (((b2) & 0xf0) >> 4)\n\n#endif\n\n\n\n#define RRI8_R RRR_R\n\n#define RRI8_S RRR_S\n\n#define RRI8_T RRR_T\n\n#define RRI8_IMM8 (b2)\n\n#define RRI8_IMM8_SE ((((b2) & 0x80) ? 0xffffff00 : 0) | RRI8_IMM8)\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define RI16_IMM16 (((b1) << 8) | (b2))\n\n#else\n\n#define RI16_IMM16 (((b2) << 8) | (b1))\n\n#endif\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALL_N (((b0) & 0xc) >> 2)\n\n#define CALL_OFFSET ((((b0) & 0x3) << 16) | ((b1) << 8) | (b2))\n\n#else\n\n#define CALL_N (((b0) & 0x30) >> 4)\n\n#define CALL_OFFSET ((((b0) & 0xc0) >> 6) | ((b1) << 2) | ((b2) << 10))\n\n#endif\n\n#define CALL_OFFSET_SE \\\n\n    (((CALL_OFFSET & 0x20000) ? 0xfffc0000 : 0) | CALL_OFFSET)\n\n\n\n#define CALLX_N CALL_N\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define CALLX_M ((b0) & 0x3)\n\n#else\n\n#define CALLX_M (((b0) & 0xc0) >> 6)\n\n#endif\n\n#define CALLX_S RRR_S\n\n\n\n#define BRI12_M CALLX_M\n\n#define BRI12_S RRR_S\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n#define BRI12_IMM12 ((((b1) & 0xf) << 8) | (b2))\n\n#else\n\n#define BRI12_IMM12 ((((b1) & 0xf0) >> 4) | ((b2) << 4))\n\n#endif\n\n#define BRI12_IMM12_SE (((BRI12_IMM12 & 0x800) ? 0xfffff000 : 0) | BRI12_IMM12)\n\n\n\n#define BRI8_M BRI12_M\n\n#define BRI8_R RRI8_R\n\n#define BRI8_S RRI8_S\n\n#define BRI8_IMM8 RRI8_IMM8\n\n#define BRI8_IMM8_SE RRI8_IMM8_SE\n\n\n\n#define RSR_SR (b1)\n\n\n\n    uint8_t b0 = cpu_ldub_code(env, dc->pc);\n\n    uint8_t b1 = cpu_ldub_code(env, dc->pc + 1);\n\n    uint8_t b2 = 0;\n\n    unsigned len = xtensa_op0_insn_len(OP0);\n\n\n\n    static const uint32_t B4CONST[] = {\n\n        0xffffffff, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    static const uint32_t B4CONSTU[] = {\n\n        32768, 65536, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256\n\n    };\n\n\n\n    switch (len) {\n\n    case 2:\n\n        HAS_OPTION(XTENSA_OPTION_CODE_DENSITY);\n\n        break;\n\n\n\n    case 3:\n\n        b2 = cpu_ldub_code(env, dc->pc + 2);\n\n        break;\n\n\n\n    default:\n\n        RESERVED();\n\n    }\n\n    dc->next_pc = dc->pc + len;\n\n\n\n    switch (OP0) {\n\n    case 0: /*QRST*/\n\n        switch (OP1) {\n\n        case 0: /*RST0*/\n\n            switch (OP2) {\n\n            case 0: /*ST0*/\n\n                if ((RRR_R & 0xc) == 0x8) {\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                }\n\n\n\n                switch (RRR_R) {\n\n                case 0: /*SNM0*/\n\n                    switch (CALLX_M) {\n\n                    case 0: /*ILL*/\n\n                        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    case 2: /*JR*/\n\n                        switch (CALLX_N) {\n\n                        case 0: /*RET*/\n\n                        case 2: /*JX*/\n\n                            if (gen_window_check1(dc, CALLX_S)) {\n\n                                gen_jump(dc, cpu_R[CALLX_S]);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*RETWw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                                gen_advance_ccount(dc);\n\n                                gen_helper_retw(tmp, cpu_env, tmp);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 3: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 3: /*CALLX*/\n\n                        if (!gen_window_check2(dc, CALLX_S, CALLX_N << 2)) {\n\n                            break;\n\n                        }\n\n                        switch (CALLX_N) {\n\n                        case 0: /*CALLX0*/\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n                                gen_jump(dc, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*CALLX4w*/\n\n                        case 2: /*CALLX8w*/\n\n                        case 3: /*CALLX12w*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            {\n\n                                TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);\n\n                                gen_callw(dc, CALLX_N, tmp);\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n                        }\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*MOVSPw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    if (gen_window_check2(dc, RRR_T, RRR_S)) {\n\n                        TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                        gen_advance_ccount(dc);\n\n                        gen_helper_movsp(cpu_env, pc);\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                        tcg_temp_free(pc);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SYNC*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*ISYNC*/\n\n                        break;\n\n\n\n                    case 1: /*RSYNC*/\n\n                        break;\n\n\n\n                    case 2: /*ESYNC*/\n\n                        break;\n\n\n\n                    case 3: /*DSYNC*/\n\n                        break;\n\n\n\n                    case 8: /*EXCW*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        break;\n\n\n\n                    case 12: /*MEMW*/\n\n                        break;\n\n\n\n                    case 13: /*EXTW*/\n\n                        break;\n\n\n\n                    case 15: /*NOP*/\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*RFEIx*/\n\n                    switch (RRR_T) {\n\n                    case 0: /*RFETx*/\n\n                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                        switch (RRR_S) {\n\n                        case 0: /*RFEx*/\n\n                            if (gen_check_privilege(dc)) {\n\n                                tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n                            }\n\n                            break;\n\n\n\n                        case 1: /*RFUEx*/\n\n                            RESERVED();\n\n                            break;\n\n\n\n                        case 2: /*RFDEx*/\n\n                            if (gen_check_privilege(dc)) {\n\n                                gen_jump(dc, cpu_SR[\n\n                                         dc->config->ndepc ? DEPC : EPC1]);\n\n                            }\n\n                            break;\n\n\n\n                        case 4: /*RFWOw*/\n\n                        case 5: /*RFWUw*/\n\n                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                            if (gen_check_privilege(dc)) {\n\n                                TCGv_i32 tmp = tcg_const_i32(1);\n\n\n\n                                tcg_gen_andi_i32(\n\n                                        cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);\n\n                                tcg_gen_shl_i32(tmp, tmp, cpu_SR[WINDOW_BASE]);\n\n\n\n                                if (RRR_S == 4) {\n\n                                    tcg_gen_andc_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                } else {\n\n                                    tcg_gen_or_i32(cpu_SR[WINDOW_START],\n\n                                            cpu_SR[WINDOW_START], tmp);\n\n                                }\n\n\n\n                                gen_helper_restore_owb(cpu_env);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1]);\n\n\n\n                                tcg_temp_free(tmp);\n\n                            }\n\n                            break;\n\n\n\n                        default: /*reserved*/\n\n                            RESERVED();\n\n                            break;\n\n                        }\n\n                        break;\n\n\n\n                    case 1: /*RFIx*/\n\n                        HAS_OPTION(XTENSA_OPTION_HIGH_PRIORITY_INTERRUPT);\n\n                        if (RRR_S >= 2 && RRR_S <= dc->config->nlevel) {\n\n                            if (gen_check_privilege(dc)) {\n\n                                tcg_gen_mov_i32(cpu_SR[PS],\n\n                                                cpu_SR[EPS2 + RRR_S - 2]);\n\n                                gen_helper_check_interrupts(cpu_env);\n\n                                gen_jump(dc, cpu_SR[EPC1 + RRR_S - 1]);\n\n                            }\n\n                        } else {\n\n                            qemu_log(\"RFI %d is illegal\\n\", RRR_S);\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    case 2: /*RFME*/\n\n                        TBD();\n\n                        break;\n\n\n\n                    default: /*reserved*/\n\n                        RESERVED();\n\n                        break;\n\n\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*BREAKx*/\n\n                    HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                    if (dc->debug) {\n\n                        gen_debug_exception(dc, DEBUGCAUSE_BI);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*SYSCALLx*/\n\n                    HAS_OPTION(XTENSA_OPTION_EXCEPTION);\n\n                    switch (RRR_S) {\n\n                    case 0: /*SYSCALLx*/\n\n                        gen_exception_cause(dc, SYSCALL_CAUSE);\n\n                        break;\n\n\n\n                    case 1: /*SIMCALL*/\n\n                        if (semihosting_enabled) {\n\n                            if (gen_check_privilege(dc)) {\n\n                                gen_helper_simcall(cpu_env);\n\n                            }\n\n                        } else {\n\n                            qemu_log(\"SIMCALL but semihosting is disabled\\n\");\n\n                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                        }\n\n                        break;\n\n\n\n                    default:\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RSILx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    if (gen_check_privilege(dc) &&\n\n                        gen_window_check1(dc, RRR_T)) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_SR[PS]);\n\n                        tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_INTLEVEL);\n\n                        tcg_gen_ori_i32(cpu_SR[PS], cpu_SR[PS], RRR_S);\n\n                        gen_helper_check_interrupts(cpu_env);\n\n                        gen_jumpi_check_loop_end(dc, 0);\n\n                    }\n\n                    break;\n\n\n\n                case 7: /*WAITIx*/\n\n                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_waiti(dc, RRR_S);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*ANY4p*/\n\n                case 9: /*ALL4p*/\n\n                case 10: /*ANY8p*/\n\n                case 11: /*ALL8p*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        const unsigned shift = (RRR_R & 2) ? 8 : 4;\n\n                        TCGv_i32 mask = tcg_const_i32(\n\n                                ((1 << shift) - 1) << RRR_S);\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_and_i32(tmp, cpu_SR[BR], mask);\n\n                        if (RRR_R & 1) { /*ALL*/\n\n                            tcg_gen_addi_i32(tmp, tmp, 1 << RRR_S);\n\n                        } else { /*ANY*/\n\n                            tcg_gen_add_i32(tmp, tmp, mask);\n\n                        }\n\n                        tcg_gen_shri_i32(tmp, tmp, RRR_S + shift);\n\n                        tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR],\n\n                                tmp, RRR_T, 1);\n\n                        tcg_temp_free(mask);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 1: /*AND*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_and_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*OR*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_or_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 3: /*XOR*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_xor_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 4: /*ST1*/\n\n                switch (RRR_R) {\n\n                case 0: /*SSR*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        gen_right_shift_sar(dc, cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*SSL*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        gen_left_shift_sar(dc, cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*SSA8L*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*SSA8B*/\n\n                    if (gen_window_check1(dc, RRR_S)) {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);\n\n                        gen_left_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*SSAI*/\n\n                    {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_S | ((RRR_T & 1) << 4));\n\n                        gen_right_shift_sar(dc, tmp);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*RER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 7: /*WER*/\n\n                    TBD();\n\n                    break;\n\n\n\n                case 8: /*ROTWw*/\n\n                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                    if (gen_check_privilege(dc)) {\n\n                        TCGv_i32 tmp = tcg_const_i32(\n\n                                RRR_T | ((RRR_T & 8) ? 0xfffffff0 : 0));\n\n                        gen_helper_rotw(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n                        /* This can change tb->flags, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                    }\n\n                    break;\n\n\n\n                case 14: /*NSAu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    if (gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                        gen_helper_nsa(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 15: /*NSAUu*/\n\n                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);\n\n                    if (gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                        gen_helper_nsau(cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 5: /*TLB*/\n\n                HAS_OPTION_BITS(\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_MMU) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_PROTECTION) |\n\n                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_TRANSLATION));\n\n                if (gen_check_privilege(dc) &&\n\n                    gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                    TCGv_i32 dtlb = tcg_const_i32((RRR_R & 8) != 0);\n\n\n\n                    switch (RRR_R & 7) {\n\n                    case 3: /*RITLB0*/ /*RDTLB0*/\n\n                        gen_helper_rtlb0(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 4: /*IITLB*/ /*IDTLB*/\n\n                        gen_helper_itlb(cpu_env, cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 5: /*PITLB*/ /*PDTLB*/\n\n                        tcg_gen_movi_i32(cpu_pc, dc->pc);\n\n                        gen_helper_ptlb(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    case 6: /*WITLB*/ /*WDTLB*/\n\n                        gen_helper_wtlb(\n\n                                cpu_env, cpu_R[RRR_T], cpu_R[RRR_S], dtlb);\n\n                        /* This could change memory mapping, so exit tb */\n\n                        gen_jumpi_check_loop_end(dc, -1);\n\n                        break;\n\n\n\n                    case 7: /*RITLB1*/ /*RDTLB1*/\n\n                        gen_helper_rtlb1(cpu_R[RRR_T],\n\n                                cpu_env, cpu_R[RRR_S], dtlb);\n\n                        break;\n\n\n\n                    default:\n\n                        tcg_temp_free(dtlb);\n\n                        RESERVED();\n\n                        break;\n\n                    }\n\n                    tcg_temp_free(dtlb);\n\n                }\n\n                break;\n\n\n\n            case 6: /*RT0*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                switch (RRR_S) {\n\n                case 0: /*NEG*/\n\n                    tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);\n\n                    break;\n\n\n\n                case 1: /*ABS*/\n\n                    {\n\n                        TCGv_i32 zero = tcg_const_i32(0);\n\n                        TCGv_i32 neg = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_neg_i32(neg, cpu_R[RRR_T]);\n\n                        tcg_gen_movcond_i32(TCG_COND_GE, cpu_R[RRR_R],\n\n                                cpu_R[RRR_T], zero, cpu_R[RRR_T], neg);\n\n                        tcg_temp_free(neg);\n\n                        tcg_temp_free(zero);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 7: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n\n\n            case 8: /*ADD*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 9: /*ADD**/\n\n            case 10:\n\n            case 11:\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 8);\n\n                    tcg_gen_add_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 12: /*SUB*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 13: /*SUB**/\n\n            case 14:\n\n            case 15:\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 12);\n\n                    tcg_gen_sub_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 1: /*RST1*/\n\n            switch (OP2) {\n\n            case 0: /*SLLI*/\n\n            case 1:\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    tcg_gen_shli_i32(cpu_R[RRR_R], cpu_R[RRR_S],\n\n                                     32 - (RRR_T | ((OP2 & 1) << 4)));\n\n                }\n\n                break;\n\n\n\n            case 2: /*SRAI*/\n\n            case 3:\n\n                if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    tcg_gen_sari_i32(cpu_R[RRR_R], cpu_R[RRR_T],\n\n                                     RRR_S | ((OP2 & 1) << 4));\n\n                }\n\n                break;\n\n\n\n            case 4: /*SRLI*/\n\n                if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    tcg_gen_shri_i32(cpu_R[RRR_R], cpu_R[RRR_T], RRR_S);\n\n                }\n\n                break;\n\n\n\n            case 6: /*XSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_X) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_mov_i32(tmp, cpu_R[RRR_T]);\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                    gen_wsr(dc, RSR_SR, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n                /*\n\n                 * Note: 64 bit ops are used here solely because SAR values\n\n                 * have range 0..63\n\n                 */\n\n#define gen_shift_reg(cmd, reg) do { \\\n\n                    TCGv_i64 tmp = tcg_temp_new_i64(); \\\n\n                    tcg_gen_extu_i32_i64(tmp, reg); \\\n\n                    tcg_gen_##cmd##_i64(v, v, tmp); \\\n\n                    tcg_gen_trunc_i64_i32(cpu_R[RRR_R], v); \\\n\n                    tcg_temp_free_i64(v); \\\n\n                    tcg_temp_free_i64(tmp); \\\n\n                } while (0)\n\n\n\n#define gen_shift(cmd) gen_shift_reg(cmd, cpu_SR[SAR])\n\n\n\n            case 8: /*SRC*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_concat_i32_i64(v, cpu_R[RRR_T], cpu_R[RRR_S]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 9: /*SRL*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_shr_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(shr);\n\n                }\n\n                break;\n\n\n\n            case 10: /*SLL*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_m32_5bit) {\n\n                    tcg_gen_shl_i32(cpu_R[RRR_R], cpu_R[RRR_S], dc->sar_m32);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    TCGv_i32 s = tcg_const_i32(32);\n\n                    tcg_gen_sub_i32(s, s, cpu_SR[SAR]);\n\n                    tcg_gen_andi_i32(s, s, 0x3f);\n\n                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_S]);\n\n                    gen_shift_reg(shl, s);\n\n                    tcg_temp_free(s);\n\n                }\n\n                break;\n\n\n\n            case 11: /*SRA*/\n\n                if (!gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                    break;\n\n                }\n\n                if (dc->sar_5bit) {\n\n                    tcg_gen_sar_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);\n\n                } else {\n\n                    TCGv_i64 v = tcg_temp_new_i64();\n\n                    tcg_gen_ext_i32_i64(v, cpu_R[RRR_T]);\n\n                    gen_shift(sar);\n\n                }\n\n                break;\n\n#undef gen_shift\n\n#undef gen_shift_reg\n\n\n\n            case 12: /*MUL16U*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16u_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16u_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            case 13: /*MUL16S*/\n\n                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    TCGv_i32 v1 = tcg_temp_new_i32();\n\n                    TCGv_i32 v2 = tcg_temp_new_i32();\n\n                    tcg_gen_ext16s_i32(v1, cpu_R[RRR_S]);\n\n                    tcg_gen_ext16s_i32(v2, cpu_R[RRR_T]);\n\n                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);\n\n                    tcg_temp_free(v2);\n\n                    tcg_temp_free(v1);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 2: /*RST2*/\n\n            if (OP2 >= 8 && !gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                break;\n\n            }\n\n\n\n            if (OP2 >= 12) {\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IDIV);\n\n                int label = gen_new_label();\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0, label);\n\n                gen_exception_cause(dc, INTEGER_DIVIDE_BY_ZERO_CAUSE);\n\n                gen_set_label(label);\n\n            }\n\n\n\n            switch (OP2) {\n\n#define BOOLEAN_LOGIC(fn, r, s, t) \\\n\n                do { \\\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN); \\\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32(); \\\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32(); \\\n\n                    \\\n\n                    tcg_gen_shri_i32(tmp1, cpu_SR[BR], s); \\\n\n                    tcg_gen_shri_i32(tmp2, cpu_SR[BR], t); \\\n\n                    tcg_gen_##fn##_i32(tmp1, tmp1, tmp2); \\\n\n                    tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR], tmp1, r, 1); \\\n\n                    tcg_temp_free(tmp1); \\\n\n                    tcg_temp_free(tmp2); \\\n\n                } while (0)\n\n\n\n            case 0: /*ANDBp*/\n\n                BOOLEAN_LOGIC(and, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 1: /*ANDBCp*/\n\n                BOOLEAN_LOGIC(andc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*ORBp*/\n\n                BOOLEAN_LOGIC(or, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*ORBCp*/\n\n                BOOLEAN_LOGIC(orc, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*XORBp*/\n\n                BOOLEAN_LOGIC(xor, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef BOOLEAN_LOGIC\n\n\n\n            case 8: /*MULLi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL);\n\n                tcg_gen_mul_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 10: /*MULUHi*/\n\n            case 11: /*MULSHi*/\n\n                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL_HIGH);\n\n                {\n\n                    TCGv lo = tcg_temp_new();\n\n\n\n                    if (OP2 == 10) {\n\n                        tcg_gen_mulu2_i32(lo, cpu_R[RRR_R],\n\n                                          cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_muls2_i32(lo, cpu_R[RRR_R],\n\n                                          cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    tcg_temp_free(lo);\n\n                }\n\n                break;\n\n\n\n            case 12: /*QUOUi*/\n\n                tcg_gen_divu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            case 13: /*QUOSi*/\n\n            case 15: /*REMSi*/\n\n                {\n\n                    int label1 = gen_new_label();\n\n                    int label2 = gen_new_label();\n\n\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_S], 0x80000000,\n\n                            label1);\n\n                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0xffffffff,\n\n                            label1);\n\n                    tcg_gen_movi_i32(cpu_R[RRR_R],\n\n                            OP2 == 13 ? 0x80000000 : 0);\n\n                    tcg_gen_br(label2);\n\n                    gen_set_label(label1);\n\n                    if (OP2 == 13) {\n\n                        tcg_gen_div_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    } else {\n\n                        tcg_gen_rem_i32(cpu_R[RRR_R],\n\n                                cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    }\n\n                    gen_set_label(label2);\n\n                }\n\n                break;\n\n\n\n            case 14: /*REMUi*/\n\n                tcg_gen_remu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 3: /*RST3*/\n\n            switch (OP2) {\n\n            case 0: /*RSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_R) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);\n\n                }\n\n                break;\n\n\n\n            case 1: /*WSR*/\n\n                if (gen_check_sr(dc, RSR_SR, SR_W) &&\n\n                    (RSR_SR < 64 || gen_check_privilege(dc)) &&\n\n                    gen_window_check1(dc, RRR_T)) {\n\n                    gen_wsr(dc, RSR_SR, cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*SEXTu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_SEXT);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    int shift = 24 - RRR_T;\n\n\n\n                    if (shift == 24) {\n\n                        tcg_gen_ext8s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else if (shift == 16) {\n\n                        tcg_gen_ext16s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);\n\n                    } else {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], shift);\n\n                        tcg_gen_sari_i32(cpu_R[RRR_R], tmp, shift);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 3: /*CLAMPSu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_CLAMPS);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    TCGv_i32 tmp1 = tcg_temp_new_i32();\n\n                    TCGv_i32 tmp2 = tcg_temp_new_i32();\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 24 - RRR_T);\n\n                    tcg_gen_xor_i32(tmp2, tmp1, cpu_R[RRR_S]);\n\n                    tcg_gen_andi_i32(tmp2, tmp2, 0xffffffff << (RRR_T + 7));\n\n\n\n                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 31);\n\n                    tcg_gen_xori_i32(tmp1, tmp1, 0xffffffff >> (25 - RRR_T));\n\n\n\n                    tcg_gen_movcond_i32(TCG_COND_EQ, cpu_R[RRR_R], tmp2, zero,\n\n                            cpu_R[RRR_S], tmp1);\n\n                    tcg_temp_free(tmp1);\n\n                    tcg_temp_free(tmp2);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MINu*/\n\n            case 5: /*MAXu*/\n\n            case 6: /*MINUu*/\n\n            case 7: /*MAXUu*/\n\n                HAS_OPTION(XTENSA_OPTION_MISC_OP_MINMAX);\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_LE,\n\n                        TCG_COND_GE,\n\n                        TCG_COND_LEU,\n\n                        TCG_COND_GEU\n\n                    };\n\n                    tcg_gen_movcond_i32(cond[OP2 - 4], cpu_R[RRR_R],\n\n                            cpu_R[RRR_S], cpu_R[RRR_T],\n\n                            cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 8: /*MOVEQZ*/\n\n            case 9: /*MOVNEZ*/\n\n            case 10: /*MOVLTZ*/\n\n            case 11: /*MOVGEZ*/\n\n                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_NE,\n\n                        TCG_COND_LT,\n\n                        TCG_COND_GE,\n\n                    };\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_R[RRR_R],\n\n                            cpu_R[RRR_T], zero, cpu_R[RRR_S], cpu_R[RRR_R]);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVFp*/\n\n            case 13: /*MOVTp*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                if (gen_window_check2(dc, RRR_R, RRR_S)) {\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                            cpu_R[RRR_R], tmp, zero,\n\n                            cpu_R[RRR_S], cpu_R[RRR_R]);\n\n\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 14: /*RUR*/\n\n                if (gen_window_check1(dc, RRR_R)) {\n\n                    int st = (RRR_S << 4) + RRR_T;\n\n                    if (uregnames[st].name) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_UR[st]);\n\n                    } else {\n\n                        qemu_log(\"RUR %d not implemented, \", st);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            case 15: /*WUR*/\n\n                if (gen_window_check1(dc, RRR_T)) {\n\n                    if (uregnames[RSR_SR].name) {\n\n                        gen_wur(RSR_SR, cpu_R[RRR_T]);\n\n                    } else {\n\n                        qemu_log(\"WUR %d not implemented, \", RSR_SR);\n\n                        TBD();\n\n                    }\n\n                }\n\n                break;\n\n\n\n            }\n\n            break;\n\n\n\n        case 4: /*EXTUI*/\n\n        case 5:\n\n            if (gen_window_check2(dc, RRR_R, RRR_T)) {\n\n                int shiftimm = RRR_S | ((OP1 & 1) << 4);\n\n                int maskimm = (1 << (OP2 + 1)) - 1;\n\n\n\n                TCGv_i32 tmp = tcg_temp_new_i32();\n\n                tcg_gen_shri_i32(tmp, cpu_R[RRR_T], shiftimm);\n\n                tcg_gen_andi_i32(cpu_R[RRR_R], tmp, maskimm);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 6: /*CUST0*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 7: /*CUST1*/\n\n            RESERVED();\n\n            break;\n\n\n\n        case 8: /*LSCXp*/\n\n            switch (OP2) {\n\n            case 0: /*LSXf*/\n\n            case 1: /*LSXUf*/\n\n            case 4: /*SSXf*/\n\n            case 5: /*SSXUf*/\n\n                HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n                if (gen_window_check2(dc, RRR_S, RRR_T) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_add_i32(addr, cpu_R[RRR_S], cpu_R[RRR_T]);\n\n                    gen_load_store_alignment(dc, 2, addr, false);\n\n                    if (OP2 & 0x4) {\n\n                        tcg_gen_qemu_st32(cpu_FR[RRR_R], addr, dc->cring);\n\n                    } else {\n\n                        tcg_gen_qemu_ld32u(cpu_FR[RRR_R], addr, dc->cring);\n\n                    }\n\n                    if (OP2 & 0x1) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_S], addr);\n\n                    }\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 9: /*LSC4*/\n\n            if (!gen_window_check2(dc, RRR_S, RRR_T)) {\n\n                break;\n\n            }\n\n            switch (OP2) {\n\n            case 0: /*L32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                if (gen_check_privilege(dc)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_ld32u(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            case 4: /*S32E*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                if (gen_check_privilege(dc)) {\n\n                    TCGv_i32 addr = tcg_temp_new_i32();\n\n                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],\n\n                            (0xffffffc0 | (RRR_R << 2)));\n\n                    tcg_gen_qemu_st32(cpu_R[RRR_T], addr, dc->ring);\n\n                    tcg_temp_free(addr);\n\n                }\n\n                break;\n\n\n\n            default:\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 10: /*FP0*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            switch (OP2) {\n\n            case 0: /*ADD.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_add_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 1: /*SUB.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_sub_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 2: /*MUL.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_mul_s(cpu_FR[RRR_R], cpu_env,\n\n                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 4: /*MADD.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_madd_s(cpu_FR[RRR_R], cpu_env,\n\n                                      cpu_FR[RRR_R], cpu_FR[RRR_S],\n\n                                      cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 5: /*MSUB.Sf*/\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    gen_helper_msub_s(cpu_FR[RRR_R], cpu_env,\n\n                                      cpu_FR[RRR_R], cpu_FR[RRR_S],\n\n                                      cpu_FR[RRR_T]);\n\n                }\n\n                break;\n\n\n\n            case 8: /*ROUND.Sf*/\n\n            case 9: /*TRUNC.Sf*/\n\n            case 10: /*FLOOR.Sf*/\n\n            case 11: /*CEIL.Sf*/\n\n            case 14: /*UTRUNC.Sf*/\n\n                if (gen_window_check1(dc, RRR_R) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    static const unsigned rounding_mode_const[] = {\n\n                        float_round_nearest_even,\n\n                        float_round_to_zero,\n\n                        float_round_down,\n\n                        float_round_up,\n\n                        [6] = float_round_to_zero,\n\n                    };\n\n                    TCGv_i32 rounding_mode = tcg_const_i32(\n\n                            rounding_mode_const[OP2 & 7]);\n\n                    TCGv_i32 scale = tcg_const_i32(RRR_T);\n\n\n\n                    if (OP2 == 14) {\n\n                        gen_helper_ftoui(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    } else {\n\n                        gen_helper_ftoi(cpu_R[RRR_R], cpu_FR[RRR_S],\n\n                                rounding_mode, scale);\n\n                    }\n\n\n\n                    tcg_temp_free(rounding_mode);\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 12: /*FLOAT.Sf*/\n\n            case 13: /*UFLOAT.Sf*/\n\n                if (gen_window_check1(dc, RRR_S) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 scale = tcg_const_i32(-RRR_T);\n\n\n\n                    if (OP2 == 13) {\n\n                        gen_helper_uitof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    } else {\n\n                        gen_helper_itof(cpu_FR[RRR_R], cpu_env,\n\n                                cpu_R[RRR_S], scale);\n\n                    }\n\n                    tcg_temp_free(scale);\n\n                }\n\n                break;\n\n\n\n            case 15: /*FP1OP*/\n\n                switch (RRR_T) {\n\n                case 0: /*MOV.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 1: /*ABS.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        gen_helper_abs_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*RFRf*/\n\n                    if (gen_window_check1(dc, RRR_R) &&\n\n                        gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*WFRf*/\n\n                    if (gen_window_check1(dc, RRR_S) &&\n\n                        gen_check_cpenable(dc, 0)) {\n\n                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_R[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                case 6: /*NEG.Sf*/\n\n                    if (gen_check_cpenable(dc, 0)) {\n\n                        gen_helper_neg_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        case 11: /*FP1*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n\n\n#define gen_compare(rel, br, a, b) \\\n\n    do { \\\n\n        if (gen_check_cpenable(dc, 0)) { \\\n\n            TCGv_i32 bit = tcg_const_i32(1 << br); \\\n\n            \\\n\n            gen_helper_##rel(cpu_env, bit, cpu_FR[a], cpu_FR[b]); \\\n\n            tcg_temp_free(bit); \\\n\n        } \\\n\n    } while (0)\n\n\n\n            switch (OP2) {\n\n            case 1: /*UN.Sf*/\n\n                gen_compare(un_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 2: /*OEQ.Sf*/\n\n                gen_compare(oeq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 3: /*UEQ.Sf*/\n\n                gen_compare(ueq_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 4: /*OLT.Sf*/\n\n                gen_compare(olt_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 5: /*ULT.Sf*/\n\n                gen_compare(ult_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 6: /*OLE.Sf*/\n\n                gen_compare(ole_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n            case 7: /*ULE.Sf*/\n\n                gen_compare(ule_s, RRR_R, RRR_S, RRR_T);\n\n                break;\n\n\n\n#undef gen_compare\n\n\n\n            case 8: /*MOVEQZ.Sf*/\n\n            case 9: /*MOVNEZ.Sf*/\n\n            case 10: /*MOVLTZ.Sf*/\n\n            case 11: /*MOVGEZ.Sf*/\n\n                if (gen_window_check1(dc, RRR_T) &&\n\n                    gen_check_cpenable(dc, 0)) {\n\n                    static const TCGCond cond[] = {\n\n                        TCG_COND_EQ,\n\n                        TCG_COND_NE,\n\n                        TCG_COND_LT,\n\n                        TCG_COND_GE,\n\n                    };\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n\n\n                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_FR[RRR_R],\n\n                            cpu_R[RRR_T], zero, cpu_FR[RRR_S], cpu_FR[RRR_R]);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            case 12: /*MOVF.Sf*/\n\n            case 13: /*MOVT.Sf*/\n\n                HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                if (gen_check_cpenable(dc, 0)) {\n\n                    TCGv_i32 zero = tcg_const_i32(0);\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n\n\n                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);\n\n                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                            cpu_FR[RRR_R], tmp, zero,\n\n                            cpu_FR[RRR_S], cpu_FR[RRR_R]);\n\n\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(zero);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 1: /*L32R*/\n\n        if (gen_window_check1(dc, RRR_T)) {\n\n            TCGv_i32 tmp = tcg_const_i32(\n\n                    ((dc->tb->flags & XTENSA_TBFLAG_LITBASE) ?\n\n                     0 : ((dc->pc + 3) & ~3)) +\n\n                    (0xfffc0000 | (RI16_IMM16 << 2)));\n\n\n\n            if (dc->tb->flags & XTENSA_TBFLAG_LITBASE) {\n\n                tcg_gen_add_i32(tmp, tmp, dc->litbase);\n\n            }\n\n            tcg_gen_qemu_ld32u(cpu_R[RRR_T], tmp, dc->cring);\n\n            tcg_temp_free(tmp);\n\n        }\n\n        break;\n\n\n\n    case 2: /*LSAI*/\n\n#define gen_load_store(type, shift) do { \\\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << shift); \\\n\n                if (shift) { \\\n\n                    gen_load_store_alignment(dc, shift, addr, false); \\\n\n                } \\\n\n                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n        switch (RRI8_R) {\n\n        case 0: /*L8UI*/\n\n            gen_load_store(ld8u, 0);\n\n            break;\n\n\n\n        case 1: /*L16UI*/\n\n            gen_load_store(ld16u, 1);\n\n            break;\n\n\n\n        case 2: /*L32I*/\n\n            gen_load_store(ld32u, 2);\n\n            break;\n\n\n\n        case 4: /*S8I*/\n\n            gen_load_store(st8, 0);\n\n            break;\n\n\n\n        case 5: /*S16I*/\n\n            gen_load_store(st16, 1);\n\n            break;\n\n\n\n        case 6: /*S32I*/\n\n            gen_load_store(st32, 2);\n\n            break;\n\n\n\n#define gen_dcache_hit_test(w, shift) do { \\\n\n            if (gen_window_check1(dc, RRI##w##_S)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                TCGv_i32 res = tcg_temp_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \\\n\n                                 RRI##w##_IMM##w << shift); \\\n\n                tcg_gen_qemu_ld8u(res, addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n                tcg_temp_free(res); \\\n\n            } \\\n\n        } while (0)\n\n\n\n#define gen_dcache_hit_test4() gen_dcache_hit_test(4, 4)\n\n#define gen_dcache_hit_test8() gen_dcache_hit_test(8, 2)\n\n\n\n        case 7: /*CACHEc*/\n\n            if (RRI8_T < 8) {\n\n                HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n            }\n\n\n\n            switch (RRI8_T) {\n\n            case 0: /*DPFRc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 1: /*DPFWc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 2: /*DPFROc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 3: /*DPFWOc*/\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 4: /*DHWBc*/\n\n                gen_dcache_hit_test8();\n\n                break;\n\n\n\n            case 5: /*DHWBIc*/\n\n                gen_dcache_hit_test8();\n\n                break;\n\n\n\n            case 6: /*DHIc*/\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_dcache_hit_test8();\n\n                }\n\n                break;\n\n\n\n            case 7: /*DIIc*/\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_window_check1(dc, RRI8_S);\n\n                }\n\n                break;\n\n\n\n            case 8: /*DCEc*/\n\n                switch (OP1) {\n\n                case 0: /*DPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_dcache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*DHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_dcache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*DIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                case 4: /*DIWBc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                case 5: /*DIWBIc*/\n\n                    HAS_OPTION(XTENSA_OPTION_DCACHE);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n#undef gen_dcache_hit_test\n\n#undef gen_dcache_hit_test4\n\n#undef gen_dcache_hit_test8\n\n\n\n#define gen_icache_hit_test(w, shift) do { \\\n\n            if (gen_window_check1(dc, RRI##w##_S)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                tcg_gen_movi_i32(cpu_pc, dc->pc); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \\\n\n                                 RRI##w##_IMM##w << shift); \\\n\n                gen_helper_itlb_hit_test(cpu_env, addr); \\\n\n                tcg_temp_free(addr); \\\n\n            }\\\n\n        } while (0)\n\n\n\n#define gen_icache_hit_test4() gen_icache_hit_test(4, 4)\n\n#define gen_icache_hit_test8() gen_icache_hit_test(8, 2)\n\n\n\n            case 12: /*IPFc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                gen_window_check1(dc, RRI8_S);\n\n                break;\n\n\n\n            case 13: /*ICEc*/\n\n                switch (OP1) {\n\n                case 0: /*IPFLl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_icache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 2: /*IHUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_icache_hit_test4();\n\n                    }\n\n                    break;\n\n\n\n                case 3: /*IIUl*/\n\n                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);\n\n                    if (gen_check_privilege(dc)) {\n\n                        gen_window_check1(dc, RRI4_S);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n                }\n\n                break;\n\n\n\n            case 14: /*IHIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                gen_icache_hit_test8();\n\n                break;\n\n\n\n            case 15: /*IIIc*/\n\n                HAS_OPTION(XTENSA_OPTION_ICACHE);\n\n                if (gen_check_privilege(dc)) {\n\n                    gen_window_check1(dc, RRI8_S);\n\n                }\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n#undef gen_icache_hit_test\n\n#undef gen_icache_hit_test4\n\n#undef gen_icache_hit_test8\n\n\n\n        case 9: /*L16SI*/\n\n            gen_load_store(ld16s, 1);\n\n            break;\n\n#undef gen_load_store\n\n\n\n        case 10: /*MOVI*/\n\n            if (gen_window_check1(dc, RRI8_T)) {\n\n                tcg_gen_movi_i32(cpu_R[RRI8_T],\n\n                                 RRI8_IMM8 | (RRI8_S << 8) |\n\n                                 ((RRI8_S & 0x8) ? 0xfffff000 : 0));\n\n            }\n\n            break;\n\n\n\n#define gen_load_store_no_hw_align(type) do { \\\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_local_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2); \\\n\n                gen_load_store_alignment(dc, 2, addr, true); \\\n\n                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n        case 11: /*L32AIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(ld32u); /*TODO acquire?*/\n\n            break;\n\n\n\n        case 12: /*ADDI*/\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 13: /*ADDMI*/\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S],\n\n                                 RRI8_IMM8_SE << 8);\n\n            }\n\n            break;\n\n\n\n        case 14: /*S32C1Iy*/\n\n            HAS_OPTION(XTENSA_OPTION_CONDITIONAL_STORE);\n\n            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                int label = gen_new_label();\n\n                TCGv_i32 tmp = tcg_temp_local_new_i32();\n\n                TCGv_i32 addr = tcg_temp_local_new_i32();\n\n                TCGv_i32 tpc;\n\n\n\n                tcg_gen_mov_i32(tmp, cpu_R[RRI8_T]);\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, true);\n\n\n\n                gen_advance_ccount(dc);\n\n                tpc = tcg_const_i32(dc->pc);\n\n                gen_helper_check_atomctl(cpu_env, tpc, addr);\n\n                tcg_gen_qemu_ld32u(cpu_R[RRI8_T], addr, dc->cring);\n\n                tcg_gen_brcond_i32(TCG_COND_NE, cpu_R[RRI8_T],\n\n                        cpu_SR[SCOMPARE1], label);\n\n\n\n                tcg_gen_qemu_st32(tmp, addr, dc->cring);\n\n\n\n                gen_set_label(label);\n\n                tcg_temp_free(tpc);\n\n                tcg_temp_free(addr);\n\n                tcg_temp_free(tmp);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S32RIy*/\n\n            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);\n\n            gen_load_store_no_hw_align(st32); /*TODO release?*/\n\n            break;\n\n#undef gen_load_store_no_hw_align\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 3: /*LSCIp*/\n\n        switch (RRI8_R) {\n\n        case 0: /*LSIf*/\n\n        case 4: /*SSIf*/\n\n        case 8: /*LSIUf*/\n\n        case 12: /*SSIUf*/\n\n            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);\n\n            if (gen_window_check1(dc, RRI8_S) &&\n\n                gen_check_cpenable(dc, 0)) {\n\n                TCGv_i32 addr = tcg_temp_new_i32();\n\n                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);\n\n                gen_load_store_alignment(dc, 2, addr, false);\n\n                if (RRI8_R & 0x4) {\n\n                    tcg_gen_qemu_st32(cpu_FR[RRI8_T], addr, dc->cring);\n\n                } else {\n\n                    tcg_gen_qemu_ld32u(cpu_FR[RRI8_T], addr, dc->cring);\n\n                }\n\n                if (RRI8_R & 0x8) {\n\n                    tcg_gen_mov_i32(cpu_R[RRI8_S], addr);\n\n                }\n\n                tcg_temp_free(addr);\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 4: /*MAC16d*/\n\n        HAS_OPTION(XTENSA_OPTION_MAC16);\n\n        {\n\n            enum {\n\n                MAC16_UMUL = 0x0,\n\n                MAC16_MUL  = 0x4,\n\n                MAC16_MULA = 0x8,\n\n                MAC16_MULS = 0xc,\n\n                MAC16_NONE = 0xf,\n\n            } op = OP1 & 0xc;\n\n            bool is_m1_sr = (OP2 & 0x3) == 2;\n\n            bool is_m2_sr = (OP2 & 0xc) == 0;\n\n            uint32_t ld_offset = 0;\n\n\n\n            if (OP2 > 9) {\n\n                RESERVED();\n\n            }\n\n\n\n            switch (OP2 & 2) {\n\n            case 0: /*MACI?/MACC?*/\n\n                is_m1_sr = true;\n\n                ld_offset = (OP2 & 1) ? -4 : 4;\n\n\n\n                if (OP2 >= 8) { /*MACI/MACC*/\n\n                    if (OP1 == 0) { /*LDINC/LDDEC*/\n\n                        op = MAC16_NONE;\n\n                    } else {\n\n                        RESERVED();\n\n                    }\n\n                } else if (op != MAC16_MULA) { /*MULA.*.*.LDINC/LDDEC*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n\n\n            case 2: /*MACD?/MACA?*/\n\n                if (op == MAC16_UMUL && OP2 != 7) { /*UMUL only in MACAA*/\n\n                    RESERVED();\n\n                }\n\n                break;\n\n            }\n\n\n\n            if (op != MAC16_NONE) {\n\n                if (!is_m1_sr && !gen_window_check1(dc, RRR_S)) {\n\n                    break;\n\n                }\n\n                if (!is_m2_sr && !gen_window_check1(dc, RRR_T)) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            if (ld_offset && !gen_window_check1(dc, RRR_S)) {\n\n                break;\n\n            }\n\n\n\n            {\n\n                TCGv_i32 vaddr = tcg_temp_new_i32();\n\n                TCGv_i32 mem32 = tcg_temp_new_i32();\n\n\n\n                if (ld_offset) {\n\n                    tcg_gen_addi_i32(vaddr, cpu_R[RRR_S], ld_offset);\n\n                    gen_load_store_alignment(dc, 2, vaddr, false);\n\n                    tcg_gen_qemu_ld32u(mem32, vaddr, dc->cring);\n\n                }\n\n                if (op != MAC16_NONE) {\n\n                    TCGv_i32 m1 = gen_mac16_m(\n\n                            is_m1_sr ? cpu_SR[MR + RRR_X] : cpu_R[RRR_S],\n\n                            OP1 & 1, op == MAC16_UMUL);\n\n                    TCGv_i32 m2 = gen_mac16_m(\n\n                            is_m2_sr ? cpu_SR[MR + 2 + RRR_Y] : cpu_R[RRR_T],\n\n                            OP1 & 2, op == MAC16_UMUL);\n\n\n\n                    if (op == MAC16_MUL || op == MAC16_UMUL) {\n\n                        tcg_gen_mul_i32(cpu_SR[ACCLO], m1, m2);\n\n                        if (op == MAC16_UMUL) {\n\n                            tcg_gen_movi_i32(cpu_SR[ACCHI], 0);\n\n                        } else {\n\n                            tcg_gen_sari_i32(cpu_SR[ACCHI], cpu_SR[ACCLO], 31);\n\n                        }\n\n                    } else {\n\n                        TCGv_i32 lo = tcg_temp_new_i32();\n\n                        TCGv_i32 hi = tcg_temp_new_i32();\n\n\n\n                        tcg_gen_mul_i32(lo, m1, m2);\n\n                        tcg_gen_sari_i32(hi, lo, 31);\n\n                        if (op == MAC16_MULA) {\n\n                            tcg_gen_add2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             lo, hi);\n\n                        } else {\n\n                            tcg_gen_sub2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             cpu_SR[ACCLO], cpu_SR[ACCHI],\n\n                                             lo, hi);\n\n                        }\n\n                        tcg_gen_ext8s_i32(cpu_SR[ACCHI], cpu_SR[ACCHI]);\n\n\n\n                        tcg_temp_free_i32(lo);\n\n                        tcg_temp_free_i32(hi);\n\n                    }\n\n                    tcg_temp_free(m1);\n\n                    tcg_temp_free(m2);\n\n                }\n\n                if (ld_offset) {\n\n                    tcg_gen_mov_i32(cpu_R[RRR_S], vaddr);\n\n                    tcg_gen_mov_i32(cpu_SR[MR + RRR_W], mem32);\n\n                }\n\n                tcg_temp_free(vaddr);\n\n                tcg_temp_free(mem32);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 5: /*CALLN*/\n\n        switch (CALL_N) {\n\n        case 0: /*CALL0*/\n\n            tcg_gen_movi_i32(cpu_R[0], dc->next_pc);\n\n            gen_jumpi(dc, (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            break;\n\n\n\n        case 1: /*CALL4w*/\n\n        case 2: /*CALL8w*/\n\n        case 3: /*CALL12w*/\n\n            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n            if (gen_window_check1(dc, CALL_N << 2)) {\n\n                gen_callwi(dc, CALL_N,\n\n                           (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 6: /*SI*/\n\n        switch (CALL_N) {\n\n        case 0: /*J*/\n\n            gen_jumpi(dc, dc->pc + 4 + CALL_OFFSET_SE, 0);\n\n            break;\n\n\n\n        case 1: /*BZ*/\n\n            if (gen_window_check1(dc, BRI12_S)) {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQZ*/\n\n                    TCG_COND_NE, /*BNEZ*/\n\n                    TCG_COND_LT, /*BLTZ*/\n\n                    TCG_COND_GE, /*BGEZ*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI12_M & 3], cpu_R[BRI12_S], 0,\n\n                        4 + BRI12_IMM12_SE);\n\n            }\n\n            break;\n\n\n\n        case 2: /*BI0*/\n\n            if (gen_window_check1(dc, BRI8_S)) {\n\n                static const TCGCond cond[] = {\n\n                    TCG_COND_EQ, /*BEQI*/\n\n                    TCG_COND_NE, /*BNEI*/\n\n                    TCG_COND_LT, /*BLTI*/\n\n                    TCG_COND_GE, /*BGEI*/\n\n                };\n\n\n\n                gen_brcondi(dc, cond[BRI8_M & 3],\n\n                        cpu_R[BRI8_S], B4CONST[BRI8_R], 4 + BRI8_IMM8_SE);\n\n            }\n\n            break;\n\n\n\n        case 3: /*BI1*/\n\n            switch (BRI8_M) {\n\n            case 0: /*ENTRYw*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 pc = tcg_const_i32(dc->pc);\n\n                    TCGv_i32 s = tcg_const_i32(BRI12_S);\n\n                    TCGv_i32 imm = tcg_const_i32(BRI12_IMM12);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_entry(cpu_env, pc, s, imm);\n\n                    tcg_temp_free(imm);\n\n                    tcg_temp_free(s);\n\n                    tcg_temp_free(pc);\n\n                    /* This can change tb->flags, so exit tb */\n\n                    gen_jumpi_check_loop_end(dc, -1);\n\n                }\n\n                break;\n\n\n\n            case 1: /*B1*/\n\n                switch (BRI8_R) {\n\n                case 0: /*BFp*/\n\n                case 1: /*BTp*/\n\n                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);\n\n                    {\n\n                        TCGv_i32 tmp = tcg_temp_new_i32();\n\n                        tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRI8_S);\n\n                        gen_brcondi(dc,\n\n                                BRI8_R == 1 ? TCG_COND_NE : TCG_COND_EQ,\n\n                                tmp, 0, 4 + RRI8_IMM8_SE);\n\n                        tcg_temp_free(tmp);\n\n                    }\n\n                    break;\n\n\n\n                case 8: /*LOOP*/\n\n                case 9: /*LOOPNEZ*/\n\n                case 10: /*LOOPGTZ*/\n\n                    HAS_OPTION(XTENSA_OPTION_LOOP);\n\n                    if (gen_window_check1(dc, RRI8_S)) {\n\n                        uint32_t lend = dc->pc + RRI8_IMM8 + 4;\n\n                        TCGv_i32 tmp = tcg_const_i32(lend);\n\n\n\n                        tcg_gen_subi_i32(cpu_SR[LCOUNT], cpu_R[RRI8_S], 1);\n\n                        tcg_gen_movi_i32(cpu_SR[LBEG], dc->next_pc);\n\n                        gen_helper_wsr_lend(cpu_env, tmp);\n\n                        tcg_temp_free(tmp);\n\n\n\n                        if (BRI8_R > 8) {\n\n                            int label = gen_new_label();\n\n                            tcg_gen_brcondi_i32(\n\n                                    BRI8_R == 9 ? TCG_COND_NE : TCG_COND_GT,\n\n                                    cpu_R[RRI8_S], 0, label);\n\n                            gen_jumpi(dc, lend, 1);\n\n                            gen_set_label(label);\n\n                        }\n\n\n\n                        gen_jumpi(dc, dc->next_pc, 0);\n\n                    }\n\n                    break;\n\n\n\n                default: /*reserved*/\n\n                    RESERVED();\n\n                    break;\n\n\n\n                }\n\n                break;\n\n\n\n            case 2: /*BLTUI*/\n\n            case 3: /*BGEUI*/\n\n                if (gen_window_check1(dc, BRI8_S)) {\n\n                    gen_brcondi(dc, BRI8_M == 2 ? TCG_COND_LTU : TCG_COND_GEU,\n\n                                cpu_R[BRI8_S], B4CONSTU[BRI8_R],\n\n                                4 + BRI8_IMM8_SE);\n\n                }\n\n                break;\n\n            }\n\n            break;\n\n\n\n        }\n\n        break;\n\n\n\n    case 7: /*B*/\n\n        {\n\n            TCGCond eq_ne = (RRI8_R & 8) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            switch (RRI8_R & 7) {\n\n            case 0: /*BNONE*/ /*BANY*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 1: /*BEQ*/ /*BNE*/\n\n            case 2: /*BLT*/ /*BGE*/\n\n            case 3: /*BLTU*/ /*BGEU*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    static const TCGCond cond[] = {\n\n                        [1] = TCG_COND_EQ,\n\n                        [2] = TCG_COND_LT,\n\n                        [3] = TCG_COND_LTU,\n\n                        [9] = TCG_COND_NE,\n\n                        [10] = TCG_COND_GE,\n\n                        [11] = TCG_COND_GEU,\n\n                    };\n\n                    gen_brcond(dc, cond[RRI8_R], cpu_R[RRI8_S], cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                }\n\n                break;\n\n\n\n            case 4: /*BALL*/ /*BNALL*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);\n\n                    gen_brcond(dc, eq_ne, tmp, cpu_R[RRI8_T],\n\n                            4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 5: /*BBC*/ /*BBS*/\n\n                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    TCGv_i32 bit = tcg_const_i32(0x80000000);\n\n#else\n\n                    TCGv_i32 bit = tcg_const_i32(0x00000001);\n\n#endif\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_T], 0x1f);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                    tcg_gen_shr_i32(bit, bit, tmp);\n\n#else\n\n                    tcg_gen_shl_i32(bit, bit, tmp);\n\n#endif\n\n                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], bit);\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                    tcg_temp_free(bit);\n\n                }\n\n                break;\n\n\n\n            case 6: /*BBCI*/ /*BBSI*/\n\n            case 7:\n\n                if (gen_window_check1(dc, RRI8_S)) {\n\n                    TCGv_i32 tmp = tcg_temp_new_i32();\n\n                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_S],\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n                            0x80000000 >> (((RRI8_R & 1) << 4) | RRI8_T));\n\n#else\n\n                            0x00000001 << (((RRI8_R & 1) << 4) | RRI8_T));\n\n#endif\n\n                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            }\n\n        }\n\n        break;\n\n\n\n#define gen_narrow_load_store(type) do { \\\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) { \\\n\n                TCGv_i32 addr = tcg_temp_new_i32(); \\\n\n                tcg_gen_addi_i32(addr, cpu_R[RRRN_S], RRRN_R << 2); \\\n\n                gen_load_store_alignment(dc, 2, addr, false); \\\n\n                tcg_gen_qemu_##type(cpu_R[RRRN_T], addr, dc->cring); \\\n\n                tcg_temp_free(addr); \\\n\n            } \\\n\n        } while (0)\n\n\n\n    case 8: /*L32I.Nn*/\n\n        gen_narrow_load_store(ld32u);\n\n        break;\n\n\n\n    case 9: /*S32I.Nn*/\n\n        gen_narrow_load_store(st32);\n\n        break;\n\n#undef gen_narrow_load_store\n\n\n\n    case 10: /*ADD.Nn*/\n\n        if (gen_window_check3(dc, RRRN_R, RRRN_S, RRRN_T)) {\n\n            tcg_gen_add_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], cpu_R[RRRN_T]);\n\n        }\n\n        break;\n\n\n\n    case 11: /*ADDI.Nn*/\n\n        if (gen_window_check2(dc, RRRN_R, RRRN_S)) {\n\n            tcg_gen_addi_i32(cpu_R[RRRN_R], cpu_R[RRRN_S],\n\n                             RRRN_T ? RRRN_T : -1);\n\n        }\n\n        break;\n\n\n\n    case 12: /*ST2n*/\n\n        if (!gen_window_check1(dc, RRRN_S)) {\n\n            break;\n\n        }\n\n        if (RRRN_T < 8) { /*MOVI.Nn*/\n\n            tcg_gen_movi_i32(cpu_R[RRRN_S],\n\n                    RRRN_R | (RRRN_T << 4) |\n\n                    ((RRRN_T & 6) == 6 ? 0xffffff80 : 0));\n\n        } else { /*BEQZ.Nn*/ /*BNEZ.Nn*/\n\n            TCGCond eq_ne = (RRRN_T & 4) ? TCG_COND_NE : TCG_COND_EQ;\n\n\n\n            gen_brcondi(dc, eq_ne, cpu_R[RRRN_S], 0,\n\n                    4 + (RRRN_R | ((RRRN_T & 3) << 4)));\n\n        }\n\n        break;\n\n\n\n    case 13: /*ST3n*/\n\n        switch (RRRN_R) {\n\n        case 0: /*MOV.Nn*/\n\n            if (gen_window_check2(dc, RRRN_S, RRRN_T)) {\n\n                tcg_gen_mov_i32(cpu_R[RRRN_T], cpu_R[RRRN_S]);\n\n            }\n\n            break;\n\n\n\n        case 15: /*S3*/\n\n            switch (RRRN_T) {\n\n            case 0: /*RET.Nn*/\n\n                gen_jump(dc, cpu_R[0]);\n\n                break;\n\n\n\n            case 1: /*RETW.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);\n\n                {\n\n                    TCGv_i32 tmp = tcg_const_i32(dc->pc);\n\n                    gen_advance_ccount(dc);\n\n                    gen_helper_retw(tmp, cpu_env, tmp);\n\n                    gen_jump(dc, tmp);\n\n                    tcg_temp_free(tmp);\n\n                }\n\n                break;\n\n\n\n            case 2: /*BREAK.Nn*/\n\n                HAS_OPTION(XTENSA_OPTION_DEBUG);\n\n                if (dc->debug) {\n\n                    gen_debug_exception(dc, DEBUGCAUSE_BN);\n\n                }\n\n                break;\n\n\n\n            case 3: /*NOP.Nn*/\n\n                break;\n\n\n\n            case 6: /*ILL.Nn*/\n\n                gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n                break;\n\n\n\n            default: /*reserved*/\n\n                RESERVED();\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default: /*reserved*/\n\n            RESERVED();\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default: /*reserved*/\n\n        RESERVED();\n\n        break;\n\n    }\n\n\n\n    if (dc->is_jmp == DISAS_NEXT) {\n\n        gen_check_loop_end(dc, 0);\n\n    }\n\n    dc->pc = dc->next_pc;\n\n\n\n    return;\n\n\n\ninvalid_opcode:\n\n    qemu_log(\"INVALID(pc = %08x)\\n\", dc->pc);\n\n    gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);\n\n#undef HAS_OPTION\n\n}\n", "idx": 22421, "substitutes": {"env": ["bc", "priv", "e", "en", "conn", "eu", "config", "iv", "ea", "ef", "dir", "fg", "her", "enc", "dict", "rc", "cb", "usr", "hl", "enter", "inst", "proc", "conf", "kw", "ev", "environment", "ec"], "dc": ["lc", "bc", "fc", "cc", "cd", "disc", "ct", "director", "cm", "d", "pc", "nc", "ac", "da", "mc", "xc", "tc", "rc", "c", "sc", "dm", "fd", "cdn", "jc", "di", "oc", "ec", "DC"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "int kvm_arch_on_sigbus(int code, void *addr)\n\n{\n\n#ifdef KVM_CAP_MCE\n\n    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {\n\n        void *vaddr;\n\n        ram_addr_t ram_addr;\n\n        target_phys_addr_t paddr;\n\n\n\n        /* Hope we are lucky for AO MCE */\n\n        vaddr = addr;\n\n        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||\n\n            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,\n\n                                               &paddr)) {\n\n            fprintf(stderr, \"Hardware memory error for memory used by \"\n\n                    \"QEMU itself instead of guest system!: %p\\n\", addr);\n\n            return 0;\n\n        }\n\n        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);\n\n    } else\n\n#endif /* KVM_CAP_MCE */\n\n    {\n\n        if (code == BUS_MCEERR_AO) {\n\n            return 0;\n\n        } else if (code == BUS_MCEERR_AR) {\n\n            hardware_memory_error();\n\n        } else {\n\n            return 1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 2996, "substitutes": {"code": ["call", "Code", "name", "cycle", "CE", "def", "key", "cc", "charge", "pe", "go", "data", "loc", "co", "type", "nc", "id", "cur", "parent", "end", "frame", "enc", "ode", "ch", "cod", "func", "ec", "fe", "ce", "content", "change", "c", "age", "message", "reason", "ca", "sec", "comment", "seq", "error", "catch", "codes", "coe", "cf", "line", "count", "mode", "val", "desc"], "addr": ["oa", "layer", "call", "route", "arg", "name", "src", "offset", "inter", "conn", "alias", "array", "host", "nn", "url", "localhost", "r", "loc", "ad", "align", "nc", "callback", " address", "ord", "ha", "adr", "arp", "mac", "ac", "coord", "pointer", "func", "address", "ip", "x", "pad", "ptr", "hop", "ref", "Address", "arm", "ar", "attr", "eth", "cmd", "node", "amp", "asm", "point", "amd", "rx", "rt", "mode", "enter", "ast", "ace", "rc"], "vaddr": ["pfunc", "vhost", "vpad", "varg", "upad", "faddress", "vvaddr", "ufunc", "vaddress", "vfunc", "paddress", "vmd", " vmd", "waddr", " vpad", "vvarg", "whost", " vhost", "ppad", " vaddress", "fmd", "uaddr", "fhost", "wmd", "uaddress", "vvhost", "phost", "parg", " vfunc", "farg", "vvaddress", "waddress", "faddr"], "ram_addr": ["ramvaddress", "gram_work", "ram_src", "vm_name", "ramingwork", "ram_host", "vm_host", "gram_ace", "ramingaddress", "gram_src", "ram_name", "ram_address", "gram_pad", "ram_work", "ramingaddr", "ramwaddress", "ram_pad", "gram_addr", "ramwace", "ram_ace", "ramvhost", "ramvname", "gram_address", "vm_address", "ramwaddr", "vm_addr", "ramwsrc", "ramingpad", "ramvaddr"], "paddr": ["vhost", "Paddr", "chost", "jpaddress", "pptr", "faddress", " paddress", "vaddress", "pccap", "paddress", "pcaddress", "Pptr", "porig", "pcaddr", "vcap", "corig", "lpaddr", "vorig", " pcap", "pcap", "lphost", "jpptr", "fptr", "jpeth", "caddr", "phost", "feth", "caddress", "lporig", "lpaddress", "Peth", "Paddress", "jpaddr", "faddr", "peth"]}}
{"project": "FFmpeg", "commit_id": "5a08ba5381cf8d46034440163e71cd95748beceb", "target": 0, "func": "static void decode_interframe_v4(AVCodecContext *avctx, uint8_t *src, uint32_t size)\n\n{\n\n    Hnm4VideoContext *hnm = avctx->priv_data;\n\n    GetByteContext gb;\n\n    uint32_t writeoffset = 0, count, left, offset;\n\n    uint8_t tag, previous, backline, backward, swap;\n\n\n\n    bytestream2_init(&gb, src, size);\n\n\n\n    while (bytestream2_tell(&gb) < size) {\n\n        count = bytestream2_peek_byte(&gb) & 0x1F;\n\n        if (count == 0) {\n\n            tag = bytestream2_get_byte(&gb) & 0xE0;\n\n            tag = tag >> 5;\n\n            if (tag == 0) {\n\n                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);\n\n                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);\n\n            } else if (tag == 1) {\n\n                writeoffset += bytestream2_get_byte(&gb) * 2;\n\n            } else if (tag == 2) {\n\n                count = bytestream2_get_le16(&gb);\n\n                count *= 2;\n\n                writeoffset += count;\n\n            } else if (tag == 3) {\n\n                count = bytestream2_get_byte(&gb) * 2;\n\n                while (count > 0) {\n\n                    hnm->current[writeoffset++] = bytestream2_peek_byte(&gb);\n\n                    count--;\n\n                }\n\n                bytestream2_skip(&gb, 1);\n\n            } else {\n\n                break;\n\n            }\n\n        } else {\n\n            previous = bytestream2_peek_byte(&gb) & 0x20;\n\n            backline = bytestream2_peek_byte(&gb) & 0x40;\n\n            backward = bytestream2_peek_byte(&gb) & 0x80;\n\n            bytestream2_skip(&gb, 1);\n\n            swap   = bytestream2_peek_byte(&gb) & 0x01;\n\n            offset = bytestream2_get_le16(&gb);\n\n            offset = (offset >> 1) & 0x7FFF;\n\n            offset = writeoffset + (offset * 2) - 0x8000;\n\n\n\n            left = count;\n\n\n\n            if (!backward && offset + count >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Attempting to read out of bounds\");\n\n                break;\n\n            } else if (backward && offset >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Attempting to read out of bounds\");\n\n                break;\n\n            } else if (writeoffset + count >= hnm->width * hnm->height) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"Attempting to write out of bounds\");\n\n                break;\n\n            }\n\n\n\n            if (previous) {\n\n                while (left > 0) {\n\n                    if (backline) {\n\n                        hnm->current[writeoffset++] = hnm->previous[offset - (2 * hnm->width) + 1];\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                        offset++;\n\n                    } else {\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                        hnm->current[writeoffset++] = hnm->previous[offset++];\n\n                    }\n\n                    if (backward)\n\n                        offset -= 4;\n\n                    left--;\n\n                }\n\n            } else {\n\n                while (left > 0) {\n\n                    if (backline) {\n\n                        hnm->current[writeoffset++] = hnm->current[offset - (2 * hnm->width) + 1];\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                        offset++;\n\n                    } else {\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                        hnm->current[writeoffset++] = hnm->current[offset++];\n\n                    }\n\n                    if (backward)\n\n                        offset -= 4;\n\n                    left--;\n\n                }\n\n            }\n\n\n\n            if (swap) {\n\n                left         = count;\n\n                writeoffset -= count * 2;\n\n                while (left > 0) {\n\n                    swap = hnm->current[writeoffset];\n\n                    hnm->current[writeoffset] = hnm->current[writeoffset + 1];\n\n                    hnm->current[writeoffset + 1] = swap;\n\n                    left--;\n\n                    writeoffset += 2;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 24677, "substitutes": {"avctx": ["apcontext", "ahctx", "afcas", "ahcontext", "awconnection", "afconnection", "AVloc", "awcontext", "apctx", "awctx", "avcontext", "awcas", "afcontext", "afctx", "AVcb", "ahcas", "afcb", "avconnection", "avloc", "AVctx", "apcb", "aploc", "avcas", "ahconnection", "afloc", "avcb", "AVcontext"], "src": ["sc", "rs", "slice", "sr", "image", "scene", "data", "buffer", "storage", "img", "rb", "filename", "config", "cb", "bc", "inst", "sync", "url", "buf", "rob", "input", "loc", "sub", "lib", "sel", "ctx", "sb", "rc", "channel", "source", "stream", "func", "dest", "sl", "ssl", "secure"], "size": ["esc", "code", "sc", "args", "z", "ize", "c", "empty", "sized", "data", "storage", "sum", "en", "style", "address", "global", "Size", "unit", "SIZE", "max", "loc", "small", "fee", "mode", "sec", "scale", "shape", "length", "six", "timeout", "bytes", "cs", "len"], "hnm": ["hnmos", "wnmm", "hnms", "rnm", "knm", "dnc", "nnl", "rnfm", "wnM", "cnf", "cnmm", "hnf", "wnfm", "knl", "gnM", "hnr", "wnc", "wnm", "gnmm", "dnl", "ennsm", "cnm", "wnmos", "gnm", "nnm", "hnc", "hnfm", "wnms", "nnc", "hnl", "rnms", "rnM", "ennf", "gnf", "wnsm", "dnr", "hnmm", "dnf", "gnc", "hnsm", "cnc", "dnm", "dnmos", "ennm", "ennmos", "wnf", "knr", "knc", "gnfm", "nnr", "dnsm", "hnM", "gnms"], "gb": ["pg", "usb", "gru", "gom", "gs", "cmd", " cd", "lib", "ga", "rg", " camera", "game", " db", "uu", "buff", " storage", " mem", " bi", "gin", "bb", " scene", "storage", " eg", "gpu", " chunk", "tg", "mb", "ko", "binary", "ci", "gp", "git", "gio", "yg", "bm", "g", "gram", "gu", "byte", " co", " img", " rg", "rb", "gal", "gam", "gz", "gy", "region", "db", " rc", "cfg", "gn", " cf", "eb", "gd", "gae", "sb", " channel", " alloc", "cod", "ogg", " gl", " prog", "bf", "py", "bc", "broad", "kb", "hub", " msg", " GC", " conf", " gcc", "ctx", "GB", "rc", " kb", "gl", " gui", "greg", "gh", " disp", "gg", "bg", "gm", "ui", " now", "cgi"], "count": ["use", "call", "batch", "name", "keep", "cat", "time", "base", "label", "bug", "tail", "num", "cast", "max", "start", "Count", "pool", "cond", "number", "level", "current", "part", "limit", "list", "match", "core", "content", "val", "code", "low", "p", "cost", "c", "flag", "sum", "col", "counter", "cycle", "key", "process", "cache", "coll", "large", "len", "carry", "session", "parent", "cc", "more", "length", "connection", "skip", "close", "weight", "type", "id", "catch", "depth", "allow", "loc", "comment", "child", "index", "ind"], "offset": ["ref", "skip", "location", "gap", "slice", "shift", "position", "image", "data", "api", "attribute", "pointer", "align", "next", "address", "type", "error", "Offset", "tail", "sync", "end", "alias", "point", "patch", "o", "padding", "iso", "set", "start", "at", "loc", "fee", "slot", "output", "loss", "sort", "online", "number", "off", "length", "origin", "timeout", "part", "limit", "index", "operation", "alt", "attr", "alpha", "range", "pos", "et", "len", "layer"], "tag": ["use", "ref", "call", "tags", "date", "batch", "name", "cat", "label", "bug", "tail", "character", "word", "number", "hop", "uu", "go", "year", "match", "big", "code", "gap", "user", "option", "cost", "c", "flag", "Tag", "attribute", "sum", "pe", "debug", "port", "key", "patch", "bit", "month", "category", "cache", "feat", "bad", "rule", "ver", "meta", "attr", "block", "byte", "token", "class", "error", "sign", "parent", "length", "ack", "reg", "TAG", "post", "close", "image", "cur", "style", "type", "id", "catch", "loc", "role", "rate", "channel", "co", "round", "loop", "comment", "child", "ag", "format", "eng"], "previous": ["Precision", "reviously", "Previously", " prevert", "forepre", "forevert", "prepre", "reprev", "Preprev", "previously", "Previous", "foretext", "interpre", "recision", "perviously", "perprev", "revious", "prevert", "intervert", "intervious", " pretext", "forevious", "preprev", "percision", "intertext", "pervious", " prepre", "pretext"], "backline": ["worklined", "bookline", "backplane", "backside", "frontlined", " backwrite", "frontwrite", "booklink", "bookplane", "bookside", "frontlines", " backlined", "bottomplane", "firstline", "firstlink", "worklines", "backlink", "bottomline", "bottomlink", "bottomside", "frontline", "firstside", " backlines", "backlined", "backwrite", "firstplane", "workwrite", "backlines", "workline"], "backward": ["Backwards", "frontwards", "backforward", " backforward", "backboard", "BACKwards", "Backline", "frontforward", " backwards", "frontward", " backboard", "frontline", "backwards", "BACKboard", "BACKforward", "Backforward", "Backward", "Backboard", "BACKward"], "swap": [" swapping", "rewap", "chap", "chip", "swave", "swapper", "scapper", " swave", "rewapping", "swip", "rewag", "scap", " swag", " swapper", "Swap", "Swapping", "Swaps", "Swag", " swip", " swaps", "swapping", "swag", "rewaps", "scip", "swaps", "chapper", "chave", "scave"]}}
{"project": "qemu", "commit_id": "068593deea6cc61b06243a33c7fcfadb1650b654", "target": 1, "func": "void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n\n{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    } else {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if (dest != (src + 1)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version crossing pages with byte accesses */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n", "idx": 12946, "substitutes": {"env": ["forge", "proc", "en", "context", "enh", "esp", "queue", "qa", "enc", "ea", "ench", "config", "cdn", "priv", "iv", "eu", "ah", "style", "kn", "er", "vm", "init", "gear", "server", "v", "conn", "np", "console", "loader", "energy", "e", "equ", "viron", "exc", "info", "engine", "buf", "net", "eng", "tern", "her", "qt", "Environment", "assets", "dep", "export", "eni", "shell", "dt", "here", "atten", "que", "exec", "db", "ev", "vel", "ec", "chal", "stack", "hess", "environment", "el", "fen", "opt", "ctx", "esi", "esm"], "l": ["ln", "m", "nl", "lin", "d", "fl", "t", "level", "lc", "g", "source", "dl", "lp", "h", "x", "lang", "lit", "loc", "v", "o", "ul", "w", "layer", "ll", "la", "p", "lr", "kl", "z", "u", "s", "e", "li", "k", "b", "j", "L", "n", "f", "length", "line", "rl", "c", "shell", "url", "il", "ol", "lu", "ell", "sl", "ls", "al", "lb", "el", "len"], "dest": ["future", "proc", "dist", "delete", "priv", "bound", "other", "loc", "dev", "temp", "pl", "end", "attr", "text", "transform", "Dest", "class", "prop", "destroy", "st", "comb", "south", "head", "vision", "done", "slice", "d", "seed", "cdn", "home", "sup", "lc", "front", "lower", "di", "txt", "dir", "session", "grad", "img", "resource", "du", "data", "wb", "b", "inst", "origin", "url", "route", "gen", "cont", "uv", "wd", "path", "gz", "config", "again", "source", "null", "lit", "secure", "master", "output", "desc", "dep", "diff", "usr", "uc", "tmp", " destination", "shift", "name", "ident", "later", "v", "gl", "de", "feat", "sign", "trans", "store", "dat", "dc", "norm", "target", "ssl", "rest", "coord", "opt", "start"], "src": ["rib", "proc", "remote", "bc", "dist", "fl", "low", "image", "sth", "project", "gin", "loc", "ul", "rb", "cb", "sn", "sc", "sl", "sur", "sub", "ruby", "st", "vision", "slice", "sync", "rc", "iv", "sup", "lc", "front", "req", "sr", "img", "resource", "s", "b", "inst", "length", "url", "r", "ource", "support", "username", "filename", "sys", "gz", "config", "source", "null", "lit", "gn", "view", "download", "sec", "desc", "sb", "gb", "rl", "rob", "sh", "SOURCE", "sel", "cur", "bl", "RC", "connect", "uc", "hl", "stream", "back", "uri", "gl", "feat", "nil", "target", "ssl", "rest", "start"], "i": ["hi", "qi", "it", "ui", "m", "I", "d", "t", "ni", "ai", "xi", "id", "ini", "gi", "iu", "my", "io", "mu", "ci", "x", "di", "si", "ie", "ii", "v", "uri", "o", "yi", "u", "z", "p", "e", "fi", "mi", "li", "b", "ix", "j", "L", "n", "f", "phi", "ti", "ip", "c", "ji", "pi", "bi", "ri", "zi", "y", "index"]}}
{"project": "qemu", "commit_id": "641bb63cd6b003ab0ca2e312a014449037d71647", "target": 0, "func": "static int inc_refcounts(BlockDriverState *bs,\n\n                         BdrvCheckResult *res,\n\n                         uint16_t *refcount_table,\n\n                         int64_t refcount_table_size,\n\n                         int64_t offset, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k;\n\n\n\n    if (size <= 0) {\n\n        return 0;\n\n    }\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= refcount_table_size) {\n\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n\n                \"the end of the image file, can't properly check refcounts.\\n\",\n\n                cluster_offset);\n\n            res->check_errors++;\n\n        } else {\n\n            if (++refcount_table[k] == 0) {\n\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9072, "substitutes": {"bs": ["vs", "ts", "bb", "ds", "src", "b", "gs", "iss", "ls", "pb", "qs", "cb", "gb", "ins", "bits", "rb", "outs", "rs", "js", "BS", "bc", "os", "cs", "bl", "es", "sync", "bh", "fps", "bis", "ns", "sb", "blocks", "ms", "ps", "fs", "ses", "css", "ss", "bos"], "res": ["vals", "des", "arr", "rem", "Res", "nos", "val", "RS", "def", "RES", "resolution", "gr", "ress", "obj", "ros", "reg", "pers", "Rs", "rss", "args", "rs", "js", "cs", "pres", "ras", "rc", "response", "r", "req", "err", "results", "details", "spec", "rus", "ms", "re", "sys", "ons", "params", "rez", "ps", "ret", "result", "rev", "ch", "resp", "rh", "ex"], "refcount_table": ["refcompPtype", "refcountttype", "refcomp_type", "refcountstab", "refcache2cache", "refcompPmap", "refcountslist", "refcountPtable", "refcomp_table", "refcache_table", "refcountscache", "refcount_list", "refcount2list", "refcount_cache", "refcompPtable", "refcount2table", "refcache_list", "refcompPcache", "refcountPcache", "refcounttcache", "refcount2tab", "refcomp_map", "refcache_tab", "refcountstable", "refcache2list", "refcountsmap", "refcomp_cache", "refcache2tab", "refcounttmap", "refcount_map", "refcount2cache", "refcountPmap", "refcountttable", "refcountPtype", "refcount_tab", "refcountstype", "refcount_type", "refcache_cache", "refcache2table"], "refcount_table_size": ["refcount_cache_scale", "refcount_cache_small", "refcount_table2small", "refcount_tab_num", "refcount_table2num", "refcount_cache_size", "refcount_tab_small", "refcount_table_small", "refcount_tab_size", "refcount_table2size", "refcount_table_num", "refcount_table_scale"], "offset": ["alias", "element", "location", "reference", "ui", "base", "optional", "initial", "prefix", "origin", "shift", "pointer", "i", "slot", "limit", "ref", "addr", "adjust", "p", "iterator", "set", "starting", "off", "loc", "activity", "padding", "next", "entry", "zero", "slice", "index", "edge", "align", "end", "address", "first", "part", "position", "error", "tail", "online", "pos", "gap", "length", "Offset", "transfer", "reset"], "size": ["count", "needed", "score", "timeout", "scale", "n", "len", "capacity", "small", "ey", "SIZE", "send", "shift", "c", "max", "e", "ish", "se", "set", "loc", "empty", "Size", "sec", "code", "cs", "unit", "sync", "name", "six", "sized", "end", "address", "storage", "form", "cm", "ci", "length", "cache", "use", "ize", "sc", "range", "fee"], "s": ["l", "ts", "ds", "is", "g", "si", "its", "stats", "http", "b", "t", "d", "gs", "sa", "c", "i", "p", "ls", "e", "qs", "se", "outs", "rs", "sq", "js", "os", "f", "args", "cs", "sym", "o", "sets", "S", "es", "sync", "south", "states", "sl", "state", "services", "r", "sb", "ns", "spec", "less", "sys", "ions", "ses", "ps", "site", "a", "ss", "settings", "ssl"], "start": ["count", "base", "scale", "started", "info", "id", "open", "shift", "ad", "from", "max", "work", "ace", "se", "ish", "set", "skip", "before", "starting", "off", "stop", "step", "st", "Start", "next", "ie", "index", "min", "ind", "state", "cur", "end", "address", "first", "part", "art", "check", "error", "get", "grade", "init", "type", "pos", "back", "range"], "last": ["parent", "count", "needed", "later", "base", "est", "Last", "low", "total", "latest", "from", "max", "prev", "close", "p", "se", "before", "final", "loc", "empty", "st", "next", "j", "scope", "nd", "end", "cur", "old", "full", "first", "ending", "after", "ast", "cycle", "use", "length", "so", "since", "range"], "cluster_offset": ["cluster__off", "clust_size", "clructure_size", "cluster67offset", "clandra_prefix", "cluster_entry", "clructure_offset", "clust_offset", "cluster_off", "cluster_prefix", "clance_address", "clance67offset", "clusterPoff", "clust_option", "clust_pos", "cluster67size", "cluster8offset", "clructure_index", "clructure_limit", "cluster_object", "clance_offset", "cluster67off", "cluster_position", "cluster8route", "cluster8address", "clance67limit", "cluster_option", "cluster67limit", "cluster_error", "cluster__offset", "clandra_offset", "clandra_size", "cluster_address", "cluster_start", "cluster_size", "clusterPaddress", "clance_route", "cluster8off", "clust_optional", "clance67off", "clandra_error", "clust_entry", "cluster_index", "cluster_optional", "clance_off", "clust_position", "clancePaddress", "clust_start", "cluster_route", "clusterPoffset", "clance_size", "clusterProute", "clance67size", "cluster_pos", "clancePoffset", "cluster_limit", "clanceProute", "cluster__route", "clancePoff", "clance_limit", "cluster__address", "clust_object"], "k": ["count", "ek", "ku", "ks", "n", "g", "key", "w", "id", "x", "b", "d", "i", "c", "max", "p", "work", "ka", "e", "number", "q", "kat", "f", "sk", "ak", "j", "o", "kid", "ck", "ky", "ik", "r", "end", "ki", "kn", "ask", "K", "uk", "ko", "unk", "ke", "kw", "u", "length", "y", "ch", "kick", "ok", "kk", "range"], "check_errors": ["update__results", "update__errors", "update_error", "check_error", "update__dates", "update__error", "check__dates", "check__results", "check__error", "check_results", "update_dates", "update_results", "check__errors", "update_errors", "check_dates"], "corruptions": ["disruptances", "corregients", "corrictients", "coremptes", "disruptes", "disrictients", "disrictances", "disruptions", "coremptients", "corrictances", "corruptances", "corregions", "correges", "corregances", "corrictes", "coremptances", "disrictes", "disruptients", "disrictions", "coremptions", "corrictions", "corruptes", "corruptients"]}}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static void json_message_process_token(JSONLexer *lexer, GString *input,\n\n                                       JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    QDict *dict;\n\n\n\n    switch (type) {\n\n    case JSON_LCURLY:\n\n        parser->brace_count++;\n\n        break;\n\n    case JSON_RCURLY:\n\n        parser->brace_count--;\n\n        break;\n\n    case JSON_LSQUARE:\n\n        parser->bracket_count++;\n\n        break;\n\n    case JSON_RSQUARE:\n\n        parser->bracket_count--;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    qdict_put(dict, \"token\", qstring_from_str(input->str));\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += input->len;\n\n\n\n    g_queue_push_tail(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     */\n\n    json_message_free_tokens(parser);\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    /* parser->emit takes ownership of parser->tokens.  */\n\n    parser->emit(parser, parser->tokens);\n\n    parser->tokens = g_queue_new();\n\n    parser->token_size = 0;\n\n}\n", "idx": 9619, "substitutes": {"lexer": ["Lexeder", "Lexe", "licers", "ntaxera", "cloder", "Lexer", "loge", "visioner", "lexeder", "licer", "visione", "visionator", "clator", "Lexoder", " lexers", "ntaxer", "cler", "Lexker", "lexe", "ntaxe", "ntaxker", "Lexator", "Lexers", "logker", "lexers", " lexeder", "logera", "cle", "visionoder", "lexker", "Lexera", "lexoder", " lexe", "liceder", "loger", "lexera", "lexator", "lice"], "input": ["element", "session", "Input", "argument", "context", "field", "source", "view", "temp", "model", "instance", "data", "expression", "config", "output", "reader", "qa", "xml", "request", "array", "op", "select", "resource", "inc", "format", "current", "query", "magic", "state", "raw", "ctx", "inner", "document", "token", "storage", "list", "form", "import", "image", "text", "inf", "expr", "buffer"], "type": ["parent", "kind", "level", "field", "str", "class", "key", "info", "method", "id", "like", "t", "by", "i", "post", "Type", "data", "python", "time", "p", "block", "set", "pe", "value", "action", "style", "number", "types", "op", "code", "call", "o", "version", "shape", "py", "size", "format", "name", "state", "pre", "ty", "token", "sort", "part", "ping", "error", "spec", "TYPE", "handler", "year", "length", "ype", "typ", "direction"], "x": ["l", "n", "in", "key", "w", "xx", "m", "id", "t", "b", "z", "d", "i", "c", "data", "X", "p", "ix", "e", "number", "xs", "xxx", "f", "code", "size", "index", "v", "name", "xt", "h", "on", "length", "ex"], "y": ["ym", "ady", "oy", "n", "ry", "key", "ny", "w", "id", "xx", "t", "ey", "z", "vy", "ye", "i", "ys", "cy", "p", "iy", "yi", "ay", "zy", "xxx", "yy", "sy", "j", "gy", "o", "py", "sky", "ery", "Y", "sys", "year", "ya", "length", "dy", "yo"], "parser": ["parent", "lp", "operator", "enter", "worker", "json", "tree", "http", "pool", "block", "python", "config", "script", "xml", "txt", "lex", "er", "code", "document", "spec", "init", "self", "seed", "buffer", "author", "php", "missing", "arser", "instance", "post", "player", "rule", "s", "jack", "before", "value", "args", "slice", "ars", "magic", "winner", "loader", "token", "storage", "above", "list", "root", "plugin", "this", "layer", "handler", "general", "file", "join", "holder", "wp", "g", "test", "builder", "data", "local", "writer", "entry", "master", "ger", "part", "super", "node", "copy", "sys", "command", "message", "Parser", "man", "pass", "argument", "comment", "ring", "processor", "pack", "lower", "p", "reader", "server", "upper", "private", "star", "manager", "parse", "paragraph", "gg", "pillar", "inner", "der", "book"], "dict": ["diff", "map", "dot", "conf", "session", "arr", "di", "fix", "str", "comment", "auth", "dog", "record", "json", "tree", "info", "model", "def", "d", "doc", "data", "sum", "config", "reader", "obj", "package", "bug", "table", "coll", "df", "array", "dr", "code", "db", "dir", "slice", "module", "parse", "response", "pillar", "state", "document", "dd", "patch", "hash", "list", "copy", "init", "pair", "cat", "der", "clean", "file", "cache", "ict", "result", "pkg", "database"], "brace_count": ["brace_part", "brace\u00b7left", "option_amount", "plate_left", "plate\u00b7part", "line_size", "braceacoffset", "brace_cell", "brace\u00b7cast", "plate_count", "line_length", "brace_size", "brace_length", "line_catch", "brace_index", "line_const", "brace_min", "braceaccount", "brace_len", "brace\u00b7part", "option_offset", "brace\u00b7depth", "brace\u00b7count", "brace_left", "option_length", "braceanceleft", "braceancecast", "brace_cast", "braceancepart", "braceancecount", "brace\u00b7size", "line_index", "braceacsize", "line_min", "plate\u00b7left", "line_cell", "brace_catch", "plate\u00b7count", "plate\u00b7cast", "brace_depth", "plate_cast", "braceacamount", "braceacmin", "line_len", "brace_const", "brace\u00b7min", "line_count", "plate_part", "line_depth", "braceacdepth", "option_count", "brace_amount", "brace_offset", "braceaclength"], "bracket_count": ["bracket_code", "bracket_age", "bracket9weight", "bracket_length", "brace_code", "bracket9order", "brace_size", "brace_length", "bracket9count", "bracketercount", "brace_age", "brace_len", "bracketersize", "brace_order", "bracketerdepth", "brace_weight", "bracket_size", "bracket_weight", "bracket_depth", "bracket_order", "brace_depth", "bracket9length", "bracket_len"]}}
{"project": "FFmpeg", "commit_id": "40cf1bbacc6220a0aa6bed5c331871d43f9ce370", "target": 0, "func": "static int libschroedinger_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                                        const AVFrame *frame, int *got_packet)\n\n{\n\n    int enc_size = 0;\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n    SchroEncoder *encoder = p_schro_params->encoder;\n\n    struct FFSchroEncodedFrame *p_frame_output = NULL;\n\n    int go = 1;\n\n    SchroBuffer *enc_buf;\n\n    int presentation_frame;\n\n    int parse_code;\n\n    int last_frame_in_sequence = 0;\n\n    int pkt_size, ret;\n\n\n\n    if (!frame) {\n\n        /* Push end of sequence if not already signalled. */\n\n        if (!p_schro_params->eos_signalled) {\n\n            schro_encoder_end_of_stream(encoder);\n\n            p_schro_params->eos_signalled = 1;\n\n        }\n\n    } else {\n\n        /* Allocate frame data to schro input buffer. */\n\n        SchroFrame *in_frame = libschroedinger_frame_from_data(avctx, frame);\n\n        if (!in_frame)\n\n            return AVERROR(ENOMEM);\n\n        /* Load next frame. */\n\n        schro_encoder_push_frame(encoder, in_frame);\n\n    }\n\n\n\n    if (p_schro_params->eos_pulled)\n\n        go = 0;\n\n\n\n    /* Now check to see if we have any output from the encoder. */\n\n    while (go) {\n\n        int err;\n\n        SchroStateEnum state;\n\n        state = schro_encoder_wait(encoder);\n\n        switch (state) {\n\n        case SCHRO_STATE_HAVE_BUFFER:\n\n        case SCHRO_STATE_END_OF_STREAM:\n\n            enc_buf = schro_encoder_pull(encoder, &presentation_frame);\n\n            if (enc_buf->length <= 0)\n\n                return AVERROR_BUG;\n\n            parse_code = enc_buf->data[4];\n\n\n\n            /* All non-frame data is prepended to actual frame data to\n\n             * be able to set the pts correctly. So we don't write data\n\n             * to the frame output queue until we actually have a frame\n\n             */\n\n            if ((err = av_reallocp(&p_schro_params->enc_buf,\n\n                                   p_schro_params->enc_buf_size +\n\n                                   enc_buf->length)) < 0) {\n\n                p_schro_params->enc_buf_size = 0;\n\n                return err;\n\n            }\n\n\n\n            memcpy(p_schro_params->enc_buf + p_schro_params->enc_buf_size,\n\n                   enc_buf->data, enc_buf->length);\n\n            p_schro_params->enc_buf_size += enc_buf->length;\n\n\n\n\n\n            if (state == SCHRO_STATE_END_OF_STREAM) {\n\n                p_schro_params->eos_pulled = 1;\n\n                go = 0;\n\n            }\n\n\n\n            if (!SCHRO_PARSE_CODE_IS_PICTURE(parse_code)) {\n\n                schro_buffer_unref(enc_buf);\n\n                break;\n\n            }\n\n\n\n            /* Create output frame. */\n\n            p_frame_output = av_mallocz(sizeof(FFSchroEncodedFrame));\n\n            if (!p_frame_output)\n\n                return AVERROR(ENOMEM);\n\n            /* Set output data. */\n\n            p_frame_output->size     = p_schro_params->enc_buf_size;\n\n            p_frame_output->p_encbuf = p_schro_params->enc_buf;\n\n            if (SCHRO_PARSE_CODE_IS_INTRA(parse_code) &&\n\n                SCHRO_PARSE_CODE_IS_REFERENCE(parse_code))\n\n                p_frame_output->key_frame = 1;\n\n\n\n            /* Parse the coded frame number from the bitstream. Bytes 14\n\n             * through 17 represesent the frame number. */\n\n            p_frame_output->frame_num = AV_RB32(enc_buf->data + 13);\n\n\n\n            ff_schro_queue_push_back(&p_schro_params->enc_frame_queue,\n\n                                     p_frame_output);\n\n            p_schro_params->enc_buf_size = 0;\n\n            p_schro_params->enc_buf      = NULL;\n\n\n\n            schro_buffer_unref(enc_buf);\n\n\n\n            break;\n\n\n\n        case SCHRO_STATE_NEED_FRAME:\n\n            go = 0;\n\n            break;\n\n\n\n        case SCHRO_STATE_AGAIN:\n\n            break;\n\n\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unknown Schro Encoder state\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* Copy 'next' frame in queue. */\n\n\n\n    if (p_schro_params->enc_frame_queue.size == 1 &&\n\n        p_schro_params->eos_pulled)\n\n        last_frame_in_sequence = 1;\n\n\n\n    p_frame_output = ff_schro_queue_pop(&p_schro_params->enc_frame_queue);\n\n\n\n    if (!p_frame_output)\n\n        return 0;\n\n\n\n    pkt_size = p_frame_output->size;\n\n    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0)\n\n        pkt_size += p_schro_params->enc_buf_size;\n\n    if ((ret = ff_alloc_packet(pkt, pkt_size)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet of size %d.\\n\", pkt_size);\n\n        goto error;\n\n    }\n\n\n\n    memcpy(pkt->data, p_frame_output->p_encbuf, p_frame_output->size);\n\n    avctx->coded_frame->key_frame = p_frame_output->key_frame;\n\n    /* Use the frame number of the encoded frame as the pts. It is OK to\n\n     * do so since Dirac is a constant frame rate codec. It expects input\n\n     * to be of constant frame rate. */\n\n    pkt->pts =\n\n    avctx->coded_frame->pts = p_frame_output->frame_num;\n\n    pkt->dts = p_schro_params->dts++;\n\n    enc_size = p_frame_output->size;\n\n\n\n    /* Append the end of sequence information to the last frame in the\n\n     * sequence. */\n\n    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0) {\n\n        memcpy(pkt->data + enc_size, p_schro_params->enc_buf,\n\n               p_schro_params->enc_buf_size);\n\n        enc_size += p_schro_params->enc_buf_size;\n\n        av_freep(&p_schro_params->enc_buf);\n\n        p_schro_params->enc_buf_size = 0;\n\n    }\n\n\n\n    if (p_frame_output->key_frame)\n\n        pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\nerror:\n\n    /* free frame */\n\n    libschroedinger_free_frame(p_frame_output);\n\n    return ret;\n\n}\n", "idx": 21641, "substitutes": {"avctx": ["avcam", "afcoll", "awcontext", "avecoll", "avecca", "AVcmd", " avcoll", "avecam", "afcam", "awcfg", "avcca", "avconn", "afcmd", "afctx", "AVcontext", "avcoll", "awconn", "avecfg", "avecontext", "awctx", "avcontext", "avcfg", "AVconn", "avectx", "avcmd", "afcontext", "AVctx", " avcam", "afconn", "afcca", " avcontext", "afcfg", "awcmd", "awcca"], "pkt": ["Packet", "cpet", " pct", " packet", "Pct", " pet", "pct", "Pkt", "packet", "pet", "Pet", "cpkt", "cpct", "cpacket"], "frame": ["row", "e", "iframe", "object", "config", "event", "none", "part", "kt", "framework", "fb", "file", "feature", "process", "node", "function", "f", "buffer", "fake", "motion", " Frame", "data", "zip", "component", "setup", "code", "fe", "fr", "frames", "cfg", "dom", "module", "document", "window", "rame", "seq", "channel", "call", "slice", "flow", "element", "game", "base", "Frame", "range", "fram", "image", "block", "position", "fi"], "got_packet": ["got2compacket", "got2packacket", "got_packsET", "got2packet", "got_compet", "got_compacket", "got2competer", "got_octET", "got_octeter", "got2compet", "got_packset", "got_packET", "got2packET", "got_packsacket", "got_octacket", "got_packeter", "got_packacket", "got_compET", "got2compET", "got2packeter", "got_packseter", "got_octet", "got_competer"], "p_schro_params": ["p_schrob_remote", "p_schro5resources", "p_schroPDchanges", "p_schrotparam", "p_schros_resources", "p_schrosparams", "p_schro__manager", "p_schoreappparam", "p_schro2params", "p_schro2manager", "p_schroappmanager", "p_schrotparams", "p_Sch\n", "p_schros_params", "p_schro5args", "p_schro2param", "p_schrob_param", "p_schrob_params", "p_schoreappsource", "p_schroPDparams", "p_schro_ams", "p_schroapprequest", "p_schro_args", "p_schro_changes", "p_schoreappparams", "p_schroPDrequest", "p_schore_source", "p_ch\n", "p_schroappphys", "p_schro__settings", "p_schore_phys", "p_schro__param", "p_schore_params", "p_sch\n", "p_schro5params", "p_schro5manager", "p_schro_source", "p_schro_remote", "p_schrob_manager", "p_schros_connection", "p_schroappremote", "p_schros_args", "p_schro_data", "p_schrosresources", "p_schrob_ams", "p_schros_manager", "p_schroappsource", "p_schro__params", "p_schros_settings", "p_schro_resources", "p_schrosparam", "p_schro_param", "p_schros_request", "p_schro2ams", "p_schroappparams", "p_schrotmanager", "p_schroappparam", "p_schrob_resources", "p_schoreappphys", "p_schrotconnection", "p_schros_param", "p_schro_settings", "p_schore_param", "p_schro_phys", "p_schro_request", "p_schrossettings", "p_schro_connection", "p_sche\n", "p_schroappchanges", "p_schro_manager", "p_schros_changes", "p_schrob_data", "p_schroPDmanager"], "encoder": ["engoder", "ecode", "encader", "incoser", " encoster", "enryption", " encoded", "ecoder", "decader", "encoding", "engoding", "encator", "engoded", "incator", "enoder", "enoding", "enader", "enler", "enater", "decoding", "engader", "encoster", " encode", "encler", "encode", " encoding", "encoser", "encater", "enoser", "incoding", "ecator", "enator", "engode", "incoder", "ecler", "decler", "enode", "engoster", "ecoser", "encoded", "enoded", "decoded", " encryption", "decoder", "encryption", "decator", "ecoded", "ecoding", " encater", "engryption", " encator", "decode", "decoster", "engater"], "p_frame_output": ["p_frame_input", "p_fram_full", "p_fram_output", "p_frame_data", "p_fram_input", "p_fram_data", "p_frame_full"], "enc_buf": ["enc_window", "enc__data", "enc_uf", " enc_uf", "enc_config", "encxbuff", "encJqueue", "ec_buffer", "enc_box", "en_cb", "enc_vec", " enc_buff", "ec_buf", "encJheader", "en_buf", "enc__buffer", "enc_bag", "pc_buf", "en_uf", "en_buff", "enc_db", " enc_func", "encswindow", "enc2uf", " enc_db", "enc2cb", "encxconfig", "encxbuf", "encscb", "enc_queue", "encxdata", "pc_cb", "enc_buffer", " enc_config", "ec_queue", "encsbuf", "enc2buf", " enc_bag", "enc_buff", "pc_vec", " enc_box", "encsvec", "enc__buff", "ec_data", " enc_data", "ec_bag", "encJdata", "enc__buf", "enc_func", "enc__uf", "enc__bag", "ec_header", "enc_cb", "pc_window", "enc_data", "enc_header", "enc2buff", "encJbuf", " enc_cb", " enc_buffer"], "presentation_frame": ["presentation_fram", "presentation_sequence", "presentational_frames", "presentationamFrame", "presentationamnode", "presentationamframe", "presentational_sequence", "presentational_node", "presentational_Frame", "presentational_frame", "presentation_node", "presentational_fram", "presentation_frames", "presentation_Frame", "presentationamframes"], "parse_code": ["parse_codes", "parse2code", "parse2tag", "parseableinfo", " parse_data", "parserablecount", "parse_tag", "parse2codes", "parse_queue", "parseablecount", " parse_tag", "parse_count", "parserablecode", "parse___code", "parserablequeue", " parse2code", "parseablecode", " parse2tag", "parser_code", "parserableinfo", "parseablequeue", "parse_info", "parse___count", "parse_data", "parser_info", "parse___queue", "parser_queue", "parse___info", "parser_count", " parse_codes", "parse2data", " parse2data", " parse2codes"], "pkt_size": ["pet_name", "pkt_name", "pkt_len", "pet_len", "pet_size"], "ret": ["status", "reg", "def", "std", "result", "val", "progress", "rx", "rec", "msg", "res", "fin", "arr", "success", "rc", "lo", "run", "RET", "reply", "seq", "proc", "orig", "fi", "resp", "fun"], "in_frame": [" in_story", " in_motion", "in__window", "in_message", "in__frame", " in_window", "in_point", "inamframe", "inammessage", " in_sample", "in_window", "in_story", "in_sample", " in_message", "in_fram", " in_fram", "in_motion", "in__story", " in_point", "in__fram", "inammotion"], "err": ["status", "str", "e", "asm", "ind", "result", "val", "mode", "der", "Er", "rr", "f", "order", "op", "r", "msg", "bug", "init", "opt", "risk", "arr", "act", "id", "code", "rh", "count", "var", "addr", "rc", "dr", "out", "fe", "num", "rule", "arm", "usr", "error", "Error", "magic", "er", "erg", "loc", "gr", " Err", "mr", "req", "ner", "rage", "conf", "orig", "ise", "h", "attr", "type"], "state": ["status", "str", "step", "reg", "State", " State", "e", "class", "name", "kind", "next", "STATE", "event", "config", "val", "part", "mode", "key", "style", "use", "stat", "new", "act", "code", "work", "sync", "comment", "open", "action", "tag", "run", "go", "set", "rule", "error", "session", "states", "stage", "are", "instance", "resource", "scope", "this", " STATE", "type"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int vnc_validate_certificate(struct VncState *vs)\n\n{\n\n    int ret;\n\n    unsigned int status;\n\n    const gnutls_datum_t *certs;\n\n    unsigned int nCerts, i;\n\n    time_t now;\n\n\n\n    VNC_DEBUG(\"Validating client certificate\\n\");\n\n    if ((ret = gnutls_certificate_verify_peers2 (vs->tls_session, &status)) < 0) {\n\n\tVNC_DEBUG(\"Verify failed %s\\n\", gnutls_strerror(ret));\n\n\treturn -1;\n\n    }\n\n\n\n    if ((now = time(NULL)) == ((time_t)-1)) {\n\n\treturn -1;\n\n    }\n\n\n\n    if (status != 0) {\n\n\tif (status & GNUTLS_CERT_INVALID)\n\n\t    VNC_DEBUG(\"The certificate is not trusted.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n\n\t    VNC_DEBUG(\"The certificate hasn't got a known issuer.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_REVOKED)\n\n\t    VNC_DEBUG(\"The certificate has been revoked.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_INSECURE_ALGORITHM)\n\n\t    VNC_DEBUG(\"The certificate uses an insecure algorithm\\n\");\n\n\n\n\treturn -1;\n\n    } else {\n\n\tVNC_DEBUG(\"Certificate is valid!\\n\");\n\n    }\n\n\n\n    /* Only support x509 for now */\n\n    if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509)\n\n\treturn -1;\n\n\n\n    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))\n\n\treturn -1;\n\n\n\n    for (i = 0 ; i < nCerts ; i++) {\n\n\tgnutls_x509_crt_t cert;\n\n\tVNC_DEBUG (\"Checking certificate chain %d\\n\", i);\n\n\tif (gnutls_x509_crt_init (&cert) < 0)\n\n\t    return -1;\n\n\n\n\tif (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_expiration_time (cert) < now) {\n\n\t    VNC_DEBUG(\"The certificate has expired\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_activation_time (cert) > now) {\n\n\t    VNC_DEBUG(\"The certificate is not yet activated\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_activation_time (cert) > now) {\n\n\t    VNC_DEBUG(\"The certificate is not yet activated\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tgnutls_x509_crt_deinit (cert);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6243, "substitutes": {"vs": ["verts", "v", "http", "s", "alls", "va", "session", "vt", "ums", "VS", "ses", "services", "sts", "xs", "vals", "sk", "ants", "ns", "server", "ls", "iss", "bs", "ss", "cs", "hs", "sb", "gs", "ks", "ops", "ds", "qs", "ts", "ils", "settings", "vers", "vp", "sv", "fs", "changes", "os", "ms", "env", "vc", "es", "rs", "versions", "manager", "ps"], "ret": ["stat", "base", "er", "flag", "sr", "reg", "mem", "al", " success", "alt", "iter", "rt", "progress", "value", "pre", "val", "tr", "rc", "info", "reply", "ll", "pret", "repl", "f", "lit", "job", "att", "pet", " resp", "obj", "res", "len", "det", "RET", "rev", "result", " result", "Ret", "ft", "ut", "re", "fail", "fun", " fut", "detail", "back", "resp", "Status", "success", "ref", " r", "r", "rets"], "status": ["stat", "login", "name", "gc", "flag", "sr", "sec", "id", "complete", "spec", "progress", "note", "security", "session", "update", "skip", "si", "sync", "style", "sys", "info", "speed", "html", "content", "f", "state", "server", "wait", "version", "active", "grade", "service", "stats", "match", "reason", "confirmed", "code", "error", "sb", "comment", "message", "received", "sign", "err", "str", "score", "result", "seq", "source", "temp", "rate", "ity", "settings", "stage", "sp", "fs", "ssl", "type", "Status", "success", "current", "git", "index", "site", "date", "summary", "flags", "msg"], "certs": ["Certd", "privp", "privs", "signp", "certls", "Certb", "Certp", " certes", "Certi", "Certls", " certls", "certb", "Certs", "signb", "certp", "signls", "reqs", "certes", "signes", "privd", "prives", "reqp", "reqd", "reqes", "reqb", "signi", "Certes", "signs", "certd", " certi", "certi"], "nCerts": [" nCertd", "pCertis", "nCertis", " nCuri", "nCookis", "pcertes", "pcertp", "nSigni", "nCookes", "ncertes", "nCurc", "pCertp", "nCookp", "nSignn", " nCurd", "nCertn", "pCertes", " nCertc", "ncertd", "pCerts", "nCerti", "nCertes", "ncerti", "nSignp", " nCurs", "ncerts", "nCuri", " nCertns", "nSignes", "nCertc", "nLogd", "ncertis", " nCerti", "ncertp", "nCooks", "nLogs", "nSignns", "ncertn", "pcertis", "nSigns", "nLogi", "pcerts", "nCertp", " nCurc", "nSignis", "nCertd", "nCurd", "ncertc", "nCertns", "nCurs", "ncertns", " nCertn", "nLogc"], "i": ["gi", "ti", "v", "id", "I", "di", "ci", "ni", "xi", "ri", "si", "io", "slice", "b", "info", "bi", "qi", "ix", "inc", "l", "yi", "pi", "f", "phi", "j", "ii", "iu", "d", "it", "ai", "u", "e", "t", "n", "multi", "mi", "ini", "ie", "p", "mini", "h", "eni", "z", "sup", "ind", "ip", "c", "g", "y", "type", "li", "fi", "index", "zi", "ui"], "now": ["function", "time", "st", "no", "gm", "id", "md", "not", "parent", "v", "since", "omp", "session", "get", " current", "or", "comp", "NOW", "night", "today", "at", "wait", "j", "length", " NOW", "create", "from", "Now", "low", "created", "func", "day", "df", "after", "ctx", " Now", "self", "result", "old", "this", "start", "import", "new", "mm", "off", "type", "current", "next", "form", "age", "date", "max", "size"], "cert": ["cp", "name", "ch", "cur", "alt", "pr", "dat", "chain", "config", "val", "non", "secret", "ificate", "cat", "dest", "pt", "trust", "key", " Cert", "resource", "cl", "valid", "ext", "Cert", "order", "url", "j", "sl", "ctr", "ert", "ce", "crit", "priv", "sign", "fac", "err", "str", "pub", "temp", "ca", "req", "font", "opt", "sp", "ver", "gen", "ind", "cand", "ssl", "class", "type", "cf", "user", "br", "pair", "pl", "cot", "cel"]}}
{"project": "qemu", "commit_id": "442773cef15092b5927851237850760345d2cf16", "target": 0, "func": "void qmp_migrate_set_speed(int64_t value, Error **errp)\n\n{\n\n    MigrationState *s;\n\n\n\n    if (value < 0) {\n\n        value = 0;\n\n    }\n\n\n\n    s = migrate_get_current();\n\n    s->bandwidth_limit = value;\n\n    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);\n\n}\n", "idx": 8409, "substitutes": {"value": ["count", "score", "Value", "timeout", "rate", "scale", "start", "val", "window", "key", "media", "test", "id", "total", "num", "update", "create", "data", "max", "p", "limit", "set", "number", "flow", "unit", "values", "size", "index", "try", "v", "format", "current", "min", "name", "end", "age", "function", "grade", "property", "offset", "type", "change", "message", "complete", "image", "length", "weight", "VALUE", "fee"], "errp": ["erp", "err", " errlp", "errpc", "nerr", "erlp", " errpc", "nerp", "erpc", " errr", "errlp", "errr", "nerlp", "nerpc"], "s": ["l", "conf", "session", "sg", "ts", "ds", "si", "g", "your", "sf", "stats", "m", "ops", "i", "gs", "service", "c", "p", "ls", "qs", "status", "e", "args", "js", "rs", "f", "os", "cs", "sym", "o", "aws", "sets", "S", "es", "sync", "states", "sl", "services", "state", "new", "ns", "sb", "u", "sys", "self", "rates", "ips", "params", "ses", "fs", "su", "ps", "ss", "settings", "ssl"]}}
{"project": "FFmpeg", "commit_id": "5674d4b0a35a34b75e3533a8580e0b5a0a8895a7", "target": 0, "func": "static int mpc8_decode_frame(AVCodecContext * avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MPCContext *c = avctx->priv_data;\n\n    GetBitContext gb2, *gb = &gb2;\n\n    int i, j, k, ch, cnt, res, t;\n\n    Band *bands = c->bands;\n\n    int off;\n\n    int maxband, keyframe;\n\n    int last[2];\n\n\n\n    keyframe = c->cur_frame == 0;\n\n\n\n    if(keyframe){\n\n        memset(c->Q, 0, sizeof(c->Q));\n\n        c->last_bits_used = 0;\n\n    }\n\n    init_get_bits(gb, buf, buf_size * 8);\n\n    skip_bits(gb, c->last_bits_used & 7);\n\n\n\n    if(keyframe)\n\n        maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1);\n\n    else{\n\n        maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2);\n\n        if(maxband > 32) maxband -= 33;\n\n    }\n\n    c->last_max_band = maxband;\n\n\n\n    /* read subband indexes */\n\n    if(maxband){\n\n        last[0] = last[1] = 0;\n\n        for(i = maxband - 1; i >= 0; i--){\n\n            for(ch = 0; ch < 2; ch++){\n\n                last[ch] = get_vlc2(gb, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch];\n\n                if(last[ch] > 15) last[ch] -= 17;\n\n                bands[i].res[ch] = last[ch];\n\n            }\n\n        }\n\n        if(c->MSS){\n\n            int mask;\n\n\n\n            cnt = 0;\n\n            for(i = 0; i < maxband; i++)\n\n                if(bands[i].res[0] || bands[i].res[1])\n\n                    cnt++;\n\n            t = mpc8_get_mod_golomb(gb, cnt);\n\n            mask = mpc8_get_mask(gb, cnt, t);\n\n            for(i = maxband - 1; i >= 0; i--)\n\n                if(bands[i].res[0] || bands[i].res[1]){\n\n                    bands[i].msf = mask & 1;\n\n                    mask >>= 1;\n\n                }\n\n        }\n\n    }\n\n    for(i = maxband; i < c->maxbands; i++)\n\n        bands[i].res[0] = bands[i].res[1] = 0;\n\n\n\n    if(keyframe){\n\n        for(i = 0; i < 32; i++)\n\n            c->oldDSCF[0][i] = c->oldDSCF[1][i] = 1;\n\n    }\n\n\n\n    for(i = 0; i < maxband; i++){\n\n        if(bands[i].res[0] || bands[i].res[1]){\n\n            cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1;\n\n            if(cnt >= 0){\n\n                t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1);\n\n                if(bands[i].res[0]) bands[i].scfi[0] = t >> (2 * cnt);\n\n                if(bands[i].res[1]) bands[i].scfi[1] = t & 3;\n\n            }\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < maxband; i++){\n\n        for(ch = 0; ch < 2; ch++){\n\n            if(!bands[i].res[ch]) continue;\n\n\n\n            if(c->oldDSCF[ch][i]){\n\n                bands[i].scf_idx[ch][0] = get_bits(gb, 7) - 6;\n\n                c->oldDSCF[ch][i] = 0;\n\n            }else{\n\n                t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2);\n\n                if(t == 64)\n\n                    t += get_bits(gb, 6);\n\n                bands[i].scf_idx[ch][0] = ((bands[i].scf_idx[ch][2] + t - 25) & 0x7F) - 6;\n\n            }\n\n            for(j = 0; j < 2; j++){\n\n                if((bands[i].scfi[ch] << j) & 2)\n\n                    bands[i].scf_idx[ch][j + 1] = bands[i].scf_idx[ch][j];\n\n                else{\n\n                    t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2);\n\n                    if(t == 31)\n\n                        t = 64 + get_bits(gb, 6);\n\n                    bands[i].scf_idx[ch][j + 1] = ((bands[i].scf_idx[ch][j] + t - 25) & 0x7F) - 6;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    for(i = 0, off = 0; i < maxband; i++, off += SAMPLES_PER_BAND){\n\n        for(ch = 0; ch < 2; ch++){\n\n            res = bands[i].res[ch];\n\n            switch(res){\n\n            case -1:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++)\n\n                    c->Q[ch][off + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510;\n\n                break;\n\n            case 0:\n\n                break;\n\n            case 1:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){\n\n                    cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2);\n\n                    t = mpc8_get_mask(gb, 18, cnt);\n\n                    for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1)\n\n                        c->Q[ch][off + j + k] = (t & 0x20000) ? (get_bits1(gb) << 1) - 1 : 0;\n\n                }\n\n                break;\n\n            case 2:\n\n                cnt = 6;//2*mpc8_thres[res]\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += 3){\n\n                    t = get_vlc2(gb, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2);\n\n                    c->Q[ch][off + j + 0] = mpc8_idx50[t];\n\n                    c->Q[ch][off + j + 1] = mpc8_idx51[t];\n\n                    c->Q[ch][off + j + 2] = mpc8_idx52[t];\n\n                    cnt = (cnt >> 1) + mpc8_huffq2[t];\n\n                }\n\n                break;\n\n            case 3:\n\n            case 4:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += 2){\n\n                    t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3];\n\n                    c->Q[ch][off + j + 1] = t >> 4;\n\n                    c->Q[ch][off + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF);\n\n                }\n\n                break;\n\n            case 5:\n\n            case 6:\n\n            case 7:\n\n            case 8:\n\n                cnt = 2 * mpc8_thres[res];\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++){\n\n                    t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5];\n\n                    c->Q[ch][off + j] = t;\n\n                    cnt = (cnt >> 1) + FFABS(c->Q[ch][off + j]);\n\n                }\n\n                break;\n\n            default:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++){\n\n                    c->Q[ch][off + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2);\n\n                    if(res != 9){\n\n                        c->Q[ch][off + j] <<= res - 9;\n\n                        c->Q[ch][off + j] |= get_bits(gb, res - 9);\n\n                    }\n\n                    c->Q[ch][off + j] -= (1 << (res - 2)) - 1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels);\n\n\n\n    c->cur_frame++;\n\n\n\n    c->last_bits_used = get_bits_count(gb);\n\n    if(c->cur_frame >= c->frames)\n\n        c->cur_frame = 0;\n\n    *data_size =  MPC_FRAME_SIZE * 2 * avctx->channels;\n\n\n\n    return c->cur_frame ? c->last_bits_used >> 3 : buf_size;\n\n}\n", "idx": 7558, "substitutes": {"avctx": [" avcontext", "afcli", " avcv", "Avcli", "abcp", "Avpkg", "afcv", "ajpkg", "afctx", "abcontext", "afcp", "afpkg", "avcontext", "avcv", "ajcli", "avcp", "Avcontext", " avcp", "Avctx", "avpkg", "afcontext", "ajctx", "ajcontext", "abcv", "abctx", "avcli"], "data": ["base", "pack", "buff", "bin", "block", "dat", "channel", "config", "val", "queue", "body", "image", "m", "in", "window", "uf", "content", "client", "media", "d", "DATA", "buffer", "code", "connection", "da", "message", "Data", "bytes", "response", "load", "result", "p", "input", "batch", "reader", "frame", "memory", "read", "board", "cache", "next", "size"], "data_size": ["data\u00b7grow", "data\u00b7timeout", "dataflowsize", "dataflowgrow", "dataflowlen", "buffer_len", "buffer_timeout", "dataflowtimeout", "buffer_grow", "data\u00b7size", "data\u00b7len", "data_len", "data_grow", "data_timeout", "buffer_size"], "avpkt": ["avfacket", "abpct", "avfpkt", " avvpki", "avfkt", " avpki", "avfpkg", "abpck", "avfck", "avpacket", "avwpck", "avwpkt", "avbpcht", "abpkg", "avpct", "abcpacket", "avfpct", " avvpck", "avcpacket", "avvpkt", "avckt", "avcpkt", "avcpct", "abcpkg", "abcpct", "avcpck", "avvpki", "avwpcht", "abcpck", "avpck", " avvpcht", " avpcht", "avvpcht", "avpkg", "avfpacket", "avvpck", "avbpki", "avbpkt", "avpki", " avvpkt", "avwpki", "avpcht", "abpacket", "abpkt", "avcct", "avcpkg", "avcck", " avpck", "avfct", "avbpck", "avfkg", "avcacket", "abcpkt"], "buf": ["cas", "buff", "vec", "mem", "block", "box", "cur", "v", "rb", "config", " buffer", "rc", "queue", "map", "uc", "fb", "uf", "buffer", "code", "bag", "raw", "port", "cmd", "pad", "bc", "cb", "seq", "array", "p", "batch", "alloc", "cf", "br", "board", "cv", "cache", "pb", "src", "img"], "c": ["cp", "icc", "cmp", "cr", "v", "cur", "s", "ci", "component", "config", "b", "nc", "com", "sync", "rc", "enc", "cat", "co", "C", "uc", "cy", "m", "l", "f", "client", "d", "pc", "cc", "cs", "ce", "u", "conf", "arc", "con", "mc", "sc", "e", "dc", "conn", "ctx", "n", "bc", "cu", "coll", "p", "ctrl", "ec", "ca", "h", "cit", "g", "ct", "cn", "cf", "lc", "fc", "ac", "vc", "cache", "r", "cm", "cd", "xc"], "gb2": ["cvv", "gb4", "gb3", "GB2", "c2", "GB1", "GB4", "gbTwo", "pc2", "GBv", " rc3", "cTwo", "cv1", "gg2", " rcTwo", "pcTwo", "ggv", "cv4", "gbv", "pc3", "c3", "gb1", "cv2", "gg4", "gg1", " rc2"], "gb": ["gp", "agg", "cgi", "cfg", "band", "buff", "bp", "bin", "gm", "hub", "ci", "gru", "rb", "config", "bg", "b", "rc", "bm", "db", "gu", "uf", "ga", "pg", "usb", "gin", "pc", "gz", "bb", "py", "eb", "sb", "gs", "gam", "rg", "banks", "binary", "storage", "lib", "ctx", "bc", "GB", "cb", "go", "nb", "gold", "mb", "boot", "gy", "kb", "g", "bf", "gd", "lc", "gt", "gg", "bo", "yg"], "i": ["gi", "o", "ti", "v", "id", "I", "chi", "ih", "di", "ik", "ci", "ki", "ji", "ni", "b", "x", "si", "xi", "io", "ri", "info", "bi", "m", "in", "qi", "ix", "l", "f", "pi", "yi", "phi", "d", "ii", "iu", "it", "ai", "u", "e", "sh", "uri", "ami", "ori", "n", "multi", "mi", "ini", "ie", "p", "h", "z", "eni", "oi", "hi", "ind", "ip", "y", "api", "li", "fi", "r", "zi", "ui"], "j": ["o", "v", "ji", "b", "si", "m", "l", "f", "ij", "ii", "d", "q", "u", "J", "n", "jp", "ie", "p", "h", "z", "pos", "ind", "g", "y", "r"], "k": ["o", "v", "ik", "ki", "x", "kk", "m", "key", "K", "sk", "f", "d", "q", "u", "ck", "e", "w", "ks", "n", "p", "kw", "h", "z", "ke", "g", "y"], "ch": ["chi", "ci", "x", "b", "ich", "sk", "f", "conf", "code", "col", "cho", "cor", "cham", "h", "chn", "ver", "y", "CH", "bh", "conn", "cm", "cp", "cur", "try", "channel", "cry", "cher", "Ch", "sh", "sc", "zh", "sch", "work", "batch", "z", "cht", "arch", "form", "fr", "change", "cha", "th", "cl", "ph", "u", "dev", "p", "hr", "ach", "app", "cel", "chy", "chip", "v", "pr", "pull", "che", "cy", "qi", "child", "q", "chart", "qu", "ky", "gh", "chan", "och"], "cnt": ["lcno", " cn", " cnc", " cnd", "count", "cnd", "CNT", "ecnc", "ecNT", "cno", "lcnc", "Cno", "Cnc", "acno", "lcn", " cNT", "ecnt", "lcct", "cct", "cnc", " cct", "ecct", "Cnt", "cNT", "lcNT", "Count", "ecnd", " count", "acn", "acnt", "ecount", " cno", "cn", "lcnt", "Cnd", "acNT", "Cct"], "res": ["gr", "reset", "ret", "reg", "press", "block", "prev", "spec", "total", "ress", "values", "Res", "ex", "real", "rh", "vals", "results", "rest", "ras", "des", "resolution", "def", "rss", "sc", "arr", "rx", "ts", "err", "response", "rev", "pres", "result", "rem", "req", "blocks", "remote", "re", "mr", "sp", "RES", "pos", "os", "range", "ms", "resp", "rep", "rs", "r", "ps", "max"], "t": ["ot", "o", "tf", "v", "rt", "total", "nt", "unt", "qt", "token", "template", "wt", "m", "pt", "l", "f", "at", "it", "e", "mt", "det", "tn", "port", "n", "tm", "ts", "p", "tz", "ut", "ta", "g", "y", "type", "dt", "tp", "tt", "T", "r", "tc"], "bands": ["groups", "points", "types", "models", "bass", "band", "files", "books", "objects", "rules", "balls", "bits", "plugins", "words", "b", "modules", "cells", "services", "ogs", "cats", "pins", "planes", "states", "girls", "codes", "parts", "images", "cycles", "heads", "stores", "rooms", "archs", "orders", "classes", "sb", "banks", "ks", "steps", "pages", "ds", "bys", "jobs", "devices", "chains", "players", "blocks", "rings", "pieces", "products", "tops", "bags", "cards", "g", "tracks", "ands", "amps", "bones", "frames", "ids", "lines", "versions", "bows", "charges", "lists"], "off": ["o", "reset", "ef", "total", "offs", "op", "offset", "obj", "loop", "def", "low", "error", "out", "one", "opt", "Off", " offset", "ip", "orig", "on", "mode", "shift", "ff", "ok"], "maxband": ["maxhard", "xBand", "mincell", "scaleband", "modbridge", "maxchannel", " maxbit", "maxblock", "scalebit", "modbit", "maxbroad", "Maxband", "axboot", "axbridge", "righthard", "maxgroup", " maxbroad", "workline", " maxgroup", "workbit", "lastbit", "taxpage", "lastline", "maxBand", "totalband", "rightbit", "axblock", "rightblock", "xbit", "rightband", "axpage", "minchannel", "taxhard", "axbroad", "lastband", "totalline", "minbit", "taxband", " maxline", "axBand", "axbit", "workband", "MaxBand", "minline", "totalbit", "mingroup", "modpage", "xband", "axline", " maxblock", "minband", "maxcell", " maxBand", " maxchannel", "maxbit", "Maxboot", "taxbit", "rightbridge", "maxline", "maxbridge", " maxpage", "scalecell", "lastBand", "rightpage", "axframe", "workframe", "scalegroup", "totalBand", "maxboot", " maxcell", "axband", "modband", "maxframe", "rightbroad", " maxboot", " maxframe", "maxpage", "axchannel", " maxhard"], "keyframe": ["maxFrame", "Keyline", "khole", " keyframes", "rowframe", "rowcode", " keyhole", "skycode", "keyfram", "Keyframe", "Keyiframe", "keycode", "skyfram", "keyframes", "kframe", "skyframe", " keyiframe", "keyline", "skyiframe", "rowfram", "maxframe", "KeyFrame", "maxline", "Keyfram", "Keyframes", "rowframes", "kframes", "Keycode", "keyhole", " keyfram", "skyframes", "Keyhole", "maxframes", "keyiframe", " keyFrame", " keyline", "keyFrame"], "last": ["master", "base", "est", "recent", "build", "extra", "id", "not", "prev", "parent", "total", "count", "since", "scope", "best", "list", "final", "style", "tr", "or", "now", "bottom", "use", "valid", "cle", "private", "child", "used", "active", "Last", "pop", "push", "code", "all", "any", "full", "latest", "always", "history", "empty", "first", "cycle", "str", "self", "one", "old", "eval", "this", "shared", "cost", "range", "pull", "new", "worst", "only", "desc", "next", "cache", "current", "max", "end", "size"], "mask": ["id", "count", "bits", "total", " tr", "tr", " masks", "bit", "info", "m", "th", "sk", "offset", "Mask", "tl", "all", "depth", "black", "ts", "ask", "p", "qa", "batch", "tile", "ta", "type", "max"], "cur_frame": ["curopchannel", "latestopelement", "curfelement", "curfchannel", "cur_channel", "cur_bit", "cur__bit", "latestopbit", "latest_bit", "curopframe", "curopbit", "curfframe", "latest_frame", "latest_element", "latestopchannel", "latestopframe", "cur__channel", "cur__frame", "cur_element", "curopelement", "latest_channel", "curfbit", "cur__element"]}}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    PXA2xxPICState *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (PXA2xxPICState *)\n\n            qemu_mallocz(sizeof(PXA2xxPICState));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);\n\n    cpu_register_physical_memory(base, 0x00100000, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(NULL, \"pxa2xx_pic\", 0, 0, pxa2xx_pic_save,\n\n                    pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n", "idx": 25549, "substitutes": {"base": ["seq", "obe", "byte", "info", "b", "p", "server", "c", "ix", "vs", "buffer", "en", "bf", "gb", "up", "py", "address", "ada", "real", "bc", "end", "inet", "aos", "buf", "es", "e", "ba", "work", "path", "bi", "ctx", "Base", "weak", "cache", "as", "au", "f", "po", "fs", "used", "ip", "net", "fp", "out", "be", "full", "root", "core", "r", "ace", "v", "reset", "len", "area"], "env": ["ses", "ep", "np", "er", "w", "scope", "z", "iss", "exc", "p", "c", "context", "inv", "enc", "vs", "enable", "ec", "en", "config", "conf", "state", "ch", "ev", "end", "ea", "inet", "environment", "e", "es", "ey", "path", "viron", "si", "ctx", "energy", "eu", "sb", "eni", "cache", "oa", "h", "f", "y", "network", "conn", "net", "core", "v", "init", "ex", "settings", "nc", "que"], "s": ["socket", "sys", "w", "z", "server", "ns", "ts", "vs", "sites", "sq", "ps", "states", "sync", "sis", "u", "es", "gs", "south", "sym", "f", "fs", "js", "n", "qs", "t", "r", "S", "sk", "p", "m", "b", "c", "en", "ds", "us", "state", "su", "is", "spec", "services", "sl", "settings", "its", "g", "rs", "ses", "ss", "d", "conf", "sg", "e", "session", "sb", "client", "q", "sf", "ssl", "cs", "secure", "sc", "secret", "i", "o", "si", "os", "ctx", "ls", "y", "v", "l"], "iomemtype": ["vocemtypes", "iomademTYPE", "iopademstyle", "iopademtype", "iomhemstyle", "iomerType", "iomhemval", "iomhemTYPE", "iomemTYPE", "iomemType", "iomEMtypes", "iopemTYPE", "lovemType", "iomEMstyle", "lovearType", "iomeltype", "iomertypes", "iopemtypes", "iomhemtype", "iopademtypes", "iomemtypes", "lovemid", "iomelrole", "iomimertypes", "iomhemtypes", "voceltypes", "iomearval", "iomhemid", "iopemtype", "iomimerrole", "iopademTYPE", "iomertype", "voceltype", "iomhemType", "iomEMtype", "loveartype", "iomerrole", "iopemstyle", "iomearid", "iomelval", "iomelid", "vocemtype", "lovearid", "iomearType", "iomeartype", "iomemval", "iomademtype", "iomademtypes", "vocelrole", "iomelType", "vocemType", "iomemstyle", "lovemtype", "vocelType", "iomademstyle", "iomimertype", "iomemid", "iomimerType", "iomemrole", "iomEMTYPE", "vocemrole", "lovearval", "iomeltypes", "lovemval"], "qi": ["fen", "gui", "iq", "qua", "yi", "i", "p", "shi", "c", " ki", "qa", "qt", "sq", "config", "jp", " ii", "ei", " iii", " q", " ni", "li", "zi", "esi", "xi", "aq", "bi", "ii", "si", "ai", "cli", "ni", "ctx", "ci", "fi", "iaz", "agi", "eni", "cf", "sci", "req", "pai", "ahi", "qs", "qq", "q", "qv", "mu", "dq", "ace", "query", "chi", "ce"]}}
{"project": "qemu", "commit_id": "2e1198672759eda6e122ff38fcf6df06f27e0fe2", "target": 1, "func": "static void stellaris_enet_save(QEMUFile *f, void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n    int i;\n\n\n\n    qemu_put_be32(f, s->ris);\n\n    qemu_put_be32(f, s->im);\n\n    qemu_put_be32(f, s->rctl);\n\n    qemu_put_be32(f, s->tctl);\n\n    qemu_put_be32(f, s->thr);\n\n    qemu_put_be32(f, s->mctl);\n\n    qemu_put_be32(f, s->mdv);\n\n    qemu_put_be32(f, s->mtxd);\n\n    qemu_put_be32(f, s->mrxd);\n\n    qemu_put_be32(f, s->np);\n\n    qemu_put_be32(f, s->tx_fifo_len);\n\n    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n\n    for (i = 0; i < 31; i++) {\n\n        qemu_put_be32(f, s->rx[i].len);\n\n        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n\n\n\n    }\n\n    qemu_put_be32(f, s->next_packet);\n\n    qemu_put_be32(f, s->rx_fifo_offset);\n\n}\n", "idx": 8526, "substitutes": {"f": ["l", "rf", "uf", "conf", "fu", "fo", "fen", "n", "ff", "ph", "af", "sf", "def", "w", "m", "fr", "info", "fd", "t", "x", "b", "k", "fw", "d", "c", "fb", "fal", "p", "e", "fp", "cf", "feed", "q", "df", "fa", "fm", "bf", "tf", "v", "fx", "r", "fun", "elf", "fn", "u", "form", "F", "file", "fs", "ft", "func", "inf", "fi", "fe", "fc"], "opaque": ["paque", "opacity", "opac", "opasso", "hoprique", "hopasso", " oprique", "operacity", "iopaque", "hopac", " opac", "oprique", " opaques", "paques", " opacity", "iopac", "hopaque", "pacity", " opasso", "operaque", "iopasso", "opaques", "ioprique", "operaques"], "s": ["l", "session", "is", "its", "strings", "m", "t", "gs", "sum", "er", "sy", "v", "err", "ns", "spec", "ser", "settings", "sg", "ds", "si", "n", "sites", "sf", "b", "c", "e", "se", "args", "sq", "us", "j", "sym", "sets", "es", "ar", "r", "en", "as", "u", "fs", "su", "site", "ps", "ss", "ess", "sc", "ks", "g", "ops", "d", "ys", "ls", "os", "cs", "o", "sync", "south", "sl", "new", "sb", "sys", "ions", "a", "ssl", "conf", "ts", "rows", "in", "service", "p", "qs", "js", "an", "aws", "S", "states", "services", "ms", "h", "ses", "y"], "i": ["oi", "l", "vi", "hi", "ui", "di", "start", "si", "n", "adi", "zi", "m", "xi", "info", "id", "b", "x", "ini", "ami", "iv", "d", "c", "ji", "line", "limit", "p", "uri", "ix", "e", "mu", "yi", "eni", "ie", "dr", "j", "ai", "o", "multi", "index", "v", "gi", "mi", "ti", "phi", "chi", "qi", "abi", "bi", "pi", "ii", "init", "u", "layer", "I", "li", "ip", "loop", "a", "ci", "io", "ni", "y", "ri", "fi", "iu", "ki"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int idreg_init1(SysBusDevice *dev)\n\n{\n\n    IDRegState *s = MACIO_ID_REGISTER(dev);\n\n\n\n    memory_region_init_ram(&s->mem, OBJECT(s),\n\n                           \"sun4m.idreg\", sizeof(idreg_data), &error_abort);\n\n    vmstate_register_ram_global(&s->mem);\n\n    memory_region_set_readonly(&s->mem, true);\n\n    sysbus_init_mmio(dev, &s->mem);\n\n    return 0;\n\n}\n", "idx": 2624, "substitutes": {"dev": ["serial", "cam", "def", "dd", "hw", "conn", "device", "mod", "data", "d", "ver", "di", "av", "priv", "de", "grad", "eng", "dom", "Dev", "md", "ch", "home", "dc", "gu", "p", "w", "self", "prom", "dm", "app", "exec", "cmd", "die", "comment", "driver", "ev", "rad", "dem", "serv", "nov", "link", "valid", "pro", "img", "gd", "mem"], "s": ["sg", "js", "service", "cs", "ss", "spec", "ts", "rs", "a", "sb", "r", "d", "n", "is", "sl", "ms", "i", "side", "g", "m", "ses", "sf", "args", "sync", "storage", "ds", "ps", "gs", "ns", "c", "p", "services", "w", "e", "self", "f", "es", "sys", "sq", "obj", "sec", "o", "b", "su", "S", "t", "session", "os", "an", "states", "fs", "si", "sym", "ssl"]}}
{"project": "qemu", "commit_id": "b0fd8d18683f0d77a8e6b482771ebea82234d727", "target": 0, "func": "static void setup_rt_frame(int sig, struct target_sigaction *ka,\n\n                           target_siginfo_t *info,\n\n                           target_sigset_t *set, CPUAlphaState *env)\n\n{\n\n    abi_ulong frame_addr, r26;\n\n    struct target_rt_sigframe *frame;\n\n    int i, err = 0;\n\n\n\n    frame_addr = get_sigframe(ka, env, sizeof(*frame));\n\n    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {\n\n        goto give_sigsegv;\n\n    }\n\n\n\n    err |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n    __put_user(0, &frame->uc.tuc_flags);\n\n    __put_user(0, &frame->uc.tuc_link);\n\n    __put_user(set->sig[0], &frame->uc.tuc_osf_sigmask);\n\n    __put_user(target_sigaltstack_used.ss_sp,\n\n               &frame->uc.tuc_stack.ss_sp);\n\n    __put_user(sas_ss_flags(env->ir[IR_SP]),\n\n               &frame->uc.tuc_stack.ss_flags);\n\n    __put_user(target_sigaltstack_used.ss_size,\n\n               &frame->uc.tuc_stack.ss_size);\n\n    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);\n\n    for (i = 0; i < TARGET_NSIG_WORDS; ++i) {\n\n        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);\n\n    }\n\n\n\n    if (ka->sa_restorer) {\n\n        r26 = ka->sa_restorer;\n\n    } else {\n\n        __put_user(INSN_MOV_R30_R16, &frame->retcode[0]);\n\n        __put_user(INSN_LDI_R0 + TARGET_NR_rt_sigreturn,\n\n                   &frame->retcode[1]);\n\n        __put_user(INSN_CALLSYS, &frame->retcode[2]);\n\n        /* imb(); */\n\n        r26 = frame_addr;\n\n    }\n\n\n\n    if (err) {\n\n    give_sigsegv:\n\n       if (sig == TARGET_SIGSEGV) {\n\n            ka->_sa_handler = TARGET_SIG_DFL;\n\n        }\n\n        force_sig(TARGET_SIGSEGV);\n\n    }\n\n\n\n    env->ir[IR_RA] = r26;\n\n    env->ir[IR_PV] = env->pc = ka->_sa_handler;\n\n    env->ir[IR_A0] = sig;\n\n    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);\n\n    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);\n\n    env->ir[IR_SP] = frame_addr;\n\n}\n", "idx": 23933, "substitutes": {"sig": [" sigma", "ssigned", "pigma", "sigs", "pess", " sess", " sigs", "asigma", "pigs", "gsigma", "sigh", "dsig", "sIG", "ssigs", " sigh", "fIG", "pigh", "ssig", "figma", "pIG", "asess", " sIG", "asigs", "dsigs", "sigma", "figs", "gsig", "ssigma", "sess", "asig", "gsigs", "gsigh", "fig", "pig", "dsigned", "dsigma"], "ka": ["bc", "ja", "ra", "ya", "ia", "fi", "ba", "kernel", "ha", "wa", "oda", "kt", "KA", "ki", "oa", "ker", "ca", "jam", "ea", "ci", "ga", "da", "na", "java", "kb", "sa", "la", "ctx", "ket", "sc", "ema", "a", "ta", "ua", "auc", "qa", "va", "ai", "cca", "ku", "LA", "aka", "qua", "ae", "ko", "ma", "ke", "kee", "sta", "k", "ama"], "info": ["name", "summary", "area", "def", "Info", "fi", " fi", "start", "config", "ind", "ui", "INFO", "meta", "ti", "f", "ci", "ini", "information", "raf", "init", "data", "isu", "stat", "abi", "inf", "setup", "id", "code", "context", "mi", "ctx", "index", "spec", "source", "si", "family", "ii", "alias", "error", "loc", "hi", "util", "conf", "image", "ie", "api", "attr", "fo", "inter", "interface"], "set": ["status", "ut", "net", "e", "start", "sel", "en", "end", "send", "err", "config", "ind", "push", "sche", "post", "kit", "sign", "parse", "site", "get", "export", "SET", "ex", "use", "init", "state", "stat", "new", "setting", "act", "Set", "setup", "ace", "code", "context", "sync", "load", "open", "gen", "settings", "ctx", "spec", "et", "add", "c", "sc", "check", "match", "create", "se", "update", "see", "vert", "ner", "reset", "ise", "server", "offset", "base", "ne"], "env": ["net", "stack", "e", "en", "eq", "obj", "end", "eu", "config", "conn", "eni", "me", "db", "ea", "ef", "exec", "exc", "nc", "ini", "dir", "dev", "init", "cache", "state", "enc", "ep", "dict", "que", "context", "np", "ext", "ctx", "et", "cfg", "viron", "stage", "osc", "vert", "qt", "ne", "conf", "v", "ev", "environment", "scope", "server", "ec"], "frame_addr": ["frame_nr", "frame_address", "frame__offset", " frame_layer", "frame_layer", " frame_ord", " frame_offset", "frame_offset", "fram_addr", "frame__address", " frame_address", " frame_nr", "frame__nr", "fram_offset", "fram_address", "frame__addr", "fram_ord", "frame_ord"], "r26": ["p16", " r16", "p27", "R6", "p26", "r6", "R27", "R16", "p6", "r27", " r6", " r27", "r16", "R26"], "frame": ["target", "def", "sample", "config", "event", "part", "message", "force", "parse", "plate", "sequence", "figure", "context", "fr", "window", "line", "draw", "slice", "game", "Frame", "ko", "image", "fi", "feat", "txt", "object", "jp", "sche", "file", "za", "processor", "style", "node", "fake", "state", "lock", "component", "setup", "tick", "code", "body", "fire", "cfg", "raise", "element", "boot", "fram", "ce", "position", "scope", "interface", "e", "flower", "thread", "fb", "framework", "function", "f", "layer", "model", "section", "play", "cf", "point", "coe", "module", "role", "face", "call", "flow", "show", "stage", "ze", "fo", "plane", "iframe", "feature", "build", "invoke", "motion", "version", "cycle", "word", "fe", "frames", "shot", "die", "profile", "seq", "session", "update", "range", "block", "environment", "base", "condition"], "i": ["io", "uli", "ix", "e", "ie", "qi", "err", "ind", "ri", "ui", "eni", "part", "mini", "gi", "d", "uri", "ti", "I", "l", "ci", "y", "t", "phi", "adi", "m", "ini", "oi", "j", "u", "ip", "p", "id", "o", "code", "bi", "is", "cli", "c", "mu", "index", "si", "a", "ii", "x", "ji", "b", "n", "iu", "slice", "ai", "xi", "hi", "di", "multi", "z", "v", "li", "yi", "api", "pi", "fi", "zi", "ni"]}}
{"project": "qemu", "commit_id": "203d65a4706be345c209f3408d3a011a3e48f0c9", "target": 0, "func": "static void imx_gpt_reset(DeviceState *dev)\n\n{\n\n    IMXGPTState *s = IMX_GPT(dev);\n\n\n\n    /* stop timer */\n\n    ptimer_stop(s->timer);\n\n\n\n    /*\n\n     * Soft reset doesn't touch some bits; hard reset clears them\n\n     */\n\n    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|\n\n               GPT_CR_WAITEN|GPT_CR_DBGEN);\n\n    s->sr = 0;\n\n    s->pr = 0;\n\n    s->ir = 0;\n\n    s->cnt = 0;\n\n    s->ocr1 = TIMER_MAX;\n\n    s->ocr2 = TIMER_MAX;\n\n    s->ocr3 = TIMER_MAX;\n\n    s->icr1 = 0;\n\n    s->icr2 = 0;\n\n\n\n    s->next_timeout = TIMER_MAX;\n\n    s->next_int = 0;\n\n\n\n    /* compute new freq */\n\n    imx_gpt_set_freq(s);\n\n\n\n    /* reset the limit to TIMER_MAX */\n\n    ptimer_set_limit(s->timer, TIMER_MAX, 1);\n\n\n\n    /* if the timer is still enabled, restart it */\n\n    if (s->freq && (s->cr & GPT_CR_EN)) {\n\n        ptimer_run(s->timer, 1);\n\n    }\n\n}\n", "idx": 23938, "substitutes": {"dev": ["Dev", "priv", "reg", "grad", "cam", "def", "serv", "conn", "app", "prof", "mode", "de", "tr", "temp", "home", "device", "devices", "ro", "dd", "data", "serial", "mod", "pro", "dem", "dom", "ver", "rad", "w", "dm", "prom", "test", "debug", "req", "di", "conf", "hw", "ev"], "s": ["sv", "i", "es", "uns", "xs", "ds", "sys", "y", "ssl", "os", "ts", "cs", "us", "params", "js", "ms", "n", "S", "ns", "rs", "ins", "ans", "conf", "l", "ss", "same", "sb", "g", "ses", "d", "sets", "site", "as", "services", "u", "o", "sg", "c", "spec", "a", "has", "ats", "su", "e", "sym", "qs", "tests", "hs", "fs", "f", "t", "new", "p", "si", "b", "service", "ps", "gs", "x", "sq", "sl", "your", "plugins", "ks", "m", "args", "its", "vs", "ls", "sync", "is", "settings", "w", "se", "session", "comments", "bs", "states"]}}
{"project": "FFmpeg", "commit_id": "4691a77db4672026d62d524fd292fb17db6514b4", "target": 1, "func": "static inline int get_chroma_qp(H264Context *h, int qscale){\n\n    return h->pps.chroma_qp_table[qscale & 0xff];\n\n}\n", "idx": 17893, "substitutes": {"h": ["m", "ch", "t", "eh", "image", "oh", "n", "gh", "i", "cpp", "hd", "rh", "ctx", "host", "context", "hw", "header", "ht", "him", "sh", "ahi", "w", "hl", "q", "e", "bh", "ih", "v", "c", "hp", "p", "hm", "b", "http", "hh", "ec", "ph", "ha", "hs", "he", "ah", "H"], "qscale": ["eqset", "eqslice", "qualcale", "bitcale", "qqshape", "qualset", "bitset", " qcale", "qqcale", "bitscale", "qshape", "wcale", "eqscale", "eqcale", " qshape", "wshape", "qset", "wscale", "qcale", "qualscale", "qslice", "qqscale", "bitslice", "qualslice"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)\n\n{\n\n    uint8_t *old_code_ptr = s->code_ptr;\n\n    assert(ret != arg);\n\n#if TCG_TARGET_REG_BITS == 32\n\n    tcg_out_op_t(s, INDEX_op_mov_i32);\n\n#else\n\n    tcg_out_op_t(s, INDEX_op_mov_i64);\n\n#endif\n\n    tcg_out_r(s, ret);\n\n    tcg_out_r(s, arg);\n\n    old_code_ptr[1] = s->code_ptr - old_code_ptr;\n\n}\n", "idx": 19129, "substitutes": {"s": ["ns", "spec", "m", "ts", "sg", "session", "t", "info", "x", "f", "services", "r", "ions", "service", "n", "sb", "g", "i", "ss", "src", "in", "ctx", "this", "scope", "fs", "sec", "self", "xs", "is", "o", "cs", "context", "d", "su", "new", "args", "site", "w", "e", "ssl", "ses", "sync", "v", "c", "js", "si", "p", "S", "b", "ks", "gs", "sys", "u", "a", "es", "os", "us", "se", "sq", "ds", "sf"], "type": ["types", "spec", " t", "t", "name", "f", "pe", "rel", "def", "enc", "class", "re", "Type", "path", "style", "sub", "id", "parent", "TYPE", "p", "ty", "py", "prot", "ype", " typ", "typ"], "ret": ["tr", "obj", "err", "ref", "f", "alt", "al", "reg", "rc", "rt", "fun", "rel", "result", "str", "ar", "flag", "match", "usr", "sel", "ext", "sec", "mem", "ry", "def", "rets", "arr", "att", "store", "val", "re", "Ret", "args", "sr", "rev", "RET", "inter", "sys", "res", "proc", "opt", "fi", "reply", "target"], "arg": ["grad", "rest", "err", "ref", "alt", "all", "rc", "reg", "debug", "ar", "result", "str", "g", "flag", "arm", "Arg", "orig", "ext", "sec", "tag", "arr", "enc", "arc", "rec", "val", "re", "Ret", "args", "ig", "ag", "cmd", "argument", "inter", "b", "param", "addr", "mac", "target"], "old_code_ptr": ["old_code\u00b7length", "old_code_ref", "old_codeJptr", "old_line_tr", "old_code2pointers", "old_line_pointer", "old_line_ptr", "old_code_pointers", "old_code_length", "old_call_rep", "old_code_pointer", "old_line_ref", "old_code2pointer", "old_codeJpointer", "old_code_tr", "old_code_rep", "old_codeJrep", "old_code\u00b7rep", "old_code_addr", "old_code\u00b7pointer", "old_call_ptr", "old_call_pointer", "old_code2addr", "old_code\u00b7ptr", "old_codeJlength", "old_code2ptr", "old_call_length"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "static int find_pte32(CPUPPCState *env, mmu_ctx_t *ctx, int h,\n\n                      int rw, int type, int target_page_bits)\n\n{\n\n    hwaddr pteg_off;\n\n    target_ulong pte0, pte1;\n\n    int i, good = -1;\n\n    int ret, r;\n\n\n\n    ret = -1; /* No entry found */\n\n    pteg_off = get_pteg_offset(env, ctx->hash[h], HASH_PTE_SIZE_32);\n\n    for (i = 0; i < 8; i++) {\n\n        if (env->external_htab) {\n\n            pte0 = ldl_p(env->external_htab + pteg_off + (i * 8));\n\n            pte1 = ldl_p(env->external_htab + pteg_off + (i * 8) + 4);\n\n        } else {\n\n            pte0 = ldl_phys(env->htab_base + pteg_off + (i * 8));\n\n            pte1 = ldl_phys(env->htab_base + pteg_off + (i * 8) + 4);\n\n        }\n\n        r = pte_check_hash32(ctx, pte0, pte1, h, rw, type);\n\n        LOG_MMU(\"Load pte from %08\" HWADDR_PRIx \" => \" TARGET_FMT_lx \" \"\n\n                TARGET_FMT_lx \" %d %d %d \" TARGET_FMT_lx \"\\n\",\n\n                pteg_off + (i * 8), pte0, pte1, (int)(pte0 >> 31), h,\n\n                (int)((pte0 >> 6) & 1), ctx->ptem);\n\n        switch (r) {\n\n        case -3:\n\n            /* PTE inconsistency */\n\n            return -1;\n\n        case -2:\n\n            /* Access violation */\n\n            ret = -2;\n\n            good = i;\n\n            break;\n\n        case -1:\n\n        default:\n\n            /* No PTE match */\n\n            break;\n\n        case 0:\n\n            /* access granted */\n\n            /* XXX: we should go on looping to check all PTEs consistency\n\n             *      but if we can speed-up the whole thing as the\n\n             *      result would be undefined if PTEs are not consistent.\n\n             */\n\n            ret = 0;\n\n            good = i;\n\n            goto done;\n\n        }\n\n    }\n\n    if (good != -1) {\n\n    done:\n\n        LOG_MMU(\"found PTE at addr %08\" HWADDR_PRIx \" prot=%01x ret=%d\\n\",\n\n                ctx->raddr, ctx->prot, ret);\n\n        /* Update page flags */\n\n        pte1 = ctx->raddr;\n\n        if (pte_update_flags(ctx, &pte1, ret, rw) == 1) {\n\n            if (env->external_htab) {\n\n                stl_p(env->external_htab + pteg_off + (good * 8) + 4,\n\n                      pte1);\n\n            } else {\n\n                stl_phys_notdirty(env->htab_base + pteg_off +\n\n                                  (good * 8) + 4, pte1);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* We have a TLB that saves 4K pages, so let's\n\n     * split a huge page to 4k chunks */\n\n    if (target_page_bits != TARGET_PAGE_BITS) {\n\n        ctx->raddr |= (ctx->eaddr & ((1 << target_page_bits) - 1))\n\n                      & TARGET_PAGE_MASK;\n\n    }\n\n    return ret;\n\n}\n", "idx": 10049, "substitutes": {"env": ["cot", "chal", "conf", "ou", "qt", "context", "ext", "equ", "dict", "conn", "org", "dt", "que", "ini", "net", "viron", "ne", "environment", "vm", "config", "qa", "cli", "osc", "np", "txt", "cf", "e", "esi", "ec", "eni", "eh", "act", "bc", "ev", "db", "console", "qv", "inv", "exc", "cv", "ea", "oa", "energy", "event", "cal", "en", "loader", "jp", "eng", "Environment", "enc", "cfg", "nc", "site", "cache", "ah", "engine", "eu", "ocr", "fi", "exec"], "ctx": ["utils", "qt", "context", "cmp", "Context", "na", "conn", "src", "dt", "que", "sci", "fw", "service", "c", "ct", "cp", "config", "qq", "obj", "qa", "cli", "cu", "fp", "component", "cn", "cf", "wcs", "loc", "sq", "hw", "bc", "cc", "console", "ctrl", "rt", "cv", "exc", "ck", "sync", "rc", "connection", "cas", "conv", "cal", "tx", "kt", "acl", "git", "xc", "nc", "cm", "ca", "client", "grad", "ci", "vc", "lc", "cmd", "anc", "pkg", "ocr", "settings", "cgi", "kb", "sc", "exec"], "h": ["l", "hi", "sh", "ht", "dh", "n", "g", "ph", "hh", "w", "m", "id", "b", "t", "x", "c", "p", "hm", "gh", "q", "hw", "f", "host", "ha", "v", "bh", "ih", "end", "en", "hp", "hash", "oh", "hs", "hd", "u", "H", "hl", "header", "ch", "rh", "uh"], "rw": ["wl", "wn", "rf", "ru", "wp", "w", "iw", "wh", "sw", "fw", "wb", "wt", "wk", "wd", "rew", "usr", "rss", "wr", "nw", "rb", "writer", "rs", "wo", "lr", "hw", " w", "rc", "ih", "raw", "nr", "wx", "kw", "wu", "rn", "ww", "rx", "rg", "rack", "RW", "rh", "rl", "tw"], "type": ["kind", "id", "method", "info", "temp", "t", "path", "rec", "Type", "rule", "time", "ref", "p", "pb", "attr", "pe", "thin", "style", "ptr", "prop", "types", "tmp", "op", "unit", "o", "py", "shape", "format", "name", "rc", "cur", "ty", "ping", "error", "TYPE", "sys", "re", "y", "ype", "weight", "resp", "typ"], "target_page_bits": ["target_width_bytes", "target_page64bit", "target_page64config", "target_page64bytes", "target_pagenumbits", "target_pagenumbit", "target_width64bytes", "target_width_config", "target_width_bit", "target_page64bits", "target_width64bit", "target_page_bytes", "target_width_bits", "target_width64bits", "target_pagenumconfig", "target_page_config", "target_width64config", "target_page_bit", "target_pagenumbytes"], "pteg_off": ["pteg55fail", "ptig_Off", "pteg00off", "ptpeg_ON", "pteg67open", "ptpeglenon", "pteg_open", "ptreg_set", "pteg67num", "ptig_num", "ptpeg_offset", "ptrig55Off", "ptpeg_off", "ptpeg_on", "pteg_set", "pteglenoff", "ptrig_not", "pteg_ref", "pteglenON", "pteglenon", "ptrig_off", "pteg0open", "pteg55orig", "pteg_offset", "pteg00on", "pteg_orig", "pteg_fail", "pteg67ref", "pteg55not", "pteg_num", "ptigh00on", "ptpeglenoffset", "pteg_alt", "pteg0off", "ptigh00alt", "ptrig55off", "pteg_on", "ptpeglenoff", "pteg_not", "pteg55on", "pteg67orig", "pteg0ref", "ptreg_off", "pteg67not", "pteg55off", "ptigh_fail", "pteg_Off", "ptig_ref", "pteg00alt", "ptpeglenON", "ptrig55not", "pteg_opp", "ptreg_opp", "pteg55Off", "ptreg_offs", "ptigh00fail", "ptigh_off", "ptigh_on", "ptig_open", "ptreg_on", "ptrig_Off", "pteg_ON", "ptrig55orig", "pteg67Off", "pteg67off", "pteglenoffset", "pteg00fail", "ptreg_OFF", "pteg_offs", "pteg55alt", "ptigh00off", "pteg_OFF", "ptrig_orig", "ptigh_alt", "ptig_off"], "pte0": ["pte050", "ctee150", "cte18", "ctee0", "cte0", "cte192", "ptae180", "pti0", "ptee192", "ptte100", "ptea0", "PTE2", " pts8", "ptee100", "upti0", "pte8", "ctee18", "pte100", "PTE029", "ptae18", "ptte1", "ptse00", "cte00", "pts8", "ptse1", "pte5", "ptE5", "ptee8", "upti050", "ptE029", "ptoe050", "pteio", "ptse0", " pteio", "pte180", "pte18", "ptE4", "ptE25", "ptte0", "PTe0", " pts0", "ptae050", "ptee5", "ptae00", "ptnio", "PTe5", "PTE0", "pte00", "ptse18", "ptedge029", "ptea192", "ptee1", "ptoe192", "ptoe1", "ptte25", "ptee18", "ptae4", "pte029", "ptedge2", " ptsio", "ptae1", "pte2", "ptea1", "upti4", " pte8", "upte4", "ptee25", "ctee1", "upte180", "ptee0", "PTE5", "ptoe0", "pts0", "cte4", "ctee4", "ptee4", "ptoe180", "cte25", "ptee00", "pteeio", "upte050", "cte100", "PTe2", "ptn0", "ptsio", "pti4", "ctee00", "ptoe150", "ptse100", "ptse25", "ptE2", "ptee029", "pti180", "ptee2", "ptE1", "ctee25", "cte1", "ptedge5", "ptea150", "pte150", "PTe029", "upte0", "ptoe25", "ptE0", "pte192", "pti050", "pte4", "pte25", "ctee100", "cte150", "ptedge0", "ptee150", "ptae0", "ctee192", "upti180", "ptn8", "ptoe4"], "pte1": ["cteOne", "cteeone", "postoe81", "cte5", "ctee0", "cteen", "cte0", "pteeone", "ctee11", "ptoe9", "ptea0", "ptlOne", "ptfe0", "ptee3", "pte8", "ptoe5", "pteone", "ctee2", "pte9", "cteeOne", "pted1", "cte3", "poste0", "pteen", "ptee81", "cte11", "ptoeOne", "ptse1", "pte5", "ptee8", "ptfe3", "ctee3", "ptoe81", "ptei5", "ptse0", "ptl0", "ptedone", "ptea11", "ptfeOne", "postoeOne", "ptee5", "poste81", "poste1", "cteone", "ptseone", "posteOne", "ptee1", "ptoe1", "ptfe1", "pte11", "postoe0", "cte2", "cten", "ptoen", "ptae1", "pte2", "cte8", "ptea1", "ptoeone", "ctee8", "ptei1", "pte81", "ctee1", "ptee0", "ptoe0", "ptle9", "pten", "ptea3", "ptoe11", "ptle1", "pted2", "ptl81", "cte9", "ptei3", "ptee11", "ptei2", "pteione", "ptaen", "ptee2", "ptoe8", "ptl1", "cte1", "ptle0", "pteiOne", "ptei0", "pte3", "pteOne", "postoe1", "ctee9", "pted5", "ptse8", "ptle5", "ptae0", "ptee9", "ptae3", "pteeOne", "ctee5", "ptoe3"], "i": ["oi", "l", "hi", "ui", "di", "is", "si", "n", "in", "zi", "adi", "info", "xi", "id", "b", "x", "ini", "my", "t", "d", "c", "ji", "p", "ix", "uri", "e", "cli", "mu", "yi", "mini", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "slice", "v", "gi", "mi", "phi", "ti", "ind", "chi", "abi", "qi", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "ni", "io", "y", "ri", "fi", "iu"], "ret": ["good", "pass", "valid", "bad", "flag", "debug", "len", "val", "fail", "def", " success", "nt", "id", "Ret", "rr", "like", "num", "mem", "last", "big", "data", "ref", "arg", "lit", "fit", "reg", " result", "bug", "gt", "rets", "best", "f", "rt", "res", "db", "ig", "rc", "ind", "req", "fun", "done", "err", "get", "bit", "fin", "re", "stable", "cat", "rx", "RET", " good", "back", "result", "resp", "fi", "success"], "r": ["rf", "ru", "g", "ry", "hr", "m", "mr", "rr", "b", "t", "kr", "d", "c", "s", "p", "e", "ir", "rb", "rs", "er", "f", "lr", "dr", "rt", "res", "v", "R", "rc", "ar", "end", "err", "nr", "error", "ur", "re", "rg", "result", "sr", "ri", "br", "rh", "rl"]}}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)\n\n{\n\n    QemuOpts *opts;\n\n\n\n    opts = qemu_opts_create(list, qdict_get_try_str(qdict, \"id\"), 1);\n\n    if (opts == NULL)\n\n        return NULL;\n\n\n\n    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);\n\n    return opts;\n\n}\n", "idx": 23809, "substitutes": {"list": ["like", "name", "ul", "object", "config", "acl", "result", "chain", "coll", "tree", "pkg", "ack", "lists", "cl", "listed", "entry", "full", "p", "List", "code", "load", "comment", "out", "self", "xml", "complete", "add", "set", "seq", "call", "batch", "base", "parent", "array", "li", "LIST", "l", "x", "this"], "qdict": ["qstr", "qudir", "qdf", "sqdict", "qudict", " qmap", "qdocument", "qsdf", "qdir", "eqdict", "eqdocument", " qdocument", " qdir", "qudf", "qtdict", "qsmap", "eqstyle", " qstr", "qmap", " qdf", "sqdt", "sqstr", "qsdict", "qtdocument", "sqdf", "sqmap", "qdt", "qsdt", "qumap", "sqdir", "qtstyle", " qstyle", "eqdf", "qustr", "qstyle", "qudt", "qtdf"], "opts": [" optt", "opals", " optins", "hopents", "optbs", " ops", "opcs", "OPts", " optrs", "ops", " opents", "obps", " opbs", "obts", "OPps", "opgs", "opents", " opss", "opins", "obins", "optrs", "OPals", "oprs", "OPgs", "hopts", "optents", " oprs", " opcs", "OPrs", "optgs", " opgs", "hopcs", " optps", "opss", " optts", "opps", "optss", " opals", "OPs", "obrs", "optt", "apptt", " opps", "appps", "appals", "optcs", "hopss", "opbs", "OPtt", "optins", "OPbs", "appts", "optts", "optps"]}}
{"project": "FFmpeg", "commit_id": "b926b6282d3b9fc8115660ae013f74f4f8c06d30", "target": 0, "func": "static void opt_new_stream(const char *opt, const char *arg)\n\n{\n\n    AVFormatContext *oc;\n\n    if (nb_output_files <= 0) {\n\n        fprintf(stderr, \"At least one output file must be specified\\n\");\n\n        ffmpeg_exit(1);\n\n    }\n\n    oc = output_files[nb_output_files - 1];\n\n\n\n    if      (!strcmp(opt, \"newvideo\"   )) new_video_stream   (oc);\n\n    else if (!strcmp(opt, \"newaudio\"   )) new_audio_stream   (oc);\n\n    else if (!strcmp(opt, \"newsubtitle\")) new_subtitle_stream(oc);\n\n    else assert(0);\n\n}\n", "idx": 16183, "substitutes": {"opt": ["oper", "path", "ott", "config", "mp", "test", "optim", "option", "str", "txt", "init", "eff", "fn", "loc", "error", "o", "feat", "obj", "p", "ok", "options", "cho", "pot", "ext", "op", "ort", "ocr", "spec", "token", "crit", "cat", "type", "text", "attr", "hop", "off", "prop", "Opt", "tag", "usr", "color"], "arg": ["args", "path", "proc", "call", "enc", "config", "val", "or", "ig", "option", "loc", "lib", "obj", "parse", "doc", "ok", "ext", "op", "arc", "ax", "cat", "argument", "Arg", "ar", "tag", "prop", "alloc"], "oc": ["toc", "oid", "aco", "mc", "uc", "bc", "enc", "unc", "irc", "pc", "cc", "iv", "roc", " alloc", "auc", "acc", "abc", "og", "loc", "OC", "output", "isc", "o", "oco", "ir", "mic", "op", "ocol", "ocr", "c", "cu", "voc", "ac", "anc", "ucc", "AC", "ogg", "ic", "org", "exec", "oci", "ec", "soc", "orc", "hop", "fc", "oca", "alloc"]}}
{"project": "FFmpeg", "commit_id": "4d87001096ff1d4e3ee6f88f8caddbd8ccb2c816", "target": 1, "func": "static int update_dimensions(VP8Context *s, int width, int height)\n\n{\n\n    if (width  != s->avctx->width ||\n\n        height != s->avctx->height) {\n\n        if (av_image_check_size(width, height, 0, s->avctx))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        vp8_decode_flush_impl(s->avctx, 1, 0, 1);\n\n\n\n        avcodec_set_dimensions(s->avctx, width, height);\n\n    }\n\n\n\n    s->mb_width  = (s->avctx->coded_width +15) / 16;\n\n    s->mb_height = (s->avctx->coded_height+15) / 16;\n\n\n\n    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));\n\n    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));\n\n    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);\n\n    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));\n\n    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));\n\n\n\n    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||\n\n        !s->top_nnz || !s->top_border)\n\n        return AVERROR(ENOMEM);\n\n\n\n    s->macroblocks        = s->macroblocks_base + 1;\n\n\n\n    return 0;\n\n}\n", "idx": 14014, "substitutes": {"s": ["i", "rs", "qs", "h", "new", "si", "js", "ps", "params", "spec", "c", "is", "ics", "states", "aws", "args", "m", "self", "d", "t", "sync", "sg", "fs", "ins", "sym", "g", "cs", "es", "full", "session", "w", "cons", "u", "sf", "b", "ns", "ops", "r", "sis", "ks", "sys", "parts", "service", "your", "has", "hs", "os", "sets", "o", "ms", "e", "http", "site", "sb", "f", "less", "services", "ls", "ses", "as", "ys", "l", "a", "sites", "S", "its", "uns", "sq", "conf", "ss", "p", "n", "ments", "gs", "xs", "stats", "ssl", "ic", "ds", "su", "ts", "us", "y"], "height": ["stroke", "device", "Height", "deep", "input", "thin", "bottom", "id", "level", "density", "style", "shape", "container", "api", "row", "gap", "image", "hub", "h", "missing", "buffer", "gh", "crop", "rows", "rh", "rank", "alpha", "w", "view", "size", "tight", "img", "direction", "gallery", "huge", "max", "driver", "length", "read", "th", "padding", "resolution", "gpu", "inches", "above", "hold", "dim", "layout", "volume", "high", "window", "ty", "lat", "y", "depth", "fw"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,\n\n                     int ret, int rw)\n\n{\n\n    int store = 0;\n\n\n\n    /* Update page flags */\n\n    if (!(*pte1p & 0x00000100)) {\n\n        /* Update accessed flag */\n\n        *pte1p |= 0x00000100;\n\n        store = 1;\n\n    }\n\n    if (!(*pte1p & 0x00000080)) {\n\n        if (rw == 1 && ret == 0) {\n\n            /* Update changed flag */\n\n            *pte1p |= 0x00000080;\n\n            store = 1;\n\n        } else {\n\n            /* Force page fault for first write access */\n\n            ctx->prot &= ~PAGE_WRITE;\n\n        }\n\n    }\n\n\n\n    return store;\n\n}\n", "idx": 16237, "substitutes": {"ctx": ["sem", "context", "tx", "pkg", "bc", "cm", "qa", "ca", "cv", "sync", "rc", "config", "cc", "jp", "ctrl", "ci", "cs", "cn", "std", "cmp", "sq", "loc", "conn", "client", "obj", "grad", "comp", "c", "cca", "cb", "cas", "sci", "sc", "cmd", "cf", "cp", "exec", "qq", "xc", "src", "mac", "hw"], "pte1p": ["pte2p", "pte01p", "pte0c", "ptee1point", "pte1fp", "ptec6p", "pte001point", "pte01c", "pte001p", "pte251p", "ptec6e", "pte5c", "ptee1f", "ptee3f", "pte2b", "pte6e", "pte3point", "pte3p", "pte251fp", "pte01f", "pte6f", "pte2f", "ptea1point", "ptea001c", "ptee1c", "ptec6sp", "pte1s", "pte6p", "pte5fp", "pte3l", "ptea1c", "pte11b", "pte251sp", "pte1l", "ptea1l", "ptee3p", "pte0point", "ptec1fp", "pteonep", "pte6s", "pteonef", "pte1b", "ptec6fp", "pte5sp", "ptee2b", "pte3s", "pte6c", "ptee3c", "pte01point", "ptee2f", "ptea1p", "pte2point", "pte2s", "ptea001l", "ptea001point", "ptee1b", "ptec1e", "pte001l", "pte1e", "pte001c", "pte6fp", "pte3f", "ptee1p", "pte251e", "ptee2p", "pte0p", "pte1sp", "pte11f", "pte1f", "ptec1p", "pte5p", "pte6sp", "pte5point", "ptee1s", "pte2c", "pte1point", "ptee3s", "pte5e", "pte0l", "ptec1sp", "pteoneb", "ptea001p", "pte1c", "pte3c", "pte5f", "ptee2point", "ptee2c", "pte11p"], "ret": ["pet", "alt", "nat", "ft", "reply", "val", "back", "def", "gt", "rets", "ref", "feat", "match", "success", "ext", "Ret", "result", "store", " RET", "att", "rl", "route", "ry", "offset", "nt", "re", "rt", "sur", "resp", "pat", "RET", "rest", "reg", "rf", "flag", "bit"], "rw": ["rr", "wk", "rss", "reply", "rus", "rd", "rc", "our", "ride", "rn", "wx", "rg", "sw", "sr", "raf", "rh", "nw", "feat", "w", "adr", "rec", "lr", "rb", "rx", "wb", "rack", "rl", "route", "ro", "attr", "rt", "RW", "wrap", "rf", "usr", "rue", "fw"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n     int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) {\n\n  uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY;\n\n  // yv12toyuy2( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );\n\n  uint8_t *ysrc = src[0];\n\n  uint8_t *usrc = src[1];\n\n  uint8_t *vsrc = src[2];\n\n  const int width = c->srcW;\n\n  const int height = srcSliceH;\n\n  const int lumStride = srcStride[0];\n\n  const int chromStride = srcStride[1];\n\n  const int dstStride = dstStride_a[0];\n\n  const vector unsigned char yperm = vec_lvsl(0, ysrc);\n\n  const int vertLumPerChroma = 2;\n\n  register unsigned int y;\n\n\n\n  if(width&15){\n\n    yv12toyuy2( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride);\n\n    return srcSliceH;\n\n  }\n\n\n\n  /* this code assume:\n\n\n\n  1) dst is 16 bytes-aligned\n\n  2) dstStride is a multiple of 16\n\n  3) width is a multiple of 16\n\n  4) lum&chrom stride are multiple of 8\n\n  */\n\n\n\n  for(y=0; y<height; y++)\n\n    {\n\n      int i;\n\n      for (i = 0; i < width - 31; i+= 32) {\n\n\tconst unsigned int j = i >> 1;\n\n\tvector unsigned char v_yA = vec_ld(i, ysrc);\n\n\tvector unsigned char v_yB = vec_ld(i + 16, ysrc);\n\n\tvector unsigned char v_yC = vec_ld(i + 32, ysrc);\n\n\tvector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm);\n\n\tvector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm);\n\n\tvector unsigned char v_uA = vec_ld(j, usrc);\n\n\tvector unsigned char v_uB = vec_ld(j + 16, usrc);\n\n\tvector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc));\n\n\tvector unsigned char v_vA = vec_ld(j, vsrc);\n\n\tvector unsigned char v_vB = vec_ld(j + 16, vsrc);\n\n\tvector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, vsrc));\n\n\tvector unsigned char v_uv_a = vec_mergeh(v_u, v_v);\n\n\tvector unsigned char v_uv_b = vec_mergel(v_u, v_v);\n\n\tvector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b);\n\n\tvector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b);\n\n\tvec_st(v_yuy2_0, (i << 1), dst);\n\n\tvec_st(v_yuy2_1, (i << 1) + 16, dst);\n\n\tvec_st(v_yuy2_2, (i << 1) + 32, dst);\n\n\tvec_st(v_yuy2_3, (i << 1) + 48, dst);\n\n      }\n\n      if (i < width) {\n\n\tconst unsigned int j = i >> 1;\n\n\tvector unsigned char v_y1 = vec_ld(i, ysrc);\n\n\tvector unsigned char v_u = vec_ld(j, usrc);\n\n\tvector unsigned char v_v = vec_ld(j, vsrc);\n\n\tvector unsigned char v_uv_a = vec_mergeh(v_u, v_v);\n\n\tvector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);\n\n\tvector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);\n\n\tvec_st(v_yuy2_0, (i << 1), dst);\n\n\tvec_st(v_yuy2_1, (i << 1) + 16, dst);\n\n      }\n\n      if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) )\n\n\t{\n\n\t  usrc += chromStride;\n\n\t  vsrc += chromStride;\n\n\t}\n\n      ysrc += lumStride;\n\n      dst += dstStride;\n\n    }\n\n\n\n  return srcSliceH;\n\n}\n", "idx": 9846, "substitutes": {"c": ["cit", "cr", "l", "oc", "C", "n", "g", "w", "m", "conn", "b", "t", "k", "d", "con", "cp", "ct", "s", "p", "e", "cd", "cu", "cf", "cn", "f", "cc", "ac", "cs", "ctrl", "ce", "ctx", "dc", "xc", "nc", "cm", "ca", "ci", "vc", "lc", "ch", "mc", "cy", "sc"], "src": ["chrom", "source", "sel", "scene", "http", "sur", "filename", "iv", "rect", "buf", "config", "rib", "dest", "attr", "split", "stab", "rss", "rb", "loc", "sq", "st", "inst", "sub", "cv", "rc", "input", "sl", "sup", "req", "ctx", "cur", "conv", "sn", "support", "sb", "scl", "usc", "impl", "url", "sit", "rob", "sr", "sc", "uc", "ssl", "secure"], "srcStride": ["srcRestro", "srcstri", "sourceStrip", "sourceRestride", "srcCurride", "srcShride", " srcStOverride", "srcstride", "srcStrid", "sourceStide", "srcShrip", "srcRestride", "sourceRestide", "srcStOverride", "srcStri", "srcRestOverride", "srcRestri", "srcShOverride", "srcRestrid", "sourceStride", "srcStyride", " srcStide", "sourceRestrip", " srcRestide", "sourceStrid", " srcstri", "srcStyrip", "srcCurrip", "srcRestrip", "srcShide", "srcScrip", " srcRestrip", "srcRestide", "srcScri", "srcStrip", "srcStyOverride", " srcStri", "srcstro", "sourceRestrid", "srcScro", " srcstro", "srcCuride", " srcStro", " srcStrip", "srcStro", " srcRestride", " srcstrip", " srcRestOverride", " srcstride", "srcScride", "srcStyide", "srcstrip", "srcCurrid", "srcStide"], "srcSliceY": ["srcPliceW", "srcSlaceW", "srcPliceX", "srcPlaceH", "srcSlaceH", "srcSlICEB", "srcPlICEY", "srcSlaceY", "srcSlICEX", "srcPlICEW", "srcSlICEW", "srcSliceB", "srcSlueB", "srcSliceX", "srcSlueY", "srcSlICEH", "srcPlaceW", "srcSlineY", "srcSlineH", "srcSlueW", "srcPlICEH", "srcSlineW", "srcSlaceB", "srcPlICEB", "srcSlueH", "srcSlaceX", "srcSlineX", "srcPlaceX", "srcSlICEY", "srcSliceW", "srcPlaceY", "srcPliceB", "srcPliceH", "srcPliceY"], "srcSliceH": ["srcSlaceh", "srcPliceW", "srcSlaceW", "srcPlaceh", "srcPliceX", "srcSliceN", "srcPlaceH", "srcSlaceH", "srcSlaseW", "srcSlaseY", "srcSlaseN", "srcSlaceY", "srcSlICEX", "srcPlICEW", "srcSlICEW", "srcSliceX", "srcSlaceN", "srcSlenseH", "srcPlaceW", "srcSlICEH", "srcSlaseH", "srcSlineY", "srcSliceh", "srcPlICEh", "srcSlineH", "srcSlueW", "srcPlICEH", "srcSlineW", "srcSlueN", "srcSlICEN", "srcSlueH", "srcSlenseW", "srcSlaceX", "srcSlineX", "srcPlaceX", "srcSlICEY", "srcPlICEN", "srcSliceW", "srcPlaceY", "srcPliceh", "srcPliceH", "srcPliceY", "srcSlueh", "srcSlenseh", "srcSlICEh", "srcPliceN", "srcSlenseY"], "dstParam": ["dscPar", "dscParam", "dscMode", "destPar", "DstPar", "dstMode", "DstParam", "dscParameter", "dstPar", "dspParam", "dspParameter", "inblParameter", "destParam", "inblMode", "dblMode", "DscPar", "dspPar", "instMode", "DscParam", "DstParameter", "instParam", "instPar", "destParameter", "dblParameter", "DstMode", "DscParameter", "destMode", "dblParam", "DscMode", "dspMode", "dblPar", "dstParameter", "inblPar", "inblParam", "instParameter"], "dstStride_a": ["dstStri_e", "dstStri_a", "dstStride4p", "dstStrite2A", "dstStride2a", "dstStri_m", "dstStrite_c", "dstStriteJp", "dstStride_p", "dstStrite_o", "dstStride_e", "dstStriteJc", "dstStride4o", "dstStride_A", "dstStrideJa", "dstStriteJe", "dstStrideJp", "dstStriteJa", "dstStrite_a", "dstStride2p", "dstStrite2p", "dstStride2o", "dstStride2A", "dstStrideJe", "dstStrite2o", "dstStrite_p", "dstStride_m", "dstStrite_A", "dstStrite_e", "dstStrideJc", "dstStride_c", "dstStride4a", "dstStrite2a", "dstStride_o", "dstStride4A"], "dst": ["DST", "dsrc", " dsc", "lsrc", "adST", "lsc", "Dsc", "dsc", " dcr", "Dsrc", " dsrc", " dST", "Dst", "dcr", "lcr", "lst", "dST", "adcr", "adsrc", "adst", "adsc"], "ysrc": ["syssrc", "sysrc", "rysrc", "dsroc", "ryssrc", "dsrc", "ynource", "gesource", "ynsrc", "source", "lsrc", "lsource", "iessrc", "pspc", "ieslc", "sRC", "lssrc", "ysrec", "geslc", "rsroc", "iesconfig", "sysroc", "ysroc", "dsrec", "sysconfig", "sysRC", "rsrc", "yspc", "gesrc", "ryslc", "dslc", "ynconfig", "rssrc", "anssrc", "iesrc", "lsRC", "iesource", "gessrc", "ysRC", "iesusc", "dsRC", "ysusc", "ansrc", "dssrc", "dsusc", "yslc", "ssrc", "rysusc", "ynrc", "yssrc", "ysource", "ysconfig", "anspc", "ansrec", "dsource", "dspc", "sysource", "psrc", "psrec", "pssrc", "rsRC"], "usrc": ["ussrc", "usrb", "unsrb", "mssrc", "srt", " ussrc", "slc", "asource", "sfc", "source", "srb", "ssdc", "msloc", "unslc", "sRC", "asrc", "ssr", "unsrc", "assrc", "ssRC", "rusrc", "uslc", "usr", " usr", "usource", "sssrc", "msrc", "USrc", " usdc", "USrb", "sloc", "USrt", "ssource", "ssrc", "usrt", "rusr", " usloc", "unsrt", "USlc", "msfc", "asRC", "russrc", "usfc", "rusdc", " usfc", "usloc", "usdc", "usRC"], "vsrc": [" vconst", "dsrc", "vrc", "svsrc", "svsource", "lsrc", "hconst", "ldest", "drc", "lconst", "lloc", "svrc", "vconst", "hloc", " vdest", "sdest", "vloc", "hsrc", "ddest", "hdest", "ssource", "ssrc", "svdest", "vdest", " vloc", "dsource", "vsource"], "y": ["ym", "ady", "yt", "oy", "n", "ry", "asy", "ny", "w", "m", "t", "x", "ey", "vy", "ye", "z", " Y", "b", "p", "iy", "yi", "ay", "zy", "yy", "sy", "gy", "j", "o", "py", "sky", "ky", "yd", "hy", "Y", "ty", " cy", "ies", "yr", "type", "dy", "h", "year", "ya", "cy", "yo"], "i": ["ani", "vi", "l", "ui", "di", "it", "start", "si", "n", "in", "zi", "m", "xi", "id", "iw", "k", "x", "b", "ini", "z", "ami", "uli", "ji", "p", "ix", "uri", "e", "yi", "mini", "ia", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "v", "gi", "mi", "phi", "ti", "ik", "qi", "bi", "pi", "ii", "init", "u", "h", "I", "li", "ip", "ci", "ni", "io", "ri", "fi", "iu"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,\n\n                                 unsigned npfd, int64_t timeout)\n\n{\n\n    if (!ctx->epoll_available) {\n\n        return false;\n\n    }\n\n    if (aio_epoll_enabled(ctx)) {\n\n        return true;\n\n    }\n\n    if (npfd >= EPOLL_ENABLE_THRESHOLD) {\n\n        if (aio_epoll_try_enable(ctx)) {\n\n            return true;\n\n        } else {\n\n            aio_epoll_disable(ctx);\n\n        }\n\n    }\n\n    return false;\n\n}\n", "idx": 16829, "substitutes": {"ctx": ["pc", "dc", "cc", "txt", "fw", "fp", "obj", "cca", "jp", "cus", "ct", "cor", "vc", "ctr", "cm", "cf", "cpp", "cb", "coll", "bc", "loc", "cp", "src", "this", "scope", "ctrl", "cas", "Context", "ca", "cs", "exec", "context", "hw", "cms", "ce", "pkg", "nc", "tx", "ci", "tc", "xc", "config", "sc", "cu", "cam", "cl", "cli", "lc", "c", "cr", "req", "qa", "kt", "client", "cmd", "cmp", "cn", "cv", "conn", "cci"], "pfds": ["pfda", "pfdc", "pfd", " pfd", " pfsda", "pcfds", "pfsd", " pfsd", "pfsds", "pfsda", " pfda", "pcfd", " pfsds", "pcfda", " pfdc", " pfsdc", "pfsdc", "pcfdc"], "npfd": [" tcpfc", "wpdf", "NPdf", "npf", "wpbf", "wpdc", " tcpfd", "NPdc", "NPfc", "vpFD", "fpf", "npfc", "npFD", "wpFD", "fpbf", "vpbf", "vpfd", "wpf", "wpfc", "NPfd", "fpFD", "wpfd", " tcpdc", "fpfd", "npbf", "npdc", " tcpdf", "npdf", "vpf"], "timeout": ["time", "name", "call", "base", "options", "err", "pool", "duration", "wait", "block", "cb", "max", "sec", "after", "out", "val", " max", "size", "args", "outs", "delay", "Timeout", "unit", "cache", "conn"]}}
{"project": "qemu", "commit_id": "bf298f83c35da854632c5be75733a4aa95a780bf", "target": 0, "func": "void tlb_set_page(CPUState *env, target_ulong vaddr,\n\n                  target_phys_addr_t paddr, int prot,\n\n                  int mmu_idx, target_ulong size)\n\n{\n\n    PhysPageDesc *p;\n\n    unsigned long pd;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    unsigned long addend;\n\n    CPUTLBEntry *te;\n\n    CPUWatchpoint *wp;\n\n    target_phys_addr_t iotlb;\n\n\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n    p = phys_page_find(paddr >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        pd = IO_MEM_UNASSIGNED;\n\n    } else {\n\n        pd = p->phys_offset;\n\n    }\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_set_page: vaddr=\" TARGET_FMT_lx \" paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\\n\",\n\n           vaddr, (int)paddr, prot, mmu_idx, is_softmmu, pd);\n\n#endif\n\n\n\n    address = vaddr;\n\n    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {\n\n        /* IO memory case (romd handled later) */\n\n        address |= TLB_MMIO;\n\n    }\n\n    addend = (unsigned long)qemu_get_ram_ptr(pd & TARGET_PAGE_MASK);\n\n    if ((pd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {\n\n        /* Normal RAM.  */\n\n        iotlb = pd & TARGET_PAGE_MASK;\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM)\n\n            iotlb |= IO_MEM_NOTDIRTY;\n\n        else\n\n            iotlb |= IO_MEM_ROM;\n\n    } else {\n\n        /* IO handlers are currently passed a physical address.\n\n           It would be nice to pass an offset from the base address\n\n           of that region.  This would avoid having to special case RAM,\n\n           and avoid full address decoding in every device.\n\n           We can't use the high bits of pd for this because\n\n           IO_MEM_ROMD uses these as a ram address.  */\n\n        iotlb = (pd & ~TARGET_PAGE_MASK);\n\n        if (p) {\n\n            iotlb += p->region_offset;\n\n        } else {\n\n            iotlb += paddr;\n\n        }\n\n    }\n\n\n\n    code_address = address;\n\n    /* Make accesses to pages with watchpoints go via the\n\n       watchpoint trap routines.  */\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) {\n\n            iotlb = io_mem_watch + paddr;\n\n            /* TODO: The memory case can be optimized by not trapping\n\n               reads of pages with a write breakpoint.  */\n\n            address |= TLB_MMIO;\n\n        }\n\n    }\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||\n\n            (pd & IO_MEM_ROMD)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&\n\n                   !cpu_physical_memory_is_dirty(pd)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 5381, "substitutes": {"env": ["eng", "cfg", "ea", "ep", "kn", "v", "ef", "config", "qt", "environment", "nc", "rc", "exc", "et", "enc", "queue", "eu", "inet", "db", "ext", "gui", "server", "obj", "init", "net", "conf", "ev", "np", "e", "en", "dev", "dc", "ctx", "exec", "ini", "Environment", "context", "ec", "network", "eni", "viron", "console", "global", "proc", "txt", "engine", "loader", "manager", "conn"], "vaddr": ["zaddress", "vadd", "vserver", " vserver", "voffset", "Voffset", " voffset", "vconfig", " vhost", "Vaddr", "zhost", "phost", "wadd", "faddr", "zaddr", " vconfig", "waddr", " vadd", "paddress", "vptr", "foffset", "tvaddr", "pptr", "Vaddress", "pserver", "fdr", "tvconfig", "pconfig", " vdr", "pdr", "qaddress", "tvaddress", "vhost", "zptr", " vaddress", "faddress", "vdr", "qaddr", "Vdr", "padd", "qhost", "qptr", "whost", "tvserver", "vaddress", "fhost", "fptr", "waddress"], "paddr": [" pmode", " poffset", "padded", "pyaddress", "vadd", " palign", "voffset", "vpairs", " voffset", "npaddr", "fadd", " pptr", "pyadded", "fmode", "pmode", "vpoffset", "vpalign", "pyaddr", "vpaddr", "vadded", "pairs", "faddr", "vpaddress", "npoffset", "pyoffset", "vpptr", "paddress", "vptr", "npairs", "valign", "pptr", "npaddress", " vairs", "vmode", " vaddress", "faddress", "palign", "poffset", "padd", " padd", " paddress", "vaddress", " padded"], "prot": ["stat", "fen", "ocol", "reset", "ret", "inf", "phy", "platform", "pro", "eth", " proto", "config", "rot", "rf", "Prot", "typ", "inet", "lit", "conv", "ext", "sil", "thin", "fl", "pri", "cli", "period", "np", "lo", "uri", "bis", "nat", "lat", "rx", "fp", " protocol", "rin", "iol", "prop", "addr", "dim", "prefix"], "mmu_idx": ["mmu_indg", "mmu_indb", "mmu_idf", "mmu_idg", "mmu_indf", "mmu_ridy", "mmu_ridv", "mmu_idy", "mmu_sidy", "mmu_idsxc", "mmu_idv", "mmu_sidv", "mmu_idsx", "mmu_idsy", "mmu_indx", "mmu_sidb", "mmu_idsv", "mmu_sidx", "mmu_sidf", "mmu_sidxc", "mmu_sidg", "mmu_ridx", "mmu_idxc", "mmu_ridxc", "mmu_idb"], "size": ["name", "SIZE", "large", "sec", "count", "fee", "shape", "value", "security", "sum", "data", "password", "sn", "si", "unit", "loc", "capacity", "offset", "limit", "length", "small", "Size", "ffff", "number", "code", "len", "uri", "en", "storage", "sized", "bytes", "empty", "timeout", "scale", "z", "global", "memory", "cap", "c", "class", "page", "desc", "ize", "max"], "p": ["cp", "P", "o", "bp", "python", "v", "pr", "parent", "pa", "pre", "po", "b", "pp", "i", "sync", "pe", "lp", "ap", "l", "pm", "f", "pi", "pg", "d", "j", "pc", "np", "dp", "e", "point", "w", "pn", "t", "n", "fp", "jp", "h", "vp", "sp", "c", "page", "api", "tp", "pb", "r", "ps", "pkg"], "pd": ["pat", "dh", "pins", "pm", "pi", "d", "td", "adh", "sd", "ped", "sha", "ppa", "gd", "dt", "tp", "pb", "mode", "nd", "cd", "plugin", "pid", " dd", "pod", "slice", "pattern", "pe", " rc", "php", "wordpress", "sth", "da", "ds", "xd", "pad", "dra", "ld", "std", "python", "pard", "md", "bd", "vd", "dat", "pa", "po", "pp", " prod", "wa", "lp", "ad", " sd", "att", "pc", "py", "np", "wd", "dp", "lda", "priority", "pos", "dep", "fd", "api", "dl", "dim", " delta", " td", "od", "pr", "dd", "si", "edd", "pg", "delay", " da", "dc", "PD", "hd"], "index": ["base", "position", "bin", "count", "ci", "config", "val", "si", "slice", "pattern", "loc", " indexes", "ion", "length", "pc", "fe", "ffff", "byte", "part", "len", "dc", "pos", "pointer", "type", "Index"], "address": ["area", "position", "entry", "ress", "shape", "Address", "object", "password", "alias", "module", "adjust", "image", "ace", "route", "region", "enter", "resource", "capacity", "package", "offset", "event", "order", "state", "server", "number", "code", "point", "uri", "message", "port", "array", "output", "network", "pointer", "memory", "attribute", "ip", "node", "location", "adr", "pair", "element", "addr", "host", "reference", "prefix"], "code_address": ["cache_number", "cache_reference", "data_address", "code_reference", "codeouthost", "data_addr", "code2address", "code2reference", "codeoutnumber", "code2host", "code_addr", "cache_host", "code_location", "code_number", "code2number", "data_location", "codeoutaddress", "code_host", "cache_address", "codeoutreference"], "addend": ["loadstart", "addstart", "loadending", " addends", " addending", "readest", "readends", "addends", "pushstart", "readend", "addpath", "pushend", "loadend", "addending", "Addends", "Addest", " addstart", "pushending", "Addpath", " addest", "Addend", "pushends", "addest", " addpath", "readpath", "loadends"], "te": ["ep", "inf", "fee", "ite", "ffe", "eu", "de", "ext", "ue", "fe", "ss", "e", "oe", "se", "inst", "tw", "we", "port", "oss", "ee", "ne", "eni", "ta", "slave", "txt", "ette", "pl", "au"], "wp": ["cp", "hp", "plugin", "gp", "hw", "bp", "ep", "fw", "wx", "pp", "op", "pod", "wm", "widget", "wk", "lp", "xp", "wb", "pg", "mp", "php", "arp", "pc", "wordpress", "np", "WP", "dp", "w", "pn", "dc", "ctx", "fp", "jp", "hop", "kw", "iw", "vp", "wu", "ip", "wl", "api", "tp", "pb"], "iotlb": ["iottb", "iottlas", "iotll", "cotlb", "otlas", "youtlp", "ontlp", "iollas", "youtlb", "otlr", "ietlp", "nitrb", "iollab", "iotla", "otrb", "ietlb", "ietb", "ietrb", "iotrb", "iotlab", "bootlas", "iollb", "iotl", "cotl", "otl", "bootlb", "iotlr", "iottlr", "youtl", "otb", "ietlr", "ittlp", "iottlp", "iotlp", "iottlab", "ittl", "nitla", "ittlb", "ietlab", "iottl", "ioll", "otlp", "ietll", "ittll", "iottlb", "ontlb", "nitl", "nitlb", "otlb", "bootl", "ontl", "ontll", "cotlp", "ietla", "iotb", "nitlp", "bootlab", "ietlas", "iotlas", "youtla", "ietl", "cotlas", "otlab"]}}
{"project": "FFmpeg", "commit_id": "290e7eb77bee5a54182fb3d5fb122c1e117190da", "target": 1, "func": "void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)\n\n{\n\n    int i;\n\n\n\n    for (i=0; i < in->n; i++) {\n\n        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);\n\n\n\n\n        do {\n\n            out[x] = 0.0;\n\n            x += in->pitch_lag;\n\n        } while (x < size && repeats);\n\n    }\n\n}", "idx": 14599, "substitutes": {"out": ["IN", "bin", "array", "sync", "up", "extra", "again", "io", "new", "null", "init", "v", "output", "conn", "o", "obj", "p", "ext", "base", "co", "dot", "point", "parent", "at", "line", "inc", "arr", "OUT", "outs", "In", "Out", "exec", "work", "prefix", "copy", "window", "err"], "in": ["IN", "bin", "isin", "lin", "slice", "input", "ins", "id", "ini", "vin", "again", "a", "or", "connection", "ci", "source", "image", "new", "this", "x", "inn", "str", "con", "gin", "update", "init", "inas", "conn", "win", "pass", "rec", "tin", "rin", "data", "reader", "old", "query", "token", "inc", "diff", "inner", "nin", "In", "ic", "login", "exec", "err"], "size": ["ice", "en", "small", "cm", "sized", "grow", "shift", "code", "shape", "io", "name", "g", "Size", "capacity", "si", "ii", "loc", "white", "form", "z", "ize", "e", "six", "time", "ix", "length", "n", "address", "c", "number", "SIZE", "scale", "empty", "iz", "len"], "i": ["hi", "qi", "ui", "m", "I", "d", "t", "ai", "ni", "xi", "id", "l", "ini", "gi", "iu", "a", "io", "mu", "ci", "h", "x", "di", "si", "ii", "v", "uri", "o", "w", "yi", "u", "z", "ind", "p", "e", "mi", "li", "k", "b", "min", "ix", "j", "multi", "n", "f", "ti", "ip", "c", "is", "pi", "r", "bi", "zi", "y", "index", "start"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int qesd_init_out (HWVoiceOut *hw, audsettings_t *as)\n\n{\n\n    ESDVoiceOut *esd = (ESDVoiceOut *) hw;\n\n    audsettings_t obt_as = *as;\n\n    int esdfmt = ESD_STREAM | ESD_PLAY;\n\n    int err;\n\n    sigset_t set, old_set;\n\n\n\n    sigfillset (&set);\n\n\n\n    esdfmt |= (as->nchannels == 2) ? ESD_STEREO : ESD_MONO;\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n    case AUD_FMT_U8:\n\n        esdfmt |= ESD_BITS8;\n\n        obt_as.fmt = AUD_FMT_U8;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n    case AUD_FMT_U32:\n\n        dolog (\"Will use 16 instead of 32 bit samples\\n\");\n\n\n\n    case AUD_FMT_S16:\n\n    case AUD_FMT_U16:\n\n    deffmt:\n\n        esdfmt |= ESD_BITS16;\n\n        obt_as.fmt = AUD_FMT_S16;\n\n        break;\n\n\n\n    default:\n\n        dolog (\"Internal logic error: Bad audio format %d\\n\", as->fmt);\n\n        goto deffmt;\n\n\n\n    }\n\n    obt_as.endianness = AUDIO_HOST_ENDIANNESS;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n\n\n    hw->samples = conf.samples;\n\n    esd->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!esd->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        return -1;\n\n    }\n\n\n\n    esd->fd = -1;\n\n    err = pthread_sigmask (SIG_BLOCK, &set, &old_set);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    esd->fd = esd_play_stream (esdfmt, as->freq, conf.dac_host, NULL);\n\n    if (esd->fd < 0) {\n\n        qesd_logerr (errno, \"esd_play_stream failed\\n\");\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&esd->pt, qesd_thread_out, esd, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask(restore) failed\\n\");\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    if (close (esd->fd)) {\n\n        qesd_logerr (errno, \"%s: close on esd socket(%d) failed\\n\",\n\n                     AUDIO_FUNC, esd->fd);\n\n    }\n\n    esd->fd = -1;\n\n\n\n fail2:\n\n    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask(restore) failed\\n\");\n\n    }\n\n\n\n fail1:\n\n    qemu_free (esd->pcm_buf);\n\n    esd->pcm_buf = NULL;\n\n    return -1;\n\n}\n", "idx": 7498, "substitutes": {"hw": ["hp", "nv", "gp", "rw", " HW", "nw", "eng", "fw", "wei", "wx", "nas", "sw", "wan", "hz", "ow", "wm", "hhh", "wp", "umi", "wk", "gpu", "wa", "haw", "rh", "wb", "wy", "him", "wo", "usb", "dq", "np", "wd", "hm", "w", "ohm", "tw", "hh", "ctx", "zh", "wcs", "cu", "hop", "voc", "ww", "ou", "kw", "ogg", "wire", "h", "iw", "vp", "war", "wav", "wu", "aff", "ht", "gh", "mm", "lv", "gg", "vc", "cow", "conn", "pkg", "aw"], "as": ["bas", "ch", "act", "asu", "is", "a", "nas", "s", "sw", "asa", "mas", "session", "pas", "ow", "or", "ap", "sys", "AS", "mac", "was", "ga", "ns", "has", "av", "res", "from", "us", "ss", "conf", "cs", "ay", "sh", "ars", "ar", "auth", "gs", "As", "an", "instance", "ase", "ask", "self", "asm", "asha", "aws", "pos", "am", "acs", "sa", "os", "mm", "ms", "ams", "asc", "ach", "inas", "ac", "aus", "rs", "ras", "ast", "ass", "aw"], "esd": ["lesdl", "esdl", "asdb", "etsd", "lsds", "eesd", "sesdn", " esds", "gesd", "gesds", "owsdk", "zesds", " esdb", "ossdk", "asd", "essds", "sesd", "lssd", "openspd", "sesds", "lsd", "essdk", "essd", "eesdb", "essdb", "lsdb", "usd", "ossds", "gesdk", "essdn", "sesdk", "opensdk", "esds", "asdk", "opensds", "asds", "eesdl", "espd", "owsdl", "ossd", "esdb", "zessd", "lesdb", "usdb", "lesds", "owsds", "esssd", "zesd", "usds", "etspd", "esspd", "lesd", "gesdn", " esdk", "essdl", "esdn", "esdk", "zesdb", "eesds", "usdk", "owsd", "ossdl", "etsdk", "etsds", "opensd"], "err": ["gr", "dr", "fg", "fam", "er", "act", "yer", "aer", "fr", "iter", "fy", "id", "rr", "pr", "fee", "rag", "icer", "bug", "rc", "ise", "loc", "der", "rh", "rage", "eor", "ir", "f", "attr", "ler", "order", "call", "nr", "magic", "res", "acer", "rar", "e", "error", "ar", "die", "arr", " error", "lr", "str", "result", "ec", "req", "wr", "finder", "ner", "erer", "mr", "ver", "ind", "fer", "errors", "g", "resp", "y", "orig", "yr", "Er", "test", "kr", "r", "Error", "found", "msg"], "set": ["base", "sets", "reset", "sec", "store", "id", "not", "dat", "send", "check", "ets", "get", "setting", "sort", "update", "use", "SET", "sync", "et", "sett", "valid", "client", "Set", "server", "mod", "init", "match", "sent", "sc", "mit", "sign", "str", "parse", "ut", "vert", "zero", "start", "gen", "cast", "write", "type", "read", "clear", "util", "end", "setup", "size"], "old_set": ["objvalreset", "objvalsets", "oldvalreset", " old_sets", "obj_sc", "old_start", "obj_set", "objvalset", "oldvalset", "objvalsc", "oldvalsc", "old_sc", " old_start", " old_settings", "old_sets", "oldvalsets", "obj_reset", "obj_sets", "old_settings", "old_reset"]}}
{"project": "qemu", "commit_id": "231bb267644ee3a9ebfd9c7f42d5d41610194b45", "target": 1, "func": "int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs,\n\n            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,\n\n            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16465, "substitutes": {"bs": ["ns", "ab", "ros", "eb", "bi", "db", "lbs", "blog", "core", "obj", "ob", "las", "rs", "plugins", "sb", "cb", "bc", "ls", "ss", "src", "pb", "fs", "lb", "bb", "ba", "bid", "cs", "css", "gb", "bos", "ins", "obs", "outs", "BS", "iss", "blocks", "bis", "abi", "bl", "vs", "fb", "bh", "ses", "bas", "js", "rb", "bits", "b", "ks", "ec", "es", "bytes", "os", "state", "bes", "banks", "us", "ds"], "l1_index": ["l2_index", "l2_i", "l1_Index", "l1_i", "l1rindex", "l1roffset", "l2_Index", "l1rIndex", "l1_offset", "l1_length", "l1raddress", "l1_address", "l2_offset", "l2_length", "l2_address"], "s": ["ns", "spec", "session", "ts", "stats", "rs", "uns", "f", "settings", "services", "r", "n", "ubs", "sb", "sl", "ss", "ls", "ops", "fs", "xs", "is", "cs", "d", "su", "ins", "args", "site", "w", "bis", "qs", "e", "ssl", "vs", "ses", "v", "c", "js", "si", "ps", "sym", "p", "S", "b", "ks", "gs", "sys", "its", "es", "os", "state", "us", "sets", "states", "ds"], "buf": ["Buffer", "ab", "bin", "br", "fw", "ff", "db", "data", "af", "func", "base", "fp", "text", "pool", "buffer", "rc", "vec", "fi", "stab", "result", "cf", "block", "cb", "bc", "Buff", "wb", "ctx", "fab", "pb", "bb", "mem", "ba", "cas", "gb", "conv", "bed", "bf", "box", "aux", "img", "config", "queue", "bd", "fd", "buff", "bh", "fb", "cat", "v", "ucc", "tmp", "seq", "cmd", "uc", "rb", "pad", "b", "null", "cap", "alloc", "proc", "bytes", "port", "bag", "uf", "cv"], "l1_start_index": ["l1_start_size", "l1_end_size", "l1_start1size", "l1_start64offset", "l1_start_end", "l1_end_end", "l1_end_value", "l1_end_shape", "l1_start_offset", "l1_start64size", "l1_start_ind", "l1_start1offset", "l1_start_position", "l1_start64index", "l1_end_ind", "l1_startpindex", "l1_end_offset", "l1_startpend", "l1_startpposition", "l1_start64ind", "l1_start1ind", "l1_start1index", "l1_end_index", "l1_start_shape", "l1_end_point", "l1_start_value", "l1_end_position", "l1_start_point"], "i": ["gi", "uri", "ti", "m", "bi", "j", "ji", "x", "f", "ix", "ini", "qi", "r", "ai", "io", "n", "z", "ii", "in", "di", "iu", "index", "I", "zi", "o", "l", "d", "oi", "pi", "ui", "ci", "id", "e", "k", "v", "lc", "c", "ni", "si", "ri", "p", "xi", "b", "mu", "anti", "u", "h", "a", "it", "eni", "fi", "li", "len"], "ret": ["vr", "al", "bit", "ref", "err", "f", "alt", "obj", "reg", "rc", "nt", "mi", "rt", "r", "fun", "result", "num", "lit", "rel", "flag", "match", "bc", "pass", "ext", "run", "rf", "active", "resp", "rets", "en", "def", "get", "out", "arg", "att", "art", "arr", "bad", "val", "re", "Ret", "feat", "bf", "reset", "back", "id", "det", "rev", "cat", "rb", "ur", "repl", "RET", "error", "red", "res", "mt", "ft", "fi", "reply", "success", "len"]}}
{"project": "FFmpeg", "commit_id": "69d0a2922f76e4e121c9f434bdf29f55b26c0c66", "target": 0, "func": "static av_cold int sonic_encode_init(AVCodecContext *avctx)\n\n{\n\n    SonicContext *s = avctx->priv_data;\n\n    PutBitContext pb;\n\n    int i, version = 0;\n\n\n\n    if (avctx->channels > MAX_CHANNELS)\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono and stereo streams are supported by now\\n\");\n\n        return AVERROR(EINVAL); /* only stereo or mono for now */\n\n    }\n\n\n\n    if (avctx->channels == 2)\n\n        s->decorrelation = MID_SIDE;\n\n    else\n\n        s->decorrelation = 3;\n\n\n\n    if (avctx->codec->id == AV_CODEC_ID_SONIC_LS)\n\n    {\n\n        s->lossless = 1;\n\n        s->num_taps = 32;\n\n        s->downsampling = 1;\n\n        s->quantization = 0.0;\n\n    }\n\n    else\n\n    {\n\n        s->num_taps = 128;\n\n        s->downsampling = 2;\n\n        s->quantization = 1.0;\n\n    }\n\n\n\n    // max tap 2048\n\n    if ((s->num_taps < 32) || (s->num_taps > 1024) ||\n\n        ((s->num_taps>>5)<<5 != s->num_taps))\n\n    {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid number of taps\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    // generate taps\n\n    s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant));\n\n    for (i = 0; i < s->num_taps; i++)\n\n        s->tap_quant[i] = ff_sqrt(i+1);\n\n\n\n    s->channels = avctx->channels;\n\n    s->samplerate = avctx->sample_rate;\n\n\n\n    s->block_align = 2048LL*s->samplerate/(44100*s->downsampling);\n\n    s->frame_size = s->channels*s->block_align*s->downsampling;\n\n\n\n    s->tail_size = s->num_taps*s->channels;\n\n    s->tail = av_calloc(s->tail_size, sizeof(*s->tail));\n\n    if (!s->tail)\n\n        return AVERROR(ENOMEM);\n\n\n\n    s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) );\n\n    if (!s->predictor_k)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < s->channels; i++)\n\n    {\n\n        s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples));\n\n        if (!s->coded_samples[i])\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples));\n\n\n\n    s->window_size = ((2*s->tail_size)+s->frame_size);\n\n    s->window = av_calloc(s->window_size, sizeof(*s->window));\n\n    if (!s->window)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avctx->extradata = av_mallocz(16);\n\n    if (!avctx->extradata)\n\n        return AVERROR(ENOMEM);\n\n    init_put_bits(&pb, avctx->extradata, 16*8);\n\n\n\n    put_bits(&pb, 2, version); // version\n\n    if (version == 1)\n\n    {\n\n        put_bits(&pb, 2, s->channels);\n\n        put_bits(&pb, 4, code_samplerate(s->samplerate));\n\n    }\n\n    put_bits(&pb, 1, s->lossless);\n\n    if (!s->lossless)\n\n        put_bits(&pb, 3, SAMPLE_SHIFT); // XXX FIXME: sample precision\n\n    put_bits(&pb, 2, s->decorrelation);\n\n    put_bits(&pb, 2, s->downsampling);\n\n    put_bits(&pb, 5, (s->num_taps >> 5)-1); // 32..1024\n\n    put_bits(&pb, 1, 0); // XXX FIXME: no custom tap quant table\n\n\n\n    flush_put_bits(&pb);\n\n    avctx->extradata_size = put_bits_count(&pb)/8;\n\n\n\n    av_log(avctx, AV_LOG_INFO, \"Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\\n\",\n\n        version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling);\n\n\n\n    avctx->frame_size = s->block_align*s->downsampling;\n\n\n\n    return 0;\n\n}\n", "idx": 3743, "substitutes": {"avctx": ["afconfig", "aveconfig", "evctx", "AVctx", "evcontext", "alconn", "avectx", "appcontext", "evcf", "avconn", "afcmp", "afctx", "afcontext", "avecf", "alcontext", "aveconn", "alctx", " avcli", "avcli", "appctx", "appcmp", "AVconn", "avcf", " avcontext", " avcf", "AVconfig", "rafconn", "rafctx", "afconn", "afcn", "AVcms", "afcms", "abctx", "appcn", "rafcms", "afcf", "avcn", "AVcn", "avconfig", "abconfig", "avcontext", "abconn", "abcontext", "avecontext", "evconn", "rafcontext", "AVcf", "avcmp", "AVcli", "AVcmp", "AVcontext", "alcli", "avecmp", "avcms", " avconn"], "s": ["sg", "js", "this", "qs", "n", "sites", "g", "ses", "ls", "args", "vs", "self", "us", "f", "secondary", "sys", "sc", "u", "your", "fs", "parts", "spec", "ts", "aws", "ims", "uns", "xs", "sets", "p", "e", "conf", "as", "uses", "v", "less", "su", "site", "S", "t", "session", "ks", "os", "its", "bs", "hs", "in", "sym", "plugins", "ssl", "cs", "ctx", "ss", "rs", "a", "new", "r", "is", "ins", "m", "settings", "ds", "ps", "gs", "native", "ns", "h", "c", "rates", "es", "sec", "o", "si", "server", "ops", "d", "results", "ms", "sync", "ats", "tests", "l", "services", "w", "features", "sq", "stats", "b", "full", "states"], "pb": [" img", " config", "ctx", " sc", " std", " subp", " src", " self", " acc", " enc", " out", " conv", " impl", " plugin", " app", " cipher", " sp", " conf", " proto", " parent", " pl", " sup", " mc", " rc"], "i": ["yi", "version", "li", "abi", "gi", "counter", "a", "key", "ni", "ii", "zi", "chi", "ji", "current", "pi", "ui", "mini", "d", "n", "I", "type", "di", "id", "mi", "uli", "k", "iu", "it", "num", "j", "y", "eni", "m", "inner", "info", "ti", "multi", "index", "z", "ini", "ai", "x", "ip", "hi", "p", "phi", "bi", "c", "e", "len", "u", "o", "v", "ix", "qi", "b", "t", "ci", "count", "io", "mu", "fi", "si", "in", "xi"]}}
{"project": "qemu", "commit_id": "5d79b80b335c5f65f148d1bb1672d9d534ace73b", "target": 0, "func": "static void pflash_write(pflash_t *pfl, hwaddr offset,\n\n                         uint32_t value, int width, int be)\n\n{\n\n    uint8_t *p;\n\n    uint8_t cmd;\n\n\n\n    cmd = value;\n\n\n\n    DPRINTF(\"%s: writing offset \" TARGET_FMT_plx \" value %08x width %d wcycle 0x%x\\n\",\n\n            __func__, offset, value, width, pfl->wcycle);\n\n\n\n    if (!pfl->wcycle) {\n\n        /* Set the device in I/O access mode */\n\n        memory_region_rom_device_set_readable(&pfl->mem, false);\n\n    }\n\n\n\n    switch (pfl->wcycle) {\n\n    case 0:\n\n        /* read mode */\n\n        switch (cmd) {\n\n        case 0x00: /* ??? */\n\n            goto reset_flash;\n\n        case 0x10: /* Single Byte Program */\n\n        case 0x40: /* Single Byte Program */\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            break;\n\n        case 0x20: /* Block erase */\n\n            p = pfl->storage;\n\n            offset &= ~(pfl->sector_len - 1);\n\n\n\n            DPRINTF(\"%s: block erase at \" TARGET_FMT_plx \" bytes %x\\n\",\n\n                    __func__, offset, (unsigned)pfl->sector_len);\n\n\n\n            if (!pfl->ro) {\n\n                memset(p + offset, 0xff, pfl->sector_len);\n\n                pflash_update(pfl, offset, pfl->sector_len);\n\n            } else {\n\n                pfl->status |= 0x20; /* Block erase error */\n\n            }\n\n            pfl->status |= 0x80; /* Ready! */\n\n            break;\n\n        case 0x50: /* Clear status bits */\n\n            DPRINTF(\"%s: Clear status bits\\n\", __func__);\n\n            pfl->status = 0x0;\n\n            goto reset_flash;\n\n        case 0x60: /* Block (un)lock */\n\n            DPRINTF(\"%s: Block unlock\\n\", __func__);\n\n            break;\n\n        case 0x70: /* Status Register */\n\n            DPRINTF(\"%s: Read status register\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x90: /* Read Device ID */\n\n            DPRINTF(\"%s: Read Device information\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x98: /* CFI query */\n\n            DPRINTF(\"%s: CFI query\\n\", __func__);\n\n            break;\n\n        case 0xe8: /* Write to buffer */\n\n            DPRINTF(\"%s: Write to buffer\\n\", __func__);\n\n            pfl->status |= 0x80; /* Ready! */\n\n            break;\n\n        case 0xf0: /* Probe for AMD flash */\n\n            DPRINTF(\"%s: Probe for AMD flash\\n\", __func__);\n\n            goto reset_flash;\n\n        case 0xff: /* Read array mode */\n\n            DPRINTF(\"%s: Read array mode\\n\", __func__);\n\n            goto reset_flash;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        pfl->wcycle++;\n\n        pfl->cmd = cmd;\n\n        break;\n\n    case 1:\n\n        switch (pfl->cmd) {\n\n        case 0x10: /* Single Byte Program */\n\n        case 0x40: /* Single Byte Program */\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n                pflash_update(pfl, offset, width);\n\n            } else {\n\n                pfl->status |= 0x10; /* Programming error */\n\n            }\n\n            pfl->status |= 0x80; /* Ready! */\n\n            pfl->wcycle = 0;\n\n        break;\n\n        case 0x20: /* Block erase */\n\n        case 0x28:\n\n            if (cmd == 0xd0) { /* confirm */\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) { /* read array mode */\n\n                goto reset_flash;\n\n            } else\n\n                goto error_flash;\n\n\n\n            break;\n\n        case 0xe8:\n\n            DPRINTF(\"%s: block write of %x bytes\\n\", __func__, value);\n\n            pfl->counter = value;\n\n            pfl->wcycle++;\n\n            break;\n\n        case 0x60:\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0x01) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: Unknown (un)locking command\\n\", __func__);\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        case 0x98:\n\n            if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: leaving query mode\\n\", __func__);\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 2:\n\n        switch (pfl->cmd) {\n\n        case 0xe8: /* Block write */\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n            } else {\n\n                pfl->status |= 0x10; /* Programming error */\n\n            }\n\n\n\n            pfl->status |= 0x80;\n\n\n\n            if (!pfl->counter) {\n\n                hwaddr mask = pfl->writeblock_size - 1;\n\n                mask = ~mask;\n\n\n\n                DPRINTF(\"%s: block write finished\\n\", __func__);\n\n                pfl->wcycle++;\n\n                if (!pfl->ro) {\n\n                    /* Flush the entire write buffer onto backing storage.  */\n\n                    pflash_update(pfl, offset & mask, pfl->writeblock_size);\n\n                } else {\n\n                    pfl->status |= 0x10; /* Programming error */\n\n                }\n\n            }\n\n\n\n            pfl->counter--;\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 3: /* Confirm mode */\n\n        switch (pfl->cmd) {\n\n        case 0xe8: /* Block write */\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else {\n\n                DPRINTF(\"%s: unknown command for \\\"write block\\\"\\n\", __func__);\n\n                PFLASH_BUG(\"Write block confirm\");\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    default:\n\n        /* Should never happen */\n\n        DPRINTF(\"%s: invalid write state\\n\",  __func__);\n\n        goto reset_flash;\n\n    }\n\n    return;\n\n\n\n error_flash:\n\n    qemu_log_mask(LOG_UNIMP, \"%s: Unimplemented flash cmd sequence \"\n\n                  \"(offset \" TARGET_FMT_plx \", wcycle 0x%x cmd 0x%x value 0x%x)\"\n\n                  \"\\n\", __func__, offset, pfl->wcycle, pfl->cmd, value);\n\n\n\n reset_flash:\n\n    memory_region_rom_device_set_readable(&pfl->mem, true);\n\n\n\n    pfl->bypass = 0;\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n}\n", "idx": 19198, "substitutes": {"pfl": ["lpfe", "ppflo", "execfl", "ppsl", "prefly", "gflo", "gfw", "ppform", "perf", "lpcol", "Pfly", "copfl", " pFL", "pbf", "preflo", "pfw", "pflash", "Pbf", "perFL", " psl", "wpf", "pfx", "PFL", "Pf", "peull", "gbf", "wpl", "presl", "wpFL", "tfly", "wpfly", "ppl", " pfc", "copfr", "prefi", "lpfx", "perfl", "ppfw", "Pfc", " pfi", "copFL", "Pform", "gFL", " pfly", "wfl", "Pzl", "tpsl", "pfr", "tpFL", "pfe", "lpull", "tpbf", "tfx", "wcl", "tfe", " pcol", "pecol", "Pflush", "pfly", "gsl", "Pflo", "lpfi", "copflo", "wFL", "Pcoll", "tll", "pfc", "Pflash", "tFL", "pefl", "ppfe", "prefl", "psl", " pzl", "tfl", " pflush", "lpflush", " pf", "pflush", "execflo", " pcl", "Pfe", "percoll", "pcoll", "copfly", " pcoll", "Pfl", "peFL", "pcl", " pfe", "Psl", "ppflush", " pull", "ppf", "pflo", "Ppl", "pform", " pflo", "lpfl", "tpfly", "pf", "ppFL", "execflash", "pfi", " ppl", "tfr", "pcol", "gf", "pzl", "pll", "lpFL", "ppfl", "wpfl", " pform", "copsl", "lpll", "pull", "Pfr", "execFL", "tpfl", "gfe", "precol", " pfx", " pll", "gflash", "tcl", "lpflo", "tpflo", "ppfc", " pfw", "pFL", "Pcl", "gfl", "ppzl"], "offset": ["entry", "part", "data", "info", "Offset", "af", "ref", "image", "attribute", "f", "fp", "op", "mode", "annot", "align", "num", "i", "loc", "phase", "padding", "index", "ptr", "pos", "slice", "timeout", "count", "pointer", "online", "o", "range", "l", "location", "slot", "alias", "size", "adjust", "initial", "length", "start", "limit", "layout", "position", "off", "address", "shift", "pad", "area", "enabled", "number", "origin", "api", "addr", "end", "port", "usage", "operation", "attr", "len"], "value": ["set", "native", "values", "scale", "Value", "content", "data", "text", "mode", "name", "image", "op", "buffer", "option", "window", "current", "type", "max", "function", "padding", "index", "create", "range", "val", "array", "format", "complete", "size", "memory", "flow", "w", "length", "start", "buf", "v", "update", "VALUE", "off", "output", "write", "weight", "message", "end", "port", "usage", "command", "version", "wave"], "be": ["s", "code", "mode", "bit", "op", "buffer", "pos", "count", "val", " mode", "le", "w", "buff", "buf", "bits", "pad", "b", "cap", " buffer", "loop", "cut", "write", "port"], "p": ["pc", "m", "point", "j", "t", "data", "fp", "x", "f", "jp", "op", "sp", "r", "pe", "n", "g", "i", "bp", "z", "pb", "ap", "pointer", "o", "ip", "l", "d", "array", "pre", "w", "e", "q", "v", "parent", "c", "b", "cache", "h", "tp", "port", "np", "P", "u"], "cmd": ["grad", "stat", "cfg", "bit", "ref", "op", "md", "align", "cf", "cod", "config", "prefix", "id", "send", "cli", "qq", "opt", "carry", "command", "cc", "target", "plugin", "content", "init", "mod", "wx", "name", "bind", "ctr", "fun", "cp", "msg", "force", "read", "update", "cat", "bg", "reason", "mac", "status", "gn", "code", "text", "cookie", "call", "component", "cb", "type", "mem", "byte", "help", "ctrl", "ack", "generic", "buf", "cd", "state", "func", "mode", "module", "method", "MD", "kind", "ctx", "acl", "def", "header", "Cmd", "pkg", "cl", "req", "seq", "url", "cmp", "sid", "custom"], "wcycle": ["xcle", "ewstage", "fwyear", "fwsec", " wyear", "wuse", " wsync", "swuse", "swcycle", "swcle", " wuse", "awsec", "wcle", "wyear", " wcycl", "rwcycle", "wsec", "ewcycle", " wsec", "wstage", " wstage", "fwcycle", "wsync", "awcycle", " wcle", "rwstage", "awcycl", "xuse", "fwcycl", "wcycl", "xcycl", "ewsync", "awyear", "xcycle", "rwsync", "swcycl"]}}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){\n\n    int y;\n\n    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;\n\n    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;\n\n\n\n    for(y=-2; y<height; y+=2){\n\n        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;\n\n        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;\n\n\n\n{START_TIMER\n\n        if(b1 <= b3)     horizontal_decompose53i(b2, width);\n\n        if(y+2 < height) horizontal_decompose53i(b3, width);\n\nSTOP_TIMER(\"horizontal_decompose53i\")}\n\n\n\n{START_TIMER\n\n        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);\n\n        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);\n\nSTOP_TIMER(\"vertical_decompose53i*\")}\n\n\n\n        b0=b2;\n\n        b1=b3;\n\n    }\n\n}\n", "idx": 14942, "substitutes": {"buffer": ["seek", "bridge", "transfer", "database", "slice", "queue", "batch", "memory", "container", "player", "binary", "FFER", "source", "reference", "audio", "image", "manager", "border", "writer", "position", "comment", "server", "table", "buff", "document", "loader", "surface", "view", "size", "buf", "Buffer", "reader", "length", "result", "url", "uffer", "file", "iter", "cache", "header", "window", "program", "texture", "material", "filename"], "height": ["upper", "stroke", "head", "Height", "deep", "input", "thin", "d", "bottom", "my", "id", "level", "density", "shape", "style", "name", "row", "gap", "border", "image", "h", "x", "capacity", "third", "rows", "crop", "rank", "hang", "w", "size", "tight", "direction", "three", "distance", "han", "length", "flow", "padding", "resolution", "inches", "above", "dim", "wall", "center", "layout", "history", "volume", "high", "window", "ty", "depth", "header", "lat"], "stride": ["striided", "strid", "stade", " strine", "Strance", "Strine", "arrend", "striride", "strride", "dride", " strade", " strid", " strride", "Strride", "Stride", "stided", "Strade", "STRide", "stend", "STRine", "striine", "strided", "arrided", "arrid", "strone", "grid", "drine", "drid", "strade", "STRride", "STRid", " strance", "grend", "drone", "Strided", "grade", "drend", "strance", "drride", "trride", "arride", "gride", "Strid", "stide", "trance", "grided", "arrade", "grone", "arrone", "tride", "striide", "trade", "drided", "strend", "strine"], "y": ["ny", "yt", "ch", "hy", "ys", "t", "sky", "id", "l", "i", "ish", "ey", "yd", "py", "h", "x", "cy", "gy", "by", "ym", "ye", "yer", "o", "col", "yi", "dy", "w", "z", "ady", "yl", "p", "yr", "b", "yo", "j", "yn", "oy", "ay", "vy", "ry", "yu", "yah", "year", "Y", "ya", "ky", "xy", "yy", "zy", "ty", "sy"], "b0": ["p2", "B0", "bb2", "p4", "p0", "p05", "p3", " b4", "bb0", "f2", "bb5", "f0", "br1", "p1", "br05", "bb1", "f05", "B2", "B3", "f3", "b4", "bb4", "B4", "f1", "f5", " b5", "br2", "f4", "b05", "br0", "b5", "bb3"], "b1": ["p2", "B0", "bb2", "a1", "p3", " bone", "a0", "f2", "bb0", "f0", "p1", "b11", "bb1", "B1", "B2", "B3", "f3", "bbone", "fone", " b11", "f1", "p11", "a2", "f11", "a3", "bb3", "bone"], "b2": ["b6", "l3", "buff1", "B0", "b32", "bbb", "bb2", "l1", "btwo", "bufftwo", "bb", "bbtwo", " b32", "l2", "bb0", "f2", "sbb", "B6", "f0", "buff0", "bb1", "l0", "B1", " b6", "buff2", "bb32", "B2", "f3", "sb2", "f32", "sb0", "f1", "sb3", " btwo", "bb3", " bb", "bb6"], "b3": ["b6", "l3", "b33", "bb2", "f8", "l1", "fthree", "w3", "bThird", " bThird", "embThird", "emb6", "wThree", "bthree", "emb1", " b33", "l2", "abbThree", "bb0", "f2", " b8", "abb6", "f0", "bb1", "bThree", "w1", "l0", " b6", "bbthree", "fThree", "b8", "f3", "b4", "f33", "bb33", "l8", "emb3", "bb4", "embThree", "abbThird", " bThree", "f1", " bthree", "f4", "l4", "wthree", "embthree", "abb3", "bb3"]}}
{"project": "qemu", "commit_id": "9e472e101f37233f4e32d181d2fee29014c1cf2f", "target": 1, "func": "static int qemu_signalfd_compat(const sigset_t *mask)\n\n{\n\n    pthread_attr_t attr;\n\n    pthread_t tid;\n\n    struct sigfd_compat_info *info;\n\n    int fds[2];\n\n\n\n    info = malloc(sizeof(*info));\n\n    if (info == NULL) {\n\n        errno = ENOMEM;\n\n        return -1;\n\n    }\n\n\n\n    if (pipe(fds) == -1) {\n\n        free(info);\n\n        return -1;\n\n    }\n\n\n\n    memcpy(&info->mask, mask, sizeof(*mask));\n\n    info->fd = fds[1];\n\n\n\n    pthread_attr_init(&attr);\n\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n\n\n    pthread_create(&tid, &attr, sigwait_compat, info);\n\n\n\n    pthread_attr_destroy(&attr);\n\n\n\n    return fds[0];\n\n}\n", "idx": 9510, "substitutes": {"mask": ["count", "diff", "map", "alias", "conf", "Mask", "arr", "filter", "fix", "delay", "flag", "scale", "comment", "auth", "depth", "key", "pad", "id", "pack", "mount", "mm", "block", "data", "sum", "config", "addr", "reg", "secret", "bits", "sk", "mode", "code", "mark", "shape", "size", "trace", "flags", "wait", "address", "mod", "ask", "user", "patch", "check", "offset", "bit", "lock", "allow", "type", "dev", "header", "image", "result", "cache", "buff", "weight", "buffer"], "attr": ["alias", "adr", "arr", "cmp", "si", "alt", "access", "class", "perm", "method", "conn", "rr", "stat", "config", "addr", "ref", "app", "cb", "rel", "ptr", "rad", "prop", "atts", "rs", "f", "ac", "rb", "ai", "rt", "ctrl", "py", "opt", "sync", "ind", "attach", "r", "att", "address", "err", "mut", "ii", "offset", "spec", "error", "type", "layer", "api", "attribute", "func", "cache", "match", "fac", "ann", "fi", "typ", "acc"], "tid": ["Tname", "untids", " tone", "pids", "pid", "tids", " tids", "untid", "nids", "pip", "toid", "nid", "nname", "pone", "tip", "untname", " tip", "Toid", "fids", "fid", "noid", "fip", "fone", "Tids", "tname", "untoid", "tone", "Tid"], "info": ["diff", "alias", "hi", "conf", "ui", "fo", "start", "si", "Info", "handle", "source", "comment", "is", "def", "ext", "id", "conn", "http", "inter", "ami", "update", "fw", "i", "data", "config", "INFO", "obj", "afi", "txt", "thin", "args", "bug", "f", "op", "py", "trace", "index", "hand", "name", "gi", "order", "att", "inner", "raf", "part", "error", "ii", "offset", "now", "init", "link", "type", "self", "lock", "handler", "api", "options", "fs", "ignore", "image", "result", "inf", "cache", "ret", "extra", "help", "fi", "buff"], "fds": [" fns", "tfds", "ifords", "ifds", " fDS", "fdds", "rfd", "ofords", "afDS", "sfds", "fDS", " fdes", "fdes", "pdds", "fd", "dfdds", "fmails", "ofns", "fords", "sfdds", " fords", " fdd", "sfdes", " fd", "pDS", "fdd", "afds", " fmails", "ifns", "fns", "dfds", "dfmails", "rfds", "afdds", "tfdds", "sfdd", "ofds", "rfdds", "tfdes", "rfmails", "tfdd", " fdds", "afns", "ifdds", "pns", "dfd", "pds", "ofdds"]}}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_quit(int argc, const char **argv)\n\n{\n\n    exit(0);\n\n}\n", "idx": 25580, "substitutes": {"argc": [" argf", "argsf", "Argf", "argsc", " argn", "Argn", "argf", "Argv", "argn", "argsn", "Argc", "argsv"], "argv": ["argsb", " argp", "argb", "argsc", "Argp", "Argv", "argp", "argsp", "Argc", "argsv", "Argb", " argb"]}}
{"project": "qemu", "commit_id": "bdd4df332a1bdb20b7fa39ea741f7830e41e1187", "target": 1, "func": "void qemu_spice_display_init(DisplayState *ds)\n\n{\n\n    assert(sdpy.ds == NULL);\n\n    qemu_spice_display_init_common(&sdpy, ds);\n\n    register_displaychangelistener(ds, &display_listener);\n\n\n\n    sdpy.qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_interface(&sdpy.qxl.base);\n\n    assert(sdpy.worker);\n\n\n\n    qemu_spice_create_host_memslot(&sdpy);\n\n    qemu_spice_create_host_primary(&sdpy);\n\n}\n", "idx": 21392, "substitutes": {"ds": ["md", "dos", "plays", "rd", "fs", "std", "ses", "Ds", "ded", "db", "xs", "der", "d", "pd", "ks", "uds", "ld", "services", "gd", "DS", "df", "dist", "dh", "da", "dd", "data", "state", "ys", "vs", "cs", "dy", "sync", "settings", "cb", "sd", "sts", "dt", "dim", "dc", "des", "dds", "dm", "dl", "fd", "ns", "states", "bd", "ps", "rs", "gs", "di", "dat", "ss", "gb"]}}
{"project": "FFmpeg", "commit_id": "1eaff98c8320d9ba48fbaec2a558f31f4104de98", "target": 1, "func": "static int flv_write_trailer(AVFormatContext *s)\n\n{\n\n    int64_t file_size;\n\n\n\n    AVIOContext *pb = s->pb;\n\n    FLVContext *flv = s->priv_data;\n\n    int i;\n\n\n\n    /* Add EOS tag */\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVCodecContext *enc = s->streams[i]->codec;\n\n        FLVStreamContext *sc = s->streams[i]->priv_data;\n\n        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n            enc->codec_id == AV_CODEC_ID_H264)\n\n            put_avc_eos_tag(pb, sc->last_ts);\n\n    }\n\n\n\n    file_size = avio_tell(pb);\n\n\n\n    /* update information */\n\n    avio_seek(pb, flv->duration_offset, SEEK_SET);\n\n    put_amf_double(pb, flv->duration / (double)1000);\n\n    avio_seek(pb, flv->filesize_offset, SEEK_SET);\n\n    put_amf_double(pb, file_size);\n\n\n\n    avio_seek(pb, file_size, SEEK_SET);\n\n    return 0;\n\n}\n", "idx": 6103, "substitutes": {"s": ["sets", "v", "ins", "is", "a", "S", "spec", "sg", "single", "comments", "b", "si", "sync", "ses", "services", "in", "support", "l", "xs", "f", "ns", "d", "ls", "sl", "series", "service", "ss", "cs", "sports", "e", "submit", "sb", "gs", "ks", "w", "rss", "se", "qs", "ds", "t", "ctx", "n", "ts", "su", "p", "settings", "sv", "fs", "sa", "c", "os", "g", "ssl", "sq", "sym", "es", "rs", "sup", "js"], "file_size": ["file_number", "data_ize", "file_scale", " file_sum", "file_name", "file64ize", " file_data", "file_count", "file_ize", "file__sum", "file__data", "file64time", "file_sum", "filexcount", "file_Size", "image_size", "file_time", "filextime", "file64size", "data_count", "filexize", "file__Size", "image_speed", "block_rate", "file_speed", "image_number", " file_Size", "data_time", "file64count", "block_size", "file__size", "data_size", "file_data", "block_scale", "block_name", "file_rate", "filexsize"], "pb": ["verb", "cp", "plugin", "bp", "lb", "hub", "platform", "pa", "rb", "plug", "b", "bps", "pd", "wp", "typ", "bm", "lp", "queue", "lab", "loc", "library", "fb", "db", "wb", "uf", "pm", "pg", "prot", "pc", "bs", "xb", "eb", "dp", "sb", "parser", "ctx", "bc", "PB", "fp", "cb", "jp", "ab", "p", "mb", "summary", "vp", "gb", "ppa", "ub", "ld", "bf", "lc", "dl", "orp", "tp", "fc", "api", "cv", "pl", "um", "rob", "cpp", "bh", "pkg"], "flv": ["elb", "elf", "flV", " flV", "FLf", "elc", " flb", "llp", " flp", "flb", " flvs", "flp", "wlvs", "flvs", "llv", "flc", "wlv", "slv", "wlV", "FLc", " flc", "elv", "flf", "slc", "FLb", "wlc", "elp", "slV", "slvs", "llb", "FLv", " flf", "llf"], "i": ["gi", "o", "ti", "v", "I", "chi", "di", "ci", "ni", "xi", "x", "si", "ri", "b", "io", "slice", "info", "bi", "m", "qi", "ix", "l", "f", "pi", "yi", "phi", "j", "iu", "ii", "d", "ai", "u", "e", "uri", "ori", "n", "multi", "mi", "jp", "ini", "ie", "p", "eni", "iv", "oi", "hi", "ip", "g", "y", "li", "inner", "fi", "index", "zi", "mu", "ui"], "enc": ["oc", "eng", "anc", "ENC", "ch", "emb", "sec", "spec", "acc", "nc", "et", "sys", "nec", "loc", "inc", "cl", "ext", "sl", "pc", "sci", "cc", "cs", "ev", "code", "con", "e", "acl", "en", "Enc", "dc", "ctx", "ant", "bc", "ent", "equ", "ou", "ic", "ec", "iv", "c", "ssl", "lc", "core", "fc", "env", "cod", "ac", "vc", "cv", "oder", "conn", "cel"], "sc": ["sub", "osc", "ch", "anc", "cr", "spec", "sw", "sem", "nc", "rc", "uc", "cl", "ga", "soc", "Sc", "pc", "cc", "sci", "cs", "ss", "mc", "sb", "cam", "dc", "esc", "ctx", "bc", "cms", "ec", "ca", "sa", "c", "sq", "lc", "cv", "pl", "SC", "src", "tc"]}}
{"project": "qemu", "commit_id": "b769d8fef6c06ddb39ef0337882a4f8872b9c2bc", "target": 0, "func": "int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int rw,\n\n                              int is_user, int is_softmmu)\n\n{\n\n    uint32_t physical;\n\n    int prot;\n\n    int exception = 0, error_code = 0;\n\n    int access_type;\n\n    int ret = 0;\n\n\n\n//    printf(\"%s 0\\n\", __func__);\n\n    access_type = env->access_type;\n\n    if (env->user_mode_only) {\n\n        /* user mode only emulation */\n\n        ret = -2;\n\n        goto do_fault;\n\n    }\n\n    /* NASTY BUG workaround */\n\n    if (access_type == ACCESS_CODE && rw) {\n\n\tprintf(\"%s: ERROR WRITE CODE ACCESS\\n\", __func__);\n\n\taccess_type = ACCESS_INT;\n\n    }\n\n    ret = get_physical_address(env, &physical, &prot,\n\n                               address, rw, access_type);\n\n    if (ret == 0) {\n\n\tret = tlb_set_page(env, address & ~0xFFF, physical, prot,\n\n\t\t\t   is_user, is_softmmu);\n\n    } else if (ret < 0) {\n\n    do_fault:\n\n#if defined (DEBUG_MMU)\n\n\tif (loglevel > 0)\n\n\t    cpu_ppc_dump_state(env, logfile, 0);\n\n#endif\n\n        if (access_type == ACCESS_CODE) {\n\n            exception = EXCP_ISI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables */\n\n                error_code = EXCP_ISI_TRANSLATE;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = EXCP_ISI_PROT;\n\n                break;\n\n            case -3:\n\n\t\t/* No execute protection violation */\n\n                error_code = EXCP_ISI_NOEXEC;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                /* No code fetch is allowed in direct-store areas */\n\n                error_code = EXCP_ISI_DIRECT;\n\n                break;\n\n            }\n\n        } else {\n\n            exception = EXCP_DSI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables */\n\n                error_code = EXCP_DSI_TRANSLATE;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = EXCP_DSI_PROT;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    /* Floating point load/store */\n\n                    exception = EXCP_ALIGN;\n\n                    error_code = EXCP_ALIGN_FP;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    /* lwarx, ldarx or srwcx. */\n\n                    exception = EXCP_DSI;\n\n                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT;\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    exception = EXCP_DSI;\n\n                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT |\n\n\t\t\tEXCP_DSI_ECXW;\n\n                    break;\n\n                default:\n\n\t\t    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    exception = EXCP_PROGRAM;\n\n                    error_code = EXCP_INVAL | EXCP_INVAL_INVAL;\n\n                    break;\n\n                }\n\n            }\n\n            if (rw)\n\n                error_code |= EXCP_DSI_STORE;\n\n\t    /* Store fault address */\n\n\t    env->spr[DAR] = address;\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\",\n\n               __func__, exception, error_code);\n\n#endif\n\n        env->exception_index = exception;\n\n        env->error_code = error_code;\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 14936, "substitutes": {"env": ["forge", "erv", "proc", "en", "context", "enc", "ea", "config", "worker", "code", "enter", "profile", "eu", "style", "kn", "manager", "settings", "txt", "init", "scope", "server", "v", "conf", "conn", "np", "console", "obj", "loader", "energy", "dict", "e", "equ", "viron", "exc", "engine", "her", "site", "eng", "ext", "qt", "Environment", "dat", "export", "eni", "shell", "dt", "ne", "network", "here", "org", "que", "exec", "db", "ev", "inet", "ec", "et", "cache", "environment", "ef", "net", "err"], "address": ["channel", "area", "device", "port", "Address", "database", "interface", "context", "location", "array", "config", "enter", "external", "object", "shape", "absolute", "uration", "connection", "reference", "image", "ace", "position", "server", "uri", "localhost", "output", "password", "office", "p", "primary", "pointer", "entry", "mode", "ip", "number", "route", "type", "offset", "target", "attribute", "network", "host", "inet", "prefix", "addr", "contract", "index", "message"], "rw": ["func", "rr", "rss", "wh", "ru", "rc", "iw", "ww", "rs", "row", "rn", "wx", "sw", "sth", "raw", "slave", "rh", "nw", "wn", "access", "w", "password", "lr", "rb", "resource", "rx", "wb", "rack", "wp", "rl", "route", "ro", "rt", "r", "src", "work", "RW", "wl", "rf", "tty", "hw", "wr", "fw"], "is_user": [" is_bug", "islanduser", "is24user", "iswebbug", "iswebpublic", "iswebuse", " is_public", "is24force", "islanduse", " is_force", "is24users", " is_use", "iswebuser", "is_use", " is_users", "islandbug", "is_force", "is_users", "islandpublic", "is_bug", "is_public", "is24use"], "is_softmmu": ["is_softmcu", "is_hardmmou", "is_softmlcu", "is_softmlus", "is_hardmmcu", "is_softmmou", "is_softmmus", "is_softpmu", "is_softmmi", "is_softpmi", "is_softpmcu", "is_softmcus", "is_softpmou", "is_softmmcu", "is_hardmmus", "is_softpmus", "is_softmci", "is_hardmmi", "is_softmlu", "is_softmccu", "is_softmlou", "is_hardmmu"], "physical": ["channel", "secondary", "proc", "remote", "relative", "tmp", "config", "phys", "native", "external", "phone", "binary", "local", "api", "optional", "reference", "sp", "pg", "ref", "buffer", "server", "np", "password", "p", "temp", "info", "boot", "primary", "http", "pointer", "sb", "data", "rx", "ocol", "stat", "protected", "number", "route", "nt", "network", "hard", "virtual", "resp", "host", "prefix", "net", "php"], "prot": ["Prot", "alt", "transfer", "secondary", "port", "ret", "got", "format", "len", "plain", "response", "config", "phys", "gt", "fun", "reference", "status", "ref", "txt", "fp", "server", "uri", "platform", "conn", "password", "primary", "cli", "ext", "pointer", "notes", "stat", "protected", "att", "reset", "phy", "tell", "offset", "eth", "rt", "resp", "virtual", "pro", "seq", "pos", "prefix", "addr", "rf", "prop", "rot", "ptr", "bit", "php"], "access_type": ["access_role", "accessalinfo", " access_info", "access_level", "accessalname", "access_value", "accessenname", "play_role", "accessaltoken", "accessingrole", "playingtype", "accessalltypes", "action_method", "accessallstyle", " access_set", "playingcode", "accessingclass", "playingrole", "actioningtype", "action_types", "play_code", "access_style", " access_level", "accessfullvalue", " access_key", "accessencode", "actioningmethod", " access_value", "access_types", "accessfullkey", "access_token", "accessingmethod", "actioningclass", "accessingtypes", "accessalltype", "accessingtype", "accessingcode", "accessalset", "access_code", "action_class", "accessalcode", "access_info", " access_types", " access_name", " access_size", "accessalrole", "accessaltype", "accessallevel", "play_type", " access_style", "access_name", "actioningtypes", " access_token", "access_size", "access_method", "accessentype", "access_set", " access_code", "access_class", "accessfulltype", "accessentoken", "access_key", "action_type", "accessallcode", "accessfullcode"]}}
{"project": "qemu", "commit_id": "1110bfe6f5600017258fa6578f9c17ec25b32277", "target": 0, "func": "static void do_interrupt_protected(CPUX86State *env, int intno, int is_int,\n\n                                   int error_code, unsigned int next_eip,\n\n                                   int is_hw)\n\n{\n\n    SegmentCache *dt;\n\n    target_ulong ptr, ssp;\n\n    int type, dpl, selector, ss_dpl, cpl;\n\n    int has_error_code, new_stack, shift;\n\n    uint32_t e1, e2, offset, ss = 0, esp, ss_e1 = 0, ss_e2 = 0;\n\n    uint32_t old_eip, sp_mask;\n\n    int vm86 = env->eflags & VM_MASK;\n\n\n\n    has_error_code = 0;\n\n    if (!is_int && !is_hw) {\n\n        has_error_code = exception_has_error_code(intno);\n\n    }\n\n    if (is_int) {\n\n        old_eip = next_eip;\n\n    } else {\n\n        old_eip = env->eip;\n\n    }\n\n\n\n    dt = &env->idt;\n\n    if (intno * 8 + 7 > dt->limit) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    ptr = dt->base + intno * 8;\n\n    e1 = cpu_ldl_kernel(env, ptr);\n\n    e2 = cpu_ldl_kernel(env, ptr + 4);\n\n    /* check gate type */\n\n    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;\n\n    switch (type) {\n\n    case 5: /* task gate */\n\n        /* must do that check here to return the correct error code */\n\n        if (!(e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n        }\n\n        switch_tss(env, intno * 8, e1, e2, SWITCH_TSS_CALL, old_eip);\n\n        if (has_error_code) {\n\n            int type;\n\n            uint32_t mask;\n\n\n\n            /* push the error code */\n\n            type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;\n\n            shift = type >> 3;\n\n            if (env->segs[R_SS].flags & DESC_B_MASK) {\n\n                mask = 0xffffffff;\n\n            } else {\n\n                mask = 0xffff;\n\n            }\n\n            esp = (env->regs[R_ESP] - (2 << shift)) & mask;\n\n            ssp = env->segs[R_SS].base + esp;\n\n            if (shift) {\n\n                cpu_stl_kernel(env, ssp, error_code);\n\n            } else {\n\n                cpu_stw_kernel(env, ssp, error_code);\n\n            }\n\n            SET_ESP(esp, mask);\n\n        }\n\n        return;\n\n    case 6: /* 286 interrupt gate */\n\n    case 7: /* 286 trap gate */\n\n    case 14: /* 386 interrupt gate */\n\n    case 15: /* 386 trap gate */\n\n        break;\n\n    default:\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n        break;\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    cpl = env->hflags & HF_CPL_MASK;\n\n    /* check privilege if software int */\n\n    if (is_int && dpl < cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);\n\n    }\n\n    /* check valid bit */\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);\n\n    }\n\n    selector = e1 >> 16;\n\n    offset = (e2 & 0xffff0000) | (e1 & 0x0000ffff);\n\n    if ((selector & 0xfffc) == 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, 0);\n\n    }\n\n    if (load_segment(env, &e1, &e2, selector) != 0) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    dpl = (e2 >> DESC_DPL_SHIFT) & 3;\n\n    if (dpl > cpl) {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_P_MASK)) {\n\n        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);\n\n    }\n\n    if (!(e2 & DESC_C_MASK) && dpl < cpl) {\n\n        /* to inner privilege */\n\n        get_ss_esp_from_tss(env, &ss, &esp, dpl, 0);\n\n        if ((ss & 0xfffc) == 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if ((ss & 3) != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (load_segment(env, &ss_e1, &ss_e2, ss) != 0) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        ss_dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;\n\n        if (ss_dpl != dpl) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_S_MASK) ||\n\n            (ss_e2 & DESC_CS_MASK) ||\n\n            !(ss_e2 & DESC_W_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        if (!(ss_e2 & DESC_P_MASK)) {\n\n            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);\n\n        }\n\n        new_stack = 1;\n\n        sp_mask = get_sp_mask(ss_e2);\n\n        ssp = get_seg_base(ss_e1, ss_e2);\n\n    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {\n\n        /* to same privilege */\n\n        if (vm86) {\n\n            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        }\n\n        new_stack = 0;\n\n        sp_mask = get_sp_mask(env->segs[R_SS].flags);\n\n        ssp = env->segs[R_SS].base;\n\n        esp = env->regs[R_ESP];\n\n        dpl = cpl;\n\n    } else {\n\n        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);\n\n        new_stack = 0; /* avoid warning */\n\n        sp_mask = 0; /* avoid warning */\n\n        ssp = 0; /* avoid warning */\n\n        esp = 0; /* avoid warning */\n\n    }\n\n\n\n    shift = type >> 3;\n\n\n\n#if 0\n\n    /* XXX: check that enough room is available */\n\n    push_size = 6 + (new_stack << 2) + (has_error_code << 1);\n\n    if (vm86) {\n\n        push_size += 8;\n\n    }\n\n    push_size <<= shift;\n\n#endif\n\n    if (shift == 1) {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHL(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHL(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHL(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHL(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHL(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHL(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHL(ssp, esp, sp_mask, error_code);\n\n        }\n\n    } else {\n\n        if (new_stack) {\n\n            if (vm86) {\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_GS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_FS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_DS].selector);\n\n                PUSHW(ssp, esp, sp_mask, env->segs[R_ES].selector);\n\n            }\n\n            PUSHW(ssp, esp, sp_mask, env->segs[R_SS].selector);\n\n            PUSHW(ssp, esp, sp_mask, env->regs[R_ESP]);\n\n        }\n\n        PUSHW(ssp, esp, sp_mask, cpu_compute_eflags(env));\n\n        PUSHW(ssp, esp, sp_mask, env->segs[R_CS].selector);\n\n        PUSHW(ssp, esp, sp_mask, old_eip);\n\n        if (has_error_code) {\n\n            PUSHW(ssp, esp, sp_mask, error_code);\n\n        }\n\n    }\n\n\n\n    /* interrupt gate clear IF mask */\n\n    if ((type & 1) == 0) {\n\n        env->eflags &= ~IF_MASK;\n\n    }\n\n    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);\n\n\n\n    if (new_stack) {\n\n        if (vm86) {\n\n            cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0, 0);\n\n            cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0, 0);\n\n        }\n\n        ss = (ss & ~3) | dpl;\n\n        cpu_x86_load_seg_cache(env, R_SS, ss,\n\n                               ssp, get_seg_limit(ss_e1, ss_e2), ss_e2);\n\n    }\n\n    SET_ESP(esp, sp_mask);\n\n\n\n    selector = (selector & ~3) | dpl;\n\n    cpu_x86_load_seg_cache(env, R_CS, selector,\n\n                   get_seg_base(e1, e2),\n\n                   get_seg_limit(e1, e2),\n\n                   e2);\n\n    env->eip = offset;\n\n}\n", "idx": 26941, "substitutes": {"env": ["exec", "her", "exc", "server", "pg", "shell", "enc", "vs", "chal", "eur", "gear", "export", "inet", "ne", "dev", "uv", "core", "nc", "et", "obj", "engine", "cv", "ec", "qt", "en", "Environment", "jp", "address", "proc", "ception", "password", "dh", "enter", "energy", "eni", "erv", "forge", "dep", "stage", "enh", "que", "args", "np", "console", "context", "inv", "eve", "conf", "global", "loader", "ev", "ea", "profile", "db", "e", "cdn", "output", "exe", "here", "req", "nw", "init", "org", "anne", "cot", "img", "config", "vt", "end", "environment", "site", "esi", "dat", "viron", "ctx", "eu", "vm", "osc", "ext", "conn", "net", "v", "reset", "eng"], "intno": ["indnumber", " intdo", "intNO", "intnum", "pointnum", "initnum", "structnumber", "integernumber", "intnr", "integerno", " inteno", "pointno", "integerdo", "structna", "INTnumber", "indNO", " intnum", "argname", "structno", "idNO", "extno", "argnum", "extdo", "intNo", "uintNO", "Intnos", "pointname", "extnumber", "initno", "intnos", "INTnr", " intna", " intnot", "integernum", "Intno", "indnos", "intnot", "integereno", "INTno", " intnr", "argnot", "idnumber", " intNO", "structNo", "intna", "initNO", " intnos", "indnum", "intdo", "idnos", "extnum", "intname", " intnumber", "idno", "structnos", "IntNo", "intnumber", "argno", "indno", "uinteno", " intNo", "pointNO", "uintno", "pointnot", "INTNo", "inteno", "integerNO", "structnr", " intname", "Intna", "uintnum"], "is_int": ["is_ip", " is_integer", "is_INT", "as_nt", "is6nt", "as_inter", " is_nt", "as_INT", "is6inner", "as_int", "is6ci", "is_ci", "is_inner", "is_integer", " is_ip", "as_ci", "is_nt", "as_inner", "is_inter", "is6int"], "error_code": ["error_size", " error_mode", "errorwavemode", " error_size", "error_codes", " error_codes", "errorwavecode", "error_mode", "errorwavesize", "errorwavecodes"], "next_eip": ["next_peIP", "next_feof", "next_eep", "next_seep", "next_feIP", "next_peof", "next_eeips", "next_peip", "next_seIP", "next_eIP", "next_eeIP", "next_eeep", "next_eips", "next_feep", "next_feip", "next_seip", "next_peep", "next_peips", "next_seof", "next_eof", "next_eeip", "next_seips"], "is_hw": ["isAhw", " is_ht", "isAiw", "isAfw", "is_ht", "is_iw", " is_fw", "is_ether", "isAether", "is_rw", " is_iw", " is_rw", " is_ether", "is_fw"], "dt": ["txt", "tk", "cm", "np", "dc", "ta", "dr", "tm", "qt", "ds", "tz", "jp", "vt", "ct", "tif", "ea", "db", "e", "td", "tu", "adr", "dh", "dat", "tmp", "cmd", "mt", "tick", "tt", "ctx", "target", "elt", "rt", "tn", "uv", "wt", "tc", "tp", "dm", "t", "DT", "fp", "dq", "bt", "utm", "ut", "kt"], "ptr": ["ref", "seq", "code", "slice", "fe", "obj", " pointer", "p", "pt", "dr", "cur", "br", "pointer", "jp", "pointers", "address", "inst", "port", "tr", "proc", "pad", "cmp", "eger", "sp", "td", "str", "start", "loc", "rot", "ctr", "alloc", "req", "Ptr", "cache", "addr", "rc", "length", "rt", "count", "ext", "prot", "index", "reg", "fp", "src", "memory", "attr", "reset", "pos", "len"], "ssp": ["csm", "sslp", "csl", "ssm", "cssm", "cssl", "assm", "cssp", "asslp", "csp", "csslp", "cslp", "ssl", "assp", "assl"], "type": ["ref", "code", "call", "slice", "class", "info", "p", "i", "name", "x", "test", "action", "base", "weight", "style", "var", "label", "py", "pe", "address", "types", "error", "version", "state", "col", "port", "id", "kind", "op", "method", "typ", "key", "unit", "o", "rel", "bit", "loc", "Type", "parent", "like", "size", "sort", "scale", "shape", "ype", "length", "part", "count", "TYPE", "y", "value", "ip", "t", "null", "map", "ty", "block", "pos", "mark", "val", "format", "layer"], "dpl": ["fPL", "dcPL", " dfl", "dcfl", " dPL", "fpl", "dcpl", "ffl", "fsl", "dsl", " dsl", "dPL", "dcsl", "dfl"], "selector": ["constructors", "constructor", "processor", "constructur", "selectory", "processur", "electur", "processory", "selectur", "electors", "constructory", "elector", "processors", "selectors", "electory"], "ss_dpl": ["ss_rdll", "ss_rdpe", "ss_dbl", "ss_rdpl", "ss_dll", "ss_fpe", "ss_rdbl", "ss_ppl", "ss_dpe", "ss_fll", "ss_pll", "ss_fbl", "ss_pbl", "ss_fpl", "ss_ppe"], "cpl": ["ctpl", "cPL", "xcpy", " cps", "ctpy", "xcps", "cpy", " cPL", " cpy", "xcpl", "ctPL", "ctps", "cps", "xcPL"], "has_error_code": ["has_error_call", "has_active_count", "has_err_codes", "has_active_size", "has_error_codes", "has_errorfulcode", "has_ror_done", "has_errorfulsize", "has_active_code", "has_error64call", "has_error_size", "has_errorfulclass", "has_error_done", "has_error64code", "has_errorifcode", "has_error_class", "has_ror_count", "has_activeureclass", "has_ror_codes", "has_errorureclass", "has_error64size", "has_errorifcodes", "has_err_desc", "has_error64codes", "has_error_count", "has_err_error", "has_error_error", "has_errorifdesc", "has_erroruredone", "has_activeuresize", "has_ror_size", "has_errorurecall", "has_errorfulcount", "has_active_class", "has_errorurecode", "has_erroruresize", "has_activeurecount", "has_erroriferror", "has_activeurecode", "has_error_desc", "has_err_code", "has_ror_code", "has_ror_call", "has_errorurecount"], "new_stack": ["new__buffer", "raw__stack", "new_trace", "raw__buffer", "new_buffer", "raw__window", "new__trace", "new_window", "newlwindow", "new__stack", "newvalstack", "newlbuffer", "raw_stack", "newvaltrace", "newvalwindow", "raw_trace", "newlstack", "raw__trace", "raw_window", "newltrace", "new__window", "newvalbuffer", "raw_buffer"], "shift": ["skip", "seq", "slice", "pop", "cost", "sum", "align", "weight", "address", "Shift", "error", "push", "cmp", "seed", "extra", "ff", "small", "hift", "ctr", "scale", "shape", "sup", "dist", "slave", "count", "pull", "ip", "index", "init", "ind", "block", "pos", "sh"], "e1": ["p3", "e9", "eone", "ec2", "E3", "ec1", "ae3", "oe1", "oe32", " e3", "E1", "p1", "E6", "ae1", "Eone", "oe2", "E2", "e3", "ae2", "p2", "econe", "ec9", "oe3", " e32", "e6", " e6", " eone", "ae32", " e9", "E9", "p6", "e32"], "e2": ["ea4", " eTwo", " e4", "ee1", "eeTwo", "ea2", " e8", "ea1", "ee4", "E4", "E3", "ea8", "ee2", "E8", "E1", "E32", "p1", " e3", "E6", "ea6", "e4", "E2", "e3", "p2", "p8", " e32", "ee3", "e6", " e6", "eTwo", "ETwo", "ee32", "ee8", "e8", "e32"], "offset": ["seq", "skip", "slice", "adjust", "position", "align", "address", "error", "op", "alias", "sp", "padding", "loc", "slot", "order", "size", "ip", "index", "pos", "len"], "esp": ["yp", "esc", "temp", "pp", "asp", "sk", "ep", "np", "slice", "ss", "sn", "parser", "sw", "ism", "py", "eff", "sg", "css", "eps", "expr", "rss", "sp", "esi", "ef", "eb", "cp", "sb", "gp", "addr", "sup", "ext", "lv", "xp", "arp", "resp", "ace", "isp"], "old_eip": ["old_eeIP", "old_aeis", "old_edIP", "old_peis", "old_seep", "old_eeep", "old_eeips", "old_eIP", "old_eeid", "old_edis", "old_aeip", "old_seid", "old_peid", "old_edip", "old_seIP", "old_peIP", "old_eis", "old_eid", "old_eips", "old_peip", "old_edid", "old_aeIP", "old_seip", "old_aeid", "old_eep", "old_peep", "old_seips", "old_eeip", "old_peips"], "sp_mask": ["ss_mask", "ss_delay", "ss_map", "ss_ask", "sp_ask", "sp_map", "sp_delay"], "mask": ["args", "class", "info", "flag", "flags", "filter", "dr", "data", "fix", "weight", "sum", "bug", "op", "ask", "alias", "depth", "allow", "key", "patch", "arr", "max", "zero", "bit", "Mask", "group", "sign", "scale", "shape", "field", "scan", "asks", "count", "bits", "pull", "index", "header", "match", "map", "pack", "block", "ace", "mark", "ph", "lock"]}}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static uint8_t eeprom24c0x_read(void)\n\n{\n\n    logout(\"%u: scl = %u, sda = %u, data = 0x%02x\\n\",\n\n        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);\n\n    return eeprom.sda;\n\n}\n", "idx": 15788, "substitutes": {}}
{"project": "qemu", "commit_id": "f2488736371ae902f345cf9270d141f0a6797731", "target": 1, "func": "static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi,\n\n                             int s_bits, int tlb_offset)\n\n{\n\n    TCGReg base = TCG_AREG0;\n\n\n\n    /* Should generate something like the following:\n\n     * pre-v7:\n\n     *   shr    tmp, addr_reg, #TARGET_PAGE_BITS                  (1)\n\n     *   add    r2, env, #off & 0xff00\n\n     *   and    r0, tmp, #(CPU_TLB_SIZE - 1)                      (2)\n\n     *   add    r2, r2, r0, lsl #CPU_TLB_ENTRY_BITS               (3)\n\n     *   ldr    r0, [r2, #off & 0xff]!                            (4)\n\n     *   tst    addr_reg, #s_mask\n\n     *   cmpeq  r0, tmp, lsl #TARGET_PAGE_BITS                    (5)\n\n     *\n\n     * v7 (not implemented yet):\n\n     *   ubfx   r2, addr_reg, #TARGET_PAGE_BITS, #CPU_TLB_BITS    (1)\n\n     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask\n\n     *   movw   r0, #off\n\n     *   add    r2, env, r2, lsl #CPU_TLB_ENTRY_BITS              (2)\n\n     *   bic    tmp, addr_reg, tmp\n\n     *   ldr    r0, [r2, r0]!                                     (3)\n\n     *   cmp    r0, tmp                                           (4)\n\n     */\n\n#  if CPU_TLB_BITS > 8\n\n#   error\n\n#  endif\n\n    tcg_out_dat_reg(s, COND_AL, ARITH_MOV, TCG_REG_TMP,\n\n                    0, addrlo, SHIFT_IMM_LSR(TARGET_PAGE_BITS));\n\n\n\n    /* We assume that the offset is contained within 16 bits.  */\n\n    assert((tlb_offset & ~0xffff) == 0);\n\n    if (tlb_offset > 0xff) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n\n                        (24 << 7) | (tlb_offset >> 8));\n\n        tlb_offset &= 0xff;\n\n        base = TCG_REG_R2;\n\n    }\n\n\n\n    tcg_out_dat_imm(s, COND_AL, ARITH_AND,\n\n                    TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1);\n\n    tcg_out_dat_reg(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,\n\n                    TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS));\n\n\n\n    /* Load the tlb comparator.  Use ldrd if needed and available,\n\n       but due to how the pointer needs setting up, ldm isn't useful.\n\n       Base arm5 doesn't have ldrd, but armv5te does.  */\n\n    if (use_armv6_instructions && TARGET_LONG_BITS == 64) {\n\n        tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0,\n\n                        TCG_REG_R2, tlb_offset, 1, 1);\n\n    } else {\n\n        tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0,\n\n                         TCG_REG_R2, tlb_offset, 1, 1);\n\n        if (TARGET_LONG_BITS == 64) {\n\n            tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1,\n\n                             TCG_REG_R2, 4, 1, 0);\n\n        }\n\n    }\n\n\n\n    /* Check alignment.  */\n\n    if (s_bits) {\n\n        tcg_out_dat_imm(s, COND_AL, ARITH_TST,\n\n                        0, addrlo, (1 << s_bits) - 1);\n\n    }\n\n\n\n    tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0,\n\n                    TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS));\n\n\n\n    if (TARGET_LONG_BITS == 64) {\n\n        tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0,\n\n                        TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0));\n\n    }\n\n}\n", "idx": 3288, "substitutes": {"s": ["sg", "server", "js", "service", "this", "cs", "groups", "http", "ss", "stat", "spec", "rs", "a", "context", "sb", "current", "is", "scope", "client", "g", "m", "ses", "sf", "sync", "settings", "sv", "request", "sets", "ds", "gs", "native", "ns", "c", "p", "services", "setup", "e", "private", "f", "secondary", "self", "sys", "sq", "u", "set", "south", "b", "site", "S", "t", "session", "support", "se", "fs", "complex", "si", "input", "sym", "ssl"], "addrlo": ["addresslo", "addrLo", "addresslittle", " addrHi", "amdlo", "addressla", "drlo", "Addresshi", "drLo", "Addresslo", "addrHi", "drlittle", "amdlittle", "AddressLo", "addressHi", "addressLo", "amdla", " addrLo", "drla", "AddressHi", "addrlittle", "addresshi", "addrla", "amdLo"], "addrhi": ["Addresshi", "Addresspi", "addrHi", " addrha", "addrpi", "addhi", " addrHi", "AddressHi", "addHi", "addpi", "Addressha", "addrha", "addha", " addrpi"], "s_bits": ["ps_pins", "ps_flags", "s2parts", "ps_parts", "s_flags", "s2pins", "s_parts", "s_pins", "ps_bits", "s2bits", "s2flags"], "tlb_offset": ["tlb2off", "tlb_attribute", "tlb_Offset", "tbl2size", "tlb_location", "tlb__size", "tlb__Offset", "tlp_location", "tbl2offset", "tlb_len", "tl_base", "tla_Offset", "tlp_sum", "tlb2offset", "tlp_offset", "tlc_len", "tlb_base", "tla_no", "tlb_off", "tla_offset", "tla_off", "tlb_line", "tlp_position", "tbl_size", "tlb_addr", "tlb2addr", "tlb2size", "tlb__off", "tbl_off", "tlb__offset", "tlb_no", "tlb__addr", "tlc_offset", "tlp_attribute", "tlp_Offset", "tbl_addr", "tbl2addr", "tbl_offset", "tlb8offset", "tlp_size", "tlb__len", "tlp_line", "tlc_Offset", "tlb8base", "tlb_sum", "tl_off", "tl_size", "tlb8off", "tlb_size", "tl_offset", "tlb8size", "tlc_size", "tbl2off", "tlb_position"]}}
{"project": "qemu", "commit_id": "8297be80f7cf71e09617669a8bd8b2836dcfd4c3", "target": 0, "func": "void net_hub_check_clients(void)\n\n{\n\n    NetHub *hub;\n\n    NetHubPort *port;\n\n    NetClientState *peer;\n\n\n\n    QLIST_FOREACH(hub, &hubs, next) {\n\n        int has_nic = 0, has_host_dev = 0;\n\n\n\n        QLIST_FOREACH(port, &hub->ports, next) {\n\n            peer = port->nc.peer;\n\n            if (!peer) {\n\n                fprintf(stderr, \"Warning: hub port %s has no peer\\n\",\n\n                        port->nc.name);\n\n                continue;\n\n            }\n\n\n\n            switch (peer->info->type) {\n\n            case NET_CLIENT_DRIVER_NIC:\n\n                has_nic = 1;\n\n                break;\n\n            case NET_CLIENT_DRIVER_USER:\n\n            case NET_CLIENT_DRIVER_TAP:\n\n            case NET_CLIENT_DRIVER_SOCKET:\n\n            case NET_CLIENT_DRIVER_VDE:\n\n            case NET_CLIENT_DRIVER_VHOST_USER:\n\n                has_host_dev = 1;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        if (has_host_dev && !has_nic) {\n\n            warn_report(\"vlan %d with no nics\", hub->id);\n\n        }\n\n        if (has_nic && !has_host_dev) {\n\n            fprintf(stderr,\n\n                    \"Warning: vlan %d is not connected to host network\\n\",\n\n                    hub->id);\n\n        }\n\n    }\n\n}\n", "idx": 11128, "substitutes": {"hub": ["library", "ib", "grid", "bb", "blog", "conn", "lab", "src", "http", "mob", "builder", "trap", "project", "job", "pool", "config", "server", "pb", "cb", "ub", "gb", "driver", "feed", "plug", "bug", "Hub", "club", "tube", "host", "db", "pub", "sub", "lib", "route", "connection", "home", "proxy", "bot", "mod", "pc", "hop", "bus", "git", "node", "plugin", "hole", "client", "ob", "image", "interface", "url", "month", "box"], "port": ["parent", "PORT", "adr", "bb", "tr", "point", "porter", "http", "project", "pid", "iv", "pool", "ports", "serv", "bridge", "cp", "service", "p", "server", "pb", "target", "Port", "pt", "gp", "pm", "manager", "host", "pub", "device", "ort", "state", "proxy", "end", "address", "patch", "pc", "hop", "oper", "plugin", "type", "pod", "pair", "pos", "client", "ip", "proc", "pin", "transfer"], "peer": ["parent", "channel", "prov", "source", "owner", "worker", "info", "conn", "point", "http", "origin", "instance", "ker", "cer", "pp", "pool", "player", "bridge", "addr", "server", "p", "reader", "pb", "pro", "target", "driver", "rel", "pe", "ref", "socket", "er", "slave", "manager", "host", "device", "pub", "edge", "scope", "master", "connection", "remote", "state", "proxy", "entity", "address", "tp", "pc", "hop", "node", "enc", "root", "plugin", "type", "pod", "vr", "client", "ip", "dev", "iper", "interface", "transfer", "buffer", "ssl", "per", "chain"]}}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "static int rdma_add_block(RDMAContext *rdma, const char *block_name,\n\n                         void *host_addr,\n\n                         ram_addr_t block_offset, uint64_t length)\n\n{\n\n    RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n    RDMALocalBlock *block;\n\n    RDMALocalBlock *old = local->block;\n\n\n\n    local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));\n\n\n\n    if (local->nb_blocks) {\n\n        int x;\n\n\n\n        if (rdma->blockmap) {\n\n            for (x = 0; x < local->nb_blocks; x++) {\n\n                g_hash_table_remove(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset);\n\n                g_hash_table_insert(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset,\n\n                                    &local->block[x]);\n\n            }\n\n        }\n\n        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);\n\n        g_free(old);\n\n    }\n\n\n\n    block = &local->block[local->nb_blocks];\n\n\n\n    block->block_name = g_strdup(block_name);\n\n    block->local_host_addr = host_addr;\n\n    block->offset = block_offset;\n\n    block->length = length;\n\n    block->index = local->nb_blocks;\n\n    block->src_index = ~0U; /* Filled in by the receipt of the block list */\n\n    block->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;\n\n    block->transit_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);\n\n    block->unregister_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);\n\n    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));\n\n\n\n    block->is_ram_block = local->init ? false : true;\n\n\n\n    if (rdma->blockmap) {\n\n        g_hash_table_insert(rdma->blockmap, (void *) block_offset, block);\n\n    }\n\n\n\n    trace_rdma_add_block(block_name, local->nb_blocks,\n\n                         (uintptr_t) block->local_host_addr,\n\n                         block->offset, block->length,\n\n                         (uintptr_t) (block->local_host_addr + block->length),\n\n                         BITS_TO_LONGS(block->nb_chunks) *\n\n                             sizeof(unsigned long) * 8,\n\n                         block->nb_chunks);\n\n\n\n    local->nb_blocks++;\n\n\n\n    return 0;\n\n}\n", "idx": 12968, "substitutes": {"rdma": ["ridmas", "rdmad", "ridmma", "raftsta", "ridqa", "rxmma", "rgmas", "rgma", "ndma", "ldta", "ldama", "raftmma", "rrta", "rxqa", "ldmas", "rdqa", "rdama", "rlda", "rnma", "rrama", "rlsta", "vrmar", "raftda", "rtmma", "rdea", "rgea", "ldmma", "ndmas", "raftma", "rtmas", "rtma", "rrda", "rdmar", "rlma", "rgda", "ridma", "rtama", "rlmma", "rnea", "ndda", "vrda", "vrmas", "rdda", "rtta", "rxma", "ldmar", "rdsta", "rtsta", "rdmas", "ldda", "vrma", "ldqa", "rtmar", "rdta", "ldma", "rtda", "rnmas", "rnda", "rtea", "rxmas", "rnmad", "rtmad", "rrma", "ndmad", "rdmma"], "block_name": ["blockingname", "block__name", "block_names", "byte_name", "byte_names", "blockfullclass", "byte_def", "blockfullspec", " block_number", "block__size", "blockingdef", "block___spec", "block_size", "byte_spec", "blockfulldescription", "block___name", "block_class", "plugin_spec", "blockfullname", " block_size", "block_def", "block__number", "block___class", "block_number", "blockingnames", "block_description", "block___description", "plugin_class", "plugin_description", "blockingspec", "block_spec", "plugin_name"], "host_addr": ["block_addr", "host_off", "hostingad", "host_index", "hostingoffset", "hostacindex", "server_name", "hostalindex", "host_address", "hostingname", "hostingaddress", "hostalslot", "block_index", "host_name", "hostingaddr", " host_nr", " host_ad", "hostacaddress", "block_slot", "hostingnr", "host6addr", "host6address", "hostipindex", "hostacaddr", "hostipaddr", "hostingoff", "hostaladdress", " host_offset", "host_slot", "hostipslot", "server_addr", "hostaladdr", "host_ad", "host_offset", "server_address", "host_nr", "host6index", "hostipaddress", "host6size", "block_size", "host_size", "hostacsize", "server_off", "block_address"], "block_offset": ["block_prefix", "block_padding", "block_addr", "block___size", " block_prefix", "block___padding", "block_length", "byte_size", "byte_padding", "byte_offset", "block___addr", "block_size", "byte_addr", " block_size", "block___offset", " block_length"], "length": ["zip", "path", "ch", "part", "slice", "build", "l", "code", "split", "style", "shape", "range", "name", "weight", "section", "h", "capacity", "sequence", "lang", "position", "live", "key", "limit", "form", "size", "p", "time", "base", "Length", "count", "th", "padding", "address", "line", "url", "number", "end", "pull", "type", "offset", "body", "load", "angle", "duration", "seq", "lock", "len", "depth", "ength", "height", "index"], "local": ["remote", "partial", "small", "tx", "self", "build", "shared", "l", "private", "back", "external", "child", "current", "home", "standard", "container", "public", "new", "final", "event", "pool", "missing", "lang", "foreign", "user", "model", "update", "full", "loc", "session", "valid", "server", "package", "client", "same", "pass", "group", "clean", "parse", "instance", "plugin", "joined", "pack", "temp", "http", "base", "Local", "list", "parent", "custom", "state", "global", "single", "inner", "all", "link", "get", "wall", "initial", "lock", "el", "util", "post", "join", "node"], "block": ["map", "blocks", "build", "child", "def", "label", "pre", "image", "new", "event", "panel", "pool", "other", "raw", "model", "loc", "frame", "base", "flow", "line", "out", "work", "tag", "lock", "num", "copy", "off", "index", "call", "bin", "part", "sync", "container", "full", "comment", "key", "error", "session", "script", "check", "group", "clean", "instance", "pack", "byte", "BL", "ip", "number", "clock", "link", "exec", "cache", "header", "condition", "random", "config", "un", "style", "builder", "Block", "section", "null", "option", "unit", "buffer", "init", "update", "view", "info", "http", "none", "point", "address", "global", "close", "type", "load", "wall", "bl", "prev", "post", "cl", "bit", "node", "channel", "record", "before", "object", "name", "row", "user", "patch", "chain", "request", "open", "plugin", "match", "parent", "outer", "ban", "join"], "old": ["before", "small", "existing", "part", "slice", "build", "array", "val", "object", "orig", "and", "l", "pre", "or", "current", "row", "low", "new", "OLD", "original", "other", "arg", "update", "full", "model", "ld", "buff", "o", "obj", "clean", "an", "ind", "p", "e", "where", "base", "from", "f", "ore", "att", "state", "diff", "inner", "gen", "now", "last", "ard", "Old", "el", "older", "prev", "post", "handle"], "x": ["xb", "m", "tx", "t", "xi", "id", "code", "i", "val", "ww", "xe", "name", "ex", "wx", "h", "fx", "sw", "xt", "xa", "xp", "v", "w", "dx", "z", "ady", "u", "p", "e", "rx", "k", "ix", "b", "base", "j", "ext", "f", "xx", "ax", "c", "xs", "pe", "X", "sex", "wa", "r", "lex", "xc", "work", "xxx", "xy", "num", "y", "max", "index", "ux"], "nb_blocks": ["nb64works", "nb__chains", "nb_chains", "nn_blocks", "nb_locks", "b_ins", "nb_works", "nb__images", "b_classes", "nb___images", "nb_images", "nbJbars", "nb54works", "nbJrooms", "b_bars", "nbJclasses", "nb___quarters", "nb_heads", "nb_boxes", "nbJlocks", "nb__frames", "nr__blocks", "nn54chains", "b_blocks", "nb64heads", "nbJins", "nn_heads", "nb54heads", "nb_bars", "nr__maps", "nb64blocks", "num_rooms", "nn_chains", "num_chains", "nr__frames", "nr_images", "num_frames", "nb___blocks", "nr__images", "nb_quarters", "nb__locks", "nn54works", "nbJboxes", "nb_maps", "nr_blocks", "num_images", "nr_maps", "nb__maps", "nb_classes", "num_quarters", "num_locks", "nb_rooms", "num_blocks", "nb__blocks", "nr_frames", "nb54chains", "nb64chains", "nbJblocks", "nn_works", "nn54blocks", "nb_frames", "nb___locks", "num_boxes", "nn54heads", "nb_ins", "nb54blocks"]}}
{"project": "FFmpeg", "commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "target": 1, "func": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n\n{\n\n    long i;\n\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n\n        long a = *(long *)(src1 + i);\n\n        long b = *(long *)(src2 + i);\n\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n\n    }\n\n    for (; i < w; i++)\n\n        dst[i] = src1[i] + src2[i];\n\n}\n", "idx": 18624, "substitutes": {"dst": ["sdbl", "Dst", "rdsrc", "rdst", "rdsts", "Dfe", "dsST", "sdput", "dssrc", " dbl", "dsbl", "dfe", "dsrc", "rdST", "adsrc", "udsrc", "dsst", "sdfe", "sdst", "udST", " dput", "adst", "adST", "udst", "adbl", "Dput", " dsrc", "dput", " dfe", " dsts", "dssts", "dST", " dST", "Dbl", "dsts", "dbl", "udbl"], "src1": [" srca", "rcA", "scb", "rc2", "src3", "src0", "srcb", "srcA", "source1", "sc0", "sourcea", " srcb", "rc3", "source2", "sourceA", "source0", " srcA", "seqb", "sc1", "sourceb", "source3", "rc1", "srca", "rca", "rcb", "seqA", "sc3", "seq2", "seq1", "rc0"], "src2": ["gb82", "loadb", "load1", " src0", " srcB", "rc2", "src0", "srcb", "config82", "configtwo", "source1", "rcB", " srcb", "config02", "srctwo", "src82", "source2", "gbtwo", " src02", "source0", "gb02", " srctwo", "loadB", "config2", "load2", "sourceb", "gb2", "rc1", "src02", "rcb", "rc0", " src82", "srcB"], "w": ["wei", "wt", "m", "fw", "wed", "t", "wx", "x", "f", "r", "n", "wl", "we", "g", "window", "sw", "z", "max", "wb", "ow", "iw", "kw", "ew", "l", "hw", "d", "W", "ww", "q", "k", "v", "c", "nw", "p", "tw", "win", "wh", "wa", "h", "aw", "u", "weight", "wave"], "i": ["gi", "ti", "uri", "m", "bi", "j", "ji", "t", "info", "x", "f", "ix", "ini", "qi", "ai", "mi", "n", "phi", "io", "hi", "z", "ii", "ie", "in", "di", "index", "iu", "I", "multi", "zi", "o", "l", "adi", "d", "oi", "yi", "pi", "ui", "ci", "abi", "id", "e", "k", "v", "cli", "ni", "c", "si", "lc", "ri", "xi", "p", "b", "mu", "a", "api", "it", "fi", "y", "li", "ib", "u"]}}
{"project": "qemu", "commit_id": "8e65b7c04965c8355e4ce43211582b6b83054e3d", "target": 0, "func": "static void uhci_async_complete(USBPacket *packet, void *opaque)\n\n{\n\n    UHCIState *s = opaque;\n\n    UHCIAsync *async = (UHCIAsync *) packet;\n\n\n\n    DPRINTF(\"uhci: async complete. td 0x%x token 0x%x\\n\", async->td, async->token);\n\n\n\n    async->done = 1;\n\n\n\n    uhci_process_frame(s);\n\n}\n", "idx": 16728, "substitutes": {"packet": ["ppet", "packel", "aset", "packsinet", "payet", "encet", "asacket", "packsacket", "ackacket", "encacket", "ackel", "packetter", "packhole", "encel", "ppinet", "payel", "ppetter", "payacket", "ppacket", "enchole", "packinet", "acket", "asinet", "packset", "payhole", "ackhole", "asetter", "packacket", "packsetter"], "opaque": ["openque", " opque", "oponymous", "openaque", "copaque", " opacity", "iopque", "compaque", "openicit", "opacity", "iopaque", "operaque", "ioponymous", "compque", "coponymous", "openacity", "operque", "operonymous", "copque", "compicit", "opicit", "compacity", "opque", " opicit"], "s": ["ns", "spec", "m", "sg", "stats", "f", "settings", "services", "service", "n", "sb", "g", "sw", "sl", "ss", "ops", "fs", "o", "submit", "args", "socket", "e", "ssl", "ses", "c", "slave", "sym", "p", "secondary", "S", "b", "sys", "os", "server", "states", "sq", "south", "params", "sf"], "async": ["assynchronous", "rasync", "nasynchronous", "nasync", " asynchronous", "acync", "Asynchron", " asyn", "rassync", "asynchron", " asynchron", "nasyn", "asyn", "assAsync", "acynchronous", "acsync", "Asyn", "asAsync", "Async", "asynchronous", "rasyn", "assync", "asssync", "rasynchronous", "assyn", "acyn", "rasAsync", "Asynchronous", " assync", " asAsync", "nasynchron"]}}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mfrom(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 2229, "substitutes": {"ctx": ["fc", "cm", "cli", "gpu", "src", "cs", "hw", "conn", "context", "anc", "cc", "cl", "gc", "Context", "cpp", "loc", "ct", "ck", "nc", "bc", "tc", "cus", "cas", "component", "tx", "cb", "ch", "config", "crit", "ce", "pkg", "cu", "c", "cv", "xc", "css", "lc", "cpu", "cn", "ca", "sc", "wcs", "ctrl", "cmd", "vc", "cca", "pc", "qa", "cp", "cmp", "req", "cf", "ci", "cfg", "sci", "rc"]}}
{"project": "qemu", "commit_id": "d02f8adc6d2a178bcbf77d0413f9a96fdbed53f0", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n\n{\n\n    AHCICmdHdr *cmd = ad->cur_cmd;\n\n    uint32_t opts = le32_to_cpu(cmd->opts);\n\n    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;\n\n    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;\n\n    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    int sum = 0;\n\n    int off_idx = -1;\n\n    int off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    if (!sglist_alloc_hint) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (sglist_alloc_hint > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);\n\n            if (offset <= (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %d\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),\n\n                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);\n\n\n\n        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            le32_to_cpu(tbl[i].flags_size) + 1);\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 10801, "substitutes": {"ad": ["ld", "ady", "mad", "bb", "pad", "id", "http", "quad", "ads", "ud", "ab", "ang", "d", "post", "adh", "bd", "p", "add", "addr", "ace", "wd", "ada", "exec", "at", "ag", "ade", "ay", "rad", "jad", "ass", "ac", "an", "db", "dat", "al", "edd", "md", "att", "end", "dd", "AD", "art", "dc", "pc", "admin", "pod", "od", "client", "dev", "api", "a", "aud", "ap", "aed", "ed", "Ad"], "sglist": ["sgnIST", "sgnst", "sGLister", " sglIST", "sgnister", "sglIST", "sGLst", " sGLIST", "sgelister", " sGLst", " sGList", "sgelIST", " sglister", "sgelst", "sGList", "sgnist", "sgelist", "sGLIST", " sGLister", "sglst", " sglst", "sglister"], "offset": ["location", "timeout", "delay", "start", "si", "len", "prefix", "pad", "origin", "num", "data", "slot", "sum", "limit", "addr", "config", "ref", "p", "skip", "set", "number", "off", "loc", "f", "padding", "entry", "alpha", "o", "index", "size", "align", "r", "end", "address", "part", "position", "amount", "type", "pos", "attribute", "length", "Offset", "range", "reset"], "cmd": ["mac", "ht", "cmp", "def", "pad", "conn", "MD", "d", "c", "head", "config", "cp", "addr", "cd", "cb", "rad", "cod", "op", "dr", "code", "pkg", "ctrl", "ctl", "md", "ctx", "req", "mod", "Cmd", "cl", "dc", "node", "cat", "cfg", "comm", "command", "grad", "client", "od", "dad", "proc"], "prdt": ["Prt", "brtd", "frtd", "Prdt", "prDT", "PRdt", " prta", "Prta", "prds", "brds", "prot", "protd", "Prqt", " prt", " prqt", "prtd", "brdt", "prta", " prDT", "frqt", "PrDT", "PRqt", "PRtd", "frta", "prt", " prds", "Prtd", "prodt", "prqt", "brqt", " prtd", "proDT", "frdt", "PRds"], "i": ["oi", "l", "hi", "ui", "di", "it", "n", "len", "si", "m", "xi", "info", "k", "x", "ini", "z", "ami", "t", "b", "d", "c", "p", "ix", "uri", "e", "mu", "yi", "mini", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "v", "gi", "mi", "phi", "ti", "ind", "r", "chi", "abi", "qi", "bi", "pi", "ii", "u", "I", "pos", "li", "ip", "ci", "ni", "io", "y", "ri", "fi", "iu", "ki"], "tbl_entry_size": ["tbl_row_len", "tbl_entry_pos", "tbl_row_pos", "tbl_entry_sum", "tbl_offset_size", "tbl_Entry_size", "tbl_Entry_len", "tbl_entry_count", "tbl_offset_len", "tbl_entry_len", "tbl_row_size", "tbl_Entry_sum", "tbl_offset_count"], "bus": [" buses", "boot", "pass", "base", "class", "board", "brid", "b", "bridge", "c", "block", "service", "config", "p", "used", "ux", "feed", "plug", "bug", "us", "BUS", "serial", "bc", "Bus", "route", "connection", "state", "proxy", "las", "pu", "port", "usb", "hub", "cat", "type", "pos", "dev", "io", "cache", "vc", "proc"], "qbus": ["qboot", "sqboot", "QBus", "dqbus", "dqboot", "Qdi", "qBus", "sqbus", "Qbus", "dqdi", "sqBus", "dqBus", "Qboot", "sqdi", "qdi"], "tbl": ["itill", "bill", "tpl", "tuple", " tcol", "fbl", "Tbl", "tBL", "fBL", "itcol", "fuple", " tBL", "itBL", "tcol", "ruple", "Tuple", "rpl", "till", "fpl", "bbl", "TBL", "bcol", " till", "itbl", "bBL", "Tpl", "rBL", "rbl"]}}
{"project": "qemu", "commit_id": "22156ab498acf5f8104801148732ae8e83f336a0", "target": 0, "func": "uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,\n\n                             uint8_t *addrs, uint8_t *buf)\n\n{\n\n    uint32_t sum = 0;\n\n\n\n    sum += net_checksum_add(length, buf);         // payload\n\n    sum += net_checksum_add(8, addrs);            // src + dst address\n\n    sum += proto + length;                        // protocol & length\n\n    return net_checksum_finish(sum);\n\n}\n", "idx": 18598, "substitutes": {"length": ["offset", "shape", "code", "text", "ch", "buffer", "duration", "family", "block", "type", "match", "loc", "th", "padding", "count", "range", "l", "size", "cost", "build", "buff", "cur", "position", "seq", "url", "address", "sum", "h", "number", "weight", "Length", "port", "end", "word", "len"], "proto": ["protcer", "pex", "Prof", "protx", "peco", "prob", "proco", "Prob", "preb", "protocol", "prox", "precer", "Proocol", "proocol", "protto", "pecer", "procer", "peto", "prex", "prof", "Proto", "protco", "preocol", "preco", "preto", "pref", "protf", "protb"], "addrs": ["addls", "attresses", "ddr", "addros", "attrs", "ddrs", "adros", " addros", "attros", "ddls", "ddresses", "adrs", "adresses", " addresses", "adls", "adr", "addresses", "attls", "addr", " addr", "attr"], "buf": ["br", "data", "text", "ctr", "pool", "buffer", "rc", "vec", "cf", "cb", "src", "padding", "raw", "header", "array", "uint", "aux", "queue", "mount", "config", "buff", "cur", "rb", "seq", "cmd", "binary", "address", "pad", "b", "alloc", "addr", "port", "uf", "each", "cv", "len"]}}
{"project": "qemu", "commit_id": "89ae337acbe4dba5b2481007aec1277252d2b86c", "target": 0, "func": "static void mem_begin(MemoryListener *listener)\n\n{\n\n    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);\n\n\n\n    d->phys_map.ptr = PHYS_MAP_NODE_NIL;\n\n}\n", "idx": 321, "substitutes": {"listener": ["Listener", "latener", " listencer", "intener", "parentceiver", "listceiver", "listend", "parentener", "latender", " listceiver", "lateners", " listiner", "Listend", "parenter", "cleners", "later", " listeners", "parentender", "listeners", "listiner", "parentest", "intencer", "clender", "Listencer", "intend", "listencer", " lister", " listend", "parenteners", "listender", "clest", "clener", "latest", "intiner", "listest", "latceiver", "lister", "Listiner"], "d": ["dr", "fd", "ld", "dn", "da", "dd", "pd", "sd", "dh", "dad", "r", "ad", "xd", "n", "id", "did", "j", "i", "m", "dy", " D", "dt", "md", "ds", "dc", "ind", "ade", "p", "c", "l", "e", "dm", "f", "bd", "rd", "v", "b", "t", "od", "ded", " dd", "dat", "nd", "D", "gd"]}}
{"project": "FFmpeg", "commit_id": "a7f27453f64d9020b92b01687baeb5909c6cdad0", "target": 0, "func": "static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;\n\n    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&\n\n        codec->codec_id == AV_CODEC_ID_H264 &&\n\n        atom.size > 11) {\n\n        avio_skip(pb, 10);\n\n        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */\n\n        if (avio_rb16(pb) == 0xd4d)\n\n            codec->width = 1440;\n\n        return 0;\n\n    }\n\n\n\n    return mov_read_avid(c, pb, atom);\n\n}\n", "idx": 25357, "substitutes": {"c": ["sc", "cm", "dc", "uc", "cd", "p", "m", "b", "oc", "C", "cv", "xc", "ec", "cur", "config", "cr", "cus", "ct", "cb", "bc", "abc", "cy", "ch", "cmp", "e", "fc", "con", "cl", "vc", "ac", "jc", "icc", "cc", "ctx", "ci", "cp", "cf", "mc", "cn", "co", "lc", "ctrl", "ca", "f", "tc", "conn", "coll", "core", "nc", "l", "cs", "ce", "pc"], "pb": ["pa", "uc", "p", "b", "wb", "pg", "lb", "ppa", "bb", "xb", "api", "rb", "ab", "bh", "gb", "jp", "cb", "bc", "dp", "bp", "platform", "typ", "cmp", "db", "mp", "PB", "fc", "rob", "fab", "tmp", "eb", "pl", "ctx", "cp", "fb", "sb", "pm", "abb", "bot", "lp", "tc", "cpp", "fp", "bm", "bps", "pc", "ib"], "atom": ["temp", "node", "mom", "abi", "obj", "cm", "chem", "param", "m", "app", "image", "bb", "asm", "data", "tm", "orb", "ab", "config", "om", "prop", "component", "operator", "type", "instance", "op", "num", "orbit", "atomic", "typ", "canon", "article", "mag", "fab", "cell", "amp", "tmp", "term", "at", "ator", "spec", "object", "parent", "emb", "item", "com", "hop", "xml", "tc", "tom", "material", "container", " Atom", "attr", "ac", "chrom", "tag"], "codec": ["odac", "odroc", "odEC", " codoc", "Codroc", "codeesc", "odef", "compec", "Codec", "odec", "pedenc", " codEC", "compEC", "codenc", "codEC", "equec", "codeEC", "pedef", "codeoc", "CodEC", "Codoc", "odoc", "odbc", "Codef", "coduc", "odesc", "pedac", "codac", "codeec", "codesc", "codroc", "pedesc", "compex", "copec", "Codbc", "comproc", "codoc", "copenc", "copuc", "equoc", "codex", "Codenc", "copesc", "oduc", " codesc", "codbc", "peduc", "equenc", "Codac", "odex", "pedbc", "equEC", "pedec", "Codex", "odenc", "codef"]}}
{"project": "qemu", "commit_id": "daa76aa416b1e18ab1fac650ff53d966d8f21f68", "target": 1, "func": "void trace_init_file(const char *file)\n\n{\n\n#ifdef CONFIG_TRACE_SIMPLE\n\n    st_set_trace_file(file);\n\n#elif defined CONFIG_TRACE_LOG\n\n    /* If both the simple and the log backends are enabled, \"-trace file\"\n\n     * only applies to the simple backend; use \"-D\" for the log backend.\n\n     */\n\n    if (file) {\n\n        qemu_set_log_filename(file);\n\n    }\n\n#else\n\n    if (file) {\n\n        fprintf(stderr, \"error: -trace file=...: \"\n\n                \"option not supported by the selected tracing backends\\n\");\n\n        exit(1);\n\n    }\n\n#endif\n\n}\n", "idx": 22693, "substitutes": {"file": ["port", "place", "ile", "name", "class", "e", "txt", "binary", "config", "ban", "db", "message", "time", "key", "connection", "uri", "handler", "function", "f", "buffer", "path", "write", "model", "fp", "use", "entry", "socket", "data", "cache", "bug", "id", "code", "work", "le", "comment", "cli", "filename", "hide", "single", "source", "future", "line", "File", "call", "feed", "http", "folder", "resource", "files", "empty", "l", "base", "output", "command", "type", "letter"]}}
{"project": "qemu", "commit_id": "33bef0b9948b85000221d32c758d9d4a9276aaaf", "target": 1, "func": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n", "idx": 22006, "substitutes": {"timer_list": ["timerlisttest", "meterapplist", "timerappget", "tick_List", " timer_count", "timerlqueue", "timerdList", "timer_diff", "timerAtable", "timer2config", "ticklistlist", "ticklistList", "tick_queue", "timeridbatch", "lateridlist", "timer2list", "lateridleft", "timer2def", "timerappstack", "timerallconfig", "timeralldef", "timerAlist", "meter_get", "timer_record", "theme6stack", "er_list", "theme_get", "later_add", "ticklistqueue", "er_lock", "timer_batch", "theme0list", "theme0detail", "timerlistdetail", "timer_left", "timerlistList", " timer_diff", "timer5LIST", "timer6stack", "timeralllist", "theme_LIST", "ticklisttree", "timerlistlist", "theme6LIST", "meter_list", "timerkdiff", "lateridadd", "timerappconfig", "timer0get", "timerllist", "timer0test", "timer_queue", "timeridlist", "timer6LIST", "er_batch", "timerappdef", "timer0list", "meterappget", "tick_list", "timeridleft", "timerxlist", "timerklist", "timer_add", "meter_config", "timer5list", "theme6get", "timerktable", "timerdpair", "er_type", "timerxpair", "timer_test", "timer5stack", "timer_config", "timer_List", "theme_detail", "timer_table", "timer6get", "timerxList", "timer_type", "theme_test", "timerdlist", "timerlistqueue", "timer5get", "meter_def", " timer_table", "theme0get", "timer_count", "timerapplist", "timerAdiff", "timer_lock", "theme_stack", "timerdrecord", "timerlisttree", "timer2get", "er_pair", "later_batch", "timerlList", "timer_get", "timer_tree", "timer_detail", "theme0test", "timer_pair", "timerappLIST", "timerltree", "tick_tree", "theme6list", "timer_stack", "meterappconfig", "meterappdef", "timerAcount", "timerkcount", "theme_list", "lateridbatch", "later_list", "er_record", "timerxrecord", "timer0detail", "timerallget", "timerlistget", "er_List", "later_left", "timer_LIST", "timer_def", "timer6list", "timeridadd"], "expire_time": ["expireystart", "expireftime", "exire_money", "expireycount", "exake_start", "expire_start", "expire64timeout", "expire_count", "expirefmode", "exire_Time", "exire_mode", "expirextime", "exake___hour", "expiration_timeout", "exake_count", "exake___time", "expire__money", "expire_hour", "expire64start", "expire_money", "expireyhour", "expire64count", "expirexmoney", "exire_count", "expire__timeout", "expire__time", "expire64hour", "expire_timeout", "expire___count", "expireytime", "exake___count", "expirexmode", "exake_time", "expire_mode", "expire___time", "expire___start", "expire_Time", "exake___start", "expiration_time", "exake_hour", "exire_time", "expire64money", "expiration_money", "expire___hour", "expire64time", "expirefmoney"]}}
{"project": "qemu", "commit_id": "ba2ab2f2ca4150a7e314fbb19fa158bd8ddc36eb", "target": 1, "func": "static int qcow2_create2(const char *filename, int64_t total_size,\n                         const char *backing_file, const char *backing_format,\n                         int flags, size_t cluster_size, int prealloc,\n                         QEMUOptionParameter *options, int version,\n                         Error **errp)\n{\n    /* Calculate cluster_bits */\n    int cluster_bits;\n    cluster_bits = ffs(cluster_size) - 1;\n    if (cluster_bits < MIN_CLUSTER_BITS || cluster_bits > MAX_CLUSTER_BITS ||\n        (1 << cluster_bits) != cluster_size)\n    {\n        error_setg(errp, \"Cluster size must be a power of two between %d and \"\n                   \"%dk\", 1 << MIN_CLUSTER_BITS, 1 << (MAX_CLUSTER_BITS - 10));\n        return -EINVAL;\n    /*\n     * Open the image file and write a minimal qcow2 header.\n     *\n     * We keep things simple and start with a zero-sized image. We also\n     * do without refcount blocks or a L1 table for now. We'll fix the\n     * inconsistency later.\n     *\n     * We do need a refcount table because growing the refcount table means\n     * allocating two new refcount blocks - the seconds of which would be at\n     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file\n     * size for any qcow2 image.\n     */\n    BlockDriverState* bs;\n    QCowHeader header;\n    uint8_t* refcount_table;\n    Error *local_err = NULL;\n    int ret;\n    ret = bdrv_create_file(filename, options, &local_err);\n    if (ret < 0) {\n        return ret;\n    ret = bdrv_file_open(&bs, filename, NULL, BDRV_O_RDWR, &local_err);\n    if (ret < 0) {\n        return ret;\n    /* Write the header */\n    memset(&header, 0, sizeof(header));\n    header.magic = cpu_to_be32(QCOW_MAGIC);\n    header.version = cpu_to_be32(version);\n    header.cluster_bits = cpu_to_be32(cluster_bits);\n    header.size = cpu_to_be64(0);\n    header.l1_table_offset = cpu_to_be64(0);\n    header.l1_size = cpu_to_be32(0);\n    header.refcount_table_offset = cpu_to_be64(cluster_size);\n    header.refcount_table_clusters = cpu_to_be32(1);\n    header.refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT);\n    header.header_length = cpu_to_be32(sizeof(header));\n    if (flags & BLOCK_FLAG_ENCRYPT) {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);\n    } else {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);\n    if (flags & BLOCK_FLAG_LAZY_REFCOUNTS) {\n        header.compatible_features |=\n            cpu_to_be64(QCOW2_COMPAT_LAZY_REFCOUNTS);\n    ret = bdrv_pwrite(bs, 0, &header, sizeof(header));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write qcow2 header\");\n    /* Write an empty refcount table */\n    refcount_table = g_malloc0(cluster_size);\n    ret = bdrv_pwrite(bs, cluster_size, refcount_table, cluster_size);\n    g_free(refcount_table);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write refcount table\");\n    /*\n     * And now open the image and make it consistent first (i.e. increase the\n     * refcount of the cluster that is occupied by the header and the refcount\n     * table)\n     */\n    BlockDriver* drv = bdrv_find_format(\"qcow2\");\n    assert(drv != NULL);\n        BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);\n    if (ret < 0) {\n    ret = qcow2_alloc_clusters(bs, 2 * cluster_size);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not allocate clusters for qcow2 \"\n                         \"header and refcount table\");\n    } else if (ret != 0) {\n        error_report(\"Huh, first cluster in empty image is already in use?\");\n        abort();\n    /* Okay, now that we have a valid image, let's give it the right size */\n    ret = bdrv_truncate(bs, total_size * BDRV_SECTOR_SIZE);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not resize image\");\n    /* Want a backing file? There you go.*/\n    if (backing_file) {\n        ret = bdrv_change_backing_file(bs, backing_file, backing_format);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not assign backing file '%s' \"\n                             \"with format '%s'\", backing_file, backing_format);\n    /* And if we're supposed to preallocate metadata, do that now */\n    if (prealloc) {\n        BDRVQcowState *s = bs->opaque;\n        qemu_co_mutex_lock(&s->lock);\n        ret = preallocate(bs);\n        qemu_co_mutex_unlock(&s->lock);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not preallocate metadata\");\n    ret = 0;\nout:\n    bdrv_unref(bs);\n    return ret;", "idx": 26388, "substitutes": {"filename": ["summary", "processor", "txt", "dll", "location", "kn", "selection", "download", "wb", "name", "phrase", "fn", "queue", "metadata", "config", "prefix", "Filename", "url", "directory", "nil", "path", "rl", "jpg", "kl", "journal", "sequence", "files", "il", "which", "username", "f", "source", "jl", "fp", "content", "database", "fil", "memory", "title", "fd", "fits", "file"], "total_size": [" total_capacity", " total_content", "total67size", "total_scale", "total67content", "total_capacity", " total_scale", "total_content", "total67capacity", "total67scale"], "backing_file": ["backing64image", "backing_image", "backping2table", "backing2file", "backping_files", "backing2table", "backping2files", "backping2file", "backping2image", "backping_table", "backing2image", "backping_file", "backping_image", "backing64file", "backing64table", "backing_table", "backing2files", "backing_files", "backing64files"], "backing_format": ["backiving_unit", "backiving_writer", "backing_writer", "backiving_format", "backing_unit", "backiving_file"], "flags": ["mask", "ants", "args", "heads", "errors", "features", "flag", "ips", "Flags", "types", "plugins", "locks", "format", "depth", "vals", "stats", "fps", "fields", "links", "fl", "versions", "tops", "lag", "utils", "files", "mods", "missions", "groups", "fs", "bits", "status", "alls", "FLAG", "settings", "ops", "parts", "len", "ints"], "cluster_size": ["clinal_size", "clust_count", "cluster_capacity", "cluster2number", "cluster2bits", "clusters_count", "clinalalsize", "clusters_capacity", "clusteraltable", "clinal_count", "cluster6width", "clinalaltable", "cluster_mode", "cluster2capacity", "clinal_time", "clusters_size", "cluster6count", "cluster64mode", "cluster_table", "clust_size", "clinalaltime", "cluster_count", "clusteraltime", "cluster2size", "cluster6number", "clust_number", "clinal_table", "cluster64capacity", "clusteralcount", "cluster2mode", "cluster_width", "clusteralsize", "clusters_mode", "cluster_number", "cluster2count", "clinalalcount", "cluster64count", "cluster6size", "clust_width", "cluster_time", "cluster64size"], "prealloc": ["prexp", "postalloc", "postxp", " rexp", "postgr", " prexp", "pregr", " pregr", " regr"], "options": ["obj", "args", "errors", "info", "none", "option", "members", "ssl", "ts", "other", "config", "opens", "types", "opt", "global", "outs", "io", "Options", "linux", "vals", "ions", "caps", "session", "rates", "object", "properties", "als", "utils", "files", "cache", "details", "results", "values", "settings", "ops", "resources", "params", "limits"], "version": ["build", "VERSION", "gen", "package", "class", "driver", "section", "features", "Version", "option", "currency", "name", "server", "position", "image", "style", "config", "vision", "feature", "type", "prefix", "support", "platform", "serial", "brand", "plugin", "depth", "ception", "seed", "arch", "versions", "mode", " ver", " versions", "size", "target", "scale", "number", "level", "generation", "current", "length", "update", "product", "stage", "value", "ip", "index", "v", "ver", "release", "tag", "format", "fun"], "errp": ["errpc", "erP", "irpre", "erfp", "errorpc", "irp", "irpc", "errpre", "erpc", " errfp", "errorfp", "erpre", " errpc", "errorP", "irP", "erp", "errP", "errfp", " errpre", "errorpre", "errorp"], "cluster_bits": ["closer_bytes", "clust_bit", "cluster8features", "closer_bits", "cluster2bits", "cluster32width", "clust_pieces", "closer_cycles", "clancer_bytes", "cluster_pieces", "clust_bytes", "cluster_flags", "cluster__bytes", "cluster2bytes", "cluster32pieces", "cluster_features", "cluster6cycles", "clancer_bits", "cluster__size", "cluster_bytes", "cluster8pieces", "closer_flags", "cluster6flags", "clust_bits", "clust_parts", "cluster_parts", "closer6cycles", "cluster32bytes", "cluster6bytes", "clust_features", "cluster6bits", "cluster_width", "cluster2bit", "cluster_cycles", "clancer_parts", "cluster__bits", "cluster8bits", "cluster__parts", "closer6bytes", "clancer_size", "cluster8parts", "closer6bits", "cluster_pins", "cluster_bit", "clust_width", "closer6flags", "cluster32bits"], "bs": ["rs", "ses", "b", "ss", "bas", "ns", "lb", "bn", "bb", "vs", "base", "ds", "br", "bh", "gb", "bos", "bc", "BS", "bl", "ps", "SB", "gs", "ba", "pb", "bi", "mb", "os", "sb", "fb", "utils", "bid", "ls", "fs", "bytes", "ssl", "cs"], "header": ["head", "definition", "server", "frame", "name", "manager", "module", "buffer", "request", "holder", "secondary", "character", "column", "tail", "url", "bridge", "number", "external", "f", "service", "entry", "status", "fp", "content", "cookie", "Header", "pillar", "document", "writer", "layer", "summary", "body", "code", "driver", "parser", "queue", "reader", "port", "fr", "line", "journal", "headers", "cache", "response", "h", "report", "event", "meta", "rr", "block", "forward", "table", "final", "public", "section", "data", "back", "error", "plugin", "player", "extra", "message", "offset", "output", "client", "later", "full", "ssl", "connection", "kernel", "info", "hash", "master", "dr", "metadata", "config", "br", "type", "cover", "protected", "layout", "ext", "comment", "index", "builder", "result", "hr"], "refcount_table": ["refcount_count", "refcount_master", "refCount_cache", "refCount_master", "refCount_table", "refcount2table", "refCount_count", "refcount_cache", "refcount2count", "refcount2cache", "refcount2master"], "local_err": ["httperstr", "local_str", "localamerr", "httperresult", "localerresult", "local7str", "localamerror", "localamresult", "local_info", "httpererr", "http_err", "localamexit", "local7Error", "remote_exit", "localerstr", "localamstr", "localererror", "localanderr", "localererr", "http_str", "localanderror", "loc_result", "local7err", "localamError", "remote_err", "local7result", "local_result", "local_Error", "httpererror", "localaminfo", "loc_Error", "http_error", "http_result", "remote_info", "remote_error", "localandexit", "loc_err", "loc_str", "local_exit", "localandinfo", "local_error"], "ret": ["ref", "fin", "obj", "ft", "res", "info", "hash", " RET", "cat", "flag", "msg", "rf", "red", "back", "success", "br", "bf", "fail", "att", "pub", "debug", "def", "error", "end", "rep", "num", "proc", "ure", "db", "rets", "arr", "rl", "mt", "det", "lit", "nb", "RET", "run", "re", "art", "nt", "reply", "rc", "let", "sec", "bad", "arg", "Ret", "rt", " result", "part", "status", "alt", "reg", "resp", "conn", "match", "ver", "result", "len", "val", "lock", "fun"]}}
{"project": "qemu", "commit_id": "1a9353d258aba69afd8a389bf5fb705caab12ce0", "target": 0, "func": "int cpu_x86_gen_code(uint8_t *gen_code_buf, int max_code_size, \n\n                     int *gen_code_size_ptr, uint8_t *pc_start, \n\n                     int flags)\n\n{\n\n    DisasContext dc1, *dc = &dc1;\n\n    uint8_t *gen_code_end, *pc_ptr;\n\n    long ret;\n\n#ifdef DEBUG_DISAS\n\n    struct disassemble_info disasm_info;\n\n#endif\n\n    dc->code32 = (flags >> GEN_FLAG_CODE32_SHIFT) & 1;\n\n    dc->addseg = (flags >> GEN_FLAG_ADDSEG_SHIFT) & 1;\n\n    dc->f_st = (flags >> GEN_FLAG_ST_SHIFT) & 7;\n\n    dc->cc_op = CC_OP_DYNAMIC;\n\n    gen_code_ptr = gen_code_buf;\n\n    gen_code_end = gen_code_buf + max_code_size - 4096;\n\n    gen_start();\n\n\n\n    dc->is_jmp = 0;\n\n    pc_ptr = pc_start;\n\n    do {\n\n        ret = disas_insn(dc, pc_ptr);\n\n        if (ret == -1) \n\n            error(\"unknown instruction at PC=0x%x B=%02x %02x\", \n\n                  pc_ptr, pc_ptr[0], pc_ptr[1]);\n\n        pc_ptr = (void *)ret;\n\n    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);\n\n    /* we must store the eflags state if it is not already done */\n\n    if (dc->cc_op != CC_OP_DYNAMIC)\n\n        gen_op_set_cc_op(dc->cc_op);\n\n    if (dc->is_jmp != 1) {\n\n        /* we add an additionnal jmp to update the simulated PC */\n\n        gen_op_jmp_im(ret);\n\n    }\n\n    gen_end();\n\n    *gen_code_size_ptr = gen_code_ptr - gen_code_buf;\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (loglevel) {\n\n        uint8_t *pc;\n\n        int count;\n\n\n\n        INIT_DISASSEMBLE_INFO(disasm_info, logfile, fprintf);\n\n#if 0        \n\n        disasm_info.flavour = bfd_get_flavour (abfd);\n\n        disasm_info.arch = bfd_get_arch (abfd);\n\n        disasm_info.mach = bfd_get_mach (abfd);\n\n#endif\n\n#ifdef WORDS_BIGENDIAN\n\n        disasm_info.endian = BFD_ENDIAN_BIG;\n\n#else\n\n        disasm_info.endian = BFD_ENDIAN_LITTLE;\n\n#endif        \n\n        fprintf(logfile, \"IN:\\n\");\n\n        disasm_info.buffer = pc_start;\n\n        disasm_info.buffer_vma = (unsigned long)pc_start;\n\n        disasm_info.buffer_length = pc_ptr - pc_start;\n\n        pc = pc_start;\n\n        while (pc < pc_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n        \n\n        pc = gen_code_buf;\n\n        disasm_info.buffer = pc;\n\n        disasm_info.buffer_vma = (unsigned long)pc;\n\n        disasm_info.buffer_length = *gen_code_size_ptr;\n\n        fprintf(logfile, \"OUT: [size=%d]\\n\", *gen_code_size_ptr);\n\n        while (pc < gen_code_ptr) {\n\n            fprintf(logfile, \"0x%08lx:  \", (long)pc);\n\n            count = print_insn_i386((unsigned long)pc, &disasm_info);\n\n            fprintf(logfile, \"\\n\");\n\n            pc += count;\n\n        }\n\n        fprintf(logfile, \"\\n\");\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 24315, "substitutes": {"gen_code_buf": ["gen_code36end", "gen_code2len", "gen_code_len", "gen_codes_end", "gen_code24ptr", "gen_code1len", "gen_code1uf", "gen_code36buf", "gen_code24buff", "gen_code_uf", "gen_call_offset", "gen_code_pad", "gen_call_buff", "gen_code_buffer", "gen_code24buf", "gen_codes2end", "gen_codes_buf", "gen_code_offset", "gen_codes2buf", "gen_call_buffer", "gen_code2uf", "gen_code36len", "gen_codes_uf", "gen_code2end", "gen_code36uf", "gen_code24end", "gen_codes2len", "gen_codes2uf", "gen_code1buf", "gen_code1end", "gen_code_buff", "gen_code2buf", "gen_call_buf", "gen_codes_len", "gen_call_end", "gen_call_pad", "gen_code_ptr", "gen_call_ptr"], "max_code_size": ["max_code_capacity", "max_codes_capacity", "max_code_SIZE", "max_codes_size", "max_cache_SIZE", "max_codes_len", "max_code2size", "max_code2max", "max_code_max", "max_code_len", "max_code2SIZE", "max_cache_size", "max_cache_max"], "gen_code_size_ptr": ["gen_code_address_tr", "gen_code_address_pointer", "gen_code_size_pt", "gen_code_address_pt", "gen_code_size_pointer", "gen_code_address_ptr", "gen_code_size_tr", "gen_code_size_inter"], "pc_start": ["pc67start", "pc_offset", "PC_end", "pc2len", "pc2ptr", "pc_end", "fc_start", "PC_start", "fc_end", "pc_scale", "pc67scale", "pc_len", "PC_len", "pc67offset", "PC_ptr", "pc2start", "fc_offset", "pc2end", "fc_scale", "pc67end"], "flags": ["mask", "comments", "ants", "seq", "args", "heads", "features", "flag", "days", "cards", "Flags", " Flags", "pins", "blocks", "opens", "planes", "types", "rules", "plugins", "windows", "vals", "lins", "lf", "stats", "codes", "rets", "options", "fields", "s", "strings", "lines", "fts", "fee", "limits", "words", "lag", "utils", "files", "mods", "feat", "xs", "pages", "ags", "f", "fs", "bytes", "bits", "groups", "alls", "tests", "checks", "details", "func", "atts", "FLAG", "ops", "packs", "len", "ints", "fun"], "dc1": ["c2", "dc0", " dc0", "c0", "DC1", "nc1", " dc2", "DC2", "DC0", "nc0", "rc1", "rc0", "c1", "dc2"], "dc": ["gui", "sc", "ctl", "DC", "cca", "uc", "cd", "director", "dim", "c", "auc", "d", "dr", "fd", "enc", "doc", "xc", "ec", " DC", "ds", "cr", "diff", "ct", "bc", "abc", "dp", "dd", "ea", "db", "fc", "td", "cmd", "input", "dat", "vc", "cdn", "dir", "loc", "disc", "jc", "di", "enter", "dt", "cc", "cf", "mc", "ga", "rc", "inc", "dra", "device", "design", "lc", "ctrl", "gc", "tc", "vd", "da", "dm", "conn", "draw", "df", "nc", "ac", "dk", "desc"], "gen_code_end": ["gen_code67start", "gen_codes_end", "gen_codeprepend", "gen_codepreend", "gen_codes_pend", "gen_code_pend", "gen_codeenlength", "gen_code_END", "gen_code_max", "gen_call_end", "gen_code67offset", "gen_code67end", "gen_code_offset", "gen_codepreoffset", "gen_codeenmax", "gen_code_length", "gen_call_END", "gen_codes_offset", "gen_call_start", "gen_code67pend", "gen_codeenstart", "gen_codeenend", "gen_code_start", "gen_codeprestart", "gen_codes_start"], "pc_ptr": ["PC_start", "dc_end", "fc_pad", "fc_end", "pc_addr", "PC_pointer", "pc67pointer", "bc_ref", "fc_tip", "fc_ptr", "PC_enter", "dc_ptr", "dc_size", "bc_pointer", "PC_ptr", "fc_offset", "bc_pad", "pc_enter", "pc_desc", "pc_code", "pc_end", "pc_size", "fc_pointer", "dc_pointer", "pc_ref", "pc_offset", "fc_desc", "pc67ref", "pc_pointer", "pc67ptr", "pc67pad", "fc_code", "bc_ptr", "dc_addr", "pc_tip", "pc_pad"], "ret": ["ref", "code", "fin", "obj", "ft", "res", " RET", "flag", "red", "job", "back", "data", "buffer", "no", "success", "bf", "ct", "att", " Ret", "rep", "num", "xt", "id", "rets", "al", "rl", "eth", "mt", "det", "rev", "lit", "bit", "repl", "RET", "last", "re", "nt", "lag", "reply", "bot", "let", "rc", "pat", "ry", "arg", "Ret", "rt", "gc", "ext", "status", "part", "comment", "reg", "alt", "desc", "match", "r", "result", "len", "val", "fun"], "disasm_info": ["disam_now", "dispackaminformation", "disast_offset", "disasm_conf", "disassembly_info", "disasmaminformation", "disassembly_state", "disam_inf", "dispackaminf", "disassembly_spec", "dispack_inf", "disast_error", "disasmamalias", "disjam_conf", "disasmaminf", "disasm_help", "disasm_Info", "disasmCinfo", "disjam_info", "disast2info", "dispack_alias", "disjam_id", "disam_info", "disasmamoffset", "disjam_Info", "disam_error", "dispack_info", "disasm_information", "disast2help", "disasmamhelp", "disasm_id", "dispackaminfo", "disasmCstate", "disasm_offset", "dispack_information", "disast_help", "disast2offset", "disasmaminfo", "disasm_state", "disasm2error", "disasm_now", "disasm_spec", "disasmCspec", "disasm_alias", "disast2error", "disasm_inf", "disasm2offset", "disasm_error", "disasmamerror", "disasm2help", "dispackamalias", "disast_info", "disasm2info"], "pc": ["sc", "sys", "uc", "anc", "toc", "c", "enc", "xc", "pointer", "PC", "bc", "mac", "proc", "fc", "con", "amp", "td", "pb", "cpu", "cc", "mc", "rc", "lc", "tc", "arc", "nc", "ac", "pid"], "count": ["ref", "seq", "code", "call", "found", "toc", "c", "base", "col", "cb", "counter", "type", "id", "num", "proc", "depth", "con", "offset", "Count", "nt", "parent", "cc", "cache", "length", "total", "child", "func", "len"]}}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,\n\n                                         uint32_t *sums, int n, int pred_order)\n\n{\n\n    int i;\n\n    int k, cnt, part;\n\n    uint32_t all_bits;\n\n\n\n    part     = (1 << porder);\n\n    all_bits = 4 * part;\n\n\n\n    cnt = (n >> porder) - pred_order;\n\n    for (i = 0; i < part; i++) {\n\n        k = find_optimal_param(sums[i], cnt);\n\n        rc->params[i] = k;\n\n        all_bits += rice_encode_count(sums[i], cnt, k);\n\n        cnt = n >> porder;\n\n    }\n\n\n\n    rc->porder = porder;\n\n\n\n    return all_bits;\n\n}\n", "idx": 18426, "substitutes": {"rc": ["dc", "oc", "pc", "rx", "rs", "core", "irc", "cca", "RC", "r", "rt", "result", "coll", "anc", "cb", "bc", "src", "loc", "rh", "ctx", "fc", "abc", "ctrl", "auc", "cs", "arc", "context", "roc", "rec", "gb", "nc", "ac", "tc", "xc", "config", "sc", "sync", "cur", "c", "lc", "rb", "uc", "cmp", "icc", "cv", "cc"], "porder": ["lpake", "npake", "upair", "parm", "corders", " pordered", " pcount", "varm", "nordered", "lparm", "npair", "prorder", "Porders", "upoder", " pake", "Pordering", "lporders", "uporder", "lpordering", "pordered", "preoder", " paddress", " porders", "pcount", "cordered", "Parm", "prorders", "ncount", "rordered", "preair", "Porder", "vorder", "uporders", "pair", " poder", "lpaddress", "upordering", "cordering", "pordering", "pake", "paddress", "prordering", "vordering", "nair", "rair", "corder", "poder", " pordering", "upordered", "lpair", "porders", "vorders", "preorder", " pair", "rcount", "lporder", "norder", "rorder", "npaddress", "nporder", "preorders"], "sums": ["sesums", " sults", "psamples", " samples", " suma", "samples", " sum", "asups", " suss", "sesuss", "pales", "asums", "sus", "psales", "Sums", "suss", "Suma", "sults", "suma", " sales", "Suss", "Sults", "subs", "pum", "pamples", "asuma", " sups", "pums", "sups", "sum", " subs", "psum", "Subs", "sesubs", "psums", "Sus", " sus", "sales", "Sups", "sesults", "asus"], "n": ["ns", "m", "j", "s", "un", "t", "x", "f", "pn", "net", "ne", "nt", "num", "mn", "N", "g", "z", "node", "in", "nb", "en", "o", "nm", "l", "d", "non", "nc", "network", "sn", "no", "e", "span", "v", "ni", "c", "p", "b", "fn", "cn", "len", "number", "nn", "an", "conn", "u"], "pred_order": ["Pred_order", "predPordered", "predfordered", "Pred_key", "pred__orders", "Pred_orders", "predforders", "cmp_orders", "pred_orders", "pred_rank", "pred__rank", "pred_Order", "cmpforder", "predfrank", "Pred_ordered", "predPorder", "pred__order", "cmpforders", "cmp_Order", "predPkey", "cmpfrank", "predfOrder", "pred_key", "predfkey", "predforder", "cmp_rank", "pred__Order", "cmp_order", "pred_ordered", "cmpfOrder", "predPorders"], "i": ["gi", "ti", "uri", "m", "bi", "init", "j", "s", "ji", "info", "x", "f", "ix", "ini", "qi", "r", "ai", "mi", "io", "ii", "in", "ie", "di", "index", "mini", "slice", "I", "multi", "zi", "o", "ip", "l", "d", "oi", "pi", "ui", "ci", "abi", "id", "e", "q", "v", "c", "ni", "si", "ki", "ri", "p", "xi", "b", "mu", "h", "api", "it", "fi", "y", "li", "u"], "k": ["m", "ik", "j", "work", "ijk", "x", "f", "kick", "ek", "r", "kin", "g", "K", "ok", "kind", "kid", "kr", "kw", "o", "sk", "ask", "d", "kh", "ko", "kn", "w", "key", "id", "q", "e", "ak", "kat", "unk", "ka", "c", "v", "ki", "p", "ck", "mk", "ks", "b", "ke", "dk", "kk", "y", "u"], "cnt": ["dcct", "cnd", "acnt", "pcpt", "dcnt", " cnc", "cpt", "pcnn", "acent", " cNT", "dcnd", "Cno", " cnd", " cct", "dcant", "ucant", "crt", "Cant", "dcpt", "conwd", " cpt", "ucnd", " cent", "Cnt", "CNT", "dcNT", "acwd", "conNT", "ucnn", " crt", "cent", " cno", "ucnc", "ucnt", "cct", "connt", "cwd", " cant", "dcrt", "conent", "cno", "cNT", "dcnc", "ucct", "cant", "pcnt", "pcrt", "acNT", "cnn", " cwd", "dcnn", "cnc", "dcno", " cnn"], "part": ["pc", "m", "point", "j", "x", "base", "f", "round", "block", "year", "type", "max", "pos", "min", "count", "po", "art", "half", "force", "pair", "val", "d", "section", "change", "step", "partial", "space", "pi", "pre", "seed", "minute", "no", "start", "limit", "PART", "id", "v", "span", "parent", "position", "patch", "p", "pad", "b", "number", "parts", "Part", "order", "len"], "all_bits": ["allCbytes", "all__bits", "all_bit", "all_pieces", "all__parts", "all_params", " all_pins", "all_pins", "allCparams", " all_bytes", " all_parts", "all__bytes", "allCbits", "all__pieces", " all_bit", "all_bytes", "allCpieces", " all_pieces", "all_parts", " all_params"]}}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "void hmp_info_snapshots(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs, *bs1;\n\n    QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s;\n\n    int nb_sns, i, ret, available;\n\n    int total;\n\n    int *available_snapshots;\n\n\n\n    bs = find_vmstate_bs();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No available block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    nb_sns = bdrv_snapshot_list(bs, &sn_tab);\n\n    if (nb_sns < 0) {\n\n        monitor_printf(mon, \"bdrv_snapshot_list: error %d\\n\", nb_sns);\n\n        return;\n\n    }\n\n\n\n    if (nb_sns == 0) {\n\n        monitor_printf(mon, \"There is no snapshot available.\\n\");\n\n        return;\n\n    }\n\n\n\n    available_snapshots = g_malloc0(sizeof(int) * nb_sns);\n\n    total = 0;\n\n    for (i = 0; i < nb_sns; i++) {\n\n        sn = &sn_tab[i];\n\n        available = 1;\n\n        bs1 = NULL;\n\n\n\n        while ((bs1 = bdrv_next(bs1))) {\n\n            if (bdrv_can_snapshot(bs1) && bs1 != bs) {\n\n                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);\n\n                if (ret < 0) {\n\n                    available = 0;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (available) {\n\n            available_snapshots[total] = i;\n\n            total++;\n\n        }\n\n    }\n\n\n\n    if (total > 0) {\n\n        bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, NULL);\n\n        monitor_printf(mon, \"\\n\");\n\n        for (i = 0; i < total; i++) {\n\n            sn = &sn_tab[available_snapshots[i]];\n\n            bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, sn);\n\n            monitor_printf(mon, \"\\n\");\n\n        }\n\n    } else {\n\n        monitor_printf(mon, \"There is no suitable snapshot available\\n\");\n\n    }\n\n\n\n    g_free(sn_tab);\n\n    g_free(available_snapshots);\n\n\n\n}\n", "idx": 12558, "substitutes": {"mon": ["mc", "non", "my", "lon", "wan", "tom", "mn", "module", "vol", "mx", "mr", "mun", "nan", "mol", "MON", "prem", "md", "mag", "lock", "dom", "m", "bin", "on", "mat", "ml", "con", "amon", "mt", "ran", "an", "ann", "pin", "don", "minute", "rock", "comm", "reg", "mu", "wm", "meter", "Mon", "phys", "mp", "bean", "un", "mail", "fun", "mons", "member", "ms", "boot", "atom", "mos", "token", "bo", "man", "net", "date", "lin", "pal", "month", "plan", "mm", "platform", "col", "mer", "mor", "mini", "mi", "monitor", "mo", "login", "day", "chron"], "qdict": [" qdat", "qdat", "dqdict", "qudat", "qudict", "dqdat", "dqdef", "qudef", "qdf", "qdef", "qudf", " qdf", " qdef", "dqdf"], "bs": ["sys", "rss", "ses", "bid", "bis", "bc", "ob", "BS", "fs", "ins", "bb", "fb", "rs", "bn", "cs", "os", "js", "ps", "ss", "conn", "obj", "ba", "obs", "pb", "vs", "b", "sb", "base", "nas", "banks", "gb", "gs", "less", "bh", "ns", "bu", "bps", "xs", "bes", "eb", "bas", "ds", "bi", "db", "src", "ls", "css", "bos", "lb", "ubs", "bl", "iss"], "bs1": ["resone", "cs3", "cs0", "resOne", "bsone", "bes2", "bb1", "cs1", "bb81", "nsone", "psone", "obs81", "bis1", "bs01", "bosone", "bsOne", "ns2", "bes1", "ls01", "ns81", "bb0", "bingpre", "bbOne", "sespre", "psOne", "ps01", "ses3", "bisOne", "bisone", "bing0", "obsOne", "bs2", "besone", "bes0", "ses2", "bos0", "ls2", "csOne", "bs3", "lsOne", "bis81", "fs1", "bos81", "lsone", "fsOne", "res01", "ls1", "fs3", "bbone", "csone", "bing11", "cs11", "sesOne", "ns0", "cspre", "fs2", "ns1", "bing1", "ps1", "cs2", "bs81", "fsone", "ses1", "obs1", "bos1", "bs0", "ses0", "bspre", "ses11", "obsone", "bs11", "res1"], "sn_tab": ["sb8tab", "sn__tab", "sn__list", "sb_group", "sn_group", "SN_info", "snappinfo", "sn_list", "SN_tab", "snappstat", "SN_stack", "SN_bar", "sn__lab", "sn_stat", "sn1stat", "snappstack", "sb_tab", "sn8tab", "sn1info", "fn_cell", "SN_stat", "SN_list", "sn_stack", "sn_range", "sn2tab", "sb8group", "sn1tab", "sb_info", "sn_cell", "sn8group", "fn_tab", "sb8range", "snapptab", "sn2bar", "sb8info", "sn8info", "sb_range", "sn2info", "sn_lab", "sn__info", "fn_state", "SN_lab", "sn1stack", "sn_state", "sn_bar", "sn8range", "fn_info", "sn2list"], "sn": ["ny", "sync", "ni", "nn", "kn", "syn", "sp", "na", "sk", "cn", "nb", "sw", "si", "sq", "ii", "fn", "session", "conn", "sch", "p", "li", "sb", "sf", "sd", "n", "ski", "ann", "ns", "skill", "shell", "pn", "sc", "ssl", "sv", "nt", "sl", "attr", "sh", "sa", "SN", "dn", "ls", "su", "span", "Sn", "sm"], "s": ["sys", "m", "service", "sync", "t", "sg", "d", "g", "S", "sp", "settings", "js", "si", "sq", "session", "server", "ps", "ss", "o", "p", "e", "sb", "sf", "b", "n", "gs", "state", "spec", "ns", "is", "stats", "sv", "sl", "services", "ds", "sa", "ls", "space", "sm"], "sn_info": ["sn2info", "SN_list", "sn__info", "sn__Info", "sn_fo", "sn2id", "sn2tab", "sn__tab", "sn__list", "sn_id", "SN_id", "SN_info", "SN_fo", "sn_Info", "SN_Info", "sn_list", "sn2fo", "SN_tab"], "nb_sns": ["nb_exns", "nb_psts", "nb_ssns", "nb_sxs", "nb_kls", "nb_csls", "nbJexls", "nb_pns", "nb_ssgs", "nb_kns", "nb_Samples", "nb_ngs", "nb_snapvs", "nbJsns", "nb_nessions", "nb_csgs", "nb_inds", "nb_snapnas", "nb_sesls", "nb_nsts", "nb_pgs", "nb_pls", "nb_kvs", "nb_shults", "nb_csns", "nbJssts", "nbJsessions", "nb_ssls", "nb_pcs", "nb_snas", "nb_sscs", "nb_exsts", "nb_ncs", "nb_sssts", "nb_exls", "nb_pamples", "nb_snapessions", "nb_Sns", "nb_pds", "nbJsgs", "nb_inns", "nb_snapns", "nb_ssvs", "nb_sgs", "nb_samples", "nb_pxs", "nbJsnapls", "nbJsls", "nb_ssnas", "nb_pults", "nb_nns", "nb_shns", "nb_sults", "nb_nls", "nb_scs", "nbJexvs", "nb_sesgs", "nb_snapgs", "nb_Sxs", "nbJexsts", "nb_nults", "nb_shsts", "nb_inxs", "nbJsnapgs", "nbJsnapessions", "nb_snapls", "nb_ssds", "nb_sesds", "nbJexns", "nbJsvs", "nb_sesns", "nb_nvs", "nb_sls", "nb_sds", "nb_inamples", "nbJsnapns", "nb_Sds", "nb_shls", "nb_csessions", "nb_exvs", "nb_ssts", "nb_svs", "nb_knas", "nb_sessions"], "i": ["hi", "qi", "it", "ui", "slice", "I", "ni", "ai", "xi", "id", "ini", "iu", "gi", "l", "my", "io", "oi", "api", "mu", "ci", "ki", "di", "x", "si", "ie", "ii", "uri", "limit", "o", "yi", "u", "ind", "size", "p", "e", "ib", "info", "fi", "z", "mi", "li", "k", "ix", "multi", "j", "count", "n", "phi", "f", "ti", "ski", "ip", "c", "eni", "end", "inner", "pi", "iter", "bi", "ri", "ori", "ami", "zi", "y", "abi", "index", "start"], "ret": ["alt", "part", "complete", "reply", "art", "trial", "val", "back", "def", "rets", "fun", "option", "ref", "post", "arg", "det", "full", "lit", "sr", "valid", "error", "job", "failed", "open", "mem", "found", "rb", "desc", "mi", "match", "data", "ext", "success", "Ret", "bit", "f", "result", "att", "rl", "url", "nt", "selected", "re", "rt", "sur", "r", "RET", "al", "res", "reg", "usr", "len", "stable"], "available": ["supported", "enough", "enabled", "existing", "complete", "usable", "shared", "ai", "successful", "external", "confirmed", "extra", "disabled", "current", "api", "bound", "limited", "public", "safe", "expected", "missing", "published", "full", "sum", "valid", "open", "able", "active", "instance", "resource", "visible", "initialized", "info", "effective", "running", "used", "length", "availability", "protected", "ready", "installed", "ac", "allowed", "selected", "Available", "empty", "volume", "accessible", "stable"], "total": ["percent", "partial", "done", "part", "non", "complete", "qa", "t", "shared", "id", "private", "current", "tax", "limited", "final", "null", "by", "full", "sum", "fat", "valid", "error", "key", "meta", "Total", "open", "index", "active", "size", "e", "temp", "info", "not", "li", "base", "multi", "used", "length", "count", "result", "parent", "list", "html", "next", "cat", "type", "now", "pi", "nt", "scale", "all", " Total", "last", "volume", "we", "no", "post", "max", "stable"], "available_snapshots": ["available_sputs", "available__captctions", "available_gallipes", "available_sshot", "available_simages", "available2captpoints", "available_gallshots", "available_nipes", "available_gallots", "available_snapcs", "available2captments", "available_captpoints", "available_sblems", "available_batchpoints", "available_batchuts", "available_spshots", "available__snapots", "available_gallimages", "available_snapots", "available_captots", "available__captets", "available__snapctions", "available2snapments", "available2snaputs", "available_captshots", "available_captets", "available_snappoints", "available_synshots", "available_synets", "available_snapments", "available_batchments", "available_snapipes", "available_prections", "available_spments", "available__snapshots", "available_snapets", "available_snapctions", "available_sppoints", "available_Snapshots", "available_synots", "available_captctions", "available_preets", "available_fourshot", "available_Snapshot", "available2snapshots", "available_preots", "available_Snapcs", "available_synctions", "available_sshots", "available_preshots", "available_recordshots", "available_captments", "available2snappoints", "available_fourcs", "available_nots", "available2captuts", "available_recordblems", "available_nimages", "available_captuts", "available__captots", "available_fourshots", "available_snaputs", "available_recordshot", "available_recordimages", "available_nshots", "available_scs", "available_snapshot", "available__snapets", "available_Snapblems", "available2captshots", "available_snapblems", "available_batchshots", "available__captshots", "available_snapimages", "available_Snapimages"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,\n\n                                        hwaddr size, unsigned client)\n\n{\n\n    assert(mr->terminates);\n\n    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,\n\n                                                    size, client);\n\n}\n", "idx": 21612, "substitutes": {"mr": ["ru", "err", "adr", "Mr", "rpm", "rr", "tr", "yr", "rf", "lr", "pc", "r", "m", "mc", "rh", "dr", "rc", "nr", "rm", "fr", "rar", "sr", "rl", "vr", "rt", "hr", "usr", "fm", "cr", "er", "bm", "reader", "br", "req", "rs", "manager", "vm", "kr", "rb", "tm", "ir", "MR", "mn", "rg"], "addr": ["conn", "ref", "adr", "hop", "amp", "part", "val", "kt", "mode", "oa", "ord", "wd", "align", "host", "node", "layer", "address", "ip", "enc", "id", "ace", "prefix", "mac", "ext", "dr", "index", "nr", "edge", "rt", "ptr", "src", "slice", "base", "offset", "x", "attr", "inter", "url"], "size": ["name", "security", "shape", "iz", "esc", "en", "scale", "eni", "sized", "Size", "style", "ize", "ish", "address", "use", "storage", "grow", "gz", "six", "small", "si", "len", "z", "sec", "from", "SIZE", "empty", "offset", "max", "count"], "client": ["remote", "sim", "public", "external", "conn", "wrapper", "gray", "config", "progress", "cm", "connection", "null", "pc", "local", "cell", "buffer", "ian", "standard", "box", "cache", "mac", "cli", "close", "ctx", "self", "window", "worker", "child", "ients", "clean", "global", "parent", "lib", "util", "ce", "resource", "server", "this", "Client"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)\n\n{\n\n    VLANClientState *vc;\n\n\n\n    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {\n\n        if (vc != sender && !vc->link_down) {\n\n            vc->receive(vc->opaque, buf, size);\n\n        }\n\n    }\n\n}\n", "idx": 26904, "substitutes": {"vc": ["dc", "ll", "c", "cv", "vs", "cci", "xc", "ec", "api", "vec", "vr", "ant", "nv", "vt", "ct", "bc", "cy", "util", "vv", "nec", "wx", "fc", "cs", "iw", "ic", "vid", "rl", "loc", "wl", "voc", "cli", "wd", "cc", "ku", "ci", "client", "cf", "cn", "rc", "ou", "ctx", "ga", "vm", "cp", "lc", "serv", "ls", "rt", "lv", "service", "vd", "cu", "conn", "fp", "VC", "nc", "sv", "ce", "pc", "dn"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,\n\n                      int abort_on_failure)\n\n{\n\n    QemuOpts *opts;\n\n    int rc = 0;\n\n\n\n    TAILQ_FOREACH(opts, &list->head, next) {\n\n        rc = func(opts, opaque);\n\n        if (abort_on_failure  &&  rc != 0)\n\n            break;\n\n    }\n\n    return rc;\n\n}\n", "idx": 24047, "substitutes": {"list": ["stack", "name", "config", "acl", "chain", "loop", "result", "queue", "lists", "layer", "listed", "pre", "sequence", "full", "List", "code", "sync", "cli", "live", "client", "out", "self", "complete", "la", "collection", "low", "seq", "top", "call", "batch", "parent", "li", "all", "LIST", "l", "base", "this"], "func": ["fc", "expr", "stack", "cc", "prev", "next", "wrapper", "loop", "val", "unc", "apply", "handler", "pc", "interface", "invoke", "function", "f", "layer", "exec", "op", "adder", "nc", " function", "r", "cf", "ace", "c", "cb", "later", "complete", "lambda", "b", "go", "worker", "callback", "back", "proc", "up", "fn", "fun"], "opaque": ["operacity", "opaques", "operaque", "opsacs", "opspha", "opusacity", "opsacity", "opsaques", "ipaques", "ipaque", "ipacle", "opusaque", "opusacs", "opacle", "opuspha", "oppha", " oppha", " opacs", "opacity", "operacle", " opacity", "opsacle", "opsaque", "operaques", "ipacity", "opacs"], "abort_on_failure": ["abort_on_structash", "abort_on_passure", "abort_on_failured", "abort_on_flowured", "abort_on_structure", "abort_on_failedion", "abort_on_fallur", "abort_on_failedured", "abort_on_failion", "abort_on_flowure", "abort_on_failures", "abort_on_failedURE", "abort_on_structures", "abort_on_flowion", "abort_on_failur", "abort_on_passash", "abort_on_flowURE", "abort_on_failash", "abort_on_fallures", "abort_on_structur", "abort_on_fallure", "abort_on_passURE", "abort_on_passion", "abort_on_passured", "abort_on_passures", "abort_on_passur", "abort_on_failURE", "abort_on_fallash", "abort_on_failedure"], "opts": [" optms", " opms", "opters", "operrs", "opcs", "optps", "optters", " opks", "operps", " optters", "operts", "appcs", "opms", "optrs", "hopts", "oprs", " opcs", " opte", " optcs", "opte", "optte", " optts", "opps", "opercs", "optms", "hopte", "optks", "hopters", "appps", "optcs", "hopks", "opks", "appts", "optts", "apprs", " opters"]}}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "static inline int RENAME(yuv420_rgb16)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n\n    int y, h_size;\n\n\n\n    if(c->srcFormat == PIX_FMT_YUV422P){\n\n\tsrcStride[1] *= 2;\n\n\tsrcStride[2] *= 2;\n\n    }\n\n\n\n    h_size= (c->dstW+7)&~7;\n\n    if(h_size*2 > FFABS(dstStride[0])) h_size-=8;\n\n\n\n    __asm__ __volatile__ (\"pxor %mm4, %mm4;\" /* zero mm4 */ );\n\n//printf(\"%X %X %X %X %X %X %X %X %X %X\\n\", (int)&c->redDither, (int)&b5Dither, (int)src[0], (int)src[1], (int)src[2], (int)dst[0],\n\n//srcStride[0],srcStride[1],srcStride[2],dstStride[0]);\n\n    for (y= 0; y<srcSliceH; y++ ) {\n\n\tuint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];\n\n\tuint8_t *_py = src[0] + y*srcStride[0];\n\n\tuint8_t *_pu = src[1] + (y>>1)*srcStride[1];\n\n\tuint8_t *_pv = src[2] + (y>>1)*srcStride[2];\n\n\tlong index= -h_size/2;\n\n\n\n\tb5Dither= dither8[y&1];\n\n\tg6Dither= dither4[y&1];\n\n\tg5Dither= dither8[y&1];\n\n\tr5Dither= dither8[(y+1)&1];\n\n\t    /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8\n\n\t       pixels in each iteration */\n\n\t    __asm__ __volatile__ (\n\n\t/* load data for start of next scan line */\n\n\t\t     \"movd (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\t\t     \"movd (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\t\t     \"movq (%5, %0, 2), %%mm6;\" /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n//\t\t    \".balign 16\t\t\t\\n\\t\"\n\n\t\t    \"1:\t\t\t\t\\n\\t\"\n\n/* no speed diference on my p3@500 with prefetch,\n\n * if it is faster for anyone with -benchmark then tell me\n\n\t\t\tPREFETCH\" 64(%0) \\n\\t\"\n\n\t\t\tPREFETCH\" 64(%1) \\n\\t\"\n\n\t\t\tPREFETCH\" 64(%2) \\n\\t\"\n\n*/\n\nYUV2RGB\n\n\n\n#ifdef DITHER1XBPP\n\n\t\t\t\"paddusb \"MANGLE(b5Dither)\", %%mm0;\"\n\n\t\t\t\"paddusb \"MANGLE(g6Dither)\", %%mm2;\"\n\n\t\t\t\"paddusb \"MANGLE(r5Dither)\", %%mm1;\"\n\n#endif\n\n\t\t     /* mask unneeded bits off */\n\n\t\t     \"pand \"MANGLE(mmx_redmask)\", %%mm0;\" /* b7b6b5b4 b3_0_0_0 b7b6b5b4 b3_0_0_0 */\n\n\t\t     \"pand \"MANGLE(mmx_grnmask)\", %%mm2;\" /* g7g6g5g4 g3g2_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"pand \"MANGLE(mmx_redmask)\", %%mm1;\" /* r7r6r5r4 r3_0_0_0 r7r6r5r4 r3_0_0_0 */\n\n\n\n\t\t     \"psrlw $3,%%mm0;\" /* 0_0_0_b7 b6b5b4b3 0_0_0_b7 b6b5b4b3 */\n\n\t\t     \"pxor %%mm4, %%mm4;\" /* zero mm4 */\n\n\n\n\t\t     \"movq %%mm0, %%mm5;\" /* Copy B7-B0 */\n\n\t\t     \"movq %%mm2, %%mm7;\" /* Copy G7-G0 */\n\n\n\n\t\t     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */\n\n\t\t     \"punpcklbw %%mm4, %%mm2;\" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"punpcklbw %%mm1, %%mm0;\" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */\n\n\n\n\t\t     \"psllw $3, %%mm2;\" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */\n\n\t\t     \"por %%mm2, %%mm0;\" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */\n\n\n\n\t\t     \"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\t\t     MOVNTQ \" %%mm0, (%1);\" /* store pixel 0-3 */\n\n\n\n\t\t     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */\n\n\t\t     \"punpckhbw %%mm4, %%mm7;\" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */\n\n\t\t     \"punpckhbw %%mm1, %%mm5;\" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */\n\n\n\n\t\t     \"psllw $3, %%mm7;\" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */\n\n\t\t     \"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\n\n\t\t     \"por %%mm7, %%mm5;\" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */\n\n\t\t     \"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\n\n\t\t     MOVNTQ \" %%mm5, 8 (%1);\" /* store pixel 4-7 */\n\n\n\n\t\t     \"add $16, %1\t\t\t\\n\\t\"\n\n\t\t     \"add $4, %0\t\t\t\\n\\t\"\n\n\t\t     \" js 1b\t\t\t\t\\n\\t\"\n\n\n\n\t\t     : \"+r\" (index), \"+r\" (_image)\n\n\t\t     : \"r\" (_pu - index), \"r\" (_pv - index), \"r\"(&c->redDither), \"r\" (_py - 2*index)\n\n\t\t     );\n\n    }\n\n\n\n    __asm__ __volatile__ (EMMS);\n\n\n\n    return srcSliceH;\n\n}\n", "idx": 9109, "substitutes": {"c": ["l", "conf", "oc", "cam", "C", "n", "g", "w", "m", "tc", "conn", "t", "b", "k", "d", "con", "cp", "s", "ct", "p", "e", "cu", "cn", "ec", "f", "ac", "cc", "cs", "ctrl", "cv", "ce", "rc", "ctx", "cur", "cal", "pc", "dc", "xc", "enc", "u", "nc", "h", "cm", "ca", "ci", "comp", "vc", "lc", "ch", "mc"], "src": ["seq", "proc", "source", "sel", "scene", "http", "b", "sur", "bs", "rect", "iv", "config", "dest", "gl", "attr", "usr", "rss", "rb", "loc", "sq", "st", "sec", "inst", "sub", "lib", "cv", "rc", "sl", "ctx", "conv", "sup", "support", "sb", "scenes", "spec", "secure", "scl", "url", "text", "rob", "ources", "sr", "uc", "ssl", "sc"], "srcStride": ["srcShride", "srcScide", "srcSlope", "stStride", "srcDride", "srcShide", "srcSTri", "srcSTrue", "rcShri", "rcStroy", "rcEstri", "srcSlrite", "stClride", "srcScrue", "srcStause", "srcStandcase", "srcClride", "srcStide", "srcShri", "srcClrite", "srcStcase", "supportSTope", "srcEstope", "supportStuse", "srcSlroy", "srcClause", "srcEstuse", " srcSterve", "supportStope", "supportSTuse", "srcSlerve", "srcSlroute", "rcStri", "srcEstrue", "supportStide", "rcStride", "rcEstrue", "srcSTope", "srcSlri", "srcConstroy", "rcShroy", "srcStroy", "srcScrite", "srcStandide", "srcShrite", "srcShcase", "srcDause", " srcStrite", "srcDrite", "supportSTide", "srcEstride", "stStructure", "supportSTride", "rcEstide", "stStause", "rcStroute", "rcShride", "srcStuse", "srcStope", "srcScructure", "srcShroute", "srcSlride", "srcScri", "srcStandrite", "srcSTuse", " srcStcase", "srcSlide", "rcStrue", "srcScride", "srcConstride", "srcStrite", "stStrite", "stClructure", "stClrite", "srcStri", "rcShroute", "supportStride", "srcStrue", " srcStide", "srcStructure", "srcEstri", "srcConstroute", "stClause", "rcStide", "srcSTide", "srcConstri", "srcEstide", "srcSTride", "rcEstride", "srcSluse", "srcScause", "srcClructure", "srcStandride", "srcStroute", "srcDructure", "srcEstrite", "srcEsterve", "srcSterve", "srcShroy"], "srcSliceY": ["srcSlideW", "srcSlideH", "srcSlaceW", "srcFliceW", "srcSliceM", "srcFliceH", "srcSlaseW", "srcSlaceH", "srcSlaseY", "srcFlICEY", "srcSlaceY", "srcSlICEX", "srcSlICEW", "srcFlICEM", "srcSliceX", "srcSlideX", "srcSlaseH", "srcFliceX", "srcFlaseH", "srcSlaceM", "srcFlICEW", "srcFliceY", "srcFlaseW", "srcSlideM", "srcFliceM", "srcSlaceX", "srcSlICEM", "srcSlICEY", "srcSliceW", "srcSlaseX", "srcFlaseX", "srcSlideY", "srcFlICEX", "srcFlaseY"], "srcSliceH": ["srcSlideW", "srcSlideH", "srcSlaceW", "srcFliceH", "srcFliceW", "srcSlsliceHT", "srcSlaceH", "srcFlICEH", "srcSlsliceH", "srcFlICEY", "srcSlaceY", "srcSlICEX", "srcSlICEW", "srcSlICEHT", "srcSlaceF", "srcSliceX", "srcFlICEHT", "srcSlaceHT", "srcSlICEH", "srcFliceHT", "srcFliceX", "srcSlsliceX", "srcSlideF", "srcFliceF", "srcFlICEW", "srcSlICEF", "srcSliceF", "srcFliceY", "srcSliceHT", "srcSlaceX", "srcSlsliceY", "srcSlICEY", "srcSliceW", "srcFlICEF", "srcSlideY", "srcFlICEX"], "dst": ["nste", " drc", "dsrc", "gst", "grc", "nsts", "drc", "Dste", "Dsts", "Dsrc", "dste", "nsrc", " dsrc", "gsts", " dsts", "nst", "Dst", "dsts", " dste", "gsrc", "Drc"], "dstStride": ["dstStide", "dscTrip", "dstTride", "dscStrip", "dstStrend", "dstStro", "dscTri", "dsrcStride", "dststrip", "dstCrip", "dscStri", "dstStrip", "dstStrri", "dstScrite", "dstScube", "dststri", "dstaStride", "dstTide", "dstCrite", "dstStrrite", "dstStrite", "dsrcstube", "dscTrite", "dsrcstrite", "dstStrro", "dstCro", "dstaStrro", "dstTend", "dstTrip", "dstStube", "dscStrite", "dstStrube", "dstaStend", "dsrcStube", "dstTrite", "dststride", "dstaStrride", "dstTri", "dstaStro", "dstaStide", "dstScri", "dscTride", "dstStrride", "dscStride", "dstCride", "dststrite", "dstScride", "dstaStrend", "dsrcStri", "dsrcStrite", "dstStend", "dsrcstride", "dsrcstri", "dstCri", "dstCend", "dstTro", "dstCide", "dststube", "dstStri"], "y": ["count", "isy", "ym", "ady", "my", "yt", "oy", "say", "n", "ry", "ny", "m", "w", "t", "x", "ey", "z", "vy", " Y", "d", "i", "b", "ye", "uy", "ys", "cy", "p", "iy", "yi", "yang", "ay", "zy", "yy", "sy", "j", "gy", "py", "sky", "ky", "yl", "yd", "hy", " x", "Y", "ty", "yr", "yu", "type", "h", "yan", "year", "ya", "dy", "yo"], "h_size": ["h__len", "hxloc", "H_size", "H__len", " hxsize", "h_len", "h1length", "hxize", " h_scale", " h_sum", "H__loc", " h_address", "h2scale", "h__Size", "h2size", "h_Size", " h_width", "H_scale", "h1loc", "h__length", "hxsize", "h_width", " h_SIZE", "h_address", "h_scale", "H__scale", "h_ize", "H__Size", "H_length", "H_Size", " hxize", "h__scale", "H_loc", "H__length", "H_len", " hxscale", "H__size", "h_SIZE", "h1len", "hxscale", "h__loc", "h2loc", " hxloc", "h_length", "h1size", "h2ize", "h__size", "h__sum", " h_ize", "H__sum", "h_loc", " h_loc", "h_sum", "H_sum"], "_image": ["_original", "timg", "_img", "toriginal", "timage", "tpng", "_png"], "_py": [" _dim", "_xy", "wpic", "wdim", "hpic", "hpy", "_dim", "hxy", " _pic", "_pic", "hdim", "wpy", " _xy", "wxy"], "_pu": ["_gpu", "_ui", "__lu", "__ui", "_lu", "__gpu", "__pu"], "_pv": ["_ppf", "_pf", "_Pf", "_gv", "_Pu", "_pvi", "_ppu", "_gu", "_Pvi", "_ppvi", "_gf", "_ppv", "_gvi", "_Pv"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void bdrv_co_drain_bh_cb(void *opaque)\n\n{\n\n    BdrvCoDrainData *data = opaque;\n\n    Coroutine *co = data->co;\n\n\n\n    qemu_bh_delete(data->bh);\n\n    bdrv_drain_poll(data->bs);\n\n    data->done = true;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 26315, "substitutes": {"opaque": ["pacity", "openaques", " opaques", "copaque", "oplaques", "oaque", "opaques", "oacity", "oaques", "pque", "openacity", "copaques", "openaya", "oplaya", "oplaque", "opaya", "paques", " opque", "copacity", " opacity", "paque", "openaque", "opacity", "opque", "oaya", "oplacity", "copque"], "data": ["load", "Data", "code", "call", "info", "batch", "aa", "d", "ae", "module", "ready", "style", "config", "ad", "no", "ada", "type", "error", "reader", "state", "dd", "sync", "op", "rec", "ee", "li", "o", "input", "dat", "la", "object", "one", "di", "change", "client", "cache", "missing", "ata", "as", "comment", "po", "entry", "child", "da", "a", "coll", "DATA", "results", "cookie", "init", "meta", "alpha", "result", "writer"], "co": ["call", "cm", "can", "cca", "CO", "cost", "c", "bo", "oo", "ob", "bb", "soc", "col", "cb", "bc", "so", "cycle", "ra", "company", "oe", "self", "coe", "con", "o", "cl", "loc", "ko", "cro", "cc", "coord", "ci", "mo", "cf", "mc", "rc", "Co", "ca", "aco", "po", "flo", "coll", "ck", "ac", "pc"]}}
{"project": "qemu", "commit_id": "cdeaf1f15909e2e8af38f45aea7cfa467a729c52", "target": 1, "func": "static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,\n\n                                      const uint8_t *buf, int nb_sectors)\n\n{\n\n    int ret;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = vmdk_write(bs, sector_num, buf, nb_sectors);\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    return ret;\n\n}\n", "idx": 11334, "substitutes": {"bs": ["vs", "base", "ds", "lbs", "ba", "bid", "bas", "b", "iss", "sa", "fb", "ls", "pb", "gb", "js", "us", "BS", "bc", "os", "obs", "cs", "bl", "es", "ubs", "bh", "las", "lb", "bis", "bi", "ns", "sb", "blocks", "as", "fs", "ses", "css", "ps", "ss", "bes", "bos"], "sector_num": ["sectorIdnum", "sectoridnumber", " sector_number", "sectorIdnumber", "sector_count", "sector_number", "sector_nom", "sectoridcount", "sectorIdfn", "sectorIdcount", " sector_nom", " sector_count", " sector_name", "sector_fn", "sectoridfn", "sector_name", "sectoridnum", " sector_fn"], "buf": ["bag", "uf", "seq", "Buffer", "ff", "src", "fd", "b", "num", "pool", "fi", "data", "block", "fb", "batch", "ref", "pb", "cb", "fp", "queue", "rb", "loc", "array", "bc", "bf", "alloc", "cv", "v", "ctx", "port", "bytes", "result", "vec", "buff", "buffer"], "nb_sectors": ["nb_spegments", "nb_secctors", "nb_vectors", "nb_sucs", "nb_surars", "nb_specs", "nb_secs", "nb_sears", "nb_surctors", "nb_secvers", "nb_suars", "nb_seitors", "nb_pectors", "nb_severs", "nb_suvers", "nb_survers", "nb_segments", "nb_pegments", "nb_surcs", "nb_vecs", "nb_spectors", "nb_pecs", "nb_speitors", "nb_vegments", "nb_secars", "nb_seccs", "nb_peitors", "nb_suctors", "nb_veitors"], "ret": ["pass", "base", "flag", "len", "val", "alt", "nt", "id", "Ret", "info", "x", "num", " Ret", "pat", "data", "reply", "ref", "arg", "obj", "reg", "final", "rets", "tmp", "f", "j", "code", "rt", "res", "bf", "py", "det", "fun", "att", "ben", "en", "art", "bit", "fin", "cat", "re", "RET", "back", "result", "rev", "match", "ft", "fi"], "s": ["l", "conf", "session", "ts", "is", "ds", "g", "si", "n", "w", "b", "t", "d", "gs", "sa", "c", "service", "iss", "p", "server", "e", "args", "js", "rs", "sq", "f", "j", "cs", "sym", "o", "opt", "S", "sync", "sl", "r", "ns", "sys", "h", "side", "ses", "ps", "fs", "site", "ss", "settings", "ssl"]}}
{"project": "qemu", "commit_id": "becf8217deb2afc347d5172d9f30c8a8964b8b27", "target": 0, "func": "void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,\n\n                                     uintptr_t retaddr)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    int t;\n\n\n\n    cs->exception_index = EXCP_PGM;\n\n    env->int_pgm_code = excp;\n\n\n\n    /* Use the (ultimate) callers address to find the insn that trapped.  */\n\n    cpu_restore_state(cs, retaddr);\n\n\n\n    /* Advance past the insn.  */\n\n    t = cpu_ldub_code(env, env->psw.addr);\n\n    env->int_pgm_ilen = t = get_ilen(t);\n\n    env->psw.addr += t;\n\n\n\n    cpu_loop_exit(cs);\n\n}\n", "idx": 12686, "substitutes": {"env": ["forge", "args", "en", "context", "bc", "enc", "cv", "ea", "config", "code", " environment", "eve", "eu", "utils", "ah", "oa", "ass", "manager", "settings", "kernel", "cn", "txt", "vm", "init", "server", "v", "conf", "conn", "np", "console", "obj", "energy", "dev", "dict", "e", "net", "viron", "exc", "engine", "nc", "vs", "her", "ext", "eng", "site", "Environment", "dat", "export", "c", "eni", "global", "agent", "dt", "ne", "cb", "ce", "cf", "here", "que", "exec", "db", "ev", "inet", "ec", "cache", "environment", "fen", "el", "core", "et", "ctx", "err"], "excp": ["axcp", "extcp", "nexcpp", "excm", "nexpp", "nexcp", "napc", "nexcm", "Expc", "execcpp", "extcpp", "excs", "execcm", "axcs", "axCP", "axpc", "expp", "exCP", "execpp", "Excp", "nacs", "extcm", "excpp", "expc", "execcp", "naCP", "extpp", "ExCP", "nacp", "Excs"], "retaddr": ["RETaddr", "Retace", "Retaddr", "retwork", "RETwork", " retwork", "RETaddress", "Retaddress", " retnode", " retace", "retaddress", "retace", "RETace", " retaddress", "RETnode", "Retwork", "Retnode", "retnode"], "cs": ["args", "acs", "bc", "ca", "sync", "bs", "cc", "pc", "fs", "rs", "lc", "CS", "ci", "sk", "cn", "os", "wcs", "js", "Cs", "ras", "ps", "ss", "conn", "cons", "s", "cks", "ck", "cus", "ars", "gs", "spec", "c", "ns", "cas", "sc", "cf", "cp", "ds", "ec", "css", "ls", "ts", "ces", "vs", "ctx", "ks"], "t": ["T", "port", "it", "m", "d", "l", "i", "pt", "a", "ta", "g", "test", "h", "tt", "wt", "x", "null", "total", "v", "tm", "o", "w", "z", "ant", "u", "p", "e", "y", "s", "temp", "mt", "b", "tc", "j", "n", "f", "ti", "at", "token", "c", "dt", "tf", "type", "tz", "target", " p", "out", "rt", "off", " T", "ts", "ty", "et", "tp"]}}
{"project": "FFmpeg", "commit_id": "f43a16049ef07585789d311f314f236a314f91f7", "target": 0, "func": "int opt_cpuflags(const char *opt, const char *arg)\n\n{\n\n#define CPUFLAG_MMX2     (AV_CPU_FLAG_MMX      | AV_CPU_FLAG_MMX2)\n\n#define CPUFLAG_3DNOW    (AV_CPU_FLAG_3DNOW    | AV_CPU_FLAG_MMX)\n\n#define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW)\n\n#define CPUFLAG_SSE      (AV_CPU_FLAG_SSE      | CPUFLAG_MMX2)\n\n#define CPUFLAG_SSE2     (AV_CPU_FLAG_SSE2     | CPUFLAG_SSE)\n\n#define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2)\n\n#define CPUFLAG_SSE3     (AV_CPU_FLAG_SSE3     | CPUFLAG_SSE2)\n\n#define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3)\n\n#define CPUFLAG_SSSE3    (AV_CPU_FLAG_SSSE3    | CPUFLAG_SSE3)\n\n#define CPUFLAG_SSE4     (AV_CPU_FLAG_SSE4     | CPUFLAG_SSSE3)\n\n#define CPUFLAG_SSE42    (AV_CPU_FLAG_SSE42    | CPUFLAG_SSE4)\n\n#define CPUFLAG_AVX      (AV_CPU_FLAG_AVX      | CPUFLAG_SSE42)\n\n#define CPUFLAG_XOP      (AV_CPU_FLAG_XOP      | CPUFLAG_AVX)\n\n#define CPUFLAG_FMA4     (AV_CPU_FLAG_FMA4     | CPUFLAG_AVX)\n\n    static const AVOption cpuflags_opts[] = {\n\n        { \"flags\"   , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = \"flags\" },\n\n        { \"altivec\" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC  },    .unit = \"flags\" },\n\n        { \"mmx\"     , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX      },    .unit = \"flags\" },\n\n        { \"mmx2\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2         },    .unit = \"flags\" },\n\n        { \"sse\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE          },    .unit = \"flags\" },\n\n        { \"sse2\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2         },    .unit = \"flags\" },\n\n        { \"sse2slow\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW     },    .unit = \"flags\" },\n\n        { \"sse3\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3         },    .unit = \"flags\" },\n\n        { \"sse3slow\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW     },    .unit = \"flags\" },\n\n        { \"ssse3\"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3        },    .unit = \"flags\" },\n\n        { \"atom\"    , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM     },    .unit = \"flags\" },\n\n        { \"sse4.1\"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4         },    .unit = \"flags\" },\n\n        { \"sse4.2\"  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42        },    .unit = \"flags\" },\n\n        { \"avx\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX          },    .unit = \"flags\" },\n\n        { \"xop\"     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP          },    .unit = \"flags\" },\n\n        { \"fma4\"    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4         },    .unit = \"flags\" },\n\n        { \"3dnow\"   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW        },    .unit = \"flags\" },\n\n        { \"3dnowext\", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT     },    .unit = \"flags\" },\n\n        { NULL },\n\n    };\n\n    static const AVClass class = {\n\n        .class_name = \"cpuflags\",\n\n        .item_name  = av_default_item_name,\n\n        .option     = cpuflags_opts,\n\n        .version    = LIBAVUTIL_VERSION_INT,\n\n    };\n\n    int flags = av_get_cpu_flags();\n\n    int ret;\n\n    const AVClass *pclass = &class;\n\n\n\n    if ((ret = av_opt_eval_flags(&pclass, &cpuflags_opts[0], arg, &flags)) < 0)\n\n        return ret;\n\n\n\n    av_force_cpu_flags(flags);\n\n    return 0;\n\n}\n", "idx": 3054, "substitutes": {"opt": ["pl", "name", "ext", "Opt", "bit", "spec", "optim", "cat", "prop", "alt", "ord", "buf", "op", "pair", "options", "proc", "Option", "config", "attr", "oc", "text", "cmd", "var", "path", "val", "OP", "option"], "arg": ["argument", "call", "ig", "name", "bit", "cat", "Arg", "end", "op", "enc", "param", "mac", "proc", "args", "config", "len", "flag", "ar", "cmd", "lib", "var", "gen", "val", "load", "inc", "mem"], "cpuflags_opts": ["cpuflags_opcs", "cpuflags_optcs", "cpuflags_ops", "cpuflags_optionts", "cpuflags_optioncs", "cpuflags_opencs", "cpuflags_opc", "cpuflags_opents", "cpuflags_optc", "cpuflags_options", "cpuflags_openc", "cpuflags_optionc", "cpuflags_opens", "cpuflags_optts"]}}
{"project": "FFmpeg", "commit_id": "1f361124d97cf8b8ce6d3aacb10cdc53706470de", "target": 1, "func": "int ff_img_read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n    VideoDemuxData *s = s1->priv_data;\n\n    char filename_bytes[1024];\n\n    char *filename = filename_bytes;\n\n    int i;\n\n    int size[3]           = { 0 }, ret[3] = { 0 };\n\n    AVIOContext *f[3]     = { NULL };\n\n    AVCodecContext *codec = s1->streams[0]->codec;\n\n\n\n    if (!s->is_pipe) {\n\n        /* loop over input */\n\n        if (s->loop && s->img_number > s->img_last) {\n\n            s->img_number = s->img_first;\n\n        }\n\n        if (s->img_number > s->img_last)\n\n            return AVERROR_EOF;\n\n        if (s->use_glob) {\n\n#if HAVE_GLOB\n\n            filename = s->globstate.gl_pathv[s->img_number];\n\n#endif\n\n        } else {\n\n        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),\n\n                                  s->path,\n\n                                  s->img_number) < 0 && s->img_number > 1)\n\n            return AVERROR(EIO);\n\n        }\n\n        for (i = 0; i < 3; i++) {\n\n            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,\n\n                           &s1->interrupt_callback, NULL) < 0) {\n\n                if (i >= 1)\n\n                    break;\n\n                av_log(s1, AV_LOG_ERROR, \"Could not open file : %s\\n\",\n\n                       filename);\n\n                return AVERROR(EIO);\n\n            }\n\n            size[i] = avio_size(f[i]);\n\n\n\n            if (!s->split_planes)\n\n                break;\n\n            filename[strlen(filename) - 1] = 'U' + i;\n\n        }\n\n\n\n        if (codec->codec_id == AV_CODEC_ID_NONE) {\n\n            AVProbeData pd;\n\n            AVInputFormat *ifmt;\n\n            uint8_t header[PROBE_BUF_MIN + AVPROBE_PADDING_SIZE];\n\n            int ret;\n\n            int score = 0;\n\n\n\n            ret = avio_read(f[0], header, PROBE_BUF_MIN);\n\n            if (ret < 0)\n\n                return ret;\n\n\n            avio_skip(f[0], -ret);\n\n            pd.buf = header;\n\n            pd.buf_size = ret;\n\n            pd.filename = filename;\n\n\n\n            ifmt = av_probe_input_format3(&pd, 1, &score);\n\n            if (ifmt && ifmt->read_packet == ff_img_read_packet && ifmt->raw_codec_id)\n\n                codec->codec_id = ifmt->raw_codec_id;\n\n        }\n\n\n\n        if (codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)\n\n            infer_size(&codec->width, &codec->height, size[0]);\n\n    } else {\n\n        f[0] = s1->pb;\n\n        if (url_feof(f[0]))\n\n            return AVERROR(EIO);\n\n        if (s->frame_size > 0) {\n\n            size[0] = s->frame_size;\n\n        } else {\n\n            size[0] = 4096;\n\n        }\n\n    }\n\n\n\n    if (av_new_packet(pkt, size[0] + size[1] + size[2]) < 0)\n\n        return AVERROR(ENOMEM);\n\n    pkt->stream_index = 0;\n\n    pkt->flags       |= AV_PKT_FLAG_KEY;\n\n    if (s->ts_from_file) {\n\n        struct stat img_stat;\n\n        if (stat(filename, &img_stat))\n\n            return AVERROR(EIO);\n\n        pkt->pts = (int64_t)img_stat.st_mtime;\n\n        av_add_index_entry(s1->streams[0], s->img_number, pkt->pts, 0, 0, AVINDEX_KEYFRAME);\n\n    } else if (!s->is_pipe) {\n\n        pkt->pts      = s->pts;\n\n    }\n\n\n\n    pkt->size = 0;\n\n    for (i = 0; i < 3; i++) {\n\n        if (f[i]) {\n\n            ret[i] = avio_read(f[i], pkt->data + pkt->size, size[i]);\n\n            if (!s->is_pipe)\n\n                avio_close(f[i]);\n\n            if (ret[i] > 0)\n\n                pkt->size += ret[i];\n\n        }\n\n    }\n\n\n\n    if (ret[0] <= 0 || ret[1] < 0 || ret[2] < 0) {\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO); /* signal EOF */\n\n    } else {\n\n        s->img_count++;\n\n        s->img_number++;\n\n        s->pts++;\n\n        return 0;\n\n    }\n\n}", "idx": 6763, "substitutes": {"s1": ["fs81", "cs1", "s81", "cone", "sone", "c2", "ds3", "c1", "sons", "sys1", "jsfirst", "e2", "sysons", "js81", "sfirst", "sc7", "ns11", "f3", "s2", "csone", " s81", "e1", "fs1", "dsone", "s7", " sfirst", "js1", "eone", "fone", "dsons", "ds11", "sc11", " s7", "fsfirst", "ds1", " s11", "s3", "sysrc", " sons", " src", "ns7", "cs2", "sys11", "s11", "ns1", "f1", "src", "dsrc", "c3", "sc1"], "pkt": [" ppt", "dpkt", "Ppt", "Pkt", "dpct", "ppt", " pct", "dppt", "pct", "packet", "Pct", "dpacket", "Packet", " packet"], "s": ["S", "a", "b", "data", "sk", "parts", "d", "service", "conf", "w", "self", "h", "aws", "g", "sym", "y", "tp", "sets", "is", "spec", "services", "its", "states", "server", "ls", "sc", "ds", "ctx", "ts", "settings", "sv", "fs", "new", "sq", "ms", "site", "rs", "as", "sec", "ins", "sg", "comments", "sync", "ses", "cs", "u", "vs", "e", "sb", "ks", "t", "qs", "p", "c", "os", "ssl", "ims", "r", "ps", "o", "v", "http", "session", "si", "sys", "m", "l", "xs", "ns", "stats", "args", "us", "ss", "gs", "storage", "n", "this", "es", "js"], "filename_bytes": ["Filename_Bytes", "filename6length", "filename_tes", "filename2Bytes", "Filename_bits", "filename_seconds", "sound_lines", "filename_Bytes", " filename_lines", "filename2seconds", "filename_parts", "sound_Bytes", "filename6lines", "filename_bits", "filename6bytes", "sound_bytes", "filename2bytes", "filename_groups", "sound_tes", " filename_length", "filename_lines", "Filename_parts", "Filename_bytes", "Filename_seconds", "filename_length", "filename2parts", "Filename_groups"], "filename": ["name", "files", "sf", "kn", "word", "username", "STDOUT", "whatever", "data", "final", "sn", "slice", "image", "status", "sequence", "wb", "content", "url", "metadata", "phrase", "sheet", "nm", "length", "document", "gz", "subject", "which", "ename", "buffer", "fil", "uri", "download", "file", "message", "fn", "binary", "json", "jpg", "directory", "fp", "dll", "nil", "feat", "suff", "source", "output", "memory", "kl", "txt", "bf", "sym", "utf", "il", "fd", "sword", "src", "Filename", "summary", "prefix"], "i": ["gi", "layer", "ti", "v", "id", "I", "count", "chi", "di", "ci", "ki", "ni", "x", "xi", "si", "ri", "slice", "abi", "b", "io", "bi", "m", "qi", "ix", "l", "num", "pi", "yi", "phi", "j", "ii", "iu", "d", "it", "cli", "ai", "split", "u", "vi", "part", "len", "e", "uri", "n", "multi", "mi", "ini", "ie", "p", "mini", "eni", "z", "start", "oi", "hi", "c", "ip", "y", "lc", "li", "inner", "fi", "index", "zi", "diff", "mu", "ui"], "size": ["fat", "name", "ch", "time", "SIZE", "extra", "sec", "el", "shape", "value", "x", "sum", "data", "final", "sn", "enc", "si", " sizes", "body", "unit", "status", "loc", "offset", "content", "j", "length", "fl", "small", "Size", "member", "code", "len", "buffer", "e", "en", "message", "file", "sized", "empty", "z", "g", "fd", "desc", "ize", "form"], "ret": ["flag", "reg", "mem", "el", "rt", "alt", "id", "nt", "lt", "val", "rc", "data", "sn", "enc", "final", "cat", "info", "reply", "let", "flat", "status", "valid", "uf", " Ret", "lit", "offset", "ext", "att", "pet", "res", "match", "def", "buffer", "len", "part", "det", "error", "out", "en", "RET", "fn", "feat", "response", "rl", "result", "temp", "Ret", "opt", "ft", "re", "fun", "back", "detail", "bf", "resp", "gt", "txt", "success", "ref", "rep", "test", "group", "desc", "rets"], "f": ["fen", "fr", "feed", "sf", "v", "b", "x", "rf", "info", "m", "fb", "l", "d", "fl", "j", "q", "fe", "u", "def", "e", "w", "file", "full", "fn", "t", "df", "xf", "fp", "self", "of", "fa", "p", "h", "z", "frame", "fs", "c", "g", "fd", "cf", "fc", "lf", "r", "F"], "codec": ["predec", "Codoc", "codroc", "codef", "Codef", "labec", " codric", "predoc", "labef", "odroc", "laboc", "predef", "codeca", "Codroc", "Coditor", "odric", "coditor", "calroc", "pedeca", "pedef", "CodEC", "calitor", " codeca", "pedec", "odeca", "Codec", " codef", "labEC", "oditor", "codoc", "calec", "odef", "predEC", "pedric", "codEC", "codric", "odec"], "pd": [" dw", " rec", " td", " cd", " dd", " board", "data", " buff", " obj", " det", " ad", " sd", " rc", " dc", "d", " din", " parser", " enc", " da", " device", " d", " cc", " dev", " gp", " structure", " dst", " props", " def", " coding"], "ifmt": [" ifm", "ifvt", "ifdr", " ifdr", "itvt", "iffvt", "itmt", "ifm", "itm", "iffmt", "iffm", "iffdr", "itdr", " ifvt"], "header": ["master", "writer", "dr", "name", "layer", "bin", "block", "channel", "tail", "cover", "data", "token", "body", "mask", "holder", "null", "offset", "content", "event", "player", "meta", "version", "metadata", "server", "document", "table", "byte", "buffer", "len", "Header", "secondary", "df", "headers", "h", "cap", "head", "type", "handler", "index", "flags"], "img_number": ["imgIdwork", "imgsno", "img_work", "imgIPnext", "imglnumber", "imgqno", "imgsnumber", "imgkno", "image_next", "image_no", "imgIPclass", "imgqnumber", "image_numbered", "imglnum", "img_address", "img_source", "imag_work", "image_last", "image_num", "image_class", "imgsfirst", "imgqclass", "imgIdnom", "img_last", "img_type", "imgknumber", "imgqnext", "image_address", "imgIdnum", "imgIdnumber", "imag_nom", "imgslast", "imgladdress", "img_numbered", "image_first", "img_no", "imag_num", "imgknumbered", "image_number", "imgIPnumber", "imgIPno", "image_type", "imgknext", "img_next", "img_class", "image_source", "img_nom", "img_num", "img_first", "imag_number", "imgltype"]}}
{"project": "qemu", "commit_id": "086abc1ccd0fa5103345adda819e6c6436949579", "target": 0, "func": "static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(n);\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n    int queues = n->multiqueue ? n->max_queues : 1;\n\n\n\n    if (!get_vhost_net(nc->peer)) {\n\n        return;\n\n    }\n\n\n\n    if (!!n->vhost_started ==\n\n        (virtio_net_started(n, status) && !nc->peer->link_down)) {\n\n        return;\n\n    }\n\n    if (!n->vhost_started) {\n\n        int r;\n\n        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {\n\n            return;\n\n        }\n\n        n->vhost_started = 1;\n\n        r = vhost_net_start(vdev, n->nic->ncs, queues);\n\n        if (r < 0) {\n\n            error_report(\"unable to start vhost net: %d: \"\n\n                         \"falling back on userspace virtio\", -r);\n\n            n->vhost_started = 0;\n\n        }\n\n    } else {\n\n        vhost_net_stop(vdev, n->nic->ncs, queues);\n\n        n->vhost_started = 0;\n\n    }\n\n}\n", "idx": 10982, "substitutes": {"n": ["l", "gn", "un", "mn", "nb", "g", "hn", "na", "w", "conn", "m", "nt", "t", "net", "b", "num", "z", "k", "d", "i", "ne", "c", "s", "nor", "p", "anon", "e", "np", "cn", "dn", "nov", "network", "nm", "pn", "f", "an", "j", "o", "N", "nit", "v", "syn", "ic", "en", "sn", "new", "ns", "nic", "node", "enc", "fn", "u", "self", "nl", "rn", "not", "nu", "on", "yn", "adj", "ln", "nn"], "status": ["Status", "uses", "std", "active", "str", "stats", "conn", "stat", "data", "s", "config", "server", "cli", "np", "rss", "network", "nat", "code", "progress", "version", "size", "nil", "sync", "name", "current", "remote", "state", "details", "spec", "node", "sys", "out", "result", "ss", "resp", "ok", "sc"], "vdev": ["svdiv", "ldev", "htr", "svver", "svdevice", " vver", "svtr", "Vev", "wdev", "vserv", "vswitch", " vswitch", "vdevice", "hdevice", " vdiv", "lswitch", "hdev", "Vdev", "hdiv", "pdev", " vdevice", "vev", "svdev", "Vdiv", "vDev", "ldevice", "pserv", " vev", " vDev", "ltr", "pdiv", "VDev", "wdevice", "vver", " vserv", "vdiv", "wev", "pdevice", "vtr", "svswitch", "wDev", "Vserv", "lver", "Vdevice"], "nc": ["cdn", "gn", "qt", "mn", "conn", "nt", "net", "ne", "c", "ct", "nec", "cb", "np", "cn", "nw", "ec", "dn", "bc", "nm", "cc", "cs", "NC", "nv", "cv", "ck", "rc", "ctx", "sn", "nr", "ns", "pc", "dc", "nic", "enc", "rn", "ci", "ng", "bn", "ni", "lc", "jc", "mc", "roc", "nn", "fc"], "r": ["cr", "rh", "l", "rf", "ru", "arr", "str", "g", "rd", "hr", "rw", "w", "m", "mr", "rr", "b", "k", "t", "z", "kr", "d", "i", "ra", "c", "p", "e", "attr", "or", "rb", "rs", "lr", "f", "er", "o", "v", "R", "rc", "ar", "pr", "err", "nr", "error", "rar", "u", "re", "rx", "rg", "row", "a", "result", "sr", "br", "rl"]}}
{"project": "qemu", "commit_id": "65cdadd2e2de76f7db3bf6b7d8dd8c67abff9659", "target": 0, "func": "START_TEST(qint_get_int_test)\n\n{\n\n    QInt *qi;\n\n    const int value = 123456;\n\n\n\n    qi = qint_from_int(value);\n\n    fail_unless(qint_get_int(qi) == value);\n\n\n\n    QDECREF(qi);\n\n}\n", "idx": 218, "substitutes": {"qi": ["Q", "li", "gi", "q", "quad", "fen", "qs", "ei", "ii", "zi", "chi", "lli", "ni", "pi", "mini", "di", "cci", "ffe", "iq", "i", "eni", "iaz", "plug", "aka", "pai", "ani", "ini", "dq", "ai", "ie", "adi", "bi", "iana", "ahi", "sq", "gui", "jp", "qa", "agi", "ci", "mu", "qt", "fi", "qq", "si", "qua", "xi"]}}
{"project": "qemu", "commit_id": "17ad9b358bceba78ae80f2963c6036eab726010c", "target": 0, "func": "static int ram_save_block(QEMUFile *f)\n\n{\n\n    RAMBlock *block = last_block;\n\n    ram_addr_t offset = last_offset;\n\n    int bytes_sent = -1;\n\n    MemoryRegion *mr;\n\n\n\n    if (!block)\n\n        block = QLIST_FIRST(&ram_list.blocks);\n\n\n\n    do {\n\n        mr = block->mr;\n\n        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,\n\n                                    DIRTY_MEMORY_MIGRATION)) {\n\n            uint8_t *p;\n\n            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;\n\n\n\n            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,\n\n                                      DIRTY_MEMORY_MIGRATION);\n\n\n\n            p = memory_region_get_ram_ptr(mr) + offset;\n\n\n\n            if (is_dup_page(p)) {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);\n\n                qemu_put_byte(f, *p);\n\n                bytes_sent = 1;\n\n            } else {\n\n                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);\n\n                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);\n\n                bytes_sent = TARGET_PAGE_SIZE;\n\n            }\n\n\n\n            break;\n\n        }\n\n\n\n        offset += TARGET_PAGE_SIZE;\n\n        if (offset >= block->length) {\n\n            offset = 0;\n\n            block = QLIST_NEXT(block, next);\n\n            if (!block)\n\n                block = QLIST_FIRST(&ram_list.blocks);\n\n        }\n\n    } while (block != last_block || offset != last_offset);\n\n\n\n    last_block = block;\n\n    last_offset = offset;\n\n\n\n    return bytes_sent;\n\n}\n", "idx": 2280, "substitutes": {"f": ["fo", "fc", "ff", "fd", "tf", "q", "fen", "xf", "fw", "form", "fa", "d", "lf", "buff", "fn", "rf", "F", "j", "g", "i", "m", "fp", "file", "sf", "df", "fr", "info", "bf", "feed", "fe", "fi", "l", "c", "e", "self", "conf", "fx", "handler", "fm", "v", "fb", "b", "cf", "uf", "af", "fs", "inf"], "block": ["lock", "row", "large", "key", "panel", "queue", "clock", "open", "job", "empty", "index", "address", "ack", "x", "prev", "object", "blocking", "join", "comment", "manager", "limit", "board", "map", "pack", "flow", "unit", "group", "name", "image", "type", "position", "bc", "id", "chain", "frame", "off", "batch", "bl", "tx", "work", "state", "layout", "lc", "length", "Block", "plugin", "session", "link", "base", "offset", "channel", "loc", "out", "page", "loop", "pre", "info", "cb", "pool", "function", "ref", "cache", "other", "node", "error", "module", "close", "run", "call", "ban", "check", "no", "buffer", "broad", "header", "un", "label", "none", "box", "sync", "coll", "number", "config", "ip", "range", "b", "clean", "full", "line", "view", "part"], "mr": ["dr", "mn", "rg", "cm", "vm", "mt", "rs", "gr", "spec", "wk", "mc", "mx", "bm", "wr", "ml", "km", "rr", "MR", "r", "yr", "ru", "mer", "mi", "mm", "lr", "kr", "rf", "rb", "m", "nr", "er", "fr", "cr", "tr", "md", "hm", "bro", "pr", "rpm", "rl", "dm", "br", "attr", "rm", "wm", "pm", "fm", "rd", "sr", "asm", "bridge", "shr", "manager", "module", "rt", "vr", "rh", "Mr"], "p": ["np", "vp", "offset", "q", "lp", "pe", "pi", "r", "n", "page", "ap", "pg", "sp", "pb", "pair", "api", "py", "pre", "i", "po", "tp", "j", "m", "proc", "fp", "P", "pid", "pointer", "pool", "ps", "address", "pa", "ip", "c", "pr", "l", "e", "u", "jp", "o", "pc", "point", "bp", "v", "cp", "b", "t", "wp", "pp", "port"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n", "idx": 24164, "substitutes": {"s": ["S", "temp", "txt", "rs", "ses", "sys", "w", "i", "p", "m", "b", "c", "ns", "context", "d", "ts", "ds", "conf", "support", "ps", "sg", "sync", "su", "u", "e", "es", "sets", "session", "sv", "sym", "ctx", "sb", "services", "xs", "h", "f", "fs", "js", "src", "t", "a", "v", "sf", "ops", "ssl", "cs", "g"], "rlow": [" rlo", " rmin", "rrange", "rrlo", "rmid", "rrmin", "plow", "pLow", "srlo", "rrlow", "rlo", "prange", "rclow", "rrmid", "srLow", "rcLow", "srmin", "srmid", "srrange", "rcmin", "rmin", "pmin", "rLow", "srlow", " rmid", "rcrange"], "rhigh": ["frfill", "frpeak", "rmid", "rpeak", "rtop", "prhi", "frmid", "irlimit", "rlimit", "prlimit", "rfill", " rpeak", "prhigh", "rarhigh", " rfill", "rhi", "rarmid", " rhi", "frhigh", "rarfill", "irhigh", "irtop", " rlimit", "prtop", "rarpeak", " rtop", "irhi", " rmid"], "val": ["temp", "ref", "obj", "pot", "b", "pt", "p", "VAL", "x", "test", "eval", "data", "base", "var", "prop", "py", "gb", "vt", "bl", "split", "vals", "db", "al", "grad", "valid", "pb", "loc", "lib", "fl", "slot", "sel", "ctx", "pm", "ffff", "Val", "elt", "rt", "f", "part", "value", "j", "t", "reg", "func", "v", "sl", "ind", "alt", "pre", "pos", "len"], "tmp": ["temp", "txt", "obj", "np", "kk", "b", "m", "p", "stuff", "emp", "pt", "c", "app", "test", "data", "Temp", "storage", "rb", "config", "py", "jp", "vt", "cb", "beta", "property", "bp", "proc", "vv", "cmp", "tv", "mp", "buf", "TB", "pb", "nb", "tt", "output", "copy", "ctx", "cp", "sb", "fb", "cache", "ptr", "vm", "tab", "part", "rt", "etc", "tc", "j", "src", "t", "fp", "tp", "v", "attr", "pre", "result"]}}
{"project": "FFmpeg", "commit_id": "6ff0ad6bfd0f00a3d54705811ee91a7ce3c22cda", "target": 0, "func": "static void RENAME(swScale)(SwsContext *c, uint8_t* srcParam[], int srcStrideParam[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dstParam[], int dstStride[]){\n\n\n\n\t/* load a few things into local vars to make the code more readable? and faster */\n\n\tconst int srcW= c->srcW;\n\n\tconst int dstW= c->dstW;\n\n\tconst int dstH= c->dstH;\n\n\tconst int chrDstW= c->chrDstW;\n\n\tconst int lumXInc= c->lumXInc;\n\n\tconst int chrXInc= c->chrXInc;\n\n\tconst int dstFormat= c->dstFormat;\n\n\tconst int flags= c->flags;\n\n\tconst int canMMX2BeUsed= c->canMMX2BeUsed;\n\n\tint16_t *vLumFilterPos= c->vLumFilterPos;\n\n\tint16_t *vChrFilterPos= c->vChrFilterPos;\n\n\tint16_t *hLumFilterPos= c->hLumFilterPos;\n\n\tint16_t *hChrFilterPos= c->hChrFilterPos;\n\n\tint16_t *vLumFilter= c->vLumFilter;\n\n\tint16_t *vChrFilter= c->vChrFilter;\n\n\tint16_t *hLumFilter= c->hLumFilter;\n\n\tint16_t *hChrFilter= c->hChrFilter;\n\n\tint16_t *lumMmxFilter= c->lumMmxFilter;\n\n\tint16_t *chrMmxFilter= c->chrMmxFilter;\n\n\tconst int vLumFilterSize= c->vLumFilterSize;\n\n\tconst int vChrFilterSize= c->vChrFilterSize;\n\n\tconst int hLumFilterSize= c->hLumFilterSize;\n\n\tconst int hChrFilterSize= c->hChrFilterSize;\n\n\tint16_t **lumPixBuf= c->lumPixBuf;\n\n\tint16_t **chrPixBuf= c->chrPixBuf;\n\n\tconst int vLumBufSize= c->vLumBufSize;\n\n\tconst int vChrBufSize= c->vChrBufSize;\n\n\tuint8_t *funnyYCode= c->funnyYCode;\n\n\tuint8_t *funnyUVCode= c->funnyUVCode;\n\n\tuint8_t *formatConvBuffer= c->formatConvBuffer;\n\n\n\n\t/* vars whch will change and which we need to storw back in the context */\n\n\tint dstY= c->dstY;\n\n\tint lumBufIndex= c->lumBufIndex;\n\n\tint chrBufIndex= c->chrBufIndex;\n\n\tint lastInLumBuf= c->lastInLumBuf;\n\n\tint lastInChrBuf= c->lastInChrBuf;\n\n\tint srcStride[3];\n\n\tuint8_t *src[3];\n\n\tuint8_t *dst[3];\n\n\t\n\n\tif((c->srcFormat == IMGFMT_IYUV) || (c->srcFormat == IMGFMT_I420)){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]= srcParam[2];\n\n\t\tsrc[2]= srcParam[1];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]= srcStrideParam[2];\n\n\t\tsrcStride[2]= srcStrideParam[1];\n\n\t}\n\n\telse if(c->srcFormat==IMGFMT_YV12){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]= srcParam[1];\n\n\t\tsrc[2]= srcParam[2];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]= srcStrideParam[1];\n\n\t\tsrcStride[2]= srcStrideParam[2];\n\n\t}\n\n\telse if(isPacked(c->srcFormat)){\n\n\t\tsrc[0]=\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= srcParam[0];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= srcStrideParam[0]<<1;\n\n\t}\n\n\telse if(c->srcFormat==IMGFMT_Y8){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= NULL;\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= 0;\n\n\t}\n\n\n\n\tif((c->dstFormat == IMGFMT_IYUV) || (c->dstFormat == IMGFMT_I420)){\n\n\t\tdst[0]= dstParam[0];\n\n\t\tdst[1]= dstParam[2];\n\n\t\tdst[2]= dstParam[1];\n\n\t\t\n\n\t}else{\n\n\t\tdst[0]= dstParam[0];\n\n\t\tdst[1]= dstParam[1];\n\n\t\tdst[2]= dstParam[2];\n\n\t}\n\n\t\n\n\n\n\tif(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)\n\n\t{\n\n\t\tstatic int firstTime=1; //FIXME move this into the context perhaps\n\n\t\tif(flags & SWS_PRINT_INFO && firstTime)\n\n\t\t{\n\n\t\t\tfprintf(stderr, \"SwScaler: Warning: dstStride is not aligned!\\n\"\n\n\t\t\t\t\t\"SwScaler:          ->cannot do aligned memory acesses anymore\\n\");\n\n\t\t\tfirstTime=0;\n\n\t\t}\n\n\t}\n\n\n\n\t/* Note the user might start scaling the picture in the middle so this will not get executed\n\n\t   this is not really intended but works currently, so ppl might do it */\n\n\tif(srcSliceY ==0){\n\n\t\tlumBufIndex=0;\n\n\t\tchrBufIndex=0;\n\n\t\tdstY=0;\t\n\n\t\tlastInLumBuf= -1;\n\n\t\tlastInChrBuf= -1;\n\n\t}\n\n\n\n\tfor(;dstY < dstH; dstY++){\n\n\t\tunsigned char *dest =dst[0]+dstStride[0]*dstY;\n\n\t\tunsigned char *uDest=dst[1]+dstStride[1]*(dstY>>1);\n\n\t\tunsigned char *vDest=dst[2]+dstStride[2]*(dstY>>1);\n\n\t\tconst int chrDstY= isHalfChrV(dstFormat) ? (dstY>>1) : dstY;\n\n\n\n\t\tconst int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input\n\n\t\tconst int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input\n\n\t\tconst int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input\n\n\t\tconst int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input\n\n\n\n\t\t//handle holes (FAST_BILINEAR & weird filters)\n\n\t\tif(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;\n\n\t\tif(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;\n\n//printf(\"%d %d %d\\n\", firstChrSrcY, lastInChrBuf, vChrBufSize);\n\n\t\tASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)\n\n\t\tASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)\n\n\n\n\t\t// Do we have enough lines in this slice to output the dstY line\n\n\t\tif(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < ((srcSliceY + srcSliceH)>>1))\n\n\t\t{\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf < lastLumSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n//\t\t\t\tprintf(\"%d %d %d %d\\n\", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n//\t\t\t\tprintf(\"%d %d\\n\", lumBufIndex, vLumBufSize);\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf < lastChrSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)\n\n\t\t\t\t//FIXME replace parameters through context struct (some at least)\n\n\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t}\n\n\t\telse // not enough lines left in this slice -> load the rest in the buffer\n\n\t\t{\n\n/*\t\tprintf(\"%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\\n\",\n\n\t\t\tfirstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,\n\n\t\t\tlastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,\n\n\t\t\tvChrBufSize, vLumBufSize);\n\n*/\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf+1 < srcSliceY + srcSliceH)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf+1 < ((srcSliceY + srcSliceH)>>1))\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)\n\n\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t\tbreak; //we cant output a dstY line so lets try with the next slice\n\n\t\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t\tb5Dither= dither8[dstY&1];\n\n\t\tg6Dither= dither4[dstY&1];\n\n\t\tg5Dither= dither8[dstY&1];\n\n\t\tr5Dither= dither8[(dstY+1)&1];\n\n#endif\n\n\t    if(dstY < dstH-2)\n\n\t    {\n\n\t\tif(isPlanarYUV(dstFormat)) //YV12 like\n\n\t\t{\n\n\t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t *lumBuf = lumPixBuf[0];\n\n\t\t\t\tint16_t *chrBuf= chrPixBuf[0];\n\n\t\t\t\tRENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW);\n\n\t\t\t}\n\n\t\t\telse //General YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\t\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\t\t\tRENAME(yuv2yuvX)(\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, uDest, vDest, dstW,\n\n\t\t\t\t\tlumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+(dstY>>1)*vChrFilterSize*4);\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB\n\n\t\t\t{\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\n\n\t\t\t\tRENAME(yuv2rgb1)(*lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, chrAlpha, dstFormat, flags);\n\n\t\t\t}\n\n\t\t\telse if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB\n\n\t\t\t{\n\n\t\t\t\tint lumAlpha= vLumFilter[2*dstY+1];\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\n\n\t\t\t\tRENAME(yuv2rgb2)(*lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, lumAlpha, chrAlpha, dstFormat, flags);\n\n\t\t\t}\n\n\t\t\telse //General RGB\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2rgbX)(\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, dstW, dstFormat,\n\n\t\t\t\t\tlumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+dstY*vChrFilterSize*4);\n\n\t\t\t}\n\n\t\t}\n\n            }\n\n\t    else // hmm looks like we cant use MMX here without overwriting this arrays tail\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\tif(isPlanarYUV(dstFormat)) //YV12\n\n\t\t{\n\n\t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2yuvXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, vDest, dstW);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tyuv2rgbXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, dstW, dstFormat);\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n\t/* store changed local vars back in the context */\n\n\tc->dstY= dstY;\n\n\tc->lumBufIndex= lumBufIndex;\n\n\tc->chrBufIndex= chrBufIndex;\n\n\tc->lastInLumBuf= lastInLumBuf;\n\n\tc->lastInChrBuf= lastInChrBuf;\n\n}\n", "idx": 20022, "substitutes": {"c": ["dc", "pc", "ic", "spec", "m", "ch", "t", "conf", "f", "vc", "ct", "rc", "center", "n", "cm", "cf", "g", "i", "coll", "cb", "cp", "bc", "ctx", "mc", "ctrl", "o", "ca", "enc", "cs", "l", "d", "rec", "cont", "ce", "nc", "ac", "ci", "com", "con", "xc", "tc", "config", "e", "cu", "sc", "k", "client", "cr", "lc", "cur", "v", "p", "uc", "cache", "col", "cit", "ec", "cn", "co", "C", "y", "cc", "u"], "srcParam": ["rcParam", "srcMem", " srcPart", "rcMem", " srcPar", " srcMem", "selMem", "srcPart", "selParam", "rcPart", "selPar", "selPart", "srcPar", "rcPar"], "srcStrideParam": ["srcStripNum", "srcRestrideParam", "srcStridePar", "srcRestridePar", "srcStriteNum", "srcStritePar", "srcStrParam", "srcRestripPar", "srcStrideNum", "srcStripPar", "srcRestrideNum", "srcStrideMin", "srcStriteMin", "srcRestripNum", "srcStrPar", "srcStrNum", "srcStripMin", "srcStriteParam", "srcRestripParam", "srcStripParam", "srcRestripMin", "srcRestrideMin", "srcStrMin"], "srcSliceY": ["srcFliceW", "srcSlueW", "srcSlangeW", "srcSlicey", "srcFliceY", "srcSluey", "srcFlueY", "srcSlueYY", "srcFlueYY", "srcFliceYY", "srcFlueW", "srcSlineY", "srcSlueY", "srcSliceYY", "srcSlangey", "srcSlineW", "srcSlineYY", "srcSlangeYY", "srcSlangeY", "srcFluey", "srcSliney", "srcFlicey", "srcSliceW"], "srcSliceH": ["srcSlaceG", "srcSlaceY", "srcSlueW", "srcSlashH", "srcPliceH", "srcPliceY", "srcPliceW", "srcSlueY", "srcSlashW", "srcSlashG", "srcSlaceW", "srcSlaceH", "srcPliceG", "srcPlaceH", "srcPlaceG", "srcSlueG", "srcPlaceY", "srcSlueH", "srcSliceG", "srcPlaceW", "srcSlashY", "srcSliceW"], "dstParam": ["DndPar", "DstParameter", "drdPar", "dstParameter", "DstMem", "dstMem", "DndParameter", "DndParam", "dndParam", "dndPar", "drdParameter", "dSTPar", "DstPar", "dSTMem", "drdMem", "DstParam", "dndParameter", "dSTParam", "dstPar", "DndMem", "drdParam", "dndMem", "dSTParameter"], "dstStride": ["dscDestructure", "dstStide", "dscStructure", "dscDestOverride", "dscStide", "dstStructure", "dscStOverride", "dscDestride", "dstStOverride", "dstSTOverride", "dstSTide", "dscStride", "dscDestide", "dststructure", "dststride", "dststOverride", "dstDestide", "dstDestructure", "dstSTride", "dststide", "dstDestOverride", "dstSTructure", "dstDestride"], "vLumFilterPos": ["vLumLimitMin", "vLUMNumberPos", "vLumControlLoc", "vLumFPos", "vLumFilterLen", "vLumFeaturePos", "vLumLimitLoc", "vLUMNumberLoc", "vLUMNumberPOS", "vLUMFilterPOS", "vLumNumberPosition", "vLUMNumberPosition", "vLumControlPos", "vLumFilterLoc", "vLumFeatureMin", "vLumFilterPosition", "vLumFLoc", "vLumLimitLen", "vLumFPosition", "vLumFeatureLen", "vLumFilterMin", "vLUMMaskLoc", "vLUMFilterLoc", "vLumControlPOS", "vLumNumberPOS", "vLumFPOS", "vLUMMaskMin", "vLumNumberLoc", "vLumFeatureLoc", "vLUMFilterMin", "vLUMFilterLen", "vLumControlPosition", "vLumLimitPos", "vLUMFilterPosition", "vLumMaskLen", "vLumFilterPOS", "vLumNumberPos", "vLUMMaskPos", "vLumMaskPos", "vLumMaskMin", "vLUMMaskLen", "vLUMFilterPos", "vLumMaskLoc"], "vChrFilterPos": ["vCharFilterDir", "vCharFilterPOS", "vChrRulePOS", "vChrFilterDir", "vChrNumberPOS", "vChrNumberPos", "vCharUserpos", "vChrFilterPOS", "vChrNumberDir", "vChrFPos", "vChruFactorRes", "vChruFactorPosition", "vChrUserDir", "vChrUserPOS", "vChruFilterPer", "vChrFilterpos", "vChrFactorPos", "vChrFPer", "vChrUserpos", "vChruFilterRes", "vCharUserPOS", "vChruFilterPosition", "vCharUserPos", "vChruFactorPos", "vChrListenerRes", "vCharFilterpos", "vChrListenerPos", "vChrFactorPer", "vChrUserPos", "vChrRulePos", "vChrFRes", "vChrFPosition", "vChrFilterPer", "vChrFactorRes", "vChrFilterRes", "vChrListenerPer", "vChruFactorPer", "vChrRulepos", "vCharUserDir", "vChrFilterPosition", "vChrFactorPosition", "vCharFilterPos", "vChrRuleDir", "vChrNumberpos", "vChrListenerPosition", "vChruFilterPos"], "hLumFilterPos": ["hLumaHeaderPosition", "hLumValueSize", "hLumControlpos", "hLumFilePos", "hLumFileTrans", "hLumValueTrans", "hLumHeaderTrans", "hLumFilepos", "hLumaHeaderPos", "hLumGrouppos", "hLumaHeaderTrans", "hLumGroupPos", "hLumGroupStart", "hLumerGroupPos", "hLumHeaderSize", "hLumaFilterSize", "hLumHeaderPosition", "hLumFileSize", "hLumerGroupPosition", "hLumFilterTrans", "hLumerFilterStart", "hLumerGrouppos", "hLumerFilterPos", "hLumaFilterPosition", "hLumerFilterpos", "hLumValuePosition", "hLumControlPos", "hLumaFilterTrans", "hLumControlPosition", "hLumaHeaderSize", "hLumFilePosition", "hLumFileStart", "hLumGroupPosition", "hLumerFilterPosition", "hLumHeaderPos", "hLumerGroupStart", "hLumControlStart", "hLumFilterStart", "hLumaFilterPos", "hLumValuePos", "hLumFilterSize", "hLumFilterpos", "hLumFilterPosition"], "hChrFilterPos": ["hChrControlPos", "hChrHandlerLoc", "hChrHandlerPos", "hChrMasterPos", "hChrSearchPo", "hChrFilterLoc", "hChrHandlerPo", "hChmLimitOff", "hChrLimitEx", "hChrFilterNeg", "hChrSearchPos", "hChrControlEx", "hChmFilterPo", "hChrLimitOff", "hChrFilterEx", "hChrbSearchLoc", "hChrSearchNeg", "hChrMasterNeg", "hChrbSearchNeg", "hChmLimitPo", "hChrbFilterNeg", "hChrLimitPo", "hChrbFilterPos", "hChrbSearchPo", "hChrbFilterLoc", "hChmLimitEx", "hChmFilterPos", "hChrbSearchPos", "hChrbFilterPo", "hChrLimitPos", "hChrFilterPo", "hChrMasterPo", "hChrMasterLoc", "hChmLimitPos", "hChrManagerEx", "hChrManagerPo", "hChrFilterOff", "hChmFilterOff", "hChrManagerOff", "hChrControlPo", "hChmFilterEx", "hChrManagerPos", "hChrSearchLoc", "hChrHandlerNeg", "hChrControlOff"], "vLumFilter": ["vPlumbLevel", "vBlumFlow", "vLumeLimit", "vLumLimit", "vLumGroup", "vLrumFlow", "vBlumbLimit", "vLumbFlow", "vLumerLevel", "vLmpFilter", "vLumbSort", "vLumeGroup", "vLumbControl", "vLumerControl", "vLrumGroup", "vBlumGroup", "vLumFlow", "vPlumFilter", "vBlumbGroup", "vLumbLevel", "vPlumbControl", "vPlumbFilter", "vLmpControl", "vLumbFilter", "vLumLevel", "vLumerSort", "vLumbLimit", "vPlumbSort", "vLumbGroup", "vLmpLevel", "vLumeFlow", "vBlumFilter", "vLumSort", "vBlumbFlow", "vLrumLimit", "vLumeFilter", "vLrumFilter", "vPlumSort", "vPlumControl", "vLmpSort", "vLumerFilter", "vBlumLimit", "vLumControl", "vBlumbFilter", "vPlumLevel"], "vChrFilter": ["vCHrLayer", "vChrFile", "vchrLimit", "vCHrFilter", "vChrbLayer", "vChlLimit", "vchrcFilter", "vCHrcLayer", "vChrtControl", "vChrtFilter", "vChrLimit", "vChrbLimit", "vChrcControl", "vChlFilter", "vChlMask", "vCHrcFile", "vChrLayer", "vChrcLimit", "vChrtLimit", "vChrbFile", "vChrMask", "vChrcLayer", "vchrFilter", "vchrcMask", "vChrControl", "vChbLayer", "vchrControl", "vCHrLimit", "vChbFilter", "vCHrcFilter", "vChrcFilter", "vCHrcLimit", "vChrcMask", "vChlControl", "vChrbFilter", "vChrtMask", "vCHrFile", "vchrcControl", "vChbLimit", "vChbFile", "vChrcFile", "vchrcLimit", "vchrMask"], "hLumFilter": ["hElumbPath", "hElumFilter", "hElumPath", "hLumRule", "hElumbFilter", "hLulRule", "hLumaControl", "hElumSort", "hLmFilter", "hLumaSort", "hLummerControl", "hLummerFilter", "hLuncFilter", "hLumbSort", "hLumFlow", "hLuncFlow", "hLuncSort", "hSlumFlow", "hSlumSort", "hLumControl", "hLumaFilter", "hSlulRule", "hLulSort", "hElumControl", "hLmFlow", "hLulFilter", "hLumbFilter", "hLumSort", "hLumaPath", "hSlulFlow", "hLmSort", "hSlulFilter", "hSlumFilter", "hSlulSort", "hLumbPath", "hLmRule", "hLuncRule", "hLummerPath", "hLumPath", "hElumbControl", "hLumbControl", "hElumbSort", "hLulFlow", "hSlumRule", "hLummerSort"], "hChrFilter": ["hChpFactor", "hChrLimit", "hColrRule", "hChrgHandler", "hChruHandler", "hCharSort", "hChmSort", "hPhrLimit", "hChrcFilter", "hColrFilter", "hChrcLimit", "hChruFilter", "hChrHandler", "hChrcSort", "hColrHandler", "hColrgFilter", "hChrFactor", "hCharFilter", "hChrgFilter", "hChrgRule", "hChruRule", "hPhrcFilter", "hPhrcFactor", "hChmLimit", "hPhrSort", "hColrgHandler", "hChrRule", "hChrgSort", "hPhrcSort", "hPhrFilter", "hPhrcLimit", "hChmFactor", "hChrSort", "hChpLimit", "hChruSort", "hColrgRule", "hColrgSort", "hChmFilter", "hPhrFactor", "hColrSort", "hCharHandler", "hChrcFactor", "hChpFilter", "hCharRule", "hChpSort"], "lumMmxFilter": ["lumMmxSort", "lumMmxConfig", "lumMpxLimit", "lumMwmMask", "lumMwmLimit", "lumMaxSort", "lumMaxConfig", "lumMxSort", "lumMxConfig", "lumRmxConfig", "lumRmxLimit", "lumMwmFilter", "lumMuxMask", "lumMxFilter", "lumMuxFilter", "lumMappingLimit", "lumRmxFilter", "lumMuxLimit", "lumMappingMask", "lumMaxLimit", "lumMpxFilter", "lumMpxConfig", "lumRmxSort", "lumMappingFilter", "lumMmxLimit", "lumMmxMask", "lumRaxConfig", "lumRaxFilter", "lumMuxFile", "lumMxLimit", "lumMappingFile", "lumMpxSort", "lumMwmFile", "lumRaxLimit", "lumMmxFile", "lumMaxFilter", "lumRaxSort"], "chrMmxFilter": ["chrMappedControl", "chrLpxFilter", "chrMmxFi", "chrMiasRule", "chrMpxFi", "chrMuxSort", "chrVmxFilter", "chrMMXLimit", "chrMuxRule", "chrMexControl", "chrMexFilter", "chrMiasSort", "chrViasFilter", "chrVmxSort", "chrLmxLimit", "chrMuxControl", "chrMMXFi", "chrVmxControl", "chrMpxFilter", "chrMappedLimit", "chrMmxControl", "chrViasSort", "chrViasRule", "chrMMXFilter", "chrLmxControl", "chrMappedFilter", "chrMuxFilter", "chrMexRule", "chrLpxLimit", "chrMpxControl", "chrMmxLimit", "chrLpxFi", "chrMmxSort", "chrViasControl", "chrMiasFilter", "chrVmxRule", "chrLpxControl", "chrLmxFi", "chrMappedFi", "chrLmxFilter", "chrMiasControl", "chrMexSort", "chrMMXControl", "chrMpxLimit", "chrMmxRule"], "lumPixBuf": ["lumPixFaf", "lumPxCuff", "lumPixBoff", "lumPixFluff", "lumPxCuf", "lumPixCiff", "lumPexAmp", "lumPixFmp", "lumPixAuf", "lumPxCoff", "lumPexBuf", "lumPxCiff", "lumPixLuff", "lumPixCuff", "lumPixLmp", "lumPexAuff", "lumPixLuf", "lumPexBuff", "lumPixBaf", "lumPexBmp", "lumPxBuf", "lumPexBaf", "lumPixFluf", "lumPixBiff", "lumPexAuf", "lumPixCoff", "lumPixLiff", "lumPixBuff", "lumPxBuff", "lumPxBoff", "lumPixLaf", "lumPixFliff", "lumPixFuff", "lumPixLoff", "lumPixAaf", "lumPixFuf", "lumPixFloff", "lumPixBmp", "lumPixAuff", "lumPixCuf", "lumPixAmp", "lumPexAaf", "lumPxBiff"], "chrPixBuf": ["chrPxAaf", "chrPxBoff", "chrPxBuff", "chrPixFaf", "chrPixFoff", "chrPixCuf", "chrPxAoff", "chrPiusBuf", "chrPiusBundle", "chrPixPuf", "chrPixBab", "chrPxAuf", "chrPixFuf", "chrPixPab", "chrPiusMump", "chrPiusMundle", "chrPixFuff", "chrPixLump", "chrPiusMab", "chrPixPump", "chrPixMump", "chrPxAuff", "chrPixBoff", "chrPixAaf", "chrPixMab", "chrPxBuf", "chrPixLab", "chrPixCaf", "chrPixAuf", "chrPixLuf", "chrPixBundle", "chrPixAoff", "chrPixBump", "chrPixBaf", "chrPixMuf", "chrPixBuff", "chrPiusMuf", "chrPixCuff", "chrPixLundle", "chrPixMundle", "chrPiusBab", "chrPiusBump", "chrPixPundle", "chrPixAuff", "chrPixCoff", "chrPxBaf"]}}
{"project": "FFmpeg", "commit_id": "f907615f0813e8499f06a7eebccf1c63fce87c8e", "target": 1, "func": "static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n\n\n    pc->enc = av_mallocz(sizeof(MpegEncContext));\n\n    if (!pc->enc)\n\n        return -1;\n\n    pc->first_picture = 1;\n\n\n    return 0;\n\n}", "idx": 14362, "substitutes": {"s": ["sys", "ses", "self", "m", "as", "sg", "fs", "rs", "cs", "hs", "si", "js", "sq", "v", "ps", "ss", "ms", "p", "e", "sb", "sf", "gs", "c", "parser", "xs", "sac", "sc", "sv", "services", "ds", "sa", "soc", "ls", "ks"], "pc": ["mc", "cam", "bc", "amp", "uc", "ca", "enc", "rc", "cc", "pac", "cz", "lc", "PC", "cs", "auc", "lp", "cms", "px", "cr", "pd", "oc", "p", "pb", "nc", "pa", "tc", "cus", "co", "ck", "gb", "arc", "c", "pm", "cca", "FC", "cu", "dc", "ac", "anc", "sc", "cp", "vc", "sa", "xc", "ec", "fc", "pic", "ctx"]}}
{"project": "FFmpeg", "commit_id": "1bfb4587a2e5b25ed15f742149e555efc8f305ae", "target": 1, "func": "static void test_function(const TestStruct test_sample)\n\n{\n\n    int ret, i;\n\n    void **output_data  = NULL;\n\n    AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,\n\n                                            test_sample.nb_samples_pch);\n\n    if (!afifo) {\n\n        ERROR(\"ERROR: av_audio_fifo_alloc returned NULL!\");\n\n    }\n\n    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_write failed!\");\n\n    }\n\n    printf(\"written: %d\\n\", ret);\n\n\n\n    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_write failed!\");\n\n    }\n\n    printf(\"written: %d\\n\", ret);\n\n    printf(\"remaining samples in audio_fifo: %d\\n\\n\", av_audio_fifo_size(afifo));\n\n\n\n    ret = read_samples_from_audio_fifo(afifo, &output_data, test_sample.nb_samples_pch);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_read failed!\");\n\n    }\n\n    printf(\"read: %d\\n\", ret);\n\n    print_audio_bytes(&test_sample, output_data, ret);\n\n    printf(\"remaining samples in audio_fifo: %d\\n\\n\", av_audio_fifo_size(afifo));\n\n\n\n    /* test av_audio_fifo_peek */\n\n    ret = av_audio_fifo_peek(afifo, output_data, afifo->nb_samples);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_peek failed!\");\n\n    }\n\n    printf(\"peek:\\n\");\n\n    print_audio_bytes(&test_sample, output_data, ret);\n\n    printf(\"\\n\");\n\n\n\n    /* test av_audio_fifo_peek_at */\n\n    printf(\"peek_at:\\n\");\n\n    for (i = 0; i < afifo->nb_samples; ++i){\n\n        ret = av_audio_fifo_peek_at(afifo, output_data, 1, i);\n\n        if (ret < 0){\n\n            ERROR(\"ERROR: av_audio_fifo_peek_at failed!\");\n\n        }\n\n        printf(\"%d:\\n\", i);\n\n        print_audio_bytes(&test_sample, output_data, ret);\n\n    }\n\n    printf(\"\\n\");\n\n\n\n    /* test av_audio_fifo_drain */\n\n    ret = av_audio_fifo_drain(afifo, afifo->nb_samples);\n\n    if (ret < 0){\n\n        ERROR(\"ERROR: av_audio_fifo_drain failed!\");\n\n    }\n\n    if (afifo->nb_samples){\n\n        ERROR(\"drain failed to flush all samples in audio_fifo!\");\n\n    }\n\n\n\n    /* deallocate */\n\n    for (i = 0; i < afifo->nb_buffers; ++i){\n\n        av_freep(&output_data[i]);\n\n    }\n\n    av_freep(&output_data);\n\n    av_audio_fifo_free(afifo);\n\n}\n", "idx": 24655, "substitutes": {"test_sample": ["testnsample", "writelsample", "testedsound", "test_case", "check_sample", "test_resource", "testedsample", "sampleableSample", " test_test", "savedsound", "testdcase", "testgshape", " test_scale", "testknode", "testablestring", "test_sequence", "test00ample", "testgsample", "txtkstage", "txt_stage", "testdexample", "seedvalpackage", "testndatabase", "test_group", "stageingsample", "stage_instance", "test_example", "testnample", "writelservice", " test_shape", "testedexample", "write_service", "testedcase", "check_database", "testabledata", "seed_package", "testdsound", "liveedsample", "testingsample", "test_instance", "testappsample", "liveedproject", "testvalgold", "txtknode", "sample_package", "testerspace", "test_stage", "save_sound", "test_project", "testmfolder", "sampleableslice", "txt_node", "testablecell", "stageinginstance", "testappinstance", "testvalresource", "testlsample", " test_component", "test_shape", "testureresource", "check00ample", "train_component", "test2instance", "testgtest", "test_space", "test_slice", "stage_group", "write_model", "testkstage", "test_cell", "testablegroup", "testuresample", "testappgroup", "testedproject", "testercomponent", "live_sample", "stageinggroup", " test_space", "test_test", "writelfolder", "testablestage", "write_sample", "test_model", "test_service", "check_phase", "testnphase", "testmservice", " test_group", "test_Sample", "testurepackage", "writelmodel", "test_data", "testfexample", "testedname", "testvalpackage", "testableSample", "test_node", "sample_slice", "txt_group", "liveedsequence", "testingscale", "testablegold", "testlfolder", "train_model", "test_component", "test00database", "test2example", "test_folder", "testablenode", "test_name", "sampleablesample", "testkgroup", "check00database", "sample_cell", "testfsample", "savedexample", "testvalsample", "testingexample", "testappexample", "testmsample", "test_string", "liveedname", "txtksample", "testlservice", "train_sample", "test00sample", "test_ample", "sample_string", "savedsample", "test_sound", "testersample", "test_database", "testedsequence", "test_phase", "txt_sample", "testlmodel", "testableslice", "test2group", "testuregold", "stage_sample", "train_phase", "test_scale", "seedvalsample", "save_sample", "sample_data", "testingcomponent", "save_case", "testdsample", "save_example", "test00phase", "live_sequence", "check00sample", "testerscale", "live_project", "testfcase", "test_package", "live_name", "seedvalresource", "txtkgroup", "seed_sample", "seed_resource", "testingspace", "testinggroup", "sample_Sample", "testggroup", "testmmodel", "testinginstance", "testfsound", "savedcase", "stageingexample", "test_gold", "check00phase", "testablesample", "testksample", "stage_example", "seedvalgold", "sampleablepackage", "check_ample", "seed_gold", "testableresource", "write_folder", "sample_sample", "testablepackage", "test2sample"], "ret": ["ref", "sr", "ft", "cat", "rf", "detail", "base", "att", "ct", "url", "mem", "arr", "valid", "mt", "det", "lit", "nt", "pet", "part", "reset", "f", "match", "r", "val", "gt", "code", "obj", "flag", "en", "def", "rep", "xt", "store", "pret", "key", "sur", "bit", "RET", "group", "let", "feat", "pat", "Ret", "len", "fun", "res", "usr", "data", "back", "rb", "success", "error", "all", "db", "al", "str", "get", "err", "re", "reply", "arg", "alt", "reg", "full", "post", "info", " RET", "cur", "br", "bf", "opt", " Ret", "pass", "id", "rets", "rl", "rev", "fit", "art", "html", "active", "rt", "ext", "result", "format"], "i": ["ref", "rest", "slice", "k", "ie", "p", "info", "yi", "b", "c", "ix", "x", "ami", "ti", "mi", "phi", "qi", "it", "end", "ri", "id", "rep", "io", "u", "key", "li", "rel", "gi", "o", "err", "multi", "bit", "xi", "uri", "ii", "ini", "si", "bi", "di", "ni", "ai", "ci", "eni", "I", "y", "mini", "f", "j", "index", "ip", "ori", "t", "init", "ind", "iu", "pi", "mu", "in", "ui", "l", "hi", "len", "val", "g"], "output_data": ["input_done", "output2size", "outputPlist", "outputingdata", "outputsdata", "output_results", "bytePlist", "output2format", "input_dat", "output_list", "outputeddata", "byte_list", "output_default", "outputingsize", "output_space", "byte_length", "outputPdat", "outputingdone", "response_bytes", "doublesdata", "outputPlen", "byte_len", "application_space", " output_format", "outputeddefault", "double_data", "response_space", "response_data", "input_bytes", "output_body", "application_data", "outputedvalid", "outputingdat", "input_default", "output_done", "outputingformat", "outputPbytes", "outputalldata", "outputsbytes", "outputallvalid", "output_format", "outputPdone", "application_buffer", "outputPbody", "outputPspace", "output_size", "outputPdata", "output_length", "application_alpha", "bytePdata", "output_bytes", "doublesresults", "output_buffer", "outputsresults", "outputingbody", "byte_data", " output_size", "outputedbytes", "outputallbytes", "output_len", "output_valid", "response_dat", "bytePlength", "double_results", "bytePlen", "output_dat", "input_valid", "input_body", "doublesbytes", "output_alpha", "outputalldefault", "input_data", "output2data", "double_bytes", "outputPlength"], "afifo": ["afiffoin", "afihos", "afigoo", "afiffo", "aflifano", "aftifoo", "affifn", "afefo", "failo", "afiferano", "afilos", "affn", "afifol", "affifio", "aff\n", "afiferiso", "afiano", "avifano", "affipoo", "alifo", "afifi", "affifoa", "afiloa", "afifio", "afiffiso", "affiffo", "afild", "atifi", "afiolo", "afiplo", "avifi", "afifn", "afihno", "afinfbo", "affiffos", "afefos", "afiffos", "afipoo", "afofoo", "afiffio", "afippano", "avifiso", "afinfol", "afiffoo", "afiftode", "affifo", "afefi", "affifoo", "aftifno", "alifbo", "afispol", "aviferiso", "avinfiso", "afipode", "afianio", "failoa", "afinfdo", "avinfo", "afafo", "alifoi", "afianoin", "affi", "afihoa", "faifo", "afispoi", "affiffi", "atifoa", "afiffdo", "faifoo", "af\n", "afofdo", "afefio", "afofo", "affio", "afiplos", "aliolo", "aftifi", "aphefo", "afofio", "afefone", "aviferano", "aphifos", "aflifiso", "afifoi", "afafos", "afifdo", "afifano", "aftifo", "avinfdo", "affiffoa", "aftifoa", "afafi", "aftifode", "afipo", "affiffone", "afipno", "afifto", "aifo", "alioloi", "afinfo", "afiferoff", "ab\n", "afifoo", "affifode", "afipli", "aifoa", "aviploff", "afinfoo", "afigoa", "aifone", "afifone", "aliolol", "aifi", "afioloi", "afifno", "aftifone", "aviplos", " af\n", "afifoin", "aviplo", "afiffone", "afilno", "afigd", "afianos", "avifero", "affiffio", "affifno", "afefoin", "affipode", "atifone", "avifos", "afilo", "afiloff", "afifode", "afiffd", "afiolol", "affifi", "afofn", "afifos", "afifiso", "affifone", "faifoa", "avifo", "avifdo", "avifoff", "affipo", "afippoff", "aflifo", "afiploa", "afippiso", "afiffn", "affipno", "atifo", "afifero", "afifbo", "afiffoa", "affo", "afispo", "aphefio", "faifd", "afigo", "aphefos", "aphifoin", "afifoa", "affifos", "afiffi", "alifol", "afiffno", "avifoo", "avipli", "aliolbo", "aphefoin", "afiploff", "afiftoo", "afiolbo", "afiloo", "afinfoi", "afili", "afafone", "afinfiso", "failoo", "afiftno", "faild", "aphifio", "afefoa", "afiplone", "aphifo", "affiffno", "affiffn", "avinfoo", "aviferoff", "afippo", "afispbo", "afofi", "afofiso", "afifoff", "afiho", "afifd", "aflifoff"]}}
{"project": "qemu", "commit_id": "665414ad06aa1bc92e615db9641e58fb13d07de1", "target": 1, "func": "static int ram_block_enable_notify(const char *block_name, void *host_addr,\n\n                                   ram_addr_t offset, ram_addr_t length,\n\n                                   void *opaque)\n\n{\n\n    MigrationIncomingState *mis = opaque;\n\n    struct uffdio_register reg_struct;\n\n\n\n    reg_struct.range.start = (uintptr_t)host_addr;\n\n    reg_struct.range.len = length;\n\n    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;\n\n\n\n    /* Now tell our userfault_fd that it's responsible for this area */\n\n    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {\n\n        error_report(\"%s userfault register: %s\", __func__, strerror(errno));\n\n\n\n\n\n\n\n\n\n    return 0;\n", "idx": 24771, "substitutes": {"block_name": ["blockfprefix", " block_address", "block_prefix", "blockfaddress", " block_size", "blockfsize", " block_prefix", "blockfname", "block_address", "block_size"], "host_addr": ["hostacoffset", "block_addr", "hostacaddress", "hostacaddr", "block_id", "hostacsize", "block_offset", "host_size", "host_address", "host_name", "host_id", "block_address", "hostbname", "block_size", "hostbaddress", "hostbaddr", "hostbid", "host_offset"], "offset": ["ref", "slice", "position", "data", "base", "style", "align", "pointer", "address", "prefix", "Offset", "error", "end", "start", "set", "loc", "parent", "order", "off", "origin", "addr", "entry", "limit", "index", "range", "pos", "len"], "length": ["build", "seq", "ength", "slice", "family", "section", "info", "position", "mount", "base", "style", "read", "delay", "filename", "address", "type", "duration", "port", "pad", "url", "depth", "line", "padding", "angle", "library", "sequence", "view", "shape", "level", "block", "Length", "count", "limit", "pull", "index", "match", "range", "l", "len"], "opaque": [" oprobe", "opprobe", "ospatile", " opaques", "opaques", "opatile", "opcos", "ospaque", "opusatile", " opatile", "opusmac", "opusaque", "ospcos", " opmac", "Opaque", " opcos", "Opaques", "oppaques", "ospmac", "opuscos", "oppaque", "opmac", "Opatile", "Oprobe", "oprobe", "oppatile"], "mis": ["abi", "sys", "oci", "iss", "scope", "oc", "m", "tis", "isi", "cci", "ms", "vis", "mi", "Mis", "bos", "mac", "rec", "mos", "is", "mes", "proc", "mic", "miss", "session", "mn", "os", "fi", "mc", "mas", "cas", "fs", "pas", "osi", "acs", "voc", "pc", "params"], "reg_struct": ["reg2const", "regacint", "mod_return", "mod_feat", "Reg_feat", " reg_addr", "reg_addr", "regacnat", " reg_string", "Reg_int", "reg_int", "reg2struct", "rec_config", "rec_struct", "mod_struct", " reg_nat", "Reg_nat", "reg_feat", "rec_const", "reg_config", "reg_string", " reg_feat", "rec_construct", "reg_Struct", "reg2config", "regacstruct", "regacfeat", "reg_const", "Reg_struct", "reg_return", "reg_ptr", "reg_construct", " reg_ptr", "mod_config", "reg_nat", "reg2construct", " reg_Struct"]}}
{"project": "FFmpeg", "commit_id": "bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29", "target": 1, "func": "void show_help(void)\n\n{\n\n    const char *prog;\n\n    const OptionDef *po;\n\n    int i, expert;\n\n    \n\n    prog = do_play ? \"ffplay\" : \"ffmpeg\";\n\n\n\n    printf(\"%s version \" FFMPEG_VERSION \", Copyright (c) 2000, 2001, 2002 Gerard Lantau\\n\", \n\n           prog);\n\n    \n\n    if (!do_play) {\n\n        printf(\"usage: ffmpeg [[options] -i input_file]... {[options] outfile}...\\n\"\n\n               \"Hyper fast MPEG1/MPEG4/H263/RV and AC3/MPEG audio encoder\\n\");\n\n    } else {\n\n        printf(\"usage: ffplay [options] input_file...\\n\"\n\n               \"Simple audio player\\n\");\n\n    }\n\n           \n\n    printf(\"\\n\"\n\n           \"Main options are:\\n\");\n\n    for(i=0;i<2;i++) {\n\n        if (i == 1)\n\n            printf(\"\\nAdvanced options are:\\n\");\n\n        for(po = options; po->name != NULL; po++) {\n\n            char buf[64];\n\n            expert = (po->flags & OPT_EXPERT) != 0;\n\n            if (expert == i) {\n\n                strcpy(buf, po->name);\n\n                if (po->flags & HAS_ARG) {\n\n                    strcat(buf, \" \");\n\n                    strcat(buf, po->argname);\n\n                }\n\n                printf(\"-%-17s  %s\\n\", buf, po->help);\n\n            }\n\n        }\n\n    }\n\n\n\n    exit(1);\n\n}\n", "idx": 21050, "substitutes": {"prog": ["proge", "Progs", "pregs", "Progn", "rougs", "Prog", "prob", "progn", "prb", "prgg", " proge", " prob", "rouG", "proG", "pregn", "progs", "ProG", "puge", "proga", " progs", "preG", " proG", "prega", "prge", " progg", "Proga", "rouga", "progg", "prg", "pug", "pugg", "preg", "roug", " progn", "pub"], "po": ["Ko", "ee", "obj", "oo", "oe", "jp", "pe", "ao", "oa", "apo", "pd", "Po", "pc", "so", "no", "yo", "elo", "pos", "pg", "op", "pre", "wo", "mo", "obo", "da", "pp", "gro", "p", "zone", "o", "py", "lo", "pr", "la", "pro", "aco", "cho", "bo", "vo", "flo", "va", "PO", "aa", "co", "ps", "ote", "ko", "li", "odo", "jo", "pi", "ppa", "poke", "pa", "ppo"], "i": ["io", "lc", "e", "ix", "ie", "fi", "qi", "ri", "ind", "ui", "part", "gi", "d", "uri", "ti", "I", "l", "f", "hei", "ci", "split", "r", "oi", "ini", "u", "it", "j", "phi", "p", "ip", "id", "o", "bi", "ori", "cli", "mi", "c", "index", "si", "a", "ii", "in", "b", "n", "iu", "slice", "ai", "xi", "hi", "di", "yi", "multi", "v", "li", "z", "api", "pi", "x", "zi", "ni", "type"], "expert": ["comret", "expr", "invert", "pretern", "intervert", "inert", "expconfig", "xert", "interert", "exlr", "prepert", "Exvert", "comtern", "Exert", "exert", "exvert", " exret", "explr", "xlr", "inpert", "interpr", "Expr", "preper", "compert", "Exconfig", "exret", "preret", "exppert", "inpr", "exconfig", "comper", " exper", "xpert", "xconfig", "Expert", "exper", "Exlr", "interpert"], "buf": ["begin", "bc", "str", "uf", "binary", "uc", "brace", "nat", "ba", "fab", "board", "ha", "cv", "fb", "queue", "utf", "Buff", "img", "home", "fp", "cas", "buffer", "path", "xff", "alloc", "cmd", "box", "cat", "cf", " buffer", "wb", "font", "rc", "cb", "ctx", "la", "b", "seq", "auc", "desc", "fd", "src", "fw", "bd", "br", "append", "Buffer", "aka", "buff", "proc", "bh", "bag", "rb", "vec", "block", "lit", "fi", "cap"]}}
{"project": "qemu", "commit_id": "0d1c5c91607d1c55a8f5db39c57c6e5c76e21131", "target": 0, "func": "void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    if (!bs->drv)  {\n\n        return;\n\n    }\n\n\n\n    if (!(bs->open_flags & BDRV_O_INACTIVE)) {\n\n        return;\n\n    }\n\n    bs->open_flags &= ~BDRV_O_INACTIVE;\n\n\n\n    if (bs->drv->bdrv_invalidate_cache) {\n\n        bs->drv->bdrv_invalidate_cache(bs, &local_err);\n\n    } else if (bs->file) {\n\n        bdrv_invalidate_cache(bs->file->bs, &local_err);\n\n    }\n\n    if (local_err) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n\n    if (ret < 0) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n\n        return;\n\n    }\n\n}\n", "idx": 19380, "substitutes": {"bs": ["ns", "bi", "ts", "bin", "s", "facebook", "blog", "rs", "db", "obj", "base", "br", "las", "plugins", "bps", "ubs", "sb", "cb", "bc", "ls", "ss", "pb", "fs", "lb", "bb", "abc", "xs", "ba", "bid", "cs", "css", "als", "gb", "bos", "bot", "bf", "ins", "obs", "bu", "outs", "BS", "iss", "blocks", "bis", "qs", "abi", "bl", "vs", "bas", "fb", "ses", "bh", "ps", "sync", "bits", "js", "bn", "b", "cache", "ks", "gs", "its", "bytes", "os", "bes", "us", "banks", "bus", "ds", "bing"], "errp": ["errcp", "Err", " errP", " errcp", "serverps", "err", "errP", "rrpre", "rrr", "errpc", "serverp", "errv", "Ercp", "erpre", "erps", "serverr", "serverpre", "errpre", "erpc", "erp", "Erv", "errr", "rrv", " errr", "rrp", "errps", "rrps", "erP", "rrcp", "rrP", " errpc", " errv", "Erp", "rrpc"], "local_err": ["local6errors", "local_result", " local_error", "localWerrors", "local_Er", " local_magic", " local_result", " local_iter", "local_error", "local_rr", "local6error", " local_rr", "localWerr", "global_error", "global_rr", "global_err", " local_errors", "localWmagic", "local6result", "local_iter", " local_Er", "local6err", "localWerror", "local_magic", "local_errors"], "ret": ["db", "code", "sur", "f", "ref", "bit", "alt", "let", "rc", "nt", "lit", "reg", "rt", "fun", "result", "num", "flag", "match", "bc", "ext", "dt", "fin", "sec", "done", "mem", "rets", "arg", "att", "val", "re", "Ret", "feat", "no", "back", "id", "det", "rev", "cat", "req", "rl", "gt", "RET", "res", "mt", "ft", "iter", "success", "len"]}}
{"project": "FFmpeg", "commit_id": "607ad990d31e6be52980970e5ce8cd25ab3de812", "target": 0, "func": "static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,\n\n                                        int buf_size, AVSubtitle *sub)\n\n{\n\n    DVBSubContext *ctx = avctx->priv_data;\n\n    DVBSubDisplayDefinition *display_def = ctx->display_definition;\n\n\n\n    DVBSubRegion *region;\n\n    DVBSubRegionDisplay *display;\n\n    AVSubtitleRect *rect;\n\n    DVBSubCLUT *clut;\n\n    uint32_t *clut_table;\n\n    int i;\n\n    int offset_x=0, offset_y=0;\n\n\n\n    sub->rects = NULL;\n\n    sub->start_display_time = 0;\n\n    sub->end_display_time = ctx->time_out * 1000;\n\n    sub->format = 0;\n\n\n\n    if (display_def) {\n\n        offset_x = display_def->x;\n\n        offset_y = display_def->y;\n\n    }\n\n\n\n    sub->num_rects = ctx->display_list_size;\n\n    if (sub->num_rects <= 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    sub->rects = av_mallocz_array(sub->num_rects * sub->num_rects,\n\n                                  sizeof(*sub->rects));\n\n    if (!sub->rects)\n\n        return AVERROR(ENOMEM);\n\n\n\n    i = 0;\n\n\n\n    for (display = ctx->display_list; display; display = display->next) {\n\n        region = get_region(ctx, display->region_id);\n\n        rect = sub->rects[i];\n\n\n\n        if (!region)\n\n            continue;\n\n\n\n        rect->x = display->x_pos + offset_x;\n\n        rect->y = display->y_pos + offset_y;\n\n        rect->w = region->width;\n\n        rect->h = region->height;\n\n        rect->nb_colors = 16;\n\n        rect->type      = SUBTITLE_BITMAP;\n\n        rect->pict.linesize[0] = region->width;\n\n\n\n        clut = get_clut(ctx, region->clut);\n\n\n\n        if (!clut)\n\n            clut = &default_clut;\n\n\n\n        switch (region->depth) {\n\n        case 2:\n\n            clut_table = clut->clut4;\n\n            break;\n\n        case 8:\n\n            clut_table = clut->clut256;\n\n            break;\n\n        case 4:\n\n        default:\n\n            clut_table = clut->clut16;\n\n            break;\n\n        }\n\n\n\n        rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);\n\n        if (!rect->pict.data[1]) {\n\n            av_free(sub->rects);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));\n\n\n\n        rect->pict.data[0] = av_malloc(region->buf_size);\n\n        if (!rect->pict.data[0]) {\n\n            av_free(rect->pict.data[1]);\n\n            av_free(sub->rects);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        memcpy(rect->pict.data[0], region->pbuf, region->buf_size);\n\n\n\n        i++;\n\n    }\n\n\n\n    sub->num_rects = i;\n\n\n\n#ifdef DEBUG\n\n    save_display_set(ctx);\n\n#endif\n\n\n\n    return 1;\n\n}\n", "idx": 21841, "substitutes": {"avctx": ["vercontext", "verconn", "verctx", "evconn", "avconn", "AVcli", "AVctrl", "AVcontext", "evcontext", "amctx", "evctrl", "avcontext", "amcontext", "AVconn", "avalctrl", "avalcli", "amcli", "avalctx", "evctx", "AVctx", "avalcontext", "avctrl", "avcli", "amctrl", "verctrl"], "buf": ["conv", "port", "uf", "ref", "map", "cv", "queue", "img", "buffer", "alloc", "cmd", "box", "cache", "pool", "rc", "cb", "mem", "seq", "src", "br", "batch", "buff", "proc", "conf", "vec", "rb", "block"], "buf_size": ["buf_small", " buffer8len", " buffer8small", "buf8small", " buffer_len", " buffer_small", "buf8size", " buffer_size", " buffer8size", "buf8len", "buf_len"], "sub": ["app", "config", "part", "address", "submit", "small", "pl", "dim", "src", "slice", "ab", "http", "conf", "image", "this", "type", "pub", "sim", "sb", "text", "split", "builder", "pre", "trans", "ext", "sc", "hub", "desc", "child", "feed", "Sub", "lib", "sum", "remote", "reg", "public", "summary", "sel", "uc", "ref", "queue", "func", "exec", "section", "full", "new", "job", "comment", "form", "b", "sup", "loc", "sec", "user", "children", "pb", "shape", "project", "input", "ubs", "plugin", "home", "build", "rob", "super", "abc", "py", "client", "hide", "search", "match", "ub", "sing", "rub", "block", "server", "um"], "ctx": ["lc", "bc", "git", "sync", "fc", "cc", "cam", "wcs", "uc", "conn", "sci", "config", "ha", "progress", "pkg", "cv", "chan", "cm", "tx", "ca", "Context", "anc", "cas", "cl", "cu", "ci", "cmp", "exec", "fp", "cmd", "cp", "data", "storage", "cf", "xc", "cs", "ctrl", "kb", "context", "que", "cli", "mac", "rc", "c", "cb", "cn", "client", "cfg", "sc", "comp", "ocr", "hub", "qa", "media", "src", "fw", "loc", "cca", "utils", "buff", "cms", "lib", "ck", "kw", "concept", "sq", "pub"], "display_def": ["process_manager", "displayerDef", "displayabledef", "displayabledefinition", "displayaldesign", "screenerconf", "displayacdefine", "displayername", "display_config", "displayJconfig", "regionaddel", "display_conf", "process_def", "winADdefault", "displayWdef", "screenerdist", "display_del", "displayADdev", "displayADdefault", "win_def", "displayitydef", "displayADdefine", "displayerdef", "displayerconf", "screen_dist", "displayerdefine", "regionadconfig", "display_design", "display_dev", "displayabledist", "displayermanager", "winADdefine", "win_default", "regionaddef", "displayalconfig", "displayaddel", "screen_def", "displayaddesign", "win_dev", "screen_conf", "region_design", "displayacdefault", "displayalconf", "displayaldefinition", "displayWDef", "displayWmanager", "display_manager", "process_Def", "processWdef", "display_default", "screen_definition", "displayableconf", "region_config", "displayacdef", "regionaddesign", "displayadconfig", "processWmanager", "displayaddef", "displayacdev", "processWname", "displayJdel", "displayerdist", "win_define", "displayWname", "displayerdefault", "process_name", "display_Def", "displayaldist", "displayityname", "region_del", "displayerdev", "displayADdef", "displayJdef", "displayaldel", "screenerdef", "displayityDef", "displayitymanager", "display_name", "displayerdefinition", "display_dist", "display_definition", "screenerdefinition", "displayJdesign", "processWDef", "display_define", "region_def", "winADdev", "winADdef", "displayaldef"], "region": ["remote", "route", "feat", "country", "view", "reg", "port", "summary", "shape", "recent", "area", "config", "pattern", "project", "progress", "feature", "plugin", "local", "layer", "transfer", "dist", "section", "address", "cache", "description", "component", "gallery", "zone", "content", "memory", "tag", "module", "dim", "rule", "location", "REG", "division", "desc", "slice", "loc", "definition", "large", "radius", "update", "stage", "report", "Region", "range", "manager", "shadow", "artist", "resource", "script", "image", "production", "scope", "gap", "record", "output", "texture", "format", "theme", "contract"], "display": ["remote", "render", "roy", "reg", "view", "public", "summary", "disc", "app", "config", "be", "rem", "player", "mor", "feature", "process", "bin", "host", "device", "dist", "section", "use", "ini", "rest", "full", "cache", "address", "description", "play", "component", "screen", "profile", "destroy", "hide", "index", "fe", "match", "run", "dim", "gui", "role", "present", "draw", "REG", "orn", "service", "date", "Display", "show", "console", "large", "debug", "domain", "update", "feed", "stage", "report", "shadow", "script", "image", "position", "production", "block", "record", "output", "browser"], "rect": ["remote", "str", "port", "view", "col", "shape", "lat", "nav", "area", "object", "ref", "config", "project", "butt", "progress", "coll", "input", "post", "map", "tr", "feature", "Rect", "device", "layer", "section", "coord", "dir", "box", "round", "init", "patch", "act", "point", "crop", "thin", "rc", "tile", "dr", "client", "spec", "tag", "texture", "dom", "font", "ext", "dim", "rt", "pull", "ptr", "draw", "slice", "loc", "test", "large", "RECT", "image", "block", "pt", "att", "record", "feat", "attr", "format", "tri", "contract"], "clut": ["slut", "decut", "Clut", " clott", "clob", "clur", "cluto", "cluton", " clob", "kluts", "plot", "window", "cluts", "Clutor", "lcaut", "klot", "slunt", "flob", "this", "type", "flant", "flunt", "plut", "plute", "slute", "flatur", "g", "aclaut", "decuto", "Clur", "Clott", " cluton", "clant", "decatur", "lcut", "klutt", " clatur", "klunt", "flut", "clatur", " cluts", " clute", "slur", " clunt", "plaut", "plutt", "clutt", "bytes", "img", "clute", "klatur", "lcutt", "celott", "fluts", " clutor", "acluto", " clot", " clutt", "klut", " claut", "slutt", "celur", "kluto", " clur", "slant", " cluto", "plur", " clant", "klob", "claut", "clot", "celutor", "lcuto", "kluton", "obj", "aclut", "aclutt", "_", "pluto", "decuton", "clott", "clutor", "plunt", "celut", "clunt", "slaut", "flaut", "all"], "clut_table": ["clute_tab", "clit_table", "clit2tree", "clut2tree", "clit2index", "clit_index", "clut_db", "cluts_cache", "clit2list", "clutt_type", "clit2table", "clutttype", "clutt_cache", "clut___family", "clute_family", "clut_list", "clit_tree", "clut_family", "clut___tab", "clut_tree", "clute_stable", "clut2list", "clut_cache", "clut___table", "cluts_type", "clutt_level", "clut2table", "cluts_table", "cluttcache", "clut_tab", "cluttlevel", "clute_table", "clutt_table", "clut2index", "clutttable", "clut_index", "clit_list", "clut_type", "clut___stable", "clut_level", "cluts_db", "clut_stable"], "i": ["start", "fi", "qi", "ind", "ri", "ui", "mini", "connection", "gi", "d", "ti", "I", "l", "f", "ci", "y", "phi", "u", "ini", "j", "ip", "p", "abi", "vi", "bi", "mi", "c", "index", "num", "si", "ii", "b", "n", "iu", "ai", "xi", "hi", "di", "uni", "li", "pi", "x", "ni", "ori"]}}
{"project": "qemu", "commit_id": "b97400caef60ccfb0bc81c59f8bd824c43a0d6c8", "target": 0, "func": "static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)\n\n{\n\n    int err;\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    err =  lstat(rpath(fs_ctx, path, buffer), stbuf);\n\n    if (err) {\n\n        return err;\n\n    }\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        /* Actual credentials are part of extended attrs */\n\n        uid_t tmp_uid;\n\n        gid_t tmp_gid;\n\n        mode_t tmp_mode;\n\n        dev_t tmp_dev;\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.uid\", &tmp_uid,\n\n                    sizeof(uid_t)) > 0) {\n\n            stbuf->st_uid = tmp_uid;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.gid\", &tmp_gid,\n\n                    sizeof(gid_t)) > 0) {\n\n            stbuf->st_gid = tmp_gid;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.mode\",\n\n                    &tmp_mode, sizeof(mode_t)) > 0) {\n\n            stbuf->st_mode = tmp_mode;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.rdev\", &tmp_dev,\n\n                        sizeof(dev_t)) > 0) {\n\n                stbuf->st_rdev = tmp_dev;\n\n        }\n\n    }\n\n    return err;\n\n}\n", "idx": 12672, "substitutes": {"fs_ctx": ["fsxctx", "fs_xc", "fs_lc", "fs_course", "aws_exc", "vs_lc", "aws_course", "ws_path", "fs_cf", "fsJcf", "fs_anc", "fsxrc", "fs___voc", "fsprectx", "vs_connection", "fs_rc", "fsgcn", "fs_cn", "fsjctx", "FS_context", "raf_ctx", "raf_crit", "fsprexc", "fs_context", "FS_rc", "fs_c", "fs___conn", "fb_anc", "FS_src", "fb_lc", "fsJxc", "aws_cf", "fb_ctx", "fsJctx", "fs_conn", "fsprecf", "fsJcrit", "fs_sem", "fs_src", "aws_exec", "fs_voc", "fs___path", "aws_ctx", "fs_exc", "fsjconnection", "raf_sem", "ws_ctx", "fsprecrit", "fsjc", "vs_ctx", "ws_voc", "fsgctx", "vs_c", "fs___ctx", "fsjlc", "aws_xc", "FS_ctx", "fsgcrit", "fsgsem", "ws_conn", "fs_crit", "fsxsrc", "fs_exec", "aws_crit", "raf_cn", "fb_src", "fsxcontext", "fs_connection"], "fs_path": [" fs___anc", "fs___context", "fs_config", " fs_tx", "fs___batch", " fs_batch", "fs_context", " fs_context", " fs_anc", " fs___context", " fs___path", "fs_tx", "fs_batch", "fs_anc", " fs_config", "fs___path", "fs___anc", " fs___batch"], "stbuf": ["ftgb", "STcb", "putport", "resttext", "ostbuf", " stfb", "ctbuffer", "ctbuff", "STblock", "stport", " stbuff", "putgb", "stblock", "ostbuff", "stgb", "STport", "lbuf", " stbh", "ftbuffer", "STbuff", "ctblock", "restbuf", "stbuffer", "STbuffer", "stcb", "STgb", " stcb", "STuf", "restfb", " stbuffer", "luf", " stport", "putfb", "puttext", "ftcb", " sttext", "stuf", "putbuff", "ostbuffer", "stbuff", "stfb", "ctbh", "constbuffer", "STbuf", "sttext", "constuf", "ftbuf", "constbuff", " stblock", "restcb", "lbuffer", "putbuf", "ostbh", " stgb", "putcb", "ctbuf", "stbh", "constbuf", "lbuff"], "err": ["ah", "msg", "Error", "str", "loc", "Er", "br", "ind", "mr", "lr", "ok", "ver", "ler", "count", "magic", "cb", " Err", "attr", "eb", "out", "here", "fee", "dr", "order", "self", "rc", "id", "ctr", "or", "req", "error", "result", "aaa", "arr", "try", "r", "pr", "ar", "rage", "rr", "fer", "gr", "test", "ref", "init", "rh", "der", "e", "found", "f", "fe", "type", "more", "go", "ner", "bug", "it", "fy", "orig", "die", "range", "er", "act", "later", "aster", "dy", "ee", "nil", "nor", "all", "resp", "ise", "len", "y"], "buffer": [" buffers", "seek", "channel", "map", "transfer", "device", " buf", "bin", "context", "slice", "queue", "array", "batch", "texture", "seed", "fb", "shape", "binary", "memory", "uf", "FFER", " Buffer", "source", "reference", "str", "raw", "position", "writer", "slave", "server", "buff", "limit", "table", "phrase", "bar", "document", "loader", "size", "handler", "buf", "data", "b", "base", "Buffer", "reader", "length", "byte", "pointer", "flow", "holder", "url", "block", "feed", "counter", "uffer", "file", "loop", "iter", "cache", "pad", "header", "filename", "message"], "path": ["area", "port", "context", "root", "location", "part", "ath", "uc", "sync", "thin", "config", "mount", "id", "child", "home", "current", "name", "connection", "source", "image", "ref", "full", "dir", "fn", "conn", "col", "view", "loader", "p", "temp", "folder", "data", "pointer", "base", "mode", "Path", "parent", "c", "PATH", "url", "block", "route", "cat", "end", "inner", "file", "text", "transform", "host", "cache", "pattern", "content", "prop", "prefix", "alias", "ctx", "node"], "tmp_uid": ["tmp___u", "mp_uid", "mp_mode", "tmp_pid", "tmp00mode", "tmp00uu", "tmp___uid", " tmp_u", "tmp00uid", "tmp___dev", " tmp_uu", "mp_pid", "tmp00user", "tmp_machine", "tmp___uu", "mp_machine", "tmp_uu", "tmp_u", "tmp_user", "mp_user", "mp_uu"], "tmp_gid": ["tmp_gident", "tmp_appids", "tmp_rad", "tmp_cids", "tmp_guids", "tmp_rid", "tmp_guident", "tmp_guax", "tmp_appax", "tmp_uids", "tmp_egids", "tmp_gax", "tmp_guad", "tmp_cone", "tmp_uip", "tmp_rident", "tmp_guid", "tmp_uone", "tmp_cid", "tmp_gamiden", "tmp_gamids", "tmp_appiden", "tmp_gad", "tmp_rids", "tmp_egid", "tmp_cip", "tmp_egad", "tmp_gamid", "tmp_egident", "tmp_gip", "tmp_appid", "tmp_gone", "tmp_guip", "tmp_guiden", "tmp_guone", "tmp_gamax", "tmp_gids", "tmp_giden"], "tmp_mode": ["tmp67user", "mp_mode", "tmp_option", "temp_dev", "vt_mod", "temp_mac", "vt_mode", "mp_mod", "tmp5mode", "tmp67mod", "tmp_mac", "tmp_dim", "tmp5user", "temp_mod", "tmp5mod", "tmp67mode", "temp_mode", "tmp5option", "vt_raid", "tmp_mod", "tmp67option", "vt_dim", "tmp_user", "tmp_raid", "mp_user", "mp_option"], "tmp_dev": ["tmp_debug", "mp_mode", "tmp__diff", "mp_debug", "mp_device", "tmp__dev", "mp_push", "tmp__device", "tmp_device", "mp_dev", "tmp_diff", "tmp__push", "tmp_de", " tmp_de", "tmp_home", "tmp_push", " tmp_home", " tmp_device", "mp_diff"]}}
{"project": "FFmpeg", "commit_id": "f3e5a7844bbf13620ca4b6a5e19aa087c9141b15", "target": 0, "func": "static int allocate_buffers(ALACContext *alac)\n\n{\n\n    int ch;\n\n    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {\n\n        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n\n\n        if (alac->sample_size == 16) {\n\n            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],\n\n                             buf_size, buf_alloc_fail);\n\n        }\n\n\n\n        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],\n\n                         buf_size, buf_alloc_fail);\n\n    }\n\n    return 0;\n\nbuf_alloc_fail:\n\n    alac_decode_close(alac->avctx);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 21584, "substitutes": {"alac": ["alsacs", "beloc", "maluc", "elec", "calacc", "malacs", "alsc", "alloc", " alec", "allAC", "altacc", "alunc", "calanc", "plmac", "alacs", "elacl", "altac", "elacc", "elac", "altc", "palAC", "ploc", "ilanc", "palmac", " alacs", "allc", "pliac", " alacl", "ALac", "elmac", "alsac", "elax", "aliacc", "plac", "belmac", "paliac", "almac", " aliac", "ALoc", "alsacc", "calac", "pluc", " alacc", "allacs", "malac", "aliec", "placs", "alc", "elacs", "alAC", " alunc", "alec", " alc", "maloc", "ilacc", "allacc", "alic", " alax", "alacc", "elAC", "alax", "ALAC", "malunc", "aluc", "ilacs", " aloc", " alAC", "aloc", "calacs", "plAC", "aliac", "alanc", "alacl", " almac", "belac", "allac", " alanc", "palac", "altacl", "elc", "malc", "eloc", "eluc", "elunc", "ilac", "ALacs", "belax"], "ch": ["cha", "col", "sch", "i", "och", "chn", "sk", "conn", "ach", "ct", "mot", "jp", "err", "cor", "hop", "chan", "ich", "cm", "cry", "anch", "chi", "Ch", "che", "cur", "cl", "f", "y", "cp", "oy", "j", "cht", "p", "CH", "enc", "change", "code", "work", "q", "client", "c", "el", "arch", "ctx", "ver", "cho", "cham", "b", "comp", "cy", "channel", "child", "length", "zh", "pol", "gr", "chip", "gh", "batch", "cher", "ech", "conf", "bh", "chrom", "h", "l", "x", "k", "count"]}}
{"project": "FFmpeg", "commit_id": "842b6c14bcfc1c5da1a2d288fd65386eb8c158ad", "target": 0, "func": "static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)\n\n{\n\n    MpegTSWrite *ts = s->priv_data;\n\n    uint8_t data[1012], *q, *desc_length_ptr, *program_info_length_ptr;\n\n    int val, stream_type, i;\n\n\n\n    q = data;\n\n    put16(&q, 0xe000 | service->pcr_pid);\n\n\n\n    program_info_length_ptr = q;\n\n    q += 2; /* patched after */\n\n\n\n    /* put program info here */\n\n\n\n    val = 0xf000 | (q - program_info_length_ptr - 2);\n\n    program_info_length_ptr[0] = val >> 8;\n\n    program_info_length_ptr[1] = val;\n\n\n\n    for(i = 0; i < s->nb_streams; i++) {\n\n        AVStream *st = s->streams[i];\n\n        MpegTSWriteStream *ts_st = st->priv_data;\n\n        AVDictionaryEntry *lang = av_dict_get(st->metadata, \"language\", NULL,0);\n\n        switch(st->codec->codec_id) {\n\n        case AV_CODEC_ID_MPEG1VIDEO:\n\n        case AV_CODEC_ID_MPEG2VIDEO:\n\n            stream_type = STREAM_TYPE_VIDEO_MPEG2;\n\n            break;\n\n        case AV_CODEC_ID_MPEG4:\n\n            stream_type = STREAM_TYPE_VIDEO_MPEG4;\n\n            break;\n\n        case AV_CODEC_ID_H264:\n\n            stream_type = STREAM_TYPE_VIDEO_H264;\n\n            break;\n\n        case AV_CODEC_ID_CAVS:\n\n            stream_type = STREAM_TYPE_VIDEO_CAVS;\n\n            break;\n\n        case AV_CODEC_ID_DIRAC:\n\n            stream_type = STREAM_TYPE_VIDEO_DIRAC;\n\n            break;\n\n        case AV_CODEC_ID_MP2:\n\n        case AV_CODEC_ID_MP3:\n\n            stream_type = STREAM_TYPE_AUDIO_MPEG1;\n\n            break;\n\n        case AV_CODEC_ID_AAC:\n\n            stream_type = (ts->flags & MPEGTS_FLAG_AAC_LATM) ? STREAM_TYPE_AUDIO_AAC_LATM : STREAM_TYPE_AUDIO_AAC;\n\n            break;\n\n        case AV_CODEC_ID_AAC_LATM:\n\n            stream_type = STREAM_TYPE_AUDIO_AAC_LATM;\n\n            break;\n\n        case AV_CODEC_ID_AC3:\n\n            stream_type = STREAM_TYPE_AUDIO_AC3;\n\n            break;\n\n        default:\n\n            stream_type = STREAM_TYPE_PRIVATE_DATA;\n\n            break;\n\n        }\n\n        *q++ = stream_type;\n\n        put16(&q, 0xe000 | ts_st->pid);\n\n        desc_length_ptr = q;\n\n        q += 2; /* patched after */\n\n\n\n        /* write optional descriptors here */\n\n        switch(st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if(st->codec->codec_id==AV_CODEC_ID_EAC3){\n\n                *q++=0x7a; // EAC3 descriptor see A038 DVB SI\n\n                *q++=1; // 1 byte, all flags sets to 0\n\n                *q++=0; // omit all fields...\n\n            }\n\n            if(st->codec->codec_id==AV_CODEC_ID_S302M){\n\n                *q++ = 0x05; /* MPEG-2 registration descriptor*/\n\n                *q++ = 4;\n\n                *q++ = 'B';\n\n                *q++ = 'S';\n\n                *q++ = 'S';\n\n                *q++ = 'D';\n\n            }\n\n\n\n            if (lang) {\n\n                char *p;\n\n                char *next = lang->value;\n\n                uint8_t *len_ptr;\n\n\n\n                *q++ = 0x0a; /* ISO 639 language descriptor */\n\n                len_ptr = q++;\n\n                *len_ptr = 0;\n\n\n\n                for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) {\n\n                    next = strchr(p, ',');\n\n                    if (strlen(p) != 3 && (!next || next != p + 3))\n\n                        continue; /* not a 3-letter code */\n\n\n\n                    *q++ = *p++;\n\n                    *q++ = *p++;\n\n                    *q++ = *p++;\n\n\n\n                if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS)\n\n                    *q++ = 0x01;\n\n                else if (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED)\n\n                    *q++ = 0x02;\n\n                else if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED)\n\n                    *q++ = 0x03;\n\n                else\n\n                    *q++ = 0; /* undefined type */\n\n\n\n                    *len_ptr += 4;\n\n                }\n\n\n\n                if (*len_ptr == 0)\n\n                    q -= 2; /* no language codes were written */\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            {\n\n                const char default_language[] = \"und\";\n\n                const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language;\n\n\n\n                if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {\n\n                    uint8_t *len_ptr;\n\n                    int extradata_copied = 0;\n\n\n\n                    *q++ = 0x59; /* subtitling_descriptor */\n\n                    len_ptr = q++;\n\n\n\n                    while (strlen(language) >= 3 && (sizeof(data) - (q - data)) >= 8) { /* 8 bytes per DVB subtitle substream data */\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        /* Skip comma */\n\n                        if (*language != '\\0')\n\n                            language++;\n\n\n\n                        if (st->codec->extradata_size - extradata_copied >= 5) {\n\n                            *q++ = st->codec->extradata[extradata_copied + 4]; /* subtitling_type */\n\n                            memcpy(q, st->codec->extradata + extradata_copied, 4); /* composition_page_id and ancillary_page_id */\n\n                            extradata_copied += 5;\n\n                            q += 4;\n\n                        } else {\n\n                            /* subtitling_type:\n\n                             * 0x10 - normal with no monitor aspect ratio criticality\n\n                             * 0x20 - for the hard of hearing with no monitor aspect ratio criticality */\n\n                            *q++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10;\n\n                            if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) {\n\n                                /* support of old 4-byte extradata format */\n\n                                memcpy(q, st->codec->extradata, 4); /* composition_page_id and ancillary_page_id */\n\n                                extradata_copied += 4;\n\n                                q += 4;\n\n                            } else {\n\n                                put16(&q, 1); /* composition_page_id */\n\n                                put16(&q, 1); /* ancillary_page_id */\n\n                            }\n\n                        }\n\n                    }\n\n\n\n                    *len_ptr = q - len_ptr - 1;\n\n                } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) {\n\n                    uint8_t *len_ptr = NULL;\n\n                    int extradata_copied = 0;\n\n\n\n                    /* The descriptor tag. teletext_descriptor */\n\n                    *q++ = 0x56;\n\n                    len_ptr = q++;\n\n\n\n                    while (strlen(language) >= 3) {\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        /* Skip comma */\n\n                        if (*language != '\\0')\n\n                            language++;\n\n\n\n                        if (st->codec->extradata_size - 1 > extradata_copied) {\n\n                            memcpy(q, st->codec->extradata + extradata_copied, 2);\n\n                            extradata_copied += 2;\n\n                            q += 2;\n\n                        } else {\n\n                            /* The Teletext descriptor:\n\n                             * teletext_type: This 5-bit field indicates the type of Teletext page indicated. (0x01 Initial Teletext page)\n\n                             * teletext_magazine_number: This is a 3-bit field which identifies the magazine number.\n\n                             * teletext_page_number: This is an 8-bit field giving two 4-bit hex digits identifying the page number. */\n\n                            *q++ = 0x08;\n\n                            *q++ = 0x00;\n\n                        }\n\n                    }\n\n\n\n                    *len_ptr = q - len_ptr - 1;\n\n                 }\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (stream_type == STREAM_TYPE_VIDEO_DIRAC) {\n\n                *q++ = 0x05; /*MPEG-2 registration descriptor*/\n\n                *q++ = 4;\n\n                *q++ = 'd';\n\n                *q++ = 'r';\n\n                *q++ = 'a';\n\n                *q++ = 'c';\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_DATA:\n\n            if (st->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) {\n\n                *q++ = 0x05; /* MPEG-2 registration descriptor */\n\n                *q++ = 4;\n\n                *q++ = 'K';\n\n                *q++ = 'L';\n\n                *q++ = 'V';\n\n                *q++ = 'A';\n\n            }\n\n            break;\n\n        }\n\n\n\n        val = 0xf000 | (q - desc_length_ptr - 2);\n\n        desc_length_ptr[0] = val >> 8;\n\n        desc_length_ptr[1] = val;\n\n    }\n\n    mpegts_write_section1(&service->pmt, PMT_TID, service->sid, ts->tables_version, 0, 0,\n\n                          data, q - data);\n\n}\n", "idx": 4896, "substitutes": {"s": ["as", "sets", "ches", "sf", "v", "ins", "is", "S", "spec", "session", "b", "si", "sync", "sys", "ses", "services", "its", "support", "states", "l", "f", "parts", "ns", "server", "sl", "series", "space", "ss", "cs", "gs", "ks", "sim", "t", "ds", "qs", "storage", "tests", "su", "settings", "aws", "sv", "sa", "c", "ys", "g", "ssl", "sq", "y", "os", "rs", "ps", "js"], "service": ["Service", "serv", "sr", "v", "scope", "session", "config", "si", "sync", "stream", "sys", "info", "services", "image", "support", "so", "resource", "server", "sl", "j", "space", "cs", "connection", "se", "storage", "sd", "ctx", "ie", "settings", "reader", "sv", "sp", "bank", "fs", "c", "g", "query", "vc", "js"], "ts": ["tes", "ets", "atts", "tr", "services", "tu", "tx", "Ts", "att", "ns", "ats", "ls", "TS", "cs", "ss", "ics", "gs", "ks", "t", "ds", "qs", "tests", "outs", "ents", "trans", "acs", "fs", "utils", "ms", "ims", "uts", "tt", "test", "rs", "ps", "tc"], "data": ["mem", "block", "a", "dat", "config", "format", "stream", "map", "buf", "vals", "offset", "f", "d", "length", "DATA", "byte", "def", "buffer", "len", "ops", "arr", "raw", "ds", "Data", "bytes", "empty", "seq", "input", "array", "req", "reader", "xxx", "zero", "read", "cache", "r", "rec", "shift"], "q": ["ch", "o", "iq", "v", "id", "count", "qq", "value", "qt", "x", "queue", "qi", "quant", "l", "f", "ue", "dq", "length", "d", "u", "w", "depth", "qs", "Q", "k", "t", "n", "qu", "seq", "qa", "req", "h", "z", "charge", "c", "g", "sq", "type", "query", "requ", "quest"], "desc_length_ptr": ["program_length32length", "program_length32ptr", "program_length_info", "program_length32pointer", "program_length_length", "program_len_ptr", "program_length_ptr", "program_len_pointer", "program_length32info", "program_len_info", "program_len_length", "program_length_pointer"], "program_info_length_ptr": ["program_info_length_pointer", "program_info_length__length", "program_info_info_pad", "program_info_info_pointer", "program_info_info_tr", "program_info_length_tr", "program_info_len_len", "program_info_length_pad", "program_info_len_pointer", "program_info_length__pointer", "program_info_length_len", "program_info_info_pointers", "program_info_length_pointers", "program_info_length__pointers", "program_info_length__ptr", "program_info_info_val", "program_info_length_length", "program_info_len_length", "program_info_info_length", "program_info_info_ptr", "program_info_length_val", "program_info_len_ptr"], "val": ["vol", "base", " v", "v", "al", "el", "sec", "alt", "value", "x", "b", "Val", "pt", " value", "fx", "buf", "l", "vals", "cal", "valid", "f", "ival", "tx", "d", "sl", "fl", "VAL", "len", "e", "depth", "ol", "aval", "k", "bc", "seq", "eval", "sel", "vl", "ul", "il", "li", "bl", "ref", "au", "r", "grad", "max"], "stream_type": ["streamenunit", "source_style", "streamsstyle", " stream_id", "streamalid", "streamfformat", "channel_TYPE", "outputentype", "streamerunit", "resource_shape", "outputenid", "streamingname", "streamingid", "streamingtype", "stream_unit", "channel_type", "output_id", "streamingTYPE", "stream_target", "streamabletype", "source_type", "channel_template", "stream_format", "stream_TYPE", "streamingtemplate", "stream_state", "output_type", "stream_template", "stream_id", "streamenlength", "resourceingcount", "streamftemplate", "streamalstyle", "stream_list", "streamingshape", "streamvaltemplate", "streamenlist", "outputenlength", "source_mode", "streamerlist", "sourcesid", "streamalstate", "streamsid", "resource_id", "streamftype", "ream_type", "streamsmode", "source_id", "stream_length", "resource_count", "streamaltype", "stream_count", "program_length", "stream_value", "resourceingid", "streamertype", "streamenvalue", "resourceingshape", "program_type", "stream_shape", "streamalformat", "sourcestype", "streamfTYPE", "streamablestyle", "resourceingtype", "streamvaltype", "stream_mode", "channel_format", "streamalvalue", "output_target", "streamenid", "streamingstate", "program_id", "output_length", "program_name", "streamingvalue", " stream_template", "ream_list", "streaminglength", "streamstarget", "streamentarget", "ream_unit", "streamingformat", "stream_style", "streamingcount", "ream_format", "streamvalid", "streamableid", "streamalmode", "sourcesmode", "ream_state", "streamstype", "sourcesstyle", "streamslength", "streamervalue", "outputentarget", "stream_name", "streamentype", "streamablemode", "ream_value", "resource_type"], "i": ["gi", "o", "ti", "v", "id", "I", "di", "ci", "ni", "x", "b", "si", "ri", "xi", "io", "info", "abi", "m", "qi", "ix", "yi", "pi", "phi", "d", "ii", "j", "iu", "ai", "my", "uli", "it", "u", "e", "uri", "k", "multi", "mi", "ini", "ie", "eni", "oi", "hi", "c", "ip", "im", "y", "li", "fi", "index", "zi", "mu", "ui"], "st": ["std", "r", "est", "fr", "ste", "sr", "ost", "sw", "stal", "tr", "sn", "stream", "pt", "stress", "sts", "rest", "d", "sl", "St", "fe", "td", "sc", "sth", "sb", "ist", "inst", "sd", "t", "ds", "ST", "str", "sta", "stage", "sp", "start", "sa", "ld", "src", "ast", "nd", "stim"], "ts_st": ["ds_stream", "ts_stream", "ts_ost", "ds_st", "ts_sc", "ds_ost", "ds_sc"], "lang": ["std", "ml", "la", "entry", "enc", "art", "tu", "in", "th", "tag", "tx", "de", "ga", "obj", "en", "sd", "str", "trans", "sa", "lc", "bl", "pl", "au", "rs", "src", "ast", "nd"]}}
{"project": "qemu", "commit_id": "210b580b106fa798149e28aa13c66b325a43204e", "target": 0, "func": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n\n                             uint32_t token, uint32_t nargs, target_ulong args,\n\n                             uint32_t nret, target_ulong rets)\n\n{\n\n    if ((token >= TOKEN_BASE)\n\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n\n\n\n        if (call->fn) {\n\n            call->fn(spapr, token, nargs, args, nret, rets);\n\n            return H_SUCCESS;\n\n        }\n\n    }\n\n\n\n    /* HACK: Some Linux early debug code uses RTAS display-character,\n\n     * but assumes the token value is 0xa (which it is on some real\n\n     * machines) without looking it up in the device tree.  This\n\n     * special case makes this work */\n\n    if (token == 0xa) {\n\n        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);\n\n        return H_SUCCESS;\n\n    }\n\n\n\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n\n    rtas_st(rets, 0, -3);\n\n    return H_PARAMETER;\n\n}\n", "idx": 24759, "substitutes": {"spapr": ["Spapar", "Spappar", "spajra", " spapprd", "spaprar", "Spapprar", "sparpR", "spaprd", "wpapr", "spiprar", "sprapr", "spaptr", "spapsrar", "spapprar", "wpaptra", " spappra", "spapsR", "Spapr", "spaptsr", "sprapra", "spatrar", " spaprd", "sparprar", "wpaprar", "Spappr", "spaptrar", "spapra", "spappra", "sprapR", "spapprd", " spapra", "spraprd", "spajrd", "SpappR", "spipr", "spajR", "sparpr", "Spaprar", "sparpar", "wpapra", "spajr", " spapR", "wpaptsr", "spappR", "spipsr", "spaptra", "SpapR", "spapR", "wpapsr", "wpaptr", " spappR", "spapar", " spappr", "spapsr", "spipra", "spapsar", "spatsr", "spatra", "wpaptrar", "spatr", "spappr", "spappar"], "token": ["remember", "node", "secret", "socket", "element", "byte", "sid", "trial", "argument", "date", "option", "oken", "sn", "name", "function", "template", "api", "text", "type", "prefix", "version", "duration", "character", "column", "shadow", "sync", "KEN", "key", "seed", "o", "password", "code", "tick", "start", "session", "uri", "offset", "word", "sequence", "target", "number", "variable", "eni", "channel", "len", "length", "Token", "auth", "arg", "note", "timeout", "notice", "username", "rule", "stage", "wt", "prot", "limit", "year", "header", "cookie", "event", "document", "random", "tag", "format", "ok"], "nargs": [" nvalid", "pvalid", "lgs", "natret", "lvalid", "largs", "cparams", "ngs", "pparams", " narg", "natarg", " nparams", "cret", "nvalid", "carg", "nparams", "lparams", "natargs", "narg", " ngs", "pargs", "cgs", "cargs", "larg"], "args": ["ants", "secret", "rs", "seq", "argument", "res", "info", "parse", "context", "flags", "msg", "data", "doc", "var", "config", "ans", "next", "col", "ars", "vals", "stats", "aux", "gs", "arr", "extra", "cmd", "fields", "err", "Args", "strings", "ig", "aws", "ras", "ret", "files", "arg", "details", "names", "conn", "resp", "func", "results", "pos", "cs", "len", "params", "fun"], "nret": ["nrets", "crets", "nresult", "lRET", "creturn", "lret", " nlen", "cresult", "lresult", " nRET", "calt", "enrets", " nresult", " nreturn", "cret", "nRET", "nalt", "Nreturn", "lreturn", "enreturn", "clen", "Nrets", " nrets", "Nlen", "enalt", "Nret", " nalt", "nlen", "nreturn", "cRET", "enret"], "rets": ["ants", "secret", "rs", "breaks", "errors", "res", "info", "ns", "ats", "flags", "ts", "red", "items", "ds", "verts", "vt", "att", "def", "rules", "rows", "urs", "artifacts", "vals", " secrets", "aux", "protected", "tails", "fields", "runs", "strings", "lines", "RET", "ras", "uds", "ret", "urses", "utils", "nas", "cas", "ents", "ails", "fs", "details", "des", "alt", "results", "ieves", "ops", "pillar", "uments", "ints", "fun"], "call": ["exec", "use", "build", "code", "throw", "can", "invoke", "parse", "p", "play", "c", "close", "name", "cat", "function", "make", "ec", "send", "ell", "act", "def", "pass", "push", "end", "sync", "key", "e", "cell", "work", "create", "ul", "run", "cal", "roll", "cache", "co", "kill", "ack", "f", "mix", "apply", "init", "event", "Call", "block", "ac"]}}
{"project": "qemu", "commit_id": "1acae9f22380a03b468a29a3cc035b280610b5e4", "target": 0, "func": "_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,\n\n          const struct timespec *,tsp,int,flags)\n\n#endif\n\n#endif /* CONFIG_UTIMENSAT  */\n\n\n\n#ifdef CONFIG_INOTIFY\n\n#include <sys/inotify.h>\n\n\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\nstatic int sys_inotify_init(void)\n\n{\n\n  return (inotify_init());\n\n}\n", "idx": 13589, "substitutes": {}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void co_write_request(void *opaque)\n\n{\n\n    BDRVSheepdogState *s = opaque;\n\n\n\n    qemu_coroutine_enter(s->co_send, NULL);\n\n}\n", "idx": 24895, "substitutes": {"opaque": ["OPque", "octsea", "opsaques", "octaques", "opsque", "openaques", " opaques", "OPacity", "OPaques", "opsaque", "opaques", "ipsea", "openque", "ipacity", "octacity", "openacity", "opsea", "octaque", " opacity", "opsacity", "ipaque", " opsea", "ipaques", "opacity", "openaque", "opque", "OPaque"], "s": ["S", "ses", "socket", "sys", "scope", "ss", "p", "m", "server", "c", "b", "ns", "sq", "ds", "sg", "secondary", "sync", "e", "south", "o", "sie", "session", "spec", "si", "sym", "submit", "hs", "sb", "services", "sa", "f", "fs", "n", "a", "sl", "settings", "ops", "ssl", "g"]}}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)\n\n{\n\n    InputStream  *ist = s->opaque;\n\n    DXVA2Context *ctx = ist->hwaccel_ctx;\n\n\n\n    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);\n\n}\n", "idx": 23560, "substitutes": {"s": ["sv", "sb", "i", "e", "sed", "es", "ast", "sci", "sl", "fs", "ses", "an", "lex", "sac", "sis", "as", "ds", "f", "sys", "p", "cs", "ls", "is", "ss", "sa", "sg", "c", "self", "source", "si", "sts", "sc", "a", "w", "service", "se", "src", "ns", "sf", "rs", "gs", "sq"], "frame": ["view", "e", "iframe", "next", "scene", "part", "framework", "fb", "za", "feature", "fp", "f", "buffer", "data", "fx", "cf", "component", "point", "ace", "word", "pse", "self", "frames", "document", "source", "window", "rame", "face", "seq", "slice", "flow", "Frame", "range", "fram", "image", "fi", "video", "interface"], "flags": ["kind", "fs", "features", "mode", "func", "ffff", "ops", "f", "args", "faces", " flag", "cs", "Flag", "stats", "ants", "Flags", "settings", "lag", "fr", "bits", "flag", "FLAG", "mask", " Flags", "options", "ips", "feat", "format"], "ist": ["est", "edit", "ess", "dit", "xt", "ast", "adr", "ind", "ost", "IST", "iste", "kt", "aci", "ide", "isc", "pect", "dist", "asi", "osi", "ant", "sd", "wp", "et", "ic", "alist", "ists", "ism", "iss", "ict", "st", "isd", "ais", "asp", "pt", "feat", "ista"], "ctx": ["lc", "fc", "cc", "wcs", "conn", "sci", "ct", "config", "acl", "pkg", "cv", "tx", "ca", "Context", "pc", "ds", "cu", "cas", "fp", "ci", "cmp", "ac", "cmd", "cp", "nc", "p", "cs", "cf", "ace", "context", "c", "cn", "comp", "cal", "fw", "loc", "cca", "hw", "kw", "sq", "acs", "vc"]}}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,\n\n                              const char *default_model)\n\n{\n\n    int i, exit_status = 0;\n\n\n\n    if (!nd->model)\n\n        nd->model = strdup(default_model);\n\n\n\n    if (strcmp(nd->model, \"?\") != 0) {\n\n        for (i = 0 ; models[i]; i++)\n\n            if (strcmp(nd->model, models[i]) == 0)\n\n                return i;\n\n\n\n        fprintf(stderr, \"qemu: Unsupported NIC model: %s\\n\", nd->model);\n\n        exit_status = 1;\n\n    }\n\n\n\n    fprintf(stderr, \"qemu: Supported NIC models: \");\n\n    for (i = 0 ; models[i]; i++)\n\n        fprintf(stderr, \"%s%c\", models[i], models[i+1] ? ',' : '\\n');\n\n\n\n    exit(exit_status);\n\n}\n", "idx": 19916, "substitutes": {"nd": ["gn", "dd", "dn", "cdn", "gd", "inn", "td", "ng", "ND", "md", "nt", "ne", "pd", "inc", "ani", "hd", "vd", "ld", "ind", "dl", "wd", "nb", "sd", "ln", "ond", "d", "rd", "std", "inf", "nc", "nda", "bd", "rn", "nu", "fd", "ant", "xd", "idd", "nw", "dev", "da", "cmd", "ck", "ud", "zn", "od", "dat", "cd", "wn", "nn", "end", "dk", "und", "ds"], "models": ["classes", "bugs", "ms", "move", "m", "strings", "mod", "data", "mode", "jobs", "x", "image", "grid", "settings", "services", "media", "faces", "view", "modules", "flows", "plugins", "cm", "objects", "forms", "module", "files", "users", "gui", "mas", "cod", "items", "index", "model", "apps", "xs", "views", "links", "rooms", "agents", "cms", "cells", "args", "features", "config", "blocks", "codes", "gl", "chains", "id", "women", "ima", "xml", "Model", "ids", "projects", "names", "dem", "rules", "members", "groups", "parents", "sql", "im", "keys", "images", "custom", "params", "bug"], "default_model": ["Default_module", " default_service", "defaultusermodule", " default_models", "default_method", "Default_models", "default_models", "defaultusermethod", "default_service", "defaultuserservice", "default_module", "Default_model", "defaultusermodel", "Default_method", "defaultusermodels"], "i": ["uri", "bi", "x", "qi", "gu", "ai", "phi", "hi", "ie", "d", "pi", "id", "cli", "ni", "xi", "p", "h", "end", "it", "fi", "source", "gi", "ei", "m", "init", "j", "name", "ix", "ini", "in", "iu", "I", "count", "o", "key", "v", "si", "ri", "a", "ti", "code", "f", "r", "mi", "type", "ii", "di", "ind", "multi", "zi", "l", "val", "oi", "yi", "ci", "w", "start", "c", "b", "eni", "one", "mu", "data", "info", "io", "n", "index", "ip", "ui", "e", "api", "diff", "inner", "y", "li", "u"]}}
{"project": "qemu", "commit_id": "1ee24514aed34760fb2863d98bea3a1b705d9c9f", "target": 1, "func": "static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)\n\n{\n\n    NvmeNamespace *ns;\n\n    uint32_t nsid = le32_to_cpu(cmd->nsid);\n\n\n\n    if (nsid == 0 || nsid > n->num_namespaces) {\n\n        return NVME_INVALID_NSID | NVME_DNR;\n\n    }\n\n\n\n    ns = &n->namespaces[nsid - 1];\n\n    switch (cmd->opcode) {\n\n    case NVME_CMD_FLUSH:\n\n        return nvme_flush(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE_ZEROS:\n\n        return nvme_write_zeros(n, ns, cmd, req);\n\n    case NVME_CMD_WRITE:\n\n    case NVME_CMD_READ:\n\n        return nvme_rw(n, ns, cmd, req);\n\n    default:\n\n        return NVME_INVALID_OPCODE | NVME_DNR;\n\n    }\n\n}\n", "idx": 21296, "substitutes": {"n": ["i", "name", "net", "e", "un", "en", "conn", "yn", "config", "nn", "g", "d", "node", "f", "dn", "t", "y", "N", "nc", "m", "s", "u", "r", "j", "p", "na", "o", "np", "client", "c", "network", "self", "cn", "num", "b", "w", "nb", "v", "z", "nt", "fn", "sn", "nu", "l", "x", "ne", "mn", "nm", "k"], "cmd": ["md", "request", "grad", "cd", "cc", "def", "conn", "bind", "obj", "config", "input", "pkg", "ctr", "cookie", "mode", "ack", "d", "qq", "node", "cl", "cmp", "op", "Cmd", "msg", "cp", "m", "init", "head", "args", "dr", "cf", "id", "ctrl", "code", "q", "cli", "mac", "client", "c", "ctx", "cb", "gen", "num", "cfg", "dom", "module", "xml", "cn", "dc", "w", "cr", "comm", "qt", "nt", "ck", "cod", "h", "resp", "command", "prop", "vc"], "req": ["md", "str", "request", "reg", "ru", "row", "grad", "def", "response", "ref", "err", "progress", "ctr", "rx", "crit", "rec", "rr", " request", "qq", "cur", "rf", "required", "get", "cook", "r", "ok", "res", "cache", "method", "ret", "q", "rw", "client", "cb", "require", "ctx", "pro", "rt", "pull", "w", "seq", "cr", "call", "gr", "proc", "http", "conf", "ry", "user", "orig", "rb", "resp", "requ"], "ns": ["nets", "net", "syn", "outs", "nav", "qs", "sk", "conn", "fs", "coll", "xs", "lines", "nas", "ks", "ds", "names", "sys", "nc", "s", "os", "ys", "vs", "cs", "na", "mc", "ls", "sync", "ains", "c", "ctx", "xml", "cn", "si", "sts", "nw", "w", "ms", "ims", "Ns", "ps", "gs", "ne", "nt", "bs", "sn", "sp", "ips", "NS", "ss", "nos"]}}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)\n\n{\n\n    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);\n\n    object_unparent(OBJECT(&pbdev->iommu_mr));\n\n    pbdev->iommu_enabled = false;\n\n}\n", "idx": 24201, "substitutes": {"pbdev": ["pcver", "sbapp", "pbver", "labdiv", "sbconf", "sbdef", "cbdata", "pbdef", "pcdata", "cbdev", "pbtest", "cbver", "pbadv", "bbadv", "fbapp", "pbdevice", "refdevice", "sbdevice", "PBdevice", "pcdevice", "bbdev", "pdevice", "PBapp", "pconf", "pbapp", "refdev", "pcdiv", "PBadv", "pcadv", "pbdiv", "cbdiv", "pcconf", "cbtest", "sbdev", "refdata", "reftest", "PBconf", "labdev", "bbdevice", "pbconf", "PBdev", "fbdev", "pdef", "PBdef", "fbdevice", "cbdevice", "labver", "pctest", "bbconf", "pcdev", "pbdata", "pdev", "labdevice"]}}
{"project": "FFmpeg", "commit_id": "64f7db554ee83846f207e82a08946a6a5a6acfe2", "target": 1, "func": "static int mpegts_write_header(AVFormatContext *s)\n\n{\n\n    MpegTSWrite *ts = s->priv_data;\n\n    MpegTSWriteStream *ts_st;\n\n    MpegTSService *service;\n\n    AVStream *st, *pcr_st = NULL;\n\n    AVDictionaryEntry *title, *provider;\n\n    int i, j;\n\n    const char *service_name;\n\n    const char *provider_name;\n\n    int *pids;\n\n    int ret;\n\n\n\n    if (s->max_delay < 0) /* Not set by the caller */\n\n        s->max_delay = 0;\n\n\n\n    // round up to a whole number of TS packets\n\n    ts->pes_payload_size = (ts->pes_payload_size + 14 + 183) / 184 * 184 - 14;\n\n\n\n    ts->tsid = ts->transport_stream_id;\n\n    ts->onid = ts->original_network_id;\n\n    /* allocate a single DVB service */\n\n    title = av_dict_get(s->metadata, \"service_name\", NULL, 0);\n\n    if (!title)\n\n        title = av_dict_get(s->metadata, \"title\", NULL, 0);\n\n    service_name  = title ? title->value : DEFAULT_SERVICE_NAME;\n\n    provider      = av_dict_get(s->metadata, \"service_provider\", NULL, 0);\n\n    provider_name = provider ? provider->value : DEFAULT_PROVIDER_NAME;\n\n    service       = mpegts_add_service(ts, ts->service_id,\n\n                                       provider_name, service_name);\n\n\n\n    if (!service)\n\n        return AVERROR(ENOMEM);\n\n\n\n    service->pmt.write_packet = section_write_packet;\n\n    service->pmt.opaque       = s;\n\n    service->pmt.cc           = 15;\n\n\n\n    ts->pat.pid          = PAT_PID;\n\n    /* Initialize at 15 so that it wraps and is equal to 0 for the\n\n     * first packet we write. */\n\n    ts->pat.cc           = 15;\n\n    ts->pat.write_packet = section_write_packet;\n\n    ts->pat.opaque       = s;\n\n\n\n    ts->sdt.pid          = SDT_PID;\n\n    ts->sdt.cc           = 15;\n\n    ts->sdt.write_packet = section_write_packet;\n\n    ts->sdt.opaque       = s;\n\n\n\n    pids = av_malloc_array(s->nb_streams, sizeof(*pids));\n\n    if (!pids) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    /* assign pids to each stream */\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        st = s->streams[i];\n\n\n\n        ts_st = av_mallocz(sizeof(MpegTSWriteStream));\n\n        if (!ts_st) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        st->priv_data = ts_st;\n\n\n\n        ts_st->user_tb = st->time_base;\n\n        avpriv_set_pts_info(st, 33, 1, 90000);\n\n\n\n        ts_st->payload = av_mallocz(ts->pes_payload_size);\n\n        if (!ts_st->payload) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        ts_st->service = service;\n\n        /* MPEG pid values < 16 are reserved. Applications which set st->id in\n\n         * this range are assigned a calculated pid. */\n\n        if (st->id < 16) {\n\n            ts_st->pid = ts->start_pid + i;\n\n        } else if (st->id < 0x1FFF) {\n\n            ts_st->pid = st->id;\n\n        } else {\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Invalid stream id %d, must be less than 8191\\n\", st->id);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        if (ts_st->pid == service->pmt.pid) {\n\n            av_log(s, AV_LOG_ERROR, \"Duplicate stream id %d\\n\", ts_st->pid);\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        for (j = 0; j < i; j++) {\n\n            if (pids[j] == ts_st->pid) {\n\n                av_log(s, AV_LOG_ERROR, \"Duplicate stream id %d\\n\", ts_st->pid);\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n        }\n\n        pids[i]                = ts_st->pid;\n\n        ts_st->payload_pts     = AV_NOPTS_VALUE;\n\n        ts_st->payload_dts     = AV_NOPTS_VALUE;\n\n        ts_st->first_pts_check = 1;\n\n        ts_st->cc              = 15;\n\n        /* update PCR pid by using the first video stream */\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n            service->pcr_pid == 0x1fff) {\n\n            service->pcr_pid = ts_st->pid;\n\n            pcr_st           = st;\n\n        }\n\n        if (st->codec->codec_id == AV_CODEC_ID_AAC &&\n\n            st->codec->extradata_size > 0) {\n\n            AVStream *ast;\n\n            ts_st->amux = avformat_alloc_context();\n\n            if (!ts_st->amux) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            ts_st->amux->oformat =\n\n                av_guess_format((ts->flags & MPEGTS_FLAG_AAC_LATM) ? \"latm\" : \"adts\",\n\n                                NULL, NULL);\n\n            if (!ts_st->amux->oformat) {\n\n                ret = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            if (!(ast = avformat_new_stream(ts_st->amux, NULL))) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            ret = avcodec_copy_context(ast->codec, st->codec);\n\n            if (ret != 0)\n\n                goto fail;\n\n            ast->time_base = st->time_base;\n\n            ret = avformat_write_header(ts_st->amux, NULL);\n\n            if (ret < 0)\n\n                goto fail;\n\n        }\n\n        if (st->codec->codec_id == AV_CODEC_ID_OPUS) {\n\n            ts_st->opus_pending_trim_start = st->codec->initial_padding * 48000 / st->codec->sample_rate;\n\n        }\n\n    }\n\n\n\n    av_freep(&pids);\n\n\n\n    /* if no video stream, use the first stream as PCR */\n\n    if (service->pcr_pid == 0x1fff && s->nb_streams > 0) {\n\n        pcr_st           = s->streams[0];\n\n        ts_st            = pcr_st->priv_data;\n\n        service->pcr_pid = ts_st->pid;\n\n    } else\n\n        ts_st = pcr_st->priv_data;\n\n\n\n    if (ts->mux_rate > 1) {\n\n        service->pcr_packet_period = (ts->mux_rate * ts->pcr_period) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n        ts->sdt_packet_period      = (ts->mux_rate * SDT_RETRANS_TIME) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n        ts->pat_packet_period      = (ts->mux_rate * PAT_RETRANS_TIME) /\n\n                                     (TS_PACKET_SIZE * 8 * 1000);\n\n\n\n        if (ts->copyts < 1)\n\n            ts->first_pcr = av_rescale(s->max_delay, PCR_TIME_BASE, AV_TIME_BASE);\n\n    } else {\n\n        /* Arbitrary values, PAT/PMT will also be written on video key frames */\n\n        ts->sdt_packet_period = 200;\n\n        ts->pat_packet_period = 40;\n\n        if (pcr_st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (!pcr_st->codec->frame_size) {\n\n                av_log(s, AV_LOG_WARNING, \"frame size not set\\n\");\n\n                service->pcr_packet_period =\n\n                    pcr_st->codec->sample_rate / (10 * 512);\n\n            } else {\n\n                service->pcr_packet_period =\n\n                    pcr_st->codec->sample_rate / (10 * pcr_st->codec->frame_size);\n\n            }\n\n        } else {\n\n            // max delta PCR 0.1s\n\n            // TODO: should be avg_frame_rate\n\n            service->pcr_packet_period =\n\n                ts_st->user_tb.den / (10 * ts_st->user_tb.num);\n\n        }\n\n        if (!service->pcr_packet_period)\n\n            service->pcr_packet_period = 1;\n\n    }\n\n\n\n    ts->last_pat_ts = AV_NOPTS_VALUE;\n\n    ts->last_sdt_ts = AV_NOPTS_VALUE;\n\n    // The user specified a period, use only it\n\n    if (ts->pat_period < INT_MAX/2) {\n\n        ts->pat_packet_period = INT_MAX;\n\n    }\n\n    if (ts->sdt_period < INT_MAX/2) {\n\n        ts->sdt_packet_period = INT_MAX;\n\n    }\n\n\n\n    // output a PCR as soon as possible\n\n    service->pcr_packet_count = service->pcr_packet_period;\n\n    ts->pat_packet_count      = ts->pat_packet_period - 1;\n\n    ts->sdt_packet_count      = ts->sdt_packet_period - 1;\n\n\n\n    if (ts->mux_rate == 1)\n\n        av_log(s, AV_LOG_VERBOSE, \"muxrate VBR, \");\n\n    else\n\n        av_log(s, AV_LOG_VERBOSE, \"muxrate %d, \", ts->mux_rate);\n\n    av_log(s, AV_LOG_VERBOSE,\n\n           \"pcr every %d pkts, sdt every %d, pat/pmt every %d pkts\\n\",\n\n           service->pcr_packet_period,\n\n           ts->sdt_packet_period, ts->pat_packet_period);\n\n\n\n    if (ts->m2ts_mode == -1) {\n\n        if (av_match_ext(s->filename, \"m2ts\")) {\n\n            ts->m2ts_mode = 1;\n\n        } else {\n\n            ts->m2ts_mode = 0;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_freep(&pids);\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        st    = s->streams[i];\n\n        ts_st = st->priv_data;\n\n        if (ts_st) {\n\n            av_freep(&ts_st->payload);\n\n            if (ts_st->amux) {\n\n                avformat_free_context(ts_st->amux);\n\n                ts_st->amux = NULL;\n\n            }\n\n        }\n\n        av_freep(&st->priv_data);\n\n    }\n\n\n\n    for (i = 0; i < ts->nb_services; i++) {\n\n        service = ts->services[i];\n\n        av_freep(&service->provider_name);\n\n        av_freep(&service->name);\n\n        av_freep(&service);\n\n    }\n\n    av_freep(&ts->services);\n\n    return ret;\n\n}\n", "idx": 10672, "substitutes": {"s": ["l", "session", "its", "is", "m", "http", "t", "z", "gs", "parts", "set", "none", "v", "ns", "details", "hs", "spec", "settings", "sg", "ds", "si", "n", "sites", "sf", "b", "c", "e", "args", "sq", "us", "f", "sym", "sets", "es", "space", "r", "as", "u", "comments", "fs", "su", "ps", "site", "ss", "ks", "sv", "g", "stats", "ops", "d", "sa", "ls", "local", "status", "cs", "o", "sync", "south", "sb", "sys", "ions", "single", "secondary", "a", "sr", "ssl", "conf", "p", "qs", "tests", "ins", "tes", "xs", "js", "rs", "aws", "S", "services", "ches", "submit", "less", "h", "client", "ses", "y"], "ts": ["tags", "utils", "tr", "its", "t", "tt", "wt", "gs", "parts", "outs", "uts", "acs", "te", "ns", "details", "ets", "settings", "ds", "ments", "tc", "types", "tf", "es", "tis", " services", "ps", "fs", "times", "ss", "ks", "test", "stats", "mods", "tips", "alls", "ops", "ls", "os", "cs", "ics", "Ts", "tx", "tp", "ats", "als", "trans", "tim", "tm", "points", "TS", "ters", "td", "vs", "ta", "files", "ims", "ports", "qs", "tests", "ins", "tes", "xs", "rs", "js", "rets", "lets", "sts", "cons", "services", "ms", "options", "bs", "tin", "events"], "ts_st": ["ats_St", "ts_sth", "ats_sth", "ats_ST", "ats_st", "ts_St", "ts_ST"], "service": ["sp", "company", "session", "it", "sv", "ds", "si", "section", "is", "source", "start", "Service", "info", "id", "license", "http", "t", "tt", "project", "serv", "server", "component", "se", "ie", "sk", "entry", "cs", "resource", "ice", "device", "py", "module", "v", "scope", "sync", "series", "space", "event", "connection", "sl", "services", "proxy", "object", "port", "support", "ns", "storage", "git", "spec", " services", "plugin", "sys", "command", "image", "vc", "use", "match", "site", "text", "ss", "skill", "y", "cy", "security"], "st": ["sp", "std", "sv", "str", "test", "stage", "src", "t", "rest", "tt", "sa", "ct", "pt", "inst", "sts", "sta", "sl", "sn", "sth", "sb", "ST", "sid", "td", "typ", "sc"], "pcr_st": ["pcr2st", "pcrsst", "pct_ST", "pcrsrest", "pcr_rest", "pcr_ST", "pcrsST", "pcr2rest", "pcr2ST", "pct_rest", "pcr_str", "pct_str", "pcrsstr", "pct_st", "pcr2str"], "title": ["alias", "company", "term", "yt", "html", "Title", "detail", "author", "comment", "prefix", "key", "shell", "note", "id", "test", "theme", "license", " titles", "tag", "template", "article", "application", "filename", "project", "doc", "metadata", "data", "head", "meta", "username", "role", "itles", "itle", "body", "label", "profile", "resource", "unit", "primary", "alpha", "journal", "scope", "description", "format", "name", "tip", "subject", "doi", "phrase", "media", "phone", "part", "details", "summary", "front", "type", "ame", "message", "header", "text"], "provider": ["authoricator", "authorator", "produator", "divider", "configiders", "generison", "providers", "provison", "authorider", "configce", "PROVide", "authoride", "provide", "divison", "promider", "prider", "produider", "PROVoker", "proker", "generide", "generator", "PROVider", "provoker", "divoker", "provoser", "generoser", "produoker", "provator", "produicator", "provce", "PROVison", "generoker", "produce", "proser", "produiders", "produide", "promiders", "divide", "configider", "generider", "pride", "produoser", "promce", "provicator", "genericator"], "i": ["l", "ui", "di", "start", "n", "si", "zi", "id", "xi", "b", "x", "ini", "d", "fi", "ji", "c", "p", "ix", "e", "eni", "f", "ie", "ai", "index", "v", "gi", "ti", "mi", "phi", "end", "chi", "qi", "jp", "pi", "bi", "ii", "u", "type", "I", "li", "ip", "ci", "ri", "depth", "iu", "ki"], "j": ["l", "je", "it", "vision", "note", "jet", "k", "z", "job", "ji", "slot", "p", "obj", "sec", "op", "ie", "v", "sync", "r", "att", "ij", "jp", "aj", "pos", "J", "rev", "jc", "ok"], "service_name": ["server_nam", "servicealname", "server_title", "plugin_name", "servicefullname", "serviceftype", "serviceOname", "service_anc", "service_size", "service_nam", " service_desc", " service_title", "server_name", "service_title", "serviceftitle", "service_secret", "serviceFsize", "service_type", "plugin_size", "servicealtitle", "service_desc", "servicefulldesc", "servicefnam", "plugin_secret", "serviceOsecret", "server_type", "servicefname", "plugin_anc", "serviceOanc", "serviceFsecret", "servicealtype", "servicealnam", "serviceOsize", "serviceFname", "servicefulltitle", "serviceFanc"], "provider_name": ["provider1description", "provifier_number", "provifieracnumber", "proviser1description", "provider_named", "provideracname", "provideracbase", "provider_names", "provideracnumber", "providers_named", "providersid", "provider1name", "provider_number", "providersname", "proviser_names", "providerUnumber", "provider_description", "provider_code", "providerUcode", "provider_base", "proviser_description", "provider1names", "providerUname", "provifieracbase", "providers_code", "proviser1names", "provifieraccode", "provifier_name", "provider_id", "proviser_name", "provideraccode", "providerscode", "provifieracname", "proviser1name", "providers_name", "providerUbase", "providersnamed", "provifier_base", "provifier_code", "providers_id"], "pids": ["Pid", "bicks", "ppods", "cpips", "bids", "cpods", "pases", "cpid", "pips", " pid", "bid", " pips", "pid", "pods", "Pids", "cpids", "Picks", " pipes", "ppids", " pods", "ppases", "pipes", "bips", "ppipes", "Pips", "Pipes", "picks", "ppid", " pases", "Pods", " picks", "Pases", "ppips"], "ret": ["seq", "arr", "str", "alt", "val", "len", "Ret", " Ret", "mem", "vt", "reply", "lit", "util", "status", "secret", "gt", "rets", "sec", "ut", "rt", "res", "det", "fun", "att", "r", "get", "cat", "re", "RET", "back", " RET", "url", "result", "ft", "match", "success", "pet"]}}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)\n\n{\n\n    int64_t start, size, last_size;\n\n    start= url_ftell(bc) - prefix_length;\n\n\n\n    if(start != nut->packet_start + nut->written_packet_size){\n\n        av_log(nut->avf, AV_LOG_ERROR, \"get_packetheader called at weird position\\n\");\n\n        return -1;\n\n    }\n\n    \n\n    if(calculate_checksum)\n\n        init_checksum(bc, update_adler32, 0);\n\n\n\n    size= get_v(bc);\n\n    last_size= get_v(bc);\n\n    if(nut->written_packet_size != last_size){\n\n        av_log(nut->avf, AV_LOG_ERROR, \"packet size missmatch %d != %lld at %lld\\n\", nut->written_packet_size, last_size, start);\n\n        return -1;\n\n    }\n\n\n\n    nut->last_packet_start = nut->packet_start;\n\n    nut->packet_start = start;\n\n    nut->written_packet_size= size;\n\n\n\n    return size;\n\n}\n", "idx": 7777, "substitutes": {"nut": ["bolt", "cro", "utt", "cart", "stone", "cot", "gob", "ore", "ctr", "error", "nat", "ou", "boot", "ft", "nav", "ct", "dt", "uts", "conn", "pot", "ocr", "aug", "nuts", "nov", "nt", "config", "gat", "art", "missing", "orb", "dist", "oren", "nova", "nit", "lib", "ut", "node", "cn", "adr", "cod", "text", "nv", "cut", "nw", "rt", "bd", "note", "rot", "cat", "knife", "winner", "ext", "obj", "oven", "np", "fit", "feat", "ox", "transfer", "cit", "creator", "contract", "gt", "core", "ot", "fat", "od", "Nut", "piece", "bt", "kt", "category", "dc", "n", "cb", "root", "cdn", "orn"], "bc": ["oc", "BC", "gc", "cgi", "anc", "ocr", "cr", "bd", "rb", "config", "bt", "com", "nc", "rc", "cca", "uc", "loc", "orb", "fb", "db", "mac", "cl", "BBC", "ucc", "soc", "org", "pc", "sc", "mc", "dc", "lib", "ctx", "cb", "cms", "exec", "context", "ec", "gb", "c", "bf", "ct", "lc", "fc", "CBC", "bitcoin", "src", "cot", "cm", "tc"], "prefix_length": ["padding_offset", "prefixallen", "prefixlenlen", "prefix_offset", " prefix_size", "prefixlensize", "prefixalrequired", "padding_length", "padding_required", "prefixallength", " prefix_len", "padding_len", "prefix_len", "prefixlenlength", "prefix_size", "prefixaloffset", "prefix_required"], "calculate_checksum": ["calculate_hsup", "calculate_cksums", "calculate_cksam", "calculate_ckssum", "calculate_checksup", "calculate_cksum", "calculate_csum", "calculate_cksup", "calculate_hssum", "calculate_checksums", "calculate_csam", "calculate_csums", "calculate_cssum", "calculate_hsum", "calculate_checksam", "calculate_checkssum", "calculate_hsam"], "start": ["base", "address", "started", "name", "st", "store", "change", "id", "count", "try", "open", "send", "check", "config", "get", "starting", "skip", "sum", "style", "use", "shift", "i", "ad", "info", "art", "ate", "slice", "ace", "offset", "grade", "add", "length", "state", "init", "from", "ce", "it", "len", "stop", "part", "Start", "error", "se", "pad", "load", "ie", "source", "parse", "p", "scale", "step", "pos", "ind", "c", "read", "type", "set", "index", "min", "end", "seed"], "size": ["false", "address", "give", "name", "clean", "SIZE", "extra", "time", "large", "sec", "count", "fee", "shape", "send", "grow", "ny", "sum", "data", "si", "sync", "use", "last", "i", "loc", "unit", "speed", "capacity", "offset", "length", "small", "Size", "from", "number", "code", "len", "se", "en", "full", "storage", "sized", "day", "bytes", "empty", "n", "ey", "source", "ie", "scale", "ice", "range", "new", "ize", "set", "form", "end"], "last_size": ["last_len", " last_sized", "last24length", "last_length", "last_start", "last24start", "last_sized", "last24address", " last_address", " last_length", " last_len", "last24size", " last_scale", "last_address", "last_scale", " last_start"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s,\n\n                                                     PutBitContext *pb, const float *in, float *out,\n\n                                                     const float *scaled, int size, int scale_idx,\n\n                                                     int cb, const float lambda, const float uplim,\n\n                                                     int *bits, const float ROUNDING)\n\n{\n\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    int i;\n\n    int qc1, qc2, qc3, qc4;\n\n\n\n    uint8_t  *p_bits  = (uint8_t  *)ff_aac_spectral_bits[cb-1];\n\n    uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1];\n\n    float    *p_vec   = (float    *)ff_aac_codebook_vectors[cb-1];\n\n\n\n    abs_pow34_v(s->scoefs, in, size);\n\n    scaled = s->scoefs;\n\n    for (i = 0; i < size; i += 4) {\n\n        int curidx, curidx2;\n\n        int *in_int = (int *)&in[i];\n\n        uint8_t v_bits;\n\n        unsigned int v_codes;\n\n        int t0, t1, t2, t3, t4, t5, t6, t7;\n\n        const float *vec1, *vec2;\n\n\n\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n\n\n\n        __asm__ volatile (\n\n            \".set push                      \\n\\t\"\n\n            \".set noreorder                 \\n\\t\"\n\n\n\n            \"ori    %[t4],  $zero,  4       \\n\\t\"\n\n            \"slt    %[t0],  %[t4],  %[qc1]  \\n\\t\"\n\n            \"slt    %[t1],  %[t4],  %[qc2]  \\n\\t\"\n\n            \"slt    %[t2],  %[t4],  %[qc3]  \\n\\t\"\n\n            \"slt    %[t3],  %[t4],  %[qc4]  \\n\\t\"\n\n            \"movn   %[qc1], %[t4],  %[t0]   \\n\\t\"\n\n            \"movn   %[qc2], %[t4],  %[t1]   \\n\\t\"\n\n            \"movn   %[qc3], %[t4],  %[t2]   \\n\\t\"\n\n            \"movn   %[qc4], %[t4],  %[t3]   \\n\\t\"\n\n            \"lw     %[t0],  0(%[in_int])    \\n\\t\"\n\n            \"lw     %[t1],  4(%[in_int])    \\n\\t\"\n\n            \"lw     %[t2],  8(%[in_int])    \\n\\t\"\n\n            \"lw     %[t3],  12(%[in_int])   \\n\\t\"\n\n            \"srl    %[t0],  %[t0],  31      \\n\\t\"\n\n            \"srl    %[t1],  %[t1],  31      \\n\\t\"\n\n            \"srl    %[t2],  %[t2],  31      \\n\\t\"\n\n            \"srl    %[t3],  %[t3],  31      \\n\\t\"\n\n            \"subu   %[t4],  $zero,  %[qc1]  \\n\\t\"\n\n            \"subu   %[t5],  $zero,  %[qc2]  \\n\\t\"\n\n            \"subu   %[t6],  $zero,  %[qc3]  \\n\\t\"\n\n            \"subu   %[t7],  $zero,  %[qc4]  \\n\\t\"\n\n            \"movn   %[qc1], %[t4],  %[t0]   \\n\\t\"\n\n            \"movn   %[qc2], %[t5],  %[t1]   \\n\\t\"\n\n            \"movn   %[qc3], %[t6],  %[t2]   \\n\\t\"\n\n            \"movn   %[qc4], %[t7],  %[t3]   \\n\\t\"\n\n\n\n            \".set pop                       \\n\\t\"\n\n\n\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n\n              [t4]\"=&r\"(t4), [t5]\"=&r\"(t5), [t6]\"=&r\"(t6), [t7]\"=&r\"(t7)\n\n            : [in_int]\"r\"(in_int)\n\n            : \"memory\"\n\n        );\n\n\n\n        curidx = 9 * qc1;\n\n        curidx += qc2 + 40;\n\n\n\n        curidx2 = 9 * qc3;\n\n        curidx2 += qc4 + 40;\n\n\n\n        v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]);\n\n        v_bits  = p_bits[curidx] + p_bits[curidx2];\n\n        put_bits(pb, v_bits, v_codes);\n\n\n\n        if (out) {\n\n           vec1 = &p_vec[curidx*2 ];\n\n           vec2 = &p_vec[curidx2*2];\n\n           out[i+0] = vec1[0] * IQ;\n\n           out[i+1] = vec1[1] * IQ;\n\n           out[i+2] = vec2[0] * IQ;\n\n           out[i+3] = vec2[1] * IQ;\n\n        }\n\n    }\n\n}\n", "idx": 6778, "substitutes": {"s": ["sets", "sed", "v", "is", "S", "a", "spec", "sg", "scope", "session", "b", "si", "sync", "sys", "ses", "services", "f", "ns", "stats", "sl", "ls", "service", "cs", "ss", "conf", "sc", "sb", "ops", "gs", "ts", "su", "self", "p", "south", "settings", "this", "sv", "utils", "c", "os", "g", "ssl", "sq", "sa", "new", "src", "rs", "sup", "ps", "js"], "pb": ["abc", "cp", "bp", "rb", "kB", "pd", "bps", "pp", "rc", "wp", "bm", "lp", "fb", "pm", "pg", "mp", "prot", "pc", "sb", "bc", "PB", "amp", "PC", "gb", "proc", "cv", "pl", "cpp"], "in": ["login", "inf", "bin", "ins", "id", "pin", "config", "x", "inn", "data", "rec", "din", "circ", "image", "m", "inc", "f", "nin", "gin", "init", "IN", "con", "scan", "win", "isin", "err", "vin", "ini", "pass", "In", "source", "input", "into", "again", "c", "lin", "query", "inner", "src", "img", "conn"], "out": ["OUT", "o", "bin", "b", "data", "bit", "image", "m", "inc", "f", "at", "call", "init", "w", "cmd", "outs", "result", "source", "temp", "output", "doc", "Out", "new", "g", "r", "external"], "scaled": ["SCalled", "Scaled", "oscaling", "Scalled", "captaling", "escured", "oscalled", " scaling", "scraped", "SCaling", "SCaled", "oscaled", " scalled", "captaled", "escalled", "escaled", "escared", "scared", "scalled", "descaled", "SCraped", " scraped", "scaling", "Scaling", "escaling", "SCured", "descalled", "SCaped", "captured", "scaped", "Scared", "descaped", "Scraped", "oscaped", "escaped", "descared", "Scaped", "scured", " scaped", "captalled"], "size": ["uni", "ch", "SIZE", "sec", "shape", "sum", "sn", "co", "loc", "ix", "grade", "small", "Size", "q", "cs", "six", "code", "len", "sc", "sh", "dc", "sized", "ctx", "bc", "scale", "z", "c", "sq", "iz", "ize", "cm", "shift"], "scale_idx": ["scale_sidn", "scale_fdxx", "scale_idxx", "scale_mainx", "scale_ridX", "scale_fdced", "scale_idsn", "scale_sidg", "scale_idced", "scale_ridct", "scale_headz", "scale_idg", "scale_headced", "scale_mainct", "scale_idsced", "scale_sidz", "scale_idsx", "scale_headx", "scale_idX", "scale_idz", "scale_fdx", "scale_idp", "scale_mainp", "scale_ridx", "scale_idsz", "scale_idsxx", "scale_idsg", "scale_fdz", "scale_idn", "scale_ridp", "scale_sidx", "scale_headxx", "scale_idct", "scale_mainX"], "cb": ["CB", "cp", "cmp", "cgi", "buff", "cr", "fee", "obb", "ci", "rb", "crop", "ob", "nc", "com", "repeat", "sync", "kk", "loc", "cm", "buf", "db", "wb", "fb", "job", "abb", "call", "bb", "ctr", "conf", "cpp", "code", "sb", "dc", "cor", "lib", "ctx", "hh", "bc", "nb", "callback", "seq", "btn", "gb", "bf", "cf", "core", "lc", "cv", "cod", "desc", "src", "ctrl", "cd", "ff"], "lambda": ["abc", " mu", "alpha", "la", "beta", " dim", " disp", "nc", "inv", "appa", " gamma", "phi", " la", " lam", "da", "func", "dc", "bc", " omega", "DEF", "qa", "LA", "igma", " sig", "aux", "mu", " delta"], "uplim": ["uplike", "Uplib", "ulabib", "Uplim", "Uclen", "uclen", "Uplen", "ulaben", "uclim", "Uclib", "ublen", "ublib", "Uclim", "Uclike", "Uplike", "ublim", "uclike", "ublike", "ulabike", "uplen", "uclib", "uplib", "ulabim"], "bits": ["bands", "features", "config", "bps", "bit", "rows", "its", "ips", "details", "pins", "hours", "codes", "parts", "forces", "cycles", "bs", "ints", "ops", "bis", "bytes", "jobs", "fps", "blocks", "pieces", "gb", "pos", "flags"], "ROUNDING": ["ROUNDED", "Brounding", "BOUND32", "RUN32", "Rrounding", "RUNing", "RroundED", "BOUNDING", "BOUNDED", "RoundingED", "Rounding32", "ROUNDing", "Roundinging", "BroundING", "RUNING", "Rround32", "RroundING", "BOUNDing", "Bround32", "RoundingING", "BroundED", "ROUND32", "RUNED"], "i": ["gi", "ei", "ti", "iq", "id", "I", "chi", "is", "min", "di", "a", "ci", "ni", "xi", "x", "si", "slice", "io", "abi", "info", "bi", "qi", "ix", "l", "key", "f", "pi", "yi", "phi", "j", "ii", "iu", "ij", "it", "ai", "my", "e", "uri", "k", "n", "multi", "mi", "ini", "ie", "p", "jit", "mini", "z", "eni", "iv", "oi", "c", "ip", "ind", "g", "y", "type", "li", "inner", "fi", "index", "zi", "idi", "mu", "ui"], "qc1": ["qf0", "qc11", "qe11", "qdc6", " qdc0", "qsc6", "qe2", "qsc1", "qdc11", " qc0", "qdc0", "qdc2", "qpc5", "Qdc6", "qsc2", "Qdc5", "qpc2", "qf11", " qdc1", "Qc6", "Qc2", " qdc2", "qc6", "qpc1", "qe0", "qc5", "qdc5", "qpc6", "qf1", " qdc11", "qf2", "Qc5", "qsc5", " qc11", "qe1", "Qc1", "Qdc1", "Qdc2", "qdc1", "qc0"], "qc2": ["qac92", "qc92", "ph2", "Qc92", "qe2", "qcc2", "pc2", "qdc2", "ph4", "qac2", "qe62", "pc62", "qdc4", "pc0", "qh0", "Qc2", "Qdc92", "qv2", "qc62", "qac4", "qv0", "qdc92", "qv4", "pc4", "qcc02", "qh62", "Qdc4", "qh2", "Qc4", "ph62", "Qdc02", "ph0", "qh4", "Qc02", "qcc92", "qac02", "qe4", "qdc02", "Qdc2", "qc02", "qcc4", "qe0", "qc0", "qv62"], "qc3": [" qe3", " qc7", "qe8", "qp21", " qc8", " qe7", " qc13", "qe7", "qc13", "qp4", "qc43", "qlc43", "qcenter13", "qp8", "qlc7", "qe3", " qe13", " qe8", "qcenter21", " qe43", " qc21", "qlc4", "qp3", "qc7", "qcenter8", "qc21", "qe21", " qc43", "qp43", "qp7", "qc8", "qlc3", "qp13", " qe4", "qe43", "qe4", "qe13", "qcenter3", " qe21"], "qc4": ["qcr4", "qxc6", "qf0", "qrc8", "dqrc0", "qh7", " qc7", "dqrc44", "qh6", "qrc44", "qrc0", "dqc44", "dqrc8", "qc44", "qxc5", "dqc8", "qh5", " qc6", "dqc4", "qcr5", "qxc7", " qxc7", "qf4", "qlc4", "dqrc4", "qlc0", "qc7", "qlc8", " qc5", "qc6", "qcr6", "qc5", "qlc44", "qc8", " qxc4", " qxc5", "qf8", "qh4", " qxc6", "qf44", "dqc0", "qxc4", "qrc4", "qc0", "qcr7"], "p_bits": [" p_bit", " p_vals", "p_bit", " p_ints", "p_ints", "p_vals"], "p_codes": ["v_code", "p_seq", "p_code", "p_flags", "v_flags", "v_seq"], "p_vec": ["c_verts", "pvverts", "c_buf", "c_norm", "pvbuf", "pvvec", "p_verts", "p_norm", "pvnorm", "c_vec", "p_buf"], "curidx": ["Curridz", "Curidex", "Curidz", "curIDz", "curidz", "curridx", "curridX", "curIDx", "Curidx", "curridex", "CuridX", "curIDX", "curIDex", "Curridx", "curidX", "curridz", "Curridex", "CurridX", "curidex"], "curidx2": ["curIdf2", "curIdx2", "curidv1", "curidx1", "curIdfii", "curidv2", "curidyii", "curIdx1", "curIdxii", "curidfii", "curidy2", "curidf1", "curIdf1", "curidy1", "curidvii", "curidf2", "curidxii"], "in_int": ["in_bit", " in_long", " in_bit", "in_long", " in_ind", "in_ind"], "v_bits": ["v__bits", "v__codes", "v__bytes", "v_bytes", "v_vals", "v__vals", "p_bytes", "p_vals"], "v_codes": [" v_cats", "v_code", " v_code", "v_cats", "v_seq", " v_seq"], "t0": ["v00", "ta0", "ta00", "v3", "ta3", "v0", "ta1", "t00", "v1", " t00"], "t1": ["T3", "T2", "v3", "v7", "T1", "v2", "v1", "T7"], "t2": ["T2", "t22", "v4", "T22", " t22", "v2", "T4", "v22"], "t3": ["T3", " tthree", "it03", "it3", "itthree", "T03", "t03", " t03", "Tthree", "tthree"], "t4": ["T3", "T2", "T8", " t8", "v3", "v4", "v8", "v2", "T4", "t8"], "t5": ["T2", "v4", "v7", "T5", "v5", "v2", "T4", "T7"], "t6": ["T6", "t06", "T8", "ta7", "ta8", " t8", "ta6", " t06", "ta06", "t8", "T06", "T7"], "t7": ["ta07", "at07", " t77", "at729", "t77", "at7", "ta7", " t729", "at77", "ta77", "t729", "ta729", "t07", " t07"], "vec1": ["cv3", " vec3", "ven1", "ven2", "cv2", "vec3", "cv1", "ven3"], "vec2": ["vec4", " vec4", "vector4", "cv2", "cv4", "vector2", "vector1", "cv1"]}}
{"project": "qemu", "commit_id": "932e71cd57bab4e6206e1355c6425290721bbe34", "target": 0, "func": "static void fpu_init (CPUMIPSState *env, const mips_def_t *def)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MIPS_FPU_MAX; i++)\n\n        env->fpus[i].fcr0 = def->CP1_fcr0;\n\n\n\n    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));\n\n    if (env->user_mode_only) {\n\n        if (env->CP0_Config1 & (1 << CP0C1_FP))\n\n            env->hflags |= MIPS_HFLAG_FPU;\n\n#ifdef TARGET_MIPS64\n\n        if (env->active_fpu.fcr0 & (1 << FCR0_F64))\n\n            env->hflags |= MIPS_HFLAG_F64;\n\n#endif\n\n    }\n\n}\n", "idx": 474, "substitutes": {"env": ["eu", "ass", "export", "nc", "here", "enc", "inet", "code", "args", "er", "event", "err", "ec", "vs", "dev", "eval", "viron", "en", "manager", "engine", "emb", "energy", "ext", "extra", "oe", "context", "her", "ea", "end", "eng", "ef", "ce", "e", "esp", "conf", "core", "v", "ev", "init", "edge", "np", "ctx", "esc", "enable", "environment", "global", "ne", "gear", "info", "ep", "exc", "vel", "et", "loader", "cache", "el", "inst", "enter", "net", "vm", "server", "conn", "eb", "scope", "eni", "erv", "dt", "config", "exec", "cfg", "que", "console", "arch", "db", "rc", "oder"], "def": ["adv", "defined", "ass", "spec", "data", "d", "aux", "der", "end", "de", "parent", "ef", "proc", "code", "entry", "dep", "Def", "df", "info", "block", "dev", "f", "ref", "eval", "conf", "DEF", "decl", "define", "definition", "req", "cf", "gen", "val", "cfg", "init", "fi", "diff"], "i": ["ami", "li", "gi", "ni", "ii", "zi", "ji", "ui", "pi", "oi", "d", "I", "di", "n", "id", "mi", "k", "iu", "j", "y", "m", "ri", "eni", "info", "ti", "ini", "index", "multi", "ai", "ie", "ip", "l", "c", "p", "hi", "e", "f", "u", "o", "v", "ki", "qi", "b", "t", "ix", "uri", "ci", "io", "mu", "fi", "start", "si", "xi"]}}
{"project": "qemu", "commit_id": "048c74c4379789d03c857cea038ec00d95b68eaf", "target": 0, "func": "static int rtc_initfn(ISADevice *dev)\n\n{\n\n    RTCState *s = DO_UPCAST(RTCState, dev, dev);\n\n    int base = 0x70;\n\n    int isairq = 8;\n\n\n\n    isa_init_irq(dev, &s->irq, isairq);\n\n\n\n    s->cmos_data[RTC_REG_A] = 0x26;\n\n    s->cmos_data[RTC_REG_B] = 0x02;\n\n    s->cmos_data[RTC_REG_C] = 0x00;\n\n    s->cmos_data[RTC_REG_D] = 0x80;\n\n\n\n    rtc_set_date_from_host(s);\n\n\n\n    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        s->coalesced_timer =\n\n            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);\n\n#endif\n\n    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);\n\n    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);\n\n\n\n    s->next_second_time =\n\n        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;\n\n    qemu_mod_timer(s->second_timer2, s->next_second_time);\n\n\n\n    register_ioport_write(base, 2, 1, cmos_ioport_write, s);\n\n    register_ioport_read(base, 2, 1, cmos_ioport_read, s);\n\n\n\n    register_savevm(\"mc146818rtc\", base, 1, rtc_save, rtc_load, s);\n\n#ifdef TARGET_I386\n\n    if (rtc_td_hack)\n\n        register_savevm(\"mc146818rtc-td\", base, 1, rtc_save_td, rtc_load_td, s);\n\n#endif\n\n    qemu_register_reset(rtc_reset, s);\n\n    return 0;\n\n}\n", "idx": 3838, "substitutes": {"dev": ["serial", "test", "server", "cam", "def", "dd", "mod", "device", "dim", "data", "r", "development", "ver", "d", "devices", "priv", "grad", "de", "dom", " Dev", "DEV", "Dev", "m", "ve", "info", "bug", "temp", "pub", "gu", "w", "prom", "e", "dm", "f", "conf", "Device", " device", "die", "driver", "v", "o", "ev", "rad", "dem", "error", "pro", "engine", "debug", "mode"], "s": ["sg", "js", "qs", "n", "sites", "sl", "g", "ses", "ls", "sf", "storage", "sie", "self", "f", "set", "sys", "u", "changes", "an", "fs", "spec", "ts", "sb", "y", "uns", "sv", "request", "sets", "p", "state", "e", "lines", "conf", "as", "v", "less", "su", "serv", "S", "t", "session", "os", "site", "ks", "its", "hs", "sym", "plugins", "ssl", "cs", "ss", "rs", "a", "new", "r", "is", "ins", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "south", "o", "sim", "si", "server", "service", "http", "d", "ms", "side", "params", "details", "sync", "status", "l", "services", "w", "features", "stats", "b"]}}
{"project": "qemu", "commit_id": "3c529d935923a70519557d420db1d5a09a65086a", "target": 0, "func": "static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,\n\n        int64_t sector_num, uint8_t *buf, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    RawAIOCB *acb;\n\n\n\n    /*\n\n     * If O_DIRECT is used and the buffer is not aligned fall back\n\n     * to synchronous IO.\n\n     */\n\n    BDRVRawState *s = bs->opaque;\n\n\n\n    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {\n\n        QEMUBH *bh;\n\n        acb = qemu_aio_get(bs, cb, opaque);\n\n        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);\n\n        bh = qemu_bh_new(raw_aio_em_cb, acb);\n\n        qemu_bh_schedule(bh);\n\n        return &acb->common;\n\n    }\n\n\n\n    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    if (aio_read(&acb->aiocb) < 0) {\n\n        qemu_aio_release(acb);\n\n        return NULL;\n\n    }\n\n    return &acb->common;\n\n}\n", "idx": 23393, "substitutes": {"bs": ["obs", "bc", "pb", "lc", "sb", "bos", "lb", "bis", "qs", "ba", "fs", "ses", "ubs", "db", "fb", "bytes", "bid", "bl", "bes", "css", "ds", "bing", "cas", "eb", "fps", "bas", "ob", "os", "vs", "cs", "ls", "bi", "bps", "sa", "js", "b", "bits", "ns", "BS", "iss", "ps", "gs", "http", "rb", "base", "ss", "las", "gb"], "sector_num": ["section_dom", " sector_name", "sector_begin", "block_begin", "section_num", "sectoridnom", "block_name", "sector_end", " sector_length", "block_number", "block_num", "sector_dom", "sectoriddom", "sector_nom", "sectoringnom", "sectoridend", "sectoringend", " sector_number", "section_nom", "section_end", "sector_length", "sector_name", "sectoringdom", "sector_number", "sectoridnum", "sectoringnum"], "buf": ["bc", "pb", "port", "uf", "limit", "lb", "prop", "uc", "end", "ref", "config", "text", "val", "cv", "fb", "queue", "bb", "bytes", "pad", "fp", "cas", "buffer", "gb", "path", "cmd", "data", "wb", "pool", "rc", "lim", "num", "byte", "b", "mem", "blocks", "seq", "ff", "src", "length", "fd", "len", "loc", "bd", "Buffer", "ab", "batch", "feed", "buff", "bf", "proc", "array", "bag", "vec", "rb", "block", "offset", "feat", "padding"], "nb_sectors": ["nb_segments", "nb_sections", "nb_teces", "nb_vegments", "nb_beivers", "nb_pegments", "nb_veivers", "nb_pections", "nb_vections", "nb_veces", "nb_gecs", "nb_beces", "nb_secctions", "nb_veapters", "nb_secctors", "nb_begments", "nb_teivers", "nb_gectors", "nb_tegments", "nb_serctions", "nb_tectors", "nb_vectors", "nb_sercs", "nb_seces", "nb_bectors", "nb_vecs", "nb_seivers", "nb_pectors", "nb_secs", "nb_secgments", "nb_serctors", "nb_seccs", "nb_seapters", "nb_serapters", "nb_geapters", "nb_pecs", "nb_gections"], "cb": ["lc", "bc", "pb", "sb", "cd", "lb", "config", "usb", "db", "cv", "unc", "fb", "func", "bb", "function", "fp", "buffer", "cmp", "rob", "eb", "cmd", "cp", "obb", "ob", "cf", "ctrl", "tc", "abc", "code", "wb", "c", "ctx", "CB", "cfg", "b", "cpp", "gc", "src", "callback", "buff", "conf", "rb", "fn", "cod", "cgi", "gb"], "opaque": ["OPaque", "opaques", "opec", "copc", "copaques", "ipace", "ipacity", "Opac", "ipaque", " opac", "copaque", "oppaque", "iopaques", "opc", "oppacity", "opace", "pque", "Opacity", "pacity", "iopace", "pace", " opc", "ipque", "opacity", "OPec", "OPacity", "OPac", "opac", " opacity", "Opaque", "OPc", "opque", "iopacity", "copque", "copacity", "iopaque", "paque", " opec", "oppaques", "copec", "iopque", "oppque"], "acb": ["accp", "awab", " acbs", " acv", "acv", " acbf", "ACb", "ACB", "ackfb", "acca", "akb", "ocb", "ecv", "ecb", "accbe", "ackbb", "ocbs", "accn", "ecf", "ainpl", "acB", " acp", "accab", "accv", "acab", "acfb", "ack", "ancp", "aca", "sacob", " acn", "accb", "ecbf", "ACp", " acob", "sacbs", "ecfb", " acsb", " acB", "accf", "ancob", "sacbb", "ecn", "acsb", "ecsb", "akpl", " acfb", "agk", "akbb", " acf", "acn", "acob", "anca", "accbb", "ackbf", "sacb", "ancv", "agbe", "ancpl", "ancbe", "acf", "ainb", " aca", "ancsb", "ainob", "ocbe", "akob", "accsb", "ocbb", "ancbb", "ackb", "awa", "acpl", "acbf", "ACsb", "acp", "agp", "agb", "anck", "ancb", "acbs", "awb", "ocp", "awv", "ecB", "ecp", "eca", "ainbb", "ecbe", "acbb", "ecbb", "ACbb", "ocob", "ecab", "ock", " acbb", "acbe"], "s": ["status", "e", "bis", "sl", "fs", "ses", "services", "sys", "state", "ssl", "os", "p", "cs", "ls", "is", "stats", "sa", "sg", "settings", "c", "js", "spec", "si", "b", "service", "session", "S", "ns", "iss", "ps", "rs", "gs", "http", "secondary", "su", "ss", "states"], "bh": ["ih", "hab", "pb", "sb", "hp", "hy", "hm", "lb", "ba", "bang", "acl", "ha", "db", "fb", "bb", "bp", "dh", "bl", "lr", "fp", "sth", "ah", "ht", "kh", "adh", "bg", "obb", "aph", "bt", "abi", "rh", "bi", "wb", "uh", "af", "amb", "kk", "sh", "b", "hub", "hl", "bm", "zh", "bd", "bel", "gh", "bf", "http", "h", "xb", "ph", "abb", "hh"]}}
{"project": "FFmpeg", "commit_id": "17269bdfcdb79679f6b92024d1228e876b799a63", "target": 1, "func": "static int swf_write_trailer(AVFormatContext *s)\n\n{\n\n    SWFContext *swf = s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    AVCodecContext *enc, *video_enc;\n\n    int file_size, i;\n\n\n\n    video_enc = NULL;\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        enc = &s->streams[i]->codec;\n\n        if (enc->codec_type == CODEC_TYPE_VIDEO)\n\n            video_enc = enc;\n\n    }\n\n\n\n    put_swf_tag(s, TAG_END);\n\n    put_swf_end_tag(s);\n\n    \n\n    put_flush_packet(&s->pb);\n\n\n\n    /* patch file size and number of frames if not streamed */\n\n    if (!url_is_streamed(&s->pb) && video_enc) {\n\n        file_size = url_ftell(pb);\n\n        url_fseek(pb, 4, SEEK_SET);\n\n        put_le32(pb, file_size);\n\n        url_fseek(pb, swf->duration_pos, SEEK_SET);\n\n        put_le16(pb, video_enc->frame_number);\n\n    }\n\n    av_free(swf);\n\n    return 0;\n\n}\n", "idx": 21750, "substitutes": {"s": ["sv", "sb", "e", "types", "sym", "qs", "es", "bis", "sl", "fs", "g", "ses", "an", "xs", "sports", "d", "sets", "ops", "site", "ks", "l", "ds", "services", "f", "sys", "t", "u", "r", "args", "storage", "os", "ssl", "ts", "p", "cs", "us", "ls", "o", "sync", "is", "ss", "sa", "sg", "c", "js", "ctx", "settings", "submit", "spec", "si", "a", "b", "w", "service", "aws", "n", "S", "ns", "sup", "parser", "ps", "rs", "gs", "south", "v", "conf", "bs", "su", "sq"], "swf": ["srv", " swfx", "SWfx", "surrf", "srf", "swv", "wwrf", "slfs", "twtf", " swfs", "swfp", "SWfs", "wwf", "Swf", "srfx", " swv", "swrf", "surfs", "slf", "SWv", "Swfp", "swfr", "twfs", "surf", "svfs", "svf", "swfs", "twf", "wwfp", "slfr", "Swrf", "sltf", "Swfs", "svtf", "wwfs", "svfr", "surfp", "swtf", "twfr", "SWf", "srfs", "swfx"], "pb": ["bc", "platform", "sb", "binary", "summary", "prototype", "lb", "uf", "fc", "ref", "jp", "lp", "prot", "db", "cv", "verb", "mb", "fb", "pkg", "pm", "bb", "orb", "phrase", "pd", "bp", "pc", "plugin", "fp", "pg", "gb", "rob", "eb", "lab", "PB", "um", "tp", "ob", "p", "url", "tc", "abc", "wb", "bps", "plug", "ctx", "pl", "ib", "pro", "mp", "b", "ub", "cpp", "tmp", "hub", "fm", "dl", "bm", "parser", "ab", "bf", "bh", "rb", "vp", "xb", "api", "dp", "ppa", "pa"], "enc": ["bc", "lc", "e", "oder", "en", "ig", "esc", "conn", "uc", "eu", "sl", "ct", "iv", "g", "acl", "obj", "coll", "inc", "unc", "eng", "impl", "pc", "img", "Enc", "anc", "cel", "ea", "env", "nc", "ac", "nec", "cat", "act", "code", "rh", "rc", "c", "ext", "ctx", "equ", "sc", "ch", "ocr", "dc", "ic", "inst", "loc", "ent", "sec", "lang", "cod", "ENC", "voc", "ev", "oc", "ec", "emb", "vc"], "video_enc": ["video4ec", "video_dec", "video_fc", "videoIPent", "audio_enc", "video67enc", " video_fc", "video64enc", " video_Enc", "player_ec", "player_enc", "audio_ec", "audio_dec", "video_en", "video_encrypted", " video_encrypted", "video4ent", "player_en", "video_Enc", "videoalEnc", " video_ent", "videoalencrypted", "audio_impl", "video64en", "videoaldec", "videoalec", "video_ent", "video4enc", "video64engine", " video_end", "video_engine", "videoIPfc", "video67encrypted", "videoalenc", "videoIPec", "video67end", "video_ec", "video_end", " video_ec", "video_impl", "player_engine", "video64ec", "videoIPenc", "video67Enc", "videoalimpl", "video4fc"], "file_size": ["filexsize", "file64sum", "file_sum", "filelexexternal", "filexcount", " file_count", " file64sum", "filexspeed", " file_time", " file_sum", " file64time", "file64time", "filenamelexsize", "filelexsum", "filename_speed", "filexsum", "file___number", "filenamelexexternal", "filelexspeed", "file64size", " file64size", "file_external", "file___size", "file_count", "filename_external", "file___count", "file_number", "filexnumber", "filename_sum", "file64number", "filename_size", " file64number", " file_number", "filenamelexsum", "filextime", "file___speed", "filelexsize", "file_time", " file_speed", "filenamelexspeed", "file_speed"], "i": ["io", "lc", "e", "ix", "ie", "qi", "ind", "ri", "ui", "eni", "key", "gi", "uri", "ti", "I", "l", "f", "ci", "t", "oi", "info", "ini", "m", "phi", "j", "u", "p", "ip", "id", "vi", "bi", "o", "inner", "mi", "c", "mu", "index", "si", "ii", "in", "ji", "x", "iu", "ai", "xi", "hi", "di", "multi", "v", "yi", "li", "pi", "fi", "zi", "k", "ni", "ori"]}}
{"project": "FFmpeg", "commit_id": "bf2cba453244a74331238a472fe0e309f116f4d9", "target": 1, "func": "yuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2],\n\n                     const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n                     const int16_t *abuf[2], uint8_t *dest, int dstW,\n\n                     int yalpha, int uvalpha, int y,\n\n                     enum PixelFormat target, int hasAlpha)\n\n{\n\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],\n\n                  *abuf0 = abuf[0], *abuf1 = abuf[1];\n\n    int  yalpha1 = 4095 - yalpha;\n\n    int uvalpha1 = 4095 - uvalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < (dstW >> 1); i++) {\n\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;\n\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;\n\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;\n\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;\n\n        int A1, A2;\n\n        const void *r =  c->table_rV[V],\n\n                   *g = (c->table_gU[U] + c->table_gV[V]),\n\n                   *b =  c->table_bU[U];\n\n\n\n        if (hasAlpha) {\n\n            A1 = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 19;\n\n            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19;\n\n        }\n\n\n\n        yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                      r, g, b, y, target, hasAlpha);\n\n    }\n\n}\n", "idx": 7885, "substitutes": {"buf0": ["buf00", "buf3", "uf3", "uf00", "buffer0", "buff3", "uf50", " buf3", "buff00", "uf1", "buf50", "buff1", "buff0", " buf50", "buffer1", " buf00", "uf0", "buff50", "buffer50"], "buf1": [" buf2", "aux2", "buffOne", "bufone", "buf3", "uf3", "bufferone", "buff3", "bufferOne", " buf3", "ufOne", "buffer3", "buff2", "queueOne", "auxOne", "queue3", "uf1", "buf2", "buffone", "buff1", " bufOne", "buff0", "queueone", "buffer1", "queue1", "uf0", "bufOne", "aux1"], "ubuf0": ["abbuff0", "ubbuf0", "ubuff0", "abbuff2", "abuf25", "abuff00", "ubbuf1", "abuf00", "ubbuff0", "ubimg0", "abuf2", "ubuf10", "ubuf00", "abbuff25", "ubbuf00", "ubbuff1", "ubbuff2", "abbuff1", "ubbuf2", "ubuff10", "ubimg25", "ubbuff00", "ubbuff10", "abuff10", "ubuf2", "ubuf25", "abuf10", "ubimg2", "ubbuf25", "abuff0", "abuff1", "ubuff1", "ubuff00", "ubbuff25", "ubbuf10", "ubimg1"], "ubuf1": ["ubbuf0", "rubuf101", "abbuf01", "ubf101", "ubf01", "ubbuf1", "ubum2", "abbuf1", "ubbuff0", "abuf2", "ubef101", "ubbf1", "ubef1", "abbuf2", "ubbuff1", "ubbuff2", "ubbuf2", "ubbuf01", "ubef01", "ubuf2", "ubbf01", "ubuf01", "ubbf101", "ubum01", "abuf01", "rubef1", "rubuf01", "ubum0", "abbuf0", "ubbuff01", "ubuf101", "rubef01", "ubum1", "ubf1", "rubuf1", "rubef101"], "vbuf0": ["vfameu", "lbuf8", "vbuffee", "vfamio", "vuf1", "vbuff8", "vbuff0", "lbuf1", "vvecee", "lbuffio", "lbuffee", "vfam0", "lbuffeu", "vbufee", "vbuf2", "vbuffer0", "lbufeu", "vbufeu", "vuf2", "vuf8", "luf0", "vbuff2", "vvec0", "vfamee", "lbuff0", "vbuffeu", "lbufio", "luf1", "vbuffer1", "vbuffer2", "luf2", "lbufee", "vbuf8", "vbuff1", "lbuf2", "luf8", "lbuf0", "vuf0", "vbuffer8", "vveceu", "vbufio", "vvecio", "vbuffio"], "vbuf1": ["hbuff2", "vconfigOne", "vuf1", "vufOne", "vbuff0", "hbuf0", "ubufOne", "vbuf2", "vbuffer0", "vuf2", "hbuffOne", "hbuf1", "vbufOne", "vbuffOne", "vbuff2", "vconfig1", "vbuffer1", "hbuff0", "vbuffer2", "vbuff1", "hbuff1", "vuf0", "hbuf2", "ubuff1", "hbufOne", "ubuffOne", "vbufferOne"], "abuf0": ["abbuff0", "abimg2", "abuf4", "absuff1", "abuc00", "bbuf1", "abbuff4", "abbuff2", "abuc1", "absuf00", "abuff00", "abbuf1", "abuf00", "bbuf4", "abuf2", "bbuf2", "absbuff2", "abbuf2", "absbuff8", "buf4", "bbuf0", "abbuff1", "absbuff0", "absuff0", "abbuf4", "absuff00", "absuf2", "absbuff1", "buf2", "abbuff8", "abimg1", "absuf1", "abuff4", "abuf8", "absuf8", "abuff2", "abbuf0", "abbuf8", "abuc0", "abuff0", "abuff1", "abbuf00", "abimg0", "absuf0", "abimg8", "abuc2", "absuff2"], "abuf1": ["abbuff0", "abcf01", "abbufOne", "abuc3", "ubuf11", "abbuff2", "tabuf3", "abbuf01", "abuc1", "abbuf1", "ubbuff0", "fabuf1", "abuf2", "abcfOne", "abcf0", "fabbuf01", "abuu11", "fabbuf0", "fabbuf1", "abbuf2", "abuu1", "abucOne", "tabufOne", "ubbuff1", "tabuc1", "abuf11", "ubbuff2", "abbuff1", "abuff01", "abcf1", "tabuc3", "ubuf2", "abbuf3", "abufOne", "abuffOne", "ubbuff11", "tabuc0", "abuf3", "fabuf0", "fabuf01", "abef3", "abbuf11", "abuu2", "fabbufOne", "abefOne", "abuf01", "abef0", "tabucOne", "abbuff11", "abbuf0", "fabufOne", "tabuf0", "abuc0", "abuff0", "abuff1", "abef1", "abuu0", "tabuf1"], "i": ["isi", "I", "a", "chi", "di", "ci", "x", "xi", "bi", "f", "pi", "d", "ii", "my", "err", "mini", "oi", "y", "page", "li", "fi", "index", "zi", "gi", "ti", "id", "is", "slice", "info", "ix", "phi", "\u0438", "it", "ai", "ami", "uri", "mi", "ini", "ie", "z", "ip", "anti", "ui", "ni", "ri", "io", "key", "yi", "j", "cli", "u", "e", "t", "k", "p", "start", "c", "ind", "api", "idi", "mu", "v", "si", "m", "in", "qi", "l", "ij", "iu", "uli", "n", "multi", "eni", "iv"], "A1": ["AOne", "A001", "a2", "Yone", "a001", "a1", "AA4", " AOne", "AA1", "A4", "Y1", "aOne", "YOne", "AA001", "AAOne", "AAone", "AA2", " A001", " A4", " Aone", "Y4", "Aone"], "A2": ["a2", " A0", "atwo", "LA0", "LA2", "AUsecond", "AATwo", "AASecond", "AU2", "ASecond", "AAsecond", "Asecond", "APITwo", "AUSecond", "LAtwo", "A0", "APISecond", "ATwo", "Atwo", " Atwo", "AA2", "AUTwo", "APIsecond", "a0", "API2"], "r": ["o", "er", "sr", "rb", "rc", "m", "l", "ru", "f", "d", "q", "e", "w", "rg", "k", "t", "n", "rl", "p", "h", "z", "R", "re", "br", "rs"], "g": ["v", "s", "x", "m", "l", "G", "f", "ga", "d", "q", "u", "e", "w", "gs", "k", "t", "n", "go", "p", "h", "gl", "z", "gb", "c", "y", "ac", "group"], "b": ["o", "ib", "v", "a", "s", "rb", "x", "ob", "l", "f", "d", "u", "e", "w", "sb", "t", "k", "n", "B", "p", "be", "h", "boot", "z", "y"]}}
{"project": "qemu", "commit_id": "dfd100f242370886bb6732f70f1f7cbd8eb9fedc", "target": 0, "func": "static gboolean ga_channel_open(GAChannel *c, const gchar *path,\n\n                                GAChannelMethod method, int fd)\n\n{\n\n    int ret;\n\n    c->method = method;\n\n\n\n    switch (c->method) {\n\n    case GA_CHANNEL_VIRTIO_SERIAL: {\n\n        assert(fd < 0);\n\n        fd = qemu_open(path, O_RDWR | O_NONBLOCK\n\n#ifndef CONFIG_SOLARIS\n\n                           | O_ASYNC\n\n#endif\n\n                           );\n\n        if (fd == -1) {\n\n            g_critical(\"error opening channel: %s\", strerror(errno));\n\n            return false;\n\n        }\n\n#ifdef CONFIG_SOLARIS\n\n        ret = ioctl(fd, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI);\n\n        if (ret == -1) {\n\n            g_critical(\"error setting event mask for channel: %s\",\n\n                       strerror(errno));\n\n            close(fd);\n\n            return false;\n\n        }\n\n#endif\n\n        ret = ga_channel_client_add(c, fd);\n\n        if (ret) {\n\n            g_critical(\"error adding channel to main loop\");\n\n            close(fd);\n\n            return false;\n\n        }\n\n        break;\n\n    }\n\n    case GA_CHANNEL_ISA_SERIAL: {\n\n        struct termios tio;\n\n\n\n        assert(fd < 0);\n\n        fd = qemu_open(path, O_RDWR | O_NOCTTY | O_NONBLOCK);\n\n        if (fd == -1) {\n\n            g_critical(\"error opening channel: %s\", strerror(errno));\n\n            return false;\n\n        }\n\n        tcgetattr(fd, &tio);\n\n        /* set up serial port for non-canonical, dumb byte streaming */\n\n        tio.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP |\n\n                         INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY |\n\n                         IMAXBEL);\n\n        tio.c_oflag = 0;\n\n        tio.c_lflag = 0;\n\n        tio.c_cflag |= GA_CHANNEL_BAUDRATE_DEFAULT;\n\n        /* 1 available byte min or reads will block (we'll set non-blocking\n\n         * elsewhere, else we have to deal with read()=0 instead)\n\n         */\n\n        tio.c_cc[VMIN] = 1;\n\n        tio.c_cc[VTIME] = 0;\n\n        /* flush everything waiting for read/xmit, it's garbage at this point */\n\n        tcflush(fd, TCIFLUSH);\n\n        tcsetattr(fd, TCSANOW, &tio);\n\n        ret = ga_channel_client_add(c, fd);\n\n        if (ret) {\n\n            g_critical(\"error adding channel to main loop\");\n\n            close(fd);\n\n            return false;\n\n        }\n\n        break;\n\n    }\n\n    case GA_CHANNEL_UNIX_LISTEN: {\n\n        if (fd < 0) {\n\n            Error *local_err = NULL;\n\n\n\n            fd = unix_listen(path, NULL, strlen(path), &local_err);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n        }\n\n        ga_channel_listen_add(c, fd, true);\n\n        break;\n\n    }\n\n    case GA_CHANNEL_VSOCK_LISTEN: {\n\n        if (fd < 0) {\n\n            Error *local_err = NULL;\n\n            SocketAddress *addr;\n\n            char *addr_str;\n\n\n\n            addr_str = g_strdup_printf(\"vsock:%s\", path);\n\n            addr = socket_parse(addr_str, &local_err);\n\n            g_free(addr_str);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n\n\n            fd = socket_listen(addr, &local_err);\n\n            qapi_free_SocketAddress(addr);\n\n            if (local_err != NULL) {\n\n                g_critical(\"%s\", error_get_pretty(local_err));\n\n                error_free(local_err);\n\n                return false;\n\n            }\n\n        }\n\n        ga_channel_listen_add(c, fd, true);\n\n        break;\n\n    }\n\n    default:\n\n        g_critical(\"error binding/listening to specified socket\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 2265, "substitutes": {"c": ["cm", "call", "cs", "channel", "l", "conn", "cc", "mc", "r", "d", "n", "co", "cat", "bc", "cy", "con", "k", "client", "enc", "g", "ac", "m", "cr", "ch", "cod", "C", "ec", "dc", "ce", "h", "p", "cv", "xc", "cu", "e", "lc", "f", "jc", "self", "w", "cn", "ca", "sc", "cd", "exec", "col", "vc", "pc", "v", "cp", "cmp", "b", "ci", "can"], "path": ["walk", "mount", "name", "key", "anc", "context", "txt", "data", "url", "filename", "loc", "type", "prop", "id", "parent", "end", "enc", "directory", "inner", "Path", "file", "dest", "pattern", "pointer", "config", "temp", "feed", "PATH", "p", "w", "text", "ath", "handler", "cmd", "wd", "prefix", "full", "location", "mode", "root", "dir", "rh", "port"], "method": ["route", "call", "this", "name", "version", "channel", "time", "mod", "context", "process", "url", "class", "send", "header", "operation", "type", "prop", "month", "format", "METHOD", "record", "fn", "end", "instance", "model", "package", "m", "direction", "tr", "md", "status", "config", "func", "function", "h", "man", "block", "attr", "text", "message", "eth", "mp", "cmd", "round", "sign", "sort", "module", "session", "manager", "Method", "transform", "nom", "me", "mode", "rh"], "fd": ["dn", "fed", "xd", "dl", "director", "file", "sf", "direction", "cod", "feed", "ind", "f", "fm", "fee", "af", "dir", "fi", "fs", "wat", "fun", "ld", "ff", "da", "pd", "raf", "ln", "buf", "fp", "fe", "hd", "length", "bd", " fid", "handler", "wd", "ird", "vd", "td", "nd", "fc", "FD", "sd", "fw", "loc", "ad", "fan", "cb", "cond", "ds", "pid", "func", "function", "writer", "front", "fx", "wind", "cf", "dd", "fen", "fa", "d", "lf", "fl", "fn", "draft", "dy", "df", "ft", "fr", "dt", "md", "bf", "dc", "wb", "draw", "cd", "fat", "fb", "dat", "gd", "db"], "ret": ["match", "arg", "fun", "att", "mt", "ext", "def", "bit", " Ret", "success", "data", "url", "xt", "alt", "cat", "pet", "rets", "fit", "arr", "pass", " RET", "fail", "bl", "code", "lt", "nt", "ft", "rev", "back", "reply", "status", "Ret", "rc", "bf", "pat", "pub", "result", "len", "red", "flag", "f", "ref", "rl", "gt", "resp", "art", "obj", "sr", "RET", "al", "lit", "reg", "re", "val", "rt", "run", "af", "let", "part", "det", "res", "mem"], "tio": ["gio", "tauto", "fortios", " tao", "Tiao", "Tiol", "torao", "tiao", "dtios", "tigo", "Tfolio", "torios", "dtior", "untios", "Tauto", "dicho", "torui", "untio", "ttios", "bitigo", " tcho", "piol", "Tco", "tco", "tiol", "pios", " trio", "Ttimeout", "Trio", "Tigo", " tout", "dco", "atio", " tco", " tfolio", " tui", "atiol", "dio", "tui", "gios", "bitios", " tior", "untrio", " tigo", "Tior", "tout", "ttimeout", "atios", "untout", "fui", "giao", "fio", "tcho", " ticho", "forttimeout", "bitauto", "fortio", "tao", "Tout", "dtio", " tiao", "ttio", "Ticho", "dtiao", "bitio", " tauto", "fao", " ttimeout", "trio", "fortfolio", "tios", " tios", "tior", "pio", "ttcho", "atior", "torio", "gcho", "dios", "tfolio", "ttiao", "ticho", "Tios", "pior", "dtimeout", "Tio", "fios"]}}
{"project": "qemu", "commit_id": "ff74f33c310892c90c4439d963a6ce67f47ce18c", "target": 1, "func": "static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,\n\n                              const char *desc_file_path, Error **errp)\n\n{\n\n    int ret;\n\n    char access[11];\n\n    char type[11];\n\n    char fname[512];\n\n    const char *p = desc;\n\n    int64_t sectors = 0;\n\n    int64_t flat_offset;\n\n    char extent_path[PATH_MAX];\n\n    BlockDriverState *extent_file;\n\n    BDRVVmdkState *s = bs->opaque;\n\n    VmdkExtent *extent;\n\n\n\n    while (*p) {\n\n        /* parse extent line:\n\n         * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET\n\n         * or\n\n         * RW [size in sectors] SPARSE \"file-name.vmdk\"\n\n         */\n\n        flat_offset = -1;\n\n        ret = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64,\n\n                access, &sectors, type, fname, &flat_offset);\n\n        if (ret < 4 || strcmp(access, \"RW\")) {\n\n            goto next_line;\n\n        } else if (!strcmp(type, \"FLAT\")) {\n\n            if (ret != 5 || flat_offset < 0) {\n\n                error_setg(errp, \"Invalid extent lines: \\n%s\", p);\n\n                return -EINVAL;\n\n            }\n\n        } else if (!strcmp(type, \"VMFS\")) {\n\n            if (ret == 4) {\n\n                flat_offset = 0;\n\n            } else {\n\n                error_setg(errp, \"Invalid extent lines:\\n%s\", p);\n\n                return -EINVAL;\n\n            }\n\n        } else if (ret != 4) {\n\n            error_setg(errp, \"Invalid extent lines:\\n%s\", p);\n\n            return -EINVAL;\n\n        }\n\n\n\n        if (sectors <= 0 ||\n\n            (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") &&\n\n             strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) ||\n\n            (strcmp(access, \"RW\"))) {\n\n            goto next_line;\n\n        }\n\n\n\n        path_combine(extent_path, sizeof(extent_path),\n\n                desc_file_path, fname);\n\n        extent_file = NULL;\n\n        ret = bdrv_open(&extent_file, extent_path, NULL, NULL,\n\n                        bs->open_flags | BDRV_O_PROTOCOL, NULL, errp);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        /* save to extents array */\n\n        if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) {\n\n            /* FLAT extent */\n\n\n\n            ret = vmdk_add_extent(bs, extent_file, true, sectors,\n\n                            0, 0, 0, 0, 0, &extent, errp);\n\n            if (ret < 0) {\n\n\n                return ret;\n\n            }\n\n            extent->flat_start_offset = flat_offset << 9;\n\n        } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) {\n\n            /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/\n\n            char *buf = vmdk_read_desc(extent_file, 0, errp);\n\n            if (!buf) {\n\n                ret = -EINVAL;\n\n            } else {\n\n                ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf, errp);\n\n            }\n\n            if (ret) {\n\n                g_free(buf);\n\n\n                return ret;\n\n            }\n\n            extent = &s->extents[s->num_extents - 1];\n\n        } else {\n\n            error_setg(errp, \"Unsupported extent type '%s'\", type);\n\n\n            return -ENOTSUP;\n\n        }\n\n        extent->type = g_strdup(type);\n\nnext_line:\n\n        /* move to next line */\n\n        while (*p) {\n\n            if (*p == '\\n') {\n\n                p++;\n\n                break;\n\n            }\n\n            p++;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 8793, "substitutes": {"desc": ["asc", "des", "ext", "def", " description", "info", "src", "password", "path", "rec", "d", "DES", "doc", "data", "config", "ref", "meta", "dest", "attr", "dist", "priv", "sec", "code", "dir", "sub", "Description", "description", "rc", "name", "phrase", "Desc", "dc", "esc", "text", "lc", "dep", "sc", "uc"], "bs": ["vs", "base", "bb", "ds", "bas", "b", "ab", "gs", "fb", "ls", "pb", "cb", "ins", "gb", "rb", "rs", "us", "BS", "bc", "os", "js", "obs", "cs", "bl", "bps", "bh", "las", "lb", "bis", "bi", "ns", "sb", "fs", "ses", "ps", "css", "ss", "bes", "bos"], "desc_file_path": ["desc_file__pointer", "desc_file_url", "desc_file_patch", "desc_full_path", "desc_full_name", "desc_file___name", "desc_file_location", "desc_file_pointer", "desc_file__name", "desc_full_url", "desc_file__patch", "desc_file_name", "desc_full_pointer", "desc_file___url", "desc_full_location", "desc_file___location", "desc_file___path", "desc_full_patch", "desc_file__path"], "errp": ["orderpatch", "erp", "errorc", "reqg", "errpre", "errorfp", "erg", "orderfp", "errg", "rrc", "erpre", "reqc", "erc", " errpc", "errorp", "errorP", "reqp", "errorpc", " errc", "rrp", "erpatch", "strg", "errorg", "errP", " errpatch", "errpatch", "errpc", "rrg", "orderp", "erP", " errg", "errorpre", "err", "reqfp", "erpc", "strr", " errfp", "Erp", "Erpre", "erfp", "strp", "errc", "Erc", "orderr", "strc", "ErP", " errr", "errr", "rrfp", "errfp", "errorr"], "ret": ["count", "base", "fail", "t", "ref", "arg", "reg", "gt", "code", "al", "opt", "cur", "att", "orig", "re", " RET", "let", "url", "arr", "flag", "val", "Ret", "mem", "post", "fit", "res", "bf", "det", "try", "lt", "art", "back", "mt", "str", "ext", "alt", "len", "def", "nt", "num", " Ret", "pat", "data", "reply", "status", "usr", "rt", "rc", "fun", "part", "cat", "result", "success", "pass", "valid", "info", "sur", "lit", "obj", "final", "rets", "pub", "bot", "bit", "RET", "ft", "rev", "match", "feat"], "access": ["parent", "asc", "area", "reference", "pass", "connect", "source", "na", "key", "test", "id", "view", "src", "open", "password", "class", "public", "path", "sa", "config", "ref", "escape", "qa", "ace", "attr", "request", "condition", "ec", "array", "empty", "select", "ac", "mode", "Access", "alpha", "resource", "index", "shape", "accessible", "input", "name", "object", "att", "buffer", "ga", "option", "address", "acl", "error", "cast", "ast", "ACC", "secure", "esc", "a", "url", "image", "cache", "length", "use", "security", "auth", "expr", "acc", "sc", "uc"], "type": ["parent", "session", "field", "media", "path", "t", "block", "python", "ref", "attr", "code", "call", "full", "sort", "url", "ype", "alias", "key", "total", "post", "app", "pe", "value", "types", "op", "py", "index", "non", "format", "pre", "ty", "token", "position", "error", "root", "source", "class", "test", "temp", "Type", "status", "action", "style", "flow", "share", "label", "o", "version", "shape", "size", "order", "TYPE", "area", "level", "param", "domain", "comment", "info", "by", "time", "rel", "route", "name", "track", "address", "user", "option", "platform", "null", "api", "length", "y", "family", "typ", "security"], "fname": ["sfkey", "fName", "Fnames", "Fpath", " fnames", "fnames", " fprefix", "fcpath", "fkey", "fcname", "Fprefix", "sfnames", "Fkey", "fcprefix", "fprefix", "Fname", "cpath", "fcName", "cnames", "FName", " fkey", " fpath", "fpath", "cname", "sfname", " fName"], "p": ["lp", "l", "parent", "sp", "n", "g", "m", "bp", "point", "pl", "t", "path", "b", "pa", "d", "i", "pointer", "pp", "c", "data", "python", "cp", "pb", "e", "fp", "np", "pe", "q", "P", "f", "op", "o", "v", "r", "pr", "pre", "port", "tp", "jp", "pi", "part", "pc", "error", "h", "ip", "a", "ap", "vp"], "flat_offset": ["flat___offset", "plain___pos", "plain_length", "flat_width", "flat_left", "flat00Offset", "flat00position", "flat_pos", "flat_range", "plain___length", "flat_bit", "flat___size", " flat_range", " flat_start", "flat___pos", "plain_bit", "flat___length", "slice_left", "plain_pos", "fixed64position", "flat00width", "slice_offset", "plain___offset", "plain_offset", "fixed_position", "flat00offset", "flat64offset", "flat64alias", "fixed64Offset", "flat\u00b7range", "flat_alias", "flat_off", "flat64position", "flat_Offset", "fixed_width", "plain_size", " flat_port", "fixed_Offset", "flat_position", "flat___alias", "flat64width", "flat_start", "flat___bit", "flat\u00b7offset", "flat\u00b7start", "flat64size", "fixed64width", "flat64Offset", "slice_slot", "flat_length", "flat_size", "slice_off", "plain_position", "plain_alias", "fixed64offset", "plain___bit", "flat\u00b7port", "fixed_offset", "flat___position", "flat_port", "flat_slot"], "extent_path": ["extent_data", "extant_dir", "extant_path", "extension_file", "extant_file", "extant_case", "extent_name", "extent__path", "extent__file", "extent_method", "extant_name", "extent__method", "extant_data", "extension_dir", "extent_dir", "extension_path", "extension_method", "extent__dir", "extent_case"], "extent_file": ["extent_data", "extrent_files", "extents_file", "extent_files", "extant_path", "extrent_file", "extant_file", "extents_path", "extent_name", "extent2data", "extents_filename", "extant_files", "extent2file", "extant_data", "extents_name", "extent2files", "extrent_path", "extent_filename", "extent2path", "extrent_filename"], "s": ["sp", "session", "ts", "words", "is", "ds", "rows", "stats", "b", "x", "ims", "ops", "gs", "sa", "service", "server", "ls", "se", "xs", "js", "us", "safe", "os", "cs", "sym", "sets", "S", "es", "sync", "sl", "services", "state", "ches", "ies", "ns", "storage", "blocks", "ms", "sys", "comm", "ips", "ses", "fs", "su", "site", "ps", "ss", "y", "settings", "ssl"], "extent": ["extant", "EXTent", "Extend", "ExtENT", "extENT", "Extent", "content", "Extant", "contENT", "contend", "EXTENT", "extend", "contant", "EXTend", "EXTant"]}}
{"project": "qemu", "commit_id": "1a61a9ae61cdf7b7d24c3eb711fe772c196c235e", "target": 0, "func": "int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t *hc = (uint32_t*)buf;\n\n\n\n    struct kvm_ppc_pvinfo pvinfo;\n\n\n\n    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&\n\n        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {\n\n        memcpy(buf, pvinfo.hcall, buf_len);\n\n\n\n        return 0;\n\n    }\n\n\n\n    /*\n\n     * Fallback to always fail hypercalls:\n\n     *\n\n     *     li r3, -1\n\n     *     nop\n\n     *     nop\n\n     *     nop\n\n     */\n\n\n\n    hc[0] = 0x3860ffff;\n\n    hc[1] = 0x60000000;\n\n    hc[2] = 0x60000000;\n\n    hc[3] = 0x60000000;\n\n\n\n    return 0;\n\n}\n", "idx": 10192, "substitutes": {"env": ["runner", "conf", "visor", "context", "ext", "dict", "conn", "que", "viron", "serv", "environment", "config", "server", "obj", "ace", "cli", "e", "np", "args", "ec", "priv", "eni", "ev", "exc", "ea", "virt", "exe", "req", "loader", "en", "err", "eng", "enc", "init", "esp", "cfg", "fs", "cache", "anc", "eu", "proc", "core", "eve", "exec"], "buf": ["bag", "uf", "mac", "seq", "Buffer", "base", "len", "ff", "fd", "b", "que", "mem", "pool", "fi", "data", "cp", "fb", "batch", "bd", "ref", "pb", "config", "cb", "queue", "feed", "cf", "rb", "array", "bc", "alloc", "cv", "Buff", "msg", "rc", "cas", "raw", "ctx", "blocks", "func", "vec", "buff", "cmd", "br", "buffer", "uc"], "buf_len": ["bufspos", "buf_pos", "buf_size", " buf_val", " buf_size", " buf_length", "bufsval", "buflenpos", "bufsdl", "buflendl", "buf_dl", "bufslen", "buflenlen", " buf_pos", "buf_val", " buf_dl", "bufssize", "buflenlength", "buf_length", "bufslength"], "cpu": [" cp", "cow", "cca", "processor", "conn", "gpu", "bench", "instance", "pid", "cp", "vm", "c", "cu", "computer", "np", "uci", "cn", "cf", "hw", "bc", "pai", "linux", "mc", "rc", "ctx", "pu", "pc", "cpp", "CPU", "nc", "px", "css", "cache", "lc", "proc", "core", "cus"], "cs": ["vs", "utils", "co", "ks", "ds", "conn", "gs", "c", "cp", "ls", "qs", "cf", "cn", "ec", "bc", "cc", "os", "sk", "cus", "acs", "ck", "sync", "CS", "cons", "ics", "ctx", "ns", "pc", "spec", "cms", "sys", "nc", "ca", "ci", "ps", "fs", "css", "vc", "lc", "bs", "mc", "sc", "Cs"], "hc": [" hv", "hcf", "hpc", "khc", "hardpc", "hardc", "hrc", "hhpc", "ohcf", "Hc", "Hv", "hhc", " hf", " hec", "hardcf", "whec", "hcu", "ohpc", "ohv", " hcu", "rhf", "rhc", "ohc", "hardcu", "Hcall", "Hcs", " hrc", "qf", " hpc", "qcu", "khec", " hcs", "khf", "rhcu", "whf", "whc", "ohlc", " hcf", "ohcu", "khcu", "qrc", "hlc", " hlc", "rhrc", "hv", "Hlc", "whcu", "qc", "hhcs", "hec", "hf", " hcall", "hhcall", "hcs", "Hpc", "hcall"], "pvinfo": ["pdenfam", "pevinbo", " pininfo", "pevinco", "pevinfam", "pcinbo", " pevininfo", " pevinco", "pwinfi", " pwinfi", "pinbo", "pvinfam", " pinfo", "pinfo", " pwinf", "pdenfo", "pevinfi", "pwinfo", "pvinco", " pvininfo", "pcininfo", " pevinf", "pdenf", "pvinfi", "pwinco", " pwinfam", " pvinbo", " pvinf", "pvinf", " pwinfo", "pevininfo", "pwinfam", "pcinfo", "pwininfo", "pvininfo", "pininfo", " pvinfi", " pvinco", " pinbo", "pinf", "pevinf", " pvinfam", " pevinfo", "pvinbo", "pwinf", "pcinf", "pevinfo", "pcinco", "pdenfi", " pinf"]}}
{"project": "FFmpeg", "commit_id": "1bc64c2814d409d3cc129c27c493ee915bebdc4a", "target": 1, "func": "int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n                                              int *got_picture_ptr,\n                                              AVPacket *avpkt)\n{\n    int ret;\n    *got_picture_ptr = 0;\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n        return -1;\n    avctx->pkt = avpkt;\n    apply_param_change(avctx, avpkt);\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n                                         avpkt);\n        else {\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n                                       avpkt);\n            picture->pkt_dts             = avpkt->dts;\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n            picture->width               = avctx->width;\n            picture->height              = avctx->height;\n            picture->format              = avctx->pix_fmt;\n        }\n        emms_c(); //needed to avoid an emms_c() call before every return;\n        if (*got_picture_ptr)\n            avctx->frame_number++;\n    } else\n        ret = 0;\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n     * make sure it's set correctly */\n    picture->extended_data = picture->data;\n    return ret;\n}", "idx": 372, "substitutes": {"avctx": ["ajctx", "amctx", "alconn", "afcontext", "afsync", "alcontext", "avsync", "ajsync", "avcus", "afctl", "akcmp", "avelc", "akconn", "avecca", "avcontext", "afwcs", "avca", "avalcb", "afxc", "navconn", "akctx", "afcca", "AVcca", "afcmp", "AVcontext", "avecu", "akcu", "avalcca", "ajcf", "afcv", "avectx", "amcu", "avecf", "afctx", "navctx", "aveconn", "navcf", "akcontext", "avcf", "evcas", "afconn", "ajctrl", "avcb", "abcf", "avercus", "avalcontext", "aucontext", "abcontext", "umcontext", "verctx", "ajca", "avcv", "AVcmp", "avalctrl", "avecmp", "avcas", "avalctx", "evctx", "evcu", "evcontext", "evcmp", "avewcs", "ajchan", "avxc", "afcas", "vercas", "alctx", "ajconn", "abcmp", "avecb", "umconn", "vercu", "auctx", "avalwcs", "abctx", "avctrl", "afchan", "afcu", "afctrl", "avcca", "avectl", "aflc", "afcf", "afsys", "avctl", "verlc", "aucu", "avecv", "aucf", "avwcs", "umctx", "ajctl", "ajcontext", "vercontext", "ajcus", "AVctx", "avalcv", "avconn", "avchan", "avercontext", "aveca", "vercf", "avesys", "ajcv", "avalsys", "avsys", "afcus", "avalcu", "amcmp", "alcf", "navcontext", "averchan", "evxc", "akcf", "avesync", "avecontext", "afca", "amcontext", "averctx", "akxc", "avcu", "avlc", "avcmp", "afcb", "umcf"], "picture": ["media", "base", "winner", "guide", "piece", "cam", "movie", "ctx", "ami", "service", "large", "bank", "figure", "ji", "data", "audio", "image", "share", "video", "profile", "query", "study", "frame", "camera", "package", "photo", "anti", "file", "info", "entry", "attribute", "style", "license", "storage", "parse", "feat", "config", "home", "pict", "feature", "sea", "game", "library", "ana", "summary", "definition", "comment", "shadow", "pie", "plugin", "pic", "module", "manager", "error", "statement", "family", "img", "cover", "player", "view", "import", "quote", "pause", "gif", "Picture"], "got_picture_ptr": ["got_image_struct", "got_image_address", "got_picture__addr", "got_image_ptr", "got_image_addr", "got_picture__address", "got_picture__ptr", "got_picture_reference", "got_picture_pointer", "got_picturenaddr", "got_profile_addr", "got_image_pos", "got_picturenreference", "got_image_pointer", "got_picture__offset", "got_picture_addr", "got_picturenptr", "got_image_offset", "got_picture_address", "got_picture_struct", "got_picturenpointer", "got_picture_offset", "got_profile_reference", "got_picture__pointer", "got_profile_pointer", "got_picture_pos", "got_profile_ptr"], "avpkt": ["avgpkn", "avcpdt", "avepeth", "avgpdt", "affkt", "avpake", "ajpkt", "avppct", "avspacket", "avpkn", "avlpkt", "affiece", "avpakt", "avecpqt", "avjpkn", "avcpkn", "ajdpkt", "afpct", "avfcht", "avdpkt", "avdpkh", "avepdt", "avcpet", "ajdpsk", "avlpke", "ajpsk", "avpqt", "avpacht", "avpacket", "avemeth", "avemkt", "avdpet", "avpdt", "ajdpetsk", "avpaacket", "akpaacket", "avmiece", "avepkh", "avcpnt", "avcpsk", "avfpacket", "avcpqt", "avpki", "avcpkt", "avppacket", "avemiece", "avfki", "avepki", "affacket", "avppkt", "avwke", "avfct", "avdpetsk", "avlpeth", "avfpki", "avpet", "avfke", "avfiece", "avfkt", "avpetsk", "avmkt", "avepnt", "avepkt", "avlpct", "avwcht", "akpake", "avgpkt", "avlpacket", "avecpkt", "avefpki", "avcpiece", "afpcht", "ajpetsk", "avjpdt", "avpeth", "avspcht", "avlpiece", "avpct", "avspkt", "avlpnt", "avfkh", "avpke", "avecpkn", "avdpsk", "avmnt", "avpnt", "afpkt", "akpke", "avjpqt", "avemnt", "avmeth", "avepkn", "avipetsk", "affcht", "avjpkt", "akpacket", "avipkt", "avipsk", "avfpkt", "avcpeth", "avdpki", "avpcht", "avcpetsk", "avefpacket", "akpkt", "avpkh", "akpakt", "akpacht", "affke", "avepacket", "ajpet", "avppke", "affct", "avpsk", "avefpkh", "avfacket", "avepiece", "akpcht", "avpiece", "afpacket", "avspiece", "afpke", "avfpcht", "avgpqt", "avipet", "avwacket", "avefpkt", "avwkt", "avdpacket", "avfpkh", "avfpiece", "afpiece", "avepqt", "avecpdt", "ajdpet"], "ret": ["ur", "match", "rot", "base", "arg", "fun", "att", "mt", "def", "success", "data", "get", "alt", "job", "ure", "pet", "rets", "num", "rb", "code", "ft", "nt", "rev", "back", "reply", "feat", "Ret", "rc", "bf", "result", "et", "ut", "fin", "len", "f", "ref", "flag", "gt", "art", "value", "RET", "lit", "re", "reg", "val", "rt", "det", "res"], "frame_number": ["video_no", "frameblockversion", "frame_counter", "frame_no", "frameblockno", "frameblocknumber", "video_version", "video_number", "frame_version", "video_counter", "frameblockcounter"]}}
{"project": "FFmpeg", "commit_id": "4cec43a9eeb58eb9e581a2d9d25f78e5bfbb0960", "target": 0, "func": "static int h264_slice_header_parse(H264Context *h, H264SliceContext *sl)\n\n{\n\n    const SPS *sps;\n\n    const PPS *pps;\n\n    unsigned int first_mb_in_slice;\n\n    unsigned int pps_id;\n\n    int ret;\n\n    unsigned int slice_type, tmp, i;\n\n    int last_pic_structure, last_pic_droppable;\n\n    int needs_reinit = 0;\n\n    int field_pic_flag, bottom_field_flag;\n\n    int frame_num, droppable, picture_structure;\n\n    int mb_aff_frame = 0;\n\n\n\n    first_mb_in_slice = get_ue_golomb(&sl->gb);\n\n\n\n    if (first_mb_in_slice == 0) { // FIXME better field boundary detection\n\n        if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {\n\n            ff_h264_field_end(h, sl, 1);\n\n        }\n\n\n\n        h->current_slice = 0;\n\n        if (!h->first_field) {\n\n            if (h->cur_pic_ptr && !h->droppable) {\n\n                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                          h->picture_structure == PICT_BOTTOM_FIELD);\n\n            }\n\n            h->cur_pic_ptr = NULL;\n\n        }\n\n    }\n\n\n\n    slice_type = get_ue_golomb_31(&sl->gb);\n\n    if (slice_type > 9) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"slice type %d too large at %d\\n\",\n\n               slice_type, first_mb_in_slice);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (slice_type > 4) {\n\n        slice_type -= 5;\n\n        sl->slice_type_fixed = 1;\n\n    } else\n\n        sl->slice_type_fixed = 0;\n\n\n\n    slice_type         = ff_h264_golomb_to_pict_type[slice_type];\n\n    sl->slice_type     = slice_type;\n\n    sl->slice_type_nos = slice_type & 3;\n\n\n\n    if (h->nal_unit_type  == NAL_IDR_SLICE &&\n\n        sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"A non-intra slice in an IDR NAL unit.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    pps_id = get_ue_golomb(&sl->gb);\n\n    if (pps_id >= MAX_PPS_COUNT) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", pps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!h->ps.pps_list[pps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing PPS %u referenced\\n\",\n\n               pps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!h->setup_finished) {\n\n        h->ps.pps = (const PPS*)h->ps.pps_list[pps_id]->data;\n\n    } else if (h->ps.pps != (const PPS*)h->ps.pps_list[pps_id]->data) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"PPS changed between slices\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!h->ps.sps_list[h->ps.pps->sps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing SPS %u referenced\\n\",\n\n               h->ps.pps->sps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (h->ps.sps != (const SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data) {\n\n        h->ps.sps = (SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data;\n\n\n\n        if (h->bit_depth_luma    != h->ps.sps->bit_depth_luma ||\n\n            h->chroma_format_idc != h->ps.sps->chroma_format_idc)\n\n            needs_reinit         = 1;\n\n    }\n\n\n\n    pps = h->ps.pps;\n\n    sps = h->ps.sps;\n\n\n\n    if (!h->setup_finished) {\n\n        h->avctx->profile = ff_h264_get_profile(sps);\n\n        h->avctx->level   = sps->level_idc;\n\n        h->avctx->refs    = sps->ref_frame_count;\n\n\n\n        if (h->mb_width  != sps->mb_width ||\n\n            h->mb_height != sps->mb_height * (2 - sps->frame_mbs_only_flag))\n\n            needs_reinit = 1;\n\n\n\n        h->mb_width  = sps->mb_width;\n\n        h->mb_height = sps->mb_height * (2 - sps->frame_mbs_only_flag);\n\n        h->mb_num    = h->mb_width * h->mb_height;\n\n        h->mb_stride = h->mb_width + 1;\n\n\n\n        h->b_stride = h->mb_width * 4;\n\n\n\n        h->chroma_y_shift = sps->chroma_format_idc <= 1; // 400 uses yuv420p\n\n\n\n        h->width  = 16 * h->mb_width;\n\n        h->height = 16 * h->mb_height;\n\n\n\n        ret = init_dimensions(h);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        if (sps->video_signal_type_present_flag) {\n\n            h->avctx->color_range = sps->full_range ? AVCOL_RANGE_JPEG\n\n                : AVCOL_RANGE_MPEG;\n\n            if (sps->colour_description_present_flag) {\n\n                if (h->avctx->colorspace != sps->colorspace)\n\n                    needs_reinit = 1;\n\n                h->avctx->color_primaries = sps->color_primaries;\n\n                h->avctx->color_trc       = sps->color_trc;\n\n                h->avctx->colorspace      = sps->colorspace;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (h->context_initialized && needs_reinit) {\n\n        h->context_initialized = 0;\n\n        if (sl != h->slice_ctx) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"changing width %d -> %d / height %d -> %d on \"\n\n                   \"slice %d\\n\",\n\n                   h->width, h->avctx->coded_width,\n\n                   h->height, h->avctx->coded_height,\n\n                   h->current_slice + 1);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        ff_h264_flush_change(h);\n\n\n\n        if ((ret = get_pixel_format(h)) < 0)\n\n            return ret;\n\n        h->avctx->pix_fmt = ret;\n\n\n\n        av_log(h->avctx, AV_LOG_INFO, \"Reinit context to %dx%d, \"\n\n               \"pix_fmt: %d\\n\", h->width, h->height, h->avctx->pix_fmt);\n\n\n\n        if ((ret = h264_slice_header_init(h)) < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"h264_slice_header_init() failed\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n    if (!h->context_initialized) {\n\n        if (sl != h->slice_ctx) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Cannot (re-)initialize context during parallel decoding.\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n\n\n        if ((ret = get_pixel_format(h)) < 0)\n\n            return ret;\n\n        h->avctx->pix_fmt = ret;\n\n\n\n        if ((ret = h264_slice_header_init(h)) < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"h264_slice_header_init() failed\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    frame_num = get_bits(&sl->gb, sps->log2_max_frame_num);\n\n    if (!h->setup_finished)\n\n        h->poc.frame_num = frame_num;\n\n\n\n    sl->mb_mbaff       = 0;\n\n\n\n    last_pic_structure = h->picture_structure;\n\n    last_pic_droppable = h->droppable;\n\n\n\n    droppable = h->nal_ref_idc == 0;\n\n    if (sps->frame_mbs_only_flag) {\n\n        picture_structure = PICT_FRAME;\n\n    } else {\n\n        field_pic_flag = get_bits1(&sl->gb);\n\n        if (field_pic_flag) {\n\n            bottom_field_flag = get_bits1(&sl->gb);\n\n            picture_structure = PICT_TOP_FIELD + bottom_field_flag;\n\n        } else {\n\n            picture_structure = PICT_FRAME;\n\n            mb_aff_frame      = sps->mb_aff;\n\n        }\n\n    }\n\n    if (!h->setup_finished) {\n\n        h->droppable         = droppable;\n\n        h->picture_structure = picture_structure;\n\n        h->mb_aff_frame      = mb_aff_frame;\n\n    }\n\n    sl->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;\n\n\n\n    if (h->current_slice != 0) {\n\n        if (last_pic_structure != picture_structure ||\n\n            last_pic_droppable != droppable) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Changing field mode (%d -> %d) between slices is not allowed\\n\",\n\n                   last_pic_structure, h->picture_structure);\n\n            return AVERROR_INVALIDDATA;\n\n        } else if (!h->cur_pic_ptr) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"unset cur_pic_ptr on slice %d\\n\",\n\n                   h->current_slice + 1);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else {\n\n        /* Shorten frame num gaps so we don't have to allocate reference\n\n         * frames just to throw them away */\n\n        if (h->poc.frame_num != h->poc.prev_frame_num) {\n\n            int unwrap_prev_frame_num = h->poc.prev_frame_num;\n\n            int max_frame_num         = 1 << sps->log2_max_frame_num;\n\n\n\n            if (unwrap_prev_frame_num > h->poc.frame_num)\n\n                unwrap_prev_frame_num -= max_frame_num;\n\n\n\n            if ((h->poc.frame_num - unwrap_prev_frame_num) > sps->ref_frame_count) {\n\n                unwrap_prev_frame_num = (h->poc.frame_num - sps->ref_frame_count) - 1;\n\n                if (unwrap_prev_frame_num < 0)\n\n                    unwrap_prev_frame_num += max_frame_num;\n\n\n\n                h->poc.prev_frame_num = unwrap_prev_frame_num;\n\n            }\n\n        }\n\n\n\n        /* See if we have a decoded first field looking for a pair...\n\n         * Here, we're using that to see if we should mark previously\n\n         * decode frames as \"finished\".\n\n         * We have to do that before the \"dummy\" in-between frame allocation,\n\n         * since that can modify s->current_picture_ptr. */\n\n        if (h->first_field) {\n\n            assert(h->cur_pic_ptr);\n\n            assert(h->cur_pic_ptr->f->buf[0]);\n\n            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);\n\n\n\n            /* figure out if we have a complementary field pair */\n\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n\n                /* Previous field is unmatched. Don't display it, but let it\n\n                 * remain for reference if marked as such. */\n\n                if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {\n\n                    ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                              last_pic_structure == PICT_TOP_FIELD);\n\n                }\n\n            } else {\n\n                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {\n\n                    /* This and previous field were reference, but had\n\n                     * different frame_nums. Consider this field first in\n\n                     * pair. Throw away previous field except for reference\n\n                     * purposes. */\n\n                    if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {\n\n                        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                                  last_pic_structure == PICT_TOP_FIELD);\n\n                    }\n\n                } else {\n\n                    /* Second field in complementary pair */\n\n                    if (!((last_pic_structure   == PICT_TOP_FIELD &&\n\n                           h->picture_structure == PICT_BOTTOM_FIELD) ||\n\n                          (last_pic_structure   == PICT_BOTTOM_FIELD &&\n\n                           h->picture_structure == PICT_TOP_FIELD))) {\n\n                        av_log(h->avctx, AV_LOG_ERROR,\n\n                               \"Invalid field mode combination %d/%d\\n\",\n\n                               last_pic_structure, h->picture_structure);\n\n                        h->picture_structure = last_pic_structure;\n\n                        h->droppable         = last_pic_droppable;\n\n                        return AVERROR_INVALIDDATA;\n\n                    } else if (last_pic_droppable != h->droppable) {\n\n                        avpriv_request_sample(h->avctx,\n\n                                              \"Found reference and non-reference fields in the same frame, which\");\n\n                        h->picture_structure = last_pic_structure;\n\n                        h->droppable         = last_pic_droppable;\n\n                        return AVERROR_PATCHWELCOME;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        while (h->poc.frame_num != h->poc.prev_frame_num &&\n\n               h->poc.frame_num != (h->poc.prev_frame_num + 1) % (1 << sps->log2_max_frame_num)) {\n\n            H264Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;\n\n            av_log(h->avctx, AV_LOG_DEBUG, \"Frame num gap %d %d\\n\",\n\n                   h->poc.frame_num, h->poc.prev_frame_num);\n\n            ret = initialize_cur_frame(h);\n\n            if (ret < 0) {\n\n                h->first_field = 0;\n\n                return ret;\n\n            }\n\n\n\n            h->poc.prev_frame_num++;\n\n            h->poc.prev_frame_num        %= 1 << sps->log2_max_frame_num;\n\n            h->cur_pic_ptr->frame_num = h->poc.prev_frame_num;\n\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);\n\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);\n\n            ret = ff_generate_sliding_window_mmcos(h, 1);\n\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n                return ret;\n\n            ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n                return ret;\n\n            /* Error concealment: If a ref is missing, copy the previous ref\n\n             * in its place.\n\n             * FIXME: Avoiding a memcpy would be nice, but ref handling makes\n\n             * many assumptions about there being no actual duplicates.\n\n             * FIXME: This does not copy padding for out-of-frame motion\n\n             * vectors.  Given we are concealing a lost frame, this probably\n\n             * is not noticeable by comparison, but it should be fixed. */\n\n            if (h->short_ref_count) {\n\n                if (prev &&\n\n                    h->short_ref[0]->f->width == prev->f->width &&\n\n                    h->short_ref[0]->f->height == prev->f->height &&\n\n                    h->short_ref[0]->f->format == prev->f->format) {\n\n                    av_image_copy(h->short_ref[0]->f->data,\n\n                                  h->short_ref[0]->f->linesize,\n\n                                  (const uint8_t **)prev->f->data,\n\n                                  prev->f->linesize,\n\n                                  prev->f->format,\n\n                                  h->mb_width  * 16,\n\n                                  h->mb_height * 16);\n\n                    h->short_ref[0]->poc = prev->poc + 2;\n\n                }\n\n                h->short_ref[0]->frame_num = h->poc.prev_frame_num;\n\n            }\n\n        }\n\n\n\n        /* See if we have a decoded first field looking for a pair...\n\n         * We're using that to see whether to continue decoding in that\n\n         * frame, or to allocate a new one. */\n\n        if (h->first_field) {\n\n            assert(h->cur_pic_ptr);\n\n            assert(h->cur_pic_ptr->f->buf[0]);\n\n            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);\n\n\n\n            /* figure out if we have a complementary field pair */\n\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n\n                /* Previous field is unmatched. Don't display it, but let it\n\n                 * remain for reference if marked as such. */\n\n                h->cur_pic_ptr = NULL;\n\n                h->first_field = FIELD_PICTURE(h);\n\n            } else {\n\n                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {\n\n                    /* This and the previous field had different frame_nums.\n\n                     * Consider this field first in pair. Throw away previous\n\n                     * one except for reference purposes. */\n\n                    h->first_field = 1;\n\n                    h->cur_pic_ptr = NULL;\n\n                } else {\n\n                    /* Second field in complementary pair */\n\n                    h->first_field = 0;\n\n                }\n\n            }\n\n        } else {\n\n            /* Frame or first field in a potentially complementary pair */\n\n            h->first_field = FIELD_PICTURE(h);\n\n        }\n\n\n\n        if (!FIELD_PICTURE(h) || h->first_field) {\n\n            if (h264_frame_start(h) < 0) {\n\n                h->first_field = 0;\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        } else {\n\n            release_unused_pictures(h, 0);\n\n        }\n\n    }\n\n\n\n    assert(h->mb_num == h->mb_width * h->mb_height);\n\n    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||\n\n        first_mb_in_slice >= h->mb_num) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"first_mb_in_slice overflow\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sl->resync_mb_x = sl->mb_x =  first_mb_in_slice % h->mb_width;\n\n    sl->resync_mb_y = sl->mb_y = (first_mb_in_slice / h->mb_width) <<\n\n                                 FIELD_OR_MBAFF_PICTURE(h);\n\n    if (h->picture_structure == PICT_BOTTOM_FIELD)\n\n        sl->resync_mb_y = sl->mb_y = sl->mb_y + 1;\n\n    assert(sl->mb_y < h->mb_height);\n\n\n\n    if (h->picture_structure == PICT_FRAME) {\n\n        h->curr_pic_num = h->poc.frame_num;\n\n        h->max_pic_num  = 1 << sps->log2_max_frame_num;\n\n    } else {\n\n        h->curr_pic_num = 2 * h->poc.frame_num + 1;\n\n        h->max_pic_num  = 1 << (sps->log2_max_frame_num + 1);\n\n    }\n\n\n\n    if (h->nal_unit_type == NAL_IDR_SLICE)\n\n        get_ue_golomb(&sl->gb); /* idr_pic_id */\n\n\n\n    if (sps->poc_type == 0) {\n\n        int poc_lsb = get_bits(&sl->gb, sps->log2_max_poc_lsb);\n\n\n\n        if (!h->setup_finished)\n\n            h->poc.poc_lsb = poc_lsb;\n\n\n\n        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {\n\n            int delta_poc_bottom = get_se_golomb(&sl->gb);\n\n            if (!h->setup_finished)\n\n                h->poc.delta_poc_bottom = delta_poc_bottom;\n\n        }\n\n    }\n\n\n\n    if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) {\n\n        int delta_poc = get_se_golomb(&sl->gb);\n\n\n\n        if (!h->setup_finished)\n\n            h->poc.delta_poc[0] = delta_poc;\n\n\n\n        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {\n\n            delta_poc = get_se_golomb(&sl->gb);\n\n\n\n            if (!h->setup_finished)\n\n                h->poc.delta_poc[1] = delta_poc;\n\n        }\n\n    }\n\n\n\n    if (!h->setup_finished)\n\n        ff_h264_init_poc(h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc,\n\n                         sps, &h->poc, h->picture_structure, h->nal_ref_idc);\n\n\n\n    if (pps->redundant_pic_cnt_present)\n\n        sl->redundant_pic_count = get_ue_golomb(&sl->gb);\n\n\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B)\n\n        sl->direct_spatial_mv_pred = get_bits1(&sl->gb);\n\n\n\n    ret = ff_h264_parse_ref_count(&sl->list_count, sl->ref_count,\n\n                                  &sl->gb, pps, sl->slice_type_nos,\n\n                                  h->picture_structure);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n       ret = ff_h264_decode_ref_pic_list_reordering(h, sl);\n\n       if (ret < 0) {\n\n           sl->ref_count[1] = sl->ref_count[0] = 0;\n\n           return ret;\n\n       }\n\n    }\n\n\n\n    sl->pwt.use_weight = 0;\n\n    for (i = 0; i < 2; i++) {\n\n        sl->pwt.luma_weight_flag[i]   = 0;\n\n        sl->pwt.chroma_weight_flag[i] = 0;\n\n    }\n\n    if ((pps->weighted_pred && sl->slice_type_nos == AV_PICTURE_TYPE_P) ||\n\n        (pps->weighted_bipred_idc == 1 &&\n\n         sl->slice_type_nos == AV_PICTURE_TYPE_B))\n\n        ff_h264_pred_weight_table(&sl->gb, sps, sl->ref_count,\n\n                                  sl->slice_type_nos, &sl->pwt);\n\n\n\n    // If frame-mt is enabled, only update mmco tables for the first slice\n\n    // in a field. Subsequent slices can temporarily clobber h->mmco_index\n\n    // or h->mmco, which will cause ref list mix-ups and decoding errors\n\n    // further down the line. This may break decoding if the first slice is\n\n    // corrupt, thus we only do this if frame-mt is enabled.\n\n    if (h->nal_ref_idc) {\n\n        ret = ff_h264_decode_ref_pic_marking(h, &sl->gb,\n\n                                             !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||\n\n                                             h->current_slice == 0);\n\n        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR, \"cabac_init_idc %u overflow\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->cabac_init_idc = tmp;\n\n    }\n\n\n\n    sl->last_qscale_diff = 0;\n\n    tmp = pps->init_qp + get_se_golomb(&sl->gb);\n\n    if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"QP %u out of range\\n\", tmp);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sl->qscale       = tmp;\n\n    sl->chroma_qp[0] = get_chroma_qp(h, 0, sl->qscale);\n\n    sl->chroma_qp[1] = get_chroma_qp(h, 1, sl->qscale);\n\n    // FIXME qscale / qp ... stuff\n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP)\n\n        get_bits1(&sl->gb); /* sp_for_switch_flag */\n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP ||\n\n        sl->slice_type == AV_PICTURE_TYPE_SI)\n\n        get_se_golomb(&sl->gb); /* slice_qs_delta */\n\n\n\n    sl->deblocking_filter     = 1;\n\n    sl->slice_alpha_c0_offset = 0;\n\n    sl->slice_beta_offset     = 0;\n\n    if (pps->deblocking_filter_parameters_present) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"deblocking_filter_idc %u out of range\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->deblocking_filter = tmp;\n\n        if (sl->deblocking_filter < 2)\n\n            sl->deblocking_filter ^= 1;  // 1<->0\n\n\n\n        if (sl->deblocking_filter) {\n\n            sl->slice_alpha_c0_offset = get_se_golomb(&sl->gb) * 2;\n\n            sl->slice_beta_offset     = get_se_golomb(&sl->gb) * 2;\n\n            if (sl->slice_alpha_c0_offset >  12 ||\n\n                sl->slice_alpha_c0_offset < -12 ||\n\n                sl->slice_beta_offset >  12     ||\n\n                sl->slice_beta_offset < -12) {\n\n                av_log(h->avctx, AV_LOG_ERROR,\n\n                       \"deblocking filter parameters %d %d out of range\\n\",\n\n                       sl->slice_alpha_c0_offset, sl->slice_beta_offset);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7716, "substitutes": {"h": ["H", "FH", "hp", "ah", "hw", "ch", "header", "v", "http", "ih", "s", "b", "hhh", "home", "ssh", "oh", "uh", "m", "image", "hel", "l", "rh", "html", "f", "j", "q", "hs", "ph", "u", "e", "sh", "hm", "w", "adh", "en", "t", "hh", "hl", "ctx", "he", "n", "k", "hist", "zh", "eh", "work", "p", "self", "this", "history", "ht", "c", "gh", "g", "hi", "hr", "hash", "ha", "host", "img", "bh", "hd"], "sl": ["fr", "ml", "serv", "sf", "el", "al", "la", "spec", "s", "sw", "ell", "val", "si", "sn", "slice", "ll", "loc", "isl", "l", "cl", "sk", "SL", "tl", "sil", "fl", "ls", "sm", "service", "ph", "kel", "sh", "sth", "sc", "sb", "her", "se", "acl", "hl", "ctx", "zh", "lib", "lr", "rl", "su", "Sl", "gl", "gb", "sp", "sv", "ld", "sa", "sel", "kl", "ssl", "ul", "lc", "dl", "chal", "lv", "il", "li", "pl", "g", "bl", "ess", "api", "cel"], "sps": ["sPS", "psps", "psds", "Sds", " sPS", "pspps", " spps", "SPS", "psPS", "Spps", "Sps", " sds", "sds", "spps"], "pps": ["cp", "hops", "pp", "bps", "wp", "ups", "lp", "ips", "ppers", "px", "xs", "mp", "pg", "drops", "forces", "hs", "ops", "fps", "eps", "ppa", "amps", "ssl", "params", "ppy", "PP", "pb", "cpp", "ps", "pkg"], "first_mb_in_slice": ["first_mb_inside_layer", "first_mb_in64video", "first_mb_inside_slice", "first_mb_in_source", "first_mb_inside_sequence", "first_mb_inside_video", "first_mb_inside_ice", "first_mb_in64slice", "first_mb_in_video", "first_mb_inside_slot", "first_mb_in_slot", "first_mb_in64ice", "first_mb_in_layer", "first_mb_in_image", "first_mb_in_ice", "first_mb_inside_image", "first_mb_in64source", "first_mb_in_sequence"], "pps_id": ["pps_sid", "ps_bit", "pps_ids", "pps_bit", "ps_sid", "ps_id", "ps_ids"], "ret": ["mem", "alt", "complete", "nt", "skip", "val", "rc", "info", "details", "res", "match", "def", "bis", "RET", "mi", "rev", "result", "seq", "Ret", "batch", "proc", "resp", "success", "rep", "quiet", "rets"], "slice_type": ["slicexlike", "slice_info", "split_val", "slice_class", "slice_ty", " slice_like", "slice_types", "slice_address", "sectioningshape", "slice_Type", "slice_unit", "sectioningpy", "sliceflevel", "slicealtype", "slice64index", "slice67length", "image_info", "section_block", "cell67type", "slice_length", "slicexType", "slice_format", "sliceFunit", "slicealformat", "slice_val", "slice_key", "cell67length", " slice_class", " slice_ty", "slice_day", "slice67type", " slice_kind", " slice_size", "slice__types", "slice_shape", " slice_level", "sliceftype", "slice_block", "sliceTypetype", "slice67address", "slice__ty", "split_format", "sliceTypelevel", " slice_index", "slice_kind", "slice_name", " slice_key", "slice8type", "slice64type", "slice__type", "cell_type", "slicextype", "slice_width", "slicealkey", "slice8source", "slicealwidth", "slice__size", "image_name", "single_width", "slice_like", "sliceingtype", "sectioningblock", "slice_level", "slice7level", "sliceingshape", "cell67unit", "cell67address", "slicealtypes", "single_format", "slice67unit", " slice8unit", "sliceTypekind", " slice_no", "slicefblock", "slice64level", "cell_length", "slicealunit", "slice_index", "slice7type", "sliceingblock", " slice_source", " slice_unit", "slice_source", "slice7ty", "section_shape", " slice8type", "slicealindex", "slicefkind", "slicealsource", "slice7index", "slice_no", " slice_Type", "sliceingpy", "slice_style", "slicealno", "cell_unit", "image_style", "image_type", "split_day", "slice64ty", "slice_size", "section_type", "slicealclass", "section_py", "slice8key", "single_index", " slice_types", "single_type", "split_type", "sliceTypeblock", " slice_length", " slice8key", "sliceFlength", "sliceFtype", "slice_py", " slice_block", "slicexlength", "sliceFaddress", "cell_address", "sectioningtype", " slice8source", "slice8unit"], "tmp": ["cp", "cmp", "rb", "config", "pixel", "pp", "kk", "slice", "mp", "meta", "obj", "ii", "cpp", "zip", "fp", "cb", "source", "temp", "amp", "proc", "ip", "mm", "txt", "params", "cache", "src", "sup", "img"], "i": ["ti", "I", "di", "ci", "ki", "ni", "si", "io", "info", "pi", "phi", "iu", "ii", "it", "cli", "ai", "init", "ori", "mi", "ini", "p", "mini", "ip", "oci", "li", "inner", "index", "ui"], "last_pic_structure": ["last_pic_instructure", "last_pic_restruction", "last_pic_instruction", "last_pic_resturation", "last_pic_estructure", "last_pic_restructure", "last_pic_institute", "last_pic_sturation", "last_pic_estitute", "last_pic_insturation", "last_pic_estruction", "last_pic_struction", "last_pic_esturation", "last_pic_restitute", "last_pic_stitute"], "last_pic_droppable": ["last_pic_croppables", "last_pic_droptability", "last_pic_droptible", "last_pic_droppible", "last_pic_droplable", "last_pic_droplability", "last_pic_droappible", "last_pic_croplible", "last_pic_croppable", "last_pic_droplible", "last_pic_droptables", "last_pic_droappable", "last_pic_croplability", "last_pic_croppible", "last_pic_droplables", "last_pic_droppables", "last_pic_droppability", "last_pic_croplable", "last_pic_croppability", "last_pic_droappables", "last_pic_droappability", "last_pic_croplables", "last_pic_droptable"], "field_pic_flag": ["field_picture_mode", "field_pic0flags", "field_pic_count", "field_pic_mode", "field_pic0mode", "field_pic_flags", "field_picture_flag", "field_pic0count", "field_picture_flags", "field_picture_count", "field_pic0flag"], "bottom_field_flag": ["bottom_line_flag", "bottom_line_flags", "bottom_field_class", "bottom_line_count", "bottom_field_count", "bottom_line_class", "bottom_field_flags"], "frame_num": ["frame_seq", " frame_number", " frame_seq", " frame_nb", "frame_nb", "frame_number"], "droppable": ["cropper", "droposables", "droppsable", "droposability", " droposability", "dropped", "croappable", "croapper", "croppables", "droippable", " droppiable", " droposable", " droposiable", "droppsables", "droipped", "droappables", "droapped", "croappables", " droposables", " droppability", "droppables", "droperables", "droposiable", "droppsed", "croppable", "droipper", "droappiable", "droperiable", "cropped", "droippables", "droposable", "droppiable", "droperability", "droappability", "droperable", "droapper", "droppability", "droppser", " droppables", "droappable", "croapped", "dropper"], "picture_structure": ["picture_estatter", "picture_contruction", "picture_structribution", "picture_destatter", "picture_struction", "picture_gestructure", "picture_stribution", "picture_structruction", "picture_estruction", "picture_structatter", "picture_esture", "picture_sture", "picture_estructure", "picture_gestribution", "picture_estribution", "picture_contructure", "picture_gesture", "picture_destribution", "picture_gestruction", "picture_destructure", "picture_contribution", "picture_destruction", "picture_structructure", "picture_conture", "picture_statter"]}}
{"project": "qemu", "commit_id": "aea14095ea91f792ee43ee52fe6032cd8cdd7190", "target": 0, "func": "static void decode_opc (CPUMIPSState *env, DisasContext *ctx)\n\n{\n\n    int32_t offset;\n\n    int rs, rt, rd, sa;\n\n    uint32_t op, op1;\n\n    int16_t imm;\n\n\n\n    /* make sure instructions are on a word boundary */\n\n    if (ctx->pc & 0x3) {\n\n        env->CP0_BadVAddr = ctx->pc;\n\n        generate_exception(ctx, EXCP_AdEL);\n\n        return;\n\n    }\n\n\n\n    /* Handle blikely not taken case */\n\n    if ((ctx->hflags & MIPS_HFLAG_BMASK_BASE) == MIPS_HFLAG_BL) {\n\n        int l1 = gen_new_label();\n\n\n\n        MIPS_DEBUG(\"blikely condition (\" TARGET_FMT_lx \")\", ctx->pc + 4);\n\n        tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n        tcg_gen_movi_i32(hflags, ctx->hflags & ~MIPS_HFLAG_BMASK);\n\n        gen_goto_tb(ctx, 1, ctx->pc + 4);\n\n        gen_set_label(l1);\n\n    }\n\n\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n        tcg_gen_debug_insn_start(ctx->pc);\n\n    }\n\n\n\n    op = MASK_OP_MAJOR(ctx->opcode);\n\n    rs = (ctx->opcode >> 21) & 0x1f;\n\n    rt = (ctx->opcode >> 16) & 0x1f;\n\n    rd = (ctx->opcode >> 11) & 0x1f;\n\n    sa = (ctx->opcode >> 6) & 0x1f;\n\n    imm = (int16_t)ctx->opcode;\n\n    switch (op) {\n\n    case OPC_SPECIAL:\n\n        decode_opc_special(env, ctx);\n\n        break;\n\n    case OPC_SPECIAL2:\n\n        decode_opc_special2_legacy(env, ctx);\n\n        break;\n\n    case OPC_SPECIAL3:\n\n        decode_opc_special3(env, ctx);\n\n        break;\n\n    case OPC_REGIMM:\n\n        op1 = MASK_REGIMM(ctx->opcode);\n\n        switch (op1) {\n\n        case OPC_BLTZL: /* REGIMM branches */\n\n        case OPC_BGEZL:\n\n        case OPC_BLTZALL:\n\n        case OPC_BGEZALL:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        case OPC_BLTZ:\n\n        case OPC_BGEZ:\n\n            gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);\n\n            break;\n\n        case OPC_BLTZAL:\n\n        case OPC_BGEZAL:\n\n            if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                if (rs == 0) {\n\n                    /* OPC_NAL, OPC_BAL */\n\n                    gen_compute_branch(ctx, op1, 4, 0, -1, imm << 2, 4);\n\n                } else {\n\n                    generate_exception(ctx, EXCP_RI);\n\n                }\n\n            } else {\n\n                gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);\n\n            }\n\n            break;\n\n        case OPC_TGEI ... OPC_TEQI: /* REGIMM traps */\n\n        case OPC_TNEI:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            gen_trap(ctx, op1, rs, -1, imm);\n\n            break;\n\n        case OPC_SYNCI:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            /* Break the TB to be able to sync copied instructions\n\n               immediately */\n\n            ctx->bstate = BS_STOP;\n\n            break;\n\n        case OPC_BPOSGE32:    /* MIPS DSP branch */\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_BPOSGE64:\n\n#endif\n\n            check_dsp(ctx);\n\n            gen_compute_branch(ctx, op1, 4, -1, -2, (int32_t)imm << 2, 4);\n\n            break;\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DAHI:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            check_mips_64(ctx);\n\n            if (rs != 0) {\n\n                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 32);\n\n            }\n\n            MIPS_DEBUG(\"dahi %s, %04x\", regnames[rs], imm);\n\n            break;\n\n        case OPC_DATI:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            check_mips_64(ctx);\n\n            if (rs != 0) {\n\n                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 48);\n\n            }\n\n            MIPS_DEBUG(\"dati %s, %04x\", regnames[rs], imm);\n\n            break;\n\n#endif\n\n        default:            /* Invalid */\n\n            MIPS_INVAL(\"regimm\");\n\n            generate_exception(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case OPC_CP0:\n\n        check_cp0_enabled(ctx);\n\n        op1 = MASK_CP0(ctx->opcode);\n\n        switch (op1) {\n\n        case OPC_MFC0:\n\n        case OPC_MTC0:\n\n        case OPC_MFTR:\n\n        case OPC_MTTR:\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DMFC0:\n\n        case OPC_DMTC0:\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n            gen_cp0(env, ctx, op1, rt, rd);\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_C0_FIRST ... OPC_C0_LAST:\n\n#ifndef CONFIG_USER_ONLY\n\n            gen_cp0(env, ctx, MASK_C0(ctx->opcode), rt, rd);\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_MFMC0:\n\n#ifndef CONFIG_USER_ONLY\n\n            {\n\n                uint32_t op2;\n\n                TCGv t0 = tcg_temp_new();\n\n\n\n                op2 = MASK_MFMC0(ctx->opcode);\n\n                switch (op2) {\n\n                case OPC_DMT:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_dmt(t0);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_EMT:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_emt(t0);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_DVPE:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_dvpe(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_EVPE:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_evpe(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_DI:\n\n                    check_insn(ctx, ISA_MIPS32R2);\n\n                    save_cpu_state(ctx, 1);\n\n                    gen_helper_di(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    /* Stop translation as we may have switched the execution mode */\n\n                    ctx->bstate = BS_STOP;\n\n                    break;\n\n                case OPC_EI:\n\n                    check_insn(ctx, ISA_MIPS32R2);\n\n                    save_cpu_state(ctx, 1);\n\n                    gen_helper_ei(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    /* Stop translation as we may have switched the execution mode */\n\n                    ctx->bstate = BS_STOP;\n\n                    break;\n\n                default:            /* Invalid */\n\n                    MIPS_INVAL(\"mfmc0\");\n\n                    generate_exception(ctx, EXCP_RI);\n\n                    break;\n\n                }\n\n                tcg_temp_free(t0);\n\n            }\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_RDPGPR:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_load_srsgpr(rt, rd);\n\n            break;\n\n        case OPC_WRPGPR:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_store_srsgpr(rt, rd);\n\n            break;\n\n        default:\n\n            MIPS_INVAL(\"cp0\");\n\n            generate_exception(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case OPC_BOVC: /* OPC_BEQZALC, OPC_BEQC, OPC_ADDI */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BOVC, OPC_BEQZALC, OPC_BEQC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_ADDI */\n\n            /* Arithmetic with immediate opcode */\n\n            gen_arith_imm(ctx, op, rt, rs, imm);\n\n        }\n\n        break;\n\n    case OPC_ADDIU:\n\n         gen_arith_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SLTI: /* Set on less than with immediate opcode */\n\n    case OPC_SLTIU:\n\n         gen_slt_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_ANDI: /* Arithmetic with immediate opcode */\n\n    case OPC_LUI: /* OPC_AUI */\n\n    case OPC_ORI:\n\n    case OPC_XORI:\n\n         gen_logic_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_J ... OPC_JAL: /* Jump */\n\n         offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n         gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n         break;\n\n    /* Branch */\n\n    case OPC_BLEZC: /* OPC_BGEZC, OPC_BGEC, OPC_BLEZL */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rt == 0) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            /* OPC_BLEZC, OPC_BGEZC, OPC_BGEC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_BLEZL */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        }\n\n        break;\n\n    case OPC_BGTZC: /* OPC_BLTZC, OPC_BLTC, OPC_BGTZL */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rt == 0) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            /* OPC_BGTZC, OPC_BLTZC, OPC_BLTC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_BGTZL */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        }\n\n        break;\n\n    case OPC_BLEZALC: /* OPC_BGEZALC, OPC_BGEUC, OPC_BLEZ */\n\n        if (rt == 0) {\n\n            /* OPC_BLEZ */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        } else {\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            /* OPC_BLEZALC, OPC_BGEZALC, OPC_BGEUC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        }\n\n        break;\n\n    case OPC_BGTZALC: /* OPC_BLTZALC, OPC_BLTUC, OPC_BGTZ */\n\n        if (rt == 0) {\n\n            /* OPC_BGTZ */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        } else {\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            /* OPC_BGTZALC, OPC_BLTZALC, OPC_BLTUC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        }\n\n        break;\n\n    case OPC_BEQL:\n\n    case OPC_BNEL:\n\n         check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_BEQ:\n\n    case OPC_BNE:\n\n         gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n         break;\n\n    case OPC_LWL: /* Load and stores */\n\n    case OPC_LWR:\n\n    case OPC_LL:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_LB ... OPC_LH:\n\n    case OPC_LW ... OPC_LHU:\n\n         gen_ld(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SWL:\n\n    case OPC_SWR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_SB ... OPC_SH:\n\n    case OPC_SW:\n\n         gen_st(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SC:\n\n         check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n         gen_st_cond(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_CACHE:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_cp0_enabled(ctx);\n\n        check_insn(ctx, ISA_MIPS3 | ISA_MIPS32);\n\n        /* Treat as NOP. */\n\n        break;\n\n    case OPC_PREF:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_insn(ctx, ISA_MIPS4 | ISA_MIPS32);\n\n        /* Treat as NOP. */\n\n        break;\n\n\n\n    /* Floating point (COP1). */\n\n    case OPC_LWC1:\n\n    case OPC_LDC1:\n\n    case OPC_SWC1:\n\n    case OPC_SDC1:\n\n        gen_cop1_ldst(ctx, op, rt, rs, imm);\n\n        break;\n\n\n\n    case OPC_CP1:\n\n        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {\n\n            check_cp1_enabled(ctx);\n\n            op1 = MASK_CP1(ctx->opcode);\n\n            switch (op1) {\n\n            case OPC_MFHC1:\n\n            case OPC_MTHC1:\n\n                check_insn(ctx, ISA_MIPS32R2);\n\n            case OPC_MFC1:\n\n            case OPC_CFC1:\n\n            case OPC_MTC1:\n\n            case OPC_CTC1:\n\n                gen_cp1(ctx, op1, rt, rd);\n\n                break;\n\n#if defined(TARGET_MIPS64)\n\n            case OPC_DMFC1:\n\n            case OPC_DMTC1:\n\n                check_insn(ctx, ISA_MIPS3);\n\n                gen_cp1(ctx, op1, rt, rd);\n\n                break;\n\n#endif\n\n            case OPC_BC1EQZ: /* OPC_BC1ANY2 */\n\n                if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                    /* OPC_BC1EQZ */\n\n                    gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),\n\n                                    rt, imm << 2);\n\n                } else {\n\n                    /* OPC_BC1ANY2 */\n\n                    check_cop1x(ctx);\n\n                    check_insn(ctx, ASE_MIPS3D);\n\n                    gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),\n\n                                    (rt >> 2) & 0x7, imm << 2);\n\n                }\n\n                break;\n\n            case OPC_BC1NEZ:\n\n                check_insn(ctx, ISA_MIPS32R6);\n\n                gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),\n\n                                rt, imm << 2);\n\n                break;\n\n            case OPC_BC1ANY4:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n                check_cop1x(ctx);\n\n                check_insn(ctx, ASE_MIPS3D);\n\n                /* fall through */\n\n            case OPC_BC1:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n                gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),\n\n                                    (rt >> 2) & 0x7, imm << 2);\n\n                break;\n\n            case OPC_PS_FMT:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            case OPC_S_FMT:\n\n            case OPC_D_FMT:\n\n                gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                           (imm >> 8) & 0x7);\n\n                break;\n\n            case OPC_W_FMT:\n\n            case OPC_L_FMT:\n\n            {\n\n                int r6_op = ctx->opcode & FOP(0x3f, 0x1f);\n\n                if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                    switch (r6_op) {\n\n                    case R6_OPC_CMP_AF_S:\n\n                    case R6_OPC_CMP_UN_S:\n\n                    case R6_OPC_CMP_EQ_S:\n\n                    case R6_OPC_CMP_UEQ_S:\n\n                    case R6_OPC_CMP_LT_S:\n\n                    case R6_OPC_CMP_ULT_S:\n\n                    case R6_OPC_CMP_LE_S:\n\n                    case R6_OPC_CMP_ULE_S:\n\n                    case R6_OPC_CMP_SAF_S:\n\n                    case R6_OPC_CMP_SUN_S:\n\n                    case R6_OPC_CMP_SEQ_S:\n\n                    case R6_OPC_CMP_SEUQ_S:\n\n                    case R6_OPC_CMP_SLT_S:\n\n                    case R6_OPC_CMP_SULT_S:\n\n                    case R6_OPC_CMP_SLE_S:\n\n                    case R6_OPC_CMP_SULE_S:\n\n                    case R6_OPC_CMP_OR_S:\n\n                    case R6_OPC_CMP_UNE_S:\n\n                    case R6_OPC_CMP_NE_S:\n\n                    case R6_OPC_CMP_SOR_S:\n\n                    case R6_OPC_CMP_SUNE_S:\n\n                    case R6_OPC_CMP_SNE_S:\n\n                        gen_r6_cmp_s(ctx, ctx->opcode & 0x1f, rt, rd, sa);\n\n                        break;\n\n                    case R6_OPC_CMP_AF_D:\n\n                    case R6_OPC_CMP_UN_D:\n\n                    case R6_OPC_CMP_EQ_D:\n\n                    case R6_OPC_CMP_UEQ_D:\n\n                    case R6_OPC_CMP_LT_D:\n\n                    case R6_OPC_CMP_ULT_D:\n\n                    case R6_OPC_CMP_LE_D:\n\n                    case R6_OPC_CMP_ULE_D:\n\n                    case R6_OPC_CMP_SAF_D:\n\n                    case R6_OPC_CMP_SUN_D:\n\n                    case R6_OPC_CMP_SEQ_D:\n\n                    case R6_OPC_CMP_SEUQ_D:\n\n                    case R6_OPC_CMP_SLT_D:\n\n                    case R6_OPC_CMP_SULT_D:\n\n                    case R6_OPC_CMP_SLE_D:\n\n                    case R6_OPC_CMP_SULE_D:\n\n                    case R6_OPC_CMP_OR_D:\n\n                    case R6_OPC_CMP_UNE_D:\n\n                    case R6_OPC_CMP_NE_D:\n\n                    case R6_OPC_CMP_SOR_D:\n\n                    case R6_OPC_CMP_SUNE_D:\n\n                    case R6_OPC_CMP_SNE_D:\n\n                        gen_r6_cmp_d(ctx, ctx->opcode & 0x1f, rt, rd, sa);\n\n                        break;\n\n                    default:\n\n                        gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                                                       (imm >> 8) & 0x7);\n\n                        break;\n\n                    }\n\n                } else {\n\n                    gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                               (imm >> 8) & 0x7);\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                MIPS_INVAL(\"cp1\");\n\n                generate_exception (ctx, EXCP_RI);\n\n                break;\n\n            }\n\n        } else {\n\n            generate_exception_err(ctx, EXCP_CpU, 1);\n\n        }\n\n        break;\n\n\n\n    /* Compact branches [R6] and COP2 [non-R6] */\n\n    case OPC_BC: /* OPC_LWC2 */\n\n    case OPC_BALC: /* OPC_SWC2 */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BC, OPC_BALC */\n\n            gen_compute_compact_branch(ctx, op, 0, 0,\n\n                                       sextract32(ctx->opcode << 2, 0, 28));\n\n        } else {\n\n            /* OPC_LWC2, OPC_SWC2 */\n\n            /* COP2: Not implemented. */\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n        }\n\n        break;\n\n    case OPC_BEQZC: /* OPC_JIC, OPC_LDC2 */\n\n    case OPC_BNEZC: /* OPC_JIALC, OPC_SDC2 */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rs != 0) {\n\n                /* OPC_BEQZC, OPC_BNEZC */\n\n                gen_compute_compact_branch(ctx, op, rs, 0,\n\n                                           sextract32(ctx->opcode << 2, 0, 23));\n\n            } else {\n\n                /* OPC_JIC, OPC_JIALC */\n\n                gen_compute_compact_branch(ctx, op, 0, rt, imm);\n\n            }\n\n        } else {\n\n            /* OPC_LWC2, OPC_SWC2 */\n\n            /* COP2: Not implemented. */\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n        }\n\n        break;\n\n    case OPC_CP2:\n\n        check_insn(ctx, INSN_LOONGSON2F);\n\n        /* Note that these instructions use different fields.  */\n\n        gen_loongson_multimedia(ctx, sa, rd, rt);\n\n        break;\n\n\n\n    case OPC_CP3:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {\n\n            check_cp1_enabled(ctx);\n\n            op1 = MASK_CP3(ctx->opcode);\n\n            switch (op1) {\n\n            case OPC_LWXC1:\n\n            case OPC_LDXC1:\n\n            case OPC_LUXC1:\n\n            case OPC_SWXC1:\n\n            case OPC_SDXC1:\n\n            case OPC_SUXC1:\n\n                gen_flt3_ldst(ctx, op1, sa, rd, rs, rt);\n\n                break;\n\n            case OPC_PREFX:\n\n                /* Treat as NOP. */\n\n                break;\n\n            case OPC_ALNV_PS:\n\n            case OPC_MADD_S:\n\n            case OPC_MADD_D:\n\n            case OPC_MADD_PS:\n\n            case OPC_MSUB_S:\n\n            case OPC_MSUB_D:\n\n            case OPC_MSUB_PS:\n\n            case OPC_NMADD_S:\n\n            case OPC_NMADD_D:\n\n            case OPC_NMADD_PS:\n\n            case OPC_NMSUB_S:\n\n            case OPC_NMSUB_D:\n\n            case OPC_NMSUB_PS:\n\n                gen_flt3_arith(ctx, op1, sa, rs, rd, rt);\n\n                break;\n\n            default:\n\n                MIPS_INVAL(\"cp3\");\n\n                generate_exception (ctx, EXCP_RI);\n\n                break;\n\n            }\n\n        } else {\n\n            generate_exception_err(ctx, EXCP_CpU, 1);\n\n        }\n\n        break;\n\n\n\n#if defined(TARGET_MIPS64)\n\n    /* MIPS64 opcodes */\n\n    case OPC_LDL ... OPC_LDR:\n\n    case OPC_LLD:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_LWU:\n\n    case OPC_LD:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_ld(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_SDL ... OPC_SDR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_SD:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_st(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_SCD:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_st_cond(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC, OPC_DADDI */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BNVC, OPC_BNEZALC, OPC_BNEC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_DADDI */\n\n            check_insn(ctx, ISA_MIPS3);\n\n            check_mips_64(ctx);\n\n            gen_arith_imm(ctx, op, rt, rs, imm);\n\n        }\n\n        break;\n\n    case OPC_DADDIU:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_arith_imm(ctx, op, rt, rs, imm);\n\n        break;\n\n#else\n\n    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            MIPS_INVAL(\"major opcode\");\n\n            generate_exception(ctx, EXCP_RI);\n\n        }\n\n        break;\n\n#endif\n\n    case OPC_DAUI: /* OPC_JALX */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n#if defined(TARGET_MIPS64)\n\n            /* OPC_DAUI */\n\n            check_mips_64(ctx);\n\n            if (rt != 0) {\n\n                TCGv t0 = tcg_temp_new();\n\n                gen_load_gpr(t0, rs);\n\n                tcg_gen_addi_tl(cpu_gpr[rt], t0, imm << 16);\n\n                tcg_temp_free(t0);\n\n            }\n\n            MIPS_DEBUG(\"daui %s, %s, %04x\", regnames[rt], regnames[rs], imm);\n\n#else\n\n            generate_exception(ctx, EXCP_RI);\n\n            MIPS_INVAL(\"major opcode\");\n\n#endif\n\n        } else {\n\n            /* OPC_JALX */\n\n            check_insn(ctx, ASE_MIPS16 | ASE_MICROMIPS);\n\n            offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n            gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n        }\n\n        break;\n\n    case OPC_MDMX:\n\n        check_insn(ctx, ASE_MDMX);\n\n        /* MDMX: Not implemented. */\n\n        break;\n\n    case OPC_PCREL:\n\n        check_insn(ctx, ISA_MIPS32R6);\n\n        gen_pcrel(ctx, rs, imm);\n\n        break;\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"major opcode\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n", "idx": 15980, "substitutes": {"env": ["erv", "proc", "en", "context", "pkg", "tx", "qa", "queue", "enc", "cv", "ea", "pec", "config", "code", "priv", "eu", "oa", "kn", "req", "txt", "vm", "init", "scope", "loc", "conf", "conn", "np", "console", "obj", "loader", "dev", "dict", "e", "viron", "exc", "fi", "info", "buf", "cli", "qt", "inst", "Environment", "ocr", "bg", "ce", "ep", "cal", "que", "exec", "db", "ev", "ec", "vt", "prefix", "environment", "util", "vs", "et", "hw", "esi", "err"], "ctx": [" context", "tx", "bc", "pec", "wcs", "cmp", "fp", "ct", "loc", "np", "obj", "ck", "scl", "c", "cas", "sc", "cp", "fc", "cpp", "anon", "context", "sync", "rc", "cc", "lc", "cs", "conv", "cn", "cms", "txt", "fn", "client", "bp", "console", "grad", "kt", "anc", "cases", "exec", "kb", "xc", "history", "support", "sys", "cv", "ca", "config", "pc", "cz", "ci", "wx", "cy", "xp", "scope", "linux", "conn", "kw", "nc", "tc", "acl", "gpu", "voc", "chan", "cf", "prefix", "hw", "cl", "fw", "pkg", "cm", "qa", "jp", "utils", "Context", "ctrl", "na", "std", "sq", "cli", "cus", "wp", "cca", "cu", "sci", "cmd", "qq", "vc", "src", "util"], "offset": ["oid", "Offset", "ff", "ffff", "top", "align", "fp", "loc", "error", "base", "bit", "origin", "skip", "ip", "rot", "src", "seq", "hop", "pos", "num", "prefix", "no", "len", "ptr", "alloc"], "rs": ["RC", "Rs", "rr", "rc", "ins", "cs", "hs", "os", "rg", "rows", "pps", "ps", "aps", "ms", "rb", "rx", "ars", "RS", "rl", "ns", "xs", "ops", "r", "ds", "rep", "pr", "ips", "dr", "res", " RS", "ls", "hop", "ims", "vs", "reg", "agg"], "rt": ["rr", "apt", "ru", "irt", "RT", "rat", "rc", "tr", "pt", "rn", "wt", "sr", "br", "rh", "adr", "mt", "rec", "rb", "rx", "NT", "ann", "rm", "rl", "cat", "ur", "attr", "nt", "rob", "r", "pr", "dr", "rel", "rf", "rot", "ptr", "rit", "err"], "rd": ["rr", "rss", "as", "ru", "rid", "d", "hr", "rc", "da", "bd", "ra", "RD", "rn", "rg", "ld", "lda", "rh", "adr", "lr", "rb", "rx", "nas", "rw", "rm", "rl", "dra", "dc", "attr", "md", "rob", "r", "ds", "dd", "ri", "dr", "addr", "rf"], "sa": ["sta", "as", "ca", "sg", "da", "a", "asi", "ta", "ra", "ain", "na", "sha", "sr", "si", "ama", "sq", "aa", "ras", "SA", "ba", "s", "sam", "pa", "sf", "sb", "au", "ann", "ma", "Sa", "ans", "ssl", "va", "ds", "ga", "asa", "ity", "sm", "asm"], "op": ["oper", "oid", "OP", "cop", "ipop", "api", "sp", "option", "pp", "post", "pop", "cmp", "mod", "operator", "loc", "app", "pol", "o", "set", "vert", "opus", "ant", "oc", "p", "comp", "oop", "omp", "opp", "expr", "ipp", "ip", "Op", "cat", "type", "ops", "ic", " Op", "hop", "off", "pos", "upp", "prop", "rot", "opt", "bit"], "op1": ["OP1", "hop1", "optn", "op3", "oper2", "OP2", "oper1", "opt3", "OPn", "opername", "opn", "op0", "hop3", "OP0", "opt1", " op0", " opn", "hop2", "optname", " op3", "opt2", "opname", " opname", "opt0"], "imm": ["cm", "lig", "fl", "amm", "mitt", "orm", "Imm", "fm", "cond", "umm", "umi", "mm", "mit", "si", "aim", "tm", "sim", "imp", "gm", "mt", "mem", "mun", "lif", "bm", "mi", "ann", "rm", "pm", "serv", "attr", "im", "ism", "lamm", "imet", "imi", "dim", "sm", "lim"]}}
{"project": "FFmpeg", "commit_id": "4bb1070c154e49d35805fbcdac9c9e92f702ef96", "target": 0, "func": "static int decode_slice_header(FFV1Context *f, FFV1Context *fs)\n\n{\n\n    RangeCoder *c = &fs->c;\n\n    uint8_t state[CONTEXT_SIZE];\n\n    unsigned ps, i, context_count;\n\n    memset(state, 128, sizeof(state));\n\n\n\n    if (fs->ac > 1) {\n\n        for (i = 1; i < 256; i++) {\n\n            fs->c.one_state[i]        = f->state_transition[i];\n\n            fs->c.zero_state[256 - i] = 256 - fs->c.one_state[i];\n\n        }\n\n    }\n\n\n\n    fs->slice_x      = get_symbol(c, state, 0) * f->width;\n\n    fs->slice_y      = get_symbol(c, state, 0) * f->height;\n\n    fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width + fs->slice_x;\n\n    fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;\n\n\n\n    fs->slice_x     /= f->num_h_slices;\n\n    fs->slice_y     /= f->num_v_slices;\n\n    fs->slice_width  = fs->slice_width / f->num_h_slices - fs->slice_x;\n\n    fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;\n\n    if ((unsigned)fs->slice_width  > f->width ||\n\n        (unsigned)fs->slice_height > f->height)\n\n        return AVERROR_INVALIDDATA;\n\n    if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||\n\n        (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    for (i = 0; i < f->plane_count; i++) {\n\n        PlaneContext *const p = &fs->plane[i];\n\n        int idx               = get_symbol(c, state, 0);\n\n        if (idx > (unsigned)f->quant_table_count) {\n\n            av_log(f->avctx, AV_LOG_ERROR, \"quant_table_index out of range\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        p->quant_table_index = idx;\n\n        memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));\n\n        context_count = f->context_count[idx];\n\n\n\n        if (p->context_count < context_count) {\n\n            av_freep(&p->state);\n\n            av_freep(&p->vlc_state);\n\n        }\n\n        p->context_count = context_count;\n\n    }\n\n\n\n    ps = get_symbol(c, state, 0);\n\n    if (ps == 1) {\n\n        f->cur->interlaced_frame = 1;\n\n        f->cur->top_field_first  = 1;\n\n    } else if (ps == 2) {\n\n        f->cur->interlaced_frame = 1;\n\n        f->cur->top_field_first  = 0;\n\n    } else if (ps == 3) {\n\n        f->cur->interlaced_frame = 0;\n\n    }\n\n    f->cur->sample_aspect_ratio.num = get_symbol(c, state, 0);\n\n    f->cur->sample_aspect_ratio.den = get_symbol(c, state, 0);\n\n\n\n    if (av_image_check_sar(f->width, f->height,\n\n                           f->cur->sample_aspect_ratio) < 0) {\n\n        av_log(f->avctx, AV_LOG_WARNING, \"ignoring invalid SAR: %u/%u\\n\",\n\n               f->cur->sample_aspect_ratio.num,\n\n               f->cur->sample_aspect_ratio.den);\n\n        f->cur->sample_aspect_ratio = (AVRational){ 0, 1 };\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10738, "substitutes": {"f": ["count", "l", "af", "m", "http", "fd", "t", "x", "fw", "fb", "config", "ref", "feed", "of", "fl", "v", "flags", "full", "now", "form", "self", "flat", "fi", "fab", "fc", "xf", "lf", "sf", "_", "id", "fr", "b", "s", "e", "cf", "bf", "tf", "r", "this", "u", "file", "rf", "fen", "g", "ff", "ul", "fed", "d", "fp", "flow", "df", "fa", "fm", "fx", "feature", "new", "fn", "F", "func", "aff", "uf", "conf", "fo", "function", "raf", "h", "pos", "fac", "y", "inf", "fe"], "fs": ["utils", "af", "http", "fd", "x", "fw", "flows", "gs", "fb", "feed", "wcs", "of", "fl", "v", "flags", "full", "ns", "fi", "ves", "fc", "vals", "xf", "FS", "lf", "ds", "sf", "fr", "ils", "s", "e", "cf", "bc", "bf", "tf", "res", "es", "fps", "fits", "ss", "ows", "Fs", "fee", "rf", "uses", "ks", "frames", "ff", "features", "ops", "ls", "fp", "df", "os", "cs", "fm", "linux", "aux", "fx", "fn", "sys", "cache", "func", "fts", "vs", "uf", "ts", "fo", "rows", "fields", "files", "qs", "rs", "obs", "states", "raf", "ms", "faces", "h", "options", "css", "bs", "fe"], "c": ["l", "cr", "arc", "center", "conf", "co", "C", "abc", "n", "g", "m", "conn", "b", "t", "k", "z", "x", "d", "con", "cp", "ct", "config", "s", "chain", "e", "cd", "cu", "cf", "cn", "ec", "coll", "q", "bc", "cc", "ac", "code", "cs", "cus", "cv", "v", "ce", "ic", "ctx", "r", "can", "cl", "pc", "dc", "xc", "com", "col", "controller", "u", "this", "nc", "h", "cm", "ca", "cycle", "ci", "vc", "lc", "cache", "jc", "y", "ch", "mc", "uc", "cy", "sc", "fc"], "state": ["parent", "count", "session", "m", "t", "config", "memory", "loc", "st", "body", "code", "v", "object", "port", "type", "form", "seed", "buffer", "key", "id", "instance", "s", "rule", "component", "e", "j", "slice", "input", "current", "r", "this", "u", "State", "context", "str", "source", "conn", "public", "stat", "data", "local", "STATE", "style", "resource", "size", "version", "sync", "use", "cache", "core", "area", "start", "pointer", "private", "name", "states", "address", "h", "null", "options", "length", "y"], "ps": [" base", " parent", " bc", "State", " val", " cache", " output", " cc", " frame", " pos", " function", " _", " config", " func", " mask", " q", " block", " self", " col", " props", " bits", " code", " flags", " out", " res", " source", " callback"], "i": ["oi", "l", "diff", "ani", "hi", "ui", "di", "it", "is", "si", "n", "axis", "in", "zi", "key", "id", "info", "xi", "m", "b", "ini", "z", "ami", "x", "ji", "uri", "ix", "e", "mu", "yi", "esi", "mini", "eni", "ie", "j", "ai", "o", "multi", "index", "slice", "v", "jit", "ind", "mi", "ti", "gi", "phi", "isin", "min", "abi", "inner", "qi", "ij", "ei", "bi", "pi", "ii", "u", "I", "li", "ip", "ci", "ni", "io", "y", "ri", "fi", "iu", "range"], "context_count": ["path2counter", "path_name", "context_counter", "path_count", "context2count", "context1count", "path2name", "context2counter", "context_name", "context1counter", "context_len", "path_len", "path2count", "path2len", "context1name", "context1len", "context2name", "path_counter", "context2len"], "p": ["l", "g", "m", "b", "z", "pp", "cp", "e", "np", "pe", "pt", "q", "P", "op", "j", "o", "py", "v", "r", "port", "pi", "pc", "u", "a", "vp"]}}
{"project": "FFmpeg", "commit_id": "c9aab8a123c0bcf6adeab390db1ec783326456ca", "target": 0, "func": "static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){\n\n    MpegEncContext * const s = &h->s;\n\n    Picture * const ref1 = &h->ref_list[1][0];\n\n    int j, old_ref, rfield;\n\n    int start= mbafi ? 16                      : 0;\n\n    int end  = mbafi ? 16+2*h->ref_count[0]    : h->ref_count[0];\n\n    int interl= mbafi || s->picture_structure != PICT_FRAME;\n\n\n\n    /* bogus; fills in for missing frames */\n\n    memset(map[list], 0, sizeof(map[list]));\n\n\n\n    for(rfield=0; rfield<2; rfield++){\n\n        for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){\n\n            int poc = ref1->ref_poc[colfield][list][old_ref];\n\n\n\n            if     (!interl)\n\n                poc |= 3;\n\n            else if( interl && (poc&3) == 3) //FIXME store all MBAFF references so this isnt needed\n\n                poc= (poc&~3) + rfield + 1;\n\n\n\n            for(j=start; j<end; j++){\n\n                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {\n\n                    int cur_ref= mbafi ? (j-16)^field : j;\n\n                    map[list][2*old_ref + (rfield^field) + 16] = cur_ref;\n\n                    if(rfield == field || !interl)\n\n                        map[list][old_ref] = cur_ref;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11080, "substitutes": {"h": ["l", "sh", "he", "ht", "html", "n", "g", "hr", "ph", "hh", "w", "m", "http", "t", "b", "z", "d", "i", "c", "p", "hm", "e", "ref", "gh", "eh", "q", "hw", "f", "host", "o", "ha", "v", "ih", "bh", "hp", "oh", "hs", "hd", "u", "H", "self", "hl", "header", "image", "ah", "ch", "rh", "uh"], "map": ["parent", "conf", "maps", "arr", "up", "cmp", "scale", "dict", "m", "model", "open", "pack", "mem", "create", "pool", "block", "data", "config", "max", "meta", "app", "set", "table", "group", "array", "share", "code", "db", "bl", "shape", "module", "scope", "cap", "master", "msg", "min", "Map", "pre", "address", "en", "hash", "copy", "lock", "change", "pair", "file", "ge", "use", "MAP", "cache", "match", "down", "ap", "image", "buffer", "per"], "list": ["parent", "count", "l", "base", "record", "m", "path", "x", "pool", "block", "config", "max", "set", "act", "st", "none", "code", "err", "full", "com", "type", "self", "flat", "chain", "arr", "val", "key", "all", "view", "low", "cont", "c", "List", "pre", "load", "cl", "wx", "listed", "header", "lc", "range", "str", "g", "len", "source", "test", "lists", "data", "head", "cli", "local", "coll", "old", "can", "cache", "diff", "batch", "p", "server", "queue", "table", "name", "LIST", "ist", "null", "out", "write", "feat"], "field": ["count", "play", "cmp", "record", "x", "shift", "ref", "v", "end", "offset", "type", "change", "ld", "key", "fr", "low", "i", "c", "rule", "component", "value", "group", "f", "input", "Field", "load", "layer", "lc", "range", "fix", "len", "g", "source", "ff", "d", "size", "query", "old", "message", "diff", "level", "co", "start", "fields", "FIELD", "line", "p", "ix", "number", "off", "length", "match", "force", "fe"], "colfield": ["catindex", "textindex", "colrule", "collref", "textfix", "reflabel", "reforder", "rolrule", "collfield", "collrow", "colindex", " colfix", "actloader", " collabel", "colfix", "catgroup", "actfield", "rolref", "colorder", "catfield", "rolfield", "actrow", "colrow", "colgroup", "rolorder", "rollabel", " colrule", "catfix", "reffield", "refrule", "textgroup", "collloader", " colindex", "actref", " colorder", "rolloader", "textfield", "colloader", "rolrow", "colref", "collabel", " colgroup"], "mbafi": ["MBafi", "mdifa", "embafi", "kbaf", "kbafa", "mciera", "MBfi", "mpaf", "mbfi", "macabi", "embfi", " MBafi", "nobaf", "mbifa", "mnafi", " MBabi", "nobfi", "mpifa", "embaf", "MBifi", " MBiana", "mdafi", "ombafa", "nobafa", "ombafi", "mpabi", "maciera", "MBafa", "mbifi", "mnabi", "ombabi", "maciana", "embafa", "mdabi", "mnaf", "mdafa", "mbabi", "ombifa", "mcaf", "mcafa", " MBfi", "mbiana", "mnafa", "mcabi", "mpifi", "mbafa", "mcafi", "macafi", "mpafi", " MBifi", "mpafa", "mpfi", "mciana", "nobafi", "mbiera", "mbaf", " MBiera", "kbfi", "kbafi", " MBafa"], "s": ["l", "session", "sg", "sh", "is", "n", "g", "si", "w", "m", "b", "ages", "t", "ops", "i", "gs", "c", "p", "ls", "server", "e", "rs", "os", "f", "cs", "o", "S", "es", "v", "scope", "sync", "sl", "services", "r", "als", "ns", "sb", "spec", "u", "sys", "ions", "ances", "params", "ps", "ures", "fs", "ses", "y", "ss", "a", "settings", "ssl", "sc"], "ref1": [" ref2", "ref01", " Ref2", "rangeOne", "col2", "resp01", "reference1", "ref0", "refOne", "reference01", "range1", "Ref0", " Ref0", "ref2", "range2", "respOne", "reference2", " refOne", "resp1", "Ref1", "referenceOne", "colOne", "range01", "resp2", "col0", "Ref2", " Ref1", "col1"], "j": ["l", "jan", "je", "it", "str", "n", "g", "start", "adj", "key", "all", "note", "m", "fr", "section", "x", "jet", "b", "jen", "dj", "z", "num", "k", "d", "i", "job", "c", "ji", "ref", "p", "obj", "jo", "jam", "reg", "e", "el", "js", "f", "ie", "code", "uj", "child", "bj", "o", "index", "bl", "v", "syn", "jit", "ind", "r", "ij", "jp", "part", "ja", "offset", "col", "u", "aj", "oj", "li", "pos", "J", "length", "y", "ch", "jc", "jl", "jj", "br"], "old_ref": ["old_diff", "old_rec", "old5ref", "oldlexfe", "old5cmp", "old_cmp", "old67Ref", "oldlexval", "old_remote", "old_pointer", "oldJpointer", "oldJreference", " old_pointer", "old5rec", "old67diff", "oldlexref", "olderlexref", " old_remote", "old67ref", " old_Ref", "oldlexreference", "old67ext", "olderlexfe", "olderlexval", " old_vis", "old67fe", " old_reference", "oldJref", "old_vis", "olderlexreference", "old67pre", "older_cmp", "old_val", "old_Ref", "old67remote", "old5reference", " old_pre", " old_diff", "older_val", "older_fe", "old_ext", "older_rec", "old_fe", " old_fe", "oldJRef", "old67reference", "old_reference", "old67vis", " old_ext", "oldJdiff", "old_pre", "older_ref", "older_reference"], "rfield": ["rtkey", "rdkey", "rkey", "rtref", "reldiff", "relkey", "rtfun", "relslice", "drslice", "rddiff", "rarfield", "jf", "roslice", "rdref", "nrfields", "nrslice", " rfc", " rdiff", "jref", "drcomp", "rolabel", "rlabel", "relref", "lkey", "rofc", " rlabel", " rslice", " rfields", "rslice", "lfc", "jfield", "nrforce", "bfield", "Rslice", "rofield", "nrfield", "rcomp", "lslice", "srforce", "rarref", "rref", "rdfield", " rf", "rfix", "nrchar", "nrFIELD", "rf", "relchar", "relfix", " rforce", "rfields", "rfc", "bslice", "lfield", "rfun", "rdfix", " rFIELD", "rokey", " rfix", " rfun", "rarkey", "nrkey", "srfield", " rkey", " rref", "rdslice", "srFIELD", "rof", "jlabel", "Rcomp", "rforce", "srfields", "roref", "rchar", "rtfield", "rdiff", "Rfield", "drfield", "rdchar", "relfield", "rarfun", "bcomp", "rFIELD"]}}
{"project": "FFmpeg", "commit_id": "e5dd4ae7284bb290d8dc8e9cd3f2e035d1d77cd0", "target": 1, "func": "static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,\n\n                            AVPacket *avpkt)\n\n{\n\n    const char *ptr = avpkt->data;\n\n    int len, size = avpkt->size;\n\n\n\n    while (size > 0) {\n\n        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);\n\n        int duration = dialog->end - dialog->start;\n\n        len = ff_ass_add_rect(data, ptr, 0, duration, 1);\n\n        if (len < 0)\n\n            return len;\n\n        ptr  += len;\n\n        size -= len;\n\n    }\n\n\n\n    *got_sub_ptr = avpkt->size > 0;\n\n    return avpkt->size;\n\n}\n", "idx": 18175, "substitutes": {"avctx": ["ajctx", "avc", "ajcontext", "afc", "ajcv", "ajci", "ajloc", "afcontext", "AVci", "abc", "afctx", "abctx", "abcontext", "avci", "AVloc", "ajc", "abcv", "afloc", "afci", "avloc", "AVctx", "avcv", "AVcontext", "avcontext", "afcv"], "data": ["part", "Data", "content", "offset", "code", "mode", "reader", "base", "name", "image", "media", "buffer", "result", "window", "type", "padding", "pos", "progress", "pointer", "d", "empty", "draw", "complete", "size", "memory", "length", "id", "start", "ad", "open", "parent", "map", "da", "p", "address", "pad", "ada", "cache", "missing", "dat", "ata", "next", "body", "DATA", "message", "bytes", "addr", "frame", "connection", "a", "alpha", "value", "source", "input"], "got_sub_ptr": ["got_sub_dr", "got_subipdim", "got_sub_dim", "got_subxpointer", "got_sub_addr", "got_subxptr", "got_subxaddr", "got_subipaddr", "got_sub_pointer", "got_subxdr", "got_subipptr", "got_subippointer"], "avpkt": ["avpcht", "ajpakt", "avfcht", "avmka", "abpnt", "avprkt", "avpkg", "avpqt", "uppkt", "abpkt", "avpcp", "abfkt", "abfkg", "avvpkt", "avvkt", "avfkg", "avspct", "ajpke", "ajpcht", "afPqt", "avprqt", "upvpacket", "avpwk", "avnkt", "avPqt", "avpake", "avpcacket", "avfet", "avnacket", "avspqt", "afpct", "afPkt", "avfnt", "avfwk", "avnqt", "abfqt", "avpawk", "upvpet", "avpet", "avspkt", "afpkt", "abpkg", "avprct", "afPcp", "avprcp", "abpwk", "avfqt", "ajpkt", "ajpake", "avvpacket", "uppet", "ajpaacket", "abpacket", "avpant", "avvpet", "ajpacht", "avPcht", "abfwk", "avpckt", "afpcp", "avmkt", "avPcp", "avPct", "upvpkt", "avmet", "avpct", "uppacket", "avpnt", "uppka", "afPct", "avnkg", "avvpka", "ajpacket", "avspcp", "abpqt", "avpka", "avpacket", "abfacket", "avvqt", "avfkt", "upvpka", "avfka", "avpke", "afpqt", "avpacht", "abfnt", "avpaacket", "avvacket", "avPke", "avmacket", "avpakt", "avvkg", "avpcnt", "avpcwk", "avfacket", "avPkt", "avfke", "avPacket"], "ptr": ["point", "offset", "pointers", "tr", "fp", "ref", "ctr", "tty", "buffer", "coord", " pointer", "loc", "src", "ctx", "ext", "slice", "pos", "index", "pointer", "context", "length", "tell", "start", "fd", "dr", "buff", "buf", "temp", "req", "cur", "tmp", "patch", "p", "shift", "address", "pad", "depth", "alloc", "proc", "inst", "addr", "Ptr", "port", "desc", "attr", "pt"], "len": ["lon", "part", "offset", "code", "ell", "lim", "base", "name", "all", "lit", "vec", "n", "fun", "str", "i", "sl", "z", "loc", "ls", "ie", "led", "fin", "dl", "pos", "min", "en", "count", "lt", "lf", " el", "ln", "l", "low", "val", "fl", "size", "le", "pre", "dy", "length", "hl", "ler", " length", "id", "start", "rev", "span", "elt", "lc", "c", "seq", "lib", "line", "url", "doc", "req", "split", "bytes", "iter", "lang", "el", "li", "Len"], "dialog": ["llogue", "chalogs", "Dialogue", "collog", "llocation", "dialogue", "chalogue", "colog", "diffogs", "defogue", "llog", "defogs", "diffogue", "chalogging", "logog", "diffog", "cologue", "dialit", "dialogs", "Dialog", "logocation", "llocol", "colocation", "logogue", "Dialogo", "collogo", "Dialit", "dialocation", "defog", "dialogging", "logocol", "colocol", "chalog", "defogging", "dialogo", "diffogging", "collit", "collogue", "dialocol", "logogo", "logit"]}}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int pnm_decode_header(AVCodecContext *avctx, PNMContext * const s){\n\n    char buf1[32], tuple_type[32];\n\n    int h, w, depth, maxval;;\n\n\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    if (!strcmp(buf1, \"P4\")) {\n\n        avctx->pix_fmt = PIX_FMT_MONOWHITE;\n\n    } else if (!strcmp(buf1, \"P5\")) {\n\n        if (avctx->codec_id == CODEC_ID_PGMYUV) \n\n            avctx->pix_fmt = PIX_FMT_YUV420P;\n\n        else\n\n            avctx->pix_fmt = PIX_FMT_GRAY8;\n\n    } else if (!strcmp(buf1, \"P6\")) {\n\n        avctx->pix_fmt = PIX_FMT_RGB24;\n\n    } else if (!strcmp(buf1, \"P7\")) {\n\n        w = -1;\n\n        h = -1;\n\n        maxval = -1;\n\n        depth = -1;\n\n        tuple_type[0] = '\\0';\n\n        for(;;) {\n\n            pnm_get(s, buf1, sizeof(buf1));\n\n            if (!strcmp(buf1, \"WIDTH\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                w = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"HEIGHT\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                h = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"DEPTH\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                depth = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"MAXVAL\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                maxval = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"TUPLETYPE\")) {\n\n                pnm_get(s, tuple_type, sizeof(tuple_type));\n\n            } else if (!strcmp(buf1, \"ENDHDR\")) {\n\n                break;\n\n            } else {\n\n                return -1;\n\n            }\n\n        }\n\n        /* check that all tags are present */\n\n        if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type[0] == '\\0')\n\n            return -1;\n\n        avctx->width = w;\n\n        avctx->height = h;\n\n        if (depth == 1) {\n\n            if (maxval == 1)\n\n                avctx->pix_fmt = PIX_FMT_MONOWHITE;\n\n            else \n\n                avctx->pix_fmt = PIX_FMT_GRAY8;\n\n        } else if (depth == 3) {\n\n            avctx->pix_fmt = PIX_FMT_RGB24;\n\n        } else if (depth == 4) {\n\n            avctx->pix_fmt = PIX_FMT_RGBA32;\n\n        } else {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    } else {\n\n        return -1;\n\n    }\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    avctx->width = atoi(buf1);\n\n    if (avctx->width <= 0)\n\n        return -1;\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    avctx->height = atoi(buf1);\n\n    if (avctx->height <= 0)\n\n        return -1;\n\n    if (avctx->pix_fmt != PIX_FMT_MONOWHITE) {\n\n        pnm_get(s, buf1, sizeof(buf1));\n\n    }\n\n\n\n    /* more check if YUV420 */\n\n    if (avctx->pix_fmt == PIX_FMT_YUV420P) {\n\n        if ((avctx->width & 1) != 0)\n\n            return -1;\n\n        h = (avctx->height * 2);\n\n        if ((h % 3) != 0)\n\n            return -1;\n\n        h /= 3;\n\n        avctx->height = h;\n\n    }\n\n    return 0;\n\n}\n", "idx": 14056, "substitutes": {"avctx": ["afcca", "aucdn", "Avconf", "afconn", "navcca", "Avcontext", "afpkg", "aucontext", "AVcmp", "afconf", "Avctx", "avcmp", "avlc", "cvctx", " avpkg", "navcu", "auconn", "afcdn", "cvcmp", "aflc", "AVcontext", "vercontext", "afxc", "avalconf", "navctx", "afcu", "afcmp", " avxc", "AVlc", "avalcontext", "avalctrl", "avcdn", "verconn", "afcontext", " avcmp", "AVxc", "vercdn", "auctx", "avalctx", "appcca", "avcu", "appctx", " avcontext", "avcontext", "verctx", "avconn", "avxc", "avconf", "afctx", "Avctrl", "navconn", " avconn", "cvlc", "navcontext", "cvcontext", "AVctx", "appcu", "avpkg", "appcontext", "afctrl", "avctrl", "navpkg", "avcca"], "s": ["args", "path", "south", "sys", "ses", "m", "bis", "self", "d", "service", "t", "sg", "sync", "fs", "native", "i", "sym", "rs", "a", "current", "sup", "g", "cs", "details", "settings", "cms", "comments", "sets", "js", "es", "scope", "sq", "session", "server", "secure", "conf", "ss", "o", "params", "p", "e", "info", "ions", "site", "http", "sf", "sb", "b", "scl", "n", "f", "gs", "gb", "spec", "stat", "ns", "c", "serv", "is", "stats", "sc", "ssl", "ops", "r", "ds", "services", "support", "in"], "buf1": ["bufOnce", "uber1", "bu0", "buff01", "buffer2", "cmdone", "buf51", "buffs", "uf31", " bufone", "buf9", "buf100", "ufnum", "buffn", "uf01", "bu1", "Buff1", "uf64", "vecpre", "buff2", "bu51", "buL", "rafOne", "cfone", "bu91", "vec61", "uber9", "buf61", "buf91", "buff51", " bufnum", "buffL", "Buff0", "bufone", "bg1", "buffer81", "bg2", "cf2", "buf64", "cmd0", "uf0", "nob2", "nob1", "bufnum", "cv2", " buf0", "bus", "bufs", "vec1", "buffpre", "vecone", "ufback", "cfOne", "bag81", "cvback", "vec100", "cmd1", "cv1", " buffer1", "bufferull", "cmdpre", "buffOne", "rub2", "ufOne", "bufferone", "cvone", "ufs", "bu2", "nob31", "bc2", " bufOne", "bufull", "vecn", "bagone", "uf91", "cmd64", "buff1", "bag2", "buf01", "rub1", "cmd2", "cmdONE", "buffone", "ufn", "bufn", "buf0", "uf61", "raf2", " buf81", "cvn", "buf81", "buff64", "vec2", "bufpre", "ufpre", " buffer2", "bag1", "raf1", "bufOne", "vec0", "buffer1", "bgone", "bu9", "rub100", "cf1", "ufL", "bufback", "uf100", "buffONE", " bufOnce", "uf51", "uf2", "bu31", "buf2", "buff61", "bcONE", " buf2", "bufL", "buff0", "uf9", "buff91", "uber91", "uber0", "uf1", "ufONE", "bgull", "vecback", "ufOnce", "ufone", "raf0", "vec01", "bufONE", " buffernum", "ufull", "BuffOne", "bc1", "buf31", "BuffOnce"], "tuple_type": ["tuple_key", "tuple_t", "tple_type", "tune_size", "tple_key", "c", "end", "text", "tple_block", "tple_unit", "tple_t", "d", "g", "tune_length", "r", "tune2type", "tuple2size", "format", "tune_type", "tune2size", "tune2length", "tuple2length", "tuple_size", "_", "tuple_unit", "tuple_length", "tuple_block", "all", "tuple2type"], "h": ["hi", "m", "en", " H", "hl", "d", "t", "ih", "hr", "l", "i", "g", "hs", "x", "gh", "v", "rh", "o", "hh", "u", "z", "p", "b", "count", "n", "f", "length", "th", "padding", "bh", "c", "ph", "ht", "q", "sl", "H", "sh", "hw", "y", "height"], "w": ["m", "wh", "d", "t", "l", "row", "g", "weight", "wx", "sw", "wt", "x", "how", "v", " W", "kw", "win", "u", "z", "wave", "p", "n", "f", "c", "W", "wd", "ow", "wa", "q", "r", "sh", "we", "work", "window", "wl", "y", "max", "height", "fw"], "depth": ["path", "m", "deep", "root", "dq", "d", "dist", "fl", "id", "level", "style", "weight", "progress", "x", "lang", "rh", "der", "layer", "z", "dev", "p", "time", "count", "length", "n", "phi", "parent", "padding", "th", "Depth", "reverse", "sn", "q", "scale", "debug", "sl", "r", "cache", "pr", "stack", "dr", "quality", "color", "push", "order", "dim", "len", "y", "max", "height"], "maxval": ["maxvalue", "MaxVal", " maxVal", " maxVAL", "axvals", "MAXVAL", "maxVal", "minval", "maxvals", "axval", "minVal", "minvalue", "MaxVAL", "Maxvalue", " maxvals", "maxVAL", "MAXVal", "Maxval", "MAXval", "Maxvals", " maxvalue", "MAXvals", "minvals", "axvalue", "axVal"]}}
{"project": "FFmpeg", "commit_id": "dc64f203a62083c3d5f81e8201018279c29581af", "target": 1, "func": "static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n\n                            AVPacket *avpkt) {\n\n    const uint8_t *buf = avpkt->data;\n\n\n    PTXContext * const s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    AVFrame * const p = &s->picture;\n\n    unsigned int offset, w, h, y, stride, bytes_per_pixel;\n\n    uint8_t *ptr;\n\n\n\n\n\n    offset          = AV_RL16(buf);\n\n    w               = AV_RL16(buf+8);\n\n    h               = AV_RL16(buf+10);\n\n    bytes_per_pixel = AV_RL16(buf+12) >> 3;\n\n\n\n    if (bytes_per_pixel != 2) {\n\n        av_log_ask_for_sample(avctx, \"Image format is not RGB15.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avctx->pix_fmt = PIX_FMT_RGB555;\n\n\n\n    if (buf_end - buf < offset)\n\n\n    if (offset != 0x2c)\n\n        av_log_ask_for_sample(avctx, \"offset != 0x2c\\n\");\n\n\n\n    buf += offset;\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return -1;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    if (avctx->get_buffer(avctx, p) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    for (y=0; y<h; y++) {\n\n        if (buf_end - buf < w * bytes_per_pixel)\n\n            break;\n\n#if HAVE_BIGENDIAN\n\n        unsigned int x;\n\n        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)\n\n            AV_WN16(ptr+x, AV_RL16(buf+x));\n\n#else\n\n        memcpy(ptr, buf, w*bytes_per_pixel);\n\n#endif\n\n        ptr += stride;\n\n        buf += w*bytes_per_pixel;\n\n    }\n\n\n\n    *picture = s->picture;\n\n    *data_size = sizeof(AVPicture);\n\n\n\n    return offset + w*h*bytes_per_pixel;\n\n}", "idx": 1804, "substitutes": {"avctx": ["ajctx", "ajxc", "afcontext", "avalconnection", "navcu", "avmac", "afctl", "afcup", "afkb", "afcn", " avcu", "akconn", "avemac", "avecas", "afcrit", "afci", "avcontext", "afxc", "navconn", "afcmd", "avconnection", "akctx", "afcp", "aveconfig", "AVcontext", "avecu", "akconnection", "avkb", "avectx", "avecf", "afctx", "navctx", "afcli", "aveconn", " avcli", "navcf", "akcontext", "afconnection", "avcf", "avalobj", "afobj", "afrc", "afconn", "ajconfig", "avalcli", "akcrit", "avcp", "avalctl", "akctrl", "avcn", "avconfig", "avalcontext", "aircp", "avrc", "avci", "avalctrl", "AVtx", "avobj", "avcas", "avalctx", "avxc", "afcas", "avtx", " avcup", "avcli", "aftx", "aircontext", "avctrl", "afcu", "aveobj", "afctrl", "avectl", "afcf", "avctl", "avalmac", "navcn", "ajcrit", "ajcontext", "avcrit", "afconfig", "AVctx", "avcmd", " avci", "avconn", "avecp", "avalcf", " avcontext", "avekb", "afmac", " avconfig", " avrc", "navcup", "avcup", "navcontext", "AVkb", "avalcmd", "avalkb", "avetx", "avalconfig", "averc", "akcn", " avcmd", "avecontext", "ajci", "avcu", "akxc", "aircas", "airctx"], "data": ["media", "background", "buffer", "read", "channel", "primary", "device", "queue", "memory", "image", "audio", "binary", "window", "d", "header", "devices", "align", "open", "buff", "video", "bin", "parent", "sample", "frame", "client", "tmp", "api", "batch", "package", "next", "map", "pos", "proc", "body", "slice", "style", "database", "index", "pointer", "config", "pool", "progress", "content", "result", "pad", "reader", "size", "f", "length", "draw", "cache", "value", "DATA", "meta", "connection", "module", "bytes", "val", "load", "dat", "Data", "start", "input"], "data_size": ["data2size", "datablockscale", "total_Size", "data_timeout", "totalblocktimeout", "datablocktimeout", "total_timeout", "data_Size", "totalblockscale", "total_scale", "totalblocksize", "data2Size", "datablockSize", "data_scale", "total_size", "data2scale", "totalblockSize", "datablocksize", "data2timeout"], "avpkt": ["avbpkt", "avbpnt", "avebpnt", "avfpct", "avpct", "avpkw", "avcpkt", "avppct", "avPkg", "avppsth", "avPct", "AVPsth", "avepkw", "avppkt", "AVPct", "avbpkw", "avpkg", "AVpsth", "AVPkg", "avpromkw", "AVpkg", "avpnt", "avpsth", "AVpkt", "avepnt", "avPsth", "avepkt", "avppkg", "avpacket", "avPkt", "avebpacket", "AVpct", "avfpkg", "avpromacket", "avbpacket", "avfpkt", "avfpsth", "avpromnt", "avpromkt", "avcpacket", "avebpkw", "AVPkt", "avebpkt", "avcpkw", "avcpnt", "avepacket"], "buf": ["queue", "home", "cv", "vec", "f", "seq", "uf", "path", "uu", "port", "ff", "bag", "context", "filename", "bc", "buff", "tmp", "cas", "off", "batch", "fp", "plug", "aka", "coord", "text", "v", "ctx", "fw", "ab", "loc", "ru", "cat", "proc", "cb", "func", "feat", "usr", "ref", "br", "cache", "ctr", "cmd", "alloc", "cf", "img", "uc", "fd", "src", "buffer", "bo", "header", "window", "prop", "cur", "wav", "num", "rb", "dest", "box", "comb", "config", "block", "wb", "uint", "padding", "um", "fb", "b", "rc"], "s": ["sg", "np", "js", "service", "cs", "sup", "ss", "a", "share", "r", "d", "sk", "i", "g", "j", "space", "m", "sf", "sync", "slice", "sv", "ps", "gs", "c", "services", "e", "f", "sys", "sq", "conf", "as", "o", "v", "b", "S", "t", "sky", "an", "fs", "si", "sym", "ssl"], "picture": ["media", "np", "pocket", "guide", "buffer", "vp", "photos", "audio", "image", "video", "profile", "pb", "frame", "camera", "package", "png", "detail", "gallery", "photo", "fp", "info", "details", "capt", "config", "pict", "feature", "pkg", "conference", "cache", "game", "jp", "summary", "gui", "obj", "meta", "cp", "plugin", "pic", "img", "family", "avi", "gif", "Picture"], "p": ["pl", "np", "pkg", "vp", "q", "lp", "pd", "a", "pe", "pi", "r", "d", "n", "ap", "sp", "pb", "op", "api", "py", "pre", "i", "g", "tp", "j", "m", "po", "proc", "fp", "P", "pointer", "ps", "post", "l", "c", "pa", "pr", "e", "ip", "f", "per", "patch", "u", "jp", "mp", "up", "o", "v", "pc", "bp", "point", "b", "cp", "t", "pro", "wp", "dp", "pt", "part", "pp", "port"], "offset": ["rot", " padding", "index", "pointer", "address", "alpha", "shift", "xff", "f", "reset", " offsets", "stop", "af", "location", "limit", "start", "port", "adjust", "usage", "image", "align", "type", "position", "slot", "format", "buff", "fff", "end", "off", "api", "fp", "hop", "length", "origin", "t", "a", "loc", "i", "aw", "slice", "pad", "et", "len", "size", "o", "prefix", "timeout", "no", "buffer", "append", "alias", "num", "pos", "entry", "attribute", "bound", "ffff", "padding", "Offset", "b", "addr", "part"], "w": ["q", "n", "weight", "wal", "g", "sw", "f", "u", "wp", "all", "wx", "we", "wt", "type", "sh", " W", "end", "max", "kw", "z", "work", "e", "wd", "v", "t", "wa", "ow", "fw", "r", "aw", "m", "wh", "c", "size", "ww", "win", "ew", "iw", "img", "_", "buffer", "hw", "d", "wl", "W", "pos", "wo", "l", "wb", "height", "b"], "h": ["H", "bh", "q", "ih", "hw", "ht", "high", "r", "d", "n", "sh", "ph", "k", "uh", "ha", "g", "m", "hr", "ah", "z", "hm", "l", "hi", "c", "e", "hh", "f", "size", "height", "hd", "u", "o", "v", "b", "t", "wa", "he", "hs", "oh", "rh", "gh"], "y": ["yi", "key", "ye", "yl", "yo", "gy", "d", "n", "yr", "cy", "k", "ny", "ya", "ty", "i", "py", "j", "ady", "dy", "m", "yn", "z", "ey", "yy", "ch", "hi", "c", "l", "e", "vy", "f", "hop", "height", "col", "u", "o", "v", "b", "ay", "t", "Y", "oy", "wy", "ym", "sy"], "stride": ["strided", "STRided", "tride", "Striden", "trider", "STRision", " strade", "strider", " striden", " strider", "STRipe", "STRade", "Stripe", " stripe", "STRider", "strision", "stripe", "Stride", "STRiden", "trided", "trision", "strade", "STRide", " strided", "striden", "Strade", " strision"], "bytes_per_pixel": ["bytes_per_chip", "bytes_PER_second", "bytes_per\u00b7hour", "bytes_per_channel", "bytes_PER_byte", "bytes_PER_channel", "bytes_Per_scale", "bytes_per_hour", "bytes_per_scale", "bytes_Per_cell", "bytes_Per_byte", "bytes_per\u00b7letter", "bytes_PER_letter", "bytes_per\u00b7pixel", "bytes_PER_pixel", "bytes_per_second", "bytes_per_tile", "bytes_Per_pixel", "bytes_per_byte", "bytes_per\u00b7second", "bytes_per_cell", "bytes_per_letter", "bytes_per\u00b7channel", "bytes_per\u00b7tile"], "ptr": ["dr", "pend", "fd", "src", "buffer", "ctx", "tip", "context", "loc", "bc", "buff", "profile", "cur", "grad", "tmp", "pair", "pos", "proc", "code", "fp", "plug", "tx", "slice", "tr", "pointer", "xp", "address", "pad", "Ptr", "cv", "length", "draw", "attr", "ref", "ctr", "br", "obj", "alloc", "req", "uf", "img", "addr", "val", "pt", "fi", "rect", "port"], "x": ["name", "yx", "key", "image", "d", "n", "ct", "type", "px", "xy", "num", "max", "i", "pos", "dx", "m", "code", "tx", "work", "X", "xs", "index", "z", "xp", "xx", "c", "sw", "l", "e", "f", "ax", "u", "ww", "fx", "win", "v", "ix", "b", "t", "rx", "wa", "val", "xxx", "on", "ex", "my", "xi", "wx"]}}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n    NMIClass *nc = NMI_CLASS(oc);\n\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->ri_allowed = true;\n\n    s390mc->cpu_model_allowed = true;\n\n    s390mc->css_migration_enabled = true;\n\n    s390mc->gs_allowed = true;\n\n    mc->init = ccw_init;\n\n    mc->reset = s390_machine_reset;\n\n    mc->hot_add_cpu = s390_hot_add_cpu;\n\n    mc->block_default_type = IF_VIRTIO;\n\n    mc->no_cdrom = 1;\n\n    mc->no_floppy = 1;\n\n    mc->no_serial = 1;\n\n    mc->no_parallel = 1;\n\n    mc->no_sdcard = 1;\n\n    mc->use_sclp = 1;\n\n    mc->max_cpus = S390_MAX_CPUS;\n\n    mc->has_hotpluggable_cpus = true;\n\n    mc->get_hotplug_handler = s390_get_hotplug_handler;\n\n    mc->cpu_index_to_instance_props = s390_cpu_index_to_props;\n\n    mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;\n\n    /* it is overridden with 'host' cpu *in kvm_arch_init* */\n\n    mc->default_cpu_type = S390_CPU_TYPE_NAME(\"qemu\");\n\n    hc->plug = s390_machine_device_plug;\n\n    hc->unplug_request = s390_machine_device_unplug_request;\n\n    nc->nmi_monitor_handler = s390_nmi;\n\n}\n", "idx": 14356, "substitutes": {"oc": ["toc", "oid", "aco", "uc", "bc", "ob", "rc", "cc", "pc", "config", "object", "roc", "os", "cms", "og", "loc", "OC", "mot", "isc", "o", "oco", "ok", "mic", "co", "cus", "oo", "ocr", "c", "dc", "voc", "ac", "anc", "ucc", "org", "coll", "mac", "oci", "ec", "soc", "fc", "oca", "alloc"], "data": ["func", "record", "d", "config", "object", "da", "def", "os", "di", "module", "raw", "output", "meta", "o", "obj", "doc", "desc", "co", "parent", " dc", "Data", "DATA", "load", "ds", "dd", "cache", "mac"], "mc": ["m", "aco", "cm", "bc", "uc", "ca", "rc", "cc", "pc", "mp", "config", "container", "DC", "roc", "VC", "gc", "lc", "PC", "mn", "cms", "ml", "WC", "module", "di", "mm", "model", "loc", "mx", "mot", "conn", "chain", "meta", "col", "ms", "mr", "doc", "Mc", "mic", "mi", "tc", "co", "cus", "cli", "acl", "cfg", "ma", "spec", "c", "cca", "inc", "NC", "mk", "dc", "fc", "ac", "md", "cf", "coll", "disc", "mac", "ec", "cycle", "core", "cci", "MC"], "nc": ["uc", "bc", "enc", "rc", "cc", "pc", "unc", "cdn", "nn", "roc", "gc", "lc", "ci", "mn", "cn", "conn", "tc", "cca", "c", "inc", "dc", "jc", "ac", "anc", "ucc", "cb", "nt", "fc", "nv", "disc", "nec", "xc", "ec", "nic", "NC", "cci"], "hc": [" hvc", "shc", "hmpc", "Hrc", " hk", "hmc", "hk", "hrc", "shpc", "hmrc", "hvc", " hci", " hpc", "hercs", " hac", "hmci", "hcs", "phc", "phcs", "Hc", "Hci", "hac", "Hpc", " hrc", "herc", "shk", "hpc", "phk", " hcs", "phvc", "hci", "phac", "shac", "hervc", "phpc", "herpc"], "s390mc": ["s40mc", " s40mac", "s90cc", " s40pc", "s40pc", "S390pc", "s370mac", "s90tc", "s90MC", "s390nc", "s90mac", "s620pc", "s370pc", " s90pc", " s390cm", "S90mc", " s170MC", "s90pc", "S90cc", " s40mot", "S370pc", "s40tc", "s380cm", "S370mc", " s170c", "s390c", "s170cc", "S370cm", " s390c", "saferpc", "S390mac", " s90c", "s90mc", "s390mac", "s620mac", "S90tc", " s390pc", "s390tc", "s170MC", "safermc", "safernc", "s90cm", "s370c", "s090mc", "S90mac", "s370nc", "s380c", "s40cc", "s620mot", " s90mc", "S390tc", " s170cc", "s40mot", "s380pc", "s170c", "s090cc", " s390mot", "safercm", "s390pc", "S390cm", "s370mot", "S390mc", "S370nc", "s370cm", "S390cc", "s40c", "s090tc", "s490mc", " s170mc", "s390cm", " s390mac", "s380mc", "s40MC", "s490nc", "s370mc", "s490cm", "s90c", "s170mc", "S390nc", "s390mot", "s390cc", "s090mac", " s90cm", "s620mc", " s390MC", " s390cc", " s40mc", "s490pc", "s40mac", "s390MC"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static inline int decode_vui_parameters(H264Context *h, SPS *sps)\n\n{\n\n    int aspect_ratio_info_present_flag;\n\n    unsigned int aspect_ratio_idc;\n\n\n\n    aspect_ratio_info_present_flag = get_bits1(&h->gb);\n\n\n\n    if (aspect_ratio_info_present_flag) {\n\n        aspect_ratio_idc = get_bits(&h->gb, 8);\n\n        if (aspect_ratio_idc == EXTENDED_SAR) {\n\n            sps->sar.num = get_bits(&h->gb, 16);\n\n            sps->sar.den = get_bits(&h->gb, 16);\n\n        } else if (aspect_ratio_idc < FF_ARRAY_ELEMS(pixel_aspect)) {\n\n            sps->sar = pixel_aspect[aspect_ratio_idc];\n\n        } else {\n\n            av_log(h->avctx, AV_LOG_ERROR, \"illegal aspect ratio\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else {\n\n        sps->sar.num =\n\n        sps->sar.den = 0;\n\n    }\n\n\n\n    if (get_bits1(&h->gb))      /* overscan_info_present_flag */\n\n        get_bits1(&h->gb);      /* overscan_appropriate_flag */\n\n\n\n    sps->video_signal_type_present_flag = get_bits1(&h->gb);\n\n    if (sps->video_signal_type_present_flag) {\n\n        get_bits(&h->gb, 3);                 /* video_format */\n\n        sps->full_range = get_bits1(&h->gb); /* video_full_range_flag */\n\n\n\n        sps->colour_description_present_flag = get_bits1(&h->gb);\n\n        if (sps->colour_description_present_flag) {\n\n            sps->color_primaries = get_bits(&h->gb, 8); /* colour_primaries */\n\n            sps->color_trc       = get_bits(&h->gb, 8); /* transfer_characteristics */\n\n            sps->colorspace      = get_bits(&h->gb, 8); /* matrix_coefficients */\n\n            if (sps->color_primaries >= AVCOL_PRI_NB)\n\n                sps->color_primaries = AVCOL_PRI_UNSPECIFIED;\n\n            if (sps->color_trc >= AVCOL_TRC_NB)\n\n                sps->color_trc = AVCOL_TRC_UNSPECIFIED;\n\n            if (sps->colorspace >= AVCOL_SPC_NB)\n\n                sps->colorspace = AVCOL_SPC_UNSPECIFIED;\n\n        }\n\n    }\n\n\n\n    /* chroma_location_info_present_flag */\n\n    if (get_bits1(&h->gb)) {\n\n        /* chroma_sample_location_type_top_field */\n\n        h->avctx->chroma_sample_location = get_ue_golomb(&h->gb) + 1;\n\n        get_ue_golomb(&h->gb);  /* chroma_sample_location_type_bottom_field */\n\n    }\n\n\n\n    sps->timing_info_present_flag = get_bits1(&h->gb);\n\n    if (sps->timing_info_present_flag) {\n\n        sps->num_units_in_tick = get_bits_long(&h->gb, 32);\n\n        sps->time_scale        = get_bits_long(&h->gb, 32);\n\n        if (!sps->num_units_in_tick || !sps->time_scale) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"time_scale/num_units_in_tick invalid or unsupported (%\"PRIu32\"/%\"PRIu32\")\\n\",\n\n                   sps->time_scale, sps->num_units_in_tick);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sps->fixed_frame_rate_flag = get_bits1(&h->gb);\n\n    }\n\n\n\n    sps->nal_hrd_parameters_present_flag = get_bits1(&h->gb);\n\n    if (sps->nal_hrd_parameters_present_flag)\n\n        if (decode_hrd_parameters(h, sps) < 0)\n\n            return AVERROR_INVALIDDATA;\n\n    sps->vcl_hrd_parameters_present_flag = get_bits1(&h->gb);\n\n    if (sps->vcl_hrd_parameters_present_flag)\n\n        if (decode_hrd_parameters(h, sps) < 0)\n\n            return AVERROR_INVALIDDATA;\n\n    if (sps->nal_hrd_parameters_present_flag ||\n\n        sps->vcl_hrd_parameters_present_flag)\n\n        get_bits1(&h->gb);     /* low_delay_hrd_flag */\n\n    sps->pic_struct_present_flag = get_bits1(&h->gb);\n\n\n\n    sps->bitstream_restriction_flag = get_bits1(&h->gb);\n\n    if (sps->bitstream_restriction_flag) {\n\n        get_bits1(&h->gb);     /* motion_vectors_over_pic_boundaries_flag */\n\n        get_ue_golomb(&h->gb); /* max_bytes_per_pic_denom */\n\n        get_ue_golomb(&h->gb); /* max_bits_per_mb_denom */\n\n        get_ue_golomb(&h->gb); /* log2_max_mv_length_horizontal */\n\n        get_ue_golomb(&h->gb); /* log2_max_mv_length_vertical */\n\n        sps->num_reorder_frames = get_ue_golomb(&h->gb);\n\n        get_ue_golomb(&h->gb); /*max_dec_frame_buffering*/\n\n\n\n        if (get_bits_left(&h->gb) < 0) {\n\n            sps->num_reorder_frames         = 0;\n\n            sps->bitstream_restriction_flag = 0;\n\n        }\n\n\n\n        if (sps->num_reorder_frames > 16U\n\n            /* max_dec_frame_buffering || max_dec_frame_buffering > 16 */) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Clipping illegal num_reorder_frames %d\\n\",\n\n                   sps->num_reorder_frames);\n\n            sps->num_reorder_frames = 16;\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n    if (get_bits_left(&h->gb) < 0) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"Overread VUI by %d bits\\n\", -get_bits_left(&h->gb));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13388, "substitutes": {"h": ["hi", "head", "m", "ch", "hp", "hl", "ha", "enh", "d", "FH", "t", "oh", "hr", "l", "i", "ah", "g", "hs", "x", "gh", "hash", "v", "rh", "kh", "uh", "o", "w", "hh", "ul", "u", "p", "e", "s", "he", "http", "k", "b", "f", "th", "hm", "bh", "c", "ph", "ht", "q", "hand", "r", "H", "sh", "hd", "host", "zh", "history", "him", "esh", "hist", "beh", "header", "hw", "ctx"], "sps": ["unsips", "egs", "scheples", "tsops", "dsops", " spe", "asops", "ansops", "ansips", "asips", "mseps", "tseps", "eps", "srs", "sops", "scheps", "dsps", "lps", "hpps", "sols", "sms", "wspe", "dspps", "ansrs", "lpe", "sinples", "gpps", "ksports", "spp", "eops", "esips", "scs", "pspps", "pseps", "spt", "lsips", "asports", "lspps", "psops", "sips", "anspps", " sms", " sapes", "osips", "msips", "Spp", "tspps", "ispt", " spt", "aspos", " sops", " srs", "jsips", "lseps", "isPS", "wseps", "sapes", "anscs", "jsps", "asrs", " scs", "psports", "lspe", "psips", "tsports", "eseps", "osps", "spe", "wsips", " spps", "sls", "lips", "fseps", "sports", " sbs", "setsples", "msps", "unspe", "tspos", "lports", "sks", "kspps", " spp", "sbs", "isps", "pspos", " sks", "setsols", "pops", "psls", "asps", " sPS", "sPS", "sss", "schepp", "pps", "ests", "unsps", "esps", "setsps", "gps", "ksps", "msts", "tsps", "sgs", "ospps", "dsms", "spos", "psgs", "seps", "gips", "wsps", "Sps", "hps", "lscs", "hgs", "unseps", "ppps", "Spt", " seps", "setspp", "sinps", "ansps", "epps", "fsps", " sports", "ispp", "aspps", " sss", "fsks", "osss", "SPS", "ksips", "peps", "psks", " sls", "fsls", "jspe", "scheols", "jsports", "spps", " sips", "asbs", "anseps", "hops", "sinpp", "aseps", "osapes", "lsps", "psps", "sples", "osports", "gports", "sinols", "sts"], "aspect_ratio_info_present_flag": ["aspect_ratio_info_presentingflag", "aspect_ratio_info_present_count", "aspect_ratio_info_valid_flag", "aspect_ratio_info_valid_count", "aspect_ratio_info_presentingflags", "aspect_ratio_info_present_band", "aspect_ratio_info_presentingcount", "aspect_ratio_info_valid_band", "aspect_ratio_info_show_flag", "aspect_ratio_info_present_bit", "aspect_ratio_info_present_flags", "aspect_ratio_info_show_flags", "aspect_ratio_info_valid_bit", "aspect_ratio_info_show_count"], "aspect_ratio_idc": ["aspect_ratio_idsn", "aspect_ratio_Idx", "aspect_ratio__idee", "aspect_ratio_deff", "aspect_ratio_idci", "aspect_ratio_cdcs", "aspect_ratio__idec", "aspect_ratio_idex", "aspect_ratio__ide", "aspect_ratio_idsx", "aspect_ratio_idn", "aspect_ratio_bidc", "aspect_ratio_cdx", "aspect_ratio_cdc", "aspect_ratio_idse", "aspect_ratio_idf", "aspect_ratio__idef", "aspect_ratio_idcs", "aspect_ratio__idci", "aspect_ratio_idef", "aspect_ratio_defc", "aspect_ratio_idscs", "aspect_ratio__ideci", "aspect_ratio__idf", "aspect_ratio_defn", "aspect_ratio_ider", "aspect_ratio_idsc", "aspect_ratio_ideci", "aspect_ratio_bidr", "aspect_ratio_idec", "aspect_ratio_idee", "aspect_ratio_idx", "aspect_ratio_bidx", "aspect_ratio_Idf", "aspect_ratio_idr", "aspect_ratio_ide", "aspect_ratio_defci", "aspect_ratio_bidci", "aspect_ratio_Idc", "aspect_ratio_cdf", "aspect_ratio_idsci", "aspect_ratio_idsf", "aspect_ratio_Idn", "aspect_ratio_Ide", "aspect_ratio__idc", "aspect_ratio_Idci"]}}
{"project": "qemu", "commit_id": "9eca6cc64392b4ad8bd8723e840f491fa36524ad", "target": 0, "func": "sprintf_len(char *string, const char *format, ...)\n\n#else\n\nsprintf_len(va_alist) va_dcl\n\n#endif\n\n{\n\n\tva_list args;\n\n#ifdef __STDC__\n\n\tva_start(args, format);\n\n#else\n\n\tchar *string;\n\n\tchar *format;\n\n\tva_start(args);\n\n\tstring = va_arg(args, char *);\n\n\tformat = va_arg(args, char *);\n\n#endif\n\n\tvsprintf(string, format, args);\n\n\treturn strlen(string);\n\n}\n", "idx": 25167, "substitutes": {"format": ["space", "call", "package", "args", "argument", " formatting", "transform", "name", "function", "template", "time", "data", "attribute", "style", "ant", "pointer", "text", "filename", "base", "letter", "type", "prefix", "property", "version", "Format", "form", "character", "method", "unit", "str", "term", "command", "at", "pattern", "spec", "magic", "size", "scale", "feat", "field", "length", "arg", "array", "before", "f", "source", "value", "pretty", "alpha", "language", "len", "file"]}}
{"project": "qemu", "commit_id": "a22313deca720e038ebc5805cf451b3a685d29ce", "target": 0, "func": "static void vfio_platform_eoi(VFIODevice *vbasedev)\n\n{\n\n    VFIOINTp *intp;\n\n    VFIOPlatformDevice *vdev =\n\n        container_of(vbasedev, VFIOPlatformDevice, vbasedev);\n\n\n\n    qemu_mutex_lock(&vdev->intp_mutex);\n\n    QLIST_FOREACH(intp, &vdev->intp_list, next) {\n\n        if (intp->state == VFIO_IRQ_ACTIVE) {\n\n            trace_vfio_platform_eoi(intp->pin,\n\n                                event_notifier_get_fd(&intp->interrupt));\n\n            intp->state = VFIO_IRQ_INACTIVE;\n\n\n\n            /* deassert the virtual IRQ */\n\n            qemu_set_irq(intp->qemuirq, 0);\n\n\n\n            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {\n\n                /* unmasks the physical level-sensitive IRQ */\n\n                vfio_unmask_single_irqindex(vbasedev, intp->pin);\n\n            }\n\n\n\n            /* a single IRQ can be active at a time */\n\n            break;\n\n        }\n\n    }\n\n    /* in case there are pending IRQs, handle the first one */\n\n    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {\n\n        intp = QSIMPLEQ_FIRST(&vdev->pending_intp_queue);\n\n        vfio_intp_inject_pending_lockheld(intp);\n\n        QSIMPLEQ_REMOVE_HEAD(&vdev->pending_intp_queue, pqnext);\n\n    }\n\n    qemu_mutex_unlock(&vdev->intp_mutex);\n\n}\n", "idx": 24162, "substitutes": {"vbasedev": ["vbasedesc", "vbaseef", "vbaseev", " vakedev", "vbasedown", "verbasediv", "vfedell", "vakeddev", "svasedell", "vbackeddev", "verbasedev", "vbuiltef", "vmadee", " vbasedef", "vmadiv", "svbasedell", "vfedesc", "vldee", " vbaseef", "vasedev", "vldown", "vfedee", "vbaseiv", "vfedev", "vbuiltiv", "vbasedom", "vadedell", "vadedev", "vfedown", " vbasedom", " vbaseddev", "verbasedee", "svbasedesc", "svasedesc", "verbasedown", " vakedef", "vbackedom", "vadedesc", "vakedef", "svbasedev", " vbaseiv", "vbuiltdev", "vbuiltev", "vmadev", " vakedom", "svasedown", "vadedown", "vasedell", "vbasedef", "vasedesc", "vldev", " vbasediv", "verldev", "vasedown", "svbasedown", "verldee", "vfediv", "vbasedee", "verldiv", "vbackedef", " vakeddev", "vbasedell", "vakedev", "vbackedev", "svasedev", "vbackediv", "vakedom", "vbaseddev", "vbasediv", "vldiv", " vbaseev", "vmadown", "verldown"], "intp": ["intq", "INTp", "INTc", "intf", "interc", "structq", "pointu", "intsc", "ortps", "intu", "uintP", "ortf", "xtp", "Intl", "INTu", "indP", " intpa", "Intp", "intpc", "genpe", "xtps", "indpoint", "xtpc", "ntP", "Intc", "indpr", "Intpc", "ntf", "uintp", "interl", "indp", "indd", "intP", " intq", "interp", "indps", "interu", "inte", "intc", "ntpoint", "pointpc", "incpa", "pointc", "bitc", "genv", "intpoint", "structc", "intps", "intv", "idv", "ipp", "bitpoint", "interpc", "incv", "Intpoint", "intsl", "idpe", "structpr", "indv", "ntp", " intP", " intps", "genP", "indpe", "pointp", "incps", "ortpoint", " intd", "intd", "inpr", "uintpr", "uintv", "ntpa", "uintpc", "xte", "intpa", "intsp", "ipc", " intc", "intl", "ine", "idp", "inde", "incP", "indpc", "uintd", "incp", "intspc", "ortpc", "ortc", "Intv", "intpe", "structp", "uintq", "ippr", "ntc", "ortp", "orte", "INTpc", "bitp", "genp", "idP", "inc", "uintc", "bitP", "ipe", "IntP", "indq", "ntps", "inp", "indf", "incpc", "indc", "intpr"], "vdev": ["varrad", "vdem", "tvdef", "verror", "wdef", "Vdevelopment", "pdevice", "Vvalid", "tvrad", "qdiff", "qdef", "vdevelopment", "svdef", "nmod", "vardev", "ndev", "vardef", "Verror", "ovdef", "pdc", "svconn", " vdiv", "ldev", "qerror", "tvvalid", " vdem", "qconn", "ovvalid", "Vdc", "Vconf", "vdiff", "pmod", "qdevelopment", "Vdev", "qdiv", "Vconn", "vvdevice", "svdem", "Vmod", "vvalid", "ndc", "qdev", "wdev", " vdef", "ldevelopment", "vdef", "vvdev", "vrad", "vdevice", "vdc", "wdevice", "ldef", "wvalid", "Vdef", "Vdiv", "vdiv", "Vdem", "pdev", "qconf", "varvalid", "ldiff", "vverror", "vmod", "svdiv", "Vdevice", "tvdev", "ndevice", "Vdiff", "vconf", "Vrad", "vconn", "vvconf", "svdevice", "svdev", "ovdev", "qdevice", "ovdevice"]}}
{"project": "qemu", "commit_id": "5a2223ca26b1a34e131b5b9a63599d9426d2c25c", "target": 0, "func": "int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,\n\n                              PCIHotplugState state)\n\n{\n\n    int slot = PCI_SLOT(dev->devfn);\n\n    int bsel = acpi_pcihp_get_bsel(dev->bus);\n\n    if (bsel < 0) {\n\n        return -1;\n\n    }\n\n\n\n    /* Don't send event when device is enabled during qemu machine creation:\n\n     * it is present on boot, no hotplug event is necessary. We do send an\n\n     * event when the device is disabled later. */\n\n    if (state == PCI_COLDPLUG_ENABLED) {\n\n        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n        return 0;\n\n    }\n\n\n\n    if (state == PCI_HOTPLUG_ENABLED) {\n\n        enable_device(s, bsel, slot);\n\n    } else {\n\n        disable_device(s, bsel, slot);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 11016, "substitutes": {"s": ["session", "sg", "ks", "sv", "ds", "is", "g", "si", "m", "info", "http", "b", "t", "ops", "d", "i", "gs", "service", "c", "server", "p", "e", "js", "sq", "us", "os", "f", "an", "rs", "sym", "cs", "o", "S", "es", "sync", "south", "states", "services", "sl", "r", "ns", "sb", "spec", "u", "self", "sys", "ions", "ses", "fs", "ps", "su", "a", "ss", "ssl"], "dev": ["diff", "debug", "comment", "Dev", " device", "info", "def", "w", "prom", "die", "game", "dem", "development", "adv", "d", "ver", "de", "data", "ad", "block", "app", "driver", "bug", "rad", "priv", "serial", "ev", "device", "v", "md", "end", "dd", "dc", "bus", "sd", "grad", "od", "der", "engine", "cmd", "wd"], "state": ["parent", "un", "session", "State", "start", "handle", "key", "statement", "tag", "t", "instance", "stat", "d", "shadow", "head", "config", "p", "rule", "e", "status", "driver", "se", "set", "role", "ace", "STATE", "style", "st", "mode", " self", "resource", "scope", "sync", "name", "states", "sl", "cur", "see", "err", "port", "part", "spec", "type", "self", "lock", " states", " State", "ignore", "use", "ss", "seed", "settings"]}}
{"project": "FFmpeg", "commit_id": "86dfcfd0e30d6645eea2c63c1c60a0550e7c97ea", "target": 1, "func": "static int read_kuki_chunk(AVFormatContext *s, int64_t size)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st      = s->streams[0];\n\n\n\n    if (size < 0 || size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)\n\n        return -1;\n\n\n\n    if (st->codec->codec_id == AV_CODEC_ID_AAC) {\n\n        /* The magic cookie format for AAC is an mp4 esds atom.\n\n           The lavc AAC decoder requires the data from the codec specific\n\n           description as extradata input. */\n\n        int strt, skip;\n\n        MOVAtom atom;\n\n\n\n        strt = avio_tell(pb);\n\n        ff_mov_read_esds(s, pb, atom);\n\n        skip = size - (avio_tell(pb) - strt);\n\n        if (skip < 0 || !st->codec->extradata ||\n\n            st->codec->codec_id != AV_CODEC_ID_AAC) {\n\n            av_log(s, AV_LOG_ERROR, \"invalid AAC magic cookie\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        avio_skip(pb, skip);\n\n    } else if (st->codec->codec_id == AV_CODEC_ID_ALAC) {\n\n#define ALAC_PREAMBLE 12\n\n#define ALAC_HEADER   36\n\n#define ALAC_NEW_KUKI 24\n\n        uint8_t preamble[12];\n\n        if (size < ALAC_NEW_KUKI) {\n\n            av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n            avio_skip(pb, size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        avio_read(pb, preamble, ALAC_PREAMBLE);\n\n\n\n        st->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.\n\n         * The new style cookie only contains the last 24 bytes of what was\n\n         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes\n\n         * in that case to maintain compatibility. */\n\n        if (!memcmp(&preamble[4], \"frmaalac\", 8)) {\n\n            if (size < ALAC_PREAMBLE + ALAC_HEADER) {\n\n                av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n                av_freep(&st->codec->extradata);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            avio_read(pb, st->codec->extradata, ALAC_HEADER);\n\n            avio_skip(pb, size - ALAC_PREAMBLE - ALAC_HEADER);\n\n        } else {\n\n            AV_WB32(st->codec->extradata, 36);\n\n            memcpy(&st->codec->extradata[4], \"alac\", 4);\n\n            AV_WB32(&st->codec->extradata[8], 0);\n\n            memcpy(&st->codec->extradata[12], preamble, 12);\n\n            avio_read(pb, &st->codec->extradata[24], ALAC_NEW_KUKI - 12);\n\n            avio_skip(pb, size - ALAC_NEW_KUKI);\n\n        }\n\n        st->codec->extradata_size = ALAC_HEADER;\n\n    } else {\n\n        st->codec->extradata = av_mallocz(size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n        avio_read(pb, st->codec->extradata, size);\n\n        st->codec->extradata_size = size;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24230, "substitutes": {"s": ["S", "space", "sc", "ses", "rs", "sys", "sr", "ss", "p", "b", "i", "c", "bis", "ns", "ts", "sed", "sq", "ds", "us", "ps", "sg", "ks", "sync", "bs", "self", "su", "is", "e", "gs", "south", "sie", "ions", "lines", "session", "sts", "spec", "sv", "l", "si", "less", "sign", "aws", "os", "sb", "services", "sa", "sing", "xs", "ls", "f", "service", "sim", "js", "fs", "t", "an", "v", "sl", "r", "sf", "ops", "ssl", "cs", "g"], "size": ["use", "name", "time", "enc", "buffer", "num", "second", "any", "max", "SIZE", "fee", "number", "six", "n", "core", "content", "complete", "code", "body", "ize", "p", "c", "empty", "sized", "storage", "sum", "en", "address", "speed", "form", "cache", "shape", "now", "timeout", "iz", "large", "len", "g", "args", "sn", "data", "send", "capacity", "Size", "small", "offset", "sec", "length", "count", "page", "i", "shift", "type", "loc", "si", "scale", "handle", "v"], "pb": ["summary", "txt", "uf", "pa", "uc", "p", "b", "parser", "pg", "wb", "pkg", "lb", "ppa", "cv", "bb", "xb", "api", "rb", "ab", "bf", "bh", "jp", "alist", "cb", "gb", "bc", "dp", "py", "prop", "bp", "platform", "bs", "proc", "typ", "plugin", "db", "hub", "PB", "fc", "rob", "fab", "pd", "tmp", "loc", "eb", "pl", "cli", "ctx", "cp", "fb", "sb", "ub", "pm", "lab", "bot", "lc", "wp", "lp", "prot", "tp", "fp", "cpp", "bm", "bps", "vp", "pc", "ib"], "st": ["rest", "std", "sc", "fe", "ST", "ft", "ss", "pt", "rd", "sn", "se", "ts", "sam", "sw", "ld", "ste", "ct", "ast", "ust", "inst", "end", "St", "fr", "typ", "sth", "sp", "td", "sta", "str", "nd", "start", "mt", "sts", "art", "sign", "nt", "lt", "sb", "client", "est", "ist", "sa", "ost", "stage", "stop", "t", "stack", "sd", "dest", "sl", "sf", "post", "put", "ut", "kt"], "strt": ["Strtt", "srs", "drt", "charts", "charT", "frt", "strT", "STRte", "strtt", "trte", "drtt", "chartt", " strT", " strtt", "trt", "srd", "Strts", "Strt", "strs", "drT", "strts", "STRt", "strte", "STRtt", "srt", " strd", "drts", "STRT", " strte", "frts", " strts", "trtt", "strd", "StrT", "chart", " strs", "frd", "trT", "srts", "frs"], "skip": ["use", "call", "gap", "slice", "parse", "jump", "keep", "name", "scroll", "read", "success", "delay", "ignore", "fail", "access", "type", "hide", "speed", "pass", "write", "sync", "op", "allow", "link", "step", "unit", "miss", "min", "zero", "start", "nic", "spec", "offset", "run", "blank", "scale", "item", "hop", "missing", "need", "scan", "sleep", "loop", "ipp", "stop", "eat", "n", "ip", "index", "limit", "Skip", "pos", "wait"], "atom": ["acc", "node", "mom", "cm", "np", "class", "info", "p", "m", "app", "fam", "data", "tm", "base", "orb", "ab", "om", "prop", "component", "oms", "am", "type", "abc", "article", "op", "atomic", "typ", "rss", "mag", " atoms", "tmp", "term", "at", "spec", "abb", "item", "com", "channel", "xml", "tab", "array", "list", "tom", "kat", " Atom", "attr", "plane", "map"], "preamble": [" pREAMble", "pREAMbled", "parsbling", " preambled", "parenble", "pairle", " parenle", "parml", "pairbling", "parmbe", "prambe", "pramble", "prawbe", " pREAMle", "preambling", " parmBLE", " preamBLE", "pairble", " parmbe", "pramBLE", "parmbled", "parmBLE", "prawBLE", "prawle", " preambe", " preamle", "parenBLE", "parsBLE", "parmble", "parsble", "parsle", " parenble", " parenBLE", "prawble", "preambe", "praml", "pREAMle", "prambled", "preaml", "parenle", "pREAMble", "pramle", "parenbling", " pREAMbled", " parmle", " parenbling", "parmle", " parmble", "pairBLE", "preamle", " preaml", " pREAMl", "preambled", "pREAMl", " preambling", "preamBLE"]}}
{"project": "qemu", "commit_id": "d049bde69d8ab3dfa4edeee48896088ae9feb693", "target": 1, "func": "static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset,\n\n                                       sPAPRPHBState *sphb)\n\n{\n\n    ResourceProps rp;\n\n    bool is_bridge = false;\n\n    int pci_status, err;\n\n    char *buf = NULL;\n\n    uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev);\n\n    uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3);\n\n    uint32_t max_msi, max_msix;\n\n\n\n    if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) ==\n\n        PCI_HEADER_TYPE_BRIDGE) {\n\n        is_bridge = true;\n\n    }\n\n\n\n    /* in accordance with PAPR+ v2.7 13.6.3, Table 181 */\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"vendor-id\",\n\n                          pci_default_read_config(dev, PCI_VENDOR_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"device-id\",\n\n                          pci_default_read_config(dev, PCI_DEVICE_ID, 2)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"revision-id\",\n\n                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"class-code\", ccode));\n\n    if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"interrupts\",\n\n                 pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)));\n\n    }\n\n\n\n    if (!is_bridge) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"min-grant\",\n\n            pci_default_read_config(dev, PCI_MIN_GNT, 1)));\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"max-latency\",\n\n            pci_default_read_config(dev, PCI_MAX_LAT, 1)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)));\n\n    }\n\n\n\n    if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"subsystem-vendor-id\",\n\n                 pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"cache-line-size\",\n\n        pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1)));\n\n\n\n    /* the following fdt cells are masked off the pci status register */\n\n    pci_status = pci_default_read_config(dev, PCI_STATUS, 2);\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"devsel-speed\",\n\n                          PCI_STATUS_DEVSEL_MASK & pci_status));\n\n\n\n    if (pci_status & PCI_STATUS_FAST_BACK) {\n\n        _FDT(fdt_setprop(fdt, offset, \"fast-back-to-back\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_66MHZ) {\n\n        _FDT(fdt_setprop(fdt, offset, \"66mhz-capable\", NULL, 0));\n\n    }\n\n    if (pci_status & PCI_STATUS_UDF) {\n\n        _FDT(fdt_setprop(fdt, offset, \"udf-supported\", NULL, 0));\n\n    }\n\n\n\n    _FDT(fdt_setprop_string(fdt, offset, \"name\",\n\n                            pci_find_device_name((ccode >> 16) & 0xff,\n\n                                                 (ccode >> 8) & 0xff,\n\n                                                 ccode & 0xff)));\n\n    buf = spapr_phb_get_loc_code(sphb, dev);\n\n    if (!buf) {\n\n        error_report(\"Failed setting the ibm,loc-code\");\n\n        return -1;\n\n    }\n\n\n\n    err = fdt_setprop_string(fdt, offset, \"ibm,loc-code\", buf);\n\n    g_free(buf);\n\n    if (err < 0) {\n\n        return err;\n\n    }\n\n\n\n    if (drc_index) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index));\n\n    }\n\n\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#address-cells\",\n\n                          RESOURCE_CELLS_ADDRESS));\n\n    _FDT(fdt_setprop_cell(fdt, offset, \"#size-cells\",\n\n                          RESOURCE_CELLS_SIZE));\n\n\n\n    max_msi = msi_nr_vectors_allocated(dev);\n\n    if (max_msi) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi\", max_msi));\n\n    }\n\n    max_msix = dev->msix_entries_nr;\n\n    if (max_msix) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,req#msi-x\", max_msix));\n\n    }\n\n\n\n    populate_resource_props(dev, &rp);\n\n    _FDT(fdt_setprop(fdt, offset, \"reg\", (uint8_t *)rp.reg, rp.reg_len));\n\n    _FDT(fdt_setprop(fdt, offset, \"assigned-addresses\",\n\n                     (uint8_t *)rp.assigned, rp.assigned_len));\n\n\n\n    if (sphb->pcie_ecs && pci_is_express(dev)) {\n\n        _FDT(fdt_setprop_cell(fdt, offset, \"ibm,pci-config-space-type\", 0x1));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 740, "substitutes": {"dev": ["serial", "test", "vol", "cam", "def", "dd", "spec", "hw", "conn", "device", "mod", "desc", "data", "current", "development", "d", "ver", "devices", "di", "google", "der", "prof", "priv", "grad", "de", "dom", "off", "fail", "Dev", "DEV", "des", "proc", "info", "bug", "md", "ch", "progress", "user", "dc", "home", "pad", "block", "gu", "prom", "app", "attr", "conf", "loader", " device", "die", "comment", "ev", "dem", "rad", "error", "od", "prov", "valid", "serv", "reg", "debug", "mode", "dis", "diff", "dist"], "fdt": ["feedt", "fxwt", "mdwt", "dlT", "fdn", "dlc", "dfz", "dfT", "lfd", "vdT", "dlts", "vdout", "dirwt", "fdd", "FDtt", "fedt", "FDc", "dirt", "ydn", "gdts", "lfts", "ecdwt", "dirtt", "fdtt", "dlta", "ydtt", "fdtz", "sdtt", "mdT", "vdn", "vdtz", "ydtz", "fdout", "fdnot", "dfout", "dlnot", "feedT", "ldtt", "mdc", "ldn", "vdt", "fedc", "sdt", "gdd", "FDt", "fxc", "dft", "fedz", "fdta", "FDwt", "vdtt", "sdT", "fxt", "dld", "ecdt", "FDta", "fedwt", "feedwt", "sdz", "dlwt", "fxta", "fdz", "ydt", "fedT", "gdt", "FDout", "fdwt", "ldtz", "fedtt", "lfc", "ecdtt", "lft", "dfta", "ldt", "ecdnot", "FDT", "dftt", "dltt", "gdc", "fdts", "mdt", "fdc", "fdT", "dfwt", "dirnot", "feedta", "dlt"], "offset": ["rot", "layer", "append", "outer", "trace", "skip", "no", "et", "array", "alias", "url", "loc", "align", "scroll", "position", "slot", "format", "off", "initial", "api", "seed", "next", "pos", "output", "item", "fp", "entry", "sync", "attribute", "slice", "style", "index", "pointer", "offer", "enabled", "address", "begin", "pad", "shift", "start", "layout", "bound", "reset", "length", "set", "ref", "len", "attr", "origin", "range", "padding", "phase", "o", "prefix", "exclusive", "optional", "Offset", "error", "online", "location", "addr", "enter", "limit", "part", "timeout"], "sphb": [" sphBs", " sphsb", "scld", "pshb", "sppb", "sphsb", "sppsb", " sppsb", "sshd", "sppr", "pphr", "sppBs", " sphr", "sphar", "sshp", "sphap", "sphr", "pphb", "smphsb", " sppBs", "sphp", "smphBs", "sshr", "smphr", "pphp", " sppb", "sphd", "sphab", "sshsb", "sclp", "pshr", "pshp", "sshb", " sppr", "sclr", "smphb", "sphBs", "sshBs", "sclb", "sphad", "pshd", "pphd"], "rp": ["nrP", "rper", "nrp", " rP", "rP", "Rp", "RP", " rper", "nrper", "Rper"], "pci_status": ["pci__status", "pci_stat", "pci__error", "pcm_err", "pci__err", "pcm_error", "pcm_status", "pci__stat", "pci_err", "pci_error", "pcm_stat"], "err": ["rs", "Error", "rr", "r", " error", "proc", "info", "cb", "er", "cr", "str", "temp", "progress", "errors", "result", "ind", "e", "len", "attr", "cache", "ctr", "resp", "error", "req", "msg", "iter", "fi", "res"], "buf": ["fd", "src", "buffer", "ctx", "queue", "mem", "data", "buff", "tmp", "fp", "cb", "temp", "pool", "pad", "block", "Buffer", "ptr", "ref", "br", "cache", "cmd", "alloc", "seq", "bytes", "uf", "path", "rc", "port"], "max_msi": ["max_ksI", "max_ssi", "max_MSI", "max_ssd", "max_MSii", "max_MSd", "max_msii", "max_ssI", "max_ksii", "max_ksd", "max_ksi", "max_MSi", "max_msd", "max_ssii", "max_msI"], "max_msix": ["max_mmix", "max_ansi", "max_mi", "max_msiz", "max_mmci", "max_mmi", "max_ansix", "max_mix", "max_msci", "max_miz", "max_mci", "max_ansci", "max_ansiz", "max_mmiz"]}}
{"project": "FFmpeg", "commit_id": "8cd1c0febe88b757e915e9af15559575c21ca728", "target": 1, "func": "static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n\n                            AVPacket *avpkt) {\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    PCXContext * const s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    AVFrame * const p = &s->picture;\n\n    int compressed, xmin, ymin, xmax, ymax;\n\n    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,\n\n                 bytes_per_scanline;\n\n    uint8_t *ptr;\n\n    uint8_t const *bufstart = buf;\n\n    uint8_t *scanline;\n\n    int ret = -1;\n\n\n\n    if (buf[0] != 0x0a || buf[1] > 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"this is not PCX encoded data\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    compressed = buf[2];\n\n    xmin = AV_RL16(buf+ 4);\n\n    ymin = AV_RL16(buf+ 6);\n\n    xmax = AV_RL16(buf+ 8);\n\n    ymax = AV_RL16(buf+10);\n\n\n\n    if (xmax < xmin || ymax < ymin) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid image dimensions\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    w = xmax - xmin + 1;\n\n    h = ymax - ymin + 1;\n\n\n\n    bits_per_pixel     = buf[3];\n\n    bytes_per_line     = AV_RL16(buf+66);\n\n    nplanes            = buf[65];\n\n    bytes_per_scanline = nplanes * bytes_per_line;\n\n\n\n    if (bytes_per_scanline < w * bits_per_pixel * nplanes / 8) {\n\n        av_log(avctx, AV_LOG_ERROR, \"PCX data is corrupted\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch ((nplanes<<8) + bits_per_pixel) {\n\n        case 0x0308:\n\n            avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n            break;\n\n        case 0x0108:\n\n        case 0x0104:\n\n        case 0x0102:\n\n        case 0x0101:\n\n        case 0x0401:\n\n        case 0x0301:\n\n        case 0x0201:\n\n            avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCX file\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    buf += 128;\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return AVERROR_INVALIDDATA;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    if ((ret = avctx->get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    scanline = av_malloc(bytes_per_scanline);\n\n    if (!scanline)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (nplanes == 3 && bits_per_pixel == 8) {\n\n        for (y=0; y<h; y++) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++) {\n\n                ptr[3*x  ] = scanline[x                    ];\n\n                ptr[3*x+1] = scanline[x+ bytes_per_line    ];\n\n                ptr[3*x+2] = scanline[x+(bytes_per_line<<1)];\n\n            }\n\n\n\n            ptr += stride;\n\n        }\n\n\n\n    } else if (nplanes == 1 && bits_per_pixel == 8) {\n\n        const uint8_t *palstart = bufstart + buf_size - 769;\n\n\n\n        for (y=0; y<h; y++, ptr+=stride) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n            memcpy(ptr, scanline, w);\n\n        }\n\n\n\n        if (buf != palstart) {\n\n            av_log(avctx, AV_LOG_WARNING, \"image data possibly corrupted\\n\");\n\n            buf = palstart;\n\n        }\n\n        if (*buf++ != 12) {\n\n            av_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto end;\n\n        }\n\n\n\n    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */\n\n        GetBitContext s;\n\n\n\n        for (y=0; y<h; y++) {\n\n            init_get_bits(&s, scanline, bytes_per_scanline<<3);\n\n\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++)\n\n                ptr[x] = get_bits(&s, bits_per_pixel);\n\n            ptr += stride;\n\n        }\n\n\n\n    } else {    /* planar, 4, 8 or 16 colors */\n\n        int i;\n\n\n\n        for (y=0; y<h; y++) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++) {\n\n                int m = 0x80 >> (x&7), v = 0;\n\n                for (i=nplanes - 1; i>=0; i--) {\n\n                    v <<= 1;\n\n                    v  += !!(scanline[i*bytes_per_line + (x>>3)] & m);\n\n                }\n\n                ptr[x] = v;\n\n            }\n\n            ptr += stride;\n\n        }\n\n    }\n\n\n\n    if (nplanes == 1 && bits_per_pixel == 8) {\n\n        pcx_palette(&buf, (uint32_t *) p->data[1], 256);\n\n    } else if (bits_per_pixel * nplanes == 1) {\n\n        AV_WN32A(p->data[1]  , 0xFF000000);\n\n        AV_WN32A(p->data[1]+4, 0xFFFFFFFF);\n\n    } else if (bits_per_pixel < 8) {\n\n        const uint8_t *palette = bufstart+16;\n\n        pcx_palette(&palette, (uint32_t *) p->data[1], 16);\n\n    }\n\n\n\n    *picture = s->picture;\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    ret = buf - bufstart;\n\nend:\n\n    av_free(scanline);\n\n    return ret;\n\n}\n", "idx": 23786, "substitutes": {"avctx": ["avcam", "AVkb", "avesync", "aveloc", "avcv", "afcc", "vercontext", " avcv", "avsync", "afnp", "AVcp", "verconn", "avcca", "verctx", "avconn", "avecc", "avcp", "avecp", "afctx", "AVcontext", "avercontext", "avercca", "vercam", "AVsync", "avercas", "avcas", "AVnp", "afloc", "avnp", "averctx", "avercam", "versync", "avecontext", "avalcas", "AVcca", "avekb", "avecv", "verkb", "avcontext", "AVconn", "avenp", " avcc", "averconn", " avconn", "avalctx", " avloc", "avalcca", "avectx", "AVcam", "afcontext", "AVctx", "afconn", "avalcontext", " avcontext", "afcv", "avkb", "afcp", "aveconn", "avcc", "AVcas", "avloc"], "data": ["package", "start", "next", "sample", "config", "result", "input", "val", "text", "Data", "connection", "queue", "d", "meta", "pad", "buffer", "results", "pos", "entry", "size", "cache", "body", "record", "open", "content", "client", "memory", "frame", "audio", "module", "window", "DATA", "channel", "read", "media", "reader", "database", "batch", "feed", "buff", "parent", "doc", "proc", "dat", "image", "block", "api", "base", "video", "value"], "data_size": ["data_name", " data_capacity", " data_len", " data_name", "data_capacity", "data_len"], "avpkt": ["avskt", "avesck", "avpnt", "abfacket", "aveppsth", "aveppnt", "avepck", "avcft", "avfck", "abfft", "avpck", "abfct", "abpacket", "avPacket", "avepnt", "avesacket", "avfkt", "avcpkt", "avPsth", "abfkt", "avPnt", "avcct", "abpkt", "avfct", "avcpft", "avpft", "avssth", "avfacket", "avpct", "avppsth", "aveskt", "avppnt", "avcpnt", "avsacket", "avsck", "avPck", "avfsth", "avppacket", "aveppkt", "avcpsth", "aveppacket", "avepsth", "avpsth", "avepacket", "avessth", "avcpct", "avckt", "avfft", "abpft", "avcpacket", "avPkt", "abpct", "avpacket", "avppkt", "avcacket", "avepkt"], "buf": ["conv", "begin", "bc", "uint", "port", "uf", "prop", "uc", "brace", "config", "text", "pkg", "cv", "fb", "queue", "func", "utf", "pad", "Buff", "img", "cur", "cas", "home", "buffer", "gb", "uber", "alloc", "coord", "cmd", "grab", "tab", "box", "cf", "uv", "context", "wb", "pool", "c", "cb", "ctx", "plug", "aux", "b", "window", "bo", "tmp", "usr", "seq", "fd", "src", "wav", "br", "bd", "loc", "ab", "feed", "batch", "aka", "buff", "proc", "chrom", "bag", "vec", "rb", "dest", "block", "fam", "feat", "cap", "pub"], "s": ["sky", "sv", "sb", "e", "space", "sl", "fs", "g", "d", "as", "ds", "ages", "f", "r", "m", "size", "j", "os", "ssl", "cs", "o", "q", "sa", "sg", "c", "sq", "pass", "si", "a", "b", "S", "sup", "sf", "ps", "rs", "v", "conf", "sec", "l", "ss", "share"], "picture": ["camera", "package", "summary", "cam", "space", "fine", "obj", "movie", "config", "mini", "meta", "uri", "piece", "feature", "Picture", "style", "img", "buffer", "pict", "info", "gallery", "pic", "detail", "ctx", "frame", "brush", "family", "gui", "profile", "conference", "library", "media", "details", "plan", "definition", "avi", "image", "photo", "guide", "base", "video"], "p": ["pb", "port", "e", "g", "pi", "d", "P", "pd", "pc", "fp", "f", "r", "m", "it", "o", "np", "py", "c", "mp", "a", "b", "ps", "proc", "v", " P", "vp", "l"], "compressed": [" uncompression", "suppressor", "ompacted", " composed", "compressor", " compacted", " compression", "ompressed", " uncompressor", "ompression", "suppacted", "suppressed", "suppression", " decompacted", " decompressed", "expressed", " decomposed", "expacted", " uncompressed", "compacted", " uncompacted", "composed", "expression", " decompression", "expressor", "omposed", "compression"], "xmin": ["Xmax", "ystart", " xstart", "ixpos", "wmin", "exMin", "xmins", "exmin", "Xmin", "wmax", " xmini", "xmini", "wmins", "ixmax", "xstart", "Xstart", "ypos", " xpos", "ixmin", " xMin", "wpos", " xinit", "xMin", "wMin", "ymini", "xinit", "exmax", "ymins", "yMin", "Xmini", "yinit", "ixinit", "xpos", "exmins"], "ymin": ["xonly", "y0", "ystart", "Ymini", " yname", "sypos", "eymax", "symini", "xmean", "syonly", "systart", "eypos", "sy0", "eymean", "eyonly", "yonly", "yname", "Y0", " y0", "Ymax", "ypos", "xname", "Ymin", " yonly", "Yname", "eymin", " ystart", "Ystart", " ymean", "ymini", " ymini", "symin", "symax", "xpos", "ymean"], "xmax": ["Xend", "Xmax", "xxend", "yMAX", "axend", "xMAX", "xxax", "exmin", "Xmin", "Xdiv", "dxmad", "xxmax", "dxmax", "xdiv", " xmad", " xlast", "xxlast", "exend", "xlast", "yend", "axdiv", "xend", " xdiv", "dxend", " xMAX", "xax", "exMAX", "xxmad", "dxax", "xxmin", " xend", "exmax", "Xlast", "axmax", "xmad", " xax", "axmin"], "ymax": ["atemail", "iamail", "ymmak", "tmack", "ymand", "ymass", "iamack", "ymaz", "tmax", "atemade", "imak", "ammax", "iemax", "yrax", "iemand", "ymak", "ammail", "imase", "mmaz", "ymmaz", "iemaz", "ymmap", "ymaze", "ymmand", "ymake", "ymase", "yrass", "iamake", "ymack", "imax", "mmap", "iamax", "yahass", "ymade", "yrak", "yraze", "iamase", "mmand", "iamak", "mmax", "iamade", "ymmax", "atemax", "ammade", "yahax", "ymap", "tmase", "tmak", "iemap", "ymail", "yahaze", "atemake", "ymmaze", "yahak", "ammake", "imack", "ymmass"], "w": ["how", "ow", "g", "week", "wa", "d", "wave", "weight", "f", "win", "r", "ex", "m", "u", "wh", "work", "we", "aw", "rw", "W", "q", "c", "iw", "wb", "wt", "b", "sw", "n", "fw", "ew", "wx", "v", "z", "hw", " W", "l", "max"], "h": ["col", "hm", "e", "en", "g", "height", "d", "dh", "f", "t", "u", "r", "m", "ht", "j", "o", "rh", "q", "H", "c", "sh", "ch", "b", "n", "gh", "hi", "v", "z", "l", "ph", "k", "hh", "padding"], "bits_per_pixel": ["bits_per_channel", "bits_PER_pixel", "bits_per_page", "bits_per_chip", "bits_Per_pixel", "bits_per_line", "bits_per_cell", "bits_Per_cell", "bits_PER_channel", "bits_per_byte", "bits_PER_chip", "bits_Per_line"], "bytes_per_line": ["bytes_per_slice", "bytes_per_page", "bytes_per_row", "bytes_per_scene", "bytes_PER_line", "bytes_per_cell", "bytes_PER_slice", "bytes_per_byte", "bytes_PER_byte", "bytes_PER_pixel", "bytes_per_pixel"], "nplanes": [" nliners", "nliners", "Npages", " nlines", " nframes", "llines", "snplanes", "numbands", "Nliners", "numlines", " npins", "lplanes", "numpins", "nrows", "mplanes", "nframes", "Nbands", "Nrows", "snlines", "mlines", "nbplanes", "numpages", "numframes", "Nlines", "numrows", "Nplanes", "npins", "numliners", "lframes", "mframes", "Nframes", "Npins", "nblines", "mrows", " nrows", "nlines", "nbrows", "nbands", "snbands", "nbpages", "snframes", "lbands", "npages", "numplanes", " nbands"], "stride": ["snided", "decides", "brides", "snide", "brided", "strider", "decide", "strides", "strided", "snider", "decided", "snides", "brider", "decider", "bride"], "y": ["start", "vy", "yy", "height", "d", "f", "t", "ey", "m", "size", "o", "dy", "c", "b", "Y", "min", "n", "lon", "z", "l", "padding", "type"], "x": ["step", "ix", "xs", "xy", "d", "height", "xx", "f", "win", "ex", "size", "c", "px", "xml", "index", "dx", "X", "min", "n", "z", "l", "max"], "bytes_per_scanline": ["bytes_per_scanment", "bytes_per_scancell", "bytes_per_pixelse", "bytes_per_pixelblock", "bytes_per_binline", "bytes_per_bincell", "bytes_per_Scanframe", "bytes_per_readline", "bytes_per_misscell", "bytes_per_pixelframe", "bytes_per_binment", "bytes_per_readblock", "bytes_per_pixelcell", "bytes_per_missse", "bytes_per_scanframe", "bytes_per_readcell", "bytes_per_pixelline", "bytes_per_Scanline", "bytes_per_pixelment", "bytes_per_Scanse", "bytes_per_missframe", "bytes_per_scanse", "bytes_per_Scanment", "bytes_per_binblock", "bytes_per_missline", "bytes_per_Scanblock", "bytes_per_Scancell", "bytes_per_scanblock"], "ptr": ["port", "config", "ctr", "queue", "pad", "fp", "buffer", "alloc", "code", "addr", "dr", "cb", "tmp", "seq", "fd", "src", "slice", "br", "trace", "buff", "proc", "pair", "pointer", "vec", "fi", "attr", "prop"], "bufstart": ["ufstart", "bufferstop", "bufStart", "ufStart", "queuestart", "bufstop", "queueStart", "ufstop", "bufferStart", "queuestop", "bufferstart"], "scanline": ["parselines", "readline", " scanlines", " scanl", "readlines", "scanlines", "readl", "parsel", "scanl", "parseline"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "void ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f)\n\n{\n\n    PerThreadContext *p = avctx->internal->thread_ctx;\n\n    FrameThreadContext *fctx;\n\n    AVFrame *dst, *tmp;\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    int can_direct_free = !(avctx->active_thread_type & FF_THREAD_FRAME) ||\n\n                          avctx->thread_safe_callbacks                   ||\n\n                          (\n\n#if FF_API_GET_BUFFER\n\n                           !avctx->get_buffer &&\n\n#endif\n\n                           avctx->get_buffer2 == avcodec_default_get_buffer2);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n\n\n    if (!f->f->buf[0])\n\n        return;\n\n\n\n    if (avctx->debug & FF_DEBUG_BUFFERS)\n\n        av_log(avctx, AV_LOG_DEBUG, \"thread_release_buffer called on pic %p\\n\", f);\n\n\n\n    av_buffer_unref(&f->progress);\n\n    f->owner    = NULL;\n\n\n\n    if (can_direct_free) {\n\n        av_frame_unref(f->f);\n\n        return;\n\n    }\n\n\n\n    fctx = p->parent;\n\n    pthread_mutex_lock(&fctx->buffer_mutex);\n\n\n\n    if (p->num_released_buffers + 1 >= INT_MAX / sizeof(*p->released_buffers))\n\n        goto fail;\n\n    tmp = av_fast_realloc(p->released_buffers, &p->released_buffers_allocated,\n\n                          (p->num_released_buffers + 1) *\n\n                          sizeof(*p->released_buffers));\n\n    if (!tmp)\n\n        goto fail;\n\n    p->released_buffers = tmp;\n\n\n\n    dst = &p->released_buffers[p->num_released_buffers];\n\n    av_frame_move_ref(dst, f->f);\n\n\n\n    p->num_released_buffers++;\n\n\n\nfail:\n\n    pthread_mutex_unlock(&fctx->buffer_mutex);\n\n}\n", "idx": 22503, "substitutes": {"avctx": ["abcmp", "avecu", "axctx", "aveca", "devcontext", "AVcf", "aveconfig", "AVconfig", "AVcmp", "afca", "afcf", "ajcontext", "devcmp", "avhw", "axcontext", "afctl", "avcal", "afcmp", "avconn", "AVcal", "avconfig", "afhw", "afctx", "afconv", "AVcontext", "avecmp", "evcontext", "AVcu", "devcf", "avcf", "aycontext", "avehw", "avconv", "avca", "evcu", "avectl", "ayctx", "axca", "aycu", "avecontext", "avlc", "afcu", "ajcal", "avelc", "avcu", "avcontext", "devctx", "avctl", "abctx", "AVconn", "evconv", "ajconn", "AVlc", "ajcu", "axctl", "afcal", "ajconv", "evctx", "afconfig", "ayctl", "avectx", "avcmp", "abcontext", "ajctx", "afcontext", "AVctx", "afconn", "abhw", "aflc"], "f": ["fa", "of", "fc", "i", "uf", "e", "fac", "ref", "fs", "g", "fb", "framework", "d", "file", "rf", "fp", "function", "df", "exec", "t", "u", "info", "m", "s", "r", "j", "cache", "full", "new", "cf", "fx", "inf", "q", "af", "ext", "c", "fe", "frame", "fr", "tf", "form", "b", "x", "w", "fm", "ff", "fl", "fd", "F", "fw", "flow", "sf", "k", "feed", "parent", "bf", "v", "fen", "conf", "fn", "h", "l", "fi", "fo", "interface", "elf"], "p": ["pb", "after", "i", "e", "ap", "app", "jp", "lp", "g", "pe", "part", "pkg", "post", "d", "pm", "parse", "P", "cop", "bp", "pc", "l", "fp", "pg", "po", "per", "t", "pre", "u", "r", "m", "cp", "op", "j", "cache", "tp", "s", "pp", "patch", "point", "o", "np", "q", "c", "ctx", "self", "pr", "wp", "b", "w", "n", "br", "ps", "parent", "v", "up", "http", "sp", "vp", "h", "pi", "api", "this", "k", "pa"], "fctx": ["frctrl", "ifca", "pcmp", "fctrl", "Fcf", "cfcontext", "flowcmp", "afca", "afcf", "fca", "fxtx", "frcontext", "Fctx", "fcmp", "frctx", "afctx", "cfsci", "ifcontext", "Fcb", "cfctx", "cfctrl", "psci", " fcontext", "fcb", "flowcontext", "Ftx", "fsci", "Fcontext", "ftx", "fxcb", "pctx", "flowctx", "cfcmp", "fcf", "afcontext", "pctrl", "pcontext", " fcb", "flowsci", "frcmp", "fxcontext", "fcontext", " ftx", "ifctx", "Fca", "ifcf", "fxctx"], "dst": ["Dst", "lst", " dST", "dedST", " dost", "dedost", "rdfe", "dedsts", "hdset", "hdstore", "lost", "dST", "dsrc", "dstore", "hdst", "Dsrc", "dost", "ddput", "dfe", "lST", "dsts", " dfe", "adput", "ddset", "rdst", "dedst", "hdput", "rdsrc", "adset", "Dfe", "adst", "dset", "Dsts", "rdsts", " dsts", " dsrc", "dput", "lsts", "ddst", "ddstore", "adstore"], "tmp": ["pb", "sb", "txt", "obj", "err", "jp", "vt", "result", "part", "pkg", "fb", "copy", "tt", "bb", "temp", "pad", "img", "fp", "emp", "pos", "fake", "cmp", "t", "pre", "acc", "cp", "j", "cache", "tp", "bug", "data", "bt", "zip", "diff", "tc", "Temp", "buf", "kk", "cb", "wp", "tf", "mp", "beta", "b", "ptr", "now", "cpp", "stuff", "vv", "fd", "src", "sup", "slice", "test", "loc", "nb", "boot", "proc", "v", "bf", "nt", "sp", "rb", "dest", "buff", "su", "output", "attr", "mmm"], "num_released_buffers": ["num_released_buffores", "num_released_Buffests", "num_released_codests", "num_released_buffants", "num_released_buckants", "num_releasedingbufferc", "num_released_buffERS", "num_releaseditycodeners", "num_released_comperc", "num_releaseditycoders", "num_released_buckers", "num_released_bufores", "num_released_bufters", "num_released_compERS", "num_released_buckerc", "num_released_fundters", "num_releasedingbuckerc", "num_released_coder", "num_released_buffeners", "num_released_bufERS", "num_released_compers", "num_released_ufers", "num_released_scribants", "num_releasedingbuffers", "num_released_funders", "num_released_counterc", "num_released_countensions", "num_releaseditycodests", "num_released_Buffers", "num_released_Bufferers", "num_released_Bufferc", "num_released_bufferers", "num_released_Buffer", "num_released_buterers", "num_releasedingbuffants", "num_released_codeners", "num_releaseditybuffests", "num_releaseditybuffers", "num_released_buffests", "num_released_calleners", "num_released_scribensions", "num_releaseditybuffer", "num_released_caller", "num_released_ufters", "num_released_buffensions", "num_released_fundores", "num_released_ufERS", "num_released_BuffERS", "num_released_Buffeners", "num_releasedingbuckants", "num_released_buffer", "num_released_countants", "num_releasedingbuffensions", "num_released_ufores", "num_releasedingbuckensions", "num_releasedingbuckers", "num_released_coders", "num_released_buterc", "num_released_comperers", "num_released_scriberc", "num_released_buters", "num_released_buffters", "num_released_fundERS", "num_released_callers", "num_released_scribers", "num_releaseditybuffeners", "num_released_callests", "num_released_counters", "num_released_bufferc", "num_released_bufers", "num_released_buckensions", "num_releaseditycoder", "num_released_butERS"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_ns);\n\n\n\n        if (max_ns) {\n\n            poll_set_started(ctx, true);\n\n\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    poll_set_started(ctx, false);\n\n\n\n    /* Even if we don't run busy polling, try polling once in case it can make\n\n     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).\n\n     */\n\n    return run_poll_handlers_once(ctx);\n\n}\n", "idx": 27100, "substitutes": {"ctx": ["sc", "kw", "cm", "cca", "anc", "c", "pkg", "context", "cv", "connection", "qa", "xc", "config", "component", "jp", "support", "ct", "cb", "bc", "cus", "ce", "instance", "util", "sync", "kb", "css", "cmp", "fc", "cmd", "cl", "cms", "vc", "loc", "fw", "cli", "Context", "cc", "ci", "cn", "cf", "cp", "client", "ga", "rc", "co", "cas", "lc", "ctrl", "comp", "ca", "tc", "cu", "conn", "coll", "event", "ck", "nc", "tx", "cs", "cam", "pc", "cgi", "kt"], "blocking": ["complete", "exec", "starting", "rising", "testing", "interrupted", "quiet", "exclusive", "using", "locking", "buffer", "blocks", "calling", "no", "ocking", "prefix", "bc", "bl", "regular", "wait", "loading", "protected", "padding", "cl", "background", "partial", "http", "enabled", "successful", "restricted", "client", "including", "sleep", "rolling", "working", "locked", "running", "full", "block", "ssl", "limited"]}}
{"project": "FFmpeg", "commit_id": "39d607e5bbc25ad9629683702b510e865434ef21", "target": 1, "func": "static inline void RENAME(yuv2yuvX_ar)(SwsContext *c, const int16_t *lumFilter,\n\n                                       const int16_t **lumSrc, int lumFilterSize,\n\n                                       const int16_t *chrFilter, const int16_t **chrUSrc,\n\n                                       const int16_t **chrVSrc,\n\n                                       int chrFilterSize, const int16_t **alpSrc,\n\n                                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest,\n\n                                       uint8_t *aDest, long dstW, long chrDstW)\n\n{\n\n    if (uDest) {\n\n        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)\n\n        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, vDest, chrDstW + c->uv_off, c->uv_off)\n\n    }\n\n    if (CONFIG_SWSCALE_ALPHA && aDest) {\n\n        YSCALEYUV2YV12X_ACCURATE(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)\n\n    }\n\n\n\n    YSCALEYUV2YV12X_ACCURATE(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)\n\n}\n", "idx": 22361, "substitutes": {"c": ["lc", "fc", "e", "cc", "uc", "ct", "config", "g", "cv", "cm", "d", "con", "ca", "cur", "cu", "f", "ci", "ac", "u", "m", "s", "cache", "oc", "p", "cs", "xc", "enc", "ctrl", "cf", "context", "client", "ctx", "cn", "icc", "b", "dc", "w", "cy", "n", "C", "co", "v", "ce", "cit", "h", "l", "ec", "vc"], "lumFilter": ["LumbFile", "lumbFilter", "lumFile", "LumFile", "LumbFil", "Lumbfilter", "LumFil", "lumfilter", "lufFilter", "LumFilter", "lumFil", "lacFile", "lumbfilter", "lufFil", "lumbFil", "lacfilter", "lufFile", "lacFil", "luffilter", "LumbFilter", "lacFilter", "Lumfilter", "lumbFile"], "lumSrc": ["lumAsvc", "lumSysnc", "lumaAsnc", "lumVSvc", "lumaSnc", "lumVSnc", "lumSRC", "lumAsnc", "lumAsrc", "lumSysvc", "lumVSRC", "lumaSvc", "lumSnc", "lumaAsvc", "lumAsRC", "lumSvc", "lumaSrc", "lumaSRC", "lumSysRC", "lumSysrc", "lumVSrc", "lumaAsRC", "lumaAsrc"], "lumFilterSize": ["lmpfilterC", "lumControlExport", "lumFilterC", "lumfilterExport", "lumFilterExport", "lmpfilterExport", "lumControlSize", "lumfilterSize", "lumFileC", "lmpFilterExport", "lumFileExport", "lumFileSize", "lmpfilterSize", "lmpFilterSize", "lumControlC", "lumfilterC", "lmpFilterC"], "chrFilter": ["chrfFilter", "shrfFilter", "chmSource", "chmFl", "chbFl", "chmConfig", "chrfSource", "shrFilter", "chrfConfig", "chrConfig", "shrSource", "shrfFl", "chbFilter", "chmFilter", "shrfConfig", "chrfFl", "chrSource", "chbSource", "shrConfig", "chbConfig", "shrFl", "shrfSource", "chrFl"], "chrUSrc": ["chrSSsrc", "chrUSSec", "chrSSrc", "chrUSec", "chrfUSrc", "chrSSrs", "chrfSSrc", "chrUSSrs", "chrUSSsrc", "chrfUSrs", "chrUSSrc", "chrfUSec", "chrUSrs", "chrVSsrc", "chrfUSsrc", "chrfSSrs", "chrfSSec", "chrVSrs", "chrSSec", "chrUSsrc", "chrVSec", "chrfSSsrc"], "chrVSrc": ["chrbVsrc", "chrVSRC", "chrVsRC", "chrbVSrc", "chrRSsrc", "chrbVssrc", "chrSdc", "chrSrc", "chrVsdc", "chrbVSdc", "chrVsrc", "chrbVsRC", "chrRSrc", "chrVSdc", "chrRSRC", "chrSsrc", "chrbVsdc", "chrVSsrc", "chrbVSsrc", "chrSRC", "chrRSdc", "chrbVSRC", "chrVssrc"], "chrFilterSize": ["chrbFilterLength", "chrfilterLength", "chrSortSIZE", "chrFiltersize", "chrbSortLength", "chrbSortSIZE", "chrSortsize", "chrFilterSIZE", "chrSortSize", "chrfilterSIZE", "chrbFilterSIZE", "chrbFiltersize", "chrfiltersize", "chrfilterSize", "chrFilterLength", "chrbSortsize", "chrSortLength", "chrbSortSize", "chrbFilterSize"], "alpSrc": ["alpSSdr", "alpSSrc", "alpAssrc", "alcSdr", "alcAsdr", "alpSdr", "alcSsrc", "alpAsRC", "alpAsdr", "alpSSRC", "alcAsRC", "alcSrc", "alpSSsrc", "alpSRC", "alcAsrc", "alpAsrc", "alcSRC", "alcAssrc", "alpSsrc"], "dest": ["md", "route", "transform", "name", "txt", "target", "shape", "uc", "send", "config", "mode", "de", "d", "home", "img", "cur", "dep", "dist", "path", "done", "cont", "dir", "coord", "dev", "data", "diff", "wb", "shift", "destroy", "cb", "Dest", "source", "match", "die", "sc", "beta", "dc", "tmp", "desc", "src", "loc", "comb", "dat", "ie"], "uDest": ["vSc", "uDir", "vDir", "uRest", "URest", "udest", "cComb", "UDest", "aOrig", " uDir", "adest", "UDir", "aRest", "aComb", " uSc", "fComb", " udest", "cDest", "vdest", "USc", "uOrig", "vRest", " uRest", "uSc", "fDest", "uComb", "cOrig", "aDir", "fOrig"], "vDest": ["vDist", "wDesc", "wOrig", "wDes", " vDesc", "wDist", "bDesc", " vDist", "vOrig", "bDes", "vExt", "fExt", "wExt", " vOrig", "fDesc", "bDest", "fDist", " vDes", " vExt", "vDesc", "bOrig", "wDest", "fDest", "vDes"], "aDest": ["sDesc", "vaCor", "bSource", "AOrig", " aDep", "vaPriv", " aForce", "aDist", "baDest", "APriv", "bDep", "aOrig", "ADep", "sPriv", " aOrig", "aSource", " aDesc", " aPriv", "bDist", "baPriv", "sCor", "aCor", "ADest", " aSource", "aForce", "ADist", "vaDesc", " aCor", "ASource", "sDest", " aDist", "bDest", "vaDest", "aDep", "AForce", "baOrig", "aDesc", "aPriv", "baForce"], "dstW": ["DscWS", "dSTH", "DscH", "dstageW", "Dstw", "dscL", " dstD", "dstM", "drcw", "drcMW", "dscD", "dstMW", "drcM", "DscW", " drcD", "dSTD", "DrcW", "dSTW", "DrcMW", "DstW", "dscM", "dstL", "dstWS", "dscWS", "dmtH", "dstageM", "drcW", "drcD", "dscH", "DstM", "DstH", "drcH", "dstw", "dstH", "DrcH", "dmtW", "dstageWS", " drcW", "dmtMW", "dstageH", "dscW", "drcL", "DscM", "dmtw", "DstMW", "dstD", " dstL", "dSTw", "dSTMW", " dstH", "dSTL", "Drcw", "DstWS", " drcH", "drcWS", " drcL"], "chrDstW": ["chrDSTWS", "chrLstM", "chrDscH", "chrIdstVW", "chrDftW", "chrDrcH", "chrDSTVW", "chrDstVW", "chrDstrU", "chrDrcW", "chrNSTW", "chrLSTW", "chrIdstW", "chrNstW", "chrDstL", "chrLstH", "chrDstU", "chrNstU", "chrDrcG", "chrDftG", "chrDSTG", "chrIdstG", "chrDSTU", "chrDrcM", "chrIdftW", "chrDscW", "chrDstM", "chrDSTF", "chrDstWS", "chrDstrW", "chrDSTH", "chrIdftG", "chrLstL", "chrDstF", "chrDftVW", "chrNSTWS", "chrDntWS", "chrDntU", "chrDSTL", "chrNstWS", "chrDntF", "chrDstrF", "chrIdftH", "chrLSTH", "chrDrcVW", "chrNSTF", "chrDftH", "chrDSTW", "chrDntW", "chrIdstH", "chrDscL", "chrDrcL", "chrLSTL", "chrDstH", "chrNSTU", "chrLSTM", "chrDscM", "chrIdftVW", "chrDstG", "chrLstW", "chrDSTM", "chrDstrWS", "chrNstF"]}}
{"project": "qemu", "commit_id": "d02532f08e207419e412ea7cd4eb8b36f04f426d", "target": 1, "func": "int page_unprotect(target_ulong address, uintptr_t pc, void *puc)\n\n{\n\n    unsigned int prot;\n\n    PageDesc *p;\n\n    target_ulong host_start, host_end, addr;\n\n\n\n    /* Technically this isn't safe inside a signal handler.  However we\n\n       know this only ever happens in a synchronous SEGV handler, so in\n\n       practice it seems to be ok.  */\n\n    mmap_lock();\n\n\n\n    p = page_find(address >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        mmap_unlock();\n\n        return 0;\n\n    }\n\n\n\n    /* if the page was really writable, then we change its\n\n       protection back to writable */\n\n    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {\n\n        host_start = address & qemu_host_page_mask;\n\n        host_end = host_start + qemu_host_page_size;\n\n\n\n        prot = 0;\n\n        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {\n\n            p = page_find(addr >> TARGET_PAGE_BITS);\n\n            p->flags |= PAGE_WRITE;\n\n            prot |= p->flags;\n\n\n\n            /* and since the content will be modified, we must invalidate\n\n               the corresponding translated code. */\n\n            tb_invalidate_phys_page(addr, pc, puc);\n\n#ifdef DEBUG_TB_CHECK\n\n            tb_invalidate_check(addr);\n\n#endif\n\n        }\n\n        mprotect((void *)g2h(host_start), qemu_host_page_size,\n\n                 prot & PAGE_BITS);\n\n\n\n        mmap_unlock();\n\n        return 1;\n\n    }\n\n    mmap_unlock();\n\n    return 0;\n\n}\n", "idx": 10416, "substitutes": {"address": ["alias", "Address", "adr", "location", "reference", "holder", "start", "enter", "prefix", "pad", "point", "pointer", "data", "config", "add", "server", "uri", "target", "set", "component", "ace", "number", "memory", "array", "socket", "network", "padding", "host", "code", "resource", "index", "shape", "route", "name", "order", "end", "object", "en", "port", "position", "dc", "offset", "node", "type", "pair", "ip", "localhost", "image", "length"], "pc": ["cpu", "arc", "pg", "ota", "tc", "point", "pl", "pid", "pointer", "con", "c", "ref", "pb", "gb", "ocol", "pt", "po", "pm", "ptr", "bc", "cc", "ac", "pn", "code", "py", "amp", "inc", "rc", "port", "ping", "dc", "xc", "type", "nc", "pos", "client", "lic", "lc", "mc", "uc", "PC", "fc"], "puc": ["pucc", "Pcc", "pcc", "pbc", " pucc", "tbc", "Pbc", " pream", "lpream", "ppuc", "tcc", " pUC", "lpucc", "lpuc", "lpcc", " pcc", " pbc", "tuc", "PUC", "pream", "tUC", "ppream", "ppcc", "Puc", "pUC", "ppucc"], "prot": [" protocols", " pref", "seq", "inet", "pg", "len", " clen", "ext", " Protocol", "prefix", " protocol", "cli", "stat", "rect", "pointer", "pool", "bc", "server", "utf", "pro", "fp", "status", "txt", "ocol", "pt", "bits", "ptr", "prop", "lead", " Prot", "rot", "padding", "nat", "code", "primary", "dat", "fl", "ref", "size", "opt", "rog", "flags", "sil", "att", "pre", " len", " PROT", "port", "en", "rep", " proto", "offset", " Proto", "col", "eth", "platform", "pos", "header", "gap", "io", "Prot", "ret", "typ", "lo", "reset"], "p": ["lp", "l", "dp", "parent", "sp", "wp", "pg", "n", "proc", "w", "m", "bp", "point", "t", "b", "page", "pa", "pp", "i", "post", "d", "c", "cp", "s", "pb", "e", "fp", "ep", "np", "pe", "po", "gp", "P", "f", "op", "j", "pkg", "progress", "o", "py", "v", "pr", "pre", "hp", "jp", "tp", "patch", "pi", "part", "u", "api", "ps", "ap", "per", "vp"], "host_start": ["hostlexend", "hostlexstart", "node_end", "server_stop", "host_id", "server_end", "server_pos", "node_id", "host_pad", "host_size", "host_starting", "host_se", "host_stop", "server_starting", "node_pad", " host_size", " host_id", "hostlexpos", "node_start", "host_set", "server_set", "host_pos", "hostlexstarting", "server_start", "server_se"], "host_end": ["server_line", "hostlexend", "host_ends", "hostlexstart", "host_max", "host_line", "host_ended", " host_ends", "hostsend", "hostsEND", " host_send", "hostsstart", "server_max", "server_start", "hostsmax", "host_END", "server_END", "server_end", "hostlexends", "host_send", "server_ended", "hostlexsend"], "addr": ["Address", "ack", "xp", "enter", "arch", "pad", "x", "ad", "ref", "ace", "attr", "amd", "act", "loc", "ac", "code", "amp", "align", "nr", "hop", "offset", "grad", "od", "url", "alias", "mac", "arr", "ord", "id", "work", "index", "md", "r", "en", "position", "error", "eth", "layer", "adj", "nn", "ady", "seq", "ext", "len", "conn", "src", "add", "coord", "ptr", "dr", "host", "rt", "size", "oa", "order", "sta", "rc", "fx", "part", "ast", "vr", "cmd", "adder", "adr", "start", "rr", "origin", "pointer", "obj", "inst", "route", "name", "dd", "pos", "ip", "wd"]}}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int bt_hci_parse(const char *str)\n\n{\n\n    struct HCIInfo *hci;\n\n    bdaddr_t bdaddr;\n\n\n\n    if (nb_hcis >= MAX_NICS) {\n\n        fprintf(stderr, \"qemu: Too many bluetooth HCIs (max %i).\\n\", MAX_NICS);\n\n        return -1;\n\n    }\n\n\n\n    hci = hci_init(str);\n\n    if (!hci)\n\n        return -1;\n\n\n\n    bdaddr.b[0] = 0x52;\n\n    bdaddr.b[1] = 0x54;\n\n    bdaddr.b[2] = 0x00;\n\n    bdaddr.b[3] = 0x12;\n\n    bdaddr.b[4] = 0x34;\n\n    bdaddr.b[5] = 0x56 + nb_hcis;\n\n    hci->bdaddr_set(hci, bdaddr.b);\n\n\n\n    hci_table[nb_hcis++] = hci;\n\n\n\n    return 0;\n\n}\n", "idx": 21450, "substitutes": {"str": ["txt", "name", "Str", "err", "text", "ctr", "tr", "wr", "cur", "f", "buffer", "exec", "r", "strings", "enc", "arr", "dict", "code", "dr", "fr", "pass", "sr", "ptr", "w", "read", "cr", "br", "iter", "st", "kr", "STR"], "hci": ["ihcu", "cc", "khai", "ihcin", "hlcu", "rhco", "khci", "hhcit", "cii", " hco", "hhcci", " hcu", "khcin", "pci", "hlc", "hai", "hdco", "affci", "hlci", "handcin", "hcin", "Hcit", "handcci", "handcu", "rhcin", "hhci", " hai", "hco", "pcci", "vci", "hdii", "hii", "ihci", "Hoci", "affcci", "rhci", "Hci", "vni", "handci", "ihai", "hc", " hcin", "hdcin", "pcu", "vcci", "Hcci", "cci", "pcin", " hcci", "hcit", " hoci", "hhoci", " hii", " hc", "khcu", "hdci", "affcin", "hni", "ccu", "hoci", "affni", "vcin", " hcit", "hlii", "hcu", "hcci", "rhii", " hni"], "bdaddr": ["godplayer", "ndwork", "bbaddr", "bdadr", "godpart", "bdno", "godattr", "hdaddr", "cbwork", "bdptr", "nbnode", "bdorig", "fdaddr", "ndattr", "bdwork", "cbattr", "bbadr", "dbadr", "pdaddress", "ndno", "ndaddress", "godnode", "bdplayer", "ndplayer", "bdpart", "ndowner", "nbaddress", "ndorder", "cbptr", "BDno", "bdowner", "dbattr", "cbaddr", "godaddress", "fdaddress", "ndadr", "BDorig", "nbpart", "bdattr", "nbaddr", "dbaddr", "dbaddress", "bbattr", "godaddr", "hdno", "fdptr", "cbaddress", "BDaddress", "cbadr", "ndaddr", "bdaddress", "pdaddr", "bbpart", "pdowner", "ndptr", "BDaddr", "hdaddress", "pdorder", "bbnode", "bdnode", "hdorig", "BDattr", "ndorig", "fdwork", "bdorder", "dborder", "dbowner", "BDadr", "bbaddress", "dbplayer"]}}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "static void dsputil_init_mmx2(DSPContext *c, AVCodecContext *avctx,\n\n                              int mm_flags)\n\n{\n\n    const int bit_depth      = avctx->bits_per_raw_sample;\n\n    const int high_bit_depth = bit_depth > 8;\n\n\n\n    c->prefetch = prefetch_mmx2;\n\n\n\n    if (!high_bit_depth) {\n\n        c->put_pixels_tab[0][1] = put_pixels16_x2_mmx2;\n\n        c->put_pixels_tab[0][2] = put_pixels16_y2_mmx2;\n\n\n\n        c->avg_pixels_tab[0][0] = avg_pixels16_mmx2;\n\n        c->avg_pixels_tab[0][1] = avg_pixels16_x2_mmx2;\n\n        c->avg_pixels_tab[0][2] = avg_pixels16_y2_mmx2;\n\n\n\n        c->put_pixels_tab[1][1] = put_pixels8_x2_mmx2;\n\n        c->put_pixels_tab[1][2] = put_pixels8_y2_mmx2;\n\n\n\n        c->avg_pixels_tab[1][0] = avg_pixels8_mmx2;\n\n        c->avg_pixels_tab[1][1] = avg_pixels8_x2_mmx2;\n\n        c->avg_pixels_tab[1][2] = avg_pixels8_y2_mmx2;\n\n    }\n\n\n\n    if (!(avctx->flags & CODEC_FLAG_BITEXACT)) {\n\n        if (!high_bit_depth) {\n\n            c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_mmx2;\n\n            c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_mmx2;\n\n            c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_mmx2;\n\n            c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_mmx2;\n\n\n\n            c->avg_pixels_tab[0][3] = avg_pixels16_xy2_mmx2;\n\n            c->avg_pixels_tab[1][3] = avg_pixels8_xy2_mmx2;\n\n        }\n\n\n\n        if (CONFIG_VP3_DECODER && HAVE_YASM) {\n\n            c->vp3_v_loop_filter = ff_vp3_v_loop_filter_mmx2;\n\n            c->vp3_h_loop_filter = ff_vp3_h_loop_filter_mmx2;\n\n        }\n\n    }\n\n    if (CONFIG_VP3_DECODER && HAVE_YASM)\n\n        c->vp3_idct_dc_add = ff_vp3_idct_dc_add_mmx2;\n\n\n\n    if (CONFIG_VP3_DECODER && (avctx->codec_id == CODEC_ID_VP3 ||\n\n                               avctx->codec_id == CODEC_ID_THEORA)) {\n\n        c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_exact_mmx2;\n\n        c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_exact_mmx2;\n\n    }\n\n\n\n    if (CONFIG_H264QPEL) {\n\n        SET_QPEL_FUNCS(put_qpel,        0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_qpel,        1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(put_no_rnd_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_no_rnd_qpel, 1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(avg_qpel,        0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(avg_qpel,        1,  8, mmx2, );\n\n\n\n        if (!high_bit_depth) {\n\n            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, mmx2, );\n\n            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, mmx2, );\n\n            SET_QPEL_FUNCS(put_h264_qpel, 2,  4, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 2,  4, mmx2, );\n\n        } else if (bit_depth == 10) {\n\n#if HAVE_YASM\n\n#if !ARCH_X86_64\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, 10_mmxext, ff_);\n\n#endif\n\n            SET_QPEL_FUNCS(put_h264_qpel, 2, 4,  10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 2, 4,  10_mmxext, ff_);\n\n#endif\n\n        }\n\n\n\n        SET_QPEL_FUNCS(put_2tap_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_2tap_qpel, 1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(avg_2tap_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(avg_2tap_qpel, 1,  8, mmx2, );\n\n    }\n\n\n\n#if HAVE_YASM\n\n    if (!high_bit_depth && CONFIG_H264CHROMA) {\n\n        c->avg_h264_chroma_pixels_tab[0] = ff_avg_h264_chroma_mc8_mmx2_rnd;\n\n        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_mmx2;\n\n        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_mmx2;\n\n        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_mmx2;\n\n    }\n\n    if (bit_depth == 10 && CONFIG_H264CHROMA) {\n\n        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_10_mmxext;\n\n        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_10_mmxext;\n\n        c->put_h264_chroma_pixels_tab[1] = ff_put_h264_chroma_mc4_10_mmxext;\n\n        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_10_mmxext;\n\n    }\n\n\n\n    c->add_hfyu_median_prediction   = ff_add_hfyu_median_prediction_mmx2;\n\n\n\n    c->scalarproduct_int16          = ff_scalarproduct_int16_mmx2;\n\n    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_mmx2;\n\n\n\n    if (avctx->flags & CODEC_FLAG_BITEXACT) {\n\n        c->apply_window_int16 = ff_apply_window_int16_mmxext_ba;\n\n    } else {\n\n        c->apply_window_int16 = ff_apply_window_int16_mmxext;\n\n    }\n\n#endif\n\n}\n", "idx": 17124, "substitutes": {"c": ["dc", "oc", "pc", "ic", "spec", "cc", "s", "ch", "t", "conf", "f", "x", "vc", "ct", "rc", "r", "w", "cm", "n", "cf", "g", "i", "coll", "bc", "cp", "ctx", "fc", "mc", "self", "ctrl", "cy", "o", "ca", "enc", "cs", "l", "d", "ce", "nc", "ac", "ci", "con", "tc", "xc", "config", "e", "cu", "sc", "k", "cr", "cl", "lc", "cur", "v", "p", "uc", "b", "cache", "cit", "ec", "h", "co", "C", "conn", "u"], "avctx": ["aphcontext", "afcmp", "AVscl", "apcmp", "apcp", "apcontext", "avcb", "aircontext", "Avscl", "avcp", "afcontext", "Avcontext", "apctx", "AVcb", "abctx", "afctx", "abcontext", "abcmp", "AVcca", "abcp", "avscl", "aircca", "afcp", "aphcca", "apcca", "aphscl", "aircb", "apcb", "AVctx", "avcca", "AVcontext", "aphctx", "avcmp", "avcontext", "Avctx", "airctx", "Avcca"], "mm_flags": [" pixel_settings", " pixel_data", " pixel_flags", "mm_data", " pixel_planes", "mm_settings", "mm_planes"]}}
{"project": "qemu", "commit_id": "b9ce1454e14ec918acb90d899ce7724f69682f45", "target": 0, "func": "int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)\n\n{\n\n    int size, l;\n\n\n\n    if (f->is_write)\n\n        abort();\n\n\n\n    size = size1;\n\n    while (size > 0) {\n\n        l = f->buf_size - f->buf_index;\n\n        if (l == 0) {\n\n            qemu_fill_buffer(f);\n\n            l = f->buf_size - f->buf_index;\n\n            if (l == 0)\n\n                break;\n\n        }\n\n        if (l > size)\n\n            l = size;\n\n        memcpy(buf, f->buf + f->buf_index, l);\n\n        f->buf_index += l;\n\n        buf += l;\n\n        size -= l;\n\n    }\n\n    return size1 - size;\n\n}\n", "idx": 26191, "substitutes": {"f": ["ref", "fen", "uf", "fe", "family", "found", "w", "fo", "af", "i", "p", "m", "elf", "c", "b", "this", "fac", "d", "info", "of", "rf", "x", "bf", "conf", "fm", "form", "flow", "fr", "u", "lf", "e", "fc", "feed", "o", "ff", "flat", "inf", "fw", "fl", "new", "fi", "fb", "fx", "cf", "buff", "fs", "tf", "n", "j", "fa", "t", "fp", "z", "v", "r", "sf", "df", "fd", "file", "F"], "buf": ["ref", "head", "seq", "uf", "bag", "uc", "b", "p", "c", "wb", "context", "lb", "cv", "Buff", "data", "vec", "buffer", "queue", "base", "rb", "br", "cur", "bd", "cb", "bc", "port", "id", "num", "orig", "cmp", "lf", "mem", "ff", "cmd", "pb", "path", "ul", "loc", "fl", "box", "offset", "ctx", "cp", "fb", "cf", "rc", "alloc", "Buffer", "cache", "block", "ptr", "len", "length", "buff", "count", "src", "fp", "header", "v", "lim", "result", "fd"], "size1": ["ize0", "shapeone", "value1", "addressOne", "sizeone", "valueOne", " size0", "shapeOne", "Size0", " sizeOne", "Size1", "sizeOne", " sizeone", "shape1", "capacityOne", "size0", "address1", "ize1", "capacityone", "capacity1"], "size": ["L", "z", "name", "time", "ell", "url", "u", "hl", "li", "el", "SIZE", "min", "cl", "dl", "fl", "n", "code", "low", "ize", "m", "p", "c", "empty", "sized", "x", "storage", "address", "speed", "line", "s", "cache", "shape", "sl", "iz", "large", "len", "sn", "d", "no", "capacity", "Size", "e", "la", "small", "le", "like", "length", "lc", "count", "null", "page", "i", "ll", "position", "weight", "unit", "o", "loc", "cel", "si", "last", "gl", "scale", "y", "v", "kl"], "l": ["L", "acl", "z", "i", "b", "ll", "dL", "c", "lb", "shell", "ld", "en", "ell", "bl", "url", "u", "lf", "e", "al", "el", "li", "o", "lu", "cl", "rl", "ol", "la", "ul", "lr", "loc", "dl", "pl", "s", "fl", "cel", "le", "ln", "len", "length", "lc", "il", "ls", "lp", "lv", "jl", "n", "lo", "nl", "v", "sl", "r", "kl"]}}
{"project": "FFmpeg", "commit_id": "87e8788680e16c51f6048af26f3f7830c35207a5", "target": 0, "func": "static int flv_probe(AVProbeData *p)\n\n{\n\n    const uint8_t *d;\n\n\n\n    if (p->buf_size < 6)\n\n        return 0;\n\n    d = p->buf;\n\n    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {\n\n        return AVPROBE_SCORE_MAX;\n\n    }\n\n    return 0;\n\n}\n", "idx": 2466, "substitutes": {"p": ["np", "vp", "lp", "a", "data", "r", "n", "ap", "sp", "pb", "op", "api", "i", "j", "tp", "m", "fp", "P", "ps", "pa", "l", "c", "e", "f", "u", "jp", "o", "v", "pc", "bp", "s", "b", "cp", "t", "pp"], "d": ["dr", "fd", "ld", "dn", "da", "dd", "pd", "dh", "dim", "dad", "data", "r", "n", "ad", "di", "dl", "id", "dict", "k", "de", "dom", "did", "i", "g", "j", "m", "dy", "dt", "ds", "md", "dc", "l", "c", "ind", "w", "e", "f", "bd", "u", "cd", "rd", "s", "o", "b", "t", "od", "nd", "dat", "dp", "D", "db"]}}
{"project": "FFmpeg", "commit_id": "e477f09d0b3619f3d29173b2cd593e17e2d1978e", "target": 1, "func": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int v, i;\n\n\n\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        if (length > 256 || !(s->state & PNG_PLTE))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length; i++) {\n\n            v = bytestream2_get_byte(&s->gb);\n\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n\n        }\n\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length / 2; i++) {\n\n            /* only use the least significant bits */\n\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n\n\n\n            if (s->bit_depth > 8)\n\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n\n            else\n\n                s->transparent_color_be[i] = v;\n\n        }\n\n    } else {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n    s->has_trns = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 23309, "substitutes": {"avctx": ["avesci", "Avsci", "avectx", "afsci", "Avmedia", "Avctx", "afcontext", "afctx", "avcontext", "afmedia", "avemedia", "avmedia", "avsci", "Avcontext", "avecontext"], "s": ["ions", "sv", "es", "uns", "xs", "ds", "sys", "r", "os", "ssl", "ts", "cs", "us", "params", "js", "aws", "ms", "S", "ns", "rs", "ins", "ans", "conf", "http", "l", "ss", "this", "sb", "rows", "g", "ses", "d", "sets", "as", "ches", "services", "u", "o", "sg", "c", "self", "spec", "a", "sf", "ies", "ats", "su", "e", "sym", "qs", "hs", "fs", "lines", "ings", "f", "t", "new", "p", "si", "b", "service", "ims", "parts", "ps", "gs", "h", "sq", "sl", "ubs", "als", "your", "ops", "plugins", "ks", "m", "args", "its", "strings", "ys", "ls", "sync", "is", "settings", "session", "comments"], "length": ["off", "part", "duration", "oh", "buffer", "path", "other", "sequence", "j", "list", "url", "load", "pl", "line", "slice", "angle", "l", "type", "delay", "end", "text", "style", "sth", "lock", "code", "child", "position", "tail", "ph", "k", "section", "size", "full", "zip", "p", "number", "el", "form", "ength", "total", "th", "count", "shape", "limit", "level", "sl", "Length", "build", "id", "L", "supp", "match", "sh", "se", "seq", "len", " lengths", "block", "value"], "v": ["conv", "tv", "sv", "e", "limit", "end", "nv", "V", "lv", "iv", "g", "gu", "val", "av", "cv", "d", "vd", "qv", "f", "t", "y", "u", "r", "m", "j", "p", "uv", "vals", "vs", "vi", "code", "o", " V", "q", "c", "ver", "a", "b", "ii", "volt", "w", "vol", "n", "va", "vv", "ve", "z", "vp", "h", "ev", "l", "x", "k", "value"], "i": ["io", "ix", "e", "ie", "fi", "qi", "ri", "ind", "iv", "ui", "eni", "pi", "gi", "uri", "ti", "I", "f", "ci", "y", "oi", "u", "ini", "info", "phi", "j", "it", "ip", "p", "abi", "id", "vi", "bi", "o", "is", "mi", "cli", "c", "mu", "index", "si", "ii", "b", "ji", "n", "iu", "slice", "ai", "xi", "hi", "di", "multi", "yi", "li", "z", "api", "l", "x", "zi", "k", "ni", "ori"]}}
{"project": "FFmpeg", "commit_id": "7167bc94cb695a3027aea6aac34a1b040848c7dc", "target": 1, "func": "static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float bias)\n\n{\n\n    IndividualChannelStream *ics = &sce->ics;\n\n    float *in    = sce->coeffs;\n\n    float *out   = sce->ret;\n\n    float *saved = sce->saved;\n\n    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;\n\n    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;\n\n    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;\n\n    float *buf  = ac->buf_mdct;\n\n    float *temp = ac->temp;\n\n    int i;\n\n\n\n    // imdct\n\n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n        if (ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE)\n\n            av_log(ac->avctx, AV_LOG_WARNING,\n\n                   \"Transition from an ONLY_LONG or LONG_STOP to an EIGHT_SHORT sequence detected. \"\n\n                   \"If you heard an audible artifact, please submit the sample to the FFmpeg developers.\\n\");\n\n        for (i = 0; i < 1024; i += 128)\n\n            ff_imdct_half(&ac->mdct_small, buf + i, in + i);\n\n    } else\n\n        ff_imdct_half(&ac->mdct, buf, in);\n\n\n\n    /* window overlapping\n\n     * NOTE: To simplify the overlapping code, all 'meaningless' short to long\n\n     * and long to short transitions are considered to be short to short\n\n     * transitions. This leaves just two cases (long to long and short to short)\n\n     * with a little special sauce for EIGHT_SHORT_SEQUENCE.\n\n     */\n\n    if ((ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE) &&\n\n            (ics->window_sequence[0] == ONLY_LONG_SEQUENCE || ics->window_sequence[0] == LONG_START_SEQUENCE)) {\n\n        ac->dsp.vector_fmul_window(    out,               saved,            buf,         lwindow_prev, bias, 512);\n\n    } else {\n\n        for (i = 0; i < 448; i++)\n\n            out[i] = saved[i] + bias;\n\n\n\n        if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n            ac->dsp.vector_fmul_window(out + 448 + 0*128, saved + 448,      buf + 0*128, swindow_prev, bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow,      bias, 64);\n\n            ac->dsp.vector_fmul_window(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      bias, 64);\n\n            memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));\n\n        } else {\n\n            ac->dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, bias, 64);\n\n            for (i = 576; i < 1024; i++)\n\n                out[i] = buf[i-512] + bias;\n\n        }\n\n    }\n\n\n\n    // buffer update\n\n    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n        for (i = 0; i < 64; i++)\n\n            saved[i] = temp[64 + i] - bias;\n\n        ac->dsp.vector_fmul_window(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 0, 64);\n\n        ac->dsp.vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 0, 64);\n\n        ac->dsp.vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 0, 64);\n\n        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n\n    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {\n\n        memcpy(                    saved,       buf + 512,        448 * sizeof(float));\n\n        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));\n\n    } else { // LONG_STOP or ONLY_LONG\n\n        memcpy(                    saved,       buf + 512,        512 * sizeof(float));\n\n    }\n\n}\n", "idx": 24424, "substitutes": {"ac": ["acc", "aic", "acl", "k", "rac", "dc", "uc", "oc", "auc", "anc", "c", "fac", "enc", "ec", "sac", "ad", "am", "cus", "ax", "bc", "act", "mac", "mic", "con", "AC", "ic", "vc", "http", "cc", "Ac", "jac", "mc", "roc", "pac", "as", "ack", "ca", "gc", "aut", "tc", "arc", "acs", "ace", "iac", "cs", "pc", "cam"], "sce": ["dscel", "ske", "Sces", "scle", "dsCE", "openske", "Sce", "Scle", "opensce", " sface", " sque", "scel", " sne", "dske", "sces", "Sne", " sse", "sface", "dsce", "openscel", "sque", "sCE", " sCE", "Sse", "psce", "Ske", "pske", " ske", " scle", "Sque", "sne", "SCE", "psCE", "pscel", "opensface", " scel", "sse", " sces"], "bias": ["Bases", " bases", "bai", " bius", " bake", "bake", "Bait", "base", " unbase", " base", "lbai", "bius", "fait", "lax", "fias", "lbias", "Bake", " bait", "bax", "bases", "Base", "bait", "fius", " bax", " unbases", "fake", " bai", "lai", "Bias", " unbias", " unbius", "lbax", "lias", "Bius"], "ics": ["exec", "ants", "sys", "ns", "ts", "ips", "inas", "acks", "sync", "self", "bs", "mic", "stats", "cms", "http", "ig", "IC", "nas", "xs", "ums", "ents", "fs", "qs", "osi", "ris", "pic", "aic", "ICS", "ec", "ins", "css", "s", "spec", "ik", "mc", "cache", "xml", "ex", "ico", "voc", "pc", "its", "rates", "rs", "args", "tis", "ats", "iris", "icks", "act", "abc", "icons", "ks", "uses", "fc", "fps", "nic", "wcs", "cats", "ras", "bits", "atts", "cs", "iss", "oc", "ix", "isc", "config", "cus", "bc", "cons", "ic", "icc", "wic", "ctx", "inc", "ls", "facts", "acs", "iac", "fits"], "in": ["login", "IN", "slice", "bin", "uc", "c", "image", "gin", "In", "x", "qa", "data", "buffer", "img", "config", "again", "ins", "pass", "rec", "orig", "into", "con", "min", "input", "str", "vin", "ul", "inner", "ini", "nin", "pin", "new", "ci", "inc", "inn", "isin", "win", "f", "source", "bits", "n", "index", "a", "init", "ints"], "out": ["exec", "call", "obj", "OUT", "bin", "batch", "image", "fn", "data", "buffer", "sum", "config", "again", "prefix", "Out", "outs", "pass", "sync", "op", "io", "wx", "o", "extra", "cmd", "str", "work", "err", "input", "at", "bit", "inner", "output", "pool", "copy", "parent", "new", "ret", "client", "inc", "cache", "arg", "buff", "window", "ext", "source", "child", "init", "ex", "result", "val"], "saved": ["paved", "psave", "unsaged", " saving", " sitched", "saving", "Sitched", "psaved", " saged", "Save", "pave", "saves", "sitched", "setsaves", "Saved", "served", "Saving", "unsave", "unsaving", "sorted", " save", "setsaved", "Saves", "setsave", "saged", "unsaves", "pserved", "save", "Served", "Sorted", "setsitched", "paving", " sorted", " saves", "setsorted", "psaves", "psaving", "setsaged", "perved", "unsaved", "setsaving"], "swindow": ["swillo", "swINDo", "swINDowed", "swillowed", "swinnowed", "swindowed", "swINDow", "Swindows", "swindows", "SwINDow", "SwINDows", "Swindowed", "swINDows", "swillows", "swinno", "SwINDo", "swindo", "swinnows", "swillow", "Swindo", "swinnow", "SwINDowed", "Swindow"], "lwindow_prev": ["lwindows_prev", "lview_prev", "lwindows_last", "lview_first", "lwindow1first", "lwindow_pre", "lwindow1orig", "lwindow_orig", "lwindow1upper", "lwindow_upper", "lwindows_cur", "lwindow1prev", "lwindow_last", "lwindow_cur", "lwindow_first", "lview_orig", "lview_upper", "lwindows_pre"], "swindow_prev": ["swindow_orig", "swindOW_pre", "swindow_last", "swindOW_last", "swindOW_prev", "swindow_pre", "swindOW_orig"], "buf": ["seq", "uf", "ru", "bag", "margin", "uc", "b", "auc", "batch", "wb", "gin", "cv", "bn", "data", "buffer", "vec", "queue", "text", "rb", "img", "br", "cur", "cb", "prefix", "bc", "port", "num", "bus", "aux", "home", "ff", "tmp", "input", "fw", "box", "output", "pool", "ctx", "result", "fb", "cf", "fi", "rc", "cache", "xff", "conv", "cas", "buff", "window", "fp", "block", "fd"], "temp": ["txt", "margin", "w", "pt", "keep", "c", "cv", "wave", "buffer", "Temp", "frac", "weight", "prefix", "opt", "wrap", "num", "tr", "iter", "tmp", "input", "flat", "output", "clean", "ctr", "local", "cache", "tem", "conv", "ptr", "stable", "current", "win", "buff", "timeout", "window", "tc", "alt", "dest", "wa", "table"], "i": ["z", "it", "io", "num", "u", "li", "start", "bi", "ini", "ai", "f", "n", "j", "chi", "ami", "slice", "k", "b", "p", "c", "x", "ti", "mi", "phi", "qi", "ri", "key", "iter", "di", "ci", "eni", "isin", "ki", "yi", "d", "uli", "adi", "e", "iw", "axis", "uri", "ii", "cli", "fi", "I", "init", "iu", "my", "info", "ix", "id", "gi", "ji", "o", "zi", "multi", "xi", "inner", "si", "ni", "y", "mini", "child", "oi", "ip", "index", "a", "v", "mu", "pi", "ui", "l", "hi"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 2246, "substitutes": {"ysrc": ["src", "sysuc", "sysrc", "gsource", "cssrc", "csrc", "vsource", "gsc", "ysource", "source", "gssrc", "sssrc", "ssource", "ssuc", "ysuc", "syssrc", "sc", "yssrc", "vssrc", "csource", "vsuc", "csc", "sysource", "gsrc", "ssrc", "ysc"], "usrc": ["USrc", "Usrc", "lsdc", "usroc", "lsroc", "lssrc", "usdc", " ussrc", "usrid", "USsrc", "vsroc", "ussrc", "ssroc", "sssrc", "Ussrc", "USroc", "vsrid", "Usroc", " usroc", "lsrc", "Usrid", "vssrc", "USrid", " usdc", "ssrc", "ssdc"], "vsrc": ["wrc", "vsource", " vrc", "vssource", "wsource", " vstat", "vsstat", "vources", "vstat", "vsources", "vrc", "wources", " vsource", "vssrc", " vources", "wsrc", "wstat"], "dst": ["Dsrc", "idsrc", "dsth", "idst", "adsc", "idsc", "dsc", "adst", "dsts", "idsts", "dST", "idST", "adsth", "adsts", "adsrc", " dsc", " dsts", "dsrc", "adST", "Dsth", "Dsc", " dST", "idsth", "Dst"], "height": ["resolution", "crop", "above", "Height", "dim", "image", "high", "window", "distance", "wrap", "ty", "gap", "max", "y", "direction", "style", "slice", "pad", "h", "alpha", "thin", "deep", "rank", "images", "size", "length", "input", "hd", "density", "square", "padding", "pull", "depth", "img", "shape", "bottom", "dist"], "lumStride": ["lumScri", "lumSTri", "lumbStrap", "lumSTrap", "lumbSTrap", "lumStrrap", "lumStoreride", "lumbstri", "lumbstride", "lumstro", "lumStrride", "lumbStri", "lumstride", "lumbSTride", "lumStrip", "lumSTride", "lumStro", "lumScride", "lumbStride", "lumStorerap", "lumbstrite", "lumbstro", "lumbStrip", "lumstri", "lumStorerip", "lumSTrip", "lumSTro", "lumStrrip", "lumbSTro", "lumbStro", "lumstrite", "lumbStrite", "lumScrite", "lumbSTrip", "lumStrro", "lumScro", "lumStri", "lumSTrite", "lumStorero", "lumStrap", "lumStrite"], "chromStride": ["chromStipe", "chromSyncrip", "chromStyridden", "chromstrite", "chromSyncride", "chromStyrip", "chromstrate", "chromStandro", "chromstride", "chelStyrip", "chelStyride", "chromSTro", "chromStandrate", "chromSyncipe", "chromStridden", "chelStride", "chelStridden", "chromSTrip", "romStrate", "romSTro", "chromStrip", "romStride", "chelStipe", "chromstro", "chromSTridden", "romSTrate", "romSTride", "chromSTrate", "romSTrite", "romStrite", "chromSTride", "romStro", "chromStyride", "chelStrip", "chromSTipe", "chromStandride", "chromStyipe", "chelStyipe", "chromSyncridden", "chromStro", "chromSTrite", "chelStyridden", "chromStrite", "chromStandrite", "chromStrate"], "dstStride": ["dststore", "dstSTro", "dstStro", "dscSTride", "dscSTide", "dblStro", "dstStrite", "dblStride", "dstRestro", "dscStrip", "dblSTro", "dstSTrite", "dstStrip", "dblSTride", "dscStride", "dscSTrip", "dblSTrite", "dstStrride", "dstSTrip", "dblStrite", "dststrite", "dstRestride", "dstRestrip", "dstStrore", "dstStore", "dstStide", "dstSTride", "dstRestide", "dstStrro", "dstSTide", "dststride", "dstSTore", "dblStore", "dblSTore", "dststro", "dscStro", "dstStrrite", "dscSTro", "dscStide"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void puv3_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    CPUUniCore32State *env;\n\n    UniCore32CPU *cpu;\n\n\n\n    if (initrd_filename) {\n\n        error_report(\"Please use kernel built-in initramdisk\");\n\n        exit(1);\n\n    }\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"UniCore-II\";\n\n    }\n\n\n\n    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));\n\n    if (!cpu) {\n\n        error_report(\"Unable to find CPU definition\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    puv3_soc_init(env);\n\n    puv3_board_init(env, ram_size);\n\n    puv3_load_kernel(kernel_filename);\n\n}\n", "idx": 13077, "substitutes": {"machine": ["database", "proc", "m", "mom", "part", "service", "config", "object", "manager", "image", "project", "module", "vm", "game", "model", "comment", "linux", "server", "computer", "app", "slave", "sim", "loader", "parse", "instance", "boot", "Machine", "data", "base", "mode", "address", "state", "agent", "rule", "process", "hard", "host", "cache", "template", "mac", "class", "space", "environment", "controller", "node", "message"], "cpu_model": ["cpuleximage", "cpu_loader", "core_base", "core_size", "cpu_size", "gpu_mode", "cpujmode", "kernel_mode", " cpu_mode", "gpu_image", "gpu_layout", "gpu_resource", "kernel_manager", "cpujmanager", "kernel_model", "cpulexmodel", "cpuamserver", "cpulexresource", "kernel_service", " cpu_models", "cpu_models", "core_model", "cpu_layout", "cpuamsize", "cpu_base", "kerneljmodel", "cpuidmode", "kerneljservice", "cpujmodel", "cpu_service", " cpu_size", "kerneljmode", "cpuidmodel", "cpuambase", "cpuidresource", "cpu_mode", "cpu_image", "cpu_resource", "cpuidimage", "gpu_model", "cpulexmode", "cpujservice", "kerneljmanager", "core_server", "cpu_manager", "cpuammodel", "cpu_server", "gpu_loader"], "kernel_filename": ["kernelpsize", "kernel_title", " kernelpfilename", " kernelpfile", "kerneldbtitle", "ernel_filename", " kernelpsize", "kernel_label", "kernel2file", " kernel_file", "kernelFlabel", " kernelplabel", "kernel1download", "kernel2filename", "kernelblockfilename", "nn_filename", "kerneldbdownload", "kernelpfile", "nn_function", "erneldbfilename", "kernelFdownload", "kerneldblabel", "erneldbtitle", "kernel1title", "ernel_label", "kernelblocksize", "kernel_function", "ernel_download", "ernel_title", "kernel_file", " kernel_label", "erneldbdownload", "erneldblabel", "kernelFfilename", "kernelFtitle", "kerneldbfilename", "kernelpfilename", "kernel_size", "kernel2size", "nn_file", "nn_size", " kernel_size", "kernelblockfunction", "kernel1label", "kernel1filename", "kernelplabel", "kernelblockfile", "kernel2label", "kernel_download"], "initrd_filename": ["initrs_file", "initr_fn", "initr_maximum", "initrd___fn", "initrd___Filename", "initrt_module", "initrd_selection", "initrd_module", "initr_Filename", "initrd_file", "initrd_fn", "initrt_file", "initrd_name", "initrd_maximum", "initrs_Filename", "initrt_selection", "initrs_filename", "initrd___maximum", "initrs_name", "initrd___filename", "initrt_filename", "initrd_Filename", "initr_filename"], "env": ["args", "path", "egg", "en", "context", "edge", "queue", "enc", "ea", "eye", "config", "cv", " environment", "code", "eu", "oa", "ah", "style", "vm", "scope", "skin", "estate", "v", "conf", "conn", "np", "console", "loader", "energy", "size", "doc", "e", "ctx", "viron", "exc", "equ", "exe", "img", "her", "ext", "engine", "eng", "qt", "Environment", "cfg", "state", "global", "eni", "shell", "agent", "end", "pe", "attr", "osc", "network", "here", "exec", "gui", "db", "ev", "cache", "ec", "work", "que", "environment", "core", "net", "err"], "cpu": ["proc", "bench", "po", "cow", "ni", "config", "pc", "roc", "gc", "lc", "currency", "cn", "kernel", "uno", "vm", "linux", "uca", "px", "computer", "performance", "gnu", "pu", "fp", "conn", "np", "console", "processor", "loader", "GPU", "instance", " CPU", "net", "boot", "nc", "CPU", "nu", "eni", "gpu", "prem", "clock", "process", "cp", "hw", "css", "lb", "environment", "core", "python", "ctx", "node"]}}
{"project": "qemu", "commit_id": "f5ed36635d8fa73feb66fe12b3b9c2ed90a1adbe", "target": 1, "func": "static void virtio_queue_notify_vq(VirtQueue *vq)\n{\n    if (vq->vring.desc && vq->handle_output) {\n        VirtIODevice *vdev = vq->vdev;\n        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);\n        vq->handle_output(vdev, vq);", "idx": 20647, "substitutes": {"vq": ["Vqq", " vquery", "vqq", "Vq", "varquery", "evue", "Vqa", "viciq", "flqa", "svself", "VQ", "varque", "evQ", "vue", "uvqa", "verque", "avque", "fiq", "vqu", "vqa", "vcqa", "voltque", "svque", "vcself", "vck", "evq", "svqa", "vicque", "avq", "vicq", "vque", "svqq", "flque", " vQ", "flq", "evque", "lQ", "evqq", "svue", " vquest", "evquest", "evqu", "vcque", "sviq", "vquery", " vqa", "vquest", "verqa", "fquest", "eviq", "uvque", "voltq", "vcQ", "vciq", "viq", "avck", " vck", " vqq", "varck", "lreq", "varq", " vque", "voltQ", "vcq", "uvq", "flqu", "svdev", "svq", "svquest", "fq", "lque", "lq", "vreq", "verq", "vself", "Vque", "vicqq", "uvqu", "avquery", "fue", "Viq", " viq", "verdev", " vself", "svreq", "voltreq", "vcquest", "evqa", "vQ", "svQ"], "vdev": ["vdd", "svDev", "nvdevice", "Vq", "vddev", "vDev", "svdevice", "vreq", "svdem", "vsdd", "vdq", "nvdev", "vd", "pdevice", "tvdevice", " vd", "evq", "wDev", "svdc", "svdd", " vdd", "vpu", "preq", "vdc", "vpriv", "pdev", "vdevice", "wpu", "svd", "Vdevice", "wdevice", "nvad", "tvdev", "svad", "evdev", "vdpriv", "wreq", "evdevice", "ppu", "wdc", "gmod", " vdem", "vsdem", "wdev", "vmod", "gdevice", "tvpu", "vsdev", "gdev", "vsd", " vDev", " vdc", "vad", "nvmod", "vdem", "Vpriv", "svmod", "evpriv", "vddevice", "tvreq", "Vdev", "gad", "svdev", " vdevice"]}}
{"project": "FFmpeg", "commit_id": "199d4478de102ca7987adb97f2e66a1820a98ebd", "target": 1, "func": "int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)\n\n{\n\n    PerThreadContext *p = avctx->thread_opaque;\n\n    int *progress, err;\n\n\n\n    f->owner = avctx;\n\n\n\n    ff_init_buffer_info(avctx, f);\n\n\n\n    if (!(avctx->active_thread_type&FF_THREAD_FRAME)) {\n\n        f->thread_opaque = NULL;\n\n        return avctx->get_buffer(avctx, f);\n\n    }\n\n\n\n    if (p->state != STATE_SETTING_UP &&\n\n        (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks &&\n\n                avctx->get_buffer != avcodec_default_get_buffer))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() cannot be called after ff_thread_finish_setup()\\n\");\n\n        return -1;\n\n    }\n\n\n\n    pthread_mutex_lock(&p->parent->buffer_mutex);\n\n    f->thread_opaque = progress = allocate_progress(p);\n\n\n\n    if (!progress) {\n\n        pthread_mutex_unlock(&p->parent->buffer_mutex);\n\n        return -1;\n\n    }\n\n\n\n    progress[0] =\n\n    progress[1] = -1;\n\n\n\n    if (avctx->thread_safe_callbacks ||\n\n        avctx->get_buffer == avcodec_default_get_buffer) {\n\n        err = avctx->get_buffer(avctx, f);\n\n    } else {\n\n        p->requested_frame = f;\n\n        p->state = STATE_GET_BUFFER;\n\n        pthread_mutex_lock(&p->progress_mutex);\n\n        pthread_cond_signal(&p->progress_cond);\n\n\n\n        while (p->state != STATE_SETTING_UP)\n\n            pthread_cond_wait(&p->progress_cond, &p->progress_mutex);\n\n\n\n        err = p->result;\n\n\n\n        pthread_mutex_unlock(&p->progress_mutex);\n\n\n\n        if (!avctx->codec->update_thread_context)\n\n            ff_thread_finish_setup(avctx);\n\n    }\n\n\n\n    pthread_mutex_unlock(&p->parent->buffer_mutex);\n\n\n\n    return err;\n\n}\n", "idx": 8105, "substitutes": {"avctx": ["ajconfig", "evconn", "avesys", "aveci", "auxc", "ajctl", "macconn", "navcn", "evcontext", "aveqa", "aulc", "avcomponent", "abcmp", "navcontext", "afxc", "aveconfig", "afctx", "afsc", "avqa", "afsys", "vertx", "ajctx", "navctx", "ausys", "abcf", "avconv", "avsys", " avcontext", "verxc", "attctx", "evcmp", "aucontext", "avescope", "afci", "afcmp", "avcmp", "afcn", "avectl", "abcontext", "navcu", "avalctx", "avxc", "ajcu", "aveconn", "AVcmp", "avecontext", "afcf", "avlc", "attcontext", "AVcu", "AVconn", "avecu", "avelc", "avalcontext", "ajconv", "aflc", "attcmp", "afctl", "vercontext", "avcu", "navcmp", "avconfig", "AVcontext", "aveconv", "macctx", "avalcomponent", "navcf", "avcontext", " avcn", "attcf", "afqa", "ajqa", "navsc", "avconn", "autx", "evctx", "abctx", "ajconn", "avcn", "AVcf", "avctl", "afconv", "auci", "avectx", " avsc", "avetx", "AVctx", "avalcmp", "afscope", "avcf", "maccf", "aftx", "avalconn", "avscope", "avecf", "avtx", "avsc", "avecomponent", "verctx", "maccontext", "afconn", "afcontext", "afconfig", "afcomponent", "ajcontext", "avalscope", "auctx", "avci", "avecmp", "afcu"], "f": ["fen", "flow", "fr", "tf", "feed", "sf", "v", "fw", "parent", "b", "x", "rf", "i", "info", "m", "fx", "fb", "l", "j", "d", "fl", "q", "fe", "conf", "u", "e", "per", "file", "t", "fn", "ff", "n", "fac", "df", "fp", "k", "framework", "fa", "h", "frame", "z", "fs", "c", "bf", "fd", "g", "cf", "fc", "ref", "fi", "form", "lf", "F"], "p": ["patch", "cp", "plugin", "P", "o", "bp", "v", "a", "parent", "s", "pa", "pre", "pp", "b", "op", "i", "up", "wp", "ap", "lp", "pe", "m", "l", "pm", "pi", "client", "post", "php", "j", "d", "pc", "py", "q", "param", "np", "u", "part", "e", "point", "per", "port", "t", "k", "n", "ctx", "fp", "jp", "exec", "this", "h", "vp", "sp", "proc", "c", "ip", "g", "y", "api", "br", "tp", "cache", "pb", "r"], "progress": ["patch", "flow", "gr", "cmp", "recent", "imp", "act", "area", "diff", "press", "id", "complete", "done", "parent", "scope", "update", "Progress", "data", "xp", "queue", "debug", "status", "track", "resource", "content", "order", "grade", "wait", "dist", "cli", "push", "error", "depth", "history", "path", "feat", "exec", "callback", "process", "result", "scale", "qa", "stage", "mode", "step", "range", "resp", "asc", "move", "desc", "success", "activity", "cache", "next", "max", "dim"], "err": ["dr", "gr", "fr", "ch", "er", "cr", "iter", "id", "rr", "count", "fee", "pre", "bug", "exc", "rc", "or", "i", "in", "ace", "status", "rh", "rage", "l", "attr", "phi", "order", "grade", "bar", "res", "ctr", "acer", "code", "e", "all", "error", "comment", "out", "arr", "dev", " error", "n", "cb", "lr", "str", "nil", "result", "raise", "req", "h", "runner", "mr", "var", "ind", "errors", "orig", "resp", "y", "br", "c", "inner", "cache", "test", "r", "diff", "Error", "msg"]}}
{"project": "FFmpeg", "commit_id": "b46a77f19ddc4b2b5fa3187835ceb602a5244e24", "target": 0, "func": "int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,\n\n                         int level)\n\n{\n\n    VDPAUHWContext *hwctx = avctx->hwaccel_context;\n\n    VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data;\n\n    VdpVideoSurfaceQueryCapabilities *surface_query_caps;\n\n    VdpDecoderQueryCapabilities *decoder_query_caps;\n\n    VdpDecoderCreate *create;\n\n    void *func;\n\n    VdpStatus status;\n\n    VdpBool supported;\n\n    uint32_t max_level, max_mb, max_width, max_height;\n\n    VdpChromaType type;\n\n    uint32_t width;\n\n    uint32_t height;\n\n\n\n    vdctx->width            = UINT32_MAX;\n\n    vdctx->height           = UINT32_MAX;\n\n\n\n    if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height))\n\n        return AVERROR(ENOSYS);\n\n\n\n    if (hwctx) {\n\n        hwctx->reset            = 0;\n\n\n\n        if (hwctx->context.decoder != VDP_INVALID_HANDLE) {\n\n            vdctx->decoder = hwctx->context.decoder;\n\n            vdctx->render  = hwctx->context.render;\n\n            vdctx->device  = VDP_INVALID_HANDLE;\n\n            return 0; /* Decoder created by user */\n\n        }\n\n\n\n        vdctx->device           = hwctx->device;\n\n        vdctx->get_proc_address = hwctx->get_proc_address;\n\n\n\n        if (hwctx->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)\n\n            level = 0;\n\n\n\n        if (!(hwctx->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) &&\n\n            type != VDP_CHROMA_TYPE_420)\n\n            return AVERROR(ENOSYS);\n\n    } else {\n\n        AVHWFramesContext *frames_ctx = NULL;\n\n        AVVDPAUDeviceContext *dev_ctx;\n\n\n\n        // We assume the hw_frames_ctx always survives until ff_vdpau_common_uninit\n\n        // is called. This holds true as the user is not allowed to touch\n\n        // hw_device_ctx, or hw_frames_ctx after get_format (and ff_get_format\n\n        // itself also uninits before unreffing hw_frames_ctx).\n\n        if (avctx->hw_frames_ctx) {\n\n            frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n        } else if (avctx->hw_device_ctx) {\n\n            int ret;\n\n\n\n            avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);\n\n            if (!avctx->hw_frames_ctx)\n\n                return AVERROR(ENOMEM);\n\n\n\n            frames_ctx            = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n            frames_ctx->format    = AV_PIX_FMT_VDPAU;\n\n            frames_ctx->sw_format = avctx->sw_pix_fmt;\n\n            frames_ctx->width     = avctx->coded_width;\n\n            frames_ctx->height    = avctx->coded_height;\n\n\n\n            ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);\n\n            if (ret < 0) {\n\n                av_buffer_unref(&avctx->hw_frames_ctx);\n\n                return ret;\n\n            }\n\n        }\n\n\n\n        if (!frames_ctx) {\n\n            av_log(avctx, AV_LOG_ERROR, \"A hardware frames context is \"\n\n                   \"required for VDPAU decoding.\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        dev_ctx = frames_ctx->device_ctx->hwctx;\n\n\n\n        vdctx->device           = dev_ctx->device;\n\n        vdctx->get_proc_address = dev_ctx->get_proc_address;\n\n\n\n        if (avctx->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)\n\n            level = 0;\n\n    }\n\n\n\n    if (level < 0)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device,\n\n                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        surface_query_caps = func;\n\n\n\n    status = surface_query_caps(vdctx->device, type, &supported,\n\n                                &max_width, &max_height);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    if (supported != VDP_TRUE ||\n\n        max_width < width || max_height < height)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device,\n\n                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        decoder_query_caps = func;\n\n\n\n    status = decoder_query_caps(vdctx->device, profile, &supported, &max_level,\n\n                                &max_mb, &max_width, &max_height);\n\n#ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE\n\n    if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) {\n\n        profile = VDP_DECODER_PROFILE_H264_MAIN;\n\n        status = decoder_query_caps(vdctx->device, profile, &supported,\n\n                                    &max_level, &max_mb,\n\n                                    &max_width, &max_height);\n\n    }\n\n#endif\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n\n\n    if (supported != VDP_TRUE || max_level < level ||\n\n        max_width < width || max_height < height)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        create = func;\n\n\n\n    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        vdctx->render = func;\n\n\n\n    status = create(vdctx->device, profile, width, height, avctx->refs,\n\n                    &vdctx->decoder);\n\n    if (status == VDP_STATUS_OK) {\n\n        vdctx->width  = avctx->coded_width;\n\n        vdctx->height = avctx->coded_height;\n\n    }\n\n\n\n    return vdpau_error(status);\n\n}\n", "idx": 4524, "substitutes": {"avctx": ["vcu", "navbc", "AVtx", "AVlc", "afcas", "hwcf", "verpkg", " avcas", "evcontext", "navcv", "abcmp", "navcontext", "afxc", "afctx", "avkb", "navctx", "ovbc", "hwcontext", "abcf", " avcontext", "evcmp", "afcv", "evcf", "afcmp", "avcmp", "navpkg", "vxc", "abcontext", "avcv", "navcu", "avxc", "AVcmp", "ovcontext", "avecontext", "afcf", "avlc", "AVcu", "svcv", "avecu", "avbc", "avekb", "aflc", "avcas", "AVcas", "evlc", "vercontext", "avcu", "navcmp", "AVcontext", "ovconn", "afkb", "navconn", "navcf", "hwcu", "vctx", "hwxc", "avcontext", "navlc", "afpkg", "svcf", "navtx", "avconn", "evctx", "abctx", "AVpkg", "avectx", "avepkg", "svcontext", "ovctx", "AVctx", "avcf", "aftx", "avtx", "afbc", "hwcmp", "verctx", "afconn", "avpkg", "afcontext", "verkb", " avlc", "avecmp", "afcu", "vcontext", "svctx"], "profile": ["plugin", "program", " plugin", " profiles", "prof", " Profile", "method", " proto", "TYPE", "val", "image", " preview", "details", "picture", "py", "def", "buffer", " profiling", "file", "port", " prog", "path", " mode", " prof", "pb", "summary", "Profile", "view"], "level": ["levels", "name", "layer", "clean", "local", "id", "count", "method", "parent", "scope", "vel", "stack", "key", "l", "Level", "child", "limit", "length", "loop", "code", "len", "col", "error", "depth", "path", "temp", "scale", "stage", "lvl", "where", "line", "global", "thread", "model", "wl", "VEL", "test", "index", "mode"], "hwctx": ["fwcmp", "hawconn", "hlcmp", "hwcf", "fwxc", "hwctrl", "hwtx", "iwctx", "hwlc", "rwctrl", "rwctx", "vcctx", "wxcmp", "fwconn", "fwkb", "hwcontext", "fwloc", "hwkb", "fwsci", "rhcf", "rwcf", "wxctx", "rhctx", "hawcontext", "fwcontext", "vdcn", "hwcn", "fwlc", "hlctx", "avcmp", "fwtx", "nvtx", "lvloc", "nvcmp", "rhcontext", "rwkb", "hlcontext", "hwloc", "iwconn", "rwloc", "rwsci", "wxcontext", "iwctrl", "rhloc", "iwcf", "iwloc", "fwcn", "rwlc", "hwconn", "rwcn", "hwxc", "avcontext", "fwcf", "lvcontext", "iwxc", "nvctx", "vdloc", "hawctx", "hwsci", "rwcontext", "vccontext", "hawcf", "iwcmp", "hawxc", "hlxc", "iwtx", "iwlc", "vdcontext", "lvcf", "avcf", "wxxc", "vcconn", "hawsci", "iwkb", "hwcmp", "vccf", "lvctx", "fwctx", "nvcontext", "fwctrl", "iwcontext", "rwcmp"], "vdctx": ["svkb", "xdctx", "hdcmp", "hdcf", "hdctx", "nvcf", "vdcrit", "vdkb", "vidcontext", "vvcrit", "vcctx", "vidcli", "nvxc", "hwcp", "hwcontext", "nvpkg", "dlsync", "vdxc", "hdxc", "hdpkg", "vddc", "hwcv", "vvctx", "nvtx", "nvcrit", "vdcli", "vidctx", "viddc", "dlctx", "nvcmp", "hdcontext", "vdcf", "nvctrl", "vdsync", "vvcli", "hdcrit", "dlctrl", "hdtx", "hdkb", "vdtx", "sdcp", "hdctrl", "nvdc", "vdconn", "hdsync", "vdctrl", "vdpkg", "vdcp", "xdpkg", "vctx", "hwxc", "vvcf", "sdctx", "hdconn", "vdcmp", "vvdc", "xdkb", "vvcontext", "nvconn", "nvkb", "nvctx", "dlcontext", "sdcv", "nvcli", "nvcv", "vccontext", "nvcp", "svcontext", "vdcontext", "sdcontext", "xdcontext", "vcconn", "svpkg", "hwcmp", "nvsync", "nvcontext", "vdcv", "svctx"], "surface_query_caps": ["surface_view_pieces", "surface_query_abilities", "surface_view_caps", "surface_query_pieces", "surface_view_abilities", "surface_view_cap", "surface_query_cap"], "decoder_query_caps": ["decoder_request_cap", "decoder_query_abilities", "decoder_query_cap", "decoder_query_cards", "decoder_request_abilities", "decoder_request_cards", "decoder_request_caps"], "create": ["enable", "creat", "copy", "open", "send", "save", "execute", "update", "sync", "invoke", "draw", "make", "media", "call", "Create", "code", "activate", "process", "source", "parse", "stage", "define", "creator", "write", "apply", "construct", "setup", "add"], "func": ["function", "pack", "unc", "execute", "nc", "sync", "sys", "module", "conv", "call", "pc", "ack", "cc", "code", "fn", "cmd", "Function", "cb", "exec", "callback", "process", "stage", "alloc", "fun", "apply", "src", "grad", "setup"], "status": ["function", "stat", "name", "complete", "method", "STAT", "sync", "unit", " Status", "state", "stats", "obj", "active", "reason", "str", "process", "source", "result", "output", "stage", "Status", "success", "current", "summary", "mode"], "supported": ["function", " compatibility", "flag", "platform", " platform", "compatible", "b", " library", "Supported", "support", "valid", "null", " required", "used", "enabled", "state", "mod", " allowed", " support", "lib", " enabled", " compatible", " connected", "prop", " capable", " supports", " native", " valid"], "max_level": ["maxalllayer", "max67block", "max_length", "max_layer", "max_block", " max_layer", " max_block", "maxalllevel", "maxalllength", "max67layer", "max67length", "maxallblock", " max_length", "max67level"], "max_mb": ["min_level", "min_mode", "min_lvl", "min_mb", "max_mode", "max_lvl"], "max_width": [" max_weight", "max_weight", " max_window", "max___width", "max_length", "max___window", "max_window", "max___length", "max___weight", " max_length"], "max_height": ["maxaldata", "maxalheight", " max_data", "maxalwidth", " max_h", "maxalh", "max_h", "max_data"], "type": ["function", "types", " Type", "name", "time", "position", "block", "id", "method", "parent", "shape", "value", "TYPE", "op", "object", "style", "slice", "format", "typ", "rel", "pe", " TYPE", "unit", "key", "resource", " typ", "version", "state", "call", "by", "number", "code", "kind", "error", "port", "t", "ype", "source", "p", "rule", "attribute", "class", "y", "link", "set", "Type", "view", "role"], "height": ["density", "Height", "build", "host", "padding", "id", "alpha", "shape", "device", "layout", "crop", "gap", "inches", "style", "x", "image", "draw", "window", "ty", "capacity", "weight", "length", "thin", "resolution", "definition", "deep", "depth", "w", "k", "volume", "history", "pad", "container", "quality", "input", "h", "direction", "hold", "strength", "memory", "ip", "rank", "stroke", "index", "max", "dim", "size"], "frames_ctx": ["videos_ctx", "frames_context", "frames_anc", "frames_chan", "videos_xc", "frames_xc", "flows_anc", "videos_chan", "flows_ctx", "flows_lc", "frames_lc", "flows_xc", "videos_context"], "dev_ctx": ["device_alloc", "dev_context", "devPcb", "device_cb", "devPalloc", "device_ctx", "device_context", "devPcontext", "dev_cb", "devjalloc", "devPctx", "devjcontext", "devjcb", "devjctx", "dev_alloc"], "ret": ["row", "layer", "flag", "ag", "al", "value", "vel", "val", "rc", "conv", "res", "ry", "def", "all", "col", "det", "deep", "RET", "result", " result", "Ret", "re", "back", "resp", "group"]}}
{"project": "qemu", "commit_id": "56b4a42a2e0ae74cee629abcb82993e79deeb356", "target": 0, "func": "static void migrate_set_downtime(QTestState *who, const char *value)\n\n{\n\n    QDict *rsp;\n\n    gchar *cmd;\n\n\n\n    cmd = g_strdup_printf(\"{ 'execute': 'migrate_set_downtime',\"\n\n                          \"'arguments': { 'value': %s } }\", value);\n\n    rsp = qtest_qmp(who, cmd);\n\n    g_free(cmd);\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n}\n", "idx": 7458, "substitutes": {"who": ["whose", "name", "someone", "cgi", "ko", "la", "eth", "san", "home", "wa", "nick", "wh", "how", "foo", "wo", "gob", "which", "cli", "organ", "from", "gmail", "lo", "que", "what", "da", "woman", "har", "hou", "wife", " Who", "ou", "whe", "staff", "where", "Who", "WHO", "hi", "gh", "gram", "bo", "ha", " wo", "hello"], "value": ["function", "name", "time", "v", "change", "entry", "values", "update", "val", "password", "data", "style", "place", "format", "unit", "key", "null", "valid", "content", "how", "money", "state", "server", "property", "w", "message", "Value", "VALUE", "range", "new", "type", "set", "index", "command", "end"], "rsp": ["Rsp", "yrp", "rso", "Rsc", "rp", "srps", " rps", "srsl", " rp", "nrso", "rst", "nrsp", "Rso", "yrsp", "nrp", "srsp", "risp", " rmp", "srst", "srmp", " rst", " rsl", "yrmp", "rsl", "Rp", "srisp", " risp", "rsc", "srp", "rrsl", "Risp", "srsc", "rrsp", "yrps", "rrst", " rsc", " rso", "rps", "nrsc", "rmp"], "cmd": ["bind", "cp", "cmp", "name", "cfg", "id", "md", "method", "dict", "config", "Cmd", "comp", "help", "draw", "buf", "cl", "attr", "client", "call", "obj", "args", "arg", "gz", "cli", "cc", "ack", "reason", "code", "ck", "col", "func", "ctx", "path", "cb", "prefix", "ctrl", "req", "c", "ind", "cf", "cod", "cookie", "gn", "addr", "src", "command", "grad", "conn", "cd", "msg"]}}
{"project": "qemu", "commit_id": "6baebed7698a37a0ac5168faf26023426b0ac940", "target": 1, "func": "static int find_dirty_height(VncState *vs, int y, int last_x, int x)\n\n{\n\n    int h;\n\n\n\n    for (h = 1; h < (vs->serverds.height - y); h++) {\n\n        int tmp_x;\n\n        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))\n\n            break;\n\n        for (tmp_x = last_x; tmp_x < x; tmp_x++)\n\n            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);\n\n    }\n\n\n\n    return h;\n\n}\n", "idx": 18194, "substitutes": {"vs": ["ns", "ums", "vas", "ts", "s", "bs", "stats", "rs", "vr", "las", "sv", "vc", "services", "vp", "ils", "vals", "sb", "ys", "ss", "ls", "ops", "fs", "xs", "lines", "lv", "vers", "sk", "views", "cs", "css", "VS", "obs", "outs", "qs", "ov", "ses", "v", "verts", "js", "ps", "alls", "vt", "sts", "ks", "http", "gs", "va", "es", "env", "cv", "ds"], "y": ["j", "ch", "ky", "t", "sky", "iy", "hy", "ya", "i", "year", "ys", "type", "z", "ny", "ym", "zy", "ry", "cy", "Y", "l", "d", "ye", "yi", "dy", "ay", "w", "height", "yy", "ey", "e", "ish", "key", "yt", "v", "yr", "c", "yn", "p", "col", "oy", "vy", "yo", "gy", "a", "py", "sy", "u"], "last_x": ["last__w", " last_ex", "last_index", "last__xy", " last_xp", "prev_y", " last_z", " last_xy", "last__xp", "last__x", " last_w", "prev_x", "prev_w", "prev_index", "last__y", "last__z", "last_w", "last_z", "last_xy", "last_xp", "last__ex", "last_y", "last_ex", " last_y"], "x": ["rx", "m", "xf", "xx", "t", "f", "ix", "px", "n", "i", "z", "xy", "max", "index", "pos", "xs", "en", "l", "d", "ax", "ex", "w", "dx", "e", "X", "q", "_", "v", "c", "p", "xi", "wa", "u"], "h": ["m", "j", "ch", "code", "t", "eh", "f", "oh", "hr", "n", "hy", "dh", "g", "gh", "hi", "i", "hd", "z", "rh", "max", "ho", "uh", "o", "han", "his", "home", "hhh", "l", "d", "ht", "sh", "kh", "height", "w", "hl", "id", "k", "q", "e", "bh", "v", "ih", "c", "hp", "p", "hm", "b", "hh", "ph", "ha", "hs", "he", "ah", "H", "u"], "tmp_x": ["tmp__xi", "last_rx", " tmp_name", " tmp_xs", "tmp_ex", " tmp_ex", "tmp_ix", " tmp_X", "last_ix", "tmp__y", "tmp_name", " tmp_rex", "tmp_xs", "tmp_pe", "tmp__pe", "tmp_X", " tmp_xi", " tmp_pe", "tmp_rex", "tmp__x", "tmp_y", " tmp_y", "last_X", "tmp_rx", "tmp_xi"]}}
{"project": "qemu", "commit_id": "c5ce83334465ee5acb6789a2f22d125273761c9e", "target": 0, "func": "static void press_key(VncState *vs, int keysym)\n\n{\n\n    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);\n\n    qemu_input_event_send_key_delay(0);\n\n    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);\n\n    qemu_input_event_send_key_delay(0);\n\n}\n", "idx": 24603, "substitutes": {"vs": ["rs", "ses", "sk", "sys", "events", "ss", "ns", "va", "cv", "ts", "las", "ms", "ds", "forces", "conf", "verts", "ps", "vas", "state", "vers", "ks", "plugins", "bs", "css", "uses", "vals", "ys", "cs", "gs", "stats", "vc", "s", "http", "os", "sb", "obs", "services", "xs", "ums", "ents", "ls", "fs", "qs", "ves", "alls", "v", "acs", "vp", "VS", "sv", "env", "views"], "keysym": ["Keysys", "keyscm", "typesy", "typesem", "keysys", " keysyn", "keysem", " keysy", "Keysym", " keyscm", "typessym", "Keysy", "keyssym", " Keysyn", "typesys", "typesym", "Keysem", "keysy", " keysem", "typescm", "keysyn", "typesyn", " Keyscm", " keyssym", " keysys", " Keyssym", " Keysym"]}}
{"project": "qemu", "commit_id": "973945804d95878375b487c0c5c9b2556c5e4543", "target": 0, "func": "static void tcx_blit_writel(void *opaque, hwaddr addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    TCXState *s = opaque;\n\n    uint32_t adsr, len;\n\n    int i;\n\n\n\n    if (!(addr & 4)) {\n\n        s->tmpblit = val;\n\n    } else {\n\n        addr = (addr >> 3) & 0xfffff;\n\n        adsr = val & 0xffffff;\n\n        len = ((val >> 24) & 0x1f) + 1;\n\n        if (adsr == 0xffffff) {\n\n            memset(&s->vram[addr], s->tmpblit, len);\n\n            if (s->depth == 24) {\n\n                val = s->tmpblit & 0xffffff;\n\n                val = cpu_to_be32(val);\n\n                for (i = 0; i < len; i++) {\n\n                    s->vram24[addr + i] = val;\n\n                }\n\n            }\n\n        } else {\n\n            memcpy(&s->vram[addr], &s->vram[adsr], len);\n\n            if (s->depth == 24) {\n\n                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);\n\n            }\n\n        }\n\n        memory_region_set_dirty(&s->vram_mem, addr, len);\n\n    }\n\n}\n", "idx": 3449, "substitutes": {"opaque": ["opacity", " opque", "opaques", "iopque", "oaque", "ovacle", " opac", "opac", "iopaque", "copaques", "iopac", "copque", " opacity", "copac", "ovaque", "copacle", "copacity", "iopacity", "oacity", "opacle", "oacle", "copaque", "oaques", "ovaques", "opque", "ovacity"], "addr": ["dr", "route", "act", "acl", "url", "lvl", "alt", "adder", "enc", "ady", "code", "index", "pointer", "address", "ack", "x", "ind", "en", "rt", "name", "host", "sid", "nn", "align", "id", "ea", "frame", "buf", "arr", "adr", "ac", "coord", "work", "p", "ptr", "hop", "amp", "edge", "layer", "base", "np", "offset", "data", "rr", "loc", "ad", "r", "env", "ha", "enh", "pad", "usr", "h", "anne", "afi", "order", "ref", "attr", "arm", "el", "fx", "node", "kk", "cmd", "asm", "ino", "req", "ost", "mode", "oa", "src", "intel", "inter", "conn", "alias", "aa", "ord", "grad", "pos", "md", "config", "ip", "nick", "ar", "padding", "pc", "amd", "cmp", "sta", "ace", "rc"], "val": ["ret", "base", "arg", "vol", "ol", "li", "cal", "def", "key", "elt", "vals", "data", "loc", "Val", "slot", "fl", "sl", "it", "end", "buf", "arr", "enc", "bl", "pre", "py", "pos", "tx", "bal", "aval", "sel", "x", "l", "block", "p", "ind", "fi", "eval", "ref", "f", "la", "el", "value", "ival", "il", "v", "seq", "serv", "b", "var", "valid", "al", "reg", "VAL", "am", "pt", "rt", "all", "count", "db", "mem"], "size": [" err", "ctx", " iv", "vals", "data", " pri", " ret", " arg", "pos", " data", " pos", " el", "eval", "length", " length", "value", "padding", "v", "al", "VAL", "mem"], "s": ["sg", "js", "service", "this", "cs", "ss", "rs", "ts", "spec", "a", "sb", "new", "r", "n", "aws", "is", "ins", "sl", "ms", "y", "g", "side", "m", "ses", "ls", "args", "uns", "sync", "settings", "ds", "ps", "gs", "ns", "l", "c", "p", "sie", "state", "w", "e", "services", "f", "self", "es", "conf", "sq", "us", "sys", "secondary", "rows", "as", "o", "v", "b", "site", "t", "S", "session", "ks", "os", "your", "hs", "states", "fs", "si", "sym", "parts", "ssl"], "adsr": ["assesr", "andsdr", " adsdr", "Adrr", "artsrr", "assesnr", "edsrr", " adsrt", "aidpr", "acksp", "psrt", "edsr", "aidr", "adesr", "adsp", "artsrd", "Adr", "ddcr", "artsrf", "adscr", "aidrr", "adsrd", "psrr", "adsrr", "ansrr", "adsdr", "andsr", "aidrt", "acksrr", "ansrt", "ansr", "assesdr", "acksr", "artsr", "ksrr", "ksrf", "ksr", "adescr", "andsnr", "adesrf", "assesp", "ksrd", "edsrd", "edsrf", "adsrt", "assesrt", "adspr", "adesp", "ddr", "adesrr", "andsrt", "Adcr", "adsnr", "acksrt", " adsnr", "adesrt", "pspr", "anspr", "ddrr", "adsrf", "ddrf", "assesrr", "Adrf", "psr"], "len": ["base", "led", "fun", "ld", "name", "li", "lan", "den", "ni", "Len", "dim", "loc", "ellen", "n", "lvl", "lf", "lif", "ln", "sl", "dl", "sp", "lang", "un", "fn", "end", "id", "lim", "pos", "dy", "ls", "ll", "lt", "fl", "z", "ie", "lon", "l", "ind", "fin", "e", "lc", "length", "f", "la", "el", "il", "en", "rel", "lib", "seq", "lin", "lit", "line", "ann", "count", "gen", "part", "limit", "in", "le", "mem"], "i": ["base", "li", "gi", "a", "ni", "ii", "zi", "ui", "oi", "pi", "d", "n", "I", "uni", "di", "is", "id", "mi", "it", "k", "j", "pos", "eni", "ri", "code", "ti", "ini", "z", "index", "ai", "x", "ip", "l", "p", "ind", "bi", "hi", "e", "c", "f", "phi", "adi", "u", "il", "en", "ori", "v", "o", "vi", "qi", "ix", "b", "uri", "ci", "start", "si", "in", "xi"]}}
{"project": "FFmpeg", "commit_id": "1577526b47439f33a999339efdec5d624b70e1da", "target": 1, "func": "static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)\n{\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n    opj_image_cmptparm_t cmptparm[4] = {{0}};\n    opj_image_t *img;\n    int i;\n    int sub_dx[4];\n    int sub_dy[4];\n    int numcomps;\n    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;\n    sub_dx[0] = sub_dx[3] = 1;\n    sub_dy[0] = sub_dy[3] = 1;\n    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;\n    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;\n    numcomps = desc->nb_components;\n    switch (avctx->pix_fmt) {\n    case AV_PIX_FMT_GRAY8:\n    case AV_PIX_FMT_YA8:\n    case AV_PIX_FMT_GRAY16:\n    case AV_PIX_FMT_YA16:\n        color_space = CLRSPC_GRAY;\n        break;\n    case AV_PIX_FMT_RGB24:\n    case AV_PIX_FMT_RGBA:\n    case AV_PIX_FMT_RGB48:\n    case AV_PIX_FMT_RGBA64:\n    case AV_PIX_FMT_GBR24P:\n    case AV_PIX_FMT_GBRP9:\n    case AV_PIX_FMT_GBRP10:\n    case AV_PIX_FMT_GBRP12:\n    case AV_PIX_FMT_GBRP14:\n    case AV_PIX_FMT_GBRP16:\n    case AV_PIX_FMT_XYZ12:\n        color_space = CLRSPC_SRGB;\n        break;\n    case AV_PIX_FMT_YUV410P:\n    case AV_PIX_FMT_YUV411P:\n    case AV_PIX_FMT_YUV420P:\n    case AV_PIX_FMT_YUV422P:\n    case AV_PIX_FMT_YUV440P:\n    case AV_PIX_FMT_YUV444P:\n    case AV_PIX_FMT_YUVA420P:\n    case AV_PIX_FMT_YUVA422P:\n    case AV_PIX_FMT_YUVA444P:\n    case AV_PIX_FMT_YUV420P9:\n    case AV_PIX_FMT_YUV422P9:\n    case AV_PIX_FMT_YUV444P9:\n    case AV_PIX_FMT_YUVA420P9:\n    case AV_PIX_FMT_YUVA422P9:\n    case AV_PIX_FMT_YUVA444P9:\n    case AV_PIX_FMT_YUV420P10:\n    case AV_PIX_FMT_YUV422P10:\n    case AV_PIX_FMT_YUV444P10:\n    case AV_PIX_FMT_YUVA420P10:\n    case AV_PIX_FMT_YUVA422P10:\n    case AV_PIX_FMT_YUVA444P10:\n    case AV_PIX_FMT_YUV420P12:\n    case AV_PIX_FMT_YUV422P12:\n    case AV_PIX_FMT_YUV444P12:\n    case AV_PIX_FMT_YUV420P14:\n    case AV_PIX_FMT_YUV422P14:\n    case AV_PIX_FMT_YUV444P14:\n    case AV_PIX_FMT_YUV420P16:\n    case AV_PIX_FMT_YUV422P16:\n    case AV_PIX_FMT_YUV444P16:\n    case AV_PIX_FMT_YUVA420P16:\n    case AV_PIX_FMT_YUVA422P16:\n    case AV_PIX_FMT_YUVA444P16:\n        color_space = CLRSPC_SYCC;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR,\n               \"The requested pixel format '%s' is not supported\\n\",\n               av_get_pix_fmt_name(avctx->pix_fmt));\n    }\n    for (i = 0; i < numcomps; i++) {\n        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;\n        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;\n        cmptparm[i].sgnd = 0;\n        cmptparm[i].dx = sub_dx[i];\n        cmptparm[i].dy = sub_dy[i];\n        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];\n        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];\n    }\n    img = opj_image_create(numcomps, cmptparm, color_space);\n    // x0, y0 is the top left corner of the image\n    // x1, y1 is the width, height of the reference grid\n    img->x0 = 0;\n    img->y0 = 0;\n    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;\n    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;\n    return img;\n}", "idx": 1883, "substitutes": {"avctx": ["camctx", "afsci", "AVctx", "avectx", "avsci", "avconn", "afcmp", "afctx", "afcontext", "afpkg", "aveconn", "Avcontext", "akcontext", "Avconn", "Avctx", "avpkg", "akcmp", "AVpkg", "afconn", "AVcontext", "avecca", "camcontext", "camcca", "avcca", "avcontext", "avesci", "avecontext", "akpkg", "akctx", "Avsci", "afcca", "camconn", "AVcmp", "avcmp"], "parameters": ["paramseters", "configparams", "paramParameters", "ramParameters", "configParameters", "paramparams", "paramsParameters", "configeters", "ramparams", "paramsparams", "rameters"], "desc": ["sub", "name", "ext", "def", "esc", "conn", "dim", "loc", "d", "Description", "rec", "der", "de", "neg", "enc", "reci", "adr", "des", "dest", "dep", "info", "df", "config", "asc", "description", "dc", "ec", "dev", "doc", "design", "diff", "Desc", "text", "sc", "decl", "ca", "summary", "sec", "comment", "req", "dir", "pri", "dist"], "cmptparm": ["cmptpore", "cmptpair", "cmppfare", "cmptpare", "cmptfare", "cmpppare", "cmppparm", "cmptbare", "cmptppare", "cmptfair", "cmppfarm", "cmptbair", "cmpppair", "cmppfore", "cmppfair", "cmpppore", "cmptppore", "cmptpparm", "cmptfarm", "cmptppair", "cmptbore", "cmptfore", "cmptbarm"], "img": ["crop", "ff", "src", "sup", "imp", "ii", "norm", "picture", "orig", "im", "ng", "buf", "tmp", "cb", "tif", "iframe", "fig", "aff", "gd", "app", "br", "cube", "obj", "bg", "amp", "iv", "transform"], "i": ["cli", "ii", "pi", "ui", "r", "d", "I", "n", "iu", "j", "pixel", "ti", "ip", "l", "c", "p", "bi", "e", "f", "u", "v", "s", "b", "qi", "t", "ci", "io", "xi"], "sub_dx": [" sub_du", "Sub_dc", "sub__ded", "sub_ds", "Sub_dx", " sub_coe", "sub__dx", "sub_du", "sub__eddy", " sub_dq", "Sub_dy", "Sub_du", "sub_wd", "sub_ded", "sub_dj", "sub__dy", "sub__dc", " sub_eddy", "sub_dc", " sub_dj", "Sub_ded", "sub_eddy", "Sub_ds", "sub__wd", "sub_coe", "sub_dq", " sub_wd"], "sub_dy": [" sub_y", "Sub_dx", " sub_d", "sub_dt", "Sub_idd", "Sub_dj", "Sub_die", "sub__dx", "Sub_di", "sub_done", "sub_y", "sub__eddy", "sub_idd", "Sub_dy", "Sub_der", "sub__dt", "sub2dx", "sub_d", "sub_der", "sub__d", "sub__y", "sub_dj", "sub__dy", "Sub_done", " sub_eddy", "sub_die", "sub_di", "sub_eddy", "sub2dj", " sub_dt", "sub2dy", "sub2done"], "numcomps": ["numquonents", "numquples", "numcompos", "nbcomps", "numcomPS", "numcomponents", "numcompps", "numproPS", "numcompples", "nbcompples", "numcomonents", "ncomppos", "numproples", "numCompos", "nbcompPS", "numComonents", "numComples", "nbcomppos", "ncomonents", "ncompps", "nbcompps", "ncompos", "ncomples", "nbcompos", "numComPS", "numComps", "numcomples", "ncompples", "numcompPS", "numcomppos", "numqups", "ncomponents", "numpropos", "numqupos", "nbcomples", "numprops", "nbcomPS", "ncomps"]}}
{"project": "qemu", "commit_id": "8ec14402029d783720f4312ed8a925548e1dad61", "target": 0, "func": "static int packet_enqueue(CompareState *s, int mode)\n\n{\n\n    ConnectionKey key;\n\n    Packet *pkt = NULL;\n\n    Connection *conn;\n\n\n\n    if (mode == PRIMARY_IN) {\n\n        pkt = packet_new(s->pri_rs.buf,\n\n                         s->pri_rs.packet_len,\n\n                         s->pri_rs.vnet_hdr_len);\n\n    } else {\n\n        pkt = packet_new(s->sec_rs.buf,\n\n                         s->sec_rs.packet_len,\n\n                         s->sec_rs.vnet_hdr_len);\n\n    }\n\n\n\n    if (parse_packet_early(pkt)) {\n\n        packet_destroy(pkt, NULL);\n\n        pkt = NULL;\n\n        return -1;\n\n    }\n\n    fill_connection_key(pkt, &key);\n\n\n\n    conn = connection_get(s->connection_track_table,\n\n                          &key,\n\n                          &s->conn_list);\n\n\n\n    if (!conn->processing) {\n\n        g_queue_push_tail(&s->conn_list, conn);\n\n        conn->processing = true;\n\n    }\n\n\n\n    if (mode == PRIMARY_IN) {\n\n        if (!colo_insert_packet(&conn->primary_list, pkt)) {\n\n            error_report(\"colo compare primary queue size too big,\"\n\n                         \"drop packet\");\n\n        }\n\n    } else {\n\n        if (!colo_insert_packet(&conn->secondary_list, pkt)) {\n\n            error_report(\"colo compare secondary queue size too big,\"\n\n                         \"drop packet\");\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4609, "substitutes": {"s": ["stat", "as", "o", "sets", "v", "is", "S", "a", "spec", "sg", "session", "socket", "si", "sync", "sys", "ses", "m", "services", "status", "its", "states", "in", "xs", "f", "ns", "d", "ls", "args", "service", "ss", "hs", "conf", "cs", "sis", "e", "u", "sb", "ops", "ks", "se", "gs", "ds", "qs", "t", "ts", "su", "self", "p", "south", "settings", "aws", "sv", "fs", "c", "os", "g", "ssl", "sq", "sym", "site", "syn", "es", "ps", "js"], "mode": [" modes", "MODE", "name", "gone", "dim", "dm", "ward", "md", "dd", "device", "Mode", " module", "style", "mo", "phase", "module", "ace", "mac", "de", "rage", "side", "grade", "state", "mod", "loop", "sid", "table", "cli", "code", "kind", "driver", "iden", "ode", "source", "ODE", "scale", "stage", "direction", "level", "range", "slave", "type", " m", "no", "lane", "role"], "key": ["name", "row", "er", "id", "fee", "x", " Key", "data", "pe", "info", "ace", "sk", "client", "order", "state", "j", "call", "keys", "service", "net", "match", "code", "e", "ck", "KEY", "error", "connection", "k", "cor", "ctx", "kid", "ey", "lock", "result", "ee", "ie", "kw", "ke", "ip", "type", "class", "Key", "link", "query", " connection", "group", "index", "seed"], "pkt": ["cpct", "payacket", "cpkt", "Pkt", "payet", " pet", "Pck", "ppk", "ppelt", "ppkt", "pct", " pwk", "Picket", "apet", "paracket", "pck", " pnt", "Pcht", "pwk", "payicket", "paykt", "ppnt", "Pk", "ppck", "ppacket", "pet", "ppet", "apkt", "Pnt", "apacket", "Packet", "ppwk", "Pelt", "apcht", "pcht", "parct", " pct", "cpet", " pck", "cpacket", "picket", "Pct", " pk", " picket", "pk", " pcht", "Pwk", "pnt", "packet", "parcht", "cpelt", "Pet", "parkt", "pelt", " packet"], "conn": ["cp", "rn", "gate", "ch", "act", "nw", "ann", "reg", "rt", "comm", "dn", "nt", "sg", "ci", "session", "wan", "po", "config", "nc", "sync", "oa", "enc", "cat", "ad", "co", "cm", "db", "ga", "client", "pg", "ns", "org", "pc", "ai", "connect", "cc", "conf", "cs", "con", "mc", "connection", "auth", "en", "dc", "cmd", "ctx", "n", "go", "oss", "Conn", "p", "ca", "ec", "c", "g", "ct", "cn", "core", "lc", "cf", "adj", "ac", "syn", "gn"]}}
{"project": "qemu", "commit_id": "70976a7926b42d87e0c575412b85a8f5c1e48fad", "target": 1, "func": "static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#ifdef WORDS_BIGENDIAN\n\n        env->avr[n].u64[0] = ldq_p(mem_buf);\n\n        env->avr[n].u64[1] = ldq_p(mem_buf+8);\n\n#else\n\n        env->avr[n].u64[1] = ldq_p(mem_buf);\n\n        env->avr[n].u64[0] = ldq_p(mem_buf+8);\n\n#endif\n\n        return 16;\n\n    }\n\n    if (n == 33) {\n\n        env->vscr = ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    if (n == 34) {\n\n        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25459, "substitutes": {"env": ["exec", " en", "txt", "NV", "her", "obj", "code", "console", "np", "er", "this", "scope", "exc", "app", "server", "engine", "ass", "context", "manager", "enable", "enc", "me", "data", "ec", "en", "config", "conf", "Environment", "export", "style", "global", "priv", "dict", "ev", "loader", "ea", "end", "environment", "proc", "self", "ne", "db", "buf", "e", "site", "el", "extra", "err", "cdn", "viron", "dev", "ctx", "eu", "eni", "cache", "erv", "external", "esp", "ext", "nw", "conn", "net", "core", "event", " environment", "nc", "que", "et", " environments", "eng"], "mem_buf": ["memalprim", "mem0buffer", "sm_raf", "mem_coord", "Mem_coord", "Mem_done", "sm_buf", "mem_bu", "memingbuf", "memalhor", "mem0hor", " mem_fd", "mem_prim", "mem_begin", "Mem_buf", "memingbuffer", "mem_fd", "sm_begin", "Mem_buffer", " mem_prim", "memmemvec", "mem_bag", "memmembuff", "mem_brace", "memalbuf", "mem_done", "mem_buffer", "mem_vec", "memmemdone", "Mem_brace", " mem_buff", "memmembuf", " mem_hor", "Mem_bu", "mem0prim", "sm_bu", "memalbuffer", "Mem_vec", "mem_raf", "Mem_buff", "mem_buff", "Mem_bag", "mem_hor", " mem_buffer", "memingfd", "mem0buf", "memingbuff"], "n": ["node", "np", "k", "w", "z", "i", "sn", "m", "b", "c", "name", "ns", "p", "d", "pn", "x", "or", "fn", "en", "no", "on", "nn", "config", " N", "num", "self", "ne", "u", "all", "nor", "e", "o", "s", "nb", "ni", "nt", "cn", "number", "N", "f", "y", "nr", "network", "j", "nw", "t", "un", "conn", "an", "net", "v", "nu", "r", "in", "nc", "l", "len", "nat"]}}
{"project": "qemu", "commit_id": "ad674e53b5cce265fadafbde2c6a4f190345cd00", "target": 0, "func": "static void conditional_branch(DBDMA_channel *ch)\n\n{\n\n    dbdma_cmd *current = &ch->current;\n\n    uint16_t br;\n\n    uint16_t sel_mask, sel_value;\n\n    uint32_t status;\n\n    int cond;\n\n\n\n    DBDMA_DPRINTF(\"conditional_branch\\n\");\n\n\n\n    /* check if we must branch */\n\n\n\n    br = le16_to_cpu(current->command) & BR_MASK;\n\n\n\n    switch(br) {\n\n    case BR_NEVER:  /* don't branch */\n\n        next(ch);\n\n        return;\n\n    case BR_ALWAYS: /* always branch */\n\n        branch(ch);\n\n        return;\n\n    }\n\n\n\n    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;\n\n\n\n    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;\n\n    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;\n\n\n\n    cond = (status & sel_mask) == (sel_value & sel_mask);\n\n\n\n    switch(br) {\n\n    case BR_IFSET:  /* branch if condition bit is 1 */\n\n        if (cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    case BR_IFCLR:  /* branch if condition bit is 0 */\n\n        if (!cond)\n\n            branch(ch);\n\n        else\n\n            next(ch);\n\n        return;\n\n    }\n\n}\n", "idx": 23816, "substitutes": {"ch": ["cha", "sch", "kick", "chn", "ph", "conn", "ach", "app", "err", "cor", "g", "chan", "ich", "chi", "Ch", "che", "cur", "cl", "cand", "ci", "exec", "cmd", "cp", "qu", "cht", "p", "CH", "enc", "chart", "code", "work", "q", "change", "or", "client", "c", "arch", "ctx", "cb", "sh", "form", "sc", "cho", "ic", "cy", "channel", "gr", "chip", "zh", "chron", "th", "gh", "history", "game", "http", "cher", "ce", "ech", "conf", "hw", "ck", "chrom", "bh", "command"], "current": ["recent", "target", "comment", "prev", "next", "conn", "config", "valid", "result", "com", "queue", "accept", "temp", "control", "local", "path", "cont", "cache", "compl", "component", "serial", "code", "open", "active", "client", "c", "ctx", "self", "complete", " cur", "content", "reported", "future", "form", "comp", "present", "now", "volt", "counter", "channel", "history", "running", "selected", "parent", "report", "currently", "stream", "image", "server", "command", "Current", "count"], "br": ["BR", "bc", "str", "handle", "serv", "bro", "fore", "err", "ref", "db", "ctr", "bal", "be", "fb", "queue", "cm", "tr", "bid", "bl", "bridge", "cl", "bre", "r", "cmd", "msg", "bug", "bg", "rel", "j", "arr", "p", "code", "buf", "dr", "rc", "header", "el", "fr", "ver", "hr", "b", "vr", "cr", "comm", "gr", "bm", "mr", "bh", "Br", "rb", "broad", "base"], "sel_mask": ["selgmatch", "sl_match", "sl_scale", "selgvalue", "sel2value", "sel_scale", "sel2mask", "sl_mode", "sl_sum", "sel_sum", "sl_shadow", "sl_count", "sl_mask", "sel___mask", "selalweight", "sel___sum", "selgcount", "sel___shadow", "sl_scan", "selalscan", "sel_count", "sel_scan", "sl_value", "sel_match", "selalvalue", "sel2mode", "sel_mode", "sl_weight", "sel_weight", "sel2scale", "selgmask", "sel_shadow", "sel___value", "selalmask"], "sel_value": ["sel___address", "sl_work", "selvalvalue", "hidevaladdress", "selfaddress", "hide_id", "sl_val", "sl_scale", "selvalinfo", "hide_value", "sel___info", "hidevalinfo", "selvaladdress", "sel___id", "sel_val", "sel_scale", "selvalwork", "selsvalue", "sel_id", "sl_mask", "selsmask", "hidevalvalue", "selfid", "sel_label", "selfinfo", "selsval", "selfvalue", "selsscale", "selvalmask", "sel_info", "hide_info", "hidevalid", "sl_value", "hide_address", "sl_label", "selvallabel", "selvalid", "sel_work", "sel_address", "sel___value"], "status": ["reg", "summary", "security", "connect", "serv", "STAT", "err", "nic", "result", "progress", "val", "shell", "uses", "style", "css", "flags", "cmp", "exec", "reason", "msg", "s", "fps", "stat", "state", "ssl", "score", "unit", "id", "code", "sync", "cli", "comment", "success", "stats", "rc", "complete", "spec", "speed", "service", "seq", "gc", "error", "comm", "rss", "wait", "st", "sp", "Status", "resp"], "cond": ["lc", "bc", "col", "reg", " condition", "fc", "cc", "connect", "rupt", "fail", "err", "ct", "ind", "thread", "part", " conf", " conditional", "crit", "func", "cl", "cas", "contin", "no", "cmp", "ci", "pos", "cont", "Cond", "reason", "cmd", "bit", "pre", "exec", "box", "stat", "act", "unit", "xc", "code", "count", "success", "close", "day", "cb", "c", "lic", "comp", "fl", "cr", "len", "loc", "co", "parent", "bf", "sec", "block", " cont", "resp", "condition"]}}
{"project": "qemu", "commit_id": "0ab07c623c629acfbc792e5a174129c19faefbb7", "target": 0, "func": "void qemu_cpu_kick(void *env)\n\n{\n\n    return;\n\n}\n", "idx": 1194, "substitutes": {"env": ["buffer", "ctx", "context", "device", "global", "environment", "nc", "scope", "buf", "param", "proc", "config", "ec", " environment", "h", "p", "dev", "e", "ptr", "eval", "core", "exec", "node", "en", "ev", "iv", "console", "port"]}}
{"project": "FFmpeg", "commit_id": "a28cccf6d62dc770757491510c248ed632a836ce", "target": 1, "func": "static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode)\n\n{\n\n    int   band, result=0, numSubbands, lastTonal, numBands;\n\n\n\n    if (codingMode == JOINT_STEREO && channelNum == 1) {\n\n        if (get_bits(gb,2) != 3) {\n\n            av_log(NULL,AV_LOG_ERROR,\"JS mono Sound Unit id != 3.\\n\");\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (get_bits(gb,6) != 0x28) {\n\n            av_log(NULL,AV_LOG_ERROR,\"Sound Unit id != 0x28.\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* number of coded QMF bands */\n\n    pSnd->bandsCoded = get_bits(gb,2);\n\n\n\n    result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded);\n\n    if (result) return result;\n\n\n\n    pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded);\n\n    if (pSnd->numComponents == -1) return -1;\n\n\n\n    numSubbands = decodeSpectrum (gb, pSnd->spectrum);\n\n\n\n    /* Merge the decoded spectrum and tonal components. */\n\n    lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components);\n\n\n\n\n\n    /* calculate number of used MLT/QMF bands according to the amount of coded spectral lines */\n\n    numBands = (subbandTab[numSubbands] - 1) >> 8;\n\n    if (lastTonal >= 0)\n\n        numBands = FFMAX((lastTonal + 256) >> 8, numBands);\n\n\n\n\n\n    /* Reconstruct time domain samples. */\n\n    for (band=0; band<4; band++) {\n\n        /* Perform the IMDCT step without overlapping. */\n\n        if (band <= numBands) {\n\n            IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCT_buf, band&1);\n\n        } else\n\n            memset(pSnd->IMDCT_buf, 0, 512 * sizeof(float));\n\n\n\n        /* gain compensation and overlapping */\n\n        gainCompensateAndOverlap (pSnd->IMDCT_buf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]),\n\n                                    &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]),\n\n                                    &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band]));\n\n    }\n\n\n\n    /* Swap the gain control buffers for the next frame. */\n\n    pSnd->gcBlkSwitch ^= 1;\n\n\n\n    return 0;\n\n}\n", "idx": 1404, "substitutes": {"q": ["Q", "ue", "quad", "kb", "qs", "queue", "hub", "ui", "buff", "query", "g", "m", "cgi", "dq", "w", "f", "conf", "sq", "question", "qa", "qi", "req", "qt", "quant", "qq", "gd", "qu", "rc"], "gb": ["rg", "cm", "gio", "ogg", "quad", "kb", "gram", "ga", "ges", "sb", "bm", "lb", "hub", "ui", "mb", "gy", "eb", "gru", "gnu", "pg", "bc", "buff", "gz", "ko", "GB", "gin", "g", "gg", "rb", "gm", "cb", "cgi", "storage", "gam", "gs", "bf", "hm", "cv", "nb", "ym", "wb", "agg", "bg", "bb", "pc", "b", "abb", "usb", "gal", "cfg", "gp", "gd", "db", "rc"], "pSnd": ["PAsck", "pESnw", "cpOsND", " pAsstd", " pAsnt", "pAsck", "PAsnt", "pClnd", " pSinf", "PAsND", "pPsvd", "pAsdk", "pNnn", " pAsgn", "PAsnn", "pEsnt", "pAsdn", "pOsnd", " pAsdc", "PSdk", " pSnt", "pAsign", " pAsnw", "pOsld", "pCND", "pOsND", " pSne", "pOSND", "PSsd", "PNND", "pSuind", "npSck", "pAsgn", "pGSgn", "pESnt", "pEsld", "pOsnt", "pAsstd", "PSng", " pSind", "pSyncdc", "pRSnd", "pHSnt", "pESND", "pSdat", "pSuck", "pNnt", "PSund", "PAssd", "pAsvd", "pAsnt", "PSnt", "pGSnd", "pResdk", "PAsdn", " pNnd", "pAssd", "pAsne", " pSvd", " pAsvd", "PSign", "pLSdn", "pInsinf", "pCnt", "pRSND", "pNND", "PAsng", "pEsND", "cpSnd", "pCnd", "pHSind", "pAsind", " pNck", "pSnn", "pHSnn", "pShND", "pOSnn", "pLSnd", " pAsne", "pAsdat", "pNck", " pAsND", "pIsund", "PSnn", "pHSdn", "pCld", "pNnd", "PSdn", " pAsdn", " pSgn", "pSund", " pAsld", " pSnn", "pInsnd", "pNld", "npHSck", "pIsstd", "npHSND", "cpOsld", "pGSnn", "pRSstd", "pIsND", "pHSND", "cpOsnd", "psign", "PSND", " pAsdat", "pIsld", "pIsnd", "pGSnt", "PAsund", "PAsdk", "pWSng", "pSdn", "pAsinf", "pAsnn", "pSind", "npSND", "pAsund", "pEsnd", "pWSnd", "pShind", "psck", "psnd", "pSstd", "pSyncnd", "pESnd", "pHSck", "pAsdc", "npHSnd", "pSinf", "pSND", "pSsd", "pNind", "PSnd", " pSdc", " pSnw", " pAsnd", "pLSsd", "pSng", "pResnd", "PAsld", "pIsind", "pShdn", "cpSND", "pGSdn", "pSgn", "pGSne", " pSdat", "pSdc", "PNnt", "pSnw", "pSyncne", "pSdk", "npHSind", "pRSind", "pEsund", "npSnd", "pResnt", "pOSnd", " pSND", "pShnt", "pSck", "pSld", "pAsnw", " pAsnn", " pSld", "pEsdat", "pPsgn", "pGSvd", "PNck", "pClld", "pSvd", "pHSnd", " pAsind", "cpOsnt", "pGSdc", "pAsND", "pSne", "pSyncnt", " pSck", "pSnt", "pInsND", "pAsld", "cpSnt", "pResng", "PAsnd", "PSck", "pCldat", "pClnt", "pNnw", "pPsnd", "pSign", "psND", " pNND", " pSdn", "pWSnt", "pAsng", "pPsnt", "pOSld", "PNnd", " pSstd", "pLSND", "pAsnd", "pHSsd", " pNinf", "pWSck", "pInsck", "cpSld", "PSld", "pSunt", "npSind", "pNinf", "pShnd"], "pOut": [" pArray", "POutput", "PIn", "fpArray", "POut", "PArray", "pOutput", "pout", "pArray", "npIn", "npOutput", " pout", "fpIn", "npout", "Pout", " pIn", "fpout", "npOut", "fpOut", "pIn", " pOutput"], "channelNum": ["channelLen", "pageNum", "ChannelLen", "componentNumber", "pageNumber", "componentnum", "pagenum", "ChannelNum", "Channelnum", " channelNumber", "channelNumber", "channelnum", "ChannelNumber", " channelLen", "pageLen", " channelnum", "componentNum", "componentLen"], "codingMode": ["codemode", "coderMode", "codermode", "cachingType", "codedMode", "lcodeMode", "castingmode", "cachingMODE", "lcodingmode", "codedType", "lcodeMODE", "codedMODE", "codeMode", "encodingMODE", "encodingmode", "codingmode", "lcodemode", "cachingmode", "coderMODE", "encodeType", "codingType", "lcodingMODE", "codeMODE", "cachingMode", "encodingType", "codedmode", "castingMode", "codeType", "castingMODE", "encodeMODE", "encodingMode", "codingMODE", "encodemode", "encodeMode", "lcodingMode"], "band": ["key", "device", "current", "ver", "weight", "field", "code", "direction", "track", "cell", "kg", "board", "bands", "unit", "flow", "group", "bind", "tag", "song", "type", "position", "gap", "batch", "pass", "off", "component", "step", "length", "patch", "amp", "plugin", "leg", "count", "layer", "cm", "piece", "version", "offset", "channel", "byte", "data", "page", "frequency", "boot", "loop", "filter", "back", "function", "result", "ground", "phase", "card", "bb", "kat", "low", "mode", "stage", "match", "Band", "level", "bit", "broad", "d", "ord", "number", "bug", "feature", "word", "bound", "range", "point", "plane", "product", "line", "part", "day", "db"], "numSubbands": ["sumSubband", "numBbands", "numSubtracks", " numPerbands", "nSuperlines", " numPerplanes", "numsublines", " numSubcats", "sumSubtracks", "numSublines", " numSubgroups", "sumSubplanes", "numPergroups", "numSubband", "sumsubtracks", " numPercats", "numMicrobands", "numSubgroups", "numBbits", "numsubbands", "numPerbands", "numShortbands", " numSubplanes", "nSublines", "nSubbits", "numMicroplanes", "nSupergroups", "numPerplanes", "sumsubband", "nSuperbits", "numBlines", "nSubgroups", "numShorttracks", "numsubcats", "numSubbits", "numsubtracks", "numsubbits", "numBgroups", "numSuperbands", "numsubplanes", "numSubcats", "numSuperbits", "numPercats", "numsubgroups", "numMicrocats", "numShortplanes", "numsubband", "numSupergroups", "numSubplanes", "nSubbands", "sumsubplanes", "numShortband", "numSuperlines", "numMicrogroups", "sumSubbands", "sumsubbands", " numPergroups", "nSuperbands"], "lastTonal": [" lastTone", "lastForal", "lastCronic", "lastFronic", "lasttonic", " lastBonic", "lastNotonal", "lastToral", " lastFooting", "lastTahn", "lastThon", "lastFooting", "lastFahn", "LastTon", "lastXTahn", "lastXTonic", "lasttooting", " lastToned", "LastThoral", "lasttonal", "lastTone", "lastBonal", "lastConed", "lastTonic", " lastTonic", "lastBone", " lastFonal", " lastTahn", "lastTronic", " lastTronic", "lastXTronic", "LastThonal", " lastFahn", "lastTooting", " lastBronic", " lastFonic", "lastBahn", "lastThoral", "lastBoned", "lasttone", "lastConal", " lastTooting", "lastConic", "lastNoton", " lastFronic", "lastFonic", "LastThoned", "lastNotoral", "lastNotoned", "lastFoned", "lastBooting", "LastTonal", "LastThon", "LastToned", "lastThoned", "lastTon", "LastToral", "lastBonic", "lastBronic", "lastToned", "lastThonal", "lastXTonal", "lastFone", " lastBonal", " lastBoned", " lastFone", "lastFonal", "lastFon"], "numBands": ["sumBands", "sumbannels", "numChands", "sumBounds", " numBards", "numBans", "sumWands", "numBayers", "numbounds", "umBards", " numBannels", "sumBbands", "numRands", "NUMBans", "numWounds", "numbands", "numBsbands", " numBsands", "numWans", "numChbands", "sumbbands", "numBbands", "numDands", "numDannels", "numPlannels", "numChayers", "NUMBayers", "numBsays", "numCans", "numbbands", "numDayers", "numbacks", "numBounds", "numPlards", "numBacks", "numBsands", "numBays", "numCands", "sumBacks", "numPounds", "NUMDans", "NUMBannels", "numBsounds", "numCannels", "numRards", "sumWacks", "numBsards", "numDans", "sumWounds", "numWands", "sumbands", "numRbands", "umBands", "numPans", "numRannels", " numBsards", "umBsards", "numPacks", "numBannels", "NUMDands", "umBsbands", "numChans", "numChannels", "numBsannels", "NUMBands", "numCayers", "numWacks", "numbays", "sumBannels", " numBays", "numChounds", "umBbands", "NUMDayers", "numPlands", "umBsands", "numPlays", "numbannels", "NUMDannels", " numBsannels", "sumBans", "numPands", "umBsannels", "numbards", "sumWans", "sumbounds", " numBsays", "umBannels", "numbans", "numBards"]}}
{"project": "FFmpeg", "commit_id": "5ecabd3c54b7c802522dc338838c9a4c2dc42948", "target": 1, "func": "static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,\n\n                             GetByteContext *gb)\n\n{\n\n    unsigned char rle_code;\n\n    unsigned char extra_byte, odd_pixel;\n\n    unsigned char stream_byte;\n\n    unsigned int pixel_ptr = 0;\n\n    int row_dec = pic->linesize[0];\n\n    int row_ptr = (avctx->height - 1) * row_dec;\n\n    int frame_size = row_dec * avctx->height;\n\n    int i;\n\n\n\n    while (row_ptr >= 0) {\n\n        if (bytestream2_get_bytes_left(gb) <= 0) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"MS RLE: bytestream overrun, %d rows left\\n\",\n\n                   row_ptr);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        rle_code = stream_byte = bytestream2_get_byteu(gb);\n\n        if (rle_code == 0) {\n\n            /* fetch the next byte to see how to handle escape code */\n\n            stream_byte = bytestream2_get_byte(gb);\n\n            if (stream_byte == 0) {\n\n                /* line is done, goto the next one */\n\n                row_ptr -= row_dec;\n\n                pixel_ptr = 0;\n\n            } else if (stream_byte == 1) {\n\n                /* decode is done */\n\n                return 0;\n\n            } else if (stream_byte == 2) {\n\n                /* reposition frame decode coordinates */\n\n                stream_byte = bytestream2_get_byte(gb);\n\n                pixel_ptr += stream_byte;\n\n                stream_byte = bytestream2_get_byte(gb);\n\n                row_ptr -= stream_byte * row_dec;\n\n            } else {\n\n                // copy pixels from encoded stream\n\n                odd_pixel =  stream_byte & 1;\n\n                rle_code = (stream_byte + 1) / 2;\n\n                extra_byte = rle_code & 0x01;\n\n                if (row_ptr + pixel_ptr + stream_byte > frame_size ||\n\n                    bytestream2_get_bytes_left(gb) < rle_code) {\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"MS RLE: frame/stream ptr just went out of bounds (copy)\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                for (i = 0; i < rle_code; i++) {\n\n                    if (pixel_ptr >= avctx->width)\n\n                        break;\n\n                    stream_byte = bytestream2_get_byteu(gb);\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n\n                    pixel_ptr++;\n\n                    if (i + 1 == rle_code && odd_pixel)\n\n                        break;\n\n                    if (pixel_ptr >= avctx->width)\n\n                        break;\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n\n                    pixel_ptr++;\n\n                }\n\n\n\n                // if the RLE code is odd, skip a byte in the stream\n\n                if (extra_byte)\n\n                    bytestream2_skip(gb, 1);\n\n            }\n\n        } else {\n\n            // decode a run of data\n\n            if (row_ptr + pixel_ptr + stream_byte > frame_size) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"MS RLE: frame ptr just went out of bounds (run)\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            stream_byte = bytestream2_get_byte(gb);\n\n            for (i = 0; i < rle_code; i++) {\n\n                if (pixel_ptr >= avctx->width)\n\n                    break;\n\n                if ((i & 1) == 0)\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n\n                else\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n\n                pixel_ptr++;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* one last sanity check on the way out */\n\n    if (bytestream2_get_bytes_left(gb)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"MS RLE: ended frame decode with %d bytes left over\\n\",\n\n               bytestream2_get_bytes_left(gb));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12940, "substitutes": {"avctx": ["AVconfig", "afconn", "avscope", "AVpc", "abcontext", "evctx", "AVcmp", "ablc", " avscope", " avcf", "ajcontext", "avcmp", "avlc", "abctx", "abcmp", "avescope", "avcf", " avconfig", "avcit", "AVcontext", "aflc", "ajpc", "avectx", "AVcci", "evconn", "afcmp", "AVconn", "AVlc", "AVcf", "afconfig", "AVscope", "ajctx", " avcmp", "afcontext", "ajcit", "AVcit", " avcontext", "evcontext", "avcontext", "avecf", "abpc", "evlc", "avconn", "ajcmp", "afctx", "avpc", "afcci", "avcci", "AVctx", "avecontext", " avcci", "avconfig", " avcit"], "pic": ["proc", "typ", "mc", "cam", "bc", "sync", "rc", "xi", "pc", "pins", "cdn", "gc", "lc", "ctrl", "image", "Pic", "bus", "conn", "lib", "quad", "parse", "oc", "doc", "img", "fi", "sec", "cli", "picture", "cus", "spec", "pict", "pin", "jc", "ac", "pi", "sci", "mag", "ic", "coll", "bi", "gui", "vc", "mac", "cycle", "inch", "fc", "cci", "ctx"], "gb": ["bridge", "ui", "gz", "cam", "bc", "pc", "bb", "gio", "gc", "ub", "g", "hub", "rg", "nb", "gy", "gin", "gnu", "cgi", "gru", "mb", "storage", "gd", "gm", "gg", "bm", "rb", "sb", "usb", "jpg", "bf", "gs", "cfg", "greg", "agi", "gam", "vg", "gram", "cb", "bg", "eb", "abb", "kb", "db", "GB", "gui", "ga", "src", "gal", "gp"], "rle_code": ["rseOpbyte", "rle8count", "rseOpcode", "rLE_module", "rleOpbyte", "rse_value", "rle_Code", "rle_byte", "rle__codes", "rle__code", "rle8number", "rLE_name", "rLE_code", "rle_name", "rle_cod", "rle64code", "rleOpcode", "rLE_Code", "rle__const", "rLE_const", "rlembyte", "rle64number", "rle64call", "rLE_call", "rlemconst", "rle9name", "rle9count", "rle8code", "rle_codes", "rlemcode", "rse_code", "rle_call", "rle64Code", "rLE_number", "rle__byte", "rLE_count", "rLE_byte", "rle_const", "rle8name", "rle_value", "rle_module", "rle9code", "rle__Code", "rse_byte", "rle9number", "rleOpvalue", "rle__cod", "rLE_cod", "rle_number", "rle_count", "rseOpvalue"], "extra_byte": ["extra67byte", "extra67message", "random_value", "extra___character", "stream_bit", "extra___byte", "random_byte", "extra___message", "extra___value", "extra_bit", "extra_message", "random_message", "random___value", "stream_character", "extra67bit", "extra___bit", "random___byte", "stream_layer", "extra_value", "random___message", "extra___layer", "extra_layer", "random___bit", "extra67value", "random_bit", "extra_character"], "odd_pixel": ["odd\u00b7pin", " oddxpixel", "auto_byte", "auto_character", "oddvelpixel", "oddxpin", "oddencharacter", " odd_byte", "auto_hole", "oddenhole", "odd_byte", "odd\u00b7byte", "oddvelbyte", " odd_pin", "oddvelcharacter", "odd\u00b7color", "auto_pixel", " oddxpin", "odd_character", "odd\u00b7pixel", "odd_hole", "oddxcolor", " oddxcolor", "odd_pin", " oddxbyte", "oddvelhole", " odd_color", "oddxbyte", "oddenbyte", "oddxpixel", "oddenpixel", "odd_color"], "stream_byte": [" stream_channel", "roll_byte", "console_byte", "console_outine", "stream_type", "rollMchannel", "filter_layer", "streamJblock", "drawdcode", "model_route", "stream_Byte", "stream67position", "draw_bytes", "streamStoken", "stream_size", "streamMnode", "reader_byte", "streamdbytes", "stream_source", "stream_full", "streamCblock", "stream_bin", "streamablechannel", "stream67job", "sslflowchannel", "drawdbyte", "filterolayer", "streamablebinary", "streamaccode", "draw_unit", " stream_bytes", "header_byte", "header_position", "roll_rule", "stream___block", "readerJphase", "filterSfee", "streamdunit", "readerJbyte", "stream___byte", "streamedoutine", "streamJphase", "rollMbyte", "stream_phase", "stream_unit", "streamflowbyte", "streamflowconnection", "streamdbyte", "stream_page", "streamingbytes", "header_token", "streamablebyte", "streamingblock", "stream_binary", "stream67byte", "streamPcode", "stream_outine", "draw_code", "stream_block", "sslflowconnection", "streamedByte", "stream_note", "stream67value", "stream_function", "filterobin", "roll_channel", "streamacfee", "streamMsource", "streamdcode", "stream___job", "streamJjob", "stream_job", "filter_bin", "streamJval", "model_byte", "stream_layer", "reader_reference", "streamJreference", "filter_token", "stream_connection", "streamMphase", "feed___full", "sslflowbyte", "stream_level", "readerJreference", "filterosecond", "streamedlevel", "streamedbyte", " stream_size", "drawdbytes", "model_node", "streamCreference", "streamMrule", "filterSbyte", "video_node", "streamPtoken", "stream_value", "streamJbyte", "streamallbyte", "feed_full", "streamallnode", "streamMbyte", " stream_binary", "stream_rule", "streamScode", "feed_val", "streamflowoutine", " stream_Byte", "filterobyte", "streammbyte", "video_source", "streamactoken", "feed_byte", "streammsize", "stream67full", "streamMreference", "rollMtoken", "feed___val", "stream_fee", "feed___byte", "console_level", "streamMblock", "video_type", "stream_bytes", "drawdunit", "streamobyte", "filter_fee", "streamingbyte", "streamPposition", " stream_job", "model_function", "stream67token", "streamingchannel", "video_byte", "stream_second", "streamflowchannel", "streammcode", "streamPnote", "streamallsource", "streamSbyte", "reader_block", "streammByte", "streamacbyte", "stream_code", "reader_note", "feed___job", "stream_node", "ssl_connection", "streamolayer", "streamJfull", "streamJfee", "streamalltype", "stream_route", "streamPbyte", "streamPvalue", "ssl_outine", "filter_byte", "console_Byte", "filterScode", "streamobin", "streamSfee", "reader_page", "readerJblock", " stream_block", "feed_job", "streamJtoken", "stream_val", "header_value", "streamPpage", "stream_channel", "streamCbyte", "streamJcode", "roll_token", "ssl_byte", "ssl_channel", " stream_code", "stream67val", "sslflowoutine", "reader_code", "stream___channel", "streamablejob", "streamCphase", "filterStoken", "stream___val", "stream_position", "stream_reference", "streamMtoken", "filter_second", "filter_code", "draw_byte", "stream___bytes", "stream___full", "streamMtype", "streamMchannel", "streamosecond", "reader_phase", "stream_token", "rollMrule"], "i": ["hi", "qi", "it", "ui", "I", "d", "t", "ni", "ai", "xi", "id", "iu", "split", "gi", "code", "ini", "l", "io", "ci", "ki", "di", "x", "si", "ie", "ii", "uri", "v", "yi", "u", "ind", "p", "e", "mini", "fi", "cli", "li", "page", "k", "ix", "multi", "j", "count", "phi", "b", "n", "ti", "ski", "f", "ip", "c", "eni", "ji", "pi", "chi", "bi", "ri", "zi", "in", "index", "start"], "pixel_ptr": ["row_wr", " pixel_cro", "row_addr", "cpuIdpair", "pixelPoaddr", "pixel_pos", "row_ptr", "pixelaldim", "pixelIdref", "cpuIdptr", "pixelitypair", "pixelityptr", "pixelPowr", "pixelIdptr", "pixelityref", " pixel_addr", "pixelxptr", "pixelalptr", "pixelxpointers", "cpuIdref", "pixelitycro", "pixelalpointer", "row_dim", "row_inter", "pixelacref", "pixel_proc", "pixel_dim", "pixelPopointer", " pixel_pointers", "pixelitydegree", "pixelPpointer", "pixel_inter", "pixelPoptr", "row_proc", "pixel_ref", "pixelacptr", "pixelIddegree", "pixelxpointer", "pixelPdim", "pixelalinter", "cpuIddegree", "pixelPptr", "pixel_wr", "pixel_pointers", " pixel_pointer", " pixel_slice", "pixelitypointer", "pixel_slice", "pixel_pointer", "pixel_cro", "cpu_degree", "pixelacdegree", "cpu_ref", "pixel_addr", "pixel_degree", "pixelacpair", "pixelPinter", "cpu_pair", "pixelxdegree", "pixel_pair", "cpu_ptr", "row_pointer", "row_pos", "pixelityaddr", "pixelIdpair", " pixel_degree"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_srlq(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    TCGv t0 = tcg_temp_local_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    TCGv t2 = tcg_temp_local_new();\n\n    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);\n\n    tcg_gen_movi_tl(t1, 0xFFFFFFFF);\n\n    tcg_gen_shr_tl(t2, t1, t2);\n\n    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);\n\n    gen_load_spr(t0, SPR_MQ);\n\n    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_and_tl(t0, t0, t2);\n\n    gen_load_spr(t1, SPR_MQ);\n\n    tcg_gen_andc_tl(t1, t1, t2);\n\n    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);\n\n    gen_set_label(l2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 5219, "substitutes": {"ctx": ["cp", "cmp", "cfg", "anc", "hw", "pai", "ci", "gru", "component", "config", "qt", "cus", "rc", "cca", "sync", "sys", "concept", "loc", "cm", "tx", "client", "conv", "JC", "cc", "cli", "cs", "sci", "crit", "kt", "np", "ck", "sc", "mc", "que", "connection", "cam", "cmd", "bc", "cb", "cu", "Context", "cms", "exec", "context", "input", "ctrl", "ca", "qa", "cpu", "kb", "utils", "c", "txt", "cn", "cf", "chan", "cv", "vc", " cx", "git", "src", "cpp", "cas", "conn", "pkg", "tc"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)\n\n{\n\n    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);\n\n}\n", "idx": 15492, "substitutes": {"env": ["args", "en", "context", "enh", "esp", "enc", "ea", "cv", "config", "iss", "code", "priv", "eu", "iv", "style", "er", "vm", "scope", "v", "conf", "nw", "conn", "np", "impl", "loader", "e", "enable", "viron", "exc", "vs", "state", "eni", "cb", "ov", "uv", "que", "ev", "ec", "environment", "core", "ef", "ctx", "esm", "err"], "m": ["mc", "cm", "d", "l", "i", "fm", "g", "h", "x", "module", "vm", "machine", "v", "tm", "mx", "o", "ms", "gm", "p", "e", "bm", "mi", "k", "mobile", "b", "n", "f", "hm", "address", "am", "c", "M", "md", "man", "dm", "sm"]}}
{"project": "qemu", "commit_id": "d7651f150d61936344c4fab45eaeb0716c606af2", "target": 0, "func": "static bool migrate_caps_check(bool *cap_list,\n\n                               MigrationCapabilityStatusList *params,\n\n                               Error **errp)\n\n{\n\n    MigrationCapabilityStatusList *cap;\n\n    bool old_postcopy_cap;\n\n\n\n    old_postcopy_cap = cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM];\n\n\n\n    for (cap = params; cap; cap = cap->next) {\n\n        cap_list[cap->value->capability] = cap->value->state;\n\n    }\n\n\n\n#ifndef CONFIG_LIVE_BLOCK_MIGRATION\n\n    if (cap_list[MIGRATION_CAPABILITY_BLOCK]) {\n\n        error_setg(errp, \"QEMU compiled without old-style (blk/-b, inc/-i) \"\n\n                   \"block migration\");\n\n        error_append_hint(errp, \"Use drive_mirror+NBD instead.\\n\");\n\n        return false;\n\n    }\n\n#endif\n\n\n\n    if (cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]) {\n\n        if (cap_list[MIGRATION_CAPABILITY_COMPRESS]) {\n\n            /* The decompression threads asynchronously write into RAM\n\n             * rather than use the atomic copies needed to avoid\n\n             * userfaulting.  It should be possible to fix the decompression\n\n             * threads for compatibility in future.\n\n             */\n\n            error_setg(errp, \"Postcopy is not currently compatible \"\n\n                       \"with compression\");\n\n            return false;\n\n        }\n\n\n\n        /* This check is reasonably expensive, so only when it's being\n\n         * set the first time, also it's only the destination that needs\n\n         * special support.\n\n         */\n\n        if (!old_postcopy_cap && runstate_check(RUN_STATE_INMIGRATE) &&\n\n            !postcopy_ram_supported_by_host()) {\n\n            /* postcopy_ram_supported_by_host will have emitted a more\n\n             * detailed message\n\n             */\n\n            error_setg(errp, \"Postcopy is not supported\");\n\n            return false;\n\n        }\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 12470, "substitutes": {"cap_list": ["cl_set", "CAP_list", "capFtable", "capFlist", "cap_info", "CAP_base", "cap_map", "cp_type", "cap_listed", "cap_base", "apeFtable", "capFlists", "cap_lists", "CAP_map", "cp_cache", "cl_list", "apeFedit", "cap_edit", "cap_type", "cap_def", "caps_list", "cap_set", "capsmap", "cp_info", "caps_set", "capFedit", "cap_note", "cap_cache", "capslists", "CAP_note", "cap_LIST", "capslist", "cl_listed", "ape_lists", "cp_list", "caps_table", "cl_LIST", "ape_edit", "cap_table", "capsset", "ape_list", "apeFlists", "CAP_lists", "ape_table", "CAP_set", "caps_def", "apeFlist"], "params": ["types", "args", "proc", "camp", "mc", "array", "tmp", "ram", "config", "rs", "shape", "changes", "pre", "api", "caps", "cs", "sp", "cms", "cmp", "ps", "conf", "instance", "options", "plugins", "cli", "eps", "comp", "acl", "json", "spec", "ip", "par", "ams", "cas", "param", "mac", "ips", "copy", "opt", "ctx"], "errp": [" errr", "serr", " errf", " errps", "serpr", " errpe", "erfp", "errf", "cerp", " errsp", "errpr", "errr", "resultfp", "resultpr", "errpe", " errcp", "errsp", "erpr", "resultps", "terr", "errfp", "terp", "derp", "verpe", "derpe", "errps", "cerps", " errfp", " errpr", "erp", "cersp", "resultp", "Err", "derpc", "verfp", "resultr", "resultsp", "verp", "Erp", "errpc", " errpc", "errcp", "verpc", "Erpr", "erf", "erps", "derfp", "terps", "sercp", "terf", "Ercp", "serp", "err"], "cap": ["plug", "card", "call", "ch", "cm", "bc", "capt", "ca", "cop", "config", "pc", "mp", "pac", "jp", "account", "caps", "ctrl", "gap", "sp", "act", "cmp", "ace", "ap", "crop", "ct", "app", "cr", "av", "clip", "an", "p", "pack", "pl", "CAP", "can", "fab", "cut", "op", "rap", "acl", "ape", "spec", "c", "ip", "block", "ab", "cat", "crit", "ac", "sc", "ce", "sv", "cf", "cod", "ep", "Cap", "cp", "com", "exec", "lex", "mac", "tool", "fac", "span", "cl"], "old_postcopy_cap": ["old_postcopy_CAP", "old_postcopy_mac", "old_postcopy__ap", "old_posttransfer_cp", "old_postshare__caps", "old_postshare__ap", "old_postshare__CAP", "old_postcopy__CAP", "old_postcopy_cp", "old_postshare__cap", "old_posttransfer_CAP", "old_postcopy__caps", "old_postcopy_caps", "old_postshare_caps", "old_posttransfer_ap", "old_postcopy_ap", "old_posttransfer_mac", "old_postshare_ap", "old_posttransfer_cap", "old_postshare_cap", "old_postshare_CAP", "old_postcopy__cap"]}}
{"project": "qemu", "commit_id": "9bbd4843c052a0a467c7a3363046b0c95c0e5fc0", "target": 1, "func": "gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,\n\n             uint32_t up_shift, CPUTriCoreState *env)\n\n{\n\n    TCGv temp = tcg_temp_new();\n\n    TCGv temp2 = tcg_temp_new();\n\n    TCGv temp3 = tcg_temp_new();\n\n    TCGv_i64 t1 = tcg_temp_new_i64();\n\n    TCGv_i64 t2 = tcg_temp_new_i64();\n\n    TCGv_i64 t3 = tcg_temp_new_i64();\n\n    TCGv_i64 t4 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_ext_i32_i64(t2, arg2);\n\n    tcg_gen_ext_i32_i64(t3, arg3);\n\n\n\n    tcg_gen_mul_i64(t2, t2, t3);\n\n\n\n    tcg_gen_ext_i32_i64(t1, arg1);\n\n    /* if we shift part of the fraction out, we need to round up */\n\n    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);\n\n    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);\n\n    tcg_gen_sari_i64(t2, t2, up_shift - n);\n\n    tcg_gen_add_i64(t2, t2, t4);\n\n\n\n    tcg_gen_sub_i64(t3, t1, t2);\n\n    tcg_gen_trunc_i64_i32(temp3, t3);\n\n    /* calc v bit */\n\n    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);\n\n    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);\n\n    tcg_gen_or_i64(t1, t1, t2);\n\n    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);\n\n    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);\n\n    /* We produce an overflow on the host if the mul before was\n\n       (0x80000000 * 0x80000000) << 1). If this is the\n\n       case, we negate the ovf. */\n\n    if (n == 1) {\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);\n\n        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);\n\n        tcg_gen_and_tl(temp, temp, temp2);\n\n        tcg_gen_shli_tl(temp, temp, 31);\n\n        /* negate v bit, if special condition */\n\n        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);\n\n    }\n\n    /* Calc SV bit */\n\n    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);\n\n    /* Calc AV/SAV bits */\n\n    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);\n\n    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);\n\n    /* calc SAV */\n\n    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);\n\n    /* write back result */\n\n    tcg_gen_mov_tl(ret, temp3);\n\n\n\n    tcg_temp_free(temp);\n\n    tcg_temp_free(temp2);\n\n    tcg_temp_free(temp3);\n\n    tcg_temp_free_i64(t1);\n\n    tcg_temp_free_i64(t2);\n\n    tcg_temp_free_i64(t3);\n\n    tcg_temp_free_i64(t4);\n\n}\n", "idx": 22058, "substitutes": {"ret": ["reg", "expr", "wrapper", "result", "ctr", "tr", "prep", "Ret", "buffer", "fit", "model", "path", "final", "cache", "prefix", "active", "ctx", "aux", "seq", "test", "iter", "req", "alt", "template", "output"], "TCGv": ["TCGlvv", "OCGuvv", "TCGuvr", "TCGvr", "TCGlf", "PGGMv", "TCCGv", "PCgvs", "TCgver", "PCGvan", "TCGenerv", "PCgv", "TCGarf", "TCgvv", "TCGsV", "PGGMV", "TCGMvm", "TCMGvv", "TCGroupvc", "TCGenevv", "TCGWf", "TCMGver", "TCGarv", "TCGroupev", "TCGlvan", "TCGef", "PCGvs", "TCGenevan", "TCGuvv", "PGGMvr", "TCGvan", "TCGMv", "TCGatep", "OCGuver", "PCGcv", "TCGenef", "PCgvc", "TCGenervc", "OCGuvr", "TCGsv", "TCGsvr", "TCGatev", "TCGeneralvc", "TCGvm", "TCgvan", "PGGMvm", "OCGv", "PCGp", "TCgev", "TCGarev", "PCgvan", "TCGvv", "PGGvm", "TCGarvs", "TCgf", "PCgev", "TCGsvm", "TCGWev", "PCgcv", "OCGvr", "TCgvr", "PGGV", "TCGWvc", "TCgvs", "TCGV", "TCGev", "TCGenerf", "TCGeneralf", "PGGvr", "OCGver", "TCGver", "TCGeneralvs", "PCGvc", "TCCGvm", "TCGep", "TCGWvs", "PCgvv", "PGGv", "TCCGV", "TCGcv", "TCGlv", "TCGMV", "PCGf", "TCMGv", "TCGuver", "OCGvv", "OCGuv", "TCgvc", "TCGatecv", "PCgp", "TCGenev", "TCGf", "PCGvv", "TCgp", "TCgcv", "PCGv", "TCGWv", "TCMGvr", "TCGeneralv", "TCGecv", "PCgf", "TCGroupv", "TCGuv", "PCGev", "TCGp", "TCGvc", "TCGvs", "TCGenervs", "TCCGvr", "TCGatef", "TCGMvr", "TCGroupf", "TCgv"], "uint32_t": ["uint32_n", "uint8_f", "uint32_int", "uint8_t", "uint16_n", "uint16_T", "uint8_T", "uint32_f", "uint32_T", "uint32_p", "uint16_p", "uint16_t", "uint8_int"]}}
{"project": "qemu", "commit_id": "e1f7b4812eab992de46c98b3726745afb042a7f0", "target": 0, "func": "static size_t get_request_size(VirtQueue *vq)\n\n{\n\n    unsigned int in, out;\n\n\n\n    virtqueue_get_avail_bytes(vq, &in, &out);\n\n    return in;\n\n}\n", "idx": 25578, "substitutes": {"vq": [" vqs", "svqs", "vQ", "vux", "ivck", "sviq", "svQ", "svq", "gQ", "vque", "svux", "Vck", "svck", "ivq", "Vq", " vque", "gque", "iviq", "gqs", "vck", "gq", "viq", " vQ", "svque", "vqs", "Viq", "Vux", "ivux"], "in": ["login", "IN", "din", "margin", "byte", "bin", "i", "b", "m", "c", "name", "d", "gin", "In", "inas", "qa", "data", "kin", "read", "again", "rin", "diff", "ax", "ins", "pass", "Out", "pc", "id", "rec", "raw", "max", "input", "min", "str", "ini", "nin", "pin", "new", "inc", "inn", "isin", "len", "win", "arg", "f", "n", "index", "ex", "ac", "val"], "out": ["IN", "OUT", "call", "token", "bin", "gin", "In", "qa", "doc", "no", "again", "diff", "ax", "Out", "outs", "ins", " Out", "id", "wx", "o", "arr", "cmd", "outer", "str", "nin", "nt", "new", "inc", "isin", "off", "ext", "index", "net", "init", "ex", "gt"]}}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_current_dir(FTPContext *s)\n\n{\n\n    char *res = NULL, *start = NULL, *end = NULL;\n\n    int i;\n\n    const char *command = \"PWD\\r\\n\";\n\n    const int pwd_codes[] = {257, 0};\n\n\n\n    if (!ftp_send_command(s, command, pwd_codes, &res))\n\n        goto fail;\n\n\n\n    for (i = 0; res[i]; ++i) {\n\n        if (res[i] == '\"') {\n\n            if (!start) {\n\n                start = res + i + 1;\n\n                continue;\n\n            }\n\n            end = res + i;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (!end)\n\n        goto fail;\n\n\n\n    if (end > res && end[-1] == '/') {\n\n        end[-1] = '\\0';\n\n    } else\n\n        *end = '\\0';\n\n    av_strlcpy(s->path, start, sizeof(s->path));\n\n\n\n    av_free(res);\n\n    return 0;\n\n\n\n  fail:\n\n    av_free(res);\n\n    return AVERROR(EIO);\n\n}\n", "idx": 15401, "substitutes": {"s": ["secondary", "south", "ses", "m", "service", "t", "d", "sync", "fs", "your", "rs", "sym", "a", "g", "cs", "sites", "S", "new", "sets", "opens", "es", "js", "sq", "session", "server", "ps", "ss", "conf", "o", "p", "e", "socket", "http", "sb", "b", "sf", "data", "f", "gs", "c", "ns", "is", "ssl", "ops", "r", "ds", "services", "ts", "us", "ssh", "aws"], "res": ["ons", "args", "rez", "remote", "ret", "rss", "blocks", "rev", "root", "reply", "Res", "rus", "response", "gr", "rc", "enc", "complete", "rs", "pre", "range", "row", "cs", "details", "req", "nos", "os", "opens", "es", "ros", "RES", "rows", "pres", "ras", "error", "rh", "ps", "request", "ids", "ms", "params", "rec", "ris", "resource", "ver", "rx", "ries", "lines", "result", "resolution", "des", "reset", "arr", "results", "re", "resp", "r", "rep", "ress", "ri", "rest", "reg", "rem", "prev", "RE", "vals", "err"], "start": ["part", "art", "id", "mid", "ish", "style", "pre", "range", "name", "sp", "send", "use", "x", "init", "ie", "Start", "starting", "error", "like", "set", "step", "open", "check", "parse", "ind", "stop", "p", "ad", "info", "size", "min", "length", "from", "count", "none", "line", "address", "next", "first", "offset", "started", "change", "get", "r", "empty", "rest", "work", "pos", "space", "len", "max", "index"], "end": ["en", "END", "End", "event", "use", "x", "nd", "append", "begin", "limit", "vert", "dev", "old", "grade", "c", "offset", "change", "order", "index", "part", "id", "api", "w", "u", "entry", "length", "pend", "url", "ion", "r", "core", "path", "edge", "after", "complete", "update", "value", "ad", "z", "stop", "e", "est", "address", "close", "reset", "ended", "pos", "post", "enc", "code", "object", "range", "name", "send", "patch", "set", "open", "size", "p", "ending", "next", "one", "all", "last", "rest", "max"], "i": ["qi", "it", "ui", "slice", "I", "d", "t", "ai", "ni", "xi", "id", "code", "ini", "gi", "l", "oi", "io", "iu", "api", "ci", "x", "di", "si", "ie", "shift", "ii", "uri", "v", "o", "u", "ind", "iii", "p", "e", "cli", "li", "mi", "ix", "b", "multi", "j", "n", "f", "phi", "ti", "ip", "c", "eni", "reset", "diff", "next", "pi", "r", "bi", "ri", "zi", "y", "in", "index"], "command": ["action", "remote", "escape", "response", "code", "name", "directory", "execute", "operation", "send", "method", "sequence", "comment", "script", "uri", "package", "request", "password", "clear", "resource", "data", "Command", "mode", "resolution", "query", "timeout", "type", "attribute", "function", "cmd", "process", "exec", "pattern", "content", "prefix", "exclusive", "message"], "pwd_codes": ["pwdpcode", "pwd2code", "pwd2codes", "pwdpcod", "pwd_desc", "pwd2cod", "pwdpdesc", "pw_keys", "pw_desc", "pwd_keys", "pwd2desc", "pw_cod", "pwdpcodes", "pw_code", "pwd_cod", "pw_codes", "pwd_code"]}}
{"project": "qemu", "commit_id": "3b098d56979d2f7fd707c5be85555d114353a28d", "target": 0, "func": "static void visitor_output_setup_internal(TestOutputVisitorData *data,\n\n                                          bool human)\n\n{\n\n    data->human = human;\n\n    data->sov = string_output_visitor_new(human);\n\n    g_assert(data->sov);\n\n    data->ov = string_output_get_visitor(data->sov);\n\n    g_assert(data->ov);\n\n}\n", "idx": 17596, "substitutes": {"data": ["na", "Data", "init", "extra", "work", "code", "info", "reader", "base", "media", "results", "feed", "script", "result", "window", "g", "i", "root", "as", "pass", "this", "di", "model", "alpha", "self", "parser", "exec", "d", "database", "empty", "parse", "change", "final", "first", "and", "style", "ui", "aa", "fail", "rule", "config", "ad", "id", "last", "ga", "client", "parent", "cat", "post", "qa", "da", "p", "test", "builder", "missing", "dat", "next", "la", "wa", "a", "api", "DATA", "end", "valid", "it", "writer", "one", "dict", "li", "input"], "human": ["sov", "native", "reach", "mother", "veh", "small", "user", "name", "full", "json", "humans", "woman", "hou", "ouch", "huge", "urn", "family", "clean", "method", "public", "raw", "person", "username", "upper", "head", "low", "home", "han", "host", "cover", "liv", "father", "path", "modern", "large", "individual", "utf", "high", "remote", "ov", "hello", "client", "man", "parent", "dom", "ghost", "uc", "liter", "external", "http", "serial", "local", "Human", "valid", "canon", "own", "custom", "author", "pure"]}}
{"project": "qemu", "commit_id": "3010460fb99776bdf0a8b170555f2ab076382f9c", "target": 1, "func": "int hvf_vcpu_exec(CPUState *cpu)\n\n{\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n    CPUX86State *env = &x86_cpu->env;\n\n    int ret = 0;\n\n    uint64_t rip = 0;\n\n\n\n    cpu->halted = 0;\n\n\n\n    if (hvf_process_events(cpu)) {\n\n        return EXCP_HLT;\n\n    }\n\n\n\n    do {\n\n        if (cpu->vcpu_dirty) {\n\n            hvf_put_registers(cpu);\n\n            cpu->vcpu_dirty = false;\n\n        }\n\n\n\n        if (hvf_inject_interrupts(cpu)) {\n\n            return EXCP_INTERRUPT;\n\n        }\n\n        vmx_update_tpr(cpu);\n\n\n\n        qemu_mutex_unlock_iothread();\n\n        if (!cpu_is_bsp(X86_CPU(cpu)) && cpu->halted) {\n\n            qemu_mutex_lock_iothread();\n\n            return EXCP_HLT;\n\n        }\n\n\n\n        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);\n\n        assert_hvf_ok(r);\n\n\n\n        /* handle VMEXIT */\n\n        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);\n\n        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);\n\n        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,\n\n                                           VMCS_EXIT_INSTRUCTION_LENGTH);\n\n\n\n        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n\n\n        hvf_store_events(cpu, ins_len, idtvec_info);\n\n        rip = rreg(cpu->hvf_fd, HV_X86_RIP);\n\n        RFLAGS(env) = rreg(cpu->hvf_fd, HV_X86_RFLAGS);\n\n        env->eflags = RFLAGS(env);\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        update_apic_tpr(cpu);\n\n        current_cpu = cpu;\n\n\n\n        ret = 0;\n\n        switch (exit_reason) {\n\n        case EXIT_REASON_HLT: {\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            if (!((cpu->interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                (EFLAGS(env) & IF_MASK))\n\n                && !(cpu->interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                !(idtvec_info & VMCS_IDT_VEC_VALID)) {\n\n                cpu->halted = 1;\n\n                ret = EXCP_HLT;\n\n            }\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_MWAIT: {\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n            /* Need to check if MMIO or unmmaped fault */\n\n        case EXIT_REASON_EPT_FAULT:\n\n        {\n\n            hvf_slot *slot;\n\n            addr_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);\n\n\n\n            if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&\n\n                ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {\n\n                vmx_set_nmi_blocking(cpu);\n\n            }\n\n\n\n            slot = hvf_find_overlap_slot(gpa, gpa);\n\n            /* mmio */\n\n            if (ept_emulation_fault(slot, gpa, exit_qual)) {\n\n                struct x86_decode decode;\n\n\n\n                load_regs(cpu);\n\n                env->hvf_emul->fetch_rip = rip;\n\n\n\n                decode_instruction(env, &decode);\n\n                exec_instruction(env, &decode);\n\n                store_regs(cpu);\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        case EXIT_REASON_INOUT:\n\n        {\n\n            uint32_t in = (exit_qual & 8) != 0;\n\n            uint32_t size =  (exit_qual & 7) + 1;\n\n            uint32_t string =  (exit_qual & 16) != 0;\n\n            uint32_t port =  exit_qual >> 16;\n\n            /*uint32_t rep = (exit_qual & 0x20) != 0;*/\n\n\n\n#if 1\n\n            if (!string && in) {\n\n                uint64_t val = 0;\n\n                load_regs(cpu);\n\n                hvf_handle_io(env, port, &val, 0, size, 1);\n\n                if (size == 1) {\n\n                    AL(env) = val;\n\n                } else if (size == 2) {\n\n                    AX(env) = val;\n\n                } else if (size == 4) {\n\n                    RAX(env) = (uint32_t)val;\n\n                } else {\n\n                    VM_PANIC(\"size\");\n\n                }\n\n                RIP(env) += ins_len;\n\n                store_regs(cpu);\n\n                break;\n\n            } else if (!string && !in) {\n\n                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);\n\n                hvf_handle_io(env, port, &RAX(env), 1, size, 1);\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n#endif\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            VM_PANIC_ON(ins_len != decode.len);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n\n\n            break;\n\n        }\n\n        case EXIT_REASON_CPUID: {\n\n            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);\n\n            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);\n\n\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, rax);\n\n            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);\n\n            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);\n\n\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_XSETBV: {\n\n            X86CPU *x86_cpu = X86_CPU(cpu);\n\n            CPUX86State *env = &x86_cpu->env;\n\n            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            if (ecx) {\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n            env->xcr0 = ((uint64_t)edx << 32) | eax;\n\n            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_INTR_WINDOW:\n\n            vmx_clear_int_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_NMI_WINDOW:\n\n            vmx_clear_nmi_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_EXT_INTR:\n\n            /* force exit and allow io handling */\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_RDMSR:\n\n        case EXIT_REASON_WRMSR:\n\n        {\n\n            load_regs(cpu);\n\n            if (exit_reason == EXIT_REASON_RDMSR) {\n\n                simulate_rdmsr(cpu);\n\n            } else {\n\n                simulate_wrmsr(cpu);\n\n            }\n\n            RIP(env) += rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_CR_ACCESS: {\n\n            int cr;\n\n            int reg;\n\n\n\n            load_regs(cpu);\n\n            cr = exit_qual & 15;\n\n            reg = (exit_qual >> 8) & 15;\n\n\n\n            switch (cr) {\n\n            case 0x0: {\n\n                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 4: {\n\n                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 8: {\n\n                X86CPU *x86_cpu = X86_CPU(cpu);\n\n                if (exit_qual & 0x10) {\n\n                    RRX(env, reg) = cpu_get_apic_tpr(x86_cpu->apic_state);\n\n                } else {\n\n                    int tpr = RRX(env, reg);\n\n                    cpu_set_apic_tpr(x86_cpu->apic_state, tpr);\n\n                    ret = EXCP_INTERRUPT;\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                error_report(\"Unrecognized CR %d\\n\", cr);\n\n                abort();\n\n            }\n\n            RIP(env) += ins_len;\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_APIC_ACCESS: { /* TODO */\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TPR: {\n\n            ret = 1;\n\n            break;\n\n        }\n\n        case EXIT_REASON_TASK_SWITCH: {\n\n            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n            x68_segment_selector sel = {.sel = exit_qual & 0xffff};\n\n            vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,\n\n             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo\n\n             & VMCS_INTR_T_MASK);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TRIPLE_FAULT: {\n\n            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_RDPMC:\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, 0);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, 0);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        case VMX_REASON_VMCALL:\n\n            /* TODO: inject #GP fault */\n\n            break;\n\n        default:\n\n            error_report(\"%llx: unhandled exit %llx\\n\", rip, exit_reason);\n\n        }\n\n    } while (ret == 0);\n\n\n\n    return ret;\n\n}\n", "idx": 15999, "substitutes": {"cpu": ["device", "runner", "proc", "intel", "profile", "roc", "auc", "image", "pool", "module", "cmp", "hu", "gru", "np", "ck", "c", "prem", "cp", "nic", "program", "fen", "fc", "cpp", "chip", "home", "gc", "lc", "fps", "cn", "product", "vm", "lua", "console", "loader", "GPU", "instance", " CPU", "eni", "clock", "host", "cache", "colo", "mac", "lb", "core", "python", "fork", "consumer", "pty", "queue", "ilo", "config", "pc", "uu", "uno", "linux", "px", "conn", "processor", "boot", "nc", "CPU", "cfg", "uci", "gpu", "cf", "que", "prefix", "ctx", "node", "hp", "bench", "pkg", "cm", "worker", "utils", "kernel", "performance", "computer", "rpm", "pu", "platform", "cli", "component", "cu", "process", "pai", "css"], "x86_cpu": ["x86JCPU", "x54_cpu", "x86_processor", "x86Jprocessor", "xea_processor", "x86_CPU", "x54_CPU", "x86_conn", "x54_gpu", "x86_gpu", "x86Jcpu", "x86Jgpu", "xea_gpu", "xea_cpu", "x54_conn", "xea_CPU"], "env": ["args", "path", "egg", "en", "context", "esp", "enc", "ea", "config", "profile", " environment", "worker", "extra", "priv", "eu", "style", "api", "ex", "fg", "scope", "skin", "estate", "conf", "conn", "np", "console", "dev", "equ", "e", "enable", "exc", "exe", "cli", "ext", "eng", "Environment", "cfg", "dep", "export", "global", "eni", "agent", "ne", "esc", "file", "ep", "gui", "db", "cache", "ev", "ec", "properties", "stack", "inet", "environment", "el", "fen", "opt", "net", "err"]}}
{"project": "FFmpeg", "commit_id": "55815edca038997ec283569a192a3eca7f2143bc", "target": 0, "func": "static void build_feed_streams(void)\n\n{\n\n    FFStream *stream, *feed;\n\n    int i;\n\n\n\n    /* gather all streams */\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n\n        feed = stream->feed;\n\n        if (feed) {\n\n            if (!stream->is_feed) {\n\n                /* we handle a stream coming from a feed */\n\n                for(i=0;i<stream->nb_streams;i++)\n\n                    stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* gather all streams */\n\n    for(stream = first_stream; stream != NULL; stream = stream->next) {\n\n        feed = stream->feed;\n\n        if (feed) {\n\n            if (stream->is_feed) {\n\n                for(i=0;i<stream->nb_streams;i++)\n\n                    stream->feed_streams[i] = i;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* create feed files if needed */\n\n    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {\n\n        int fd;\n\n\n\n        if (url_exist(feed->feed_filename)) {\n\n            /* See if it matches */\n\n            AVFormatContext *s;\n\n            int matches = 0;\n\n\n\n            if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {\n\n                /* Now see if it matches */\n\n                if (s->nb_streams == feed->nb_streams) {\n\n                    matches = 1;\n\n                    for(i=0;i<s->nb_streams;i++) {\n\n                        AVStream *sf, *ss;\n\n                        sf = feed->streams[i];\n\n                        ss = s->streams[i];\n\n\n\n                        if (sf->index != ss->index ||\n\n                            sf->id != ss->id) {\n\n                            http_log(\"Index & Id do not match for stream %d (%s)\\n\",\n\n                                   i, feed->feed_filename);\n\n                            matches = 0;\n\n                        } else {\n\n                            AVCodecContext *ccf, *ccs;\n\n\n\n                            ccf = sf->codec;\n\n                            ccs = ss->codec;\n\n#define CHECK_CODEC(x)  (ccf->x != ccs->x)\n\n\n\n                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {\n\n                                http_log(\"Codecs do not match for stream %d\\n\", i);\n\n                                matches = 0;\n\n                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {\n\n                                http_log(\"Codec bitrates do not match for stream %d\\n\", i);\n\n                                matches = 0;\n\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                                if (CHECK_CODEC(time_base.den) ||\n\n                                    CHECK_CODEC(time_base.num) ||\n\n                                    CHECK_CODEC(width) ||\n\n                                    CHECK_CODEC(height)) {\n\n                                    http_log(\"Codec width, height and framerate do not match for stream %d\\n\", i);\n\n                                    matches = 0;\n\n                                }\n\n                            } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n                                if (CHECK_CODEC(sample_rate) ||\n\n                                    CHECK_CODEC(channels) ||\n\n                                    CHECK_CODEC(frame_size)) {\n\n                                    http_log(\"Codec sample_rate, channels, frame_size do not match for stream %d\\n\", i);\n\n                                    matches = 0;\n\n                                }\n\n                            } else {\n\n                                http_log(\"Unknown codec type\\n\");\n\n                                matches = 0;\n\n                            }\n\n                        }\n\n                        if (!matches)\n\n                            break;\n\n                    }\n\n                } else\n\n                    http_log(\"Deleting feed file '%s' as stream counts differ (%d != %d)\\n\",\n\n                        feed->feed_filename, s->nb_streams, feed->nb_streams);\n\n\n\n                av_close_input_file(s);\n\n            } else\n\n                http_log(\"Deleting feed file '%s' as it appears to be corrupt\\n\",\n\n                        feed->feed_filename);\n\n\n\n            if (!matches) {\n\n                if (feed->readonly) {\n\n                    http_log(\"Unable to delete feed file '%s' as it is marked readonly\\n\",\n\n                        feed->feed_filename);\n\n                    exit(1);\n\n                }\n\n                unlink(feed->feed_filename);\n\n            }\n\n        }\n\n        if (!url_exist(feed->feed_filename)) {\n\n            AVFormatContext s1 = {0}, *s = &s1;\n\n\n\n            if (feed->readonly) {\n\n                http_log(\"Unable to create feed file '%s' as it is marked readonly\\n\",\n\n                    feed->feed_filename);\n\n                exit(1);\n\n            }\n\n\n\n            /* only write the header of the ffm file */\n\n            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {\n\n                http_log(\"Could not open output feed file '%s'\\n\",\n\n                         feed->feed_filename);\n\n                exit(1);\n\n            }\n\n            s->oformat = feed->fmt;\n\n            s->nb_streams = feed->nb_streams;\n\n            for(i=0;i<s->nb_streams;i++) {\n\n                AVStream *st;\n\n                st = feed->streams[i];\n\n                s->streams[i] = st;\n\n            }\n\n            av_set_parameters(s, NULL);\n\n            if (av_write_header(s) < 0) {\n\n                http_log(\"Container doesn't supports the required parameters\\n\");\n\n                exit(1);\n\n            }\n\n            /* XXX: need better api */\n\n            av_freep(&s->priv_data);\n\n            avio_close(s->pb);\n\n        }\n\n        /* get feed size and write index */\n\n        fd = open(feed->feed_filename, O_RDONLY);\n\n        if (fd < 0) {\n\n            http_log(\"Could not open output feed file '%s'\\n\",\n\n                    feed->feed_filename);\n\n            exit(1);\n\n        }\n\n\n\n        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);\n\n        feed->feed_size = lseek(fd, 0, SEEK_END);\n\n        /* ensure that we do not wrap before the end of file */\n\n        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)\n\n            feed->feed_max_size = feed->feed_size;\n\n\n\n        close(fd);\n\n    }\n\n}\n", "idx": 666, "substitutes": {"stream": ["wheel", "row", "queue", "current", "url", "sl", "client", "roll", "pipe", "forward", "event", "ream", "control", "ack", "down", "sw", "track", "f", "child", "message", "object", "round", "single", "path", "board", "port", "flow", "group", "host", "form", "image", "cloud", "model", "request", "resource", "length", "web", "transform", "wave", "load", "input", "user", "channel", "loop", "filter", "live", "document", "pool", "raw", "food", "content", "design", "node", "cf", "hook", "uc", "Stream", "null", "server", "follow", "header", "output", "draft", "sync", "coll", "source", "config", "reader", "draw", "pull", "thread", "fuel", "clean", "full", "view", "table", "upload"], "feed": ["allow", "row", "large", "fed", "queue", "sl", "wait", "next", "roll", "forward", "event", "index", "control", "ack", "f", "child", "sc", "comment", "cell", "valid", "af", "board", "acc", "accept", "flow", "read", "gram", "zip", "host", "form", "image", "scroll", "id", "pass", "model", "update", "write", "request", "post", "feeding", "layout", "length", "handler", "driver", "link", "load", "import", "keep", "input", "gh", "Feed", "fast", "build", "channel", "hub", "report", "page", "insert", "loop", "search", "cr", "raw", "food", "design", "rss", "cf", "close", "fork", "gen", "low", "hook", "cook", "uc", "inf", "service", "check", "def", "ga", "throw", "follow", "grow", "seed", "gg", "draft", "entry", "bug", "source", "config", "reader", "zero", "draw", "pull", "fuel", "full", "view"], "i": ["q", "j", "g", "ti", "index", "x", "hi", "f", "u", "ori", "vi", "uri", "fi", "start", "abi", "zi", "pi", "ui", "image", "id", "mi", "k", "iu", "y", "ri", "z", "ie", "p", "e", "lc", "isi", "v", "qi", "ix", "t", "io", "root", "in", "li", "a", "ni", "ii", "chi", "data", "r", "I", "di", "is", "m", "inner", "info", "slice", "ini", "h", "c", "phi", "o", "si", "yi", "gi", "ei", "oi", "d", "it", "iii", "eni", "none", "multi", "ai", "ip", "l", "block", "reader", "bi", "min", "b", "ci", "part", "xi"], "fd": ["fc", "ff", "find", "form", "fa", "d", "ct", "di", "aa", "ma", "fff", "fn", "found", "file", "flows", "fr", "cond", "feat", "fe", "iff", "f", "ffff", " fid", "handler", "fm", "ci"], "s": ["server", "js", "service", "spec", "qs", "ts", "rs", "a", "sb", "n", "aws", "sl", "search", "y", "g", "space", "m", "ses", "ls", "sync", "xs", "sv", "storage", "sets", "ds", "settings", "ps", "gs", "source", "ns", "l", "c", "p", "sw", "services", "e", "f", "es", "sq", "u", "o", "v", "stats", "b", "su", "S", "t", "session", "single", "site", "rss", "hs", "se", "fs", "si", "ssl"], "sf": ["fc", "tf", "vp", "fs", "sd", "sb", "xf", "fy", "fw", "cpp", "uci", "lf", "dl", "sl", "fl", "rf", "ef", "fp", "df", "fr", "ft", "sv", "bf", "fe", "fg", "sw", "aff", "f", "sq", "fx", "eph", "fm", "fee", "fb", "nw", "su", "SF", "cf", "rss", "sm", "uf", "fi", "si", "ssl"], "ss": ["cs", "sch", "ass", "rs", "sd", "sb", "pg", "sp", "sl", "sh", "ssh", "ses", "fts", "ls", "sync", "ys", "xs", "sv", "ds", "SS", "WS", "ess", "xx", "ns", "ps", "css", "vs", "sw", "oss", "f", "es", "hess", "sq", "sc", "sys", "uss", "sr", "iss", "rss", "su", "serv", "cf", "os", "bs", "se", "fs", "si", "ssl"], "ccf": ["cff", "csv", "CCb", "acf", "cfrf", "ccrf", "CCfs", "ecb", "CCs", "ecfs", "cfv", "csfs", "acfs", "ecs", "ucb", "csf", "ucs", "cffs", "CCf", "acv", "acrf", "csrf", "ucfs", "ucf", "ccb", "ecf", "ccv", "ccfs"], "ccs": ["csp", "cff", "csv", "rcl", "ccl", "ctp", "accf", "cts", "rcc", "cfs", "cfv", "ccp", "css", "accl", "csf", "ucs", "ccc", "cfp", "accc", "rcf", "ucc", "accs", "ucf", "ctf", "ctv", "ucl", "rcs", "ccv"]}}
{"project": "qemu", "commit_id": "375092332eeaa6e47561ce47fd36144cdaf964d0", "target": 0, "func": "qcrypto_block_luks_create(QCryptoBlock *block,\n\n                          QCryptoBlockCreateOptions *options,\n\n                          QCryptoBlockInitFunc initfunc,\n\n                          QCryptoBlockWriteFunc writefunc,\n\n                          void *opaque,\n\n                          Error **errp)\n\n{\n\n    QCryptoBlockLUKS *luks;\n\n    QCryptoBlockCreateOptionsLUKS luks_opts;\n\n    Error *local_err = NULL;\n\n    uint8_t *masterkey = NULL;\n\n    uint8_t *slotkey = NULL;\n\n    uint8_t *splitkey = NULL;\n\n    size_t splitkeylen = 0;\n\n    size_t i;\n\n    QCryptoCipher *cipher = NULL;\n\n    QCryptoIVGen *ivgen = NULL;\n\n    char *password;\n\n    const char *cipher_alg;\n\n    const char *cipher_mode;\n\n    const char *ivgen_alg;\n\n    const char *ivgen_hash_alg = NULL;\n\n    const char *hash_alg;\n\n    char *cipher_mode_spec = NULL;\n\n    QCryptoCipherAlgorithm ivcipheralg = 0;\n\n    uint64_t iters;\n\n\n\n    memcpy(&luks_opts, &options->u.luks, sizeof(luks_opts));\n\n    if (!luks_opts.has_iter_time) {\n\n        luks_opts.iter_time = 2000;\n\n    }\n\n    if (!luks_opts.has_cipher_alg) {\n\n        luks_opts.cipher_alg = QCRYPTO_CIPHER_ALG_AES_256;\n\n    }\n\n    if (!luks_opts.has_cipher_mode) {\n\n        luks_opts.cipher_mode = QCRYPTO_CIPHER_MODE_XTS;\n\n    }\n\n    if (!luks_opts.has_ivgen_alg) {\n\n        luks_opts.ivgen_alg = QCRYPTO_IVGEN_ALG_PLAIN64;\n\n    }\n\n    if (!luks_opts.has_hash_alg) {\n\n        luks_opts.hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n    }\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        if (!luks_opts.has_ivgen_hash_alg) {\n\n            luks_opts.ivgen_hash_alg = QCRYPTO_HASH_ALG_SHA256;\n\n            luks_opts.has_ivgen_hash_alg = true;\n\n        }\n\n    }\n\n    /* Note we're allowing ivgen_hash_alg to be set even for\n\n     * non-essiv iv generators that don't need a hash. It will\n\n     * be silently ignored, for compatibility with dm-crypt */\n\n\n\n    if (!options->u.luks.key_secret) {\n\n        error_setg(errp, \"Parameter 'key-secret' is required for cipher\");\n\n        return -1;\n\n    }\n\n    password = qcrypto_secret_lookup_as_utf8(luks_opts.key_secret, errp);\n\n    if (!password) {\n\n        return -1;\n\n    }\n\n\n\n    luks = g_new0(QCryptoBlockLUKS, 1);\n\n    block->opaque = luks;\n\n\n\n    memcpy(luks->header.magic, qcrypto_block_luks_magic,\n\n           QCRYPTO_BLOCK_LUKS_MAGIC_LEN);\n\n\n\n    /* We populate the header in native endianness initially and\n\n     * then convert everything to big endian just before writing\n\n     * it out to disk\n\n     */\n\n    luks->header.version = QCRYPTO_BLOCK_LUKS_VERSION;\n\n    qcrypto_block_luks_uuid_gen(luks->header.uuid);\n\n\n\n    cipher_alg = qcrypto_block_luks_cipher_alg_lookup(luks_opts.cipher_alg,\n\n                                                      errp);\n\n    if (!cipher_alg) {\n\n        goto error;\n\n    }\n\n\n\n    cipher_mode = QCryptoCipherMode_lookup[luks_opts.cipher_mode];\n\n    ivgen_alg = QCryptoIVGenAlgorithm_lookup[luks_opts.ivgen_alg];\n\n    if (luks_opts.has_ivgen_hash_alg) {\n\n        ivgen_hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.ivgen_hash_alg];\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s:%s\", cipher_mode, ivgen_alg,\n\n                                           ivgen_hash_alg);\n\n    } else {\n\n        cipher_mode_spec = g_strdup_printf(\"%s-%s\", cipher_mode, ivgen_alg);\n\n    }\n\n    hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.hash_alg];\n\n\n\n\n\n    if (strlen(cipher_alg) >= QCRYPTO_BLOCK_LUKS_CIPHER_NAME_LEN) {\n\n        error_setg(errp, \"Cipher name '%s' is too long for LUKS header\",\n\n                   cipher_alg);\n\n        goto error;\n\n    }\n\n    if (strlen(cipher_mode_spec) >= QCRYPTO_BLOCK_LUKS_CIPHER_MODE_LEN) {\n\n        error_setg(errp, \"Cipher mode '%s' is too long for LUKS header\",\n\n                   cipher_mode_spec);\n\n        goto error;\n\n    }\n\n    if (strlen(hash_alg) >= QCRYPTO_BLOCK_LUKS_HASH_SPEC_LEN) {\n\n        error_setg(errp, \"Hash name '%s' is too long for LUKS header\",\n\n                   hash_alg);\n\n        goto error;\n\n    }\n\n\n\n    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {\n\n        ivcipheralg = qcrypto_block_luks_essiv_cipher(luks_opts.cipher_alg,\n\n                                                      luks_opts.ivgen_hash_alg,\n\n                                                      &local_err);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            goto error;\n\n        }\n\n    } else {\n\n        ivcipheralg = luks_opts.cipher_alg;\n\n    }\n\n\n\n    strcpy(luks->header.cipher_name, cipher_alg);\n\n    strcpy(luks->header.cipher_mode, cipher_mode_spec);\n\n    strcpy(luks->header.hash_spec, hash_alg);\n\n\n\n    luks->header.key_bytes = qcrypto_cipher_get_key_len(luks_opts.cipher_alg);\n\n    if (luks_opts.cipher_mode == QCRYPTO_CIPHER_MODE_XTS) {\n\n        luks->header.key_bytes *= 2;\n\n    }\n\n\n\n    /* Generate the salt used for hashing the master key\n\n     * with PBKDF later\n\n     */\n\n    if (qcrypto_random_bytes(luks->header.master_key_salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Generate random master key */\n\n    masterkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_random_bytes(masterkey,\n\n                             luks->header.key_bytes, errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the block device payload encryption objects */\n\n    block->cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                       luks_opts.cipher_mode,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       errp);\n\n    if (!block->cipher) {\n\n        goto error;\n\n    }\n\n\n\n    block->kdfhash = luks_opts.hash_alg;\n\n    block->niv = qcrypto_cipher_get_iv_len(luks_opts.cipher_alg,\n\n                                           luks_opts.cipher_mode);\n\n    block->ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                                     ivcipheralg,\n\n                                     luks_opts.ivgen_hash_alg,\n\n                                     masterkey, luks->header.key_bytes,\n\n                                     errp);\n\n\n\n    if (!block->ivgen) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Determine how many iterations we need to hash the master\n\n     * key, in order to have 1 second of compute time used\n\n     */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       masterkey, luks->header.key_bytes,\n\n                                       luks->header.master_key_salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    /* Why /= 8 ?  That matches cryptsetup, but there's no\n\n     * explanation why they chose /= 8... Probably so that\n\n     * if all 8 keyslots are active we only spend 1 second\n\n     * in total time to check all keys */\n\n    iters /= 8;\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n    iters = MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_MASTER_KEY_ITERS);\n\n    luks->header.master_key_iterations = iters;\n\n\n\n    /* Hash the master key, saving the result in the LUKS\n\n     * header. This hash is used when opening the encrypted\n\n     * device to verify that the user password unlocked a\n\n     * valid master key\n\n     */\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       masterkey, luks->header.key_bytes,\n\n                       luks->header.master_key_salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.master_key_iterations,\n\n                       luks->header.master_key_digest,\n\n                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Although LUKS has multiple key slots, we're just going\n\n     * to use the first key slot */\n\n    splitkeylen = luks->header.key_bytes * QCRYPTO_BLOCK_LUKS_STRIPES;\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        luks->header.key_slots[i].active = i == 0 ?\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_ENABLED :\n\n            QCRYPTO_BLOCK_LUKS_KEY_SLOT_DISABLED;\n\n        luks->header.key_slots[i].stripes = QCRYPTO_BLOCK_LUKS_STRIPES;\n\n\n\n        /* This calculation doesn't match that shown in the spec,\n\n         * but instead follows the cryptsetup implementation.\n\n         */\n\n        luks->header.key_slots[i].key_offset =\n\n            (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n             QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n            (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                      (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                       QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) * i);\n\n    }\n\n\n\n    if (qcrypto_random_bytes(luks->header.key_slots[0].salt,\n\n                             QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                             errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Again we determine how many iterations are required to\n\n     * hash the user password while consuming 1 second of compute\n\n     * time */\n\n    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,\n\n                                       (uint8_t *)password, strlen(password),\n\n                                       luks->header.key_slots[0].salt,\n\n                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                                       luks->header.key_bytes,\n\n                                       &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu too large to scale\",\n\n                         (unsigned long long)iters);\n\n        goto error;\n\n    }\n\n\n\n    /* iter_time was in millis, but count_iters reported for secs */\n\n    iters = iters * luks_opts.iter_time / 1000;\n\n\n\n    if (iters > UINT32_MAX) {\n\n        error_setg_errno(errp, ERANGE,\n\n                         \"PBKDF iterations %llu larger than %u\",\n\n                         (unsigned long long)iters, UINT32_MAX);\n\n        goto error;\n\n    }\n\n\n\n    luks->header.key_slots[0].iterations =\n\n        MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_SLOT_KEY_ITERS);\n\n\n\n\n\n    /* Generate a key that we'll use to encrypt the master\n\n     * key, from the user's password\n\n     */\n\n    slotkey = g_new0(uint8_t, luks->header.key_bytes);\n\n    if (qcrypto_pbkdf2(luks_opts.hash_alg,\n\n                       (uint8_t *)password, strlen(password),\n\n                       luks->header.key_slots[0].salt,\n\n                       QCRYPTO_BLOCK_LUKS_SALT_LEN,\n\n                       luks->header.key_slots[0].iterations,\n\n                       slotkey, luks->header.key_bytes,\n\n                       errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* Setup the encryption objects needed to encrypt the\n\n     * master key material\n\n     */\n\n    cipher = qcrypto_cipher_new(luks_opts.cipher_alg,\n\n                                luks_opts.cipher_mode,\n\n                                slotkey, luks->header.key_bytes,\n\n                                errp);\n\n    if (!cipher) {\n\n        goto error;\n\n    }\n\n\n\n    ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,\n\n                              ivcipheralg,\n\n                              luks_opts.ivgen_hash_alg,\n\n                              slotkey, luks->header.key_bytes,\n\n                              errp);\n\n    if (!ivgen) {\n\n        goto error;\n\n    }\n\n\n\n    /* Before storing the master key, we need to vastly\n\n     * increase its size, as protection against forensic\n\n     * disk data recovery */\n\n    splitkey = g_new0(uint8_t, splitkeylen);\n\n\n\n    if (qcrypto_afsplit_encode(luks_opts.hash_alg,\n\n                               luks->header.key_bytes,\n\n                               luks->header.key_slots[0].stripes,\n\n                               masterkey,\n\n                               splitkey,\n\n                               errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n    /* Now we encrypt the split master key with the key generated\n\n     * from the user's password, before storing it */\n\n    if (qcrypto_block_encrypt_helper(cipher, block->niv, ivgen,\n\n                                     QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                                     0,\n\n                                     splitkey,\n\n                                     splitkeylen,\n\n                                     errp) < 0) {\n\n        goto error;\n\n    }\n\n\n\n\n\n    /* The total size of the LUKS headers is the partition header + key\n\n     * slot headers, rounded up to the nearest sector, combined with\n\n     * the size of each master key material region, also rounded up\n\n     * to the nearest sector */\n\n    luks->header.payload_offset =\n\n        (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n         QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +\n\n        (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),\n\n                  (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /\n\n                   QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) *\n\n         QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS);\n\n\n\n    block->payload_offset = luks->header.payload_offset *\n\n        QCRYPTO_BLOCK_LUKS_SECTOR_SIZE;\n\n\n\n    /* Reserve header space to match payload offset */\n\n    initfunc(block, block->payload_offset, &local_err, opaque);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Everything on disk uses Big Endian, so flip header fields\n\n     * before writing them */\n\n    cpu_to_be16s(&luks->header.version);\n\n    cpu_to_be32s(&luks->header.payload_offset);\n\n    cpu_to_be32s(&luks->header.key_bytes);\n\n    cpu_to_be32s(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        cpu_to_be32s(&luks->header.key_slots[i].active);\n\n        cpu_to_be32s(&luks->header.key_slots[i].iterations);\n\n        cpu_to_be32s(&luks->header.key_slots[i].key_offset);\n\n        cpu_to_be32s(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n\n\n    /* Write out the partition header and key slot headers */\n\n    writefunc(block, 0,\n\n              (const uint8_t *)&luks->header,\n\n              sizeof(luks->header),\n\n              &local_err,\n\n              opaque);\n\n\n\n    /* Delay checking local_err until we've byte-swapped */\n\n\n\n    /* Byte swap the header back to native, in case we need\n\n     * to read it again later */\n\n    be16_to_cpus(&luks->header.version);\n\n    be32_to_cpus(&luks->header.payload_offset);\n\n    be32_to_cpus(&luks->header.key_bytes);\n\n    be32_to_cpus(&luks->header.master_key_iterations);\n\n\n\n    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {\n\n        be32_to_cpus(&luks->header.key_slots[i].active);\n\n        be32_to_cpus(&luks->header.key_slots[i].iterations);\n\n        be32_to_cpus(&luks->header.key_slots[i].key_offset);\n\n        be32_to_cpus(&luks->header.key_slots[i].stripes);\n\n    }\n\n\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto error;\n\n    }\n\n\n\n    /* Write out the master key material, starting at the\n\n     * sector immediately following the partition header. */\n\n    if (writefunc(block,\n\n                  luks->header.key_slots[0].key_offset *\n\n                  QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,\n\n                  splitkey, splitkeylen,\n\n                  errp,\n\n                  opaque) != splitkeylen) {\n\n        goto error;\n\n    }\n\n\n\n    luks->cipher_alg = luks_opts.cipher_alg;\n\n    luks->cipher_mode = luks_opts.cipher_mode;\n\n    luks->ivgen_alg = luks_opts.ivgen_alg;\n\n    luks->ivgen_hash_alg = luks_opts.ivgen_hash_alg;\n\n    luks->hash_alg = luks_opts.hash_alg;\n\n\n\n    memset(masterkey, 0, luks->header.key_bytes);\n\n    g_free(masterkey);\n\n    memset(slotkey, 0, luks->header.key_bytes);\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    return 0;\n\n\n\n error:\n\n    if (masterkey) {\n\n        memset(masterkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(masterkey);\n\n    if (slotkey) {\n\n        memset(slotkey, 0, luks->header.key_bytes);\n\n    }\n\n    g_free(slotkey);\n\n    g_free(splitkey);\n\n    g_free(password);\n\n    g_free(cipher_mode_spec);\n\n\n\n    qcrypto_ivgen_free(ivgen);\n\n    qcrypto_cipher_free(cipher);\n\n\n\n    g_free(luks);\n\n    return -1;\n\n}\n", "idx": 21740, "substitutes": {"luks": ["like", "lack", "licks", "fluKS", "flucks", "LUke", "laks", "lucs", "fluck", "flucs", "LUKS", "lucks", "LUks", "lick", "luke", "lics", "liks", "LUcs", "fluke", "lacks", "fluks", "lacs", "liKS", "luKS", "luck"], "luks_opts": ["luks_os", "luks_opters", "luks_opted", "luks_lockts", "luks_optcs", "luks_OPbs", "luks_optals", "luks_ots", "luks_cpters", "luks_obls", "luks_optms", "luks_optls", "luks_Opts", "luks_Opcs", "luks_catters", "luks_ryts", "luks_copters", "luks_okts", "luks_proths", "luks_opte", "luks_optt", "luks_optments", "luks_defte", "luks_adts", "luks_opens", "luks_hopte", "luks_otms", "luks_copks", "luks_Opt", "luks_otcs", "luks_OPted", "luks_opt", "luks_defts", "luks_opsts", "luks_optters", "luks_Ops", "luks_opments", "luks_OPps", "luks_hopps", "luks_opcs", "luks_otts", "luks_ryths", "luks_opms", "luks_opents", "luks_prots", "luks_OPns", "luks_cpts", "luks_copss", "luks_OPts", "luks_OPte", "luks_alts", "luks_alters", "luks_adbs", "luks_pcs", "luks_OPters", "luks_ryt", "luks_OPtes", "luks_pters", "luks_hopals", "luks_optted", "luks_obts", "luks_OPs", "luks_lockters", "luks_okt", "luks_proters", "luks_cats", "luks_hopters", "luks_optts", "luks_optes", "luks_opks", "luks_ott", "luks_prosts", "luks_alns", "luks_obments", "luks_opls", "luks_cpouts", "luks_opths", "luks_opentes", "luks_OPt", "luks_oktes", "luks_obters", "luks_opouts", "luks_locktes", "luks_ocs", "luks_adters", "luks_lockt", "luks_openments", "luks_defths", "luks_copsts", "luks_adouts", "luks_hopted", "luks_OPcs", "luks_catts", "luks_deft", "luks_optte", "luks_OPms", "luks_opals", "luks_opss", "luks_openls", "luks_alss", "luks_okters", "luks_adths", "luks_optps", "luks_pt", "luks_hopt", "luks_pts", "luks_alks", "luks_opbs", "luks_rybs", "luks_copts", "luks_copths", "luks_cpns", "luks_adt", "luks_ot", "luks_ops", "luks_opps", "luks_adns", "luks_OPths", "luks_alt", "luks_okns", "luks_cattes", "luks_hopts", "luks_openters", "luks_opns"], "local_err": ["local___bug", "shared_er", "shared_bug", "local___er", "local__er", "local_ver", "local__err", "local__ver", "local_bug", "shared_err", "local_er", "local___err", "local___ver", "shared_ver", "local__bug"], "masterkey": ["mastername", "primarykey", "parentblock", "parentKey", "parentkey", "primaryname", "masterblock", "publicblock", "primaryKey", "primaryblock", "publicname", "masterKey", "publicKey", "parentname", "publickey"], "slotkey": ["slicekey", "bitname", "bitid", "sliceid", "bitkey", "bitKey", "slotname", "offsetKey", "sliceKey", "offsetid", "slotKey", "slicename", "slotid", "offsetname", "offsetkey"], "splitkey": ["splitblock", "splitkeys", "sliceblock", "sharedkey", "sliceKey", "sharedkeys", "sessionblock", "slicekeys", "sessionkeys", "sharedblock", "sessionKey", "slicekey", "splitKey", "sessionkey", "sharedKey"], "i": ["I", "t", "s", "data", "shared", "ip", "abi", "p", "is", "c", "a", "b", "ii", "n", "multi", "array", "l", "fi", "k"], "cipher": ["scrypt", "scipher", "Crypt", "acrypt", "acairo", "scairo", "acursor", "crypt", "scursor", "Cairo", "cairo", "cursor", "Cursor", "acipher", "Cipher"], "ivgen": ["ivdec", " ivdec", "IVgener", "vmap", "ivmap", " ivmap", " ivgener", "IVmap", "vdec", "IVgen", "vgen", "vgener", "ivgener", "IVdec"], "password": ["security", "wallet", "text", "RAW", "phrase", "token", "path", "enc", "params", "prefix", "word", "auth", "mac", "comment", "rw", "random", "pass", "w", "alias", "session", "secret", "words", "mask", "sword", "user", "username", "Password", "padding"], "cipher_alg": ["cryption_mag", "cipher_erg", "cryption_method", "cryption_erg", "cipher_round", "cipher_orig", "cryption_mode", "cryption_orig", "cryption_round", "cryption_alg", "cipher_method", "cipher_mag"], "cipher_mode": ["cipher\u00b7level", "cipheringmodule", "cipher_level", "cursor_level", "cipheringstyle", "cursor_type", "crypt_style", "cipheringalg", "cipher_style", "crypt_mode", "cipher\u00b7type", "cipher_type", "cipher_def", "cipher\u00b7mode", "crypt_module", "crypt_alg", "cursor_mode", "cipher_module", "cursor_def", "cipheringmode", "cipher\u00b7def"], "ivgen_alg": ["ivgen_agg", "ivgn_alg", "ivgn_generation", "ivget_rg", "ivget_alg", "ivgeningrg", "ivgeningagg", "ivgen_rg", "ivgn_rg", "ivgetingrg", "ivgen_alt", "ivgeningmode", "ivgetingagg", "ivgen_mode", "ivgeningalg", "ivgn_alt", "ivget_agg", "ivgn_lass", "ivgn_mode", "ivgetingmode", "ivgetingalg", "ivget_mode", "ivgen_lass", "ivgen_generation"], "ivgen_hash_alg": ["ivgen_hash_mode", "ivgen_hash_mag", "ivgen_hash_lim"], "hash_alg": ["hash___arch", "hash67spec", "hash67alg", " hash_dec", " hash_mode", "hashabledec", "hashablemode", " hash_arch", "hashablealg", "hash_arch", "hash_spec", "hash_mode", "hash_dec", " hash_gen", "hash___alg", "hashablearch", "hash___mode", "hash67gen", "hash___dec", "hash67mode", "hash_gen", " hash_spec"], "cipher_mode_spec": ["cipher_mod_spec", "cipher_mode_mode", "cipher_mod_len", "cipher_mode_SPEC", "cipher_mod_SPEC", "cipher_mod_mode", "cipher_mode_len"], "iters": ["itering", "integers", "liters", "integer", "iter", "litering", "itered", "ifered", "ifer", "liter", "litered", "ifering", "ifers", "integered", "integering"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,\n\n                                unsigned size)\n\n{\n\n    IMXTimerGState *s = (IMXTimerGState *)opaque;\n\n\n\n    DPRINTF(\"g-read(offset=%x)\", offset >> 2);\n\n    switch (offset >> 2) {\n\n    case 0: /* Control Register */\n\n        DPRINTF(\" cr = %x\\n\", s->cr);\n\n        return s->cr;\n\n\n\n    case 1: /* prescaler */\n\n        DPRINTF(\" pr = %x\\n\", s->pr);\n\n        return s->pr;\n\n\n\n    case 2: /* Status Register */\n\n        DPRINTF(\" sr = %x\\n\", s->sr);\n\n        return s->sr;\n\n\n\n    case 3: /* Interrupt Register */\n\n        DPRINTF(\" ir = %x\\n\", s->ir);\n\n        return s->ir;\n\n\n\n    case 4: /* Output Compare Register 1 */\n\n        DPRINTF(\" ocr1 = %x\\n\", s->ocr1);\n\n        return s->ocr1;\n\n\n\n\n\n    case 9: /* cnt */\n\n        imx_timerg_update_counts(s);\n\n        DPRINTF(\" cnt = %x\\n\", s->cnt);\n\n        return s->cnt;\n\n    }\n\n\n\n    IPRINTF(\"imx_timerg_read: Bad offset %x\\n\",\n\n            (int)offset >> 2);\n\n    return 0;\n\n}\n", "idx": 4556, "substitutes": {"opaque": ["oopicit", "opque", "operque", "ipopaque", "operaques", "oopque", " opque", "operaque", " opity", "oopity", " opicit", " opca", "ipopacity", "operity", " opacity", "opaques", "operacity", "ipopca", "opericit", "oopaque", "opacity", "opca", "operca", " opaques", "opicit", "ipopaques", "opity"], "offset": ["base", "address", "o", "position", "padding", "reset", "no", "id", "entry", "parent", "fee", "skip", "object", "data", "alias", "et", "shift", "sync", "slice", "Offset", "phase", "loc", "null", "key", "url", "limit", "length", "align", "delay", "initial", "part", "len", "error", "bound", "timeout", "seq", "ptr", "pos", "pointer", "start", "alloc", "off", "attribute", "location", "type", "range", "oid", "slot", "ref", "notation", "set", "addr", "index", "next", "seed", "mode", "optional"], "size": ["address", "SIZE", "data", " bytes", "length", "args", " length", "Size", "bytes", "ptr", "ize"], "s": ["ing", "sf", "S", "a", "b", "ums", "i", "status", "results", "f", "service", "hs", "w", "ar", " parts", " statements", "aws", "sa", "g", "sym", "y", " entries", "types", "sets", "ers", "is", "services", "its", "states", "server", "sl", "ls", " results", "ops", "ds", "ts", "south", "settings", "ors", " values", "fs", "sq", " defaults", "rs", "as", "er", "ins", "sy", "sg", "als", "sync", "ses", "ions", "has", "ports", "cs", "e", "sb", "secondary", "qs", "t", "erences", "ings", "p", "ies", "c", "os", "ssl", "ed", "r", " signals", "ps", "o", "scope", "session", "si", "sys", "m", "l", "ns", "stats", "us", "ss", " symbols", "gs", "storage", "es", "js"]}}
{"project": "FFmpeg", "commit_id": "eb24fd64589b7eea91fa752861f0c6f07e5a48a8", "target": 0, "func": "int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)\n\n{\n\n    int count, x;\n\n    uint8_t *out;\n\n\n\n    out = outbuf;\n\n\n\n\n\n        for(x = 0; x < w; x += count) {\n\n            /* see if we can encode the next set of pixels with RLE */\n\n            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {\n\n                if(out + bpp + 1 > outbuf + out_size) return -1;\n\n                *out++ = (count ^ xor) + add;\n\n                memcpy(out, ptr, bpp);\n\n                out += bpp;\n\n            } else {\n\n                /* fall back on uncompressed */\n\n                count = count_pixels(ptr, w-x, bpp, 0);\n\n                *out++ = count - 1;\n\n\n\n                if(out + bpp*count > outbuf + out_size) return -1;\n\n                memcpy(out, ptr, bpp * count);\n\n                out += bpp * count;\n\n        }\n\n\n\n        ptr += count * bpp;\n\n    }\n\n\n\n    return out - outbuf;\n\n}\n", "idx": 8211, "substitutes": {"outbuf": ["tempqueue", "outputcb", "Outbuf", " outbuffer", "outcb", "upfac", "upbuffer", "inbuf", "againcb", " outbuff", "outerbuffer", "bitfac", "incb", "offbuffer", "outputbuf", "offuf", "offbuf", " outfac", "Outqueue", "againuf", "outfile", "tempbuf", "againbuf", "outuf", " outfile", " outqueue", "outbuffer", "tempuf", "tempbuffer", "Outbuffer", "bitcb", "outbuff", "infile", "outerfile", "upbuf", "bitbuffer", "Outuf", "outfac", " outcb", "outputbuff", " outuf", "outqueue", "againbuffer", "bitbuf", "offcb", "upcb", "outputbuffer", "inbuffer", "outerbuf", "inbuff", "outerbuff"], "out_size": ["out_address", "in_shape", "out__uri", "out64address", "out64shape", "in_size", "out__scale", "out_uri", "image_uri", "out__space", "outlogaddress", "in_address", "out_space", "out_shape", "image_size", "image_max", "out__size", "out__max", "out_length", "out_scale", "out_max", "image_length", "outlogshape", "image_space", "out__length", "out64size", "outlogsize", "image_scale"], "ptr": ["later", "Ptr", "sh", "up", "cmp", "ext", "tr", "str", "xp", "depth", "pad", "rw", "inter", "src", "temp", "mount", "pty", "tty", "pp", "buf", "pointer", "shift", "addr", "p", "ref", "attr", "fp", "pt", "plug", "loc", "tmp", "dr", "inst", "code", "slice", "alloc", "trace", "ctr", "ind", "rc", "r", "pr", "pre", "address", "err", "port", "ctx", "cur", "req", "patch", "pc", "offset", "pair", "pos", "length", "ch", "proc", "br", "buffer", "per"], "bpp": ["lpp", "lbpo", "lbcp", "bpped", "lbpar", "wbpp", " bsp", "barpp", "bact", "bapc", " bppa", "sbpp", " bcp", "abpp", "lbpp", "bpps", "hpp", "fpl", "bcp", "pppa", "cpp", "brppa", "wbpps", "brpp", "bpc", "lpper", "lep", "wbppa", "brpped", "bep", " bpc", "bpl", "npp", " bpar", "ppped", "sbact", " bpped", "brmp", "dbupp", "sbsp", "brpper", "lbpc", "hppa", "bppa", "rpp", "rep", "rppa", "bpo", "lupp", "bsp", "barupp", "dbpp", "hpl", "psp", "wbupp", "bpar", "pupp", "pep", "nsp", "abpped", "cep", "lmp", "rpl", "ppl", "pact", "bapo", "dbpl", "brep", "lpped", "bapped", "abcp", "bbep", " bpo", "cpped", "brupp", " bact", "sbppa", "bupp", "nppa", "ppp", "barppa", "fupp", "cupp", "bapp", "abpar", "bbpp", "barpps", "bbmp", " bpl", "fpo", "bmp", "bpper", " bpps", "lbpped", "fpp", " bupp", "bbpper", "dbpo", "npl", "hep"], "w": ["l", "wl", "wp", "n", "g", "wa", "win", "window", "m", "temp", "iw", "b", "sw", "z", "fw", "wb", "d", "wt", "t", "c", "s", "work", "p", "wd", "we", "max", "q", "wal", "hw", "f", "o", "v", "r", "wx", "aw", "kw", "wu", "u", "ww", "h", "ew", "a", "y", "W", "ow"], "add": ["diff", "arr", "ack", "plus", "start", "len", "pad", "mult", "added", "each", "d", "shift", "last", "ad", "sum", "c", "addr", "max", "app", "push", "ac", "call", "append", "inc", "ind", "end", "apply", "att", "mod", "address", "en", "load", "Add", "read", "init", "pos", "comp", "extra", "mix", "ADD"], "xor": ["yors", "Xnor", " xors", " xOR", "exr", "xOR", "ynor", "xr", "exors", " xnor", "exore", "XOR", "xtors", "xnor", "yor", " xr", "Xors", "xtore", "xtor", " xore", "xors", "Xor", "xtr", "yOR", "exor", "xore"], "count": ["l", "parent", "base", "find", "z", "sum", "max", "ref", "act", "cc", "ac", "code", "call", "found", "v", "process", "offset", "type", "depth", "ount", "scroll", "cond", "filter", "n", "val", "key", "all", "id", "missing", "b", "i", "con", "c", "ct", "e", "cd", "f", "index", "ind", "current", "list", "cast", "col", "Count", "ch", "len", "num", "d", "coll", "size", "part", "cat", "cache", "weight", "start", "time", "p", "number", "q", "child", "name", "check", "counter", "h", "length", "y", "match"], "x": ["xp", "plus", "n", "val", "wa", "in", "ax", "xx", "xi", "m", "id", "t", "sw", "z", "b", "d", "i", "c", "ct", "s", "X", "p", "ix", "el", "e", "pe", "xs", "f", "j", "code", "call", "index", "v", "min", "content", "fx", "ctx", "r", "tx", "en", "wx", "xc", "xes", "bit", "xt", "u", "ww", "pair", "h", "rx", "on", "px", "y", "dx", "ex"], "out": ["parent", "base", " in", "again", "word", "point", "t", "pool", "block", "sum", "max", "at", "ac", "code", "call", "v", "connection", "att", "err", "init", "image", "buffer", "up", "n", "prefix", "no", "Out", "b", "c", "work", "output", "tmp", "op", "index", "r", "error", "wx", "extra", "ext", "g", "temp", "conn", "page", "data", "o", "sync", "req", "new", "OUT", "part", "copy", "a", "cache", "result", "cmd", "diff", "byte", "co", "in", "update", "doc", "line", "p", "obj", "off", "child", "inc", "name", "user", "bit", "client", "bin", "ex"]}}
{"project": "qemu", "commit_id": "4f4321c11ff6e98583846bfd6f0e81954924b003", "target": 1, "func": "static int usb_bt_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    struct USBBtState *s = (struct USBBtState *) dev->opaque;\n\n    int ret = 0;\n\n\n\n    if (!s->config)\n\n        goto fail;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_IN:\n\n        switch (p->devep & 0xf) {\n\n        case USB_EVT_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->evt, p);\n\n            break;\n\n\n\n        case USB_ACL_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->acl, p);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            ret = usb_bt_fifo_dequeue(&s->sco, p);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_OUT:\n\n        switch (p->devep & 0xf) {\n\n        case USB_ACL_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,\n\n                            usb_bt_hci_acl_complete, p->data, p->len);\n\n            break;\n\n\n\n        case USB_SCO_EP:\n\n            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,\n\n                            usb_bt_hci_sco_complete, p->data, p->len);\n\n            break;\n\n\n\n        default:\n\n            goto fail;\n\n        }\n\n        break;\n\n\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 25602, "substitutes": {"dev": ["ve", "md", "w", "info", "d", "data", "ds", "ad", "conf", "def", "dd", "priv", "ch", "ev", "die", "dom", "proc", "self", "serial", "private", "pad", "dem", "hw", "gd", "di", "device", "mod", "pro", "dm", "conn", "plug", "Dev", "rad", "od", "de", "sd", "an", "g", "v", "cam", "sh"], "p": ["exec", "pp", "pa", "ep", "np", "k", "er", "param", "i", "m", "b", "c", "pg", "parse", "parser", "d", "data", "api", "P", "py", "jp", "pe", "up", "ps", "dp", "ch", "bp", "op", "port", "proc", "press", "u", "mp", "e", "sp", "patch", "o", "pd", "pb", "process", "per", "cp", "pm", "gp", "cache", "ar", "current", "wp", "h", "part", "lp", "f", "po", "n", "tp", "ip", "t", "fp", "j", "php", "a", "v", "r", "pi", "vp", "pre", "l", "post", "pc", "ap", "g"], "s": ["sys", "w", "sr", "ns", "ts", "sq", "ps", "sync", "sis", "self", "u", "private", "es", "gs", "http", "sym", "sa", "xs", "f", "service", "fs", "n", "js", "tests", "qs", "t", "sd", "r", "ops", "native", "S", "m", "b", "c", "x", "ds", "us", "ins", "su", "is", "css", "sp", "ions", "spec", "aws", "services", "sl", "its", "g", "sh", "rs", "ses", "args", "ss", "d", "ms", "sg", "e", "has", "session", "less", "sb", "php", "full", "sf", "ssl", "cs", "sv", "i", "sw", "plugins", "o", "si", "os", "uns", "sup", "as", "ls", "y", "v", "l"]}}
{"project": "FFmpeg", "commit_id": "ae21776207e8a2bbe268e7c9e203f7599dd87ddb", "target": 0, "func": "void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n\n{\n\n    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);\n\n    AVFilterPad *dst = link->dstpad;\n\n    int i;\n\n\n\n    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);\n\n\n\n    if (!(filter_samples = dst->filter_samples))\n\n        filter_samples = avfilter_default_filter_samples;\n\n\n\n    /* prepare to copy the samples if the buffer has insufficient permissions */\n\n    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||\n\n        dst->rej_perms & samplesref->perms) {\n\n\n\n        av_log(link->dst, AV_LOG_DEBUG,\n\n               \"Copying audio data in avfilter (have perms %x, need %x, reject %x)\\n\",\n\n               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);\n\n\n\n        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,\n\n                                                          samplesref->audio->nb_samples);\n\n        link->cur_buf->pts                = samplesref->pts;\n\n        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;\n\n\n\n        /* Copy actual data into new samples buffer */\n\n        for (i = 0; samplesref->data[i]; i++)\n\n            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);\n\n\n\n        avfilter_unref_buffer(samplesref);\n\n    } else\n\n        link->cur_buf = samplesref;\n\n\n\n    filter_samples(link, link->cur_buf);\n\n}\n", "idx": 7472, "substitutes": {"link": ["lang", "flow", "band", "play", "local", "entry", "di", "ci", "check", "style", "ace", "arg", "service", "match", "code", "connection", "self", "line", "head", "user", "hip", "li", "lf", "msg", "plugin", "pack", "friend", "channel", "plug", "kick", "list", "slice", "info", "mail", "url", "loop", "linked", "comment", "zip", "lib", "path", "bridge", "rock", "back", "ip", "mm", "hack", "contact", "type", "model", "light", "group", "low", "address", "feed", "block", "lan", "sync", "ad", "co", "image", "loc", "lag", "key", "like", "post", "cell", "ck", "e", "dev", "source", "network", "Link", "frame", "set", "add", "dd", "bug", "ink", "links", "tag", "l", "call", "ack", "lock", "load", "ln", "slave"], "samplesref": ["samplesREF", "sannelsREF", "sifiersREF", "damplesdiff", "sourcesrel", " sampleslf", "tamplespart", "dampsrel", "sampsREF", "sacksref", "dampsre", "sourcesref", "sessionsref", "sampsdiff", "tampsreference", " samplesrel", "smodelsREF", " sagesRef", "sessionsreference", "sanceshard", "sampsRef", "tamplesRef", "lampsob", "simsdiff", "samplesre", " sannelshard", "tampsREF", "sampleREF", "sacksdiff", "simensreference", "damplesREF", "samplelf", " sampleshard", "sificationsrel", "sampsre", "tamplesREF", "simenslf", " samplesREF", "sificationsref", " sampsreference", "sessionsREF", "damplesre", "tampsref", " sagesREF", "dampsREF", "lampsalt", "sancesrel", "lamplesob", " sampsref", " samplesreference", "sampsrec", "saleslf", "damplesreference", "tamplesrel", "sizesRef", "samplesRef", "sipesreference", "salesref", "sourcesRef", "sessionsob", "sagesRef", "samplerel", "samplere", " salesRef", "samplespart", "dampsRef", "sipsRef", "tampleslf", "sampleob", "sipsreference", "sacksRef", "sifiersrel", "sipsREF", "lamplesRef", "sampleref", "sagesREF", "sampleshard", "tampsrel", "simsreference", "sessionsrel", "samplepart", "lamplesalt", " saleslf", "sampspart", "sipesRef", "lamplesref", " samplesRef", "damplesref", "sancesref", "samplesob", "tamplesreference", "sifiersRef", "samplesrec", " salesref", "smodelsref", " sampsREF", "salesRef", "damplesRef", "sacksrel", "lampsref", "sacksreference", "sipesREF", "dampsdiff", "sacksrec", "samplealt", "sificationsre", "sannelshard", "sampsreference", "sizesref", " sampsRef", "sifiersdiff", "sampleRef", "sourcesREF", "sampsalt", "sancesREF", "sannelsrel", "samplesreference", "sampsrel", "simsRef", " sannelsREF", "sipesref", "tampsrec", "sampleslf", "sagesref", "sipsref", "damplesrel", "sampsref", "samplereference", "tampsRef", "smodelsRef", " sannelsrel", "sifiersreference", "sessionsRef", "simenspart", "simensref", "lampsRef", " sagesref", "dampsref", "tamplesref", "sizeslf", "simsref", "sampsob", "sessionsrec", "samplesalt", " sannelsref", "smodelsrel", "sifiersref", "sannelsref", "samplesdiff", "sifiershard", "tampspart", "tampslf", "sificationsreference", "sessionsalt", "dampsreference", "tamplesrec", "sampslf", "samplesrel"], "filter_samples": ["filter_samps", "filter_golutions", "filter_pources", "filter_servicesamps", "filter_saves", "filter_vipes", "filter_pamples", "filter_sounds", "filter_symample", "filter_gages", "filter_solutions", "filter_bamps", "filter_scaves", "filter_hamps", "filter_nones", "filter_tamples", "filter_tages", "filter_nources", "filter_vamps", "filter_bones", "filter_haves", "filter_bamples", "filter_sample", "filter_panguages", "filter_insanguages", "filter_servicesolutions", "filter_insamps", "filter_namples", "filter_bipes", "filter_tolutions", "filter_insamples", "filter_symamps", "filter_servicesages", "filter_pipes", "filter_pounds", "filter_symanguages", "filter_bamp", "filter_namp", "filter_sones", "filter_paves", "filter_scamps", "filter_lamp", "filter_nipes", "filter_sipes", "filter_gamples", "filter_pamps", "filter_asources", "filter_hounds", "filter_asamples", "filter_vamples", "filter_lamps", "filter_lipes", "filter_scamples", "filter_sanguages", "filter_lamples", "filter_symamples", "filter_asipes", "filter_hamples", "filter_sources", "filter_asamps", "filter_pample", "filter_vones", "filter_gamps", "filter_scounds", "filter_namps", "filter_sages", "filter_insample", "filter_tamps", "filter_servicesamples", "filter_samp"], "dst": ["mdsts", "adsp", "dput", "Dst", "drct", "drbl", "dtd", "dbl", "fsts", "madtd", "fdst", "nost", "Dost", "mdsp", "adsc", "dsc", "sdput", " dost", "madst", "fput", "nnd", "Dnd", "Dsts", "pdST", "pdsts", "madput", "dsp", "fST", "dnd", "dST", "dsts", "datct", "mdst", " dnd", "adsts", "pdst", " dput", "fst", " dsts", "nst", " dsc", " dsp", "bsts", "dft", "sdst", "sdost", " dft", "adst", "mdsc", "sdtd", "drst", " dct", " dbl", "sdsts", "fdost", "pdput", "madsts", "datput", "datst", "fdft", "bput", "sdsc", "fdsc", "sdft", "dost", "bst", "btd", "sdbl", "datsc", "bST", "nsts", "dct", "drsts", "sdct"], "i": ["gi", "ti", "v", "id", "I", "a", "di", "ci", "ji", "ni", "xi", "b", "si", "io", "x", "ri", "info", "bi", "m", "image", "qi", "in", "ix", "l", "f", "pi", "yi", "phi", "d", "ii", "iu", "j", "loop", "ai", "init", "u", "e", "uri", "t", "k", "n", "multi", "mi", "ini", "ie", "p", "h", "mini", "z", "line", "oi", "hi", "c", "ip", "y", "li", "fi", "index", "zi", "mu", "ui"]}}
{"project": "qemu", "commit_id": "2884cf5b934808f547b5268a51be631805c25857", "target": 0, "func": "static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,\n\n                                void *opaque)\n\n{\n\n    VirtualConsole *vc = opaque;\n\n    GtkDisplayState *s = vc->s;\n\n    InputButton btn;\n\n\n\n    /* implicitly grab the input at the first click in the relative mode */\n\n    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&\n\n        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {\n\n        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),\n\n                                       TRUE);\n\n        return TRUE;\n\n    }\n\n\n\n    if (button->button == 1) {\n\n        btn = INPUT_BUTTON_LEFT;\n\n    } else if (button->button == 2) {\n\n        btn = INPUT_BUTTON_MIDDLE;\n\n    } else if (button->button == 3) {\n\n        btn = INPUT_BUTTON_RIGHT;\n\n    } else {\n\n        return TRUE;\n\n    }\n\n\n\n    qemu_input_queue_btn(vc->gfx.dcl.con, btn,\n\n                         button->type == GDK_BUTTON_PRESS);\n\n    qemu_input_event_sync();\n\n    return TRUE;\n\n}\n", "idx": 20434, "substitutes": {"widget": ["view", "ui", "input", "plugin", "ou", "poll", "pipe", "win", "ac", "owl", "cli", "q", "client", "wp", "ch", "gui", "window", "w", "draw", "fl", "fw", "ogg", "console", "wx", "util", "lib", "Widget"], "button": ["delete", "bc", "target", "attribute", "class", "next", "off", "event", "config", "key", "connection", "cell", "click", "bug", "data", "field", "shift", "submit", "trigger", "select", "type", "password", "object", "option", "text", "style", "lock", "component", "current", "code", "atom", "title", "channel", "element", "action", "ui", "fb", "patch", "p", "or", "number", "comment", "open", "module", "gui", "error", "page", "callback", "html", "bot", "api", "command", "span", "icon", "focus", "press", "category", "loop", "input", "color", "feature", "plugin", "down", "Button", "label", "ctrl", "timeout", "pin", "document", "pull", "flag", "touch", "editor", "skip", "att", "toggle", "url"], "opaque": ["OPaque", "opaques", "OPchid", "OPaques", "oppac", "Opaqu", " opchid", "oppaque", "opaqu", "obaques", "opchid", "Opacity", "obaque", "opacity", "OPacity", "OPac", "opac", " opacity", " opaqu", "obac", "Opaque", "Opchid", "OPaqu", "oppaques"], "vc": ["lc", "bc", "serv", "conn", "nv", "vt", "vim", "input", "cv", "bb", "vg", "pc", "ci", "win", "sys", "nc", "ac", "cs", "wl", "cf", "ctrl", "tc", "iw", "cli", "rc", "c", "ctx", "wp", "ch", "gui", "dc", "ic", "service", "gc", "vv", "fw", "ogg", "VC", "wx", "util", "qt", "vp", "hw", "voc", "oc", "cu", "gb"], "s": ["status", "sv", "i", "sb", "e", "space", "es", "qs", "sie", "sl", "fs", "g", "ses", "xs", "d", "sis", "site", "services", "f", "sys", "less", "m", "args", "storage", "state", "ssl", "os", "p", "cs", "screen", "o", "sync", "is", "stats", "sg", "c", "settings", "js", "spec", "self", "si", "b", "w", "session", "S", "ns", "sf", "south", "h", "secondary", "server", "scope", "ss", "states"], "btn": ["lc", "bc", "sb", "fc", "txt", "focus", "bolt", "jp", "config", "ct", "mot", "nn", "yout", "input", "butt", "kt", "fb", "bb", "token", "ou", "bp", "fp", "Button", "click", "t", "nc", "cmd", "bg", "affle", "bug", "bt", "tick", "ctrl", "wb", "cli", "kn", "c", "cb", "kk", "tag", "wp", "cn", "dt", "colour", "b", "dc", "rl", "wt", "gui", "touch", "lvl", "fl", "qa", "src", "tn", "callback", "batch", "wx", "ko", "bot", "qt", "typ", "toggle", "ctl"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yvu9_to_yuy2)(const uint8_t *src1, const uint8_t *src2, const uint8_t *src3,\n\n                                        uint8_t *dst,\n\n                                        long width, long height,\n\n                                        long srcStride1, long srcStride2,\n\n                                        long srcStride3, long dstStride)\n\n{\n\n    x86_reg x;\n\n    long y,w,h;\n\n    w=width/2; h=height;\n\n    for (y=0;y<h;y++) {\n\n        const uint8_t* yp=src1+srcStride1*y;\n\n        const uint8_t* up=src2+srcStride2*(y>>2);\n\n        const uint8_t* vp=src3+srcStride3*(y>>2);\n\n        uint8_t* d=dst+dstStride*y;\n\n        x=0;\n\n#if COMPILE_TEMPLATE_MMX\n\n        for (;x<w-7;x+=8) {\n\n            __asm__ volatile(\n\n                PREFETCH\"   32(%1, %0)          \\n\\t\"\n\n                PREFETCH\"   32(%2, %0)          \\n\\t\"\n\n                PREFETCH\"   32(%3, %0)          \\n\\t\"\n\n                \"movq      (%1, %0, 4), %%mm0   \\n\\t\" /* Y0Y1Y2Y3Y4Y5Y6Y7 */\n\n                \"movq         (%2, %0), %%mm1   \\n\\t\" /* U0U1U2U3U4U5U6U7 */\n\n                \"movq         (%3, %0), %%mm2   \\n\\t\" /* V0V1V2V3V4V5V6V7 */\n\n                \"movq            %%mm0, %%mm3   \\n\\t\" /* Y0Y1Y2Y3Y4Y5Y6Y7 */\n\n                \"movq            %%mm1, %%mm4   \\n\\t\" /* U0U1U2U3U4U5U6U7 */\n\n                \"movq            %%mm2, %%mm5   \\n\\t\" /* V0V1V2V3V4V5V6V7 */\n\n                \"punpcklbw       %%mm1, %%mm1   \\n\\t\" /* U0U0 U1U1 U2U2 U3U3 */\n\n                \"punpcklbw       %%mm2, %%mm2   \\n\\t\" /* V0V0 V1V1 V2V2 V3V3 */\n\n                \"punpckhbw       %%mm4, %%mm4   \\n\\t\" /* U4U4 U5U5 U6U6 U7U7 */\n\n                \"punpckhbw       %%mm5, %%mm5   \\n\\t\" /* V4V4 V5V5 V6V6 V7V7 */\n\n\n\n                \"movq            %%mm1, %%mm6   \\n\\t\"\n\n                \"punpcklbw       %%mm2, %%mm1   \\n\\t\" /* U0V0 U0V0 U1V1 U1V1*/\n\n                \"punpcklbw       %%mm1, %%mm0   \\n\\t\" /* Y0U0 Y1V0 Y2U0 Y3V0*/\n\n                \"punpckhbw       %%mm1, %%mm3   \\n\\t\" /* Y4U1 Y5V1 Y6U1 Y7V1*/\n\n                MOVNTQ\"          %%mm0,  (%4, %0, 8)    \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 8(%4, %0, 8)    \\n\\t\"\n\n\n\n                \"punpckhbw       %%mm2, %%mm6   \\n\\t\" /* U2V2 U2V2 U3V3 U3V3*/\n\n                \"movq     8(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm6, %%mm0   \\n\\t\" /* Y U2 Y V2 Y U2 Y V2*/\n\n                \"punpckhbw       %%mm6, %%mm3   \\n\\t\" /* Y U3 Y V3 Y U3 Y V3*/\n\n                MOVNTQ\"          %%mm0, 16(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 24(%4, %0, 8)   \\n\\t\"\n\n\n\n                \"movq            %%mm4, %%mm6   \\n\\t\"\n\n                \"movq    16(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm5, %%mm4   \\n\\t\"\n\n                \"punpcklbw       %%mm4, %%mm0   \\n\\t\" /* Y U4 Y V4 Y U4 Y V4*/\n\n                \"punpckhbw       %%mm4, %%mm3   \\n\\t\" /* Y U5 Y V5 Y U5 Y V5*/\n\n                MOVNTQ\"          %%mm0, 32(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 40(%4, %0, 8)   \\n\\t\"\n\n\n\n                \"punpckhbw       %%mm5, %%mm6   \\n\\t\"\n\n                \"movq    24(%1, %0, 4), %%mm0   \\n\\t\"\n\n                \"movq            %%mm0, %%mm3   \\n\\t\"\n\n                \"punpcklbw       %%mm6, %%mm0   \\n\\t\" /* Y U6 Y V6 Y U6 Y V6*/\n\n                \"punpckhbw       %%mm6, %%mm3   \\n\\t\" /* Y U7 Y V7 Y U7 Y V7*/\n\n                MOVNTQ\"          %%mm0, 48(%4, %0, 8)   \\n\\t\"\n\n                MOVNTQ\"          %%mm3, 56(%4, %0, 8)   \\n\\t\"\n\n\n\n                : \"+r\" (x)\n\n                : \"r\"(yp), \"r\" (up), \"r\"(vp), \"r\"(d)\n\n                :\"memory\");\n\n        }\n\n#endif\n\n        for (; x<w; x++) {\n\n            const long x2 = x<<2;\n\n            d[8*x+0] = yp[x2];\n\n            d[8*x+1] = up[x];\n\n            d[8*x+2] = yp[x2+1];\n\n            d[8*x+3] = vp[x];\n\n            d[8*x+4] = yp[x2+2];\n\n            d[8*x+5] = up[x];\n\n            d[8*x+6] = yp[x2+3];\n\n            d[8*x+7] = vp[x];\n\n        }\n\n    }\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__(\n\n            EMMS\"       \\n\\t\"\n\n            SFENCE\"     \\n\\t\"\n\n            ::: \"memory\"\n\n        );\n\n#endif\n\n}\n", "idx": 10233, "substitutes": {"src1": ["rc2", "st1", " src01", "src01", "rc1", "source1", "source01", "source3", "loc3", " srcA", "st3", "sourceA", "loc1", "srcA", "stA", "rc3", "loc2", "st01"], "src2": ["const02", "src0", "rc02", "srcTwo", "rc2", "const2", "sort02", "src02", " srcTwo", "source02", " src0", "sort0", "sort2", "source2", "sourceTwo", "constTwo", " src02", "rc0"], "src3": ["rc2", "source5", "rc1", "source1", "rc53", "source2", "source3", "source53", "rc5", "src5", "src53", " src5", " src53", "rc3"], "dst": [" dsc", "dost", " dconst", "rdst", "Dsc", "dsc", "rdsts", "Dsts", "dconst", "pdost", " dsts", " dST", "pdST", "Dst", "Dconst", "dsts", "pdst", "rdconst", "dST", "rdsc", " dost", "pdsc"], "height": ["rank", "dim", "sh", "img", "window", "z", "resolution", "fw", "density", "work", "max", "layout", "thin", "style", "gravity", "padding", "Height", "th", "size", "shape", "hold", "stroke", "v", "input", "ty", "hd", "crop", "length", "image", "inches", "depth", "dy", "direction"], "srcStride1": ["srcScrite3", "srcShride1", "srcScrite1", "srcStriteOne", "srcStide1", "srcStrue1", "srcStri1", "srcStrueOne", "srcStrip2", "srcShrue1", "srcStide2", "srcScride3", "srcStrite2", "srcScride2", "srcScrite2", "srcShrideOne", "srcStrip1", "srcStri2", "srcShrueOne", "srcStide3", "srcShride2", "srcShride3", "srcStideOne", "srcStrite1", "srcStrue2", "srcShrue2", "srcStri3", "srcStrite3", "srcStrue3", "srcScride1", "srcStrip3", "srcStrideOne", "srcShrue3"], "srcStride2": ["srcStide8", "srcStrate1", "srcScrite1", "srcStrip52", "srcScride52", "srcStide1", "srcStrid4", "srcStrid2", "srcStrid1", "srcStrip2", "srcStriteTwo", "srcScrite4", "srcScride4", "srcSTrateTwo", "srcStide2", "srcStrite2", "srcScride2", "srcScrite2", "srcScrite52", "srcStrite52", "srcStrip4", "srcStride52", "srcSTride1", "srcSTride8", "srcSTrate2", "srcStideTwo", "srcStrateTwo", "srcSTrideTwo", "srcSTrate1", "srcStrite1", "srcSTride2", "srcStrideTwo", "srcStrate8", "srcStride8", "srcScride1", "srcStrite4", "srcStride4", "srcSTrate8", "srcStrid52", "srcStrate2", "srcStrip1", "srcStrite8"], "srcStride3": ["srcScrite7", "srcStrideN", "srcstrideThree", "srcStrlN", "srcStrideThree", "srcStide1", "srcStride7", "srcScride7", "srcsterve1", "srcStriteN", "srcStriteThree", "srcStrl3", "srcsterveThree", "srcStrl7", "srcsterve2", "srcStide2", "srcScride3", "srcStrite2", "srcStideThree", "srcScrite2", "srcScride2", "srcstride2", "srcStrl2", "srcStri2", "srcstride1", "srcSterve3", "srcStriN", "srcStide3", "srcSterveThree", "srcStrite7", "srcScriteN", "srcStrite1", "srcstride3", "srcStri3", "srcsterve3", "srcScrideN", "srcStrite3", "srcSterve2", "srcSterve1", "srcStri7", "srcScrite3"], "dstStride": ["dstShrate", "dstStide", "dstSTrb", "dstShrite", "dstRestride", "dstStrate", "dstShride", "drdStride", "dststrib", "dstRestrate", "drdStide", "drdSTide", "dstStrib", "dstStrite", "dstSTide", "drdStrate", "dstStrb", "dstSTrite", "dststrb", "drdSTrate", "dstSTride", "dndstride", "dstSTrib", "dndStride", "dstRestrb", "dststride", "drdSTrb", "dndstrate", "dstShrib", "dststrate", "dstRestide", "dststide", "dndstrib", "dststrite", "dstSTrate", "dndStrite", "dndStrib", "dndstrite", "dndStrate", "drdStrb", "drdSTride"], "x": ["l", "ady", "xp", "n", "g", "ax", "key", "xx", "id", "xi", "m", "t", "z", "b", "my", "i", "k", "con", "c", "s", "X", "p", "ix", "time", "e", "status", "ct", "python", "work", "cross", "xs", "q", "step", "xxx", "f", "j", "code", "index", "v", "yx", "sync", "zx", "fx", "ctx", "tx", "wx", "xc", "u", "ww", "xy", "rx", "px", "on", "sex", "image", "dx", "ex"], "y": ["ym", "ady", "yt", "oy", "n", "g", "ry", "ny", "yer", "t", "ey", "z", "vy", "b", "i", "ye", "c", "ys", "cy", "p", "e", "yi", "iy", "yang", "ay", "lat", "zy", "f", "yy", "sy", "j", "gy", "py", "iny", "sky", "ky", "yl", "yd", "hy", "Y", "ty", "ies", "yr", "yu", "yan", "year", "yah", "ya", "yn", "wy", "ity", "dy", "yo"], "w": ["wid", "l", "wn", "wl", "wp", "n", "g", "wa", "win", "m", "wh", "sw", "t", "z", "wt", "wb", "fw", "b", "c", "s", "p", "we", "e", "q", "hw", "v", "r", "wx", "kw", "aw", "u", "ww", "ew", "W", "weight", "wd"], "h": ["l", "hi", "sh", "ht", "n", "g", "ph", "wa", "hh", "m", "t", "b", "z", "i", "c", "s", "p", "hm", "e", "q", "hw", "f", "v", "r", "hs", "u", "H", "ch", "W", "rh", "uh"], "yp": ["lp", "dp", "ym", "sp", "yt", "wp", "pg", "xp", "iw", "wb", "pp", "cp", "ys", "pb", "fp", "ep", "np", "pe", "pt", "pm", "op", "yy", "dr", "omp", "mp", "py", "eps", "pr", "yd", "jp", "tp", "xt", "yu", "px", "ip", "ps", "yn", "dep", "typ", "cy"], "up": ["cr", "uf", "sp", "ui", "uph", "wp", "img", "xp", "in", "ul", "pp", "cp", "upp", "pt", "op", "upt", "mp", "ups", "uv", "sup", "aw", "u", "ps", "out", "url", "ch", "down", "um", "uc"], "vp": ["lp", "dp", "vs", "dq", "sp", "wp", "vl", "xp", "sv", "lv", "pp", "vt", "pb", "pd", "fp", "np", "gp", "pm", "pn", "mp", "uv", "eps", "pu", "tp", "jp", "vr", "vg", "vv", "vc"], "d": ["dp", "ld", "dim", "di", "dh", "ds", "n", "g", "m", "dt", "b", "t", "z", "c", "data", "bd", "p", "pd", "e", "cd", "dist", "dn", "f", "dl", "db", "dat", "v", "md", "yd", "dd", "dc", "sd", "dm", "dy", "dx", "D"]}}
{"project": "qemu", "commit_id": "384acbf46b70edf0d2c1648aa1a92a90bcf7057d", "target": 0, "func": "BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,\n\n        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,\n\n        BlockDriverCompletionFunc *cb, void *opaque, int type)\n\n{\n\n    struct qemu_paiocb *acb;\n\n\n\n    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);\n\n    if (!acb)\n\n        return NULL;\n\n    acb->aio_type = type;\n\n    acb->aio_fildes = fd;\n\n    acb->ev_signo = SIGUSR2;\n\n    acb->async_context_id = get_async_context_id();\n\n\n\n    if (qiov) {\n\n        acb->aio_iov = qiov->iov;\n\n        acb->aio_niov = qiov->niov;\n\n    }\n\n    acb->aio_nbytes = nb_sectors * 512;\n\n    acb->aio_offset = sector_num * 512;\n\n\n\n    acb->next = posix_aio_state->first_aio;\n\n    posix_aio_state->first_aio = acb;\n\n\n\n    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);\n\n    qemu_paio_submit(acb);\n\n    return &acb->common;\n\n}\n", "idx": 404, "substitutes": {"bs": ["ob", "base", "http", "bh", "ss", "ba", "sb", "lb", "eb", "BS", "bid", "bc", "pb", "boot", "fps", "bis", "rb", "plugins", "bits", "ls", "ses", "ds", "bas", "ps", "gs", "bf", "ns", "abc", "bi", "vs", "bos", "sys", "gb", "obj", "bb", "blocks", "lib", "fb", "b", "os", "bytes", "fs", "db"], "fd": ["flow", "fc", "ff", "lambda", "da", "dd", "pd", "FD", "fa", "dB", "d", "dl", "lf", "fff", "fn", "buf", "draft", "sf", "fp", "df", "cond", "ds", "func", "fe", "bf", "dc", "fif", "fi", "f", "ffff", " fid", "fx", "handler", "fee", "fb", "ecd", "nd", "fs"], "sector_num": ["ector_name", " sector_count", "sector_count", "sectorPname", "section_name", "section_len", "sectorPnum", "section_num", "ector_offset", "sector_len", "section_id", "ector_id", "sector_id", " sector_name", "sectorPcount", "sector_name", " sector_len", "sectorPlen", "sector_offset", "ector_num"], "qiov": ["uuno", "kiov", "uiov", "kmus", "sqliv", "qoby", "kliv", "qquno", "sqdyl", " qilo", "qqoren", "quilo", "quliv", "filo", "fiov", "qurolet", "uoren", "qudyl", "quiov", "sqiov", "qgio", "quoby", "qumus", "quuno", " qgio", "qdyl", "qqiov", " qliv", "frolet", "qqilo", "sqgio", " qdyl", "krolet", "qmus", " qmus", " qrolet", "foby", "uilo", "qrolet", "qoren", "quoren", " qoby", "qliv", "qugio", "quno", "qilo"], "nb_sectors": ["nb_pector", "nb_perets", "nb_gectors", "nb_peors", "nb_psegments", "nb_tector", "nb_gector", "nb_vegments", "nb_teors", "nb_pegments", "nb_sector", "nb_vector", "nb_gegments", "nb_segments", "nb_sections", "nb_gerets", "nb_veors", "nb_psectors", "nb_vectors", "nb_verets", "nb_vecs", "nb_serets", "nb_psecs", "nb_pectors", "nb_vections", "nb_tectors", "nb_seors", "nb_secs", "nb_psections", "nb_tegments"], "cb": ["ob", "call", "orb", "ctx", "obb", "sb", "acl", "CB", "hub", "eb", "rob", "bc", "callback", "buff", "pb", "fn", "rb", "fp", "sync", "func", "cod", "bf", "function", "abc", "c", "cv", "wb", "unc", "ctrl", "cd", "gb", "bb", "fb", "b", "cmp", "cp", "cf", "abb", "db", "xb"], "opaque": ["opacity", "opaques", "OPacity", "hopaques", "pac", "compacity", " opac", "opac", "ipaques", "OPace", "opaco", "opace", " opacity", "compace", "hopaque", "ipaque", "compaque", "OPaque", "hopc", "ipac", "compaco", " opace", "ipacity", "pacity", " opaques", "ipc", "hopac", "pc", " opaco", "OPaco", "opc", "paque", " opc"], "type": ["unit", "call", "name", "time", "key", "pe", "method", "ype", "url", "format", "id", "pb", "op", "ocol", "ty", "py", "y", "year", "pos", "tp", "code", "Type", "style", "func", "function", "address", "block", "p", "role", "state", "f", "length", "col", "attr", "token", "o", "pc", "phase", "prefix", "plugin", "t", "types", "site", "error", "port", "path", "TYPE", "typ", "ity"], "acb": ["acbi", "acecb", "akmb", "akk", "maca", "acf", "acl", "macn", "acefb", "accb", "acce", "icbb", "acp", "ecp", "acmb", " acbe", "ack", "ancbe", "ancsb", "actf", "adb", "anca", " acr", "aceb", "accr", "ocmb", "ancfb", "ecfb", "eck", "ocbar", " acbar", "acfb", "sacp", "macb", " acl", "acB", "adbb", "ecb", "acebb", "macban", "ocsb", "ocbb", "ocb", " accb", "ecv", "acban", "accbi", "macbb", "accbe", "sacbe", "macf", "acsb", "aca", " acsb", "akr", "ACsb", " ace", " acbi", "accfb", "ancr", " acfb", "akn", "ACa", "admb", "ocfb", "ancb", "accf", "macB", "sacbi", "ake", "sacb", " acv", " acbb", "accmb", "ecmb", "acca", "akb", " ack", "accn", "icb", "icB", "acv", "actn", "actb", "rcf", " acban", "oca", "ecsb", "aksb", "accv", "accp", "acbe", "ocbd", "accbb", "acbb", "rcbb", " acf", " acmb", "akfb", "acbd", "ocl", "accbar", "ACl", "acck", "ACb", "accsb", " acp", "occb", "ica", "acbar", "rcb", "accB", " aca", "acn", "adsb", "actban", "ecbb", "acr", "akbb", "ACbd", " acbd", " acn", "ACbb", "ace", "ACfb"]}}
{"project": "FFmpeg", "commit_id": "3932ccc472ad4f4d370dcfc1c2f574b0f3acb88c", "target": 1, "func": "static void diff_pixels_altivec(int16_t *restrict block, const uint8_t *s1,\n\n                                const uint8_t *s2, int stride)\n\n{\n\n    int i;\n\n    vec_u8 perm1 = vec_lvsl(0, s1);\n\n    vec_u8 perm2 = vec_lvsl(0, s2);\n\n    const vec_u8 zero = (const vec_u8)vec_splat_u8(0);\n\n    vec_s16 shorts1, shorts2;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        /* Read potentially unaligned pixels.\n\n         * We're reading 16 pixels, and actually only want 8,\n\n         * but we simply ignore the extras. */\n\n        vec_u8 pixl  = vec_ld(0,  s1);\n\n        vec_u8 pixr  = vec_ld(15, s1);\n\n        vec_u8 bytes = vec_perm(pixl, pixr, perm1);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts1 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the same for the second block of pixels.\n\n        pixl  = vec_ld(0,  s2);\n\n        pixr  = vec_ld(15, s2);\n\n        bytes = vec_perm(pixl, pixr, perm2);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts2 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the subtraction.\n\n        shorts1 = vec_sub(shorts1, shorts2);\n\n\n\n        // Save the data to the block, we assume the block is 16-byte aligned.\n\n        vec_st(shorts1, 0, (vec_s16 *)block);\n\n\n\n        s1    += stride;\n\n        s2    += stride;\n\n        block += 8;\n\n\n\n        /* The code below is a copy of the code above...\n\n         * This is a manual unroll. */\n\n\n\n        /* Read potentially unaligned pixels.\n\n         * We're reading 16 pixels, and actually only want 8,\n\n         * but we simply ignore the extras. */\n\n        pixl  = vec_ld(0,  s1);\n\n        pixr  = vec_ld(15, s1);\n\n        bytes = vec_perm(pixl, pixr, perm1);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts1 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the same for the second block of pixels.\n\n        pixl  = vec_ld(0,  s2);\n\n        pixr  = vec_ld(15, s2);\n\n        bytes = vec_perm(pixl, pixr, perm2);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts2 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the subtraction.\n\n        shorts1 = vec_sub(shorts1, shorts2);\n\n\n\n        // Save the data to the block, we assume the block is 16-byte aligned.\n\n        vec_st(shorts1, 0, (vec_s16 *)block);\n\n\n\n        s1    += stride;\n\n        s2    += stride;\n\n        block += 8;\n\n    }\n\n}\n", "idx": 8103, "substitutes": {"block": ["Block", "base", "name", "row", "pack", "time", "clean", "header", "position", "large", "bin", "copy", "square", "channel", "check", "word", "device", "blocking", "inv", "style", "pixel", "sync", "bit", "image", "mask", "unit", "window", "cl", "num", "offset", "version", "length", "byte", "number", "buffer", "all", "len", "col", "random", "clock", "section", "error", "full", "lock", "blocks", "batch", "frame", "pos", "line", "level", "none", "off", "ip", "range", "type", "page", "label", "user", "bl", "broad", "cache", "size"], "s1": ["ks101", "sone", "S127", "ses1", "ss4", "s101", "ks2", "S11", "gs1", "ps2", "sesONE", "gs2", "fone", "sin001", "ssone", "s127", " s11", "ses11", "f4", "s91", "ss2", "f1", "ss11", "f101", "sinONE", "ses2", "sp2", "fONE", "ss1", "ks001", "s001", "S2", "ss127", "sp5", "ss81", "ss91", "ses001", "rs1", "ps1", "pone", "site11", "s5", "S81", "S001", " s91", "s4", "s15", "s81", "S15", "ss01", " sA", "rs01", "sin1", "site127", "p4", "sp15", "S5", "f001", "p1", "gs001", "site1", "gs4", " s15", "s11", "SA", "rs91", "sA", "S4", "sONE", "ps101", "p2", " s5", "S1", "f2", "ps001", "sesA", "site81", "sp1", "ks1", "sin2", " s01", "rs2", "s01"], "s2": ["c5", "s20", " svec", "d2", "ks2", "d14", "south14", "S02", "Svec", "gs2", "inII", "size2", "ctwo", "s02", "gs\n", " s92", "p5", "size7", "d72", "sII", "in2", " s\n", "f1", "s92", "ksTwo", "p02", "s14", "cs72", "S2", "s72", "f7", " s0", "s7", "in02", " sTwo", "s56", "S\n", " s14", "size82", "f82", "south2", "f0", "cs2", "d22", "s5", "sTwo", "south1", "ptwo", " s82", "s4", " s22", "p62", "ks20", " s20", "d92", "c4", " s72", " sII", "svec", "stwo", "in56", "p4", "s62", "gsvec", "p1", " s4", " s56", "fTwo", " s62", " s02", "cs22", "south92", "cs1", "c2", "s82", "p2", "size0", "s\n", "s0", " s5", "S1", "s22", "S62", "f20", " s7", "f2", "d1", " stwo", "ks1"], "stride": ["drided", "arrided", "STRider", "STRidi", "shrider", "sprided", "striding", " strider", " strite", "privides", "STRide", "strided", "strider", "privise", "prividing", "STRip", "brided", "spriding", "sprince", "shride", "dividing", "arrince", " strance", "drance", " strided", " striding", "privide", "briding", "stridi", "arride", "strip", "bride", "strance", "brance", "dride", "strides", "divides", " stridi", " strides", " strip", "shridi", "spride", "brite", "strise", "strince", "shrip", "brince", "strite", "divide", "drite", "arriding", "divise", " strise"], "i": ["uni", "gi", "o", "ti", "v", "wei", "I", "a", "chi", "di", "ci", "ji", "ni", "x", "xi", "si", "io", "b", "ri", "abi", "info", "bi", "qi", "l", "f", "pi", "yi", "phi", "adi", "j", "iu", "ii", "d", "cli", "ai", "u", "e", "ami", "uri", "ori", "k", "n", "mi", "ini", "ie", "p", "eni", "pos", "oi", "hi", "c", "ip", "li", "fi", "index", "zi", "mu", "ui"], "shorts1": ["ghapes2", "shocksOne", "shocks1", "shortsOne", "shorter2", "shorts01", "short81", "howorters2", "ghorts9", " shorters2", " shorts31", "shortsone", "phapes0", "horts81", "hortsOne", "shints1", "shessions01", "hort1", "cliftsOnce", "shintsone", "shifts100", "shorts9", "shorter1", "shorters2", "shorts81", "hintsone", " shports1", "shocks81", "shorters1", "short4", "hints2", "clifts01", " shorts4", "phorts0", "shortsOnce", "ghapes9", "shores2", " shorters4", "shports01", "shports0", "shapesone", "shorter9", "shportsOnce", "ghapes1", " shorts100", "hortsone", "horts0", "phorts1", "howorts2", "shresses1", "hort81", "shresses31", "shports100", "shportsone", "clortsOnce", "clorts1", "shports2", "shapes1", "shoresOne", "ghorts1", "shores81", "shorts4", " shports31", "hortOne", "shorterone", "shresses100", "horts2", "howorts4", "hints1", "shifts01", "phorts2", "ghortsone", "shessions1", "howorters1", "shapes2", "shports1", "shortone", "shints2", "horts1", "hort0", "shorts31", "ghapesone", "howorts1", "shiftsOnce", "howorters4", "shorters4", "clifts1", "phapes2", "shifts1", "shports4", "shapes9", "shortOne", "shapes0", "hort2", "shocks2", "phapes1", "shores1", "short1", "clorts01", "short0", "ghorts2", "shports31", "short2", "shifts31", "shessionsOnce", "shorters0", " shports100", " shorters1", "shorts0", "shorts100", "short9"], "shorts2": ["shresses0", "chorts2", "shordsTwo", "shorter2", " shorttwo", " shortstwo", "swirts4", "chports22", "shports02", "horts02", "shifts2", "hort1", "shorter1", "chorts1", "shorters2", "swirts52", "shportsTwo", "shresses4", "shops4", "shorters1", "short4", "swirts2", "shresses22", "shords2", "shirts52", "shresses2", "shorts6", "short02", "sworts4", " shortsTwo", "hort4", "shorttwo", "shports0", "shapes4", "sworts52", "chports6", "shops2", "shirts2", "shports2", "shops1", "shortsTwo", "chports0", "shiftstwo", "shorts4", "shiftsTwo", "horts2", "hort02", "shports22", "sworts2", "shapes2", "shports1", "horts1", "chorts4", "horts4", "shords52", "shords4", "shorters4", " short2", "shorts52", "shifts1", "shports4", "shortTwo", "shapes0", "shirts4", "shortertwo", "hort2", "shorts22", "shports6", "shops02", "shorterTwo", "shports52", "short1", "chports4", "shapes22", "chports1", "chorts0", "short2", " short1", "short6", "swortsTwo", "chports2", "shortstwo", " shortTwo", "shorters6", "shorts02", "chorts6", "chorts22", "shorts0", "swirtsTwo", "shirtsTwo"]}}
{"project": "FFmpeg", "commit_id": "8155233413540c63e53a620ff5734fb4b0635611", "target": 1, "func": "static int decode_header(MPADecodeContext *s, UINT32 header)\n\n{\n\n    int sample_rate, frame_size, mpeg25, padding;\n\n    int sample_rate_index, bitrate_index;\n\n    if (header & (1<<20)) {\n\n        s->lsf = (header & (1<<19)) ? 0 : 1;\n\n        mpeg25 = 0;\n\n    } else {\n\n        s->lsf = 1;\n\n        mpeg25 = 1;\n\n    }\n\n    \n\n    s->layer = 4 - ((header >> 17) & 3);\n\n    /* extract frequency */\n\n    sample_rate_index = (header >> 10) & 3;\n\n    sample_rate = mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25);\n\n    if (sample_rate == 0)\n\n        return 1;\n\n    sample_rate_index += 3 * (s->lsf + mpeg25);\n\n    s->sample_rate_index = sample_rate_index;\n\n    s->error_protection = ((header >> 16) & 1) ^ 1;\n\n\n\n    bitrate_index = (header >> 12) & 0xf;\n\n    padding = (header >> 9) & 1;\n\n    //extension = (header >> 8) & 1;\n\n    s->mode = (header >> 6) & 3;\n\n    s->mode_ext = (header >> 4) & 3;\n\n    //copyright = (header >> 3) & 1;\n\n    //original = (header >> 2) & 1;\n\n    //emphasis = header & 3;\n\n\n\n    if (s->mode == MPA_MONO)\n\n        s->nb_channels = 1;\n\n    else\n\n        s->nb_channels = 2;\n\n    \n\n    if (bitrate_index != 0) {\n\n        frame_size = mpa_bitrate_tab[s->lsf][s->layer - 1][bitrate_index];\n\n        s->bit_rate = frame_size * 1000;\n\n        switch(s->layer) {\n\n        case 1:\n\n            frame_size = (frame_size * 12000) / sample_rate;\n\n            frame_size = (frame_size + padding) * 4;\n\n            break;\n\n        case 2:\n\n            frame_size = (frame_size * 144000) / sample_rate;\n\n            frame_size += padding;\n\n            break;\n\n        default:\n\n        case 3:\n\n            frame_size = (frame_size * 144000) / (sample_rate << s->lsf);\n\n            frame_size += padding;\n\n            break;\n\n        }\n\n        s->frame_size = frame_size;\n\n    } else {\n\n        /* if no frame size computed, signal it */\n\n        if (!s->free_format_frame_size)\n\n            return 1;\n\n        /* free format: compute bitrate and real frame size from the\n\n           frame size we extracted by reading the bitstream */\n\n        s->frame_size = s->free_format_frame_size;\n\n        switch(s->layer) {\n\n        case 1:\n\n            s->frame_size += padding  * 4;\n\n            s->bit_rate = (s->frame_size * sample_rate) / 48000;\n\n            break;\n\n        case 2:\n\n            s->frame_size += padding;\n\n            s->bit_rate = (s->frame_size * sample_rate) / 144000;\n\n            break;\n\n        default:\n\n        case 3:\n\n            s->frame_size += padding;\n\n            s->bit_rate = (s->frame_size * (sample_rate << s->lsf)) / 144000;\n\n            break;\n\n        }\n\n    }\n\n    s->sample_rate = sample_rate;\n\n    \n\n#if defined(DEBUG)\n\n    printf(\"layer%d, %d Hz, %d kbits/s, \",\n\n           s->layer, s->sample_rate, s->bit_rate);\n\n    if (s->nb_channels == 2) {\n\n        if (s->layer == 3) {\n\n            if (s->mode_ext & MODE_EXT_MS_STEREO)\n\n                printf(\"ms-\");\n\n            if (s->mode_ext & MODE_EXT_I_STEREO)\n\n                printf(\"i-\");\n\n        }\n\n        printf(\"stereo\");\n\n    } else {\n\n        printf(\"mono\");\n\n    }\n\n    printf(\"\\n\");\n\n#endif\n\n    return 0;\n\n}\n", "idx": 14459, "substitutes": {"s": ["ings", "native", "i", "rs", "qs", "h", "new", "status", "js", "si", "server", "ps", "spec", "c", "is", "states", "aws", "m", "self", "bis", "d", "sync", "sg", "t", "fs", "ins", "sym", "g", "cs", "es", "full", "session", "client", "b", "ns", "ops", "r", "sports", "ks", "sys", "parts", "service", "details", "hs", "os", "sets", "o", "e", "obs", "http", "site", "sb", "features", "f", "services", "ls", "comments", "ses", "bs", "l", "rates", "sites", "S", "settings", "this", "its", "sq", "v", "conf", "ss", "p", "plugins", "n", "gs", "xs", "stats", "ssl", "ds", "ts", "us"], "header": ["bridge", "prot", "image", "h", "event", "status", "gender", "server", "frame", "filter", "handler", "ver", "driver", "reader", "liner", "line", "magic", "c", "counter", "offset", "text", "iter", "dr", "num", "message", "head", "numbered", "border", "writer", "key", "version", "her", "data", "page", "cover", "number", "pper", "inner", "body", "cookie", "headers", "queue", "config", "source", "null", "buffer", "master", "document", "layer", "metadata", "e", "feature", "block", "first", "hidden", "prev", "channel", "date", "input", "response", "code", "stream", "player", "er", "later", "hash", "v", "meta", "request", "size", "definition", "outer", "ssl", "forward", "content", "Header"], "sample_rate": ["sampleAcprice", "scale_score", "sample_speed", "sample_grade", "sample64rate", "scale_grade", "sample_rates", "Sample_speed", " sample2rate", " sample_rates", "sample2rate", "sample_width", "sample_rated", " sample_width", "sampleAccharge", "Sampleaccharge", "sample64rating", "Sample_term", " sample_rating", "Sample_charge", "sampleacprice", "samplealrate", " sample2rating", " sample_name", " sample2number", "samplealrates", "sample64name", "sample2number", "sample_number", "Sampleacrate", "Sample_size", " sample_price", "sample_charge", "scale_size", "samplealprice", "sample2rating", "sample_name", "sample_rating", "Sample_rate", "sample_score", "sampleacspeed", "sampleAcspeed", "sample2width", "scale_rate", " sample_rated", "sample64size", "sample64number", "sample_price", "sampleacrate", "sample64width", "Sampleacspeed", "samplealrated", "sampleAcrate", "sample_term", "sample_size", "Sample_price", "sample64grade", " sample2width", "sampleaccharge", " sample_number", "Sampleacprice", " sample_size", "sample64score"], "frame_size": ["byte64offset", "frame_member", " frame_strength", " frame_gap", "byte_size", "byte64sized", "view_size", "frame64size", "frame_rate", "framealoffset", "frame_Size", "frame_color", "frame64style", " frame_shape", "frame_content", "sample_ize", "frame64ize", "sequence_fee", "frame_memory", "frame64scale", "game_color", "frame_style", "sequence_size", "module64content", "fram_rate", "framexsize", "byte_memory", "frameacrate", "frameacmemory", "framexsized", "frameacscale", "frame_cost", "frame_body", "game_size", "view_sized", "byte64memory", "frame_fee", "sequence_length", "frame67size", " frame_use", " frame_rate", "byte64size", "module_content", "module_size", "game_term", "game_function", "slice_source", "frame64sized", "frame_sized", "frame_scale", "frame64content", " frame_offset", " frame_content", "frame_offset", "frameingoffset", "frameingsize", "module64source", "framealmember", " frame_member", "frame_source", "frame67scale", "framexscale", "frameacoffset", "framealsize", "view_strength", "frame_strength", "frame_function", "byte_offset", "fram_body", "module64size", "frame67function", "view_Size", "byte_sized", " frame_scale", "module_source", "module64style", "frame64source", " frame_cost", "frame_gap", "frameacsize", "frame64offset", "module_style", "game_sized", "sample_strength", "frameacsized", " frame_ize", "frame_length", "fram_size", "game_scale", "framexgap", " frame_sized", "frame_storage", "frame_address", "frameacfunction", "slice_size", "sample_size", "frame_use", "frameingmemory", "frameacshape", "frame_ize", " frame_address", "frame64memory", "slice_storage", "frameingsized", "frame_term", "frame67sized", "frameaccost", "frame_shape"], "mpeg25": ["mp25", "ogg125", "wav23", "ogg75", "video125", "gg125", "mp35", "ogg15", "camera35", "mpeg24", "peg35", "ogg25", "gg25", "mp50", "peg20", "mp24", "mpeg50", "mpeg23", "peg23", "peg125", "camera25", "camera50", "peg15", "mpeg75", "gg75", "peg50", "peg25", "mp75", "camera20", "mpeg125", "wav125", "mp23", "mpeg15", "peg24", "video25", "wav24", "wav25", "video75", "mpeg35", "mp125", "wav75", "peg75", "mpeg20", "mp20", "video50", "gg15"], "padding": ["trace", "pixel", "large", "gap", "align", "border", "buffer", "pressure", "position", "performance", "crop", "binding", "value", "alpha", "np", "password", "adding", "size", "layer", "p", "protection", "temp", "pointer", "packing", "length", "radius", "skip", "ping", "ip", "parser", "timeout", "tracking", "margin", "offset", "scale", "wrapper", "duration", "power", "prefix", "space", "ppa", "pad", "height"], "sample_rate_index": ["sample_wave_length", "sample_size_slice", "sample_rate_pointer", "sample_size_pointer", "sample_status_offset", "sample_rate2slice", "sample_rate_offset", "sample_rate_inc", "sample_size_size", "sample_rate_length", "sample_rate2ini", "sample_size_index", "sample_scale_index", "sample_status_number", "sample_status_index", "sample_wave_ini", "sample_rate_point", "sample_size_position", "sample_rate2position", "sample_rate2size", "sample_size_point", "sample_rate_ind", "sample_status_position", "sample_rate_number", "sample_rate_ini", "sample_wave_ind", "sample_rate2index", "sample_rate_position", "sample_scale_point", "sample_rate2pointer", "sample_rate_x", "sample_rate_slice", "sample_size_ini", "sample_wave_index", "sample_rate_size", "sample_scale_length", "sample_rate2point", "sample_scale_position"], "bitrate_index": ["bitration_index", "bitration_number", "bitrating_index", "bitrate_ind", "bitrate__field", "bitrating_field", "bitrating_Index", "bitrate_field", "bitrate__index", "bitration_ind", "bitrate__left", "bitrate_left", "bitrate_number", "bitration_size", "bitrate__Index", "bitrate_size", "bitrate_Index", "bitrate_address", "bitrating_left"]}}
{"project": "qemu", "commit_id": "424ad8388f89f4202a7836d003273f23ebe04b09", "target": 0, "func": "static void cchip_write(void *opaque, hwaddr addr,\n\n                        uint64_t val, unsigned size)\n\n{\n\n    TyphoonState *s = opaque;\n\n    uint64_t oldval, newval;\n\n\n\n    switch (addr) {\n\n    case 0x0000:\n\n        /* CSC: Cchip System Configuration Register.  */\n\n        /* All sorts of data here; nothing relevant RW.  */\n\n        break;\n\n\n\n    case 0x0040:\n\n        /* MTR: Memory Timing Register.  */\n\n        /* All sorts of stuff related to real DRAM.  */\n\n        break;\n\n\n\n    case 0x0080:\n\n        /* MISC: Miscellaneous Register.  */\n\n        newval = oldval = s->cchip.misc;\n\n        newval &= ~(val & 0x10000ff0);     /* W1C fields */\n\n        if (val & 0x100000) {\n\n            newval &= ~0xff0000ull;        /* ACL clears ABT and ABW */\n\n        } else {\n\n            newval |= val & 0x00f00000;    /* ABT field is W1S */\n\n            if ((newval & 0xf0000) == 0) {\n\n                newval |= val & 0xf0000;   /* ABW field is W1S iff zero */\n\n            }\n\n        }\n\n        newval |= (val & 0xf000) >> 4;     /* IPREQ field sets IPINTR.  */\n\n\n\n        newval &= ~0xf0000000000ull;       /* WO and RW fields */\n\n        newval |= val & 0xf0000000000ull;\n\n        s->cchip.misc = newval;\n\n\n\n        /* Pass on changes to IPI and ITI state.  */\n\n        if ((newval ^ oldval) & 0xff0) {\n\n            int i;\n\n            for (i = 0; i < 4; ++i) {\n\n                AlphaCPU *cpu = s->cchip.cpu[i];\n\n                if (cpu != NULL) {\n\n                    CPUState *cs = CPU(cpu);\n\n                    /* IPI can be either cleared or set by the write.  */\n\n                    if (newval & (1 << (i + 8))) {\n\n                        cpu_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    } else {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_SMP);\n\n                    }\n\n\n\n                    /* ITI can only be cleared by the write.  */\n\n                    if ((newval & (1 << (i + 4))) == 0) {\n\n                        cpu_reset_interrupt(cs, CPU_INTERRUPT_TIMER);\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 0x00c0:\n\n        /* MPD: Memory Presence Detect Register.  */\n\n        break;\n\n\n\n    case 0x0100: /* AAR0 */\n\n    case 0x0140: /* AAR1 */\n\n    case 0x0180: /* AAR2 */\n\n    case 0x01c0: /* AAR3 */\n\n        /* AAR: Array Address Register.  */\n\n        /* All sorts of information about DRAM.  */\n\n        break;\n\n\n\n    case 0x0200: /* DIM0 */\n\n        /* DIM: Device Interrupt Mask Register, CPU0.  */\n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[0], val & s->cchip.drir);\n\n        break;\n\n    case 0x0240: /* DIM1 */\n\n        /* DIM: Device Interrupt Mask Register, CPU1.  */\n\n        s->cchip.dim[0] = val;\n\n        cpu_irq_change(s->cchip.cpu[1], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0280: /* DIR0 (RO) */\n\n    case 0x02c0: /* DIR1 (RO) */\n\n    case 0x0300: /* DRIR (RO) */\n\n        break;\n\n\n\n    case 0x0340:\n\n        /* PRBEN: Probe Enable Register.  */\n\n        break;\n\n\n\n    case 0x0380: /* IIC0 */\n\n        s->cchip.iic[0] = val & 0xffffff;\n\n        break;\n\n    case 0x03c0: /* IIC1 */\n\n        s->cchip.iic[1] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0400: /* MPR0 */\n\n    case 0x0440: /* MPR1 */\n\n    case 0x0480: /* MPR2 */\n\n    case 0x04c0: /* MPR3 */\n\n        /* MPR: Memory Programming Register.  */\n\n        break;\n\n\n\n    case 0x0580:\n\n        /* TTR: TIGbus Timing Register.  */\n\n        /* All sorts of stuff related to interrupt delivery timings.  */\n\n        break;\n\n    case 0x05c0:\n\n        /* TDR: TIGbug Device Timing Register.  */\n\n        break;\n\n\n\n    case 0x0600:\n\n        /* DIM2: Device Interrupt Mask Register, CPU2.  */\n\n        s->cchip.dim[2] = val;\n\n        cpu_irq_change(s->cchip.cpu[2], val & s->cchip.drir);\n\n        break;\n\n    case 0x0640:\n\n        /* DIM3: Device Interrupt Mask Register, CPU3.  */\n\n        s->cchip.dim[3] = val;\n\n        cpu_irq_change(s->cchip.cpu[3], val & s->cchip.drir);\n\n        break;\n\n\n\n    case 0x0680: /* DIR2 (RO) */\n\n    case 0x06c0: /* DIR3 (RO) */\n\n        break;\n\n\n\n    case 0x0700: /* IIC2 */\n\n        s->cchip.iic[2] = val & 0xffffff;\n\n        break;\n\n    case 0x0740: /* IIC3 */\n\n        s->cchip.iic[3] = val & 0xffffff;\n\n        break;\n\n\n\n    case 0x0780:\n\n        /* PWR: Power Management Control.   */\n\n        break;\n\n    \n\n    case 0x0c00: /* CMONCTLA */\n\n    case 0x0c40: /* CMONCTLB */\n\n    case 0x0c80: /* CMONCNT01 */\n\n    case 0x0cc0: /* CMONCNT23 */\n\n        break;\n\n\n\n    default:\n\n        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);\n\n        return;\n\n    }\n\n}\n", "idx": 20365, "substitutes": {"opaque": ["OPaque", "operaque", "ospacity", "oplcoe", "opcoe", "oplrice", " opac", "copaque", "copace", "oplaque", "opace", "OPrice", "ospcoe", "operque", "operace", "opacity", "OPacity", " opque", "opac", "oplacity", " opace", "opque", "copque", "osprice", "ospaque", "operac", "oprice", "copac", "OPcoe"], "addr": ["name", "asm", "ino", "ref", "config", "hop", "acl", "eth", "mode", "ord", "pad", "host", "align", "device", "xff", "cmp", "r", "cmd", "address", "socket", "ad", "data", "p", "ace", "slot", "mac", "code", "dr", "rc", "cb", "ctx", "frame", "ext", "ptr", "channel", "src", "fd", "len", "sid", "pointer", "offset", "x", "type"], "val": ["ival", "reg", "grad", "sel", "serv", "fail", "ref", "sl", "valid", "item", "ind", "arg", "db", "cond", "part", "trial", "ol", "bl", "local", "pal", "split", "sol", "exec", "al", "alloc", "pos", "fee", "data", "rel", "ret", "p", "arr", "vals", "unit", "slot", "count", "elt", "rot", "el", "index", "pl", "aval", "dim", "cal", "pid", "ann", "x", "vol", "fl", "len", "loc", "slice", "VAL", "update", "Val", "doc", "v", "alt", "eval", "all", "block", "lit", "base", "value"], "size": [" error", " bytes", "Size", "bytes", " len", " arg", "data", " slot", "unit", "buf", " data", "ctx", "mem", " n", " mem", " length", "length", "len", " num", "v", "SIZE", " res", "type"], "s": ["sb", "e", "sym", "qs", "es", "sie", "sl", "g", "ses", "fs", "d", "sets", "ops", "site", "l", "ds", "services", "f", "sys", "t", "u", "m", "socket", "state", "ssl", "os", "p", "ts", "us", "o", "ls", "sync", "is", "ss", "sg", "c", "js", "settings", "self", "si", "b", "service", "aws", "session", "n", "S", "ns", "sup", "sf", "side", "south", "rs", "gs", "ps", "conf", "h", "secondary", "server", "su", "sq", "states"], "oldval": ["newVAL", "lowval", "lowvalid", "lowVal", "oldVAL", "newVal", "origVal", "newvalid", "origval", "oldeval", "olderval", " oldeval", " oldvalid", "origvalue", " oldVal", "neweval", "oldvalid", "origeval", " oldvalue", "oldvalue", "oldVal", "lowvalue", "olderVAL", "newvalue", "olderVal", "oldervalue", " oldVAL"], "newval": ["currentvalue", "newpol", "currentVal", "currentfb", "Newval", "newVal", "longVal", "oldvals", "NEWvalue", "newvalid", "fvalue", "NEWeval", "Newvals", "longvalid", "newvals", "longval", " neweval", "rawval", "raweval", "nextvalue", "oldeval", "Neweval", " newvalue", "nextVal", " newVal", "NewVal", "freshval", "nextvalid", "Newpol", "currenteval", "nextvals", "neweval", " newvals", "fval", "currentvalid", "longvalue", "oldvalid", "fresheval", "Newvalue", "fvals", "NEWval", "currentval", "oldvalue", "NEWvalid", "newfb", " newfb", "nexteval", "oldVal", "nextpol", "newvalue", "nextval", "Newvalid", "rawvalue", "freshvalue", "freshfb", " newpol", "fVal", "longeval", "rawvalid"], "i": ["io", "udi", "uli", "e", "anti", "ix", "ie", "qi", "ri", "ui", "eni", "mini", "gi", "uri", "ti", "I", "l", "f", "ci", "y", "u", "adi", "m", "ini", "it", "j", "info", "phi", "ip", "p", "id", "o", "bi", "vi", "cli", "c", "index", "si", "a", "ii", "b", "x", "n", "child", "iu", "slice", "ai", "xi", "hi", "di", "v", "multi", "yi", "li", "pi", "fi", "zi", "isin", "ni"], "cpu": ["monitor", "lc", "platform", "bench", "computer", "hp", "net", "fc", "lb", "gpu", "linux", "config", "GPU", "nic", "eni", "consumer", "cm", "pit", "processor", "process", "pc", "CPU", "css", "device", "host", "intel", "ci", "cmp", "node", "proxy", "nc", "phy", "cp", "ram", "cache", "program", "lu", "p", "component", "currency", "machine", "uci", "np", "memory", "pse", "px", "c", "cn", "frame", "module", "roc", "gp", "comp", "dim", "uca", "uu", "core", "auc", "chip", "pai", "prem", "proc", "vm", " CPU", "clock", "ips", "pu", "ilo"], "cs": ["lc", "bc", "cc", "ces", "qs", "conn", "cing", "fs", "cons", "ks", "pc", "css", "ds", "cas", "CS", "ci", "sys", "ac", "cp", "codes", "cache", "cases", "cells", "vs", "cf", "ls", "sync", "ss", "rc", "c", "ctx", "cn", "sc", "cks", "ics", "core", "cers", "ns", "cus", "ps", "gs", "cms", "bs", "ips", "ec", "acs", "gb"]}}
{"project": "qemu", "commit_id": "7c24384b3b984f0256ba10eb26d877ec28985019", "target": 1, "func": "static int64_t nfs_client_open(NFSClient *client, const char *filename,\n\n                               int flags, Error **errp)\n\n{\n\n    int ret = -EINVAL, i;\n\n    struct stat st;\n\n    URI *uri;\n\n    QueryParams *qp = NULL;\n\n    char *file = NULL, *strp = NULL;\n\n\n\n    uri = uri_parse(filename);\n\n    if (!uri) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    if (!uri->server) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    strp = strrchr(uri->path, '/');\n\n    if (strp == NULL) {\n\n        error_setg(errp, \"Invalid URL specified\");\n\n        goto fail;\n\n    }\n\n    file = g_strdup(strp);\n\n    *strp = 0;\n\n\n\n    client->context = nfs_init_context();\n\n    if (client->context == NULL) {\n\n        error_setg(errp, \"Failed to init NFS context\");\n\n        goto fail;\n\n    }\n\n\n\n    qp = query_params_parse(uri->query);\n\n    for (i = 0; i < qp->n; i++) {\n\n        if (!qp->p[i].value) {\n\n            error_setg(errp, \"Value for NFS parameter expected: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n        if (!strncmp(qp->p[i].name, \"uid\", 3)) {\n\n            nfs_set_uid(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"gid\", 3)) {\n\n            nfs_set_gid(client->context, atoi(qp->p[i].value));\n\n        } else if (!strncmp(qp->p[i].name, \"tcp-syncnt\", 10)) {\n\n            nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value));\n\n        } else {\n\n            error_setg(errp, \"Unknown NFS parameter name: %s\",\n\n                       qp->p[i].name);\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_mount(client->context, uri->server, uri->path);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to mount nfs share: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    if (flags & O_CREAT) {\n\n        ret = nfs_creat(client->context, file, 0600, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to create file: %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    } else {\n\n        ret = nfs_open(client->context, file, flags, &client->fh);\n\n        if (ret < 0) {\n\n            error_setg(errp, \"Failed to open file : %s\",\n\n                       nfs_get_error(client->context));\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = nfs_fstat(client->context, client->fh, &st);\n\n    if (ret < 0) {\n\n        error_setg(errp, \"Failed to fstat file: %s\",\n\n                   nfs_get_error(client->context));\n\n        goto fail;\n\n    }\n\n\n\n    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);\n\n    client->has_zero_init = S_ISREG(st.st_mode);\n\n    goto out;\n\nfail:\n\n    nfs_client_close(client);\n\nout:\n\n    if (qp) {\n\n        query_params_free(qp);\n\n    }\n\n    uri_free(uri);\n\n    g_free(file);\n\n    return ret;\n\n}\n", "idx": 9434, "substitutes": {"client": ["session", "context", "prefix", "chrome", "worker", "conn", "open", "http", "consumer", "public", "container", "project", "con", "Client", "c", "service", "config", "server", "reader", "util", "cli", "package", "request", "local", "private", "wrapper", "queue", "gui", "app", "cod", "socket", "manager", "entry", "host", "call", "child", "https", "ce", "current", "connection", "remote", "event", "google", "ctx", "user", "custom", "storage", "get", "plugin", "command", "handler", "single", "api", "image", "cache", "cell", "ssl"], "filename": ["fil", "il", "source", "prefix", "password", "fd", "path", "files", "tty", "buf", "username", "utf", "fp", "txt", "title", "Filename", "f", "binary", "bf", "database", "slice", "folder", "name", "content", "connection", "phrase", "loader", "buffer", "dll", "acl", "fn", "url", "directory", "which", "rl", "kl"], "flags": ["flag", "features", "stats", "files", "ops", "s", "mask", "util", "status", "bits", "args", "lag", "errors", "mode", " flag", "FLAG", "Flags", "format", "fun", " bits", " Flags", "rep", "bytes", "bit", "ips", "options", "fs", "gen"], "errp": ["erp", "armfp", "rarpa", "rrr", " errP", "rarpo", "ferlp", "lerfp", "finderpc", "errr", " errlp", "acerp", "arrsp", "acerpr", "armpr", "ferp", "erP", "err", "erpc", "lerlp", "ferpc", "erfp", "erpo", "rarsp", "errpr", "argpa", "finderping", "asterlp", "errpre", "asterpr", "erpr", "armpo", "argp", "arrpr", "errlp", "errpi", "errorpa", "armsp", " errr", "armp", "ferpi", "finderfp", "errorfp", "arrpo", "ferfp", "errorp", "errping", "arrfp", "rrpre", "errsp", "errP", "errpc", "argb", "errpo", "ferpr", "yrpe", "acerpi", "errb", "errfp", "yrpa", "rarp", "errorping", "errorpe", "errpe", "erping", "erpre", "argpe", " errpc", "acerlp", "errorpc", "rrp", "armpa", "finderp", " errpre", "errpa", "arrpa", "yrb", "asterpi", "yrp", "arrp", "lerpc", " errfp", "lerp", "rrP", "asterp", "errorb"], "i": ["l", "is", "m", "t", "x", "z", "iv", "ie", "v", "phi", "abi", "err", "ii", "init", "type", "ori", "ri", "fi", "oi", "gu", "si", "n", "id", "xi", "b", "c", "e", "mu", "f", "j", "index", "slice", "jit", "r", "bi", "u", "li", "ni", "lc", "hi", "di", "g", "source", "adi", "d", "status", "cli", "yi", "eni", "dr", "ai", "o", "gi", "chi", "pi", "I", "ret", "result", "iu", "ui", "start", "in", "info", "ini", "ji", "line", "p", "ix", "isi", "multi", "ti", "mi", "inner", "qi", "idi", "ip", "ci", "io", "y"], "st": ["ld", "l", "std", "str", "est", "nt", "no", "istic", "x", " sc", "ct", "stream", "obj", "ost", "f", "code", "v", "r", "ist", "sth", "et", "ST", "func", "fi", "fe", "sc"], "uri": ["ui", "archive", "location", "term", "di", " URI", "si", "source", "adi", "processor", "http", "path", "iri", "ini", "service", "metadata", "config", "server", "username", "reader", "cli", "package", "component", "ir", "gui", "eni", "parser", "manager", "binary", "unit", "resource", "multi", "slice", "umi", "route", "gi", "connection", "query", "folder", "doi", "mi", "address", "qi", "document", "pi", "storage", "git", "plugin", "uni", "handler", "api", "ci", "url", "io", "ori", "attribute", "directory", "ri", "URI", "transfer", "database"], "qp": ["idp", "ppP", "qP", "sqn", "sqP", "qn", "sqnp", "qop", "qq", "qpart", "reqop", "reqp", "questv", "sqf", "queste", "sqi", "idpc", "QP", "questpoint", "pgb", "qz", "sqpoint", "requpre", " qtp", "sqe", "qpre", "qupart", "requh", "qpc", "sqv", "sqpre", "sqtp", "qtp", "ql", "Qr", "que", "requp", "quc", "requl", "sqb", " qf", "sqm", "pgpr", "sqpart", "quq", "questf", " qr", "Qp", "qutp", "qunp", "qupc", "qufp", "sqop", "sqfp", "qc", "questh", "sqr", "reql", "idv", "sqz", "sqc", "questz", " qfp", "sqpr", "sql", "Qps", "qh", " qs", "Qi", "questp", "qpoint", " qm", "qul", "ppi", "sqh", "sqps", "qupre", "qfp", " qc", "quf", "qupoint", "sqp", "qnp", "qup", "ppp", "questpart", "Qs", "qps", "qupr", "qr", "qum", " qn", "Qc", "pgp", "sqq", "qs", "qun", "qf", "quz", "sqs", " qb", "ppps", "quop", "qv", "questl", "sqpc", "qub", "qe", "qpr", "pgh", "qi", "qm", "reqnp", "quh", "quv", "questq", "qb", "idh"], "file": ["parent", "base", "il", "flag", "comment", "ile", "source", "info", "http", "files", "path", "data", "line", "rule", "local", "queue", "feed", "f", "unit", "dir", "resource", "format", "folder", "name", "live", "pipe", "fat", "current", "pic", "full", "part", "offset", "get", "root", "File", "ignore", "image", "cache", "io", "buffer"], "strp": ["drpc", "irP", "drpe", "irp", "strpi", "nerpa", "drlp", "strpe", "Strpr", "strpatch", "strib", "strfp", "rrpatch", "nerp", "rrpr", "yrlp", "nerP", "Strb", "Strn", "strpr", "trn", "stripc", "strP", "arrpc", " strpe", "Strpc", "yrpc", "Strfp", "strb", "strip", "Strpe", "strpc", "arrpe", " strpatch", "StrP", "strpa", "rrp", "drp", "strifp", "Strp", "Strpi", " strn", "yrp", "trP", "arrp", " strpr", "trpe", " strpc", "Strpa", "strlp", "trp", " strb", "yrpe", "arrlp", "rrP", "irpi", "Strpatch", " strP", "nerpi", "irpa", "strn", " strfp"]}}
{"project": "FFmpeg", "commit_id": "f1ffb01ee9fd3a15c395c3cf6ff362ac5cd668d0", "target": 0, "func": "static int synchronize_audio(VideoState *is, short *samples,\n\n                             int samples_size1, double pts)\n\n{\n\n    int n, samples_size;\n\n    double ref_clock;\n\n\n\n    n = 2 * is->audio_st->codec->channels;\n\n    samples_size = samples_size1;\n\n\n\n    /* if not master, then we try to remove or add samples to correct the clock */\n\n    if (((is->av_sync_type == AV_SYNC_VIDEO_MASTER && is->video_st) ||\n\n         is->av_sync_type == AV_SYNC_EXTERNAL_CLOCK)) {\n\n        double diff, avg_diff;\n\n        int wanted_size, min_size, max_size, nb_samples;\n\n\n\n        ref_clock = get_master_clock(is);\n\n        diff = get_audio_clock(is) - ref_clock;\n\n\n\n        if (diff < AV_NOSYNC_THRESHOLD) {\n\n            is->audio_diff_cum = diff + is->audio_diff_avg_coef * is->audio_diff_cum;\n\n            if (is->audio_diff_avg_count < AUDIO_DIFF_AVG_NB) {\n\n                /* not enough measures to have a correct estimate */\n\n                is->audio_diff_avg_count++;\n\n            } else {\n\n                /* estimate the A-V difference */\n\n                avg_diff = is->audio_diff_cum * (1.0 - is->audio_diff_avg_coef);\n\n\n\n                if (fabs(avg_diff) >= is->audio_diff_threshold) {\n\n                    wanted_size = samples_size + ((int)(diff * is->audio_st->codec->sample_rate) * n);\n\n                    nb_samples = samples_size / n;\n\n\n\n                    min_size = ((nb_samples * (100 - SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;\n\n                    max_size = ((nb_samples * (100 + SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;\n\n                    if (wanted_size < min_size)\n\n                        wanted_size = min_size;\n\n                    else if (wanted_size > max_size)\n\n                        wanted_size = max_size;\n\n\n\n                    /* add or remove samples to correction the synchro */\n\n                    if (wanted_size < samples_size) {\n\n                        /* remove samples */\n\n                        samples_size = wanted_size;\n\n                    } else if (wanted_size > samples_size) {\n\n                        uint8_t *samples_end, *q;\n\n                        int nb;\n\n\n\n                        /* add samples */\n\n                        nb = (samples_size - wanted_size);\n\n                        samples_end = (uint8_t *)samples + samples_size - n;\n\n                        q = samples_end + n;\n\n                        while (nb > 0) {\n\n                            memcpy(q, samples_end, n);\n\n                            q += n;\n\n                            nb -= n;\n\n                        }\n\n                        samples_size = wanted_size;\n\n                    }\n\n                }\n\n                av_dlog(NULL, \"diff=%f adiff=%f sample_diff=%d apts=%0.3f vpts=%0.3f %f\\n\",\n\n                        diff, avg_diff, samples_size - samples_size1,\n\n                        is->audio_clock, is->video_clock, is->audio_diff_threshold);\n\n            }\n\n        } else {\n\n            /* too big difference : may be initial PTS errors, so\n\n               reset A-V filter */\n\n            is->audio_diff_avg_count = 0;\n\n            is->audio_diff_cum       = 0;\n\n        }\n\n    }\n\n\n\n    return samples_size;\n\n}\n", "idx": 14306, "substitutes": {"is": ["mis", "nis", "i", "ish", "js", "si", "play", "isi", "serv", "ics", "im", "get", "ist", "are", "kit", "in", "ais", "bis", "series", "fs", "id", "oss", "iv", "or", "cms", "es", "ois", "isa", "s", "inst", "bits", "ip", "ops", "sie", "sis", "iss", "Is", "osi", "parts", "does", "has", "ci", "os", "IS", "ie", "iris", "init", "ms", "obs", "info", "state", "ls", "it", "isu", "ists", "ses", "ui", "as", "isin", "bs", "ai", "lis", "its", "ii", "sil", "isc", "ris", "isl", "op", "iso", "ic", "ri", "css", "ori", "us", "ils", "esi", "irc"], "samples": ["Samps", "Sannels", "samps", "sesamples", "sannels", " sannels", " samps", "sesips", "sesannels", "Sips", " sips", "sips", "sesamps", "Samples"], "samples_size1": ["samples_mode01", "samples_scale01", "samples_scale1", "samples_form01", "samples_scale2", "samples_mode2", "samples_form2", "samples_size01", "samples_unit1", "samples_size2", "samples_form1", "samples_mode1"], "pts": ["ptsi", "mindsi", "indsf", "putsf", "inds", "mindsf", "mindS", "putsi", "minds", "putS", "ptS", "indS", "indsi", "ptsf"], "n": ["adj", "m", "en", "nl", "d", "t", "ni", "l", "i", "un", "nn", "N", "name", "g", "cn", "x", "fn", "v", "nw", "conn", " N", "np", "o", "w", "z", "size", "u", "p", "y", "s", "an", "e", "nc", "k", "b", "min", "j", "count", "f", "nu", "c", "ns", "ne", "norm", "sn", "network", "dn", "num", "span", "len", "pn", "net"], "samples_size": ["sourses_sized", "summiesallscale", "summies_edge", "samples__ize", "samples___scale", "samplesetsized", "sourses_type", "sourses0size", "samples_weight", "samples128sized", "samples___sized", "samples___capacity", "samplesalledge", "sample_ize", "samplesetarea", "summiesallsize", "samples__size", "samples_center", "samples___weight", "samplesallscale", "samples0center", "samples__member", "sourses0type", "samplesallsize", "samples128center", "summiesallcount", "sampleetsized", "samples0type", "sourses_center", "sourses_size", "samplesallcount", "samples_width", "summiesalledge", "summies_size", "summies_count", "samplesetize", "sampleslexize", "summies_scale", "samples_member", "samples_capacity", "samplesetsize", "sample_area", "samples_area", "samples128type", "samples0sized", "samples_sized", "samples__width", "samples___size", "samples_scale", "sampleslexsize", "samples_sum", "sourses0center", "sampleslexmember", "sampleslexwidth", "samples_edge", "samples_ize", "sourses0sized", "sampleetsize", "samples128size", "sampleetize", "samples_count", "sample_size", "samples___sum", "sample_sized", "sampleetarea", "samples0size", "samples_type", "samples_length"], "ref_clock": ["ref_lock", " referencexbalance", " ref_error", "ref01clock", "refureround", "ref_Clock", "ref01lock", "ref67charge", "ref01error", " ref_Clock", "ref_round", "refureclock", "ref_balance", "refxbalance", " referencexclock", "refxclock", "ref67clock", "ref67Clock", " reference_clock", " referencexround", "ref_charge", "ref67lock", " ref_lock", " reference_round", "refurebalance", "ref01Clock", "ref_error", " ref_charge", " reference_balance", "refxround"], "diff": ["bug", "transfer", "part", "frac", "d", "dist", "shift", "l", "i", "def", "range", "low", "test", "progress", "ref", "cmp", "update", "sum", "comment", "dir", "error", "conf", " delta", "alpha", "dust", "mix", "cd", "iff", "dev", " difference", "version", "info", "desc", "comp", "distance", "data", "min", "length", "count", "f", "none", "flow", "fe", "df", "message", "md", "change", "scale", "fail", "Diff", "between", "changed", " differences", "different", "err"], "avg_diff": ["avgen_comp", "avgin67message", "avgin67length", "avgen_diff", "avg67message", "avrg_cmp", "avgen_field", "avg_message", "avrg_diff", "avgin67scale", "avg67scale", "avg_different", "avg_length", "avg67length", "avrg_different", "avg_cmp", "avg_comp", "avg67comp", "avg_dist", "avg67diff", "avgin67diff", "avgin_scale", "avg67field", "avg_field", "avgin_diff", "avgin_length", "avg67dist", "avgen_dist", "avg_scale", "avrg_comp", "avgin_message"], "wanted_size": ["wanted_num", "wanted64scale", "wanted_ize", "want_mode", "wanted67size", "wanted_mode", "want_lane", "want_size", "wanted_code", "want_ize", "wanted_capacity", "wanted_sized", "wanted64ize", "wanted_name", "wanted_lane", "wanted64sized", "wanting_size", "woded_num", "watched_size", "wanted_speed", "want_sized", "watched_speed", "wanting_scale", "wanted_left", "woded_size", "woded_scale", "wanted67ize", "wanting_left", "watched_capacity", "wanted67mode", "wanted67scale", "want_speed", "wanting_ize", "wanted64length", "want_name", "wanted_length", "wanted64speed", "wanting_code", "wanted64size", "watched_ize", "want_Size", "want_time", "wanted64num", "wanted_time", "woded_length", "want_scale", "wanted_scale", "wanted_Size", "wanting_capacity"], "min_size": ["minallrate", "min_large", " min_length", " min_course", "min\u00b7rate", "minqsize", "minimum\u00b7size", "min\u00b7area", "minallsize", "min_speed", "minimum_area", "min_length", "min48size", "min64speed", "minqgrow", "min64size", "min_rate", "min48course", "int_large", "min_area", "minfsmall", "min_course", "min_mini", " min_mini", "min_core", "min64source", "min_small", "int_core", "minimum_grow", "min_source", "minflarge", "min_grow", "min\u00b7size", "minimum\u00b7rate", "min48length", " min_source", "min64mini", "int_small", "min48speed", "minimum_rate", "minimum\u00b7area", "minimum_size", "minimum\u00b7grow", "int_size", "minallarea", "minfsize", "minqarea", "minallgrow", "minqrate", "minfcore", "min\u00b7grow", " min_speed"], "max_size": ["maxacsource", "maxenshape", "maxfullstrength", "maxacsize", "max\u00b7strength", "breakfullshape", "max_shape", "max_score", "max00large", "maxingsize", " max_handle", "breakfullsize", "maxfulldepth", "maxfullshape", "maxensize", "max00size", "maxfullscore", "max00cache", "maxenscore", "max\u00b7shape", "break_strength", " max_large", "maxingscale", "max_handle", "az_source", "maxfullscale", " max_depth", "max\u00b7score", "maxingcache", " max_scale", "max_large", "max_scale", "az_uri", "max_cache", "maxinglarge", "maxmsize", "max_source", "max\u00b7size", "break_size", "max_depth", "maxfullhandle", "max_strength", "breakfullscore", "maxenstrength", "max00scale", "maxmscale", " max_cache", "maxmdepth", "break_shape", "maxacuri", "break_score", "maxfullsize", "max_uri", "breakfullstrength", "maxmhandle", "az_size"], "nb_samples": ["nb_namples", "nb_banguages", "nb_sesamples", "nb_tamples", "nb67sacters", "nb_testsamps", "nb_servicesiments", "nb_filesannels", "nb_stamples", "nb_gample", "nb_servicesacters", "nb_stides", "nb_tesamples", "nb_bides", "nb_tesiments", "nb_siments", "nb_sviments", "nb_svamples", "nb_bamples", "nb_servicesamples", "nb_sesources", "nb_sources", "nb_filesimens", "nb_bources", "nb_filesamples", "nb_tesacters", "nb67tesacters", "nb_sidamples", "nb_sacters", "nb_tamps", "nb67splings", "nb_sample", "nb_sidamps", "nb67tesiments", "nb_simens", "nb_nannels", "nb_stources", "nb_sores", "nb_sesides", "nb_sanguages", "nb_splings", "nb_tesplings", "nb_testsamples", "nb_namps", "nb_testsannels", "nb_sesanguages", "nb_gamps", "nb_tores", "nb_stanguages", "nb_sidores", "nb_gores", "nb67tesplings", "nb_testsimens", "nb_svacters", "nb67tesamples", "nb_svplings", "nb_sides", "nb_gamples", "nb_samps", "nb_sannels", "nb67siments", "nb_tample", "nb_nimens", "nb67samples", "nb_filesamps", "nb_sidample", "nb_servicesplings"], "audio_diff_avg_count": ["audio_diff_avG_sum", "audio_diff_avg_sum", "audio_diff_avg_c", "audio_diff_avg_cache", "audio_diff_avG_diff", "audio_diff_avG_c", "audio_diff_avG_cache", "audio_diff_avG_count", "audio_diff_avg_diff"]}}
{"project": "FFmpeg", "commit_id": "48e52e4edd12adbc36eee0eebe1b97ffe0255be3", "target": 0, "func": "static int nvenc_find_free_reg_resource(AVCodecContext *avctx)\n\n{\n\n    NvencContext *ctx = avctx->priv_data;\n\n    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;\n\n    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;\n\n\n\n    int i;\n\n\n\n    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {\n\n        for (i = 0; i < ctx->nb_registered_frames; i++) {\n\n            if (!ctx->registered_frames[i].mapped) {\n\n                if (ctx->registered_frames[i].regptr) {\n\n                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,\n\n                                                ctx->registered_frames[i].regptr);\n\n                    ctx->registered_frames[i].regptr = NULL;\n\n                }\n\n                return i;\n\n            }\n\n        }\n\n    } else {\n\n        return ctx->nb_registered_frames++;\n\n    }\n\n\n\n    av_log(avctx, AV_LOG_ERROR, \"Too many registered CUDA frames\\n\");\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 24072, "substitutes": {"avctx": ["awcontext", "avcv", "akcmd", "Avmac", "awconv", "airctx", "afcmd", "Avconv", "AVcontext", "afctx", "avcas", "avconv", "AVmac", "akcontext", "Avcomponent", "afcas", "Avcontext", "Avcv", "akctx", "awctx", "Avcmd", "avcontext", "aircomponent", "avcomponent", "Avcas", "airmac", "Avctx", "avcmd", "aircontext", "AVctx", "AVcomponent", "AVcv", "AVconv", "afcontext", "avmac", "awcv", "akcas"], "ctx": ["bc", "fc", "cam", "ct", "config", "acl", "cm", "connection", "pc", "cp", "data", "cs", "xc", "prefix", "kb", "context", " context", "qa", "fw", "cus", "instance", "wcs", "support", "conn", "jp", "coll", "pkg", "cv", "anc", "fp", "ci", "component", "setup", "mac", "c", "cb", "wp", "sc", "ce", "concept", "cu", "vc", "conv", "lc", "cc", "tx", "cas", "cmp", "exec", "cmd", "p", "cf", "tc", "cli", "comp", "python", "loc", "cca", "hw", "obj", "sci", "kt", "ca", "Context", "nc", "mc", "ctrl", "np", "sync", "client", "cn", "aux", "auc", "parent", "kw", "ck"], "dl_fn": ["ll_function", "dl_func", "DL_module", "ll_fn", "dl1fn", "DL_conn", "dl_module", "DL_fn", "DL_ln", "dlpfn", "dlpfd", "dl_fd", "dlWconn", "dl1function", "ll_fd", "dlWfn", "dl_ln", "dl1func", "dlpfunction", "dl_conn", "dl1fd", "dlWln", "dl_function", "dlWmodule", "dlpfunc", "ll_func"], "p_nvenc": ["p_purenc", "p_cvenf", "p_cavenc", "p_nvencs", "p_nvenf", "p_nrenf", "p_nvincs", "p_cvenec", "p_nvinec", "p_pvenci", "p_purencs", "p_cvencs", "p_navenf", "p_nrencs", "p_cavenec", "p_nvincc", "p_nvenec", "p_pvencc", "p_nurenc", "p_navenec", "p_purenci", "p_nvencc", "p_nvinf", "p_nvinci", "p_nvenci", "p_navencc", "p_nurencs", "p_navenci", "p_pvenc", "p_nvinc", "p_navencs", "p_navenc", "p_cavenf", "p_nrenc", "p_cvenc", "p_nrenec", "p_nurencc", "p_purencc", "p_pvencs", "p_cavencs", "p_nurenci"], "i": ["io", "lc", "e", "ix", "start", "ie", "fi", "qi", "ind", "ri", "iv", "ui", "g", "part", "gi", "d", "uri", "ti", "I", "l", "f", "ci", "t", "y", "phi", "info", "m", "u", "adi", "j", "oi", "ini", "full", "ip", "abi", "p", "id", "current", "o", "bi", "inner", "load", "mi", "code", "mu", "index", "si", "a", "ii", "b", "ji", "in", "iu", "slice", "ai", "xi", "di", "r", "multi", "v", "yi", "li", "pointer", "h", "block", "pi", "x", "zi", "isin", "count"], "nb_registered_frames": ["nb_registered_flows", "nb_registered64frames", "nb_registered64Frames", "nb_loaded_flows", "nb_loaded_images", "nb_registered64objects", "nb_registered_images", "nb_registered_frame", "nb_registeredjobjects", "nb_registered_Frames", "nb_loaded_frame", "nb_registeredjframe", "nb_registeredjframes", "nb_registeredjFrames", "nb_loaded_frames", "nb_loaded_cycles", "nb_registered_devices", "nb_registered_objects", "nb_loaded_Frames", "nb_registered64frame", "nb_loaded_objects", "nb_registered_cycles", "nb_loaded_devices"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)\n\n{\n\n    uint32_t rgb = 0;\n\n\n\n    if (bpp == 32) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;\n\n        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;\n\n        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;\n\n        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;\n\n    }\n\n    if (bpp == 16) {\n\n        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;\n\n        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;\n\n    }\n\n    return rgb;\n\n}\n", "idx": 325, "substitutes": {"bpp": ["rbcp", "fpp", "bupp", "ppps", "pupp", "fcp", "bpc", " bPP", "lgp", "fpps", "ebpps", "fupp", "abbPP", " bgp", "ebPP", "pcp", "ebpp", "abbpps", "ppp", " bcp", " bupp", "bpps", "bcp", "bgp", "lcp", "rbgp", "rbmp", "lmp", "bmp", "abbpc", "ebpc", "rbpp", "bPP", " bpps", " bpc", "lpp", "abbpp", " bmp"], "buf": ["src", "buffer", "ctx", "bag", "Buff", "context", "queue", "ab", "data", "loc", "window", "bc", "buff", "cur", "ph", "bin", "tab", "grad", "ha", "map", "off", "mac", "rb", "proc", "fab", "dest", "box", "comb", "cb", "aka", "plug", "feat", "config", "func", "home", "pub", "begin", "usr", "block", "cv", "Buffer", "vec", "ptr", "band", "book", "bd", "wb", "text", "cache", "uint", "uv", "gb", "cap", "cmd", "alloc", "fb", "b", "border", "cf", "conv", "font", "uf", "path", "img", "msg", "que", "uc", "db"]}}
{"project": "FFmpeg", "commit_id": "62c3c8ca78ee2da7dc20c2d6371866266c82966d", "target": 1, "func": "int ff_rtsp_make_setup_request(AVFormatContext *s, const char *host, int port,\n\n                              int lower_transport, const char *real_challenge)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int rtx = 0, j, i, err, interleave = 0, port_off;\n\n    RTSPStream *rtsp_st;\n\n    RTSPMessageHeader reply1, *reply = &reply1;\n\n    char cmd[2048];\n\n    const char *trans_pref;\n\n\n\n    if (rt->transport == RTSP_TRANSPORT_RDT)\n\n        trans_pref = \"x-pn-tng\";\n\n    else\n\n        trans_pref = \"RTP/AVP\";\n\n\n\n    /* default timeout: 1 minute */\n\n    rt->timeout = 60;\n\n\n\n    /* for each stream, make the setup request */\n\n    /* XXX: we assume the same server is used for the control of each\n\n     * RTSP stream */\n\n\n\n    /* Choose a random starting offset within the first half of the\n\n     * port range, to allow for a number of ports to try even if the offset\n\n     * happens to be at the end of the random range. */\n\n    port_off = av_get_random_seed() % ((rt->rtp_port_max - rt->rtp_port_min)/2);\n\n    /* even random offset */\n\n    port_off -= port_off & 0x01;\n\n\n\n    for (j = rt->rtp_port_min + port_off, i = 0; i < rt->nb_rtsp_streams; ++i) {\n\n        char transport[2048];\n\n\n\n        /*\n\n         * WMS serves all UDP data over a single connection, the RTX, which\n\n         * isn't necessarily the first in the SDP but has to be the first\n\n         * to be set up, else the second/third SETUP will fail with a 461.\n\n         */\n\n        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP &&\n\n             rt->server_type == RTSP_SERVER_WMS) {\n\n            if (i == 0) {\n\n                /* rtx first */\n\n                for (rtx = 0; rtx < rt->nb_rtsp_streams; rtx++) {\n\n                    int len = strlen(rt->rtsp_streams[rtx]->control_url);\n\n                    if (len >= 4 &&\n\n                        !strcmp(rt->rtsp_streams[rtx]->control_url + len - 4,\n\n                                \"/rtx\"))\n\n                        break;\n\n                }\n\n                if (rtx == rt->nb_rtsp_streams)\n\n                    return -1; /* no RTX found */\n\n                rtsp_st = rt->rtsp_streams[rtx];\n\n            } else\n\n                rtsp_st = rt->rtsp_streams[i > rtx ? i : i - 1];\n\n        } else\n\n            rtsp_st = rt->rtsp_streams[i];\n\n\n\n        /* RTP/UDP */\n\n        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP) {\n\n            char buf[256];\n\n\n\n            if (rt->server_type == RTSP_SERVER_WMS && i > 1) {\n\n                port = reply->transports[0].client_port_min;\n\n                goto have_port;\n\n            }\n\n\n\n            /* first try in specified port range */\n\n            while (j <= rt->rtp_port_max) {\n\n                ff_url_join(buf, sizeof(buf), \"rtp\", NULL, host, -1,\n\n                            \"?localport=%d\", j);\n\n                /* we will use two ports per rtp stream (rtp and rtcp) */\n\n                j += 2;\n\n                if (!ffurl_open(&rtsp_st->rtp_handle, buf, AVIO_FLAG_READ_WRITE,\n\n                               &s->interrupt_callback, NULL))\n\n                    goto rtp_opened;\n\n            }\n\n\n\n            av_log(s, AV_LOG_ERROR, \"Unable to open an input RTP port\\n\");\n\n            err = AVERROR(EIO);\n\n            goto fail;\n\n\n\n        rtp_opened:\n\n            port = ff_rtp_get_local_rtp_port(rtsp_st->rtp_handle);\n\n        have_port:\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/UDP;\", trans_pref);\n\n            if (rt->server_type != RTSP_SERVER_REAL)\n\n                av_strlcat(transport, \"unicast;\", sizeof(transport));\n\n            av_strlcatf(transport, sizeof(transport),\n\n                     \"client_port=%d\", port);\n\n            if (rt->transport == RTSP_TRANSPORT_RTP &&\n\n                !(rt->server_type == RTSP_SERVER_WMS && i > 0))\n\n                av_strlcatf(transport, sizeof(transport), \"-%d\", port + 1);\n\n        }\n\n\n\n        /* RTP/TCP */\n\n        else if (lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n\n            /* For WMS streams, the application streams are only used for\n\n             * UDP. When trying to set it up for TCP streams, the server\n\n             * will return an error. Therefore, we skip those streams. */\n\n            if (rt->server_type == RTSP_SERVER_WMS &&\n\n                (rtsp_st->stream_index < 0 ||\n\n                 s->streams[rtsp_st->stream_index]->codec->codec_type ==\n\n                    AVMEDIA_TYPE_DATA))\n\n                continue;\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/TCP;\", trans_pref);\n\n            if (rt->transport != RTSP_TRANSPORT_RDT)\n\n                av_strlcat(transport, \"unicast;\", sizeof(transport));\n\n            av_strlcatf(transport, sizeof(transport),\n\n                        \"interleaved=%d-%d\",\n\n                        interleave, interleave + 1);\n\n            interleave += 2;\n\n        }\n\n\n\n        else if (lower_transport == RTSP_LOWER_TRANSPORT_UDP_MULTICAST) {\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/UDP;multicast\", trans_pref);\n\n        }\n\n        if (s->oformat) {\n\n            av_strlcat(transport, \";mode=receive\", sizeof(transport));\n\n        } else if (rt->server_type == RTSP_SERVER_REAL ||\n\n                   rt->server_type == RTSP_SERVER_WMS)\n\n            av_strlcat(transport, \";mode=play\", sizeof(transport));\n\n        snprintf(cmd, sizeof(cmd),\n\n                 \"Transport: %s\\r\\n\",\n\n                 transport);\n\n        if (rt->accept_dynamic_rate)\n\n            av_strlcat(cmd, \"x-Dynamic-Rate: 0\\r\\n\", sizeof(cmd));\n\n        if (i == 0 && rt->server_type == RTSP_SERVER_REAL && CONFIG_RTPDEC) {\n\n            char real_res[41], real_csum[9];\n\n            ff_rdt_calc_response_and_checksum(real_res, real_csum,\n\n                                              real_challenge);\n\n            av_strlcatf(cmd, sizeof(cmd),\n\n                        \"If-Match: %s\\r\\n\"\n\n                        \"RealChallenge2: %s, sd=%s\\r\\n\",\n\n                        rt->session_id, real_res, real_csum);\n\n        }\n\n        ff_rtsp_send_cmd(s, \"SETUP\", rtsp_st->control_url, cmd, reply, NULL);\n\n        if (reply->status_code == 461 /* Unsupported protocol */ && i == 0) {\n\n            err = 1;\n\n            goto fail;\n\n        } else if (reply->status_code != RTSP_STATUS_OK ||\n\n                   reply->nb_transports != 1) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        /* XXX: same protocol for all streams is required */\n\n        if (i > 0) {\n\n            if (reply->transports[0].lower_transport != rt->lower_transport ||\n\n                reply->transports[0].transport != rt->transport) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n        } else {\n\n            rt->lower_transport = reply->transports[0].lower_transport;\n\n            rt->transport = reply->transports[0].transport;\n\n        }\n\n\n\n        /* Fail if the server responded with another lower transport mode\n\n         * than what we requested. */\n\n        if (reply->transports[0].lower_transport != lower_transport) {\n\n            av_log(s, AV_LOG_ERROR, \"Nonmatching transport in server reply\\n\");\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        switch(reply->transports[0].lower_transport) {\n\n        case RTSP_LOWER_TRANSPORT_TCP:\n\n            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;\n\n            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;\n\n            break;\n\n\n\n        case RTSP_LOWER_TRANSPORT_UDP: {\n\n            char url[1024], options[30] = \"\";\n\n\n\n            if (rt->rtsp_flags & RTSP_FLAG_FILTER_SRC)\n\n                av_strlcpy(options, \"?connect=1\", sizeof(options));\n\n            /* Use source address if specified */\n\n            if (reply->transports[0].source[0]) {\n\n                ff_url_join(url, sizeof(url), \"rtp\", NULL,\n\n                            reply->transports[0].source,\n\n                            reply->transports[0].server_port_min, \"%s\", options);\n\n            } else {\n\n                ff_url_join(url, sizeof(url), \"rtp\", NULL, host,\n\n                            reply->transports[0].server_port_min, \"%s\", options);\n\n            }\n\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) &&\n\n                ff_rtp_set_remote_url(rtsp_st->rtp_handle, url) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            /* Try to initialize the connection state in a\n\n             * potential NAT router by sending dummy packets.\n\n             * RTP/RTCP dummy packets are used for RDT, too.\n\n             */\n\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) && s->iformat &&\n\n                CONFIG_RTPDEC)\n\n                ff_rtp_send_punch_packets(rtsp_st->rtp_handle);\n\n            break;\n\n        }\n\n        case RTSP_LOWER_TRANSPORT_UDP_MULTICAST: {\n\n            char url[1024], namebuf[50], optbuf[20] = \"\";\n\n            struct sockaddr_storage addr;\n\n            int port, ttl;\n\n\n\n            if (reply->transports[0].destination.ss_family) {\n\n                addr      = reply->transports[0].destination;\n\n                port      = reply->transports[0].port_min;\n\n                ttl       = reply->transports[0].ttl;\n\n            } else {\n\n                addr      = rtsp_st->sdp_ip;\n\n                port      = rtsp_st->sdp_port;\n\n                ttl       = rtsp_st->sdp_ttl;\n\n            }\n\n            if (ttl > 0)\n\n                snprintf(optbuf, sizeof(optbuf), \"?ttl=%d\", ttl);\n\n            getnameinfo((struct sockaddr*) &addr, sizeof(addr),\n\n                        namebuf, sizeof(namebuf), NULL, 0, NI_NUMERICHOST);\n\n            ff_url_join(url, sizeof(url), \"rtp\", NULL, namebuf,\n\n                        port, \"%s\", optbuf);\n\n            if (ffurl_open(&rtsp_st->rtp_handle, url, AVIO_FLAG_READ_WRITE,\n\n                           &s->interrupt_callback, NULL) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            break;\n\n        }\n\n        }\n\n\n\n        if ((err = rtsp_open_transport_ctx(s, rtsp_st)))\n\n            goto fail;\n\n    }\n\n\n\n    if (reply->timeout > 0)\n\n        rt->timeout = reply->timeout;\n\n\n\n    if (rt->server_type == RTSP_SERVER_REAL)\n\n        rt->need_subscription = 1;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    ff_rtsp_undo_setup(s);\n\n    return err;\n\n}\n", "idx": 17766, "substitutes": {"s": ["ns", "spec", "ts", "sg", "sit", "t", "rs", "sv", "services", "service", "sb", "sl", "ss", "ls", "sec", "fs", "cs", "su", "acs", "sed", "ssl", "ses", "private", "c", "sam", "si", "S", "sci", "ks", "gs", "sys", "storage", "os", "server", "se", "sq", "sa", "ds", "sf"], "host": ["uri", "component", "proxy", "service", "auth", "method", "node", "localhost", "nick", "username", "ip", "link", "header", "path", "socket", "prefix", "remote", "ssl", "address", "test", "http", "domain", "Host", "server", "mac", "conn"], "port": ["uri", "plugin", "point", "code", "ort", "pod", "ports", "file", "hop", "channel", "stream", "type", "method", "cp", "ip", "profile", "path", "PORT", "pipe", "phone", "p", "address", "Port", "route", "message", "server"], "lower_transport": ["lower_transports", "lower_transpt", "lower_streampt", "lower_ranspt", "lower_transsource", "lower_ransource", "lower_ransp", "lower_transort", "lower_transrule", "lower_ranrule", "lower_transpace", "lower_ransort", "lower_userrule", "lower_hostports", "lower_mailort", "lower_usersource", "lower_streampace", "lower_middlePort", "lower_transPort", "lower_streamort", "lower_mailport", "lower_middleports", "lower_streamport", "lower_ranport", "lower_ranspace", "lower_userp", "lower_ransPort", "lower_mailpace", "lower_ranssource", "lower_transp", "lower_hostport", "lower_middlefile", "lower_ransfile", "lower_ransrule", "lower_hostfile", "lower_middleport", "lower_mailpt", "lower_hostPort", "lower_ransport", "lower_ransports", "lower_transfile", "lower_userport", "lower_ranp"], "real_challenge": ["real_dupe", "real_duplay", "real_challplay", "realparentchallpe", "real_openplay", "real_challonge", "real_protonge", "realparentopenplay", "real_protenge", "real_challpe", "realparentopenpe", "realparentopenenge", "real_protpe", "real_duenge", "real_duonge", "real_openonge", "real_openpe", "real_openenge", "realparentchallplay", "real_protplay", "realparentchallenge", "realparentopenonge", "realparentchallonge"], "rt": ["rx", "grad", "RT", "rr", "tt", "ret", "txt", "fr", "nd", "tr", "rs", "vr", "t", "NT", "ot", "ort", "ct", "gd", "rc", "r", "nt", "sett", "hd", "mot", "rh", "ut", "dt", "bt", "rf", "irt", "rat", "art", "att", "rd", "ott", "ht", "feat", "tx", "urt", "ru", "rn", "rot", "sr", "dr", "qt", "ant", "yt", "apt", "rl", "rb", "kt", "vt", "gt", "od", "dat", "adr", "error", "boot", "rect", "mt", "ft", "tp", "tm", "pt"], "j": ["jc", "m", "jl", "ji", "t", "x", "jp", "jit", "f", "uj", "qi", "r", "adj", "n", "jj", "job", "g", "z", "ii", "ij", "jet", "index", "ind", "aj", "dj", "o", "l", "d", "w", "J", "k", "q", "v", "si", "p", "xi", "b", "h", "ja", "y", "li"], "i": ["ti", "gi", "uri", "m", "bi", "ei", "ji", "x", "f", "jit", "ini", "qi", "r", "ai", "mi", "n", "io", "phi", "hi", "z", "ii", "ie", "ori", "iu", "index", "di", "ij", "I", "zi", "o", "ip", "l", "d", "yi", "pi", "uni", "ui", "ci", "id", "e", "v", "cli", "ni", "c", "si", "ki", "ri", "p", "xi", "b", "api", "it", "eni", "fi", "y", "li", "u"], "err": ["status", "fr", "rr", "init", "ini", "ai", "result", "str", "ie", "ind", "ry", "resp", "out", "nil", "go", "aa", "aaa", "dr", "e", "req", "next", "error", "er", "server", "y"], "port_off": ["portenoa", "port___off", "port_data", "port67left", "key67left", "key_length", "port_pos", "port___max", "port_id", "port67name", "port_oa", "port2diff", "key_left", "key_and", "portfleft", "port67and", "port_Off", "key67off", "port64off", "port_length", "post_offset", "portenoff", "port_offset", "portenlength", "port6pos", "port67id", "portendata", "port67length", "port64name", "ort_max", "portflength", " port_id", "port___on", "portaldata", "portenand", "port_name", "ort_on", " port_data", "port6off", "portaloa", "ort_off", "post_pos", "portfoff", "key_off", "port_max", "port2off", "port_diff", "key67length", "port6offset", "portaloff", "portfand", "port___Off", "port2pos", "port64id", "portenleft", "port_and", " port_oa", "key67and", "ort_Off", "port6diff", "port67off", " port_name", "port_on", "post_off", "post_diff", "port_left", "port2offset"], "rtsp_st": ["rtsnp_ST", "rtspec_stream", "rtsp_sl", "rtsnp_sl", "rtsnp_stream", "rtsper_st", "rtsp_se", "rtsnp_se", "rtspec_est", "rtsnp_st", "rtsp_sts", "rtsper_sts", "rtsnp_str", "rtsp__se", "rtsp__str", "rtspec_stim", "rtsp_const", "rtsp_ST", "rtsp_stream", "rtsp_est", "rtsp__stream", "rtsper_const", "rtsp_stack", "rtspec_st", "rtsp__st", "rtsp_stim", "rtsper_stack", "rtsp_str"], "reply1": ["response2", "response1", "Reply2", "next0", "Reply1", " reply0", "response3", " reply2", "next1", "answer3", " reply3", "answer1", "Reply0", "reply2", "answer2", "next2", "reply3", "reply0"], "reply": ["entry", "code", "comment", "respond", "proxy", "result", "pack", "match", "msg", "resp", "ack", "flash", "link", "answer", "prefix", "response", "send", "respons", "address", " replies", "next", "route", "write", "connection", "frame", "reason", "Reply", "transfer"], "cmd": ["bin", "mode", " mac", " req", "rc", "comm", "root", "auth", "loc", "msg", "ctx", "bid", " auth", "Cmd", "box", "config", "buff", "batch", "req", "unit", "seq", "cap", "alloc", "opt", " command", "proc", "mac", "command"], "trans_pref": ["trans_perfor", "trans_rec", "trans_preef", "trans_Pref", "trans_Prec", "trans_ref", "trans_reef", "trans_perf", "trans_profor", "trans_foreef", "trans_prof", "trans_perfer", "trans_prefs", "trans_Prefs", "trans_forefer", "trans_brefs", "trans_profer", "trans_Prefer", "trans_proc", "trans_prefor", "trans_perc", "trans_prec", "trans_bref", "trans_brefer", "trans_prefer", "trans_brec", "trans_forec", "trans_forefor", "trans_peref", "trans_foref", "trans_perfs", "trans_refer"], "transport": ["ranstext", "Transtext", "Transp", "ransporter", "transporter", "interporter", " transform", "interports", "Transform", "transort", " transp", "ransports", "ransp", "Transport", "teleports", "teleport", "transtext", "interort", "teleporter", "teleort", "transp", "ransport", "transports", " transtext", "transform", "ransort", "interport", "ransform"], "rtx": ["retxp", "RTfx", "ttX", "retex", "rdX", "rotX", "rtz", "rotx", "rtex", "ntxs", "rtxp", "rtX", "retX", "rcxp", "rtxa", "ttz", "rotwy", "qtxes", "rotxb", "dtX", "ntxc", "aptX", "ortxs", "ttxb", "rtc", "rtwx", "ntX", "rtwy", "gtx", "ntz", "retx", "rrxc", "RTwy", "rdc", "drfx", "rtix", "vrX", "rtxs", "ttwy", "ttxs", "RTwx", "retxc", "rrwork", "RTxes", "retc", "rtxc", "dtx", "RTfe", "vrfx", "ttx", "drxc", "RTwork", "retxa", "ytex", "aptfe", "gtxy", "drx", "qtx", "rrx", "rdxc", "rcxa", "rcix", "retix", "rdx", "ytxc", "RTxc", "rtxes", "dtxy", "rcfx", "rotix", "rtxb", "dtv", "retfx", "ytx", "rtfx", "aptx", "ntx", "RTc", "aptxes", "ntwork", "RTv", "rtfe", "rcx", "RTX", "RTxy", "rtv", "rrX", "rotxa", "rtwork", "rcX", "rtxy", "vrx", "rotxp", "rcwx", "gtX", "ttxc", "ytfx", "ortxc", "qtfe", "gtv", "RTx", "RTxb", "vrwx", "ortz", "drex", "qtX", "ortx"], "buf": ["Buffer", "bin", "br", "func", "base", "pool", "buffer", "num", "block", "cb", "bc", "Buff", "wb", "mem", "ba", "conv", "box", "queue", "buff", "batch", "map", "pad", "b", "cap", "alloc", "proc", "bag", "uf"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "static inline float64 ucf64_itod(uint64_t i)\n\n{\n\n    union {\n\n        uint64_t i;\n\n        float64 d;\n\n    } v;\n\n\n\n    v.i = i;\n\n    return v.d;\n\n}\n", "idx": 15066, "substitutes": {"i": ["qi", "it", "ui", "m", "I", "d", "t", "ai", "xi", "l", "iu", "gi", "ini", "a", "oi", "val", "ci", "ig", "h", "di", "x", "si", "ie", "ii", "vi", "o", "u", "p", "e", "li", "k", "ix", "b", "j", "phi", "f", "n", "ti", "c", "is", "pi", "ic", "r", "bi", "ri", "ik", "index"], "v": ["m", "d", "t", "vv", "l", "val", "vp", "iv", "g", "x", "vm", "value", "vi", "var", "tv", "o", "av", "w", "u", "p", "e", "ver", "k", "data", "j", "n", "f", "c", "lv", "ov", "sv", "q", "nv", "va", "uv", "V", "ev", "vd", "vt", "vs", "vals"]}}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int usb_host_handle_control(USBDevice *dev, USBPacket *p,\n\n               int request, int value, int index, int length, uint8_t *data)\n\n{\n\n    USBHostDevice *s = DO_UPCAST(USBHostDevice, dev, dev);\n\n    struct usbdevfs_urb *urb;\n\n    AsyncURB *aurb;\n\n    int ret;\n\n\n\n    /*\n\n     * Process certain standard device requests.\n\n     * These are infrequent and are processed synchronously.\n\n     */\n\n\n\n    /* Note request is (bRequestType << 8) | bRequest */\n\n    trace_usb_host_req_control(s->bus_num, s->addr, request, value, index);\n\n\n\n    switch (request) {\n\n    case DeviceOutRequest | USB_REQ_SET_ADDRESS:\n\n        return usb_host_set_address(s, value);\n\n\n\n    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\n\n        return usb_host_set_config(s, value & 0xff);\n\n\n\n    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:\n\n        return usb_host_set_interface(s, index, value);\n\n    }\n\n\n\n    /* The rest are asynchronous */\n\n\n\n    if (length > sizeof(dev->data_buf)) {\n\n        fprintf(stderr, \"husb: ctrl buffer too small (%d > %zu)\\n\",\n\n                length, sizeof(dev->data_buf));\n\n        return USB_RET_STALL;\n\n    }\n\n\n\n    aurb = async_alloc(s);\n\n    aurb->packet = p;\n\n\n\n    /*\n\n     * Setup ctrl transfer.\n\n     *\n\n     * s->ctrl is laid out such that data buffer immediately follows\n\n     * 'req' struct which is exactly what usbdevfs expects.\n\n     */\n\n    urb = &aurb->urb;\n\n\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n\n    urb->endpoint = p->devep;\n\n\n\n    urb->buffer        = &dev->setup_buf;\n\n    urb->buffer_length = length + 8;\n\n\n\n    urb->usercontext = s;\n\n\n\n    trace_usb_host_urb_submit(s->bus_num, s->addr, aurb,\n\n                              urb->buffer_length, aurb->more);\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n\n\n    DPRINTF(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n\n\n    if (ret < 0) {\n\n        DPRINTF(\"husb: submit failed. errno %d\\n\", errno);\n\n        async_free(aurb);\n\n\n\n        switch(errno) {\n\n        case ETIMEDOUT:\n\n            return USB_RET_NAK;\n\n        case EPIPE:\n\n        default:\n\n            return USB_RET_STALL;\n\n        }\n\n    }\n\n\n\n    return USB_RET_ASYNC;\n\n}\n", "idx": 13426, "substitutes": {"dev": ["plug", "bug", "device", "proc", "ch", "self", "d", "dist", "priv", "die", "home", " device", "def", "g", "req", "ve", "serial", "new", "di", "devices", "h", "user", "Dev", "mod", "bus", "comment", "valid", "v", "app", "conf", "pu", "error", "av", "gd", "de", "w", "pub", "temp", "pack", "info", "engine", "sd", "driver", "f", "dom", "diff", "block", "dem", "DEV", "md", "cmd", "pro", "ds", "dd", "ev", "dn", "debug", "dm", "hw"], "p": ["proc", "m", "d", "t", "pc", "i", "vp", "pre", "g", "sp", "h", "py", "pp", "fp", "v", "o", "np", "pd", "w", "u", "e", "plugin", "pb", "b", "j", "f", "ip", "c", "q", "dp", "r", "cp", "P", "tp", "gp"], "request": ["device", "path", "head", " Request", "insert", "complete", "input", "response", "art", "config", "id", "received", "object", "current", "name", "req", "hello", "event", "effect", "use", "buffer", "method", "Request", "frame", "access", "version", "instance", "time", "resource", "info", "rx", "ext", "mode", "f", "result", "address", "query", "pair", "first", "pull", "type", "attribute", "q", "forward", "command", "initial", "author", "param", "r", "rest", "push", "rf", "header", "message"], "value": ["device", "port", "input", "response", "config", "id", "val", "search", "current", "name", "range", "values", "section", "null", "description", "x", "buffer", "update", "position", "total", "key", "server", "v", "localhost", "valid", "set", "element", "view", "size", "version", "time", "Value", "info", "property", "flow", "store", "address", "json", "number", "start", "end", "type", "function", "change", "write", "command", "initial", "fee", "content", "off", "max", "message"], "index": ["Index", "connect", "slice", "input", "config", "id", "val", "i", "level", "name", "weight", "x", "position", "loc", "error", "key", "localhost", "access", "view", "size", "ind", "active", "info", "match", "base", "read", "point", "address", "query", "inc", "diff", "end", "type", "offset", "initial", "field", "pos", "tail", "len", "start"], "length": ["zip", "path", "slice", "thin", "val", "l", "level", "style", "shape", "name", "weight", "section", "buffer", "sequence", "full", "position", "total", "loc", "limit", "failed", "size", "time", "info", "max", "count", "Length", "f", "padding", "number", "block", "end", "type", "offset", "ph", "body", "text", "load", "angle", "duration", "empty", "off", "lock", "delay", "tail", "len"], "data": ["transfer", "input", "d", "response", "array", "config", "def", "send", "new", "raw", "frame", "buff", "info", "pack", "du", "base", "read", "result", "block", "feed", "Data", "DATA", "load", "command", "fee", "push", "message"], "s": ["device", "rs", "qs", "h", "new", "si", "js", "server", "ps", "sim", "spec", "c", "serv", "is", "sc", "sv", "sl", "states", "south", "m", "self", "bis", "d", "t", "sync", "sg", "ins", "sym", "g", "cs", "es", "session", "storage", "w", "an", "u", "b", "ns", "r", "ks", "sys", "service", "details", "sp", "hs", "os", "sets", "o", "e", "http", "sd", "sb", "j", "f", "services", "sh", "ls", "ses", "as", "l", "S", "its", "sq", "v", "conf", "ss", "se", "ions", "n", "gs", "ssl", "ds", "su", "us", "ts"], "urb": ["rib", "interface", "eur", "report", "aim", "br", "force", "rb", "verb", "fab", "usb", "flow", "ocr", "cb", "attr", "eb", "deb", "abb", "uff", "utter", "bb", "obb", "uf", "urban", "lc", "api", "air", "erg", "editor", "adr", "img", "b", "ann", "url", "feed", "ur", "uv", "um", "qi", "transfer", "ch", "config", "abuse", "uber", "fb", "account", "ub", "hub", "nb", "buffer", "raf", "rub", "abl", "element", "aff", "atom", "f", "gb", "address", "ulp", "udi", "rob", "aud", "arb", "ob", "orb", "uri", "buff", "cr", "plugin", "pb", "buf", "ab", "urt", "aur", "ell", "irm", "emb"], "aurb": ["iarf", "iarb", "turab", "aurd", "iarB", "urab", "turbs", "eurp", "rumb", "auc", "ervp", "turB", "urc", "hra", "rard", "iarbs", "urchab", "rarb", "igrB", "urchr", "aub", "aurib", "aurab", "eurc", "urr", "urchB", "ervB", "eurr", "urib", "iarp", "igrb", "urchb", "URb", "aup", "eurab", "erva", "ura", "ervb", "igrd", "URbs", "rumr", "URB", "eurb", "aurbs", "acerb", "URf", "hrab", "ervc", "iarab", "urd", "urB", "rumab", "turr", "aurr", "acerr", "iarr", "turb", "eura", "turp", "igrib", "acerB", "aua", "urp", "eurB", "aurf", "acerab", "aurB", "hrB", "turf", "aura", "hrb", "rumB", "ervr", "aurp", "aur", "aurc", "rarib", "igrab", "igra", "rara"], "ret": ["alt", "let", "rev", "reply", "sat", "rc", "id", "val", "code", "back", "orig", "rets", "fun", "ref", "arg", "det", "full", "lit", "hash", "valid", "obj", "pass", "fin", "match", "success", "Ret", "bit", "count", "result", " RET", "att", "url", "arr", "eth", "nt", "re", "rt", "resp", "pat", "RET", "res", "reg", "num", "no", "len", "opt", "red"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(slw)\n\n{\n\n    if (T1 & 0x20) {\n\n        T0 = 0;\n\n    } else {\n\n        T0 = T0 << T1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 5855, "substitutes": {}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_overflow(void)\n\n{\n\n    const char *str = \"99999999999999999999999999999999999999999999\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, -ERANGE);\n\n    g_assert_cmpint(res, ==, ULLONG_MAX);\n\n    g_assert(endptr == str + strlen(str));\n\n}\n", "idx": 1108, "substitutes": {"str": ["dr", "cs", "Str", "ss", "rs", "spec", "res", "expr", "r", "strings", "wrap", "sp", "orig", "cur", "arr", "kr", "enc", "pos", "frac", "hr", "stri", "code", "er", "fr", "cr", "tr", "temp", "index", "st", "pr", "start", "vec", "lc", "br", "text", "sc", "ctr", "exec", "obj", "sec", "sr", "seq", "req", "inst", "old", "line", "iter", "input", "STR", "est"], "endptr": ["adptr", "Endpointer", "Endptr", "pendPtr", "entprot", "pendproc", "startaddr", " endctr", "Endaddr", "pendctr", " endprot", "adPtr", "endedproc", "startPtr", "endpoint", "endproc", "endctr", "endedptr", "pendpoint", "endpointer", "adpointer", "entPtr", "EndPtr", "endedctr", " endproc", "endedPtr", "entpoint", " endpoint", "endaddr", "pendptr", "pendprot", "endprot", " endPtr", "endPtr", "entptr", "startptr", "startpointer", "adaddr"], "err": ["dr", "ise", "rage", "ner", "gr", "Error", "rr", "out", "ver", "r", "der", "lr", "arr", "code", "er", "fr", "cr", "cb", "result", "ind", "c", "or", "pr", "ler", "order", "try", "e", "aster", "ctr", "cache", "ar", "resp", "die", "mr", "error", "rx", "var", "req", "Er", "msg", "iter", "rh", "res", "rc"]}}
{"project": "qemu", "commit_id": "71b58b82dac1e1dc5e08a005a14bbcafecbd9e2a", "target": 0, "func": "static int write_f(int argc, char **argv)\n\n{\n\n    struct timeval t1, t2;\n\n    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;\n\n    int c, cnt;\n\n    char *buf;\n\n    int64_t offset;\n\n    int count;\n\n    /* Some compilers get confused and warn if this is not initialized.  */\n\n    int total = 0;\n\n    int pattern = 0xcd;\n\n\n\n    while ((c = getopt(argc, argv, \"bCpP:q\")) != EOF) {\n\n        switch (c) {\n\n        case 'b':\n\n            bflag = 1;\n\n            break;\n\n        case 'C':\n\n            Cflag = 1;\n\n            break;\n\n        case 'p':\n\n            pflag = 1;\n\n            break;\n\n        case 'P':\n\n            pattern = parse_pattern(optarg);\n\n            if (pattern < 0) {\n\n                return 0;\n\n            }\n\n            break;\n\n        case 'q':\n\n            qflag = 1;\n\n            break;\n\n        default:\n\n            return command_usage(&write_cmd);\n\n        }\n\n    }\n\n\n\n    if (optind != argc - 2) {\n\n        return command_usage(&write_cmd);\n\n    }\n\n\n\n    if (bflag && pflag) {\n\n        printf(\"-b and -p cannot be specified at the same time\\n\");\n\n        return 0;\n\n    }\n\n\n\n    offset = cvtnum(argv[optind]);\n\n    if (offset < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    optind++;\n\n    count = cvtnum(argv[optind]);\n\n    if (count < 0) {\n\n        printf(\"non-numeric length argument -- %s\\n\", argv[optind]);\n\n        return 0;\n\n    }\n\n\n\n    if (!pflag) {\n\n        if (offset & 0x1ff) {\n\n            printf(\"offset %\" PRId64 \" is not sector aligned\\n\",\n\n                   offset);\n\n            return 0;\n\n        }\n\n\n\n        if (count & 0x1ff) {\n\n            printf(\"count %d is not sector aligned\\n\",\n\n                   count);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    buf = qemu_io_alloc(count, pattern);\n\n\n\n    gettimeofday(&t1, NULL);\n\n    if (pflag) {\n\n        cnt = do_pwrite(buf, offset, count, &total);\n\n    } else if (bflag) {\n\n        cnt = do_save_vmstate(buf, offset, count, &total);\n\n    } else {\n\n        cnt = do_write(buf, offset, count, &total);\n\n    }\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (cnt < 0) {\n\n        printf(\"write failed: %s\\n\", strerror(-cnt));\n\n        goto out;\n\n    }\n\n\n\n    if (qflag) {\n\n        goto out;\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, t1);\n\n    print_report(\"wrote\", &t2, offset, count, total, cnt, Cflag);\n\n\n\nout:\n\n    qemu_io_free(buf);\n\n\n\n    return 0;\n\n}\n", "idx": 599, "substitutes": {"argc": ["Argv", "argn", "argumentv", "argumentf", "agv", "confign", "configC", "catc", "catn", "configv", " argC", "arglc", "Argc", "agp", "Argn", "catp", " argn", "argumentc", "agc", "argumentp", " arglc", "agf", "ArgC", "argumentlc", " argf", "argC", " argp", "argumentn", "configc", "argf", "argp", "catlc"], "argv": ["Argv", "argumentv", "parf", "argumentf", "agv", "Argvs", "parc", " argl", "ArgV", " argb", "Argb", "Argc", "argsV", "agp", "argV", "agvs", "parv", " argvs", "argsp", "agver", "parvs", "Argf", "agc", "argumentp", "argl", "argumentl", "agf", "argver", "Argl", " argf", "argsv", " argV", " argver", "argb", "Argp", "argsf", " argp", "argsc", "argvs", "argsvs", "argf", "argsver", "argsb", "argp"], "t1": [" t0", "c3", "f1", " t8", "T2", "f2", "T0", "f3", "t0", "c1", "T3", "t8", "f0", "T8", "v2", "t3", "v1", "T1", "c0", "c2", "v0", "v8"], "t2": ["int5", "Ttwo", "t4", "a0", "p4", "T2", "int1", "p1", "temp4", "ttwo", "T0", "int0", "T5", "temptwo", "t0", "a2", "t5", "temp1", "ptwo", "T4", "a1", "int2", "p2", "temp2", "T1", "a5"], "c": ["cs", "channel", "cc", "mc", "r", "d", "n", "ct", "cat", "nc", "cy", "con", "k", "enc", "i", "ac", "m", "code", "cb", "cr", "z", "ch", "C", "ec", "orc", "dc", "ce", "ind", "p", "l", "xc", "e", "lc", "f", "col", "cn", "sc", "cd", "cmd", "comment", "v", "cit", "b", "t", "cf", "ci", "rc"], "cnt": ["icret", "rcct", "rcant", "cant", " cant", "pnt", "rcnt", "Cnc", "Cret", "icount", "Cno", " cret", "cpt", " cct", " cno", "ecount", "rcNT", "ecnt", " cNT", "acount", "cret", "CNT", "acNT", " cnc", "Cpt", "pret", "pount", "Cct", "icnt", "Cant", "icct", "rcount", "pNT", "cno", "cNT", "ecct", "cct", " cpt", "ecno", "acnt", "Cnt", "Count", "rcnc", "rcpt", "ecret", "cnc", "acno"], "buf": ["ff", "fd", "buffer", "ctx", "bh", "bag", "Buff", "context", "bo", "queue", "fw", "data", "window", "loc", "bc", "buff", "cur", "parent", "tmp", "cas", "ha", "batch", "output", "pos", "rb", "fp", "box", "aka", "cb", "coll", "err", "pool", "config", "bf", "runner", "func", "home", "result", "pkg", "block", "cv", "vec", "Buffer", "wb", "bd", "br", "cache", "cmd", "alloc", "bg", "seq", "b", "fb", "cmp", "cf", "uf", "socket", "img", "msg", "que", "fi", "uc", "rc", "port"], "offset": ["active", "url", "empty", "index", "pointer", "address", "alpha", "shift", "set", "reset", "seq", "optional", "af", "location", "limit", "start", "option", "image", "elta", "align", "position", "slot", "type", "format", "id", "parent", "end", "off", "gap", "api", "layout", "ptr", "aff", "length", "unc", "origin", "layer", "base", "skip", "data", "loc", "info", "slice", "et", "order", "len", "size", "ref", "attr", "o", "prefix", "error", "online", "timeout", "total", "append", "olerance", "array", "alias", "area", "operation", "num", "pos", "entry", "sync", "nt", "attribute", "number", "style", "config", "zero", "amount", "range", "padding", "Offset", "addr", "part", "ace"], "count": ["allow", "key", "large", "queue", "current", "n", "weight", "empty", "code", "partial", "index", "f", "child", "comment", "sum", "collection", "limit", "start", "name", "type", "id", "found", "parent", "end", "batch", "max", "p", "length", "patch", "text", "catch", "session", "val", "base", "counter", "complete", "more", "multiple", "cat", "loop", "pattern", "last", "order", "len", "size", "ref", "cache", "error", "low", "list", "match", "call", "total", "now", "num", "coll", "nt", "number", "bug", "col", "amount", "b", "depth", "full", "Count", "part"], "optind": ["octnd", "OptInd", "propnd", "optimind", "opinc", "Optii", "parentInd", "octInd", "propInd", "propend", "Optinc", "optimInd", "octint", "opend", "optii", "optinc", "optend", "Optind", " optnd", "optimnd", "parentend", "opInd", " optinc", "propind", "opint", "octind", "optnd", "optionind", "optionii", "optioninc", "opind", "optInd", "parentind", "Optnd", "optionnd", "opnd", " optInd", "optionint", "optint", "optiminc", " optii", "optimend", "optionend", "optionInd", "parentinc"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_loongson_integer(DisasContext *ctx, uint32_t opc,\n\n                                 int rd, int rs, int rt)\n\n{\n\n    const char *opn = \"loongson\";\n\n    TCGv t0, t1;\n\n\n\n    if (rd == 0) {\n\n        /* Treat as NOP. */\n\n        MIPS_DEBUG(\"NOP\");\n\n        return;\n\n    }\n\n\n\n    switch (opc) {\n\n    case OPC_MULT_G_2E:\n\n    case OPC_MULT_G_2F:\n\n    case OPC_MULTU_G_2E:\n\n    case OPC_MULTU_G_2F:\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DMULT_G_2E:\n\n    case OPC_DMULT_G_2F:\n\n    case OPC_DMULTU_G_2E:\n\n    case OPC_DMULTU_G_2F:\n\n#endif\n\n        t0 = tcg_temp_new();\n\n        t1 = tcg_temp_new();\n\n        break;\n\n    default:\n\n        t0 = tcg_temp_local_new();\n\n        t1 = tcg_temp_local_new();\n\n        break;\n\n    }\n\n\n\n    gen_load_gpr(t0, rs);\n\n    gen_load_gpr(t1, rt);\n\n\n\n    switch (opc) {\n\n    case OPC_MULT_G_2E:\n\n    case OPC_MULT_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        opn = \"mult.g\";\n\n        break;\n\n    case OPC_MULTU_G_2E:\n\n    case OPC_MULTU_G_2F:\n\n        tcg_gen_ext32u_tl(t0, t0);\n\n        tcg_gen_ext32u_tl(t1, t1);\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        opn = \"multu.g\";\n\n        break;\n\n    case OPC_DIV_G_2E:\n\n    case OPC_DIV_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_ext32s_tl(t0, t0);\n\n            tcg_gen_ext32s_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);\n\n            tcg_gen_mov_tl(cpu_gpr[rd], t0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"div.g\";\n\n        break;\n\n    case OPC_DIVU_G_2E:\n\n    case OPC_DIVU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"divu.g\";\n\n        break;\n\n    case OPC_MOD_G_2E:\n\n    case OPC_MOD_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"mod.g\";\n\n        break;\n\n    case OPC_MODU_G_2E:\n\n    case OPC_MODU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"modu.g\";\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DMULT_G_2E:\n\n    case OPC_DMULT_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        opn = \"dmult.g\";\n\n        break;\n\n    case OPC_DMULTU_G_2E:\n\n    case OPC_DMULTU_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        opn = \"dmultu.g\";\n\n        break;\n\n    case OPC_DDIV_G_2E:\n\n    case OPC_DDIV_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);\n\n            tcg_gen_mov_tl(cpu_gpr[rd], t0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"ddiv.g\";\n\n        break;\n\n    case OPC_DDIVU_G_2E:\n\n    case OPC_DDIVU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"ddivu.g\";\n\n        break;\n\n    case OPC_DMOD_G_2E:\n\n    case OPC_DMOD_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"dmod.g\";\n\n        break;\n\n    case OPC_DMODU_G_2E:\n\n    case OPC_DMODU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"dmodu.g\";\n\n        break;\n\n#endif\n\n    }\n\n\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s\", opn, regnames[rd], regnames[rs]);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 6193, "substitutes": {"ctx": ["abc", "cp", "cmp", "ci", "rc", "loc", "cm", "tx", "conv", "sci", "cc", "ck", "cam", "rx", "cb", "Context", "context", "ctrl", " context", "ca", "kb", "alloc", "txt", "cv", " cx", "cas", "grad", "conn", "xc"], "opc": ["OPcs", "ipc", "OPf", "ripn", "ipf", " opnc", "opnc", "ripc", " opC", "opb", "copn", "copnc", "ipcs", "opC", "OPc", "opcs", "ripf", "OPn", "copc", "opernc", "operc", " opf", " opb", "OPC", "operb", "ipC", " opcs", "ripC", "copb", "opern", "opf"], "rd": ["dr", "rn", "rw", "fr", "vr", "red", "sr", "aug", "od", "rr", "rid", "la", "dd", "dat", "RF", "rb", "rod", "aa", "lt", "ri", "rc", "rf", "pt", "rm", "loc", "rh", "db", "wb", "ru", "ra", "cd", "d", "rax", "td", "rost", "wd", "rect", "rg", "ren", "ds", "xd", "rx", "lr", "rl", "ha", "rin", "dra", "fail", "ld", "ind", "rat", "ct", "hr", "fd", "RR", "cn", "adr", "ud", "ord", "pl", "src", "ARR", "RS", "r", "lf", "bh", "rob", "nd", "RD"], "rs": ["dr", "rw", "vr", "cr", "sr", "pr", "rr", "ins", "sw", "rb", "RC", "tr", "rc", "rows", "rf", "rm", "xs", "ru", "ra", "ls", "res", "cs", "Rs", "ras", "ints", "rss", "ars", "rg", "ds", "rx", "lr", "rl", "rings", "mr", "src", "RS", "r", "ps"], "rt": ["irt", "dr", "rn", "fr", "vr", "ret", "rr", "rid", "nt", "rb", "vt", "rot", "lt", "tr", "rc", "rf", "ri", "art", "wt", "pt", "rm", "rh", "ru", "mt", "rss", "RT", "t", "rx", "rl", "rin", "ft", "ptr", "ct", "gt", "adr", "addr", "r", "RC", "rec", "nd"], "opn": [" opcn", "opN", "opr", "operns", "optN", " opN", "ropr", "opercn", "Opn", "opert", "optr", "optc", "optn", "Opns", " opr", "ropn", "opns", "operc", "Opc", "opcn", " opns", "operr", "opt", "ropc", "Opcn", "ropt", " opt", "opern", "operN"], "t0": ["ret0", "T2", " t000", "pt0", " mt0", "pt3", "t9", "T050", " t4", "l0", "te50", " mt1", "te1", " t8", " tau", "te00", "t50", "T0", " mt50", "ret1", "t4", "tt50", "tau", "ret00", "nt0", "ta50", "T1", "te0", "t3", "nt1", "tt9", " mt9", "T50", "nt050", " t050", "l1", "T3", "tt1", "t2", "pt8", "tty0", "f2", "tt0", "nt50", " t9", "l000", "te3", "f4", "T00", "ttyau", "T4", "tty00", "f0", "t050", " t2", "ta0", "l50", "pt1", "tty1", "ta000", "T8", "t000", " t3", "ta1", "f1", "t00", "t8", " t50", " t00", "retau"], "t1": ["pt0", "t100", " t4", "wt1", "wt001", "tie4", "ntONE", "unt81", "t151", "nt1", " t100", "tt1", "pt8", "Tone", "tty100", "tty1", "taone", "kt0", "ta1", "it0", "Tapp", "tty127", "t110", "t121", "tie0", "dtapp", "tie1", "T121", "unt1", "ta2", "nt0", "T1", "pt4", "ptarg", "wt81", "TONE", "pone", "p0", "T4", "unt001", "wt127", "dt0", "pt1", "T8", "t2", "t001", "tt110", "unt127", "tONE", "itONE", "p1", "tiearg", "t81", "tapp", "ta0", " t151", "kt1", "tty001", "ttyapp", "tty81", "t8", "Targ", "tty110", "T2", "dt1", "targ", "it121", "T151", "kt4", "ttyONE", "kt151", "p2", "T0", "t4", "pt5", "t127", "dtONE", "tty0", "nt121", "it1", "t5", "tt100", " t110", " t5", "tone", "T5", " t8"]}}
{"project": "FFmpeg", "commit_id": "3c895fc098f7637f6d5ec3a9d6766e724a8b9e41", "target": 0, "func": "static void put_payload_header(\n\n                                AVFormatContext *s,\n\n                                ASFStream       *stream,\n\n                                int             presentation_time,\n\n                                int             m_obj_size,\n\n                                int             m_obj_offset,\n\n                                int             payload_len\n\n            )\n\n{\n\n    ASFContext *asf = s->priv_data;\n\n    ByteIOContext *pb = &asf->pb;\n\n    int val;\n\n    \n\n    val = stream->num;\n\n    if (s->streams[val - 1]->codec.coded_frame->key_frame)\n\n        val |= ASF_PL_FLAG_KEY_FRAME;\n\n    put_byte(pb, val);\n\n        \n\n    put_byte(pb, stream->seq);  //Media object number\n\n    put_le32(pb, m_obj_offset); //Offset Into Media Object\n\n         \n\n    // Replicated Data shall be at least 8 bytes long.\n\n    // The first 4 bytes of data shall contain the \n\n    // Size of the Media Object that the payload belongs to.\n\n    // The next 4 bytes of data shall contain the \n\n    // Presentation Time for the media object that the payload belongs to.\n\n    put_byte(pb, ASF_PAYLOAD_REPLICATED_DATA_LENGTH);\n\n\n\n    put_le32(pb, m_obj_size);       //Replicated Data - Media Object Size\n\n    put_le32(pb, presentation_time);//Replicated Data - Presentation Time\n\n    \n\n    if (asf->multi_payloads_present){\n\n        put_le16(pb, payload_len);   //payload length\n\n    }\n\n}\n", "idx": 20662, "substitutes": {"s": ["sv", "sb", "e", "support", "qs", "sam", "sl", "fs", "g", "ses", "lines", "ops", "l", "ds", "services", "f", "t", "m", "storage", "ssl", "os", "p", "cs", "setup", "ls", "ss", "sa", "sg", "c", "js", "settings", "spec", "si", "sc", "b", "service", "aws", "S", "ns", "sup", "sf", "utils", "ps", "rs", "gs", "v", "bs", "su", "sq"], "stream": ["view", "transform", "row", "sel", "object", "event", "sl", "valid", "thread", "iv", "loop", "input", "coll", "progress", "gram", "post", "message", "forward", "draft", "Stream", "model", "path", "ream", "data", "ssl", "context", "upload", "client", "pool", "content", "audio", "frame", "source", "document", "form", "channel", "read", "sw", "src", "reader", "slice", "child", "feed", "stage", "image", "video"], "presentation_time": ["presentation_Time", "presentationpttimes", "presenting_Time", "presenting_time", "presentation_times", "presentation_url", "presentation64Time", "presenting_times", "presentationpturl", "presentation64cost", "presentationpttime", "presentation64times", "presentation36time", "presentation_cost", "presentationptspeed", "presentation_speed", "presentation64time", "presenting_url", "presenting_speed", "presenting_cost", "presentation36Time", "presentation36times", "presentation36cost"], "m_obj_size": ["m_obj2size", "m_obj__size", "m_obj__time", "m_obj__len", "m_obj_num", "m_obj_member", "m_obj_time", "m_obj0len", "m_obj2address", "m_obj0num", "m_object_size", "m_obj2offset", "m_obj\u00b7size", "m_block_size", "m_block_address", "m_obj__num", "m_object_time", "m_obj\u00b7address", "m_obj\u00b7member", "m_obj\u00b7offset", "m_object_len", "m_block_offset", "m_obj_address", "m_obj_len", "m_obj2member", "m_obj0size", "m_obj0time", "m_object_num", "m_block_member"], "m_obj_offset": ["m_obj_seq", "m_obj_off", "m_object_pos", "m_object_off", "m_obj_header", "m_object_size", "m_object_header", "m_object_offset", "m_obj_pos", "m_object_seq"], "payload_len": ["payload33number", "payload2len", "payflow_val", "payload_Len", "payflow_number", "payflow2Len", "payload33length", "payload_length", "payload33val", "payflow_Len", "payload_number", "payload64val", "payflow_size", "payload2size", "payload_size", "payload64length", "payload64number", "payload64len", "payflow2len", "payload2Len", "payload33len", "payflow_len", "payload_val", "payflow2length", "payflow2size", "payflow_length", "payload2length"], "asf": ["ASfs", "Asdf", "asdf", "Asf", " asfc", "assfo", "masfs", "lasfc", "csfs", "masF", "ASf", "asfo", "asfc", "rasfs", "assfs", " ascf", "csfo", " asF", "ASfc", "asF", "lasfs", "asfs", "rasf", "rasF", "assf", "lasf", "Asfs", "assF", "csf", "AsF", "masf", "csF", " asfs", "AScf", "masdf", "ascf", "lascf", " asfo", "rasdf"], "pb": ["lc", "bc", "platform", "sb", "bos", "summary", "fc", "lb", "prop", "jp", "lp", "prot", "mb", "cv", "db", "pkg", "fb", "pm", "pd", "bp", "pc", "plugin", "fp", "gb", "pg", "bsp", "rob", "eb", "lab", "cp", "login", "PB", "obb", "ob", "p", "kb", "abc", "wb", "bps", "kk", "ctx", "cb", "ib", "wp", "mp", "gp", "ub", "b", "cpp", "hub", "alist", "dl", "bm", "nb", "ab", "bf", "proc", "bh", "dp", "rb", "vp", "typ", "xb", "bs", "bj", "ppa", "emb", "pa"], "val": ["ival", "col", "bc", "sel", "ee", "ref", "ind", "valid", "sl", "il", "lv", "part", "key", "cond", "ol", "tx", "xx", "pos", "split", "win", "al", "bit", "fee", "enc", "unit", "vals", "slot", "count", "year", "py", "el", "index", "num", "ctx", "aval", "byte", "pid", "x", "seq", "vol", "fl", "vc", "length", "len", "loc", "slice", "VAL", "Val", "v", "sec", "eval", "lit", "pt", "offset", "base", "prop", "value"]}}
{"project": "FFmpeg", "commit_id": "369cb092ecbbaff20bb0a2a1d60536c3bc04a8f0", "target": 1, "func": "static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc)\n\n{\n\n    AVStream *st;\n\n    OutputStream *ost;\n\n    AVCodecContext *audio_enc;\n\n\n\n    ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO);\n\n    st  = ost->st;\n\n\n\n    audio_enc = st->codec;\n\n    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n    if (!ost->stream_copy) {\n\n        char *sample_fmt = NULL;\n\n\n\n        MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st);\n\n\n\n        MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st);\n\n        if (sample_fmt &&\n\n            (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid sample format '%s'\\n\", sample_fmt);\n\n            exit_program(1);\n\n        }\n\n\n\n        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);\n\n    }\n\n\n\n    return ost;\n\n}\n", "idx": 7666, "substitutes": {"o": ["ot", "ocol", "ko", "options", "od", "s", "po", "ob", "op", "io", "ow", "OC", "oa", "or", "O", "m", "so", "f", "d", "og", "e", "oco", "ops", "t", "k", "n", "p", "ou", "oper", "oi", "os", "c", "oo", "oci", "oid", "r"], "oc": ["osc", "ocol", "ocr", "anc", "unc", "irc", "roc", "mic", "ci", "config", "op", "rc", "OC", "enc", "co", "ocl", "uc", "loc", "inc", "ict", "soc", "org", "pc", "cc", "oca", "mc", "oco", "dc", "bc", "cu", "voc", "ic", "ec", "ogg", "iv", "toc", "oper", "c", "os", "ct", "oci", "oid", "lc", "asc", "fc", "ac", "cot", "isc"], "st": ["std", "osc", "est", "ste", "cr", "od", "store", "sw", "ob", "et", "sn", "stream", "ust", "art", "stack", "pt", "uc", "loc", "sts", "cl", "rest", "sl", "St", "fe", "ss", "kt", "stop", "sc", "sth", "sb", "ist", "inst", "storage", "sign", "ST", "str", "sta", "stage", "ut", "ft", "ptr", "sp", "start", "step", "ld", "os", "c", "ct", "put", "src", "ast", "nd", "stim"], "ost": ["ot", "osc", "ocol", "ocr", "est", "od", "om", "nt", "omp", "sw", "osi", "tmp", "ob", "op", "object", "pod", "tto", "or", "ust", "art", "oh", "stream", "rog", "so", "ott", "rest", "OST", "post", "oop", "org", "oster", "osta", "bb", "fe", "rost", "ood", "sth", "ist", "inst", "ado", "oss", "\u00f3", "iol", "sta", "opt", "pos", "oper", "ld", "os", "oid", "ort", "tt", "src", "host", "ast", "omm"], "audio_enc": ["audio_sys", "video_enz", "audio_inc", "picture_rec", "audio_enz", "audio__enc", "audioappenc", "audio__eng", "audio_config", "audioaccoll", "audioappdec", "audio__rec", "audio_rec", "audioacsys", "video_sys", "picture_anc", "video_rec", "video_anc", "video_enc", "audioappec", "audio__ec", "picture_enc", "audio_ec", "video_coll", "media_enc", "audio__conn", "audio_dec", "video_dec", "audio_coll", "video_ec", "picture_config", "media_inc", "media_ec", "media_eng", "audio_conn", "video_conn", "audioappenz", "audio_eng", "audioacec", "audio_anc", "audioacenc", "audio__inc"], "sample_fmt": ["sample_sfrt", "sample_pmt", "sample_Fnt", "sample_Farm", "sample_Ftm", "sample_rfma", "sample_rfformat", "sample64fmnd", "sample_fformat", "sample_cfmt", "sample_formct", "sample_frt", "sample_ptm", "sample_rfMT", "sample_farm", "sample_formt", "sample_pld", "sample_forformat", "sample_sfct", "sample_sfMT", "sample_FMT", "sample_fmm", "sample_fmMT", "sample_gmt", "sample_garm", "sample_cfm", "sample64fmmd", "sample_vmt", "sample_fct", "sample_vct", "sample64fmformat", "sample_dmt", "sample_vnt", "sample_fnt", "sample64fformat", "sample_dformat", "sample64fnd", "sample64fmd", "sample_fmma", "sample_varm", "sample_fMT", "sample_forarm", "sample_rfmd", "sample64fmt", "sample_gnt", "sample_pformat", "sample_fxmt", "sample_form", "sample64fmmt", "sample_Fmt", "sample_formMT", "sample_dnd", "sample_fxld", "sample_fma", "sample_cfarm", "sample_ftm", "sample_gMT", "sample_fxformat", "sample_fnd", "sample_vrt", "sample_sfmt", "sample_cfformat", "sample_Fformat", "sample_formmt", "sample_fmmt", "sample_Fld", "sample_fmformat", "sample_formrt", "sample_fxtm", "sample_fld", "sample_rfmt", "sample_rfnd", "sample_fmmd", "sample_formma", "sample_fmnd", "sample_formformat", "sample_fmarm", "sample_fmd", "sample_vMT", "sample_fm", "sample_dmd"]}}
{"project": "qemu", "commit_id": "c5acdc9ab4e6aa9b05e6242114479333b15d496b", "target": 0, "func": "static void bdrv_delete(BlockDriverState *bs)\n\n{\n\n    assert(!bs->job);\n\n    assert(bdrv_op_blocker_is_empty(bs));\n\n    assert(!bs->refcnt);\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    bdrv_close(bs);\n\n\n\n    /* remove from list, if necessary */\n\n    bdrv_make_anon(bs);\n\n\n\n    g_free(bs);\n\n}\n", "idx": 20485, "substitutes": {"bs": ["obs", "bc", "pb", "sb", "bos", "lbs", "outs", "lb", "bis", "es", "ba", "obj", "fs", "ses", "ubs", "xs", "als", "db", "fb", "bb", "ops", "ks", "bid", "ds", "bes", "bl", "css", "bing", "bas", "os", "vs", "cs", "ls", "sync", "bps", "js", "cb", "b", "bits", "blocks", "ns", "BS", "iss", "Bs", "rs", "gs", "ps", "ins", "banks", "bh", "base", "ss", "las", "gb"]}}
{"project": "FFmpeg", "commit_id": "49c8132b17ec26666d71ee94a50f421b84feeb35", "target": 1, "func": "static int ipmovie_read_packet(AVFormatContext *s,\n\n                               AVPacket *pkt)\n\n{\n\n    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    int ret;\n\n\n\n    ret = process_ipmovie_chunk(ipmovie, pb, pkt);\n\n    if (ret == CHUNK_BAD)\n\n        ret = AVERROR_INVALIDDATA;\n\n    else if (ret == CHUNK_EOF)\n\n        ret = AVERROR_IO;\n\n    else if (ret == CHUNK_NOMEM)\n\n        ret = AVERROR_NOMEM;\n\n    else\n\n        ret = 0;\n\n\n\n    return ret;\n\n}\n", "idx": 1373, "substitutes": {"s": ["sg", "parser", "src", "cs", "ctx", "ss", "spec", "sa", "a", "qs", "sb", "data", "d", "n", "sl", "k", "client", "i", "g", "m", "ses", "sf", "settings", "sv", "ds", "ps", "gs", "ns", "c", "p", "services", "self", "private", "f", "e", "sys", "sq", "sc", "south", "v", "b", "t", "S", "session", "an", "si", "parts", "ssl"], "pkt": ["apacket", " pqt", " packet", "wacket", "Pqt", " pct", "apkt", "wkg", "pet", " pet", "pkg", "wkt", "apqt", "Pet", "Pkg", "pqt", "pct", " pkg", "apet", "packet", "wct", "Pkt", "Pct", "Packet"], "ipmovie": ["epcam", "ipvideo", "opmovie", " ipcam", "ipMovie", "ipcam", "mpMovie", "epmovie", "ippMovie", "ipfilm", "ippfilm", "opMovie", "mpmovie", "ippcam", "epMovie", "ippmovie", "opvideo", "ippvideo", "mpvideo", "mpfilm", " ipMovie", "opfilm"], "pb": ["fc", "pl", "vp", "abi", "bh", "lp", "ppa", "pd", "sb", "bps", "bm", "lb", "ab", "hub", "eb", "ub", "cpp", "binary", "prot", "ib", "prop", "bc", "platform", "tc", "api", " eb", "py", "PB", "rb", "sf", "fp", "cb", "bf", "abc", "pa", "p", "cv", "pak", "wb", "gb", "jp", "pm", "mp", "pit", "phrase", "amp", "bp", "pc", "bb", "fb", "b", "cp", "aph", "uf", "pp", "xb"], "ret": ["match", "fun", "att", "mt", "ext", "def", "bit", "conn", "hash", "sb", "success", "data", "get", "ct", "alt", "type", "cat", "job", "id", "pet", "rets", "pass", "rb", "rep", "code", "ait", "info", "nt", "ft", "rev", "cb", "replace", "reply", "status", "Ret", "rc", "bf", "feat", "back", "result", "len", "ref", "flag", "gt", "art", "obj", "value", "RET", "t", "error", "al", "lit", "re", "reg", "val", "rt", "let", "det", "res", "db"]}}
{"project": "qemu", "commit_id": "ca6b6e1e68ac44b2e8895da10dd1c80dc03d08b7", "target": 0, "func": "static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)\n\n{\n\n    const QDictEntry *ent;\n\n    const char *arg_name;\n\n    const QObject *arg_obj;\n\n    bool has_exec_key = false;\n\n    QDict *dict = NULL;\n\n\n\n    if (qobject_type(request) != QTYPE_QDICT) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,\n\n                   \"request is not a dictionary\");\n\n        return NULL;\n\n    }\n\n\n\n    dict = qobject_to_qdict(request);\n\n\n\n    for (ent = qdict_first(dict); ent;\n\n         ent = qdict_next(dict, ent)) {\n\n        arg_name = qdict_entry_key(ent);\n\n        arg_obj = qdict_entry_value(ent);\n\n\n\n        if (!strcmp(arg_name, \"execute\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n\n                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\",\n\n                           \"string\");\n\n                return NULL;\n\n            }\n\n            has_exec_key = true;\n\n        } else if (strcmp(arg_name, \"arguments\")) {\n\n            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (!has_exec_key) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n        return NULL;\n\n    }\n\n\n\n    return dict;\n\n}\n", "idx": 5820, "substitutes": {"request": ["patch", "condition", "Request", "id", "complete", "try", "parent", "require", "object", "data", "xml", "resource", "client", "post", "child", "order", "call", "create", "subject", "q", "QUEST", "push", "error", "message", "instance", "path", "response", "self", "result", "context", "input", "req", "frame", "hello", "head", "type", "report", "model", "query", "user", "r", "quest"], "errp": ["rrpre", "Erp", "erpc", "erP", "nerps", "finderc", "errorr", "Erpc", "nerp", "rrP", "erping", "herP", "finderpre", "errorp", "errorpre", "rrp", "herping", "herp", "errP", "errping", "errpc", "ErP", " errP", "finderp", "erps", " errping", "finderping", "errorpc", " errpc", " errc", "lerp", "lerP", "err", "herr", " errps", "nerP", "lerping", "errc", "lerr", "errps", "errr", "erp", " errr", "nerpc", "Erc", "rrpc", " errpre", "rrc", "rrping", "errpre", "erpre"], "ent": ["ENT", "gent", "cent", "anc", "ect", "ch", "od", "sec", "id", "entry", "parent", "ente", "nt", "anch", "elt", "et", "enc", "art", "sett", "pt", "loc", "enter", "inc", "rent", "ict", "cart", "event", "de", "entity", " entry", "ce", "ev", "kt", "sent", "e", "det", "inst", "en", "vent", "se", "conn", "dc", "pent", "ant", "exec", "Ent", "equ", "ents", "ou", " entity", "ec", "ut", "intent", "ind", "ct", "ment", "ident", "query", "inner", "rec", "nd", "end"], "arg_name": ["Arg_Name", "attr_obj", "arg__code", "argument__code", "attracnm", "arg__Name", "enc__value", "argument_key", "enc__obj", "arg__len", "argaccommon", "arg__names", "enc_name", "argSobj", "argument__key", "argacobj", "arg_nm", "argument__name", "arg__obj", "arg_common", "attr_name", "Arg_word", "argument_name", "arg_names", "argacnm", "argument_code", "enc__len", "attracname", "enc_len", " arg_names", "Arg_obj", "arg_word", "attr_common", "enc_value", "enc_obj", "arg__value", "attracobj", "arg__name", "attraccommon", "arg_Name", "arg_len", "arg_key", "enc__name", "arg_code", "arg_value", " arg_Name", "argument_Name", "argument__Name", "argSword", "argSname", "Arg_name", "argacname", "attr_nm", "argSName", "arg__key"], "arg_obj": ["arg__object", "Arg_object", "Arg_xy", "arg_ob", "arg_val", " arg_object", "ar_name", "ar_ob", "ar_obj", "Arg_val", "Arg_obj", "arg__obj", " arg_ob", "arg__name", "ar_object", "arg__ob", "arg_xy", "arg_object"], "dict": ["condition", "dr", "inf", "diff", "count", "entry", "parent", "di", "dat", "nt", "value", "session", "config", "po", "list", "pillar", "object", "data", "rec", "cat", "module", "record", "map", "details", "db", "inc", "ict", "state", "d", "obj", "document", "table", "init", "dir", "dom", "def", "code", "out", "arr", "dev", "da", "dc", "ds", "df", "instance", "file", "full", "err", "response", "str", "lock", "path", "coll", "result", "array", "req", "collection", "doc", "tree", "hash", "ct", "head", "back", "dt", "query", "cache", "index", "set", "conn", "nd"]}}
{"project": "qemu", "commit_id": "9cbaacf999b01b27dc3a22502705178057af66de", "target": 0, "func": "static void gpollfds_from_select(void)\n\n{\n\n    int fd;\n\n    for (fd = 0; fd <= nfds; fd++) {\n\n        int events = 0;\n\n        if (FD_ISSET(fd, &rfds)) {\n\n            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, &wfds)) {\n\n            events |= G_IO_OUT | G_IO_ERR;\n\n        }\n\n        if (FD_ISSET(fd, &xfds)) {\n\n            events |= G_IO_PRI;\n\n        }\n\n        if (events) {\n\n            GPollFD pfd = {\n\n                .fd = fd,\n\n                .events = events,\n\n            };\n\n            g_array_append_val(gpollfds, pfd);\n\n        }\n\n    }\n\n}\n", "idx": 1626, "substitutes": {"fd": ["fc", "ff", "ld", "fun", "dd", "fen", "pd", "FD", "sd", "fed", "fw", "fa", "flo", "d", "lf", "dl", "fl", "id", " events", "fff", "fn", "buf", "pos", "draft", "dy", "pipe", "fp", "sf", "df", "cb", "cond", "ds", "pid", "dt", "md", "fe", "feed", "dc", "cod", "fi", "ind", "function", "func", "fin", "f", "ffff", "bd", "length", " fid", "draw", "cd", "fx", "handler", "wd", "fm", "die", "connection", "fee", "fb", "events", "cf", "config", "vd", "td", "nd", "dir", "fs", "db"]}}
{"project": "qemu", "commit_id": "7d91ddd25e3a4e5008a2ac16127d51a34fd56bf1", "target": 1, "func": "static void qemu_net_queue_append(NetQueue *queue,\n\n                                  NetClientState *sender,\n\n                                  unsigned flags,\n\n                                  const uint8_t *buf,\n\n                                  size_t size,\n\n                                  NetPacketSent *sent_cb)\n\n{\n\n    NetPacket *packet;\n\n\n\n    if (queue->nq_count >= queue->nq_maxlen && !sent_cb) {\n\n        return; /* drop if queue full and no callback */\n\n    }\n\n    packet = g_malloc(sizeof(NetPacket) + size);\n\n    packet->sender = sender;\n\n    packet->flags = flags;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n\n    QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);\n\n}", "idx": 21995, "substitutes": {"queue": ["status", "port", "stack", "Queue", "menu", "event", "loop", "connection", "plugin", "buffer", "entry", "ue", "sequence", "cache", "list", "prefix", "que", "context", "q", "pool", "client", "header", "module", "collection", "gui", "priority", "seq", "channel", "qa", "core", "console", "flow", "feed", "update", "database", "stage", "parent", "manager", "group", "server", "command", "type"], "sender": ["send", "sidender", "sidensor", "senders", "sink", "Send", "Sink", "pink", "penders", "nsorter", "sensor", "sorter", "resenders", " senders", "nsink", "sener", " sensor", "reserver", "pender", "Sorter", "Senders", "Sender", "resener", "pend", "resender", "Sensor", "pener", "nsenders", "nsender", "nsend", "nserver", "nsener", "sidenders", "perver", "server", " send", "porter", "sidend"], "flags": ["status", "types", "workers", "config", "weights", "fs", "features", "ops", "bytes", "tails", "orts", "weight", "offset", "nl", "enabled", "fps", "fee", "args", "data", "ils", "ents", "vs", "cs", "fx", "prefix", "version", "addr", "stats", "ants", "Flags", "settings", "filename", "lag", "bits", "flag", "FLAG", "parts", "fl", "length", "fd", "mask", "len", "fields", " Flags", "options", "ats", "files", "ips", "feat", "states", "fun"], "buf": ["bc", "uf", "ref", "config", "cv", "func", "fp", "buffer", "path", "env", "alloc", "cmd", "msg", "data", "box", "args", "addr", "wb", "rc", "pool", "cb", "ctx", "b", "window", "raw", "flag", "seq", "length", "fd", "src", "len", "loc", "callback", "flow", "buff", "vec", "bag", "rb", "offset", "prop", "count"], "size": ["io", "ize", "pos", "use", "address", "data", "live", "small", "name", "ix", "end", "scale", "g", "eng", "ci", "fee", "unit", "izes", "code", "body", "c", "capacity", "SIZE", "empty", "position", "offset", "iz", "store", "ui", "time", "mode", "bytes", "weight", "new", "form", "length", "loc", "page", "z", "sec", "x", "count", "limit", "shape", "en", "Size", "args", "storage", "cache", "content", "source", "len", "large", "parent"], "sent_cb": [" sent_Callback", " sent_data", "sentitycd", "sentfnc", "sentablecd", " sent_rb", " sent_nc", "sentablecor", "sentitycor", " sent_cd", "sentfCallback", "sent_code", "sent_cor", "sentitycb", " sent_fn", "sent_Callback", "sent_cd", "sent_rb", "sent_callback", "sent_fn", " sent_code", "sentablecb", "sentfcallback", "sentitycallback", "sentablecallback", "sentfcb", " sent_cor", "sent_nc", " sent_callback", "sent_data"], "packet": ["payacket", "compart", "competer", "passeter", " Packacket", "competing", "payett", "comppt", "compec", "packageet", " packant", "compett", "pad", "packeter", "payeter", "packageec", " packend", "hooketer", "packct", "packacker", "compant", "pacacket", "packacket", "compat", "packart", "hookacket", "compset", "ppeter", "ppet", " packeter", "passacket", " Packet", "ppacket", "passet", "packett", "compend", "pat", " packart", "assacket", "packpt", "compet", " packacket", "packec", "pacet", "packageant", "assacker", "compct", " Packart", " packset", " Packpt", "pet", "compad", "paceting", "packageacket", "asset", "compacket", "payet", "packat", "packeting", "packageart", "hookct", " packct", " packad", " packec", " packat", "packset", "compacker", "packend", "pacacker", "packad", "packant", "asseting", "packageend", " packpt", "passett", "ppset", "hooket"]}}
{"project": "qemu", "commit_id": "ba9c5de5f2d33d468a07a8794121472ea031a0b5", "target": 0, "func": "void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,\n\n                                 bool is_write, bool is_exec, int unused,\n\n                                 unsigned size)\n\n{\n\n    AlphaCPU *cpu = ALPHA_CPU(cs);\n\n    CPUAlphaState *env = &cpu->env;\n\n\n\n    env->trap_arg0 = addr;\n\n    env->trap_arg1 = is_write ? 1 : 0;\n\n    dynamic_excp(env, 0, EXCP_MCHK, 0);\n\n}\n", "idx": 11833, "substitutes": {"cs": ["ks", "ds", "c", "cp", "ls", "ace", "qs", "cf", "cn", "wcs", "ec", "cc", "ac", "acs", "ce", "rc", "ras", "sync", "CS", "ics", "cas", "cons", "ctx", "ns", "pc", "spec", "cms", "sys", "ca", "ci", "fs", "ps", "css", "lc", "cus", "sc", "Cs"], "addr": ["setup", "alias", "mac", "base", "cmp", "len", "val", "prefix", "pad", "conn", "src", "x", "pointer", "ad", "ref", "config", "ace", "attr", "ptr", "args", "socket", "mode", "dr", "host", "pkg", "index", "alloc", "oa", "rc", "name", "proxy", "r", "ctx", "address", "nr", "offset", "node", "eth", "pos", "ip", "cmd", "proc"], "is_write": ["is__writing", " is_writ", " is_written", " is_writing", "is_writ", "is__writ", " is_read", "is_read", "is__read", "is_writing", "is__write", "is_written", "is__written"], "is_exec": ["is___execute", "is__exclusive", "is_exclusive", " is_read", "is_read", " is_exclusive", " is__read", "is__read", " is__exclusive", "is__execute", "is___read", " is_execute", " is__execute", "is___exec", "is___exclusive", "is__exec", " is__exec", "is_execute"], "unused": ["uninitialized", "nused", "nuse", "onusable", "unusable", " unuse", "nusable", " uninitialized", "ninitialized", "unuse", "onused", "onuse", " unusable", "oninitialized"], "size": ["count", " bytes", "timeout", "len", "capacity", "SIZE", "mem", "data", "s", "max", "memory", "empty", "Size", "sec", "mode", "unit", "alloc", "cap", "name", "rc", "ctx", "address", "blocks", "offset", "bytes", "length", "ize"], "cpu": ["parent", " cp", "uca", "cow", "kernel", "cmp", "processor", "conn", "gpu", "bench", "net", "ne", "cp", "vm", "c", "ace", "cli", "np", "uci", "cn", "ec", "eni", "ac", "console", "unit", "ea", "clock", "ctx", "pu", "pc", "node", "cpp", "CPU", "nc", "cache", "lc", "proc", "core", "fc"], "env": ["vs", "inet", "context", "ext", "conn", "estate", "ini", "viron", "export", "ne", "environment", "vm", "config", "el", "enable", "stack", "e", "ace", "np", "global", "nw", "act", "args", "ec", "eni", "style", "cf", "network", "er", "db", "console", "ev", "skin", "eval", "exc", "scope", "energy", "ea", "oa", "edge", "state", "ctx", "loader", "en", "err", "Environment", "enc", "pect", "init", "cfg", "nc", "et", "eye", " environment", "extra", "site", "cache", "agent", "engine", "eu", "core", "settings"]}}
{"project": "qemu", "commit_id": "b4548fcc0314f5e118ed45b5774e9cd99f9a97d3", "target": 1, "func": "static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    IRQMP      *irqmp = opaque;\n\n    IRQMPState *state;\n\n\n\n    assert(irqmp != NULL);\n\n    state = irqmp->state;\n\n    assert(state != NULL);\n\n\n\n    addr &= 0xff;\n\n\n\n    /* global registers */\n\n    switch (addr) {\n\n    case LEVEL_OFFSET:\n\n        return state->level;\n\n\n\n    case PENDING_OFFSET:\n\n        return state->pending;\n\n\n\n    case FORCE0_OFFSET:\n\n        /* This register is an \"alias\" for the force register of CPU 0 */\n\n        return state->force[0];\n\n\n\n    case CLEAR_OFFSET:\n\n    case MP_STATUS_OFFSET:\n\n        /* Always read as 0 */\n\n        return 0;\n\n\n\n    case BROADCAST_OFFSET:\n\n        return state->broadcast;\n\n\n\n    default:\n\n        break;\n\n    }\n\n\n\n    /* mask registers */\n\n    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {\n\n        int cpu = (addr - MASK_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->mask[cpu];\n\n    }\n\n\n\n    /* force registers */\n\n    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {\n\n        int cpu = (addr - FORCE_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->force[cpu];\n\n    }\n\n\n\n    /* extended (not supported) */\n\n    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {\n\n        int cpu = (addr - EXTENDED_OFFSET) / 4;\n\n        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);\n\n\n\n        return state->extended[cpu];\n\n    }\n\n\n\n    trace_grlib_irqmp_unknown_register(\"read\", addr);\n\n    return 0;\n\n}\n", "idx": 24899, "substitutes": {"opaque": ["obaca", "opsaques", "OPya", "ospacity", "opaca", "OPacity", "opsaque", "ospac", "oppaca", "opac", "opaques", " opac", "opatile", "ospaque", "opsatile", "OPac", "ospya", "oppaques", "opya", " opacity", " opya", "oppaque", "opsaca", "opacity", "obatile", "obaques", "OPaque", "obaque", "oppatile"], "addr": ["ref", "socket", "frame", "name", "pkg", "callback", "base", "ld", "add", "cb", "url", "arr", "cmd", "sta", "ord", "edge", "hop", "ptr", "osi", "nc", "layer", "md", "code", "arm", "rpm", "x", "hard", "ad", "align", "address", "prefix", "port", "proc", "cmp", "point", "work", "wd", "fx", "oa", "ost", "src", "attr", "rr", "len", "kt", "node", "args", "byte", "np", "data", "pointer", "nn", "mac", "alias", "adr", "la", "afi", "offset", "mode", "ar", "req", "ack", "xp", "reg", "host", "ha", "intel", "dc", "dr", "hd", "asm", "clock", "config", "vr", "dd", "id", "pad", "nick", "amp", "grad", "cpu", "advert", "eth", "loc", "slot", "art", "device", "amd", "handle", "ext", "rt", "ip", "index", "conn", "arp", "route", "adder", "ace"], "irqmp": ["irgmp", "irqump", "Irqump", "ircmp", "irQMP", "irqm", "irqqmp", "ircepy", "ircema", " irqpm", "IrquMP", "Irqpy", "Irqmm", "iriqumb", "irqpy", "irqqmb", "irqum", "Irqumm", "irqumm", "irgmm", "irqma", "irgpm", "irqpm", "ircemm", "Irqupy", "ircemp", "iriqmb", " irgpm", "irquma", " irgmm", "irchpm", "irgMP", "irqupy", "irchmp", "irqmm", "iriqmp", "irqmb", "ircem", "ircmm", "ircpy", "irqumb", " irgMP", "iriqma", "irqqma", "irchmm", "ircemb", "iriqum", "irQmp", " irqMP", "irQpm", "IrqMP", "irQmm", "irquMP", "iriqump", "irchMP", "ircMP", "Irqmp", " irgmp", "iriquma", "irqMP", " irqmm", "irqqm", "irceMP", "iriqm"], "state": ["call", "param", "name", "manager", "State", "dict", "states", "sync", "self", "seed", "set", "start", "progress", "object", "STATE", "level", "note", "part", "status", "list", "print", "val", "code", "body", "slice", "er", "se", "test", "address", "port", "store", "key", "patch", "work", "resource", "spec", "new", "cache", "notice", "rule", "value", "event", "map", "node", "scope", "parse", "force", "data", "trace", "component", "error", "push", "all", "e", "step", "open", "message", "err", "session", "mode", "parent", "grade", "stat", "order", "size", "length", "count", "source", "ke", "connection", "statement", "lock", "tag", "info", "master", "style", "config", "type", "o", "estate", "co", "conn", "ace", "range"]}}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_handle_byte(int ch)\n\n{\n\n    switch(term_esc_state) {\n\n    case IS_NORM:\n\n        switch(ch) {\n\n        case 1:\n\n            term_bol();\n\n            break;\n\n        case 4:\n\n            term_delete_char();\n\n            break;\n\n        case 5:\n\n            term_eol();\n\n            break;\n\n        case 9:\n\n            term_completion();\n\n            break;\n\n        case 10:\n\n        case 13:\n\n            term_cmd_buf[term_cmd_buf_size] = '\\0';\n\n\t    term_hist_add(term_cmd_buf);\n\n            term_printf(\"\\n\");\n\n            term_handle_command(term_cmd_buf);\n\n            term_show_prompt();\n\n            break;\n\n        case 27:\n\n            term_esc_state = IS_ESC;\n\n            break;\n\n        case 127:\n\n        case 8:\n\n            term_backspace();\n\n            break;\n\n\tcase 155:\n\n            term_esc_state = IS_CSI;\n\n\t    break;\n\n        default:\n\n            if (ch >= 32) {\n\n                term_insert_char(ch);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n    case IS_ESC:\n\n        if (ch == '[') {\n\n            term_esc_state = IS_CSI;\n\n            term_esc_param = 0;\n\n        } else {\n\n            term_esc_state = IS_NORM;\n\n        }\n\n        break;\n\n    case IS_CSI:\n\n        switch(ch) {\n\n\tcase 'A':\n\n\tcase 'F':\n\n\t    term_up_char();\n\n\t    break;\n\n\tcase 'B':\n\n\tcase 'E':\n\n\t    term_down_char();\n\n\t    break;\n\n        case 'D':\n\n            term_backward_char();\n\n            break;\n\n        case 'C':\n\n            term_forward_char();\n\n            break;\n\n        case '0' ... '9':\n\n            term_esc_param = term_esc_param * 10 + (ch - '0');\n\n            goto the_end;\n\n        case '~':\n\n            switch(term_esc_param) {\n\n            case 1:\n\n                term_bol();\n\n                break;\n\n            case 3:\n\n                term_delete_char();\n\n                break;\n\n            case 4:\n\n                term_eol();\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        term_esc_state = IS_NORM;\n\n    the_end:\n\n        break;\n\n    }\n\n    term_update();\n\n}\n", "idx": 7992, "substitutes": {"ch": ["cp", "quit", "cr", "chin", "cur", "count", "Char", "ech", "chi", "change", "channel", "prev", "kick", "che", "quote", "last", "i", "enc", "cy", "tch", "cha", "ich", "th", "cl", "chu", "state", "length", "cher", "q", "u", "code", "Ch", "cell", "col", "sh", "power", "cho", "k", "cor", "cmd", "ctx", "zh", "sch", "character", "qu", "p", "chn", "h", "cht", "c", "range", "y", "utf", "chan", "ach", "CH", "cod", "text", "command", "och", "inch"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    EEPRO100State *s = opaque;\n\n\n\n    switch (size) {\n\n    case 1: return eepro100_read1(s, addr);\n\n    case 2: return eepro100_read2(s, addr);\n\n    case 4: return eepro100_read4(s, addr);\n\n    default: abort();\n\n    }\n\n}\n", "idx": 13155, "substitutes": {"opaque": ["OPec", "Opaque", " opctx", "opec", "oppaques", "Opctx", "oppacity", "opatile", "oppaque", "oppatile", "operacity", "ipopatile", "opaques", "ipopacity", "operaque", "ipopaque", "opacity", "OPacity", "operatile", "ipopaques", "Opec", " opacity", "OPctx", "Opacity", " opec", "OPaque", "opctx", "operaques"], "addr": ["ord", "args", "device", "port", "edge", "part", "adder", "amd", "config", "i", "oa", "a", "align", "image", "null", "x", "ref", "ace", "server", "error", "np", "index", "grad", "adr", "ad", "p", "e", "layer", "rx", "socket", "data", "pointer", "base", "byte", "mode", "point", "padding", "address", "ip", "type", "offset", "cmd", "host", "r", "src", "seq", "nr", "dr", "pos", "pad", "len", "ptr", "node", "xxx", "start"], "size": ["args", "en", "small", "sync", "enc", "sized", "code", "shape", "or", "g", "align", "Size", "bytes", "x", "capacity", "loc", "z", "ize", "e", "sec", "length", "n", "from", "mode", "address", "c", "timeout", "SIZE", "type", "offset", "sn", "scale", "empty", "fee", "len"], "s": ["secondary", "south", "ses", "m", "slice", "d", "service", "t", "sync", "fs", "sym", "a", "g", "S", "settings", "os", "status", "si", "es", "scope", "sq", "session", "server", "ss", "o", "request", "an", "u", "p", "e", "instance", "socket", "http", "sf", "sb", "b", "n", "f", "stat", "address", "spec", "c", "ns", "is", "ssl", "side", "sl", "r", "sie", "us", "aws"]}}
{"project": "FFmpeg", "commit_id": "c81185a18333b28439476fdc00979225158c8755", "target": 1, "func": "void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height){\n\n    int w_align= 1;\n\n    int h_align= 1;\n\n\n\n    switch(s->pix_fmt){\n\n    case PIX_FMT_YUV420P:\n\n    case PIX_FMT_YUYV422:\n\n    case PIX_FMT_UYVY422:\n\n    case PIX_FMT_YUV422P:\n\n    case PIX_FMT_YUV444P:\n\n    case PIX_FMT_GRAY8:\n\n    case PIX_FMT_GRAY16BE:\n\n    case PIX_FMT_GRAY16LE:\n\n    case PIX_FMT_YUVJ420P:\n\n    case PIX_FMT_YUVJ422P:\n\n    case PIX_FMT_YUVJ444P:\n\n    case PIX_FMT_YUVA420P:\n\n        w_align= 16; //FIXME check for non mpeg style codecs and use less alignment\n\n        h_align= 16;\n\n\n\n        break;\n\n    case PIX_FMT_YUV411P:\n\n    case PIX_FMT_UYYVYY411:\n\n        w_align=32;\n\n        h_align=8;\n\n        break;\n\n    case PIX_FMT_YUV410P:\n\n        if(s->codec_id == CODEC_ID_SVQ1){\n\n            w_align=64;\n\n            h_align=64;\n\n        }\n\n    case PIX_FMT_RGB555:\n\n        if(s->codec_id == CODEC_ID_RPZA){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n    case PIX_FMT_PAL8:\n\n    case PIX_FMT_BGR8:\n\n    case PIX_FMT_RGB8:\n\n        if(s->codec_id == CODEC_ID_SMC){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    case PIX_FMT_BGR24:\n\n        if((s->codec_id == CODEC_ID_MSZH) || (s->codec_id == CODEC_ID_ZLIB)){\n\n            w_align=4;\n\n            h_align=4;\n\n        }\n\n        break;\n\n    default:\n\n        w_align= 1;\n\n        h_align= 1;\n\n        break;\n\n    }\n\n\n\n    *width = ALIGN(*width , w_align);\n\n    *height= ALIGN(*height, h_align);\n\n    if(s->codec_id == CODEC_ID_H264)\n\n        *height+=2; // some of the optimized chroma MC reads one line too much\n\n}", "idx": 21899, "substitutes": {"s": ["sv", "sim", "sb", "i", "native", "e", "sym", "qs", "es", "space", "support", "sci", "sl", "fs", "g", "ses", "site", "ks", "l", "ds", "services", "f", "sys", "t", "j", "ssl", "os", "ts", "cs", "p", "us", "ls", "sync", "is", "ss", "sa", "sg", "c", "js", "settings", "spec", "si", "a", "service", "se", "n", "S", "ns", "sup", "session", "sf", "south", "rs", "gs", "ps", "conf", "su", "sq"], "height": ["view", "row", "shape", "end", "level", "layout", "style", "align", "build", "pad", "Height", "rank", "y", "size", "data", "hang", "depth", "crop", "index", "distance", "pull", "window", "w", "stroke", "top", "length", "angle", "alpha", "volume", "gap", "h", "image", "resolution", "bottom", "arrow", "x", "high", "max", "block", "padding"]}}
{"project": "qemu", "commit_id": "44bc910794eff956ceba0030f0751a26bed748b5", "target": 0, "func": "static int get_physical_address(CPUPPCState *env, mmu_ctx_t *ctx,\n\n                                target_ulong eaddr, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n#if 0\n\n    qemu_log(\"%s\\n\", __func__);\n\n#endif\n\n    if ((access_type == ACCESS_CODE && msr_ir == 0) ||\n\n        (access_type != ACCESS_CODE && msr_dr == 0)) {\n\n        if (env->mmu_model == POWERPC_MMU_BOOKE) {\n\n            /* The BookE MMU always performs address translation. The\n\n               IS and DS bits only affect the address space.  */\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n        } else if (env->mmu_model == POWERPC_MMU_BOOKE206) {\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                                   access_type);\n\n        } else {\n\n            /* No address translation.  */\n\n            ret = check_physical(env, ctx, eaddr, rw);\n\n        }\n\n    } else {\n\n        ret = -1;\n\n        switch (env->mmu_model) {\n\n        case POWERPC_MMU_32B:\n\n        case POWERPC_MMU_601:\n\n            /* Try to find a BAT */\n\n            if (env->nb_BATs != 0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                /* We didn't match any BAT entry or don't have BATs */\n\n                ret = get_segment32(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n        case POWERPC_MMU_SOFT_6xx:\n\n        case POWERPC_MMU_SOFT_74xx:\n\n            /* Try to find a BAT */\n\n            if (env->nb_BATs != 0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                /* We didn't match any BAT entry or don't have BATs */\n\n                ret = get_segment_6xx_tlb(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n#if defined(TARGET_PPC64)\n\n        case POWERPC_MMU_64B:\n\n        case POWERPC_MMU_2_06:\n\n        case POWERPC_MMU_2_06d:\n\n            ret = get_segment64(env, ctx, eaddr, rw, access_type);\n\n            break;\n\n#endif\n\n\n\n        case POWERPC_MMU_SOFT_4xx:\n\n        case POWERPC_MMU_SOFT_4xx_Z:\n\n            ret = mmu40x_get_physical_address(env, ctx, eaddr,\n\n                                              rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE:\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE206:\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                               access_type);\n\n            break;\n\n        case POWERPC_MMU_MPC8xx:\n\n            /* XXX: TODO */\n\n            cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n            break;\n\n        case POWERPC_MMU_REAL:\n\n            cpu_abort(env, \"PowerPC in real mode do not do any translation\\n\");\n\n            return -1;\n\n        default:\n\n            cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n#if 0\n\n    qemu_log(\"%s address \" TARGET_FMT_lx \" => %d \" TARGET_FMT_plx \"\\n\",\n\n             __func__, eaddr, ret, ctx->raddr);\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 15779, "substitutes": {"env": ["en", "enh", "esp", "oa", "event", "server", "np", "obj", "dev", "spec", "c", "ec", "chal", "context", "cdn", "eu", "lc", "txt", "vm", "console", "equ", "viron", "fi", "eni", "dt", "qv", "cal", "exec", "cache", "ev", "ou", "lv", "iss", "erv", "ea", "cv", "config", "kn", "init", "scope", "conn", "e", "exc", "engine", "nc", "site", "eng", "qt", "Environment", "dep", "global", "ne", "osc", "que", "pos", "cur", "hw", "net", "enc", "act", "v", "conf", "inv", "energy", "chn", "cli", "dat", "shell", "org", "db", "environment", "util", "vs", "et", "esi"], "ctx": ["sem", "proc", "context", "ch", "tx", "pkg", "bc", "qa", "gz", "cv", "enc", "tk", "rc", "config", "sync", "jp", "ca", "utils", "lc", "ctrl", "ci", "qs", "conv", "cn", "wcs", "cmp", "linux", "fp", "ct", "loc", "conf", "conn", "kw", "np", "lib", "obj", "client", "exc", "cli", "nc", "kt", "qt", "inst", "state", "c", "cu", "cb", "cas", "sci", "sc", "cf", "exec", "que", "vc", "xc", "src", "environment", "git", "hw", "cl", "fw"], "eaddr": ["asyhr", "adydr", "efdr", "cehr", "reamric", "cedr", "cefr", "oadric", "ewayder", "adybr", "ealdress", "asydr", "ealdr", "asyfr", "ewaydr", "eadder", "reamder", "ecdr", "egdr", "eadDr", "ewayDr", "eybr", "eadfr", "ellhr", "eadhr", "eadbr", "adyhr", "eyhr", "ellfr", "ealder", "adyDR", "ayder", "asyDR", "egdress", "ecDR", "ecDr", "eadDR", "ayDR", "oadder", "eghr", "egder", "ealDR", "eeddr", "egbr", "ayric", "eadric", "efDr", "egfr", "efDR", "eedder", "aydr", "ellder", "ecder", "ayfr", "eedDR", "oadDR", "ceDR", "aydress", "asyder", "egDR", "oaddr", "ayhr", "ellDR", "eydr", "adyfr", "efder", "oadhr", "elldr", "eedfr", "ewayDR", "eyDR", "eaddress", "reamDR", "reamdr"], "rw": ["wer", "rr", "wk", "wh", "vr", "ru", "iw", "worker", "ww", "ew", "row", "rn", "wx", "rg", "sw", "wt", "wcs", "sr", "raw", "writer", "rh", "wn", "nw", "kw", "war", "w", "rew", "lr", "wal", "rb", "ring", "rx", "wb", "wu", "rack", "wp", "nor", "rl", "dra", "tw", "lv", "wa", "r", "resp", "vc", "work", "RW", "wo", "wl", "usr", "rf", "hw", "wd", "wr", "fw"], "access_type": ["accesstypetypes", " access_address", "access_role", "accessXlevel", "access_level", "access_site", " access_length", "accessabletype", "access_TYPE", "accessableaddress", "accesstypetype", "accessettype", "access_value", "accessablelevel", " access_model", " access_class", "accessalblock", "accessetvalue", "access_style", " access_level", " access_rel", " access_key", "accessentime", " access_value", "access_types", "access_model", "accessingTYPE", "access_block", "access_address", "access_field", "accessetclass", "accesstypelevel", "accessallength", "accessingtype", "accessingcode", " access_role", "access_length", "access_code", " access_types", " access_TYPE", "accessXtype", "accessalrole", "accessaltype", "accessallevel", "accesstypeaddress", " access_site", " access_field", " access_block", " access_style", "accessingkey", "accessalkey", "access_rel", "accessentype", "access_ver", " access_ver", "accessXmodel", " access_code", "accessabletypes", "access_class", " access_time", "access_key", "access_time", "accessenmodel"], "ret": ["pet", "alt", "ft", "let", "rev", "part", "reply", "art", "rc", "id", "val", "back", "def", "rets", "gt", "fun", "std", "status", "ref", "arg", "det", "lit", "error", "job", "aug", "feat", "pass", "ut", "obj", "mt", "mem", "info", "lt", "success", "match", "ext", "Ret", "bf", "result", "fit", " RET", "att", "rl", "url", "cat", "arr", "nt", "re", "rt", "resp", "db", "RET", "res", "num", "reg", "cur", "flag", "len", "opt", "bit", "err"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = ( 3 * dc +  1) >> 1;\n\n    dc = (17 * dc + 64) >> 7;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 4; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n", "idx": 5781, "substitutes": {"dest": ["master", "est", "miss", "done", "shape", "data", "delete", "status", "route", "ctr", "dom", "cont", "die", "Dest", "err", "hop", "access", "stage", "output", "trans", "head", "trip", "img", "mode", "option", "name", "id", "parent", "config", "null", "content", "dist", "table", "member", "target", "path", "usr", "node", "txt", "class", "ident", "text", "test", "end", "ui", "address", "origin", "tmp", "home", "loc", "wb", "db", "cl", "num", "select", "coord", "feat", "source", "temp", "prop", "transfer", "start", "orig", "contract", "west", "desc", "sup", "src", "dim", "sort", "session", "draw", "de", "rest", "lit", "dc", "cb", "result", "opt", "transform", "comb", "ord", "success", "cdn", "shift"], "linesize": [" linesizing", " linessize", "casesization", " linesiz", "nssize", "linesization", "casesize", "nsizing", "linedsize", "linediz", "nsize", "lineship", " lineship", "linship", "casesizing", "linesiz", "linsiz", "linssize", "linsize", "nsization", "linedhip", "linesizing", "casessize", "linedize", "linessize", " linesization"], "block": ["Block", "address", "pack", "row", "name", "clean", "word", "check", "chain", "config", "channel", "list", "object", "map", "unit", "cl", "num", "event", "table", "match", "def", "buffer", "col", "section", "comment", "bc", "lock", "load", "source", "blocks", "line", "none", "node", "contract", "type", "bl", "cache", "ref", "group", "end", "copy"], "i": ["gi", "ti", "v", "I", "count", "di", "ci", "ji", "ni", "x", "b", "io", "xi", "si", "abi", "info", "bi", "qi", "l", "f", "pi", "d", "j", "ii", "iu", "ai", "cli", "u", "e", "ami", "col", "uri", "k", "n", "multi", "mi", "ie", "p", "oi", "hi", "c", "ip", "api", "li", "fi", "index", "zi", "mu", "ui"], "cm": ["cp", "address", "dim", "cr", "dm", "hem", "gm", "rom", "comm", "iam", "vm", "om", "ci", "config", "sem", "com", "wm", "bm", "cy", "co", "module", "dem", "m", "rm", "ram", "pm", "cc", "param", "cum", "man", "center", "cont", "km", "mc", "em", "que", "CM", "cam", "hm", "dc", "cmd", "ctx", "cms", "car", "fm", "ca", "asm", "DC", "don", "am", "c", "im", "mm", "cn", "ym", "lc", "cf", "um", "rem", "ctrl", "mode", "cd", "tc"]}}
{"project": "qemu", "commit_id": "fbeadf50f2f965741def823036b086bbc2999b1f", "target": 1, "func": "unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\n\n\t\t\t\t unsigned long offset)\n\n{\n\n    const unsigned long *p = addr + BITOP_WORD(offset);\n\n    unsigned long result = offset & ~(BITS_PER_LONG-1);\n\n    unsigned long tmp;\n\n\n\n    if (offset >= size) {\n\n        return size;\n\n    }\n\n    size -= result;\n\n    offset %= BITS_PER_LONG;\n\n    if (offset) {\n\n        tmp = *(p++);\n\n        tmp |= ~0UL >> (BITS_PER_LONG - offset);\n\n        if (size < BITS_PER_LONG) {\n\n            goto found_first;\n\n        }\n\n        if (~tmp) {\n\n            goto found_middle;\n\n        }\n\n        size -= BITS_PER_LONG;\n\n        result += BITS_PER_LONG;\n\n    }\n\n    while (size & ~(BITS_PER_LONG-1)) {\n\n        if (~(tmp = *(p++))) {\n\n            goto found_middle;\n\n        }\n\n        result += BITS_PER_LONG;\n\n        size -= BITS_PER_LONG;\n\n    }\n\n    if (!size) {\n\n        return result;\n\n    }\n\n    tmp = *p;\n\n\n\nfound_first:\n\n    tmp |= ~0UL << size;\n\n    if (tmp == ~0UL) {\t/* Are any bits zero? */\n\n        return result + size;\t/* Nope. */\n\n    }\n\nfound_middle:\n\n    return result + ffz(tmp);\n\n}\n", "idx": 23888, "substitutes": {"addr": ["hp", "asm", "ref", "adr", "amp", "g", "oa", "ord", "amd", "align", "host", "pad", "nc", "r", "address", "ad", "ip", "ace", "prefix", "np", "buf", "dr", "rc", "nr", "inet", "ar", "ptr", "Address", "src", "slice", "alpha", "array", "pointer", "rb", "image", "x", "padding"], "size": ["confirmed", "i", "area", "esc", "es", "message", "extra", "ize", "pos", "order", "address", "data", "false", "last", "shift", "small", "negative", "n", "global", "since", "from", "name", "response", "end", "scale", "g", "term", "fee", "unit", "when", "code", "c", "complete", "capacity", "needed", "set", "see", "SIZE", "empty", "position", "sum", "e", "ui", "result", "sized", "bytes", "function", "white", "new", "score", "or", "number", "max", "answer", "num", "second", "si", "speed", "error", "length", "loc", "side", "page", "sec", "count", "shape", "start", "en", "send", "Size", "done", "cache", "storage", "change", "sync", "timeout", "source", "len", "large", "grade", "range", "value"], "offset": ["exclusive", "adjust", "after", "i", "limit", "start", "attribute", "end", "off", "ref", "next", "option", "result", "part", "origin", "extra", "oa", "disabled", "align", "no", "pos", "order", "optional", "address", "ace", "id", "prefix", "o", "initial", "operation", "shift", "count", "timeout", "number", "answer", "index", "second", "ptr", "set", "now", "location", "alias", "online", "error", "Offset", "length", "iterator", "slice", "loc", "len", "page", "range", "alpha", "array", "pointer", "aligned", "empty", "position", "attr", "padding", "type"], "p": ["i", "e", "ap", "jp", "lp", "g", "d", "P", "bp", "pc", "l", "fp", "f", "po", "t", "op", "r", "u", "m", "cp", "pre", "s", "tp", "pp", "ip", "point", "o", "np", "q", "py", "c", "wp", "a", "b", "x", "w", "n", "proc", "v", "pair", "sp", "pointer", "vp", "h", "api", "pi", "dp"], "tmp": ["sample", "config", "vt", "part", "extra", "copy", "temp", "pad", "bp", "emp", "buffer", "front", "cp", "address", "data", "tp", "shift", "crop", "slice", "test", "wx", "proc", "v", "pointer", "rb", "output", "attr", "sb", "binary", "txt", "jp", "bb", "tt", "fp", "pre", "treatment", "opt", "code", "buf", "c", "cb", "wp", "tf", "mp", "appy", "st", "opp", "prev", "wrapper", "result", "meta", "fb", "f", "cmp", "t", "zip", "tc", "gz", "cro", "b", "ptr", "sup", "loc", "page", "buff", "clip", "api", "start", "obj", "input", "po", "m", "storage", "cache", "pp", "np", "py", "kk", "source", "now", "stuff", "paper", "array", "sp"]}}
{"project": "qemu", "commit_id": "47c6d3ecdfc3fc354cf996f873a9f854c2325160", "target": 1, "func": "static const QObject *qmp_input_get_object(QmpInputVisitor *qiv,\n\n                                           const char *name)\n\n{\n\n    const QObject *qobj;\n\n\n\n    if (qiv->nb_stack == 0) {\n\n        qobj = qiv->obj;\n\n    } else {\n\n        qobj = qiv->stack[qiv->nb_stack - 1].obj;\n\n    }\n\n\n\n    if (name && qobject_type(qobj) == QTYPE_QDICT) {\n\n        return qdict_get(qobject_to_qdict(qobj), name);\n\n    } else if (qiv->nb_stack > 0 && qobject_type(qobj) == QTYPE_QLIST) {\n\n        return qlist_entry_obj(qiv->stack[qiv->nb_stack - 1].entry);\n\n    }\n\n\n\n    return qobj;\n\n}\n", "idx": 25734, "substitutes": {"qiv": ["sqoc", "waiva", "qenc", "phpiv", " qih", "quou", "qirc", " qirc", "qiver", "waiver", " qoc", "erhr", "qhr", " qiva", "dqiv", " qou", "qerv", "qou", "phpexp", "quIV", "waivist", " qroc", "phpIV", "qqenc", "sqiv", "questev", "quhr", "Qoy", "qroc", " qov", "qoc", "quenc", "sqroc", "quivo", "qqoc", "phpou", "quiver", "quivist", "quroc", " qoy", "sqivo", "dqoc", "qsiva", "eriva", "questiv", "erirc", "quih", "qov", "dqivo", "quiv", "sqivist", "qivist", "qsivist", " qIV", "sqirc", "questoc", "qsiv", "querv", "qqev", "questenc", "sqih", "questov", "quiva", "quev", "quirc", "qqiv", "qtirc", "Qenc", "eriv", "qterv", "qoy", "qtiv", " qexp", "qev", " qenc", "waiv", "qtiva", "qIV", "qih", "sqiva", " qhr", "qsiver", "qiva", "qexp", "questoy", "quexp", "sqerv", "qivo", "Qiv", "Qov", "quoc", "dqivist"], "name": ["space", "code", "class", "none", "time", "x", "data", "base", "label", "no", "style", "type", "prefix", "ame", "id", "alias", "self", "Name", "key", "resource", "path", "search", "common", "object", "parent", "word", "new", "size", "part", "comment", "NAME", "named", "value", "n", "entry", "names", "null", "core", "nam", "known"], "qobj": ["kaj", "capi", "qtmp", "qlib", "questcdn", "eqopt", "sqbj", "dqobject", "kobi", "Qorb", "qcdn", "qbh", "qapi", "qopt", "sqopt", "sqobb", "questlib", "kapi", "qqobb", " qtmp", "quobject", "questaj", "questobi", "playocl", "kcdn", "Qobj", "klib", "questobj", "dqobj", "playobject", "wob", "qobi", "sqlib", "cbh", "dqorb", "cocl", "worb", "eqobj", "quobj", "qbj", "eqobb", "kobject", "eqlib", "sqaj", "qqopt", "Qob", "qualobject", "kbj", "qutmp", "qqobj", "questobject", "wobj", "qualob", "sqobi", "qqlib", "sqobject", "qualobj", "eqbh", "Qobject", "wobject", "kobj", "qobb", "eqobject", "qorb", "qaj", "cobj", "cobject", "eqcdn", "qob", " qorb", "quorb", "sqobj", "playbh", "eqocl", "cbj", "dqtmp", "qualorb", "qocl", "playobj", " qobject", "sqapi", "qobject"]}}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_log(int argc, const char **argv)\n\n{\n\n    int mask;\n\n    \n\n    if (argc != 2)\n\n        goto help;\n\n    if (!strcmp(argv[1], \"none\")) {\n\n        mask = 0;\n\n    } else {\n\n        mask = cpu_str_to_log_mask(argv[1]);\n\n        if (!mask) {\n\n        help:\n\n            help_cmd(argv[0]);\n\n            return;\n\n        }\n\n    }\n\n    cpu_set_log(mask);\n\n}\n", "idx": 14413, "substitutes": {"argc": ["argsc", "Argrc", "Argc", "Argsc", "argrc", "tagc", "igxc", " argrc", "Argpc", " argxc", "igc", "tagsc", "agpc", "argpc", "iglc", "igrc", "Argxc", "Arglc", " arglc", "tagfc", "agfc", "argxc", "argfc", "arglc", "agsc", "Argfc", "agc", "tagpc"], "argv": ["argsc", "argsf", "Argv", "Argc", "argval", "opc", " argp", "tagc", "Argf", "opv", "tagv", "Argp", "arval", "arf", "tagp", "tagsv", "argsv", "opsv", "argsp", " argval", "opp", "arp", "argp", "argf", "argssv", "arv", " argf", "argsval", " argsv"], "mask": ["zip", "bug", "map", "qa", "array", "allow", "id", "code", "unk", "style", "pixel", "weight", "image", "sk", "mark", "hack", "ace", "sum", "comment", "key", "like", "patch", "Mask", "scan", "fix", "filter", "check", "group", "clean", "cost", "sign", "info", "match", "data", "ck", "ask", "count", "result", "parent", "cover", "black", "block", "iq", "offset", "broad", "scale", "ack", "cache", "work", "lock", "ban", "delay", "flag", "strip", "bit", "cloud"]}}
{"project": "FFmpeg", "commit_id": "5c2fb561d94fc51d76ab21d6f7cc5b6cc3aa599c", "target": 0, "func": "static int h264_decode_frame(AVCodecContext *avctx, void *data,\n\n                             int *got_frame, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    H264Context *h     = avctx->priv_data;\n\n    AVFrame *pict      = data;\n\n    int buf_index      = 0;\n\n    int ret;\n\n    const uint8_t *new_extradata;\n\n    int new_extradata_size;\n\n\n\n    h->flags = avctx->flags;\n\n    h->setup_finished = 0;\n\n\n\n    /* end of stream, output what is still in the buffers */\n\nout:\n\n    if (buf_size == 0) {\n\n        H264Picture *out;\n\n        int i, out_idx;\n\n\n\n        h->cur_pic_ptr = NULL;\n\n\n\n        // FIXME factorize this with the output code below\n\n        out     = h->delayed_pic[0];\n\n        out_idx = 0;\n\n        for (i = 1;\n\n             h->delayed_pic[i] &&\n\n             !h->delayed_pic[i]->f->key_frame &&\n\n             !h->delayed_pic[i]->mmco_reset;\n\n             i++)\n\n            if (h->delayed_pic[i]->poc < out->poc) {\n\n                out     = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n\n\n        if (out) {\n\n            ret = output_frame(h, pict, out->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n\n\n        return buf_index;\n\n    }\n\n\n\n    new_extradata_size = 0;\n\n    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,\n\n                                            &new_extradata_size);\n\n    if (new_extradata_size > 0 && new_extradata) {\n\n        ret = ff_h264_decode_extradata(new_extradata, new_extradata_size,\n\n                                       &h->ps, &h->is_avc, &h->nal_length_size,\n\n                                       avctx->err_recognition, avctx);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    buf_index = decode_nal_units(h, buf, buf_size);\n\n    if (buf_index < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n\n        buf_size = 0;\n\n        goto out;\n\n    }\n\n\n\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n\n            return 0;\n\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||\n\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n\n        if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)\n\n            decode_postinit(h, 1);\n\n\n\n        ff_h264_field_end(h, &h->slice_ctx[0], 0);\n\n\n\n        *got_frame = 0;\n\n        if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) ||\n\n                                   h->next_output_pic->recovered)) {\n\n            if (!h->next_output_pic->recovered)\n\n                h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT;\n\n\n\n            ret = output_frame(h, pict, h->next_output_pic->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n    }\n\n\n\n    assert(pict->buf[0] || !*got_frame);\n\n\n\n    return get_consumed_bytes(buf_index, buf_size);\n\n}\n", "idx": 10554, "substitutes": {"avctx": ["afconn", "afctx", "AVcn", "afcfg", "evcf", "avectx", "awcontext", "afctl", "avcf", "evcontext", "avsci", " avctl", "avcu", "AVcontext", "afcf", "afcu", "avectl", "avconn", "AVctx", " avcontext", "avcontext", "awctx", "evconn", " avconn", "avcfg", "afsci", "AVcfg", "avesci", " avcf", "evctx", "afloc", "afcn", "awcu", "awcfg", " avsci", "awcn", " avloc", "aveloc", "avecf", "AVcu", "avecontext", "avctl", "afcontext", "avcn", "avloc"], "data": ["parent", "channel", "img", "context", "val", "in", "media", "window", "da", "capt", "block", "head", "config", "p", "reader", "batch", "qa", "feed", "memory", "frame", "empty", "tmp", "body", "f", "DATA", "next", "code", "dat", "size", "slice", "input", "connection", "response", "content", "fat", "picture", "load", "new", "Data", "message", "api", "client", "header", "video", "image", "result", "cache", "buff", "a", "proc", "buffer"], "got_frame": ["got__frame", "gotqsample", "getting__frames", "gotoffframes", "got__frames", "got__sample", "getting_frames", "gotqframes", "get_frame", "getting_iframe", "get_sample", "get_value", "gotqiframe", "got__iframe", "getting__iframe", "got_sample", "getting_sample", "got_iframe", "got___value", "gotqframe", "gotoffvalue", "got___frame", "gotoffframe", "getting_frame", "got_frames", "getting__sample", "get_frames", "got_value", "getting__frame", "got___sample", "gotoffsample", "got___frames"], "avpkt": ["avwpacket", "avcpcht", "abfacket", "afckt", "avpkn", " avpet", "avspct", "abpsth", "avcpkt", "avpct", "avpek", "navpcht", "afpdt", "avwpkn", " avfput", "afpkt", "avfpet", "avjpkt", "afcelt", "avpekt", "avcacket", "navpacket", "avnpdt", "avwpsth", "avpeacket", "abpkt", "avcpacket", "avjpkn", "avfkt", "navpkt", " avpait", "avnpelt", "avnput", "avfpkt", "avspkt", "afpelt", "avfput", "avtpkt", "avcdt", "abfsth", "abfkt", "afpct", "abpkn", "avtpet", "avpdt", "avnpct", "avcct", "navpeacket", "avjpsth", "avtpait", "avfsth", "abfkn", "avnpkt", "avfacket", "avpelt", "navpekt", "afcdt", "avwpkt", "avpet", "navpk", "avcelt", "avtput", "avckt", " avput", "avcpk", "avpsth", "avpacket", "avnpait", " avfpkt", "avjpacket", " avfpet", "avck", "avfpait", "navpecht", "avnpet", "avpait", "avpecht", "abpacket", "avccht", " avfpait", "avspdt", "avput", "avfkn", "avspelt", "navpek", "avpcht", "afcct", "avpk"], "buf": ["uf", "seq", "Buffer", "img", "ph", "path", "pool", "block", "fb", "batch", "config", "cb", "fp", "queue", "cf", "rb", "tmp", "alloc", "cv", "cas", "conv", "cat", "buff", "cmd", "proc", "buffer", "box", "uc"], "h": ["l", "hi", "sh", "he", "ht", "dh", "n", "g", "han", "ph", "hr", "auth", "hh", "w", "m", "ich", "http", "t", "b", "d", "c", "adh", "work", "hm", "p", "help", "gh", "eh", "q", "hw", "f", "hal", "j", "host", "zh", "ha", "th", "v", "bh", "ih", "home", "ctx", "hy", "en", "hp", "him", "hash", "hs", "oh", "kh", "hub", "hd", "this", "u", "H", "handler", "hl", "self", "beh", "header", "image", "ah", "ch", "y", "um", "hu", "rh", "uh"], "pict": ["dq", "img", "def", "conn", "path", " pic", "pty", "pid", "stat", "fw", "capt", "doc", "ct", "config", "p", "obj", "qa", "cli", "fp", "txt", "gui", "tmp", "pai", "fa", "fat", "photo", "ctx", "pic", "picture", "mat", "avi", "mot", "fig", "init", "fin", "cat", "image", "ch", "buff", "proc", "feat", "fi"], "ret": ["count", "base", "fail", "red", "ref", "arg", "reg", "gt", "code", "att", "pret", "re", " RET", "url", "let", "resp", "flag", "val", "no", "id", "Ret", "mem", "post", "last", "value", "db", "res", "bf", "det", "msg", "en", "error", "back", "mt", "rl", "rf", "std", "nb", "alt", "len", "class", "def", "nt", "num", "reply", "usr", "rb", "rt", "rc", "fun", "part", "fin", "cat", "result", "sr", "success", "pass", "active", "run", "lit", "obj", "rets", "bit", "RET", "ft", "bin", "rev", "match", "feat", "pet"], "new_extradata": ["new_externalradta", "new_externaladade", "new_extradada", "new_extracada", "new_externalpartata", "new_extrafade", "new_extrataton", "new_extradta", "new_extpartATA", "new_externalradada", "new_extadata", "new_extrafaton", "new_extrastaton", "new_extvardaton", "new_extadATA", "new_extarcada", "new_extvardada", "new_extadta", "new_extracata", "new_extadada", "new_extradica", "new_extpartoint", "new_externalpartATA", "new_externalradATA", "new_externalradica", "new_externalradaton", "new_externaladta", "new_externalradoint", "new_extarcoint", "new_extrafta", "new_extrafata", "new_extrastata", "new_extracica", "new_extvardica", "new_externaladata", "new_extrastada", "new_extratata", "new_extratade", "new_extpartada", "new_extadade", "new_externalpartada", "new_extarcATA", "new_extradaton", "new_extracaton", "new_externalradade", "new_extadoint", "new_externaladica", "new_extradATA", "new_externaladaton", "new_externaladada", "new_extadaton", "new_externalradata", "new_extrastta", "new_extarcata", "new_externalpartoint", "new_extadica", "new_extrafada", "new_extvardata", "new_extpartata", "new_extradoint", "new_extradade", "new_extratada"], "new_extradata_size": ["new_extradada_Size", "new_extradata_Size", "new_extradata_small", "new_extradada_capacity", "new_extradata_name", "new_extradata_address", "new_extradata_capacity", "new_extradada_size", "new_extradada_address", "new_extradata_number", "new_extradada_scale", "new_extradata_scale", "new_extradada_name", "new_extradada_number", "new_extradada_small"], "out": ["parent", "img", " in", "again", "m", "point", "path", "x", "net", "config", "at", "step", "call", "opt", "v", "connection", "err", "init", "image", "flat", "picture", "timeout", "n", "prefix", "w", "outer", "Out", "b", "plain", "c", "output", "hard", "tmp", "f", "format", "input", "conv", "error", "wx", "u", "ext", "str", "g", "test", "conn", "o", "sync", "raw", "home", "new", "OUT", "part", "after", "copy", "cat", "a", "cache", "cmd", "dot", "yout", "in", "update", "batch", "p", "obj", "qa", "off", "lib", "inc", "name", "inner", "user", "option", "client", "loop", "io", "write", "proc", "cgi"], "i": ["oi", "l", "hi", "ui", "di", "it", "si", "g", "in", "zi", "info", "xi", "id", "x", "ini", "my", "d", "c", "ji", "p", "uri", "ix", "e", "yi", "cli", "mini", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "slice", "gi", "mi", "phi", "ti", "name", "chi", "abi", "qi", "inner", "pi", "bi", "ii", "init", "u", "idi", "I", "li", "ip", "ci", "a", "io", "ni", "y", "api", "ri", "ori", "lc", "fi", "iu", "ki"], "out_idx": ["out_ider", "out_indb", "out_ideX", "out_ridx", "out_idex", "out_idb", "out_idX", "out__inc", "out_ridc", "outxidp", "out__idc", "out_index", "out_indp", "out_indw", "outxidb", "out__idv", "out_idp", "out_ridxe", "out_idy", "out_idv", "out_idxe", "out__inx", "outxidx", "out__idx", "out_idc", "out_inc", "out_ridy", "out_inxc", "out_inb", "out_indv", "out_idw", "out_ridex", "out__idex", "out_endx", "out_endxe", "out_inv", "out_indc", "out_idxc", "out_idew", "outxindp", "out_indxc", "out_indr", "out_indx", "out__inex", "outxidxc", "out__inv", "out_endy", "out_idr", "outxindx", "outxindb", "out_ridX", "out_inex", "out_inp", "out_endX", "out_indX", "out_ridv", "outxindxc", "out_inx"]}}
{"project": "FFmpeg", "commit_id": "1cb4ef526dd1e5f547d0354efb0831d07e967919", "target": 1, "func": "static int add_candidate_ref(HEVCContext *s, RefPicList *list,\n\n                             int poc, int ref_flag)\n\n{\n\n    HEVCFrame *ref = find_ref_idx(s, poc);\n\n\n\n    if (ref == s->ref)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!ref) {\n\n        ref = generate_missing_ref(s, poc);\n\n        if (!ref)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    list->list[list->nb_refs] = ref->poc;\n\n    list->ref[list->nb_refs]  = ref;\n\n    list->nb_refs++;\n\n\n\n    mark_ref(ref, ref_flag);\n\n    return 0;\n\n}\n", "idx": 2400, "substitutes": {"s": ["sg", "cli", "js", "service", "src", "cs", "sup", "ss", "ops", "a", "context", "sb", "new", "r", "com", "d", "n", "is", "i", "g", "m", "ses", "sf", "sync", "source", "ds", "gs", "ns", "c", "p", "services", "w", "e", "self", "f", "sys", "sq", "u", "south", "o", "v", "b", "cmp", "t", "os", "S", "site", "support", "si", "ssl"], "list": ["call", "base", "test", "group", "nav", "null", "name", "li", "act", "local", "def", "lp", "array", "queue", "cl", "data", "current", "get", "LIST", "com", "out", "n", "dl", "id", "parent", "frame", "loop", "batch", "pre", "bl", "comp", "g", "i", "ls", "code", "ll", "info", "lex", "coll", "source", "back", "index", "pool", "config", "result", "l", "block", "p", "c", "w", "self", "lc", "set", "cache", "conf", "la", "object", "lists", "v", "table", "old", "full", "view", "List", "load", "wp", "all", "diff"], "poc": ["ipoca", "spuc", "spoc", "foca", " pocol", " puc", "puc", "ipoc", "Poc", "jpoca", "jpocol", "Pc", "sproc", "toc", "proc", "jpuc", "foc", "pocol", "tpuc", "froc", "focol", "jpc", "Poca", "tproc", "tpc", "tpocol", "tpoc", "toca", "spoca", "Puc", " pc", "tpoca", "tocol", "pc", "jpoc", "troc", "ipocol", "iproc", " poca", "tuc", "poca"], "ref_flag": ["refsflag", "refacflags", "refacflag", "ref_bit", "reference_flags", "reference_kind", "reference_bit", "refsbit", "refsflags", "ref2bit", "refackind", "ref2flags", "ref2flag", "ref_kind", "reference_flag", "ref_flags"], "ref": ["ob", "this", " reference", "url", "n", "alt", "field", "rec", "next", "err", "index", "pointer", "self", "f", "reference", "object", "af", "lab", "ff", "name", "ext", "id", "parent", "frame", "ef", "REF", "fe", "p", "aff", "e", "conf", "lib", "re", "val", "fc", "base", "nav", "ab", "new", "r", "loc", "remote", "pre", "proxy", "info", "cb", "c", "br", "cache", "el", "obj", "bb", "req", "cf", "old", "inf", "call", "null", "fact", "def", "lf", "comp", "rf", "fr", "source", "bf", "Ref", "block", "doc", "arc", "col", "rel", "fb", "b", "cmp", "part", "inc", "diff", "db"], "nb_refs": ["nb_defd", "nb_REFd", "nb_defblocks", "nb_relp", "nb_defs", "nb_relits", "nb_rels", "nb_reld", "nb_relerences", "nb_clp", "nb_REFls", "nb_childs", "nb_REFs", "nb_relblocks", "nb_refp", "nb_defls", "nb_refd", "nb_refblocks", "nb_defp", "nb_childerences", "nb_REFerences", "nb_cld", "nb_cls", "nb_refls", "nb_references", "nb_childblocks", "nb_rells", "nb_clits", "nb_childd", "nb_deferences", "nb_refits", "nb_defits"]}}
{"project": "FFmpeg", "commit_id": "043800a96888f1a04732f12316ba477d8f098d3f", "target": 0, "func": "static int end_frame(AVFilterLink *inlink)\n\n{\n\n    AVFilterContext    *ctx = inlink->dst;\n\n    FPSContext           *s = ctx->priv;\n\n    AVFilterLink   *outlink = ctx->outputs[0];\n\n    AVFilterBufferRef  *buf = inlink->cur_buf;\n\n    int64_t delta;\n\n    int i, ret;\n\n\n\n    inlink->cur_buf = NULL;\n\n    s->frames_in++;\n\n    /* discard frames until we get the first timestamp */\n\n    if (s->pts == AV_NOPTS_VALUE) {\n\n        if (buf->pts != AV_NOPTS_VALUE) {\n\n            write_to_fifo(s->fifo, buf);\n\n            s->first_pts = s->pts = buf->pts;\n\n        } else {\n\n            av_log(ctx, AV_LOG_WARNING, \"Discarding initial frame(s) with no \"\n\n                   \"timestamp.\\n\");\n\n            avfilter_unref_buffer(buf);\n\n            s->drop++;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    /* now wait for the next timestamp */\n\n    if (buf->pts == AV_NOPTS_VALUE) {\n\n        return write_to_fifo(s->fifo, buf);\n\n    }\n\n\n\n    /* number of output frames */\n\n    delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,\n\n                         outlink->time_base);\n\n\n\n    if (delta < 1) {\n\n        /* drop the frame and everything buffered except the first */\n\n        AVFilterBufferRef *tmp;\n\n        int drop = av_fifo_size(s->fifo)/sizeof(AVFilterBufferRef*);\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"Dropping %d frame(s).\\n\", drop);\n\n        s->drop += drop;\n\n\n\n        av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);\n\n        flush_fifo(s->fifo);\n\n        ret = write_to_fifo(s->fifo, tmp);\n\n\n\n        avfilter_unref_buffer(buf);\n\n        return ret;\n\n    }\n\n\n\n    /* can output >= 1 frames */\n\n    for (i = 0; i < delta; i++) {\n\n        AVFilterBufferRef *buf_out;\n\n        av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);\n\n\n\n        /* duplicate the frame if needed */\n\n        if (!av_fifo_size(s->fifo) && i < delta - 1) {\n\n            av_log(ctx, AV_LOG_DEBUG, \"Duplicating frame.\\n\");\n\n            write_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, AV_PERM_READ));\n\n            s->dup++;\n\n        }\n\n\n\n        buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,\n\n                                    outlink->time_base) + s->frames_out;\n\n\n\n        if ((ret = ff_start_frame(outlink, buf_out)) < 0 ||\n\n            (ret = ff_draw_slice(outlink, 0, outlink->h, 1)) < 0 ||\n\n            (ret = ff_end_frame(outlink)) < 0) {\n\n            avfilter_unref_bufferp(&buf);\n\n            return ret;\n\n        }\n\n\n\n        s->frames_out++;\n\n    }\n\n    flush_fifo(s->fifo);\n\n\n\n    ret = write_to_fifo(s->fifo, buf);\n\n    s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);\n\n\n\n    return ret;\n\n}\n", "idx": 22425, "substitutes": {"inlink": ["inslock", "inlock", "outlock", "inclink", "incline", "outline", "Inlock", "insLink", "inflow", "InLink", "inload", "Inload", " inload", "ninline", "inslink", "inclock", "outflow", "inLink", "insline", "outink", "ninflow", " inink", " inlock", "outLink", "Inlink", " inflow", " inLink", "outload", "insload", "insink", "incink", "ninlock", "ninlink", "inink"], "ctx": ["conv", "lc", "bc", "sync", "fc", "cc", "wcs", "cam", "uc", "conn", "sci", "config", "acl", "driver", "pkg", "cv", "cm", "crit", "tx", "ca", "Context", "anc", "cas", "cu", "ci", "cmp", "exec", "nc", "cmd", "cp", "cs", "cf", "xc", "ctrl", "mc", "context", "tc", "kb", "cli", "rc", "c", "cb", "client", "mac", "cn", "sc", "ann", "cal", "gc", "qa", "media", "fw", "loc", "bm", "cca", "utils", "wx", "util", "cms", "hw", "ck", "kw", "sq", "vc"], "s": ["bc", "sv", "es", "config", "uns", "xs", "ds", "sys", "r", "data", "ssl", "ts", "cs", "us", "stats", "js", "aws", "ms", "n", "S", "ns", "src", "slice", "rs", "ins", "v", "conf", "ans", "http", "ss", "sb", "uf", "g", "ses", "d", "sets", "as", "services", "u", "sg", "c", "spec", "sc", "a", "soc", "sf", "scope", "su", "e", "sym", "qs", "serv", "space", "tests", "hs", "fs", "lines", "sis", "f", "full", "p", "si", "sr", "b", "service", "parts", "sup", "ps", "gs", "sq", "sl", "ops", "ks", "m", "args", "its", "storage", "vs", "ls", "sync", "is", "sa", "settings", "session", "bs", "server"], "outlink": ["offlink", "outplug", " outconnection", "unline", " outline", "outline", "outman", "outconnection", "upline", "unconnection", "unlink", "unLink", "uplink", "inLink", "upplug", " outLink", "inconnection", "outLink", "offplug", "inman", "offline", "upman", "inplug", "offman"], "buf": ["conv", "bc", "pb", "port", "sb", "uf", "lb", "uc", "ref", "config", "pkg", "cv", "fb", "queue", "func", "bridge", "img", "home", "fp", "f", "buffer", "cas", "cmp", "cur", "alloc", "bu", "cmd", "cp", "raf", "box", "bt", "cf", "context", "wb", "pool", "cb", "aux", "b", "window", "seq", "ff", "src", "fd", "bm", "fw", "bd", "br", "ab", "buff", "bf", "proc", "bh", "bag", "vec", "rb", "su", "fi", "cap"], "delta": ["adelta", "cdelta", "sdqa", "dancel", "lDelta", " danta", "Dota", "Dqa", "sdance", "dqa", "cdota", "adetime", "nency", "Delt", "sdelt", "lota", "nota", "nelt", "danta", "DDelta", "lelta", " dota", "sdetime", "nqa", "adota", " dency", "sdota", "netime", "detime", "Delta", " dancel", "dency", "nanta", "sdelta", "delt", " dDelta", "sdanta", "dDelta", "cdelt", "dance", "sdency", "dota", "nelta", "adance", " delt", "cdancel", "sdancel", "nance"], "i": ["io", "jit", "ix", "e", "start", "ie", "qi", "ind", "ri", "ui", "mini", "ki", "gi", "d", "uri", "chi", "ti", "I", "l", "f", "ci", "y", "t", "u", "info", "ini", "phi", "it", "j", "p", "ip", "id", "count", "bi", "ani", "is", "c", "mu", "index", "si", "a", "ii", "b", "x", "ji", "n", "iu", "ai", "xi", "hi", "di", "v", "z", "multi", "li", "pi", "base", "zi", "k", "ni", "type"], "ret": ["reg", "red", "flat", "en", "obj", "ref", "gt", "result", "val", "mini", "det", "rem", "stop", "rep", "Ret", "rf", "get", "lr", "r", "info", "res", "data", "final", "fin", "rets", "fun", "mi", "rc", "rot", "match", "pass", "RET", "rt", "mem", "reply", "rev", "re", "fl", "len", "iter", "back", "alt", "nt", "rb", "fi", "resp", "url", "ft"], "frames_in": ["frames__end", "framesNin", "frames_used", "frames__out", "frame_used", "frame_out", "frame_end", "framesNend", "framesNused", "frames_end", "frames__used", "frames__in", "framesNout", "frame_in"], "drop": ["delete", "delay", "col", "grad", "phase", "shape", "flat", "fail", "level", "hop", "clear", "throw", "scale", "push", "loop", "stop", "pad", "down", "type", "layer", "pos", "op", "roll", "size", "zip", "patch", "diff", "change", "fall", "Drop", "field", "grow", "id", "dro", "shift", "pool", "move", "dr", "fix", "hide", "drops", "low", "pass", "pop", "crop", "add", "pull", "create", "x", "carry", "save", "core", "dl", "error", "min", "slice", "ignore", "keep", "update", "batch", "fly", "dropping", "sleep", "clip", "sort", "close", "dp", "max", "count"], "tmp": ["conv", "pb", "uf", "txt", "flat", "obj", "ref", "vt", "config", "result", "map", "part", "pkg", "meta", "fb", "bb", "copy", "temp", "pad", "img", "etc", "fp", "buffer", "cmp", "front", "cp", "tab", "data", "storage", "cache", "zip", "tc", "np", "wb", "mm", "gz", "kk", "cb", "cro", "wp", "mp", "ptr", "stuff", "appy", "src", "media", "slice", "foo", "test", "nb", "buff", "proc", "bag", "rb", "api", "attr"], "buf_out": ["bufKout", "bufadin", "bufnoff", "fp_io", "buf_again", "buf_io", "buff_again", "buff_in", "bufKio", "fpKio", "bufKo", "buf_clean", "fp_o", "bufnout", "buffer_out", "bufKarr", "buf_arr", "buf_o", "bufadclean", "bufadout", "buffer_off", "buff_clean", "fp_arr", "buffer_Out", "buf_off", "bufnOut", "fpKout", "fp_out", "buffer_list", "buf_in", "buff_out", "fpKarr", "bufadagain", "buf_Out", "bufnlist", "fpKo", "buf_list"]}}
{"project": "qemu", "commit_id": "f1d3b99154138741161fc52f5a8c373bf71613c6", "target": 1, "func": "static void pci_basic(gconstpointer data)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QPCIBus *bus;\n\n    QVirtQueuePCI *tx, *rx;\n\n    QGuestAllocator *alloc;\n\n    void (*func) (const QVirtioBus *bus,\n\n                  QVirtioDevice *dev,\n\n                  QGuestAllocator *alloc,\n\n                  QVirtQueue *rvq,\n\n                  QVirtQueue *tvq,\n\n                  int socket) = data;\n\n    int sv[2], ret;\n\n\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    bus = pci_test_start(sv[1]);\n\n    dev = virtio_net_pci_init(bus, PCI_SLOT);\n\n\n\n    alloc = pc_alloc_init();\n\n    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 0);\n\n    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 1);\n\n\n\n    driver_init(&qvirtio_pci, &dev->vdev);\n\n    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);\n\n\n\n    /* End test */\n\n    close(sv[0]);\n\n    guest_free(alloc, tx->vq.desc);\n\n    pc_alloc_uninit(alloc);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n    qpci_free_pc(bus);\n\n    test_end();\n\n}\n", "idx": 6217, "substitutes": {"data": ["pack", "append", "a", "parent", "done", "di", "dat", "device", "dd", "config", "val", "sync", "info", "buf", "window", "valid", "package", "d", "init", "DATA", " DATA", "def", "buffer", "connection", "ops", "da", "Data", "timeout", "exec", "multi", "devices", "result", "array", "input", "p", "reader", "batch", "proc", "cache", "next"], "dev": ["hw", "reg", "od", "v", "prof", "id", "rad", "pu", "pro", "di", "Dev", "dd", "device", "adv", "md", "config", "plug", "bug", "tr", "rc", "ow", "enc", "ad", "info", "debug", "der", "valid", "gu", "package", "d", "ve", "mod", "fo", "dist", "conf", "ev", "def", "DEV", "wd", "priv", "prom", "w", "error", "da", "dc", "driver", "self", "pub", "serial", "req", "boot", "ver", "gh", "var", "off", "node", "api", "engine", "cache", "app", "vc", "prov", "grad", "conn", "diff"], "bus": ["plugin", "base", "cmp", "build", "feed", "block", "hub", "local", "http", "pu", "BUS", "device", "config", "plug", "bug", "b", "io", "sync", "bit", "cat", "Bus", "buf", "db", "usb", "book", "us", "def", "mount", "connection", "driver", "port", "lib", "path", "ux", "bc", "pass", "self", "bridge", "pub", "serial", "this", "boot", "proc", "os", "class", "board", "pl", "cache", "test", "index", "fi", "conn"], "tx": ["rw", "ti", "pull", "wx", "trial", "device", "x", "tr", "ax", "raf", "sync", "rc", "rel", "co", "pt", "TX", "fx", "loc", "der", "ty", "ix", "ran", "ra", "pc", "q", "def", "ck", "mc", "w", "auth", "t", "ctx", "ux", "bc", "Tx", "context", "temp", "ca", "req", "reader", "trans", "gh", "ta", "txt", "cf", "ac", "cache", "test", "cross", "cas", "worker", "tc"], "rx": ["rw", "vr", "rt", "fw", "rr", "wx", "eth", "rb", "x", "ri", "rc", "raf", "rd", "rf", "ax", "rel", "wa", "co", "sync", "loc", "fx", "rh", "ru", "ra", "rou", "nr", "pc", "ry", "wd", "ck", "rss", "rg", "ctx", "ux", "lr", "rl", "rin", "req", "lex", "reader", "mr", "src", "rs", "r", "xc"], "alloc": ["vol", "oc", "cmp", "afi", "hw", "anc", "pack", "mem", "wx", "pu", "fee", "config", "rac", "rc", "raf", "enc", "auc", "uc", "loc", "buf", "valid", "mac", "capacity", "ga", "attr", "soc", "org", "win", "pc", "ack", "init", "oca", "conf", "acl", "sc", "random", "ctx", "ux", "exec", "cu", "bc", "voc", "go", "coll", "nil", "pool", "access", "ec", "req", "gen", "toc", "c", "addr", "util", "asc", "ac", "isc", "aux", "au", "cache", "loader", "vc", "conn", "pkg", "aw"], "func": ["function", "unc", " function", "wrapper", "rb", "val", "nc", "sync", "lambda", "sys", "module", "buf", "package", "f", "call", "obj", "pc", "cc", "loop", "code", "fn", "lib", "Function", "bc", "cb", "dll", "exec", "callback", "work", "self", "fun", "proc", "class", "cf", "lc", "fc", "addr", "src", "conn", "worker"], "rvq": ["rpw", "rpq", "RvQ", "Rvw", "rvw", "Rpw", "rvvQ", "rvvflow", "rpflow", "Rpq", "rvvw", "rvvq", "rww", "rwflow", "Rvflow", "RpQ", "rvflow", "Rpflow", "rwQ", "rvQ", "Rvq", "rwq", "rpQ"], "tvq": ["voltq", "tvqueue", "voltqa", "vuq", "uvqueue", "voltqs", "uvqs", "tvqs", "vuqs", "uvqa", "vuqa", "uvq", "tvqa", "vuqueue", "voltqueue"], "socket": ["sf", "channel", "config", "ockets", "ocket", " sock", "sync", "sn", "stream", "buf", "server", "sl", "ss", "port", " sockets", "timeout", "seq", "pool", "cpu", "proc", "ssl", "sq", "src", "conn", "Socket", "slot"], "sv": ["nv", "ipt", "serv", "sf", "v", "s", "vt", "si", "sn", "sys", "services", "vector", "uv", "status", "isl", "db", "csv", "null", " SV", "sk", "support", "sl", "sm", "series", "av", "service", "ss", "vi", "vs", "sh", "via", "sb", "sql", "zip", "sd", "ds", "timeout", "su", "temp", "ft", "sp", "iv", "vl", "ssl", "sq", "lv", "api", "ov", "vv", "cv", "vc"], "ret": ["flag", "reg", "no", "mem", "rt", "cur", "alt", "nt", "pin", "val", "rc", "inter", "bit", "reply", "status", "valid", "fin", "f", "lit", "att", "arg", "res", "len", "code", "det", "en", "RET", "ben", "pass", "result", "Ret", "ft", "re", "fun", "success", "ref", "fi", "addr", "r", "rets"]}}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)\n\n{\n\n    const struct cow_header_v2 *cow_header = (const void *)buf;\n\n\n\n    if (buf_size >= sizeof(struct cow_header_v2) &&\n\n        be32_to_cpu(cow_header->magic) == COW_MAGIC &&\n\n        be32_to_cpu(cow_header->version) == COW_VERSION)\n\n        return 100;\n\n    else\n\n        return 0;\n\n}\n", "idx": 20189, "substitutes": {"buf": ["Buffer", "data", "fp", "obj", "f", "pool", "buffer", "rc", "file", "fi", "result", "cf", "loader", "cb", "cp", "src", "Buff", "ctx", "pb", "ptr", "writer", "header", "array", "bf", "img", "config", "queue", "fd", "buff", "fb", "batch", "rb", "seq", "cmd", "binary", "b", "cache", "alloc", "bag", "uf", "cv"], "buf_size": ["bufroffset", "buf_ize", "buf2size", "buf_capacity", " buf_ize", "buf2offset", "bufrsize", "cb_size", " buf_offset", "bufrize", "buf_sum", "buf2ize", "buf_offset", "cb_capacity", "cb_sum"], "filename": ["func", "name", "image", "tty", "file", "loader", "window", "src", "wb", "ctx", "fs", "console", "tif", "username", "enc", "nm", "path", "w", "prefix", "config", "png", "fd", "rb", "binary", "fn", "callback", "writer", "dll"], "cow_header": ["cow_author", "cowingpair", "cowingcache", " cow_writer", "cow_cache", "cowingdefinition", "cca_author", "cca_version", "cow_head", "cowingversion", "cow_magic", " cow_pair", "ow_magic", "ow_buffer", "cow_writer", "cow_definition", "cca_header", "cca_definition", "cow_version", "cowingheader", " cow_cache", "cowingauthor", "cow_buffer", "cowingwriter", "ow_header", "cow_pair", "ow_head"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,\n\n                          const uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    int ret;\n\n\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (!drv->bdrv_write_compressed) {\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_check_request(bs, sector_num, nb_sectors);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);\n\n}\n", "idx": 13415, "substitutes": {"bs": ["bt", "ses", "blocks", "bid", "bis", "bc", "lbs", "BS", "fs", "ins", "sync", "bb", "fb", "rs", "cs", "fps", "os", "bytes", "bus", "js", "ras", "ps", "ss", "obj", "obs", "pb", "vs", "b", "sb", "base", "bing", "nas", "banks", "gs", "bits", "ab", "bh", "ns", "bu", "cb", "bes", "bas", "ds", "db", "cache", "ls", "css", "lb", "bos", "ubs", "las", "bl", "iss", "abi", "ks"], "sector_num": ["sector__number", " sector_id", "sector_name", "sector_number", " sector_count", " sector_number", " sector_name", "sector_count", " sector_Num", "sector__num", "sector_id", "sector_Num", "sector__count"], "buf": ["port", "vec", "bin", "uc", "bc", "queue", "fd", "array", "cv", "batch", "config", "fb", "uf", "ref", "buffer", "bus", "bag", "br", "buff", "rb", "pb", "data", "b", "base", "Buffer", "fab", "ab", "block", "offset", "cb", "cas", "que", "src", "seq", "num", "len", "ctx", "alloc"], "nb_sectors": ["nb_serctors", "nb_belements", "nb_secgments", "nb_seapters", "nb_tectors", "nb_serkers", "nb_segments", "nb_secs", "nb_teapters", "nb_sekers", "nb_secctors", "nb_veapters", "nb_sergments", "nb_seccs", "nb_bectors", "nb_serlements", "nb_vecs", "nb_begments", "nb_becs", "nb_tegments", "nb_velements", "nb_seclements", "nb_tekers", "nb_vectors", "nb_vekers", "nb_vegments", "nb_telements", "nb_selements", "nb_secapters"], "drv": [" drb", "drver", "prver", "DRc", "rrf", "Drp", "dric", "driV", "driv", "hrc", "rrb", "drV", "Drb", "Drf", " drc", " drver", "Drv", " drf", "rrv", "DRv", "drb", " drw", "DRV", "prp", "hrb", " drp", "drw", "DRf", "Drc", "drif", "hrw", "drf", "prf", "hrf", "hrv", "drc", "prv", "rrw", " drV", "drp", "Drver", "hrV", "DrV"], "ret": ["pet", "alt", "en", "ft", "let", "reply", "art", "rc", "tr", "val", "code", "back", "def", "rets", "fun", "req", "sr", "ref", "det", "arg", "lit", "valid", "error", "value", "obj", "mt", "fin", "rb", "success", "base", "Ret", "bf", "result", "fit", "att", "reset", "next", "cat", "ry", " Ret", "nt", "re", "rt", "fail", "rep", "pat", "RET", "al", "res", "reg", "flag", "len", "bit", "err"]}}
{"project": "qemu", "commit_id": "5f1d1fc5928a6f8f63089b3d0768e0dc42c05fbb", "target": 0, "func": "int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)\n\n{\n\n    DeviceState *qdev, **qdevs;\n\n    BusChild *kid;\n\n    int i, num, ret = 0;\n\n\n\n    /* Count qdevs on the bus list */\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        num++;\n\n    }\n\n\n\n    /* Copy out into an array of pointers */\n\n    qdevs = g_malloc(sizeof(qdev) * num);\n\n    num = 0;\n\n    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {\n\n        qdevs[num++] = kid->child;\n\n    }\n\n\n\n    /* Sort the array */\n\n    qsort(qdevs, num, sizeof(qdev), compare_reg);\n\n\n\n    /* Hack alert. Give the devices to libfdt in reverse order, we happen\n\n     * to know that will mean they are in forward order in the tree. */\n\n    for (i = num - 1; i >= 0; i--) {\n\n        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);\n\n\n\n        ret = vio_make_devnode(dev, fdt);\n\n\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    free(qdevs);\n\n\n\n    return ret;\n\n}\n", "idx": 26468, "substitutes": {"bus": ["abi", "gen", "driver", "class", "b", "cat", "mount", "mot", "usb", "data", "back", "config", "us", "bug", "bc", "band", "ux", "pass", "cycle", "sync", "io", "serial", "plugin", "id", "self", "hub", "boot", "buf", "feed", "book", "home", "bridge", "vc", "http", "controller", "session", "Bus", "lib", "group", "drive", "parent", "board", "cache", "device", "git", "loop", "f", "child", "conn", "plug", "die", "machine", "l", "connection", "lock", "BUS"], "fdt": ["fdtm", "rafT", "FDts", "fdts", "dsts", "dst", "wdT", "FDT", "wdt", "fdT", "FDt", "dfT", "raft", "dft", "rafts", "dftm", "dfdt", "dsdt", "wdtm", "fddt", "dfts", "rafdt", "dsT", "wdts", "FDtm"], "qdev": ["reqvar", " qev", "qudiv", "Qdev", "qudc", "sqdd", " qpro", "sqvar", "questdev", "qupro", "qpro", "reqdev", "Qdiff", "questdevice", "qev", "sqdevice", "qdd", "qudev", "sqdiff", "qdiff", "qdc", "qdiv", "reqdc", "questdd", "Qpro", "Qdiv", "reqapp", "quapp", "qdevice", "Qdd", "quev", "sqdev", "qapp", "quvar", "sqdc", "Qdevice", "qvar", "questdiff", "sqapp", " qdiv", "Qev"], "qdevs": ["qvars", " qdevi", "qsdops", "qdepi", "qdeps", "pdevos", "qevos", "qdevd", "Qdeve", "qDevses", "qdevices", "wevs", "pevs", "qevses", "wdevos", "qdefe", "kevos", "dqdefstates", "qdefos", "qdevicee", "dqdevs", "qsdos", "pevses", "qdepstates", "kdevos", "pevds", "qdefsets", "wevops", "qdive", "qdeviced", "qdepd", "qvaros", "qdevses", "qevstates", "qDevds", "qdevds", "qgoodds", "qpathe", "Qdevs", "qvarops", "dqdevstates", "dqdefs", "kevlines", "qdevops", "dqdeve", "qgoodos", "qpathstates", "Qdeps", "qdevsets", "Qdevds", "qDeve", "qevlines", "qradds", "kdevs", "qDevos", "dqdevsets", "kevds", "wdevs", "qDevd", " qdevstates", "qdefstates", "qevops", "wdevops", " qddstates", "qsds", "pdevs", "qdeflines", "qdepds", "qevi", "qdefs", "kdevds", "Qdepds", "qdevlines", "qdeviceds", "qradses", "qgoodlines", "qevs", "qdepe", "kdevlines", "Qdepd", "qrados", "qpaths", "qgoods", "dqdefsets", "dqdefe", " qddi", "pdevses", "qddstates", "qddi", "qrads", "Qdevd", "pevos", "qevds", "qdivs", "qdivsets", "qdevi", "qdds", "qdevos", "pdevds", "wevos", "qdevstates", "qdivstates", "qDevs", "qpathsets", "qdefds", "kevs", "Qdepe", "qdeve", " qdds"], "kid": ["node", "kel", "tk", "sk", "gen", "sid", "k", "kn", "ski", "dc", "king", "chid", "dad", "anc", "pid", "nir", "isi", "kick", "kin", "kg", "ad", "bug", "idy", "hack", "ks", "kind", "id", "kb", " kids", "sync", "kids", "tick", "eth", "ker", "ko", "cer", "feat", "kr", "iden", "quad", "wk", "ki", "child", "da", "conn", "od", "ck", "ids", "ke", "ku", "dk", "cand", "Kid", "kt"], "i": ["k", "z", "ie", "b", "p", "yi", "c", "ix", "x", "en", "ti", "mi", "jp", "type", "phi", "qi", "it", "ri", "id", "io", "u", "e", "li", "gi", "o", "ji", "zi", "multi", "start", "xi", "l", "ii", "di", "si", "ini", "bi", "ni", "ai", "ci", "ret", "eni", "part", "I", "f", "ki", "oi", "n", "j", "index", "ip", "chi", "iu", "ind", "mu", "pi", "v", "ui", "pos", "hi"], "num": ["temp", "node", "mom", "iq", "comb", "np", "nm", "b", "dim", "name", "uni", "norm", "fn", "sum", "img", "om", "nn", "col", "Num", "end", "mut", "id", "dom", "su", "u", "count", "unit", "nom", "con", "du", "span", "max", "min", "lu", "valid", "multi", "ul", "nb", "loc", "lit", "lib", "common", "ni", "mn", "parent", "coord", "ret", "sort", "inc", "number", "mon", "uu", "um", "f", "umi", "nr", "n", "index", "un", "mult", "out", "na", "NUM", "nu", "init", "lim", "mu", "net", "len"], "dev": ["md", "w", "dc", "info", "app", "data", "var", "ad", "conf", "bd", "pub", "bug", "def", "dd", "priv", "ch", "ev", "kind", "av", "dom", "prom", "pad", "adv", "dem", "lib", "di", "device", "dist", "mod", "conn", "reg", "plug", "rad", "Dev", "od", "ver", "pu", "de", "v", "block", "cand"]}}
{"project": "FFmpeg", "commit_id": "8b27f76bf8790536afccb96780b5feb9c65636be", "target": 0, "func": "static av_cold void build_modpred(Indeo3DecodeContext *s)\n\n{\n\n  int i, j;\n\n\n\n  s->ModPred = av_malloc(8 * 128);\n\n\n\n  for (i=0; i < 128; ++i) {\n\n    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));\n\n    s->ModPred[i+1*128] = i ==   7 ?  20 :\n\n                          i == 119 ||\n\n                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));\n\n    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));\n\n    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));\n\n    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));\n\n    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));\n\n    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));\n\n    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));\n\n  }\n\n\n\n  s->corrector_type = av_malloc(24 * 256);\n\n\n\n  for (i=0; i < 24; ++i) {\n\n    for (j=0; j < 256; ++j) {\n\n      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :\n\n                                   j < 248 || (i == 16 && j == 248) ? 0 :\n\n                                   corrector_type_2[j - 248];\n\n    }\n\n  }\n\n}\n", "idx": 3658, "substitutes": {"s": ["sg", "js", "service", "cs", "ctx", "ss", "ops", "rs", "qs", "ts", "spec", "sb", "r", "d", "n", "is", "g", "vs", "ses", "ls", "sync", "ats", "settings", "sv", "sets", "ds", "utils", "ps", "gs", "ns", "h", "l", "c", "p", "services", "w", "e", "self", "f", "es", "features", "sys", "sq", "u", "gb", "lines", "south", "conf", "o", "v", "stats", "less", "su", "b", "S", "t", "session", "ks", "os", "bs", "its", "hs", "states", "fs", "si", "sym", "ssl"], "i": ["cli", "key", "n", "im", "g", "anti", "ti", "index", "x", "ind", "hi", "f", "u", "idi", "ori", "uri", "fi", "ami", "name", "abi", "ali", "esi", "ji", "zi", "pi", "ui", "image", "id", "mi", "iu", "api", "y", "ri", "z", "ie", "p", "e", "isi", "ia", "v", "ix", "qi", "ik", "me", "io", "init", "in", "li", "ni", "ii", "r", "I", "di", "is", "uli", "m", "info", "ini", "c", "phi", "o", "ic", "si", "yi", "gi", "http", "asi", "oi", "d", "it", "eni", "multi", "ai", "ip", "l", "adi", "bi", "ki", "b", "ci", "my", "xi"], "j": ["js", "adj", "li", "q", "jl", "key", "ni", "ii", "ji", "r", "jen", "d", "n", "jj", "J", "oj", "job", "im", "k", "aj", "ij", "uj", "y", "g", "m", "jo", "kj", "bj", "z", "ch", "ie", "x", "l", "h", "p", "pr", "bi", "jc", "e", "c", "f", "jam", "length", "je", "u", "jp", "note", "dj", "jet", "o", "v", "b", "qi", "ix", "si", "ja"]}}
{"project": "FFmpeg", "commit_id": "fb1473080223a634b8ac2cca48a632d037a0a69d", "target": 1, "func": "static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n\n        int *need_next_header, int *new_frame_start)\n\n{\n\n    GetBitContext bits;\n\n    AACADTSHeaderInfo hdr;\n\n    int size;\n\n    union {\n\n        uint64_t u64;\n\n        uint8_t  u8[8];\n\n    } tmp;\n\n\n\n    tmp.u64 = av_be2ne64(state);\n\n    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);\n\n\n\n    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)\n\n        return 0;\n\n    *need_next_header = 0;\n\n    *new_frame_start  = 1;\n\n    hdr_info->sample_rate = hdr.sample_rate;\n\n    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];\n\n    hdr_info->samples     = hdr.samples;\n\n    hdr_info->bit_rate    = hdr.bit_rate;\n\n    return size;\n\n}\n", "idx": 25130, "substitutes": {"state": ["code", "body", "obj", "args", "param", "callback", "data", "test", "oper", "State", "config", "media", "address", "inst", "states", "store", "proc", "private", "boot", "seed", "resource", "str", "start", "session", "inner", "st", "STATE", "ctx", "cache", "length", "addr", "buff", "part", "handle", "j", "conn", "r", "settings", "attr", "params"], "hdr_info": ["hhr_inter", "hdrsInfo", "hhr_private", "hdr_id", "hdr_error", "hdr0inter", "hhr_error", "hdrsid", "hdr_Info", "hhr_index", "hdr_private", "hDR_id", "hDR_diff", "hdr_diff", "hdr_di", "hDR_info", "hhr_Info", "hdr0info", "hdrsinf", "hdr_index", "hDR_inf", "hDR_di", "hdr0inf", "hhr_fo", "hDR_Info", "hhr_inf", "hhr_info", "hdr0private", "hdr_inf", "hdr_fo", "hdrsinfo", "hdr_inter"], "need_next_header": ["need_next_layer", "need_new_frame", "need_next_message", "need_new_message", "need_new_channel", "need_new_header", "need_next_channel", "need_new_layer", "need_next_frame"], "new_frame_start": ["new_frame2end", "new_frame_offset", "new_frame_pos", "new_fram_pos", "new_frame2start", "new_frame_id", "new_frame_set", "new_frame2id", "new_fram_set", "new_fram_end", "new_fram_id", "new_fram_start", "new_frame2set", "new_fram_offset", "new_frame_end"], "bits": ["temp", "pieces", "txt", "rs", "nets", " tcp", "features", "bis", "nos", "batch", "flags", "hops", "ips", "data", "pins", "config", "py", "cb", "opt", "bc", "mins", "bug", "outs", "ps", "proc", "self", "cmp", "locks", "bs", "mp", "lins", "boot", "stats", "options", "fps", "bit", "sections", "boxes", " buffers", "ctx", "sb", "utils", "cache", " props", "bugs", "buff", "bytes", "details", "rooms", "t", " bytes", "init", "bps", "pos", "settings", "ops", "parts", "tx", "params", "ints"], "hdr": ["wder", "hdvar", "ohdr", "hhdr", " hder", "phrs", "adhder", "ohder", "chdr", "bhver", "handhr", "herler", "hman", "adhrs", " hDR", "wdr", "hver", "rhdr", "adhDR", "chsr", " dhdr", "rhver", "hDR", " hver", "phDR", "handvar", "htr", "hvar", " hler", "hhr", " htr", "hler", "chrid", "hrid", "ohrid", "rhrs", "hhtr", "bhrs", "hldr", " hrid", "bhdr", "hller", "hlman", "phdr", "rhder", "whr", "phder", "bhder", "herman", "ohsr", "hder", " hman", "hsr", "handdr", "herdr", "hrs", "hddr", "hhder", "wvar", "handder", " hsr", "hdder", " dhder", "adhdr", "hdhr", " dhtr", "chder", " hrs"], "size": ["from", "code", "args", "ize", "i", "c", "empty", "sized", "x", "send", "sum", "en", "address", "capacity", "Size", "cmp", "unit", "extra", "SIZE", "start", "loc", "small", "offset", "new", "sec", "scale", "cache", "shape", "number", "rc", "length", "part", "handle", "count", "bytes", "n", "full", "pack", "iz", "ui", "pos", "len", "big"], "u8": ["f16", "uint6", "uint8", "U8", "c6", "f8", "ui16", "x16", "x8", "U16", "x6", "x32", "uint32", "ui6", "ui32", "u6", "c8", "u32", "U6", "c16", "c32", "f6", "u16", "f32", "ui8", "uint16", "U32"], "tmp": ["temp", "txt", "obj", "np", "app", "stuff", "bb", "data", "storage", "img", "rb", "config", "py", "jp", "vt", "cb", "prop", "fm", "inst", "proc", "cmp", "mp", "buf", "boot", "amp", "dat", "input", "nb", "ctx", "cp", "sb", "fb", "cache", "buff", "array", "uv", "part", "tf", "tp", "src", "fp", "attr", "bt", "params"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void stq_be_phys(target_phys_addr_t addr, uint64_t val)\n\n{\n\n    val = cpu_to_be64(val);\n\n    cpu_physical_memory_write(addr, &val, 8);\n\n}\n", "idx": 20282, "substitutes": {"addr": ["target", "ref", "adr", "config", "kt", "arg", "eth", "amd", "align", "host", "pc", "node", "device", "layer", "ld", "pos", "address", "data", "ad", "p", "ace", "point", "slot", "index", "ar", "cpu", "rt", " address", "ptr", "x", "src", "slice", "mx", "pointer", "offset", "base", "attr", "inter"], "val": ["grad", "sel", "ee", "fail", "ref", "sl", "valid", "ind", "db", "arg", "key", "cond", "tx", "bin", "al", "pre", "data", "p", "arr", "vals", "unit", "count", "slot", "py", "el", "index", "aval", "cal", "b", "pid", "mem", "vol", "fl", "len", "test", "loc", "VAL", "base", "Val", "lib", "v", "eval", "all", "pt", "x", "value"]}}
{"project": "qemu", "commit_id": "1e39d97af086d525cd0408eaa5d19783ea165906", "target": 0, "func": "static void gen_movl_seg_T0(DisasContext *s, int seg_reg)\n\n{\n\n    if (s->pe && !s->vm86) {\n\n        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);\n\n        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);\n\n        /* abort translation because the addseg value may change or\n\n           because ss32 may change. For R_SS, translation must always\n\n           stop as a special handling must be done to disable hardware\n\n           interrupts for the next instruction */\n\n        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n    } else {\n\n        gen_op_movl_seg_T0_vm(seg_reg);\n\n        if (seg_reg == R_SS)\n\n            s->is_jmp = DISAS_TB_JUMP;\n\n    }\n\n}\n", "idx": 21261, "substitutes": {"s": ["sim", "i", "sb", "e", "sym", "qs", "es", "hs", "sl", "g", "ses", "d", "sets", "ks", "l", "ds", "services", "f", "sys", "t", "u", "r", "m", "less", "args", "ssl", "os", "ts", "p", "cs", "us", "o", "ls", "sync", "is", "ss", "stats", "sg", "c", "ctx", "js", "spec", "self", "settings", "si", "a", "b", "w", "service", "n", "S", "ns", "session", "sf", "ps", "gs", "conf", "sec", "h", "su", "sq", "states"], "seg_reg": ["seg__rec", "seg_run", "seg_min", "sega_REG", "segptag", "seG_rec", "segn_register", "seg_Reg", "sega_tag", "seg_register", "seg_num", "seig_reg", "seG_reg", "sega_reg", "seig_min", "seG_Reg", "seig_rec", "sereg_tag", "seg_tag", "segn_rec", "seg__num", "seg_rule", "seg_REG", "seg__Reg", "sereg_num", "segn_reg", "segpREG", "segpreg", "sereg_REG", "sereg_reg", "segprun", "seg_ret", "sereg_min", "seG_num", "sega_run", "seg__reg", "seig_rule", "sereg_ret", "seg_rec"]}}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int standard_decode_i_mbs(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    MpegEncContext *s = &v->s;\n\n    int current_mb = 0; /* MB/Block Position info */\n\n    uint8_t cbpcy[4], previous_cbpcy[4], predicted_cbpcy,\n\n        *p_cbpcy /* Pointer to skip some math */;\n\n\n\n    /* Reset CBPCY predictors */\n\n    memset(v->previous_line_cbpcy, 0, s->mb_stride<<2);\n\n\n\n    /* Select ttmb table depending on pq */\n\n    if (v->pq < 5) v->ttmb_vlc = &vc9_ttmb_vlc[0];\n\n    else if (v->pq < 13) v->ttmb_vlc = &vc9_ttmb_vlc[1];\n\n    else v->ttmb_vlc = &vc9_ttmb_vlc[2];\n\n\n\n    for (s->mb_y=0; s->mb_y<s->mb_height; s->mb_y++)\n\n    {\n\n        /* Init CBPCY for line */\n\n        *((uint32_t*)previous_cbpcy) = 0x00000000;\n\n        p_cbpcy = v->previous_line_cbpcy+4;\n\n\n\n        for (s->mb_x=0; s->mb_x<s->mb_width; s->mb_x++, p_cbpcy += 4)\n\n        {\n\n            /* Get CBPCY */\n\n            GET_CBPCY(ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS);\n\n\n\n            s->ac_pred = get_bits(gb, 1);\n\n\n\n            /* TODO: Decode blocks from that mb wrt cbpcy */\n\n\n\n            /* Update for next block */\n\n#if TRACE > 2\n\n            av_log(s->avctx, AV_LOG_DEBUG, \"Block %4i: p_cbpcy=%i%i%i%i, previous_cbpcy=%i%i%i%i,\"\n\n                   \" cbpcy=%i%i%i%i\\n\", current_mb,\n\n                   p_cbpcy[0], p_cbpcy[1], p_cbpcy[2], p_cbpcy[3],\n\n                   previous_cbpcy[0], previous_cbpcy[1], previous_cbpcy[2], previous_cbpcy[3],\n\n                   cbpcy[0], cbpcy[1], cbpcy[2], cbpcy[3]);\n\n#endif\n\n            *((uint32_t*)p_cbpcy) = *((uint32_t*)previous_cbpcy);\n\n            *((uint32_t*)previous_cbpcy) = *((uint32_t*)cbpcy);\n\n            current_mb++;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 26437, "substitutes": {"v": ["ve", "k", "nav", "i", "p", "m", "b", "c", "va", "ov", "vs", "nv", "vt", "av", "version", "ev", "vu", "tv", "vv", "u", "e", "vc", "vin", "vim", "vert", "vi", "iv", "vm", "conv", "h", "uv", "f", "lv", "n", "vd", "j", "V", "t", "q", "ver", "vp", "we", "l", "sv", "volt", "vol", "g"], "gb": ["vg", "cm", "cod", "cd", "b", "m", "pg", "cv", "bb", "tm", "storage", "rb", "bf", "mi", "py", "cb", "gam", "bc", "gy", "ym", "kb", "db", "hub", "mag", "gs", "nom", "cfg", "bridge", "nb", "gd", "lib", "mb", "mode", "ctx", "ci", "sb", "abb", "GB", "rc", "gp", "rg", "pm", "vm", "buff", "gg", "uv", "gc", "bm", "gm", "ui", "pc", "g"], "s": ["acc", "sys", "w", "server", "ns", "ts", "vs", "sq", "ps", "secondary", "sync", "self", "u", "es", "gs", "share", "http", "sym", "xs", "serv", "f", "service", "fs", "n", "js", "qs", "t", "j", "r", "S", "b", "m", "p", "c", "storage", "ds", "align", "us", "ins", "su", "is", "ims", "spec", "services", "h", "sl", "its", "g", "rs", "ses", "args", "scope", "ss", "d", "ab", "conf", "sg", "ks", "e", "get", "session", "sb", "sf", "ssl", "sv", "cs", "sc", "i", "app", "site", "o", "si", "os", "sup", "ls", "y", "network", "a", "parts", "l"], "cbpcy": ["cbfky", "cbncy", "cblpci", "bbpky", "cbfry", "cbcpy", "cbppy", "bcnpsy", "cbgcy", "dbpky", "ebpcr", "cbtpcy", "cbopci", "cbopcle", "cbpci", "ebpcy", "cbccle", "cmdopcy", "cbcpcy", "dbpcy", "cbpry", "cblppy", "cbpsty", "cbcci", "bblpky", "ebpky", "bcnpci", "cbnpci", "bcnpsty", "dbpci", "dbnpcy", "cbpcsty", "cbnpsty", "bbppy", "cbpcsy", "dbnpcle", "bcpcy", "cblpky", "cbncle", "bbpci", "cbtpci", "cbpcle", "eblpky", "cblpcle", "cblpry", "cbfcy", "bcpsty", "cbnci", "bbpcy", "cbtpcle", "cmdpci", "cbnpcy", "cbpcr", "cbopry", "cbpcci", "cbcppy", "bblpcy", "cbnpsy", "ebpry", "cbfcr", "bcpci", "cbpisy", "cblpcy", "dbnpci", "cmdopcle", "cbnry", "cbccy", "cbgry", "cbpici", "cbpccy", "dbpcle", "cbpky", "dbnpky", "cbnpcle", "cbgky", "cmdopci", "cmdopry", "bblpci", "cbpisty", "cmdpcle", "cbcpky", "bcpsy", "bcnpcy", "cbnpky", "eblpcy", "cbcky", "cmdpry", "cbpicy", "bblppy", "cblpcr", "cbtpky", "cbgcr", "cbcpci", "cmdpcy", "cbopcy", "eblpcr", "cbpsy", "eblpry", "cbcry"], "previous_cbpcy": ["previous_cbnke", "previous_cbwpty", "previous_cbpry", "previous_bbpwy", "previous_bbpoy", "previous_cblpky", "previous_cbnpcy", "previous_cbvpry", "previous_bbpcy", "previous_cbPzy", "previous_cbpsch", "previous_bbPch", "previous_cbPcy", "previous_bcpcy", "previous_bbnke", "previous_cbfpzy", "previous_cbtry", "previous_cbtcat", "previous_bbPoy", "previous_bbpky", "previous_cbnwy", "previous_cbgcy", "previous_bbpsty", "previous_cbwpwy", "previous_cbpty", "previous_cbnpym", "previous_cbpscy", "previous_cbnpry", "previous_cbfpky", "previous_cbPcat", "previous_cbgry", "previous_bbpke", "previous_cbpsty", "previous_bbnty", "previous_cbpcty", "previous_cbpoy", "previous_cbprke", "previous_bbPcy", "previous_bclpky", "previous_cbPoy", "previous_cbpch", "previous_cbpke", "previous_cbvpch", "previous_cblpry", "previous_cbtsty", "previous_cbppke", "previous_cbprry", "previous_cbgym", "previous_bcpky", "previous_bcpzy", "previous_bclpry", "previous_cbppcy", "previous_cbwpcy", "previous_cbgky", "previous_cbfpcy", "previous_cbpysty", "previous_cbpzy", "previous_cbpsry", "previous_cbpym", "previous_cbpycy", "previous_bbPsty", "previous_cbfpry", "previous_cbvpcy", "previous_cbPry", "previous_cbPsty", "previous_bbncy", "previous_cbpycat", "previous_cbPky", "previous_cbtcy", "previous_bbpcat", "previous_cbnky", "previous_bclpzy", "previous_bbnym", "previous_cbncy", "previous_bbnky", "previous_cbprwy", "previous_cbvpoy", "previous_cbpcry", "previous_cblpzy", "previous_cbwpry", "previous_bbPry", "previous_bbPcat", "previous_cbpccy", "previous_bbpym", "previous_bbpry", "previous_bclpcy", "previous_cbnty", "previous_bbnry", "previous_cbnym", "previous_cbnry", "previous_cbpyry", "previous_cbpsoy", "previous_bbpch", "previous_cbpcat", "previous_bbpty", "previous_cbnpky", "previous_bcpry", "previous_cbppwy", "previous_cbprcy", "previous_cbpky", "previous_bbnwy", "previous_cbpcwy", "previous_cblpcy", "previous_cbpwy", "previous_cbPch", "previous_cbppry"], "predicted_cbpcy": ["predicted_cbpCy", "predicted_cbjpcy", "predicted_debppCy", "predicted_cbppiny", "predicted_cbppcy", "predicted_cbjpiny", "predicted_debpCy", "predicted_debppcy", "predicted_debpiny", "predicted_cbppCy", "predicted_debpcy", "predicted_cbjpCy", "predicted_cbpiny", "predicted_debppiny"], "p_cbpcy": ["p_cbfpcr", "p_bbfky", "p_pbpocy", "p_bbfkee", "p_cbpkee", "p_cblpwy", "p_cvpry", "p_cbprocfy", "p_cbfpcor", "p_ebpacor", "p_cbpaye", "p_cbbcy", "p_cbfcy", "p_cbbpcy", "p_bbfry", "p_cbppry", "p_cblpocy", "p_cbppfy", "p_bcpcy", "p_cbfct", "p_cbccy", "p_cvpcy", "p_cbpacr", "p_cbfcr", "p_ebpacy", "p_cbpsty", "p_abbpcy", "p_cbprcy", "p_cbcwy", "p_cbnpcy", "p_fbpact", "p_abbpcr", "p_cbpccy", "p_ebpcy", "p_abbfcr", "p_bcnpcy", "p_cvfya", "p_cbcct", "p_cbpaky", "p_cbpfy", "p_pbbpsty", "p_cblpcy", "p_cbpky", "p_cbpwy", "p_cblpky", "p_cbpact", "p_cbproccy", "p_bbpkee", "p_cblpct", "p_cbprct", "p_cblpci", "p_cbpocy", "p_cbprry", "p_abbfky", "p_cbpcor", "p_bcnpku", "p_cbpku", "p_bcnpky", "p_abbfcy", "p_bcnpfy", "p_cbpcr", "p_bbpcy", "p_cblpsty", "p_bbfcy", "p_cbnpfy", "p_fbpct", "p_cbnpcr", "p_bbpky", "p_cbpry", "p_cbcye", "p_ebpcor", "p_cbfpcy", "p_cblppy", "p_abbpky", "p_pbpsty", "p_cbpya", "p_cbpcky", "p_fbpwy", "p_ebpky", "p_cbnpky", "p_abbpci", "p_cbfpky", "p_cbpcsty", "p_ebpcr", "p_cbpcry", "p_cbppy", "p_cbbry", "p_cbpacor", "p_pbpcy", "p_cbpckee", "p_cbfya", "p_cbfry", "p_pbbpcy", "p_cbfpy", "p_cbbya", "p_pbbpocy", "p_fbpye", "p_cbfkee", "p_cbpci", "p_bcpku", "p_cbpawy", "p_cbpppy", "p_cbpacy", "p_cbbpky", "p_cblpye", "p_cbppku", "p_ebpaky", "p_cvpct", "p_cbnpci", "p_bbppy", "p_pbbpky", "p_fbpcy", "p_cvfry", "p_cbpye", "p_cvfcy", "p_fbpacy", "p_cblpkee", "p_ebpacr", "p_cbprocku", "p_cblpcr", "p_cbfci", "p_bbpry", "p_fbpaye", "p_cbfcor", "p_cvfct", "p_cbprocky", "p_cbfky", "p_cvpya", "p_pbpky", "p_cbppky", "p_bbfpy", "p_cbpcocy", "p_cbbpocy", "p_cbpct", "p_cbprya", "p_cblpry", "p_cbppcy", "p_bcpfy", "p_cbbpsty", "p_fbpawy", "p_cbbct", "p_cbnpku", "p_abbfci", "p_bcpky"], "mb_y": ["mbFsize", "mbFx", "MB_y", "mbFvy", "mp_w", "mb_yd", "mb_type", "MB_size", "MB_ye", "mbFye", "mb_w", "mp_y", "mb_vy", "mp_type", "mbFyd", "mbFtype", "mb_ye", "mp_yd", "MB_vy", "mp_x", "mbFy", "mb_size"], "mb_x": ["mb_wx", "MB_z", "MB_x", "mb11n", "mb_n", "MB_wx", "mb_rx", "mb__gy", "mp_rx", "mp_gy", "mb11x", "mp_z", "MB_ex", "mb__x", "mb__n", "mp_y", "mb__y", "mb11gy", "mb_gy", "mb11y", "mp_n", "mp_x", "mb_ex", "mp_ex", "mb_z"], "current_mb": ["current_bb", "current_mm", " current_mm", "current_emb", " current_MB", " current_emb", " current_bb", "current_MB"]}}
{"project": "FFmpeg", "commit_id": "8d857c543402911f46ad38b093ab9aaf5b9a9a18", "target": 1, "func": "static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,\n\n                            const uint32_t *quant) {\n\n    int coeff, i, n;\n\n    int8_t ac;\n\n    uint8_t dc = get_bits(gb, 8);\n\n\n\n    // block not coded\n\n    if (dc == 255)\n\n\n\n\n    // number of non-zero coefficients\n\n    coeff = get_bits(gb, 6);\n\n    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)\n\n\n\n\n    // normally we would only need to clear the (63 - coeff) last values,\n\n    // but since we do not know where they are we just clear the whole block\n\n    memset(block, 0, 64 * sizeof(DCTELEM));\n\n\n\n    // 2 bits per coefficient\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 2);\n\n        if (ac == -2)\n\n            break; // continue with more bits\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    // 4 bits per coefficient\n\n    ALIGN(4);\n\n\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 4);\n\n        if (ac == -8)\n\n            break; // continue with more bits\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    // 8 bits per coefficient\n\n    ALIGN(8);\n\n    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)\n\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 8);\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    PUT_COEFF(dc);\n\n    return 1;\n\n}", "idx": 11543, "substitutes": {"gb": ["GB", "gu", "ui", "gd", "boot", "bb", "pg", "nb", "g", "gio", "gpu", "phy", "bm", "b", "game", "gm", "wb", "gs", "bridge", "gin", "bo", "gp", "rb", "gt", "gal", "bug", "gh", "bc", "gy", "binary", "db", "bf", "cgi", "eb", "bg", "gate", "agg", "ig", "lib", "gi", "sync", "gg", "ctx", "gem", "lb", "ga", "sb", "pc", "usb", "git", "dc", "storage", "hub", "plugin", "gru", "gc", "cfg", "rg", "vg", "ge", "bin", "buff", "gam", "kb", "mb"], "block": ["channel", "Block", "session", "byte", "co", "bb", "board", "b", "bridge", "line", "batch", "config", "pixel", "loc", "coll", "group", "bc", "db", "unit", "bl", "device", "gate", "ck", "query", "ctx", "tx", "blocks", "bus", "pc", "ko", "node", "bit", "hub", "plugin", "spec", "lock", "self", "row", "bin", "cache", "buffer", "range"], "scan": ["mac", "scale", "comment", "src", "unc", "doc", "gain", "config", "cs", "parse", "gate", "sync", "rc", "query", "feature", "raw", "circ", "pc", "spec", "enc", "cat", "gc", "dev", "cache", "bin", "proc", "gam", "sc", "acc"], "quant": ["fix", "comment", "prefix", "depth", "pad", "complex", "quad", "total", "num", "doc", "gain", "draw", "util", "vis", "q", "wait", "input", "query", "raw", "circ", "cost", "frac", "spec", "transform", "gap", "comp", "cache", "gam", "acc"], "coeff": ["coef", "coefficients", "cef", "colefficient", "colef", " coefficients", "koeff", "COef", "coff", "ceff", "ceffect", "COeffect", "coleff", "Coeffect", "Coefficient", "collef", "Coff", "colefficients", "COefficient", "coeffect", "goefficient", "cefficient", "Coefficients", " coef", "colleff", "collff", "COeff", "COff", "goeff", "collefficient", "coefficient", "COefficients", "koef", "Coeff", "koefficient", "goef", " coefficient", " coeffect", " coff", "goefficients", "koeffect", "Coef"], "i": ["ui", "it", "g", "si", "in", "m", "id", "b", "k", "d", "c", "p", "f", "ai", "index", "mi", "ar", "r", "pi", "bi", "ii", "I", "ip", "ci", "a"], "n": ["nb", "g", "w", "m", "k", "b", "num", "d", "c", "p", "e", "f", "an", "o", "N", "name", "r", "sn", "nr", "ns", "nan", "nc", "ni", "y", "nn"], "ac": ["sac", "mac", "oc", "Ac", "ack", "abc", "jac", "tc", "unc", "auc", "k", "c", "ad", "cu", "ace", "iac", "fact", "act", "mic", "ec", "loc", "ak", "bc", "cc", "op", "ai", "cs", "alpha", "acs", "inc", "input", "ic", "cas", "am", "ga", "acl", "circ", "pc", "dc", "spec", "enc", "disc", "cat", "nc", "aa", "ca", "fc", "a", "AC", "comp", "fac", "lc", "anc", "cache", "vc", "mc", "uc", "acc", "rac"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void *memory_region_get_ram_ptr(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n", "idx": 4440, "substitutes": {"mr": ["dr", "gr", "fr", "er", "vr", "sr", "rt", "pr", "rr", "md", "rb", "shr", "mid", "MR", "tr", "rc", "rd", "rf", "bm", "wk", "m", "rm", "rh", "tx", "attr", "mn", "nr", "pc", "km", "mc", "mt", "Mr", "rg", "timer", "tm", "rx", "lr", "rl", "err", "gro", "war", "usr", "yr", "mm", "RR", "hr", "br", "lc", "adr", "kr", "rs", "r"]}}
{"project": "FFmpeg", "commit_id": "7e3e653618a59960b4c358e333ba2c0d21929e33", "target": 1, "func": "static AVStream * init_stream(AVFormatContext *s)\n\n{\n\n    BinDemuxContext *bin = s->priv_data;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return NULL;\n\n    st->codec->codec_tag   = 0;\n\n    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;\n\n\n\n    if (!bin->width) {\n\n        st->codec->width  = (80<<3);\n\n        st->codec->height = (25<<4);\n\n    }\n\n\n\n    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);\n\n\n\n    /* simulate tty display speed */\n\n    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);\n\n\n\n    return st;\n\n}\n", "idx": 767, "substitutes": {"s": ["sg", "src", "cs", "ss", "spec", "ts", "sa", "a", "sb", "r", "n", "is", "sl", "sis", "bis", "i", "ses", "ls", "sf", "xs", "sv", "settings", "ds", "ns", "c", "p", "sie", "services", "e", "sed", "f", "es", "sq", "south", "sn", "sr", "b", "su", "S", "os", "bs", "an", "init", "se", "si", "in", "sym", "parts", "ssl"], "bin": ["bian", "base", "ban", "bn", "fen", "ba", "bank", "bit", "sa", "sb", "sid", "data", "bm", "binary", "spin", "sam", "n", "di", "bid", "bc", "con", "bon", "boot", "ben", "num", "bl", "gin", "bis", "scan", "gn", "inn", "ini", "bas", "non", "bot", "bi", "cookie", "nb", "len", "vin", "gb", "win", "bg", "sn", "bb", "pc", "lib", "fb", "b", "plugin", "border", "lin", "web", "gen", "bs", "an", "root", "init", "dat", "net", "pin", "db"], "st": ["stage", "ist", "ust", "ld", "src", "stal", "rest", "ss", "stan", "stat", "ts", "sa", "sd", "sb", "be", "r", "d", "ct", " est", "sp", "sl", "sh", "spect", "cur", "sk", "St", "bl", "ste", "sf", "stri", "ft", "fr", "nt", "cr", "str", "storage", "fe", "l", "sw", "ut", "lc", "stab", "sc", "ST", "stable", "stream", "bt", "std", "obj", " St", "sn", "sts", "sta", "inst", "t", "stop", "bs", "ost", "td", "nd", "ast", "se", "part", "start", "net", "sth", "sty", "est"]}}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int alloc_refcount_block(BlockDriverState *bs,\n\n    int64_t cluster_index, uint16_t **refcount_block)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    unsigned int refcount_table_index;\n\n    int ret;\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);\n\n\n\n    /* Find the refcount block for the given cluster */\n\n    refcount_table_index = cluster_index >> s->refcount_block_bits;\n\n\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n\n\n        uint64_t refcount_block_offset =\n\n            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n\n\n\n        /* If it's already there, we're done */\n\n        if (refcount_block_offset) {\n\n            if (offset_into_cluster(s, refcount_block_offset)) {\n\n                qcow2_signal_corruption(bs, true, -1, -1, \"Refblock offset %#\"\n\n                                        PRIx64 \" unaligned (reftable index: \"\n\n                                        \"%#x)\", refcount_block_offset,\n\n                                        refcount_table_index);\n\n                return -EIO;\n\n            }\n\n\n\n             return load_refcount_block(bs, refcount_block_offset,\n\n                 (void**) refcount_block);\n\n        }\n\n    }\n\n\n\n    /*\n\n     * If we came here, we need to allocate something. Something is at least\n\n     * a cluster for the new refcount block. It may also include a new refcount\n\n     * table if the old refcount table is too small.\n\n     *\n\n     * Note that allocating clusters here needs some special care:\n\n     *\n\n     * - We can't use the normal qcow2_alloc_clusters(), it would try to\n\n     *   increase the refcount and very likely we would end up with an endless\n\n     *   recursion. Instead we must place the refcount blocks in a way that\n\n     *   they can describe them themselves.\n\n     *\n\n     * - We need to consider that at this point we are inside update_refcounts\n\n     *   and potentially doing an initial refcount increase. This means that\n\n     *   some clusters have already been allocated by the caller, but their\n\n     *   refcount isn't accurate yet. If we allocate clusters for metadata, we\n\n     *   need to return -EAGAIN to signal the caller that it needs to restart\n\n     *   the search for free clusters.\n\n     *\n\n     * - alloc_clusters_noref and qcow2_free_clusters may load a different\n\n     *   refcount block into the cache\n\n     */\n\n\n\n    *refcount_block = NULL;\n\n\n\n    /* We write to the refcount table, so we might depend on L2 tables */\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Allocate the refcount block itself and mark it as used */\n\n    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);\n\n    if (new_block < 0) {\n\n        return new_block;\n\n    }\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Allocate refcount block %d for %\" PRIx64\n\n        \" at %\" PRIx64 \"\\n\",\n\n        refcount_table_index, cluster_index << s->cluster_bits, new_block);\n\n#endif\n\n\n\n    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {\n\n        /* Zero the new refcount block before updating it */\n\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n\n            (void**) refcount_block);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n\n\n        /* The block describes itself, need to update the cache */\n\n        int block_index = (new_block >> s->cluster_bits) &\n\n            (s->refcount_block_size - 1);\n\n        (*refcount_block)[block_index] = cpu_to_be16(1);\n\n    } else {\n\n        /* Described somewhere else. This can recurse at most twice before we\n\n         * arrive at a block that describes itself. */\n\n        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,\n\n                              QCOW2_DISCARD_NEVER);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        /* Initialize the new refcount block only after updating its refcount,\n\n         * update_refcount uses the refcount cache itself */\n\n        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,\n\n            (void**) refcount_block);\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        memset(*refcount_block, 0, s->cluster_size);\n\n    }\n\n\n\n    /* Now the new refcount block needs to be written to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);\n\n    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /* If the refcount table is big enough, just hook the block up there */\n\n    if (refcount_table_index < s->refcount_table_size) {\n\n        uint64_t data64 = cpu_to_be64(new_block);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);\n\n        ret = bdrv_pwrite_sync(bs->file,\n\n            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),\n\n            &data64, sizeof(data64));\n\n        if (ret < 0) {\n\n            goto fail_block;\n\n        }\n\n\n\n        s->refcount_table[refcount_table_index] = new_block;\n\n\n\n        /* The new refcount block may be where the caller intended to put its\n\n         * data, so let it restart the search. */\n\n        return -EAGAIN;\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n\n    if (ret < 0) {\n\n        goto fail_block;\n\n    }\n\n\n\n    /*\n\n     * If we come here, we need to grow the refcount table. Again, a new\n\n     * refcount table needs some space and we can't simply allocate to avoid\n\n     * endless recursion.\n\n     *\n\n     * Therefore let's grab new refcount blocks at the end of the image, which\n\n     * will describe themselves and the new refcount table. This way we can\n\n     * reference them only in the new table and do the switch to the new\n\n     * refcount table at once without producing an inconsistent state in\n\n     * between.\n\n     */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);\n\n\n\n    /* Calculate the number of refcount blocks needed so far */\n\n    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size);\n\n\n\n    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {\n\n        return -EFBIG;\n\n    }\n\n\n\n    /* And now we need at least one block more for the new metadata */\n\n    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);\n\n    uint64_t last_table_size;\n\n    uint64_t blocks_clusters;\n\n    do {\n\n        uint64_t table_clusters =\n\n            size_to_clusters(s, table_size * sizeof(uint64_t));\n\n        blocks_clusters = 1 +\n\n            ((table_clusters + s->refcount_block_size - 1)\n\n            / s->refcount_block_size);\n\n        uint64_t meta_clusters = table_clusters + blocks_clusters;\n\n\n\n        last_table_size = table_size;\n\n        table_size = next_refcount_table_size(s, blocks_used +\n\n            ((meta_clusters + s->refcount_block_size - 1)\n\n            / s->refcount_block_size));\n\n\n\n    } while (last_table_size != table_size);\n\n\n\n#ifdef DEBUG_ALLOC2\n\n    fprintf(stderr, \"qcow2: Grow refcount table %\" PRId32 \" => %\" PRId64 \"\\n\",\n\n        s->refcount_table_size, table_size);\n\n#endif\n\n\n\n    /* Create the new refcount table and blocks */\n\n    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *\n\n        s->cluster_size;\n\n    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;\n\n    uint64_t *new_table = g_try_new0(uint64_t, table_size);\n\n    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);\n\n\n\n    assert(table_size > 0 && blocks_clusters > 0);\n\n    if (new_table == NULL || new_blocks == NULL) {\n\n        ret = -ENOMEM;\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Fill the new refcount table */\n\n    memcpy(new_table, s->refcount_table,\n\n        s->refcount_table_size * sizeof(uint64_t));\n\n    new_table[refcount_table_index] = new_block;\n\n\n\n    int i;\n\n    for (i = 0; i < blocks_clusters; i++) {\n\n        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);\n\n    }\n\n\n\n    /* Fill the refcount blocks */\n\n    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));\n\n    int block = 0;\n\n    for (i = 0; i < table_clusters + blocks_clusters; i++) {\n\n        new_blocks[block++] = cpu_to_be16(1);\n\n    }\n\n\n\n    /* Write refcount blocks to disk */\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);\n\n    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,\n\n        blocks_clusters * s->cluster_size);\n\n    g_free(new_blocks);\n\n    new_blocks = NULL;\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* Write refcount table to disk */\n\n    for(i = 0; i < table_size; i++) {\n\n        cpu_to_be64s(&new_table[i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,\n\n        table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    for(i = 0; i < table_size; i++) {\n\n        be64_to_cpus(&new_table[i]);\n\n    }\n\n\n\n    /* Hook up the new refcount table in the qcow2 header */\n\n    uint8_t data[12];\n\n    cpu_to_be64w((uint64_t*)data, table_offset);\n\n    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);\n\n    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);\n\n    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),\n\n        data, sizeof(data));\n\n    if (ret < 0) {\n\n        goto fail_table;\n\n    }\n\n\n\n    /* And switch it in memory */\n\n    uint64_t old_table_offset = s->refcount_table_offset;\n\n    uint64_t old_table_size = s->refcount_table_size;\n\n\n\n    g_free(s->refcount_table);\n\n    s->refcount_table = new_table;\n\n    s->refcount_table_size = table_size;\n\n    s->refcount_table_offset = table_offset;\n\n\n\n    /* Free old table. */\n\n    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),\n\n                        QCOW2_DISCARD_OTHER);\n\n\n\n    ret = load_refcount_block(bs, new_block, (void**) refcount_block);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* If we were trying to do the initial refcount update for some cluster\n\n     * allocation, we might have used the same clusters to store newly\n\n     * allocated metadata. Make the caller search some new space. */\n\n    return -EAGAIN;\n\n\n\nfail_table:\n\n    g_free(new_blocks);\n\n    g_free(new_table);\n\nfail_block:\n\n    if (*refcount_block != NULL) {\n\n        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);\n\n    }\n\n    return ret;\n\n}\n", "idx": 1136, "substitutes": {"bs": ["ob", "base", "js", "cs", "abi", "bh", "ss", "http", "sa", "sb", "bps", "lb", "bm", "BS", "aws", "bc", "banks", "pb", "fps", "bl", "bis", "locks", "plugins", "ls", "ses", "sync", "cb", "outs", "ds", "bas", "gs", "ns", "css", "vs", "bi", "bos", "gb", "lbs", "bb", "blocks", "stats", "fb", "b", "iss", "ubs", "os", "ks", "las", "bytes", "bes", "fs", "db", "obs"], "cluster_index": ["clusteridsize", "cluster_image", "cluster_column", "cluster67image", "clusterCimage", "clusters_size", "clusteridoffset", "cluster00index", "clusterCindex", "clusteridindex", "cluster_design", "cluster67size", "cluster_offset", "clue_number", "cluster_label", "clue67label", "clusters_index", "clue_label", "clue67design", "clue_index", "clusters_offset", "cluster00design", "cluster_size", "clusterCsize", "cluster67number", "cluster_number", "cluster_height", "cluster67offset", "cluster67label", "cluster67design", "clusters_image", "clue_design", "clue67number", "clue67index", "clusteridheight", "cluster_id", "cluster67index", "clusterCoffset", "cluster00number", "cluster00label"], "refcount_block": ["refcount00ver", "refcount_type", "refsize_type", "refcount\u00b7row", "refount_lock", "reflist64view", "refcount67type", "reftype_ver", "refcount64block", "refcount\u00b7lock", "reflist64section", "refcountsblock", "refcount_ver", "reflist_block", "reflist_container", "reftype_container", "reflist_view", "reftype_lock", "reftype_block", "refcountsrow", "refcount67header", "reftype00ver", "refcount_section", "refsize_header", "refount_row", "reftype00container", "refount_table", "refcount67block", "refcount___container", "refcount00block", "reflist_section", "refcount___view", "refcount\u00b7block", "refcount\u00b7condition", "refcount_header", "refount_block", "refcount___block", "refcountslock", "refount_type", "refcountscondition", "refount_condition", "refcount00lock", "reflist64container", "refcount_container", "refcount_condition", "refsize_block", "refcount_lock", "refcount___section", "refcount00container", "reftype00block", "refcount64container", "refcount_view", "refcount64section", "refcount64view", "reftype00lock", "refcount_table", "refcount_row", "refcount64ver", "refcount64lock", "reflist64block"], "s": ["js", "service", "cs", "http", "ss", "spec", "sa", "qs", "ts", "sb", "rs", "self", "aws", "is", "ins", "sl", "ims", "bis", "g", "ses", "ls", "uns", "sync", "settings", "sv", "outs", "ds", "status", "sets", "ps", "gs", "xs", "storage", "ns", "l", "c", "p", "sie", "state", "services", "e", "vs", "f", "es", "secondary", "sys", "sq", "css", "us", "south", "comm", "iss", "stats", "less", "b", "site", "S", "su", "t", "os", "ks", "full", "its", "states", "fs", "si", "sym", "parts", "ssl"], "refcount_table_index": ["refcount_cache_level", "refcount_tablePindex", "refcount_chain_position", "refcount_cache_index", "refcount_table_position", "refcount_cache_height", "refcount_tablePsize", "refcount_table_offset", "refcount_tablePheight", "refcount_cache_length", "refcount_table_ind", "refcount_chain_offset", "refcount_table_data", "refcount_chain_index", "refcount_cache_i", "refcount_table_size", "refcount_table_i", "refcount_cache_slice", "refcount_table_height", "refcount_chain_size", "refcount_tablePlevel", "refcount_table_length", "refcount_table_level", "refcount_cache_ind", "refcount_cache_data", "refcount_table_slice", "refcount_cache_size"], "ret": ["match", "arg", "fun", "no", "att", "mt", "ext", "def", "bit", "conn", "hash", " Ret", "success", "out", "alt", "cat", "job", "rets", "end", "num", " RET", "rb", "code", "lt", "info", "nt", "ft", "rev", "back", "reply", "feat", "Ret", "bf", "pub", "last", "result", "fin", "len", "flag", "ref", "reset", "red", "gt", "value", "art", "obj", "en", "sr", "RET", "error", "lit", "reg", "re", "val", "rt", "count", "pt", "let", "part", "det", "res", "db", "rc", "mem"]}}
{"project": "qemu", "commit_id": "65207c59d99f2260c5f1d3b9c491146616a522aa", "target": 1, "func": "static inline bool handler_is_async(const mon_cmd_t *cmd)\n\n{\n\n    return cmd->flags & MONITOR_CMD_ASYNC;\n\n}\n", "idx": 2349, "substitutes": {"cmd": ["cm", "call", "cli", "ctx", "conn", "command", "cc", "method", "Cmd", "cat", "client", "buf", "dom", "code", "cb", "md", "func", "cod", "dc", "pkg", "c", "cookie", "ctr", "core", "ctrl", "cd", "std", "comm", "node", "obj", "cp", "plugin", "req", "module", "cf", "cmp", "msg", "cfg"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int process_input_packet(InputStream *ist, const AVPacket *pkt)\n\n{\n\n    int i;\n\n    int got_output;\n\n    AVPacket avpkt;\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->last_dts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int ret = 0;\n\n    handle_eof:\n\n\n\n        ist->last_dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size &&\n\n            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = decode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = decode_video    (ist, &avpkt, &got_output);\n\n            if (avpkt.duration)\n\n                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            else if (ist->st->avg_frame_rate.num)\n\n                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),\n\n                                              AV_TIME_BASE_Q);\n\n            else if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :\n\n                                                   ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        ist->last_dts = ist->next_dts;\n\n        switch (ist->dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /\n\n                             ist->dec_ctx->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (ist->dec_ctx->time_base.num != 0) {\n\n                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->dec_ctx->time_base.num * ticks) /\n\n                                  ist->dec_ctx->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 566, "substitutes": {"ist": ["dr", "ism", "ists", "act", "rest", "ct", "adder", "kt", "er", "ind", "pop", "set", "wp", "gest", "irst", "est", "ld", "ext", "alist", "ht", "sth", "erd", "pick", "edit", "ict", "asp", "adr", "post", "work", "esp", "isi", "wd", "uss", "ird", "iz", "nd", "ast", "pt", "artist", "ard", "IST", "osi", "xt", "ad", "add", "op", "ait", "str", "feat", "st", "oss", "et", "ide", "isu", "ista", "rss", "inst", "sim", "dit", "ust", "isc", "dd", "isd", "ant", "asi", "ord", "it", "iste", "pect", "nt", "ft", "mot", "ess", "ocr", "art", "std", "ilst", "sta", "dat", "part", "ace", "gd", "dist"], "pkt": ["pcht", " packet", " pct", "pnt", "poch", "tpacket", " poch", "jpkt", "pelt", "pkh", "tacket", "paelt", "ipkh", "Pft", "wpcht", "prekt", "paacket", "spkt", " pkg", "packet", "wpkh", "ipcht", " pqt", "preacket", "tpcht", "ipnt", "cpelt", "ipkt", " pcht", "wpnt", "pkg", "tpkt", "spkg", "Pkg", "ipacket", "cpoch", "jpacket", "pct", "pakt", "dunch", "Pkt", "ipelt", "spacket", "Pcht", "punch", "spcht", "pft", "prent", " pelt", " punch", "Pnt", "ipoch", "cpkt", "jpqt", "tkt", "spnt", "Punch", "telt", "tcht", "Pelt", "spelt", "Pct", " pft", "tpqt", "Pqt", "preelt", " pnt", "pacht", "spkh", "cpacket", "dacket", "pqt", "dkt", "wpkt", "dct", "jpft", "Packet"], "i": ["ret", "out", "I", "n", "id", "it", "num", "j", "g", "rep", "inner", "info", "nt", "multi", "h", "x", "p", "et", "fin", "f", "len", "set", "reset", "en", "debug", "start", "det", "res"], "got_output": ["gotestenabled", "genestgenerated", "given_input", " got_Output", "got_hidden", "got_control", "gotesttarget", "gotaccontrol", "got_target", "gotayenabled", "gotacoutput", "genestenabled", "gotachidden", "genestoutput", "got_Output", "given_output", " got_value", "gen_target", "got_value", "genesttarget", "gotayOutput", "got_reason", "got_progress", "got_input", "got_enabled", "got_generated", "gotestgenerated", "gotaygenerated", "gen_output", "gotayreason", " got_reason", "gotacinput", "given_control", "gotestoutput", "gotaytarget", "gen_enabled", " got_progress", "given_hidden", "gen_generated", "gotayoutput"], "avpkt": ["avnpka", "avnpkt", "ullpck", "avcurrentkt", "affkt", "affck", "avpreacket", "AVpqt", "attcpacket", "avopck", "avspacket", "avprekt", "ajpkt", "avpft", "avppsth", "avespacket", "avpakt", "avvacket", "avppka", "avbputh", "ajmft", "AVpauth", "attcpkt", "avcurrentacket", "airlelt", "avfcht", "avbcht", "avhelt", "avelacket", "avcpet", "avmcht", "navpkat", "airpKT", "avcacket", "avepka", "avgelt", "avpqt", "avbpcht", "avpett", "avpacht", "avpacket", "avppft", "avpekt", "avpaunch", "airlacket", "avpeconn", "avpkat", "avcnt", "avpaacket", "airbkt", "avcpacket", "avcpt", "avrcht", "avppkh", "avepunch", "avspeth", "avpka", "avbpqt", "avbpkt", "avpaft", "attpacket", "avgkt", "ajpcht", "ajmkt", "navdacket", "avdacket", "airpett", "avcpkt", "AVpaft", "avnpck", "avcpck", "affacket", "avspelt", "avlKT", "avppck", "avbacket", "avppkt", "avfck", "ajpft", "avbpsth", "airbett", "ampkt", "avespkt", "avspunch", "avfunch", "avfpka", "avenpkt", "ullppsth", "attcpet", "avfconn", "avelnt", "avheth", "avvkt", "avpunch", "avpet", "avbkt", "navdkat", "avfiece", "avfkt", "avmkt", "avprkat", "avepnt", "ajmelt", "avepkt", "avbpck", "navpkt", "airbft", "AVpaqt", "ampcht", "ullppck", "avfpft", "ullpkt", "avwett", "avbett", "avespunch", "avwcht", "attpck", "avbpft", "avpck", "avespcht", "avpreelt", "avbconn", "ampeth", "airlKT", "avapeth", "avepft", "avelpt", "avgft", "amspeth", "avppt", "attpkt", "avpKT", "avbuth", "avdkat", "avpeth", "avspcht", "avpreKT", "ullpkh", "ampelt", "avapelt", "avnpsth", "ajpelt", "ajmcht", "avspkt", "affconn", "attcpck", "avbck", "avvKT", "avvelt", "avenpck", "avbpkh", "airlkt", "amspkt", "avepcht", "amspelt", "airpcht", "airpft", "avdiece", "avopacket", "afpconn", "avhcht", "airpelt", "avpnt", "navpiece", "AVpkt", "avpsth", "afpkt", "avbqt", "avmft", "avputh", "avfpck", "avwft", "avfkat", "avrft", "avbft", "avelkt", "avmelt", "navdkt", "avpriece", "avgcht", "avopet", "avpconn", "avbpelt", "airbcht", "ullpsth", "avfpkt", "navdiece", "avpcht", "avpkh", "avlpt", "avdkt", "avapkt", "AVputh", "avepacket", "avprkt", "ullppkh", "avopkt", "avenpft", "avfacket", "avcurrentpt", "avnpft", "avpiece", "aveppt", "avpracket", "avpeacket", "avnpkh", "afpacket", "avepck", "AVpakt", "avfet", "avenpka", "avlnt", "airpacket", "avpaqt", "ullppkt", "navpacket", "afpck", "amspcht", "avrkt", "AVpft", "avhkt", "avpelt", "airpkt", "avlelt", "avapcht", "avwkt", "avpeck", "avlkt", "avckt", "avlacket", "avcurrentnt", "avpauth", "avrett", "attpet"]}}
{"project": "FFmpeg", "commit_id": "6f3d2fb18bb6225c27e22a95846c42f2093dc3b7", "target": 0, "func": "static void end_last_frame(AVFilterContext *ctx)\n\n{\n\n    TileContext *tile    = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n    AVFilterBufferRef *out_buf = outlink->out_buf;\n\n\n\n    outlink->out_buf = NULL;\n\n    ff_start_frame(outlink, out_buf);\n\n    while (tile->current < tile->nb_frames)\n\n        draw_blank_frame(ctx, out_buf);\n\n    ff_draw_slice(outlink, 0, out_buf->video->h, 1);\n\n    ff_end_frame(outlink);\n\n    tile->current = 0;\n\n}\n", "idx": 7649, "substitutes": {"ctx": ["cp", "cmp", "anc", "fw", "ci", "component", "config", "cus", "rc", "cca", "concept", "loc", "px", "cm", "tx", "sk", "client", "conv", "obj", "cc", "ctr", "cs", "cli", "sci", "kt", "conf", "ck", "sc", "cam", "cmd", "wcs", "bc", "cb", "exec", "Context", "cu", "context", "ctrl", "ca", "kb", "c", "ct", "cn", "cf", "tk", "lc", "fc", "cv", "vc", "src", "cas", "conn", "pkg", "xc", "tc"], "tile": ["tool", "cp", "lane", "tf", "layer", "chip", "phy", "rt", "coe", "component", "ci", "qt", "kick", "update", "pixel", "crop", "tto", "race", "slice", "module", "texture", "tu", "grid", "plate", "ace", "px", "tif", "so", "image", "Tile", "sk", "late", "grade", "cli", "ctr", "kt", "uri", "target", "oe", "zip", "file", "plane", "fit", "tm", "cu", "ski", "task", "coll", "context", "ne", "ie", "scale", "ptr", "frame", "oi", "txt", "thread", "tk", "cf", "ilo", "dt", "tt", "cache", "conn", "feature", "tc"], "outlink": ["outstyle", "uplike", "apploop", "outhide", "inlink", "outlinked", "outLink", "outline", "againlink", "upline", "againstyle", "outputstyle", "pointlock", "inLink", "offloop", "libstyle", "outputlink", "outerhide", "instyle", "outerloop", "inlinked", "applink", "outlock", "offlink", "offlinked", "appload", "uppath", "inloop", "pointline", "liblink", "pointLink", " outline", "offload", "outputlike", "inload", "outlike", "againload", "inlock", " outlinked", "libline", "liblinked", "outerload", "outputpath", "applinked", "againloop", " outload", " outlock", "againhide", " outloop", "againpath", "pointlink", "uploop", " outstyle", "againlike", "outloop", "uplink", "upstyle", " outLink", " outhide", "upload", "outerlink", "outload", "outpath"], "out_buf": ["outdbuf", "in_buf", "outFbuf", "outPuf", "out_cache", "outingbuff", " out_bag", "outAcbuff", "out2buffer", "out_buff", "outdbuffer", " out_block", "out_uf", "outfbuf", "outdqueue", " outPbuffer", "out2cb", "outfref", "in_buffer", "outingbuf", "outIPblock", "outFbag", "outFuf", "out2block", "out_ref", "out_queue", "outfqueue", "outAcbuffer", "outPbag", "in_queue", "outingcache", " outPbag", "outIPbuf", "outPbuf", "outIPbuff", "outdbuff", "out_bag", " out_buffer", " out_buff", "outAcbuf", "out_cb", "out_buffer", "outfbuffer", "out2buf", " out_cache", "in_buff", " outPuf", " outPbuf", "outingbuffer", " out_uf", "outPbuffer", "outFbuffer", "out_block", "out2buff", "in_cb", "outfbuff", "outAccache", "in_ref"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void raven_class_init(ObjectClass *klass, void *data)\n\n{\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->init = raven_init;\n\n    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;\n\n    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;\n\n    k->revision = 0x00;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"PReP Host Bridge - Motorola Raven\";\n\n    dc->vmsd = &vmstate_raven;\n\n    dc->no_user = 1;\n\n}\n", "idx": 3598, "substitutes": {"klass": ["Kcl", "oklass", "klasses", " kazz", "kickclass", "okull", "skazz", "Kull", "kickazz", "kull", "okclass", "Klf", "kicklass", "skull", "Kclass", "kicklf", " kcl", "sklasses", " klf", "skclass", "klf", "skcl", "kazz", "Klasses", "Klass", "sklass", "kclass", "okcl", "Kazz", " klasses", "kcl", " kclass"], "data": ["da", "dd", "def", "context", "device", "cc", "rec", "record", "parent", "i", "params", "m", "info", "create", "df", "config", "json", "raw", "result", "reader", "dev", "DATA", "dat", "Data", "input", "db"], "k": ["ek", "uk", "cs", "q", "kick", "key", "device", "ke", "d", "tk", "ck", "kind", "K", "sk", "ko", "kr", "g", "dk", "kin", "ka", "m", "ijk", "ok", "kt", "mk", "kw", "kn", "c", "kid", "p", "self", "f", "u", "ku", "kk", "ki", "o", "ik", "ks"], "dc": ["fc", "DC", "da", "cc", "mc", "device", "d", "di", "tk", "ck", "nc", "director", "bc", "tc", "de", "cdn", "dk", "ac", "df", "dt", "ds", "config", "ec", "c", "doc", "lc", "design", "sc", "cd", "cmd", "disc", "pc", "cf", "dat", "acc", "desc", "db", "rc"]}}
{"project": "FFmpeg", "commit_id": "22fa38f0c85fb31cddbb0bc22a2df5953c702b95", "target": 0, "func": "static inline void h264_deblock_q1(register vector unsigned char p0,\n\n                                                   register vector unsigned char p1,\n\n                                                   register vector unsigned char p2,\n\n                                                   register vector unsigned char q0,\n\n                                                   register vector unsigned char tc0) {\n\n\n\n    register vector unsigned char average = vec_avg(p0, q0);\n\n    register vector unsigned char temp;\n\n    register vector unsigned char uncliped;\n\n    register vector unsigned char ones;\n\n    register vector unsigned char max;\n\n    register vector unsigned char min;\n\n\n\n    temp = vec_xor(average, p2);\n\n    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */\n\n    ones = vec_splat_u8(1);\n\n    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */\n\n    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */\n\n    max = vec_adds(p1, tc0);\n\n    min = vec_subs(p1, tc0);\n\n    p1 = vec_max(min, uncliped);\n\n    p1 = vec_min(max, p1);\n\n}\n", "idx": 9533, "substitutes": {"p0": [" p2", "q7", "q1", "p2", "q0", "c7", "c0", "cp1", "q2", "p1", " p1", "p7", "c2", "c1", "cp0", " p7", "cp2"], "temp": ["area", "eff", "base", "valid", "test", "cases", "tc", "cash", "t", "total", "mix", "Temp", "pool", "wrap", "c", "comb", "p", "output", "a", "fit", "iter", "pt", "mini", "average", "tmp", "empty", "none", "unit", "zero", "multi", "non", "fake", "amp", "wave", "current", "input", "wait", "order", "pre", "one", "new", "adapt", "now", "tim", "copy", "out", "crop", "cel", "single", "common", "clean", "tem", "null", "cache", "api", "emp", "flat", "partial", "warm", "mag", "buffer"], "uncliped": ["unapeable", "unclipsable", " unclipeded", "unclipED", "unclipsmented", "uninpaed", "unincliped", " uncapable", "uncapled", "unclipned", "uninpad", " uncapled", "uncapable", "unclipeded", " unclipsed", "unclipmented", "unpaeds", "unpad", "unclipsled", " unclipened", "unclipeds", "uncutd", "unclipseds", "uncutmented", "unpamented", "unscripted", " unclipled", "unapeed", "unclipsed", "unclipable", "uncuteds", "uncuted", "uninclipd", " unclipable", "unclipsened", " unclipED", "unclipseded", "unapeED", "uncutned", "uncuteded", "unscriptened", "unscripteded", " unclipned", " unclipsned", "unscriptned", "uncutened", "uninclipmented", "unclipsED", "unclipened", " unclipsened", "unapeled", " unclipseded", "uncaped", " uncaped", "uninclipeds", "uninpamented", "unclipled", "unclipsned", "unclipsd", "unpaed", "uninpaeds", "uncapED", "unclipd", " uncapED"], "ones": ["vals", "sample", "tones", "original", "amps", "ks", "keys", "plus", "frames", "cells", "rows", "aps", "na", "cases", "ops", "s", "ls", "names", "ins", "steps", "oned", "bits", "outs", "lines", "offs", "clone", "os", "none", "parents", "alpha", "values", "zero", "size", "packs", "cycles", "ans", "custom", "blocks", "ms", "ays", "less", "faces", " clones", "eros", "les", "pos", "null", "ips", "common", "ps", "points", "one", "ases"], "max": ["count", "diff", "parent", "conf", "ox", "co", "mad", "std", "scale", "plus", "n", "est", "ax", "pad", "w", "id", "x", "z", "last", "wrap", "ad", "sum", "from", "final", "act", "step", "none", "height", "only", "alpha", "size", "Max", "end", "az", "mod", "old", "full", "first", "frac", "now", "init", "crop", "self", "ca", "cycle", "cache", "anc", "range"], "min": ["Min", "area", "seq", "is", "n", "len", "span", "in", "prefix", "na", "ax", "start", "m", "small", "x", "sum", "s", "p", "limit", "mine", "skip", "po", "mini", "act", "mins", "none", "only", "index", "size", "non", "version", "minus", "pre", "mod", "part", "ms", "sign", "init", "mean", "pos", "null", "ps", "ng", "partial"]}}
{"project": "FFmpeg", "commit_id": "68f593b48433842f3407586679fe07f3e5199ab9", "target": 0, "func": "static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    float aspect;\n\n\n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    s->aspect_ratio_info= get_bits(&s->gb, 4);\n\n    if(!s->mpeg2){\n\n        aspect= mpeg1_aspect[s->aspect_ratio_info];\n\n        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);\n\n    }\n\n\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) /* marker */\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        /* start new mpeg1 context decoding */\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        avctx->has_b_frames= 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        if (s->frame_rate_index >= 9) {\n\n            /* at least give a valid frame rate (some old mpeg1 have this) */\n\n            avctx->frame_rate = 25 * FRAME_RATE_BASE;\n\n        } else {\n\n            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        }\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); /* vbv_buffer_size */\n\n    skip_bits(&s->gb, 1);\n\n\n\n    /* get matrix */\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_intra_matrix[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = s->intra_scantable.permutated[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->inter_matrix[s->intra_scantable.permutated[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            int j= s->idct_permutation[i];\n\n            v = ff_mpeg1_default_non_intra_matrix[i];\n\n            s->inter_matrix[j] = v;\n\n            s->chroma_inter_matrix[j] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    avctx->sub_id = 1; /* indicates mpeg1 */\n\n    return 0;\n\n}\n", "idx": 60, "substitutes": {"avctx": ["akcas", "AVsrc", "afcontext", "avcus", "mpctx", "mpcontext", "aphcontext", "aphctx", "avglobal", "afcn", "avelc", "navsrc", "afloc", "avecas", "avkw", "abconfig", "avcontext", "aveloc", "navconn", "afcmd", "aphctrl", "akctx", "avecci", "allcontext", "afcmp", "AVcontext", "avcms", " avconn", "mpconfig", "avecu", "ovcontext", "alltx", "avectx", "avecf", "afctx", "navctx", "aveconn", "akcontext", " avcmp", "apbuf", "alllc", "avcf", "ovcmd", "aphcms", "avalconn", "afconn", "AVcms", "AVglobal", "avcn", "avconfig", "avalcontext", "aucontext", "ovkw", "auloc", "abcontext", "AVcmp", "allctx", "avecmp", "avcas", "avalctx", "airloc", " avcus", " avloc", "afcas", " avkw", "avtx", "abcmp", "aftx", "aircontext", "apcontext", "afglobal", "navctrl", "afkw", "afbuf", "auctx", "ovctx", "abctx", "aucn", "avctrl", "afcu", "afcf", "aflc", "avsrc", "mpcmp", "avecus", "apconn", "afconfig", "AVctx", " avglobal", "avcmd", "avbuf", " avbuf", "avconn", "AVctrl", "avalcci", "navcms", "AVconn", " avcontext", "afcci", "avcci", "afcus", "avalcu", "apctx", "navcontext", "avetx", "avloc", "akcf", "airconn", " avcmd", "avecontext", "avcu", " avcn", "avlc", "avcmp", "airctx", "avalsrc"], "buf": ["fd", "src", "buffer", "ctx", "bn", "byte", "sb", "queue", "data", "ab", "bc", "buff", "bin", "pb", "num", "batch", "rb", "fp", "cb", "config", "raw", "block", "cv", "vec", "nb", "bd", "ref", "cache", "gb", "cmd", "alloc", "fb", "b", "seq", "conv", "uf", "img", "rc", "mem"], "buf_size": ["buf_align", "buflexsize", "imglexsize", "wav_SIZE", "wavetSIZE", "bufetlen", "wav_size", "wavetlen", "imglexdepth", "bufetsize", "buf_SIZE", "buflexdepth", "img_align", "buflexalign", "wavetsize", "wav_shape", "buf_shape", "buf_len", "img_depth", "wav_len", "bufetshape", "img_size", "wavetshape", "bufetSIZE", "buf_depth", "imglexalign"], "s1": ["wsone", "ws1", " s0", "s0", "qsOne", " sOne", "scone", "cs2", "s01", "sc11", "s11", "svone", "sone", "S01", "SOne", "qsone", "sv01", "c11", "cOne", "ws11", "s2", " s2", "Sone", "qs01", "sOne", "c1", "cs1", "sc1", "csOne", "cs0", "S1", "qs1", "c2", "c0", "ws2", "cone", "sv1", "sc2", "svOne"], "s": ["sg", "js", "qs", "n", "sl", "client", "g", "ses", "ls", "sf", "args", "storage", "us", "f", "secondary", "sys", "u", "your", "an", "se", "fs", "parts", "sup", "spec", "ts", "sb", "aws", "y", "xs", "sets", "p", "e", "conf", "su", "site", "S", "t", "ks", "os", "session", "serv", "its", "hs", "sym", "plugins", "ssl", "cs", "ctx", "ss", "a", "rs", "new", "r", "is", "ins", "bis", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "south", "o", "si", "server", "service", "ops", "d", "sk", "comments", "sync", "l", "services", "w", "sq", "b", "full", "states"], "height": ["resolution", "capacity", "device", "dim", "head", "stroke", "ty", "png", "lat", "direction", "home", "alpha", "pages", "manager", "arrow", "rh", "ows", "Height", "host", "image", "ht", "ui", "id", "html", "xy", "gap", "y", "max", "gallery", "mac", "layout", "length", "inches", "driver", "huge", "bottom", "input", "gh", "media", "crop", "version", "build", "above", "fw", "data", "tight", "slice", "h", "pad", "deep", "rank", "size", "rows", "history", "definition", "times", "img", "volume", "shape", "timeout", "total", "gpu", "def", "high", "window", "d", "devices", "distance", "show", "th", "grow", "duration", "dy", "hung", "style", " heights", "thin", "w", "density", "padding", "container", "depth", "dist"], "i": ["ii", "pi", "d", "n", "I", "mi", "it", "k", "y", "m", "info", "z", "ai", "x", "h", "l", "p", "c", "f", "u", "b", "ci", "io", "si", "in"], "v": ["q", "vt", "r", "d", "n", "video", "k", "y", "g", "m", "sv", "z", "h", "l", "c", "p", "w", "e", "f", "u", "V", "o", "b", "t", "va", "volume"], "j": ["js", "adj", "q", "ji", "r", "n", "J", "k", "aj", "ij", "y", "g", "pos", "m", "z", "ch", "h", "l", "x", "p", "w", "jp", "obj", "o", "b"], "aspect": ["Aspect", "exct", "aspec", "acess", "masspect", "act", "Asception", "Aspects", "asspects", "assct", "apects", "apec", "asspect", "ASpect", "raspecting", "expecting", "ASception", "maspect", "expect", " aspec", "maspects", "aspir", " asception", "ASpec", "ASpects", " ascess", "assspect", "asspecting", "asspir", "asception", "raspect", "apir", " asct", " aspir", "aspecting", "apect", "maspec", "Aspec", "rasct", "aspects", "asspec", "asscess", "exspect", "rasspect", "ascess", " aspects", "asct"]}}
{"project": "qemu", "commit_id": "4c8449832c0add27b898e657a9e7e8603f44157c", "target": 1, "func": "static void external_snapshot_commit(BlkActionState *common)\n\n{\n\n    ExternalSnapshotState *state =\n\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n\n\n\n    bdrv_set_aio_context(state->new_bs, state->aio_context);\n\n\n\n    /* This removes our old bs and adds the new bs */\n\n    bdrv_append(state->new_bs, state->old_bs);\n\n    /* We don't need (or want) to use the transactional\n\n     * bdrv_reopen_multiple() across all the entries at once, because we\n\n     * don't want to abort all of them if one of them fails the reopen */\n\n    bdrv_reopen(state->old_bs, state->old_bs->open_flags & ~BDRV_O_RDWR,\n\n                NULL);\n\n}\n", "idx": 18437, "substitutes": {"common": ["util", "session", "mod", "global", "record", "core", "conf", "name", "full", "component", "shared", "from", "cm", "command", "loader", "comm", "document", "master", "public", "node", "control", "ctx", "normal", "create", "COM", "low", "context", "Common", "generic", "summary", "new", "pkg", "stack", "comp", "recent", "com", "con", "security", "standard", "remote", "sync", "client", "central", "lib", "cache", "foreign", "resource", "server", "diff", " Common"], "state": ["set", "status", "part", "instance", "stat", "session", "spec", "j", "work", "cal", "data", "info", "name", "call", "comment", "settings", "media", "element", "all", "core", "component", "module", "or", "master", "type", "scope", "ass", "slice", "manager", "self", "tag", "date", "object", "State", "art", "parse", "are", "grade", "event", "the", "seed", "rule", "style", "use", "config", "start", "update", "parent", "post", "STATE", "patch", "address", "cache", "resource", "output", "form", "param", "ace", "list", "port", "states", "conn"]}}
{"project": "qemu", "commit_id": "2c30dd744aa02d31a8a3b87daaba0b2cb774f346", "target": 0, "func": "static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,\n\n                           struct dirent *entry,\n\n                           struct dirent **result)\n\n{\n\n    return readdir_r(fs->dir, entry, result);\n\n}\n", "idx": 18142, "substitutes": {"ctx": ["rx", "pc", "cc", "fw", "conf", "obj", "jp", "vc", "rc", "cm", "exc", "cb", "cp", "loc", "bc", "utils", "cas", "Context", "cs", "exec", "context", "conv", "pkg", "tx", "ci", "xc", "lc", "cmp", "conn"], "fs": ["ns", "fw", "bs", "s", "rs", "fp", "obj", "f", "FS", "irs", "flows", "feed", "cf", "files", "ls", "fc", "cs", "fx", "acs", "df", "cms", "tx", "qs", "fd", "raf", "fb", "vs", "ks", "cache", "sys", "es", "os", "Fs", "ds"], "entry": [" Entry", "record", "archive", "data", "ent", "element", "info", " entries", "feed", "try", "enter", "ie", "ry", "array", "event", "import", "Entry", "ident", "id", "e", "ries", "deep", "insert", "cur", "si", "inter", "cell", "row", "end", "se", "inner", "reader"], "result": ["inner", "instance", "ret", "record", "data", "Result", "err", "comment", "rc", "r", "results", "counter", "report", "master", "match", "successful", "raw", "der", "arr", "pair", "final", "array", "event", "future", "response", "resource", "card", "res", "end", "desc", "list", "valid", "dict", "success"]}}
{"project": "FFmpeg", "commit_id": "93c39db5f1544d1220488cfeb93bfe812a52f374", "target": 1, "func": "static int aiff_read_packet(AVFormatContext *s,\n                            AVPacket *pkt)\n{\n    AVStream *st = s->streams[0];\n    AIFFInputContext *aiff = s->priv_data;\n    int64_t max_size;\n    int res, size;\n    /* calculate size of remaining data */\n    max_size = aiff->data_end - avio_tell(s->pb);\n    if (max_size <= 0)\n        return AVERROR_EOF;\n    /* Now for that packet */\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n    case AV_CODEC_ID_GSM:\n    case AV_CODEC_ID_QDM2:\n    case AV_CODEC_ID_QCELP:\n        size = st->codecpar->block_align;\n        break;\n    default:\n        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;\n    size = FFMIN(max_size, size);\n    res = av_get_packet(s->pb, pkt, size);\n    if (res < 0)\n        return res;\n    if (size >= st->codecpar->block_align)\n        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;\n    /* Only one stream in an AIFF file */\n    pkt->stream_index = 0;\n    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;\n    return 0;", "idx": 24732, "substitutes": {"s": ["S", "sch", "ses", "sys", "w", "ss", "p", "c", "ns", "se", "ts", "sites", "sq", "ds", "opens", "ans", "us", "ps", "sg", "ins", "self", "su", "is", "e", "es", "gs", "sets", "ions", "set", "session", "spec", "sts", "sv", "less", "si", "sym", "os", "sb", "services", "xs", "sa", "ls", "f", "service", "qs", "js", "fs", "src", "a", "t", "sl", "settings", "ops", "ssl", "cs", "g"], "pkt": [" pk", "pct", " packet", "tpnt", "ppnt", "apkt", "Pnt", "pcht", " peth", "tpet", "preth", "Packer", "pracker", "packet", "ppk", " pct", " packer", " pet", "prkt", "pret", "Pk", " ppt", " pnt", "prcht", " pcht", "Packet", "ppt", "Ppt", "apacket", "tpacket", "ppkt", "tpkt", "pk", "ppacket", "pet", "peth", "packer", "pnt", "pracket", "apct", "appt", "Pcht", "Peth", "Pkt", "Pct", "Pet"], "st": ["rest", "std", "sc", "sk", "fe", "ST", "ft", "ss", "sn", "pt", "se", "sw", "sed", "ld", "ste", "ds", "stand", "ct", "bl", "ast", "ust", "inst", "St", "fr", "sth", "sp", "ess", "td", "sta", "str", "nd", "cl", "set", "start", "sts", "mt", "dt", "nt", "sb", "client", "est", "ist", "sa", "ost", "stage", "stop", "src", "stack", "t", "sd", "sl", "sf", "et", "sv", "ut", "kt"], "aiff": ["Aiff", "saiff", "aqa", " a8", "saIFF", " aqa", "gaqa", "aef", "Aif", "Aqa", "vaqa", "saisk", "naiff", " aif", "aisk", "gaef", " aiper", "aIFF", "naisk", " aef", "gaiper", "aif", "a8", "na8", "saif", "vaiper", "naif", "gaiff", "sa8", " aisk", "saqa", "AIFF", "vaef", " aIFF", "vaiff", "aiper"], "max_size": ["total_length", "maximum_length", "max64width", "max67size", "max64length", "max67shape", " max_align", "total67length", "total_size", "max_width", " max_age", "maximum_size", "maximumlexsize", "maxlexsize", "max_storage", "max67length", "max64shape", "maxlexwidth", "total67shape", " max_width", "total_shape", "max_sec", "total67size", "maximum_width", "maximumlexlength", "maximumlexwidth", "maxlexlength", "maximumlexstorage", "max_age", "max_shape", "maxlexstorage", "max_align", "maximum_storage", " max_sec", "max64sec", "max_length", "max64size"], "res": ["ares", "rs", "breaks", "errors", "nos", "resolution", "data", "blocks", "sum", "ms", "rez", "gr", "ps", "changes", "rows", "id", "rep", "rss", "es", "resh", "max", "min", "rh", "runs", "err", "rev", "ries", "re", "os", "ras", "result", "rate", "rc", "response", "ress", "req", "Res", "rem", "bytes", "des", "js", "rx", "details", "pres", "reg", "used", "resp", "row", "results", "content", " resolution", "ver", "ex", "r", "range", "ris", "cs", "len", "pos"], "size": ["esc", "code", "sc", "slice", "z", "page", "ize", "shift", "i", "empty", "sized", "resolution", "name", "c", "sn", "sw", "time", "data", "sum", "send", "sea", "capacity", "address", "speed", "Size", "form", "end", "id", "num", "sex", "ui", "e", "grow", "unit", "cs", "max", "SIZE", "min", "resource", "loc", "small", "fee", "si", "sec", "scale", "rc", "shape", "length", "ng", "bytes", "mini", "value", "go", "content", "sent", "core", "ace", "iz", "range", "pos", "large", "len", "eng"]}}
{"project": "qemu", "commit_id": "77af8a2b95b79699de650965d5228772743efe84", "target": 0, "func": "static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm)\n\n{\n\n    fadt->model = 1;\n\n    fadt->reserved1 = 0;\n\n    fadt->sci_int = cpu_to_le16(pm->sci_int);\n\n    fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);\n\n    fadt->acpi_enable = pm->acpi_enable_cmd;\n\n    fadt->acpi_disable = pm->acpi_disable_cmd;\n\n    /* EVT, CNT, TMR offset matches hw/acpi/core.c */\n\n    fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);\n\n    fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);\n\n    fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);\n\n    fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);\n\n    /* EVT, CNT, TMR length matches hw/acpi/core.c */\n\n    fadt->pm1_evt_len = 4;\n\n    fadt->pm1_cnt_len = 2;\n\n    fadt->pm_tmr_len = 4;\n\n    fadt->gpe0_blk_len = pm->gpe0_blk_len;\n\n    fadt->plvl2_lat = cpu_to_le16(0xfff); /* C2 state not supported */\n\n    fadt->plvl3_lat = cpu_to_le16(0xfff); /* C3 state not supported */\n\n    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |\n\n                              (1 << ACPI_FADT_F_PROC_C1) |\n\n                              (1 << ACPI_FADT_F_SLP_BUTTON) |\n\n                              (1 << ACPI_FADT_F_RTC_S4));\n\n    fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);\n\n    /* APIC destination mode (\"Flat Logical\") has an upper limit of 8 CPUs\n\n     * For more than 8 CPUs, \"Clustered Logical\" mode has to be used\n\n     */\n\n    if (max_cpus > 8) {\n\n        fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);\n\n    }\n\n    fadt->century = RTC_CENTURY;\n\n}\n", "idx": 12026, "substitutes": {"fadt": ["fpadt", "feddtie", "lfadht", "fradto", "feadty", "fastadto", "fpadto", "fullafter", "yadtg", "Faddto", "fedtor", "afaudt", "lfadhto", "fazit", "fidto", "fulladt", "fastpadto", "fidz", "fpadtf", " faddn", "fatty", "fidtor", "fadc", "fodtor", "fadhtg", "fidtu", "fadsx", " fagit", " faddd", "fadit", "fagto", " fadto", "fridt", "fadd", "fpeadter", "fulladter", "faudtt", "faudc", "feddtree", "faddd", "feadtu", "fidth", "lfadhtu", "fpeadx", "fadtg", "feddz", "fadte", "yadt", "faddto", "fullaftt", "fdtr", " fayte", "fudwt", " fdwt", "confidth", "fadst", "fodte", " fadf", "feaidht", "Faddte", "fpadtu", "yadht", "fpadht", "feddty", " faytu", "fadta", " fadtr", "fadytie", "feddte", "failts", "fadet", "Fadt", "fastpadty", "fastadty", "feadout", "fatout", "fagtie", "feadn", "fodt", "zadt", "feadwt", "faddte", "feadtie", "fodwt", "faytu", "fastadts", "fadout", "lfadto", "fullaft", "feadtr", "Faddt", "feddter", "feddt", " fagto", "fddtu", "fadate", "fADte", "fadetf", "fastpadter", "fastadter", "faddtu", "fidf", "fadwt", "confadf", " fachto", "fadato", " fadte", "fpadter", " fadet", "fradc", "zpadt", "fagf", " fagte", "fagit", "fddt", " fadd", " fagf", "faddtor", "fagtree", "confidf", "Fadto", "fadth", "fastpadt", "fpadz", "fadht", "fADht", "fastpadz", "fachit", "faddtr", "fastadz", "fudto", "fdtor", "faidto", "fadytt", "fpadty", "zadc", "fridta", "fadty", "faddtm", "fadz", "afadt", "zadht", "fastadout", "fpidt", "fADt", "confidt", "fidtt", "faftt", " fagtie", "fadec", "faft", "fadhts", "yadty", "yadhout", "confadtf", "fagte", "fulladtt", " fagt", "faddn", "feadd", " fachit", "fridit", "fidty", " fadtree", "afaudto", " fadn", "confidtf", "zpadht", "fidit", "fadeth", "facht", "fpadwt", "fayte", "feddf", "fpadx", "faidwt", "yadhty", "fpidto", "fadyit", "feadet", "fADter", "yadhtg", " fdtor", "lfadhz", "fadhto", "fadtor", "fdtie", "faytm", "feaidtu", "fattg", "faidt", " fagtree", "faidd", "fidwt", "feadt", "faddwt", "fadef", " fdtr", "Faddwt", "feadto", "fadtt", "fadyf", "fatz", "fadeto", " faytm", "fpeadto", "fadhty", "faidter", "fADc", "fpadit", "fpadth", "afaudc", "fastpadts", "faddt", "fpadout", "fADtm", "fidtf", "faidn", "faddet", "feadtg", "Fadte", "fadtree", "fpadts", "fadyter", "Fadwt", "faidtu", "fADtu", "fpadta", "feadht", "fpadf", "fedwt", "fadatree", "fadf", " fadtor", "feddit", "failto", " fadtie", "fpadtr", "confadt", "fedth", "fatt", "zadter", "faudt", " fdt", "fadts", "fdwt", "fadto", " fdth", " facht", "fudte", "fadhtu", "fadsto", "lfadtu", "fidter", "fdth", "faudto", "zpadc", "fadter", "afadto", "fulladty", "faidx", " fadtu", "fadster", "fadx", "fadhz", "fafter", "fazto", "fachto", "fpidwt", "fradt", "fadtr", "zpadter", "fadhout", "fagt", "fradtt", "fpadtor", "feaidt", "fpeadt", "feadter", "fodto", "fachtr", " fachtr", " fayt", "fadtu", "fradit", "fadett", "fadn", "feadx", "feadc", "fadyt", "failt", "fddht", "fpadc", "failout", " faddet", " fadit", " fadtm", "fidt", "fpidtor", " fadwt", "fazt", " fadth", "afaudtt", "fadtie", "confadth", "feddto", "fastadt", "fatter", "fadtf", "fafty", "yadout", "fadtm", "faddtie", " fdtie", "feaidwt", "fridto", " faddt", "fastpadout", "fidta", "afadtt", "fullafty", "faztr", "fdt", "fayt", "fedt", "afadc", "fudt", "fadyty", "fadat", "faidht", "fddwt", "faidet", "fradta", "lfadt", "lfadz"], "pm": ["imm", "km", "ym", "sem", "member", "dim", "param", "em", "om", "PM", "m", "model", "mr", "bm", "prem", "dem", "mm", "gm", "mon", "pa", "vim", "service", "vm", "hm", "pb", "pd", "wm", "po", "gp", "nm", "fm", "mp", "module", "mi", "md", "gem", "nom", "im", "sm", "mod", "am", "rpm", "pi", "iam", "pc", "asm", "mo", "tm", "plugin", "dm", "cm", "px", "ram", "um", "rm"]}}
{"project": "qemu", "commit_id": "45bbbb466cf4a6280076ea5a51f67ef5bedee345", "target": 1, "func": "uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)\n\n{\n\n    *q_ptr = num / den;\n\n    return num % den;\n\n}\n", "idx": 3162, "substitutes": {"q_ptr": ["q_pt", "p_pointer", " q_pointer", " q_Ptr", "q_Ptr", "q_pointer", " q_ctr", "q_ctr", "p_req", "q_req", "p_pt", "p_ptr"], "num": ["unit", "mn", "np", "null", "no", "version", "dim", "nn", "norm", "d", "n", "uni", "nc", "bin", "un", "con", "nu", "ne", "initial", "Num", "m", "nr", "number", "index", "om", "inc", "zero", "nb", "len", "du", "size", "rem", "mon", "u", "mom", "node", "sum", "um", "nm", "prefix", "su", "NUM", "nom", "gen", "count", "mu", "net", "one", "nam", "done"], "den": ["zen", "flow", "mn", "hen", "dn", "da", "lan", "fen", "dan", "dim", "nn", "norm", "flo", "di", "fl", "der", "bin", "con", "de", "ne", "side", "des", "Den", "none", "ven", "DEN", "iden", "dev", "fin", "design", "len", "dm", "ide", "rem", "mon", "core", "mask", "min", "range", "en", "su", "gen", "wall", "nd", "pri", "day"]}}
{"project": "qemu", "commit_id": "1466cef32dd5e7ef3c6477e96d85d92302ad02e3", "target": 0, "func": "static int mch_init(PCIDevice *d)\n\n{\n\n    int i;\n\n    MCHPCIState *mch = MCH_PCI_DEVICE(d);\n\n\n\n    /* setup pci memory regions */\n\n    memory_region_init_alias(&mch->pci_hole, OBJECT(mch), \"pci-hole\",\n\n                             mch->pci_address_space,\n\n                             mch->below_4g_mem_size,\n\n                             0x100000000ULL - mch->below_4g_mem_size);\n\n    memory_region_add_subregion(mch->system_memory, mch->below_4g_mem_size,\n\n                                &mch->pci_hole);\n\n\n\n    pc_init_pci64_hole(&mch->pci_info, 0x100000000ULL + mch->above_4g_mem_size,\n\n                       mch->pci_hole64_size);\n\n    memory_region_init_alias(&mch->pci_hole_64bit, OBJECT(mch), \"pci-hole64\",\n\n                             mch->pci_address_space,\n\n                             mch->pci_info.w64.begin,\n\n                             mch->pci_hole64_size);\n\n    if (mch->pci_hole64_size) {\n\n        memory_region_add_subregion(mch->system_memory,\n\n                                    mch->pci_info.w64.begin,\n\n                                    &mch->pci_hole_64bit);\n\n    }\n\n    /* smram */\n\n    cpu_smm_register(&mch_set_smm, mch);\n\n    memory_region_init_alias(&mch->smram_region, OBJECT(mch), \"smram-region\",\n\n                             mch->pci_address_space, 0xa0000, 0x20000);\n\n    memory_region_add_subregion_overlap(mch->system_memory, 0xa0000,\n\n                                        &mch->smram_region, 1);\n\n    memory_region_set_enabled(&mch->smram_region, false);\n\n    init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n             &mch->pam_regions[0], PAM_BIOS_BASE, PAM_BIOS_SIZE);\n\n    for (i = 0; i < 12; ++i) {\n\n        init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,\n\n                 &mch->pam_regions[i+1], PAM_EXPAN_BASE + i * PAM_EXPAN_SIZE,\n\n                 PAM_EXPAN_SIZE);\n\n    }\n\n    return 0;\n\n}\n", "idx": 20738, "substitutes": {"d": ["dos", "cd", "e", "dose", "ind", "ded", "db", "connection", "dad", "dh", "ds", "ld", "f", "dj", "t", "m", "da", "dd", "ad", "p", "did", "dy", "dr", "c", "dx", "sd", "dt", "du", "b", "dc", "dim", "dm", "dl", "fd", "bd", "D", "dat", "l"], "i": ["io", "span", "e", "ix", "qi", "ui", "mini", "pi", "gi", "ti", "I", "f", "t", "phi", "r", "u", "j", "ip", "abi", "p", "id", "o", "bi", "inner", "cli", "c", "index", "si", "a", "ii", "b", "ji", "n", "iu", "child", "slice", "xi", "hi", "multi", "v", "z", "li", "l", "x", "zi", "k", "ni", "count"], "mch": ["Mich", "hcha", "omich", "mgh", "omcha", " mth", "dmch", "wmch", "smcht", "Mth", "umach", "rmich", "mrcher", "pcha", "gmcher", "umich", "bmarch", "smtch", "mcht", "imich", "gmach", "gmcht", "cmzh", "omuth", "gmich", "mrich", "umch", "hche", "mach", "rmcht", "amcha", "Mchid", "mce", "mmich", "dmcher", "amcht", "mcher", "cmich", "ymche", "Mcher", "pmcha", " muth", "umcher", "mcch", "Mche", "pzh", " mcha", "wmcha", "hch", "ymich", "imach", "mrch", "pach", "manach", "ymth", "imcha", "umche", "nmche", "Muth", " mzh", " mtch", "imch", "mchid", "rmcher", "gmtch", "Mach", "hich", "Mce", "manch", "bmch", " mach", "cmche", "mccht", "mzh", "mtch", "Mcha", "mth", "pchid", "rmch", "gmch", "dmich", "mcach", "march", " mcht", "gmche", "Mgh", "amich", "mmcha", "gmzh", "Mch", "pche", "amche", "dmcha", " mich", "mmche", "March", "mccha", "cmcher", "omch", "wmich", "pcher", "pmach", "cmch", "fmach", " mce", "pmich", "mich", "manche", "cmcha", "cmgh", "pchan", "fmchan", "mancha", "omoch", "manich", "cmcht", "pich", "nmch", "mancher", "pmch", "mche", "bmcher", "nmach", "cmoch", "Moch", "omcher", "fmich", "cmth", "amch", " mgh", "moch", "pmche", "nmich", "mmch", "rmcha", "Mchan", "imcht", "umcha", "mrcha", "pmcht", "wmche", "Mzh", "bmich", "ymch", "smch", "pch", "imche", "Mcht", "fmch", "cmce", "fmchid", "mchan", " march", "rmche", "gmcha", "omche", "dmcht", "omach", " mcher", "mcha", "muth", "cmach", " mchid", " mche", "dmche", "smach", "parch"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_number(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        int64_t decoded;\n\n        int skip;\n\n    } test_cases[] = {\n\n        { \"0\", 0 },\n\n        { \"1234\", 1234 },\n\n        { \"1\", 1 },\n\n        { \"-32\", -32 },\n\n        { \"-0\", 0, .skip = 1 },\n\n        { },\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QInt *qint;\n\n\n\n        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));\n\n        g_assert(qint);\n\n        g_assert(qint_get_int(qint) == test_cases[i].decoded);\n\n        if (test_cases[i].skip == 0) {\n\n            QString *str;\n\n\n\n            str = qobject_to_json(QOBJECT(qint));\n\n            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);\n\n            QDECREF(str);\n\n        }\n\n\n\n        QDECREF(qint);\n\n    }\n\n}\n", "idx": 6486, "substitutes": {"i": ["gi", "o", "ti", "v", "id", "I", "di", "s", "ci", "x", "ni", "xi", "b", "si", "io", "slice", "abi", "ri", "module", "bi", "m", "in", "qi", "info", "ix", "l", "f", "pi", "yi", "j", "ii", "d", "iu", "it", "ai", "init", "u", "e", "uri", "ori", "n", "multi", "mi", "ski", "ini", "ie", "p", "eni", "iv", "oi", "c", "ip", "y", "lc", "li", "inner", "fi", "index", "ui"], "encoded": ["enoding", "inccoded", "engcoded", "deccoded", "incoded", "coded", "incoding", "engoder", "Encoded", "Encoding", "enccoded", "enoded", "encoder", "coder", "enoder", "Encoder", "Enccoded", "Encored", "engoded", "engoding", "incored", "decoder", "Encode", "enode", "encored", "encoding", "decored", "coding", "encode", "decoded", "enored", "ccoded", "decoding", "decode"], "test_cases": ["example67cases", "test__codes", "test_tests", "case_tests", "testplescripts", "testenases", "testslines", "example67comments", "testalllines", "test_comments", "testscase", "testing_ases", "testalltests", "casestests", "test___errors", "testingstimes", "test__cases", "example_scripts", "test67cases", "testing_errors", "testing_cases", "test___case", "testing_tests", "test__case", "testallcases", "testingstests", "casescase", "example_comments", "testplecases", "testingslines", "test_errors", "casescases", "test67case", "test___cases", "test_scripts", "case_case", "teststimes", "test_times", "test___tests", "testing_times", "test_codes", "testing_codes", "testalltimes", "example67scripts", "testencases", "test67scripts", "test_lines", "testing_lines", "test_case", "test67comments", "example_case", "teststests", "test__ases", "example_cases", "testing_case", "example67case", "case_times", "casestimes", "testencase", "testingscases", "testplecomments", "testscases", "case_cases", "testencodes", "test_ases", "testplecase"], "qint": ["shobject", "qunt", "qqinc", "questaddress", "qext", "queryobject", "questpoint", "requINT", "qin", "qinteger", "qpoint", "qainter", "quinc", "qualint", "qashort", "qx", "qux", " qobject", "qaddress", "sqinteger", "qualpoint", " qvert", "shint", "qualaddress", "questint", "eqshort", "qvert", "xinc", "quin", "queryshort", "qinter", "qqnt", "quaddress", " qstr", "sqINT", "queryinter", "qualin", "qnt", "qqint", " qinc", "qqx", "eqint", " qinteger", "qINT", "qaint", "qaext", "qqind", " qx", "qshort", "requvert", "queryINT", "requint", "sqint", "xind", "requinteger", "queryext", "qqstr", "xstr", "questin", "qupoint", "xint", " qINT", " qort", "qobject", "eqinter", "qort", "eqext", "qinc", "qind", " qind", "queryort", "quint", " qnt", "qstr", "sqvert", "shINT", "queryint"], "str": ["dr", "name", "fr", "er", "st", "sr", "cr", "iter", "id", "pr", "cur", "spec", "s", "val", "tr", "style", "data", "enc", "obj", "sl", "strip", "cs", "code", "sc", "arr", "pass", "err", "voc", "coll", "strike", "Str", "sp", "doc", "c", "txt", "type", "hr", "br", "STR", "text", "kr", "rs", "r", "stri", "dict"]}}
{"project": "qemu", "commit_id": "0c0eb30260b424d2a68603b89f1d829db18772c2", "target": 1, "func": "static void init_virtio_dev(TestServer *s)\n\n{\n\n    QPCIBus *bus;\n\n    QVirtioPCIDevice *dev;\n\n    uint32_t features;\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    g_assert_nonnull(bus);\n\n\n\n    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);\n\n    g_assert_nonnull(dev);\n\n\n\n    qvirtio_pci_device_enable(dev);\n\n    qvirtio_reset(&dev->vdev);\n\n    qvirtio_set_acknowledge(&dev->vdev);\n\n    qvirtio_set_driver(&dev->vdev);\n\n\n\n    features = qvirtio_get_features(&dev->vdev);\n\n    features = features & VIRTIO_NET_F_MAC;\n\n    qvirtio_set_features(&dev->vdev, features);\n\n\n\n    qvirtio_set_driver_ok(&dev->vdev);\n\n}\n", "idx": 4141, "substitutes": {"s": ["sf", "S", "http", "spec", "browser", "b", "sys", "ses", "services", "f", "service", "us", "cs", "ss", "sc", "sb", "w", "se", "sd", "ts", "fs", "c", "ssl", "sq", "src", "rs", "r"], "bus": ["plugin", "base", "pack", "build", "ch", "feed", "block", "hub", "id", "http", "BUS", "device", "config", "plug", "bug", "sync", "cat", "Bus", "buf", "db", "usb", "book", "bs", "us", "conf", "ck", "mount", "driver", "lib", "path", "pass", "bc", "self", "bridge", "serial", "root", "boot", "gen", "os", "back", "board", "ash", "front", "cache", "test", "host"], "dev": ["ch", "serv", "od", "v", "id", "block", "rad", "nov", "pro", "di", "Dev", "spec", "device", "dd", "adv", "dn", "plug", "bug", "data", "ow", "ad", "info", "der", "debug", "valid", "gu", "de", "d", "ve", "mod", "av", "obj", "dist", "conf", "ev", "def", "DEV", "dom", "priv", "kind", "error", "w", "cam", "die", "driver", "dc", "sd", "ready", "err", "self", "pub", "serial", "root", "req", "h", "development", "ver", "var", "off", "user", "test", "app", "prov", "conn", "diff", "end", "feature"], "features": ["types", "options", "models", "properties", "feed", "ins", "rules", "fee", "fts", "spec", "works", "plugins", "nets", "config", "atts", "words", "ributes", "data", "format", "debug", "ips", "details", "mac", "results", "f", "stats", "args", "ports", "dist", "fields", "classes", "faces", "driver", "steps", "fn", "tests", "reports", "feat", " feat", "devices", "Features", " Features", "bugs", "settings", "products", "fs", "items", "fd", "product", "params", "fc", "fi", " feature", "conn", "dim", "flags", "feature", "prefix"]}}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "static bool do_modify_softint(CPUSPARCState *env, uint32_t value)\n\n{\n\n    if (env->softint != value) {\n\n        env->softint = value;\n\n#if !defined(CONFIG_USER_ONLY)\n\n        if (cpu_interrupts_enabled(env)) {\n\n\n            cpu_check_irqs(env);\n\n\n        }\n\n#endif\n\n        return true;\n\n    }\n\n    return false;\n\n}", "idx": 5174, "substitutes": {"env": ["enable", "ah", "fg", "eng", "er", "nw", "ea", "cur", "dat", "scope", "config", "esp", "environment", "exc", "style", "enc", "eu", "buf", "db", "cal", "export", "ext", "server", "obj", "args", "py", "init", "forest", "conf", "ev", "np", "code", "e", "img", "ass", "en", "here", "esc", "estate", "err", "context", "ec", "stage", "settings", "opt", "req", "viron", "txt", "core", "cv", "site", "cache", "age", "forge", "conn", "end", "dict"], "value": ["address", "option", "name", "paid", "v", "complete", "values", "config", "update", "val", "data", "format", "image", "status", "null", "window", "num", "valid", "key", "version", "enabled", "number", "code", "property", "target", "message", "port", "timeout", "result", "Value", "scale", "start", "VALUE", "none", "attribute", "new", "type", "current", "index", "age", "set", "max", "expression", "end", "size"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_error(QEMUFile *f, int ret)\n\n{\n\n    if (f->last_error == 0) {\n\n        f->last_error = ret;\n\n    }\n\n}\n", "idx": 22431, "substitutes": {"f": ["fc", "i", "e", "ref", "fs", "g", "this", "framework", "file", "fb", "rf", "fp", "df", "t", "m", "tif", "new", "p", "fx", "inf", "cf", "o", "af", "c", "self", "fr", "tf", "w", "ff", "fd", "F", "fw", "sf", "fen", "v", "bf", "lf", "l", "fo", "elf"], "ret": ["reg", "red", "en", "xt", "ref", "result", "val", "arg", "det", "rep", "Ret", "mt", "al", "res", "cat", "rets", "arr", "id", "ext", "RET", "rt", " Ret", "mem", "reply", "re", "pat", "pret", "back", "alt", "ry", "nt", "lit", "att", "resp", "fun"]}}
{"project": "FFmpeg", "commit_id": "e70fcf075b8f92c4e410b80c703fbdc1d531d42d", "target": 1, "func": "AVStream *add_audio_stream(AVFormatContext *oc, int codec_id)\n\n{\n\n    AVCodec *codec;\n\n    AVCodecContext *c;\n\n    AVStream *st;\n\n\n\n    st = av_new_stream(oc, 1);\n\n    if (!st) {\n\n        fprintf(stderr, \"Could not alloc stream\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* find the MP2 encoder */\n\n    codec = avcodec_find_encoder(codec_id);\n\n    if (!codec) {\n\n        fprintf(stderr, \"codec not found\\n\");\n\n        exit(1);\n\n    }\n\n    c = &st->codec;\n\n    c->codec_type = CODEC_TYPE_AUDIO;\n\n\n\n    /* put sample parameters */\n\n    c->bit_rate = 64000;\n\n    c->sample_rate = 44100;\n\n    c->channels = 2;\n\n\n\n    /* open it */\n\n    if (avcodec_open(c, codec) < 0) {\n\n        fprintf(stderr, \"could not open codec\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* init signal generator */\n\n    t = 0;\n\n    tincr = 2 * M_PI * 440.0 / c->sample_rate;\n\n\n\n    audio_outbuf_size = 10000;\n\n    audio_outbuf = malloc(audio_outbuf_size);\n\n\n\n    /* ugly hack for PCM codecs (will be removed ASAP with new PCM\n\n       support to compute the input frame size in samples */\n\n    if (c->frame_size <= 1) {\n\n        audio_input_frame_size = audio_outbuf_size / c->channels;\n\n        switch(st->codec.codec_id) {\n\n        case CODEC_ID_PCM_S16LE:\n\n        case CODEC_ID_PCM_S16BE:\n\n        case CODEC_ID_PCM_U16LE:\n\n        case CODEC_ID_PCM_U16BE:\n\n            audio_input_frame_size >>= 1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    } else {\n\n        audio_input_frame_size = c->frame_size;\n\n    }\n\n    samples = malloc(audio_input_frame_size * 2 * c->channels);\n\n\n\n    return st;\n\n}\n", "idx": 18700, "substitutes": {"oc": ["dc", "pc", "org", "cot", "ocol", "irc", "rc", "cf", "coll", "anc", "toc", "loc", "bc", "ocr", "mot", "ctx", "mic", "fc", "o", "auc", "roc", "rec", "acs", "usc", "ac", "oci", "soc", "ucc", "uc", "circ", "ogg", "osc", "ec", "OC", "isc", "cc", "voc"], "codec_id": ["codoc_name", "codec0ID", "codef_ID", "codec___type", "codroc_vid", "codroc_id", "codec0type", "codec_code", "codec0id", "codec_type", "codec0name", "codec_ids", "codef_ids", "codec___vid", "codec_name", "codec___id", "codef_name", "codec0code", "codoc_type", "codoc_id", "codec___name", "codroc___vid", "codroc_name", "codef_id", "codec_ID", "codroc_type", "codec_vid", "codroc___name", "codroc___type", "codroc___id", "codoc_code", "codec0ids"], "codec": [" codesc", "cedect", "Codeca", "Codoc", "CodEC", "cedef", "cilesc", "compef", "codroc", "pedesc", "labesc", "codef", "labect", "compbc", "Codac", "Codroc", "odec", " codect", "chroc", "coderoc", " codEC", "codeec", "codect", "Codesc", "chesc", "labac", "codeca", "odef", " codac", "chec", "cilac", "codEC", "odesc", "cilect", " codbc", " codef", "codesc", "labec", "cedec", " codeca", "compesc", "pedec", "codbc", "pedoc", "cilec", "cedeca", "odac", "codeesc", "compec", "odect", " codoc", "choc", "odeca", "pedEC", "codac", "odbc", "codoc", "codeoc", "Codec"], "c": ["dc", "pc", "ic", "jc", "m", "spec", "content", "s", "ch", "code", "t", "f", "call", "vc", "ct", "rc", "r", "n", "cm", "cf", "g", "i", "coll", "anc", "cb", "cod", "bc", "ctx", "fc", "mc", "abc", "self", "ctrl", "cy", "o", "ca", "enc", "cs", "exec", "l", "rec", "d", "chain", "nc", "ac", "ci", "con", "xc", "config", "tc", "e", "cu", "k", "cl", "client", "lc", "v", "p", "uc", "cache", "b", "col", "ec", "h", "cn", "co", "icc", "C", "cc", "u"], "st": ["ist", "est", "fr", "t", "stim", "rest", "obj", "ct", "sp", "ste", "td", "fe", "nt", "pe", "r", "rt", "str", "stable", "sb", "ost", "stream", "sl", "ast", "ss", "sw", "ut", "src", "ld", "sa", "ST", "sec", "stand", "sta", "art", "spect", "d", "std", "step", "stack", "stop", "back", "sn", " est", "start", "sc", "e", "sth", "cr", "cl", " St", "tmp", "stage", "ust", "test", "sts", "St", "form", "put", "inst", "ace", "se", "pt"]}}
{"project": "FFmpeg", "commit_id": "67400f6b6219892ab7a555fb61ef979c857692d7", "target": 0, "func": "static int mov_write_hdlr_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    const char *hdlr, *descr = NULL, *hdlr_type = NULL;\n\n    int64_t pos = avio_tell(pb);\n\n\n\n    if (!track) { /* no media --> data handler */\n\n        hdlr      = \"dhlr\";\n\n        hdlr_type = \"url \";\n\n        descr     = \"DataHandler\";\n\n    } else {\n\n        hdlr = (track->mode == MODE_MOV) ? \"mhlr\" : \"\\0\\0\\0\\0\";\n\n        if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            hdlr_type = \"vide\";\n\n            descr     = \"VideoHandler\";\n\n        } else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            hdlr_type = \"soun\";\n\n            descr     = \"SoundHandler\";\n\n        } else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n\n            if (track->tag == MKTAG('t','x','3','g')) hdlr_type = \"sbtl\";\n\n            else                                      hdlr_type = \"text\";\n\n            descr = \"SubtitleHandler\";\n\n        } else if (track->enc->codec_tag == MKTAG('r','t','p',' ')) {\n\n            hdlr_type = \"hint\";\n\n            descr     = \"HintHandler\";\n\n        }\n\n    }\n\n\n\n    avio_wb32(pb, 0); /* size */\n\n    ffio_wfourcc(pb, \"hdlr\");\n\n    avio_wb32(pb, 0); /* Version & flags */\n\n    avio_write(pb, hdlr, 4); /* handler */\n\n    ffio_wfourcc(pb, hdlr_type); /* handler type */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    if (!track || track->mode == MODE_MOV)\n\n        avio_w8(pb, strlen(descr)); /* pascal string */\n\n    avio_write(pb, descr, strlen(descr)); /* handler description */\n\n    if (track && track->mode != MODE_MOV)\n\n        avio_w8(pb, 0); /* c string */\n\n    return update_size(pb, pos);\n\n}\n", "idx": 22662, "substitutes": {"pb": ["td", "bc", "platform", "sb", "uf", "hp", "bos", "lb", "fc", "prop", "jp", "lp", "amp", "bj", "prot", "pkg", "db", "fb", "pm", "pd", "bp", "pc", "fp", "pg", "gb", "eb", "lab", "cp", "PB", "tp", "aph", "pp", "p", "tc", "wb", "bps", "py", "ctx", "cb", "pl", "pro", "wp", "mp", "b", "cpp", "tmp", "hub", "bm", "bf", "proc", "bh", "bs", "vp", "rb", "xb", "api", "pt", "dp", "ppa", "bsp", "pa", "pub"], "track": ["step", "row", "event", "road", "progress", "post", "sound", "trial", "rack", "tp", "seek", "test", "task", "gap", "type", "route", "cost", "coll", "ack", "bb", "tt", "tick", "trans", "strip", "audio", "wp", "add", "tracking", "transform", "mode", "metadata", "token", "Track", "layer", "t", "roll", "round", "gro", "play", "tc", "comment", "check", "form", "call", "trace", "stage", "tm", "note", "jump", "port", "hop", "project", "song", "tr", "rr", "cur", "follow", "ACK", "tab", "gg", "sync", "dr", "tag", "match", "run", "session", "ogg", "skip", "report", "tracks", "ck", "sort", "record"], "hdlr": ["vdlr", "hdrl", "pdrf", "hidler", "mdll", "hdlc", "hdrel", "hidll", "vdrel", "hidrepl", "wdler", "adhll", "mdlr", "hdsr", "wdrl", "vdrn", "mdlc", "mdrl", "wdsr", "pdrl", "hidlc", "adhlr", "adhlc", "hidrel", "vdsr", "adhrl", "hidsr", "vdler", "hidrf", "hdll", "hdrn", "wdlr", "adhrepl", "pdrn", "adhrel", "hidlr", "hidrl", "hdrf", "hidrn", "hdler", "vdrf", "pdlr", "hdrepl", "vdrepl", "vdrl"], "descr": ["accrr", "structr", " descrs", "Descar", " descrin", "testrs", "structrs", "structrin", "prirr", "defl", "discar", "descR", "descriptionrin", "descres", "ascrin", "accerr", "declr", "testar", "accrs", " descR", "defrs", "Descl", "decll", "pririn", "declry", "escr", "neglr", "descrs", "defR", "defr", "structerr", "desterr", "descry", "declrin", "testR", "prierr", "escerr", "descrin", "descrr", "descriptionres", "accr", "declrs", "esclr", " desclr", "escres", "destr", "depr", "DescR", "discR", "descar", "escrin", "escrr", "discr", "declR", "negr", "negrs", " descrr", "Descrs", "descriptionrs", "escrs", "escR", "descrt", "ascr", "descriptionl", "deprs", "ascl", "deperr", "descerr", "deprr", "destrr", " descerr", "declres", " descrt", "prir", "Descr", " descl", "descriptionR", "destrin", "descriptionr", "ascry", "escrt", "descl", "descriptionry", "negrt", "testr", "desclr", "discrs"], "hdlr_type": ["hdrl_key", "hdlr_types", "hdLR_types", "hdrl_time", "hdlr__id", "hdlr_name", "hdlr__type", "hdril_ty", "hdrl_type", "hdlr_val", "hdlr_id", "hdlr_time", "hdrl_types", "hdLR_block", "hdlrJkey", "hdlrJtime", "hdlr_rel", "hdLR_type", "hdlr_Type", "hdlr__name", "hdrl_TYPE", "hdlrJtype", "hdlr_TYPE", "hdlr_ref", "hdlr__block", "hdlr_key", "hdril_type", "hdrl_Type", "hdrl_ty", "hdler_name", "hdlrJname", "hdriter_TYPE", "hdriter_val", "hdril_ref", "hdler_type", "hdriter_type", "hdrl_var", "hdlr_ty", "hdler_id", "hdlr_style", "hdlr__types", "hdlr_var", "hdrl_name", "hdlr__Type", "hdLR_Type", "hdrl_style", "hdlr_info", "hdler_types", "hdlr_block", "hdril_types", "hdriter_info", "hdrl_rel"]}}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,\n\n                int x, int y, int w, int h)\n\n{\n\n    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];\n\n    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;\n\n    rect->x = x;\n\n    rect->y = y;\n\n    rect->w = w;\n\n    rect->h = h;\n\n}\n", "idx": 26776, "substitutes": {"s": ["S", "rs", "ses", "sys", "ss", "p", "m", "b", "c", "i", "ns", "d", "sq", "ds", "conf", "sg", "state", "states", "sync", "self", "u", "private", "e", "south", "o", "sets", "input", "session", "spec", "si", "sym", "submit", "new", "sb", "services", "series", "f", "sim", "service", "n", "fs", "src", "t", "a", "v", "init", "r", "sf", "in", "settings", "ssl", "sv", "side"], "x": ["height", "move", "z", "i", "p", "m", "c", "b", "name", "position", "d", "image", "ix", "px", "data", "base", "on", "pointer", "X", "id", "u", "e", "o", "path", "xi", "size", "shape", "win", "f", "rx", "index", "t", "a", "v", "ex", "pos", "l"], "y": ["height", "z", "yi", "i", "p", "b", "sy", "c", "dy", "oy", "ya", "ay", "d", "yt", "ery", "ye", "cy", "lon", "vy", "u", "yo", "ys", "ey", "ady", "o", "Y", "zy", "bar", "ry", "f", "n", "j", "ny", "a", "t", "ip", "ty", "l", "hi", "yy"], "w": ["height", "ow", "k", "z", "p", "b", "c", "m", "wb", "d", "sw", "weight", "wh", "rw", "u", "wx", "o", "work", "max", "fw", "wd", "ew", "size", "length", "win", "wid", "aw", "wt", "n", "W", "wa", "a", "t", "q", "v", "we", "l", "sh"], "h": ["height", "hm", "ht", "k", "th", "z", "i", "p", "b", "m", "c", "dy", "d", "en", "H", "hh", "ch", "u", "depth", "e", "o", "dh", "size", "length", "gh", "f", "n", "j", "t", "wa", "q", "v", "l", "hi", "ph", "oh", "sh"], "rect": ["complete", "txt", "font", "butt", "slice", "driver", "pt", "director", "transform", "scroll", "dash", "dr", "text", "config", "ct", "att", "select", "cross", "surface", "port", "tr", "cont", "tv", "cover", "point", "patch", "project", "RECT", "lat", "input", "path", "grad", "tri", "spec", "object", "arrow", "ror", "client", "dra", "rc", "crop", "shape", "touch", "feat", "device", "json", "round", "dot", "quant", "upload", "pair", "row", "coll", "draw", "Rect"], "redraw_fifo_last": ["redraw_fifos_str", "redraw_fifo__last", "redraw_fifo_full", "redraw_fifos_first", "redraw_fifo_first", "redraw_fifos_max", "redraw_fifos_last", "redraw_fifos_full", "redraw_fifo_str", "redraw_fifo__max", "redraw_fifo_max", "redraw_fifo__first"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    E1000State *s = opaque;\n\n    unsigned int index = (addr & 0x1ffff) >> 2;\n\n\n\n    if (index < NREADOPS && macreg_readops[index])\n\n    {\n\n        return macreg_readops[index](s, index);\n\n    }\n\n    DBGOUT(UNKNOWN, \"MMIO unknown read addr=0x%08x\\n\", index<<2);\n\n    return 0;\n\n}\n", "idx": 15655, "substitutes": {"s": ["secondary", "south", "ses", "m", "service", "array", "sync", "fs", "i", "sym", "a", "S", "settings", "h", "status", "si", "scope", "sq", "session", "server", "v", "ss", "o", "p", "e", "socket", "sf", "sb", "n", "f", "state", "spec", "c", "is", "ssl", "states", "ops", "ds", "ips", "copy"]}}
{"project": "qemu", "commit_id": "e6afc87f804abee7d0479be5e8e31c56d885fafb", "target": 1, "func": "static float64 roundAndPackFloat64( flag zSign, int16 zExp, uint64_t zSig STATUS_PARAM)\n\n{\n\n    int8 roundingMode;\n\n    flag roundNearestEven;\n\n    int16 roundIncrement, roundBits;\n\n    flag isTiny;\n\n\n\n    roundingMode = STATUS(float_rounding_mode);\n\n    roundNearestEven = ( roundingMode == float_round_nearest_even );\n\n    roundIncrement = 0x200;\n\n    if ( ! roundNearestEven ) {\n\n        if ( roundingMode == float_round_to_zero ) {\n\n            roundIncrement = 0;\n\n        }\n\n        else {\n\n            roundIncrement = 0x3FF;\n\n            if ( zSign ) {\n\n                if ( roundingMode == float_round_up ) roundIncrement = 0;\n\n            }\n\n            else {\n\n                if ( roundingMode == float_round_down ) roundIncrement = 0;\n\n            }\n\n        }\n\n    }\n\n    roundBits = zSig & 0x3FF;\n\n    if ( 0x7FD <= (uint16_t) zExp ) {\n\n        if (    ( 0x7FD < zExp )\n\n             || (    ( zExp == 0x7FD )\n\n                  && ( (int64_t) ( zSig + roundIncrement ) < 0 ) )\n\n           ) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat64( zSign, 0x7FF, - ( roundIncrement == 0 ));\n\n        }\n\n        if ( zExp < 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloat64( zSign, 0, 0 );\n\n            isTiny =\n\n                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )\n\n                || ( zExp < -1 )\n\n                || ( zSig + roundIncrement < LIT64( 0x8000000000000000 ) );\n\n            shift64RightJamming( zSig, - zExp, &zSig );\n\n            zExp = 0;\n\n            roundBits = zSig & 0x3FF;\n\n            if ( isTiny && roundBits ) float_raise( float_flag_underflow STATUS_VAR);\n\n        }\n\n    }\n\n    if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    zSig = ( zSig + roundIncrement )>>10;\n\n    zSig &= ~ ( ( ( roundBits ^ 0x200 ) == 0 ) & roundNearestEven );\n\n    if ( zSig == 0 ) zExp = 0;\n\n    return packFloat64( zSign, zExp, zSig );\n\n\n\n}\n", "idx": 18493, "substitutes": {"zSign": ["zenStep", "zenSign", "zBig", "ZDig", "xSpec", "tzExp", "zoExp", "xSign", "tzSize", "xSk", "zenBig", "xSc", "zoneReg", "zoRound", "jBig", "zenReg", "zSc", "xReg", " zStep", "zoneSc", "zoneSk", "jSc", "zReg", "zenSc", "zStep", "zRound", " zDig", "zSpec", "zSize", "zenSize", "zoneSign", "zoSign", "zoDig", " zSize", "ZRound", "zenSk", "zDig", " zRound", "zSk", "jSpec", "jSign", "tzSign", "zenExp", "tzStep", "zenSpec", "ZSign", "xBig", "ZExp"], "zExp": ["zhEx", "zExec", "zexp", "zhEXP", " zExec", " zPos", "izStep", "ZEnd", "izDiv", "ziDiv", " zEnc", "Zexp", "zipRes", "zenEnd", "izExpl", "zLeg", "wEXP", "zEXP", "izImp", "zipSec", "zhExp", "zSc", "zeExp", " zStep", "zEx", "zeScale", "izRes", "izEx", "zenScale", "ziExp", " zSc", " zFe", "zhSec", "izPlus", "zEnc", "izEnc", "wexp", "ziEnc", "zhInc", "zhExpl", "zPlus", "zenPlus", "zeSec", "zenImp", " zEnd", "ziEx", "zhPos", " zLeg", "zhPlus", "zhSc", "zenEm", "zipExp", "zDiv", " zSec", "zPos", "zSec", " zEm", "zipInc", "izExp", "zenFe", "zhRes", "wExp", "wPos", "izInc", "zenExp", "zEnd", "zhexp", "zEm", "zhStep", "ZExp", "zenEx", " zScale", "izSec", "zhExec", " zDiv", "zScale", "ZEm", " zexp", "zeFe", "zenSc", " zEx", "zStep", "zenExec", "zExpl", "zenSec", "zenExpl", "zenexp", "zInc", "zImp", "zFe", "izLeg", " zEXP", "zhImp", "zhLeg", "zRes"], "STATUS_PARAM": ["STATUS_ARAME", "STATUS_PAR", "STATUS_PARAR", "STATUS_PARAME", "STATUS_VAR", "STATUS_PARAMS", "STATUS_VAME", "STATUS_PAME", "STATUS_VAM", "STATUS_VAMS", "STATUS_ARAR", "STATUS_PAM", "STATUS_ARAMS", "STATUS_ARAM", "STATUS_PAMS"], "roundingMode": ["boundlingOperation", "roundgingMethod", "boundingModule", "accountdingMode", "pooleringMODE", "callningModule", "tungingMode", "boundlingMode", "roundeningKind", "rounddingMODE", "tungingMethod", "roundeningModule", "accountingConfiguration", "pooleringMac", "boundingKind", "roundeningMode", "boundingEngine", "roundationMode", "rounddingStyle", "tuningStyle", "roundingEngine", "tuningMethod", "poolingMac", "poolingMODE", "boundingMODE", "roundationEngine", "boundeningMODE", "rounderingMac", "accountdingEngine", "poolingMode", "callningMode", "roundgingModule", "roundpingMethod", "roundeningStyle", "roundningOperation", "tuningMODE", "roundpingStyle", "accountingEngine", "roundeningEngine", "roundingMac", "pooleringMode", "roundlingOperation", "roundlingKind", "callingModule", "roundingModule", "accountdingConfiguration", "tungingMODE", "rounddingMode", "roundtingMac", "boundingMode", "roundgingMODE", "roundlingMode", "roundlingModule", "boundlingModule", "roundpingMODE", "roundningMode", "boundingOperation", "roundingMODE", "tuningMode", "roundingOperation", "roundgingStyle", "rounddingMethod", "rounderingMode", "roundpingMode", "callingMODE", "roundgingMac", "roundeningMODE", "roundningMODE", "roundingMethod", "roundningEngine", "roundtingMode", "roundingKind", "roundningKind", "roundingConfiguration", "roundingStyle", "roundationConfiguration", "roundtingMODE", "rounddingEngine", "callningMODE", "roundgingConfiguration", "roundningStyle", "boundingStyle", "boundlingKind", "rounderingMODE", "roundgingEngine", "boundeningStyle", "roundningModule", "rounddingConfiguration", "roundeningOperation", "roundgingMode", "boundeningMode", "callingMode", "tungingStyle", "boundeningEngine", "accountingMode"], "roundNearestEven": ["roundNelderEven", "roundNearesteven", "roundnearestOne", "roundNutraleven", "roundNearerEven", "roundNeestEven", "roundNehestEven", "roundNearestHalf", "roundneestHalf", "roundNeuristicEven", "roundNeestOne", "roundNeutralEven", "roundnearestHalf", "roundNearestEnd", "roundNaresteven", "roundNutralEven", "roundNeuristicEnd", "roundNeldereven", "roundNeutraleven", "roundNearereven", "roundneestOne", "roundNehestOne", "roundNarestEven", "roundneestEven", "roundNeutralOne", "roundNelderEnd", "roundNearestOne", "roundNeestHalf", "roundNeutralHalf", "roundNehestHalf", "roundNeuristiceven", "roundNehesteven", "roundnearestEven", "roundNeesteven", "roundnearesteven", "roundneesteven", "roundNeutralEnd"], "roundIncrement": ["roundInterment", "roughIncrelex", "rollDecreMENT", "rollIncreution", "rowSegmentation", "roundIncreasemental", "roundDecreral", "roughIncrements", " roundIncrementation", "rowIncrementation", "rowIncreration", "roundIncreral", "roundIncreasemented", "roundincrese", "Roundincremented", "roundFragmentation", "roundSegments", "roundAugse", "roundAdjustment", "roundAdjustral", "roundIncreration", "roundDecrement", " roundIncreasement", "roundIncreaseMENT", "rollDecreution", "rolln", "roundIncrementation", " roundn", " roundIncregment", "roundincremented", "roundincrementation", "roundDecregment", "rollDecremented", "roundIntermentation", "rowIncrements", "roundincrements", "roughIncreral", "rollIncrementation", "rollIncremented", "Roundincrements", "rollIncrement", "roundIncremental", "rollDecrese", " roundIncreasementation", "roundAugution", "roundDecremented", "Roundincrement", "RoundIncreMENT", "roundFragmented", "roughMeasurements", "roundincrereement", "roughMeasureral", "rowSegreement", "rollIncrese", "roundincreMENT", " roundIncremented", "roughMeasurement", "roundAdjustments", "rowIncrement", "roundIncreasese", "roundDecrese", "roundInterration", "RoundincreMENT", "rowInterration", "roundDecrelex", "roundInterution", " round\n", "rollIncreMENT", "roundIncreasement", "roundFragmental", "rowSegment", "roundIncreant", "rowIntermentation", "roundIncremented", "roundSegmental", "RoundIncremented", "roundincreant", "roundDecrementation", "roundAugmentation", " roundIncreasegment", "roundIncreasementation", "roundIncrements", "roundFragment", "roundincrement", "roundIncreution", "roundIncregment", "roundDecreMENT", "rowInterant", " roundIncremental", "roundMeasurelex", "roughIncrement", "roundIncreasegment", "roundAdjustlex", " roundIncreasemented", "rowIncrereement", "roundAugment", "roundDecrereement", "round\n", "roll\n", "roundSegmentation", "roundIncrereement", "roundincreration", "rollDecrement", "roundMeasurements", " roundIncreasese", "roundSegMENT", "roundAugMENT", "rowInterment", "roundn", "roundSegreement", "roundMeasurement", "row\n", "RoundIncrement", "rowSegments", "roundInterant", "roundAugmented", "roundAuggment", "rown", " roundIncrese", "roundIncreaseration", "roundIncreaseution", " roundIncreasemental", "roundDecrements", "roundSegment", "roughMeasurelex", "rowIncreant", "roundDecreution", "roundMeasureral", "RoundIncrements", "roundIntermented", "rollDecrementation", "roundIncrelex", "roundIncreMENT", "roundIncreaseant", "roundSegmented", "roundIncrese", "roundFragse"], "roundBits": ["roundKites", " roundBBizes", "roundClbits", "roundBsit", "sortBBith", "roundBBbits", "roundBandits", "roundWbits", "roundKatches", "rowBITS", "sortBith", "roundPITS", "roundBsugs", "roundRits", " roundBandITS", " roundBandits", "roundBandbits", "roundFit", " roundBbits", "rowbugs", " roundBites", " roundBit", "roundFits", "roundBandit", "roundRit", "roundPuts", " roundBBits", "roundWits", "rowBit", "sortBBits", "roundKits", "roundBsits", "roundBBith", "roundFITS", "roundRounds", "roundbit", "rowbit", " roundBBites", "sortBITS", "roundPbits", "roundBatches", "roundBugs", "roundBites", "roundKizes", "roundFuts", "sortBits", "roundBBatches", " roundBanduts", "roundBandITS", "roundbITS", "roundClits", "roundBbits", "roundBit", "roundBBites", "roundBsITS", "sortBbits", " roundBBatches", "roundbugs", "roundFbits", "roundClITS", "roundSBizes", "roundPits", "roundbits", "roundSBatches", "rowBugs", "roundBBITS", "roundBBizes", "roundSBits", "roundButs", " roundBatches", "roundRITS", "roundClith", "roundBith", "rowBits", "roundFounds", " roundBounds", "roundBITS", "sortBBbits", " roundBandbits", "roundSBites", "roundWITS", "rowbITS", " roundBITS", "roundWith", "rowbits", " roundBizes", "roundBandugs", "roundBizes", "roundBounds", "roundBBits", " roundButs", "sortBBITS", "roundBanduts"], "isTiny": ["IsNotiny", "isPig", "isTunky", "isWiny", "IsTidy", "isTwick", "isNiny", "isPng", "isTwig", " isTunky", "isTick", " isPiny", "isTidy", "isPiger", "isTiger", "isTng", "isDidy", " isTick", " isTig", "isPunky", "isWunky", " isTng", "isNig", "isDiger", " isPig", "isTwiny", "isTwunky", "isPiny", "isDick", "isNotiny", "isTig", " isPick", "isDiny", "IsTiny", "isPick", "isPidy", "IsTiger", "isNotiger", "isNng", "isNick", "isWick", "IsNotiger", "IsNotick", "IsNotidy", "isNotick", "isNotidy", " isPunky", "isWig", "IsTick"]}}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtol(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 14774, "substitutes": {"str": ["Str", "vec", "rr", "stri", "frac", "hr", "enc", "tr", "in", "id", "rs", "orig", "ctr", "kr", "lc", "er", "cs", "sp", "req", "std", "sr", "txt", "br", "fr", "cr", "obj", "temp", "STR", "nc", "ext", "old", "f", "spec", "ns", "c", "arr", "start", "inner", "text", "iter", "r", "pr", "dr", "res", "cur", "st", "ptr"], "endptr": ["pendtr", "endedproc", "Endpointer", "endpointer", "endPtr", "pendptr", "endctr", " endPtr", " endpointer", " endtr", "endproc", "pendproc", "adctr", "EndPtr", "endedptr", "adpointer", " endproc", "adproc", "Endptr", "endedtr", " endctr", "Endctr", "adPtr", "endtr", "endedPtr", "Endproc", "adptr", "pendPtr"], "err": ["rr", "gr", "rc", "code", "i", "ctr", "msg", "kr", "range", "Error", "er", "req", "test", "ner", "aster", "error", "Er", "rh", "fr", "var", "der", "cr", "ind", "mr", "e", "ir", "good", "ver", "ler", "result", "arr", "try", "iter", "resp", "r", "pr", "nr", "ar", "dr", "res", "order", "ise"]}}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int ftp_passive_mode_epsv(FTPContext *s)\n\n{\n\n    char *res = NULL, *start = NULL, *end = NULL;\n\n    int i;\n\n    static const char d = '|';\n\n    static const char *command = \"EPSV\\r\\n\";\n\n    static const int epsv_codes[] = {229, 0};\n\n\n\n    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)\n\n        goto fail;\n\n\n\n    for (i = 0; res[i]; ++i) {\n\n        if (res[i] == '(') {\n\n            start = res + i + 1;\n\n        } else if (res[i] == ')') {\n\n            end = res + i;\n\n            break;\n\n        }\n\n    }\n\n    if (!start || !end)\n\n        goto fail;\n\n\n\n    *end = '\\0';\n\n    if (strlen(start) < 5)\n\n        goto fail;\n\n    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)\n\n        goto fail;\n\n    start += 3;\n\n    end[-1] = '\\0';\n\n\n\n    s->server_data_port = atoi(start);\n\n    av_dlog(s, \"Server data port: %d\\n\", s->server_data_port);\n\n\n\n    av_free(res);\n\n    return 0;\n\n\n\n  fail:\n\n    av_free(res);\n\n    s->server_data_port = -1;\n\n    return AVERROR(ENOSYS);\n\n}\n", "idx": 18583, "substitutes": {"s": ["ns", "m", "ts", "session", "t", "rates", "aws", "core", "f", "conf", "settings", "services", "service", "r", "n", "sb", "g", "ss", "ls", "ops", "fs", "self", "xs", "is", "o", "cs", "d", "su", "socket", "w", "fts", "qs", "e", "ssl", "ses", "sync", "client", "c", "js", "ps", "si", "sym", "p", "secondary", "S", "b", "ks", "gs", "sys", "u", "storage", "your", "a", "es", "os", "us", "hs", "south", "sets", "ds", "sf"], "res": ["rx", "ms", "ros", "ret", "content", "rs", "info", "rest", "ras", "err", "ix", "rc", "r", "results", "reg", "result", "vals", "details", "rh", "resolution", "Res", "des", "RES", "ry", "resp", "def", "arr", "changes", "cs", "ris", "range", "rec", "ray", "re", "ress", "gr", "pre", "ins", "args", "reset", "blocks", "response", "prev", "id", "remote", "ries", "e", "rev", "req", "rus", "rows", "resource", "rez", "ids", "error", "ons", "rep", "errors", "es", "os", "pres", "rem", "reply", "progress", "params"], "start": ["offset", "x", "str", "show", "max", "ie", "pos", "started", "range", "d", "length", "id", "mid", "p", "test", "next", "source", "part", "init", "work", "rest", "name", "from", "in", "min", "count", "art", "parse", "size", "pre", "stop", "style", "key", "k", "open", "patch", "shift", "time", "r", "root", "Start", "type", "ind", "date", "grade", "starting", "ad", "check", "info", "sp", "get", "old", "step", "first", "space", "cost", "seed", "use", "add", "e", "error", "se", "diff"], "end": ["ion", "inner", "est", "set", "offset", "code", "info", "rest", "name", "all", "r", "n", "then", "END", "max", "index", "pos", "en", "after", "enc", "range", "End", "d", "change", "begin", "stop", "value", "add", "last", "use", "id", "e", "send", "open", "v", "ad", "c", "post", "p", "address", "b", "append", "next", "length", "h", "ension", "edge", "ending", "order", "ended"], "i": ["ti", "gi", "uri", "m", "bi", "j", "code", "t", "x", "f", "ix", "ini", "qi", "r", "ai", "mi", "n", "io", "hi", "ii", "in", "ori", "di", "index", "ind", "iu", "I", "ie", "min", "multi", "is", "o", "ip", "l", "d", "rec", "oi", "pi", "ui", "ci", "pri", "w", "abi", "id", "e", "rev", "v", "c", "si", "ri", "xi", "p", "shift", "b", "u", "iv", "api", "it", "eni", "iter", "fi", "one", "y", "li", "len"], "command": ["pattern", "m", "content", "code", "request", "data", "mode", "text", "call", "comment", "attribute", "script", "document", "query", "method", "function", "password", "game", "execute", "description", "exec", "array", "directory", "event", "prefix", "response", "Command", "send", "power", "c", "cmd", "resource", "connection", "message", "sequence", "usage", "operation", "custom"], "epsv_codes": ["epsv_flags", "epsv_errors", "epsv_lines", "epsi_codes", "epsi_lines", "epsi_code", "epsi_errors", "epsi_cod", "epsi_flags", "epsv_code", "epsv_cod"]}}
{"project": "FFmpeg", "commit_id": "b25e84b7399bd91605596b67d761d3464dbe8a6e", "target": 1, "func": "static int hevc_frame_start(HEVCContext *s)\n\n{\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n    int ret;\n\n\n\n    memset(s->horizontal_bs, 0, 2 * s->bs_width * (s->bs_height + 1));\n\n    memset(s->vertical_bs,   0, 2 * s->bs_width * (s->bs_height + 1));\n\n    memset(s->cbf_luma,      0, s->sps->min_tb_width * s->sps->min_tb_height);\n\n    memset(s->is_pcm,        0, s->sps->min_pu_width * s->sps->min_pu_height);\n\n\n\n    lc->start_of_tiles_x = 0;\n\n    s->is_decoded        = 0;\n\n\n\n\n    if (s->pps->tiles_enabled_flag)\n\n        lc->end_of_tiles_x = s->pps->column_width[0] << s->sps->log2_ctb_size;\n\n\n\n    ret = ff_hevc_set_new_ref(s, s->sps->sao_enabled ? &s->sao_frame : &s->frame,\n\n                              s->poc);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    ret = ff_hevc_frame_rps(s);\n\n    if (ret < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Error constructing the frame RPS.\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    ret = set_side_data(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    av_frame_unref(s->output_frame);\n\n    ret = ff_hevc_output_frame(s, s->output_frame, 0);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    ff_thread_finish_setup(s->avctx);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    if (s->ref)\n\n        ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);\n\n    s->ref = NULL;\n\n    return ret;\n\n}", "idx": 16203, "substitutes": {"s": ["i", "rs", "qs", "new", "js", "si", "ps", "lines", "tests", "spec", "c", "is", "sl", "tp", "in", "aws", "args", "south", "m", "self", "bis", "d", "t", "sync", "sg", "fs", "sym", "cs", "g", "es", "full", "session", "w", "u", "b", "sf", "ns", "r", "comm", "ks", "secondary", "sys", "parts", "service", "os", "sets", "o", "ms", "e", "site", "http", "sb", "f", "less", "services", "ls", "comments", "ctx", "ses", "as", "l", "a", "sites", "S", "settings", "this", "its", "sq", "v", "conf", "ss", "p", "se", "n", "ments", "gs", "xs", "ssl", "ds", "ts", "us", "ims", "y"], "lc": ["acs", "mc", "cm", "bc", "cc", "pc", "l", "cs", "ci", "dl", "lp", "cn", "si", "loc", "ld", "conn", "lr", "kl", "cli", "nc", "sb", "tc", "cus", "lf", "acl", "gb", "c", "ns", "lu", "lv", "cb", "sc", "sl", "coll", "lex", "ls", "lb", "wl", "fc", "ln", "cl", "ctx", "LC"], "ret": ["pet", "reply", "art", "sat", "val", "def", "gt", "str", "mem", "base", "count", " RET", "att", "cat", "end", "sur", "RET", "num", "ft", "rev", "part", "rets", "arg", "det", "error", "pass", "mt", "data", "result", "try", "arr", "al", "res", "reg", "rf", "flag", "run", "red", "alt", "let", "fun", "ref", "lit", "valid", "bot", "info", "Ret", "html", "rl", "reset", "nt", "re", "rt", "rep", "no", "usr", "bit", "err", "code", "back", "pt", "py", "feat", "lt", "success", "match", "fit", " Ret", "resp", "db", "pat", "len"]}}
{"project": "FFmpeg", "commit_id": "69c1fe7c9c9bc85eebfc02c6a19caf7e88cd74ff", "target": 0, "func": "static int mkv_write_ass_blocks(AVFormatContext *s, AVIOContext *pb,\n\n                                AVPacket *pkt)\n\n{\n\n    MatroskaMuxContext *mkv = s->priv_data;\n\n    int i, layer = 0, max_duration = 0, size, line_size, data_size = pkt->size;\n\n    uint8_t *start, *end, *data = pkt->data;\n\n    ebml_master blockgroup;\n\n    char buffer[2048];\n\n\n\n    while (data_size) {\n\n        int duration = ass_get_duration(data);\n\n        max_duration = FFMAX(duration, max_duration);\n\n        end          = memchr(data, '\\n', data_size);\n\n        size         = line_size = end ? end - data + 1 : data_size;\n\n        size        -= end ? (end[-1] == '\\r') + 1 : 0;\n\n        start        = data;\n\n        for (i = 0; i < 3; i++, start++)\n\n            if (!(start = memchr(start, ',', size - (start - data))))\n\n                return max_duration;\n\n        size -= start - data;\n\n        sscanf(data, \"Dialogue: %d,\", &layer);\n\n        i = snprintf(buffer, sizeof(buffer), \"%\" PRId64 \",%d,\",\n\n                     s->streams[pkt->stream_index]->nb_frames, layer);\n\n        size = FFMIN(i + size, sizeof(buffer));\n\n        memcpy(buffer + i, start, size - i);\n\n\n\n        av_log(s, AV_LOG_DEBUG,\n\n               \"Writing block at offset %\" PRIu64 \", size %d, \"\n\n               \"pts %\" PRId64 \", duration %d\\n\",\n\n               avio_tell(pb), size, pkt->pts, duration);\n\n        blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,\n\n                                       mkv_blockgroup_size(size));\n\n        put_ebml_id(pb, MATROSKA_ID_BLOCK);\n\n        put_ebml_num(pb, size + 4, 0);\n\n        // this assumes stream_index is less than 126\n\n        avio_w8(pb, 0x80 | (pkt->stream_index + 1));\n\n        avio_wb16(pb, pkt->pts - mkv->cluster_pts);\n\n        avio_w8(pb, 0);\n\n        avio_write(pb, buffer, size);\n\n        put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);\n\n        end_ebml_master(pb, blockgroup);\n\n\n\n        data      += line_size;\n\n        data_size -= line_size;\n\n    }\n\n\n\n    return max_duration;\n\n}\n", "idx": 24768, "substitutes": {"s": ["S", "space", "sc", "ses", "rs", "sys", "ss", "p", "b", "server", "c", "ns", "sam", "storage", "sq", "ds", "ps", "sg", "self", "su", "bs", "e", "stats", "gs", "o", "http", "session", "spec", "sv", "si", "os", "ctx", "sb", "client", "services", "sci", "sa", "ls", "f", "service", "qs", "fs", "n", "t", "a", "v", "sl", "sf", "ssl", "cs", "g"], "pb": ["pg", "pkg", "lb", "gb", "cb", "bos", "typ", "PB", "dl", "lp", "fp", "bps", "r", "vp", "ib", "summary", "p", "b", "parser", "ppa", "xb", "jp", "dp", "proc", "mp", "buf", "pit", "wp", "tc", "prot", "tp", "plug", "pc", "kt", "g", "pp", "uf", "np", "uc", "d", "rb", "bp", "plugin", "all", "db", "eb", "pl", "sb", "fb", "client", "length", "_", "pos", "pa", "api", "bf", "bh", "bc", "plugins", "platform", "hub", "python", "amp", "pd", "ctx", "pro"], "pkt": ["pct", "fnt", " packet", "matt", "facket", "apkt", "plct", "mcp", "patt", "mke", "pqt", "Patt", "pcp", "Pcp", "pke", "placket", "Pnt", " pcp", "lacket", " pqt", "Pdt", "mnt", "fct", "latt", "Pft", "packet", " pdt", "apnt", " pct", "lnt", " pnt", " pft", "Packet", "mqt", "apacket", "apqt", "pft", "apke", "mdt", "Pke", "fkt", "Pqt", "mkt", "apdt", "pnt", "plkt", "macket", "lkt", "mct", "Pkt", "pdt", "Pct", "plft"], "mkv": ["kw", "cpv", "mkw", " mkf", "kvd", "mkvd", "kvt", "mkc", "cpc", "ikw", "ikc", "mkvt", "skvd", "cpf", "kc", "ikv", " mkvd", "skv", " mkvt", "skf", "ikf", "mkf", "kf", "cpw", "skvt", "kv"], "i": ["idi", "slice", "z", "ie", "p", "info", "b", "c", "m", "position", "d", "uli", "ix", "uni", "x", "ti", "mi", "phi", "qi", "it", "id", "is", "line", "e", "iter", "li", "gi", "zi", "multi", "esi", "xi", "uri", "inner", "ii", "di", "si", "ai", "bi", "ni", "ini", "cli", "offset", "ci", "fi", "eni", "length", "part", "I", "y", "mini", "f", "n", "ip", "index", "j", "ice", "inter", "init", "ind", "pi", "ui", "l", "hi", "layer"], "size": ["use", "name", "time", "num", "max", "SIZE", "fee", "number", "six", "bytes", "n", "content", "core", "area", "ice", "body", "code", "ize", "engine", "c", "empty", "sized", "x", "storage", "sum", "en", "align", "mi", "address", "speed", "line", "ci", "eni", "shape", "timeout", "stream", "large", "len", "g", "send", "capacity", "Size", "e", "span", "extra", "small", "offset", "mode", "sec", "length", "page", "shift", "position", "weight", "member", "unit", "loc", "si", "scale", "ui", "l"], "line_size": [" line2size", " line_len", " line_sized", " line2len", "data_width", " line2scale", "line_len", " line_scale", "data_count", "line2scale", "line_scale", "line2sized", "line2len", "line_count", "data_size", " line2sized", "line_sized", "line2size", "line_width"], "start": ["use", "starting", "ie", "name", "time", "add", "next", "it", "seed", "max", "min", "set", "st", "current", "part", "j", "space", "Start", "slice", "p", "se", "x", "ad", "address", "line", "key", "sp", "work", "resource", "new", "middle", "before", "root", "block", "len", "load", "rest", "parse", "d", "started", "mid", "error", "e", "step", "span", "get", "offset", "grade", "like", "length", "source", "init", "alpha", "pos", "stop", "from", "shift", "info", "style", "cur", "type", "id", "pad", "si", "art", "scale", "index", "v", "ind", "range"], "end": ["exec", "use", "body", "p", "except", "End", "x", "enc", "send", "en", "END", "ad", "next", "style", "address", "ed", "id", "all", "e", "line", "feed", "begin", "open", "max", "nd", "until", "set", "after", "inner", "ent", "offset", "last", "append", "edge", "change", "ended", "est", "length", "update", "pend", "h", "f", "limit", "ending", "index", "desc", "content", "event", "pos", "post", "len", "stop"], "data": ["date", "batch", "frame", "frames", "time", "base", "next", "li", "input", "current", "window", "bytes", "da", "content", "memory", "area", "layer", "complete", "space", "body", "code", "gap", "slice", "p", "queue", "actions", "blocks", "media", "text", "ad", "address", "reader", "buf", "feed", "work", "resource", "di", "one", "new", "result", "response", "cache", "first", "middle", "timeout", "stream", "stage", "DATA", "block", "len", "load", "Data", "d", "delay", "three", "step", "open", "message", "offset", "parent", "video", "length", "source", "alpha", "pos", "shift", "image", "api", "dd", "id", "pad", "audio", "dat", "zero", "inner", "sample", "record", "scale", "channel", "device", "dist", "a", "results", "ui"], "blockgroup": ["poolGROUP", "byteGroup", "poolmap", "blockGroup", "BlockGROUP", " blockblock", "poolgroup", "byteblock", "blockblock", " blockGroup", "Blockgroup", " blockgroups", "rowgroups", " blockmap", "blockmap", "bytegroups", "Blockmap", "rowblock", "bytegroup", " blockGROUP", "blockgroups", "blockGROUP", "rowGroup", "rowgroup"], "buffer": ["code", "gap", "byte", "slice", "bin", "b", "p", "batch", "frame", "position", "image", "wave", "queue", "text", "read", "address", "duration", "texture", "uffer", "pad", "cube", "url", "buf", "line", "iter", "message", "resource", "input", "audio", "cap", "offset", "binary", " buffers", "result", "video", "cache", "channel", "Buffer", "shape", "length", "device", "buff", "transfer", "window", "f", "source", "null", "header", "memory", "block", "document", "layer"]}}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,\n\n                                        unsigned int queue_no,\n\n                                        unsigned int vector,\n\n                                        MSIMessage msg)\n\n{\n\n    VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no);\n\n    EventNotifier *n = virtio_queue_get_guest_notifier(vq);\n\n    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];\n\n    int ret;\n\n\n\n    if (irqfd->users == 0) {\n\n        ret = kvm_irqchip_add_msi_route(kvm_state, msg);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        irqfd->virq = ret;\n\n    }\n\n    irqfd->users++;\n\n\n\n    ret = kvm_irqchip_add_irq_notifier(kvm_state, n, irqfd->virq);\n\n    if (ret < 0) {\n\n        if (--irqfd->users == 0) {\n\n            kvm_irqchip_release_virq(kvm_state, irqfd->virq);\n\n        }\n\n        return ret;\n\n    }\n\n\n\n    virtio_queue_set_guest_notifier_fd_handler(vq, true, true);\n\n    return 0;\n\n}\n", "idx": 18067, "substitutes": {"proxy": ["uri", "plugin", "Proxy", "super", "core", "base", "image", "pool", "buffer", "io", "library", "service", "bridge", "module", "node", "python", "pb", "phy", "manager", "model", "ip", "vm", "socket", "pse", "queue", "config", "remote", "cop", "client", "parent", "driver", "p", "que", "cache", "http", "resource", "route", "wrapper", "pro", "connection", "project", "port", "server", "bus"], "queue_no": ["queue__len", "queue__no", "que_len", "queue_No", "queue_number", "que_no", "queue_len", "queue_offset", " queue_offset", "queue__number", "que_number", " queue_number", " queue_No"], "vector": ["uri", "native", "Vector", " generator", "creator", "token", "buffer", "vec", "node", "manager", "timeout", "virtual", " matrix", "pointer", "letter", "network", "queue", "prefix", " vendor", "buf", " protocol", "v", "driver", "binary", "iterator", "card", " router", "iv", "number", "connection", "sequence", "port", "prot", "command", "version", "reader"], "msg": ["uri", "ms", "m", "cfg", "request", "data", "text", "name", "op", "vec", " message", "g", "node", "sim", "Message", "mem", "manager", " MSG", "def", "out", "vm", "nm", "new", "event", "config", "response", "queue", "send", "v", "req", "Msg", "seq", "cmd", "sym", "gen", "route", "mail", "message", "command", "reply"], "vq": ["giq", "vqq", "tvch", "Vq", "vvq", "gq", "tvqa", " vch", "tvq", "vc", "gqa", "miq", "pq", " vQ", "mqq", "gqq", "tvqi", "vvqa", "pqa", " vc", "viq", "tvque", "vqi", "tvc", " vqa", "vvch", "mq", "vvque", "vque", "VQ", "pqq", "tvQ", "Vqi", "Vc", "piq", " vqi", "vQ", "vqa", "mqa", " vque", "vch"], "n": ["ns", " ng", "gn", "dn", "m", "s", "j", "t", "f", "pn", "ne", "r", "mn", "num", "N", "g", "i", "nor", "z", "nl", "nb", "en", "o", "nm", "l", "d", " N", "nr", "nc", "network", "sn", "w", "nu", "v", "nw", "c", "p", "b", "cn", "number", "nn", "np", "y"], "irqfd": ["irquestfin", "ircdir", "irqafin", "irpatchFD", "irqfront", "irpFD", "ireqfn", "yrarchcdn", "arinqufin", "irqfan", "irchfd", "irkfen", "irvfen", "iraqufan", "irtqFD", "irqufin", "yrarchfd", "irquestfen", "irqudir", "irqufn", "irqufan", "irquFD", "irqfl", "iraqfd", "irqds", "irpatchfl", "irpatchfun", "ireqfun", "arinqfen", "irkfd", "irpatchfed", "irpatchfn", "irtqfl", "irsqbd", "iraquds", "irekfd", "irvfd", "irhFD", "ireqfed", "iersqFD", "irkFD", "irwallfd", "irarchcdn", "yrarchfen", "irchfen", "irancebd", "ircfd", "irqfc", "yrarchdf", "irchdf", "iriqds", "irqufun", "iraqfan", "irqFD", "irqufd", "ierqFD", "iraqds", "ierqfd", "yrqdf", "irekfc", "iraqufin", "irtqufl", "irqufed", "ireqFD", "irsqfront", "arinqdf", "iersqfront", "irqafan", "irquestfd", "yrqfd", "irqufen", "irequfn", "arinqfin", "iersqfd", "irhfd", "irarchfen", "yrqcdn", "irqcdn", "irvcdn", "irqudf", "irsqfd", "yrqfen", "irqfn", "ircbd", "arinqufd", "ircfront", "ireqfen", "irquestdf", "irpatchdir", "arinqudf", "irqadf", "irquds", "irwallfun", "irequfed", "iraqfin", "irtqufd", "irqdir", "irtqdir", "irancefront", "irqfin", "iranceFD", "irpatchfd", "irwallfed", "irequfd", "irchfin", "irtqfd", "irqfun", "ierqbd", "irqbd", "irpfc", "irtqudir", "irqafd", "irpfen", "ireqfd", "irpfd", "irarchdf", "arinqfd", "iraqufd", "iersqbd", "ircFD", "irqads", "iriqfin", "iriqfd", "irkfc", "irqufl", "irekFD", "irekfen", "irqfed", "iriqfan", "irqdf", "arinqufen", "ircfl", "irtquFD", "ireqfc", "irwallfn", "irancefd", "irqafen", "irqacdn", "irequfun", "irqfen", "irvdf", "irsqFD", "irhfc", "ierqfront", "irarchfd", "irhfen"], "ret": ["part", "db", "code", "t", "info", "x", "f", "ref", "bit", "alt", "obj", "err", "rc", "nt", "ver", "reg", "rt", "fun", "lit", "result", "job", "try", "fi", "flag", "type", "match", "pass", "ext", "done", "run", "rf", "ry", "def", "rets", "active", "mem", "art", "secret", "att", "arg", "val", "re", "Ret", "bf", "back", "reset", "value", "rev", "cat", "rb", "hard", "repl", "url", "RET", "pat", "error", "red", "rep", "res", "pet", "opt", "mt", "ft", "usr", "reply", "success", "len"], "users": ["classes", "bugs", "packages", "pages", "jobs", "stars", "mins", "ports", "modules", "workers", "plugins", "devices", "files", "runners", "models", "items", "apps", "lines", "vers", "views", "units", "Users", "drivers", "blocks", "pins", "masters", "versions", "ids", "projects", "leaders", "names", "rules", "members", "groups", "parents", "docs", "locks"]}}
{"project": "qemu", "commit_id": "1f3ddfcb258e6e0562467a9644daad3f28597da8", "target": 1, "func": "static void bdrv_qed_drain(BlockDriverState *bs)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n\n\n    /* Cancel timer and start doing I/O that were meant to happen as if it\n\n     * fired, that way we get bdrv_drain() taking care of the ongoing requests\n\n     * correctly. */\n\n    qed_cancel_need_check_timer(s);\n\n    qed_plug_allocating_write_reqs(s);\n\n    bdrv_aio_flush(s->bs, qed_clear_need_check, s);\n\n}\n", "idx": 14750, "substitutes": {"bs": ["ses", "blocks", "bid", "bis", "bc", "lbs", "BS", "fs", "ins", "bb", "fb", "rs", "cs", "os", "bytes", "es", "aps", "ps", "ss", "ba", "rb", "obs", "pb", "vs", "b", "sb", "base", "gb", "gs", "bits", "ab", "bh", "ns", "state", "bps", "bes", "bas", "bi", "ds", "sa", "ls", "bos", "lb", "ubs", "iss", "ks", "aws"], "s": ["args", "south", "sys", "ses", "rss", "service", "sync", "t", "i", "rs", "sym", "a", "g", "cs", "S", "submit", "os", "status", "si", "es", "js", "sq", "session", "server", "ps", "ss", "o", "p", "e", "socket", "http", "b", "sb", "n", "f", "gs", "state", "spec", "c", "ns", "is", "stats", "ssl", "sl", "states", "services", "ds", "sie", "sa", "ls", "ts", "aws"]}}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "static uint64_t omap_ulpd_pm_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n    uint16_t ret;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x14:\t/* IT_STATUS */\n\n        ret = s->ulpd_pm_regs[addr >> 2];\n\n        s->ulpd_pm_regs[addr >> 2] = 0;\n\n        qemu_irq_lower(s->irq[1][OMAP_INT_GAUGE_32K]);\n\n        return ret;\n\n\n\n    case 0x18:\t/* Reserved */\n\n    case 0x1c:\t/* Reserved */\n\n    case 0x20:\t/* Reserved */\n\n    case 0x28:\t/* Reserved */\n\n    case 0x2c:\t/* Reserved */\n\n        OMAP_BAD_REG(addr);\n\n    case 0x00:\t/* COUNTER_32_LSB */\n\n    case 0x04:\t/* COUNTER_32_MSB */\n\n    case 0x08:\t/* COUNTER_HIGH_FREQ_LSB */\n\n    case 0x0c:\t/* COUNTER_HIGH_FREQ_MSB */\n\n    case 0x10:\t/* GAUGING_CTRL */\n\n    case 0x24:\t/* SETUP_ANALOG_CELL3_ULPD1 */\n\n    case 0x30:\t/* CLOCK_CTRL */\n\n    case 0x34:\t/* SOFT_REQ */\n\n    case 0x38:\t/* COUNTER_32_FIQ */\n\n    case 0x3c:\t/* DPLL_CTRL */\n\n    case 0x40:\t/* STATUS_REQ */\n\n        /* XXX: check clk::usecount state for every clock */\n\n    case 0x48:\t/* LOCL_TIME */\n\n    case 0x4c:\t/* APLL_CTRL */\n\n    case 0x50:\t/* POWER_CTRL */\n\n        return s->ulpd_pm_regs[addr >> 2];\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 17581, "substitutes": {"opaque": ["operace", " opque", "operacity", "ipopaques", "oponymous", "oclonymous", "operaya", "ipque", "ipace", " opacity", "iopaya", "oclaya", "opaya", " opace", "operec", "opec", "opacity", "iopaque", "operaque", "ioponymous", "ipacity", "ipopec", "oclacity", " opec", "operque", "ipopacity", "opace", "iopacity", "operonymous", "ipaque", "opaques", "operaques", "ipopaque", "oclaque", "opque", " opaques"], "addr": ["offset", "x", "ref", "align", "ar", "adder", "padding", "ptr", "pos", "empty", "layer", "anne", "config", "length", "prefix", "id", "asm", "p", "pad", "adr", "conn", "target", "len", "rx", "part", "work", "name", "eth", "hop", "pointer", "arity", "arg", "slot", "route", "ha", "mac", "port", "order", "amp", "code", "alt", "r", "rt", "cb", "src", "node", "byte", "host", "ack", "fx", "nr", "grade", "ad", "address", "ace", "amd", "edge", "data", "mode", "buffer", "reg", "ord", "coord", "oa", "ext", "index", "en", "ip", "alias", "args", "add", "dr", "seq", "cmd", "kt", "url", "cmp", "error", "server", "attr"], "size": ["scale", "offset", "small", "shape", "data", "capacity", "SIZE", "name", "err", "x", "code", "rc", "from", "n", "align", "sized", "g", "type", "six", "loc", "timeout", "en", "empty", " address", "large", "sn", "ize", "length", "e", "send", "c", "address", "shift", "bytes", "Size", "len"], "s": ["ns", "spec", "m", "session", "sg", "ts", "t", "rs", "uns", "aws", "f", "conf", "services", "service", "r", "results", "ions", "g", "sb", "i", "sl", "ss", "ls", "ops", "scope", "fs", "self", "is", "o", "cs", "als", "l", "su", "ins", "socket", "w", "qs", "e", "ssl", "comments", "sync", "ses", "v", "c", "js", "si", "ps", "sym", "p", "secondary", "S", "support", "rows", "b", "ks", "gs", "sys", "u", "its", "a", "es", "os", "sq", "south", "states", "sets", "ings", "ds", "sf"], "ret": ["part", "code", "t", "data", "al", "bit", "ref", "f", "alt", "buffer", "reg", "nt", "lit", "rc", "fun", "rt", "r", "result", "num", "flag", "ext", "def", "rets", "en", "out", "arg", "att", "art", "val", "re", "Ret", "feat", "det", "rev", "v", "repl", "RET", "red", "rep", "res", "desc", "value", "success", "len"]}}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static int vhost_virtqueue_init(struct vhost_dev *dev,\n\n                                struct vhost_virtqueue *vq, int n)\n\n{\n\n    struct vhost_vring_file file = {\n\n        .index = n,\n\n    };\n\n    int r = event_notifier_init(&vq->masked_notifier, 0);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    file.fd = event_notifier_get_fd(&vq->masked_notifier);\n\n    r = dev->vhost_ops->vhost_call(dev, VHOST_SET_VRING_CALL, &file);\n\n    if (r) {\n\n        r = -errno;\n\n        goto fail_call;\n\n    }\n\n    return 0;\n\nfail_call:\n\n    event_notifier_cleanup(&vq->masked_notifier);\n\n    return r;\n\n}\n", "idx": 18799, "substitutes": {"dev": ["dc", "Dev", "dd", "db", "mod", "data", "info", "conf", "gd", "comment", "engine", "md", "gu", "debug", "de", "ver", "rad", "root", "app", "block", "var", "node", "di", "def", "development", "der", "self", "d", "hw", "w", "ev", "ad", "client", "v", "device", "cache", "DEV", "end", "valid", "die", "diff", "conn", "bug"], "vq": ["vcdq", "vmq", "nvq", "svq", "pquest", "tvq", " viq", "variqu", "vp", "pq", "variq", "vmp", " vQ", "pdq", "nvp", "svque", "pQ", "tvqu", "vmquest", "svqu", "eviq", "tvquery", "viq", "tvque", "vqi", "vcq", "vcquest", "svquery", "variquery", "nvqi", " vqa", "svqi", "evq", "vmqi", "svp", "vque", "vqu", "evqi", " vquest", "varique", "vquest", "nviq", " vqi", "nvqa", "vQ", " vdq", "nvquest", "vqa", "vdq", "vcQ", "vquery", "evqa", "svquest"], "n": ["ns", "na", "m", "init", "s", "t", "x", "name", "f", "r", "ne", "num", "N", "g", "i", "node", "index", "nb", "en", "nat", "o", "nm", "l", "d", "nc", "network", "sn", "w", "k", "e", "v", "c", "p", "b", "number", "a", "nn", "u"]}}
{"project": "FFmpeg", "commit_id": "7cf22c79706d23d40d16cee37eb32d5797adcc2c", "target": 0, "func": "yuv2rgba64_full_X_c_template(SwsContext *c, const int16_t *lumFilter,\n\n                       const int32_t **lumSrc, int lumFilterSize,\n\n                       const int16_t *chrFilter, const int32_t **chrUSrc,\n\n                       const int32_t **chrVSrc, int chrFilterSize,\n\n                       const int32_t **alpSrc, uint16_t *dest, int dstW,\n\n                       int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    int i;\n\n    int A = 0xffff<<14;\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int j;\n\n        int Y  = -0x40000000;\n\n        int U  = -128 << 23; // 19\n\n        int V  = -128 << 23;\n\n        int R, G, B;\n\n\n\n        for (j = 0; j < lumFilterSize; j++) {\n\n            Y += lumSrc[j][i]  * (unsigned)lumFilter[j];\n\n        }\n\n        for (j = 0; j < chrFilterSize; j++) {;\n\n            U += chrUSrc[j][i] * (unsigned)chrFilter[j];\n\n            V += chrVSrc[j][i] * (unsigned)chrFilter[j];\n\n        }\n\n\n\n        if (hasAlpha) {\n\n            A = -0x40000000;\n\n            for (j = 0; j < lumFilterSize; j++) {\n\n                A += alpSrc[j][i] * (unsigned)lumFilter[j];\n\n            }\n\n            A >>= 1;\n\n            A += 0x20002000;\n\n        }\n\n\n\n        // 8bit: 12+15=27; 16-bit: 12+19=31\n\n        Y  >>= 14; // 10\n\n        Y += 0x10000;\n\n        U  >>= 14;\n\n        V  >>= 14;\n\n\n\n        // 8bit: 27 -> 17bit, 16bit: 31 - 14 = 17bit\n\n        Y -= c->yuv2rgb_y_offset;\n\n        Y *= c->yuv2rgb_y_coeff;\n\n        Y += 1 << 13; // 21\n\n        // 8bit: 17 + 13bit = 30bit, 16bit: 17 + 13bit = 30bit\n\n\n\n        R = V * c->yuv2rgb_v2r_coeff;\n\n        G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n        B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n        // 8bit: 30 - 22 = 8bit, 16bit: 30bit - 14 = 16bit\n\n        output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n        output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n        output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n        if (eightbytes) {\n\n            output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n            dest += 4;\n\n        } else {\n\n            dest += 3;\n\n        }\n\n    }\n\n}\n", "idx": 16335, "substitutes": {"i": ["qi", "it", "ui", "m", "I", "d", "ni", "ai", "xi", "id", "l", "ini", "iu", "a", "gi", "io", "api", "iv", "oi", "ci", "ki", "h", "x", "di", "si", "ie", "init", "ii", "v", "uri", "o", "w", "yi", "z", "u", "p", "e", "ir", "info", "fi", "mi", "k", "li", "b", "ix", "n", "f", "phi", "ti", "ip", "c", "eni", "is", "jc", "ji", "pi", "q", "r", "bi", "ik", "ri", "ei", "ori", "ami", "zi", "y", "ij"], "j": ["jj", "uj", "jen", "it", "adj", "qi", "m", "ch", "ui", "aj", "d", "t", "ja", "jp", "l", "oj", "g", "er", "syn", "dj", "h", "x", "di", "jet", "js", "si", "ie", "ii", "key", "v", "br", "fr", "jam", "job", "o", "obj", "z", "u", "jit", "p", "e", "Ja", "not", "k", "li", "b", "ix", "n", "f", "json", "jo", "next", "jl", "block", "jc", "ji", "je", "q", "r", "J", "we", "el", "y", "ij"], "R": ["D", "T", "E", "RA", "I", "O", "N", "C", "Q", "S", "RR", "AR", "GR", "F", "A", "L", "UR", "W", "M", "K", "X", "r", "H", "Y", "J", "V", "GB", "SR", "U", "P"], "G": ["D", "VG", "GL", "E", "I", "LG", "GD", "C", "Q", "N", "g", "S", "GG", "GR", "F", "A", "BG", "L", "SG", "RG", "W", "M", "K", "GE", "GV", "H", "Y", "J", "V", "GB", "Gs", "U", "P"], "B": ["D", "T", "BO", "E", "BA", "BS", "O", "C", "AB", "BC", "AR", "F", "OB", "Bs", "b", "MB", "L", "NB", "BL", "W", "M", "WB", "SB", "PB", "BB", "H", "Y", "J", "V", "GB", "BI", "U", "Bi", "UB", "P", "DB"]}}
{"project": "FFmpeg", "commit_id": "ae3da0ae5550053583a6f281ea7fd940497ea0d1", "target": 1, "func": "static int decode_band(IVI45DecContext *ctx, int plane_num,\n\n                       IVIBandDesc *band, AVCodecContext *avctx)\n\n{\n\n    int         result, i, t, idx1, idx2, pos;\n\n    IVITile     *tile;\n\n\n\n    band->buf     = band->bufs[ctx->dst_buf];\n\n    if (!band->buf) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Band buffer points to no data!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    band->ref_buf = band->bufs[ctx->ref_buf];\n\n    band->data_ptr = ctx->frame_data + (get_bits_count(&ctx->gb) >> 3);\n\n\n\n    result = ctx->decode_band_hdr(ctx, band, avctx);\n\n    if (result) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error while decoding band header: %d\\n\",\n\n               result);\n\n        return result;\n\n    }\n\n\n\n    if (band->is_empty) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Empty band encountered!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    band->rv_map = &ctx->rvmap_tabs[band->rvmap_sel];\n\n\n\n    /* apply corrections to the selected rvmap table if present */\n\n    for (i = 0; i < band->num_corr; i++) {\n\n        idx1 = band->corr[i * 2];\n\n        idx2 = band->corr[i * 2 + 1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n    pos = get_bits_count(&ctx->gb);\n\n\n\n    for (t = 0; t < band->num_tiles; t++) {\n\n        tile = &band->tiles[t];\n\n\n\n        if (tile->mb_size != band->mb_size) {\n\n            av_log(avctx, AV_LOG_ERROR, \"MB sizes mismatch: %d vs. %d\\n\",\n\n                   band->mb_size, tile->mb_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        tile->is_empty = get_bits1(&ctx->gb);\n\n        if (tile->is_empty) {\n\n            ivi_process_empty_tile(avctx, band, tile,\n\n                                      (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3));\n\n            av_dlog(avctx, \"Empty tile encountered!\\n\");\n\n        } else {\n\n            tile->data_size = ff_ivi_dec_tile_data_size(&ctx->gb);\n\n            if (!tile->data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Tile data size is zero!\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            result = ctx->decode_mb_info(ctx, band, tile, avctx);\n\n            if (result < 0)\n\n                break;\n\n\n\n            result = ff_ivi_decode_blocks(&ctx->gb, band, tile);\n\n            if (result < 0 || ((get_bits_count(&ctx->gb) - pos) >> 3) != tile->data_size) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Corrupted tile data encountered!\\n\");\n\n                break;\n\n            }\n\n\n\n            pos += tile->data_size << 3; // skip to next tile\n\n        }\n\n    }\n\n\n\n    /* restore the selected rvmap table by applying its corrections in reverse order */\n\n    for (i = band->num_corr-1; i >= 0; i--) {\n\n        idx1 = band->corr[i*2];\n\n        idx2 = band->corr[i*2+1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n#ifdef DEBUG\n\n    if (band->checksum_present) {\n\n        uint16_t chksum = ivi_calc_band_checksum(band);\n\n        if (chksum != band->checksum) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Band checksum mismatch! Plane %d, band %d, received: %x, calculated: %x\\n\",\n\n                   band->plane, band->band_num, band->checksum, chksum);\n\n        }\n\n    }\n\n#endif\n\n\n\n    align_get_bits(&ctx->gb);\n\n\n\n    return result;\n\n}\n", "idx": 21708, "substitutes": {"ctx": ["conv", "lc", "bc", "grad", "cam", "cc", "wcs", "support", "gpu", "conn", "sci", "ref", "config", "coll", "pkg", "cv", "kt", "cm", "connection", "crit", "tx", "ca", "anc", "cas", "scl", "cmp", "ci", "nc", "cmd", "cp", "component", "cf", "xc", "ctrl", "kb", "context", "sync", "np", "buf", "rc", "c", "cb", "cn", "bank", "client", "la", "sc", "ann", "cal", "cpp", "cci", "gc", "qa", "media", "fw", "loc", "bm", "cca", "utils", "buff", "cms", "conf", "hw", "ck", "kw", "voc", "concept", "cu", "gb", "vc"], "plane_num": [" sheet_num", " sheet_name", " frame_num", " sheet_no", " sheet_sum", " frame_sum", " frame_name", " frame_no"], "band": ["target", "app", "event", "amp", "config", "part", "map", "cm", "piece", "device", "cell", "front", "bit", "cat", "data", "leg", "list", "link", "work", "field", "bank", "bo", "line", "rule", "library", "station", "slice", "bd", "cast", "batch", "grid", "image", "output", "phase", "support", "object", "db", "d", "bb", "style", "bass", "component", "tool", "plug", "low", "ann", "brand", "hub", "channel", "Band", "feed", "dB", "boot", "back", "bus", "lc", "fb", "not", "ld", "function", "layer", "model", "cmd", "full", "nd", "act", "point", "gen", "day", "b", "service", "flow", "co", "stage", "group", "guide", "gb", "plane", "obj", "board", "project", "kt", "player", "card", "feature", "plugin", "bridge", "product", "grab", "pp", "word", "kk", "tag", "frame", "filter", "match", "ground", "range", "unk", "block", "broad"], "avctx": ["svcontext", "aveca", "avcci", "svcmp", "AVcmp", "AVctl", "ivcontext", "vercontext", "airctx", "verconn", "afcci", "afctl", "averctl", "afcmp", "avconn", "AVcli", "verctx", "airconn", "AVcontext", "afctx", "avercontext", "AVca", "avca", "ivctx", "averctx", "svcb", " avcli", "vercci", "svctx", "avecontext", "avercli", "avcontext", "verkb", "ivcci", "svconn", "avctl", "AVconn", "svctl", "avcb", " avctl", " avconn", "ivconn", "afcb", "vercb", "avectx", "avcmp", "afcontext", "AVctx", "aircontext", "afconn", " avca", "avcli", " avcontext", "airkb", "aveconn", "afkb", "avkb"], "result": ["status", "found", "response", "effect", "err", "event", "valid", "val", "mate", "inc", "message", "card", "feature", "duration", "type", "product", "results", "df", "done", "term", "order", "catch", "info", "acc", "rate", "entry", "res", "data", "final", "other", "ret", "score", "compl", "diff", "number", "arr", "work", "current", "record", "comment", "success", "rc", "mer", "answer", "match", "pass", "die", "ver", "future", "value", "Result", "date", "there", "error", "length", "total", "test", "page", "grade", "root", "dest", "ge", "su", "attr", "count"], "i": ["io", "name", "ix", "start", "e", "ie", "qi", "ind", "ui", "eni", "part", "pi", "key", "ki", "gi", "d", "uri", "my", "ti", "I", "f", "ci", "y", "u", "info", "m", "ini", "phi", "j", "size", "p", "ip", "id", "bi", "is", "mi", "c", "index", "si", "ii", "in", "x", "b", "n", "iu", "sup", "slice", "ai", "xi", "hi", "di", "multi", "v", "yi", "li", "l", "fi", "k", "ni", "type"], "t": ["port", "the", "target", "e", "g", "time", "d", "tt", "token", "tim", "ti", "l", "f", "y", "u", "m", "s", "j", "p", "ts", "at", "o", "c", "num", "tf", "dt", "a", "b", "ta", "w", "to", "T", "n", "te", "test", "task", "ot", "v", "z", "qt", "tz", "h", "pt", "offset", "x", "k", "type"], "idx1": ["idxf1", "idnt1", " idxOne", "idx4", "idy4", " idxc0", " idx0", "idx81", " idxc2", "idww81", "idxOne", "idxf2", "idxBack", "idww2", "idxc2", "idXOne", "idwwone", " idxone", "idxc0", " idxc81", "iddx2", "idxcJ", " idxcBack", "idxf81", "idxc4", "idy1", " idxcJ", "iddxBack", "idnOne", "idn0", "idX1", " idX0", "iddxJ", "idx0", "idy0", "idxfone", "idnt2", " idX1", " idxBack", "idX0", "idxone", "idn1", " idXOne", "idX4", " idxcone", "idntJ", "idww1", "idxc1", " idxc1", "idntBack", " idx4", "idy2", "idX2", " idxJ", " idxc4", "idxc81", "idyOne", "idxcone", " idx81", "iddx1", "idxcBack", "idxJ", " idX2", "idn2"], "idx2": ["idxf02", "indx2", "idxe1", "idXFL", "idxe2", "idx4", " idxc0", "idt02", "idxi1", " idx62", "sidt1", "indxFL", "idX0", "sidx1", "idxe22", "sidx02", "idxTwo", "idxFL", "idt1", "idX02", "idxi0", "idy02", "idt2", "idcyTwo", "idxc4", "idy1", "idxc62", "idx02", "idX1", "indcy02", "idxc1", " idx4", "idy2", "idX2", "idxi22", "idx62", "indx02", " idx0", "idXTwo", "idxc2", "idx22", "idxc0", " idx22", "indcy2", "idcy2", "indcyTwo", "idxfFL", "indcyFL", "idcyFL", "sidx2", "indxTwo", " idxc2", "idxe4", "idxi2", "idxf2", "idxfTwo", "idxi62", "idX62", "idx0", "idxc22", "idcy02", " idxc62", " idxc1", " idxc22", " idxc4", "sidt02", "idxi4", "sidt2"], "pos": ["col", "port", "def", "end", "obj", "ref", "val", "part", "pi", "post", "pc", "POS", "no", "po", "neg", "op", "j", "cache", "rel", "os", "p", "Pos", "slot", "trans", "o", "index", "pl", "pro", "spec", "pid", "pres", "min", "n", "len", "loc", "conf", "sp", "pt", "position", "offset", "prop", "type"], "tile": ["route", "pod", "col", "Tile", "plane", "port", "target", "table", "flat", "oe", "late", "scale", "hop", "item", "nn", "coll", "token", "kt", "so", "cube", "file", "feature", "plate", "style", "plugin", "bridge", "tle", "cand", "node", "layer", "pixel", "split", "cell", "transfer", "coord", "tab", "cat", "zip", "tif", "component", "unit", "zone", "sheet", "tool", "tag", "tf", "rule", "line", "service", "ele", "flo", "slice", "chip", "mask", "ole", "co", "stone", "task", "grid", "image", "ge", "texture", "fo", "entity"]}}
{"project": "qemu", "commit_id": "146beee5d9f94d96ab3bf54ac355a263290b75ac", "target": 0, "func": "static int piix4_initfn(PCIDevice *dev)\n\n{\n\n    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    isa_bus_new(&d->dev.qdev);\n\n\n\n    pci_conf = d->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge\n\n    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);\n\n\n\n    piix4_dev = &d->dev;\n\n    qemu_register_reset(piix4_reset, d);\n\n    return 0;\n\n}\n", "idx": 5899, "substitutes": {"dev": ["v", "block", "mem", "rad", "di", "Dev", "dd", "device", "adv", "config", "bug", "data", "info", "dem", "module", "der", "debug", "gu", "state", "mod", "init", "dist", "conf", "ev", "def", "DEV", "dom", "wd", " Dev", "w", "prom", "inst", "die", "error", "dc", "kind", "comment", "err", "self", "serial", "req", "development", "start", "ver", "push", "develop", "engine", "desc", "app", "grad", "conn", "diff", "end"], "d": ["D", "dr", "del", "dm", "v", "id", "md", "a", "ded", "dn", "di", "bd", "dd", "dat", "device", "config", "b", "pd", "dh", "i", "ad", "m", "draw", "l", "db", "f", "u", "dom", "e", "w", "da", "driver", "dc", "sd", "n", "ds", "t", "p", "z", "ld", "c", "ind", "g", "fd", "gd", "dt", "dl", "r", "diff", "cd", "dict"], "pci_conf": ["pcin_conf", "pci5conf", "pci_con", "pki_const", "pci_conn", "pci_Conf", "pcm_conf", "pki_config", "pci5fam", "pki_conn", "pci_gate", "pii_conf", "pci_fam", "pci_config", "pci_cf", "pii_config", "pci_sum", "pci5gate", "pcm_gate", "pii_Conf", "pki_def", "pcm_fam", "pii_con", "pcin_config", "pki_conf", "pcm_config", "pcin_sum", "pci_def", "pci5config", "pki_Conf", "pci_const", "pcin_cf"]}}
{"project": "FFmpeg", "commit_id": "e838c9852e6f0a471a6917083e70e6fe238ba26a", "target": 1, "func": "static av_cold int init_bundles(BinkContext *c)\n\n{\n\n    int bw, bh, blocks;\n\n    int i;\n\n\n\n    bw = (c->avctx->width  + 7) >> 3;\n\n    bh = (c->avctx->height + 7) >> 3;\n\n    blocks = bw * bh;\n\n\n\n    for (i = 0; i < BINKB_NB_SRC; i++) {\n\n        c->bundle[i].data = av_malloc(blocks * 64);\n\n        if (!c->bundle[i].data)\n\n            return AVERROR(ENOMEM);\n\n        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2325, "substitutes": {"c": ["fc", "cm", "cs", "ctx", "cc", "mc", "com", "ct", "co", "n", "nc", "bc", "cur", "cy", "con", "tc", "enc", "g", "ac", "cr", "ch", "C", "ec", "dc", "ce", "h", "cu", "p", "xc", "l", "e", "lc", "f", "oc", "conf", "ca", "ctrl", "cd", "sc", "u", "cache", "vc", "pc", "b", "cp", "t", "cf", "ic", "ci", "uc"], "bw": ["barwd", " bws", " bwh", "bws", "adw", "lbwt", "fw", "bbwa", "Bwd", "abwd", "fwd", "bbwd", "fws", "bbwt", "barwt", "bwd", "abwh", "bwt", " bwa", "Bw", "abw", "adwh", "Bh", "barwa", "abwa", "Bws", " bwd", "fh", "bwa", "bwh", "adwa", "lbwd", "lbw", "bbw", "lbwa", "barw", "adwd"], "bh": ["yah", "bang", "ih", "obb", "sb", "bm", "lb", "hub", "ht", "ib", "db", "ph", "pb", "uh", "bl", "rb", "ah", "cb", "dq", "ch", "bf", "h", "hi", "hh", "phi", "bi", "wb", "length", "sq", "hp", "eth", "bg", "hy", "bp", "bb", "adh", "fb", "b", "abb", "bs", "kh", "rh", "sth", "xb"], "blocks": ["limits", "bars", "files", "groups", "works", "Blocks", "qs", "bags", "angles", "rules", "cells", "gets", "results", "jobs", "ins", "ools", "hops", "locks", "checks", "frames", "runs", "bits", "flows", "outs", "errors", "block", "items", "waves", "values", "words", "lines", "planes", "pages", "height", "steps", "rows", "blocking", "cycles", "books", "types", "breaks", "times", "bytes", "stores", "bs", "forces", "loads", "units", "plugins"], "i": ["layer", "cli", "yi", "hei", "ami", "li", "gi", "abi", "split", "a", "interface", "ni", "ii", "area", "zi", "ji", "ui", "pi", "oi", "d", "di", "I", "page", "id", "mi", "uli", "k", "iu", "api", "j", "iii", "eni", "ri", "info", "ti", "slice", "ini", "index", "multi", "ai", "ie", "x", "ip", "hi", "phi", "bi", "p", "e", "l", "f", "lc", "child", "u", "ori", "o", "qa", "b", "qi", "ix", "iv", "module", "uri", "ci", "io", "mu", "init", "fi", "si", "xi"]}}
{"project": "qemu", "commit_id": "7b0309490cb108d881a0c66d6b350b4db7b3b4ac", "target": 1, "func": "DeviceState *qdev_device_add(QemuOpts *opts)\n\n{\n\n    ObjectClass *oc;\n\n    DeviceClass *dc;\n\n    const char *driver, *path, *id;\n\n    DeviceState *dev;\n\n    BusState *bus = NULL;\n\n    Error *err = NULL;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        qerror_report(QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find driver */\n\n    oc = object_class_by_name(driver);\n\n    if (!oc) {\n\n        const char *typename = find_typename_by_alias(driver);\n\n\n\n        if (typename) {\n\n            driver = typename;\n\n            oc = object_class_by_name(driver);\n\n        }\n\n    }\n\n\n\n    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {\n\n        qerror_report(ERROR_CLASS_GENERIC_ERROR,\n\n                      \"'%s' is not a valid device model name\", driver);\n\n        return NULL;\n\n    }\n\n\n\n    if (object_class_is_abstract(oc)) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"non-abstract device type\");\n\n        return NULL;\n\n    }\n\n\n\n    dc = DEVICE_CLASS(oc);\n\n    if (dc->cannot_instantiate_with_device_add_yet) {\n\n        qerror_report(QERR_INVALID_PARAMETER_VALUE, \"driver\",\n\n                      \"pluggable device type\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            qerror_report(QERR_BAD_BUS_FOR_DEVICE,\n\n                          driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus) {\n\n            qerror_report(QERR_NO_BUS_FOR_DEVICE,\n\n                          dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !bus->allow_hotplug) {\n\n        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    /* create device, set properties */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n    }\n\n\n\n    id = qemu_opts_id(opts);\n\n    if (id) {\n\n        dev->id = id;\n\n    }\n\n    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        return NULL;\n\n    }\n\n    if (dev->id) {\n\n        object_property_add_child(qdev_get_peripheral(), dev->id,\n\n                                  OBJECT(dev), NULL);\n\n    } else {\n\n        static int anon_count;\n\n        gchar *name = g_strdup_printf(\"device[%d]\", anon_count++);\n\n        object_property_add_child(qdev_get_peripheral_anon(), name,\n\n                                  OBJECT(dev), NULL);\n\n        g_free(name);\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        qerror_report_err(err);\n\n        error_free(err);\n\n        dev->opts = NULL;\n\n        object_unparent(OBJECT(dev));\n\n        object_unref(OBJECT(dev));\n\n        qerror_report(QERR_DEVICE_INIT_FAILED, driver);\n\n        return NULL;\n\n    }\n\n    return dev;\n\n}\n", "idx": 491, "substitutes": {"opts": ["obfs", "optfs", "optths", "opoptions", "otters", "experters", " copts", "lockoptions", "opps", "optoptions", "otts", "lockts", "options", "experds", "opds", "oboptions", " copters", "experts", "opttions", "opTS", "optts", "optTS", " coptions", "ottions", "alters", "obTS", "optps", "lockfs", "alds", "opths", "opfs", "alts", "opters", "obts", " copths", "experps", "otths", "optds", "lockTS", "optters", "alps"], "oc": ["ob", "fc", "dr", "oci", "ow", "http", "roc", "anc", "cc", "mc", "oe", "oper", "ace", "loc", "co", "nc", "bc", "voc", "oid", "client", "op", "enc", "toc", "ac", "oo", "ok", "coll", "om", "mot", "ec", "oco", "OC", "c", "word", "lc", "ocr", "unc", "org", "sc", "drive", "soc", "object", "vc", "pc", "cca", "bb", "o", "iv", "ic", "os", "oca", "root", "uc", "acc", "ou", "rc"], "dc": ["dr", "cm", "fc", "DC", "dn", "da", "ga", "cc", "mc", "device", "gc", "d", "di", "cat", "nc", "director", "bc", "tc", "cdn", "ac", "coll", "df", "dt", "ds", "inc", "config", "ec", "cu", "c", "xc", "doc", "design", "lc", "sc", "ca", "cd", "disc", "vc", "cca", "pc", "cf", " DC", "dat", "dir", "input", "db", "rc"], "driver": ["dr", "route", "this", "dn", "device", "get", "url", "director", "sl", "driving", "args", "direction", "database", "feed", "force", "object", "s", "manager", "uri", "engine", "dir", "port", "target", "host", "type", "operator", "der", "end", "pass", "text", "handler", "creator", "iv", "plugin", "serial", "version", "browser", "oid", "project", "str", "writer", "c", "design", "vers", "loader", "error", "mode", "slave", "ride", "drivers", "cost", "_", "test", "service", "construct", "wrapper", "ops", "class", "d", "platform", "ctor", "coll", "config", "owner", "reader", "rider", "drive", "username", "river", "Driver", "desc"], "path": ["serial", "route", "test", "mount", "cross", "target", "key", "context", "device", "method", "host", "alias", "data", "url", "image", "loc", "parent", "pass", "inner", "Path", "sync", "source", "request", "pattern", "pointer", "config", "step", "work", "resource", "hop", "length", "child", "loader", "text", "object", "ath", "node", "prefix", "uri", "location", "full", "root", "dir", "desc", "input", "user", "port"], "id": ["route", "target", "key", "host", "sid", "image", "url", "tag", "kind", "head", "ID", "parent", "end", "ids", "code", "Id", "mid", "source", "pid", "ident", "address", "ip", "kid", "length", "uri", "dir", "port"], "dev": ["serial", "test", "local", "def", "device", "host", "data", "ver", "der", "Dev", "proc", "dest", "sync", "block", "cache", "node", "lib", "ev", "session", "dist", "engine", "debug", "root", "dir", "user"], "bus": ["serial", "unit", "route", "base", "test", "mount", "service", "http", "local", "build", "device", "Bus", "host", "hub", "class", "cat", "BUS", "bc", "boot", "loop", "pass", "phone", "proc", "plug", "sync", "coll", "bug", "project", "nt", "back", "config", "feed", "home", "block", "state", "us", "book", "child", "front", "cache", "drive", "object", "vc", "comment", "pull", "lib", "bridge", "plugin", "os", "session", "las", "product", "usb", "io", "root", "load", "board", "db", "port"], "err": ["ise", "ner", "gr", "rs", "Error", "rr", "der", "cur", "arr", "proc", "coll", "er", "ir", "cr", "str", "ah", "ch", "usr", "pr", "ar", "ev", "req", "error", "iter", "fi", "rh", "res"], "typename": ["tyrenamed", "tyename", "helpename", "typenames", "helperate", "tyrenname", "typamed", "tyrenamel", "typerename", "helpenate", "typedames", "cyperamed", "typedamed", "typamel", "typeame", "typame", "tyenate", "cypenname", "cyperame", "typedame", "tyrenename", "helperames", "typerames", "typedname", "tyrename", "typeramed", "tyenename", "cyperename", "typeamed", "helpenename", "sypenename", "cypenamed", "typenname", "cypenename", "helpenames", "typedate", "sypamel", "typeename", "tyenames", "sypename", "typenate", "typerame", "sypenamel", "sypamed", "cypename", "helperame", "cypername", "typedename", "sypenamed", "typenamed", "typenamel", "sypame", "typeamel", "typername", "typerate", "typenename", "helperename"]}}
{"project": "qemu", "commit_id": "dd09c36159858c66ab6e47c688e4177dd3912bf0", "target": 1, "func": "static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    gen_read_xer(cpu_gpr[gprn]);\n\n}\n", "idx": 13118, "substitutes": {"ctx": ["context", "tx", "cam", "pkg", "cm", "bc", "cv", "ca", "rc", "cc", "pc", "Context", "lc", "ctrl", "conv", "txt", "cmp", "abc", " cx", "conn", "grad", "cca", "c", "anc", "cb", "cas", "cp", "xc", "cpp"], "gprn": ["gPRr", "gPRn", "rgPRN", "gprr", "gPRns", "gPrN", "rgprN", " gprns", " gprN", "gprN", "gprne", "gPrn", "gPrne", "gprns", " gPrne", " gPrn", "rgprns", "rgPRns", "gPRne", "gPrr", "rgPRn", " gprne", "gPRN", "rgPRr", "rgprn", "gPrns", "rgprr", " gPrN", " gPrns"], "sprn": ["prb", "prr", "sprr", "sprN", "Sprr", "prn", " sprN", " sprr", " sprb", "SprN", "prN", "sprb", "Sprb", "Sprn"]}}
{"project": "qemu", "commit_id": "e78815a554adaa551d62a71be10ee2fcf128e473", "target": 1, "func": "int ram_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    ram_addr_t addr;\n\n    int flags;\n\n\n\n    if (version_id < 3 || version_id > 4) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    do {\n\n        addr = qemu_get_be64(f);\n\n\n\n        flags = addr & ~TARGET_PAGE_MASK;\n\n        addr &= TARGET_PAGE_MASK;\n\n\n\n        if (flags & RAM_SAVE_FLAG_MEM_SIZE) {\n\n            if (version_id == 3) {\n\n                if (addr != ram_bytes_total()) {\n\n                    return -EINVAL;\n\n                }\n\n            } else {\n\n                /* Synchronize RAM block list */\n\n                char id[256];\n\n                ram_addr_t length;\n\n                ram_addr_t total_ram_bytes = addr;\n\n\n\n                while (total_ram_bytes) {\n\n                    RAMBlock *block;\n\n                    uint8_t len;\n\n\n\n                    len = qemu_get_byte(f);\n\n                    qemu_get_buffer(f, (uint8_t *)id, len);\n\n                    id[len] = 0;\n\n                    length = qemu_get_be64(f);\n\n\n\n                    QLIST_FOREACH(block, &ram_list.blocks, next) {\n\n                        if (!strncmp(id, block->idstr, sizeof(id))) {\n\n                            if (block->length != length)\n\n                                return -EINVAL;\n\n                            break;\n\n                        }\n\n                    }\n\n\n\n                    if (!block) {\n\n                        fprintf(stderr, \"Unknown ramblock \\\"%s\\\", cannot \"\n\n                                \"accept migration\\n\", id);\n\n                        return -EINVAL;\n\n                    }\n\n\n\n                    total_ram_bytes -= length;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (flags & RAM_SAVE_FLAG_COMPRESS) {\n\n            void *host;\n\n            uint8_t ch;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            ch = qemu_get_byte(f);\n\n            memset(host, ch, TARGET_PAGE_SIZE);\n\n#ifndef _WIN32\n\n            if (ch == 0 &&\n\n                (!kvm_enabled() || kvm_has_sync_mmu())) {\n\n                madvise(host, TARGET_PAGE_SIZE, MADV_DONTNEED);\n\n            }\n\n#endif\n\n        } else if (flags & RAM_SAVE_FLAG_PAGE) {\n\n            void *host;\n\n\n\n            if (version_id == 3)\n\n                host = qemu_get_ram_ptr(addr);\n\n            else\n\n                host = host_from_stream_offset(f, addr, flags);\n\n\n\n            qemu_get_buffer(f, host, TARGET_PAGE_SIZE);\n\n        }\n\n        if (qemu_file_has_error(f)) {\n\n            return -EIO;\n\n        }\n\n    } while (!(flags & RAM_SAVE_FLAG_EOS));\n\n\n\n    return 0;\n\n}\n", "idx": 22381, "substitutes": {"f": ["fa", "fc", "i", "uf", "e", "fac", "fs", "g", "fb", "file", "d", "rf", "fp", "df", "t", "r", "m", "s", "j", "xf", "p", "fx", "cf", "inf", "c", "fe", "self", "fr", "tf", "form", "b", "fm", "fed", "ff", "fd", "F", "fw", "sf", "feed", "fen", "bf", "v", "conf", "lf", "fn", "h", "l", "fi", "fo", "elf"], "opaque": ["iopacity", "Ophole", "opacity", "iopaque", "iophole", "opshole", "Opque", "opsaque", "opsque", "ophole", "opsacity", "Opacity", "iopque", "Opaque", "opque"], "version_id": ["versionCvid", "version1num", "versionEname", "versionEid", "versionEkey", "versionPid", "versionedline", "version_ID", " versionekey", "versionervalue", "version_bit", "stage_line", "versionFvalue", "stageedid", "version_vid", "versioneid", "stageedvid", " versioneid", "version1version", "versioneedesc", "version1oid", "versionedid", "versionCdesc", "versionekey", " version_name", "version_aid", "versioneeid", "versioneeline", "versionerids", "stage_id", "servereroid", "version1id", "version_line", "versionCid", "stage_vid", "server_id", " version_ids", " version_ID", "versionCline", "version_index", "version_ids", "version_desc", "versionFid", "language_value", "version_version", "language_id", "stageedline", "versioneroid", "versionerversion", "language_ids", " version_index", "server_version", "serverernum", "versioneraid", "stageeddesc", "servererversion", "server_oid", "versionedvid", "version_key", "versionFids", " versionebit", "versionPindex", "versionernum", "servererid", "versionFaid", "versionPID", " version_bit", " versionename", "stage_desc", "version_num", "server_num", "versioneevid", "versionerid", "versionebit", "versioneddesc", "language_aid", "versionPids", "version_oid", "version_name", " version_key", "version_value", "versionEbit", "versionename"], "addr": ["config", "amp", "acl", "part", "ord", "afi", "amd", "pad", "buffer", "pos", "r", "address", "data", "ip", "prefix", "url", "alias", "src", "image", "attr", "ast", "asm", "ack", "oa", "height", "bb", "align", "node", "nl", "coord", "ac", "ad", "state", "opt", "fx", "code", "od", "mac", "buf", "filename", "ext", "arch", "rc", "rt", "back", "alt", "offset", "md", "ref", "adr", "mode", "rf", "layer", "cmp", "cmd", "size", "arr", "act", "ace", "p", "b", "ptr", " address", "fd", "inst", "loc", "x", "port", "start", "hop", "args", "dr", "index", "frame", "xp", "Address", "seq", "mask", "rss", "base", "padding"], "flags": ["config", "acl", "allows", "utf", "afi", "properties", "fg", "ils", "vals", "stats", "lag", "styles", "forces", "details", "fields", "ins", "rs", "ips", "format", "linux", "eth", "services", "bugs", "nl", "ids", "fps", "s", "fx", "ports", "Flags", "bits", "FLAG", "blocks", "requires", "utils", "options", "files", "offset", "tests", "fs", "rules", "ffff", "bytes", "heads", "xff", "ants", " bits", "groups", "fd", " Flags", "alls", "lf", "mods", "count", "versions", "types", "ints", "features", "locks", "ops", "plugins", "planes", "args", "strings", "vs", "settings", "rights", "frames", "reads", "flag", "seq", "fl", "mask", "links"], "id": ["ident", "like", "i", "name", "str", "start", "def", "end", "ref", "kid", "map", "part", "val", "key", "aid", "d", "uri", "pad", "bid", "no", "offset", "split", "path", "info", "ids", "bit", "Id", "address", "data", "ad", "stat", "head", "size", "lock", "link", "ip", "p", "count", "code", "body", "gen", "tag", "num", "frame", "oid", "ID", "a", "pid", "in", "line", "hash", "seq", "root", "r", "sid", "h", "image", "uid", "base", "url", "type"], "length": ["row", "name", "limit", "shape", "en", "end", "rows", "Length", "val", "part", "key", "message", "style", "l", "build", "buffer", "path", "split", "section", "info", "padding", "address", "size", "data", "sequence", "full", "lock", "ip", "link", "sum", "count", "number", "code", "load", "label", "index", "pl", "match", "capacity", "value", "line", "seq", "n", "ength", "loc", "slice", "partial", "up", "position", "offset", "base", "url", "type"], "block": ["bc", "inv", "row", "name", "limit", "prev", "def", "blocking", "object", "off", "end", "ref", "obj", "chain", "coll", "part", "none", "bin", "plugin", "bl", "node", "function", "cl", "buffer", "pos", "offset", "r", "bit", "address", "box", "data", "full", "lock", "ip", "unit", "label", "number", "point", "comment", "open", "frame", "num", "complete", "check", "byte", "b", "line", "blocks", "channel", "error", "child", "slice", "flow", "partial", "parent", "range", "group", "pack", "Block", "image", "base", "empty", "type"], "len": ["lc", "str", "limit", "en", "sl", "ind", "il", "val", "part", "ln", "bin", "bl", "offset", "pos", "lan", "pre", "size", "data", "rel", "lock", "lin", "label", "dy", "le", "el", "num", "line", "seq", "fl", "dl", "n", "slice", "loc", "den", "ler", "z", "li", "lf", "fn", "all", "lit", "l", "Len", "url", "count"], "host": ["port", "name", "target", "connect", "serv", "object", "conn", "ref", "config", "hop", "hard", "driver", "mount", "chan", "ich", "build", "node", "home", "xx", "path", "proxy", "address", "cp", "bug", "head", "patch", "ip", "component", "cf", "act", "machine", "work", "mac", "pool", "c", "arch", "localhost", "frame", "dr", "source", "comp", "service", "hub", "location", "channel", "Host", "loc", "cast", "th", "parent", "boot", "ce", "hw", "h", "server", "image", "url"], "ch": ["cha", "col", "sch", "chn", "sk", "conn", "ach", "ct", "cor", "chan", "eth", "ich", "anch", "Ch", "che", "cl", "cmp", "cp", "dev", "bug", "cht", "p", "CH", "cs", "code", "work", "q", "c", "arch", "ctx", "el", "sh", "tch", "channel", "gr", "chip", "zh", "th", "batch", "cher", "ech", "conf", "chrom", "bh", "h", "count"]}}
{"project": "qemu", "commit_id": "35b6e94ba50cd92600a85eef444bc31df8999de1", "target": 0, "func": "static uint32_t s390_pci_generate_fid(Error **errp)\n\n{\n\n    uint32_t fid = 0;\n\n\n\n    while (fid <= ZPCI_MAX_FID) {\n\n        if (!s390_pci_find_dev_by_fid(fid)) {\n\n            return fid;\n\n        }\n\n\n\n        if (fid == ZPCI_MAX_FID) {\n\n            break;\n\n        }\n\n\n\n        fid++;\n\n    }\n\n\n\n    error_setg(errp, \"no free fid could be found\");\n\n    return 0;\n\n}\n", "idx": 1351, "substitutes": {"errp": ["errP", "erc", "erP", "rorb", "rorlp", "errc", "erlp", "irr", "erb", "irpre", "rorp", "rrr", "rrc", "irc", "errb", " errlp", "err", " errP", "irp", "errr", "erpre", "erp", " errb", "errlp", "rrpre", "errpre", "rorP", "rrp"], "fid": [" fip", " fids", " fbid", "Fname", "dids", "lip", "fpid", "afid", "fkid", "afID", "lkid", "lfids", "gID", "tfID", "tfbid", "gid", " faid", "ifID", "lname", "lfid", "vids", "lfaid", "lid", "dbid", "did", "Fid", "gname", "tfid", "afbid", "gsid", " fname", "Faid", "ifsid", "ifname", "fID", "fids", "lbid", "FID", "frid", "Fids", "vbid", "vid", "Frid", "fname", " fpid", "Fbid", "lfrid", "ifid", "fbid", "lids", "vkid", "Fpid", " fID", "faid", "dkid", "afpid", "fsid", "fip", "tfip", " frid", " fsid", "lID"]}}
{"project": "qemu", "commit_id": "447b0d0b9ee8a0ac216c3186e0f3c427a1001f0c", "target": 1, "func": "static void flatview_ref(FlatView *view)\n\n{\n\n    atomic_inc(&view->ref);\n\n}\n", "idx": 19809, "substitutes": {"view": ["entry", "child", "name", "image", "comment", "action", "show", "see", "block", "match", "face", "node", "package", "index", "model", "watch", "object", "page", "link", "alias", "event", "build", "style", "use", "seen", "client", "update", "layout", "url", "feature", "http", "route", "VIEW", "form", "row", "template", "project", "server", "View", "source"]}}
{"project": "FFmpeg", "commit_id": "b6db385922b79939b0dc124d53ddb4824afac040", "target": 0, "func": "static void mmap_release_buffer(AVPacket *pkt)\n\n{\n\n    struct v4l2_buffer buf;\n\n    int res, fd;\n\n    struct buff_data *buf_descriptor = pkt->priv;\n\n\n\n    if (pkt->data == NULL)\n\n        return;\n\n\n\n    memset(&buf, 0, sizeof(struct v4l2_buffer));\n\n    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n    buf.memory = V4L2_MEMORY_MMAP;\n\n    buf.index = buf_descriptor->index;\n\n    fd = buf_descriptor->fd;\n\n    av_free(buf_descriptor);\n\n\n\n    res = ioctl(fd, VIDIOC_QBUF, &buf);\n\n    if (res < 0)\n\n        av_log(NULL, AV_LOG_ERROR, \"ioctl(VIDIOC_QBUF): %s\\n\",\n\n               strerror(errno));\n\n\n\n    pkt->data = NULL;\n\n    pkt->size = 0;\n\n}\n", "idx": 17534, "substitutes": {"pkt": ["tkg", "tacket", "fkt", "gpkt", "ppkg", "packer", "gpacket", "Packet", "tkt", "ppct", " pct", "packet", "Pcht", " packet", "ppkt", "pwk", "ppacket", "Pwk", " pcht", "facket", "Pkg", "pkg", "ppwk", " pwk", " packer", "fct", "pct", "fkg", "pcht", "Pkt", "Pct", " pkg", "Packer", "tacker", "gpkg", "gpcht"], "buf": ["Buffer", "br", "fw", "ff", "db", "func", "fp", "data", "base", "obj", "fam", "ref", "f", "pool", "buffer", "vec", "fi", "feed", "cf", "cb", "block", "bc", "src", "cp", "msg", "wb", "ctx", "Buff", "pb", "fab", "cas", "fx", "conv", "path", "pkg", "box", "aux", "flow", "img", "queue", "bd", "buff", "fb", "bh", "raf", "rb", "tmp", "cmd", "seq", "b", "cache", "cap", "fn", "alloc", " buffer", "bag", "uf", "cv"], "res": ["rx", "ret", "func", "rs", "obj", "err", "ras", "core", "reg", "results", "r", "rc", "result", "str", "rel", "nos", "rh", "resolution", "Res", "des", "RES", "resp", "arr", "ris", "css", "sol", "val", "re", "ress", "mr", "pre", "rar", "ex", "response", "rev", "cr", " Res", "js", "req", "rus", "rss", "Rs", "rez", "error", "red", "rep", "pres", "rem", "gr", "ver"], "fd": ["dc", "dd", "draft", "fw", "db", "pid", "ff", "func", "fp", "data", "f", "dir", "buffer", "fe", "md", "io", "file", "fun", "fa", "fi", "cf", "cb", "director", "fc", " fid", "fs", "dl", "ptr", "ind", "writer", "ld", "pointer", "lf", "cond", "exec", "fx", "d", "fl", "df", "format", "socket", "bd", "length", "id", "handler", "fb", "raf", "temp", "position", "flo", "fff", "driver", "fn", "cd", "connection", "port", "die", "uf", "FD", "sf"], "buf_descriptor": ["buf_descstructor", "buf_desriptractor", "buf_descriptour", "buf_desccriptor", "buf_desccriptractor", "buf_desriptore", "buf_descriptore", "buf_descriptors", "buf_deccriptors", "buf_descryptors", "buf_descryptractor", "buf_descributractor", "buf_descruction", "buf_descructor", "buf_desriptors", "buf_descryptour", "buf_desccriptors", "buf_decriptor", "buf_descributor", "buf_deccriptore", "buf_descryptor", "buf_descstructore", "buf_deccription", "buf_descributore", "buf_descorore", "buf_desccription", "buf_desccriptour", "buf_descoror", "buf_descorors", "buf_descriptractor", "buf_descributour", "buf_descructors", "buf_descstruction", "buf_desriptour", "buf_deccriptor", "buf_decription", "buf_description", "buf_descributors", "buf_decriptore", "buf_decriptors", "buf_descstructour", "buf_desriptor", "buf_descorractor", "buf_desccriptore", "buf_descstructors", "buf_descructore"]}}
{"project": "qemu", "commit_id": "ad11ad77748bdd8016370db210751683dc038dd6", "target": 0, "func": "static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd,\n\n                            abi_long cmd, abi_long arg)\n\n{\n\n    void *argptr;\n\n    struct dm_ioctl *host_dm;\n\n    abi_long guest_data;\n\n    uint32_t guest_data_size;\n\n    int target_size;\n\n    const argtype *arg_type = ie->arg_type;\n\n    abi_long ret;\n\n    void *big_buf = NULL;\n\n    char *host_data;\n\n\n\n    arg_type++;\n\n    target_size = thunk_type_size(arg_type, 0);\n\n    argptr = lock_user(VERIFY_READ, arg, target_size, 1);\n\n    if (!argptr) {\n\n        ret = -TARGET_EFAULT;\n\n        goto out;\n\n    }\n\n    thunk_convert(buf_temp, argptr, arg_type, THUNK_HOST);\n\n    unlock_user(argptr, arg, 0);\n\n\n\n    /* buf_temp is too small, so fetch things into a bigger buffer */\n\n    big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2);\n\n    memcpy(big_buf, buf_temp, target_size);\n\n    buf_temp = big_buf;\n\n    host_dm = big_buf;\n\n\n\n    guest_data = arg + host_dm->data_start;\n\n    if ((guest_data - arg) < 0) {\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n    guest_data_size = host_dm->data_size - host_dm->data_start;\n\n    host_data = (char*)host_dm + host_dm->data_start;\n\n\n\n    argptr = lock_user(VERIFY_READ, guest_data, guest_data_size, 1);\n\n    switch (ie->host_cmd) {\n\n    case DM_REMOVE_ALL:\n\n    case DM_LIST_DEVICES:\n\n    case DM_DEV_CREATE:\n\n    case DM_DEV_REMOVE:\n\n    case DM_DEV_SUSPEND:\n\n    case DM_DEV_STATUS:\n\n    case DM_DEV_WAIT:\n\n    case DM_TABLE_STATUS:\n\n    case DM_TABLE_CLEAR:\n\n    case DM_TABLE_DEPS:\n\n    case DM_LIST_VERSIONS:\n\n        /* no input data */\n\n        break;\n\n    case DM_DEV_RENAME:\n\n    case DM_DEV_SET_GEOMETRY:\n\n        /* data contains only strings */\n\n        memcpy(host_data, argptr, guest_data_size);\n\n        break;\n\n    case DM_TARGET_MSG:\n\n        memcpy(host_data, argptr, guest_data_size);\n\n        *(uint64_t*)host_data = tswap64(*(uint64_t*)argptr);\n\n        break;\n\n    case DM_TABLE_LOAD:\n\n    {\n\n        void *gspec = argptr;\n\n        void *cur_data = host_data;\n\n        const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };\n\n        int spec_size = thunk_type_size(arg_type, 0);\n\n        int i;\n\n\n\n        for (i = 0; i < host_dm->target_count; i++) {\n\n            struct dm_target_spec *spec = cur_data;\n\n            uint32_t next;\n\n            int slen;\n\n\n\n            thunk_convert(spec, gspec, arg_type, THUNK_HOST);\n\n            slen = strlen((char*)gspec + spec_size) + 1;\n\n            next = spec->next;\n\n            spec->next = sizeof(*spec) + slen;\n\n            strcpy((char*)&spec[1], gspec + spec_size);\n\n            gspec += next;\n\n            cur_data += spec->next;\n\n        }\n\n        break;\n\n    }\n\n    default:\n\n        ret = -TARGET_EINVAL;\n\n        goto out;\n\n    }\n\n    unlock_user(argptr, guest_data, 0);\n\n\n\n    ret = get_errno(ioctl(fd, ie->host_cmd, buf_temp));\n\n    if (!is_error(ret)) {\n\n        guest_data = arg + host_dm->data_start;\n\n        guest_data_size = host_dm->data_size - host_dm->data_start;\n\n        argptr = lock_user(VERIFY_WRITE, guest_data, guest_data_size, 0);\n\n        switch (ie->host_cmd) {\n\n        case DM_REMOVE_ALL:\n\n        case DM_DEV_CREATE:\n\n        case DM_DEV_REMOVE:\n\n        case DM_DEV_RENAME:\n\n        case DM_DEV_SUSPEND:\n\n        case DM_DEV_STATUS:\n\n        case DM_TABLE_LOAD:\n\n        case DM_TABLE_CLEAR:\n\n        case DM_TARGET_MSG:\n\n        case DM_DEV_SET_GEOMETRY:\n\n            /* no return data */\n\n            break;\n\n        case DM_LIST_DEVICES:\n\n        {\n\n            struct dm_name_list *nl = (void*)host_dm + host_dm->data_start;\n\n            uint32_t remaining_data = guest_data_size;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_name_list) };\n\n            int nl_size = 12; /* can't use thunk_size due to alignment */\n\n\n\n            while (1) {\n\n                uint32_t next = nl->next;\n\n                if (next) {\n\n                    nl->next = nl_size + (strlen(nl->name) + 1);\n\n                }\n\n                if (remaining_data < nl->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, nl, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + nl_size, nl->name);\n\n                cur_data += nl->next;\n\n                remaining_data -= nl->next;\n\n                if (!next) {\n\n                    break;\n\n                }\n\n                nl = (void*)nl + next;\n\n            }\n\n            break;\n\n        }\n\n        case DM_DEV_WAIT:\n\n        case DM_TABLE_STATUS:\n\n        {\n\n            struct dm_target_spec *spec = (void*)host_dm + host_dm->data_start;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };\n\n            int spec_size = thunk_type_size(arg_type, 0);\n\n            int i;\n\n\n\n            for (i = 0; i < host_dm->target_count; i++) {\n\n                uint32_t next = spec->next;\n\n                int slen = strlen((char*)&spec[1]) + 1;\n\n                spec->next = (cur_data - argptr) + spec_size + slen;\n\n                if (guest_data_size < spec->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, spec, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + spec_size, (char*)&spec[1]);\n\n                cur_data = argptr + spec->next;\n\n                spec = (void*)host_dm + host_dm->data_start + next;\n\n            }\n\n            break;\n\n        }\n\n        case DM_TABLE_DEPS:\n\n        {\n\n            void *hdata = (void*)host_dm + host_dm->data_start;\n\n            int count = *(uint32_t*)hdata;\n\n            uint64_t *hdev = hdata + 8;\n\n            uint64_t *gdev = argptr + 8;\n\n            int i;\n\n\n\n            *(uint32_t*)argptr = tswap32(count);\n\n            for (i = 0; i < count; i++) {\n\n                *gdev = tswap64(*hdev);\n\n                gdev++;\n\n                hdev++;\n\n            }\n\n            break;\n\n        }\n\n        case DM_LIST_VERSIONS:\n\n        {\n\n            struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start;\n\n            uint32_t remaining_data = guest_data_size;\n\n            void *cur_data = argptr;\n\n            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_versions) };\n\n            int vers_size = thunk_type_size(arg_type, 0);\n\n\n\n            while (1) {\n\n                uint32_t next = vers->next;\n\n                if (next) {\n\n                    vers->next = vers_size + (strlen(vers->name) + 1);\n\n                }\n\n                if (remaining_data < vers->next) {\n\n                    host_dm->flags |= DM_BUFFER_FULL_FLAG;\n\n                    break;\n\n                }\n\n                thunk_convert(cur_data, vers, arg_type, THUNK_TARGET);\n\n                strcpy(cur_data + vers_size, vers->name);\n\n                cur_data += vers->next;\n\n                remaining_data -= vers->next;\n\n                if (!next) {\n\n                    break;\n\n                }\n\n                vers = (void*)vers + next;\n\n            }\n\n            break;\n\n        }\n\n        default:\n\n            ret = -TARGET_EINVAL;\n\n            goto out;\n\n        }\n\n        unlock_user(argptr, guest_data, guest_data_size);\n\n\n\n        argptr = lock_user(VERIFY_WRITE, arg, target_size, 0);\n\n        if (!argptr) {\n\n            ret = -TARGET_EFAULT;\n\n            goto out;\n\n        }\n\n        thunk_convert(argptr, buf_temp, arg_type, THUNK_TARGET);\n\n        unlock_user(argptr, arg, target_size);\n\n    }\n\nout:\n\n    if (big_buf) {\n\n        free(big_buf);\n\n    }\n\n    return ret;\n\n}\n", "idx": 10485, "substitutes": {"ie": ["ani", "zip", "ee", "ide", "qt", "je", "le", "img", "ext", "ife", "nice", "die", "ite", "ini", "job", "ne", "oe", "IE", "isi", "lit", "e", "cli", "ace", "fit", "lex", "plug", "ze", "ec", "eni", "oci", "nat", "pie", "ice", "eg", "eb", "edge", "ig", "ce", "lie", "sie", "exe", "intel", "ei", "ii", "ime", "li", "irc", "ip", "ci", "ge", "ni", "ine", "tie", "iu"], "buf_temp": ["buf_test", " buf_test", "uf_tem", "uf_num", "buf_tmp", " buf_cache", "buf_cache", "uf_temp", "buflextest", "buf_base", "buff_orig", "uf_buffer", " buf_current", "bufjorig", "buf1num", " buf_tem", "buff_temp", "buf_orig", "buf_num", " buf_tmp", "bufjtemp", "bufjporary", "buf_buffer", "buflexcurrent", "buff_tem", "buf1temp", "buff_porary", "buf_porary", "buflextemp", "buff_base", "buf1tem", "buflextem", "buff_cache", "bufjtem", "buf1buffer", "buf_current", "buf_tem"], "fd": ["std", "ds", "win", "def", "d", " fid", " fs", "ffff", " f", " def", "f", "df", "iff", "rc", " dc", "fff", "FD", "dc", " FD", "enc", "fin", "nc", "file", "Arg", "fi", "fe", "fc"], "cmd": ["mac", "seq", "gen", "gd", "cmp", "window", "def", "conn", "method", "buf", "config", "cb", "cli", "mode", "ctl", "ctr", "opt", "msg", "md", "Cmd", "desc", "dc", "cat", "cfg", "command", "client", "header", "alg", "bind"], "arg": ["mac", "arc", "arr", "param", "byte", "argument", "flag", "ext", "str", "g", "val", "len", "win", "pad", "nt", "ang", "num", "mem", "var", "ad", "doc", "slot", "addr", "ref", "ace", "target", "reg", "star", "amd", "ag", "args", "loc", "prop", "sec", "gt", "dr", "entry", "call", "index", "amp", "msg", "parse", "ig", "input", "inc", "ar", "end", "load", "nick", "enc", "bit", "init", "cat", "use", "result", "Arg", "gen", "inter", "exec"], "argptr": ["argumentptr", "argspad", " argbf", "arrot", "argpt", "argpointers", "paramPtr", "docpt", "arpt", "inptr", " argrot", "argbf", "arPtr", "argumentpointer", " argpointers", "parptr", "docptr", "parPtr", "argumentPtr", "docPtr", "ackptr", "ackpointer", "ackPtr", "parpointer", "paramptr", "Argpad", "inpointers", "argspointer", "ArgPtr", "parambf", " argpad", "Argrot", " argPtr", "arpointer", "arptr", "argfp", "Argpointer", "argPtr", "argrot", "argumentbf", "ackrot", "argsPtr", "argpointer", "parpointers", "Argptr", "paramfp", " argfp", "argumentfp", "docpointer", "argpad", "inpointer", "inPtr", " argpt", " argpointer", "argumentrot", "argsptr"], "host_dm": [" host_nm", "hostPooldom", "hostalldt", "host_dt", "host_cm", "host_module", "hostalldm", "hard_fm", "host__dt", "server_dt", " host_dom", " host_bm", "host_dc", "port_md", "hostallfm", "hostPoolbm", "client_dn", "Host_dm", " host_db", "host_dim", "host_metadata", "hostacdn", "host__module", "Host_cm", "hostingdl", "hard_dm", "server_data", "host_bm", "host_dl", "server_dm", "server_fm", " host_dt", "client_dl", "host__dim", "client_metadata", "hostacdl", "host_nm", "hostPooldm", "host_db", "hard_module", "hostalldata", "client_dm", "Host_dt", " host_fm", "port_dm", "port_dim", "hostingdm", "hostingmetadata", "hard_dim", "host_fm", "host_dom", "host__dm", "port_dc", "Host_fm", "host__data", "host_dn", "host_md", "hostacmetadata", "hostacdm", "host__fm", "hostingdn", "hostPooldb"], "guest_data": ["guestingbuf", "guestingData", "guest_di", "guest_size", "guestingdat", "guest_buf", "guesting_dat", "guesta_alpha", "guestingiondat", "guestingdata", "guest__data", "guestfulldi", "guest__Data", "guestiondef", "guest_alpha", "guestfulldata", "guester_buf", "guestiondata", "guesta_data", "guester_size", "guestinglength", "guest2Data", "guesting_def", "guestiondi", "guestiondat", "guester_Data", "guest__size", "guest_length", "guesting_di", "guesta_dat", "guester_data", "guester_dat", "guest_dat", "guest__dat", "guest_Data", "guestfulldef", "guestingiondef", "guesting_data", "guestingiondi", "guest2data", "guest2buf", "guestingalpha", "guest_def", "guesta_length", "guest2dat", "guestingiondata", "guestfulldat"], "guest_data_size": ["guest_action_capacity", "guest_data_capacity", "guest_Data_length", "guest_Data_size", "guest_data_form", "guest_data_length", "guest_data_pos", "guest_action_form", "guest_data_start", "guest_action_pos", "guest_Data_start", "guest_data_address", "guest_Data_address", "guest_action_size", "guest_Data_scale", "guest_data_scale"], "target_size": ["arget_len", "arget_size", " target_start", "target64len", "target64size", "target64capacity", "targetedsize", "arget_name", "arget_capacity", " target_name", "arget_sized", "targetedstart", " target_sn", "target_len", "targetedname", "arget_start", "target64sized", "target_start", "target_name", "target_SIZE", "target_capacity", "target_sized", "target_sn", " target_SIZE"], "arg_type": ["arg_typ", " arg_num", "argvtype", "arg_order", "err_type", "int_type", "arglexrole", "int_role", "arg_spec", "arg_width", "cat_spec", "arg_num", "cat_name", "argxtype", "arglextype", "argfname", "argfformat", " arg_size", "argvname", "argxname", "errlentyp", "int_types", "arglentype", "arg_size", "argrtype", "argargorder", "argvwidth", "argxnum", "argrname", "err_name", "arg_format", "arglentyp", "argrsize", " arg_format", "arglextypes", "arg_role", "arglenname", "errlenname", "arg_name", "arg_types", "arglexorder", "int_order", "err_typ", "argxsize", "argargtypes", "argargrole", "cat_width", "argargtype", "argrnum", "errlentype", "argftype", " arg_name", "cat_type", "argvspec"], "ret": ["seq", "flag", "debug", "alt", "val", "len", "def", "nt", "Ret", "num", "mem", "job", "pat", "reply", "output", "ref", "lit", "reg", "usr", "gt", "rets", "sec", "ut", "rt", "res", "eval", "det", "opt", "rc", "fun", "att", "hash", "bit", "cat", "gc", "re", "RET", "back", "let", "result", "rev", "ft", "resp", "feat", "mt", "buffer", "match", "success"], "big_buf": ["real_buffer", "real_buf", "big54bu", " big_buff", "big_bu", "big___batch", "real_buff", "big54buff", "real___buf", "big_tmp", "real___buffer", "big___bu", "bigxbuff", "real_batch", "home_buf", "big__buf", " big_vec", "big__buff", "big54vec", "bigxuf", "home54buffer", "home54tmp", " big_tmp", "bigxbuf", "big_uf", " big_buffer", " big_uf", "big___buffer", "big_vec", "home_buffer", "bigxtmp", "big_batch", "big54buf", "big_buffer", "big_buff", "home54uf", " big_bu", "home_tmp", "home54buf", "big54buffer", "big__uf", "big___buf", "big__buffer", "home_uf", "big54uf", "big___buff", "real___buff", "big54tmp", "big___vec", "real___batch"], "host_data": [" host_slice", " host_dat", "hostsdat", "master_addr", "hostsdata", "host_dat", "host_size", "hostssize", "hostacslice", "master_data", "hostacdata", "host_addr", "master_size", "hostacdat", "hostacdm", "host_slice", "master_dat", "hostsaddr"]}}
{"project": "qemu", "commit_id": "a890643958f03aaa344290700093b280cb606c28", "target": 1, "func": "static bool qht_insert__locked(struct qht *ht, struct qht_map *map,\n\n                               struct qht_bucket *head, void *p, uint32_t hash,\n\n                               bool *needs_resize)\n\n{\n\n    struct qht_bucket *b = head;\n\n    struct qht_bucket *prev = NULL;\n\n    struct qht_bucket *new = NULL;\n\n    int i;\n\n\n\n    do {\n\n        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {\n\n            if (b->pointers[i]) {\n\n                if (unlikely(b->pointers[i] == p)) {\n\n                    return false;\n\n                }\n\n            } else {\n\n                goto found;\n\n            }\n\n        }\n\n        prev = b;\n\n        b = b->next;\n\n    } while (b);\n\n\n\n    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));\n\n    memset(b, 0, sizeof(*b));\n\n    new = b;\n\n    i = 0;\n\n    atomic_inc(&map->n_added_buckets);\n\n    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {\n\n        *needs_resize = true;\n\n    }\n\n\n\n found:\n\n    /* found an empty key: acquire the seqlock and write */\n\n    seqlock_write_begin(&head->sequence);\n\n    if (new) {\n\n        atomic_rcu_set(&prev->next, b);\n\n    }\n\n    b->hashes[i] = hash;\n\n    /* smp_wmb() implicit in seqlock_write_begin.  */\n\n    atomic_set(&b->pointers[i], p);\n\n    seqlock_write_end(&head->sequence);\n\n    return true;\n\n}\n", "idx": 7191, "substitutes": {"ht": ["H", "hp", "hw", "ch", "http", "bt", "mat", "bm", "rh", "att", "hs", "hm", "sh", "hh", "cmd", "h", "hold", "gh", "bf", "ct", "hip", "ac", "cache", "ha", "host", "bh", "hard", "dict"], "map": ["master", "address", "header", "block", "change", "open", "parent", "scope", "config", "pre", "op", "sche", "data", "use", "ap", "co", "module", "m", "holder", "cl", "mp", "maps", "meta", "MAP", "table", "code", "file", "apper", "self", "lock", "work", "bridge", "node", "cap", "rule", "link", "bl", "pl", "cache", "app", "ref", "Map"], "head": ["master", "hook", "name", "Head", "header", "block", "id", "parent", "check", "tail", "config", "op", "ad", "body", "commit", "holder", "before", "client", "foot", "post", "heads", "d", "ack", "ck", "da", "HEAD", "path", "first", "self", "load", "root", "h", "run", "start", "fix", "back", "c", "off", "link", "front", "cache", "next", "set", "index", "host", "src", "conn", "end", "view", "dict"], "p": ["patch", "cp", "P", "o", "bp", "padding", "v", "pin", "pa", "pre", "pp", "ping", "ap", "m", "before", "f", "pg", "d", "j", "pc", "q", "e", "point", "w", "port", "t", "n", "pad", "fp", "jp", "pool", "h", "sp", "pos", "pointer", "c", "ip", "tp", "pair", "pb", "r"], "hash": ["base", "address", "cmp", "header", "block", "al", "change", "count", "id", "Hash", "final", "oh", "ap", "image", "rh", "key", "num", "kh", "version", "number", "depth", "height", " h", "prefix", "array", "pool", "sha", "h", "prop", "pointer", "memory", "node", "ip", "bf", "ash", "cache", "ashes", "ref", "index", "pkg", "shift", "ashing", "ump"], "needs_resize": ["needs_hardizing", "needs_resiz", "needs_hesizing", "needs_realizer", "needs_realize", "needs_hesiz", "needs_reiz", "needs_realizing", "needs_normalizer", "needs_resizer", "needs_reample", "needs_normaliz", "needs_normalize", "needs_resizing", "needs_reize", "needs_hardize", "needs_resetizing", "needs_hardiz", "needs_resample", "needs_rescale", "needs_reizing", "needs_hesize", "needs_realiz", "needs_hardcale", "needs_realcale", "needs_normalcale", "needs_resetiz", "needs_realample", "needs_resetize", "needs_hescale", "needs_resetample", "needs_hesizer"], "b": ["base", "o", "bp", "lb", "buff", "ib", "emb", "v", "bin", "block", "a", "bd", "http", "s", "rb", "bt", "ob", "bi", "m", "body", "orb", "fb", "l", "db", "wb", "f", "abb", "d", "obj", "bu", "bs", "bb", "e", "sb", "w", "k", "lib", "n", "ab", "cb", "B", "bc", "nb", "ba", "mb", "old", "this", "be", "h", "boot", "gb", "c", "g", "bf", "y", "br", "bl", "next", "pb", "app", "r", "bh", "bar"], "prev": ["cmp", "bp", "header", "bin", "v", "cur", "block", "parent", "rb", "pre", "op", "record", "rel", "loc", "reverse", "before", "buf", "mp", "post", "book", "original", "bb", "Prev", "existing", "cb", "self", "rev", "pres", "old", "root", "h", "batch", "iv", "re", "nav", "var", "vious", "orig", "back", "next", "current", "pb", "ref", "r", "rec", "first"], "new": ["base", "name", "row", "o", "v", "block", "a", "NEW", "update", "bug", "now", "normal", "fresh", "New", "m", "missing", "before", "valid", "known", "f", "make", "d", "j", "create", "w", "raw", "n", "other", "self", "old", "end", "root", "h", "un", "re", "gen", "node", "c", "g", "ew", "next", "r", "big", "diff", "first", "add"], "i": ["base", "gi", "o", "ti", "v", "id", "I", "a", "di", "s", "ci", "ji", "ni", "x", "xi", "si", "io", "ri", "slice", "bi", "m", "in", "qi", "ix", "l", "f", "pi", "d", "ii", "j", "iu", "it", "ai", "u", "e", "ami", "uri", "k", "t", "n", "multi", "ini", "ie", "z", "eni", "start", "oi", "hi", "ind", "ip", "c", "y", "api", "li", "fi", "index", "zi", "mu", "ui"]}}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,\n\n                                      CL_TRUE,CL_MAP_READ, 0, buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(dst_buf, mapped, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n", "idx": 18304, "substitutes": {"dst_buf": ["dsrc_buf", "dsrc_queue", "dst_buff", "dst_queue", "drc_buffer", "dsrc_buff", "drc_queue", "dsrc_buffer", "dst_buffer", "drc_buff", "drc_buf"], "src_cl_buf": ["src_clpbuf", "src_pl_cb", "src_clpbuff", "src_cl_uf", "src_cl_queue", "src_cl_buff", "src_clmbuffer", "src_cl_buffer", "src_clpuf", "src_pl_buff", "src_pl_uf", "src_cl_cb", "src_clmbuf", "src_pl_buffer", "src_clmbuff", "src_clpcb", "src_pl_queue", "src_clpbuffer", "src_clmuf", "src_pl_buf"], "buf_size": [" buf_Size", "buflenSize", "buf2size", "buf_capacity", "buf_num", "buf_len", "buf2len", "buf_send", " buf_send", " buf_num", "buf_Size", " buf2size", " buf_capacity", "buflensend", " buf_len", " buf2len", "buflensize", "buflenlen", " buf2capacity", "buf2capacity"], "status": ["html", "spec", "stat", "skip", "full", "comment", "settings", " Status", "service", "ity", "result", "num", "java", "ss", "score", "id", "cli", "temp", "xml", "source", "example", "name", "msg", "magic", "summary", "size", "pre", "received", "Status", "update", "si", "stage", "uses", "gly", "reason", "process", "sex", "code", "expr", "err", "image", "json", "login", "sb", "current", "type", "date", " stat", "speed", "security", "sr", "start", "sync", "wrapper", "state", "progress", "success", "session", "s", "stats", "sp", "gc", "wait", "sw", "sl", "STAT", "index", "complete", "step", "args", "response", "ssl", "js", "url", "error", " success", "server"], "mapped": ["mmaped", "maped", "mached", "cmaped", "mmapped", "smapped", "cmached", "smaked", "smaped", "smapping", "mapping", "Mapped", "cmamped", "mmamped", "smoved", "Mached", "mmached", " moved", "mamped", "smached", "maked", "Mapping", "Maked", " mached", "Maped", " maked", " maped", " mapping", "Moved", "moved", "cmapped", "Mamped"]}}
{"project": "FFmpeg", "commit_id": "7b94df232a4b76c44e243e618573f8d331a1eb1c", "target": 0, "func": "static int srt_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *got_sub_ptr, AVPacket *avpkt)\n\n{\n\n    AVSubtitle *sub = data;\n\n    AVBPrint buffer;\n\n    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;\n\n    int size, ret;\n\n    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);\n\n    FFASSDecoderContext *s = avctx->priv_data;\n\n\n\n    if (p && size == 16) {\n\n        x1 = AV_RL32(p     );\n\n        y1 = AV_RL32(p +  4);\n\n        x2 = AV_RL32(p +  8);\n\n        y2 = AV_RL32(p + 12);\n\n    }\n\n\n\n    if (avpkt->size <= 0)\n\n        return avpkt->size;\n\n\n\n    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);\n\n\n\n    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);\n\n    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);\n\n    av_bprint_finalize(&buffer, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    *got_sub_ptr = sub->num_rects > 0;\n\n    return avpkt->size;\n\n}\n", "idx": 6708, "substitutes": {"avctx": [" avcontext", " avcmp", " avcv", "evconn", " avcoll", "AVcv", "evcmp", "AVcoll", "afcv", "AVctx", "evcontext", "afcmp", "AVcontext", "avcmp", "avcoll", "afctx", "avcv", "avcontext", "AVcmp", "afcoll", "afconn", "afcontext", "AVconn", "avconn", "evctx"], "data": ["base", "address", "as", "name", "append", "feed", "header", "block", "id", "a", "parent", "dat", "value", "device", "object", "slice", "format", "ad", "record", "body", "image", "map", "buf", "window", "draw", "package", "content", "parts", "media", "d", "DATA", "code", "da", "message", "raw", "ata", "Data", "pad", "empty", "exec", "str", "load", "result", "input", "reader", "start", "pos", "primary", "sample", "inner", "cache", "next", "rec", "first", "ui"], "got_sub_ptr": ["got_subfptr", "got_sub_rect", "got_subqdesc", "got_subuchar", "got_subftr", "got_subvalchar", "got_subqtr", "got_subqrect", "got_sub_tr", "got_sub_pointer", "got_sub_desc", "got_subulength", "got_reg2desc", "got_subvalptr", "got_subvallength", "got_reg_ptr", "got_reg2rect", "got_sub2rect", "got_subqptr", "got_reg_tr", "got_subfdesc", "got_sub2tr", "got_subfrect", "got_subvalpointer", "got_subuptr", "got_reg2ptr", "got_reg_rect", "got_reg_desc", "got_sub2desc", "got_reg2tr", "got_subupointer", "got_sub_char", "got_sub_length", "got_sub2ptr"], "avpkt": ["awwpacket", "affett", "awwpcht", "avPkt", "AVcpacket", "avcpacket", "AVcpct", "afpacket", "avpedt", "avcpck", "avspki", "avespdt", "avpck", "avopacket", "avprent", "avprekt", "avcpkg", "avpett", "avPacket", "avfcht", "avepft", "affki", "AVpkt", "avopkt", "avfkt", "avwpacket", "avespcht", "avwpkt", "avpredt", "AVcpkg", "avPct", "awpcht", "avepreft", "avppft", "affkt", "aveprent", "avfdt", "avppnt", "avfki", "avwpcht", "avfpacket", "afpett", "avspdt", "avpki", "avespacket", "avfacket", "avfpkg", "avwpck", "awpacket", "avespkt", "avpct", "avfpct", "avppkt", "avbpacket", "avepacket", "avfett", "avcpct", "AVpacket", "avopdt", "avcpcht", "awwpkt", "avPck", "afpki", "avbpdt", "avbpkt", "awpck", "awwpck", "avpdt", "avopett", "AVpkg", "avfpkt", "AVpct", "avepredt", "avepdt", "AVcpkt", "avpacket", "avpekt", "avbpcht", "avpft", "avpreft", "avpnt", "avpeacket", "avspkt", "afpkt", "avcpkt", "avpeki", "aveprekt", "avspacket", "avepcht", "avepnt", "avPkg", "avPcht", "afpdt", "avpkg", "awpkt", "avppdt", "avpcht", "avcpdt", "avspett", "avepkt", "affdt", "avspcht", "avcpnt", "avcpft", "affacket"], "sub": ["name", "sec", "builder", "pre", "config", "b", "slice", "rc", "info", "uc", "buf", "job", "child", "j", "sl", "small", "match", "member", "split", "part", "sc", "per", "section", "func", "ab", "sp", "sup", "sa", "ub", "sel", "type", "Sub", "text", "pl", "pb", "desc", "form", "r", "summary", "rec", "super"], "buffer": ["writer", "base", "row", "position", "buff", "header", "iter", "v", " Buffer", "builder", "seek", "uffer", "b", "slice", "stream", "record", "queue", "m", "buf", "window", "uf", "null", "f", "server", "table", "byte", "sc", "parser", "file", "Buffer", "message", "binary", "pad", "bc", "fp", "str", "source", "context", "input", "processor", "surface", "FFER", "reader", "array", "batch", "ptr", "transfer", "pointer", "read", "result", "text", "cache", "ref", "reference", "summary", "copy"], "size": ["position", "large", "shape", "ci", "x", "password", "unit", "f", "original", "code", "len", "any", "esc", "empty", "g", "page", "general", "max", "scene", "name", "SIZE", "extra", "count", "channel", "send", "sum", "last", "capacity", "grade", "member", "number", "sized", "scale", "type", "form", "ui", "external", "uni", "address", "sec", "rc", "use", "sn", "loc", "small", "Size", "from", "e", "en", "source", "year", "pos", "c", "core", "cache", "body", "offset", "length", "args", "storage", "ize"], "ret": ["std", "base", "flag", "reg", "rt", "al", "id", "alt", "nt", "tmp", "val", "last", "rc", "reply", "valid", "db", "num", "lit", "ext", "att", "url", "obj", "arg", "res", "match", "def", "code", "len", "mt", "det", "error", "en", "full", "RET", "err", "str", "rev", "result", "Ret", "ft", "re", "fun", "back", "resp", "success", "ref", "no", "r", "rem", "rets"], "p": ["cp", "P", "o", "bp", "v", "pa", "x", "pre", "po", "b", "pp", "i", "op", "wp", "up", "pe", "lp", "ap", "m", "l", "f", "pi", "at", "post", "j", "d", "pc", "py", "np", "u", "e", "point", "part", "w", "per", "port", "t", "n", "ctx", "pad", "h", "sp", "pointer", "c", "ip", "g", "api", "tp", "current", "r"], "s": ["sf", "sec", "v", "is", "S", "spec", "sg", "b", "si", "sys", "ses", "m", "f", "ns", "server", "space", "service", "cs", "ss", "sc", "parser", "gs", "ops", "sb", "qs", "storage", "ctx", "su", "self", "context", "sv", "fs", "c", "g", "ssl", "sq", "api", "r", "ps"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_register_reset(QEMUResetHandler *func, void *opaque)\n\n{\n\n    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));\n\n\n\n    re->func = func;\n\n    re->opaque = opaque;\n\n    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);\n\n}\n", "idx": 13513, "substitutes": {"func": ["args", "proc", "pkg", "unc", "amd", "pc", "val", "code", "name", "fun", "fp", "fn", "job", "package", "conn", "obj", "super", "handler", "rb", "rx", "buf", "data", "entry", "f", "rl", "parser", "cb", "function", "attr", "rule", "cmd", "cf", "aux", "wrapper", "exec", "ack", "r", "src", "work", "wrap", "lambda", "addr", "apply", "ctx", "go", "callback"], "opaque": ["opace", " opaques", "oppaco", "ipesc", "opesc", "oppesc", "operaco", "ipaco", "oppacity", "oacity", "oaques", "oaque", "hopaques", "oppaque", "operacity", "opericit", "hopaque", "opaco", "opaques", "oicit", "operaque", " opicit", "ipacity", "hopace", "opacity", "ipaque", "operque", "operesc", " opque", "opque", " opacity", "oace", "hopacity", "oque", " opace", "opicit"], "re": ["record", "ret", "bre", "rev", "ru", "reply", "reb", "array", "response", "ere", "ren", "rs", "pre", "g", "rg", "ref", "cre", "fr", "parse", " rec", "rec", "e", "rew", "resource", "entry", "Rec", "rm", "reset", "arr", "ry", "per", "ro", "change", "rule", "rt", "r", "resp", "cache", "ae", "Re", "ar", "real", "dr", "res", "rel", "reg", "rem", "gre", "RE", "replace"]}}
{"project": "qemu", "commit_id": "1e5ffbedded7ded797f5042d82b70109a712b4c0", "target": 1, "func": "void helper_frndint(void)\n\n{\n\n    ST0 = rint(ST0);\n\n}\n", "idx": 5408, "substitutes": {}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void stellaris_init(const char *kernel_filename, const char *cpu_model,\n\n                           stellaris_board_info *board)\n\n{\n\n    static const int uart_irq[] = {5, 6, 33, 34};\n\n    static const int timer_irq[] = {19, 21, 23, 35};\n\n    static const uint32_t gpio_addr[7] =\n\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n\n        0x40024000, 0x40025000, 0x40026000};\n\n    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};\n\n\n\n    qemu_irq *pic;\n\n    DeviceState *gpio_dev[7];\n\n    qemu_irq gpio_in[7][8];\n\n    qemu_irq gpio_out[7][8];\n\n    qemu_irq adc;\n\n    int sram_size;\n\n    int flash_size;\n\n    I2CBus *i2c;\n\n    DeviceState *dev;\n\n    int i;\n\n    int j;\n\n\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *flash = g_new(MemoryRegion, 1);\n\n    MemoryRegion *system_memory = get_system_memory();\n\n\n\n    flash_size = (((board->dc0 & 0xffff) + 1) << 1) * 1024;\n\n    sram_size = ((board->dc0 >> 18) + 1) * 1024;\n\n\n\n    /* Flash programming is done via the SCU, so pretend it is ROM.  */\n\n    memory_region_init_ram(flash, NULL, \"stellaris.flash\", flash_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(flash);\n\n    memory_region_set_readonly(flash, true);\n\n    memory_region_add_subregion(system_memory, 0, flash);\n\n\n\n    memory_region_init_ram(sram, NULL, \"stellaris.sram\", sram_size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(sram);\n\n    memory_region_add_subregion(system_memory, 0x20000000, sram);\n\n\n\n    pic = armv7m_init(system_memory, flash_size, NUM_IRQ_LINES,\n\n                      kernel_filename, cpu_model);\n\n\n\n    if (board->dc1 & (1 << 16)) {\n\n        dev = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000,\n\n                                    pic[14], pic[15], pic[16], pic[17], NULL);\n\n        adc = qdev_get_gpio_in(dev, 0);\n\n    } else {\n\n        adc = NULL;\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (0x10000 << i)) {\n\n            dev = sysbus_create_simple(TYPE_STELLARIS_GPTM,\n\n                                       0x40030000 + i * 0x1000,\n\n                                       pic[timer_irq[i]]);\n\n            /* TODO: This is incorrect, but we get away with it because\n\n               the ADC output is only ever pulsed.  */\n\n            qdev_connect_gpio_out(dev, 0, adc);\n\n        }\n\n    }\n\n\n\n    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr.a);\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            gpio_dev[i] = sysbus_create_simple(\"pl061_luminary\", gpio_addr[i],\n\n                                               pic[gpio_irq[i]]);\n\n            for (j = 0; j < 8; j++) {\n\n                gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j);\n\n                gpio_out[i][j] = NULL;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (board->dc2 & (1 << 12)) {\n\n        dev = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]);\n\n        i2c = (I2CBus *)qdev_get_child_bus(dev, \"i2c\");\n\n        if (board->peripherals & BP_OLED_I2C) {\n\n            i2c_create_slave(i2c, \"ssd0303\", 0x3d);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (1 << i)) {\n\n            sysbus_create_simple(\"pl011_luminary\", 0x4000c000 + i * 0x1000,\n\n                                 pic[uart_irq[i]]);\n\n        }\n\n    }\n\n    if (board->dc2 & (1 << 4)) {\n\n        dev = sysbus_create_simple(\"pl022\", 0x40008000, pic[7]);\n\n        if (board->peripherals & BP_OLED_SSI) {\n\n            void *bus;\n\n            DeviceState *sddev;\n\n            DeviceState *ssddev;\n\n\n\n            /* Some boards have both an OLED controller and SD card connected to\n\n             * the same SSI port, with the SD card chip select connected to a\n\n             * GPIO pin.  Technically the OLED chip select is connected to the\n\n             * SSI Fss pin.  We do not bother emulating that as both devices\n\n             * should never be selected simultaneously, and our OLED controller\n\n             * ignores stray 0xff commands that occur when deselecting the SD\n\n             * card.\n\n             */\n\n            bus = qdev_get_child_bus(dev, \"ssi\");\n\n\n\n            sddev = ssi_create_slave(bus, \"ssi-sd\");\n\n            ssddev = ssi_create_slave(bus, \"ssd0323\");\n\n            gpio_out[GPIO_D][0] = qemu_irq_split(\n\n                    qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0),\n\n                    qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0));\n\n            gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0);\n\n\n\n            /* Make sure the select pin is high.  */\n\n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n\n        }\n\n    }\n\n    if (board->dc4 & (1 << 28)) {\n\n        DeviceState *enet;\n\n\n\n        qemu_check_nic_model(&nd_table[0], \"stellaris\");\n\n\n\n        enet = qdev_create(NULL, \"stellaris_enet\");\n\n        qdev_set_nic_properties(enet, &nd_table[0]);\n\n        qdev_init_nofail(enet);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]);\n\n    }\n\n    if (board->peripherals & BP_GAMEPAD) {\n\n        qemu_irq gpad_irq[5];\n\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n\n\n\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */\n\n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */\n\n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */\n\n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */\n\n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */\n\n\n\n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n\n    }\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            for (j = 0; j < 8; j++) {\n\n                if (gpio_out[i][j]) {\n\n                    qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 2329, "substitutes": {"kernel_filename": ["kernelprofunction", "kernelmprefix", "kernel_file", "kernel__filename", "kernelminformation", "system_file", "kernel_information", "kernelmfile", "kernelmfilename", "kernel_function", "system_function", "system_information", "kernel__file", "kernel__information", "kernelprofil", "kernelprofile", "kernel_fil", "kernel__prefix", "system_fil", "system_prefix", "system_filename", "kernel_prefix", "kernelprofilename"], "cpu_model": ["cpu_models", " cpu_module", " cpu_description", "cpuingdescription", "linuxloglocation", "cpu_filename", "linuxlogmodel", "linux_model", "linuxlogfile", "cpuemdescription", "linux_file", "cpuemmodule", " cpuemmodel", "cpu_file", "cpuemfilename", "linux_location", " cpuemfilename", "cpuingfilename", "cpulogmodels", "cpulogmodel", "cpu_location", "linux_models", "cpuingmodel", "linuxlogmodels", "cpu_description", "cpuemmodel", "cpuingmodule", " cpu_filename", "cpu_module", " cpuemdescription", "cpulogfile", "cpuloglocation", " cpuemmodule"], "board": ["flow", "server", "ban", "row", "controller", "buffer", "boards", "device", "bo", "data", "image", "Board", "flo", "brand", "stroke", "boot", "frame", "cart", "ko", "loop", "model", "hole", "coll", "bug", "database", "config", "control", "lane", "ack", "block", "bean", "design", "cache", "node", "comment", "o", "driver", "card", "bridge", "plugin", "cell", "plane", "room", "line", "deck", "table", "game"], "uart_irq": ["pu_ierc", "pu_ireQ", "pu_ierche", "pu_irche", "pu_irec", "pu_mirq", "pu_ireche", "pu_ierq", "pu_ierQ", "pu_ireq", "pu_mirc", "pu_irQ", "pu_irc", "pu_mirQ", "pu_irq", "pu_mirche"], "timer_irq": ["timer_mirQ", "timer_arQ", "timer_mirqs", "timer_ireq", "timer_mirq", "timer_ireque", "timer_arqs", "timer_arq", "timer_irQ", "timer_ireqs", "timer_ireQ", "timer_arque", "timer_irqs", "timer_mirque", "timer_irque"], "gpio_addr": ["gpios_address", "gpios_addr", "gpio_devices", "gpio_address", "gpios_dev", "gpios_devices"], "gpio_irq": ["gpio_arQ", "gpio_arq", "gpio_mirq", "gpio_miriq", "gpio_ireque", "gpio_irque", "gpio_mirque", "gpio_ireq", "gpio_arque", "gpio_irQ", "gpio_mirQ", "gpio_ireiq", "gpio_iriq", "gpio_ireQ", "gpio_ariq"], "pic": ["fc", "ig", "cam", "li", "Pic", "mc", "mic", "image", "mini", "picture", "bc", "cci", "nic", "mac", "ac", "proc", "scan", "file", "sync", "mag", "capt", "feat", "ec", "pict", "bi", "lc", "cache", "gui", "pins", "pc", "plan", "lib", "plugin", "ic", "module", "las", "img", "fi", "pin", "avi", "xi"], "gpio_dev": ["gpio_info", "gpios_info", "gpios_dev", "gpios_out", "gpio_device", "gpios_device"], "gpio_in": ["gpi_in", "gpio_inc", "gpi_ins", "gpi_inc", "gpi_out", "gpio_ins"], "gpio_out": ["gpio_outs", "gpi_in", "gpi_outs", "gpio__in", "gpio_again", "gpio__again", "gpi_out", "gpio__outs", "gpio__out", "gpi_again"], "adc": ["adm", "odc", "udm", "udf", "amdsc", "odsc", "udsc", "amdc", "udc", "adsc", "amdm", "adf", "amdf", "odm", "odf"], "sram_size": ["sramxsized", "sgram_name", "sram_name", "sgram_size", "sram_sized", "siam_Size", "sram_capacity", "sram_Size", "sgram_offset", "sgram_num", "sramxsize", "siam_capacity", "sram_num", "sgram_sized", "sram_offset", "sgram_width", "sgram_scale", "sram_width", "sramxscale", "siam_size", "sramxoffset", "sram_scale"], "flash_size": ["flashallsize", " flash_range", "flashaclength", "feed_sized", " flash_sum", "flash96chan", "flash_sized", "flash48style", "flash_white", "feed48white", "disk48scale", "flash96size", "flashalllength", "flash96white", "disk_scale", "flash48chan", "feed_chan", "flash_style", "feed48sized", "disk48offset", "flashallbytes", "feed48size", "flash48offset", "flash_chan", "flash_scale", "flash48white", "feed48chan", "flashallsum", "flash48scale", "disk48style", "disk48size", "flash_bytes", "flash_sum", "flash___scale", "disk_size", "feed_size", "flash_offset", " flash_bytes", "flashallrange", "flash48sized", "flash48size", "feed_white", "flash_length", "disk_offset", "flash_range", "flash___size", " flash_length", "flash___offset", "flashacsize", "flashacrange", "disk_style", "flash96sized", "flash___style"], "i2c": ["i2C", "i5C", "ui2C", "i4c", "ui2c", "ui2lc", "i2dc", "i4C", "i2lc", "i4lc", "i5dc", "i5c", "i4dc", "i5lc", "ui2dc"], "dev": ["serial", "cam", "conn", "device", "data", "mini", "ver", "devices", "boot", "Dev", "mac", "pos", "info", "pub", "feature", "block", "pu", "app", "conf", "loader", " device", "ev", "mode", "debug", "user", "mem"], "i": ["a", "ii", "r", "d", "I", "n", "is", "k", "y", "g", "m", "z", "x", "l", "c", "p", "h", "w", "e", "f", "u", "o", "v", "s", "b", "in"], "j": ["js", "ii", "ji", "jit", "d", "jj", "n", "J", "job", "it", "aj", "k", "im", "ij", "uj", "m", "z", "p", "f", "jp", "jet", "v", "b", "ja"], "sram": ["sperse", "scam", "ssra", "psram", "ssream", "psmem", "sra", "ascm", "asrum", "srum", "psrum", "Scam", "asram", "tsgram", "bsgram", " scm", "tsram", "asgram", "Sram", "smem", "psgram", "psra", "sream", "ssflash", "bsream", "sflash", "ssram", " smem", "bsra", " srum", "Sflash", "psperse", "Sgram", "sscam", "ssgram", " sgram", "pscm", "psream", " sflash", "bsram", "tsperse", " sperse", " scam", "tsmem", "scm", "sgram"], "flash": ["serial", "route", "fast", "ban", "row", "http", "Flash", "facebook", "fish", "large", "flat", "array", "zip", "form", "image", "broad", "small", "browser", "light", "spin", "fl", "video", "fire", "fox", "boot", "pass", "scan", "pixel", "sync", "fr", "slice", "bug", "flight", "silver", "push", "fly", "feed", "feature", "raw", "bolt", "sw", "layout", "zero", "design", "f", "FL", "cache", "shadow", "brush", "las", "transform", "low", "view", "pack"], "system_memory": ["systemallocation", "systemalradius", "system32memory", "objectalradius", "system_disk", "system_manager", "shared_image", "shared_memory", "accessMdisk", "shared_area", "access_usage", "system_radius", "systemalcamera", " system_message", "system32camera", "accessMusage", "objectalmemory", "system32location", "systemMdisk", "systemMusage", "systemMmanager", "accessMmanager", "shared_audio", "systemMmemory", "system_camera", "access_memory", " system_media", "system_area", " system_network", "system32radius", "objectallocation", "access_disk", "system_audio", "access_manager", "object_location", "objectalcamera", "systemalmemory", "accessMmemory", "system_usage", "system_image", "object_camera", "object_radius", "system_media", "system_message", "object_memory", "system_network", "system_location"]}}
{"project": "qemu", "commit_id": "c88305027d5a8dbeaacf04ad2ceba79a5c5fb91e", "target": 1, "func": "POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n\n\n    dc->fw_name = \"PowerPC,POWER9\";\n\n    dc->desc = \"POWER9\";\n\n    dc->props = powerpc_servercpu_properties;\n\n    pcc->pvr_match = ppc_pvr_match_power9;\n\n    pcc->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07;\n\n    pcc->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 |\n\n                         PCR_COMPAT_2_05;\n\n    pcc->init_proc = init_proc_POWER9;\n\n    pcc->check_pow = check_pow_nocheck;\n\n    cc->has_work = cpu_has_work_POWER9;\n\n    pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |\n\n                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |\n\n                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |\n\n                       PPC_FLOAT_FRSQRTES |\n\n                       PPC_FLOAT_STFIWX |\n\n                       PPC_FLOAT_EXT |\n\n                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |\n\n                       PPC_MEM_SYNC | PPC_MEM_EIEIO |\n\n                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |\n\n                       PPC_64B | PPC_64BX | PPC_ALTIVEC |\n\n                       PPC_SEGMENT_64B | PPC_SLBI |\n\n                       PPC_POPCNTB | PPC_POPCNTWD |\n\n                       PPC_CILDST;\n\n    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |\n\n                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |\n\n                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |\n\n                        PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |\n\n                        PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |\n\n                        PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |\n\n                        PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;\n\n    pcc->msr_mask = (1ull << MSR_SF) |\n\n                    (1ull << MSR_TM) |\n\n                    (1ull << MSR_VR) |\n\n                    (1ull << MSR_VSX) |\n\n                    (1ull << MSR_EE) |\n\n                    (1ull << MSR_PR) |\n\n                    (1ull << MSR_FP) |\n\n                    (1ull << MSR_ME) |\n\n                    (1ull << MSR_FE0) |\n\n                    (1ull << MSR_SE) |\n\n                    (1ull << MSR_DE) |\n\n                    (1ull << MSR_FE1) |\n\n                    (1ull << MSR_IR) |\n\n                    (1ull << MSR_DR) |\n\n                    (1ull << MSR_PMM) |\n\n                    (1ull << MSR_RI) |\n\n                    (1ull << MSR_LE);\n\n    pcc->mmu_model = POWERPC_MMU_3_00;\n\n#if defined(CONFIG_SOFTMMU)\n\n    pcc->handle_mmu_fault = ppc64_v3_handle_mmu_fault;\n\n    /* segment page size remain the same */\n\n    pcc->sps = &POWER7_POWER8_sps;\n\n    pcc->radix_page_info = &POWER9_radix_page_info;\n\n#endif\n\n    pcc->excp_model = POWERPC_EXCP_POWER8;\n\n    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;\n\n    pcc->bfd_mach = bfd_mach_ppc64;\n\n    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |\n\n                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |\n\n                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |\n\n                 POWERPC_FLAG_VSX | POWERPC_FLAG_TM;\n\n    pcc->l1_dcache_size = 0x8000;\n\n    pcc->l1_icache_size = 0x8000;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr;\n\n}\n", "idx": 1822, "substitutes": {"oc": ["PC", "fc", "ob", "oci", "isc", "roc", "anc", "mc", "xml", "loc", "co", "nc", "bc", "voc", "oid", "tc", "enc", "toc", "mac", "ac", "output", "ok", "config", "ec", "oco", "OC", "c", "doc", "unc", "soc", "org", "exec", "alloc", "vc", "o", "pc", "cca", "ucc", "ic", "oca", "inc", "uc", "rc"], "data": ["da", "dd", "def", "device", "ee", "d", "di", "co", "bc", "parent", "ac", "ds", "config", "raw", "doc", "unc", "cache", "DATA", "cca", "ci", "load", "dat", "Data", "input"], "dc": ["fc", "cm", "DC", "da", "conn", "mc", "d", "di", "nc", "director", "bc", "cci", "tc", "cdn", "ac", "df", "dt", "ec", "cu", "c", "xc", "jc", "doc", "lc", "design", "cd", "disc", "vc", "cca", "pc", "CC", "cf", "uc", "acc", "db", "rc"], "pcc": ["PCC", "apcf", "Pbc", "Pacc", " pca", " pcca", "cpc", "lacc", "lcc", "Pcc", " pcf", "muc", "pci", "Prc", " puc", "ccf", "puc", "pca", "cci", "cacc", "apuc", "Pck", "lcca", " pci", "mcf", "Ppc", "Pci", "apcc", " pck", "cpuc", "cpcc", " prc", " ppc", "pbc", " pbc", "mcc", "cpacc", "pCC", "pcf", "macc", "Puc", "Pca", "prc", "ccc", "pacc", "cbc", " pCC", "cca", "cuc", "cCC", "pck", "apacc", "crc", "Pcca", "lck", "pcca", "ccca", " pacc", "cpcf", "ppc"], "cc": ["cm", " gcc", "DC", "cs", "WC", "mc", "uc", "co", "ck", "nc", "bc", "cci", "tc", "client", "ac", "ec", "ce", "c", "xc", "jc", "lc", "unc", "craft", "ca", "ctrl", "cd", "vc", "cca", "pc", "ucc", "cf", "CC", "acc", "rc"]}}
{"project": "qemu", "commit_id": "97f90cbfe810bb153fc44bde732d9639610783bb", "target": 0, "func": "void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,\n\n                          int is_asi, int size)\n\n{\n\n    CPUState *saved_env;\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n    qemu_log(\"Unassigned \" TARGET_FMT_plx \" wr=%d exe=%d\\n\",\n\n             addr, is_write, is_exec);\n\n    if (!(env->sregs[SR_MSR] & MSR_EE)) {\n\n        return;\n\n    }\n\n\n\n    if (is_exec) {\n\n        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    } else {\n\n        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    }\n\n}\n", "idx": 13172, "substitutes": {"addr": ["ord", "args", "device", "port", "Address", "asm", "slot", "amp", "rd", "rc", "amd", "pc", "name", "ace", " address", "br", "mx", "ad", "adr", "mt", "resource", "kt", "pointer", "data", "mode", "arp", "address", "ip", "type", "offset", "target", "md", "attr", "network", "rt", "host", "cp", "mac", "nr", "dr", "alias", "wd", "ptr", "filename", "node"], "is_write": ["isgwrite", "name_write", "isgread", "namegwrite", "isgexecute", " is_writer", "is_read", "isPuball", "namegexecute", " is_read", "is1read", "name_read", "isPubwrite", "is1writer", "is1all", "is_all", "is_execute", "is_writer", "name_execute", "namegread", "namegexec", "name_exec", "is1write", "isPubread", " is_all", "isgexec", "isPubwriter"], "is_exec": ["IS__exec", " is_ec", "IS_eval", "is_ec", "is__write", "IS__eval", "isPec", "is__exec", "isPclose", "is_close", " is_sync", " is_sec", "IS_write", "is_sync", "is_read", "isPwrite", "isPexec", "IS__read", "is_sec", "IS_read", "IS_exec", "is_eval", "IS__write", "is__read", " is_close", "is__eval"], "is_asi": [" is_open", " is_data", " is_sync", "is_sync", "is_fail", " is_fail", "is_open", "is_data"], "size": ["args", "enc", "extra", "name", "align", "Size", "capacity", "unit", "loc", "form", "ize", "sec", "count", "mode", "address", "timeout", "SIZE", "offset", "security", "scale", "empty", "len"], "saved_env": ["saved__dat", "save__environment", "save_environment", "saved__environment", "save__env", "saved___environment", "save_exc", "saved_environment", "saved__env", "save_dat", "save__dat", "saved___dat", "save_env", "saved_dat", "saved___env", "saved_exc", "saved_v", "save_v"]}}
{"project": "qemu", "commit_id": "a980f7f2c2f4d7e9a1eba4f804cd66dbd458b6d4", "target": 0, "func": "static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < vs->num_queues + 2; i++) {\n\n        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);\n\n    }\n\n    pc_alloc_uninit(vs->alloc);\n\n    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));\n\n    g_free(vs->dev);\n\n    qpci_free_pc(vs->bus);\n\n    g_free(vs);\n\n}\n", "idx": 26535, "substitutes": {"vs": ["rs", "sk", "args", "ss", "pg", "ns", "va", "Vs", "ov", "ts", "blocks", "ms", "ds", "forces", "var", "verts", "ports", "vr", "ps", "vas", "plugins", "vers", "ks", "bs", "css", "vals", "es", "gs", "stats", "ims", "s", "http", "spec", "sv", "points", "dev", "versions", "os", "obs", "services", "iv", "vm", "xs", "ums", "ls", "fs", "qs", "js", "alls", "ves", "v", "ver", "vp", "ops", "VS", "pos", "cs", "env", "vol", "views"], "i": ["abi", "k", "z", "ie", "p", "b", "m", "c", "d", "x", "ti", "mi", "type", "phi", "qi", "ri", "id", "u", "e", "o", "li", "gi", "ji", "zi", "multi", "xi", "uri", "ii", "bi", "si", "ai", "di", "ni", "ini", "ci", "fi", "I", "f", "oi", "n", "ip", "j", "index", "t", "v", "iu", "mu", "pi", "in", "ui", "l", "hi"]}}
{"project": "qemu", "commit_id": "5a2223ca26b1a34e131b5b9a63599d9426d2c25c", "target": 0, "func": "static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)\n\n{\n\n    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n}\n", "idx": 16246, "substitutes": {"s": ["secondary", "south", "port", "sys", "ses", "service", "sync", "t", "fs", "private", "rs", "sym", "g", "S", "settings", "js", "sq", "session", "server", "ss", "o", "p", "e", "http", "sf", "sb", "b", "f", "stat", "c", "ns", "stats", "ssl", "ops", "services", "ds", "ssh"], "bsel": ["fbsels", "fbsl", "lbsels", " bsell", "bbsl", "lbsel", "lbsl", " bsl", "bsl", "fbsell", "bsell", "bbsel", "bbsell", "cbsel", "fbsel", "bsels", "bbsels", "lbsell", "cbsels", "cbsl", " bsels", "cbsell"], "slot": ["spot", "slice", "service", "trial", "hide", "second", "pixel", "nit", "shot", "disabled", " slots", "lot", "option", "vol", "session", "antine", "zo", "hole", "sector", "zone", "role", "lo", "sec", "Slot", "pot", "boot", "not", "socket", "rol", " Slot", "token", "serv", "offset", "loop", "sl", "layout", "rot", "bit"]}}
{"project": "FFmpeg", "commit_id": "a026a3efaeb9c2026668dccbbda339a21ab3206b", "target": 1, "func": "static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param)\n\n{\n\n    int prefix = 0;\n\n    int suffix = 0;\n\n    int last_coeff_abs_level_remaining;\n\n    int i;\n\n\n\n    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc))\n\n        prefix++;\n\n\n\n    if (prefix < 3) {\n\n        for (i = 0; i < rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;\n\n    } else {\n\n        int prefix_minus3 = prefix - 3;\n\n\n\n        if (prefix == CABAC_MAX_BIN) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"CABAC_MAX_BIN : %d\\n\", prefix);\n\n            return 0;\n\n        }\n\n\n\n        for (i = 0; i < prefix_minus3 + rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)\n\n                                              << rc_rice_param) + suffix;\n\n    }\n\n    return last_coeff_abs_level_remaining;\n\n}\n", "idx": 10609, "substitutes": {"s": ["session", "sg", "ts", "ds", "si", "g", "is", "sf", "m", "b", "t", "ops", "d", "gs", "service", "c", "serv", "p", "ls", "e", "qs", "sq", "js", "f", "os", "cs", "sym", "o", "S", "es", "sync", "scope", "sl", "services", "ctx", "ns", "sb", "spec", "u", "sys", "self", "ses", "a", "fs", "su", "site", "ss", "ssl"], "rc_rice_param": ["rc_rice_mode", "rc_rice_ram", "rc_rice2cm", "rc_square_mode", "rc_single_cm", "rc_rice_type", "rc_square_rm", "rc_square_num", "rc_cost_num", "rc_riceingprogram", "rc_single_params", "rc_ruby_param", "rc_square_cm", "rc_riceingmode", "rc_cost_cm", "rc_ruby_name", "rc_ricefullcm", "rc_single_ram", "rc_cost_par", "rc_single_param", "rc_square_param", "rc_rice_program", "rc_riceingnum", "rc_rice_cm", "rc_riceacnum", "rc_rice_params", "rc_rice2ram", "rc_ruby_type", "rc_rice_par", "rc_riceaccm", "rc_rice_name", "rc_ricefulltype", "rc_rice_rm", "rc_riceingparam", "rc_rice2params", "rc_rice2param", "rc_riceacpar", "rc_ruby_cm", "rc_square_program", "rc_ricefullparam", "rc_riceacparam", "rc_rice_num", "rc_cost_param", "rc_ricefullname"], "last_coeff_abs_level_remaining": ["last_coeff_abs_level_main", "last_coeff_abs_level_remained", "last_coeff_abs_level_mained", "last_coeff_abs_level_rapping", "last_coeff_abs_level_resain", "last_coeff_abs_level_mapping", "last_coeff_abs_level_rained", "last_coeff_abs_level_reained", "last_coeff_abs_level_regained", "last_coeff_abs_level_resaining", "last_coeff_abs_level_Remain", "last_coeff_abs_level_regain", "last_coeff_abs_level_regaining", "last_coeff_abs_level_remain", "last_coeff_abs_level_reain", "last_coeff_abs_level_Remapping", "last_coeff_abs_level_rain", "last_coeff_abs_level_regapping", "last_coeff_abs_level_reaining", "last_coeff_abs_level_maining", "last_coeff_abs_level_resapping", "last_coeff_abs_level_resained", "last_coeff_abs_level_raining", "last_coeff_abs_level_Remained", "last_coeff_abs_level_remapping", "last_coeff_abs_level_reapping", "last_coeff_abs_level_Remaining"], "i": ["oi", "ui", "di", "base", "it", "si", "zi", "pad", "adi", "id", "xi", "info", "b", "x", "t", "ini", "c", "ji", "p", "uri", "ix", "e", "mu", "fp", "mini", "eni", "f", "ie", "padding", "j", "ai", "multi", "index", "v", "gi", "ti", "phi", "abi", "pre", "qi", "inner", "jp", "pi", "bi", "ii", "u", "I", "li", "ip", "ci", "io", "ni", "image", "ri", "fi", "iu"], "prefix": ["diff", "fix", "base", "pass", "delay", "scale", "start", "wp", "len", "pad", "temp", "bp", "password", "path", "num", "post", "pointer", "phase", "adding", "batch", "p", "ix", "prev", "status", "fp", "queue", "skip", "wrapper", "number", "sequence", "xxx", "padding", "mode", "next", "priority", "append", "zero", "index", "module", "master", "order", "name", "magic", "phrase", "pre", "address", "token", "patch", "hop", "offset", "radius", "root", "init", "gap", "length", "cache", "ski", "partial", "mix", "frequency", "reset"]}}
{"project": "qemu", "commit_id": "58892b447f0ffcd0967bc6f1bcb40df288ebeebc", "target": 1, "func": "static int vfio_start_eventfd_injection(VFIOINTp *intp)\n\n{\n\n    int ret;\n\n\n\n    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\");\n\n    }\n\n    return ret;\n\n}\n", "idx": 26620, "substitutes": {"intp": ["inccp", "bitpa", "intcp", "indp", "irp", "intP", "indpi", "ircp", "incpo", "intc", "intpi", "bitpi", "indcp", "indpo", "bitp", "ippi", "indP", "bitc", "indpa", "intpa", "intpo", "ipc", "indc", "irP", "ipp", "incP", "ippa", "irpo", "incp"], "ret": ["ref", "std", "fin", "obj", "ft", "res", "cat", "flag", "red", "data", "back", "base", "bf", "py", "db", "line", "str", "valid", "mt", "det", "lit", "RET", "last", "re", "fit", "art", "nt", "fire", "reply", "rc", "pat", "pet", "arg", "active", "Ret", "rt", "part", "ext", "j", "alt", "reg", "match", "result", "et", "len", "val", "gt", "ut", "fun"]}}
{"project": "FFmpeg", "commit_id": "04763c6f87690b31cfcd0d324cf36a451531dcd0", "target": 1, "func": "static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,\n\n                                       int *mb_type)\n\n{\n\n    int b8_stride = 2;\n\n    int b4_stride = h->b_stride;\n\n    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;\n\n    int mb_type_col[2];\n\n    const int16_t (*l1mv0)[2], (*l1mv1)[2];\n\n    const int8_t *l1ref0, *l1ref1;\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    unsigned int sub_mb_type = MB_TYPE_L0L1;\n\n    int i8, i4;\n\n    int ref[2];\n\n    int mv[2];\n\n    int list;\n\n\n\n    assert(sl->ref_list[1][0].reference & 3);\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent,\n\n                           sl->mb_y + !!IS_INTERLACED(*mb_type));\n\n\n\n#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \\\n\n                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)\n\n\n\n    /* ref = min(neighbors) */\n\n    for (list = 0; list < 2; list++) {\n\n        int left_ref     = sl->ref_cache[list][scan8[0] - 1];\n\n        int top_ref      = sl->ref_cache[list][scan8[0] - 8];\n\n        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];\n\n        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];\n\n        if (refc == PART_NOT_AVAILABLE) {\n\n            refc = sl->ref_cache[list][scan8[0] - 8 - 1];\n\n            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];\n\n        }\n\n        ref[list] = FFMIN3((unsigned)left_ref,\n\n                           (unsigned)top_ref,\n\n                           (unsigned)refc);\n\n        if (ref[list] >= 0) {\n\n            /* This is just pred_motion() but with the cases removed that\n\n             * cannot happen for direct blocks. */\n\n            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];\n\n            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];\n\n\n\n            int match_count = (left_ref == ref[list]) +\n\n                              (top_ref  == ref[list]) +\n\n                              (refc     == ref[list]);\n\n\n\n            if (match_count > 1) { // most common\n\n                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),\n\n                                      mid_pred(A[1], B[1], C[1]));\n\n            } else {\n\n                assert(match_count == 1);\n\n                if (left_ref == ref[list])\n\n                    mv[list] = AV_RN32A(A);\n\n                else if (top_ref == ref[list])\n\n                    mv[list] = AV_RN32A(B);\n\n                else\n\n                    mv[list] = AV_RN32A(C);\n\n            }\n\n        } else {\n\n            int mask = ~(MB_TYPE_L0 << (2 * list));\n\n            mv[list]  = 0;\n\n            ref[list] = -1;\n\n            if (!is_b8x8)\n\n                *mb_type &= mask;\n\n            sub_mb_type &= mask;\n\n        }\n\n    }\n\n    if (ref[0] < 0 && ref[1] < 0) {\n\n        ref[0] = ref[1] = 0;\n\n        if (!is_b8x8)\n\n            *mb_type |= MB_TYPE_L0L1;\n\n        sub_mb_type |= MB_TYPE_L0L1;\n\n    }\n\n\n\n    if (!(is_b8x8 | mv[0] | mv[1])) {\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n        return;\n\n    }\n\n\n\n    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n\n        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL\n\n            mb_y  = (sl->mb_y & ~1) + sl->col_parity;\n\n            mb_xy = sl->mb_x +\n\n                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;\n\n            b8_stride = 0;\n\n        } else {\n\n            mb_y  += sl->col_fieldoff;\n\n            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity\n\n        }\n\n        goto single_col;\n\n    } else {                                             // AFL/AFR/FR/FL -> AFR/FR\n\n        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR\n\n            mb_y           =  sl->mb_y & ~1;\n\n            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;\n\n            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];\n\n            b8_stride      = 2 + 4 * h->mb_stride;\n\n            b4_stride     *= 6;\n\n            if (IS_INTERLACED(mb_type_col[0]) !=\n\n                IS_INTERLACED(mb_type_col[1])) {\n\n                mb_type_col[0] &= ~MB_TYPE_INTERLACED;\n\n                mb_type_col[1] &= ~MB_TYPE_INTERLACED;\n\n            }\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&\n\n                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&\n\n                !is_b8x8) {\n\n                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */\n\n            } else {\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        } else {                                         //     AFR/FR    -> AFR/FR\n\nsingle_col:\n\n            mb_type_col[0] =\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {\n\n                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */\n\n            } else if (!is_b8x8 &&\n\n                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n\n                *mb_type |= MB_TYPE_DIRECT2 |\n\n                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));\n\n            } else {\n\n                if (!h->ps.sps->direct_8x8_inference_flag) {\n\n                    /* FIXME: Save sub mb types from previous frames (or derive\n\n                     * from MVs) so we know exactly what block size to use. */\n\n                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */\n\n                }\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        }\n\n    }\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);\n\n\n\n    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];\n\n    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];\n\n    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];\n\n    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];\n\n    if (!b8_stride) {\n\n        if (sl->mb_y & 1) {\n\n            l1ref0 += 2;\n\n            l1ref1 += 2;\n\n            l1mv0  += 2 * b4_stride;\n\n            l1mv1  += 2 * b4_stride;\n\n        }\n\n    }\n\n\n\n    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            int x8  = i8 & 1;\n\n            int y8  = i8 >> 1;\n\n            int xy8 = x8     + y8 * b8_stride;\n\n            int xy4 = x8 * 3 + y8 * b4_stride;\n\n            int a, b;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                ((l1ref0[xy8] == 0 &&\n\n                  FFABS(l1mv0[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv0[xy4][1]) <= 1) ||\n\n                 (l1ref0[xy8] < 0 &&\n\n                  l1ref1[xy8] == 0 &&\n\n                  FFABS(l1mv1[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv1[xy4][1]) <= 1))) {\n\n                a =\n\n                b = 0;\n\n                if (ref[0] > 0)\n\n                    a = mv[0];\n\n                if (ref[1] > 0)\n\n                    b = mv[1];\n\n                n++;\n\n            } else {\n\n                a = mv[0];\n\n                b = mv[1];\n\n            }\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);\n\n        }\n\n        if (!is_b8x8 && !(n & 3))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    } else if (IS_16X16(*mb_type)) {\n\n        int a, b;\n\n\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n            ((l1ref0[0] == 0 &&\n\n              FFABS(l1mv0[0][0]) <= 1 &&\n\n              FFABS(l1mv0[0][1]) <= 1) ||\n\n             (l1ref0[0] < 0 && !l1ref1[0] &&\n\n              FFABS(l1mv1[0][0]) <= 1 &&\n\n              FFABS(l1mv1[0][1]) <= 1 &&\n\n              h->sei.unregistered.x264_build > 33U))) {\n\n            a = b = 0;\n\n            if (ref[0] > 0)\n\n                a = mv[0];\n\n            if (ref[1] > 0)\n\n                b = mv[1];\n\n        } else {\n\n            a = mv[0];\n\n            b = mv[1];\n\n        }\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);\n\n    } else {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            const int x8 = i8 & 1;\n\n            const int y8 = i8 >> 1;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n\n\n            assert(b8_stride == 2);\n\n            /* col_zero_flag */\n\n            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                (l1ref0[i8] == 0 ||\n\n                 (l1ref0[i8] < 0 &&\n\n                  l1ref1[i8] == 0 &&\n\n                  h->sei.unregistered.x264_build > 33U))) {\n\n                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;\n\n                if (IS_SUB_8X8(sub_mb_type)) {\n\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];\n\n                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                        if (ref[0] == 0)\n\n                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        if (ref[1] == 0)\n\n                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        n += 4;\n\n                    }\n\n                } else {\n\n                    int m = 0;\n\n                    for (i4 = 0; i4 < 4; i4++) {\n\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n\n                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                            if (ref[0] == 0)\n\n                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);\n\n                            if (ref[1] == 0)\n\n                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);\n\n                            m++;\n\n                        }\n\n                    }\n\n                    if (!(m & 3))\n\n                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;\n\n                    n += m;\n\n                }\n\n            }\n\n        }\n\n        if (!is_b8x8 && !(n & 15))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    }\n\n}\n", "idx": 25245, "substitutes": {"h": ["hm", "ht", "w", "p", "c", "hr", "history", "ih", "bh", "H", "hh", "ch", "ah", "self", "u", "hl", "e", "hp", "hw", "cl", "rh", "s", "http", "hs", "handler", "gh", "eh", "f", "t", "host", "ha", "q", "v", "g", "l", "hi", "he", "ph", "oh", "sh"], "sl": ["sch", "kel", "sc", "SL", "sk", "acl", "hel", "slice", "tl", "ml", "sn", "spl", "ll", "c", "pg", "se", "sw", "oper", "bh", "ell", "isl", "bl", "util", "split", "su", "hl", "el", "li", "cl", "rl", "la", "s", "ul", "lit", "cel", "dl", "l", "loc", "fl", "pl", "si", "wl", "lr", "sel", "sb", "gl", "ln", "sa", "il", "lc", "serv", "ls", "f", "sm", "flo", "sil", "t", "zh", "nl", "Sl", "sf", "ssl", "kl", "sh"], "mb_type": ["MB_length", "mbqtype", "mn_type", "mn_TYPE", "db_id", "db_type", "mbqtypes", "mn_size", "MB_types", "MB_id", "db_family", "mb_family", "mb_id", "mbqlength", "MB_type", "mb_TYPE", "mb_length", "mb_types", "mbqid", "mb_size", "db_TYPE"], "mb_type_col": ["mb_type_column", "mb_types_col", "mb_type_type", "mb_types_column", "mb_types_row", "mb_types_type", "mb_type_row"], "l1mv0": ["l1cmw6", "l1mh6", "l1mx2", "l1mw6", "l1mw2", "l1mh0", "l1cmw1", "l1cmv2", "l1cmw0", "l1mx6", "l1mx0", "l1mw0", "l1cmv1", "l1cmv6", "l1mv6", "l1cmv0", "l1mh2", "l1mx1", "l1cmw2", "l1mw1", "l1mv2", "l1mh1"], "l1mv1": ["l1mb0", "l1mh0", "l1mw3", "l1dh3", "l1mb3", "l1dh0", "l1dh1", "l1dv3", "l1dv0", "l1dv1", "l1mw0", "l1mb1", "l1mv3", "l1mh3", "l1mw1", "l1mh1"], "l1ref0": ["l_reference1", "l1reference1", "l_ref2", "l1p2", "l_ref4", "l_reference0", "l1Ref2", "l1Ref4", "l1reference4", "l1reference2", "l1Ref1", "l1p0", "l1Ref0", "l1ref4", "l1p4", "l1reference0", "l_ref0", "l1p1", "l1ref2", "l_ref1", "l_reference2", "l_reference4"], "l1ref1": ["l2ref1", "l1reference1", "l1f1", "l2f1", "l1arc8", "l1f8", "l1arc1", "l1ref8", "l1reference8", "l2f8", "l2ref8"], "i8": ["m6", "p10", "m10", "u8", "u10", "p8", "u16", "i16", "p16", "i10", "m8", "u6", "i6", "p6", "m16"], "i4": ["int8", "int6", "int4", "l8", " i6", "int64", "l6", "l4", " i64", "i6", "l64", "i64"], "ref": ["call", "info", "p", "aff", "buffer", "base", "config", "pointer", "conf", "diff", "col", "Ref", "def", "reference", "id", "num", "rec", "all", " reference", "rel", "input", "ef", "cal", "rc", "cache", "block", "arg", "comp", "f", "count", "comment", "index", "null", "row", "inter", "arc", "pre", "range", "pos", "val", "REF"], "mv": [" mvp", "pmq", "mj", "pmj", "bmq", "mvp", "bmj", " mq", "mq", "bmv", "pmv", "pmvp", " mj", "bmvp"], "list": ["chain", "L", "call", "CL", "batch", "server", "name", "cat", "module", "base", "sync", "self", "arr", "li", "cl", "set", "pool", "entry", "pair", "complete", "code", "low", "p", "test", "queue", "diff", "key", "old", "group", "cache", "feat", "com", "comp", "coll", "map", "block", "que", "large", "len", "table", "g", "load", "rest", "see", "hold", "conf", "act", "bl", "ch", "cont", "all", "e", "str", "la", "pl", "cli", "parent", "like", "view", "lc", "count", "source", "pull", "stack", "null", "full", "seq", "i", "config", "member", "type", "id", "List", "ul", "LI", "record", "lists", "gl", "listed", "loop", "comment", "LIST", "child", "index", "out", "pre", "l"], "C": ["S", "L", "CL", "DC", "c", "LC", "K", "P", "T", "H", "U", "CM", "EC", "R", "M", "JC", "FC", "D", "CR", "G", "N", "I", "CA", "W", "V", "E", "O", "VC", "F"]}}
{"project": "qemu", "commit_id": "88b062c2036cfd05b5111147736a08ba05ea05a9", "target": 0, "func": "int bdrv_pdiscard(BlockDriverState *bs, int64_t offset, int count)\n\n{\n\n    Coroutine *co;\n\n    DiscardCo rwco = {\n\n        .bs = bs,\n\n        .offset = offset,\n\n        .count = count,\n\n        .ret = NOT_DONE,\n\n    };\n\n\n\n    if (qemu_in_coroutine()) {\n\n        /* Fast-path if already in coroutine context */\n\n        bdrv_pdiscard_co_entry(&rwco);\n\n    } else {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        co = qemu_coroutine_create(bdrv_pdiscard_co_entry, &rwco);\n\n        qemu_coroutine_enter(co);\n\n        while (rwco.ret == NOT_DONE) {\n\n            aio_poll(aio_context, true);\n\n        }\n\n    }\n\n\n\n    return rwco.ret;\n\n}\n", "idx": 23751, "substitutes": {"bs": ["obs", "bc", "pb", "sb", "bos", "lbs", "lb", "bis", "fs", "ses", "ubs", "mb", "fb", "bb", "bytes", "ops", "as", "bid", "bl", "ds", "bes", "css", "fps", "s", "bas", "its", "state", "os", "bt", "vs", "cs", "ls", "bi", "bps", "ctx", "b", "bits", "sub", "blocks", "ms", "ns", "BS", "iss", "ps", "rs", "gs", "boot", "bh", "rb", "base", "ss"], "offset": ["delay", "phase", "limit", "start", "attribute", "off", "ref", "option", "part", "mode", "connection", "bytes", "type", "pos", "order", "alloc", "entry", "address", "size", "data", "ip", "number", "prefix", "slot", "addr", "initial", "url", "shift", "index", "num", "set", "location", "seq", "error", "Offset", "length", "slice", "len", "loc", "reference", "range", "reset", "from", "pointer", "clock", "block", "position", "offer", "base", "sort", "padding"], "count": ["col", "found", "name", "cc", "limit", "start", "ref", "amount", "part", "mount", "cond", "force", "key", "queue", "process", "weight", "f", "type", "Count", "size", "cache", "list", "sum", "number", "id", "code", "depth", "timeout", "content", "c", "index", "first", "counter", "seq", "error", "child", "length", "call", "total", "len", "large", "parent", "group", "base", "max"], "co": ["col", "ra", "cc", "oo", "oe", "ri", "coll", "con", "ca", "pc", "can", "po", "ci", "cmp", "ro", "ac", "mo", "cache", "ob", "ico", "mc", "cf", "oper", "o", "code", "py", "coe", "c", "rc", "aco", "Co", "bo", "CC", "call", "flo", "loc", "cca", "CO", "ko", "ck", "oc", "cu", "fo"], "aio_context": ["aios_context", "aio__sc", "aios_sc", "aio_sc", "aio_environment", "aiopenvironment", "aio_package", "aio__context", "aio__connection", "aio_connection", "aioppackage", "aio__ctx", "aiopcontext", "aiopctx", "aios_connection", "aio_ctx", "aios_ctx"]}}
{"project": "qemu", "commit_id": "e5ba83c53add51796e8ea787d2b7cb1f9c3cb72d", "target": 0, "func": "CPUState *ppc440ep_init(MemoryRegion *address_space_mem, ram_addr_t *ram_size,\n\n                        PCIBus **pcip, const unsigned int pci_irq_nrs[4],\n\n                        int do_init, const char *cpu_model)\n\n{\n\n    MemoryRegion *ram_memories\n\n        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));\n\n    target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS];\n\n    target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS];\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    qemu_irq *irqs;\n\n    qemu_irq *pci_irqs;\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"440-Xilinx\"; // XXX: should be 440EP\n\n    }\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    ppc_booke_timers_init(env, 400000000, 0);\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n\n\n    /* SDRAM controller */\n\n    memset(ram_bases, 0, sizeof(ram_bases));\n\n    memset(ram_sizes, 0, sizeof(ram_sizes));\n\n    *ram_size = ppc4xx_sdram_adjust(*ram_size, PPC440EP_SDRAM_NR_BANKS,\n\n                                    ram_memories,\n\n                                    ram_bases, ram_sizes,\n\n                                    ppc440ep_sdram_bank_sizes);\n\n    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,\n\n                      ram_bases, ram_sizes, do_init);\n\n\n\n    /* PCI */\n\n    pci_irqs = g_malloc(sizeof(qemu_irq) * 4);\n\n    pci_irqs[0] = pic[pci_irq_nrs[0]];\n\n    pci_irqs[1] = pic[pci_irq_nrs[1]];\n\n    pci_irqs[2] = pic[pci_irq_nrs[2]];\n\n    pci_irqs[3] = pic[pci_irq_nrs[3]];\n\n    *pcip = ppc4xx_pci_init(env, pci_irqs,\n\n                            PPC440EP_PCI_CONFIG,\n\n                            PPC440EP_PCI_INTACK,\n\n                            PPC440EP_PCI_SPECIAL,\n\n                            PPC440EP_PCI_REGS);\n\n    if (!*pcip)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    return env;\n\n}\n", "idx": 5875, "substitutes": {"address_space_mem": ["address_sp_mem", "address_space_mc", "address_spaceofmem", "address_spaceofmc", "address_sp_mm", "address_space_mm", "address_spaceofmm", "address_sp_mc"], "ram_size": ["ram_name", "mem_offset", "ram\u00b7name", "ramFaddress", "ramxoffset", "ram_num", "ram_mode", "ramfnum", "ramFoffset", "access_mode", "memory_name", "access_sized", "memory_size", "ram_model", "ramFmemory", "ram\u00b7size", "ramFsize", "mem_size", "mem_memory", "ramxsize", "ram\u00b7num", "ramfname", "ramxmemory", "ram\u00b7offset", "ramfsize", "memory_offset", "memory_num", "ramxaddress", "access_model", "ram_memory", "ram_address", "access_size", "ram_offset", "ramfoffset", "mem_address", "ram_sized"], "pcip": ["pcid", "PCip", "PCipes", "pcips", "PCid", "cipes", "ccid", "cip", "pcipes", "ccips", "cips", "ccip", "cid", "ccipes", "PCips"], "pci_irq_nrs": ["pci_irq_codes", "pci_irq_nls", "pci_irq_cls", "pci_irq_Nls", "pci_irq_nws", "pci_irq_nodes", "pci_irq_cws", "pci_irq_Nrs", "pci_irq_Nws", "pci_irq_Nodes", "pci_irq_crs"], "do_init": ["cpu_init", "do_alloc", "cpu_alloc", "cpu_set", "do_set"], "cpu_model": ["machinejmodels", "cpu_models", "cpupmemory", "machinejlocation", "memory_description", "cpualquery", "cpulexmodel", "cpuallocation", "ram_location", "cpualmodel", "memorylexmodel", "cpupmodels", "cpu_size", "machine_location", "cpujmodels", "machine_memory", " cpu_size", "memory_models", " cpu_store", "cpulexdescription", "cpu_memory", "cpu_store", "memory_model", "cpujlocation", " cpu_source", "memory_size", "machine_models", "cpuplocation", "memorylexsize", "ram_model", "ram_params", "ram_query", "cpu_source", "cpualparams", "cpujmemory", "cpupmodel", "memorylexmodels", "cpu_description", "machinejmodel", "cpulexsize", "machinejmemory", "cpu_location", "cpulexmodels", "cpu_query", "cpu_params", "memorylexdescription", "cpujmodel", "machine_model"], "ram_memories": ["ram_morts", "ram_temores", "ram_temory", "ram_matorts", "ram_memores", "ram_temries", "ram_shories", "ram_mory", "ram_mories", "ram_temories", "ram_monories", "ram_matories", "ram_monory", "ram_processores", "ram_mators", "ram_processries", "ram_memors", "ram_memries", "ram_temorts", "ram_shory", "ram_processories", "ram_matory", "ram_mries", "ram_memory", "ram_processory", "ram_mores", "ram_shorts", "ram_memorts", "ram_shores", "ram_monors", "ram_temors", "ram_monorts"], "ram_bases": ["_", "ram_mbasses", "ram_brases", "ram_buffias", "ram_basses", "ram_nbased", "all", "func", "cpu", "ram_brased", "g", "ram_barases", "ram_baraches", "ram_based", "ram_nbases", "ram_buffasing", "ram_buffases", "ram_nias", "ram_baches", "ram_compases", "ctx", "ram_bias", "ram_nasses", "ram_nbias", "ram_barasses", "ram_buffased", "ram_buffasses", "ram_mbases", "ram_buffonents", "ram_mbias", "ram_brasing", "ram_nases", "r", "ram_bonents", "ram_buffaches", "ram_mbaches", "ram_components", "get", "args", "ram_nonents", "ram_brias", "ram_basing", "ram_nbasing", "ram_compasses", "ram_compias", "ram_barias"], "ram_sizes": ["ram_timesizes", "ram_lizes", "ram_outsize", "ram_bources", "ram_sanguages", "ram_stylesets", "ram_lamples", "ram_stylesizes", "ram_outsizes", "ram_languages", "ram_timesets", "ram_cizes", "ram_lists", "ram_cigs", "ram_lize", "ram_lources", "ram_sifts", "ram_sets", "ram_bize", "ram_bizes", "ram_timesifts", "ram_nosamples", "ram_timesamples", "ram_outsources", "ram_nosigs", "ram_banguages", "ram_outsanguages", "ram_sists", "ram_nosizes", "ram_stylesifts", "ram_nosists", "ram_lets", "ram_camples", "ram_sources", "ram_lifts", "ram_samples", "ram_cists", "ram_stylesamples", "ram_ligs", "ram_sigs"], "env": ["bg", "environment", "style", "gui", "gear", "conf", "ev", "her", "here", "empty", "exec", "err", "equ", "Environment", "enh", "ec", "stage", "pect", "engine", "ku", "img", "conn", "ah", "config", "qt", "nc", "module", "eu", "eye", "ctx", "eval", "viron", "doc", "txt", "cf", "size", "fg", "eng", "dat", "vel", "exc", "rc", "db", "inc", "export", "obj", "net", "np", "vs", "e", "que", "en", "dev", "me", "erv", "shell", "cache", "app", "loader", "dict", "enable", "fen", "anc", "ea", "ig", "v", "scope", "session", "stack", "enc", "window", "event", "args", "init", "dir", "impl", "pec", "lock", "context", "eni", "console", "cv", "manager"], "pic": ["pot", "ig", "bin", "mic", "pin", "config", "xi", "sync", "typ", "enc", "image", "pins", "eric", "mac", "picture", "bus", "cci", "gui", "pc", "mc", "nic", "pict", "lic", "lib", "bc", "ic", "mini", "doc", "fig", "proc", "capt", "lc", "fc", "li", "cache", "fi", "lli", "Pic"], "irqs": ["mirws", "mirqs", "IRqs", "irens", "irws", "mirlocks", "IRrows", "rilocks", "riqs", "mirq", "mirces", "irquest", "ireq", "IRques", "irtq", " irws", "irq", "mirques", "irecs", "riq", "ireqs", " irlocks", "pircs", "irtqs", "IRquest", "IRws", "mircs", " irquest", "irlocks", "IRq", "irces", "pirqs", "irarows", "mirrows", "pirq", "mirns", "irtquest", " ircs", "iraces", "iraq", "pirns", "ircs", "iraqs", "IRcs", "irns", "riquest", "IRces", "irques", "irtques", "mirquest", "irrows", " irq"], "pci_irqs": ["pci_irqa", "pci_arq", "pci_arques", "pci_irques", "pci_pirq", "pci_arqs", "pci_mirq", "pci_pirqs", "pci_pirqa", "pci_mirqa", "pci_pirques", "pci_mirqs", "pci_arqa", "pci_irq", "pci_mirques"]}}
{"project": "qemu", "commit_id": "2a313e5cf6ed90b932b0abe2b4f2055785397f93", "target": 0, "func": "int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)\n\n{\n\n    PageCache *new_cache;\n\n    int64_t ret;\n\n\n\n    /* Check for truncation */\n\n    if (new_size != (size_t)new_size) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeding address space\");\n\n        return -1;\n\n    }\n\n\n\n    /* Cache should not be larger than guest ram size */\n\n    if (new_size > ram_bytes_total()) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, \"cache size\",\n\n                   \"exceeds guest ram size\");\n\n        return -1;\n\n    }\n\n\n\n    XBZRLE_cache_lock();\n\n\n\n    if (XBZRLE.cache != NULL) {\n\n        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {\n\n            goto out_new_size;\n\n        }\n\n        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);\n\n        if (!new_cache) {\n\n            ret = -1;\n\n            goto out;\n\n        }\n\n\n\n        cache_fini(XBZRLE.cache);\n\n        XBZRLE.cache = new_cache;\n\n    }\n\n\n\nout_new_size:\n\n    ret = pow2floor(new_size);\n\nout:\n\n    XBZRLE_cache_unlock();\n\n    return ret;\n\n}\n", "idx": 23924, "substitutes": {"new_size": ["NEWaccache", "new_SIZE", "new_number", "newlsize", "new_bytes", "new6size", " new_time", " new_name", "finallexsize", "newaccache", "old_content", " new_weight", " new_capacity", "old_cache", "newaclength", "finallexset", "final_set", "newlexset", "new6cache", "NEWacnumber", "newPsize", " new_loc", "new67name", "new_set", "newacsize", "NEW_length", "new67cache", "newPweight", "new_time", "new_capacity", "newlexbytes", " new_SIZE", "finallexbytes", "newlbytes", "new_name", "NEW_number", "new67capacity", "new67size", " new_year", "final_capacity", " new_storage", "final_size", "newPyear", "final_bytes", "new_storage", "newlcapacity", "finallexcapacity", "new6content", "new_weight", "new_loc", "newacnumber", "new_content", "NEWacsize", "newlexsize", "old_size", "NEWaclength", "NEW_size", "new_year", "newlset", "newlexcapacity", "new_length", "NEW_cache"], "errp": ["errcp", "errps", "errorfp", "rrpre", "armpa", "errorc", "err", "erc", "rrp", "nerp", "yrp", " errcp", "errorp", "errorpc", "nerr", " errc", "nerpc", "armcp", " errfp", " errpre", "armr", " errpc", "yrpc", "errpc", "rrpc", "yrpre", "errfp", "errpa", "armp", " errpa", "errc", "ercp", "irpc", "irps", "rrpa", "errpre", "irp", "irr", "erfp", "erpa", "erp", "errr", "nerps", " errr", "erpc", "erps", "yrpa"], "new_cache": [" new_table", " new_clear", " new_conn", "new__cache", "newAcconn", " new_buffer", "new67size", "new_clear", "new_table", "newAcsize", "new_config", "new_buffer", "newAcscore", "new_conn", "new67cache", "new67score", "new__table", "new_score", "new67conn", " new_config", " new_score", "newAccache", "new__size"], "ret": ["sat", "feat", "reg", "ut", "def", "ig", "obj", "gt", "ref", "hard", "result", "val", "part", "arg", "ft", "det", "Ret", "mt", "fit", "pre", "info", "bit", "res", "cat", "final", "data", "fin", "code", "fun", "success", "ext", "out", "num", "match", "let", "RET", "rt", " Ret", "mem", "flag", "reply", "re", "pat", "len", "req", "alt", "nt", "lit", "wrap", "format", "rets"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void *rom_ptr(target_phys_addr_t addr)\n\n{\n\n    Rom *rom;\n\n\n\n    rom = find_rom(addr);\n\n    if (!rom || !rom->data)\n\n        return NULL;\n\n    return rom->data + (addr - rom->addr);\n\n}\n", "idx": 26225, "substitutes": {"addr": ["ref", "node", "md", "code", "seq", "obj", " address", "Address", "arm", "name", "dr", "x", "asm", "data", "base", "pointer", "ad", "align", "address", "type", "dd", "port", "id", "alias", "url", "pad", "amp", "arr", "adr", "grad", "rm", "start", "ord", "loc", "offset", "coord", "order", "target", "hop", "ptr", "ar", "off", "arg", "dist", "amd", "rt", "ext", "nr", "rx", "src", "alt", "host", "index", "inter", "r", "pos", "ace", "rr", "attr", "tx", "len"], "rom": ["hom", "ru", "comm", " chrom", "rome", "comb", "cm", "ril", "RM", "m", "arm", "rod", "cry", "rn", "roll", "norm", "om", "cr", "am", "chrome", "ROM", "dom", "prom", "rob", "Rom", "dem", "ram", "cmd", "rc", "rm", "stim", "sym", "ray", "ros", "ctr", "tro", "com", "rock", "irm", "ro", "co", "roc", "roman", "rim", "im", "mod", "rem", "ore", "roy", "aram", "sim", "drm", "cum", "rx", "mm", "coll", "r", "rum", "chrom"]}}
{"project": "qemu", "commit_id": "4a19f1eced611e7c3a0fba07d13515cbc73da09f", "target": 0, "func": "static void do_info_version(Monitor *mon)\n\n{\n\n    monitor_printf(mon, \"%s\\n\", QEMU_VERSION);\n\n}\n", "idx": 17092, "substitutes": {"mon": ["m", "mag", "demon", "pid", "eor", "md", "ann", "mi", "mn", "channel", "comm", "module", "master", "arm", "mun", "mc", "dim", "bean", " monitor", "atom", "dog", "bo", "com", "con", "mons", "man", "chron", "meter", "chan", "mor", "don", "Monitor", "domain", "monitor", "MON", "an", "conn", "Mon", "mu"]}}
{"project": "qemu", "commit_id": "0d82d0e8b98cf0ea03a45f8542d835ebd3a84cd3", "target": 0, "func": "static ssize_t buffered_flush(QEMUFileBuffered *s)\n\n{\n\n    size_t offset = 0;\n\n    ssize_t ret = 0;\n\n\n\n    DPRINTF(\"flushing %zu byte(s) of data\\n\", s->buffer_size);\n\n\n\n    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {\n\n        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);\n\n        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,\n\n                                    to_send);\n\n        if (ret <= 0) {\n\n            DPRINTF(\"error flushing data, %zd\\n\", ret);\n\n            break;\n\n        } else {\n\n            DPRINTF(\"flushed %zd byte(s)\\n\", ret);\n\n            offset += ret;\n\n            s->bytes_xfer += ret;\n\n        }\n\n    }\n\n\n\n    DPRINTF(\"flushed %zu of %zu byte(s)\\n\", offset, s->buffer_size);\n\n    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);\n\n    s->buffer_size -= offset;\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    return offset;\n\n}\n", "idx": 20200, "substitutes": {"s": ["ns", "spec", "full", "settings", "service", "ss", "cs", "d", "new", "qs", "sym", "p", "h", "us", "sets", "comments", "ms", "m", "ts", "sg", "rs", "aws", "o", "su", "the", "side", "v", "si", "S", "a", "ds", "uns", "f", "r", "sb", "as", "this", "l", "ins", "sync", "c", "ps", "secondary", "b", "sys", "your", "es", "sq", "less", "sf", "session", "t", "conf", "services", "n", "g", "i", "ls", "ops", "fs", "xs", "en", "is", "site", "e", "ssl", "ses", "js", "gs", "its", "os", "server", "u"]}}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    int ret, fd;\n\n    uint32_t new_vid;\n\n    SheepdogInode *inode;\n\n    unsigned int datalen;\n\n\n\n    dprintf(\"sn_info: name %s id_str %s s: name %s vm_state_size %\" PRId64 \" \"\n\n            \"is_snapshot %d\\n\", sn_info->name, sn_info->id_str,\n\n            s->name, sn_info->vm_state_size, s->is_snapshot);\n\n\n\n    if (s->is_snapshot) {\n\n        error_report(\"You can't create a snapshot of a snapshot VDI, \"\n\n                     \"%s (%\" PRIu32 \").\", s->name, s->inode.vdi_id);\n\n\n\n        return -EINVAL;\n\n    }\n\n\n\n    dprintf(\"%s %s\\n\", sn_info->name, sn_info->id_str);\n\n\n\n    s->inode.vm_state_size = sn_info->vm_state_size;\n\n    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;\n\n    /* It appears that inode.tag does not require a NUL terminator,\n\n     * which means this use of strncpy is ok.\n\n     */\n\n    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n\n\n    /* refresh inode. */\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        ret = fd;\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    if (ret < 0) {\n\n        error_report(\"failed to write snapshot's inode.\");\n\n        goto cleanup;\n\n    }\n\n\n\n    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,\n\n                       s->addr, s->port);\n\n    if (ret < 0) {\n\n        error_report(\"failed to create inode for snapshot. %s\",\n\n                     strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    inode = (SheepdogInode *)g_malloc(datalen);\n\n\n\n    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),\n\n                      s->inode.nr_copies, datalen, 0, s->cache_enabled);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to read new inode info. %s\", strerror(errno));\n\n        goto cleanup;\n\n    }\n\n\n\n    memcpy(&s->inode, inode, datalen);\n\n    dprintf(\"s->inode: name %s snap_id %x oid %x\\n\",\n\n            s->inode.name, s->inode.snap_id, s->inode.vdi_id);\n\n\n\ncleanup:\n\n    closesocket(fd);\n\n    return ret;\n\n}\n", "idx": 899, "substitutes": {"bs": ["js", "cs", "ss", "bh", "rs", "qs", "ts", "sa", "sb", "lb", "BS", "aws", "bid", "bc", "ins", "ms", "pb", "ses", "ls", "ds", "bas", "gs", "ps", "ns", "vs", "bi", "bos", "gb", "bt", "as", "bb", "iss", "b", "os", "fs", "obs", "ssl"], "sn_info": ["snallinfo", "ns_init", "snacInfo", "snamconfig", "snappsource", "snACINFO", "serv_info", "snaminf", "syn_info", "syn_service", "serv_information", "snameopt", "sn8Info", "snameinformation", "snallinf", "nsallfamily", "syn_inf", "sn8info", " sn_diff", "snameinf", "sameopt", "sn_diff", "sn_inf", "nsallinfo", "kn_iso", "syn_off", "sn_iso", "sn_config", " sn8Info", "ns_family", "sn_init", "snappoff", "snaminformation", "snameconfig", "sn7ami", "sn7info", "sn_ami", "s_opt", "snamservice", "sn8diff", "sn_def", "sn_opt", "sn_service", "syn_source", "sl_def", "sn7def", "kn_Info", "sn7Info", "sl_ami", "snaminfo", "sn5inf", "s_source", "s_info", "servaminf", "samesource", "sn5family", "snacinfo", "sn_INFO", " sn_id", "servaminfo", "snACiso", " sn8inf", "syn_Info", "snallfamily", "snappinfo", "servamconfig", "kn_INFO", "sn_fo", "sn_information", " sn8info", " sn_fo", "sameinfo", "sn_id", "snameinfo", "serv_inf", " sn8diff", "sn8source", "knacInfo", "sn8inf", "sn5info", "snACinfo", "snallinit", "sn_source", "nsallinit", "servaminformation", "knacINFO", " sn_inf", "sl_Info", "snappinf", "knacinfo", "serv_config", "ns_info", "knaciso", "snamesource", "sn_off", "sn_family", "sn5init", "sl_info", "snacINFO", "snamInfo", " sn_Info", "snACInfo", "kn_info", "sn8opt", "sn_Info", "ns_inf", "nsallinf", "snaciso"], "s": ["sg", "js", "sa", "qs", "n", "sites", "sl", "g", "ses", "ls", "sf", "args", "self", "us", "f", "secondary", "sys", "sum", "fs", "spec", "ts", "sb", "y", "uns", "xs", "sv", "request", "sets", "p", "state", "e", "conf", "as", "sn", "uses", "v", "su", "site", "S", "t", "session", "ks", "its", "in", "sym", "ssl", "cs", "ss", "rs", "a", "r", "is", "ins", "i", "m", "info", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "o", "si", "server", "service", "ops", "d", "results", "ms", "sis", "params", "details", "sync", "l", "services", "w", "sq", "stats", "b", "full", "states"], "ret": ["base", "arg", "fun", "att", "mt", "def", "bit", "conn", "hash", "ror", "data", "success", " Ret", "ct", "alt", "cat", "format", "id", "pet", "rets", "arr", "num", "pass", "rb", "info", "nt", "ft", "rev", "str", "back", "feat", "Ret", "rc", "bf", "opt", "sat", "reply", "result", "et", "fin", "nb", "len", "ref", "flag", "rl", "gt", "fat", "resp", "art", "RET", "valid", "af", "lit", "reg", "re", "val", "rt", "let", "part", "pt", "fi", "det", "res", "db"], "fd": ["fc", "fun", "ff", "ld", "dn", "fs", "dd", "conn", "FD", "raf", "fa", "flo", "d", "ad", "alt", "dl", "lf", "fl", "ln", "fn", "buf", "rb", "dy", "draft", "fp", "ft", "df", "cb", "dt", "md", "cond", "func", "bf", "fe", "dc", "feed", "fin", "f", "hd", "bd", " fid", "cd", "fat", "resp", "fx", "handler", "wd", "fm", "exec", "bb", "fee", "fb", "cf", "td", "nd", "dir", "fi", "wat", "gd", "db"], "new_vid": ["new_virt", "newnewpin", "newnewsid", "old_sid", "new_pid", " new_pid", "old_vid", "new_addr", "newAvirt", "new_pin", "newAvid", "new_uid", " new_virt", "newtuid", " new_addr", "newAaddr", "newnewuid", "old_pin", "newtpin", "newApid", "new_sid", "newnewvid", "newtsid", "old_uid", "newtvid"], "inode": ["INade", "Inoder", " inoder", "infoding", "noder", "ninODE", "arinole", "innhole", "linade", "nube", " inodi", "inname", "axade", "dinute", "dinode", "ninade", "ninode", "Inore", "inhole", "arinovo", " inODE", "incoe", "axore", "vinute", "ninovo", "innoder", "gnode", "arinoder", " inova", "rinoding", "rinoder", "INoder", "infode", "dinova", "innode", "ginoder", " inonymous", "Inodi", "inoding", "INovo", "INoding", "incode", "innade", "innnode", "vinoder", "ginode", "nODE", "INode", " inome", "ancode", "Inole", "ninoder", "innome", " inhole", "INole", "ancodi", " inole", "linote", "dinoder", "gnoe", "Inoding", "inoder", "incoder", "innole", "ginODE", "riname", "inoe", "INube", "ancole", "ancoding", "inovo", "ginade", "incnode", " inade", "INore", "INote", "inore", "gnoder", "ninole", "iname", " inoding", "innoe", "inube", "gnonymous", "inODE", "rinoe", " inute", "axode", "infoder", " iname", "arinode", "node", "Inote", "inome", "infame", "Iname", "INODE", "rinode", "INhole", "innonymous", "axoding", "linode", "inodi", "Inoe", "linoding", "vinode", "InODE", "inole", "rinole", "Inade", " inube", "inade", "inova", "inote", "INome", " inoe", "inute", "Innode", "innODE", "inonymous", "vinova", "Inode"], "datalen": ["datalener", "dallens", "daliston", "dalen", "Daleno", "daclon", "dstalen", "dalledEN", "davalEN", "daclen", "duledens", "dalledent", "daleno", "daclener", "dalener", "Dalon", "dalsten", " dalens", "datalens", "duleden", " dalEN", "DatalEN", "Dalener", "Dalent", "davalener", "datalsten", "datalent", "dalEN", "dalistEN", "dalon", " dalsten", "datalon", "dallsten", "dstalent", "davalender", "Dalender", "dalistener", "dalender", " datalsten", "datalEN", "Datalent", "davalen", "daclender", "dalisten", "daclEN", "DalEN", " dalen", "datalender", "Datalon", "duledsten", "dalledeno", "dallEN", "duledEN", "Datalen", "Dataleno", "Datalener", "Datalender", " datalens", "dalleden", "dataleno", "dstalEN", "dalens", "dallen", "dalent", " datalEN", "Dalen", "dstaleno"]}}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_2_9_class_options(MachineClass *mc)\n\n{\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->gs_allowed = false;\n\n    ccw_machine_2_10_class_options(mc);\n\n    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);\n\n    s390mc->css_migration_enabled = false;\n\n}\n", "idx": 25831, "substitutes": {"mc": ["md", "cm", "dc", "uc", "class", "m", "anc", "c", "ml", "dr", "module", "cci", "doc", "ec", "config", "mi", "cus", "bc", "mr", "Mc", "mac", "mic", "fc", "ic", "vc", "spec", " MC", "model", "wic", "cc", "ci", "cn", "rc", "lc", "ca", "MC", "tc", "mm", "coll", "arc", "nc", "ac", "pc"], "s390mc": ["s350mac", "s170mac", "s30mm", "s40mc", "s390module", " s390mac", " s90cci", "s390mm", " s90module", "s350mc", "s350mi", "s390cc", "s390dc", "S170mc", "s170dc", "s390mac", "s170MC", "s090mc", "s30MC", " s30mm", "s390cci", "S390mac", " s30mi", "s170mc", "s90cc", "s30mc", "s30mi", "s350mm", "s090cc", " s390mm", " s390cci", "S170MC", " s390cc", "s40module", " s90mc", " s30mac", " s90cc", "s90cci", "s370MC", "s390mi", " s30mc", "s370dc", "S390mc", "s90mc", "s310mc", " s390mi", "S390MC", "s370mac", "s310mi", "s370mc", "S170mac", "s30mac", "s390MC", "s40cci", "s090cci", "S390dc", " s390module", "S170dc", "s090module", "s90module", "s310mm", "s310mac", "s40cc", "s30dc"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void musicpal_lcd_write(void *opaque, target_phys_addr_t offset,\n\n                               uint64_t value, unsigned size)\n\n{\n\n    musicpal_lcd_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_LCD_IRQCTRL:\n\n        s->irqctrl = value;\n\n        break;\n\n\n\n    case MP_LCD_SPICTRL:\n\n        if (value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD) {\n\n            s->mode = value;\n\n        } else {\n\n            s->mode = MP_LCD_SPI_INVALID;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_INST:\n\n        if (value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7) {\n\n            s->page = value - MP_LCD_INST_SETPAGE0;\n\n            s->page_off = 0;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_DATA:\n\n        if (s->mode == MP_LCD_SPI_CMD) {\n\n            if (value >= MP_LCD_INST_SETPAGE0 &&\n\n                value <= MP_LCD_INST_SETPAGE7) {\n\n                s->page = value - MP_LCD_INST_SETPAGE0;\n\n                s->page_off = 0;\n\n            }\n\n        } else if (s->mode == MP_LCD_SPI_DATA) {\n\n            s->video_ram[s->page*128 + s->page_off] = value;\n\n            s->page_off = (s->page_off + 1) & 127;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 16862, "substitutes": {"opaque": ["copaques", "ipec", "operacity", "oponymous", "ipque", "copaque", "copec", "pque", "OPonymous", "opec", "opacity", "OPque", "operaque", "ospacity", "ipaques", "paques", "operque", "paque", "OPaque", "operonymous", "copque", "ipaque", "pec", "OPacity", "opaques", "ospaque", "osponymous", "opque", "ospque"], "offset": ["set", "scale", "skip", "data", "mode", "Offset", "bit", "fp", "f", "attribute", "from", "align", "option", "num", "reference", "padding", "index", "pos", "timeout", "pointer", "o", "ip", "location", "slot", "aque", "alias", "oid", "seed", "reset", "prefix", "length", "start", "parent", "position", "p", "off", "address", "pad", "shift", "error", "addr", "port", "operation"], "value": ["set", "element", "volume", "comment", "service", "money", "num", "max", "reference", "padding", "always", "non", "no", "length", "id", "VALUE", "total", "area", "feature", "resource", "none", "va", "end", "valid", "command", "values", "m", "scale", "Value", "name", "media", "done", "timeout", "description", "style", "flow", "key", "when", "v", "off", "null", "iv", "port", "expression", "native", "image", "current", "block", "ou", "type", "node", "function", "vi", "home", "page", "gap", "val", "array", "email", "memory", "w", "ue", "start", "amount", "selected", "address", "fee", "version", "hello", "data", "mode", "info", "buffer", "option", "i", "index", "member", "create", "format", "complete", "unit", "wa", "number", "message", "server"], "size": ["set", "scale", "data", "SIZE", "buffer", "type", "padding", " amount", " bytes", "count", " address", " error", "ize", "length", "address", "fee", " buffer", "bytes", "Size", " length", "len"], "s": ["ns", "spec", "strings", "settings", "service", "ss", "copy", "cs", "d", "new", "sym", "p", "h", "us", "sets", "comments", "source", "m", "ts", "sg", "rs", "self", "o", "su", "v", "si", "S", "a", "hs", "port", "ds", "status", "uns", "f", "r", "sb", "uploads", "this", "l", "ins", "sync", "c", "ps", "secondary", "sum", "sys", "your", "es", "state", "states", "sq", "params", "sf", "session", "t", "data", "conf", "services", "n", "plugins", "g", "sl", "ls", "ops", "fs", "is", "sites", "site", "e", "ssl", "ses", "js", "gs", "its", "os", "server", "u"]}}
{"project": "FFmpeg", "commit_id": "38bb5a5434f913451aa512624a92b12b9925690f", "target": 0, "func": "void mpeg4_encode_picture_header(MpegEncContext * s, int picture_number)\n\n{\n\n    int time_incr;\n\n    int time_div, time_mod;\n\n\n\n    if(s->pict_type==AV_PICTURE_TYPE_I){\n\n        if(!(s->flags&CODEC_FLAG_GLOBAL_HEADER)){\n\n            if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT) //HACK, the reference sw is buggy\n\n                mpeg4_encode_visual_object_header(s);\n\n            if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT || picture_number==0) //HACK, the reference sw is buggy\n\n                mpeg4_encode_vol_header(s, 0, 0);\n\n        }\n\n        if(!(s->workaround_bugs & FF_BUG_MS))\n\n            mpeg4_encode_gop_header(s);\n\n    }\n\n\n\n    s->partitioned_frame= s->data_partitioning && s->pict_type!=AV_PICTURE_TYPE_B;\n\n\n\n    put_bits(&s->pb, 16, 0);                /* vop header */\n\n    put_bits(&s->pb, 16, VOP_STARTCODE);    /* vop header */\n\n    put_bits(&s->pb, 2, s->pict_type - 1);  /* pict type: I = 0 , P = 1 */\n\n\n\n    assert(s->time>=0);\n\n    time_div= s->time/s->avctx->time_base.den;\n\n    time_mod= s->time%s->avctx->time_base.den;\n\n    time_incr= time_div - s->last_time_base;\n\n    assert(time_incr >= 0);\n\n    while(time_incr--)\n\n        put_bits(&s->pb, 1, 1);\n\n\n\n    put_bits(&s->pb, 1, 0);\n\n\n\n    put_bits(&s->pb, 1, 1);                             /* marker */\n\n    put_bits(&s->pb, s->time_increment_bits, time_mod); /* time increment */\n\n    put_bits(&s->pb, 1, 1);                             /* marker */\n\n    put_bits(&s->pb, 1, 1);                             /* vop coded */\n\n    if (    s->pict_type == AV_PICTURE_TYPE_P\n\n        || (s->pict_type == AV_PICTURE_TYPE_S && s->vol_sprite_usage==GMC_SPRITE)) {\n\n        put_bits(&s->pb, 1, s->no_rounding);    /* rounding type */\n\n    }\n\n    put_bits(&s->pb, 3, 0);     /* intra dc VLC threshold */\n\n    if(!s->progressive_sequence){\n\n         put_bits(&s->pb, 1, s->current_picture_ptr->top_field_first);\n\n         put_bits(&s->pb, 1, s->alternate_scan);\n\n    }\n\n    //FIXME sprite stuff\n\n\n\n    put_bits(&s->pb, 5, s->qscale);\n\n\n\n    if (s->pict_type != AV_PICTURE_TYPE_I)\n\n        put_bits(&s->pb, 3, s->f_code); /* fcode_for */\n\n    if (s->pict_type == AV_PICTURE_TYPE_B)\n\n        put_bits(&s->pb, 3, s->b_code); /* fcode_back */\n\n}\n", "idx": 14872, "substitutes": {"s": ["native", "i", "rs", "qs", "h", "new", "status", "js", "si", "server", "ps", "admin", "share", "spec", "c", "is", "states", "args", "m", "self", "bis", "d", "t", "sync", "sg", "fs", "sym", "ches", "g", "cs", "es", "full", "session", "storage", "w", "u", "sf", "b", "ns", "results", "ops", "r", "comm", "sports", "ks", "sys", "parts", "service", "your", "details", "source", "hs", "os", "sets", "scope", "o", "ms", "e", "obs", "http", "site", "sb", "f", "services", "ls", "comments", "ses", "as", "l", "a", "er", "S", "its", "uns", "sq", "conf", "ss", "request", "set", "p", "se", "plugins", "ions", "n", "gs", "xs", "ssl", "side", "ds", "su", "ts", "us", "y"], "picture_number": ["pictureityindex", "pictureIdnumber", "picture_length", "pictureIddata", "pictureIdnum", " picture_index", "image_numbered", "pictureitynum", "image_number", "image_num", " picture_num", "pictureIdnumbered", "picture_index", "image_data", "pictureitylength", "picture_numbered", "pictureitynumber", "picture_data", "picture_num", " picture_length"], "time_incr": ["time_decr", "time_integru", "time_incrb", "time_integtr", "time_deccr", "time_Incrb", "time_integr", "time_decrx", "time_increcr", "time_integrx", "time_inctr", "time_decrc", "time_incrx", "time_incrc", "time_dectr", "time_incru", "time_Inccr", "time_decrb", "time_integerc", "time_increr", "time_integrb", "time_increrc", "time_increrr", "time_wincr", "time_corr", "time_winrar", "time_winrc", "time_incrar", "time_decrr", "time_inccr", "time_incrr", "time_corru", "time_increerc", "time_Incr", "time_winr", "time_integrr", "time_integcr", "time_decru", "time_incerc", "time_corcr", "time_cortr", "time_decerc", "time_integrc", "time_increrar", "time_Incrx", "time_decrar"], "time_div": ["timeCdiv", "timeCdev", "weight_div", "weight_mod", "time_init", "time00val", "time_base", "weight_val", "time_division", "time\u00b7mod", "weight00div", " time_dev", " time_division", "weight00def", "time_val", "time\u00b7dev", " time_init", " time_base", "time_dev", "time00mod", "time00def", "weight00mod", "time00div", "weight_def", "timeCinit", "timeCdivision", "time\u00b7base", "time_def", "weight00val", "time\u00b7div"], "time_mod": [" time_sign", "timealldiv", "time54dig", " time_inc", " time_dim", "time_dim", "timeallinc", "time_mult", "time_sign", "time___mult", "time54div", " time_mult", "time54mod", " time_dig", "timeallmodule", "timeallsign", "timeallmod", "time54dim", "time_module", "time_inc", "timeallmult", "time___div", "time___mod", "time_dig", " time_module", "time___sign"]}}
{"project": "qemu", "commit_id": "338c25b6929b5436a42aaa106c7e9136cf1ff4dc", "target": 1, "func": "static int htab_save_later_pass(QEMUFile *f, sPAPREnvironment *spapr,\n\n                                int64_t max_ns)\n\n{\n\n    bool final = max_ns < 0;\n\n    int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64;\n\n    int examined = 0, sent = 0;\n\n    int index = spapr->htab_save_index;\n\n    int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n\n\n    assert(!spapr->htab_first_pass);\n\n\n\n    do {\n\n        int chunkstart, invalidstart;\n\n\n\n        /* Consume non-dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && !HPTE_DIRTY(HPTE(spapr->htab, index))) {\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        chunkstart = index;\n\n        /* Consume valid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        invalidstart = index;\n\n        /* Consume invalid dirty HPTEs */\n\n        while ((index < htabslots)\n\n               && HPTE_DIRTY(HPTE(spapr->htab, index))\n\n               && !HPTE_VALID(HPTE(spapr->htab, index))) {\n\n            CLEAN_HPTE(HPTE(spapr->htab, index));\n\n            index++;\n\n            examined++;\n\n        }\n\n\n\n        if (index > chunkstart) {\n\n            int n_valid = invalidstart - chunkstart;\n\n            int n_invalid = index - invalidstart;\n\n\n\n            qemu_put_be32(f, chunkstart);\n\n            qemu_put_be16(f, n_valid);\n\n            qemu_put_be16(f, n_invalid);\n\n            qemu_put_buffer(f, HPTE(spapr->htab, chunkstart),\n\n                            HASH_PTE_SIZE_64 * n_valid);\n\n            sent += index - chunkstart;\n\n\n\n            if (!final && (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) {\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (examined >= htabslots) {\n\n            break;\n\n        }\n\n\n\n        if (index >= htabslots) {\n\n            assert(index == htabslots);\n\n            index = 0;\n\n        }\n\n    } while ((examined < htabslots) && (!qemu_file_rate_limit(f) || final));\n\n\n\n    if (index >= htabslots) {\n\n        assert(index == htabslots);\n\n        index = 0;\n\n    }\n\n\n\n    spapr->htab_save_index = index;\n\n\n\n    return (examined >= htabslots) && (sent == 0) ? 1 : 0;\n\n}\n", "idx": 10180, "substitutes": {"f": ["l", "uf", "rf", "conf", "xf", "fo", "fen", "g", "ff", "af", "sf", "w", "m", "fr", "fd", "t", "b", "files", "fw", "d", "i", "c", "fb", "s", "p", "e", "fp", "exec", "feed", "cf", "df", "fm", "bf", "tf", "v", "r", "framework", "elf", "this", "fn", "form", "F", "file", "fs", "func", "fi", "fe", "fc"], "spapr": ["sphapri", "Spaperb", "scaprb", "spapener", "spakr", "yparpner", "chapr", "scapsra", "sppplr", "spaperr", "scapprn", "ypapner", "sparpner", "spavner", "sessionaprs", "sppprc", "spopril", "spaprb", "paprb", "spaperrb", "spakrb", "spafR", "spapar", "spaptrar", "slarprc", "chapar", "spacrar", "sparpra", "spappR", "slapri", "spashrn", "spaplr", "spapersr", "asphapri", "spappner", "spappri", "sppprs", "slapr", "spashrar", "scaprc", "spippr", "spakrn", "spAPrc", "scapprg", "sessionapru", "spapran", "spapsrc", "spajrar", "yparpra", "spaperR", "spajra", "papR", "spacrc", "Spapr", "spashra", "asphapru", "chaprar", "spappr", "sphapr", "spAPsr", "sessionppr", "spoprar", "spacar", "sparprar", "chopril", "pAPrb", "pAPr", "spaptri", "yparpr", "spppru", "spAPr", "Spaperc", "spapsrin", "spaprin", "pAPR", "spafra", "spaptr", "papsr", "sessionpprs", "spapsra", "spapsri", "spapprn", "scaprn", "ypapr", "sessionaplr", "spashr", "spacra", "scapprb", "papr", "aspapri", "sparpru", "sessionpplr", "spaptar", "aspapr", "slarpri", "spaper", "sparprg", "ypapra", "spafrc", "scaprg", "spaprc", "slaprc", "spapplr", "spappsr", "spaprs", "spacner", "spavr", "spavrc", "speprs", "speplr", "spepru", "ypaprar", "sessionppru", "spappru", "slarpr", "sparpri", "spajrn", "spampran", "spapru", "sphaprs", "scapsR", "spipprin", "spacril", "Spapran", "spapprs", "spapsran", "spapprc", "spappra", "aspapru", "spppr", "spippran", "scappr", "Spapsrin", "asphaprs", "scapprc", "spapner", "Spaper", "Spapsran", "spacr", "scapru", "Spapner", "chopr", "pAPsr", "yparprc", "sppprg", "scapsrc", "spapri", "choprar", "spapprg", "spajr", "spapril", "ypaprc", "spAPrn", "scapR", "chapril", "spapsr", "aspaprs", "asphapr", "spAPR", "sessionapr", "spapra", "spopr", "spaprar", "scapsr", "spopar", "ypaprn", "yparprar", "spapsR", "sparpr", "spaprn", "Spaprb", "sphapru", "spapR", "spAPra", "spepr", "scapra", "spakrc", "spapprb", "yparprn", "sparprc", "spaperc", "spamprin", "spavrb", "sparprn", "spaperb", "scappru", "spafr", "scapr", "spaprg", "Spaprin", "spaptril", "Spapsr", "spaptru", "Spapener", "spaptrs", "spampr", "Spaprc", "spAPrb", "chopar"], "max_ns": ["max_nas", "max_bs", "max__ls", " max_mins", "max_ls", "maxFbs", " max_nas", " max_ls", "maxFls", " max_rss", "max__rss", "max__ns", "maxFnas", "max_mins", "max__mins", " max_bs", "max_rss", "maxFns"], "chunkstart": [" chorkstop", " chorkstart", "Chunksstart", " ChunkStart", "chiffstyle", "chiffstarting", "Chunkstart", "shankend", "chanstop", " Chunkend", "chaultstarting", "chacketsize", " chunkinit", " chaultstyle", "chashstop", "chankst", "chacketinit", "chunkstop", " chunkstarting", "chanstart", "ChunksStart", "chacketStart", " Chanstart", "chacketstop", " ChanStart", "chaultstyle", " chunkpad", "chipstart", "hacketset", "Chunksize", "hunkend", "chaultstop", "chacksize", "Chunkend", "Chunksset", "shankst", "chacketpad", " chaultstart", "Chunksend", "chanStart", "chackst", "chackStart", " Chunkstop", "chunkpad", "chunksstop", "chunkend", "chackend", "hunkset", "chunksset", " Chunkstart", "chunkset", "chackset", "chunksstart", " chaultstop", "shankStart", "chunkstarting", "chorkpad", "chunkssize", " chorkpad", "chunksend", "chackstart", " Chanstop", "chashstart", "shunkst", "chankstart", " Chanend", "chipStart", "chorkstart", "chorkstyle", "chipend", "chorkstarting", "chorkstop", "chashpad", "chanend", "chankStart", "hunkStart", "chiffstop", " chunkstyle", "chankset", "chaultstart", "hunkstart", "chunksStart", "hacketend", " chaultstarting", "chunkst", " chunkstop", "chacketend", "chunkStart", "shunkstart", "chankend", "Chunkssize", "chacketstart", "chunksize", "chunkstyle", "hacketstart", "chorkinit", " chorkinit", "ChunkStart", "chiffstart", "shankstart", "chipset", "hacketStart", "shunkStart", "chunkinit", "Chunkset", "chacketset", "chashinit", "shunkend"], "invalidstart": ["inbrokenoffset", "Incompleteend", "Incompletestar", "invalidstop", "invalidindex", "nvalstop", "INcompatiblestarted", "Invalidend", "insecurestart", "nvalidend", "incompletestop", "inasticend", "invalidend", "nvalstart", "incompatibleindex", "nvalidstop", "inlegalStart", "infreshstart", "invalidoffset", "INvalidoffset", "INcompatibleoffset", "inlegalindex", "invalend", "inbrokenstarted", " inbrokenStart", " invalidset", "INvalidstart", " invalidindex", "incompatiblestarted", "nvalidstart", "infreshstarted", "incompleteset", "insecureset", "infreshindex", "invalidset", "INcompatibleindex", "inbadset", "insecureend", "insecurestar", "inasticoffset", "incompleteoffset", "Invalidstar", "incompleteend", "inbrokenset", "Incompleteset", "INvalidstarted", "INvalidindex", "incompletestart", "inbrokenstart", "nvalend", "Invalidstart", "inbadindex", "inasticstart", "inregularset", "INcompatiblestart", "nvaloffset", "inbrokenindex", "invaloffset", "inregularstar", "invalidStart", "inbadStart", "invalstart", "inasticstop", "inregularend", "Invalidset", "nvalidoffset", "incompatibleoffset", "incompletestar", "inlegalset", "inregularstart", "inbrokenStart", "inbadstart", "invalidstar", "infreshoffset", " inbrokenindex", " inbrokenset", "inlegalstart", "invalidstarted", " inbrokenstart", "Incompletestart", " invalidStart", "invalstop", "incompatiblestart"], "index": ["count", "updated", "connect", "section", "find", "point", "connected", "path", "x", "de", "block", "config", "thread", "set", "condition", "loc", "body", "found", "connection", "end", "document", "offset", "form", "type", "online", "localhost", "element", "dim", "si", "n", "date", "key", "view", "id", "open", "total", "i", "expression", "output", "request", "value", "unit", "slice", "ind", "input", "current", "example", "position", "list", "error", "ticket", "root", "insert", "fix", "opened", "context", "initial", "len", "temp", "second", "page", "num", "add", "action", "socket", "alpha", "version", "column", "sync", "old", "part", "available", "cache", "engine", "weight", "diff", "original", "active", "start", "axis", "ini", "Index", "update", "run", "ix", "search", "route", "inc", "name", "address", "option", "pos", "length", "match", "pattern"], "examined": ["exAMine", "exambining", "xambined", "exAMinated", "examritten", "examine", "exummented", "xamided", "exambinated", "exasmritten", "examinated", " exummented", "exAMining", " exambined", " examinated", " examine", "ExAMined", " exambritten", "exAMored", "xambine", " exambinated", "exAMmented", "exAMined", "examinining", "exambored", "exameinated", "exambmented", "examining", "ExAMored", " exumined", "examinined", "exambined", "Examined", "exasmmented", "Examine", "Examining", "examinored", "xamine", "examored", "exameine", " exammented", " exumine", " examritten", "xaminated", "exameided", "exAMritten", " exuminated", "exameined", "examinine", "exambided", "xamined", "exAMided", "exasminated", " exambmented", "exumine", "xambided", "exambine", "xambinated", "ExAMine", "exasmined", "exuminated", "ExAMining", "examided", "exammented", "Examored", "exambritten", "exumined"]}}
{"project": "FFmpeg", "commit_id": "69e7336b8e16ee65226fc20381baf537f4b125e6", "target": 0, "func": "AVInputFormat *av_find_input_format(const char *short_name)\n\n{\n\n    AVInputFormat *fmt = NULL;\n\n    while ((fmt = av_iformat_next(fmt)))\n\n        if (match_format(short_name, fmt->name))\n\n            return fmt;\n\n    return NULL;\n\n}\n", "idx": 22559, "substitutes": {"short_name": ["Short_path", "shortPpath", "Short_Name", "Short_NAME", "short_Name", "short2names", "short2name", "short_names", "short_NAME", "shortFnames", "shortPName", "shortFpath", "short2NAME", "shortnameNAME", "short2size", "Short_names", "Short_size", "shortPnames", "short_size", "shortPname", "shortnamesize", "Short_name", "short_path", "shortFname", "shortnamename", "shortFName", "shortnamenames"], "fmt": ["Fatter", "Fbf", "compatter", " flt", "fatt", "complt", "formmd", "bmt", "blt", " fbf", "bpl", " fatter", "Fpr", "Flt", " fmd", "formnt", "frnt", " fMT", "Fnt", "compmt", "tfmt", "fatter", "Fpl", "tfmd", "compbf", "fbf", " fnt", "fMT", "fpl", "formlt", "ufpl", "Fmd", "fpr", "frlt", "fmd", "fnt", "tfatt", "frmt", "tflt", " fatt", "Fmt", "tfMT", "ufmt", "formmt", "FMT", "ufpr", "tfnt", "frmd", "flt", "uflt", "Fatt", "bpr"]}}
{"project": "qemu", "commit_id": "1da41cc1c6c3efbe2ed47228068bd80dbdc49d0e", "target": 0, "func": "static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)\n\n{\n\n    int i;\n\n    GICState *s = KVM_ARM_GIC(dev);\n\n    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);\n\n    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);\n\n\n\n    kgc->parent_realize(dev, errp);\n\n    if (error_is_set(errp)) {\n\n        return;\n\n    }\n\n\n\n    i = s->num_irq - GIC_INTERNAL;\n\n    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.\n\n     * GPIO array layout is thus:\n\n     *  [0..N-1] SPIs\n\n     *  [N..N+31] PPIs for CPU 0\n\n     *  [N+32..N+63] PPIs for CPU 1\n\n     *   ...\n\n     */\n\n    i += (GIC_INTERNAL * s->num_cpu);\n\n    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);\n\n    /* We never use our outbound IRQ lines but provide them so that\n\n     * we maintain the same interface as the non-KVM GIC.\n\n     */\n\n    for (i = 0; i < s->num_cpu; i++) {\n\n        sysbus_init_irq(sbd, &s->parent_irq[i]);\n\n    }\n\n    /* Distributor */\n\n    memory_region_init_reservation(&s->iomem, OBJECT(s),\n\n                                   \"kvm-gic_dist\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    kvm_arm_register_device(&s->iomem,\n\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n\n                            | KVM_VGIC_V2_ADDR_TYPE_DIST);\n\n    /* CPU interface for current core. Unlike arm_gic, we don't\n\n     * provide the \"interface for core #N\" memory regions, because\n\n     * cores with a VGIC don't have those.\n\n     */\n\n    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s),\n\n                                   \"kvm-gic_cpu\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->cpuiomem[0]);\n\n    kvm_arm_register_device(&s->cpuiomem[0],\n\n                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)\n\n                            | KVM_VGIC_V2_ADDR_TYPE_CPU);\n\n}\n", "idx": 9039, "substitutes": {"dev": ["diff", "conf", "gu", "gd", "di", "cam", "debug", "ds", "tr", "dom", "test", "Dev", "w", "conn", "info", "def", "prom", "temp", "die", "development", "dem", "d", "ver", "de", "data", "ad", "p", "pro", "driver", "rad", "serial", "priv", "hw", "mode", "ev", "device", "md", "req", "mod", "bus", "spec", "dm", "grad", "self", "der", "ch"], "errp": ["erp", "corpc", "rrpc", "rrlp", "rrc", "erpi", "corP", " errpi", "erlp", "erc", " errc", "rrp", "errP", "errpc", "erP", "Erpi", "err", "erpc", "corlp", "errlp", "Erp", "errc", "errpi", "rrP", "Erc", "Erpc", "corp", "ErP", " errr", "Err", "errr"], "i": ["oi", "l", "hi", "ui", "di", "it", "start", "si", "n", "in", "zi", "adi", "m", "xi", "id", "info", "k", "t", "ini", "z", "x", "ami", "d", "b", "c", "p", "ix", "uri", "e", "yi", "mu", "mini", "eni", "f", "j", "ai", "o", "multi", "index", "v", "gi", "ti", "mi", "phi", "udi", "abi", "qi", "pi", "bi", "ii", "init", "u", "I", "li", "ip", "ci", "a", "io", "ni", "lc", "y", "ri", "fi", "iu", "anti"], "s": ["l", "session", "is", "its", "m", "http", "t", "gs", "parts", "sk", "none", "v", "state", "ns", "spec", "self", "settings", "sg", "ds", "n", "si", "w", "b", "k", "c", "e", "args", "us", "f", "j", "sym", "es", "r", "as", "u", "this", "ps", "su", "site", "fs", "ss", "sh", "ks", "sv", "g", "d", "sa", "ls", "os", "cs", "o", "sync", "south", "sl", "new", "sb", "sys", "a", "ssl", "ts", "service", "p", "server", "qs", "xs", "js", "rs", "S", "services", "sd", "less", "h", "ses", "y"], "sbd": ["wsBD", "csbd", " sbt", "psBD", " sdb", "csmd", " sbot", "wsbot", "sdb", "psdb", " sfd", "wsdb", "asbd", " sld", "sgd", "sld", " sgd", "wsbd", " sBD", "csBD", "Sbt", " smd", "psfd", "wsmd", "wsfd", "sfd", "Sbd", " sda", "wsld", "csfd", "sBD", "sda", "Sda", "asld", "asbot", "psbd", "smd", "asBD", "sbt", "sbot", "Sgd"], "kgc": [" gccl", "ggl", "pkgc", "kgl", " gccc", "dkc", "pkgb", " gcccc", "ggb", "kgd", "kgpc", "skl", "pkgd", "dkcc", " gccpc", "ggd", "kgb", "skd", "pkgpc", "pkgl", "dkpc", "kgcc", "dkl", "pkgcc", "ggc", "skb", "skc"]}}
{"project": "qemu", "commit_id": "7873df408dd44eb92840b108211d5aa5db7db526", "target": 0, "func": "static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,\n\n                            const char *model, const char *name,\n\n                            const char *ifname, const char *script,\n\n                            const char *downscript, const char *vhostfdname,\n\n                            int vnet_hdr, int fd)\n\n{\n\n    TAPState *s;\n\n\n\n    s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);\n\n    if (!s) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    if (tap_set_sndbuf(s->fd, tap) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd || tap->has_fds) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);\n\n    } else if (tap->has_helper) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"helper=%s\",\n\n                 tap->helper);\n\n    } else {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n                 \"ifname=%s,script=%s,downscript=%s\", ifname, script,\n\n                 downscript);\n\n\n\n        if (strcmp(downscript, \"no\") != 0) {\n\n            snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);\n\n            snprintf(s->down_script_arg, sizeof(s->down_script_arg),\n\n                     \"%s\", ifname);\n\n        }\n\n    }\n\n\n\n    if (tap->has_vhost ? tap->vhost :\n\n        vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {\n\n        int vhostfd;\n\n\n\n        if (tap->has_vhostfd) {\n\n            vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname);\n\n            if (vhostfd == -1) {\n\n                return -1;\n\n            }\n\n        } else {\n\n            vhostfd = -1;\n\n        }\n\n\n\n        s->vhost_net = vhost_net_init(&s->nc, vhostfd,\n\n                                      tap->has_vhostforce && tap->vhostforce);\n\n        if (!s->vhost_net) {\n\n            error_report(\"vhost-net requested but could not be initialized\");\n\n            return -1;\n\n        }\n\n    } else if (tap->has_vhostfd || tap->has_vhostfds) {\n\n        error_report(\"vhostfd= is not valid without vhost\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7490, "substitutes": {"tap": ["tr", "data", "raf", "typ", "wt", "mp", "snap", "td", "pn", "json", "kat", "span", "sp", "ppa", "tk", "tp", "trip", "pb", "setup", "tc", "cp", "tool", "tf", "config", "pod", "wp", "ap", "apt", "xml", "tu", "tif", "php", "spl", "tick", "tw", "ts", "jp", "tin", "amp", "tip", "cap", "capt", "form", "opa", "bp", "python", "pin", "pa", "tun", "gap", "wa", "num", "att", "pc", "np", "submit", "t", "tm", "p", "input", "temp", "wal", "prop", "TP", "api", "tta", "png", "trace", "session", "pd", "skip", "pipe", "tar", "window", "project", "tim", "request", "ta", "oga", "Tap"], "peer": ["address", "gp", "pid", "er", "friend", "ep", "parent", "pro", "device", "scope", "channel", "rb", "pp", "socket", "enc", "pipe", "sys", "pe", "player", "state", "server", "pc", "e", "port", "eps", "p", "reader", "ptr", "request", "pointer", "node", "proc", "slave", "ppa", "ssl", "type", "tp", "pair", "pb", "seed", "mode"], "model": ["base", "address", "plugin", "models", "layer", "dm", "parent", "scope", "channel", "config", "pe", "module", "xml", "m", "image", "cm", "db", "package", "client", "pri", "prot", "server", "param", "owner", "zip", "instance", "ctx", "fp", "controller", "source", "stage", "reader", "slave", "ssl", "handler", "location", "sym", "lc", "Model", "mode"], "name": ["base", "time", "na", "id", "parent", "word", "data", "alias", "family", "named", "info", "image", "names", "key", "profile", "package", "client", "version", "vision", "Name", "part", "action", "NAME", "size", "path", "filename", "nam", "mini", "new", "type", "label", "term", "host", "nice", "prefix"], "ifname": ["switchName", " ifno", "Ifsize", " ifName", "switchsize", "tifname", "iffname", "Ifno", "switchnames", "ifnames", "ifsize", "Ifname", "IFnames", "tifsize", "ifno", "ifName", "tifnames", "iftype", "Ifnames", "IFtype", " ifnames", "Iftype", "switchname", "iffsize", " ifsize", "ifftype", "tifno", "iffnames", "IFsize", "IFname", "tifName"], "script": ["writer", "sec", "fee", "scope", "config", "password", "data", "secret", "slice", "image", "tx", "media", "scripts", "code", "control", "sc", "proxy", "file", "sd", "esc", "cript", "sign", "lib", "timeout", "exec", "javascript", "fn", "pass", "source", "input", "ip", "ssl", "desc", "test", "src", "command", "Script", "prefix"], "downscript": [" downsh", " downScript", " downtext", "ownscripts", "crossscript", "downScript", "upcode", "ownscript", "ownScript", "upScript", " downstyle", "crosssh", "downsh", "subscripts", "dropscript", "dropScript", "droptext", " downcript", "upscript", "ownstyle", "subscript", "upcript", "uptext", " downcode", "downcode", " downscripts", "downscripts", "downstyle", "downcript", "subcode", "crossscripts", "upscripts", "upstyle", "crosscript", "dropscripts", "upsh", "downtext"], "vhostfdname": ["vhostFDname", "vhomefname", "vhostdfname", "vhostdfnm", "vhostfdno", "vHostfdnames", "vhostdfdef", "vhostfdnumber", "vhostdnames", "vhostfdnames", "vhostFDName", "vhostfname", "vhostfnumber", "vhostdnumber", "vhostddnumber", "vhosthandlernm", "vhostfdnm", "vhostdname", "vhosthandlername", "vHostdnumber", "vhostddno", "vhostFDnm", "vhomefno", "vhostdName", "vhostFDdef", "vHostfdnumber", "vhostdfName", "vHostdnames", "vHostfdName", "vHostdname", "vhostddnames", "vhostfName", "vhomefnames", "vhostfnnames", "vhostfnname", "vhomefdnames", "vHostfdname", "vhostfdName", "vhostfnno", "vhosthandlerdef", "vhostfno", "vhostddName", "vhostddname", "vhosthandlerName", "vhomefdno", "vhomefdname", "vhostfddef", "vhostfnames", "vHostdName"], "vnet_hdr": ["vnetxvst", "vnetxhrt", "vnet_wbr", "vnet_bhdr", "vnetxhbr", "vnet_vst", "vnetxvbr", "vnet_shrt", "vnetxhdr", "vnet_vdr", "vnetxhst", "vnetxvdr", "vnet_hicit", "vnet_wdr", "vnet_wst", "vnet_bhrt", "vnet_frt", "vnet_hbr", "vnet_shicit", "vnet_ficit", "vnet_vrt", "vnet_vbr", "vnet_wrt", "vnet_bhicit", "vnet_hst", "vnetxvrt", "vnet_hrt", "vnet_shdr", "vnet_fdr"], "fd": ["writer", "function", "std", "fen", "flow", "pid", "feed", "nw", "sf", "fw", "bd", "dn", "dat", "dd", "config", "pd", "socket", "format", "pipe", "stream", "fed", "fx", "fb", "db", "wb", "fin", "f", "client", "d", "fl", "fe", "director", "td", "dir", "connection", "file", "dc", "fn", "df", "sd", "ds", "fp", "cb", "FD", "fa", "input", "temp", " fid", "fm", "pointer", "fs", "ln", "cond", "fun", "write", "handler", "dl", "fc", "cf", "dt", "fi", "form", "nd", "ff", "af"], "s": ["sf", "S", "b", "socket", "i", "f", "service", "conf", "self", "h", "aws", "sp", "sa", "g", "sym", "y", "sets", "sites", "is", "spec", "fts", "sw", "services", "https", "server", "sl", "ls", "native", "ops", "ts", "settings", "sv", "fs", "new", "sq", "your", "site", "rs", "python", "sg", "comments", "sync", "sn", "ses", "cs", "u", "an", "e", "submit", "sb", "secondary", "t", "qs", "tests", "p", "c", "os", "ssl", "r", "ps", "o", "v", "http", "session", "si", "sys", "m", "l", "ns", "us", "ss", "gs", "se", "n", "su", "es", "js"], "vhostfd": [" vhostdd", "vhostpd", "vhopda", "vhardfe", "vportf", "vworkfd", "vhomefe", "vHostdd", "vhostfp", "vhostda", "svhostdc", " vHostfd", " vhomedl", "vfrontpd", "svhostpd", "vhardf", " vhostda", "svhostfe", "vhardfd", " vhostfp", "vformatfc", "vhostfe", "vfrontfd", " vhostdl", "vvisfd", "vvisFD", "vhomedraft", "vconnectfc", "vworkd", "vhopfd", "svhardf", "svhardfd", "vhostdc", "vserverfd", "vconnectdl", "vhardff", "vvisdd", "vhostff", " vhostfc", "vconnectdraft", " vhomefd", " vhostff", "vhomepd", " vhostdraft", "vhostdl", "vfrontfc", "vportdc", "vhardd", " vworkff", "vHostda", "vserverfx", " vhomedraft", "vpoold", "vhomefx", " vHostdd", "vportfd", "vserverfc", "vhostd", "vhostdd", " vHostda", "vhomefc", "vformatdl", "vhostfx", " vworkfp", "vHostfd", "svhostf", " vhostFD", "vformatdraft", " vworkd", "vworkff", "vhopdd", "vhomedc", "vhomedl", "vworkfp", "svhostfc", "vserverpd", "svhostfd", "svserverfd", "vfrontfx", " vhomefc", "svhostfx", "vpoolfd", "vhostFD", "vhostfc", "vharddc", "vformatfd", "vhopFD", "vconnectfd", "vhostf", "vhomef", "vpoolff", "vportfe", " vHostFD", "svhardfe", "svserverfx", "svserverfc", "vHostFD", " vworkfd", "vhostdraft", "vhomefd", "svserverpd", "vpoolfp", "vvisda", " vhostd", "vhardfp", "svharddc"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "static void vnc_connect(VncDisplay *vd, int csock,\n\n                        bool skipauth, bool websocket)\n\n{\n\n    VncState *vs = g_malloc0(sizeof(VncState));\n\n    int i;\n\n\n\n    vs->csock = csock;\n\n    vs->vd = vd;\n\n\n\n    if (skipauth) {\n\n\tvs->auth = VNC_AUTH_NONE;\n\n\tvs->subauth = VNC_AUTH_INVALID;\n\n    } else {\n\n        if (websocket) {\n\n            vs->auth = vd->ws_auth;\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        } else {\n\n            vs->auth = vd->auth;\n\n            vs->subauth = vd->subauth;\n\n        }\n\n    }\n\n    VNC_DEBUG(\"Client sock=%d ws=%d auth=%d subauth=%d\\n\",\n\n              csock, websocket, vs->auth, vs->subauth);\n\n\n\n    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));\n\n    }\n\n\n\n    VNC_DEBUG(\"New client on socket %d\\n\", csock);\n\n    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n\n    qemu_set_nonblock(vs->csock);\n\n    if (websocket) {\n\n        vs->websocket = 1;\n\n        if (vd->ws_tls) {\n\n            qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io, NULL, vs);\n\n        } else {\n\n            qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);\n\n        }\n\n    } else\n\n    {\n\n        qemu_set_fd_handler(vs->csock, vnc_client_read, NULL, vs);\n\n    }\n\n\n\n    vnc_client_cache_addr(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);\n\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);\n\n\n\n    if (!vs->websocket) {\n\n        vnc_init_state(vs);\n\n    }\n\n\n\n    if (vd->num_connecting > vd->connections_limit) {\n\n        QTAILQ_FOREACH(vs, &vd->clients, next) {\n\n            if (vs->share_mode == VNC_SHARE_MODE_CONNECTING) {\n\n                vnc_disconnect_start(vs);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 15389, "substitutes": {"vd": ["vision", "vr", "d", "fd", "vv", "VD", "vp", "vid", "bd", "td", "dl", "ud", "ve", "di", "vm", "nd", "ld", "v", "gd", "help", "pd", "cd", "ant", "ad", "sd", "xd", "gb", "cover", "library", "df", "dt", "vg", "uds", "md", "ov", "sv", "va", "nv", "rt", "vo", "ds", "dd", "hd", "vc", "od", "dn", "dr", "vt", "wd", "lv"], "csock": ["cksock", "csody", " csink", "rsock", "dsocks", "jsick", "psorp", "bsink", "dsocker", "Csock", "vsocket", "psocket", "ciock", "cksocket", "jsocked", "psink", "cocks", "ssocker", "Csink", "ksocked", "cusocket", "cocked", "cssock", "rsocked", " csocket", "dsocked", "cssOCK", "csorp", "ksocket", "jsock", "ciink", "ksink", "cksocked", "vsock", "rsocket", "vsorp", "gsink", "bsOCK", "ssocket", "ssocked", "codesOCK", "ksocker", "cssink", " csick", "cocket", "csocked", "ciorp", "codesocket", "cock", "codesock", "cusock", "vsody", "vsick", "dsocket", "bsocket", "psock", "csink", "vsocker", "dsock", "bsock", "cssocket", "ksocks", "vsink", "csocks", "csocker", "dsink", "cusocked", "ksock", "wsocket", "csocket", "jsocket", "gsody", "csOCK", "resOCK", "codesink", "rsocker", "wsock", "wsink", "ssock", "gsick", " csody", "resock", "wsOCK", "Csocker", "cksick", " csocker", "dsOCK", "resink", "gsock", "Csocket", "cusick", "resocket", "ciocket", "csick"], "skipauth": [" skiputh", "skipauthent", "allowauth", "allowuth", "copyauthent", "copyacl", "allowauthent", "copyuth", "Skipauth", "allowAuth", "copyauth", "skipacl", "missingacl", "Skiputh", "Skipauthent", "missingauth", " skipacl", "skipAuth", "skiputh", "missingauthent", "missinguth", " skipauthent", " skipAuth", "SkipAuth"], "websocket": ["website", " weckset", "wealsession", "wealswitch", "rebspace", "websock", "webersession", "wealsocket", "weversocket", "wealsockets", "wecksite", "weversockets", "wecksockets", "shebswitch", "weasockets", "rebsocket", " websockets", "wecksock", "weasocket", "weblogocket", "wessession", "rebsockets", "reaswitch", "webset", "websockets", "weaswitch", "wecksource", "webswitch", "rebswitch", "webspace", "wessock", "wessocket", "wecksocket", "weversock", "pebsockets", " webset", "wesset", "shebsockets", "weckset", "weblogock", "webersockets", "wessite", "hebsock", "weaspace", "reasocket", "wesswitch", "websource", "pessockets", "hessystem", "wessource", "pebsocket", " website", "wecsocket", "webersocket", "pessocket", "pebscript", "wessystem", "weckswitch", "shebsock", "webscript", "shecksocket", "wesspace", "pebsession", "pesscript", "wecsockets", "wealscript", "weberscript", "wecsite", "weblogystem", "hebsystem", "weblogource", "reaspace", "websession", "websystem", "weverswitch", "wealsock", "hebsocket", "sheckswitch", "hebsource", "hessocket", " wecksocket", "shecksock", " wecksockets", "wecksystem", "wesscript", "reasockets", "wessockets", "hessource", " wecksite", "hessock", "pessession", "weckspace", "shecksockets", "shebsocket", "wecset"], "vs": ["vers", "env", "versions", "vp", "rs", "verts", "qs", "js", "ps", "eps", "ums", "lines", "asts", "sv", "events", "las", "fs", "ins", "Vs", "iv", "ups", "pages", "cs", "vm", "es", "nav", "views", "s", "ns", "nv", "ops", "vt", "res", "vals", "ks", "vr", "cv", "values", "pg", "hs", "os", "fg", "vi", "ves", "ms", "VS", "obs", "alls", "otes", "http", "state", "vg", "va", "services", "ls", "pos", "net", "as", "vv", "bs", "vid", "changes", "sk", "its", "nets", "v", "ss", "var", "flags", "vas", "gs", "wp", "blogs", "xs", "ports", "stats", "ov", "ds", "vc", "css", "ts", "ils", "sts"], "i": ["hi", "qi", "it", "ui", "I", "d", "t", "ai", "ni", "xi", "id", "iu", "l", "gi", "a", "io", "oi", "mu", "ci", "di", "x", "si", "ii", "v", "vi", "o", "yi", "u", "z", "p", "e", "fi", "li", "b", "base", "multi", "j", "ix", "n", "f", "phi", "ti", "ip", "c", "eni", "pi", "uli", "q", "r", "bi", "gui", "ri", "zi", "abi", "index"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static int svq1_decode_init(AVCodecContext *avctx)\n\n{\n\n    MpegEncContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    MPV_decode_defaults(s);\n\n\n\n    s->avctx = avctx;\n\n    s->width = (avctx->width+3)&~3;\n\n    s->height = (avctx->height+3)&~3;\n\n    s->codec_id= avctx->codec->id;\n\n    avctx->pix_fmt = PIX_FMT_YUV410P;\n\n    avctx->has_b_frames= 1; // not true, but DP frames and these behave like unidirectional b frames\n\n    s->flags= avctx->flags;\n\n    if (MPV_common_init(s) < 0) return -1;\n\n\n\n    init_vlc(&svq1_block_type, 2, 4,\n\n        &svq1_block_type_vlc[0][1], 2, 1,\n\n        &svq1_block_type_vlc[0][0], 2, 1);\n\n\n\n    init_vlc(&svq1_motion_component, 7, 33,\n\n        &mvtab[0][1], 2, 1,\n\n        &mvtab[0][0], 2, 1);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        init_vlc(&svq1_intra_multistage[i], 3, 8,\n\n            &svq1_intra_multistage_vlc[i][0][1], 2, 1,\n\n            &svq1_intra_multistage_vlc[i][0][0], 2, 1);\n\n        init_vlc(&svq1_inter_multistage[i], 3, 8,\n\n            &svq1_inter_multistage_vlc[i][0][1], 2, 1,\n\n            &svq1_inter_multistage_vlc[i][0][0], 2, 1);\n\n    }\n\n\n\n    init_vlc(&svq1_intra_mean, 8, 256,\n\n        &svq1_intra_mean_vlc[0][1], 4, 2,\n\n        &svq1_intra_mean_vlc[0][0], 4, 2);\n\n\n\n    init_vlc(&svq1_inter_mean, 9, 512,\n\n        &svq1_inter_mean_vlc[0][1], 4, 2,\n\n        &svq1_inter_mean_vlc[0][0], 4, 2);\n\n\n\n    return 0;\n\n}\n", "idx": 17742, "substitutes": {"avctx": ["avecp", "afconv", "AVcv", "awcf", "afcu", "ajcontext", "avecf", "avcoll", "afcfg", "svcontext", "avhw", "ovcli", " avhw", "aircli", "svconv", " avcp", "ovcontext", "afsync", "AVlc", "avsync", "AVctx", " avcontext", "mpci", "mpcam", "afcoll", "navcontext", "avvoc", "airctx", "avcfg", "macctx", "avlc", "aveconn", "ajcv", " avloc", "avecu", "avcp", "ajcfg", "mpcf", "AVloc", " avcf", "maccontext", "afvoc", "ajlc", " avcv", "machw", "navctx", "svctx", "avcv", "afcf", "avcam", "avcli", "ajctx", " avcoll", "ajconv", "airsync", "AVsync", " avci", "awctx", "ajloc", "avconv", "navcf", "svcfg", "ajsync", "avcf", "ovctx", "afcp", "afci", "avecoll", "avloc", " avvoc", "AVcontext", "ovsync", "mpconn", "mpcontext", "avectx", "afcam", "mpctx", "aflc", "aircontext", "awcontext", "afhw", "navcu", "afcontext", "avconn", "afctx", "avci", "avecontext", "afconn", "maccf", "awvoc", "afcli", " avcam", "avcu", "avcontext"], "s": ["ns", "spec", "m", "sup", "session", "sg", "ts", "t", "data", "stats", "aws", "f", "conf", "services", "service", "n", "sb", "g", "ss", "ls", "ops", "ctx", "sec", "fs", "xs", "o", "cs", "l", "d", "bis", "qs", "e", "ssl", "ses", "sync", "v", "c", "js", "private", "si", "sym", "p", "secondary", "S", "b", "http", "gs", "sys", "h", "storage", "a", "es", "os", "server", "sq", "an", "ds", "sf"], "i": ["ti", "gi", "uri", "ic", "bi", "j", "ik", "t", "info", "x", "f", "image", "ix", "ini", "qi", "ai", "mi", "io", "phi", "g", "hi", "type", "ii", "ie", "ori", "iu", "di", "slice", "ind", "I", "multi", "zi", "ip", "chi", "d", "oi", "yi", "pi", "ui", "ci", "abi", "id", "key", "e", "q", "v", "cli", "ni", "lc", "si", "ki", "ri", "xi", "p", "b", "uli", "a", "iv", "ia", "api", "it", "eni", "fi", "inner", "y", "li", "u"]}}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_stat(void *opaque)\n\n{\n\n    int32_t fid;\n\n    V9fsStat v9stat;\n\n    ssize_t err = 0;\n\n    size_t offset = 7;\n\n    struct stat stbuf;\n\n    V9fsFidState *fidp;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"d\", &fid);\n\n    trace_v9fs_stat(pdu->tag, pdu->id, fid);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);\n\n    if (err < 0) {\n\n        goto out;\n\n    }\n\n    offset += pdu_marshal(pdu, offset, \"wS\", 0, &v9stat);\n\n    err = offset;\n\n    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,\n\n                           v9stat.atime, v9stat.mtime, v9stat.length);\n\n    v9fs_stat_free(&v9stat);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, err);\n\n}\n", "idx": 2820, "substitutes": {"opaque": ["opacity", "ospacity", "OPacity", "Opca", "ospaque", "Opec", "opca", " opac", "opac", "OPac", "OPace", "opace", " opacity", "ospca", "ipec", "ipaque", "ipca", "OPaque", "ospec", "Opacity", "ipace", "ipac", "ipacity", " opace", "opec", "Opaque"], "fid": ["cname", "pID", " fids", "fpbid", "feids", "fpid", "fide", "ckid", "fkid", "pids", "lfids", "cfide", "febid", "lfid", "fekid", "cide", "lid", "fcbid", "fida", "rbid", "feid", "prid", " fide", "lfname", "fpida", "rid", " fname", "fids", "pid", "fID", "frid", "lfide", "cfida", "cids", "cid", "fname", "fcide", "fbid", "fpide", "lids", " fID", "rids", "rkid", "cfbid", "fcida", " frid", "cfid", "cbid", "lrid", "lID", "fcid"], "v9stat": ["V6stats", "f8status", "V9Stat", "V09log", "f9status", "m09stats", "V9status", "v6Stat", "v9stats", "m09not", "v8stat", "m9stat", "V8tag", "f8STAT", "v94status", "V9stat", "v8STAT", "V6min", "V09status", "f8stats", "v6min", "v8Stat", "m9log", "v91log", "v09stat", "v94stat", "v94stats", "m09log", "f9stat", "f9stats", "v9log", "v09not", "v9tag", "v9login", "v8init", "v94init", "vnineSTAT", "v9not", "V6stat", "V6login", "v_stat", "V9log", "m09stat", "V8status", "v09status", "v6stats", "v6log", "V09stat", "v91status", "v9status", "vninestats", "v6status", "v89stat", "v89log", "V6status", "v09stats", "v8log", "m9stats", "v_status", "v8login", "v89not", "v91stat", "V9min", "v9STAT", "v09min", "v09init", "vninelogin", "v09log", "V09stats", "v8tag", "vninestatus", "v8status", "v8min", "v_Stat", "v6stat", "v1stat", "f9init", "v91tag", "v6login", "v9Stat", "vninestat", "v8stats", "f9STAT", "V6Stat", "f8stat", "m9not", "V8stat", "V9stats", "V9login", "v_stats", "v1log", "v9min", "v6STAT", "v1tag", "V9tag", "v9init", "v1status", "v89stats", "f8init", "V8log"], "stbuf": ["Stbuf", "restfd", "stfd", "stfunc", "ostfd", "stdb", "stcv", "stbuffer", "stafd", "stabuffer", "sthbuf", "Stdb", "sthdata", "Stfd", "stvec", "ostbuf", "Stdata", "STfunc", "strfd", " stcv", "restbuf", "sthfd", "Stcv", " stfunc", "stabuf", "ostvec", "stdata", "restdb", "stavec", "restdata", "STcv", "strbuf", "STbuf", "Stfunc", "strbuffer", "sthdb", "ostbuffer", "strvec"], "fidp": ["faidr", "fidu", "fpidc", "fIDv", "fidv", "ofardv", "filpa", " faidpa", "ofidu", "fidpc", " fidpc", " faidf", "nardpe", "fiddp", "fidenp", "fuidpr", "fstartv", "fstartpc", " fidr", "fardpc", "fstartp", "fIdpc", "fardpr", "nidlp", " fidf", "fardp", "fiddv", "fiddu", "fidpa", "fIdv", "nidp", "fuidlp", "fardv", "fardpe", "fpidpc", "fpidp", "fardu", " fidv", " fIdp", " fidu", "fipp", "fidenpr", "ofidv", "ofardpc", "filp", "fuidpe", "fipf", "fidenpe", " faidp", "fidx", "fuidp", "nidpr", "filr", "fidex", "fidpr", " fIdu", "faidp", " faidr", "ofardp", "ofidpc", "nidpe", "fpidr", "fidenlp", "nardp", "faidf", "fiddpc", "fipr", "fIDr", "fidr", "fippa", "ofardu", "fidep", "fidlp", "fardlp", " fidc", "fIDp", "fider", "fIDu", "fIdx", " fidx", " fidpa", "fidc", "fidpe", "fIdr", "fIdp", "filf", "fiddr", "nardlp", "faidpa", "fIdu", "fidec", "ofidp", "fIdc", " fIdr", "fstartu", " fIdv", "nardpr", "fidf"], "pdu": ["bcu", "puu", "pcu", "Ptu", " ptu", "epuu", "bpuu", "sptu", "bpuc", "chtu", "ipcu", "Psu", "puc", " pud", "hdu", "bptu", "opdu", "ptu", "Pcu", "chuc", "psu", "ruu", "apdu", " psu", "cpde", "epdu", "copru", "ccu", "spdu", "opde", "pde", "fsu", "pud", "csu", "Pru", "nptu", "copdu", "ddu", "fde", "apuu", "cpdu", "ffu", " pcu", "hda", "opcu", "ipdu", "cpsu", "fcu", "bdu", "ftu", "Pdu", "spcu", "ctu", "fdu", "hcu", "cpcu", "copsu", "rtu", "copcu", "bpdu", "buu", "cptu", "dfu", "dru", "copuu", "npuu", "chuu", " pda", "aptu", "epuc", "Puu", "cda", "copfu", "fud", " pde", "Pud", "apcu", "opuu", "fuu", "eptu", "cdu", "dcu", "pda", "npdu", " puu", "optu", "Pde", " pru", "rdu", "iptu", "opru", "ipuu", "chdu", "spsu", "fru", "htu", "pru", "rru", "pfu", "npcu"], "s": ["sg", "server", "http", "ss", "ops", "spec", "a", "rs", "sb", "r", "d", "n", "is", "uploads", "scope", "i", "g", "m", "ses", "args", "sync", "settings", "storage", "gs", "ns", "h", "c", "p", "or", "state", "w", "e", "f", "secondary", "sys", "u", "south", "o", "v", "stats", "b", "S", "t", "session", "os", "location", "states", "fs", "sym", "ssl"]}}
{"project": "qemu", "commit_id": "f3db17b9514b8d724f8d6111a9f9608ff8bad631", "target": 1, "func": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n\n    return chr;\n\n}", "idx": 20761, "substitutes": {"chr": ["echrr", " chrr", " chrs", "chrb", "Chr", "chrs", "chrc", " chru", "ichrc", "echrc", "corrs", " chlr", "chlr", "chru", " chrc", "corr", "ichr", "Chlr", "ichrr", "corrb", "echru", "echr", "ichru", "chrr", "Chrb", "Chrs", "corlr", " chrb"]}}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_sws_init_swScale_mmx(SwsContext *c)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if HAVE_INLINE_ASM\n\n    if (cpu_flags & AV_CPU_FLAG_MMX)\n\n        sws_init_swScale_MMX(c);\n\n#if HAVE_MMXEXT_INLINE\n\n    if (cpu_flags & AV_CPU_FLAG_MMXEXT)\n\n        sws_init_swScale_MMX2(c);\n\n#endif\n\n#endif /* HAVE_INLINE_ASM */\n\n\n\n#if HAVE_YASM\n\n#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \\\n\n    if (c->srcBpc == 8) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 9) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \\\n\n    } else if (c->srcBpc == 10) { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \\\n\n    } else /* c->srcBpc == 16 */ { \\\n\n        hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \\\n\n                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \\\n\n    } \\\n\n} while (0)\n\n#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \\\n\n    }\n\n#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \\\n\nswitch(c->dstBpc){ \\\n\n    case 16:                          do_16_case;                          break; \\\n\n    case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \\\n\n    case 9:  if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \\\n\n    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \\\n\n    }\n\n#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \\\n\n    switch(c->dstBpc){ \\\n\n    case 16: if (!isBE(c->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \\\n\n    case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \\\n\n    case 9:  if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \\\n\n    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \\\n\n    }\n\n#define case_rgb(x, X, opt) \\\n\n        case PIX_FMT_ ## X: \\\n\n            c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \\\n\n            if (!c->chrSrcHSubSample) \\\n\n                c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \\\n\n            break\n\n#if ARCH_X86_32\n\n    if (cpu_flags & AV_CPU_FLAG_MMX) {\n\n        ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx);\n\n        ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_Y400A:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_mmx;\n\n            break;\n\n        case PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_mmx;\n\n            c->chrToYV12 = ff_yuyvToUV_mmx;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_mmx;\n\n            c->chrToYV12 = ff_uyvyToUV_mmx;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_mmx;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_mmx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, mmx);\n\n        case_rgb(bgr24, BGR24, mmx);\n\n        case_rgb(bgra,  BGRA,  mmx);\n\n        case_rgb(rgba,  RGBA,  mmx);\n\n        case_rgb(abgr,  ABGR,  mmx);\n\n        case_rgb(argb,  ARGB,  mmx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1);\n\n    }\n\n#endif /* ARCH_X86_32 */\n\n#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \\\n\n    switch (filtersize) { \\\n\n    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \\\n\n    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \\\n\n    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \\\n\n             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \\\n\n             break; \\\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSE2) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_Y400A:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            if (c->alpPixBuf)\n\n                c->alpToYV12 = ff_uyvyToY_sse2;\n\n            break;\n\n        case PIX_FMT_YUYV422:\n\n            c->lumToYV12 = ff_yuyvToY_sse2;\n\n            c->chrToYV12 = ff_yuyvToUV_sse2;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->lumToYV12 = ff_uyvyToY_sse2;\n\n            c->chrToYV12 = ff_uyvyToUV_sse2;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_sse2;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_sse2;\n\n            break;\n\n        case_rgb(rgb24, RGB24, sse2);\n\n        case_rgb(bgr24, BGR24, sse2);\n\n        case_rgb(bgra,  BGRA,  sse2);\n\n        case_rgb(rgba,  RGBA,  sse2);\n\n        case_rgb(abgr,  ABGR,  sse2);\n\n        case_rgb(argb,  ARGB,  sse2);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSSE3) {\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3);\n\n        switch (c->srcFormat) {\n\n        case_rgb(rgb24, RGB24, ssse3);\n\n        case_rgb(bgr24, BGR24, ssse3);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (cpu_flags & AV_CPU_FLAG_SSE4) {\n\n        /* Xto15 don't need special sse4 functions */\n\n        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3);\n\n        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,\n\n                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        if (c->dstBpc == 16 && !isBE(c->dstFormat))\n\n            c->yuv2plane1 = ff_yuv2plane1_16_sse4;\n\n    }\n\n\n\n    if (cpu_flags & AV_CPU_FLAG_AVX) {\n\n        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,\n\n                            HAVE_ALIGNED_STACK || ARCH_X86_64);\n\n        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);\n\n\n\n        switch (c->srcFormat) {\n\n        case PIX_FMT_YUYV422:\n\n            c->chrToYV12 = ff_yuyvToUV_avx;\n\n            break;\n\n        case PIX_FMT_UYVY422:\n\n            c->chrToYV12 = ff_uyvyToUV_avx;\n\n            break;\n\n        case PIX_FMT_NV12:\n\n            c->chrToYV12 = ff_nv12ToUV_avx;\n\n            break;\n\n        case PIX_FMT_NV21:\n\n            c->chrToYV12 = ff_nv21ToUV_avx;\n\n            break;\n\n        case_rgb(rgb24, RGB24, avx);\n\n        case_rgb(bgr24, BGR24, avx);\n\n        case_rgb(bgra,  BGRA,  avx);\n\n        case_rgb(rgba,  RGBA,  avx);\n\n        case_rgb(abgr,  ABGR,  avx);\n\n        case_rgb(argb,  ARGB,  avx);\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 3153, "substitutes": {"c": ["cm", "cs", "ctx", "cc", "mc", "context", "ct", "nc", "bc", "cur", "con", "k", "ac", "m", "coll", "cr", "ch", "C", "ec", "dc", "ce", "cu", "p", "l", "cv", "e", "lc", "f", "u", "center", "vc", "pc", "s", "v", "b", "t", "cf", "ci", "uc", "rc"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "uint8_t sd_read_data(SDState *sd)\n\n{\n\n    /* TODO: Append CRCs */\n\n    uint8_t ret;\n\n    int io_len;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable)\n\n        return 0x00;\n\n\n\n    if (sd->state != sd_sendingdata_state) {\n\n        fprintf(stderr, \"sd_read_data: not in Sending-Data state\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION))\n\n        return 0x00;\n\n\n\n    io_len = (sd->ocr & (1 << 30)) ? 512 : sd->blk_len;\n\n\n\n    switch (sd->current_cmd) {\n\n    case 6:\t/* CMD6:   SWITCH_FUNCTION */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 64)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 9:\t/* CMD9:   SEND_CSD */\n\n    case 10:\t/* CMD10:  SEND_CID */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 16)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 11:\t/* CMD11:  READ_DAT_UNTIL_STOP */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 13:\t/* ACMD13: SD_STATUS */\n\n        ret = sd->sd_status[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->sd_status))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 17:\t/* CMD17:  READ_SINGLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 18:\t/* CMD18:  READ_MULTIPLE_BLOCK */\n\n        if (sd->data_offset == 0)\n\n            BLK_READ_BLOCK(sd->data_start, io_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= io_len) {\n\n            sd->data_start += io_len;\n\n            sd->data_offset = 0;\n\n            if (sd->data_start + io_len > sd->size) {\n\n                sd->card_status |= ADDRESS_ERROR;\n\n                break;\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 22:\t/* ACMD22: SEND_NUM_WR_BLOCKS */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 30:\t/* CMD30:  SEND_WRITE_PROT */\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= 4)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 51:\t/* ACMD51: SEND_SCR */\n\n        ret = sd->scr[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sizeof(sd->scr))\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    case 56:\t/* CMD56:  GEN_CMD */\n\n        if (sd->data_offset == 0)\n\n            APP_READ_BLOCK(sd->data_start, sd->blk_len);\n\n        ret = sd->data[sd->data_offset ++];\n\n\n\n        if (sd->data_offset >= sd->blk_len)\n\n            sd->state = sd_transfer_state;\n\n        break;\n\n\n\n    default:\n\n        fprintf(stderr, \"sd_read_data: unknown command\\n\");\n\n        return 0x00;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 24206, "substitutes": {"sd": ["sch", "z", "cd", "sy", "ld", "gb", "ud", "ess", "sta", "nd", "dl", "lib", "ini", "st", "dt", "dev", "sci", "sa", "sm", "tf", "sim", "des", "service", "dm", "df", "md", "sk", "sem", "se", "dis", "sed", "ds", "ad", "bd", "su", "di", "wd", "ci", "vd", "od", "sl", "fd", "sh", "ss", "sn", "d", "isi", "data", "eddy", "sg", "sth", "gd", "sb", "lc", "zh", "sf", "sv", "ed", "dk", "std", "sc", "hd", "sam", "dd", "td", "ic", "pd", "dat", "si", "SD", "ln", "dist", "yd", "ind"], "ret": ["ref", "fin", "ft", "res", "pt", "data", "success", "att", "opt", "def", "id", "url", "all", "rets", "mem", "arr", "str", "get", "bit", "mt", "det", "lit", "rev", "RET", "re", "art", "nt", "reply", "rc", "feat", "let", "pat", "pet", "arg", "Ret", "rt", "reg", "alt", "resp", "match", "result", "len", "val", "gt", "ut", "fun"], "io_len": ["ioqlen", "net_del", "io_length", "ioqlimit", "io_offset", "control_lan", "control_width", "iofoff", "ioaclen", "feed_den", "feed_len", "ioxlan", "io67len", "ioambase", "cgiamoff", "io_base", " ioflen", "io_start", "io_field", "io_fin", " io_offset", "input_len", "control_len", " io_off", "cgiamcount", "io_count", "control00width", " iofden", " io_ln", "ioccbase", "io_min", "cgiambase", "iokcount", "control00lan", "io00lif", "feed_lim", "io67Len", "io_del", "inputaclen", "inputacln", " ioffin", "ioxlif", "input_lim", "io_den", "inputacstart", "cgiamlen", " io_width", "io67offset", "net_len", "io00len", "ioacln", "io32ln", "feed_limit", "iokbase", "io_lif", "io_lan", "io_off", "iocclen", "ioamoff", "control00len", "net_min", "ioacstart", "net_limit", "io_ln", "io_bin", "io_lim", "ioxlen", "ioklen", "input_ln", "data_len", "ioamcount", "ioqden", "io32field", "data_length", "cgi_off", " io_field", "ioflen", "io32offset", "ioaclim", "control00lif", "io_width", "io_Len", " io_den", " io_Len", "io_limit", "inputaclim", " iofoff", "io00width", "data_count", "io67width", "ioqlim", "ioffin", "ioccoff", "input_start", "iokoff", "iocccount", "control_lif", "io00lan", "iofden", " io_fin", "ioxwidth", "cgi_count", "data_bin", "cgi_len", "cgi_base", "ioamlen", "io32len"]}}
{"project": "FFmpeg", "commit_id": "4dec101acc393fbfe9a8ce0237b9efbae3f20139", "target": 0, "func": "int ff_dxva2_commit_buffer(AVCodecContext *avctx,\n\n                           AVDXVAContext *ctx,\n\n                           DECODER_BUFFER_DESC *dsc,\n\n                           unsigned type, const void *data, unsigned size,\n\n                           unsigned mb_count)\n\n{\n\n    void     *dxva_data;\n\n    unsigned dxva_size;\n\n    int      result;\n\n    HRESULT hr;\n\n\n\n#if CONFIG_D3D11VA\n\n    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)\n\n        hr = ID3D11VideoContext_GetDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context,\n\n                                                 D3D11VA_CONTEXT(ctx)->decoder,\n\n                                                 type,\n\n                                                 &dxva_size, &dxva_data);\n\n#endif\n\n#if CONFIG_DXVA2\n\n    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)\n\n        hr = IDirectXVideoDecoder_GetBuffer(DXVA2_CONTEXT(ctx)->decoder, type,\n\n                                            &dxva_data, &dxva_size);\n\n#endif\n\n    if (FAILED(hr)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to get a buffer for %u: 0x%x\\n\",\n\n               type, hr);\n\n        return -1;\n\n    }\n\n    if (size <= dxva_size) {\n\n        memcpy(dxva_data, data, size);\n\n\n\n#if CONFIG_D3D11VA\n\n        if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {\n\n            D3D11_VIDEO_DECODER_BUFFER_DESC *dsc11 = dsc;\n\n            memset(dsc11, 0, sizeof(*dsc11));\n\n            dsc11->BufferType           = type;\n\n            dsc11->DataSize             = size;\n\n            dsc11->NumMBsInBuffer       = mb_count;\n\n        }\n\n#endif\n\n#if CONFIG_DXVA2\n\n        if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {\n\n            DXVA2_DecodeBufferDesc *dsc2 = dsc;\n\n            memset(dsc2, 0, sizeof(*dsc2));\n\n            dsc2->CompressedBufferType = type;\n\n            dsc2->DataSize             = size;\n\n            dsc2->NumMBsInBuffer       = mb_count;\n\n        }\n\n#endif\n\n\n\n        result = 0;\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"Buffer for type %u was too small\\n\", type);\n\n        result = -1;\n\n    }\n\n\n\n#if CONFIG_D3D11VA\n\n    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)\n\n        hr = ID3D11VideoContext_ReleaseDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context, D3D11VA_CONTEXT(ctx)->decoder, type);\n\n#endif\n\n#if CONFIG_DXVA2\n\n    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)\n\n        hr = IDirectXVideoDecoder_ReleaseBuffer(DXVA2_CONTEXT(ctx)->decoder, type);\n\n#endif\n\n    if (FAILED(hr)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Failed to release buffer type %u: 0x%x\\n\",\n\n               type, hr);\n\n        result = -1;\n\n    }\n\n    return result;\n\n}\n", "idx": 25344, "substitutes": {"avctx": ["afcmd", "navcontext", "AVcmd", "AVcmp", "AVconfig", "abcontext", "abcv", "avecontext", "evcontext", "AVconn", "avcmp", "navpc", "afcmp", "verconn", "devconfig", "avcontext", "devctl", "vercontext", "devcontext", "avconfig", "afctx", "afcontext", "verpc", "AVpc", "evctx", "aveconfig", "avctl", "avectx", "avecv", "devctx", "svconfig", "svcontext", "abconfig", "abconn", "evconfig", "navcmp", "evconn", "abctx", "avpc", "navcmd", "AVctx", "avconn", "AVctl", "verctx", "svctx", "avcv", "svctl", "avcmd", "verconfig", "navctx", "AVcv", "AVcontext", "navconn"], "ctx": ["exec", "txt", "sc", "kw", "cca", "anc", "c", "pkg", "context", "cv", "qa", "storage", "sq", "config", "component", "cus", "bc", "concept", "mac", "kb", "ocr", "cmp", "hub", "hw", "grad", "cl", "cmd", "vc", "loc", "lib", "voc", "cli", "Context", "nt", "cp", "cn", "cf", "client", "rc", "ga", "sci", "conv", "req", "cas", "lc", "ctrl", "ca", "tc", "src", "conn", "fp", "cu", "qq", "crit", "tx", "cam", "kt"], "dsc": ["jsp", "gsp", "gsc", "fsp", " drc", "lrc", "bsp", "lesc", "Dsp", " desc", "prc", "pSC", "besc", "lsc", " dsp", "fesc", "fsc", "disc", " dbc", "bsc", "gbc", "pesc", "gisc", "Dbc", "dsp", "psc", " dSC", "bbc", "dbc", "Disc", "jisc", "drc", "lSC", "jbc", "Dsc", "fbc", "dSC", "jsc", "desc"], "type": ["slice", "class", "info", "none", "p", "name", "time", "test", "buffer", "attribute", "style", "pe", "ping", "types", "error", "version", "address", "kind", "op", "port", "url", "method", "typ", "id", "ity", "key", "unit", "http", "Type", "model", "role", "handler", "parent", "like", "client", "sort", "shape", "ype", "field", "length", "part", "rule", "TYPE", "y", "value", "ip", "t", "root", "event", "attr", "ty", "block", "pre", "table", "format"], "data": ["Data", "body", "byte", "none", "batch", "d", "image", "buffer", "media", "next", "reader", "ui", "raw", "buf", "message", "input", "dat", "zero", "start", "inner", "sample", "one", "binary", "response", "cache", "block", "missing", "window", "bytes", "source", "value", "da", "a", "DATA", "content", "memory", "draw", "alpha"], "size": ["esc", "use", "code", "slice", "ize", "sn", "c", "empty", "sized", "name", "time", "storage", "weight", "style", "filename", "sum", "capacity", "address", "hh", "speed", "Size", "unit", "password", "SIZE", "max", "loc", "small", "fee", "offset", "si", "mode", "sec", "scale", "cache", "shape", "number", "length", "timeout", "source", " sizes", "status", "ny", "content", "large", "len", "g"], "mb_count": ["byte_count", "mb2th", "mbcountsize", "mb8count", "mb8size", "mbcountth", "MB_count", "byte_len", "MB_size", "byte_th", "mb2len", "mb2count", "mb_len", "mbcountlen", "mb2size", "MB_len", "mb8len", "byte_size", "mb_th", "mbcountcount", "mb_size"], "dxva_data": ["dxva_last", "dxvas_uri", "dxva67ui", "dxva6uri", "dxva2last", "dxvas67media", "dxaa_data", "dxva_Data", "dxva_ui", "dxva2Data", "dxva6dat", "dxva67data", "dxva1data", "dxva2buf", "dxena6data", "dxva_buf", "dxvas_media", "dxva6data", "dxva67uri", "dxsa_buffer", "dxva67media", "dxena_uri", "dxena_data", "dxena_dat", "dxena6dat", "dxva_dat", "dxvas_ui", "dxsa_memory", "dxva1uri", "dxsa_data", "dxva1dat", "dxva_uri", "dxva_memory", "dxvas67ui", "dxsa_size", "dxva_buffer", "dxva1content", "dxva_content", "dxva_media", "dxena_content", "dxva2data", "dxaa_last", "dxvas67data", "dxaa_buf", "dxva6content", "dxvas_data", "dxena6uri", "dxena6content", "dxaa_Data", "dxvas67uri"], "dxva_size": ["dxha_sized", "dxvo_name", "dxva_sized", "dxvo_size", "dxva_sum", "dxva_loc", "dxva_desc", "dxva_stream", "dxva_width", "dxvo_desc", "dxva_name", "dxvo_loc", "dxha_name", "dxvo_length", "dxvo_stream", "dxva_length", "dxvo_width", "dxvo_sum", "dxha_size", "dxvo_count", "dxha_data", "dxva_count"], "result": [" cr", "rs", " sr", "sr", "res", "Result", "dr", "mr", " rc", " ret", "rh", "err", "rl", " thr", " results", "ret", "response", " success", " r", "rx", "src", "resp", "results", " res", "HR", " rs"], "hr": ["yr", "hour", "rs", "er", "sr", "p", "RS", "rd", "c", "dr", "callback", "ec", "img", "ih", "br", "bh", "cr", "gr", "hh", " HR", "mr", "id", "fr", "rw", "uh", "hl", "rid", "e", "resh", "arr", "work", "rh", "err", "str", "lr", "MR", "worker", "ctr", "rc", "rg", "kr", "req", "h", "ir", "hn", "nr", "pr", "rx", "src", "pull", "ha", "header", "wr", "r", "HR", "rr", "WR", "shr", "DR"], "dsc11": ["dsc100", "dsc10", "dc11", "desc10", "dSC10", "dc31", "dbc11", "dbc13", "Drc11", "dbc14", " desc13", " desc12", "Drc31", "dbc10", " dsc31", " desc1", "drc31", " desc101", "drc14", "Dsc11", "dSC101", " dsc100", "dsc101", " desc31", "desc31", " dsc10", "desc11", "dsc12", "dosc13", "drc101", " dsc101", "dSC14", "dsc14", "Dsc31", "Dsc14", "Drc13", " dsc12", "desc13", " desc14", "dSC12", "desc1", "desc100", "desc14", "desc12", "desc101", "dosc100", "Drc101", "dc1", "dosc11", "Dsc13", " desc100", " dsc1", " dsc13", "drc13", "dSC100", " desc10", "dsc1", "drc1", " desc11", "Dsc101", " dsc14", "Drc14", "drc11", "dbc101", "dSC11", "dosc12", "drc10", "dc14", "dsc31", "dSC13", "dsc13"], "dsc2": ["drc2", "dasc2", "Drc4", "drc1", " dbcTwo", "dsc3", "dbc3", "desc1", "dbc22", "dbcTwo", "dbc1", "dcr02", " dsc02", "dbc4", " dscTwo", "Dsc1", "duc2", "descTwo", "dsc22", "dbc2", "dSC2", "Dsc02", " dbc2", " drc02", "duc1", "Drc02", "dcr1", "duc02", " dsc3", "Drc1", "dsc02", "dasc4", " dbc1", "dasc3", "Drc2", "drc02", "dcr2", " dbc4", " drc2", "dSC4", " dsc1", "desc4", "dSC1", "desc3", "desc22", "dascTwo", " drc1", " dsc4", "dbc02", "Dsc4", "desc02", " dbc22", "dsc4", " dbc3", "duc4", "dcrTwo", "Dsc2", "dscTwo", "dsc1", "dSC22", "drc4", " dsc22", "drcTwo", "desc2", " drcTwo"]}}
{"project": "qemu", "commit_id": "74892d2468b9f0c56b915ce94848d6f7fac39740", "target": 1, "func": "int vm_stop(RunState state)\n\n{\n\n    if (qemu_in_vcpu_thread()) {\n\n\n        qemu_system_vmstop_request(state);\n\n        /*\n\n         * FIXME: should not return to device code in case\n\n         * vm_stop() has been requested.\n\n         */\n\n        cpu_stop_current();\n\n        return 0;\n\n    }\n\n\n\n    return do_vm_stop(state);\n\n}", "idx": 8221, "substitutes": {"state": ["parent", "l", "session", "State", "start", "si", "str", "class", "statement", "id", "m", "info", "instance", "i", "data", "c", "s", "config", "p", "rule", "e", "status", "ace", "request", "se", "STATE", "style", "er", "f", "j", "code", "resource", "call", "slice", "al", "parse", "scope", "name", "states", "address", "port", "part", "grade", "this", "type", "self", "use", "cache"]}}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void ac97_map (PCIDevice *pci_dev, int region_num,\n\n                      uint32_t addr, uint32_t size, int type)\n\n{\n\n    PCIAC97LinkState *d = (PCIAC97LinkState *) pci_dev;\n\n    AC97LinkState *s = &d->ac97;\n\n\n\n    if (!region_num) {\n\n        s->base[0] = addr;\n\n        register_ioport_read (addr, 256 * 1, 1, nam_readb, d);\n\n        register_ioport_read (addr, 256 * 2, 2, nam_readw, d);\n\n        register_ioport_read (addr, 256 * 4, 4, nam_readl, d);\n\n        register_ioport_write (addr, 256 * 1, 1, nam_writeb, d);\n\n        register_ioport_write (addr, 256 * 2, 2, nam_writew, d);\n\n        register_ioport_write (addr, 256 * 4, 4, nam_writel, d);\n\n    }\n\n    else {\n\n        s->base[1] = addr;\n\n        register_ioport_read (addr, 64 * 1, 1, nabm_readb, d);\n\n        register_ioport_read (addr, 64 * 2, 2, nabm_readw, d);\n\n        register_ioport_read (addr, 64 * 4, 4, nabm_readl, d);\n\n        register_ioport_write (addr, 64 * 1, 1, nabm_writeb, d);\n\n        register_ioport_write (addr, 64 * 2, 2, nabm_writew, d);\n\n        register_ioport_write (addr, 64 * 4, 4, nabm_writel, d);\n\n    }\n\n}\n", "idx": 17266, "substitutes": {"pci_dev": ["pdi_dev", "pci_ev", "pcli_device", "pci_grad", "pcli_dev", "pcli_ev", "pdi_grad", "pdi_device", "pci_device"], "region_num": ["region__sym", " region_id", "region4name", "region_id", " region_sym", " region_name", "region4id", "region_number", "region__NUM", " region_NUM", "region__number", "region_NUM", "region_name", "region4NUM", "region_sym", "region__name", "region__num", "region__id", " region_number", "region4num"], "addr": ["grad", "offset", "Address", "x", "align", "ar", "region", "adder", "ptr", "pos", "layer", "config", "prefix", "id", "asm", "p", "pad", "od", "adr", "mt", "conn", "len", "work", "name", "rc", "bridge", "hop", "ld", "wd", "class", "route", "port", "mac", "amp", "dc", "code", "base", "r", "rt", "src", "loc", "node", "byte", "xp", "host", "l", "nr", "ad", "device", "address", "ace", "amd", "flags", "rr", "shape", "data", "mode", "ord", "coord", "channel", "g", "ost", "ast", "oa", "ext", "acl", "slice", "index", "en", "ip", "alias", "pkg", "nc", "add", "dr", "e", "map", "req", "seq", "kt", "cmd", "url", "cmp", "cap", "error", "nn", "server", "el", "attr", "butt"], "size": ["scale", "offset", "extra", "capacity", "small", "mode", "name", "g", "max", "loc", "sec", "pos", "enc", "args", "large", "ize", "length", "unit", "c", "address", "cap", "bytes", "Size", "len"], "type": ["types", "offset", "shape", "t", "info", "name", "ref", "buffer", "pe", "block", "val", "class", "format", "Type", "style", "length", "config", "unit", "TYPE", "p", "address", "ty", "weight", "state", "port", "ype", " typ", "typ"], "d": ["dc", "m", "dn", "dd", "db", "j", "t", "data", "gd", "x", "f", "dB", "md", "r", "pd", "de", "n", "dh", "dos", "g", "i", "z", "dt", "di", "ld", "dl", "done", "dj", "dim", "day", "sd", "o", "dp", "l", "did", "dy", "w", "bd", "dm", "ad", "e", "fd", "dr", "id", "k", "v", "c", "dom", "dis", "D", "ded", "p", "da", "b", "dat", "cd", "h", "dad", "diff", "dict", "y", "ds", "u"], "s": ["ns", "spec", "m", "session", "sg", "stats", "rs", "t", "f", "sv", "services", "r", "service", "n", "sb", "g", "i", "sl", "z", "ss", "this", "self", "is", "o", "l", "w", "e", "ssl", "ses", "v", "sync", "c", "js", "si", "p", "S", "b", "gs", "sys", "h", "os", "state", "server", "states", "sq", "sa", "ds", "u"]}}
{"project": "FFmpeg", "commit_id": "ed1c83508ec920bfef773e3aa3ac1764a65826ec", "target": 0, "func": "static int atrim_filter_frame(AVFilterLink *inlink, AVFrame *frame)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    TrimContext       *s = ctx->priv;\n\n    int64_t start_sample, end_sample = frame->nb_samples;\n\n    int64_t pts;\n\n    int drop;\n\n\n\n    /* drop everything if EOF has already been returned */\n\n    if (s->eof) {\n\n        av_frame_free(&frame);\n\n        return 0;\n\n    }\n\n\n\n    if (frame->pts != AV_NOPTS_VALUE)\n\n        pts = av_rescale_q(frame->pts, inlink->time_base,\n\n                           (AVRational){ 1, inlink->sample_rate });\n\n    else\n\n        pts = s->next_pts;\n\n    s->next_pts = pts + frame->nb_samples;\n\n\n\n    /* check if at least a part of the frame is after the start time */\n\n    if (s->start_sample < 0 && s->start_pts == AV_NOPTS_VALUE) {\n\n        start_sample = 0;\n\n    } else {\n\n        drop = 1;\n\n        start_sample = frame->nb_samples;\n\n\n\n        if (s->start_sample >= 0 &&\n\n            s->nb_samples + frame->nb_samples > s->start_sample) {\n\n            drop         = 0;\n\n            start_sample = FFMIN(start_sample, s->start_sample - s->nb_samples);\n\n        }\n\n\n\n        if (s->start_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&\n\n            pts + frame->nb_samples > s->start_pts) {\n\n            drop = 0;\n\n            start_sample = FFMIN(start_sample, s->start_pts - pts);\n\n        }\n\n\n\n        if (drop)\n\n            goto drop;\n\n    }\n\n\n\n    if (s->first_pts == AV_NOPTS_VALUE)\n\n        s->first_pts = pts + start_sample;\n\n\n\n    /* check if at least a part of the frame is before the end time */\n\n    if (s->end_sample == INT64_MAX && s->end_pts == AV_NOPTS_VALUE && !s->duration_tb) {\n\n        end_sample = frame->nb_samples;\n\n    } else {\n\n        drop       = 1;\n\n        end_sample = 0;\n\n\n\n        if (s->end_sample != INT64_MAX &&\n\n            s->nb_samples < s->end_sample) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->end_sample - s->nb_samples);\n\n        }\n\n\n\n        if (s->end_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&\n\n            pts < s->end_pts) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->end_pts - pts);\n\n        }\n\n\n\n        if (s->duration_tb && pts - s->first_pts < s->duration_tb) {\n\n            drop       = 0;\n\n            end_sample = FFMAX(end_sample, s->first_pts + s->duration_tb - pts);\n\n        }\n\n\n\n        if (drop) {\n\n            s->eof = 1;\n\n            goto drop;\n\n        }\n\n    }\n\n\n\n    s->nb_samples += frame->nb_samples;\n\n    start_sample   = FFMAX(0, start_sample);\n\n    end_sample     = FFMIN(frame->nb_samples, end_sample);\n\n    av_assert0(start_sample < end_sample);\n\n\n\n    if (start_sample) {\n\n        AVFrame *out = ff_get_audio_buffer(ctx->outputs[0], end_sample - start_sample);\n\n        if (!out) {\n\n            av_frame_free(&frame);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        av_frame_copy_props(out, frame);\n\n        av_samples_copy(out->extended_data, frame->extended_data, 0, start_sample,\n\n                        out->nb_samples, av_get_channel_layout_nb_channels(frame->channel_layout),\n\n                        frame->format);\n\n        if (out->pts != AV_NOPTS_VALUE)\n\n            out->pts += av_rescale_q(start_sample, (AVRational){ 1, out->sample_rate },\n\n                                     inlink->time_base);\n\n\n\n        av_frame_free(&frame);\n\n        frame = out;\n\n    } else\n\n        frame->nb_samples = end_sample;\n\n\n\n    s->got_output = 1;\n\n    return ff_filter_frame(ctx->outputs[0], frame);\n\n\n\ndrop:\n\n    s->nb_samples += frame->nb_samples;\n\n    av_frame_free(&frame);\n\n    return 0;\n\n}\n", "idx": 2157, "substitutes": {"inlink": ["INlink", "inslinks", "inload", "inlock", "Inlink", "inlinks", "rinink", "rinlink", "insself", "outline", "Inlock", "outlink", " inink", "INlock", "inasline", "Inlinks", "insline", "inink", "rinlock", "insink", " inlock", "Inline", "outload", "inslock", " inlinks", "INself", "outlock", "inaslock", "inself", "inaslink", " inself", " inload", "INline", "inslink", "inasload", "rinload", "insload"], "frame": ["dr", "js", "sche", "figure", "video", "sample", "sf", "file", "framework", "iframe", "f", "object", "pse", "ze", "zone", "fi", "flow", "time", "Frame", "sequence", "spec", "zip", "image", "component", "frames", "request", "fe", "rup", "p", "state", "e", "scale", "session", "me", "scene", "ss", "fram", "rame", "data", "m", "info", "slice", "document", "c", "setup", "node", "module", "cf", "screen", "sim", "series", "service", "window", "d", "ms", "scope", "dy", "coll", "fr", "style", "source", "feature", "range", "fb", "plane", "element", "full", "line", "motion", "view", "cfg", "part", "game"], "ctx": ["cm", "cms", "cam", "cs", "conn", "context", "anc", "cc", "Context", "loc", "ck", "bc", "scope", "tc", "mac", "m", "tx", "cb", "kw", "config", "pkg", "c", "cv", "lc", "conf", "ca", "sq", "wcs", "sc", "ctrl", "cmd", "obj", "cca", "pc", "cp", "cf", "conv", "ci", "cfg"], "s": ["sg", "js", "qs", "n", "sp", "sl", "sample", "g", "ses", "ls", "sf", "args", "vs", "us", "f", "sys", "u", "se", "fs", "parts", "stat", "spec", "ts", "sb", "ims", "span", "y", "frames", "xs", "sv", "p", "state", "e", "lines", "conf", "site", "S", "os", "session", "t", "hs", "sci", "sym", "obs", "ssl", "cs", "ss", "rs", "a", "r", "is", "ins", "i", "space", "m", "settings", "slice", "ds", "ps", "gs", "ns", "h", "c", "setup", "es", "o", "sim", "si", "series", "service", "d", "ms", "scope", "sk", "sis", "sync", "source", "l", "services", "sq", "sing", "b", "states"], "start_sample": ["starting_sample", "end_stage", "startjsingle", "currentfpackage", "end_scale", "starting_scale", "start67module", "currentfsample", "start_space", "stop_sequence", "starttsample", "start_slot", "startjscale", "current_shape", "start_module", "start_shape", "current_package", "start_stage", "startPample", "pick_sample", " start_space", "starttspace", "pick_model", "startfshape", "end_ample", "currentfspace", "starttsem", "start_Sample", "current_sample", "startPsample", "starting_ample", "end_module", "start_slice", "start_side", "startxspace", "start_ample", "end_sam", "end_single", "end_package", "stop_sample", "start_scale", "start_sam", "end_group", "startxsample", "start_package", " start_side", " start_sem", "start67slot", "current_space", "startfpackage", "start_single", "pick_package", "starting_source", "startfample", "starttside", "startxslot", "startPSample", "start67space", "start_model", "startxmodule", "end_source", "stop_scale", "start67sample", "start_server", "startfsource", "end_slot", "start_size", "startjgroup", "startPscale", "start_sem", "startfspace", "startfscale", "start_sequence", "end_space", "end_sample", "start_group", "currentfshape", "end_Sample", "stop_server", "start_source", "startfsample", "end_size", "pick_slice", "startjsample"], "pts": ["seqcount", "pars", "ointds", "cts", "periodsets", "aptd", "parsym", "seqds", "conds", "periodlines", "ptcount", "periodxs", "nts", "ntsets", "iptd", "intts", "prs", "periodgroups", "eptsd", "inputs", "inputsets", "ptf", "apts", "roundlines", "parss", "ctd", "PTs", "ointf", "ptsd", "ptgroups", "pps", "PTS", "ptsw", "ptse", "condd", "condts", "monts", "uptss", "periods", "ptsym", "prd", "uptsym", "prts", "ptns", "inputxs", "ptses", "ptss", "roundsets", "PTf", "seqsd", "ipts", "epts", "aptsets", "rounds", "PTses", "ointS", "seqs", "aptxs", "uptd", "uptsi", "seqsi", "PTd", "aptsw", "ctts", "ointsets", "montd", "ptlines", "PTns", "PTss", "iptts", "periodts", "ptxs", "PTsym", "periodds", "iptsw", "PTgroups", "ptd", "parses", "ints", "aptsi", "uptses", "ptS", "ppf", "eptsi", "ptds", "intsets", "periodns", "aptts", "PTlines", "prse", "ptts", "upts", "intns", "PTsw", "seqsets", "inputts", "ptsets", "periodcount", "ntns", "roundts", "montsi", "roundns", "ointcount", "roundgroups", "oints", "PTts", "ntts", "montsd", "ptsi", "ctse", "condse", "ppS"], "drop": ["layer", "clip", "allow", "dr", "delay", "crop", "no", "append", "skip", "bag", "throw", "zip", "ignore", "alter", "send", "add", "type", "dl", "field", "pick", " dropped", "sample", "loop", "batch", "gap", "update", "move", "leave", "roll", "bug", "push", "slice", "err", "delete", "select", "Drop", "pad", "change", "step", "keep", "shift", "start", "pop", "dropping", "repeat", "col", "comment", "phase", "pull", "scale", "carry", "qa", "drops", "sleep", "error", "stop", "play", "hide", "close", "plane", "dp", "shape", "bottom", "dro", "diff", "port"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void gem_write(void *opaque, target_phys_addr_t offset, uint64_t val,\n\n        unsigned size)\n\n{\n\n    GemState *s = (GemState *)opaque;\n\n    uint32_t readonly;\n\n\n\n    DB_PRINT(\"offset: 0x%04x write: 0x%08x \", offset, (unsigned)val);\n\n    offset >>= 2;\n\n\n\n    /* Squash bits which are read only in write value */\n\n    val &= ~(s->regs_ro[offset]);\n\n    /* Preserve (only) bits which are read only in register */\n\n    readonly = s->regs[offset];\n\n    readonly &= s->regs_ro[offset];\n\n\n\n    /* Squash bits which are write 1 to clear */\n\n    val &= ~(s->regs_w1c[offset] & val);\n\n\n\n    /* Copy register write to backing store */\n\n    s->regs[offset] = val | readonly;\n\n\n\n    /* Handle register write side effects */\n\n    switch (offset) {\n\n    case GEM_NWCTRL:\n\n        if (val & GEM_NWCTRL_TXSTART) {\n\n            gem_transmit(s);\n\n        }\n\n        if (!(val & GEM_NWCTRL_TXENA)) {\n\n            /* Reset to start of Q when transmit disabled. */\n\n            s->tx_desc_addr = s->regs[GEM_TXQBASE];\n\n        }\n\n        if (!(val & GEM_NWCTRL_RXENA)) {\n\n            /* Reset to start of Q when receive disabled. */\n\n            s->rx_desc_addr = s->regs[GEM_RXQBASE];\n\n        }\n\n        break;\n\n\n\n    case GEM_TXSTATUS:\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_RXQBASE:\n\n        s->rx_desc_addr = val;\n\n        break;\n\n    case GEM_TXQBASE:\n\n        s->tx_desc_addr = val;\n\n        break;\n\n    case GEM_RXSTATUS:\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_IER:\n\n        s->regs[GEM_IMR] &= ~val;\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_IDR:\n\n        s->regs[GEM_IMR] |= val;\n\n        gem_update_int_status(s);\n\n        break;\n\n    case GEM_PHYMNTNC:\n\n        if (val & GEM_PHYMNTNC_OP_W) {\n\n            uint32_t phy_addr, reg_num;\n\n\n\n            phy_addr = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;\n\n            if (phy_addr == BOARD_PHY_ADDRESS) {\n\n                reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;\n\n                gem_phy_write(s, reg_num, val);\n\n            }\n\n        }\n\n        break;\n\n    }\n\n\n\n    DB_PRINT(\"newval: 0x%08x\\n\", s->regs[offset]);\n\n}\n", "idx": 3521, "substitutes": {"opaque": ["opacity", "OPacity", "Opesc", "opoch", "OPesc", "operaque", " opoch", " opacity", "OPque", "ipaque", "ipque", "Opque", "operoch", "opesc", "OPaque", "operacity", "Opacity", "Opoch", "ipacity", "Opaque", "ipesc", "opque"], "offset": ["rot", "url", "next", "code", "index", "pointer", "address", "aligned", "set", "reset", "f", "article", "fee", "seq", "optional", "location", "course", "start", "option", "port", "image", "align", "position", "slot", "type", "parent", "off", "fp", "disabled", "ptr", "hop", "length", "site", "layer", "base", "outer", "skip", "required", "loc", "axis", "slice", "enabled", "role", "et", "order", "len", "ref", "attr", "value", "alloc", "o", "phase", "prefix", "error", "online", "mode", "slave", "adjusted", "timeout", "oa", "server", "append", "bit", "alias", "operation", "num", "initial", "seed", "pos", "attribute", "range", "padding", "Offset", "sort", "addr", "part"], "val": ["rot", "ret", "vol", "arg", "cal", "key", "dim", "vl", "alt", "sl", "bal", "x", "pr", "eval", "fee", "seq", "valid", "fi", "unit", "pl", "ol", "local", "split", "stat", "vals", "sil", "slot", "vert", "buf", "bl", "pass", "update", "fail", "lt", "tx", "sol", "p", "v", "serv", "lit", "count", "pt", "base", "Value", "byte", "data", "ee", "loc", "pre", "nil", "ve", "live", "aval", "sel", "role", "ut", "len", "ref", "el", "value", "fx", "reg", "VAL", "lo", "mem", "isal", "test", "buffer", "bit", "elt", "pol", "Val", "fl", "prop", "pos", "block", "pret", "pal", "ival", "il", "b", "al", "part"], "size": [" af", " slot", " len", "vals", " pri", " overflow", " count", " error", " ret", " address", " flag", " fl", "pos", " index", " delta", " align", " pos", "len", " el", " length", " mem", " flags", "ival"], "s": ["sg", "submit", "js", "n", "sites", "sl", "client", "g", "ses", "ls", "sf", "sie", "self", "private", "f", "secondary", "set", "sys", "u", "your", "se", "fs", "spec", "ts", "sb", "aws", "y", "uns", "sets", "p", "state", "e", "conf", "su", "site", "S", "t", "session", "ks", "os", "bs", "hs", "sym", "ssl", "cs", "ss", "rs", "a", "new", "r", "is", "ins", "i", "bis", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "es", "south", "o", "si", "server", "service", "http", "d", "scope", "sis", "comments", "sync", "l", "services", "sq", "b", "states"], "readonly": ["loadOnly", "weakOnly", "writalone", "weakall", " readlocked", "ReadOnly", "writonly", " readOnly", "Readforce", "Readalone", "rideOnly", "readlocked", "loadsafe", "readall", "writOnly", "readOnly", "bitOnly", "loadall", "ridesafe", " readsafe", "bitforce", "Readonly", "weightOnly", "readsafe", "readforce", "loadonly", "fullocked", "readjust", "weightlocked", " readall", "bitonly", "rideonly", "weightjust", "fuljust", "fulonly", "fulOnly", "weakonly", "Readall", "readalone", " readjust", "rideall", "weakalone", "weightonly", " readforce", "writall"], "phy_addr": ["phy___node", "py_name", "py_offset", "phy_offset", "phy_ptr", "phy___offset", "phy_node", "py_addr", "py_ptr", "phy_kn", "py_address", "phy_address", "py_node", "phy67addr", "phy___addr", "phy___address", "py_kn", "phy67address", "phy_prefix", "phy_name", "py_prefix", "phy67offset", "phy67node"], "reg_num": ["REG_number", "reg_orig", "reg_no", "REG_no", "REG_orig", "reg2number", "reg_number", "reg2num", "reg2orig", "reg2no", "REG_num"]}}
{"project": "FFmpeg", "commit_id": "1e901ffc619459944ae7102428f48972cd899caa", "target": 0, "func": "static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)\n\n{\n\n    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&\n\n        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {\n\n        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&\n\n            timestamp < st->pts_wrap_reference)\n\n            return timestamp + (1ULL<<st->pts_wrap_bits);\n\n        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&\n\n            timestamp >= st->pts_wrap_reference)\n\n            return timestamp - (1ULL<<st->pts_wrap_bits);\n\n    }\n\n    return timestamp;\n\n}\n", "idx": 17009, "substitutes": {"st": ["ist", "est", "ts", "s", "nd", "t", "data", "rest", "ct", "ste", "td", "str", "stable", "sb", "ost", "stream", "sl", "ast", "ss", "src", "ut", "public", "upt", "this", "th", "ld", "gest", "ST", "sd", "sta", "sm", "art", "rd", "class", "std", "sh", "first", "stack", "stop", "sed", "back", "ad", "start", "sc", "bl", "sth", "cl", "vest", "stage", "support", "ust", "sts", "St", "inst", "sign", "cast", "end", "ft", "asts", "sa"], "timestamp": ["timcision", "timtime", "imension", "semestamp", "mompoint", "timporal", "stimuntil", "imetime", "uuessed", "magpoint", "semempt", "Timeless", "timuntil", "nampoint", "mometime", "sequessed", "timempt", "nametime", "serveless", "momestamp", "timeest", "timension", "numestamp", "timeeless", "numporal", "stimestamp", "temuration", "numeline", "magcision", "semetime", "timeestamp", "sequeless", "sequpoint", "uuestamp", "servestamp", "timeless", "numest", "tmeline", "timeline", "stimetz", "metension", "temcision", "semension", "uueless", "imeline", "imtime", "namestamp", "Timessed", "semcision", "servuntil", "tempoint", "temestamp", "sempoint", "timpoint", "tmest", "uupoint", "Timest", "magempt", "timepoint", "timetz", "imestamp", "Timpoint", "timuration", "servetz", "metpoint", "magestamp", "temetime", "temempt", "impoint", "tmporal", "timessed", "sequestamp", "metetime", "timeetz", "metestamp", "timeuntil", "timetime", "timest", "namuration", "imest", "imporal", "stimeless", "Timestamp", "Timtime", "momuration", "tmestamp"]}}
{"project": "qemu", "commit_id": "4a1cba3802554a3b077d436002519ff1fb0c18bf", "target": 1, "func": "bool aio_poll(AioContext *ctx, bool blocking)\n\n{\n\n    AioHandler *node;\n\n    int i, ret;\n\n    bool progress;\n\n    int64_t timeout;\n\n\n\n    aio_context_acquire(ctx);\n\n    progress = false;\n\n\n\n    /* aio_notify can avoid the expensive event_notifier_set if\n\n     * everything (file descriptors, bottom halves, timers) will\n\n     * be re-evaluated before the next blocking poll().  This is\n\n     * already true when aio_poll is called with blocking == false;\n\n     * if blocking == true, it is only true after poll() returns,\n\n     * so disable the optimization now.\n\n     */\n\n    if (blocking) {\n\n        atomic_add(&ctx->notify_me, 2);\n\n    }\n\n\n\n    ctx->walking_handlers++;\n\n\n\n    assert(npfd == 0);\n\n\n\n    /* fill pollfds */\n\n\n\n    if (!aio_epoll_enabled(ctx)) {\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->pfd.events\n\n                && aio_node_check(ctx, node->is_external)) {\n\n                add_pollfd(node);\n\n            }\n\n        }\n\n    }\n\n\n\n    timeout = blocking ? aio_compute_timeout(ctx) : 0;\n\n\n\n    /* wait until next event */\n\n    if (timeout) {\n\n        aio_context_release(ctx);\n\n    }\n\n    if (aio_epoll_check_poll(ctx, pollfds, npfd, timeout)) {\n\n        AioHandler epoll_handler;\n\n\n\n        epoll_handler.pfd.fd = ctx->epollfd;\n\n        epoll_handler.pfd.events = G_IO_IN | G_IO_OUT | G_IO_HUP | G_IO_ERR;\n\n        npfd = 0;\n\n        add_pollfd(&epoll_handler);\n\n        ret = aio_epoll(ctx, pollfds, npfd, timeout);\n\n    } else  {\n\n        ret = qemu_poll_ns(pollfds, npfd, timeout);\n\n    }\n\n    if (blocking) {\n\n        atomic_sub(&ctx->notify_me, 2);\n\n    }\n\n    if (timeout) {\n\n        aio_context_acquire(ctx);\n\n    }\n\n\n\n    aio_notify_accept(ctx);\n\n\n\n    /* if we have any readable fds, dispatch event */\n\n    if (ret > 0) {\n\n        for (i = 0; i < npfd; i++) {\n\n            nodes[i]->pfd.revents = pollfds[i].revents;\n\n        }\n\n    }\n\n\n\n    npfd = 0;\n\n    ctx->walking_handlers--;\n\n\n\n    /* Run dispatch even if there were no readable fds to run timers */\n\n    if (aio_dispatch(ctx, ret > 0)) {\n\n        progress = true;\n\n    }\n\n\n\n    aio_context_release(ctx);\n\n\n\n    return progress;\n\n}\n", "idx": 15115, "substitutes": {"ctx": ["context", "ch", "tx", "cm", "bc", "pkg", "qa", "cv", "ca", "sync", "config", "pc", "cc", "cdn", "ctr", "utils", "connection", "Context", "lc", "ctrl", "cs", "ci", "req", "conv", "section", "cn", "cmp", "scope", "loc", "ct", "cgi", "conn", "client", "kw", "cr", "cd", "handler", "cli", "nc", "kt", "tc", "component", "cus", "ck", "qt", "acl", "cfg", "c", "cca", "xs", "cu", "dc", "anc", "cb", "cas", "sci", "sc", "ce", "cmd", "cf", "cp", "exec", "kb", "vc", "xc", "src", "pai", "css", "git", "hw", "cl"], "blocking": ["channel", "remote", "blocks", "checking", "forcing", "using", "bc", "complete", "queue", "sync", "random", "latest", "holding", "binary", "locking", "period", "poll", "training", "regular", "boxing", "pool", "buffer", "full", "starting", "writing", "locked", "binding", "balanced", "testing", "consuming", "working", "moving", "background", "interrupted", "linear", "cli", "running", "calling", "negative", "length", "quiet", "padding", "block", "killing", "clock", "ssl", "loop", "rolling", "broad", "joining", "ocking", "changing", "ing", "rising", "lock", "prefix", "loading", "always"], "node": ["path", "remote", "call", "context", "root", "self", "edge", "part", "sync", "enc", "worker", "config", "native", "id", "cdn", "object", "child", "local", "nn", "connection", "name", "source", "event", "hub", "null", "missing", "ref", "full", "live", "fn", "server", "master", "slave", "package", "peer", "tree", "client", "nw", "document", "loader", "view", "plugin", "instance", "handler", "leaf", "component", "n", "none", "parent", "query", "global", "route", "cmd", "load", "host", "Node", "content", "num", "post", "index", "callback"], "i": ["hi", "qi", "it", "ui", "m", "part", "I", "t", "ni", "ai", "xi", "id", "iu", "val", "ini", "gi", "oi", "io", "my", "l", "ci", "image", "h", "x", "di", "si", "ie", "ii", "uri", "v", "o", "ind", "p", "e", "fi", "mi", "li", "k", "ix", "b", "abi", "j", "phi", "f", "n", "ti", "ip", "c", "eni", "end", "inner", "pi", "out", "you", "bi", "ri", "y", "in", "index", "start"], "ret": ["alt", "ft", "rev", "part", "reply", "rc", "val", "back", "pt", "def", "rets", "fun", "status", "ref", "sr", "arg", "hash", "full", "lit", "det", "xt", "error", "job", "feat", "pass", "grad", "obj", "ut", "mem", "bot", "success", "Ret", "count", "result", "att", "cat", "arr", "nt", "re", "rt", "resp", "rep", "pat", "RET", "res", "reg", "num", "lock", "flag", "len", "bit", "err"], "progress": ["show", "path", "action", "remote", "call", "partial", "done", "sort", "part", "complete", "reply", "dist", "queue", "rc", "val", "current", "act", "event", "status", "update", "live", "full", "quick", "error", "step", "bar", "grad", "active", "p", "move", "success", "data", "wait", "callback", "mode", "result", "stat", "skip", " status", "grade", "recent", "close", "state", "Progress", " result", "file", "results", " success", " error", "process", "debug", "track", "forward", "resp", "exec", "content", "push", "addr", "len", "proc", "err"], "timeout": ["alt", "remote", "call", "course", "slot", "reply", "service", "sync", "val", "confirmed", "io", "disabled", "connection", "period", "range", "event", "pool", "option", "unit", "missing", "Timeout", "live", "until", "error", "server", "table", "limit", "client", "conn", "always", "term", "size", "time", "temp", "wait", "socket", "interrupted", "tc", "nil", "qt", "length", "none", "timer", "parent", "scroll", "block", "type", "offset", "target", "nt", "ssl", "function", "security", "out", "all", "never", "command", "duration", "cache", "cookie", "cycle", "lock", "window", "delay", "span", "len", "sleep", "poll"], "walking_handlers": ["walking_hostries", "walking_handlerl", "walking_childles", "walking_handleles", "walking_handl", "walking_hostler", "walking_handlerlers", "walking_handlerles", "walking_handlerers", "walking_hosters", "walking_childler", "walking_counters", "walking_countlers", "walking_handlerler", "walking_countries", "walking_handleler", "walking_childlers", "walking_handler", "walking_handlel", "walking_countler", "walking_handries", "walking_handers", "walking_childl", "walking_handlelers", "walking_hostlers", "walking_handles", "walking_handlerries"], "epoll_handler": ["epoll_manager", "epollo_function", "epole_function", "epollerhand", "epolledpointer", "epoll_connection", "epollo_handle", "epoll_object", "epole_folder", "eprot_hand", "epoll_function", "epoll_pointer", "eprot_handle", "epollinghandler", "epolledconnection", "epollo_handler", "eprot_handler", "epollingfunction", "epoll_hand", "epollo_child", "epoll_folder", "epollermanager", "epollerhandler", "epole_handler", "epoll_child", "epole_object", "epollingchild", "epoll_handle", "eprot_connection", "epolledmanager", "eprot_pointer", "epolledhandler", "epollerhandle", "eprot_manager", "epollinghandle"]}}
{"project": "FFmpeg", "commit_id": "52a213865670ae69c1852d4d04cf41f8929abbd0", "target": 0, "func": "static int read_gab2_sub(AVStream *st, AVPacket *pkt)\n\n{\n\n    if (pkt->size >= 7 &&\n\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n\n        uint8_t desc[256];\n\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n\n                                             pkt->size - 7,\n\n                                             0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        pd = (AVProbeData) { .buf      = pb->buf_ptr,\n\n                             .buf_size = pb->buf_end - pb->buf_ptr };\n\n        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb = pb;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\n\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 2534, "substitutes": {"st": ["stage", "ist", "test", "this", "src", "rest", "ss", "stat", "ts", "sa", "sd", "sb", "d", "ct", "sam", "sp", "St", "ste", "kt", "sf", "nt", "ft", "fr", "str", "fe", "state", "sed", "sc", "ST", "art", "std", "tt", "s", "sts", "sta", "inst", "t", "station", "td", "ost", "nd", "pt", "start", "cast", "sth", "est"], "pkt": ["ipcht", " pft", "pcht", "spacket", "pka", "Pcht", "unt", "bq", "cacket", " pka", " packet", "pft", "bnt", "Pq", " pct", "pq", "uq", "pnt", "spft", "Pnt", "pet", " pet", "bkt", "spet", "cet", "Pka", "ipkt", "bct", " pcht", "ipka", "pkg", "ukt", "ipct", "uacket", "ckg", "Pet", "Pft", "Pkg", "ckt", "ipacket", "ipet", "pct", "spkt", " pkg", "packet", "backet", "Pkt", "Pct", "bft", "Packet"], "desc": ["sub", "src", "ext", "def", "esc", "extra", "txt", "data", "loc", "rec", "bc", "id", "buf", "des", "code", "dest", "info", "dep", "cb", "cont", "config", "dir", "asc", "description", "dc", "cod", "result", "cv", "doc", "lc", "Desc", "text", "sc", "meta", "en", "seq", "cmp", "pro", "diff", "uc", "dist", "rc"], "ret": ["match", "nz", "test", "fun", "no", "att", "ext", "def", "bit", "res", "success", "data", "xt", "alt", "rec", "cur", "id", "rets", "arr", "num", "score", "code", "nt", "rev", "back", "reply", "status", "Ret", "feat", "opt", "result", "best", "len", "ref", "resp", "std", "sec", "en", "RET", "seq", "lit", "reg", "re", "val", "det", "rc", "mem"], "ast": ["ist", "test", "att", "ctx", "rest", "act", "a", "sa", "anc", "sd", "ard", "host", "ab", "ad", "sam", "asting", "ap", "ma", "add", "alt", "ta", "end", "op", "api", "aw", "ac", "nt", "ft", "md", "post", "ess", "Ast", "aid", "p", "mast", "esp", "AST", "aster", "asted", "art", "std", "node", "amp", "pc", "asm", "at", "amd", "rss", "asts", "sta", "od", "inst", "old", "an", "ost", "am", "nd", "part", "ace", "cast", "sth", "est"], "sub_demuxer": ["sub_promuxeri", "sub_demexer", "sub_demuxed", "sub_demouseri", "sub_demuxera", "sub_promuxed", "sub_demxer", "sub_promxeri", "sub_promxera", "sub_demousera", "sub_demuxers", "sub_promuxera", "sub_democer", "sub_demomacheri", "sub_democers", "sub_promxers", "sub_demexera", "sub_demuxeri", "sub_promxer", "sub_promuxer", "sub_democed", "sub_demexeri", "sub_demxeri", "sub_demployer", "sub_democeri", "sub_demouser", "sub_demxers", "sub_demomacherer", "sub_demployed", "sub_demployerer", "sub_promxerer", "sub_promuxerer", "sub_demexers", "sub_promuxers", "sub_demxerer", "sub_demxera", "sub_promxed", "sub_demxed", "sub_demployeri", "sub_demomacher", "sub_demuxerer", "sub_demomachers", "sub_demployers", "sub_demousers"], "time_base": ["time_part", "time2part", "timealbase", " time_part", "time_end", "threadallbase", "time_based", " time_based", "time___end", "time_extra", "threadallformat", "thread_base", "time___size", " time_bas", "thread_format", "time_size", "time2based", " time_end", "timealsize", "time_format", "threadallextra", "time___base", "timeallextra", "time2base", " time_size", "timealend", "timeallformat", "thread_extra", "time2bas", "timeallbase", "time_bas"], "pb": ["fc", "pl", "np", "sub", "vp", "ctx", "primary", "bh", "ba", "lp", "sb", "txt", "bps", "lb", "ab", "bm", "ub", "eb", "hub", "ib", "rob", "mb", "cpp", "prot", "dl", "pg", "bc", "platform", "buf", "tc", "tmp", "api", "py", "PB", "rb", "fp", "cb", "python", "bf", "pkg", "pa", "bot", "p", "cv", "lc", "wb", "gb", "jp", "pm", "summary", "pit", "phrase", "meta", "pc", "bp", "bb", "fb", "cp", "b", "plugin", "uf", "wp", "lab", "dp", "typ", "db", "xb"], "pd": ["np", "fd", " db", " FD", "ld", " DP", "dd", "ud", " std", "lp", "ppa", "sd", "dra", "raf", "sb", " ta", "d", "PD", "xd", "dl", " cp", " cad", "py", "po", " df", "PB", " da", "tp", "fp", "cb", " td", " dc", "dt", "ds", "md", " disp", " PD", "bf", " prod", "pa", "p", "hd", "bd", "gd", "edd", "cd", "pm", "pc", " proto", "pp", " ep", " d", "vd", "td", " dd", "wp", "dp", " sd", " rc", "sth", " cd"]}}
{"project": "qemu", "commit_id": "b227a8e9aa5f27d29f77ba90d5eb9d0662a1175e", "target": 0, "func": "static int get_bat (CPUState *env, mmu_ctx_t *ctx,\n\n                    target_ulong virtual, int rw, int type)\n\n{\n\n    target_ulong *BATlt, *BATut, *BATu, *BATl;\n\n    target_ulong base, BEPIl, BEPIu, bl;\n\n    int i;\n\n    int ret = -1;\n\n\n\n#if defined (DEBUG_BATS)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s: %cBAT v 0x\" ADDRX \"\\n\", __func__,\n\n                type == ACCESS_CODE ? 'I' : 'D', virtual);\n\n    }\n\n#endif\n\n    switch (type) {\n\n    case ACCESS_CODE:\n\n        BATlt = env->IBAT[1];\n\n        BATut = env->IBAT[0];\n\n        break;\n\n    default:\n\n        BATlt = env->DBAT[1];\n\n        BATut = env->DBAT[0];\n\n        break;\n\n    }\n\n#if defined (DEBUG_BATS)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s...: %cBAT v 0x\" ADDRX \"\\n\", __func__,\n\n                type == ACCESS_CODE ? 'I' : 'D', virtual);\n\n    }\n\n#endif\n\n    base = virtual & 0xFFFC0000;\n\n    for (i = 0; i < 4; i++) {\n\n        BATu = &BATut[i];\n\n        BATl = &BATlt[i];\n\n        BEPIu = *BATu & 0xF0000000;\n\n        BEPIl = *BATu & 0x0FFE0000;\n\n        bl = (*BATu & 0x00001FFC) << 15;\n\n#if defined (DEBUG_BATS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX\n\n                    \" BATl 0x\" ADDRX \"\\n\",\n\n                    __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                    *BATu, *BATl);\n\n        }\n\n#endif\n\n        if ((virtual & 0xF0000000) == BEPIu &&\n\n            ((virtual & 0x0FFE0000) & ~bl) == BEPIl) {\n\n            /* BAT matches */\n\n            if ((msr_pr == 0 && (*BATu & 0x00000002)) ||\n\n                (msr_pr == 1 && (*BATu & 0x00000001))) {\n\n                /* Get physical address */\n\n                ctx->raddr = (*BATl & 0xF0000000) |\n\n                    ((virtual & 0x0FFE0000 & bl) | (*BATl & 0x0FFE0000)) |\n\n                    (virtual & 0x0001F000);\n\n                if (*BATl & 0x00000001)\n\n                    ctx->prot = PAGE_READ;\n\n                if (*BATl & 0x00000002)\n\n                    ctx->prot = PAGE_WRITE | PAGE_READ;\n\n#if defined (DEBUG_BATS)\n\n                if (loglevel != 0) {\n\n                    fprintf(logfile, \"BAT %d match: r 0x\" PADDRX\n\n                            \" prot=%c%c\\n\",\n\n                            i, ctx->raddr, ctx->prot & PAGE_READ ? 'R' : '-',\n\n                            ctx->prot & PAGE_WRITE ? 'W' : '-');\n\n                }\n\n#endif\n\n                ret = 0;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    if (ret < 0) {\n\n#if defined (DEBUG_BATS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"no BAT match for 0x\" ADDRX \":\\n\", virtual);\n\n            for (i = 0; i < 4; i++) {\n\n                BATu = &BATut[i];\n\n                BATl = &BATlt[i];\n\n                BEPIu = *BATu & 0xF0000000;\n\n                BEPIl = *BATu & 0x0FFE0000;\n\n                bl = (*BATu & 0x00001FFC) << 15;\n\n                fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX\n\n                        \" BATl 0x\" ADDRX \" \\n\\t\"\n\n                        \"0x\" ADDRX \" 0x\" ADDRX \" 0x\" ADDRX \"\\n\",\n\n                        __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                        *BATu, *BATl, BEPIu, BEPIl, bl);\n\n            }\n\n        }\n\n#endif\n\n    }\n\n    /* No hit */\n\n    return ret;\n\n}\n", "idx": 19567, "substitutes": {"env": ["operator", "viron", "txt", "db", "global", "esp", "code", "cal", "eu", "ne", "assets", "exc", "current", "ou", "oa", "np", "chal", "environment", "ext", "scope", "dt", "manager", "console", "en", "her", "enc", "equ", "exec", "context", "inet", "nc", "event", "network", "iss", "ev", "config", "e", "vs", "qt", "v", "inv", "ea", "que", "dat", "eur", "ec", "proc", "inst", "iv", "et", "end", "eni", "server", "Environment", "cv", "conn"], "ctx": ["grad", "cc", "fp", "obj", "vc", "ct", "rc", "exc", "cf", "cb", "cp", "loc", "bc", "src", "environment", "scope", "ctrl", "cas", "Context", "ca", "exec", "context", "hw", "cms", "conv", "nc", "tx", "config", "sc", "qt", "cl", "client", "lc", "qq", "qa", "cmd", "sci", "ec", "fn", "proc", "inst", "connection", "sq", "cv", "conn"], "virtual": [" Virtual", "uri", "visible", "vid", "physical", "complex", "required", "global", "text", "view", "optional", "component", "net", "lit", "ne", "current", "bitcoin", "setting", "public", "environment", "protected", "mini", "console", "active", "lv", "vert", "vm", "fake", "plain", "context", "final", "format", "NV", "mobile", "initial", "hidden", "config", "front", "remote", "dirty", "v", "unit", "hard", "variable", "binary", "special", "external", "volt", "actual", "resource", "output", "total", "Virtual", "virt", "intel", "iv", "connection", "visual", "enabled", "server", "valid", "fi", "real", "version", "target"], "rw": ["fp", "ref", "vc", "fe", "rc", "io", "nt", "rt", "result", "self", "ip", "rec", "nc", "ww", "wire", "ig", "w", "lr", "ih", "rb", "rl", "vt", "ive", "res", "weight", "iv", "outer", "ib"], "type": ["types", "status", "part", "time", "t", "code", "info", "user", "name", "ref", "bit", "f", "full", "action", "lit", "op", "pe", "ping", "file", "role", "block", "method", "var", "loc", "source", "function", "kind", "model", "val", "class", "format", "Type", "event", "pre", "like", "style", "rule", "site", "call", "size", "config", "id", "open", "parent", "unit", "by", "TYPE", "test", "none", "resource", "error", "level", "len", "ty", "state", "py", "port", "valid", "value", "ype", "y", "version", "target", "typ"], "BATlt": [" BATnat", "BATLT", "BGLT", "BATnat", "BTLT", "ATli", "NATelt", "ATut", "MATLT", "BTli", "MATnat", "ATelt", " BATli", "ATlt", "BTelt", "BGlt", "BATli", "BGnat", "BTlt", "ATLT", "BATelt", "NATl", "NATLT", " BATLT", "MATlt", "NATlt", "BTut", "MATut", "BGl", "BTl", "MATl", "ATl"], "BATut": ["BGlett", "MATUT", "BATlet", "BATLT", "BGLT", "BTLT", "BATlett", "MATutil", "BGlet", "BATutil", "ATut", "BGut", "MATLT", "BTlit", "BGuint", "MATu", "ATutt", "BITlit", "ATlt", "MATlett", "BATutt", "BGlt", "BITut", "ATlit", "BTUT", "BTuint", "BTlt", "BTutt", "BGUT", "MATlet", "BITlt", "MATuint", "BITutt", "BATuint", "BATUT", "BTlett", "ATutil", "MATlt", " BATutil", "BTut", "MATut", "BATlit", "BTlet", "ATu"], "BATu": ["BUSur", "CHATut", "BTur", "BATlu", "ATui", " BATU", "BTus", "BATt", "CHATul", "BATui", "APPus", "MATu", "BATus", "MATui", "NATur", "ATul", "CHATou", " BATt", "BTui", "NATu", " BATur", " BATou", "BATou", "BATul", "BUSui", "NATul", "MATul", "BITut", "BITlu", "APPui", "BATU", "MATt", "MATou", "BATur", "BUSU", "APPu", "MATus", "BITu", "MATur", " BATui", "APPul", " BATul", "MATlu", "BTut", "MATut", "BTlu", "ATur", "BTl", "CHATu", "MATl", "BTul", "BTt", "NATui", "BTu", "BTU", "ATu", "BITur", "BUSu"], "BATl": ["BITv", "s", "BITl", "MATn", "r", "MATu", "ATul", " BATL", "g", "MATL", "BTn", " BATv", "BATul", "MATul", "BATv", "BATL", "BITL", "MATv", "BITu", " BATn", "_", "BATn", " BATul", "BTl", "MATl", "addr", "BTu", "ATu", "ATl", "ATL"], "base": ["bi", "scale", "bin", "physical", " baseline", "core", "al", "bit", "name", "Base", "buffer", "rc", "file", " bias", "bc", " bases", "protected", " last", " fe", "object", "is", "ip", "val", " v", "config", "id", "bas", " unit", "v", "unit", "si", "soft", "BL", "area", "b", " mini", "Virtual", "boot", "et", "basic", "local", "live", "end", "it"], "BEPIl": ["BIPIl", "BIPUrl", "BEPEntity", "BepLt", " BEPExc", "BMPAlt", "BEPInc", "BepAlt", "BEMIl", " BTPInc", "BepEl", "BepIl", " BEPLt", "BMPEl", " BMPExc", " BMPEl", " BIPNL", "BEEPEntity", " BIPUrl", " BTPEntity", "BTPLt", "BepEntity", "BIPIns", "BEMUrl", " BMPAlt", "BepExc", "BepInc", "BMPIl", "BEPNL", "BEPUrl", "BEPExc", "BNPExc", " BEPNL", " BEPAlt", "BEPEl", " BTPLt", "BNPEl", "BEEPIl", " BEPInc", "BIPNL", " BEPUrl", " BTPIl", "BepIns", "BEEPLt", "BNPIl", "BepUrl", " BEPEntity", "BTPInc", "BEPLt", "BNPAlt", " BMPIl", "BEMNL", "BMPExc", " BEPEl", "BTPIl", " BIPIl", "BEEPInc", "BEPAlt", "BTPEntity", "BepNL", "BEMIns", " BEPIns", " BIPIns", "BEPIns"], "BEPIu": ["BEPUou", "BEPIue", "BEPUui", "BEPKIul", "BEPUcu", "BEPIDEul", "BMPIu", "BEPSIo", "BEPEq", "BECIIul", "BEPITou", "BAPSIu", "BEPIo", "BEPIDEcu", "BEPIIcu", "BEPKIcu", "BEPIou", "BMPIui", "BEPEu", "BMPIIou", "BEPITui", "BEPSIue", "BEPIcu", "BAPIq", "BECIIcu", "BEPIIu", "BEPIui", "BEPIIui", "BEPNue", "BEPUu", "BMPIou", "BAPSIue", "BAPIu", "BEPEo", "BECIIut", "BEPEue", "BEPNo", "BMPIcu", "BECIIu", "BEPIul", "BEPNq", "BECIul", "BMPIIu", "BEPITcu", "BEPNu", "BMPIIcu", "BEPSIu", "BEPIq", "BECIu", "BEPIIou", "BECIcu", "BAPIo", "BEPKIu", "BEPKIut", "BEPITu", "BEPIDEu", "BAPSIo", "BECIut", "BEPIDEut", "BAPIue", "BEPIIut", "BAPSIq", "BEPIut", "BEPSIq", "BEPIIul", "BMPIIui"], "bl": ["eb", "typ", "Bl", " Bl", "lit", "abl", "pl", "rel", "lu", "ble", "kl", "block", "sl", "nl", "loc", "ld", "pb", "lb", "iol", "dl", "ml", "label", "tl", "val", "fl", " BL", "ali", "sil", "il", "gl", "bh", "cl", "rl", "bg", "ll", "BL", "obl", "lock", "ly", "bel", "isl", "yl", "blast", "el", "ill", "pt", "li", "ib", "len"], "i": ["ti", "gi", "m", "j", "ji", "t", "info", "x", "f", "ix", "ini", "qi", "r", "ai", "mi", "n", "phi", "gu", "io", "hi", "z", "ii", "in", "iu", "index", "di", "mini", "I", "multi", "out", "is", "ip", "chi", "l", "adi", "yi", "pi", "ui", "ci", "id", "start", "e", "v", "ni", "c", "si", "ri", "p", "xi", "b", "mu", "uli", "anti", "h", "end", "it", "eni", "fi", "y", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "15ccaa344c4f645ae791aafecdef3d886e196127", "target": 1, "func": "void dct32(INTFLOAT *out, const INTFLOAT *tab)\n\n{\n\n    INTFLOAT tmp0, tmp1;\n\n\n\n    INTFLOAT val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 ,\n\n             val8 , val9 , val10, val11, val12, val13, val14, val15,\n\n             val16, val17, val18, val19, val20, val21, val22, val23,\n\n             val24, val25, val26, val27, val28, val29, val30, val31;\n\n\n\n    /* pass 1 */\n\n    BF0( 0, 31, COS0_0 , 1);\n\n    BF0(15, 16, COS0_15, 5);\n\n    /* pass 2 */\n\n    BF( 0, 15, COS1_0 , 1);\n\n    BF(16, 31,-COS1_0 , 1);\n\n    /* pass 1 */\n\n    BF0( 7, 24, COS0_7 , 1);\n\n    BF0( 8, 23, COS0_8 , 1);\n\n    /* pass 2 */\n\n    BF( 7,  8, COS1_7 , 4);\n\n    BF(23, 24,-COS1_7 , 4);\n\n    /* pass 3 */\n\n    BF( 0,  7, COS2_0 , 1);\n\n    BF( 8, 15,-COS2_0 , 1);\n\n    BF(16, 23, COS2_0 , 1);\n\n    BF(24, 31,-COS2_0 , 1);\n\n    /* pass 1 */\n\n    BF0( 3, 28, COS0_3 , 1);\n\n    BF0(12, 19, COS0_12, 2);\n\n    /* pass 2 */\n\n    BF( 3, 12, COS1_3 , 1);\n\n    BF(19, 28,-COS1_3 , 1);\n\n    /* pass 1 */\n\n    BF0( 4, 27, COS0_4 , 1);\n\n    BF0(11, 20, COS0_11, 2);\n\n    /* pass 2 */\n\n    BF( 4, 11, COS1_4 , 1);\n\n    BF(20, 27,-COS1_4 , 1);\n\n    /* pass 3 */\n\n    BF( 3,  4, COS2_3 , 3);\n\n    BF(11, 12,-COS2_3 , 3);\n\n    BF(19, 20, COS2_3 , 3);\n\n    BF(27, 28,-COS2_3 , 3);\n\n    /* pass 4 */\n\n    BF( 0,  3, COS3_0 , 1);\n\n    BF( 4,  7,-COS3_0 , 1);\n\n    BF( 8, 11, COS3_0 , 1);\n\n    BF(12, 15,-COS3_0 , 1);\n\n    BF(16, 19, COS3_0 , 1);\n\n    BF(20, 23,-COS3_0 , 1);\n\n    BF(24, 27, COS3_0 , 1);\n\n    BF(28, 31,-COS3_0 , 1);\n\n\n\n\n\n\n\n    /* pass 1 */\n\n    BF0( 1, 30, COS0_1 , 1);\n\n    BF0(14, 17, COS0_14, 3);\n\n    /* pass 2 */\n\n    BF( 1, 14, COS1_1 , 1);\n\n    BF(17, 30,-COS1_1 , 1);\n\n    /* pass 1 */\n\n    BF0( 6, 25, COS0_6 , 1);\n\n    BF0( 9, 22, COS0_9 , 1);\n\n    /* pass 2 */\n\n    BF( 6,  9, COS1_6 , 2);\n\n    BF(22, 25,-COS1_6 , 2);\n\n    /* pass 3 */\n\n    BF( 1,  6, COS2_1 , 1);\n\n    BF( 9, 14,-COS2_1 , 1);\n\n    BF(17, 22, COS2_1 , 1);\n\n    BF(25, 30,-COS2_1 , 1);\n\n\n\n    /* pass 1 */\n\n    BF0( 2, 29, COS0_2 , 1);\n\n    BF0(13, 18, COS0_13, 3);\n\n    /* pass 2 */\n\n    BF( 2, 13, COS1_2 , 1);\n\n    BF(18, 29,-COS1_2 , 1);\n\n    /* pass 1 */\n\n    BF0( 5, 26, COS0_5 , 1);\n\n    BF0(10, 21, COS0_10, 1);\n\n    /* pass 2 */\n\n    BF( 5, 10, COS1_5 , 2);\n\n    BF(21, 26,-COS1_5 , 2);\n\n    /* pass 3 */\n\n    BF( 2,  5, COS2_2 , 1);\n\n    BF(10, 13,-COS2_2 , 1);\n\n    BF(18, 21, COS2_2 , 1);\n\n    BF(26, 29,-COS2_2 , 1);\n\n    /* pass 4 */\n\n    BF( 1,  2, COS3_1 , 2);\n\n    BF( 5,  6,-COS3_1 , 2);\n\n    BF( 9, 10, COS3_1 , 2);\n\n    BF(13, 14,-COS3_1 , 2);\n\n    BF(17, 18, COS3_1 , 2);\n\n    BF(21, 22,-COS3_1 , 2);\n\n    BF(25, 26, COS3_1 , 2);\n\n    BF(29, 30,-COS3_1 , 2);\n\n\n\n    /* pass 5 */\n\n    BF1( 0,  1,  2,  3);\n\n    BF2( 4,  5,  6,  7);\n\n    BF1( 8,  9, 10, 11);\n\n    BF2(12, 13, 14, 15);\n\n    BF1(16, 17, 18, 19);\n\n    BF2(20, 21, 22, 23);\n\n    BF1(24, 25, 26, 27);\n\n    BF2(28, 29, 30, 31);\n\n\n\n    /* pass 6 */\n\n\n\n    ADD( 8, 12);\n\n    ADD(12, 10);\n\n    ADD(10, 14);\n\n    ADD(14,  9);\n\n    ADD( 9, 13);\n\n    ADD(13, 11);\n\n    ADD(11, 15);\n\n\n\n    out[ 0] = val0;\n\n    out[16] = val1;\n\n    out[ 8] = val2;\n\n    out[24] = val3;\n\n    out[ 4] = val4;\n\n    out[20] = val5;\n\n    out[12] = val6;\n\n    out[28] = val7;\n\n    out[ 2] = val8;\n\n    out[18] = val9;\n\n    out[10] = val10;\n\n    out[26] = val11;\n\n    out[ 6] = val12;\n\n    out[22] = val13;\n\n    out[14] = val14;\n\n    out[30] = val15;\n\n\n\n    ADD(24, 28);\n\n    ADD(28, 26);\n\n    ADD(26, 30);\n\n    ADD(30, 25);\n\n    ADD(25, 29);\n\n    ADD(29, 27);\n\n    ADD(27, 31);\n\n\n\n    out[ 1] = val16 + val24;\n\n    out[17] = val17 + val25;\n\n    out[ 9] = val18 + val26;\n\n    out[25] = val19 + val27;\n\n    out[ 5] = val20 + val28;\n\n    out[21] = val21 + val29;\n\n    out[13] = val22 + val30;\n\n    out[29] = val23 + val31;\n\n    out[ 3] = val24 + val20;\n\n    out[19] = val25 + val21;\n\n    out[11] = val26 + val22;\n\n    out[27] = val27 + val23;\n\n    out[ 7] = val28 + val18;\n\n    out[23] = val29 + val19;\n\n    out[15] = val30 + val17;\n\n    out[31] = val31;\n\n}\n", "idx": 10699, "substitutes": {"out": ["up", " in", "in", "In", "temp", "trial", "Out", "doc", "data", "output", "obj", "outs", "table", "opt", "input", "raw", "user", "err", "new", "OUT", "copy", "orig", "file", "image", "io", "ch", "cmd", "ex"], "tab": ["term", "bb", "window", "test", "trial", "lab", "temp", "bar", "ray", "ab", "mem", "buf", "doc", "pb", "cb", "reg", "table", "ac", "db", "ctr", "track", "tx", "sb", "col", "bin", "cell", "buff", "acc"], "tmp0": [" tmp6", "tmp6", " buf6", " buf1", " buf5", " buf0", " proc6", " proc1", " proc0", " proc5", " tmp5", "tmp5"], "tmp1": ["temp3", "tmp01", "j7", "cv01", "cv7", "j3", "temp7", "j01", "temp01", "temp1", "j1", "tmp3", "cv3", "cv1", "tmp7"], "val0": ["f00", "value00", " val00", "value2", "f0", "val00", "f2", "value0"], "val1": ["Val1", "Val5", "eval11", "al1", "al11", "eval01", "al5", "Val11", "Val01", "val01", "eval5", "al01", "eval1"], "val2": ["doc4", "el22", "el5", "eval4", "eval2", "el2", "doc5", "el4", "eval5", "eval22", "doc2", "doc22"], "val3": ["value3", "eval33", " val03", "value33", "eval4", "value03", "val03", "val33", "eval3", " val33", "value4", "eval03"], "val4": ["Val4", "Val5", "eval4", "eval6", "eval5", "Val6", "eval8", "Val8"], "val5": [" val55", "value5", "value55", "eval55", "eval4", "eval5", "eval8", "val55", "value8", "value4"], "val6": ["value5", "al6", "al16", "eval16", "al8", "value6", "al5", "eval6", "eval5", "value16", "eval8", "value8"], "val7": ["vals5", "el8", "el5", "vals8", "el17", "vals17", "eval17", "eval5", "eval7", "eval8", "el7", "vals7"], "val8": ["value5", "eval11", "value6", "eval6", "value11", "eval5", "eval8", "value8"], "val9": ["eval11", "eval9", "eval10", "Val11", "eval8", "Val10", "Val8", "Val9"], "val10": ["Val12", "al8", "eval11", "eval12", "al12", "al11", "al10", "eval10", "Val11", "eval8", "Val10", "Val8"], "val11": ["aval13", "eval11", "eval20", "eval13", "el14", "aval11", "el20", "eval14", "el13", "aval14", "el11", "aval20"], "val12": ["eval18", "eval11", "eval12", "el12", "eval4", "el18", "el4", "el11"], "val13": ["valid16", "eval16", "eval13", "valid10", "eval10", "eval27", "valid27", "valid13"], "val14": ["el10", "eval16", "eval11", "value14", "el11", "el16", "el14", "eval14", "eval10", "value11", "value16", "value10"], "val15": ["el14", "eval15", " val03", "el17", "eval17", "el15", "val03", "eval14", "eval03", "el03"], "val16": ["eval16", "eval33", "value33", "value17", "eval17", "val33", "eval8", "value16", " val33", "value8"], "val17": ["al16", "al10", "value17", "al19", "value16", "value19", "value10", "al17"], "val18": ["eval19", "vals11", "vals15", "eval11", "eval18", "vals19", "vals18", "eval15"], "val19": ["eval19", "valid25", "valid19", "eval25", "eval26", "eval17", "valid17", "valid26"], "val20": ["vals15", "value14", "value13", "eval20", "eval13", "eval14", "vals13", "vals14", "value15", "value20", "vals20", "eval15"], "val21": ["eval21", "eval23", "el14", "el23", "eval14", "el27", "eval27", "el21"], "val22": ["el22", "el14", "eval14", "eval24", "valid22", "valid32", "eval32", "el32", "val32", "el24", "valid14", "eval22", "valid24"], "val23": ["eval21", "value23", "eval23", "eval24", "el25", "value21", "eval25", "el23", "value24", "el24", "el21", "value25"], "val24": ["al16", "eval16", "al27", "vals27", "al24", "eval25", "eval24", "vals16", "al25", "vals24", "eval27", "vals25"], "val25": ["el26", "eval24", "el25", "eval25", "eval26", "el15", "el24", "eval15"], "val26": ["eval18", "el26", "eval13", "eval26", "el18", "el27", "el13", "eval27"], "val27": ["value26", "arg28", "eval26", "arg27", "arg22", "value28", "arg26", "eval28", "value22", "eval27", "eval22", "value27"], "val28": ["vals27", "vals23", "eval23", "eval25", "eval28", "vals28", "eval27", "vals25"], "val29": ["al29", "eval29", "eval24", "al14", "al24", "al22", "eval14", "eval22"], "val30": ["aval15", "aval30", "eval29", "eval30", "aval29", "aval27", "eval27", "eval15"], "val31": ["eval21", "Val31", " val32", "eval33", "Val21", " val33", "Val33", "val33", "eval32", "val32", "eval31", "Val32"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void slirp_cleanup(Slirp *slirp)\n\n{\n\n    TAILQ_REMOVE(&slirp_instances, slirp, entry);\n\n\n\n    unregister_savevm(\"slirp\", slirp);\n\n\n\n    qemu_free(slirp->tftp_prefix);\n\n    qemu_free(slirp->bootp_filename);\n\n    qemu_free(slirp);\n\n}\n", "idx": 17664, "substitutes": {"slirp": ["plpirp", "plpirb", "slirsp", "clirpc", "plpirpc", "slirlpi", "slibrper", "slibru", "sloref", "clirc", "slireq", "slirpc", "slirtc", "shirpc", "slirec", "slirc", "clirp", "urrpa", "sliren", "plirp", "plirtp", "urru", "plirpc", "slorep", "slirspa", "plirtf", "slirln", "slirb", "plirn", "slirsper", "slirap", "slirtq", "slirapd", "slirtpd", "slrrper", "plirb", "slirepi", "plirf", "uiru", "clirpi", "slirlc", "clirtp", "clirtpi", "slrpc", "slirtpi", "slirsu", "slirtp", "plirtpc", "slirlP", "slirapc", "slpirc", "urrper", "slpirb", "slrru", "shirapi", "plirc", "slrp", "slirpa", "shirap", "slirP", "slironp", "slironpi", "plirq", "plirP", "slpirpc", "plirtP", "shirp", "slirn", "slirep", "plirtn", "slirper", "slrc", "sliru", "slirpi", "slirapi", "slibrp", "plirtq", "clirtpc", "sliref", "slibrpa", "plpirc", "slrrp", "slirtn", "slorepc", "slironpd", "slpirp", "slirpd", "shirapd", "slirq", "clirtc", "uirpa", "uirper", "slirlp", "slrrpa", "slironpc", "sloreq", "shirpi", "slirepc", "slireP", "slirlpc", "urrp", "slirtpc", "slireb", "slirf", "slirtf", "shirapc", "uirp", "slirtP", "slrb", "shirpd"]}}
{"project": "qemu", "commit_id": "6658ffb81ee56a510d7d77025872a508a9adce3a", "target": 1, "func": "void cpu_exec_init(CPUState *env)\n\n{\n\n    CPUState **penv;\n\n    int cpu_index;\n\n\n\n    if (!code_gen_ptr) {\n\n        code_gen_ptr = code_gen_buffer;\n\n        page_init();\n\n        io_mem_init();\n\n    }\n\n    env->next_cpu = NULL;\n\n    penv = &first_cpu;\n\n    cpu_index = 0;\n\n    while (*penv != NULL) {\n\n        penv = (CPUState **)&(*penv)->next_cpu;\n\n        cpu_index++;\n\n    }\n\n    env->cpu_index = cpu_index;\n\n\n    *penv = env;\n\n}", "idx": 2334, "substitutes": {"env": ["eu", "np", "inel", "server", "ctx", "extra", "conn", "context", "environment", "global", "nc", "dict", "priv", "ea", "scope", "end", "empty", "ne", "tmp", "here", "enc", "next", "eni", "inner", "code", "args", "ep", "config", "ec", "exc", "Environment", "p", "cv", "vs", "dev", "e", "stack", "eval", "app", "cache", "conf", "loader", "core", "exec", "el", "node", "en", "v", "ev", "NV", "En", "net", "console", "export", "db"], "penv": ["fenchev", "finvt", "stenv", " pencode", "enx", "venvt", "fenp", "penchev", "venve", "pinve", "senvs", "finve", "senh", "Penvt", "renchev", "fencode", "penvt", "fenj", "pnf", "sench", "pench", "pinvt", "fenh", "penvin", "renvin", "fenvs", "pnx", "fenu", "penf", "stenh", "senv", "pencode", "envt", "venvs", " penu", "penve", "enu", "pinv", "stenvs", "penx", "senvt", "pnv", "renx", "fenvin", "stench", "fench", "pinvs", "fenf", " penp", "Penu", "venv", "senu", "finvs", "Penf", "penu", "enf", "penp", "pinu", "finv", "pinp", "senf", "pnj", "pincode", " penchev", "penvs", "fenx", " penvin", "enj", "penh", " penx", "penj", "Penv", "renv", "fenv"], "cpu_index": ["pc__size", "cpu2index", "conn67index", "pc_number", "cpu2pointer", "cpu_ind", "cpuxsize", "cpu_path", "cpu67ind", "cpu__offset", "pu_slice", "pc_index", "pu_length", " cpu_name", "conn_number", "cpu__slice", " cpu_Index", " cpu_i", "cpu_length", "conn_size", "cpu67size", "cpu_name", "cpu_slice", "cpu67index", "cpu__size", "cpu_size", "pc__number", "cpu67number", "cpu2length", "cpu2slice", "cpu__pointer", "cpuxind", "cpu__number", " cpu_path", "pu_index", "cpu__length", "pc__offset", "conn67number", "cpu_Index", "pc__index", "conn67ind", "cpuxnumber", "pc_offset", "conn_index", "conn_ind", "cpu_i", "pc_size", "pu_pointer", "cpu_pointer", "conn67size", "cpu_offset", "cpuxindex", "cpu__index", "cpu_number"]}}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static int decode_init_mp3on4(AVCodecContext * avctx)\n\n{\n\n    MP3On4DecodeContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    if ((avctx->extradata_size < 2) || (avctx->extradata == NULL)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Codec extradata missing or too short.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    s->chan_cfg = (((unsigned char *)avctx->extradata)[1] >> 3) & 0x0f;\n\n    s->frames = mp3Frames[s->chan_cfg];\n\n    if(!s->frames) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid channel config number.\\n\");\n\n        return -1;\n\n    }\n\n    avctx->channels = mp3Channels[s->chan_cfg];\n\n\n\n    /* Init the first mp3 decoder in standard way, so that all tables get builded\n\n     * We replace avctx->priv_data with the context of the first decoder so that\n\n     * decode_init() does not have to be changed.\n\n     * Other decoders will be inited here copying data from the first context\n\n     */\n\n    // Allocate zeroed memory for the first decoder context\n\n    s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext));\n\n    // Put decoder context in place to make init_decode() happy\n\n    avctx->priv_data = s->mp3decctx[0];\n\n    decode_init(avctx);\n\n    // Restore mp3on4 context pointer\n\n    avctx->priv_data = s;\n\n    s->mp3decctx[0]->adu_mode = 1; // Set adu mode\n\n\n\n    /* Create a separate codec/context for each frame (first is already ok).\n\n     * Each frame is 1 or 2 channels - up to 5 frames allowed\n\n     */\n\n    for (i = 1; i < s->frames; i++) {\n\n        s->mp3decctx[i] = av_mallocz(sizeof(MPADecodeContext));\n\n        s->mp3decctx[i]->compute_antialias = s->mp3decctx[0]->compute_antialias;\n\n        s->mp3decctx[i]->adu_mode = 1;\n\n        s->mp3decctx[i]->avctx = avctx;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13571, "substitutes": {"avctx": ["mpcu", "afcms", "ajcu", "airctx", "avnc", "avsci", "avcas", "akcmp", "akci", "navctx", "apcmp", "akpkg", "afconfig", "ajbc", "avcu", " avcontext", "avecoll", "afbc", "avecontext", "navcontext", "mpconn", "avconfig", "abctx", "afcas", "afconn", "absci", "abcontext", "ajcontext", "abcmp", "apcontext", "afcf", "navcmp", "aftx", "afnc", "AVcontext", "avectx", "aktx", "abcu", "afcu", "awcu", "afcontext", "avcoll", "navsci", "avbc", "akctx", "avconn", "afci", "avenc", "amcontext", "ajcoll", "akcontext", "avetx", "afsci", " avkw", "awconfig", "aircas", "mpctx", "avkw", "afcb", "avesci", "avecb", "abpkg", "ajci", "avci", "avcf", "ajsci", "afkw", "avecu", "avtx", "mpcontext", "akcf", "AVsci", "ajctx", "apcu", "aveconfig", "aveci", "avcms", "avecf", "aircontext", "afctx", "abcb", "amcas", "Avconn", "afcoll", "ajnc", "avebc", "Avcontext", "afpkg", "AVcmp", "Avctx", "amctx", "awctx", "avcmp", "aircms", "AVcu", "afcmp", "apctx", "amcms", "avcontext", "avcb", "aveconn", "Avkw", " avconn", "AVctx", "awcontext", "avpkg"], "s": ["rs", "qs", "h", "js", "si", "ps", "params", "spec", "c", "is", "states", "aws", "args", "m", "self", "t", "sync", "sg", "fs", "ins", "sym", "sup", "g", "cs", "es", "full", "session", "w", "u", "members", "sf", "b", "ns", "ops", "r", "ks", "sys", "parts", "service", "your", "os", "sets", "o", "ms", "e", "sb", "f", "ans", "services", "ls", "comments", "ctx", "ses", "as", "l", "a", "S", "this", "its", "uns", "sq", "conf", "ss", "strings", "p", "n", "gs", "xs", "stats", "ssl", "ds", "su", "ts", "us", "ims", "vs"], "i": ["hi", "qi", "it", "ui", "adi", "I", "d", "ni", "ai", "xi", "id", "iu", "ini", "gi", "l", "a", "io", "oi", "iv", "api", "mu", "ci", "manager", "di", "x", "si", "ie", "ii", "v", "uri", "o", "yi", "u", "ind", "p", "e", "mini", "fi", "info", "cli", "li", "k", "b", "mi", "ix", "j", "multi", "n", "f", "phi", "ti", "ip", "c", "anti", "ji", "pi", "chi", "im", "bi", "ri", "ori", "y", "index"]}}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static void test_qemu_strtosz_metric(void)\n\n{\n\n    const char *str = \"12345k\";\n\n    char *endptr = NULL;\n\n    int64_t res;\n\n\n\n    res = qemu_strtosz_metric(str, &endptr);\n\n    g_assert_cmpint(res, ==, 12345000);\n\n    g_assert(endptr == str + 6);\n\n}\n", "idx": 23247, "substitutes": {"str": ["lc", "expr", "ix", "Str", "start", "obj", "err", "text", "ctr", "tr", "wr", "temp", "css", "cur", "exec", "r", "arr", "cs", "frac", "enc", "last", "code", "inner", "dr", "pr", "spec", "fr", "sc", "ocr", "sr", "hr", "ptr", "seq", "cr", "inst", "gr", "len", "br", "iter", "rs", "stri", "st", "sec", "empty", "wrap", "STR"], "endptr": ["startPtr", "endpointers", "ndpt", "endedptr", "adptr", "endPtr", "endpt", "endpointer", " endpointers", "startptr", "ndptr", "startaddr", " endaddr", "endaddr", "endedPtr", "Endpointers", "adpointer", "adaddr", "EndPtr", "ndpointer", " endpt", "endedpointer", "endedpointers", " endpointer", "startpt", "startpointer", "adPtr", "Endpointer", "Endptr", " endPtr"], "res": ["reg", "ras", "obj", "err", "rows", "result", "ress", "RES", "_", "rap", "rx", "rr", "bytes", "css", "results", "rez", "pre", "ris", "r", "s", "args", "os", "ret", "Res", "cs", "vals", "arr", "rh", "reed", "rc", "out", "js", "resh", "bits", "des", "pres", "ms", "ics", "rev", "re", "cr", "gr", "R", "rss", "req", "ps", "rs", "resolution", "resp"]}}
{"project": "qemu", "commit_id": "b9f7855a50a7cbf04454fa84e9d1f333151f2259", "target": 0, "func": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    /* We don't actually refresh here, but just return data queried in\n\n     * iscsi_open(): iscsi targets don't change their limits. */\n\n\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;\n\n\n\n    bs->request_alignment = iscsilun->block_size;\n\n\n\n    if (iscsilun->bl.max_xfer_len) {\n\n        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);\n\n    }\n\n\n\n    if (max_xfer_len * iscsilun->block_size < INT_MAX) {\n\n        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->lbp.lbpu) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff) {\n\n            bs->bl.max_discard =\n\n                sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun);\n\n        }\n\n        bs->bl.discard_alignment =\n\n            sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun);\n\n    } else {\n\n        bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS;\n\n    }\n\n\n\n    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {\n\n        bs->bl.max_pwrite_zeroes =\n\n            iscsilun->bl.max_ws_len * iscsilun->block_size;\n\n    }\n\n    if (iscsilun->lbp.lbpws) {\n\n        bs->bl.pwrite_zeroes_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;\n\n    }\n\n    if (iscsilun->bl.opt_xfer_len &&\n\n        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {\n\n        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *\n\n                                        iscsilun->block_size);\n\n    }\n\n}\n", "idx": 15486, "substitutes": {"bs": ["bt", "blocks", "bis", "bc", "lbs", "BS", "ins", "iss", "sels", "bb", "fs", "fb", "rs", "bn", "bd", "sync", "cs", "qs", "BC", "os", "bytes", "js", "abc", "ros", "ps", "ss", "ba", "s", "obs", "cks", "pb", "http", "b", "sb", "base", "ums", "bf", "gb", "gs", "bits", "bh", "ns", "bps", "uss", "cb", "outs", "bes", "bas", "blog", "ls", "css", "bos", "lb", "ubs", "las", "bl", "vs", "ts", "us", "ks", "aws"], "errp": ["errr", "erp", "rP", "rr", " errr", "errP", "rp", "erfp", "errfp", "erP", " errfp", " errP", "rfp", "err"], "iscsilun": ["uscslren", "isclitur", "ircsiluna", "iscalun", "iscisluna", "uscsilon", "iscmilur", "miscilaoun", "isculinuna", "uscsiluna", "iscselun", "ISCsiluna", "iscvaleber", "isclesiunt", "iscillu", "isclituna", "iscislunt", "iscselluna", "iscilsunin", "iscryptun", "iscilaun", "ISCsilun", "ircsilunt", "iscillan", "isecsellu", "miscsilun", "iscivalun", "ircslur", "iscilul", "ircsilmun", "uscsilunt", "iscsiluno", "iscsylvunt", "iscilber", "iscilan", "isecsilken", "isciryuna", "isclassuna", "isccomplun", "iscilluna", "uscsilfun", "iscelligun", "iscelligunt", "uscsilmun", "uscslfun", "uscslu", "iscsilund", "isculinunt", "iscvalecon", "iscslund", "iscsilunt", "iscoblmun", "iscSiluna", "ecsilber", "miscsilune", "ircsilul", "iscselur", "micillunin", "miscilaunt", "wicsilken", "iscpirun", "iscislun", "iscsilen", "iscillut", "miscsiluna", "isecsilu", "iscilloren", "iscmilunt", "iscillren", "iscseluna", "iscsylvune", "miscsilunt", "isclesiuna", "iacsilmun", "isculinun", "iscivaluna", "iscSilur", "uscsilcon", "ircsilune", "uscslun", "isclassun", "iscilsune", "uscielunin", "iscvalean", "miscilaune", "ISClitunt", "uscsilut", "sicsilen", "iscsellut", "iscsellmun", "iscsilunin", "iscslfun", "iscielken", "iscmilun", "iscpiruna", "ircslmun", "uscslunin", "iscilaune", "iscsilunion", "isclitunt", "iscvaleken", "isclitul", "isclitfun", "iscslan", "wicillken", "iscryptfun", "iacsiluna", "iscilunt", "iscirymun", "iscsiluna", "usciluna", "iscinelken", "isecsilund", "ircsilu", "iscslu", "iscsellu", "iscsylvun", "iacsilun", "iscilon", "uscsilu", "ecsilun", "iscryptunin", "uscsilune", "iscislurn", "uscslunt", "eclitber", "iscielunt", "isclassren", "micsilunt", "wicsilun", "iscilaon", "iscsiloun", "iscvirtunin", "micsilunin", "ircsilur", "iscslunin", "iscsilur", "iscielu", "iacsellund", "miscilaun", "isclitan", "uscilmun", "iscslur", "iscivalund", "iscillunin", "iscinelen", "iscilaunt", "iscsilber", "iscvaleunt", "misclitun", "iscryptuna", "iscislune", "iscsellune", "micsilun", "ISClituna", "ecsilan", "isecsellken", "wicillun", "iacsellun", "uscielunt", "ircsloren", "iscselken", "sicsilmun", "isccomplund", "isccompluna", "iscoblken", "iscillunion", "iscslun", "sicsilun", "iscsilu", "iscslut", "iscalunin", "iscielun", "iscsiloren", "iscielune", "iscslren", "iacselluna", "iscvalemun", "wicsilunt", "miscsilur", "iscelligken", "iscielmun", "isclesiun", "iscsilcon", "ircsiloren", "iscinelun", "iscilsuna", "ircslu", "isculinmun", "uscsluna", "iscpirmun", "iscilren", "iscislmun", "iscalu", "iscillken", "ircslun", "ircsilut", "iscSilu", "iscvaleen", "micilluna", "iscsilren", "iscmiluna", "ircieluna", "ISCsilunion", "eclitan", "sicsilken", "uscsilren", "isclitunion", "isecsellun", "iscselluno", "isclassunt", "iscsilon", "ircslund", "uscslan", "iscsluna", "ircsilund", "iscislund", "iscsilune", "iscielunin", "isclitun", "iscoblen", "ircielun", "ISCsilunt", "iscoblun", "ircsilun", "uscieluna", "isclitber", "eclitun", "isclustuna", "uscielun", "isciryund", "isclesiune", "ircslunt", "uscsilunin", "iscielul", "iscsilken", "isclustun", "uscilunt", "ircielul", "isecsiluna", "ircielmun", "micsiluna", "ISClitun", "misclitunt", "wicsiluna", "ircsluna", "iscvirtun", "sicinelmun", "iscslune", "iscilaoun", "ircsluno", "iscilsun", "iscsilmun", "isecsilurn", "ircslune", "iscsluno", "ecsilul", "iscillunt", "isecislurn", "ISClitunion", "micillunt", "iscvirtuna", "iscSilun", "uscslon", "iscislut", "iscilmun", "iscslon", "isclustmun", "ircsiluno", "miscsiloun", "iscsilurn", "iscielund", "misclituna", "iscivalmun", "iscilauna", "iscvirtune", "isciluna", "uscsilan", "isclesiut", "iscvaleun", "iscieluna", "iscsilul", "iscelliguna", "isclesioren", "misclitur", "iscpirunt", "uscielcon", "uscilun", "isecsilun", "iscinelmun", "micillun", "iscsilfun", "isecislund", "iscilaren", "isecsellund", "uscslut", "iscisloun", "uscielune", "iscillun", "iscslunt", "sicinelun", "iscslmun", "ircslut", "wicillunt", "iscielcon", "iacsellmun", "iscsylvoun", "isccomplurn", "iscselu", "sicinelken", "isciryun", "isculinund", "iscvaleul", "iacsilund", "iscsloren", "iscvaleuna", "iscsellun", "isculinuno", "isclustul", "iscilun", "eclitul", "isclitcon", "isecislun", "isclitunin", "iscsellken", "uscsilun", "isecisluna", "iscsellund", "sicinelen", "iscillune", "iscselund", "wicilluna", "iscsilut", "iscsilan", "iscielunion", "iscaluna"]}}
{"project": "FFmpeg", "commit_id": "ebea370dc3909aa182bae4c728b83516a904beca", "target": 0, "func": "static int write_fragments(struct Tracks *tracks, int start_index,\n\n                           AVIOContext *in)\n\n{\n\n    char dirname[100], filename[500];\n\n    int i, j;\n\n\n\n    for (i = start_index; i < tracks->nb_tracks; i++) {\n\n        struct Track *track = tracks->tracks[i];\n\n        const char *type    = track->is_video ? \"video\" : \"audio\";\n\n        snprintf(dirname, sizeof(dirname), \"QualityLevels(%d)\", track->bitrate);\n\n        mkdir(dirname, 0777);\n\n        for (j = 0; j < track->chunks; j++) {\n\n            snprintf(filename, sizeof(filename), \"%s/Fragments(%s=%\"PRId64\")\",\n\n                     dirname, type, track->offsets[j].time);\n\n            avio_seek(in, track->offsets[j].offset, SEEK_SET);\n\n            write_fragment(filename, in);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 9047, "substitutes": {"tracks": ["tags", "setup", "styles", "tones", "music", "ks", "plays", "clips", "frames", "rows", "features", "roots", "cases", "links", "mods", "shows", "fields", "files", "path", "pps", "flows", "archives", "metadata", "history", "reads", "forms", "steps", "tests", "xml", "reports", "runs", "xs", "rs", " Tracks", "errors", "grades", "plugins", "cs", "checks", "notes", "acks", "services", "effects", "projects", "groups", "hops", "thumbnails", "tracking", "docs", "videos", "times", "settings", "events"], "start_index": ["work_Index", " start_initial", "start_initial", "start_Index", "start_address", "work_address", "start_offset", "work_index", " start_offset"], "in": ["str", "g", "n", "source", "In", "again", "conn", "m", "src", "b", "t", "inn", "ini", "login", "con", "c", "gin", "config", "reader", "stack", "ins", "socket", "f", "ac", "resource", "inc", "input", "connection", "min", "ic", "r", "ctx", "buffer", "read", "impl", "ci", "out", "image", "bin", "fc", "a", "url", "IN", "nin", "lin", "exec"], "dirname": ["fileName", "filenames", " directorysize", "foldernam", "folderpath", "dirsize", "pathsize", "directoryName", "dirdir", "directionsize", "dirnum", "pathstart", " dirsize", "directoryname", "dirName", "pathname", "directionname", "directorynam", "pathnum", "directoryfile", "filenam", "directorypath", " dirnames", " dirpath", "dirnames", "dirpath", "foldername", "directionsync", "folderName", "dirsync", "directionstart", "directorynames", "directorysize", "dirstart", "filepath", " dirsync", "dirfile", " dirdir", "directiondir", " directoryname", "directorystart", "pathsync", "directorynum", "directionnum", "dirnam", "pathdir", " dirfile", " directoryfile"], "filename": ["download", "il", "ename", "sheet", "prefix", "sf", "word", "json", "sql", "mpeg", "fd", "path", "wb", "lvl", "metadata", "rl", "output", "username", "lace", "uri", "fp", "txt", "final", "title", "Filename", "f", "nm", "binary", "bj", "database", "journal", "nil", "name", "folder", "phrase", "jpg", "document", "token", "dll", "summary", "fn", "fax", "file", "url", "length", "directory", "write", "jl", "buffer", "println", "kl"], "i": ["oi", "l", "ui", "di", "it", "is", "n", "si", "start", "zi", "adi", "id", "xi", "m", "b", "x", "k", "ami", "z", "ini", "d", "c", "ji", "p", "ix", "e", "yi", "eni", "f", "ie", "ai", "o", "index", "v", "name", "ind", "gi", "ti", "mi", "r", "qi", "bi", "pi", "ii", "u", "h", "I", "li", "ip", "ci", "ori", "ni", "io", "y", "ri", "fi", "iu", "ki"], "j": ["l", "ld", "je", "adj", "n", "g", "key", "m", "xi", "fr", "jet", "k", "b", "dj", "z", "t", "x", "jen", "job", "ji", "c", "p", "jo", "obj", "e", "el", "arg", "jam", "kj", "js", "f", "ie", "uj", "o", "v", "jit", "ind", "r", "jump", "req", "ij", "jp", "ii", "ja", "u", "aj", "h", "oj", "li", "ci", "J", "y", "rev", "jc", "jl", "jj", "br"], "track": ["round", "play", "rank", "sound", "field", "ack", "scale", "tr", "test", "record", "note", "trial", "date", "stage", "tag", "song", "task", "path", "project", "rec", "metadata", "rule", "time", "work", "skip", "seek", "gro", "coll", "group", "step", "mode", "call", "progress", "trace", "index", "name", "event", "order", "ride", "jump", "artist", "trip", "token", "Track", "sort", "audio", "check", "grade", "tm", "pair", "layer", "transform", "rack", "tracking", "gap", "complete", "match", "toggle"], "type": ["len", "source", "key", "date", "id", "info", "t", "path", "Type", "block", "rule", "time", "data", "p", "target", "attr", "rel", "value", "number", "style", "types", "label", "code", "dir", "version", "format", "name", "ty", "sort", "TYPE", "link", "single", "year", "file", "url", "length", "y", "ype", "typ"]}}
{"project": "qemu", "commit_id": "ebd9fbd7e102c533143c2c8372312b75c2b2678a", "target": 1, "func": "static int block_save_iterate(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n    int64_t last_ftell = qemu_ftell(f);\n\n\n\n    DPRINTF(\"Enter save live iterate submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* control the rate of transfer */\n\n    blk_mig_lock();\n\n    while ((block_mig_state.submitted +\n\n            block_mig_state.read_done) * BLOCK_SIZE <\n\n           qemu_file_get_rate_limit(f)) {\n\n        blk_mig_unlock();\n\n        if (block_mig_state.bulk_completed == 0) {\n\n            /* first finish the bulk phase */\n\n            if (blk_mig_save_bulked_block(f) == 0) {\n\n                /* finished saving bulk on all devices */\n\n                block_mig_state.bulk_completed = 1;\n\n            }\n\n            ret = 0;\n\n        } else {\n\n            /* Always called with iothread lock taken for\n\n             * simplicity, block_save_complete also calls it.\n\n             */\n\n            qemu_mutex_lock_iothread();\n\n            ret = blk_mig_save_dirty_block(f, 1);\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        blk_mig_lock();\n\n        if (ret != 0) {\n\n            /* no more dirty blocks */\n\n            break;\n\n        }\n\n    }\n\n    blk_mig_unlock();\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n    return qemu_ftell(f) - last_ftell;\n\n}\n", "idx": 26726, "substitutes": {"f": ["ref", "fen", "uf", "fe", "k", "xf", "fo", "af", "info", "p", "m", "b", "c", "elf", "this", "fac", "d", "i", "rf", "x", "fn", "bf", "fm", "form", "fr", "e", "lf", "fc", "o", "ff", "fw", "inf", "fi", "fb", "fx", "cf", "fore", "fs", "tf", "fa", "t", "fp", "v", "g", "sf", "df", "l", "fd", "file", "F"], "opaque": ["opcodes", " opalloc", "opacity", "OPalloc", "opalloc", "operacity", "OPcodes", "operaque", " opcodes", "operalloc", "OPacity", " opacity", "OPaque", "opercodes"], "ret": ["ref", "fin", "sr", "ft", "cat", "att", "num", "url", "mem", "valid", "mt", "det", "lit", "rot", "nt", "status", "match", "val", "gt", "complete", "code", "obj", "flag", "red", "hard", "debug", "def", "rep", "bit", "RET", "result", "let", "feat", "bad", "pat", "Ret", "len", "fun", "rest", "done", "res", "usr", "data", "back", "rb", "success", "fail", "pub", "bl", "error", "db", "fab", "str", "err", "re", "reply", "req", "arg", "alt", "reg", "resp", "info", "hash", "job", "bf", "rets", "rev", "fit", "art", "run", "rc", "html", "active", "rt", "ext", "out", "reset"]}}
{"project": "FFmpeg", "commit_id": "2f86e7bd12d8023da3349f10490b1e5b64531e23", "target": 1, "func": "static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,\n\n                         const char *filt_name, const char *args, AVClass *log_ctx)\n\n{\n\n    AVFilter *filt;\n\n    char inst_name[30];\n\n    char tmp_args[256];\n\n    int ret;\n\n\n\n    snprintf(inst_name, sizeof(inst_name), \"Parsed filter %d %s\", index, filt_name);\n\n\n\n    filt = avfilter_get_by_name(filt_name);\n\n\n\n    if (!filt) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"No such filter: '%s'\\n\", filt_name);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ret = avfilter_open(filt_ctx, filt, inst_name);\n\n    if (!*filt_ctx) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Error creating filter '%s'\\n\", filt_name);\n\n        return ret;\n\n    }\n\n\n\n    if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) {\n\n        avfilter_free(*filt_ctx);\n\n        return ret;\n\n    }\n\n\n\n    if (!strcmp(filt_name, \"scale\") && !strstr(args, \"flags\")) {\n\n        snprintf(tmp_args, sizeof(tmp_args), \"%s:%s\",\n\n                 args, ctx->scale_sws_opts);\n\n        args = tmp_args;\n\n    }\n\n\n\n    if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Error initializing filter '%s' with args '%s'\\n\", filt_name, args);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3721, "substitutes": {"filt_ctx": ["fill_c", "filt_ca", "fil_conn", "filt_voc", "fil_voc", "filt___voc", "filt___ctx", "filt___context", "fil_scope", "flt_ctx", "fill_ctx", "flt_loc", "filt_context", "filt_conn", "fil_cmd", "filt_lc", "filt_scope", "flt_cp", "fill_context", "filt_c", "flt_conn", "flt_lc", "flt_context", "filt___ca", "fil_ca", "filt_cs", "fil_context", "fill_ca", "filt_cp", "filt_loc", "fil_ctx", "fil_cs", "filt_cmd"], "ctx": ["fc", "cm", "cli", "cam", "src", "cs", "conn", "context", "cc", "cpp", "Context", "loc", "ck", "bc", "graph", "scope", "tc", "concept", "client", "cas", "comp", "tx", "cb", "config", "crit", "pkg", "cu", "c", "cv", "xc", "lc", "cn", "sc", "ctrl", "ca", "exec", "cmd", "obj", "pc", "cca", "connection", "qa", "cp", "cmp", "cf", "conv", "support", "ci", "cfg", "rc"], "index": ["match", "Index", "base", "name", "offset", "find", "active", "context", "current", "image", "column", "loc", "type", "id", "fff", "end", "num", "search", "instance", "pos", "info", "slice", "config", "x", "ind", "example", "len", "length", "ref", "f", "col", "size", "connection", "prefix", "depth", "addr", "part", "inc", "input"], "filt_name": ["flt_Name", "fil_name", "filtPName", "factory_NAME", "filtacNAME", "filtacnames", "filt_names", "filt__NAME", "filt_value", "filt__type", "fillFvalue", "filtPname", "fillFName", "factory_name", "filt__name", "filt_block", "filtFname", "factoryactype", "factoryacname", "filtactype", "filt_id", "flt_name", "filtFName", "fil_names", "filt_NAME", "ffilter_name", "factoryacNAME", "fill_value", "factory_type", "filtPpath", "factory_names", "filtFvalue", "flt_id", "filt__names", "fill_Name", "filt_Name", "flt_node", "ffilter_Name", "filt__Name", "ffilter_path", "factoryacnames", "filt_path", "filt_node", "fill_name", "fillFname", "filtacname", "filt_type", "ffilter_block", "fil_Name", "filtPblock"], "args": ["limits", "files", "arg", "missing", "ig", "name", "ics", "alls", "groups", "works", "null", "ass", "extra", "spec", "array", "actions", "acl", "vals", "data", "ips", "flags", "strings", "results", "help", "empty", "objects", "includes", "links", "arr", "enc", "options", "ids", "comments", "params", "bits", "body", "ars", "resources", "names", "cards", "ras", "config", "ams", "gs", "str", "result", "example", "p", "items", "afi", "values", "atts", "lines", "size", "cache", "alloc", "fields", "blocks", " arguments", "qa", "ay", "Args", "bytes", "changes", "ages", "init", "parts", "allows"], "log_ctx": ["log_cn", "logwcb", "log_ca", "logalcn", "failpcf", "log_fn", "logpctx", "log_sys", "logerctx", "logpfn", "fail_fn", "tagercb", "logpcn", "failpcn", "tagersys", "logencci", "logboardctx", "log_scope", "logervc", "fail_ctx", "tag_cb", "logingvc", "log_vc", "Log_ctx", "tagerctx", "logwvc", "lock_cci", "tag_ctx", "logenscope", "logenctx", "logercb", "logalctx", "Log_context", "logboardcontext", "lock_scope", "lock_ca", "failpctx", "log_cf", "logwctx", "logingcb", "logboardjc", "logingctx", "tag_vc", "logwsys", "logersys", "log_sc", "logalcf", "tagervc", "Log_jc", "logboardsc", "lock_ctx", "logalfn", "logpcf", "fail_cn", "log_cci", "log_cb", "failpfn", "logenca", "tag_sys", "Log_sc", "fail_cf", "logingsys", "log_context", "log_jc"], "filt": ["infizzle", "Filt", "sfizzle", "flld", "bil", "dfil", " fld", "inffilter", "filler", " facet", "firt", "flt", "Flt", "dfld", "biller", "infilt", "sflt", "sfld", "sfilt", "fil", "Facet", " fil", "bilt", "dfiller", "dfilt", "sffilter", "infld", " filler", "bld", "sfacet", "infirt", "fizzle", " flt", "fld", "facet", "ffilter", "Fizzle", "flizzle", "flilt", " ffilter", " fizzle", " firt", "flirt"], "inst_name": ["instacdata", "inst__span", "inst__id", "instameName", "Inst_data", "inst_conn", "inst_id", "inst_Name", "instamename", "instameid", " inst_conn", "inst_data", "inst_prefix", "instance_info", "inst_names", " inst_span", "inst__name", "instamespan", "inst__Name", "Inst_names", "Inst_name", "instance_name", " inst_id", "instacnames", "inst_info", "inst_span", " inst_names", "instacname", "instance_names", "instance_prefix", " inst_Name"], "tmp_args": ["tmp_items", " tmp_arg", "tmp_ams", "temp_members", " tmp_parts", "tmp2args", "tmp_params", "tmp_arg", "tmp_options", "tmp_members", "temp_items", "temp_ams", " tmp_options", "temp_errors", "tmp2parts", "temp_arg", "tmp_errors", "temp_args", "tmp2arg", "tmp_parts", "tmp2caps", "tmp_caps", " tmp_params", " tmp_caps"], "ret": ["match", "base", "arg", "fun", "att", "mt", "ext", "utf", "def", "gc", "success", "data", "url", "r", "alt", "cur", "job", "pet", "rets", "grad", "arr", "num", "pass", "fail", "rb", "code", "info", "ft", "nt", "err", "str", "reply", "feat", "Ret", "back", "tr", "bad", "opt", "result", "bot", "ut", "f", "len", "flag", "ref", "red", "gt", "value", "obj", "RET", "valid", "al", "re", "run", "val", "reg", "rt", "part", "lit", "let", "det", "res", "debug", "db", "rc", "mem"]}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))\n\n{\n\n    while (queue->p_head)\n\n        free_func(ff_schro_queue_pop(queue));\n\n}\n", "idx": 22531, "substitutes": {"queue": ["status", "route", "port", "Queue", "event", "config", "thread", "menu", "loop", "progress", "message", "file", "plugin", "buffer", "pipe", "model", "entry", "ue", "sequence", "cache", "list", "job", "p", "prefix", "que", "q", "sync", "client", "pool", "module", "complete", "collection", "future", "priority", "line", "flag", "seq", "worker", "channel", "qa", "page", "batch", "lib", "manager", "user", "group", "server", "command"], "free_func": ["free2lambda", " free_dc", " free_function", "free2pc", "freefunccb", "free_function", "free__dc", "free_cb", "free__func", " free_lambda", "free_dc", "free__cb", "free2function", " free_pc", "free__function", "freefuncdc", "free_pc", "freefuncfunction", " free_cb", "free_lambda", "freefuncfunc", "free2func"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "envlist_free(envlist_t *envlist)\n\n{\n\n\tstruct envlist_entry *entry;\n\n\n\n\tassert(envlist != NULL);\n\n\n\n\twhile (envlist->el_entries.lh_first != NULL) {\n\n\t\tentry = envlist->el_entries.lh_first;\n\n\t\tLIST_REMOVE(entry, ev_link);\n\n\n\n\t\tfree((char *)entry->ev_var);\n\n\t\tfree(entry);\n\n\t}\n\n\tfree(envlist);\n\n}\n", "idx": 20553, "substitutes": {"entry": ["member", "route", "lc", "je", "row", "e", "end", "obj", "next", "option", "part", "ger", "key", "connection", "card", "entity", "cell", "ell", "section", "slave", "cat", "data", "zip", "her", "link", "or", "list", "id", "code", "inner", "comment", "index", "search", "si", "service", "se", "enter", "error", "child", "reader", "try", "element", "archive", "feed", "base", "Entry", "ew", "ry", "ent", "nt", "server", "ge", "ie", "record", "ev", " Entry", "letter"]}}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)\n\n{\n\n    static uint32_t bmap[INPUT_BUTTON__MAX] = {\n\n        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),\n\n        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),\n\n        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),\n\n        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),\n\n        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),\n\n    };\n\n    static uint32_t prev_state;\n\n\n\n    if (prev_state != state) {\n\n        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);\n\n        prev_state = state;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,\n\n                             real_screen->w);\n\n        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,\n\n                             real_screen->h);\n\n    } else {\n\n        if (guest_cursor) {\n\n            x -= guest_x;\n\n            y -= guest_y;\n\n            guest_x += x;\n\n            guest_y += y;\n\n            dx = x;\n\n            dy = y;\n\n        }\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);\n\n        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);\n\n    }\n\n    qemu_input_event_sync();\n\n}\n", "idx": 794, "substitutes": {"dx": ["yx", "dn", "da", "ud", "dd", "dh", "data", "zx", "loc", "d", "xd", "distance", "px", "xy", "max", "ady", "push", "xs", "dt", "ds", "z", "xp", "xx", "dc", "step", "down", "pad", "phy", "w", "front", "patch", "fix", "ww", "fx", "wd", "prefix", "ix", "rx", "DX", "depth", "view", "xxx", "start", "ex", "diff", "dist", "xi", "wx"], "dy": ["delay", "yi", "dn", "da", "dd", "ii", "dim", "zi", "data", "ui", "zy", "idy", "iy", "d", "di", "gy", "dl", "ry", "xy", "ny", "ty", "j", "i", "py", "ady", "yd", "sync", "direction", "z", "yy", "md", "ey", "dir", "ds", "lon", "down", "hi", "vy", "f", "b", "depth", "dist", "yer", "eddy", "wy", "diff", "db", "sy"], "x": ["name", "yx", "q", "image", "r", "d", "n", "px", "id", "xy", "i", "pos", "m", "X", "xs", "z", "index", "xx", "down", "h", "p", "l", "c", "w", "e", "hi", "xc", "ax", "height", "u", "en", "o", "v", "b", "ix", "rx", "t", "path", "xxx", "one", "ex", "xi"], "y": ["yi", "q", "ye", "yl", "ish", "yo", "zy", "iy", "d", "n", "type", "yan", "ry", "cy", "xy", "ny", "ya", "ty", "j", "i", "year", "py", "ady", "m", "ky", "z", "yy", "ey", "ch", "h", "l", "p", "w", "vy", "col", "yt", "o", "ay", "b", "t", "Y", "oy", "sky", "wy", "sy"], "state": ["version", "name", "key", "active", "area", "new", "d", "type", "STATE", "id", "scope", "parent", "seed", "j", "instance", "next", "State", "i", "update", "inner", "m", "none", "code", "sync", "event", "direction", "style", "err", "z", "index", "ch", "status", "st", "step", "down", "p", "e", "force", "size", "length", "f", "resource", "private", "self", "set", "value", "up", "range", "scale", "b", "ate", "error", "old", "rule", "notice", "val", "mode", "states", "part", "start", "in", "sy"], "bmap": ["cMap", "cmap", "bMAP", " bMAP", "cbmaps", "pmaps", "cmaps", "bMap", "bbmap", "bbMap", " bMap", "bmaps", "cMAP", "cbmap", "cbMap", "pmap", " bmaps", "cbMAP", "pMAP", "pMap", "bbmaps", "bbMAP"], "prev_state": ["keep_status", "keepfstate", "prev_State", "keep_state", " prev_connection", "keepfstatus", " prev_rule", "prev___states", "prev___state", "keep_call", "prevfscale", " prev_State", "prevPstatus", "prev_rule", "prev_scale", "prevPscale", "prevfcall", "prevfstate", "prev_connection", "prev___connection", "prev_call", "keep_scale", "prevPstate", " prev_config", "prevfstatus", " prev_states", "prev_status", "prevPcall", "prev_states", "prev_config", "keepfcall", "keepfscale"]}}
{"project": "qemu", "commit_id": "3a5c76baf312d83cb77c8faa72c5f7a477effed0", "target": 0, "func": "static FWCfgState *bochs_bios_init(void)\n\n{\n\n    FWCfgState *fw_cfg;\n\n    uint8_t *smbios_tables, *smbios_anchor;\n\n    size_t smbios_tables_len, smbios_anchor_len;\n\n    uint64_t *numa_fw_cfg;\n\n    int i, j;\n\n    unsigned int apic_id_limit = pc_apic_id_limit(max_cpus);\n\n\n\n    fw_cfg = fw_cfg_init_io(BIOS_CFG_IOPORT);\n\n    /* FW_CFG_MAX_CPUS is a bit confusing/problematic on x86:\n\n     *\n\n     * SeaBIOS needs FW_CFG_MAX_CPUS for CPU hotplug, but the CPU hotplug\n\n     * QEMU<->SeaBIOS interface is not based on the \"CPU index\", but on the APIC\n\n     * ID of hotplugged CPUs[1]. This means that FW_CFG_MAX_CPUS is not the\n\n     * \"maximum number of CPUs\", but the \"limit to the APIC ID values SeaBIOS\n\n     * may see\".\n\n     *\n\n     * So, this means we must not use max_cpus, here, but the maximum possible\n\n     * APIC ID value, plus one.\n\n     *\n\n     * [1] The only kind of \"CPU identifier\" used between SeaBIOS and QEMU is\n\n     *     the APIC ID, not the \"CPU index\"\n\n     */\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)apic_id_limit);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_ACPI_TABLES,\n\n                     acpi_tables, acpi_tables_len);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_IRQ0_OVERRIDE, kvm_allows_irq0_override());\n\n\n\n    smbios_tables = smbios_get_table_legacy(&smbios_tables_len);\n\n    if (smbios_tables) {\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_SMBIOS_ENTRIES,\n\n                         smbios_tables, smbios_tables_len);\n\n    }\n\n\n\n    smbios_get_tables(&smbios_tables, &smbios_tables_len,\n\n                      &smbios_anchor, &smbios_anchor_len);\n\n    if (smbios_anchor) {\n\n        fw_cfg_add_file(fw_cfg, \"etc/smbios/smbios-tables\",\n\n                        smbios_tables, smbios_tables_len);\n\n        fw_cfg_add_file(fw_cfg, \"etc/smbios/smbios-anchor\",\n\n                        smbios_anchor, smbios_anchor_len);\n\n    }\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_E820_TABLE,\n\n                     &e820_reserve, sizeof(e820_reserve));\n\n    fw_cfg_add_file(fw_cfg, \"etc/e820\", e820_table,\n\n                    sizeof(struct e820_entry) * e820_entries);\n\n\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_HPET, &hpet_cfg, sizeof(hpet_cfg));\n\n    /* allocate memory for the NUMA channel: one (64bit) word for the number\n\n     * of nodes, one word for each VCPU->node and one word for each node to\n\n     * hold the amount of memory.\n\n     */\n\n    numa_fw_cfg = g_new0(uint64_t, 1 + apic_id_limit + nb_numa_nodes);\n\n    numa_fw_cfg[0] = cpu_to_le64(nb_numa_nodes);\n\n    for (i = 0; i < max_cpus; i++) {\n\n        unsigned int apic_id = x86_cpu_apic_id_from_index(i);\n\n        assert(apic_id < apic_id_limit);\n\n        for (j = 0; j < nb_numa_nodes; j++) {\n\n            if (test_bit(i, numa_info[j].node_cpu)) {\n\n                numa_fw_cfg[apic_id + 1] = cpu_to_le64(j);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    for (i = 0; i < nb_numa_nodes; i++) {\n\n        numa_fw_cfg[apic_id_limit + 1 + i] = cpu_to_le64(numa_info[i].node_mem);\n\n    }\n\n    fw_cfg_add_bytes(fw_cfg, FW_CFG_NUMA, numa_fw_cfg,\n\n                     (1 + apic_id_limit + nb_numa_nodes) *\n\n                     sizeof(*numa_fw_cfg));\n\n\n\n    return fw_cfg;\n\n}\n", "idx": 23163, "substitutes": {"fw_cfg": ["fwappfg", "nw_gd", "fwxcgi", "fwercfg", "cf_conn", "nw_fg", "cf_gate", "rw_conn", "cf_gen", "fwthegeneral", "fw_forge", "fx_forge", "fd_gui", "fw25cfg", "cf_config", "fwfcb", "rw_dc", "fw_gen", "fw25gui", "fwfconn", "fwxgd", "fx_cfg", "rw_fg", "cf_cf", "fw_gui", "fw__bg", "work_dc", "fwxcfg", "fw_config", "nw_cgi", "work_conn", "fwthecf", "fw_gd", "fwfdc", "fdthecfg", "fwxfg", "nw_cfg", "workfcfg", "fwfcfg", "cf_fg", "wk_fg", "fwappgd", "rw_cb", "fw_dc", "fx_settings", "fwappbg", "rw_cfg", "wk_cfg", "fwergeneral", "fwthesettings", "fdthegui", "wk_cf", "fw_bg", "fwthegui", "fw_fg", "workfcb", "work_cb", "fw25cf", "fdthegeneral", "fdthecf", "rw_cf", "work_cfg", "fd_cfg", "wk_conn", "fw_cf", "fwtheforge", "fd_cf", "fw_general", "fwthecfg", "fx_general", "fw_cgi", "fw25general", "workfdc", "fw_cb", "fw_gate", "fwersettings", "nw_bg", "fw__cfg", "fwerforge", "fw_conn", "fw__gd", "cf_cfg", "fw__fg", "fd_general", "fwappcfg", "fw_settings", "workfconn"], "smbios_tables": ["smbios_untable", "smbios_testries", "smbios_tasks", "smbios_entables", "smbios_temrees", "smbios_ttables", "smbios_tenras", "smbios_temables", "smbios_bipes", "smbios_nries", "smbios_ontables", "smbios_lrees", "smbios_tries", "smbios_tigs", "smbios_ontabs", "smbios_ftras", "smbios_tributes", "smbios_tees", "smbios_stigs", "smbios_nigs", "smbios_trees", "smbios_stables", "smbios_untables", "smbios_nables", "smbios_entubs", "smbios_ftipes", "smbios_Tipes", "smbios_ttubs", "smbios_ftributes", "smbios_table", "smbios_brees", "smbios_Tables", "smbios_stries", "smbios_ttamps", "smbios_ptigs", "smbios_ptrees", "smbios_tenributes", "smbios_stributes", "smbios_testables", "smbios_nributes", "smbios_ptasks", "smbios_tamps", "smbios_tenests", "smbios_tenipes", "smbios_tras", "smbios_Tries", "smbios_temipes", "smbios_ftables", "smbios_ttries", "smbios_contees", "smbios_untabs", "smbios_Tributes", "smbios_Tigs", "smbios_tenrees", "smbios_ontable", "smbios_temasks", "smbios_entries", "smbios_contabs", "smbios_bables", "smbios_bests", "smbios_contable", "smbios_tipes", "smbios_tubs", "smbios_temests", "smbios_tabs", "smbios_ligs", "smbios_temigs", "smbios_Tras", "smbios_testubs", "smbios_tests", "smbios_lasks", "smbios_entamps", "smbios_ptables", "smbios_lables", "smbios_contables", "smbios_testamps", "smbios_ontees", "smbios_untees", "smbios_tenables"], "smbios_anchor": ["smbios_actor", "smbios_chation", "smbios_cher", "smbios_chorer", "smbios_ancor", "smbios_archor", "smbios_actation", "smbios_minors", "smbios_archuser", "smbios_annors", "smbios_minOR", "smbios_chors", "smbios_ancore", "smbios_annorer", "smbios_gateore", "smbios_adaptors", "smbios_extation", "smbios_anchuser", "smbios_gateors", "smbios_adapter", "smbios_ancorer", "smbios_chore", "smbios_anchOR", "smbios_annore", "smbios_anchorer", "smbios_extors", "smbios_annor", "smbios_ancors", "smbios_archer", "smbios_gateor", "smbios_actore", "smbios_chor", "smbios_minor", "smbios_extore", "smbios_chOR", "smbios_adaptuser", "smbios_adaptor", "smbios_minore", "smbios_extor", "smbios_anchation", "smbios_ancher", "smbios_anchors", "smbios_chuser", "smbios_anchore", "smbios_archors", "smbios_gateOR", "smbios_actors"], "smbios_tables_len": ["smbios_tables_seq", "smbios_tables___lon", "smbios_tables__seq", "smbios_tables__Len", "smbios_tipes_en", "smbios_tributes_Len", "smbios_tablesslen", "smbios_tipes_lon", "smbios_tables_lon", "smbios_tables_length", "smbios_tablesslength", "smbios_tables_en", "smbios_tipes_Len", "smbios_tipes_len", "smbios_tables_rev", "smbios_tables__length", "smbios_tables_el", "smbios_tables__len", "smbios_tributes_length", "smbios_tables___length", "smbios_tables___Len", "smbios_tipes_length", "smbios_tributes_el", "smbios_tablessel", "smbios_tables_Len", "smbios_tributes_len", "smbios_tributes_part", "smbios_tipes_seq", "smbios_tablesspart", "smbios_tributes_rev", "smbios_tables_part", "smbios_tables___len"], "smbios_anchor_len": ["smbios_anchr_len", "smbios_anchr_length", "smbios_anchore_name", "smbios_anchr_lon", "smbios_anchr_Len", "smbios_anchor_val", "smbios_anchor_Len", "smbios_anchore_length", "smbios_anchore_Len", "smbios_anchor_length", "smbios_anchore_len", "smbios_anchor_name", "smbios_anchor_lon", "smbios_anchor_l", "smbios_anchore_val", "smbios_anchore_l"], "numa_fw_cfg": ["numa_FW_cfg", "numa_fw_cgi", "numa_fw_conf", "numa_fw_config", "numa_FW_cgi", "numa_FW_config", "numa_FW_conf"], "i": ["io", "ui", "d", "I", "f", "ci", "t", "y", "u", "r", "it", "p", "ip", "id", "o", "is", "c", "index", "a", "ii", "n", "iu", "v", "l", "x", "ni"], "j": ["jp", "g", "f", "pos", "r", "m", "p", "job", "o", "q", "aj", "J", "ii", "b", "ji", "ij", "n", "len", "v", "z", "uni", "l", "ne", "k"]}}
{"project": "qemu", "commit_id": "b4854f1384176d897747de236f426d020668fa3c", "target": 0, "func": "void do_smm_enter(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    CPUState *cs = CPU(cpu);\n\n    target_ulong sm_state;\n\n    SegmentCache *dt;\n\n    int i, offset;\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"SMM: enter\\n\");\n\n    log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP);\n\n\n\n    env->hflags |= HF_SMM_MASK;\n\n    if (env->hflags2 & HF2_NMI_MASK) {\n\n        env->hflags2 |= HF2_SMM_INSIDE_NMI_MASK;\n\n    } else {\n\n        env->hflags2 |= HF2_NMI_MASK;\n\n    }\n\n    cpu_smm_update(env);\n\n\n\n    sm_state = env->smbase + 0x8000;\n\n\n\n#ifdef TARGET_X86_64\n\n    for (i = 0; i < 6; i++) {\n\n        dt = &env->segs[i];\n\n        offset = 0x7e00 + i * 16;\n\n        x86_stw_phys(cs, sm_state + offset, dt->selector);\n\n        x86_stw_phys(cs, sm_state + offset + 2, (dt->flags >> 8) & 0xf0ff);\n\n        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);\n\n        x86_stq_phys(cs, sm_state + offset + 8, dt->base);\n\n    }\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e64, env->gdt.limit);\n\n\n\n    x86_stw_phys(cs, sm_state + 0x7e70, env->ldt.selector);\n\n    x86_stq_phys(cs, sm_state + 0x7e78, env->ldt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e74, env->ldt.limit);\n\n    x86_stw_phys(cs, sm_state + 0x7e72, (env->ldt.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7e88, env->idt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e84, env->idt.limit);\n\n\n\n    x86_stw_phys(cs, sm_state + 0x7e90, env->tr.selector);\n\n    x86_stq_phys(cs, sm_state + 0x7e98, env->tr.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e94, env->tr.limit);\n\n    x86_stw_phys(cs, sm_state + 0x7e92, (env->tr.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7ed0, env->efer);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7ff8, env->regs[R_EAX]);\n\n    x86_stq_phys(cs, sm_state + 0x7ff0, env->regs[R_ECX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fe8, env->regs[R_EDX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fe0, env->regs[R_EBX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fd8, env->regs[R_ESP]);\n\n    x86_stq_phys(cs, sm_state + 0x7fd0, env->regs[R_EBP]);\n\n    x86_stq_phys(cs, sm_state + 0x7fc8, env->regs[R_ESI]);\n\n    x86_stq_phys(cs, sm_state + 0x7fc0, env->regs[R_EDI]);\n\n    for (i = 8; i < 16; i++) {\n\n        x86_stq_phys(cs, sm_state + 0x7ff8 - i * 8, env->regs[i]);\n\n    }\n\n    x86_stq_phys(cs, sm_state + 0x7f78, env->eip);\n\n    x86_stl_phys(cs, sm_state + 0x7f70, cpu_compute_eflags(env));\n\n    x86_stl_phys(cs, sm_state + 0x7f68, env->dr[6]);\n\n    x86_stl_phys(cs, sm_state + 0x7f60, env->dr[7]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f48, env->cr[4]);\n\n    x86_stq_phys(cs, sm_state + 0x7f50, env->cr[3]);\n\n    x86_stl_phys(cs, sm_state + 0x7f58, env->cr[0]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);\n\n    x86_stl_phys(cs, sm_state + 0x7f00, env->smbase);\n\n#else\n\n    x86_stl_phys(cs, sm_state + 0x7ffc, env->cr[0]);\n\n    x86_stl_phys(cs, sm_state + 0x7ff8, env->cr[3]);\n\n    x86_stl_phys(cs, sm_state + 0x7ff4, cpu_compute_eflags(env));\n\n    x86_stl_phys(cs, sm_state + 0x7ff0, env->eip);\n\n    x86_stl_phys(cs, sm_state + 0x7fec, env->regs[R_EDI]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe8, env->regs[R_ESI]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe4, env->regs[R_EBP]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe0, env->regs[R_ESP]);\n\n    x86_stl_phys(cs, sm_state + 0x7fdc, env->regs[R_EBX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd8, env->regs[R_EDX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd4, env->regs[R_ECX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd0, env->regs[R_EAX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fcc, env->dr[6]);\n\n    x86_stl_phys(cs, sm_state + 0x7fc8, env->dr[7]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7fc4, env->tr.selector);\n\n    x86_stl_phys(cs, sm_state + 0x7f64, env->tr.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f60, env->tr.limit);\n\n    x86_stl_phys(cs, sm_state + 0x7f5c, (env->tr.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7fc0, env->ldt.selector);\n\n    x86_stl_phys(cs, sm_state + 0x7f80, env->ldt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f7c, env->ldt.limit);\n\n    x86_stl_phys(cs, sm_state + 0x7f78, (env->ldt.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f74, env->gdt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f70, env->gdt.limit);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f58, env->idt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f54, env->idt.limit);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        dt = &env->segs[i];\n\n        if (i < 3) {\n\n            offset = 0x7f84 + i * 12;\n\n        } else {\n\n            offset = 0x7f2c + (i - 3) * 12;\n\n        }\n\n        x86_stl_phys(cs, sm_state + 0x7fa8 + i * 4, dt->selector);\n\n        x86_stl_phys(cs, sm_state + offset + 8, dt->base);\n\n        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);\n\n        x86_stl_phys(cs, sm_state + offset, (dt->flags >> 8) & 0xf0ff);\n\n    }\n\n    x86_stl_phys(cs, sm_state + 0x7f14, env->cr[4]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);\n\n    x86_stl_phys(cs, sm_state + 0x7ef8, env->smbase);\n\n#endif\n\n    /* init SMM cpu state */\n\n\n\n#ifdef TARGET_X86_64\n\n    cpu_load_efer(env, 0);\n\n#endif\n\n    cpu_load_eflags(env, 0, ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C |\n\n                              DF_MASK));\n\n    env->eip = 0x00008000;\n\n    cpu_x86_update_cr0(env,\n\n                       env->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK |\n\n                                      CR0_PG_MASK));\n\n    cpu_x86_update_cr4(env, 0);\n\n    env->dr[7] = 0x00000400;\n\n\n\n    cpu_x86_load_seg_cache(env, R_CS, (env->smbase >> 4) & 0xffff, env->smbase,\n\n                           0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n}\n", "idx": 5707, "substitutes": {"cpu": ["cp", "cmp", "bench", "pid", "hw", "cfg", "lb", "chip", "intel", "platform", "pu", "vm", "component", "config", "environment", "nc", "rc", "gpu", "px", "cm", "eu", "num", "server", "pc", "linux", "cli", "net", "np", "cpp", "clock", "dc", "ctx", "kernel", "fp", "jp", "processor", "ec", "boot", "proc", "c", "node", "cn", "core", "lc", "fc", "cache", "loader", "CPU", "conn"], "env": ["energy", "el", "_", "ef", "environment", "inv", "style", "oa", "et", "ace", "gui", "conf", "ev", "code", "all", "her", "here", "den", "func", "bc", "err", "exec", "Environment", "ou", "ec", "output", "g", "engine", "conn", "ass", "ah", "ocr", "extra", "s", "config", "qt", "nc", "eu", "cal", "server", "assets", "iss", "ctx", "ini", "ne", "viron", "doc", "site", "addr", "end", "osc", "eng", "er", "exc", "db", "export", "ext", "org", "py", "cli", "net", "ce", "np", "e", "que", "en", "dev", "global", "het", "core", "cache", "loader", "dict", "fen", "cfg", "anc", "ea", "scope", "enc", "de", "args", "init", "impl", "cb", "context", "req", "eni", "console", "skin", "esm", "cv"], "cs": ["cp", "cmp", "Cs", "ch", "cks", "spec", "ci", "nc", "rc", "cus", "sync", "cells", "sys", "cat", "cing", "js", "ix", "sk", "ns", "ls", "pc", "cc", "bs", "cli", "ce", "tc", "CS", "vs", "sc", "ck", "code", "ks", "ds", "qs", "ctx", "wcs", "bc", "cms", "cb", "ces", "ca", "css", "acks", "gb", "fs", "acs", "c", "ys", "cn", "core", "lc", "cf", "ac", "cache", "vc", "cas", "conn"], "sm_state": ["wp_state", "sm___string", "shappstate", "sm___resource", " sm_size", "sm_store", " sm_string", "sm_context", "sm__config", "sm___shape", "sm_family", "sh_state", "smPvalue", "sm_config", "smkSTATE", "smkfamily", "sm_status", "sm_err", "sm5state", "sm__core", "sb_state", "sm_stat", "sm_STATE", "sm64class", "smPstate", "sm64state", "Sm_model", "Sm_grade", "sh_tag", "smappstate", "sm_model", "sm__stat", "sm_estate", "utm_status", "sm_size", "sm_grade", "si_state", "sm_powered", "shappresource", "sm_value", "SM_state", " sm_value", "sm_shape", "mm_resource", "wp_class", "smkstate", "utm_shape", "SM_core", "shapptag", "sm_tag", "mm_family", "sm_string", "smPstring", "utm_state", " sm_powered", "sm_form", "sb_set", "sm_core", "sb_status", "sm_State", "mm_model", "sm___status", "sh_resource", "wp_store", " sm_context", "utm_resource", "smappform", "smPpowered", "wp_set", "sm_class", "sm_rule", "SM_stat", "Sm_State", "SM_config", "sm___powered", "mm_STATE", "mm_config", "smapptag", "sm___state", " sm_area", "si_resource", "sm64store", "sm5set", "sm__state", "sb_err", "sm5status", "si_estate", "smappresource", "sm5err", "si_rule", "mm_string", "shappform", "smkresource", "sm64set", "sm_set", "Sm_state", "mm_state", "sm_area", "sm___value", "sm_resource", "sh_form"], "dt": ["dr", "tf", "dm", "rt", "gm", "md", "bd", "dn", "di", "dat", "note", "dd", "vt", "bt", "qt", "lt", "pd", "dh", "elt", "wt", "tu", "db", "utt", "tif", "att", "d", "dq", "td", "tick", "kt", "dp", "mt", "tn", "da", "timer", "t", "dc", "tm", "nat", "ds", "ts", "jp", "cb", "cmd", "ee", "ou", "tz", "ut", "DT", "ta", "txt", "gt", "tk", "dl", "tt", "conn", "tc"], "i": ["base", "uni", "gi", "ti", "v", "id", "I", "count", "chi", "di", "s", "ci", "phi", "ji", "ni", "x", "xi", "si", "io", "ri", "abi", "b", "bi", "qi", "ix", "l", "f", "pi", "yi", "adi", "d", "ii", "iu", "j", "it", "ai", "uli", "u", "code", "e", "ami", "udi", "uri", "n", "multi", "mi", "ski", "ini", "ie", "p", "z", "eni", "start", "oi", "c", "ip", "type", "y", "li", "fi", "index", "zi", "ui"], "offset": ["base", "address", "option", "o", "layer", "position", "padding", "origin", "reset", "scroll", "append", "entry", "si", "slice", "shift", "et", "Offset", "phase", "info", "alias", "image", "art", "f", "attr", "ext", "order", "enabled", "ii", "align", "outer", "part", "len", "size", "iterator", "action", "error", "item", "port", "timeout", "fp", "hop", "p", "ptr", "style", "pos", "pointer", "start", "range", "off", "attribute", "api", "iso", "article", "index", "addr", "optional", "ui", "slot"]}}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint8(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx8 : \"%\" PRIu8;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 1994, "substitutes": {"dev": ["serial", "def", "dd", "gr", "mod", "device", "sd", "data", "d", "ver", "sh", "priv", "prof", "de", "grad", "dom", "comp", "Dev", "proc", "err", "dt", "md", "ch", "tr", "w", "private", "self", "attr", "conf", "br", "wd", "rad", "dem", "ev", "iv", "od", "inst", "req", "pro", "debug", "gd"], "prop": ["property", "name", "ctx", "def", "device", "Prop", "data", "prot", "r", "type", "priv", "pb", "op", "tmp", "pos", "proc", "info", "properties", "pointer", "p", "phy", "pr", "pred", "f", "ref", "attr", "obj", "pro", "lit", "val", "root", "pt", "part"], "str": ["test", "arg", "name", "ext", "Str", "spec", "rs", "expr", "data", "r", "strings", "sp", "sl", "cur", "arr", "enc", "hr", "stri", "code", "fr", "err", "cr", "tr", "st", "pr", "br", "text", "ctr", "attr", "obj", "sec", "sr", "s", "val", "pt", "STR"], "ptr": ["dr", "fd", "src", "offset", "inter", "prot", "tty", "r", "loc", "sp", "buf", "py", "pos", "spr", "proc", "fp", "nt", "fr", "err", "tr", "pointer", "func", "st", "pad", "p", "pr", "Ptr", "len", "length", "ref", "br", "t", "inst", "addr", "rt", "val", "pt"], "fmt": ["cnt", "cmt", "Fformat", "ftt", "FMT", "hmt", "cfformat", "fxmt", "Fmd", " fformat", "Fnt", " fmd", "cfmt", "hpr", "fxpr", "fnt", "Fpr", "fmd", "fMT", "Fmt", "cfprintf", "Ftt", "cfMT", "cMT", "hMT", "fpr", "fxtt", "Fprintf", " fMT", "fformat", "cmd", "fxMT", " fnt", "htt"]}}
{"project": "qemu", "commit_id": "6877cff044cdf6da66885eab62363baf98bb39ee", "target": 0, "func": "static int assigned_initfn(struct PCIDevice *pci_dev)\n\n{\n\n    AssignedDevice *dev = DO_UPCAST(AssignedDevice, dev, pci_dev);\n\n    uint8_t e_intx;\n\n    int r;\n\n    Error *local_err = NULL;\n\n\n\n    if (!kvm_enabled()) {\n\n        error_report(\"pci-assign: error: requires KVM support\");\n\n        return -1;\n\n    }\n\n\n\n    if (!dev->host.domain && !dev->host.bus && !dev->host.slot &&\n\n        !dev->host.function) {\n\n        error_report(\"pci-assign: error: no host device specified\");\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * Set up basic config space access control. Will be further refined during\n\n     * device initialization.\n\n     */\n\n    assigned_dev_emulate_config_read(dev, 0, PCI_CONFIG_SPACE_SIZE);\n\n    assigned_dev_direct_config_read(dev, PCI_STATUS, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_REVISION_ID, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_CLASS_PROG, 3);\n\n    assigned_dev_direct_config_read(dev, PCI_CACHE_LINE_SIZE, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_LATENCY_TIMER, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_BIST, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_CARDBUS_CIS, 4);\n\n    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_VENDOR_ID, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_ID, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_CAPABILITY_LIST + 1, 7);\n\n    assigned_dev_direct_config_read(dev, PCI_MIN_GNT, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_MAX_LAT, 1);\n\n    memcpy(dev->emulate_config_write, dev->emulate_config_read,\n\n           sizeof(dev->emulate_config_read));\n\n\n\n    get_real_device(dev, &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    if (assigned_device_pci_cap_init(pci_dev, &local_err) < 0) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    /* intercept MSI-X entry page in the MMIO */\n\n    if (dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {\n\n        assigned_dev_register_msix_mmio(dev, &local_err);\n\n        if (local_err) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    /* handle real device's MMIO/PIO BARs */\n\n    assigned_dev_register_regions(dev->real_device.regions,\n\n                                  dev->real_device.region_number, dev,\n\n                                  &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    /* handle interrupt routing */\n\n    e_intx = dev->dev.config[PCI_INTERRUPT_PIN] - 1;\n\n    dev->intpin = e_intx;\n\n    dev->intx_route.mode = PCI_INTX_DISABLED;\n\n    dev->intx_route.irq = -1;\n\n\n\n    /* assign device to guest */\n\n    r = assign_device(dev);\n\n    if (r < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /* assign legacy INTx to the device */\n\n    r = assign_intx(dev);\n\n    if (r < 0) {\n\n        goto assigned_out;\n\n    }\n\n\n\n    assigned_dev_load_option_rom(dev);\n\n\n\n    add_boot_device_path(dev->bootindex, &pci_dev->qdev, NULL);\n\n\n\n    return 0;\n\n\n\nassigned_out:\n\n    deassign_device(dev);\n\nout:\n\n    free_assigned_device(dev);\n\n    return -1;\n\n}\n", "idx": 16999, "substitutes": {"pci_dev": ["pki2ev", "pci2ev", "pci_ev", "pcli_device", "pki_div", "pki2div", "pci2device", "pki2device", "pki_ev", "pci2div", "pci_div", "pcli_dev", "pki2dev", "pcli_div", "pcli_ev", "pki_dev", "pci2dev", "pki_device", "pci_device"], "dev": ["grad", "spec", "dd", "user", "gd", "comment", "gu", "debug", "result", "gh", "var", "enc", "exec", "d", "ev", "config", "prof", "ov", "p", "od", "h", "boot", "serial", "end", "valid", "die", "ve", "conn", "Dev", "mod", "pub", "engine", "de", "rad", "devices", "app", "nov", "wd", "develop", "development", "self", "hw", "vol", "adv", "v", "dom", "dis", "off", "ver", "dc", "err", "f", "block", "root", "this", "di", "model", "prom", "home", "host", "compl", "w", "ad", "device", "inst", "dem", "priv", "pro", "bug", "ch", "data", "info", "conf", "g", "module", "ow", "def", "cam", "client", "req", "cmd", "driver", "error", "DEV", "diff"], "e_intx": ["e_id32", "e_ind32", "e_intX", "e_idX", "e_indx", "e_idx", "e_int32", "e_ntX", "e_indX", "e_nt32", "e_ntx"], "r": ["ror", "m", "s", "rs", "f", "err", "rc", "n", "R", "trace", "or", "ptr", "ry", "l", "d", "w", "e", "lr", "cr", "c", "p", "error", "h", "a", "Error"], "local_err": ["remote_exc", "local_", " local\n", "Local\n", "local2err", "local2error", "local\n", "remote_err", "global\n", " local_", "local2rr", "local2exc", "local_exc", "remote_rr", "Local_", "remote_error", "global_", "local_error", "local_rr"]}}
{"project": "qemu", "commit_id": "459db780be10f7adac723a5d3a4ffeac8ae6e768", "target": 1, "func": "envlist_parse(envlist_t *envlist, const char *env,\n\n    int (*callback)(envlist_t *, const char *))\n\n{\n\n\tchar *tmpenv, *envvar;\n\n\tchar *envsave = NULL;\n\n\n\n\tassert(callback != NULL);\n\n\n\n\tif ((envlist == NULL) || (env == NULL))\n\n\t\treturn (EINVAL);\n\n\n\n\t/*\n\n\t * We need to make temporary copy of the env string\n\n\t * as strtok_r(3) modifies it while it tokenizes.\n\n\t */\n\n\tif ((tmpenv = strdup(env)) == NULL)\n\n\t\treturn (errno);\n\n\n\n\tenvvar = strtok_r(tmpenv, \",\", &envsave);\n\n\twhile (envvar != NULL) {\n\n\t\tif ((*callback)(envlist, envvar) != 0) {\n\n\t\t\tfree(tmpenv);\n\n\t\t\treturn (errno);\n\n\t\t}\n\n\t\tenvvar = strtok_r(NULL, \",\", &envsave);\n\n\t}\n\n\n\n\tfree(tmpenv);\n\n\treturn (0);\n\n}\n", "idx": 11524, "substitutes": {"tmpenv": [" tmpen", "nowenv", "tmpen", "tmpv", " tmpv", "fakeenc", "tempconfig", "tmpenvironment", "testenv", "testconfig", "ntenv", " tmpenc", "ntenvironment", "tmpenc", "fakeen", "testenvironment", "tempviron", "ntviron", "fakeenvironment", " tmpconfig", "tempen", "tempenc", "tempenvironment", "nowenvironment", "testv", " tmpviron", "nowviron", " tmpenvironment", "tempenv", "fakeenv", "tmpconfig", "tmpviron", "tempv"], "envvar": ["encvar", "environmentname", "senconst", "environmentVar", "environmentver", "environmentlist", "encVar", " envVar", "envlist", "environmentvar", "encvari", "envcat", "evvari", "environmentcat", " envstack", " envname", "enbar", "evVar", "enccat", "envconst", "evname", "envbar", "envver", " envbar", "environmentconst", "envname", "environmentstack", "envvari", "envstack", "envVar", " envvari", " envlist", " envcat", " envconst", "enlist", "environmentvari", "senlist", "evvar", " envver", "encver", "senvar", "envar", "environmentbar", "enstack"], "envsave": ["enstsaved", "ennsave", " ensssave", " enssaved", "elstsaving", "enversaving", "envsource", "enssave", "encsave", "elstsaved", "envssave", " envssave", " enversaving", "ensssave", "envsaves", "elvsaved", "elstsave", "envalsave", "envsaving", "encsaves", " envsaver", " envsaves", "encssave", "elvsaving", " enversaves", "ennssave", "envaving", "envource", "elstsource", "enversave", " enversave", "enstsaving", " enversaver", "ennsaves", "ennsaving", "enversaves", " envsaved", "elvsave", "elvsource", "ennsaver", "envaved", "envalsaves", " enssaves", "envsaver", "enstsave", "encsaved", " envsaving", "envalsaver", "enstsource", "envalsaving", "envsaved", " enssave", "enssaves", "ennsaved", "envave", "enversaver", "enssaved", "ennsource"]}}
{"project": "qemu", "commit_id": "37f51384ae05bd50f83308339dbffa3e78404874", "target": 0, "func": "static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus,\n\n                                   uint8_t devfn, hwaddr addr, bool is_write,\n\n                                   IOMMUTLBEntry *entry)\n\n{\n\n    IntelIOMMUState *s = vtd_as->iommu_state;\n\n    VTDContextEntry ce;\n\n    uint8_t bus_num = pci_bus_num(bus);\n\n    VTDContextCacheEntry *cc_entry = &vtd_as->context_cache_entry;\n\n    uint64_t slpte, page_mask;\n\n    uint32_t level;\n\n    uint16_t source_id = vtd_make_source_id(bus_num, devfn);\n\n    int ret_fr;\n\n    bool is_fpd_set = false;\n\n    bool reads = true;\n\n    bool writes = true;\n\n    uint8_t access_flags;\n\n    VTDIOTLBEntry *iotlb_entry;\n\n\n\n    /*\n\n     * We have standalone memory region for interrupt addresses, we\n\n     * should never receive translation requests in this region.\n\n     */\n\n    assert(!vtd_is_interrupt_addr(addr));\n\n\n\n    /* Try to fetch slpte form IOTLB */\n\n    iotlb_entry = vtd_lookup_iotlb(s, source_id, addr);\n\n    if (iotlb_entry) {\n\n        trace_vtd_iotlb_page_hit(source_id, addr, iotlb_entry->slpte,\n\n                                 iotlb_entry->domain_id);\n\n        slpte = iotlb_entry->slpte;\n\n        access_flags = iotlb_entry->access_flags;\n\n        page_mask = iotlb_entry->mask;\n\n        goto out;\n\n    }\n\n\n\n    /* Try to fetch context-entry from cache first */\n\n    if (cc_entry->context_cache_gen == s->context_cache_gen) {\n\n        trace_vtd_iotlb_cc_hit(bus_num, devfn, cc_entry->context_entry.hi,\n\n                               cc_entry->context_entry.lo,\n\n                               cc_entry->context_cache_gen);\n\n        ce = cc_entry->context_entry;\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n    } else {\n\n        ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce);\n\n        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;\n\n        if (ret_fr) {\n\n            ret_fr = -ret_fr;\n\n            if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n                trace_vtd_fault_disabled();\n\n            } else {\n\n                vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n            }\n\n            goto error;\n\n        }\n\n        /* Update context-cache */\n\n        trace_vtd_iotlb_cc_update(bus_num, devfn, ce.hi, ce.lo,\n\n                                  cc_entry->context_cache_gen,\n\n                                  s->context_cache_gen);\n\n        cc_entry->context_entry = ce;\n\n        cc_entry->context_cache_gen = s->context_cache_gen;\n\n    }\n\n\n\n    /*\n\n     * We don't need to translate for pass-through context entries.\n\n     * Also, let's ignore IOTLB caching as well for PT devices.\n\n     */\n\n    if (vtd_ce_get_type(&ce) == VTD_CONTEXT_TT_PASS_THROUGH) {\n\n        entry->iova = addr & VTD_PAGE_MASK_4K;\n\n        entry->translated_addr = entry->iova;\n\n        entry->addr_mask = ~VTD_PAGE_MASK_4K;\n\n        entry->perm = IOMMU_RW;\n\n        trace_vtd_translate_pt(source_id, entry->iova);\n\n\n\n        /*\n\n         * When this happens, it means firstly caching-mode is not\n\n         * enabled, and this is the first passthrough translation for\n\n         * the device. Let's enable the fast path for passthrough.\n\n         *\n\n         * When passthrough is disabled again for the device, we can\n\n         * capture it via the context entry invalidation, then the\n\n         * IOMMU region can be swapped back.\n\n         */\n\n        vtd_pt_enable_fast_path(s, source_id);\n\n\n\n        return true;\n\n    }\n\n\n\n    ret_fr = vtd_iova_to_slpte(&ce, addr, is_write, &slpte, &level,\n\n                               &reads, &writes);\n\n    if (ret_fr) {\n\n        ret_fr = -ret_fr;\n\n        if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {\n\n            trace_vtd_fault_disabled();\n\n        } else {\n\n            vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);\n\n        }\n\n        goto error;\n\n    }\n\n\n\n    page_mask = vtd_slpt_level_page_mask(level);\n\n    access_flags = IOMMU_ACCESS_FLAG(reads, writes);\n\n    vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, slpte,\n\n                     access_flags, level);\n\nout:\n\n    entry->iova = addr & page_mask;\n\n    entry->translated_addr = vtd_get_slpte_addr(slpte) & page_mask;\n\n    entry->addr_mask = ~page_mask;\n\n    entry->perm = access_flags;\n\n    return true;\n\n\n\nerror:\n\n    entry->iova = 0;\n\n    entry->translated_addr = 0;\n\n    entry->addr_mask = 0;\n\n    entry->perm = IOMMU_NONE;\n\n    return false;\n\n}\n", "idx": 8949, "substitutes": {"vtd_as": ["vdd_master", "vtd2AS", "vtd_session", "vdd2AS", "vtdokas", "vtdappasu", "vtdoksession", "vpd__as", "vdd2as", "vtd_AS", "vtdappras", "vpd_asu", "vTD__in", "vpd__ras", "vTD__is", "vtdokmaster", "vtd2as", "vTD_as", "vdd2session", "vtdappas", "vtd__master", "vtdokAS", "vtd_ras", "vtd2master", "vTD_ras", "vtdappis", "vdd_session", "vtd__as", "vpd_as", "vTD__as", "vdd_as", "vtd__AS", "vtd2session", "vTD__ras", "vdd2master", "vpd_ras", "vpd_is", "vpd__is", "vdd_AS", "vtd_master", "vtd__asu", "vtd__in", "vtd__ras", "vtd_asu", "vTD_in", "vtd_in", "vTD_is", "vpd__asu", "vtd__is", "vtd_is", "vtd__session"], "bus": ["boot", "base", "nt", "board", "http", "mount", "uss", "buf", "bridge", "service", "config", "uri", "used", "driver", "ux", "us", "BUS", "serial", "bc", "os", "host", "Bus", "sync", "name", "state", "address", "port", "usb", "plugin", "lock", "loop", "use", "cache", "proc", "drive"], "devfn": [" devln", "devname", " devfun", "diffdn", "diffkn", "diskfp", "diffn", "devicefp", "evfun", "bugn", "divfun", "devfun", "devkn", "divn", "divdn", "diskname", "evdn", "bugfun", "devln", "switchn", " devkn", "evfn", "domfp", "evname", "switchfp", "evn", "difffn", "diskfun", "switchln", "devicefn", "evkn", "diskfn", "evfp", "devdn", " devn", "devfp", " devfp", "devicename", "bugdn", " devdn", "domln", "devn", "divfn", "domn", "bugfn", "devicefun", "switchfn", "domfn"], "addr": ["mac", "adr", "area", "arr", "base", "ack", "len", "val", "id", "info", "conn", "rr", "b", "x", "bridge", "ad", "ref", "config", "uri", "ace", "server", "attr", "afi", "rss", "amd", "ag", "ptr", "act", "rs", "loc", "ac", "dr", "host", "rt", "ha", "route", "amp", "oa", "name", "sta", "rc", "md", "address", "kt", "dd", "nr", "part", "dc", "offset", "hop", "node", "asm", "eth", "vr", "layer", "pos", "rx", "ip", "url", "ann", "pkg", "wd", "adder"], "is_write": ["is__writing", "in_written", "in_write", "is_read", "in_writing", "in_read", "is2write", "is__read", "is2written", "is_writing", "is2read", "is__write", "is_written", "is2writing", "is__written"], "entry": ["ee", "session", "je", "Entry", "enter", "ry", "record", "ent", "service", "data", "server", "e", "ace", "ie", "rc", "ries", "event", "address", "ident", "spec", "row", "ge", "import", "ant", "insert", "cell"], "s": ["session", "sg", "ts", "ks", "is", "si", "g", "source", "stats", "m", "http", "b", "t", "ops", "i", "gs", "service", "c", "sa", "p", "server", "e", "parts", "ins", "request", "sq", "us", "js", "f", "os", "cs", "o", "S", "es", "sync", "space", "south", "state", "services", "sl", "r", "bis", "ns", "storage", "sb", "sis", "spec", "this", "sys", "self", "ses", "ps", "site", "a", "ss", "settings", "ssl", "sc"], "ce": ["le", "ve", "ance", "ace", "cc", "ie", " je", "code", " exce", "cur", "cal", "cle", "ca", "let", "gu", "ide", "ee", "c", "ct", "component", "se", "e", "ate", "cf", "pe", "ze", "ense", "ice", "che", " CE", " ent", "ke", "cast", "ced", "cel", "ant", "ge", "ine", "cell", "he", " ke", "CE", "cer", " ge", "cu", "ue", "dr", "cs", "ae", "catch", "edge", " ace", "ces", "cat", "use", "co", " pe", " ne", "ne", "oe", "SE", "ade", "see", " ie", "cue", "coe", "client", "ci", "force", "fe", "cy", "te"], "cc_entry": ["cc_rance", "cc_enter", "cn_enter", "ccappentry", "ccallentry", "cf_enter", "cc_element", "ccappenter", "cf_start", "rc_server", "CC_entry", "cc___inc", "ccappresult", "ccapparchive", "cf_entry", "cc_server", "cc_start", "CC_enter", "cn_event", "cc_event", "ccappelement", "ccallresult", "CC_import", "ctx_import", "CC_archive", "cnallenter", "cc_archive", "rc_path", "cc_import", " cc_inc", "cc_path", "cnallentry", "cnallevent", "cn_result", "cc_index", "ctx_reader", "cc_inc", "cf_element", "cc___path", "ctx_element", "cc___server", "ccallevent", "cnallresult", "ccallenter", " cc_index", "ccappevent", "ccappstart", " cc_rance", "cc___entry", "ccappimport", "cc_result", "cn_entry", "rc_inc", "cc_reader", "rc_entry", "ctx_entry"], "slpte": ["celptes", "celppn", "slppn", "slportd", " slntype", " slpta", "slntf", " slnta", "slptes", "slpointa", "slportey", "slupte", "celppes", "slpetes", "islpetec", "sliptec", "nlptec", "slnte", "celppe", "slpete", "nlptd", "slintes", "nlptey", "islptea", "sliptey", "slinte", "slppf", "slppes", "nlupte", "slptey", "slptf", "islpete", "slppe", "slntype", "slpetie", "celpppe", "slpointype", "slppec", " slnte", "slppea", "slporte", "slptn", "slftie", "nluptec", "nlpte", "slfte", "slptea", "celptpe", "slpetn", "slftea", "slintpe", "islpetea", "islpte", "sliptd", "slptec", "sluptd", "slpta", "islpetie", "slpetpe", "slppa", "slpetea", "celptn", "slptie", "slpppe", "sluptey", "slnta", "slptd", "slintn", "islptie", "slptype", "slppie", " slptf", "slppype", "slipte", " slntf", " slptype", "sluptec", "slpetec", "nluptd", "nluptey", "celpte", "slftec", "slportec", "slpointe", "slptpe", "islptec", "slpointf"], "page_mask": ["page_limit", "page___max", "page_flags", "page_ask", " page_length", " page_flags", " page_ask", "page___length", "page___mask", "page___limit", " page_limit", "page___flags", "page_max", "page_length", "page___ask", " page_max"], "level": ["parent", "zip", "pass", "base", "delay", "scale", "low", "lvl", "limit", "local", "loc", "mode", "priority", "code", "index", "scope", "inc", "levels", "lev", "bit", "type", "layer", "loop", "weight", "depth", "pattern", "vel"], "ret_fr": ["Ret_fr", "x", "ctr", "retregtr", "ret24br", "retregfr", "retregwrite", "ret_tr", " ret_pr", "Ret_br", "_", "retregdr", "ret24fr", "ret_pull", " ret_frac", "r", "Ret_write", "ret_dr", "this", "ret24pull", "Ret_pull", "g", " ret_dr", "d", "ret_write", "ret_frac", "ret_pr", "Ret_tr", "ret_cache", " ret_tr", "Ret_dr", " ret_cache", "write", "ret_br"], "access_flags": ["access___rights", "access_rules", "access_limits", " access_mask", "accessalflags", "accessslimits", "access___count", " access_bits", "access_parts", "access_mask", "access_flag", " access_rules", "accesssflags", "accessalmask", "access___flags", "access_rights", "access___bits", "accesssparts", " access_count", " access_flag", " access_parts", "accesssmask", "accessallimits", " access_limits", "access_bits", "accessalparts", " access_rights", "access_count"], "iotlb_entry": ["iotb_ry", "iotlb_post", "iotbl_post", "iotlb_try", "iotbl__entry", "iotzb_see", "iotla_enter", "iotzb_entry", "iotlb00ent", "iotbl_entry", "iotlbappcell", "iotlab_inc", "iotlb_enter", "iotbl_import", "iotlbapppost", "iotlb_ry", "iotb_way", "iotb_element", "iotlab_enter", "iotlab_ent", "iotml_entry", "iotlb_id", "iotla_server", "iotlb_index", "iotbl__import", "iotlb_view", "iotlb__entry", "iotlb_reader", "iotlb_element", "iotlb00view", "iotml_reader", "iotlb_server", "iotbl__post", "iotlb_way", "iotlb_exit", "iotlb_see", "iotlab_try", "iotlb__post", "iotb_entry", "iotla_index", "iotlab_exit", "iotbl_cell", "iotzb_id", "iotlab_entry", "iotla_entry", "iotlb00enter", "iotlb_inc", "iotlb__cell", "iotlb_cell", "iotml_exit", "iotlbappentry", "iotlb__import", "iotlb00entry", "iotlb_import", "iotlb_ent", "iotbl__cell", "iotlbappimport", "iotlab_view"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_array_comma(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"[32,\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 19650, "substitutes": {"obj": ["ns", "ab", "j", "bs", "code", "data", "bj", "ob", "alt", "nt", "adj", "n", "str", "sb", "oa", "src", "node", "ops", "ctx", "pos", "ass", "nb", "act", "object", "o", "po", "arr", "val", "args", "elt", "js", "cat", "tmp", "rb", "lib", "od", "Object", "az", "os", "pt", "Obj", "amp"]}}
{"project": "FFmpeg", "commit_id": "808c10e728db2d92ccbb0f8b3bcd4a2f4305a2cf", "target": 0, "func": "static void format_line(void *ptr, int level, const char *fmt, va_list vl,\n\n                        AVBPrint part[3], int *print_prefix, int type[2])\n\n{\n\n    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;\n\n    av_bprint_init(part+0, 0, 1);\n\n    av_bprint_init(part+1, 0, 1);\n\n    av_bprint_init(part+2, 0, 65536);\n\n\n\n    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;\n\n    if (*print_prefix && avc) {\n\n        if (avc->parent_log_context_offset) {\n\n            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +\n\n                                   avc->parent_log_context_offset);\n\n            if (parent && *parent) {\n\n                av_bprintf(part+0, \"[%s @ %p] \",\n\n                         (*parent)->item_name(parent), parent);\n\n                if(type) type[0] = get_category(parent);\n\n            }\n\n        }\n\n        av_bprintf(part+1, \"[%s @ %p] \",\n\n                 avc->item_name(ptr), ptr);\n\n        if(type) type[1] = get_category(ptr);\n\n    }\n\n\n\n    av_vbprintf(part+2, fmt, vl);\n\n\n\n    if(*part[0].str || *part[1].str || *part[2].str) {\n\n        char lastc = part[2].len ? part[2].str[part[2].len - 1] : 0;\n\n        *print_prefix = lastc == '\\n' || lastc == '\\r';\n\n    }\n\n}\n", "idx": 22086, "substitutes": {"ptr": ["uint", "class", "pad", "pc", "buffer", "pos", "alloc", "r", "slave", "address", "cp", "later", "fr", "peer", "src", "slice", "br", "proc", "nt", "pointer", "fi", "primary", "attr", "inter", "str", "jp", "push", "mount", "ctr", "eth", "private", "fp", "code", "ext", "desc", "dll", "eger", "pair", "typ", "offset", "remote", "ref", "adr", "thread", " pointer", "p", "nil", "ace", "point", "addr", "comp", "tmp", "inst", "length", "fd", "trace", "reference", "tty", "Ptr", "pty", "h", "porter", "port", "kind", "tr", "transfer", "dr", "ctx", "touch", "tip", "pt"], "level": ["col", "kind", "scale", "mode", "style", "ln", "temp", "cl", "layer", "Level", "vel", "unit", "point", "depth", "levels", "line", "lvl", "length", "loc", "len", "stage", "lf", "lang", "scope", "base", "count", "letter"], "fmt": [" flt", "vret", " filt", "vformat", "Flt", " fformat", "Fnt", "hnt", "filt", "hformat", "Fret", "fret", "fformat", " fnt", "Fformat", "fnt", " fret", "vlt", "hmt", "Fmt", "hilt", "Filt", "flt", "vmt"], "vl": [" l", "lc", "lp", "lv", "ml", "iv", "bb", "ol", "ln", "mt", "ld", "buffer", "split", "nl", "lan", " ls", "wl", "kl", "ls", "var", "el", "pl", " lvl", "lvl", "vol", "ure", "fl", "icle", "vv", "len", "ll", "nb", " LP", "v", "tl", "lf", "erv", "l", "vc"], "part": ["step", "class", "half", "key", "connection", "pad", "no", "pos", "order", "info", "front", "bit", "data", "list", "work", "sector", "line", "division", "PART", "from", "old", "instance", "format", "but", "member", "name", "phase", "only", "object", "item", "split", "pre", "state", "component", "unit", "year", "detail", "self", "add", "try", "element", "pair", "position", "offset", "result", "time", "Part", "function", "layer", "one", "section", "patch", "p", "or", "point", "comment", "day", "parts", "error", "partial", "page", "stage", "group", "pty", "count", "span", "start", "argument", "and", "obj", "cond", "product", "art", "entry", "diff", "id", "change", "word", "ch", "block", "pt", "base"], "print_prefix": ["print__format", "logableformat", "printablefix", "printableformat", "log_format", "log_fix", "logablegap", "print__fix", "printlogname", "print_fix", " print_format", "printlogtoken", "print_offset", "printablegap", "write_token", "log_prefix", "print_gap", "logablefix", "printableprefix", "printlogprefix", "printlogoffset", "print_token", "log_gap", "print_format", "logableprefix", "write_prefix", " print_fix", "printlogformat", "printlogfix", "print_name", "print__prefix", "print__gap", "printloggap", "write_offset", "write_name"], "type": ["class", "target", "val", "pe", "post", "key", "TYPE", "ty", "sys", "y", "order", "info", "other", "cat", "list", "link", "var", "line", "rule", "attr", "format", "Type", "name", "cross", "object", "option", "ping", "style", "op", "pre", "unit", "code", "year", "typ", "like", "ref", "time", "function", "layer", "model", "t", "size", "p", "or", "point", "number", "comment", "pr", "ver", "error", "call", "length", "user", "group", "resource", "x", "count", "status", "span", "port", "types", "rel", "at", "id", "py", "tag", "index", "match", "in", "ype", "block", "all", "base", "where", "value"], "avc": ["avcs", "avect", "avl", "Avcs", "avec", " avlc", "ajb", "AvC", " avcu", " avac", "avb", "avct", "avecs", "afct", "avf", "afcs", "ajc", "avac", "avlc", "afcu", "Avf", " avl", "avelc", "aff", "Avcu", "avcu", "Avc", " avC", "avC", "Avb", "auc", "aveac", "ajC", "aulc", "aul", " avb", "afac", "ajf", "afc", " avf", " avcs", "avel", "aflc", "auct", "afl"], "parent": ["author", "class", "target", "none", "pe", "key", "connection", "temp", "pc", "path", "fat", "parents", "other", "pool", "family", "pid", "test", "pointer", "cot", "instance", "gap", "col", "name", "conn", "option", "g", "coll", "null", "file", "anc", "term", "op", "master", "ac", "component", "current", "unit", "o", "c", "self", "channel", "child", "offset", "pa", "remote", "public", "ref", "result", "layer", "per", "size", "p", "or", "point", "mother", "pr", "comp", "loc", "owner", "reference", "children", "api", "tax", "paren", "port", "and", "Parent", "anch", "cache", "rel", "common", "father", "id", "ctx", "source", "root", "pt"]}}
{"project": "qemu", "commit_id": "3d6f761713745dfed7d2ccfe98077d213a6a6eba", "target": 0, "func": "static void arm_cpu_do_interrupt_aarch64(CPUState *cs)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    unsigned int new_el = env->exception.target_el;\n\n    target_ulong addr = env->cp15.vbar_el[new_el];\n\n    unsigned int new_mode = aarch64_pstate_mode(new_el, true);\n\n\n\n    if (arm_current_el(env) < new_el) {\n\n        if (env->aarch64) {\n\n            addr += 0x400;\n\n        } else {\n\n            addr += 0x600;\n\n        }\n\n    } else if (pstate_read(env) & PSTATE_SP) {\n\n        addr += 0x200;\n\n    }\n\n\n\n    switch (cs->exception_index) {\n\n    case EXCP_PREFETCH_ABORT:\n\n    case EXCP_DATA_ABORT:\n\n        env->cp15.far_el[new_el] = env->exception.vaddress;\n\n        qemu_log_mask(CPU_LOG_INT, \"...with FAR 0x%\" PRIx64 \"\\n\",\n\n                      env->cp15.far_el[new_el]);\n\n        /* fall through */\n\n    case EXCP_BKPT:\n\n    case EXCP_UDEF:\n\n    case EXCP_SWI:\n\n    case EXCP_HVC:\n\n    case EXCP_HYP_TRAP:\n\n    case EXCP_SMC:\n\n        env->cp15.esr_el[new_el] = env->exception.syndrome;\n\n        break;\n\n    case EXCP_IRQ:\n\n    case EXCP_VIRQ:\n\n        addr += 0x80;\n\n        break;\n\n    case EXCP_FIQ:\n\n    case EXCP_VFIQ:\n\n        addr += 0x100;\n\n        break;\n\n    case EXCP_SEMIHOST:\n\n        qemu_log_mask(CPU_LOG_INT,\n\n                      \"...handling as semihosting call 0x%\" PRIx64 \"\\n\",\n\n                      env->xregs[0]);\n\n        env->xregs[0] = do_arm_semihosting(env);\n\n        return;\n\n    default:\n\n        cpu_abort(cs, \"Unhandled exception 0x%x\\n\", cs->exception_index);\n\n    }\n\n\n\n    if (is_a64(env)) {\n\n        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = pstate_read(env);\n\n        aarch64_save_sp(env, arm_current_el(env));\n\n        env->elr_el[new_el] = env->pc;\n\n    } else {\n\n        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = cpsr_read(env);\n\n        if (!env->thumb) {\n\n            env->cp15.esr_el[new_el] |= 1 << 25;\n\n        }\n\n        env->elr_el[new_el] = env->regs[15];\n\n\n\n        aarch64_sync_32_to_64(env);\n\n\n\n        env->condexec_bits = 0;\n\n    }\n\n    qemu_log_mask(CPU_LOG_INT, \"...with ELR 0x%\" PRIx64 \"\\n\",\n\n                  env->elr_el[new_el]);\n\n\n\n    pstate_write(env, PSTATE_DAIF | new_mode);\n\n    env->aarch64 = 1;\n\n    aarch64_restore_sp(env, new_el);\n\n\n\n    env->pc = addr;\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"...to EL%d PC 0x%\" PRIx64 \" PSTATE 0x%x\\n\",\n\n                  new_el, env->pc, pstate_read(env));\n\n}\n", "idx": 17699, "substitutes": {"cs": ["pc", "ns", "spec", "s", "rs", "ras", "cus", "vc", "ix", "conn", "rc", "cf", "Cs", "cp", "CS", "bc", "ls", "ocr", "ctx", "ss", "wcs", "fs", "cons", "cas", "enc", "sk", "css", "acs", "ce", "args", "ci", "qs", "sc", "ics", "vs", "codes", "ses", "cli", "lc", "c", "sync", "js", "ck", "pec", "ks", "cache", "ec", "sys", "cn", "cc", "ds"], "cpu": ["pc", "dc", "cal", "core", "coe", "component", "cm", "cf", "cpp", "anc", "cp", "bc", "ctx", "fc", "en", "bench", "vm", "nc", "gpu", "CPU", "sc", "processor", "cli", "lc", "c", "ea", "cache", "cmp", "intel", "ec", "clock", "boot", "cn", "pu", "eni", "np", "cow", "cv", "conn"], "env": ["viron", "cfg", "extra", "forge", "cf", "anc", "gui", "environment", "console", "fen", "energy", "enc", "vm", "equ", "exec", "kn", "config", "ev", "qt", "cli", "ea", "output", "end", "cv", "conn", "enable", "init", "cal", "eve", "eye", "eu", "engine", "ne", " environment", "bc", "qv", "erv", "dt", "scope", "eng", "pect", "ench", "exe", "v", "nw", "stage", "ec", "export", "org", "core", "err", "estate", "net", "icer", "cb", "inet", "network", "vs", "csv", "c", "ace", "cn", "er", "edge", "eni", "np", "Environment", "esi", "session", "db", "global", "conf", "skin", "exc", "loader", "oa", "ctx", "ext", "en", "her", "context", "ce", "nc", "event", "args", "site", "e", "esm", "req", "osc", "cache", "que", "agent", "server", "el"]}}
{"project": "qemu", "commit_id": "e514fc7e1231c6d95011e448e6c626f2bb6f3cd8", "target": 0, "func": "e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,\n\n                             const E1000E_RxRing *rxr,\n\n                             const E1000E_RSSInfo *rss_info)\n\n{\n\n    PCIDevice *d = core->owner;\n\n    dma_addr_t base;\n\n    uint8_t desc[E1000_MAX_RX_DESC_LEN];\n\n    size_t desc_size;\n\n    size_t desc_offset = 0;\n\n    size_t iov_ofs = 0;\n\n\n\n    struct iovec *iov = net_rx_pkt_get_iovec(pkt);\n\n    size_t size = net_rx_pkt_get_total_len(pkt);\n\n    size_t total_size = size + e1000x_fcs_len(core->mac);\n\n    const E1000E_RingInfo *rxi;\n\n    size_t ps_hdr_len = 0;\n\n    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);\n\n\n\n    rxi = rxr->i;\n\n\n\n    do {\n\n        hwaddr ba[MAX_PS_BUFFERS];\n\n        e1000e_ba_state bastate = { { 0 } };\n\n        bool is_last = false;\n\n        bool is_first = true;\n\n\n\n        desc_size = total_size - desc_offset;\n\n\n\n        if (desc_size > core->rx_desc_buf_size) {\n\n            desc_size = core->rx_desc_buf_size;\n\n        }\n\n\n\n        base = e1000e_ring_head_descr(core, rxi);\n\n\n\n        pci_dma_read(d, base, &desc, core->rx_desc_len);\n\n\n\n        trace_e1000e_rx_descr(rxi->idx, base, core->rx_desc_len);\n\n\n\n        e1000e_read_rx_descr(core, desc, &ba);\n\n\n\n        if (ba[0]) {\n\n            if (desc_offset < size) {\n\n                static const uint32_t fcs_pad;\n\n                size_t iov_copy;\n\n                size_t copy_size = size - desc_offset;\n\n                if (copy_size > core->rx_desc_buf_size) {\n\n                    copy_size = core->rx_desc_buf_size;\n\n                }\n\n\n\n                /* For PS mode copy the packet header first */\n\n                if (do_ps) {\n\n                    if (is_first) {\n\n                        size_t ps_hdr_copied = 0;\n\n                        do {\n\n                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,\n\n                                           iov->iov_len - iov_ofs);\n\n\n\n                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n\n                                                      iov->iov_base, iov_copy);\n\n\n\n                            copy_size -= iov_copy;\n\n                            ps_hdr_copied += iov_copy;\n\n\n\n                            iov_ofs += iov_copy;\n\n                            if (iov_ofs == iov->iov_len) {\n\n                                iov++;\n\n                                iov_ofs = 0;\n\n                            }\n\n                        } while (ps_hdr_copied < ps_hdr_len);\n\n\n\n                        is_first = false;\n\n                    } else {\n\n                        /* Leave buffer 0 of each descriptor except first */\n\n                        /* empty as per spec 7.1.5.1                      */\n\n                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n\n                                                       NULL, 0);\n\n                    }\n\n                }\n\n\n\n                /* Copy packet payload */\n\n                while (copy_size) {\n\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n\n                                            iov->iov_base + iov_ofs, iov_copy);\n\n\n\n                    copy_size -= iov_copy;\n\n                    iov_ofs += iov_copy;\n\n                    if (iov_ofs == iov->iov_len) {\n\n                        iov++;\n\n                        iov_ofs = 0;\n\n                    }\n\n                }\n\n\n\n                if (desc_offset + desc_size >= total_size) {\n\n                    /* Simulate FCS checksum presence in the last descriptor */\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n\n                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));\n\n                }\n\n            }\n\n            desc_offset += desc_size;\n\n            if (desc_offset >= total_size) {\n\n                is_last = true;\n\n            }\n\n        } else { /* as per intel docs; skip descriptors with null buf addr */\n\n            trace_e1000e_rx_null_descriptor();\n\n        }\n\n\n\n        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,\n\n                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);\n\n        pci_dma_write(d, base, &desc, core->rx_desc_len);\n\n\n\n        e1000e_ring_advance(core, rxi,\n\n                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);\n\n\n\n    } while (desc_offset < total_size);\n\n\n\n    e1000e_update_rx_stats(core, size, total_size);\n\n}\n", "idx": 17314, "substitutes": {"d": ["dc", "board", "dn", "dd", "db", "s", "t", "data", "core", "gd", "f", "component", "pd", "cm", "dh", "dos", "g", "ide", "dl", "ind", "ci", "w", "bd", "dm", "ad", "e", "id", "client", "sync", "c", "dom", "D", "da", "p", "ded", "b", "dat", "cd", "dad", "conn", "ds"], "base": ["dc", "na", "bi", "bin", "scale", "extra", "db", "bat", "data", "info", "core", "name", "bit", "Base", "buffer", "hide", "full", "i", "root", "master", "type", "bc", "index", "byte", "def", "create", "bid", "ca", "home", "store", "bar", "size", "bf", "kit", "pre", "bu", "last", "prefix", "id", "pa", "bas", "buf", "bot", "ka", "unit", "c", "meta", "p", "da", "address", "area", "bre", "cache", "b", "la", "beta", "ase", "api", "ha", "end", "server", "se"], "desc": ["dc", "ros", "code", "info", "esc", "name", "ctr", "dir", " description", "dest", "rc", "anc", "bc", "src", "loc", "ext", "des", "sec", "def", "description", "ca", "design", "rec", "disc", "aux", "rib", "sub", "config", "sc", "buf", "comb", "req", "seq", "meta", "uc", "Desc", "doc", "dist", "beta", "decl", "asc"], "desc_size": ["description_size", "descetunit", "descaclen", "descacbody", "doc_len", "description_offset", "doc_size", "sub_unit", "doc_body", "descetscale", "desc_unit", "desc_offset", "description_loc", "doc_offset", "descetclean", "sub_clean", "descacsize", "sub_size", "desc_len", " desc_len", "desc_body", "desc_loc", "descetsize", "desc_clean", " desc_offset", "desc_num", "sub_scale", "description_len", "descacoffset", "desc_scale", " desc_num"], "iov": ["ei", "irc", "io", "dq", "ii", "iop", "ctx", "iu", "iol", "abc", "pai", "rob", "nr", "ahi", "uga", "igi", "ru", "ci", "vre", "gra", "mx", "rb", "odi", "ia", "uno", "fi", "ilo", "ib", "mu"], "rxi": ["prxa", "RXi", " rfi", "rgxi", "pfi", "prpi", "rci", "Rpi", "rbi", "Rxi", "pXi", "ppi", "prxi", "rfi", "pci", " rdi", " rXi", "rXi", "rpi", " rpi", "rgxa", " rri", "rgci", "rri", "prdi", " rci", "prri", "prbi", "rgpi", "Rri", "rdi", " rxa", "rxa", "Rci", " rbi", "rgfi", "pxi", "rgbi", "Rdi"], "ba": ["na", "aba", "ab", "bi", "au", "bs", " bo", " buf", "ai", "fa", "bc", "pb", "abc", " bc", "ae", " ac", "xa", "ca", "ta", "bu", "aa", "bd", "tta", "asa", "pa", "buf", "ga", "ka", " ab", "ea", "da", " ca", "ada", "area", "b", "va", "la", "wa", "a", "ha", "ja", "Ba", "BA", "sa", " b"], "fcs_pad": ["fcsbpad", "fcs_init", "fcs_count", "fcsbcount", "ffs_init", "ffs_pad", "fcs_pos", "fcsbpos", "ffs_count", "ffs_pos", "fcsbinit"], "iov_copy": ["iov__copy", "oren_shared", "iov__shared", "oren__shared", "oren__copy", "oren_size", "oren_copy", "iov__size", "iov__data", "oren__size", "oren__data", "iov_size", "oren_data", "iov_shared", "iov_data"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_bmdma_simple_rw(void)\n\n{\n\n    QPCIDevice *dev;\n\n    void *bmdma_base, *ide_base;\n\n    uint8_t status;\n\n    uint8_t *buf;\n\n    uint8_t *cmpbuf;\n\n    size_t len = 512;\n\n    uintptr_t guest_buf = guest_alloc(guest_malloc, len);\n\n\n\n    PrdtEntry prdt[] = {\n\n        {\n\n            .addr = cpu_to_le32(guest_buf),\n\n            .size = cpu_to_le32(len | PRDT_EOT),\n\n        },\n\n    };\n\n\n\n    dev = get_pci_device(&bmdma_base, &ide_base);\n\n\n\n    buf = g_malloc(len);\n\n    cmpbuf = g_malloc(len);\n\n\n\n    /* Write 0x55 pattern to sector 0 */\n\n    memset(buf, 0x55, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 0, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Write 0xaa pattern to sector 1 */\n\n    memset(buf, 0xaa, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Read and verify 0x55 pattern in sector 0 */\n\n    memset(cmpbuf, 0x55, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 0, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n    /* Read and verify 0xaa pattern in sector 1 */\n\n    memset(cmpbuf, 0xaa, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 1, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n\n\n    g_free(buf);\n\n    g_free(cmpbuf);\n\n}\n", "idx": 5963, "substitutes": {"dev": ["ch", "hw", "mem", "v", "md", "rad", "pu", "pro", "di", "Dev", "block", "device", "bug", "data", "home", "ad", "info", "dem", "der", "valid", "gu", "bus", "f", "d", "ve", "mod", "server", "dist", "conf", "ev", "def", "DEV", "prom", "w", "cam", "error", "driver", "dc", "lib", "comment", "go", "exec", "self", "devices", "pub", "temp", "serial", "this", "fail", "pos", "ver", "du", "g", "off", "gd", "api", "engine", "cache", "app", "loader", "img", "grad", "conn", "diff", "google"], "bmdma_base": ["bmdma__base", "bmdma_bin", "bmdta_base", "bmdda_server", "bmdma2bin", "bmdta__base", "bmdma2Base", "bmdma2base", "bmdta__area", "bmdma_area", "bmdma2server", "bmdda_bin", "bmdta_ridge", "bmdta__bas", "bmdta_bas", "bmdma__bas", "bmdda_base", "bmdda_Base", "bmdma_bas", "bmdma_ridge", "bmdta__ridge", "bmdma__area", "bmdta_area", "bmdma__ridge", "bmdma_server", "bmdma_Base"], "ide_base": ["idexBase", "ideenbased", "IDE_source", "ideambase", "IDE_format", "IDExname", "idekbased", "ideappformat", "ided_based", "ideghome", "ideappsource", "ide_Base", "ide_system", "ince_based", "ideambasic", "ideknormal", "ideembase", "ide__based", "idedkbased", "ideemsource", "ide_format", "ideenbase", "ideappsystem", "idedkstable", "IDExbase", "ideappbase", "idexbase", "ideccstable", "ince__base", "ideccnormal", "ided_normal", "ide_home", "IDEkformat", "idegbase", "ide__la", "remote_basic", "ideksource", "ideksystem", "ide_based", "remote_prefix", "ince_la", "ide_stable", "IDEksource", "IDE_base", "ide___la", "idegroot", "ide_basic", "ide__name", "ideamhome", "ince__name", "idekstable", "idedknormal", "ide___based", "idexroot", "idexname", "IDExBase", "IDE_system", "ideenstable", "idegbasic", "ideccbase", "ide_normal", "remote_base", "IDE_name", "IDEkbase", "remote_home", "ideennormal", "ide_name", "IDE_Base", "ide_la", "ince_base", "idegname", "ideccbased", "ideamprefix", "IDE_root", "idedkbase", "IDEksystem", "ide_root", "ince__based", "ideemsystem", "ide___name", "ide_prefix", "ide__base", "ince__la", "ide_source", "idekbase", "ince_name", "ided_base", "idegprefix", "idegBase", "ide___base", "ideemformat", "IDExroot", "ided_stable", "idekformat"], "status": ["serv", "flag", "progress", "ex", "data", "style", "unit", "speed", "state", "weight", "magic", "active", "service", "code", "buffer", "error", "json", "bc", "err", "pass", "stage", "sp", "g", "notice", "resp", "current", "index", "cas", "msg", "name", "id", "count", "spec", "update", "sum", "info", "valid", "html", "standard", "comment", "sign", "str", "score", "ity", "fail", "stat", "note", "security", "rc", "sync", "debug", "num", "version", "cli", "reason", "action", "source", "css", "pos", "gen", "ssl", "api", "cache", "login", "gc", "complete", "session", "si", "wait", "stats", "full", "su", "result", "seq", "Status", "success", "date", "flags", "js"], "buf": ["base", "cmp", "buff", "vec", "lb", "mem", "block", "box", "la", "rb", "config", "b", "data", "rc", "home", "dest", "queue", "uc", "loc", "fb", "wb", "uf", "f", "lit", "fl", "buffer", "len", "que", "bag", "port", "cmd", "ctx", "bc", "cb", "coord", "fp", "filename", "feat", "result", "seq", "pool", "output", "alloc", "bh", "bf", "fd", "cf", "br", "cv", "bl", "cache", "fi", "text", "aux", "src", "cas", "lim", "pkg", "ff"], "cmpbuf": ["ackbuf", "seqbuffer", "diffbuffer", "seqbuff", "ctxbuff", "ctxfile", "diffbuf", "tmpbuff", "ackbuff", "cmpfile", "compbuff", "procbuff", "cmpimg", "ctxcb", "cmpbuff", "procbuf", "tmpbuf", "cmpbuffer", "compcb", "procimg", "ctxbuf", "ctxbuffer", "compimg", "cmpcb", "diffbuff", "tmpbuffer", "proccb", "ctximg", "seqbuf", "compbuf", "ackfile", "ackbuffer"], "prdt": ["sprdist", "frdat", "prt", "grdat", " prkt", "prds", "grtz", "PRt", "brdh", "brdt", "grdt", "strdh", "strtz", "grdl", "strdt", "protd", "revdt", "trdl", "revtd", "brkt", "prdat", "brdl", "brdm", "krdt", "krdm", "PRtd", "grdc", "prdh", "prkt", " prtd", " prdat", "prtd", "frdc", "pulldt", " prqt", "prodc", " prdh", "prodm", "prot", "prdm", "PRdt", "krdc", "brqt", " prds", "trqt", "revqt", "frdh", "prdl", "krdh", "frdl", "prtz", " prdc", "PRds", "frqt", "pulldh", "frdt", "prqt", " prt", "pullqt", "frrt", "sprtd", "prods", "prodt", " prdl", "strdl", "prdc", " prrt", "revdist", "sprqt", "pulldl", "brdc", "brtz", "prrt", " prdist", "prdist", "prodh", "grrt", "trkt", "trdt", "grdh", "sprdt"]}}
{"project": "qemu", "commit_id": "ac4b0d0c4feb291643c0e8a07a92e449e13881b5", "target": 0, "func": "static void bt_submit_hci(struct HCIInfo *info,\n\n                const uint8_t *data, int length)\n\n{\n\n    struct bt_hci_s *hci = hci_from_info(info);\n\n    uint16_t cmd;\n\n    int paramlen, i;\n\n\n\n    if (length < HCI_COMMAND_HDR_SIZE)\n\n        goto short_hci;\n\n\n\n    memcpy(&hci->last_cmd, data, 2);\n\n\n\n    cmd = (data[1] << 8) | data[0];\n\n    paramlen = data[2];\n\n    if (cmd_opcode_ogf(cmd) == 0 || cmd_opcode_ocf(cmd) == 0)\t/* NOP */\n\n        return;\n\n\n\n    data += HCI_COMMAND_HDR_SIZE;\n\n    length -= HCI_COMMAND_HDR_SIZE;\n\n\n\n    if (paramlen > length)\n\n        return;\n\n\n\n#define PARAM(cmd, param)\t(((cmd##_cp *) data)->param)\n\n#define PARAM16(cmd, param)\tle16_to_cpup(&PARAM(cmd, param))\n\n#define PARAMHANDLE(cmd)\tHNDL(PARAM(cmd, handle))\n\n#define LENGTH_CHECK(cmd)\tif (length < sizeof(cmd##_cp)) goto short_hci\n\n    /* Note: the supported commands bitmask in bt_hci_read_local_commands_rp\n\n     * needs to be updated every time a command is implemented here!  */\n\n    switch (cmd) {\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY):\n\n        LENGTH_CHECK(inquiry);\n\n\n\n        if (PARAM(inquiry, length) < 1) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 1;\n\n        hci->lm.periodic = 0;\n\n        hci->lm.responses_left = PARAM(inquiry, num_rsp) ?: INT_MAX;\n\n        hci->lm.responses = 0;\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_inquiry_start(hci, PARAM(inquiry, length));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY_CANCEL):\n\n        if (!hci->lm.inquire || hci->lm.periodic) {\n\n            fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \"\n\n                            \"the Inquiry command has been issued, a Command \"\n\n                            \"Status event has been received for the Inquiry \"\n\n                            \"command, and before the Inquiry Complete event \"\n\n                            \"occurs\", __FUNCTION__);\n\n            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 0;\n\n        qemu_del_timer(hci->lm.inquiry_done);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_PERIODIC_INQUIRY):\n\n        LENGTH_CHECK(periodic_inquiry);\n\n\n\n        if (!(PARAM(periodic_inquiry, length) <\n\n                                PARAM16(periodic_inquiry, min_period) &&\n\n                                PARAM16(periodic_inquiry, min_period) <\n\n                                PARAM16(periodic_inquiry, max_period)) ||\n\n                        PARAM(periodic_inquiry, length) < 1 ||\n\n                        PARAM16(periodic_inquiry, min_period) < 2 ||\n\n                        PARAM16(periodic_inquiry, max_period) < 3) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquire = 1;\n\n        hci->lm.periodic = 1;\n\n        hci->lm.responses_left = PARAM(periodic_inquiry, num_rsp);\n\n        hci->lm.responses = 0;\n\n        hci->lm.inquiry_period = PARAM16(periodic_inquiry, max_period);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        bt_hci_inquiry_start(hci, PARAM(periodic_inquiry, length));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_EXIT_PERIODIC_INQUIRY):\n\n        if (!hci->lm.inquire || !hci->lm.periodic) {\n\n            fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \"\n\n                            \"the Inquiry command has been issued, a Command \"\n\n                            \"Status event has been received for the Inquiry \"\n\n                            \"command, and before the Inquiry Complete event \"\n\n                            \"occurs\", __FUNCTION__);\n\n            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);\n\n            break;\n\n        }\n\n        hci->lm.inquire = 0;\n\n        qemu_del_timer(hci->lm.inquiry_done);\n\n        qemu_del_timer(hci->lm.inquiry_next);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN):\n\n        LENGTH_CHECK(create_conn);\n\n\n\n        if (hci->lm.connecting >= HCI_HANDLES_MAX) {\n\n            bt_hci_event_status(hci, HCI_REJECTED_LIMITED_RESOURCES);\n\n            break;\n\n        }\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n\n\n        if (bt_hci_connect(hci, &PARAM(create_conn, bdaddr)))\n\n            bt_hci_connection_reject_event(hci, &PARAM(create_conn, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_DISCONNECT):\n\n        LENGTH_CHECK(disconnect);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(disconnect))) {\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_disconnect(hci, PARAMHANDLE(disconnect),\n\n                        PARAM(disconnect, reason));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN_CANCEL):\n\n        LENGTH_CHECK(create_conn_cancel);\n\n\n\n        if (bt_hci_lmp_connection_ready(hci,\n\n                                &PARAM(create_conn_cancel, bdaddr))) {\n\n            for (i = 0; i < HCI_HANDLES_MAX; i ++)\n\n                if (bt_hci_role_master(hci, i) && hci->lm.handle[i].link &&\n\n                                !bacmp(&hci->lm.handle[i].link->slave->bd_addr,\n\n                                        &PARAM(create_conn_cancel, bdaddr)))\n\n                   break;\n\n\n\n            bt_hci_event_complete_conn_cancel(hci, i < HCI_HANDLES_MAX ?\n\n                            HCI_ACL_CONNECTION_EXISTS : HCI_NO_CONNECTION,\n\n                            &PARAM(create_conn_cancel, bdaddr));\n\n        } else\n\n            bt_hci_event_complete_conn_cancel(hci, HCI_SUCCESS,\n\n                            &PARAM(create_conn_cancel, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_ACCEPT_CONN_REQ):\n\n        LENGTH_CHECK(accept_conn_req);\n\n\n\n        if (!hci->conn_req_host ||\n\n                        bacmp(&PARAM(accept_conn_req, bdaddr),\n\n                                &hci->conn_req_host->bd_addr)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_connection_accept(hci, hci->conn_req_host);\n\n        hci->conn_req_host = 0;\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REJECT_CONN_REQ):\n\n        LENGTH_CHECK(reject_conn_req);\n\n\n\n        if (!hci->conn_req_host ||\n\n                        bacmp(&PARAM(reject_conn_req, bdaddr),\n\n                                &hci->conn_req_host->bd_addr)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        bt_hci_connection_reject(hci, hci->conn_req_host,\n\n                        PARAM(reject_conn_req, reason));\n\n        bt_hci_connection_reject_event(hci, &hci->conn_req_host->bd_addr);\n\n        hci->conn_req_host = 0;\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_AUTH_REQUESTED):\n\n        LENGTH_CHECK(auth_requested);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(auth_requested)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_auth_complete(hci, PARAMHANDLE(auth_requested));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_SET_CONN_ENCRYPT):\n\n        LENGTH_CHECK(set_conn_encrypt);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(set_conn_encrypt)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_encrypt_change(hci,\n\n                            PARAMHANDLE(set_conn_encrypt),\n\n                            PARAM(set_conn_encrypt, encrypt));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ):\n\n        LENGTH_CHECK(remote_name_req);\n\n\n\n        if (bt_hci_name_req(hci, &PARAM(remote_name_req, bdaddr)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ_CANCEL):\n\n        LENGTH_CHECK(remote_name_req_cancel);\n\n\n\n        bt_hci_event_complete_name_cancel(hci,\n\n                        &PARAM(remote_name_req_cancel, bdaddr));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_FEATURES):\n\n        LENGTH_CHECK(read_remote_features);\n\n\n\n        if (bt_hci_features_req(hci, PARAMHANDLE(read_remote_features)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_EXT_FEATURES):\n\n        LENGTH_CHECK(read_remote_ext_features);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(read_remote_ext_features)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        else {\n\n            bt_hci_event_status(hci, HCI_SUCCESS);\n\n            bt_hci_event_read_remote_ext_features(hci,\n\n                            PARAMHANDLE(read_remote_ext_features));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_VERSION):\n\n        LENGTH_CHECK(read_remote_version);\n\n\n\n        if (bt_hci_version_req(hci, PARAMHANDLE(read_remote_version)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_CLOCK_OFFSET):\n\n        LENGTH_CHECK(read_clock_offset);\n\n\n\n        if (bt_hci_clkoffset_req(hci, PARAMHANDLE(read_clock_offset)))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_LMP_HANDLE):\n\n        LENGTH_CHECK(read_lmp_handle);\n\n\n\n        /* TODO: */\n\n        bt_hci_event_complete_lmp_handle(hci, PARAMHANDLE(read_lmp_handle));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_HOLD_MODE):\n\n        LENGTH_CHECK(hold_mode);\n\n\n\n        if (PARAM16(hold_mode, min_interval) >\n\n                        PARAM16(hold_mode, max_interval) ||\n\n                        PARAM16(hold_mode, min_interval) < 0x0002 ||\n\n                        PARAM16(hold_mode, max_interval) > 0xff00 ||\n\n                        (PARAM16(hold_mode, min_interval) & 1) ||\n\n                        (PARAM16(hold_mode, max_interval) & 1)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        if (bt_hci_mode_change(hci, PARAMHANDLE(hold_mode),\n\n                                PARAM16(hold_mode, max_interval),\n\n                                acl_hold))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_PARK_MODE):\n\n        LENGTH_CHECK(park_mode);\n\n\n\n        if (PARAM16(park_mode, min_interval) >\n\n                        PARAM16(park_mode, max_interval) ||\n\n                        PARAM16(park_mode, min_interval) < 0x000e ||\n\n                        (PARAM16(park_mode, min_interval) & 1) ||\n\n                        (PARAM16(park_mode, max_interval) & 1)) {\n\n            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        if (bt_hci_mode_change(hci, PARAMHANDLE(park_mode),\n\n                                PARAM16(park_mode, max_interval),\n\n                                acl_parked))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_EXIT_PARK_MODE):\n\n        LENGTH_CHECK(exit_park_mode);\n\n\n\n        if (bt_hci_mode_cancel(hci, PARAMHANDLE(exit_park_mode),\n\n                                acl_parked))\n\n            bt_hci_event_status(hci, HCI_NO_CONNECTION);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_ROLE_DISCOVERY):\n\n        LENGTH_CHECK(role_discovery);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(role_discovery)))\n\n            bt_hci_event_complete_role_discovery(hci,\n\n                            HCI_NO_CONNECTION, PARAMHANDLE(role_discovery), 0);\n\n        else\n\n            bt_hci_event_complete_role_discovery(hci,\n\n                            HCI_SUCCESS, PARAMHANDLE(role_discovery),\n\n                            bt_hci_role_master(hci,\n\n                                    PARAMHANDLE(role_discovery)));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_MASK):\n\n        LENGTH_CHECK(set_event_mask);\n\n\n\n        memcpy(hci->event_mask, PARAM(set_event_mask, mask), 8);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_RESET):\n\n        bt_hci_reset(hci);\n\n        bt_hci_event_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_FLT):\n\n        if (length >= 1 && PARAM(set_event_flt, flt_type) == FLT_CLEAR_ALL)\n\n            /* No length check */;\n\n        else\n\n            LENGTH_CHECK(set_event_flt);\n\n\n\n        /* Filters are not implemented */\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_FLUSH):\n\n        LENGTH_CHECK(flush);\n\n\n\n        if (bt_hci_handle_bad(hci, PARAMHANDLE(flush)))\n\n            bt_hci_event_complete_flush(hci,\n\n                            HCI_NO_CONNECTION, PARAMHANDLE(flush));\n\n        else {\n\n            /* TODO: ordering? */\n\n            bt_hci_event(hci, EVT_FLUSH_OCCURRED,\n\n                            &PARAM(flush, handle),\n\n                            EVT_FLUSH_OCCURRED_SIZE);\n\n            bt_hci_event_complete_flush(hci,\n\n                            HCI_SUCCESS, PARAMHANDLE(flush));\n\n        }\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_CHANGE_LOCAL_NAME):\n\n        LENGTH_CHECK(change_local_name);\n\n\n\n        if (hci->device.lmp_name)\n\n            free((void *) hci->device.lmp_name);\n\n        hci->device.lmp_name = strndup(PARAM(change_local_name, name),\n\n                        sizeof(PARAM(change_local_name, name)));\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_LOCAL_NAME):\n\n        bt_hci_event_complete_read_local_name(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CONN_ACCEPT_TIMEOUT):\n\n        bt_hci_event_complete_read_conn_accept_timeout(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CONN_ACCEPT_TIMEOUT):\n\n        /* TODO */\n\n        LENGTH_CHECK(write_conn_accept_timeout);\n\n\n\n        if (PARAM16(write_conn_accept_timeout, timeout) < 0x0001 ||\n\n                        PARAM16(write_conn_accept_timeout, timeout) > 0xb540) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->conn_accept_tout = PARAM16(write_conn_accept_timeout, timeout);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_SCAN_ENABLE):\n\n        bt_hci_event_complete_read_scan_enable(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_SCAN_ENABLE):\n\n        LENGTH_CHECK(write_scan_enable);\n\n\n\n        /* TODO: check that the remaining bits are all 0 */\n\n        hci->device.inquiry_scan =\n\n                !!(PARAM(write_scan_enable, scan_enable) & SCAN_INQUIRY);\n\n        hci->device.page_scan =\n\n                !!(PARAM(write_scan_enable, scan_enable) & SCAN_PAGE);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CLASS_OF_DEV):\n\n        bt_hci_event_complete_read_local_class(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CLASS_OF_DEV):\n\n        LENGTH_CHECK(write_class_of_dev);\n\n\n\n        memcpy(hci->device.class, PARAM(write_class_of_dev, dev_class),\n\n                        sizeof(PARAM(write_class_of_dev, dev_class)));\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_VOICE_SETTING):\n\n        bt_hci_event_complete_voice_setting(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_VOICE_SETTING):\n\n        LENGTH_CHECK(write_voice_setting);\n\n\n\n        hci->voice_setting = PARAM(write_voice_setting, voice_setting);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_HOST_NUMBER_OF_COMPLETED_PACKETS):\n\n        if (length < data[0] * 2 + 1)\n\n            goto short_hci;\n\n\n\n        for (i = 0; i < data[0]; i ++)\n\n            if (bt_hci_handle_bad(hci,\n\n                                    data[i * 2 + 1] | (data[i * 2 + 2] << 8)))\n\n                bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_INQUIRY_MODE):\n\n        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x40)\n\n         * else\n\n         *     goto unknown_command */\n\n        bt_hci_event_complete_read_inquiry_mode(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_INQUIRY_MODE):\n\n        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x80)\n\n         * else\n\n         *     goto unknown_command */\n\n        LENGTH_CHECK(write_inquiry_mode);\n\n\n\n        if (PARAM(write_inquiry_mode, mode) > 0x01) {\n\n            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);\n\n            break;\n\n        }\n\n\n\n        hci->lm.inquiry_mode = PARAM(write_inquiry_mode, mode);\n\n        bt_hci_event_complete_status(hci, HCI_SUCCESS);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_VERSION):\n\n        bt_hci_read_local_version_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_COMMANDS):\n\n        bt_hci_read_local_commands_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_FEATURES):\n\n        bt_hci_read_local_features_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_EXT_FEATURES):\n\n        LENGTH_CHECK(read_local_ext_features);\n\n\n\n        bt_hci_read_local_ext_features_rp(hci,\n\n                        PARAM(read_local_ext_features, page_num));\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BUFFER_SIZE):\n\n        bt_hci_read_buffer_size_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_COUNTRY_CODE):\n\n        bt_hci_read_country_code_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BD_ADDR):\n\n        bt_hci_read_bd_addr_rp(hci);\n\n        break;\n\n\n\n    case cmd_opcode_pack(OGF_STATUS_PARAM, OCF_READ_LINK_QUALITY):\n\n        LENGTH_CHECK(read_link_quality);\n\n\n\n        bt_hci_link_quality_rp(hci, PARAMHANDLE(read_link_quality));\n\n        break;\n\n\n\n    default:\n\n        bt_hci_event_status(hci, HCI_UNKNOWN_COMMAND);\n\n        break;\n\n\n\n    short_hci:\n\n        fprintf(stderr, \"%s: HCI packet too short (%iB)\\n\",\n\n                        __FUNCTION__, length);\n\n        bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);\n\n        break;\n\n    }\n\n}\n", "idx": 21100, "substitutes": {"info": ["fa", "about", "start", "def", "Info", "fi", "conn", "linux", "ref", "config", "meta", "INFO", "home", "f", "information", "init", "state", "stat", "inf", "id", "thin", "ctx", "index", "source", "family", "a", "error", "base", "iso", "http", "conf", "from", "image", "api", "fo", "type"], "data": ["request", "limit", "start", "response", "next", "config", "valid", "ui", "result", "input", "message", "Data", "d", "bytes", "pad", "buffer", "results", "done", "exec", "pos", "size", "cache", "args", "da", "ad", "p", "params", "help", "code", "number", "body", "shift", "buf", "memory", "header", "index", "complete", "missing", "DATA", "window", "value", "draw", "media", "slice", "len", "database", "batch", "parent", "multi", "dat", "array", "resource", "image", "api", "offset", "base", "output", "command", "type", "zero"], "length": ["delay", "shape", "limit", "end", "Length", "result", "input", "message", "time", "style", "duration", "l", "maximum", "type", "offset", "f", "path", "function", "section", "size", "sequence", "full", "lock", "p", "number", "url", "id", "body", "filename", "L", "match", "value", "line", "ength", "len", "partial", "total", "angle", "th", "range", "array", "position", "tail", "ph", "padding", "count"], "hci": ["hbi", "hlcci", "hlcu", "bhci", " hCI", "hdi", "ahci", "rhdi", "hladi", "Hcci", "hlcin", " hcci", "hCI", "rhcu", "shsync", "hbc", " hai", "hcu", "hii", "rhii", "Hcu", "hsync", "hscin", " hxc", " hbc", "khcin", "hscci", "hlci", "hlbi", "shci", "phcu", "bhii", "bhdi", " hii", "Hki", "shbi", "hldi", "hlii", "ahcu", "hcci", "shdi", "phii", " hcu", " hdi", "bhbc", " hki", "rhki", "phki", "ahcci", " hcin", "hlsync", "hlxc", "hscu", "hlai", "phci", "hxc", "hsci", "shai", " hadi", "khci", " hbi", "phdi", "hai", "hki", "shxc", "hlCI", "rhci", "Hci", "hlki", "khdi", "khCI", "hadi", "hlbc", "phadi", "ahii", "shcci", "rhcci", "hcin", " hsync"], "cmd": ["md", "name", "cc", "cd", "kind", "conn", "config", "pkg", "ctr", "cookie", "cm", " payload", "mode", "func", "pipe", "cmp", "op", "Cmd", "msg", "cp", "cat", " command", "head", "method", "cf", "setup", "params", "ctrl", "code", "mac", "cli", "buf", "client", "header", "ctx", " chunk", "module", "cb", "cfg", "cn", "c", "dom", "dc", "cpp", "seq", "channel", "comm", "src", "vc", "req", "domain", "proc", "chrom", "param", "ck", "cod", "command", "type"], "paramlen": ["paramlength", "paramstr", "arampos", "requestpos", " paramLen", "parlen", "paramLen", " parampos", "aramstr", " paramstr", "paramsln", "namelin", "nameid", "namelen", "paramslen", "paramln", "aramlen", "parLen", "paramid", "requestlen", "requestlength", "aramid", "paramlin", "nameln", "parampos", "aramLen", "paramslin", "paramsid", " paramlength", "parpos", "aramlin", "parstr", "aramln", "parlength", "requestLen"], "i": ["io", "binary", "ind", "input", "uri", "I", "umi", "m", "j", "ip", "p", "abi", "id", "inner", "cli", "c", "index", "num", "a", "ii", "n", "slice", "ai", "array", "li", "uni"]}}
{"project": "qemu", "commit_id": "f51074cdc6e750daa3b6df727d83449a7e42b391", "target": 1, "func": "int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)\n\n{\n\n    /* On non-x86 we don't do PCI hotplug */\n\n    monitor_printf(mon, \"Can't hot-add drive to type %d\\n\", dinfo->type);\n\n    return -1;\n\n}\n", "idx": 9845, "substitutes": {"mon": ["mont", "man", "channel", "emon", "Monitor", "mos", "meter", "own", "MON", "mor", "my", "mm", "pid", "chron", "con", "monitor", "don", "mu", "amon", "mic", "mand", "mid", "sym", "mons", "module", "mc", "master", "Mon", "min", "atom", "kin", "mut", "mot", "mun", "mo", " monitor", "ann", "bin", "mag", "pin"], "qdict": ["eqdot", "qdot", "eqdef", "Qdict", " qdef", " qdot", "Qdot", "Qdef", "eqdict", "qdef"], "dinfo": ["bdInfo", " dfo", "rdinfo", "Dinfo", "bdinfo", "bdinf", "Dfo", "DInfo", "rdfo", " dentry", " dInfo", " dinf", "dinf", "bdentry", "dfo", "Dinf", "Dentry", "rdinf", "dentry", "dInfo"]}}
{"project": "qemu", "commit_id": "c95de7e2c40da4235ceda6d134ae069dae80157e", "target": 1, "func": "static int qcow2_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int ret;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n\n    return bdrv_co_flush(bs->file);\n\n}", "idx": 5129, "substitutes": {"bs": ["bas", "base", "as", "lb", "block", "ins", "rb", "b", "lbs", "sync", "ses", "bing", "BS", "obs", "fb", "bes", "ns", "state", "ls", "obj", "iss", "bb", "cs", "ss", "vs", "sb", "bis", "ds", "bc", "cb", "ab", "outs", "ubs", "ba", "ec", "blocks", "css", "gb", "fs", "sa", "os", "bos", "bid", "ps", "bl", "pb", "es", "src", "bh", "js"], "s": ["o", "sec", "is", "S", "spec", "sg", "b", "si", "i", "sync", "ses", "services", "f", "ns", "state", "stats", "ls", "sl", "service", "ss", "cs", "e", "sie", "sb", "gs", "bis", "ds", "t", "ts", "su", "p", "sv", "sa", "c", "os", "g", "ssl", "sq", "sym", "y", "site", "es", "ps", "js"], "ret": ["std", "fat", "flag", "reg", "reset", "rt", "mem", "al", "alt", "nt", "pat", "pre", "get", "lt", "val", "rf", "data", "et", "bit", "cat", "format", "art", "num", "fin", "f", "lit", "ext", "att", " Ret", "active", "arg", "res", "len", "mt", "code", "det", "part", "en", "arr", "error", "RET", "t", "plain", "out", "pass", "err", "rev", "result", "end", "Ret", "run", "ft", "fab", "re", "fail", "true", "fun", "ut", "bf", "ct", "gt", "success", "ref", "group", "rets", "af"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void control_to_network(RDMAControlHeader *control)\n\n{\n\n    control->type = htonl(control->type);\n\n    control->len = htonl(control->len);\n\n    control->repeat = htonl(control->repeat);\n\n}\n", "idx": 4385, "substitutes": {"control": ["master", "sub", "address", "flow", "build", "feed", "block", "pull", "http", "Control", "config", "layout", "update", "object", "sync", "controlled", "edit", "route", "holder", "null", "content", "client", "event", "server", "length", "create", "ack", "connect", "close", "error", "full", "rol", "forward", "lib", "exec", "load", "controller", "bridge", "input", "output", "respond", "protected", "follow", "hold", "rule", "off", "contract", "type", "contact", "design", "model", "core", "element", "accept", "form", "group", "command", "ctrl"]}}
{"project": "qemu", "commit_id": "e568f9df086965813a318ff0558782ba90e59c33", "target": 0, "func": "static int validate_guest_space(unsigned long guest_base,\n\n                                unsigned long guest_size)\n\n{\n\n    unsigned long real_start, test_page_addr;\n\n\n\n    /* We need to check that we can force a fault on access to the\n\n     * commpage at 0xffff0fxx\n\n     */\n\n    test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask);\n\n\n\n    /* If the commpage lies within the already allocated guest space,\n\n     * then there is no way we can allocate it.\n\n     */\n\n    if (test_page_addr >= guest_base\n\n        && test_page_addr <= (guest_base + guest_size)) {\n\n        return -1;\n\n    }\n\n\n\n    /* Note it needs to be writeable to let us initialise it */\n\n    real_start = (unsigned long)\n\n                 mmap((void *)test_page_addr, qemu_host_page_size,\n\n                     PROT_READ | PROT_WRITE,\n\n                     MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n\n\n    /* If we can't map it then try another address */\n\n    if (real_start == -1ul) {\n\n        return 0;\n\n    }\n\n\n\n    if (real_start != test_page_addr) {\n\n        /* OS didn't put the page where we asked - unmap and reject */\n\n        munmap((void *)real_start, qemu_host_page_size);\n\n        return 0;\n\n    }\n\n\n\n    /* Leave the page mapped\n\n     * Populate it (mmap should have left it all 0'd)\n\n     */\n\n\n\n    /* Kernel helper versions */\n\n    __put_user(5, (uint32_t *)g2h(0xffff0ffcul));\n\n\n\n    /* Now it's populated make it RO */\n\n    if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) {\n\n        perror(\"Protecting guest commpage\");\n\n        exit(-1);\n\n    }\n\n\n\n    return 1; /* All good */\n\n}\n", "idx": 9709, "substitutes": {"guest_base": ["guester_area", "guess_based", "guess_base", "guest67size", "guester_bas", "guest_based", "guest67based", "guest_start", "guest67area", "guess_start", "guess_size", "guest_bas", "guest_bare", "guester_bare", "guest67base", "guester_base", "guester_size", "guest_area", "guess_area"], "guest_size": ["guest_offset", "guest64base", "guested64sec", "guested64size", "guested_sec", "guested64address", "guested_address", "guested_base", "guest_address", "guest64sec", "guest_sec", "guested_size", "guested64base", "guest64address", "guester_base", "guester_size", "guester_offset", "guest64size"], "real_start": ["re_address", "realamcost", "real_shift", "realacstart", " real_cost", "real64set", "realpend", " real_set", "complex_art", "re_start", "re_end", "realacsearch", "real67end", "realacaddr", "realpart", "real_address", " real_size", "real_end", "realamstart", "realpoffset", "real67shift", "real64end", "real_offset", "real_search", "complex_offset", " real_search", "real64cost", "real67start", "realamset", "re_shift", "real_set", "complex_end", "real_cost", "real_pad", "complex_start", " real_end", " real_addr", " real_stack", "realacsize", "real67address", "realamend", "realpstart", " real_pad", "real_art", "real_addr", "real_stack", "real64start", "real_size"], "test_page_addr": ["test_page_adr", "test_pageacsize", "test_site_adr", "test_server_offset", "test_page_ord", "test_server_addr", "test_page_ext", "test_site_ad", "test_site_size", "test_pageacord", "test_site_dist", "test_page64offset", "test_page_ad", "test_site_ord", "test_server_ext", "test_server_size", "test_pagexaddr", "test_pagexsize", "test_pageacaddr", "test_page_dist", "test_page64addr", "test_pagexext", "test_page_address", "test_site_addr", "test_site_address", "test_page_offset", "test_page64size", "test_page_size", "test_pageacaddress", "test_pagexaddress", "test_server_address", "test_page64address", "test_site_offset"]}}
{"project": "qemu", "commit_id": "2ff30257974e19ebe2a97baad32ac29c06da5fb9", "target": 0, "func": "static void *migration_thread(void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n    /* Used by the bandwidth calcs, updated later */\n\n    int64_t initial_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n    int64_t setup_start = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n\n    int64_t initial_bytes = 0;\n\n    int64_t max_size = 0;\n\n    int64_t start_time = initial_time;\n\n    int64_t end_time;\n\n    bool old_vm_running = false;\n\n    bool entered_postcopy = false;\n\n    /* The active state we expect to be in; ACTIVE or POSTCOPY_ACTIVE */\n\n    enum MigrationStatus current_active_state = MIGRATION_STATUS_ACTIVE;\n\n\n\n    rcu_register_thread();\n\n\n\n    qemu_savevm_state_header(s->to_dst_file);\n\n\n\n    if (migrate_postcopy_ram()) {\n\n        /* Now tell the dest that it should open its end so it can reply */\n\n        qemu_savevm_send_open_return_path(s->to_dst_file);\n\n\n\n        /* And do a ping that will make stuff easier to debug */\n\n        qemu_savevm_send_ping(s->to_dst_file, 1);\n\n\n\n        /*\n\n         * Tell the destination that we *might* want to do postcopy later;\n\n         * if the other end can't do postcopy it should fail now, nice and\n\n         * early.\n\n         */\n\n        qemu_savevm_send_postcopy_advise(s->to_dst_file);\n\n    }\n\n\n\n    qemu_savevm_state_begin(s->to_dst_file, &s->params);\n\n\n\n    s->setup_time = qemu_clock_get_ms(QEMU_CLOCK_HOST) - setup_start;\n\n    current_active_state = MIGRATION_STATUS_ACTIVE;\n\n    migrate_set_state(&s->state, MIGRATION_STATUS_SETUP,\n\n                      MIGRATION_STATUS_ACTIVE);\n\n\n\n    trace_migration_thread_setup_complete();\n\n\n\n    while (s->state == MIGRATION_STATUS_ACTIVE ||\n\n           s->state == MIGRATION_STATUS_POSTCOPY_ACTIVE) {\n\n        int64_t current_time;\n\n        uint64_t pending_size;\n\n\n\n        if (!qemu_file_rate_limit(s->to_dst_file)) {\n\n            uint64_t pend_post, pend_nonpost;\n\n\n\n            qemu_savevm_state_pending(s->to_dst_file, max_size, &pend_nonpost,\n\n                                      &pend_post);\n\n            pending_size = pend_nonpost + pend_post;\n\n            trace_migrate_pending(pending_size, max_size,\n\n                                  pend_post, pend_nonpost);\n\n            if (pending_size && pending_size >= max_size) {\n\n                /* Still a significant amount to transfer */\n\n\n\n                if (migrate_postcopy_ram() &&\n\n                    s->state != MIGRATION_STATUS_POSTCOPY_ACTIVE &&\n\n                    pend_nonpost <= max_size &&\n\n                    atomic_read(&s->start_postcopy)) {\n\n\n\n                    if (!postcopy_start(s, &old_vm_running)) {\n\n                        current_active_state = MIGRATION_STATUS_POSTCOPY_ACTIVE;\n\n                        entered_postcopy = true;\n\n                    }\n\n\n\n                    continue;\n\n                }\n\n                /* Just another iteration step */\n\n                qemu_savevm_state_iterate(s->to_dst_file, entered_postcopy);\n\n            } else {\n\n                trace_migration_thread_low_pending(pending_size);\n\n                migration_completion(s, current_active_state,\n\n                                     &old_vm_running, &start_time);\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (qemu_file_get_error(s->to_dst_file)) {\n\n            migrate_set_state(&s->state, current_active_state,\n\n                              MIGRATION_STATUS_FAILED);\n\n            trace_migration_thread_file_err();\n\n            break;\n\n        }\n\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n        if (current_time >= initial_time + BUFFER_DELAY) {\n\n            uint64_t transferred_bytes = qemu_ftell(s->to_dst_file) -\n\n                                         initial_bytes;\n\n            uint64_t time_spent = current_time - initial_time;\n\n            double bandwidth = (double)transferred_bytes / time_spent;\n\n            max_size = bandwidth * migrate_max_downtime() / 1000000;\n\n\n\n            s->mbps = (((double) transferred_bytes * 8.0) /\n\n                    ((double) time_spent / 1000.0)) / 1000.0 / 1000.0;\n\n\n\n            trace_migrate_transferred(transferred_bytes, time_spent,\n\n                                      bandwidth, max_size);\n\n            /* if we haven't sent anything, we don't want to recalculate\n\n               10000 is a small enough number for our purposes */\n\n            if (s->dirty_bytes_rate && transferred_bytes > 10000) {\n\n                s->expected_downtime = s->dirty_bytes_rate / bandwidth;\n\n            }\n\n\n\n            qemu_file_reset_rate_limit(s->to_dst_file);\n\n            initial_time = current_time;\n\n            initial_bytes = qemu_ftell(s->to_dst_file);\n\n        }\n\n        if (qemu_file_rate_limit(s->to_dst_file)) {\n\n            /* usleep expects microseconds */\n\n            g_usleep((initial_time + BUFFER_DELAY - current_time)*1000);\n\n        }\n\n    }\n\n\n\n    trace_migration_thread_after_loop();\n\n    /* If we enabled cpu throttling for auto-converge, turn it off. */\n\n    cpu_throttle_stop();\n\n    end_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n\n\n    qemu_mutex_lock_iothread();\n\n    qemu_savevm_state_cleanup();\n\n    if (s->state == MIGRATION_STATUS_COMPLETED) {\n\n        uint64_t transferred_bytes = qemu_ftell(s->to_dst_file);\n\n        s->total_time = end_time - s->total_time;\n\n        if (!entered_postcopy) {\n\n            s->downtime = end_time - start_time;\n\n        }\n\n        if (s->total_time) {\n\n            s->mbps = (((double) transferred_bytes * 8.0) /\n\n                       ((double) s->total_time)) / 1000;\n\n        }\n\n        runstate_set(RUN_STATE_POSTMIGRATE);\n\n    } else {\n\n        if (old_vm_running && !entered_postcopy) {\n\n            vm_start();\n\n        } else {\n\n            if (runstate_check(RUN_STATE_FINISH_MIGRATE)) {\n\n                runstate_set(RUN_STATE_POSTMIGRATE);\n\n            }\n\n        }\n\n    }\n\n    qemu_bh_schedule(s->cleanup_bh);\n\n    qemu_mutex_unlock_iothread();\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n", "idx": 19574, "substitutes": {"opaque": [" opque", "OPhole", "oppac", "ophole", " opacity", "opac", "opec", "operec", "opacity", "phole", " opac", "pacity", "oppaque", "operaque", " ophole", "OPaques", " opec", "paques", "operque", "paque", "OPaque", "OPacity", "operac", "opaques", "oppque", "opque", " opaques", "oppec"], "s": ["ns", "spec", "m", "ts", "sg", "stats", "rs", "conf", "f", "aws", "t", "settings", "services", "service", "sie", "sb", "g", "i", "sl", "ss", "ls", "scope", "fs", "is", "o", "cs", "l", "submit", "d", "su", "new", "args", "site", "w", "qs", "serv", "ssl", "side", "e", "ses", "sync", "c", "js", "si", "ps", "sym", "p", "secondary", "S", "b", "ks", "http", "gs", "sys", "your", "storage", "h", "a", "es", "os", "state", "hs", "south", "states", "sq", "sets", "server", "source", "y", "ds", "sf"], "end_time": ["end___time", "start_size", "start_time", "end\u00b7time", "end___money", "end\u00b7money", "start_money", "end\u00b7offset", "end___size", "start_offset", "end\u00b7size", "end_money", "end_offset", "end_size", "end___offset"], "current_time": ["reported_mode", "current00times", "current_mode", "reported_time", "reported_times", "current00time", "current00speed", "current_speed", "current67times", "current67speed", "current67mode", "current_times", "reported_speed", "current00mode", "current67time"], "pending_size": ["pending_bytes", "pended_bytes", "pending_page", "pended_page", "pended_time", "pending_time", "pended_size"], "pend_post": ["pend00pre", "pend2post", "pend_posts", "pend_type", "pend2posts", "pend_pre", "end_pre", "pend2type", "pend2pre", "pend00post", "end_type", "end_posts", "pend00type", "end_post", "pend00posts"], "pend_nonpost": ["pend_preproc", "pend_nonproc", "pend_preupload", "pend_unpadding", "pend_unproc", "pend_prepost", "pend_prepadding", "pend_nonpadding", "pend_nonupload", "pend_unpost", "pend_unupload"]}}
{"project": "qemu", "commit_id": "8ae8e904fcba484ff7c3f8f31339b56ebd88fbad", "target": 1, "func": "void qmp_blockdev_add(BlockdevOptions *options, Error **errp)\n\n{\n\n    QmpOutputVisitor *ov = qmp_output_visitor_new();\n\n    QObject *obj;\n\n    QDict *qdict;\n\n    Error *local_err = NULL;\n\n\n\n    /* Require an ID in the top level */\n\n    if (!options->has_id) {\n\n        error_setg(errp, \"Block device needs an ID\");\n\n        goto fail;\n\n    }\n\n\n\n    /* TODO Sort it out in raw-posix and drive_init: Reject aio=native with\n\n     * cache.direct=false instead of silently switching to aio=threads, except\n\n     * if called from drive_init.\n\n     *\n\n     * For now, simply forbidding the combination for all drivers will do. */\n\n    if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) {\n\n        bool direct = options->cache->has_direct && options->cache->direct;\n\n        if (!options->has_cache && !direct) {\n\n            error_setg(errp, \"aio=native requires cache.direct=true\");\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    visit_type_BlockdevOptions(qmp_output_get_visitor(ov),\n\n                               &options, NULL, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\n    obj = qmp_output_get_qobject(ov);\n\n    qdict = qobject_to_qdict(obj);\n\n\n\n    qdict_flatten(qdict);\n\n\n\n    blockdev_init(NULL, qdict, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n    }\n\n\n\nfail:\n\n    qmp_output_visitor_cleanup(ov);\n\n}\n", "idx": 1038, "substitutes": {"options": ["files", "null", "external", "this", "name", "js", "groups", "http", "cho", "ops", "ts", "acl", "rules", "ips", "data", "eps", "current", "flags", "com", "global", "results", "co", "objects", "ions", "ims", "parent", "op", "checks", "pos", "comments", "params", "none", "args", "details", "ents", "Options", "info", "settings", "style", "resources", "outs", "utils", "config", "ps", "ports", "opt", "errors", "names", "or", "self", "e", "es", "app", "cache", "public", "ors", "object", "exec", "o", "s", "issues", "events", "points", "os", "times", "changes", "io", "plugins", "option"], "errp": ["errP", "resultpc", "asterps", "erP", "armpre", "ierpe", "errorpat", "resultpre", "ierps", "rrpc", "ierf", " errpr", "errpe", "nerpc", " errpe", "errpc", "erpat", "rrP", "errorP", "armP", "ierpat", "nerpre", "nerpe", "resultf", "resultps", "ierP", "armpc", "asterpr", "err", " errps", " errP", "resultp", "asterf", "errr", "errps", "errpat", "resultpe", " errpc", "asterp", "errorp", "erp", "nerp", " errpre", "errpr", " errf", "errorr", "rrpre", "errf", "ierr", "errpre", "armp", "ierpr", "ierp", "rrp"], "ov": ["ob", "oa", "raft", "ow", "kov", "ant", "vo", "upp", "OV", "av", "oid", "opp", "boot", "ou", "ova", "ko", "off", "lov", "oo", "erv", "ove", "sv", "oyer", "obile", "ovo", "ocr", "oc", "uv", "up", "oval", "o", "orf", "iv", "nov", "ev", "od", "oy", "oven", "ovan", "oh", "rov", "obb"], "obj": ["ob", "oa", "so", "adj", "ctx", "act", "ass", "ops", "bo", "data", "oi", "n", "co", "alt", "objects", "dict", "opp", "aj", "fn", "cdn", "op", "arr", "tmp", "Obj", "j", "po", "output", "eff", "Object", "coll", "cb", "nt", "bj", "str", "utils", "ind", "block", "bot", "self", "attr", "cache", "oc", "object", "art", "o", "b", "os", "od", "val", "pt", "pp", "obb"], "qdict": ["eqdict", "pclean", "qpatch", "reqdict", "quclean", "pdict", " qdata", "rdict", "dqdata", "qdetails", "qudata", "qdata", "qudict", "sqdict", "rdetails", "quict", " qpatch", "dqpatch", "qucontainer", "qict", "pdata", " qcoll", "sqcontainer", "reqpatch", "qclean", "dqcoll", " qclean", "eqdata", "qcoll", "qcontainer", "sqict", "rdata", "qdf", " qdf", "dqdict", "rdf", "eqdetails", " qdetails", "reqcoll", "pdf", " qict", "reqdata", "sqdf", "eqdf", " qcontainer", "qudf"], "local_err": ["standard_er", "localallerr", "local_doc", "localererr", "locallystatus", "localedrr", "standardaller", "foreign_war", "standardallerr", "global_msg", "foreignallerr", " local_cr", "foreign_error", "standardallmr", "localallerror", "localermsg", "internal_rr", "foreignaller", "local_status", "global_err", "local_error", "locallyerr", "foreignallerror", "local_Er", "localerorig", "local_er", "global_orig", "local_war", "localaller", "foreign_er", "locallyconn", "local_msg", "local_mr", "local_rr", "internal_err", "global_error", " local_doc", "localedconn", "internal_conn", "foreign_err", "standard_Er", "localallEr", "localererror", "localedstatus", "local_conn", " local_error", "localallmr", "standardallEr", "internal_status", "localallwar", "foreignallwar", " local_er", "locallyrr", "localederr", "standard_mr", "local_cr", "standard_err", "local_orig"]}}
{"project": "FFmpeg", "commit_id": "d59bfcd11229300182c672ca734568919a85f773", "target": 1, "func": "static void mov_update_dts_shift(MOVStreamContext *sc, int duration)\n\n{\n\n    if (duration < 0) {\n\n\n\n\n\n        sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n\n", "idx": 21385, "substitutes": {"sc": ["lc", "bc", "SC", "fc", "cc", "cam", "uc", "esc", "sk", "sci", "asc", "sche", "cv", "ca", "Sc", "cur", "pc", "cl", "cmp", "enc", "cs", "cer", "cf", "tc", "context", "rc", "c", "ctx", "spec", "dc", "soc", "cr", "desc", "src", "loc", "usc", "osc", "cms", "scope", "ec"], "duration": ["span", "delay", "port", "period", "attribute", "end", "event", "until", "time", "d", "uri", "pause", "feature", "pad", "device", "uration", "series", "sequence", "data", "lasting", "design", "Duration", "dimension", "component", "unit", "number", "depth", "context", "timeout", "tube", "audio", "document", "distance", "window", "direction", "date", "length", "database", "stage", "range", "doc", "frequency", "gap", "resource", "sleep", "repeat", "video"]}}
{"project": "qemu", "commit_id": "8be7e7e4c72c048b90e3482557954a24bba43ba7", "target": 1, "func": "static int virtcon_parse(const char *devname)\n\n{\n\n    QemuOptsList *device = qemu_find_opts(\"device\");\n\n    static int index = 0;\n\n    char label[32];\n\n    QemuOpts *bus_opts, *dev_opts;\n\n\n\n    if (strcmp(devname, \"none\") == 0)\n\n        return 0;\n\n    if (index == MAX_VIRTIO_CONSOLES) {\n\n        fprintf(stderr, \"qemu: too many virtio consoles\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    bus_opts = qemu_opts_create(device, NULL, 0);\n\n    if (arch_type == QEMU_ARCH_S390X) {\n\n        qemu_opt_set(bus_opts, \"driver\", \"virtio-serial-s390\");\n\n    } else {\n\n        qemu_opt_set(bus_opts, \"driver\", \"virtio-serial-pci\");\n\n    } \n\n\n\n    dev_opts = qemu_opts_create(device, NULL, 0);\n\n    qemu_opt_set(dev_opts, \"driver\", \"virtconsole\");\n\n\n\n    snprintf(label, sizeof(label), \"virtcon%d\", index);\n\n    virtcon_hds[index] = qemu_chr_new(label, devname, NULL);\n\n    if (!virtcon_hds[index]) {\n\n        fprintf(stderr, \"qemu: could not open virtio console '%s': %s\\n\",\n\n                devname, strerror(errno));\n\n        return -1;\n\n    }\n\n    qemu_opt_set(dev_opts, \"chardev\", label);\n\n\n\n    index++;\n\n    return 0;\n\n}\n", "idx": 21250, "substitutes": {"devname": [" devno", " devnm", "evnames", " devName", "devno", "devName", "divnames", "devicenm", "evName", "devnm", "evname", "deviceno", " devnames", "devicename", "divName", "deviceName", "evno", "Devname", "Devnm", "divname", "DevName", "devnames"], "device": ["package", "pod", "target", "attribute", "gpu", "object", "conn", "config", "option", "driver", "Device", "project", "mount", "mode", "connection", "de", "d", "display", "host", "node", "product", "devices", "buffer", "path", "model", "custom", "address", "dev", "data", "serial", "component", "unit", "machine", "disk", "module", "cpu", "DA", "dc", "task", "di", "parent", "server", "ev"], "label": ["bind", "config", "val", "key", "cell", "path", "info", "address", "data", "link", "prefix", "field", "load", "alias", "dl", "test", "output", "col", "Label", "name", "ind", "ride", "driver", "text", "null", "style", "align", "node", "description", "unit", "code", "title", "brand", "channel", "desc", " labels", "abel", "li", "summary", "err", "ref", " Label", "model", "new", "comment", "el", "module", "error", "call", "mark", "length", "loc", "group", "note", "layout", "display", "bridge", "bl", "lab", "diff", "frame", "hide", "tex", "session", "len", "console", "border", "block", "value"], "bus_opts": ["bus_ops", "bus_optpt", "bus_operments", "bus_optents", "bus_opte", "bus___optd", "bus_cht", "bus_OPte", "bus_optte", "bus_OPents", "bus_optd", "bus_optts", "bus_operte", "bus___opts", "bus_optments", "bus_opments", "bus_OPts", "bus_OPments", "bus_opt", "bus_optt", "bus_opers", "bus_opents", "bus_chts", "bus_chpt", "bus___opt", "bus_oppt", "bus_chtd", "bus_operts", "bus___oppt", "bus_OPt", "bus_opttd", "bus_opert", "bus_OPs"], "dev_opts": ["dev_OPter", "dev_OPps", "dev_coptr", "dev_hopt", "dev_OPts", "dev_copts", "dev_appTS", "dev_ims", "dev_popps", "dev_optter", "dev_popt", "dev_optts", "dev_OPt", "dev_apptes", "dev_appt", "dev_optes", "dev_poptr", "dev_operts", "dev_imts", "dev_opcs", "dev_imt", "dev_popts", "dev_hoptes", "dev_opter", "dev_optr", "dev_opTS", "dev_OPtes", "dev_OPcs", "dev_optt", "dev_OPs", "dev_optcs", "dev_OPtr", "dev_OPTS", "dev_opert", "dev_hopts", "dev_operter", "dev_imcs", "dev_copps", "dev_hopTS", "dev_ops", "dev_opers", "dev_opps", "dev_copt", "dev_appts", "dev_opt"], "index": ["route", "i", "name", "ix", "end", "level", "ind", "option", "config", "valid", "pattern", "loop", "input", "part", "inc", "key", "connection", "column", "pos", "ion", "section", "axis", "address", "ini", "size", "version", "current", "diff", "number", "count", "find", "body", "prefix", "comment", "condition", "Index", "code", "localhost", "num", "search", "match", "form", "x", "value", "date", "point", "error", "length", "slice", "len", "test", "page", "loc", "element", "insert", "update", "append", "pointer", "ticket", "instance", "image", "position", "offset", "output", "action", "type"]}}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);\n\n    VirtQueueElement elem;\n\n    MemoryRegionSection section;\n\n\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        size_t offset = 0;\n\n        uint32_t pfn;\n\n\n\n        while (iov_to_buf(elem.out_sg, elem.out_num, offset, &pfn, 4) == 4) {\n\n            ram_addr_t pa;\n\n            ram_addr_t addr;\n\n            int p = virtio_ldl_p(vdev, &pfn);\n\n\n\n            pa = (ram_addr_t) p << VIRTIO_BALLOON_PFN_SHIFT;\n\n            offset += 4;\n\n\n\n            /* FIXME: remove get_system_memory(), but how? */\n\n            section = memory_region_find(get_system_memory(), pa, 1);\n\n            if (!int128_nz(section.size) || !memory_region_is_ram(section.mr))\n\n                continue;\n\n\n\n            trace_virtio_balloon_handle_output(memory_region_name(section.mr),\n\n                                               pa);\n\n            /* Using memory_region_get_ram_ptr is bending the rules a bit, but\n\n               should be OK because we only want a single page.  */\n\n            addr = section.offset_within_region;\n\n            balloon_page(memory_region_get_ram_ptr(section.mr) + addr,\n\n                         !!(vq == s->dvq));\n\n            memory_region_unref(section.mr);\n\n        }\n\n\n\n        virtqueue_push(vq, &elem, offset);\n\n        virtio_notify(vdev, vq);\n\n    }\n\n}\n", "idx": 18351, "substitutes": {"vdev": ["ldev", "vdd", "Vnd", "Vq", "Vdevice", "svtr", "vdi", "svq", " vtr", " vdef", "Vgd", "Vconf", "Vdd", " vnd", "svdef", "verev", "verdi", "svdd", "ltr", "vev", "svdev", " vdi", " vconf", "Vdev", "svgd", "vtr", "vnd", " vdevice", "svconf", " vgd", "svdevice", "vgd", "verdevice", "svnd", "Vdi", "ldevice", "vdef", "vdevice", "verdev", " vev", " vdd", "ldef", "Vev", "vconf"], "vq": ["mQ", " vk", "mquest", "Vq", "Vw", "vg", "enq", "wQ", "svq", " viq", " vqu", "tvq", " vw", "wg", "svg", "viewk", "tvw", "enque", " vQ", "svk", "wdev", "svque", "tvqu", "viewq", "hq", " vg", "viq", "qquest", "eng", " vqt", "qquery", "qQ", " vque", "mq", "vk", "hdev", "vqu", "hg", "vque", "viewiq", "VQ", " vquest", "vqt", "tvQ", "wq", "vquest", "qq", "vw", "sviq", "hQ", "vQ", " vquery", "enqt", "Vqu", "viewque", "vquery", "mquery", "svqt"], "s": ["spec", "m", "session", "t", "uns", "aws", "f", "conf", "services", "r", "service", "n", "sb", "g", "ss", "ls", "ops", "self", "o", "cs", "d", "su", "sh", "ins", "w", "e", "sc", "ses", "v", "c", "ps", "p", "S", "b", "gs", "params", "sys", "storage", "os", "state", "server", "states", "sa"], "elem": ["Elev", "nelements", "elev", "pelem", "elete", " elee", "nelete", "Elem", "element", "eelems", "nelev", " elements", " elev", "Element", "eelement", "belems", "belem", "eelements", "belee", "eelev", "belement", "pelements", "eelete", "eelee", " elete", "elee", "pelement", "belements", " elems", "elems", "belev", "pelev", "eelem", "nelem", "elements", " element", "Elements"], "section": ["entry", "set", "ect", "shadow", " replacement", "element", "child", "comment", "service", "region", "sec", "location", "piece", " intersection", "large", "config", "protection", "test", "area", "sa", "ion", "part", "j", "sect", "search", "division", "mission", "sector", "description", " component", "definition", "size", "sub", " part", "key", "sc", "lc", "parent", "patch", " parent", "ment", " structure", "ec", "row", "connection", " option", "port", "instance", " extension", "vision", "view", "iner", "script", "block", "sections", "loc", "function", "page", "array", "line", "address", "ace", "character", " segment", "session", "group", "small", "esc", "Section", "pe", "option", "module", "setting", "tag", "member", "ray", " address", "step", "ler", "e", " sec", "form", "storage", "sign", "se", "server"], "pfn": ["pnm", "ppfn", "pfd", " pfd", "vpnm", "bpfen", "pkn", "spfp", "spfn", "pfl", "tpfn", "bpfl", " pbn", "tpkn", "ppfl", "spbn", " pnm", "Pfn", "pbn", "vpfn", " pkn", "vpfp", " pfp", " pfl", "tpfp", "ppfd", " pfen", "bpfn", "ppfen", "bpfd", "tpbn", "pfp", "Pfp", "pfen", "Pnm", "spkn"], "pa": ["pc", "offset", "fp", "jp", "ref", "ara", "pn", "pe", "ai", "fa", "PA", "apa", "sb", "oa", "cp", "Pa", "lp", "pb", "pai", "ba", "pointer", " Pa", "po", "ca", "appa", "ta", "ota", "ista", "pi", "pre", "prefix", "tta", " PA", "si", "qa", "p", "address", "area", "ppa", "pr", "wa", "api", "ia", "opa", "pu", "ma", "ha", "port", "sa"], "addr": ["pc", "part", "au", "offset", "x", "base", "ref", "conn", "fe", "r", "rc", "rt", "coord", "align", "ar", "hop", "arm", "cp", "loc", "oa", "ptr", "pos", "byte", "pointer", "ip", "xp", "nm", "store", "layer", "alias", "nr", "ad", "asm", "ag", "seq", "afi", "qa", "p", "pad", "address", "area", "url", "adr", "route", "wa", "ace", "ha", "edge", "port", "eni", "attr", "ady", "amp"]}}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static void *ff_avio_child_next(void *obj, void *prev)\n\n{\n\n    AVIOContext *s = obj;\n\n    AVIOInternal *internal = s->opaque;\n\n    return prev ? NULL : internal->h;\n\n}\n", "idx": 13969, "substitutes": {"obj": ["self", "pkg", "tmp", "sync", "jp", "i", "object", "inf", "api", "os", "ref", "init", "js", "scope", "Obj", "o", "lib", "open", "p", "rb", "img", "sb", "b", "op", "inst", "att", "ns", "cb", "nt", "objects", "attr", "ops", "coll", "cpp", "src", "opt", "ctx", "node"], "prev": ["upper", "proc", "before", "self", "rev", "root", "after", "inter", "winner", "back", "orig", "pre", "original", "pres", "pred", "var", "request", "super", "rec", "Prev", "p", "info", "desc", "op", "result", "parent", "wp", "skip", "vious", "pper", "inc", "next", "first", "above", "counter", "reverse", "iter", "ep", "initial", "rel", "prefix", "cur", "post", "node"], "s": ["south", "sys", "ses", "self", "sg", "fs", "native", "private", "external", "object", "a", "api", "g", "S", "os", "h", "sr", "sq", "v", "storage", "ss", "o", "p", "sf", "sb", "n", "f", "c", "ns", "single", "inner", "sn", "ssl", "sv", "sl", "ops", "r", "ds"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt)\n\n{\n\n    const char *opn = \"loongson_cp2\";\n\n    uint32_t opc, shift_max;\n\n    TCGv_i64 t0, t1;\n\n\n\n    opc = MASK_LMI(ctx->opcode);\n\n    switch (opc) {\n\n    case OPC_ADD_CP2:\n\n    case OPC_SUB_CP2:\n\n    case OPC_DADD_CP2:\n\n    case OPC_DSUB_CP2:\n\n        t0 = tcg_temp_local_new_i64();\n\n        t1 = tcg_temp_local_new_i64();\n\n        break;\n\n    default:\n\n        t0 = tcg_temp_new_i64();\n\n        t1 = tcg_temp_new_i64();\n\n        break;\n\n    }\n\n\n\n    gen_load_fpr64(ctx, t0, rs);\n\n    gen_load_fpr64(ctx, t1, rt);\n\n\n\n#define LMI_HELPER(UP, LO) \\\n\n    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break\n\n#define LMI_HELPER_1(UP, LO) \\\n\n    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break\n\n#define LMI_DIRECT(UP, LO, OP) \\\n\n    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break\n\n\n\n    switch (opc) {\n\n    LMI_HELPER(PADDSH, paddsh);\n\n    LMI_HELPER(PADDUSH, paddush);\n\n    LMI_HELPER(PADDH, paddh);\n\n    LMI_HELPER(PADDW, paddw);\n\n    LMI_HELPER(PADDSB, paddsb);\n\n    LMI_HELPER(PADDUSB, paddusb);\n\n    LMI_HELPER(PADDB, paddb);\n\n\n\n    LMI_HELPER(PSUBSH, psubsh);\n\n    LMI_HELPER(PSUBUSH, psubush);\n\n    LMI_HELPER(PSUBH, psubh);\n\n    LMI_HELPER(PSUBW, psubw);\n\n    LMI_HELPER(PSUBSB, psubsb);\n\n    LMI_HELPER(PSUBUSB, psubusb);\n\n    LMI_HELPER(PSUBB, psubb);\n\n\n\n    LMI_HELPER(PSHUFH, pshufh);\n\n    LMI_HELPER(PACKSSWH, packsswh);\n\n    LMI_HELPER(PACKSSHB, packsshb);\n\n    LMI_HELPER(PACKUSHB, packushb);\n\n\n\n    LMI_HELPER(PUNPCKLHW, punpcklhw);\n\n    LMI_HELPER(PUNPCKHHW, punpckhhw);\n\n    LMI_HELPER(PUNPCKLBH, punpcklbh);\n\n    LMI_HELPER(PUNPCKHBH, punpckhbh);\n\n    LMI_HELPER(PUNPCKLWD, punpcklwd);\n\n    LMI_HELPER(PUNPCKHWD, punpckhwd);\n\n\n\n    LMI_HELPER(PAVGH, pavgh);\n\n    LMI_HELPER(PAVGB, pavgb);\n\n    LMI_HELPER(PMAXSH, pmaxsh);\n\n    LMI_HELPER(PMINSH, pminsh);\n\n    LMI_HELPER(PMAXUB, pmaxub);\n\n    LMI_HELPER(PMINUB, pminub);\n\n\n\n    LMI_HELPER(PCMPEQW, pcmpeqw);\n\n    LMI_HELPER(PCMPGTW, pcmpgtw);\n\n    LMI_HELPER(PCMPEQH, pcmpeqh);\n\n    LMI_HELPER(PCMPGTH, pcmpgth);\n\n    LMI_HELPER(PCMPEQB, pcmpeqb);\n\n    LMI_HELPER(PCMPGTB, pcmpgtb);\n\n\n\n    LMI_HELPER(PSLLW, psllw);\n\n    LMI_HELPER(PSLLH, psllh);\n\n    LMI_HELPER(PSRLW, psrlw);\n\n    LMI_HELPER(PSRLH, psrlh);\n\n    LMI_HELPER(PSRAW, psraw);\n\n    LMI_HELPER(PSRAH, psrah);\n\n\n\n    LMI_HELPER(PMULLH, pmullh);\n\n    LMI_HELPER(PMULHH, pmulhh);\n\n    LMI_HELPER(PMULHUH, pmulhuh);\n\n    LMI_HELPER(PMADDHW, pmaddhw);\n\n\n\n    LMI_HELPER(PASUBUB, pasubub);\n\n    LMI_HELPER_1(BIADD, biadd);\n\n    LMI_HELPER_1(PMOVMSKB, pmovmskb);\n\n\n\n    LMI_DIRECT(PADDD, paddd, add);\n\n    LMI_DIRECT(PSUBD, psubd, sub);\n\n    LMI_DIRECT(XOR_CP2, xor, xor);\n\n    LMI_DIRECT(NOR_CP2, nor, nor);\n\n    LMI_DIRECT(AND_CP2, and, and);\n\n    LMI_DIRECT(PANDN, pandn, andc);\n\n    LMI_DIRECT(OR, or, or);\n\n\n\n    case OPC_PINSRH_0:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 0, 16);\n\n        opn = \"pinsrh_0\";\n\n        break;\n\n    case OPC_PINSRH_1:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 16, 16);\n\n        opn = \"pinsrh_1\";\n\n        break;\n\n    case OPC_PINSRH_2:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 32, 16);\n\n        opn = \"pinsrh_2\";\n\n        break;\n\n    case OPC_PINSRH_3:\n\n        tcg_gen_deposit_i64(t0, t0, t1, 48, 16);\n\n        opn = \"pinsrh_3\";\n\n        break;\n\n\n\n    case OPC_PEXTRH:\n\n        tcg_gen_andi_i64(t1, t1, 3);\n\n        tcg_gen_shli_i64(t1, t1, 4);\n\n        tcg_gen_shr_i64(t0, t0, t1);\n\n        tcg_gen_ext16u_i64(t0, t0);\n\n        opn = \"pextrh\";\n\n        break;\n\n\n\n    case OPC_ADDU_CP2:\n\n        tcg_gen_add_i64(t0, t0, t1);\n\n        tcg_gen_ext32s_i64(t0, t0);\n\n        opn = \"addu\";\n\n        break;\n\n    case OPC_SUBU_CP2:\n\n        tcg_gen_sub_i64(t0, t0, t1);\n\n        tcg_gen_ext32s_i64(t0, t0);\n\n        opn = \"addu\";\n\n        break;\n\n\n\n    case OPC_SLL_CP2:\n\n        opn = \"sll\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_SRL_CP2:\n\n        opn = \"srl\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_SRA_CP2:\n\n        opn = \"sra\";\n\n        shift_max = 32;\n\n        goto do_shift;\n\n    case OPC_DSLL_CP2:\n\n        opn = \"dsll\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    case OPC_DSRL_CP2:\n\n        opn = \"dsrl\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    case OPC_DSRA_CP2:\n\n        opn = \"dsra\";\n\n        shift_max = 64;\n\n        goto do_shift;\n\n    do_shift:\n\n        /* Make sure shift count isn't TCG undefined behaviour.  */\n\n        tcg_gen_andi_i64(t1, t1, shift_max - 1);\n\n\n\n        switch (opc) {\n\n        case OPC_SLL_CP2:\n\n        case OPC_DSLL_CP2:\n\n            tcg_gen_shl_i64(t0, t0, t1);\n\n            break;\n\n        case OPC_SRA_CP2:\n\n        case OPC_DSRA_CP2:\n\n            /* Since SRA is UndefinedResult without sign-extended inputs,\n\n               we can treat SRA and DSRA the same.  */\n\n            tcg_gen_sar_i64(t0, t0, t1);\n\n            break;\n\n        case OPC_SRL_CP2:\n\n            /* We want to shift in zeros for SRL; zero-extend first.  */\n\n            tcg_gen_ext32u_i64(t0, t0);\n\n            /* FALLTHRU */\n\n        case OPC_DSRL_CP2:\n\n            tcg_gen_shr_i64(t0, t0, t1);\n\n            break;\n\n        }\n\n\n\n        if (shift_max == 32) {\n\n            tcg_gen_ext32s_i64(t0, t0);\n\n        }\n\n\n\n        /* Shifts larger than MAX produce zero.  */\n\n        tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max);\n\n        tcg_gen_neg_i64(t1, t1);\n\n        tcg_gen_and_i64(t0, t0, t1);\n\n        break;\n\n\n\n    case OPC_ADD_CP2:\n\n    case OPC_DADD_CP2:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            int lab = gen_new_label();\n\n\n\n            tcg_gen_mov_i64(t2, t0);\n\n            tcg_gen_add_i64(t0, t1, t2);\n\n            if (opc == OPC_ADD_CP2) {\n\n                tcg_gen_ext32s_i64(t0, t0);\n\n            }\n\n            tcg_gen_xor_i64(t1, t1, t2);\n\n            tcg_gen_xor_i64(t2, t2, t0);\n\n            tcg_gen_andc_i64(t1, t2, t1);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(lab);\n\n\n\n            opn = (opc == OPC_ADD_CP2 ? \"add\" : \"dadd\");\n\n            break;\n\n        }\n\n\n\n    case OPC_SUB_CP2:\n\n    case OPC_DSUB_CP2:\n\n        {\n\n            TCGv_i64 t2 = tcg_temp_new_i64();\n\n            int lab = gen_new_label();\n\n\n\n            tcg_gen_mov_i64(t2, t0);\n\n            tcg_gen_sub_i64(t0, t1, t2);\n\n            if (opc == OPC_SUB_CP2) {\n\n                tcg_gen_ext32s_i64(t0, t0);\n\n            }\n\n            tcg_gen_xor_i64(t1, t1, t2);\n\n            tcg_gen_xor_i64(t2, t2, t0);\n\n            tcg_gen_and_i64(t1, t1, t2);\n\n            tcg_temp_free_i64(t2);\n\n            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);\n\n            generate_exception(ctx, EXCP_OVERFLOW);\n\n            gen_set_label(lab);\n\n\n\n            opn = (opc == OPC_SUB_CP2 ? \"sub\" : \"dsub\");\n\n            break;\n\n        }\n\n\n\n    case OPC_PMULUW:\n\n        tcg_gen_ext32u_i64(t0, t0);\n\n        tcg_gen_ext32u_i64(t1, t1);\n\n        tcg_gen_mul_i64(t0, t0, t1);\n\n        opn = \"pmuluw\";\n\n        break;\n\n\n\n    case OPC_SEQU_CP2:\n\n    case OPC_SEQ_CP2:\n\n    case OPC_SLTU_CP2:\n\n    case OPC_SLT_CP2:\n\n    case OPC_SLEU_CP2:\n\n    case OPC_SLE_CP2:\n\n        /* ??? Document is unclear: Set FCC[CC].  Does that mean the\n\n           FD field is the CC field?  */\n\n    default:\n\n        MIPS_INVAL(opn);\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n\n\n#undef LMI_HELPER\n\n#undef LMI_DIRECT\n\n\n\n    gen_store_fpr64(ctx, t0, rd);\n\n\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s, %s\", opn,\n\n               fregnames[rd], fregnames[rs], fregnames[rt]);\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i64(t1);\n\n}\n", "idx": 2818, "substitutes": {"ctx": ["cm", "cms", " cx", "cli", "cam", "cs", "kb", "hw", "conn", "context", "cc", "txt", "Context", "loc", "tk", "ck", "nc", "bc", "cci", "tc", "grad", "cas", "comp", "ux", "fp", "tx", "sync", "cb", "coll", "kt", "kw", "ch", "config", "progress", "dc", "pkg", "c", "cv", "xc", "scl", "sc", "ctrl", "sq", "jp", "exec", "ca", "cmd", "vc", "obj", "wcs", "cca", "lib", "qa", "cmp", "cf", "conv", "ci", " context", "sci", "qq", "rc"], "rd": ["ld", "dd", "cc", "rw", "mc", "cl", "rr", "ru", "nc", "lr", "rf", "Rs", "rb", "ri", "hr", "cr", "st", "dc", "rl", "std", "rx", "nd", "rc"], "rs": ["rg", "src", "cs", "ops", "ries", "eps", "r", "ru", "ins", "ims", "lr", "resses", "Rs", "rb", "params", "ls", "ra", "ars", "xs", "ras", "cr", "RS", "ds", "ps", "ns", "pr", "sw", "vers", "rl", "rows", "rics", "sr", "s", "ubs", "mr", "cmp", "ks", "addr", "hs", "res", "rc"], "rt": ["rot", "dr", "ret", "mt", "q", "vt", "rw", "rn", "r", "rr", "ct", "ru", "rec", "rf", "adr", "rb", "ri", "ls", "ac", "nt", "fr", "ras", "RT", "pr", "ptr", "rl", "ref", "rm", "sr", "b", "t", "rx", "req", "addr", "vr", "pt", "rh", "rc"], "opn": [" oprn", " opns", " opcn", "Opf", "optn", "optns", "optc", "hopn", "optf", "oprn", "OPc", " opb", "OPn", "opcn", "Opb", "optconn", " opconn", "hopconn", "opf", "optr", "OPr", "Opc", "hopcn", " opr", "Opn", "opern", "hopc", "opns", " opf", "opb", "opr", "optrn", "optcn", "opconn", "OPrn", "operns", "operc", "optb"], "opc": ["ropcs", " opcode", "optn", "toolc", " opci", "optc", "hopn", "optf", "OPc", "copcode", "OPn", "copc", "toolC", "optci", "opcode", "ropn", "OPf", "opf", "tooln", "OPcode", "hopf", " opC", "OPC", "hopci", "copn", "opci", "hopc", "optcs", "ropc", "optcode", "opcs", " opf", "toolf", "copf", "ropcode", " opcs", "opC"], "shift_max": ["push_min", "push_max", "push_right", "push_MAX", "shift_right", "shift_MAX", "shift_min"], "t0": ["ta2", "ty00", "tikg", "t4", "f1", "p25", "ti0", "ta50", "T50", "p4", "fkg", "ti1", "wt1", "ty50", "T2", "ta0", "p1", "f2", "t00", "tkg", "T0", "ty2", "t2", "p50", "t25", "p0", "wt25", "t50", "ty0", "wt0", "f0", "T4", "wt50", " t50", " t4", " t2", "p2", "Tkg", "ta00", "T25", " t00", "ti2", "T1"], "t1": ["st91", "t4", "Tb", "ty6", " t80", "tie1", "otONE", "ty91", "p4", "tb", "T2", "p1", "pb", "st1", "t91", "T0", "t2", "tie91", "tie80", "te6", "p0", "teONE", "te91", "st80", "T4", "ot1", "t6", "t80", "tyONE", " t4", " t2", "p2", "tONE", "ot6", "ot91", "te1", "ty1", " t91", "T1", " tb"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "aio_compute_timeout(AioContext *ctx)\n\n{\n\n    int64_t deadline;\n\n    int timeout = -1;\n\n    QEMUBH *bh;\n\n\n\n    for (bh = atomic_rcu_read(&ctx->first_bh); bh;\n\n         bh = atomic_rcu_read(&bh->next)) {\n\n        if (bh->scheduled) {\n\n            if (bh->idle) {\n\n                /* idle bottom halves will be polled at least\n\n                 * every 10ms */\n\n                timeout = 10000000;\n\n            } else {\n\n                /* non-idle bottom halves will be executed\n\n                 * immediately */\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    deadline = timerlistgroup_deadline_ns(&ctx->tlg);\n\n    if (deadline == 0) {\n\n        return 0;\n\n    } else {\n\n        return qemu_soonest_timeout(timeout, deadline);\n\n    }\n\n}\n", "idx": 8296, "substitutes": {"deadline": [" deadlin", "hotline", "deadlined", "timeline", " deadLINE", "waitliner", "goldline", "deadLINE", "midline", "midlin", "Deadlin", "costlin", "midlined", "goldliner", "goldlin", "Deadbase", " deadbase", "deadlining", "timeLINE", "midliner", "waitzone", "deadlin", "deadbase", "timele", "hotle", "cmdliner", "DeadLINE", "deadzone", "costliner", "timelin", "waitle", "timebase", "timeliner", "goldlining", "timezone", "waitline", "hotzone", "Deadlining", "cmdlin", "Deadlined", "Deadline", "cmdline", "cmdlined", "deadliner", "costline", "deadle", "Deadliner", "hotliner", "costlining"], "bh": ["behavior", "hi", "ib", "sh", "ht", "bb", "timeout", "dh", "nb", "af", "ph", "abb", "bang", "hh", "conn", "bp", "src", "hab", "bm", "b", "adh", "fb", "batch", "work", "ref", "pb", "hm", "cb", "fp", "bo", "gh", "rb", "plug", "lr", "bc", "body", "bt", "zh", "bf", "ha", "bl", "bg", "sync", "HB", "aph", "ih", "ctx", "lb", "hp", "acl", "sb", "bi", "kh", "hub", "eth", "h", "hl", "hap", "ch", "ah", "br", "bs", "rh", "BT", "uh"]}}
{"project": "qemu", "commit_id": "eff235eb2bcd7092901f4698a7907e742f3b7f2f", "target": 1, "func": "static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,\n\n                            const DisasInsn *di)\n\n{\n\n    unsigned r2 = extract32(insn, 21, 5);\n\n    unsigned r1 = extract32(insn, 16, 5);\n\n    unsigned cf = extract32(insn, 12, 4);\n\n    unsigned rt = extract32(insn,  0, 5);\n\n    TCGv tcg_r1, tcg_r2;\n\n    ExitStatus ret;\n\n\n\n    if (cf) {\n\n        nullify_over(ctx);\n\n    }\n\n    tcg_r1 = load_gpr(ctx, r1);\n\n    tcg_r2 = load_gpr(ctx, r2);\n\n    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);\n\n    return nullify_end(ctx, ret);\n\n}\n", "idx": 9091, "substitutes": {"ctx": ["gd", "context", "cci", "cmp", "Context", "cca", "conn", "tc", "src", "que", "sci", "c", "cp", "config", "obj", "cu", "cli", "fp", "qa", "uci", "cf", "cb", "cn", "xs", "loc", "sq", "hw", "bc", "cs", "ctr", "cv", "scope", "sync", "rc", "connection", "cas", "voc", "req", "conv", "ga", "tx", "jp", "nas", "pc", "xc", "kw", "gru", "nc", "cfg", "ca", "cm", "rx", "ci", "vc", "anc", "cmd", "jc", "pkg", "lc", "cus", "kb", "exec"], "insn": ["rissn", "isinc", " insnl", "outsn", "insnt", "insN", "asp", "asn", "inne", "risn", " insns", "incb", "atsnl", "inn", "vinc", "outsnt", "risne", "isinnt", "linsner", "innt", "insc", "insns", "innl", "inp", "insne", "inc", "atsN", "insnl", "outsc", " insp", "incp", "inner", "linsne", "isinn", "outssn", "vinn", "insb", "inN", "asns", "atsp", "vinp", "linssn", " insN", "atsc", "incns", "asb", "incn", "inssn", "insp", "linsn", "atsn", "insner", "vinN", " insb", "isinsn", "risner"], "di": ["ani", "gu", "ui", "Di", "ds", "si", "adi", "zi", "da", "xi", "ini", "iri", "i", "DI", "uri", "cli", "uci", "du", "oci", "tti", "ai", "dat", "db", "gi", "ti", "mi", "ei", "vd", "bi", "pi", "dc", "andi", "ii", "idi", "cfg", "ci", "ni", "ri", "ki"], "tcg_r1": ["tcg_sr2", "tcg_rb", "tcg_m2", "tcg_srv", "tcg_lr2", "tcg_g0", "tcg_m1", "tcg_rv", "tcg_srb", "tcg_m0", "tcg_sr1", "tcg_R2", "tcg_r0", "tcg_lr0", "tcg_lr1", "tcg_R0", "tcg_lr11", "tcg_R1", "tcg_g2", "tcg_Rv", "tcg_g11", "tcg_Rb", "tcg_r11", "tcg_g1", "tcg_R11"], "tcg_r2": ["tcg_sr2", "tcg_rb", "tcg_rr2", "tcg_sr8", "tcg_hr2", "tcg_R82", "tcg_erb", "tcg_r82", "tcg_rr02", "tcg_sr82", "tcg_sr1", "tcg_R2", "tcg_hr8", "tcg_r02", "tcg_er1", "tcg_R1", "tcg_r8", "tcg_rr1", "tcg_hr82", "tcg_er2", "tcg_Rb", "tcg_R8", "tcg_R02", "tcg_hr1", "tcg_r4", "tcg_er4", "tcg_R4"], "ret": ["base", "tr", "alt", "val", "ry", "len", "def", "nt", "temp", "Ret", "ait", " Ret", "mem", "rec", "reply", "ref", "obj", "lit", "status", "reg", "rel", "final", "gt", "rets", "ut", "rt", "res", "bf", "det", "rc", "fun", "re", "gc", "sys", "RET", "cat", " RET", "result", "rev", "match", "ft", "resp", "mt", "fi", "success"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)\n\n{\n\n    uint8_t ret;\n\n\n\n    OMAP_8B_REG(addr);\n\n    cpu_physical_memory_read(addr, (void *) &ret, 1);\n\n    return ret;\n\n}\n", "idx": 5250, "substitutes": {"opaque": ["Opac", "ipaque", "ipcode", "opgate", "Opaque", "Opcode", "OPcode", "OPac", "Opgate", "ipgate", "opcode", "OPgate", "OPaque", "opac", "ipac"], "addr": ["address", "dr", "afi", "layer", "arm", "rt", "alt", "eth", "device", "config", "Address", "data", "alias", "inter", "ad", "ace", "mac", "offset", "add", "nr", "pc", "align", "byte", "code", "target", "error", "dc", "cmd", "hop", "p", "asm", "boot", "ptr", "pos", "pointer", "start", "node", "proc", "fd", "adr", "amd", "ref", "src", "reference", "host", "grad", "conn", "slot"], "ret": ["base", "flag", "reg", "rt", "mem", "id", "alt", "al", "eth", "nt", "value", "val", "data", "bit", "info", "reply", "valid", "db", " Ret", "lit", "ext", "arg", "res", "byte", "net", "def", "len", "code", "mt", "det", "sb", "arr", "RET", "result", "Ret", "re", "fun", "back", "gt", "success", "ref", "rets"]}}
{"project": "FFmpeg", "commit_id": "2fed05f53a881b64a02de7a324d67d8c029c6cf1", "target": 1, "func": "int ff_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        int r, g, b;\n\n\n\n        switch (pix_fmt) {\n\n        case AV_PIX_FMT_RGB8:\n\n            r = (i>>5    )*36;\n\n            g = ((i>>2)&7)*36;\n\n            b = (i&3     )*85;\n\n            break;\n\n        case AV_PIX_FMT_BGR8:\n\n            b = (i>>6    )*85;\n\n            g = ((i>>3)&7)*36;\n\n            r = (i&7     )*36;\n\n            break;\n\n        case AV_PIX_FMT_RGB4_BYTE:\n\n            r = (i>>3    )*255;\n\n            g = ((i>>1)&3)*85;\n\n            b = (i&1     )*255;\n\n            break;\n\n        case AV_PIX_FMT_BGR4_BYTE:\n\n            b = (i>>3    )*255;\n\n            g = ((i>>1)&3)*85;\n\n            r = (i&1     )*255;\n\n            break;\n\n        case AV_PIX_FMT_GRAY8:\n\n            r = b = g = i;\n\n            break;\n\n        default:\n\n            return AVERROR(EINVAL);\n\n        }\n\n        pal[i] = b + (g<<8) + (r<<16) + (0xFF<<24);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 9934, "substitutes": {"pal": ["conf", "area", "ee", "base", "scale", "span", "val", "in", "ph", "all", "pad", "phil", "pl", "panel", "pp", "data", "sum", "mask", "el", "ace", "cb", "pro", "pixel", "app", "style", "ette", "group", "pel", "py", "al", "align", "font", "cal", "Pal", "pod", "cel", "li", "bin", "cell", "ch", "ap", "face", "pin"], "pix_fmt": ["pix_Fmt", "pix_formformat", "pix_formmt", "pix_fMT", "pix_FMT", "pix_frMT", "pix_Fnt", "pix_fformat", "pix_frformat", "pix_formMT", "pix_formlt", "pix_Flt", "pix_lMT", "pix_frlt", "pix_llt", "pix_fnt", "pix_flt", "pix_Fformat", "pix_lmt", "pix_frmt", "pix_formnt", "pix_lnt"], "i": ["l", "is", "m", "t", "x", "z", "uri", "esi", "ie", "v", "phi", "abi", "ii", "ori", "ri", "fi", "oi", "si", "n", "id", "xi", "ami", "k", "c", "s", "e", "mu", "f", "j", "index", "slice", "ic", "bi", "u", "li", "ni", "anti", "hi", "di", "zi", "adi", "my", "yi", "cli", "mini", "eni", "ai", "o", "gi", "chi", "pi", "I", "iu", "ui", "it", "in", "info", "ini", "p", "isi", "ix", "multi", "mi", "ti", "ik", "qi", "idi", "ip", "ci", "api", "io", "y"], "r": ["l", "cr", "ru", "n", "hr", "w", "m", "fr", "bar", "rr", "k", "x", "gr", "d", "ra", "c", "s", "p", "e", "gb", "reg", "or", "rb", "rad", "rs", "q", "er", "f", "lr", "j", "o", "v", "R", "rc", "ar", "err", "nr", "ur", "u", "ro", "h", "re", "rg", "a", "y", "sr", "ri", "br", "rh", "rl", "range"], "g": ["l", "gu", "sg", "gd", "pg", "n", "w", "m", "go", "k", "x", "ang", "gm", "gr", "d", "mg", "gs", "c", "z", "s", "p", "e", "gb", "reg", "gp", "gh", "q", "group", "f", "gy", "G", "bg", "v", "ig", "og", "gi", "gg", "ga", "err", "u", "h", "rg", "vg", "ng", "ge", "y", "gen"], "b": ["l", "ib", "base", "bb", "n", "abb", "w", "m", "bp", "ba", "bar", "t", "k", "ab", "x", "z", "d", "wb", "c", "ad", "s", "fb", "p", "bd", "e", "cb", "gb", "B", "rb", "f", "bc", "be", "j", "o", "eb", "bl", "v", "bh", "reb", "lb", "ga", "bi", "sb", "ur", "u", "ob", "a", "bin", "y", "xb", "bs", "br", "mb"]}}
{"project": "qemu", "commit_id": "1eabfce6d53cb02066dbb0ac8471f8593ff24a24", "target": 0, "func": "static int kvm_get_msrs(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;\n\n    int ret, i;\n\n    uint64_t mtrr_top_bits;\n\n\n\n    kvm_msr_buf_reset(cpu);\n\n\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);\n\n    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);\n\n    kvm_msr_entry_add(cpu, MSR_PAT, 0);\n\n    if (has_msr_star) {\n\n        kvm_msr_entry_add(cpu, MSR_STAR, 0);\n\n    }\n\n    if (has_msr_hsave_pa) {\n\n        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);\n\n    }\n\n    if (has_msr_tsc_aux) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);\n\n    }\n\n    if (has_msr_tsc_adjust) {\n\n        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);\n\n    }\n\n    if (has_msr_tsc_deadline) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);\n\n    }\n\n    if (has_msr_misc_enable) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);\n\n    }\n\n    if (has_msr_smbase) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);\n\n    }\n\n    if (has_msr_feature_control) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);\n\n    }\n\n    if (has_msr_bndcfgs) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);\n\n    }\n\n    if (has_msr_xss) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);\n\n    }\n\n\n\n\n\n    if (!env->tsc_valid) {\n\n        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);\n\n        env->tsc_valid = !runstate_is_running();\n\n    }\n\n\n\n#ifdef TARGET_X86_64\n\n    if (lm_capable_kernel) {\n\n        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);\n\n        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);\n\n        kvm_msr_entry_add(cpu, MSR_FMASK, 0);\n\n        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);\n\n    }\n\n#endif\n\n    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);\n\n    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);\n\n    if (has_msr_async_pf_en) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);\n\n    }\n\n    if (has_msr_pv_eoi_en) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);\n\n    }\n\n    if (has_msr_kvm_steal_time) {\n\n        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);\n\n    }\n\n    if (has_msr_architectural_pmu) {\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);\n\n        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);\n\n        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);\n\n        }\n\n        for (i = 0; i < num_architectural_pmu_counters; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);\n\n            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);\n\n        }\n\n    }\n\n\n\n    if (env->mcg_cap) {\n\n        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);\n\n        if (has_msr_mcg_ext_ctl) {\n\n            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);\n\n        }\n\n        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);\n\n        }\n\n    }\n\n\n\n    if (has_msr_hv_hypercall) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);\n\n    }\n\n    if (has_msr_hv_vapic) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);\n\n    }\n\n    if (has_msr_hv_tsc) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);\n\n    }\n\n    if (has_msr_hv_crash) {\n\n        int j;\n\n\n\n        for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) {\n\n            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);\n\n        }\n\n    }\n\n    if (has_msr_hv_runtime) {\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);\n\n    }\n\n    if (cpu->hyperv_synic) {\n\n        uint32_t msr;\n\n\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);\n\n        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);\n\n        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {\n\n            kvm_msr_entry_add(cpu, msr, 0);\n\n        }\n\n    }\n\n    if (has_msr_hv_stimer) {\n\n        uint32_t msr;\n\n\n\n        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;\n\n             msr++) {\n\n            kvm_msr_entry_add(cpu, msr, 0);\n\n        }\n\n    }\n\n    if (has_msr_mtrr) {\n\n        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);\n\n        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);\n\n        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {\n\n            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);\n\n            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);\n\n        }\n\n    }\n\n\n\n    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    assert(ret == cpu->kvm_msr_buf->nmsrs);\n\n    /*\n\n     * MTRR masks: Each mask consists of 5 parts\n\n     * a  10..0: must be zero\n\n     * b  11   : valid bit\n\n     * c n-1.12: actual mask bits\n\n     * d  51..n: reserved must be zero\n\n     * e  63.52: reserved must be zero\n\n     *\n\n     * 'n' is the number of physical bits supported by the CPU and is\n\n     * apparently always <= 52.   We know our 'n' but don't know what\n\n     * the destinations 'n' is; it might be smaller, in which case\n\n     * it masks (c) on loading. It might be larger, in which case\n\n     * we fill 'd' so that d..c is consistent irrespetive of the 'n'\n\n     * we're migrating to.\n\n     */\n\n\n\n    if (cpu->fill_mtrr_mask) {\n\n        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);\n\n        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);\n\n        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);\n\n    } else {\n\n        mtrr_top_bits = 0;\n\n    }\n\n\n\n    for (i = 0; i < ret; i++) {\n\n        uint32_t index = msrs[i].index;\n\n        switch (index) {\n\n        case MSR_IA32_SYSENTER_CS:\n\n            env->sysenter_cs = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SYSENTER_ESP:\n\n            env->sysenter_esp = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SYSENTER_EIP:\n\n            env->sysenter_eip = msrs[i].data;\n\n            break;\n\n        case MSR_PAT:\n\n            env->pat = msrs[i].data;\n\n            break;\n\n        case MSR_STAR:\n\n            env->star = msrs[i].data;\n\n            break;\n\n#ifdef TARGET_X86_64\n\n        case MSR_CSTAR:\n\n            env->cstar = msrs[i].data;\n\n            break;\n\n        case MSR_KERNELGSBASE:\n\n            env->kernelgsbase = msrs[i].data;\n\n            break;\n\n        case MSR_FMASK:\n\n            env->fmask = msrs[i].data;\n\n            break;\n\n        case MSR_LSTAR:\n\n            env->lstar = msrs[i].data;\n\n            break;\n\n#endif\n\n        case MSR_IA32_TSC:\n\n            env->tsc = msrs[i].data;\n\n            break;\n\n        case MSR_TSC_AUX:\n\n            env->tsc_aux = msrs[i].data;\n\n            break;\n\n        case MSR_TSC_ADJUST:\n\n            env->tsc_adjust = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_TSCDEADLINE:\n\n            env->tsc_deadline = msrs[i].data;\n\n            break;\n\n        case MSR_VM_HSAVE_PA:\n\n            env->vm_hsave = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_SYSTEM_TIME:\n\n            env->system_time_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_WALL_CLOCK:\n\n            env->wall_clock_msr = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_STATUS:\n\n            env->mcg_status = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_CTL:\n\n            env->mcg_ctl = msrs[i].data;\n\n            break;\n\n        case MSR_MCG_EXT_CTL:\n\n            env->mcg_ext_ctl = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_MISC_ENABLE:\n\n            env->msr_ia32_misc_enable = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_SMBASE:\n\n            env->smbase = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_FEATURE_CONTROL:\n\n            env->msr_ia32_feature_control = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_BNDCFGS:\n\n            env->msr_bndcfgs = msrs[i].data;\n\n            break;\n\n        case MSR_IA32_XSS:\n\n            env->xss = msrs[i].data;\n\n            break;\n\n        default:\n\n            if (msrs[i].index >= MSR_MC0_CTL &&\n\n                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {\n\n                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;\n\n            }\n\n            break;\n\n        case MSR_KVM_ASYNC_PF_EN:\n\n            env->async_pf_en_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_PV_EOI_EN:\n\n            env->pv_eoi_en_msr = msrs[i].data;\n\n            break;\n\n        case MSR_KVM_STEAL_TIME:\n\n            env->steal_time_msr = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_FIXED_CTR_CTRL:\n\n            env->msr_fixed_ctr_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_CTRL:\n\n            env->msr_global_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_STATUS:\n\n            env->msr_global_status = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\n            env->msr_global_ovf_ctrl = msrs[i].data;\n\n            break;\n\n        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:\n\n            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;\n\n            break;\n\n        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:\n\n            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;\n\n            break;\n\n        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:\n\n            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_HYPERCALL:\n\n            env->msr_hv_hypercall = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_GUEST_OS_ID:\n\n            env->msr_hv_guest_os_id = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_APIC_ASSIST_PAGE:\n\n            env->msr_hv_vapic = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_REFERENCE_TSC:\n\n            env->msr_hv_tsc = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\n            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_VP_RUNTIME:\n\n            env->msr_hv_runtime = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SCONTROL:\n\n            env->msr_hv_synic_control = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SVERSION:\n\n            env->msr_hv_synic_version = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SIEFP:\n\n            env->msr_hv_synic_evt_page = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SIMP:\n\n            env->msr_hv_synic_msg_page = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\n            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_STIMER0_CONFIG:\n\n        case HV_X64_MSR_STIMER1_CONFIG:\n\n        case HV_X64_MSR_STIMER2_CONFIG:\n\n        case HV_X64_MSR_STIMER3_CONFIG:\n\n            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =\n\n                                msrs[i].data;\n\n            break;\n\n        case HV_X64_MSR_STIMER0_COUNT:\n\n        case HV_X64_MSR_STIMER1_COUNT:\n\n        case HV_X64_MSR_STIMER2_COUNT:\n\n        case HV_X64_MSR_STIMER3_COUNT:\n\n            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =\n\n                                msrs[i].data;\n\n            break;\n\n        case MSR_MTRRdefType:\n\n            env->mtrr_deftype = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix64K_00000:\n\n            env->mtrr_fixed[0] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix16K_80000:\n\n            env->mtrr_fixed[1] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix16K_A0000:\n\n            env->mtrr_fixed[2] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C0000:\n\n            env->mtrr_fixed[3] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_C8000:\n\n            env->mtrr_fixed[4] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D0000:\n\n            env->mtrr_fixed[5] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_D8000:\n\n            env->mtrr_fixed[6] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E0000:\n\n            env->mtrr_fixed[7] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_E8000:\n\n            env->mtrr_fixed[8] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F0000:\n\n            env->mtrr_fixed[9] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRfix4K_F8000:\n\n            env->mtrr_fixed[10] = msrs[i].data;\n\n            break;\n\n        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):\n\n            if (index & 1) {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |\n\n                                                               mtrr_top_bits;\n\n            } else {\n\n                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2053, "substitutes": {"cpu": ["ilo", "cli", "roc", "queue", "lb", "clock", "nc", "px", "CPU", "CP", "cu", "css", "linux", "cp", "fi", "login", "consumer", "prem", "mc", "nic", "ubuntu", "hu", "mac", "pkg", "lc", "core", "hp", "fc", "np", "uno", "ctx", "cpp", "chrom", "computer", "ck", "GPU", "boot", "instance", "kernel", "proxy", "proc", "pool", "c", "pu", "loader", "cache", "machine", "chip", "processor", "node", "uca", "net", "performance", "uc", "vm", "gpu", "intel", "uci", "platform", "android", "comp", "auc", "sync", "config", "bench", "cn", "exec", "pc", "cmp", " CPU", "product", "cfg", "que", "console", "rc"], "env": ["eu", "stage", "oa", "cli", "ext", "context", "visor", "environment", "global", "shell", "profile", "ea", "end", "enc", "ef", "eni", "pipe", "estate", "style", "err", "config", "ec", "exc", "Environment", "cv", "fg", "age", "e", "esp", "cap", "core", "conf", "skin", "gui", "viron", "en", "ev", "path", "cfg", "net", "agent", "console", "export", "desc", "energy"], "msrs": ["msRS", "mmRs", "Msrs", "mmRS", "msRs", "MsRs", "Msrd", "mmrs", "MsRS", " msRS", " msRs", "msrd", "mmrd", " msrd"], "ret": [" e", " len", " code", "res", " Ret", " pri", " reg", "k", " flag", "num", " RET", " resp", " result", "code", "nt", "Ret", " success", " res", "len", "f", " mem", " b", "val", " rc", "rc", "mem"], "i": ["li", "abi", "ni", "ii", "pi", "ui", "I", "n", "type", "uni", "id", "it", "k", "info", "ti", "slice", "ini", "index", "c", "phi", "p", "e", "f", "b", "ci", "init", "si"], "mtrr_top_bits": ["mtrr_top_bytes", "mtrr_master_rows", "mtrr_master_bits", "mtrr_top_rows", "mtrr_top_count", "mtrr_master_count", "mtrr_master_bytes"]}}
{"project": "FFmpeg", "commit_id": "a744064c4155bde063b9e8a47699542be3b8e5eb", "target": 1, "func": "static void free_geotags(TiffContext *const s)\n\n{\n\n    int i;\n\n    for (i = 0; i < s->geotag_count; i++) {\n\n        if (s->geotags[i].val)\n\n            av_freep(&s->geotags[i].val);\n\n    }\n\n    av_freep(&s->geotags);\n\n\n}", "idx": 9598, "substitutes": {"s": ["conf", "styles", "sg", "ds", "si", "your", "sf", "features", "stats", "t", "ops", "d", "gs", "c", "p", "ls", "qs", "parts", "request", "xs", "rs", "sq", "js", "f", "args", "cs", "sym", "o", "sets", "shared", "S", "es", "sync", "sts", "cons", "services", "sup", "ans", "sb", "ns", "hs", "self", "sys", "params", "ses", "a", "options", "comments", "css", "ss", "fs", "settings", "ssl"], "i": ["count", "l", "oi", "hi", "ui", "di", "start", "si", "in", "zi", "key", "m", "id", "xi", "info", "b", "x", "ini", "d", "uli", "c", "ji", "p", "uri", "ix", "e", "yi", "mu", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "slice", "v", "gi", "ti", "phi", "r", "abi", "qi", "jp", "pi", "bi", "part", "ii", "init", "u", "I", "li", "ci", "a", "length", "io", "lc", "ri", "fi", "iu"]}}
{"project": "FFmpeg", "commit_id": "c83002a4f8042ccfa0688a9a18e8fa0369c1fda8", "target": 1, "func": "int ff_ass_split_override_codes(const ASSCodesCallbacks *callbacks, void *priv,\n\n                                const char *buf)\n\n{\n\n    const char *text = NULL;\n\n    char new_line[2];\n\n    int text_len = 0;\n\n\n\n    while (*buf) {\n\n        if (text && callbacks->text &&\n\n            (sscanf(buf, \"\\\\%1[nN]\", new_line) == 1 ||\n\n             !strncmp(buf, \"{\\\\\", 2))) {\n\n            callbacks->text(priv, text, text_len);\n\n            text = NULL;\n\n        }\n\n        if (sscanf(buf, \"\\\\%1[nN]\", new_line) == 1) {\n\n            if (callbacks->new_line)\n\n                callbacks->new_line(priv, new_line[0] == 'N');\n\n            buf += 2;\n\n        } else if (!strncmp(buf, \"{\\\\\", 2)) {\n\n            buf++;\n\n            while (*buf == '\\\\') {\n\n                char style[2], c[2], sep[2], c_num[2] = \"0\", tmp[128] = {0};\n\n                unsigned int color = 0xFFFFFFFF;\n\n                int len, size = -1, an = -1, alpha = -1;\n\n                int x1, y1, x2, y2, t1 = -1, t2 = -1;\n\n                if (sscanf(buf, \"\\\\%1[bisu]%1[01\\\\}]%n\", style, c, &len) > 1) {\n\n                    int close = c[0] == '0' ? 1 : c[0] == '1' ? 0 : -1;\n\n                    len += close != -1;\n\n                    if (callbacks->style)\n\n                        callbacks->style(priv, style[0], close);\n\n                } else if (sscanf(buf, \"\\\\c%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\c&H%X&%1[\\\\}]%n\", &color, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]c%1[\\\\}]%n\", c_num, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]c&H%X&%1[\\\\}]%n\", c_num, &color, sep, &len) > 2) {\n\n                    if (callbacks->color)\n\n                        callbacks->color(priv, color, c_num[0] - '0');\n\n                } else if (sscanf(buf, \"\\\\alpha%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\alpha&H%2X&%1[\\\\}]%n\", &alpha, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]a%1[\\\\}]%n\", c_num, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]a&H%2X&%1[\\\\}]%n\", c_num, &alpha, sep, &len) > 2) {\n\n                    if (callbacks->alpha)\n\n                        callbacks->alpha(priv, alpha, c_num[0] - '0');\n\n                } else if (sscanf(buf, \"\\\\fn%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\fn%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) {\n\n                    if (callbacks->font_name)\n\n                        callbacks->font_name(priv, tmp[0] ? tmp : NULL);\n\n                } else if (sscanf(buf, \"\\\\fs%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\fs%u%1[\\\\}]%n\", &size, sep, &len) > 1) {\n\n                    if (callbacks->font_size)\n\n                        callbacks->font_size(priv, size);\n\n                } else if (sscanf(buf, \"\\\\a%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\a%2u%1[\\\\}]%n\", &an, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\an%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\an%1u%1[\\\\}]%n\", &an, sep, &len) > 1) {\n\n                    if (an != -1 && buf[2] != 'n')\n\n                        an = (an&3) + (an&4 ? 6 : an&8 ? 3 : 0);\n\n                    if (callbacks->alignment)\n\n                        callbacks->alignment(priv, an);\n\n                } else if (sscanf(buf, \"\\\\r%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\r%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) {\n\n                    if (callbacks->cancel_overrides)\n\n                        callbacks->cancel_overrides(priv, tmp);\n\n                } else if (sscanf(buf, \"\\\\move(%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, sep, &len) > 4 ||\n\n                           sscanf(buf, \"\\\\move(%d,%d,%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, &t1, &t2, sep, &len) > 6) {\n\n                    if (callbacks->move)\n\n                        callbacks->move(priv, x1, y1, x2, y2, t1, t2);\n\n                } else if (sscanf(buf, \"\\\\pos(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) {\n\n                    if (callbacks->move)\n\n                        callbacks->move(priv, x1, y1, x1, y1, -1, -1);\n\n                } else if (sscanf(buf, \"\\\\org(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) {\n\n                    if (callbacks->origin)\n\n                        callbacks->origin(priv, x1, y1);\n\n                } else {\n\n                    len = strcspn(buf+1, \"\\\\}\") + 2;  /* skip unknown code */\n\n                }\n\n                buf += len - 1;\n\n            }\n\n            if (*buf++ != '}')\n\n                return AVERROR_INVALIDDATA;\n\n        } else {\n\n            if (!text) {\n\n                text = buf;\n\n                text_len = 1;\n\n            } else\n\n                text_len++;\n\n            buf++;\n\n        }\n\n    }\n\n    if (text && callbacks->text)\n\n        callbacks->text(priv, text, text_len);\n\n    if (callbacks->end)\n\n        callbacks->end(priv);\n\n    return 0;\n\n}\n", "idx": 26031, "substitutes": {"callbacks": [" callups", "callasts", "Callback", "Callacks", "allbacks", "Callevents", "callback", "callingbacks", "broadbacks", " callback", " callevents", "broadback", "Callasts", "calleners", "Callups", "playbacks", "defback", "callheads", "defasts", "callups", "callbooks", " callheads", "defbooks", " callacks", "allback", " callasts", " calleners", "callevents", "Callbooks", "callingbooks", "Calleners", "cacks", "callacks", "Callbacks", "broadeners", " callbooks", "cbacks", "allacks", "playacks", "playups", "defbacks", "cback", "callingevents", "Callheads", "cheads"], "priv": ["txt", "Priv", "rib", "uc", "info", "wb", "usr", "data", "doc", "rb", "config", "prop", "gb", "cur", "vt", "access", "pub", "bc", "prof", "reader", "ch", "cb", "debug", "ocr", "proc", "rw", "private", "pri", "options", "li", "password", "pb", "dev", "cer", "ctx", "cp", "fi", "ctr", "rc", "ptr", "req", "pred", "pdf", "buff", "pro", "cert", "conn", "func", "attr", "tty"], "buf": ["bag", "exc", "wb", "pkg", "lb", "Buff", "callback", "buffer", "cb", "bu", "url", "cmd", "lit", "coord", "cf", "ptr", "conv", "uu", "buff", "window", "fp", "ru", "comb", "b", "auc", "cv", "fam", "grab", "bb", "queue", "filename", "port", "proc", "feed", "pb", "cap", "ucc", "cache", "feat", "cas", "raf", "tc", "src", "plug", "func", "fd", "txt", "uf", "console", "uc", "usr", "context", "data", "rb", "ab", "bp", "profile", "brace", "paren", "box", "cp", "fi", "fb", "utf", "Buffer", "tab", "length", "rail", "uber", "seq", "job", "vec", "img", "cur", "br", "config", "bh", "vr", "aka", "bc", "prof", "aux", "home", "loc", "ctx", "ctr", "rc", "loop", "runner", "dest", "bt"], "text": ["txt", "code", "font", "class", "info", "editor", "name", "image", "data", "buffer", "config", "label", "br", "tx", "check", "letter", "prefix", "select", "type", "pass", "write", "form", "id", "num", "url", "method", "math", "feed", "password", "str", "path", "input", "start", "term", "contract", "lit", "object", "binary", "append", "word", "length", "ut", "buff", "translation", "username", "ext", "source", "comment", "value", "Text", "event", "content", "title", "connection", "TEXT", "format"], "new_line": ["new_page", "newoutline", "new_name", "new_list", "newNewlines", "newvline", " new_lines", "newouttext", " new_word", "old_lines", "new_word", "newvlen", "newptline", "new_column", "newNewline", "old_code", "old_line", " new_liner", "next_line", "old_column", "newnewword", "newvlines", "new_liner", "newNewlen", "newxline", "new_code", "newNewcode", "newnewliner", "New_time", "New_page", "newnewline", "newxlines", "newnewlines", "newjline", "newptlines", "next_name", "newjlist", "newoutlines", "newoutname", "new_lines", "new_time", "New_lines", "newptcolumn", "newjpage", "newjlines", "new_len", "next_text", "newptcode", "newxtext", "New_line", "old_page", "next_lines", "newvcode", "newxname", "old_len", "new_text", "old_list"], "text_len": ["ext_pos", "txt_len", "ext_lin", "text_length", "text_lin", "txt_pos", "txt_Len", "ext_Len", "ext_len", "txt_length", "text_pos", "text_Len"], "style": ["use", "font", "body", "k", "margin", "class", "z", "info", "sy", "ss", "p", "theme", "image", "data", "force", "Style", "py", "pe", "type", "error", "speed", "character", "ch", "shadow", "sync", "id", "css", "pad", "profile", "border", "script", "line", "link", "open", "span", "o", "li", "cl", "background", "start", "price", "session", "pattern", "lib", "offset", "si", "like", "ci", "size", "cp", "co", "length", "dot", "comment", "rule", "source", "color", "styles", "sl", "attr", "white", "tag", "sh"], "c": ["code", "k", "w", "z", "dc", "i", "p", "b", "toc", "cz", "cat", "C", "d", "cv", "ec", "config", "col", "ch", "e", "o", "cl", "ac", "s", "cc", "ctx", "ci", "cp", "size", "rc", "cache", "lc", "h", "f", "count", "y", "color", "n", "cu", "t", "csv", "v", "chart", "l", "cs", "ce", "g"], "sep": ["SEk", "aseg", "sem", " sept", "seph", "semmp", " sef", "preg", "semm", "cef", "SEpa", "spek", "sepp", "lem", "pref", " seg", "seg", "kemp", "ceg", "SEpt", "cep", "kep", "sepa", "cepa", "sek", "kem", "spept", "sef", "usepa", "useg", "kepa", "lepp", "sept", "prepa", "asepa", "speg", " sek", "prep", "asep", " seph", " sepa", "lep", "useph", "sempp", "usep", "kepp", "asept", "SEp", "spep", "kept", "SEg", "semp", "keg", "lemp", "SEph"], "c_num": ["cipid", "C_num", "lc_number", "cseqloc", "c_name", "c_number", "c__number", " c1num", "c_gen", "l_dom", "lc_loc", "cseqid", "c_loc", " c1number", "c1gen", "c__name", "c_id", "ciploc", "cipnumber", "C_nm", " c1gen", " c1n", "lc_num", "c1name", "c1dim", "C_number", "l_number", "C_name", "c1number", "l_num", "cseqnumber", "c1nm", "c_nm", "c__num", " c_number", "c_dim", "c1num", "c__nm", "l_dim", " c_n", " c_gen", "c_n", "lc_id", "c1dom", "c_dom", "cseqnum", "cipnum", "c1n"], "tmp": ["temp", "font", "margin", "z", "option", "toc", "pixel", "img", "rb", "config", "cb", "opt", "proc", "script", "span", "input", "output", "cp", "rc", "source", "tc", "cpp", "bg", "attr", "white", "border"], "len": ["seq", "fen", "fin", "bin", "z", "dy", "norm", "enc", "base", "en", "align", "type", "ler", "lon", "num", "pad", "depth", "line", "sp", "span", "Len", "li", "el", "err", "cap", "la", "lit", "loc", "l", "lib", "lin", "offset", "fl", "ann", "rev", "lang", "vert", "size", "scale", "ln", "fat", "length", "den", "lif", "count", "n", "limit", "alt", "lim", "sl", "pre", "pos", "val", "fun"], "x1": ["f3", "x3", "y3", " x3", "f1", "f2"], "y1": ["y0", "p4", "p0", "p2", "p1", "cy2", "x0", "y4", "x4", "cy0", "cy1", "cy4"], "x2": [" x0", "y0", "p0", " x6", "p2", "p1", "x6", "x0", "y6", "p6"], "y2": ["y0", "p4", "p0", "p2", "Y2", "p1", "x0", "x4", "Y0", "y4", "Y1", "Y4"]}}
{"project": "qemu", "commit_id": "fac7d7b1cdb21f921d7ac396365f5e920ef03096", "target": 1, "func": "int net_init_tap(const Netdev *netdev, const char *name,\n\n                 NetClientState *peer, Error **errp)\n\n{\n\n    const NetdevTapOptions *tap;\n\n    int fd, vnet_hdr = 0, i = 0, queues;\n\n    /* for the no-fd, no-helper case */\n\n    const char *script = NULL; /* suppress wrong \"uninit'd use\" gcc warning */\n\n    const char *downscript = NULL;\n\n    Error *err = NULL;\n\n    const char *vhostfdname;\n\n    char ifname[128];\n\n\n\n    assert(netdev->type == NET_CLIENT_DRIVER_TAP);\n\n    tap = &netdev->u.tap;\n\n    queues = tap->has_queues ? tap->queues : 1;\n\n    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;\n\n\n\n    /* QEMU vlans does not support multiqueue tap, in this case peer is set.\n\n     * For -netdev, peer is always NULL. */\n\n    if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) {\n\n        error_setg(errp, \"Multiqueue tap cannot be used with QEMU vlans\");\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_fds || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, fds=, and vhostfds= \"\n\n                       \"are invalid with fd=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = monitor_fd_param(cur_mon, tap->fd, &err);\n\n        if (fd == -1) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"tap\", name, NULL,\n\n                         script, downscript,\n\n                         vhostfdname, vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            return -1;\n\n        }\n\n    } else if (tap->has_fds) {\n\n        char **fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES);\n\n        int nfds, nvhosts;\n\n\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||\n\n            tap->has_vhostfd) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"helper=, queues=, and vhostfd= \"\n\n                       \"are invalid with fds=\");\n\n            return -1;\n\n        }\n\n\n\n        nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES);\n\n        if (tap->has_vhostfds) {\n\n            nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES);\n\n            if (nfds != nvhosts) {\n\n                error_setg(errp, \"The number of fds passed does not match \"\n\n                           \"the number of vhostfds passed\");\n\n                goto free_fail;\n\n            }\n\n        }\n\n\n\n        for (i = 0; i < nfds; i++) {\n\n            fd = monitor_fd_param(cur_mon, fds[i], &err);\n\n            if (fd == -1) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n\n\n            fcntl(fd, F_SETFL, O_NONBLOCK);\n\n\n\n            if (i == 0) {\n\n                vnet_hdr = tap_probe_vnet_hdr(fd);\n\n            } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) {\n\n                error_setg(errp,\n\n                           \"vnet_hdr not consistent across given tap fds\");\n\n                goto free_fail;\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             script, downscript,\n\n                             tap->has_vhostfds ? vhost_fds[i] : NULL,\n\n                             vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                goto free_fail;\n\n            }\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return 0;\n\n\n\nfree_fail:\n\n        for (i = 0; i < nfds; i++) {\n\n            g_free(fds[i]);\n\n            g_free(vhost_fds[i]);\n\n        }\n\n        g_free(fds);\n\n        g_free(vhost_fds);\n\n        return -1;\n\n    } else if (tap->has_helper) {\n\n        if (tap->has_ifname || tap->has_script || tap->has_downscript ||\n\n            tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) {\n\n            error_setg(errp, \"ifname=, script=, downscript=, vnet_hdr=, \"\n\n                       \"queues=, and vhostfds= are invalid with helper=\");\n\n            return -1;\n\n        }\n\n\n\n        fd = net_bridge_run_helper(tap->helper,\n\n                                   tap->has_br ?\n\n                                   tap->br : DEFAULT_BRIDGE_INTERFACE,\n\n                                   errp);\n\n        if (fd == -1) {\n\n            return -1;\n\n        }\n\n\n\n        fcntl(fd, F_SETFL, O_NONBLOCK);\n\n        vnet_hdr = tap_probe_vnet_hdr(fd);\n\n\n\n        net_init_tap_one(tap, peer, \"bridge\", name, ifname,\n\n                         script, downscript, vhostfdname,\n\n                         vnet_hdr, fd, &err);\n\n        if (err) {\n\n            error_propagate(errp, err);\n\n            close(fd);\n\n            return -1;\n\n        }\n\n    } else {\n\n        if (tap->has_vhostfds) {\n\n            error_setg(errp, \"vhostfds= is invalid if fds= wasn't specified\");\n\n            return -1;\n\n        }\n\n        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;\n\n        downscript = tap->has_downscript ? tap->downscript :\n\n            DEFAULT_NETWORK_DOWN_SCRIPT;\n\n\n\n        if (tap->has_ifname) {\n\n            pstrcpy(ifname, sizeof ifname, tap->ifname);\n\n        } else {\n\n            ifname[0] = '\\0';\n\n        }\n\n\n\n        for (i = 0; i < queues; i++) {\n\n            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? \"no\" : script,\n\n                              ifname, sizeof ifname, queues > 1, errp);\n\n            if (fd == -1) {\n\n                return -1;\n\n            }\n\n\n\n            if (queues > 1 && i == 0 && !tap->has_ifname) {\n\n                if (tap_fd_get_ifname(fd, ifname)) {\n\n                    error_setg(errp, \"Fail to get ifname\");\n\n                    close(fd);\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            net_init_tap_one(tap, peer, \"tap\", name, ifname,\n\n                             i >= 1 ? \"no\" : script,\n\n                             i >= 1 ? \"no\" : downscript,\n\n                             vhostfdname, vnet_hdr, fd, &err);\n\n            if (err) {\n\n                error_propagate(errp, err);\n\n                close(fd);\n\n                return -1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 338, "substitutes": {"netdev": [" netclient", "natdevice", "natdev", "networkconn", "netdevice", " netDev", "netdi", "etev", "etdi", "networkdevice", "nede", "netconn", " netconn", "netDev", "netclient", "netev", "neconn", "netde", "networkdev", "natclient", "tunDev", " netde", "etdev", " netev", "networkdi", "networkde", " netdi", "tundev", "networkev", " netdevice", "natDev", "nedev", "nedevice", "tunclient", "tundevice", "etdevice"], "name": ["call", "test", "server", "version", "time", "alias", "filename", "new", "n", "type", "id", "profile", "parent", "client", "package", "none", "code", "info", "names", "temp", "address", "description", "ip", "Name", "size", "cap", "username", "node", "comment", "amp", "connection", "nm", "prefix", "session", "path", "NAME", "nam", "family"], "peer": ["layer", "server", "trace", "channel", "conn", "device", "tg", "pe", "host", "type", "cur", "worker", "scope", "chain", "parent", "tc", "client", "remote", "shared", "instance", "package", "tp", "inner", "proc", "pipe", "snap", "er", "master", "pod", "request", "ep", "pointer", "pool", "owner", "pkg", "ip", "p", "state", "stack", "ptr", "self", "attr", "sys", "cache", "node", "pc", "trap", "fork", "socket", "port", "addr", "mode", "slave", "player", "root", "pp", "user", "ssl"], "errp": ["errorf", "errP", "rorpr", "erP", "erpc", "rrf", "rorr", "errorpc", "derp", "errpc", "orderr", "derpc", "orderpc", "rorp", "iterp", "rrP", "ErrorP", "erf", " errr", "acerpa", "Errorps", "Errorr", "erpa", " errps", " errP", "errr", "errps", "derr", "orderp", "rrl", "errl", "Errorp", " errpc", "acerpr", "acerp", "errorp", "derf", "erp", " errl", "iterf", "rorpa", "iterP", "errpr", " errf", "errorr", "erps", "errf", "errpa", "orderf", "acerr", "iterl", "erpr", "rrp"], "tap": ["submit", "this", "ppa", "dra", "tu", "ping", "tk", "tick", "sp", "pb", "wal", "pipe", "snap", "trip", "tr", "tin", "track", "jp", "mp", "trap", "ticket", "opa", "wp", "task", "wat", "pp", "flow", "tf", "ts", "tim", "wt", "ap", "api", "gap", "tw", "python", "pa", "p", "ptr", "php", "amp", "t", "session", "wa", "transform", "td", "pin", "np", "tool", "touch", "also", "trace", "skip", "tg", "pe", "apper", "hap", "di", "ta", "chat", "pod", "project", "atom", "tif", "pad", "setup", "cap", "app", "tm", "bp", "Tap", "hook", "enter", "each", "tip", "ga", "conn", "xml", "tc", "kin", "tp", "comb", "temp", "capt", "ten", "pc", "taker", "dat", "pot", "typ"], "fd": ["flow", "fc", "fun", " FD", "ld", "dn", "da", "ff", "bind", "fen", "dd", "pd", "fs", "FD", "sd", "xf", "fed", "dim", "fw", "fa", "dB", " f", "d", "xd", "dl", "lf", "fl", "ln", "fn", "wait", "buf", "seed", " df", "draft", "dy", "pipe", "fp", "sf", "df", "cb", "cond", "md", "pid", "dt", "ds", "bf", "fe", "dc", "writer", "fin", "len", "f", "ffff", "bd", " fid", "hd", "stream", "fat", "fx", "handler", "wd", "fm", "fee", "fb", "cf", "socket", "vd", "td", "nd", "ctl", "dir", "fi", "wat", "diff", "db"], "queues": ["queueures", "queueues", " queue", "Queues", "queueue", "Queures", "quries", " queries", "queue", "Queue", "peues", "quins", "qins", "peins", "queins", "qures", "queries", "quures", "queures", " queures", "qries", "qients", "quues", "quue", "queients", "peients", "quients", "peries", "ques", "que"], "script": ["test", "cli", "cript", "command", "scroll", "sh", "scope", "client", "secure", "code", "password", "sync", "tx", "slice", "document", "style", "sudo", "config", "func", " scripts", "writer", "setup", "draw", "sq", "sc", "exec", "scripts", "comment", "Script", "prefix", "lib", "seq", "fee", "sign", "session", "xxx", "init", "ctl", "inc", "ssl"], "downscript": ["DOWNexec", "DOWNScript", " downstyle", "upscript", "downScript", "downscripts", "upstyle", " downscripts", " downScript", "downstyle", "upScript", "upexec", "downexec", "DOWNstyle", "DOWNscripts", "upscripts", " downexec", "DOWNscript"], "err": ["dr", "ise", "icer", "rage", " er", "gr", "aaa", "Error", "rn", "wr", "rr", "r", "ver", "aa", " error", "der", "gz", "lr", "eor", "arr", "grad", "kr", "raise", "later", "rb", "nil", "nr", "er", "ir", "bug", "str", "oller", "fr", "cr", "runner", "rev", "exc", "result", "phy", "pr", "doc", "ler", "e", "order", "aster", "org", "rm", "resp", "orr", "range", "mr", "fee", "ev", "error", "acer", "req", "rar", "cf", "Er", "yer", "magic", "msg", "iter", "nor", "fi", "rh", "diff", "erer"], "vhostfdname": ["vHostfname", "vHostfdName", "vHostfdnumber", "vHostfdnam", "vHostFDnames", "vHostFDName", "vhostfno", "vHostfnames", "vHostfdno", "vhostFDname", "vhostdname", "vHostFDn", "vhostddname", "vhostdnumber", "vhostddn", "vhostfdnumber", "vhostFDno", "vhostfname", "vhostfdnam", "vHostFDname", "vhostFDnames", "vHostfdnames", "vhostfdnames", "vHostfdn", "vhostFDnam", "vhostfnames", "vhostdName", "vhostfdName", "vHostFDnumber", "vhostdfno", "vhostdn", "vhostddnumber", "vHostfdname", "vhostddnames", "vhostfnam", "vHostFDno", "vhostdno", "vHostfno", "vhostfdn", "vhostfdno", "vHostFDnam", "vhostdfnam", "vhostdfName", "vhostFDn", "vhostfName", "vhostFDnumber", "vhostFDName", "vhostdfname", "vHostfName", "vhostdnames"], "ifname": ["ifkey", "ifid", "ifn", "IFkey", "defid", "defkey", "IFid", "IFname", " ifn", "defname", "IFn", " ifid", " ifkey", "defn"], "fds": [" fded", "cfns", "cfds", "cfded", "fded", "hns", " fns", "cfcs", "hds", "fcs", "hded", " fcs", "fns", "hcs"], "vhost_fds": ["vhost_rfds", "vhost_hks", "vhost_rfns", "vhost_fns", "vhost_rfrs", "vhost_rfks", "vhost_hns", "vhost_fks", "vhost_hrs", "vhost_frs", "vhost_hds"], "nfds": ["_", "new", "r", "d", "id", "g", "proc", "func", "config", "function"], "i": ["cli", "ii", "sid", "pi", "I", "di", "n", "id", "iu", "slice", "ini", "index", "pid", "pointer", "ai", "ip", "ind", "c", "phi", "f", "ix", "uri", "ci", "io", "init", "si", "in", "xi"]}}
{"project": "qemu", "commit_id": "fb9fb692312a84ebc6e9c10da6f374c5871ff7b0", "target": 0, "func": "int cpu_exec(CPUState *env1)\n\n{\n\n#define DECLARE_HOST_REGS 1\n\n#include \"hostregs_helper.h\"\n\n    int ret, interrupt_request;\n\n    TranslationBlock *tb;\n\n    uint8_t *tc_ptr;\n\n    unsigned long next_tb;\n\n\n\n    if (cpu_halted(env1) == EXCP_HALTED)\n\n        return EXCP_HALTED;\n\n\n\n    cpu_single_env = env1;\n\n\n\n    /* first we save global registers */\n\n#define SAVE_HOST_REGS 1\n\n#include \"hostregs_helper.h\"\n\n    env = env1;\n\n\n\n#if defined(TARGET_I386)\n\n    /* put eflags in CPU temporary format */\n\n    CC_SRC = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n    DF = 1 - (2 * ((env->eflags >> 10) & 1));\n\n    CC_OP = CC_OP_EFLAGS;\n\n    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n#elif defined(TARGET_SPARC)\n\n#elif defined(TARGET_M68K)\n\n    env->cc_op = CC_OP_FLAGS;\n\n    env->cc_dest = env->sr & 0xf;\n\n    env->cc_x = (env->sr >> 4) & 1;\n\n#elif defined(TARGET_ALPHA)\n\n#elif defined(TARGET_ARM)\n\n#elif defined(TARGET_PPC)\n\n#elif defined(TARGET_MICROBLAZE)\n\n#elif defined(TARGET_MIPS)\n\n#elif defined(TARGET_SH4)\n\n#elif defined(TARGET_CRIS)\n\n#elif defined(TARGET_S390X)\n\n    /* XXXXX */\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n    env->exception_index = -1;\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    for(;;) {\n\n        if (setjmp(env->jmp_env) == 0) {\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n            /* if an exception is pending, we execute it here */\n\n            if (env->exception_index >= 0) {\n\n                if (env->exception_index >= EXCP_INTERRUPT) {\n\n                    /* exit request from the cpu execution loop */\n\n                    ret = env->exception_index;\n\n                    if (ret == EXCP_DEBUG)\n\n                        cpu_handle_debug_exception(env);\n\n                    break;\n\n                } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n                    /* if user mode only, we simulate a fake exception\n\n                       which will be handled outside the cpu execution\n\n                       loop */\n\n#if defined(TARGET_I386)\n\n                    do_interrupt_user(env->exception_index,\n\n                                      env->exception_is_int,\n\n                                      env->error_code,\n\n                                      env->exception_next_eip);\n\n                    /* successfully delivered */\n\n                    env->old_exception = -1;\n\n#endif\n\n                    ret = env->exception_index;\n\n                    break;\n\n#else\n\n#if defined(TARGET_I386)\n\n                    /* simulate a real cpu exception. On i386, it can\n\n                       trigger new exceptions, but we do not handle\n\n                       double or triple faults yet. */\n\n                    do_interrupt(env->exception_index,\n\n                                 env->exception_is_int,\n\n                                 env->error_code,\n\n                                 env->exception_next_eip, 0);\n\n                    /* successfully delivered */\n\n                    env->old_exception = -1;\n\n#elif defined(TARGET_PPC)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_MIPS)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_SPARC)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_ARM)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_SH4)\n\n\t\t    do_interrupt(env);\n\n#elif defined(TARGET_ALPHA)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_CRIS)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_M68K)\n\n                    do_interrupt(0);\n\n#endif\n\n                    env->exception_index = -1;\n\n#endif\n\n                }\n\n            }\n\n\n\n            if (kvm_enabled()) {\n\n                kvm_cpu_exec(env);\n\n                longjmp(env->jmp_env, 1);\n\n            }\n\n\n\n            next_tb = 0; /* force lookup of first TB */\n\n            for(;;) {\n\n                interrupt_request = env->interrupt_request;\n\n                if (unlikely(interrupt_request)) {\n\n                    if (unlikely(env->singlestep_enabled & SSTEP_NOIRQ)) {\n\n                        /* Mask out external interrupts for this step. */\n\n                        interrupt_request &= ~(CPU_INTERRUPT_HARD |\n\n                                               CPU_INTERRUPT_FIQ |\n\n                                               CPU_INTERRUPT_SMI |\n\n                                               CPU_INTERRUPT_NMI);\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n\n                        env->exception_index = EXCP_DEBUG;\n\n                        cpu_loop_exit();\n\n                    }\n\n#if defined(TARGET_ARM) || defined(TARGET_SPARC) || defined(TARGET_MIPS) || \\\n\n    defined(TARGET_PPC) || defined(TARGET_ALPHA) || defined(TARGET_CRIS) || \\\n\n    defined(TARGET_MICROBLAZE)\n\n                    if (interrupt_request & CPU_INTERRUPT_HALT) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_HALT;\n\n                        env->halted = 1;\n\n                        env->exception_index = EXCP_HLT;\n\n                        cpu_loop_exit();\n\n                    }\n\n#endif\n\n#if defined(TARGET_I386)\n\n                    if (interrupt_request & CPU_INTERRUPT_INIT) {\n\n                            svm_check_intercept(SVM_EXIT_INIT);\n\n                            do_cpu_init(env);\n\n                            env->exception_index = EXCP_HALTED;\n\n                            cpu_loop_exit();\n\n                    } else if (interrupt_request & CPU_INTERRUPT_SIPI) {\n\n                            do_cpu_sipi(env);\n\n                    } else if (env->hflags2 & HF2_GIF_MASK) {\n\n                        if ((interrupt_request & CPU_INTERRUPT_SMI) &&\n\n                            !(env->hflags & HF_SMM_MASK)) {\n\n                            svm_check_intercept(SVM_EXIT_SMI);\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_SMI;\n\n                            do_smm_enter();\n\n                            next_tb = 0;\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                                   !(env->hflags2 & HF2_NMI_MASK)) {\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_NMI;\n\n                            env->hflags2 |= HF2_NMI_MASK;\n\n                            do_interrupt(EXCP02_NMI, 0, 0, 0, 1);\n\n                            next_tb = 0;\n\n\t\t\t} else if (interrupt_request & CPU_INTERRUPT_MCE) {\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_MCE;\n\n                            do_interrupt(EXCP12_MCHK, 0, 0, 0, 0);\n\n                            next_tb = 0;\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                                   (((env->hflags2 & HF2_VINTR_MASK) && \n\n                                     (env->hflags2 & HF2_HIF_MASK)) ||\n\n                                    (!(env->hflags2 & HF2_VINTR_MASK) && \n\n                                     (env->eflags & IF_MASK && \n\n                                      !(env->hflags & HF_INHIBIT_IRQ_MASK))))) {\n\n                            int intno;\n\n                            svm_check_intercept(SVM_EXIT_INTR);\n\n                            env->interrupt_request &= ~(CPU_INTERRUPT_HARD | CPU_INTERRUPT_VIRQ);\n\n                            intno = cpu_get_pic_interrupt(env);\n\n                            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"Servicing hardware INT=0x%02x\\n\", intno);\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n                            do_interrupt(intno, 0, 0, 0, 1);\n\n                            /* ensure that no TB jump will be modified as\n\n                               the program flow was changed */\n\n                            next_tb = 0;\n\n#if !defined(CONFIG_USER_ONLY)\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_VIRQ) &&\n\n                                   (env->eflags & IF_MASK) && \n\n                                   !(env->hflags & HF_INHIBIT_IRQ_MASK)) {\n\n                            int intno;\n\n                            /* FIXME: this should respect TPR */\n\n                            svm_check_intercept(SVM_EXIT_VINTR);\n\n                            intno = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_vector));\n\n                            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"Servicing virtual hardware INT=0x%02x\\n\", intno);\n\n                            do_interrupt(intno, 0, 0, 0, 1);\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_VIRQ;\n\n                            next_tb = 0;\n\n#endif\n\n                        }\n\n                    }\n\n#elif defined(TARGET_PPC)\n\n#if 0\n\n                    if ((interrupt_request & CPU_INTERRUPT_RESET)) {\n\n                        cpu_reset(env);\n\n                    }\n\n#endif\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        ppc_hw_interrupt(env);\n\n                        if (env->pending_interrupts == 0)\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_HARD;\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    if ((interrupt_request & CPU_INTERRUPT_HARD)\n\n                        && (env->sregs[SR_MSR] & MSR_IE)\n\n                        && !(env->sregs[SR_MSR] & (MSR_EIP | MSR_BIP))\n\n                        && !(env->iflags & (D_FLAG | IMM_FLAG))) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_MIPS)\n\n                    if ((interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                        (env->CP0_Status & env->CP0_Cause & CP0Ca_IP_mask) &&\n\n                        (env->CP0_Status & (1 << CP0St_IE)) &&\n\n                        !(env->CP0_Status & (1 << CP0St_EXL)) &&\n\n                        !(env->CP0_Status & (1 << CP0St_ERL)) &&\n\n                        !(env->hflags & MIPS_HFLAG_DM)) {\n\n                        /* Raise it */\n\n                        env->exception_index = EXCP_EXT_INTERRUPT;\n\n                        env->error_code = 0;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_SPARC)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        if (cpu_interrupts_enabled(env) &&\n\n                            env->interrupt_index > 0) {\n\n                            int pil = env->interrupt_index & 0xf;\n\n                            int type = env->interrupt_index & 0xf0;\n\n\n\n                            if (((type == TT_EXTINT) &&\n\n                                  cpu_pil_allowed(env, pil)) ||\n\n                                  type != TT_EXTINT) {\n\n                                env->exception_index = env->interrupt_index;\n\n                                do_interrupt(env);\n\n                                next_tb = 0;\n\n                            }\n\n                        }\n\n\t\t    } else if (interrupt_request & CPU_INTERRUPT_TIMER) {\n\n\t\t\t//do_interrupt(0, 0, 0, 0, 0);\n\n\t\t\tenv->interrupt_request &= ~CPU_INTERRUPT_TIMER;\n\n\t\t    }\n\n#elif defined(TARGET_ARM)\n\n                    if (interrupt_request & CPU_INTERRUPT_FIQ\n\n                        && !(env->uncached_cpsr & CPSR_F)) {\n\n                        env->exception_index = EXCP_FIQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n                    /* ARMv7-M interrupt return works by loading a magic value\n\n                       into the PC.  On real hardware the load causes the\n\n                       return to occur.  The qemu implementation performs the\n\n                       jump normally, then does the exception return when the\n\n                       CPU tries to execute code at the magic address.\n\n                       This will cause the magic PC value to be pushed to\n\n                       the stack if an interrupt occured at the wrong time.\n\n                       We avoid this by disabling interrupts when\n\n                       pc contains a magic address.  */\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && ((IS_M(env) && env->regs[15] < 0xfffffff0)\n\n                            || !(env->uncached_cpsr & CPSR_I))) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_SH4)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_ALPHA)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_CRIS)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && (env->pregs[PR_CCS] & I_FLAG)) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_NMI\n\n                        && (env->pregs[PR_CCS] & M_FLAG)) {\n\n                        env->exception_index = EXCP_NMI;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_M68K)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && ((env->sr & SR_I) >> SR_I_SHIFT)\n\n                            < env->pending_level) {\n\n                        /* Real hardware gets the interrupt vector via an\n\n                           IACK cycle at this point.  Current emulated\n\n                           hardware doesn't rely on this, so we\n\n                           provide/save the vector when the interrupt is\n\n                           first signalled.  */\n\n                        env->exception_index = env->pending_vector;\n\n                        do_interrupt(1);\n\n                        next_tb = 0;\n\n                    }\n\n#endif\n\n                   /* Don't use the cached interupt_request value,\n\n                      do_interrupt may have updated the EXITTB flag. */\n\n                    if (env->interrupt_request & CPU_INTERRUPT_EXITTB) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n\n                        /* ensure that no TB jump will be modified as\n\n                           the program flow was changed */\n\n                        next_tb = 0;\n\n                    }\n\n                }\n\n                if (unlikely(env->exit_request)) {\n\n                    env->exit_request = 0;\n\n                    env->exception_index = EXCP_INTERRUPT;\n\n                    cpu_loop_exit();\n\n                }\n\n#ifdef CONFIG_DEBUG_EXEC\n\n                if (qemu_loglevel_mask(CPU_LOG_TB_CPU)) {\n\n                    /* restore flags in standard format */\n\n#if defined(TARGET_I386)\n\n                    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);\n\n                    log_cpu_state(env, X86_DUMP_CCOP);\n\n                    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n#elif defined(TARGET_ARM)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_SPARC)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_PPC)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_M68K)\n\n                    cpu_m68k_flush_flags(env, env->cc_op);\n\n                    env->cc_op = CC_OP_FLAGS;\n\n                    env->sr = (env->sr & 0xffe0)\n\n                              | env->cc_dest | (env->cc_x << 4);\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_MIPS)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_SH4)\n\n\t\t    log_cpu_state(env, 0);\n\n#elif defined(TARGET_ALPHA)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_CRIS)\n\n                    log_cpu_state(env, 0);\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n                }\n\n#endif\n\n                spin_lock(&tb_lock);\n\n                tb = tb_find_fast();\n\n                /* Note: we do it here to avoid a gcc bug on Mac OS X when\n\n                   doing it in tb_find_slow */\n\n                if (tb_invalidated_flag) {\n\n                    /* as some TB could have been invalidated because\n\n                       of memory exceptions while generating the code, we\n\n                       must recompute the hash index here */\n\n                    next_tb = 0;\n\n                    tb_invalidated_flag = 0;\n\n                }\n\n#ifdef CONFIG_DEBUG_EXEC\n\n                qemu_log_mask(CPU_LOG_EXEC, \"Trace 0x%08lx [\" TARGET_FMT_lx \"] %s\\n\",\n\n                             (long)tb->tc_ptr, tb->pc,\n\n                             lookup_symbol(tb->pc));\n\n#endif\n\n                /* see if we can patch the calling TB. When the TB\n\n                   spans two pages, we cannot safely do a direct\n\n                   jump. */\n\n                if (next_tb != 0 && tb->page_addr[1] == -1) {\n\n                    tb_add_jump((TranslationBlock *)(next_tb & ~3), next_tb & 3, tb);\n\n                }\n\n                spin_unlock(&tb_lock);\n\n\n\n                /* cpu_interrupt might be called while translating the\n\n                   TB, but before it is linked into a potentially\n\n                   infinite loop and becomes env->current_tb. Avoid\n\n                   starting execution if there is a pending interrupt. */\n\n                if (!unlikely (env->exit_request)) {\n\n                    env->current_tb = tb;\n\n                    tc_ptr = tb->tc_ptr;\n\n                /* execute the generated code */\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n                    next_tb = tcg_qemu_tb_exec(tc_ptr);\n\n                    env->current_tb = NULL;\n\n                    if ((next_tb & 3) == 2) {\n\n                        /* Instruction counter expired.  */\n\n                        int insns_left;\n\n                        tb = (TranslationBlock *)(long)(next_tb & ~3);\n\n                        /* Restore PC.  */\n\n                        cpu_pc_from_tb(env, tb);\n\n                        insns_left = env->icount_decr.u32;\n\n                        if (env->icount_extra && insns_left >= 0) {\n\n                            /* Refill decrementer and continue execution.  */\n\n                            env->icount_extra += insns_left;\n\n                            if (env->icount_extra > 0xffff) {\n\n                                insns_left = 0xffff;\n\n                            } else {\n\n                                insns_left = env->icount_extra;\n\n                            }\n\n                            env->icount_extra -= insns_left;\n\n                            env->icount_decr.u16.low = insns_left;\n\n                        } else {\n\n                            if (insns_left > 0) {\n\n                                /* Execute remaining instructions.  */\n\n                                cpu_exec_nocache(insns_left, tb);\n\n                            }\n\n                            env->exception_index = EXCP_INTERRUPT;\n\n                            next_tb = 0;\n\n                            cpu_loop_exit();\n\n                        }\n\n                    }\n\n                }\n\n                /* reset soft MMU for next block (it can currently\n\n                   only be set by a memory fault) */\n\n            } /* for(;;) */\n\n        }\n\n    } /* for(;;) */\n\n\n\n\n\n#if defined(TARGET_I386)\n\n    /* restore flags in standard format */\n\n    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);\n\n#elif defined(TARGET_ARM)\n\n    /* XXX: Save/restore host fpu exception state?.  */\n\n#elif defined(TARGET_SPARC)\n\n#elif defined(TARGET_PPC)\n\n#elif defined(TARGET_M68K)\n\n    cpu_m68k_flush_flags(env, env->cc_op);\n\n    env->cc_op = CC_OP_FLAGS;\n\n    env->sr = (env->sr & 0xffe0)\n\n              | env->cc_dest | (env->cc_x << 4);\n\n#elif defined(TARGET_MICROBLAZE)\n\n#elif defined(TARGET_MIPS)\n\n#elif defined(TARGET_SH4)\n\n#elif defined(TARGET_ALPHA)\n\n#elif defined(TARGET_CRIS)\n\n#elif defined(TARGET_S390X)\n\n    /* XXXXX */\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n\n\n    /* restore global registers */\n\n#include \"hostregs_helper.h\"\n\n\n\n    /* fail safe : never use cpu_single_env outside cpu_exec() */\n\n    cpu_single_env = NULL;\n\n    return ret;\n\n}\n", "idx": 12451, "substitutes": {"env1": [" env3", "environment0", "ec1", "ec3", "zone01", "env0", "zone1", "environment2", " envOne", "zone2", "env01", "en3", "environmentOne", "en1", "environment01", "en0", "envOne", "environment1", "en2", "ec0", "ecOne", "zone0", "env3", " env2", "env2", "ec2", "environment3", " env01", "enOne", " env0"], "ret": ["alt", "proc", "utf", "reply", "capt", "inter", "val", "def", "rets", "Return", "fun", "eval", "status", "buffer", "arg", "det", "mt", "mem", "info", "match", "data", "ait", "Ret", "f", "result", " RET", "att", "reset", "red", " Ret", "nt", "eth", "re", "resp", "RET", "res", "run", "len", "net", "bit"], "interrupt_request": ["interrupt67request", "intersect_request", "intersect_progress", "interrupt67window", "interrupt_window", "intersect_req", "intersect67request", "intersect67progress", "interrupt67progress", "interrupt_req", "interrupt_progress", "interrupt67req", "intersect67window", "intersect67req", "intersect_window"], "tb": ["ttb", "ltbh", "ltbl", "tbl", " tbh", "ltb", "ttbh", "ttbl", " tbl", " tbb", "ttbb", "tbh", "tbb", "ltbb"], "tc_ptr": ["tc2ptr", "tc2tr", "TC_proc", "tcfptr", "tc2proc", "tcfproc", "tc_tr", "tcfpointer", "tc_proc", "tc2pointer", "tc_pointer", "tcftr", "TC_ptr", "TC_tr", "TC_pointer"], "next_tb": ["next_Tb", "next_intb", "next_etb", "next_intbl", "next_tbl", "next_Tbb", "next_etbb", "next_intp", "next_Tp", "next_intbb", "next_Tbl", "next_tp", "next_etbl", "next_tbb", "next_etp"]}}
{"project": "qemu", "commit_id": "a87f39543a9259f671c5413723311180ee2ad2a8", "target": 0, "func": "static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)\n\n{\n\n    if (memory_region_is_ram(mr)) {\n\n        return !(is_write && mr->readonly);\n\n    }\n\n    if (memory_region_is_romd(mr)) {\n\n        return !is_write;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 11674, "substitutes": {"mr": ["rh", "rf", "adr", "mk", "mn", "tr", "hr", "m", "fr", "rr", "kr", "mm", "gr", "wk", "MR", "attr", "usr", "ir", "rb", "rs", "lr", "er", "dr", "mid", "rt", "mir", "fm", "rc", "mi", "r", "pr", "nr", "shr", "ur", "yr", "tm", "vr", "rg", "mt", "Mr", "sr", "br", "eu", "mc", "rl", "rm"], "is_write": [" is_written", "is_flow", "any_line", "any_writing", " is_read", "is_read", "any_write", " is_left", "isPubleft", "isPubread", " is_flow", "is_writing", "is_written", "is_left", "is_line", "any_read", "isPubwrite"]}}
{"project": "FFmpeg", "commit_id": "eb38d8fe926bdce8110fa4be4fddf6598a079a20", "target": 0, "func": "static void fill_coding_method_array (sb_int8_array tone_level_idx, sb_int8_array tone_level_idx_temp,\n\n                sb_int8_array coding_method, int nb_channels,\n\n                int c, int superblocktype_2_3, int cm_table_select)\n\n{\n\n    int ch, sb, j;\n\n    int tmp, acc, esp_40, comp;\n\n    int add1, add2, add3, add4;\n\n    int64_t multres;\n\n\n\n    // This should never happen\n\n    if (nb_channels <= 0)\n\n        return;\n\n\n\n    if (!superblocktype_2_3) {\n\n        /* This case is untested, no samples available */\n\n        SAMPLES_NEEDED\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++) {\n\n                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer\n\n                    add1 = tone_level_idx[ch][sb][j] - 10;\n\n                    if (add1 < 0)\n\n                        add1 = 0;\n\n                    add2 = add3 = add4 = 0;\n\n                    if (sb > 1) {\n\n                        add2 = tone_level_idx[ch][sb - 2][j] + tone_level_idx_offset_table[sb][0] - 6;\n\n                        if (add2 < 0)\n\n                            add2 = 0;\n\n                    }\n\n                    if (sb > 0) {\n\n                        add3 = tone_level_idx[ch][sb - 1][j] + tone_level_idx_offset_table[sb][1] - 6;\n\n                        if (add3 < 0)\n\n                            add3 = 0;\n\n                    }\n\n                    if (sb < 29) {\n\n                        add4 = tone_level_idx[ch][sb + 1][j] + tone_level_idx_offset_table[sb][3] - 6;\n\n                        if (add4 < 0)\n\n                            add4 = 0;\n\n                    }\n\n                    tmp = tone_level_idx[ch][sb][j + 1] * 2 - add4 - add3 - add2 - add1;\n\n                    if (tmp < 0)\n\n                        tmp = 0;\n\n                    tone_level_idx_temp[ch][sb][j + 1] = tmp & 0xff;\n\n                }\n\n                tone_level_idx_temp[ch][sb][0] = tone_level_idx_temp[ch][sb][1];\n\n            }\n\n            acc = 0;\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        acc += tone_level_idx_temp[ch][sb][j];\n\n\n\n            multres = 0x66666667 * (acc * 10);\n\n            esp_40 = (multres >> 32) / 8 + ((multres & 0xffffffff) >> 31);\n\n            for (ch = 0;  ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++) {\n\n                        comp = tone_level_idx_temp[ch][sb][j]* esp_40 * 10;\n\n                        if (comp < 0)\n\n                            comp += 0xff;\n\n                        comp /= 256; // signed shift\n\n                        switch(sb) {\n\n                            case 0:\n\n                                if (comp < 30)\n\n                                    comp = 30;\n\n                                comp += 15;\n\n                                break;\n\n                            case 1:\n\n                                if (comp < 24)\n\n                                    comp = 24;\n\n                                comp += 10;\n\n                                break;\n\n                            case 2:\n\n                            case 3:\n\n                            case 4:\n\n                                if (comp < 16)\n\n                                    comp = 16;\n\n                        }\n\n                        if (comp <= 5)\n\n                            tmp = 0;\n\n                        else if (comp <= 10)\n\n                            tmp = 10;\n\n                        else if (comp <= 16)\n\n                            tmp = 16;\n\n                        else if (comp <= 24)\n\n                            tmp = -1;\n\n                        else\n\n                            tmp = 0;\n\n                        coding_method[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff;\n\n                    }\n\n            for (sb = 0; sb < 30; sb++)\n\n                fix_coding_method_array(sb, nb_channels, coding_method);\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        if (sb >= 10) {\n\n                            if (coding_method[ch][sb][j] < 10)\n\n                                coding_method[ch][sb][j] = 10;\n\n                        } else {\n\n                            if (sb >= 2) {\n\n                                if (coding_method[ch][sb][j] < 16)\n\n                                    coding_method[ch][sb][j] = 16;\n\n                            } else {\n\n                                if (coding_method[ch][sb][j] < 30)\n\n                                    coding_method[ch][sb][j] = 30;\n\n                            }\n\n                        }\n\n    } else { // superblocktype_2_3 != 0\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++)\n\n                for (j = 0; j < 64; j++)\n\n                    coding_method[ch][sb][j] = coding_method_table[cm_table_select][sb];\n\n    }\n\n\n\n    return;\n\n}\n", "idx": 21311, "substitutes": {"tone_level_idx": ["tone_level_Idxs", "tone_level_namexc", "tone_level_idsv", "tone_level_idsxes", "tone_level_idsx", "tone_level_itxs", "tone_level_IdX", "tone_level_idxes", "tone_level_infoz", "tone_level_counts", "tone_level_infoxs", "tone_level_endy", "tone_level_endx", "tone_level_Idx", "tone_level_inz", "tone_level_itx", "tone_level_idsxc", "tone_level_namex", "tone_level_onexes", "tone_level_idsz", "tone_level_onexc", "tone_level_endz", "tone_level_idw", "tone_level_its", "tone_level_inx", "tone_level_onez", "tone_level_infox", "tone_level_inxx", "tone_level_countx", "tone_level_idy", "tone_level_itw", "tone_level_idv", "tone_level_Idy", "tone_level_infoxx", "tone_level_Idz", "tone_level_idxx", "tone_level_endxs", "tone_level_infoX", "tone_level_namev", "tone_level_onex", "tone_level_idz", "tone_level_countw", "tone_level_countxs", "tone_level_inxs", "tone_level_idX", "tone_level_idxs", "tone_level_idxc", "tone_level_namez", "tone_level_ids"], "tone_level_idx_temp": ["tone_level_idz_Temp", "tone_level_idz_method", "tone_level_idx_source", "tone_level_idf_temp", "tone_level_idf_clean", "tone_level_idx_clean", "tone_level_idz_tmp", "tone_level_idz_temp", "tone_level_idx_buffer", "tone_level_idg_default", "tone_level_idx_current", "tone_level_idg_level", "tone_level_idg_temp", "tone_level_idx_cache", "tone_level_idx_Temp", "tone_level_idx_tmp", "tone_level_idx_default", "tone_level_idf_current", "tone_level_idx_method", "tone_level_idx_level", "tone_level_idf_cache", "tone_level_idg_source", "tone_level_idz_buffer"], "coding_method": ["coding2temp", "coder_function", "coding2type", "coder_method", "coder_type", "coding2function", "coding_function", "coding_type", "coding_temp", "coder_temp", "coding2method"], "nb_channels": ["nb_chanunks", "nbofchanchannel", "nb_hchannel", "nb_compairs", "nb__channels", "nb_colchannel", "nb__chairs", "nb__compannels", "nb_hars", "nb_colunks", "nb_bars", "nb_compannels", "nb_chears", "nbofchchannel", "nb_cheairs", "nbofchunks", "nb_chars", "nb_colords", "nbofchannels", "nb__chords", "nb_bbands", "nb_compords", "nb_chunks", "nb_cbands", "nb__compars", "nbofchords", "nb_chanchannel", "nb_cars", "nb__compords", "nb_hannels", "nbofchanannels", "nb_hbands", "nb_chchannel", "nb_cannels", "nb_chanords", "nb_bannels", "nb_vunks", "nb_vannels", "nb_chords", "nbofchanunks", "nb_cheords", "nb_hairs", "nb__chars", "nb_chanannels", "nb_bchannel", "nb_compars", "nb_colannels", "nb_vords", "nb__compairs", "nb_chairs", "nb_chbands", "nb_vchannel", "nb_cchannel", "nb_cheannels", "nbofchanords", "nb_hords"], "c": ["conv", "lc", "cc", "e", "ct", "con", "cl", "f", "ci", "cmp", "ac", "nc", "m", "cp", "cache", "p", "mc", "xc", "enc", "cb", "b", "dc", "w", "cpp", "n", "C", "cod", "count"], "superblocktype_2_3": ["superblocktype_1_7", "superblocktype_1_3", "superblocktype_2_three", "superblocktype_1_three", "superblocktype_2_03", "superblocktype_2A53", "superblocktype_2_53", "superblocktype_2_7", "superblocktype_1_53", "superblocktype_1_03", "superblocktype_2A03", "superblocktype_2Athree", "superblocktype_2A3"], "cm_table_select": ["cm_table_list", "cm_interface_use", "cm_interface_list", "cm_table_use", "cm_table_seq", "cm_table1seq", "cm_interface_seq", "cm_interface_select", "cm_table1use", "cm_table1list", "cm_table1select"], "ch": ["i", "chn", "app", "ct", "cm", "Ch", "che", "eff", "cell", "cp", "qu", "CH", "chart", "fr", "cpp", "gh", "v", "conf", " cs", "cha", "col", "conn", "cor", "g", "ich", "bb", "cel", "ci", "s", "code", "q", "rc", "cb", "channel", "bh", "ce", "ph", "k", "vc", "lc", "com", "uch", "chi", "f", "cmp", "cht", "p", "cf", "number", "cho", "b", "cy", "zh", "loc", "co", "th", "buff", "hw", "h", "ht", "count", "sch", "cd", "och", "sk", "ach", "chan", "_", "cl", "ky", "ctx", "sh", "session", "chu", "cher", "all"], "sb": ["bc", "sv", "i", "mb", "bp", "bg", "sit", "kb", "java", "wb", "dy", "ib", "dl", "n", "src", "ff", "bm", "nb", "rb", "ss", "conn", "jp", "g", "db", "bb", "cel", "sth", "split", "s", "sy", "SB", "sg", "cb", "sm", "sc", "ann", "sf", "yi", "bh", "bj", "lc", "syn", "lb", "sel", "sie", "usb", "nn", "shop", "fb", "eb", "obb", "sd", "num", "si", "b", "sub", "length", "sup", "zh", "ll", "jc", "bf", "cod", "stab", "sq", "abb", "gb", "pb", "sk", "sci", "sl", "btn", "bl", "lr", "jj", "ctrl", "sync", "sa", "cn", "sh", "bs", "sn", "sp"], "j": ["ja", "je", "i", "jit", "jl", "ie", "obj", "jp", "ind", "adj", "g", "jen", "jam", "f", "pos", "jj", "ju", "uj", "y", "r", "u", "m", "kj", "it", "dj", "jet", "p", "job", "jon", "o", "q", "aj", "pr", "el", "fr", "si", "J", "b", "x", "ji", "ij", "n", "er", "br", "jc", "v", "z", "jan", "sp", "sn", "li", "note", "jo", "pt", "l", "bj", "k", "pa"], "tmp": ["output", "txt", "area", "obj", "app", "jp", "config", "amp", "vt", "adj", "yy", "xxx", "extra", "fb", "bb", "tt", "temp", "pad", "img", "emp", "cmp", "jj", "fake", "pre", "cp", "cache", "seed", "tp", "zip", "p", "tem", "diff", "prefix", "tc", "Temp", "np", "elt", "buf", "rc", "kk", "cb", "ctx", "mm", "beta", "mp", "xxxx", "ptr", "stuff", "ff", "vv", "src", "sup", "pot", "test", "nb", "wx", "bf", "proc", "alpha", "v", "sp", "rb", "offset", "api", "resp", "attr"], "acc": ["cc", "app", "circ", "ind", "config", "amp", "adj", "input", "cond", "rec", "img", "eff", "emp", "cont", "cmp", "op", "ac", "ad", "cache", "seed", "abc", "add", "ai", "test", "aa", "alpha", "att", "attr"], "esp_40": ["esp_buffer", "asm_len", "asm_40", "asm_layer", "asm_buffer", "esp_layer", "esp_len"], "comp": ["omp", "circ", "config", "amp", "com", "ctr", "cond", "bb", "rec", "cur", "cmp", "pos", "op", "cp", "cache", "component", "frac", "mod", "code", "seq", "loc", "comb", "co", "proc", "lib", "conf", "quad"], "add1": ["ad2", " add16", "addOne", "load2", "add8", "added2", "ad16", "AddOne", " add7", "load1", "load99", "add16", "dd4", " add99", "Add1", "dd2", "ad8", "Add7", "added8", "added3", "add99", "dd1", "ad4", "added16", "Add2", "add7", "added4", "Add4", "added1", "Add3", " addOne", "ad1", "dd99", "adOne", "added7", " add8"], "add2": ["ad2", " add14", "inc92", "add8", "address92", "added2", " addsecond", "add62", "inc4", "add82", "added62", " add56", "addedsecond", "addedTwo", "sendsecond", "add14", "call82", "Add1", "address4", " add82", "added8", "send4", "add92", "ad4", "added22", "call4", "apply4", "Add2", "call2", "added4", "send2", "inc14", "addsecond", "Add4", "add56", "apply2", "inc2", "inc56", "address82", "apply62", " addTwo", "sendTwo", "call92", " add92", "add22", " add22", "addTwo", " add62", "address2", "inc1", "address56", "apply8", " add8", "ad22", "Add14"], "add3": ["extra83", "add236", "dd3", "add43", "join44", "inc13", "plus15", "inc39", "dd4", "plus3", "addThree", "added4", "extra15", "applythree", "inc3", "inc83", "addIII", "added13", "added43", "app236", "inc15", "incThree", "applyThree", "app39", "add83", "add44", "dd1", "push123", "ad3", "plus83", "do6", "join236", " addthree", "extraThree", "add39", "inc236", "add6", "add123", "addthree", "pushIII", "Addthree", "inc44", "do123", "plusThree", "doIII", "added3", "extra1", "push3", "apply03", "ddthree", " add13", "Add3", "call3", "Add03", "ad1", "call123", "extrathree", "add03", "call6", "inc4", " add03", " add43", "adthree", "app3", " addThree", "push6", "extra3", "inc43", "join39", "AddThree", "ad4", "extra4", "do3", "join3", "callIII", "app44", "add15", "apply3", "add13"], "add4": [" add94", "ad2", "inc24", "address47", " add6", "adfour", "added2", " add47", "inc44", "add5", "addedfour", "inc4", "inc22", "add24", "append4", "added44", "address4", " add24", "Add6", "readfour", "inc47", "append22", "add44", "ad4", "read4", "apply94", "inc5", "addfour", "Add2", "apply4", "added4", "append2", "append94", "add47", "Add4", "inc64", "Addfour", "added6", "inc2", " addfour", "apply2", "address22", "added5", "add64", "add22", "apply22", " add5", "read2", " add64", " add22", "Add64", "inc6", " add44", "address2", "add6", "added24", "add94"], "multres": ["emptre", "addreed", "ractres", "ractreed", "addrice", "emptrice", "addres", "ractrice", "ractre", "requreed", "requrice", "requre", "emptres", "requres", "emptreed", "addre"]}}
{"project": "qemu", "commit_id": "f68945d42bab700d95b87f62e0898606ce2421ed", "target": 1, "func": "void qemu_savevm_state_complete(QEMUFile *f)\n\n{\n\n    QJSON *vmdesc;\n\n    int vmdesc_len;\n\n    SaveStateEntry *se;\n\n    int ret;\n\n\n\n    trace_savevm_state_complete();\n\n\n\n    cpu_synchronize_all_states();\n\n\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n        if (!se->ops || !se->ops->save_live_complete) {\n\n            continue;\n\n        }\n\n        if (se->ops && se->ops->is_active) {\n\n            if (!se->ops->is_active(se->opaque)) {\n\n                continue;\n\n            }\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_END);\n\n\n\n        ret = se->ops->save_live_complete(f, se->opaque);\n\n        trace_savevm_section_end(se->idstr, se->section_id, ret);\n\n\n        if (ret < 0) {\n\n            qemu_file_set_error(f, ret);\n\n            return;\n\n        }\n\n    }\n\n\n\n    vmdesc = qjson_new();\n\n    json_prop_int(vmdesc, \"page_size\", TARGET_PAGE_SIZE);\n\n    json_start_array(vmdesc, \"devices\");\n\n    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {\n\n\n\n        if ((!se->ops || !se->ops->save_state) && !se->vmsd) {\n\n            continue;\n\n        }\n\n        trace_savevm_section_start(se->idstr, se->section_id);\n\n\n\n        json_start_object(vmdesc, NULL);\n\n        json_prop_str(vmdesc, \"name\", se->idstr);\n\n        json_prop_int(vmdesc, \"instance_id\", se->instance_id);\n\n\n\n        save_section_header(f, se, QEMU_VM_SECTION_FULL);\n\n\n\n        vmstate_save(f, se, vmdesc);\n\n\n\n        json_end_object(vmdesc);\n\n        trace_savevm_section_end(se->idstr, se->section_id, 0);\n\n\n    }\n\n\n\n    qemu_put_byte(f, QEMU_VM_EOF);\n\n\n\n    json_end_array(vmdesc);\n\n    qjson_finish(vmdesc);\n\n    vmdesc_len = strlen(qjson_get_str(vmdesc));\n\n\n\n    if (should_send_vmdesc()) {\n\n        qemu_put_byte(f, QEMU_VM_VMDESCRIPTION);\n\n        qemu_put_be32(f, vmdesc_len);\n\n        qemu_put_buffer(f, (uint8_t *)qjson_get_str(vmdesc), vmdesc_len);\n\n    }\n\n    object_unref(OBJECT(vmdesc));\n\n\n\n    qemu_fflush(f);\n\n}", "idx": 21670, "substitutes": {"f": ["fa", "fc", "e", "config", "fs", "g", "fb", "file", "d", "_", "parse", "ops", "rf", "fp", "df", "write", "t", "u", "m", "j", "s", "new", "p", "fx", "cf", "inf", "code", "q", "af", "c", "fe", "fr", "tf", "form", "b", "fd", "F", "sf", "feed", "update", "bf", "fen", "z", "v", "fn", "lf", "h", "l", "fi", "this", "fo", "k"], "vmdesc": ["vmdec", "vamddesc", " vcmdesc", "mmandesc", "vmaosc", "vmandocument", " vmaosc", "vcmdec", " vcmdasc", "vmnrec", "vmdex", " vcmdex", " vmdrec", " vMDesc", "vmodosc", "vmddesc", "vamdasc", "vmadoc", "vnddesc", "vmdrec", "vmderella", "vddisc", " vmdasc", "vmef", "gmmesc", "vmdest", " vcmdrec", "vndoc", "vMDsc", "vcmdest", "mmdesc", "vMDasc", "vcmdrec", " vmdsc", "vmdect", "vmandest", " vmdisc", "vmesc", "vMDest", "vmanderella", "vmonddesc", " vmdex", "mmdocument", "mmdest", "vamdef", " vMDdesc", " vmaser", "gmdisc", " vcmdest", "vamddec", "vamdser", "vmondest", "vmandrec", "vmnex", "vamdesc", "vmtesc", "vMDesc", "mmdoc", "vnddec", "vamderella", "vmdasc", "vcmddesc", "vmmasc", "vMDisc", "vmterella", "vmondisc", "gmmisc", " vmdef", "vmondasc", " vmaesc", "vmest", "mmderella", "vddasc", "vcmdsc", "gmdasc", "vamdocument", " vmdser", "vndesc", "vmadesc", " vcmdef", " vmdest", "vmondoc", "vmec", "vmaser", "vmtocument", "vmmisc", "gmdect", "vmasc", "vmodser", "vmddec", " vMDisc", "mmandest", "vmadest", "vmondesc", "vmdisc", "vcmdoc", "vddect", "vmodesc", "vmondsc", "vMDdesc", " vcmdoc", "vMDec", " vMDsc", " vmdoc", "vcmdasc", "vmandesc", "vmanddesc", "mmandoc", "gmdesc", "vmdser", "mmanddec", "gmmasc", "mmanddesc", "vcmdesc", "vmmect", "gmmect", "vamdsc", "vmaesc", "vcmdisc", " vmddesc", "vmanddec", " vmdec", "vmdoc", "vmandex", "mmanderella", " vcmdec", "vmmesc", "vmdsc", "mmandocument", "vmadasc", " vcmddesc", "vamdest", "vamdoc", "vMDect", "vcmdef", "vmnesc", "vmsc", " vmadesc", "mmddec", "vmtest", "vmdef", "vmnef", "vddesc", "vmdosc", "vmoddesc", " vmdosc", "mmddesc", "vamdosc", " vcmdsc", "vmandoc", "vmdocument", "vcmdex", "vmandef"], "vmdesc_len": ["vmdsc_length", "vmdsc_len", "vmdesc_long", "vmdsc_Len", "vmdsc_long", "vmdesc_Len", "vmdesc_length"], "se": ["ite", "e", "sel", "sed", "sk", "es", "serv", "ie", "ee", "sl", "ser", "ses", "ade", "pe", "lex", "sche", "be", "de", "parse", "site", "so", "ine", "oss", "entry", "s", "ue", "Se", "esse", "del", "cle", "SE", "sync", "le", "sa", "pse", "ese", "el", "spec", "ste", "sea", "si", "sh", "sc", "ch", "he", "service", "sing", "te", "spe", "ve", "loc", "see", "sem", "st", "ae", "ce", "ne", "sp", "sec", "ke", "pack", "ge", "su", "ase", "ze", "sle"], "ret": ["status", "bc", "reg", "def", "en", "xt", "gt", "ref", "err", "valid", "result", "val", "arg", "det", "repl", "Ret", "mt", "get", "no", "art", "cur", "rf", "bl", "al", "r", "bit", "msg", "res", "data", "cat", "rets", "fin", "last", " RET", "fun", "code", "success", "rc", "ext", "num", "match", "let", "RET", "rt", " Ret", "sr", "flag", "rev", "sur", "re", "reply", "error", "len", "lt", "back", "alt", "nt", "lit", "pt", "att", "ft"]}}
{"project": "FFmpeg", "commit_id": "fa2a34cd40d124161c748bb0f430dc63c94dd0da", "target": 0, "func": "int avfilter_register(AVFilter *filter)\n\n{\n\n    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)\n\n        return -1;\n\n\n\n    registered_avfilters[next_registered_avfilter_idx++] = filter;\n\n    return 0;\n\n}\n", "idx": 11444, "substitutes": {"filter": ["parent", "term", "b", "page", "block", "rule", "config", "cf", "search", "parser", "f", "ac", "entry", "alpha", "fl", "version", "v", "name", "event", "query", "feature", "guard", "apply", "object", "function", "user", "sort", "patch", "offset", "Filter", "root", "plugin", "type", "handler", "header", "attribute", "match"]}}
{"project": "FFmpeg", "commit_id": "4dbcdfa86d1405f7e5c0ec14a4be7d2fb5903d7b", "target": 0, "func": "static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out)\n\n{\n\n    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);\n\n    void *dst;\n\n    if (o_out)\n\n        *o_out= o;\n\n    if (!o || o->offset<=0)\n\n        return AVERROR_OPTION_NOT_FOUND;\n\n\n\n    if (o->max*den < num*intnum || o->min*den > num*intnum) {\n\n        av_log(obj, AV_LOG_ERROR, \"Value %lf for parameter '%s' out of range\\n\", num, name);\n\n        return AVERROR(ERANGE);\n\n    }\n\n\n\n    dst= ((uint8_t*)obj) + o->offset;\n\n\n\n    switch (o->type) {\n\n    case FF_OPT_TYPE_FLAGS:\n\n    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;\n\n    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;\n\n    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;\n\n    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;\n\n    case FF_OPT_TYPE_RATIONAL:\n\n        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};\n\n        else                 *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);\n\n        break;\n\n    default:\n\n        return AVERROR(EINVAL);\n\n    }\n\n    return 0;\n\n}\n", "idx": 5762, "substitutes": {"obj": ["act", "objects", "id", "Obj", "nt", "eff", "x", "tmp", "po", "b", "op", "io", "ob", "object", "bm", "val", "oa", "nc", "ad", "image", "orb", "buf", "j", "np", "lo", "len", "e", "out", "en", "bot", "n", "ctx", "ant", "ab", "cb", "jp", "lib", "lock", "Object", "coll", "p", "nb", "str", "ut", "opt", "pos", "oi", "os", "ind", "off", "api", "oid", "lc", "ord", "pl", "ref", "src", "img", "nd", "end", "bj", "js"], "name": ["base", "option", "anc", "time", "id", "parent", "word", "x", "object", "data", "alias", "i", "named", "info", "m", "names", "key", "null", "f", "l", "ext", "nm", "version", "Name", "part", "size", "NAME", "number", "len", "fn", "n", "path", "str", "filename", "old", "nam", "new", "type", "cn", "label", "no", "min", "max", "dim", "prefix"], "num": ["four", "position", "na", "una", "om", "done", "b", "i", "umi", "unit", "f", "nm", "dom", "initial", "con", "len", "gener", "NUM", "nb", "span", "don", "zero", "off", "um", "rum", "index", "id", "min", "sum", "valid", "mon", "uno", "mn", "param", "number", "Num", "nom", "one", "mom", "un", "node", "form", "no", "bn", "size", "uni", "bin", "block", "tun", "sem", "loc", "inc", "u", "np", "an", "en", "coord", "begin", "gen", "du", "im", "ul", "norm", "dim", "mu", "nu", "ten", "m", "offset", "eight", "n", "lon", "su", "nam", "term", "hum", "lim", "hom"], "den": ["uni", "fen", " DEN", "bench", "diff", "una", "min", "dn", "di", "nn", "pen", "wall", "sen", "ni", "sem", "non", "ten", "dem", "de", "mon", "lim", "side", "dan", "version", "limit", "flo", "Den", "nen", "dir", "des", "len", "con", "hen", "en", "die", "ben", "lon", "su", "ne", "begin", "don", "ner", "un", "gen", "none", "ven", "line", "range", "du", "ver", "lin", "plan", "nan", " Den", "zen", "DEN", "norm", "dim", "low"], "intnum": ["intnode", "ntnode", "intum", " intum", "pointnom", "ntlen", "doubleoffset", "interloc", "intmem", "indnode", " intbegin", "Intnu", "Intnum", "indloc", "integernum", "intbegin", "ntnum", "integeren", "integerbegin", "extnumber", "inclen", "integername", "pointnum", "intno", "ntunit", "integernu", "indunit", "extnum", " intno", "indmem", "ntname", "Intnom", "intnom", "indnu", "extname", "indnom", "intoffset", "Intum", "intname", "incnum", "intloc", "stringnum", "intblock", " intblock", "integernom", " intnom", "integerlen", "pointen", "indname", "integerblock", "Intnumber", " intname", "doublenumber", "pointnu", "intername", "incnom", "doubleloc", "intnumber", "ntnom", "intunit", "incnumber", "internum", "intlen", "pointmem", "bitblock", "ntoffset", "indnum", "doublename", "doubleno", "integermem", "pointnumber", "inten", "integernumber", "Intblock", "pointblock", "indnumber", "extlen", "stringnode", "pointbegin", "ntnu", "ntno", " intlen", "bitnum", " intnumber", " intoffset", "bitnumber", " inten", "stringunit", "stringnu", "bitum", "internumber", "doublenum", "ntnumber", "intnu"], "o_out": [" o_in", "s_sync", "o_Out", " o_o", " o_off", " o_Out", "o_off", "s_off", "s_out", "o_sync", "o_o", "o_in", "s_in"], "o": ["option", "options", "ko", "v", "po", "b", "object", "io", "i", "oa", "op", "ob", "mo", "O", "or", "m", "office", "so", "l", "offset", "f", "d", "u", "e", "lo", "oe", "online", "out", "w", "t", "k", "n", "go", "oin", "one", "p", "offer", "ou", "opt", "none", "oi", "os", "off", "oo", "c", "oid", "iso", "bo", "no"], "dst": ["idsts", "isdpush", "Dst", "Dsp", "ldstr", " ddest", "isdste", "dabl", "dbl", " dSt", "dasts", "isdstore", "DSt", "Dste", "xdst", "idste", "idst", "xdsts", "dsc", "ldst", "Dsts", "adST", "nste", "odsts", "nST", "ldste", "dsp", "odste", "dST", "dsts", "indstore", "Dbl", "indpush", "adsts", "ldsc", "Dsc", "dstore", "nst", " dsts", "dast", "adste", "idcr", "dstr", " dstore", " dsc", " dsp", " dcr", " dpush", "adst", "adstr", " dbl", "xdste", "xdST", "dpush", "Dcr", "indste", "daSt", "ddest", " dste", "nsp", "isdst", "dSt", "addest", "oddest", "dcr", "ldST", " dstr", "odst", " dST", "indst", "dste", "DST"]}}
{"project": "FFmpeg", "commit_id": "a70a3f0b4dc488ad04f81c16479c74f57b17e06f", "target": 0, "func": "static int adpcm_decode_init(AVCodecContext * avctx)\n\n{\n\n    ADPCMContext *c = avctx->priv_data;\n\n\n\n    if(avctx->channels > 2U){\n\n        return -1;\n\n    }\n\n\n\n    c->channel = 0;\n\n    c->status[0].predictor = c->status[1].predictor = 0;\n\n    c->status[0].step_index = c->status[1].step_index = 0;\n\n    c->status[0].step = c->status[1].step = 0;\n\n\n\n    switch(avctx->codec->id) {\n\n    case CODEC_ID_ADPCM_CT:\n\n        c->status[0].step = c->status[1].step = 511;\n\n        break;\n\n    case CODEC_ID_ADPCM_IMA_WS:\n\n        if (avctx->extradata && avctx->extradata_size == 2 * 4) {\n\n            c->status[0].predictor = AV_RL32(avctx->extradata);\n\n            c->status[1].predictor = AV_RL32(avctx->extradata + 4);\n\n        }\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 1713, "substitutes": {"avctx": ["ajctx", "afcontext", "alcontext", "avc", "avhw", "devcontext", "mpctx", "afctl", "mpcontext", "AVhw", "afcup", "devcf", "avcontext", "apcmp", "afc", "AVc", "afcmp", "AVcontext", "avectx", "avecf", "afctx", "broadctx", "aveconn", "broadsys", "avcf", "devsys", "broadc", "afconn", "AVctl", "avalctl", "abcf", "avalcontext", "avesc", "abcontext", "allc", "AVcmp", "devctx", "avalctx", "evctx", "evcontext", "alctx", "mpcf", "mplc", "devc", "apcontext", "afhw", "ajcup", "AVcu", "abctx", "avecup", "broadcontext", "afcu", "aflc", "afcf", "afsys", "apcu", "avctl", "evconn", "devlc", "ajcontext", "AVctx", "ablc", "alhw", "avsc", "AVlc", "avconn", "evlc", "avsys", "afsc", "avcup", "apctx", "avalc", "avecontext", "devconn", "avcu", "ajsc", "avlc", "avcmp"], "c": ["fc", "cm", "cs", "ctx", "conn", "context", "cc", "mc", "cl", "anc", "com", "d", "ct", "n", "nc", "rec", "cur", "con", "k", "tc", "client", "enc", "i", "g", "ac", "coll", "cr", "ch", "config", "C", "ec", "abc", "dc", "ce", "h", "cu", "p", "l", "w", "e", "lc", "f", "arc", "oc", "cache", "ca", "sc", "u", "core", "exec", "ctrl", "vc", "sec", "s", "pc", "v", "b", "cp", "t", "cf", "ic", "ci", "uc", "rc", "can"]}}
{"project": "qemu", "commit_id": "90e56fb46d0a7add88ed463efa4e723a6238f692", "target": 0, "func": "static void *do_data_decompress(void *opaque)\n\n{\n\n    DecompressParam *param = opaque;\n\n    unsigned long pagesize;\n\n\n\n    while (!quit_decomp_thread) {\n\n        qemu_mutex_lock(&param->mutex);\n\n        while (!param->start && !quit_decomp_thread) {\n\n            qemu_cond_wait(&param->cond, &param->mutex);\n\n        }\n\n        if (!quit_decomp_thread) {\n\n            pagesize = TARGET_PAGE_SIZE;\n\n            /* uncompress() will return failed in some case, especially\n\n             * when the page is dirted when doing the compression, it's\n\n             * not a problem because the dirty page will be retransferred\n\n             * and uncompress() won't break the data in other pages.\n\n             */\n\n            uncompress((Bytef *)param->des, &pagesize,\n\n                       (const Bytef *)param->compbuf, param->len);\n\n        }\n\n        param->start = false;\n\n        qemu_mutex_unlock(&param->mutex);\n\n\n\n        qemu_mutex_lock(&decomp_done_lock);\n\n        param->done = true;\n\n        qemu_cond_signal(&decomp_done_cond);\n\n        qemu_mutex_unlock(&decomp_done_lock);\n\n    }\n\n\n\n    return NULL;\n\n}\n", "idx": 26226, "substitutes": {"opaque": ["pacity", "copca", " opaques", "oac", "pca", "opac", "oaque", "opaques", " opac", "oaques", "copace", "copaques", " opace", "oace", "opca", "opace", " opca", "copac", "paques", " opacity", "copacity", "paque", "opacity", "copaque"], "param": ["ref", "temp", "sem", "cm", "Param", "see", "info", "p", "m", "arm", "option", "name", "keep", "image", "asm", "sam", "config", "var", "am", "member", "conf", "type", "error", "meter", "iam", "sync", "prom", "reason", "key", "pri", "ram", "amp", "project", "adr", "resource", "grad", "pb", "atom", "prem", "advert", "rm", "model", "sym", "pool", "grade", "ctx", "problem", "pm", "change", "item", "channel", " Param", "vm", "aram", "Parameter", "arg", "rem", "update", "im", "part", "comment", "service", "source", "index", "mm", "par", "monitor", "block", "connection", "mark", "params"], "pagesize": [" pagesization", "Pagesized", "filesized", "filessize", " pagesz", "blocksiz", " pagesized", "codesiz", "pagesz", "codessize", "codesz", "filesize", "pagessize", "Pagesiz", "blockssize", "Pagessize", "Pagesz", " pagessize", "PagesIZE", "pagesization", "userssize", "Pagesize", "pagesIZE", "codesize", "usersization", "blocksization", "pagesiz", "blocksize", "usersize", " pagesiz", "pagesized", "usersiz", " pagesIZE", "filesIZE"]}}
{"project": "qemu", "commit_id": "ec53b45bcd1f74f7a4c31331fa6d50b402cd6d26", "target": 0, "func": "void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)\n\n{\n\n#if defined(TARGET_HAS_ICE)\n\n    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);\n\n\n\n    breakpoint_invalidate(cpu, breakpoint->pc);\n\n\n\n    g_free(breakpoint);\n\n#endif\n\n}\n", "idx": 6098, "substitutes": {"cpu": ["cp", "flow", "bench", "gc", "cmp", "pid", "CP", "lb", "chip", "pu", "vm", "roc", "component", "gru", "config", "nc", "auc", " CPU", "gpu", "comp", "uc", "px", "mac", "uci", "pc", "linux", "np", "proxy", "clock", "instance", "ctx", "processor", "ctrl", "boot", "frame", "uca", "pointer", "proc", "node", "c", "GPU", "cn", "core", "lc", "CU", "cache", "android", "loader", "CPU", "conn"], "breakpoint": [" breakpointer", "breakpointer", "Breakart", "breakdown", "breakerPoint", " breakpt", "Breakpointer", "Breakpoint", "breakingart", "breakpt", "breakingpointer", "breakingargument", "breakingframe", "breakframe", " breakade", " breakargument", "breakingPoint", "breakart", "breakerframe", "breakerpoint", "breakingpoint", "breakerpt", " breakdown", "breakingdown", "breakerargument", " breakframe", "breakPoint", "breakingade", " breakart", "breakerdown", "breakargument", "breakade", "BreakPoint", "Breakade", " breakPoint", "breakingpt"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,\n\n                                       PutBitContext *pb, const float *in,\n\n                                       const float *scaled, int size, int scale_idx,\n\n                                       int cb, const float lambda, const float uplim,\n\n                                       int *bits)\n\n{\n\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    int i;\n\n    float cost = 0;\n\n    int qc1, qc2, qc3, qc4;\n\n    int curbits = 0;\n\n\n\n    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];\n\n    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];\n\n\n\n    for (i = 0; i < size; i += 4) {\n\n        const float *vec, *vec2;\n\n        int curidx, curidx2, sign1, count1, sign2, count2;\n\n        int   *in_int = (int   *)&in[i];\n\n        float *in_pos = (float *)&in[i];\n\n        float di0, di1, di2, di3;\n\n        int t0, t1, t2, t3, t4;\n\n\n\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n\n\n\n        __asm__ volatile (\n\n            \".set push                                          \\n\\t\"\n\n            \".set noreorder                                     \\n\\t\"\n\n\n\n            \"ori        %[t4],      $zero,      7               \\n\\t\"\n\n            \"ori        %[sign1],   $zero,      0               \\n\\t\"\n\n            \"ori        %[sign2],   $zero,      0               \\n\\t\"\n\n            \"slt        %[t0],      %[t4],      %[qc1]          \\n\\t\"\n\n            \"slt        %[t1],      %[t4],      %[qc2]          \\n\\t\"\n\n            \"slt        %[t2],      %[t4],      %[qc3]          \\n\\t\"\n\n            \"slt        %[t3],      %[t4],      %[qc4]          \\n\\t\"\n\n            \"movn       %[qc1],     %[t4],      %[t0]           \\n\\t\"\n\n            \"movn       %[qc2],     %[t4],      %[t1]           \\n\\t\"\n\n            \"movn       %[qc3],     %[t4],      %[t2]           \\n\\t\"\n\n            \"movn       %[qc4],     %[t4],      %[t3]           \\n\\t\"\n\n            \"lw         %[t0],      0(%[in_int])                \\n\\t\"\n\n            \"lw         %[t1],      4(%[in_int])                \\n\\t\"\n\n            \"lw         %[t2],      8(%[in_int])                \\n\\t\"\n\n            \"lw         %[t3],      12(%[in_int])               \\n\\t\"\n\n            \"slt        %[t0],      %[t0],      $zero           \\n\\t\"\n\n            \"movn       %[sign1],   %[t0],      %[qc1]          \\n\\t\"\n\n            \"slt        %[t2],      %[t2],      $zero           \\n\\t\"\n\n            \"movn       %[sign2],   %[t2],      %[qc3]          \\n\\t\"\n\n            \"slt        %[t1],      %[t1],      $zero           \\n\\t\"\n\n            \"sll        %[t0],      %[sign1],   1               \\n\\t\"\n\n            \"or         %[t0],      %[t0],      %[t1]           \\n\\t\"\n\n            \"movn       %[sign1],   %[t0],      %[qc2]          \\n\\t\"\n\n            \"slt        %[t3],      %[t3],      $zero           \\n\\t\"\n\n            \"sll        %[t0],      %[sign2],   1               \\n\\t\"\n\n            \"or         %[t0],      %[t0],      %[t3]           \\n\\t\"\n\n            \"movn       %[sign2],   %[t0],      %[qc4]          \\n\\t\"\n\n            \"slt        %[count1],  $zero,      %[qc1]          \\n\\t\"\n\n            \"slt        %[t1],      $zero,      %[qc2]          \\n\\t\"\n\n            \"slt        %[count2],  $zero,      %[qc3]          \\n\\t\"\n\n            \"slt        %[t2],      $zero,      %[qc4]          \\n\\t\"\n\n            \"addu       %[count1],  %[count1],  %[t1]           \\n\\t\"\n\n            \"addu       %[count2],  %[count2],  %[t2]           \\n\\t\"\n\n\n\n            \".set pop                                           \\n\\t\"\n\n\n\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n\n              [sign1]\"=&r\"(sign1), [count1]\"=&r\"(count1),\n\n              [sign2]\"=&r\"(sign2), [count2]\"=&r\"(count2),\n\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n\n              [t4]\"=&r\"(t4)\n\n            : [in_int]\"r\"(in_int)\n\n            : \"memory\"\n\n        );\n\n\n\n        curidx = 8 * qc1;\n\n        curidx += qc2;\n\n\n\n        curidx2 = 8 * qc3;\n\n        curidx2 += qc4;\n\n\n\n        curbits += p_bits[curidx];\n\n        curbits += upair7_sign_bits[curidx];\n\n        vec     = &p_codes[curidx*2];\n\n\n\n        curbits += p_bits[curidx2];\n\n        curbits += upair7_sign_bits[curidx2];\n\n        vec2    = &p_codes[curidx2*2];\n\n\n\n        __asm__ volatile (\n\n            \".set push                                          \\n\\t\"\n\n            \".set noreorder                                     \\n\\t\"\n\n\n\n            \"lwc1       %[di0],     0(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di1],     4(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di2],     8(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di3],     12(%[in_pos])               \\n\\t\"\n\n            \"abs.s      %[di0],     %[di0]                      \\n\\t\"\n\n            \"abs.s      %[di1],     %[di1]                      \\n\\t\"\n\n            \"abs.s      %[di2],     %[di2]                      \\n\\t\"\n\n            \"abs.s      %[di3],     %[di3]                      \\n\\t\"\n\n            \"lwc1       $f0,        0(%[vec])                   \\n\\t\"\n\n            \"lwc1       $f1,        4(%[vec])                   \\n\\t\"\n\n            \"lwc1       $f2,        0(%[vec2])                  \\n\\t\"\n\n            \"lwc1       $f3,        4(%[vec2])                  \\n\\t\"\n\n            \"nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \\n\\t\"\n\n\n\n            \".set pop                                           \\n\\t\"\n\n\n\n            : [di0]\"=&f\"(di0), [di1]\"=&f\"(di1),\n\n              [di2]\"=&f\"(di2), [di3]\"=&f\"(di3)\n\n            : [in_pos]\"r\"(in_pos), [vec]\"r\"(vec),\n\n              [vec2]\"r\"(vec2), [IQ]\"f\"(IQ)\n\n            : \"$f0\", \"$f1\", \"$f2\", \"$f3\",\n\n              \"memory\"\n\n        );\n\n\n\n        cost += di0 * di0 + di1 * di1\n\n                + di2 * di2 + di3 * di3;\n\n    }\n\n\n\n    if (bits)\n\n        *bits = curbits;\n\n    return cost * lambda + curbits;\n\n}\n", "idx": 5621, "substitutes": {"s": ["spec", "session", "b", "sync", "sys", "ses", "f", "ls", "ss", "cs", "e", "sc", "sb", "ops", "gs", "ds", "ts", "p", "sv", "fs", "sa", "c", "proc", "g", "ssl", "ps", "setup"], "pb": ["abc", "cp", "bp", "ib", "rb", "kB", "pd", "bps", "pp", "wp", "lp", "ses", "fb", "pm", "pg", "pc", " p", "sb", "bc", "PB", "PC", "vp", "gb", "ppa", "proc", "ub", "cv", "cpp"], "in": ["login", "complex", "bin", "ins", "pin", "config", "val", "inn", "data", "slice", "din", "image", "m", "inc", "f", "nin", "at", "gin", "d", "IN", "ints", "con", "out", "scan", "isin", "pass", "vin", "str", "In", "source", "input", "again", "ssl", "scl", "lin", "query", "inner", "index", "src", "min", "cm"], "scaled": ["SCalled", "oscraped", "Scaled", "oscaling", "stalled", "Scalled", "configalled", "scaved", "configaped", "Scilled", " Scaled", "oscalled", " Scalled", "scraped", " scaling", "expilled", "scilled", " scaved", " Scale", "SCaved", "SCaling", "expalled", "expaped", "escale", "SCaled", "expaled", " scalled", "oscaled", "escalled", "escaled", " Scaped", "scalled", " scraped", "Scaved", "scaling", "Scaling", "scale", "Scale", "stilled", "staped", "scaped", "configraped", "configaled", "Scraped", "Scaped", "escaped", " scaped", "staled"], "size": ["uni", "SIZE", "sec", "shape", "ci", "crop", "sn", "loc", "ii", "small", "Size", "ffff", "cs", "np", "six", "code", "len", "sh", "scale", "c", "sq", "ize", "cm", "mode"], "scale_idx": ["scale_initb", "scale_indb", "scale_indx", "scale_pidz", "scale_ide", "scale_idxes", "scale_idsv", "scale_nameX", "scale_idced", "scale_namex", "scale_countX", "scale_idg", "scale_idb", "scale_counte", "scale_idex", "scale_indxes", "scale_pidg", "scale_initced", "scale_idsx", "scale_idX", "scale_idz", "scale_indced", "scale_ideced", "scale_countxp", "scale_namee", "scale_idsz", "scale_countx", "scale_initx", "scale_ideb", "scale_idsg", "scale_pidx", "scale_namexp", "scale_idxp", "scale_idv", "scale_pidv", "scale_initxes", "scale_idexes"], "cb": ["abc", "CB", "cmp", "lb", "buff", "obb", "rb", "crop", "ob", "nc", "kk", "repeat", "uc", "uv", "cm", "fb", "db", "wb", "buf", "abb", "bb", "ctr", "loop", "cpp", "sb", "dc", "cor", "ctx", "bc", "nb", "gb", "kb", "bf", "cf", "core", "lc", "fc", "cv", "cod", "src", "ctrl", "cd", "ff", "low"], "lambda": ["abc", "UC", "alpha", "la", "beta", "shape", " disp", "nc", "circ", "appa", " gamma", "cl", "phi", " la", " lam", "da", "func", "dc", "qa", "LA", "mega", " beta", "sq", "igma", " sig", "mu"], "uplim": ["Uplength", "uplims", "usplength", "usplims", "uplength", "Uplim", "uclims", "uclam", "uPLam", "Uclims", "uclim", "Uplims", "usplim", "uPLims", "Uclim", "uplam", "uPLength", "uclength", "usplam", "Uplam", "Uclength", "Uclam", "uPLim"], "bits": ["bands", "features", "b", "bps", "bit", "rows", "its", "ips", "pins", "planes", "forces", "bs", "ints", "units", "ops", "bis", "bytes", "fps", "blocks", "batch", "pieces", "gb", "pos", "ps", "flags"], "i": ["uni", "gi", "ei", "ti", "v", "id", "I", "is", "chi", "a", "di", "ci", "ji", "ni", "xi", "x", "si", "b", "io", "abi", "slice", "info", "bi", "qi", "ix", "l", "f", "pi", "yi", "phi", "adi", "j", "ii", "iu", "ij", "it", "ai", "uli", "my", "u", "e", "uri", "k", "n", "multi", "mi", "vis", "ini", "ie", "p", "mini", "h", "z", "eni", "iv", "sup", "oi", "c", "ip", "ind", "y", "type", "li", "inner", "fi", "index", "zi", "min", "mu", "ui"], "qc1": ["sqc1", " qcone", " qc8", "qcone", "qdc91", "qsc1", "qdc2", "qcs8", "qsc4", "qc91", "qsc2", "sqc2", "qdc4", "ql91", " qdc1", "sqc4", " qdc2", "qcs2", "qdcone", "ql4", "ql2", "qf1", "qc8", " qdc8", "qf2", "sqsc91", "qf8", "qdc8", "sqsc4", "ql1", "sqc91", "qfone", " qdcone", "qcs1", "sqsc1", "sqsc2", "qcsone", "qdc1", "qsc91"], "qc2": ["qcr2", "qsc42", " qc8", "kc32", "qlc32", "qce8", "qrFuture", "qc32", " qrFuture", "klc32", "kc42", "kc8", "qcs8", "qsc2", "qcs182", "qlc2", "qcsFuture", "qlc8", "qc42", "qcs2", "qr182", " qr2", "qlc42", "qceFuture", "klc42", "qc8", "qcr32", " qcFuture", " qc182", "qcr42", "qr8", "klc2", "qr2", "qc182", "qce182", "klc8", "qcFuture", " qr8", " qr182", "kc2", "qsc8", "qce2", "qsc32", "qcr8"], "qc3": ["qsc3", "qr5", "qpc8", " qc8", " qc15", " qsc3", "qp6", " qsc5", "qb8", " qcs23", " qcs6", " qc6", "qr6", "qpc5", "qcs5", "qr3", "qcs6", "qc15", " qcs5", " qcs3", "qp5", " qsc15", "qb3", "qp3", "qp23", "qc23", " qc5", "qc6", "qc5", "qc8", "qcs23", "qb15", "qsc15", "qsc5", "qcs3", "qpc15", "qr23", " qsc8", "qsc8", " qc23", "qb5", "qpc3"], "qc4": ["qvc4", " qcCore", "qf5", "qlc54", "qlcCore", " qfCore", "quc4", "qvc5", " qc7", "quc54", "quc6", " qf4", "qlc7", "quci6", "qC4", "qvc7", "qC6", "qf7", "quci4", "qc54", "qvcCore", "qlc4", "qf4", "qc7", "qci54", "qC04", "qlc04", "qci4", "qlc6", "qfCore", " qf5", "qc6", "qlc5", " qc5", "qc5", "qci6", "qc04", " qf7", "quci54", "qC54", "quci04", "qcCore", "qci04", "quc04"], "p_bits": ["p_ops", "P_flags", "p_flags", "p_bytes", "P_ops", "P_bits", "P_bytes"], "p_codes": ["p_vec", "p_desc", "c_codes", "c_desc", "c_code", "p_code", "c_vec"], "vec": ["spec", "mat", "slice", "cat", "flat", "nec", "circ", "vector", "buf", "tri", "version", "ctr", "crit", "def", "len", "sc", "cube", "feat", "str", "seq", "vert", "ver", "cap", "cv", "norm"], "vec2": ["vert1", "exp5", "exp0", "cv2", "vec1", "vec0", "vert0", "cv1", "vert5", "vert2", "cv0", "exp1", "cv5", "exp2", "vec5"], "curidx": ["curidep", "curridy", " curIdc", "curridp", " curidy", " curIdy", "curridx", "curIdy", " curidp", "curIdc", "curidey", "curidc", " curIdp", "curidp", "curridc", "curIdx", " curidc", "curidex", "curidy", " curIdx", "curidec", "curIdp"], "curidx2": ["curidx1", "curidx32", "curidn1", "curidy32", "curidy2", "curidn32", "curidz1", "curidx4", "curidz32", "curidn4", "curidz2", "curidz4", "curidn2", "curidy4", "curidy1"], "sign1": ["SignA", "Sign2", "Sign1", " signA", "sumA", "sum1", "sum2", "signA"], "count1": [" countone", " count01", "count01", "sign01", "weight01", "signone", "weightone", "weight1", "countone"], "sign2": ["count0", "sum0", "Sign2", "sum4", "Sign1", "Sign4", "sum1", "sign4", "sum2", "Sign0", "sign0", "count4"], "count2": ["patch2", "patchb", "count8", "signb", " countb", "patch8", "patch4", "sign4", "sign8", " count4", " count8", "countb", "count4"], "in_int": ["inc_ind", "inc_int", "in_float", "inc_index", "in_index", "inc_float", "in_ind"], "in_pos": ["in67rot", "in_flo", "in_rot", "in67flo", "in67position", "in67pos", "in_position", " in_flo", " in_position", " in_rot"], "di0": ["di50", "ni50", " di50", " di80", "ti50", "ni1", "di80", "ti0", "ni80", "ni0", "ti1", "ti80"], "di1": ["dim8", "d8", "ni8", "dim0", "d0", "ni1", "di8", "dim1", "dim3", "d3", "d1", "ni0", "ni3"], "di2": ["ini5", "ini4", "i5", "mi0", "ini2", "mi4", "i0", "di5", "mi2", "mi5", "ini0", "i2", "i4", "di4"], "di3": ["Di33", "di15", "bi15", "i15", "di33", "bi33", "bi3", "bi4", "i3", "Di15", "Di4", "i33", "i4", "di4", "Di3"], "t0": ["e0", " t6", "p00", "p6", "t6", "e2", "p0", "t00", "e00", "e6", " t00", "p2"], "t1": ["T2", "T0", "pt1", "pt0", "p1", "T1", "p0", "p2", "pt2"], "t2": ["T2", "T0", "pt4", "pt0", "pt1", "type4", "type0", "T1", "T4", "type2", "type1", "pt2"], "t3": ["T3", "it3", "te15", "T15", "teThree", "itThree", "tThree", "T1", "TThree", "it15", "it1", "te3", "t15", "te1"], "t4": ["it04", "T04", "T2", "T384", " t384", "t04", "it384", " t04", "it2", "T4", "t384", "it4"]}}
{"project": "qemu", "commit_id": "ef8489d45927a6d35b214365e4b39ab311b48f2a", "target": 1, "func": "static void scsi_write_data(SCSIRequest *req)\n\n{\n\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);\n\n    uint32_t n;\n\n\n\n    /* No data transfer may already be in progress */\n\n    assert(r->req.aiocb == NULL);\n\n\n\n    /* The request is used as the AIO opaque value, so add a ref.  */\n\n    scsi_req_ref(&r->req);\n\n    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {\n\n        DPRINTF(\"Data transfer direction invalid\\n\");\n\n        scsi_write_complete(r, -EINVAL);\n\n        return;\n\n    }\n\n\n\n    if (!r->req.sg && !r->qiov.size) {\n\n        /* Called for the first time.  Ask the driver to send us more data.  */\n\n        r->started = true;\n\n        scsi_write_complete(r, 0);\n\n        return;\n\n    }\n\n    if (s->tray_open) {\n\n        scsi_write_complete(r, -ENOMEDIUM);\n\n        return;\n\n    }\n\n\n\n    if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 ||\n\n        r->req.cmd.buf[0] == VERIFY_16) {\n\n        if (r->req.sg) {\n\n            scsi_dma_complete(r, 0);\n\n        } else {\n\n            scsi_write_complete(r, 0);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (r->req.sg) {\n\n        dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_WRITE);\n\n        r->req.resid -= r->req.sg->size;\n\n        r->req.aiocb = dma_bdrv_write(s->qdev.conf.bs, r->req.sg, r->sector,\n\n                                      scsi_dma_complete, r);\n\n    } else {\n\n        n = r->qiov.size / 512;\n\n        bdrv_acct_start(s->qdev.conf.bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);\n\n        r->req.aiocb = bdrv_aio_writev(s->qdev.conf.bs, r->sector, &r->qiov, n,\n\n                                       scsi_write_complete, r);\n\n    }\n\n}\n", "idx": 837, "substitutes": {"req": ["ret", "q", "key", "queue", "ver", "requ", "rec", "client", "hr", "er", "ir", "err", "tr", "crit", "ec", "progress", "pr", "dev", "f", "jp", "seq", "require", "rt", "task", "ext", "spec", "rw", "sem", "id", "ra", "request", "pkg", "p", "e", "resource", "org", "comm", "sr", "ev", "re", "load", "input", "urg", "required", "rs", "gr", "tar", "mod", "rr", "ru", "dep", "str", "dq", "pub", "c", "eq", "ref", "loader", "ctr", "app", "cmd", "release", "supp", "module", "rar", "reg", "low", "cook", "res", "call", "def", "conn", "cur", "query", "grad", "rf", "rb", "fr", "config", "reader", "ro", "sq", "exec", "resp", "cmp", "rx", "pro", "quant", "desc"], "r": ["ur", "dr", "this", "q", "wr", "yr", "j", "g", "hr", "er", "ir", "err", "tr", "pr", "self", "f", "u", "rd", "var", "rt", "rh", "rw", "k", "ra", "nr", "request", "p", "or", "e", "resource", "per", "R", "sr", "v", "mr", "t", "re", "user", "rg", "rs", "gr", "rr", "ru", "lr", "kr", "m", "cr", "str", "h", "usr", "result", "c", "br", "o", "rar", "d", "cur", "rf", "rb", "fr", "rev", "l", "reader", "w", "rl", "ar", "b", "rx", "nor", "vr", "rc"], "s": ["server", "js", "service", "cs", "http", "ss", "spec", "rs", "qs", "sb", "is", "sp", "sl", "y", "j", "g", "params", "ses", "ls", "sf", "uns", "sync", "ser", "settings", "err", "z", "ds", "str", "ps", "gs", "ns", "c", "p", "sw", "or", "w", "e", "f", "es", "sys", "sq", "ar", "sec", "sr", "v", "su", "S", "os", "session", "t", "b", "fs", "si", "sym", "ssl"], "n": ["no", "adj", "not", "conn", "ni", "nn", "out", "d", "pn", "k", "un", "nu", "nl", "ne", "num", "na", "y", "i", "g", "j", "m", "nr", "network", "number", "z", "ns", "x", "l", "N", "p", "c", "h", "e", "nb", "f", "len", "size", "nan", "sn", "o", "v", "nm", "b", "t", " N", "nor", "net"]}}
{"project": "qemu", "commit_id": "63ffb564dca94f8bda01ed6d209784104630a4d2", "target": 0, "func": "static void pc_init1(ram_addr_t ram_size,\n\n                     const char *boot_device,\n\n                     const char *kernel_filename,\n\n                     const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     const char *cpu_model,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *isa_irq;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cmos_s3;\n\n    qemu_irq *smi_irq;\n\n    IsaIrqState *isa_irq_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    FDCtrl *floppy_controller;\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n\n\n    pc_cpus_init(cpu_model);\n\n\n\n    if (kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    pc_memory_init(ram_size, kernel_filename, kernel_cmdline, initrd_filename,\n\n                   &below_4g_mem_size, &above_4g_mem_size);\n\n\n\n    cpu_irq = pc_allocate_cpu_irq();\n\n    i8259 = i8259_init(cpu_irq[0]);\n\n    isa_irq_state = qemu_mallocz(sizeof(*isa_irq_state));\n\n    isa_irq_state->i8259 = i8259;\n\n    if (pci_enabled) {\n\n        ioapic_init(isa_irq_state);\n\n    }\n\n    isa_irq = qemu_allocate_irqs(isa_irq_handler, isa_irq_state, 24);\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, isa_irq, ram_size);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus_new(NULL);\n\n    }\n\n    isa_bus_irqs(isa_irq);\n\n\n\n    pc_register_ferr_irq(isa_reserve_irq(13));\n\n\n\n    pc_vga_init(pci_enabled? pci_bus: NULL);\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_irq, &floppy_controller, &rtc_state);\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!pci_enabled || (nd->model && strcmp(nd->model, \"ne2k_isa\") == 0))\n\n            pc_init_ne2k_isa(nd);\n\n        else\n\n            pci_nic_init_nofail(nd, \"e1000\", NULL);\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            dev = isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            idebus[i] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        }\n\n    }\n\n\n\n    audio_init(isa_irq, pci_enabled ? pci_bus : NULL);\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device,\n\n                 idebus[0], idebus[1], floppy_controller, rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n        i2c_bus *smbus;\n\n\n\n        cmos_s3 = qemu_allocate_irqs(pc_cmos_set_s3_resume, rtc_state, 1);\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              isa_reserve_irq(9), *cmos_s3, *smi_irq,\n\n                              kvm_enabled());\n\n        for (i = 0; i < 8; i++) {\n\n            DeviceState *eeprom;\n\n            eeprom = qdev_create((BusState *)smbus, \"smbus-eeprom\");\n\n            qdev_prop_set_uint8(eeprom, \"address\", 0x50 + i);\n\n            qdev_prop_set_ptr(eeprom, \"data\", eeprom_buf + (i * 256));\n\n            qdev_init_nofail(eeprom);\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n", "idx": 25583, "substitutes": {"ram_size": ["ram_c", "ram_shape", "ramingshape", "memory_size", "ramingc", " ram_addr", "ram6size", "ram_addr", "ram_address", "gram_source", "ram_Size", " ram_shape", " ram_c", "gram_address", "ram6Size", "ram_source", "ramingsize", "memory_address", "ram6addr", "ramingaddr", "gram_size", "gram_scale", "ram_scale", "ram6address", "memory_Size", "memory_addr"], "boot_device": ["bootbookmode", "bootportdevice", "kernel_device", "bootportmemory", "bootportroot", "boot_root", "bootbookdevice", "boot_memory", "kernel_root", "kernel_memory", "kernel_mode", "boot_mode", "bootbookmemory", "bootbookroot", "bootportmode"], "kernel_filename": ["base_platform", "base_url", "base_filename", "kernel_platform", " kernel_file", "kernel_document", "kernel_file", " kernel_username", " kernel_platform", "base_document", "kernel_username", "kernel_url"], "kernel_cmdline": ["kernel_hostline", "kernel_Cmdlined", "kernel_configlin", "kernel_hostlin", "kernel_commandlines", "kernel_configLine", "kernel_cmdlined", "kernel_commandLINE", "kernel_cmdlines", "kernel_hostLine", "kernel_configLINE", "kernel_hostLINE", "kernel_commandlined", "kernel_configline", "kernel_commandlin", "kernel_Cmdline", "kernel_Cmdlines", "kernel_hostlined", "kernel_commandLine", "kernel_hostlines", "kernel_cmdLINE", "kernel_cmdlin", "kernel_cmdLine", "kernel_commandline"], "initrd_filename": ["initrd_url", "initnd_fp", "initrd_Filename", "initrt_mode", "initnd_filename", "initrdOFilename", "initrt_filename", "initrdOfilename", "initrdOmode", "initnd_url", "initrdOfiles", "initrd_file", "initrd_files", "initrt_Filename", "initrd_fp", "initrt_files", "initrd_mode", "initnd_file"], "cpu_model": ["cpu_spec", "pu_spec", "pu_model", "core_models", "core_location", "cpuachandler", "pu_mode", "cpu_mode", "cpuaclocation", "pu_models", "cpuacmodels", "core_model", "cpu_handler", "cpu_models", "core_handler", "cpuacmodel", "cpu_location"], "pci_enabled": ["pci__disabled", "pcc_enable", "pki_interrupted", "pci_disabled", "pci67enable", "pcc67Enabled", "pci67disabled", "pki_loaded", "pcc_enabled", "pci67enabled", "pcc_Enabled", "pci__enabled", "pcc67disabled", "pcc67enable", "pci_loaded", "pci__enable", "pci_Enabled", "pki_enabled", "pci_interrupted", "pki_disabled", "pci67Enabled", "pcc67enabled", "pki_enable", "pcc_disabled", "pci_enable"], "kvmclock_enabled": ["kvmsync_enabled", "kvmlock_provided", "kvmsync_disabled", "kvmclock_Enabled", "kvmsync_Enabled", "kvmclock_disabled", "kvmsync_enable", "kvmlock_disabled", "kvmlock_led", "kvmclock_enable", "kvmclock_led", "kvmlock_enabled", "kvmclock_provided"], "i": ["k", "p", "m", "b", "c", "d", "x", " I", "counter", "type", "io", "id", "proc", "is", "e", "s", "h", "I", "f", "n", "j", "ip", "a", "v", "r", "pi", "l"], "below_4g_mem_size": ["below_4g_memory_capacity", "below_4g_memory_size", "below_4g_memory_address", "below_4g_memory_Size", "below_4g_mem_sum", "below_4g_mem_capacity", "below_4g_mem_Size", "below_4g_memory_sum", "below_4g_mem_address"], "above_4g_mem_size": ["above_4g_mem2size", "above_4g_memory_time", "above_4g_mem_sum", "above_4g_mem2sum", "above_4g_mem64Size", "above_4g_mem64size", "above_4g_mem64time", "above_4g_mem2speed", "above_4g_memory_size", "above_4g_mem_Size", "above_4g_memory_Size", "above_4g_mem_time", "above_4g_mem_speed"], "pci_bus": ["pci_bridge", "pci_device", "pciambus", "pki_bus", "pki_device", "pci__boot", "pci_lib", "pci_boot", "pci__cache", "pki_session", "pcijcache", "pciamlib", "pci__bus", "pci_cache", "pciamboot", "pcijboot", "pci_session", "pcijbus", "pci__bridge", "pki_lib", "pciamsession", "pki_bridge", "pcijbridge", "pki_cache", "pki_boot"], "i440fx_state": ["i440fx_data", "i440fs_states", "i440plex_config", "i440fx_states", "i440fx_work", "i440fx67data", "i440fx_manager", "i440fx_config", "i440plex67manager", "i440plex_manager", "i440fs_work", "i440plex_data", "i440plex_state", "i440fx67config", "i440plex67state", "i440fx67manager", "i440plex67data", "i440fs_config", "i440fx67state", "i440fs_state", "i440plex67config"], "cpu_irq": ["cpu_rinch", "cpu_rinq", "cpu_rfqs", "cpu_IRp", "cpu_pircle", "cpu_iracle", "cpu_IRqa", "cpu_ireQ", "cpu_irch", "cpu_irsq", "cpu_irQ", "cpu_pirqs", "cpu_rinqs", "cpu_pirp", "cpu_irtch", "cpu_irp", "cpu_ireq", "cpu_rinsq", "cpu_pirqa", "cpu_iraq", "cpu_ireqa", "cpu_IRq", "cpu_irtq", "cpu_irep", "cpu_irqa", "cpu_rfsq", "cpu_pirQ", "cpu_pirq", "cpu_ierquest", "cpu_ierq", "cpu_irtsq", "cpu_rfq", "cpu_iercle", "cpu_ircle", "cpu_IRQ", "cpu_pirquest", "cpu_rfch", "cpu_irqs", "cpu_irtqs", "cpu_iraqs", "cpu_iraquest", "cpu_ierqs", "cpu_irquest"], "isa_irq": ["isa__irqs", "isa__irq", "isa_ircle", "isa_Irq", "isa_mirqq", "isa_yrqt", "isa_IrQ", "isa_irtq", "isa_mirq", "isa_irtquest", "isa_irtqa", "isa__irtQ", "isa_Irqa", "isa_ierqs", "isa_irqs", "isa_irquest", "isa_IRQ", "isa_irch", "isa_irtch", "isa_irtqq", "isa_irtqs", "isa_ierqq", "isa_irtqt", "isa_irqt", "isa__irtqa", "isa__irtqs", "isa_mirqs", "isa_yrcle", "isa__irqa", "isa_irQ", "isa_Irqs", "isa_irqq", "isa_irtQ", "isa_yrq", "isa_ierquest", "isa__irtq", "isa_ierq", "isa_irtcle", "isa_ierqt", "isa_IRqa", "isa_IRqs", "isa_iercle", "isa_yrquest", "isa_mirch", "isa_irqa", "isa_IRq", "isa_ierch", "isa__irQ"], "i8259": ["xi6259", "pi8239", "xi8129", "pi4252", "i4239", "si8199", "pi4259", "pi8129", "i7259", "i8139", "i9259", "pi4129", "i15169", "xi8579", "xi8259", "si8139", "i6252", "pi8259", "i7139", "i825", "i059", "i4259", "i6129", "i15259", "i025", "si15199", " i8252", "i9252", "si15259", "i8169", "i0259", "i859", "i864249", "i12259", "i8199", "i8579", "si8259", " i059", "pi8252", "i18129", " i025", "i6259", "i0129", "i18249", "i4129", "i12139", " i825", "i4252", "i8129", " i0259", "i108259", "i7199", "xi6249", "i864129", "i12169", " i859", "si8169", "xi6129", "xi8249", " i0252", "i10825", "i0239", "i12199", "i8252", "i925", "i15199", "i6579", "i0252", "i864579", "i6239", "i108252", "si15169", "i8239", "i18579", "i6249", "i15139", "i864259", "xi6579", "i7169", "pi4239", "si15139", "i10859", "i18259", "i8249", "i959"], "cmos_s3": ["cmos_gics", "cmos_sgd", "cmos_snd", "cmos_g3", "cmos_ps3", "cmos_sics", "cmos_csgd", "cmos_psics", "cmos_cs3", "cmos_psnd", "cmos_csics", "cmos_gnd", "cmos_ggd", "cmos_psgd", "cmos_csnd"], "smi_irq": ["smi_irqs", "smi_irg", "smi_iraq", "smi_iraquest", "smi_iraqs", "smi_pirquest", "smi_errqs", "smi_errquest", "smi_pirq", "smi_pirg", "smi_errq", "smi_irquest", "smi_pirqs", "smi_errg", "smi_irag"], "isa_irq_state": ["isa_irquire_state", "isa_irq_rule", "isa_irq__state", "isa_irp_mode", "isa_irqa_state", "isa_irq_mode", "isa_irq_data", "isa_irQ_states", "isa_irqrstates", "isa_irQ_rule", "isa_irq_states", "isa_irqrstate", "isa_irq_config", "isa_irqrrule", "isa_irq_store", "isa_irquest_store", "isa_irq_back", "isa_irq__data", "isa_irp_state", "isa_irr_state", "isa_irp_rule", "isa_irq_parent", "isa_irquire_states", "isa_irqa_manager", "isa_irr_data", "isa_irq_manager", "isa_irq__states", "isa_irq__config", "isa_irr_config", "isa_irquire_parent", "isa_irquest_state", "isa_irqa_rule", "isa_irQ_back", "isa_irQ_state", "isa_irqrback", "isa_irquest_states", "isa_irr_states"], "hd": ["md", "hm", "ht", "xd", "cd", "dr", "HD", "ld", "dri", "bd", "dd", "udi", "hub", "hid", "hp", "du", "hw", "pd", "rh", "gd", "di", "dt", "wd", "cow", "dist", "vd", "df", "fd"], "MAX_IDE_BUS": ["MAX_IDE_US", "MAX_IDE_LINE", "MAX_IDEAMUS", "MAX_ISE_US", "MAX_IDEAMBUS", "MAX_ISE_DI", "MAX_ISE_LINE", "MAX_ISE_BUS", "MAX_ISE_USE", "MAX_IDEAMDI", "MAX_IDE_DI", "MAX_IDE_USE"], "MAX_IDE_DEVS": ["MAX_IDE_DIVICE", "MAX_IDE_DEVICE", "MAX_IDE_DRV", "MAX_IDE_DIV", "MAX_IDE_DVS", "MAX_IDE_DEFS", "MAX_IDE_DIFS", "MAX_IDE_DFS", "MAX_IDE_DEV", "MAX_IDE_DVICE", "MAX_IDE_DRVS", "MAX_IDE_DRFS", "MAX_IDE_DRVICE", "MAX_IDE_DIVS", "MAX_IDE_DV"], "floppy_controller": ["flp_driver", "flp_design", "floppy2driver", "floppy2controller", "floppy2design", "floppy2control", "flp_controller", "floppy_driver", "floppy_control", "flp_control", "floppy_design"], "idebus": ["IDEbus", "iebus", "ieBUS", "IDEBUS", "inecache", "inebus", "ineBus", "ideBUS", "ieBus", "IDEBus", "IDEcache", "ideBus", "ineBUS", "iecache", "idecache"], "rtc_state": ["rtc_states", "rtc_config", "rtac_config", "rtac_state", "rtac_model", "rtc_model", "rtac_states"]}}
{"project": "FFmpeg", "commit_id": "e89f58810d0d508552089495781e2a70e95edb99", "target": 0, "func": "static void check_default_settings(AVCodecContext *avctx)\n\n{\n\n    X264Context *x4 = avctx->priv_data;\n\n\n\n    int score = 0;\n\n    score += x4->params.analyse.i_me_range == 0;\n\n    score += x4->params.rc.i_qp_step == 3;\n\n    score += x4->params.i_keyint_max == 12;\n\n    score += x4->params.rc.i_qp_min == 2;\n\n    score += x4->params.rc.i_qp_max == 31;\n\n    score += x4->params.rc.f_qcompress == 0.5;\n\n    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;\n\n    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;\n\n    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;\n\n    if (score >= 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Default settings detected, using medium profile\\n\");\n\n        x4->preset = av_strdup(\"medium\");\n\n        if (avctx->bit_rate == 200*1000)\n\n            avctx->crf = 23;\n\n    }\n\n}\n", "idx": 22093, "substitutes": {"avctx": ["mpctx", "attcontext", "evca", "autcms", "Avcf", "AVcmp", "afca", "autctx", "afcf", "akcn", "afcn", "afcmp", "Avjp", "afctx", "AVcontext", "evcontext", "avcf", "mpcontext", "avca", "attcms", "akcontext", "afcms", "Avcontext", "AVcms", "akctx", "akcms", " avjp", "mpca", "avcontext", " avcf", "attcmp", "afjp", "evcmp", "avcms", " avcn", "evctx", "autcontext", " avcms", "avcmp", "Avctx", "afcontext", "AVctx", "autcmp", " avcontext", "avjp", "avcn", "mpcmp", "attctx"], "x4": [" x14", "f2", "yfour", "ex6", "i72", "cross384", "xi384", "wa54", " x484", "y84", " x24", "xi484", "x24", "pfour", "cross4", "ex004", "x2004", "cross24", "y2", "rx4", "i004", "q72", "crossfour", " x104", "wa004", "u004", "xoutput", "u04", "exfour", "q2004", " x40", "ax2004", "ffour", "ax04", "ax4", "work84", "ax6", "wa104", "X4", "f4", "wa4", "p4", "ex4", "f04", "viewoutput", "axfour", "Xfour", "q4", "X14", "p104", "view4", " x54", "ax104", "x6", "p40", "y2004", "qfour", "X40", "rx40", "cross6", "x14", " x004", "xi400", "x54", "u6", "cross400", " x6", "view484", " x44", "workfour", "cross104", "x2", "cross54", "cross004", " x04", " xoutput", "ax40", "x04", "u4", "work2", "f14", "i4", "ifour", "q004", "y4", "u72", " x2", "x104", "x484", "ufour", "x40", "x004", "X2", "x44", "X84", "x384", "work4", "x84", "xi4", "xfour", "x72", "xi14", "view14", "rxfour", "xioutput", " x400", " xfour", "rx44", "x400", " x384", "X44", "xi24", "f6"]}}
{"project": "FFmpeg", "commit_id": "14a90c9ef09a4b046500dceab5ca1875e330a376", "target": 1, "func": "static av_cold int ffmmal_init_decoder(AVCodecContext *avctx)\n{\n    MMALDecodeContext *ctx = avctx->priv_data;\n    MMAL_STATUS_T status;\n    MMAL_ES_FORMAT_T *format_in;\n    MMAL_COMPONENT_T *decoder;\n    char tmp[32];\n    int ret = 0;\n    bcm_host_init();\n    if (mmal_vc_init()) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot initialize MMAL VC driver!\\n\");\n        return AVERROR(ENOSYS);\n    if ((ret = ff_get_format(avctx, avctx->codec->pix_fmts)) < 0)\n        return ret;\n    avctx->pix_fmt = ret;\n    if ((status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER, &ctx->decoder)))\n        goto fail;\n    decoder = ctx->decoder;\n    format_in = decoder->input[0]->format;\n    format_in->type = MMAL_ES_TYPE_VIDEO;\n    switch (avctx->codec_id) {\n        case AV_CODEC_ID_MPEG2VIDEO:\n            format_in->encoding = MMAL_ENCODING_MP2V;\n            break;\n        case AV_CODEC_ID_MPEG4:\n            format_in->encoding = MMAL_ENCODING_MP4V;\n            break;\n        case AV_CODEC_ID_VC1:\n            format_in->encoding = MMAL_ENCODING_WVC1;\n            break;\n        case AV_CODEC_ID_H264:\n        default:\n            format_in->encoding = MMAL_ENCODING_H264;\n            break;\n    format_in->es->video.width = FFALIGN(avctx->width, 32);\n    format_in->es->video.height = FFALIGN(avctx->height, 16);\n    format_in->es->video.crop.width = avctx->width;\n    format_in->es->video.crop.height = avctx->height;\n    format_in->es->video.frame_rate.num = 24000;\n    format_in->es->video.frame_rate.den = 1001;\n    format_in->es->video.par.num = avctx->sample_aspect_ratio.num;\n    format_in->es->video.par.den = avctx->sample_aspect_ratio.den;\n    format_in->flags = MMAL_ES_FORMAT_FLAG_FRAMED;\n    av_get_codec_tag_string(tmp, sizeof(tmp), format_in->encoding);\n    av_log(avctx, AV_LOG_DEBUG, \"Using MMAL %s encoding.\\n\", tmp);\n    if ((status = mmal_port_format_commit(decoder->input[0])))\n        goto fail;\n    decoder->input[0]->buffer_num =\n        FFMAX(decoder->input[0]->buffer_num_min, 20);\n    decoder->input[0]->buffer_size =\n        FFMAX(decoder->input[0]->buffer_size_min, 512 * 1024);\n    ctx->pool_in = mmal_pool_create(decoder->input[0]->buffer_num, 0);\n    if (!ctx->pool_in) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    if ((ret = ffmal_update_format(avctx)) < 0)\n        goto fail;\n    ctx->queue_decoded_frames = mmal_queue_create();\n    if (!ctx->queue_decoded_frames)\n        goto fail;\n    decoder->input[0]->userdata = (void*)avctx;\n    decoder->output[0]->userdata = (void*)avctx;\n    decoder->control->userdata = (void*)avctx;\n    if ((status = mmal_port_enable(decoder->control, control_port_cb)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->input[0], input_callback)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->output[0], output_callback)))\n        goto fail;\n    if ((status = mmal_component_enable(decoder)))\n        goto fail;\n    return 0;\nfail:\n    ffmmal_close_decoder(avctx);\n    return ret < 0 ? ret : AVERROR_UNKNOWN;", "idx": 25401, "substitutes": {"avctx": ["avcms", "varctx", " avcms", "navcontext", "varcontext", " avc", " avcas", "AVc", "avcontext", "ajconn", "avec", "afcontext", "avectx", "avctl", "varcmd", "ajctx", "airctx", "awcfg", "aircontext", "akctx", "avsc", "avecmp", "akcontext", "AVcontext", "afctrl", "avconsole", "awcontext", "avalcontext", " avcc", " avcmp", "afctx", "avpkg", "avalctx", "afca", "avchan", "varcc", "avctrl", "avalcms", "AVca", "AVcas", "AVctx", "AVchan", "avcfg", "aveca", "awpkg", "avcf", "AVcfg", "avcc", "airctl", "AVcmd", "AVcmp", "avalcmp", "avecontext", "AVconn", "avcmp", "awctx", "afcms", "afcf", "avca", "navcmp", "varcms", "avc", "AVpkg", "avconn", "AVsc", "ajcf", "afconn", "AVcli", "ajcontext", "afcc", "aveconsole", " avcli", "avesc", "afctl", "airctrl", "avecf", "ajcas", "avalchan", "avalcmd", "avechan", "AVcf", "avcli", "akctrl", "akcfg", " avsc", "aveconn", " avconn", "ajconsole", "akctl", "AVconsole", " avcontext", "avcas", "avcmd", "AVcms", "navctx", "akpkg", "navcli"], "ctx": ["cm", "console", "cca", " context", "anc", "c", "pkg", "context", "cv", "connection", "qa", "cci", "xc", "text", "config", "component", "cb", "bc", "general", "cmp", "hw", "cmd", "cms", "vc", "wcs", "voc", "cli", "parent", "cc", "ci", "cp", "cf", "client", "rc", "cn", "conv", "cas", "git", "lc", "ctrl", "ca", "service", "cu", "conn", "coll", "event", "tx", "cs", "cam"], "status": ["exec", "temp", "std", "code", "sc", "Status", "STAT", "class", "res", "usr", "cat", "flag", "msg", "job", "success", "cb", "bc", "error", "state", "sync", "proc", " resp", " ret", "str", "err", "val", "s", "progress", "session", "output", "stat", "ret", "sb", "sec", "rc", "response", "gc", "null", "resp", "crit", "bg", "result", "wait"], "format_in": [" format\n", "format_ac", "Format_out", "formatocat", "Formatformat", "template_in", "formatableIn", "filter\n", "feedableout", "feedableIn", "type_In", "live_inc", "form_IN", "filter_out", " format_at", "formatableout", "filter_ini", "format_0", "format_again", "format_at", "Format_in", "filter_inn", "format_In", "format\n", "filter_in", "feed_In", "Format_inc", "formatoc0", "format_ini", "feedablenew", "formatocin", "formatingdiff", " format_init", "formatformat", " format_new", "format___IN", "format_init", "formatMixat", "formatablein", "filterformat", "Format_In", "Format_again", "formatocinit", "formatingnew", " format_out", "feedablein", "formatocini", "feed_new", "type_in", "form_in", " formatformat", "live_ins", "format_inn", " format_diff", " format_id", " format_inc", "format_ins", "formatMixin", "format_out", "format___in", "formatMixinit", "formatacnew", "formatablenew", "Format\n", "template_ini", "formatacdiff", "feed_in", "format___out", "format_for", "form_ac", "form_out", "formatingin", "format_diff", "type_inc", "format_id", "type_for", "format_inc", "formatacin", "live_in", "Format_ins", "format___ac", " format_IN", "feed_out", "format_IN", " format_In", "format_new", "template_0"], "decoder": ["Decode", "decode", "decoded", "encrator", " decrator", "recoder", "decloding", "recader", "decrator", "encoder", "decade", "encode", "Decater", "deoder", "Decoding", "ecode", "recade", "decader", "Decoder", "recode", "decloder", "declader", "deode", "decater", "declade", "deoded", "encater", "declater", "declode", " decader", " decoded", " decoding", " decade", "ecoding", "encoding", "encoded", "decoding", " decode", "deoding", "ecater", "declrator", "ecoder"], "tmp": ["temp", "obj", " obj", " co", " img", " proc", "bb", "img", "cb", " params", "MP", "proc", "pad", "cmp", "mp", " ecc", " rc", " resp", " reply", " msg", " dup", " app", "sb", " param", " dst", " pad", "src", " pts"]}}
{"project": "qemu", "commit_id": "b9f7c377df4f04e9119cb0e917438dd37ef34029", "target": 1, "func": "static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,\n\n                                           const void *pkt_data,\n\n                                           size_t pkt_len)\n\n{\n\n    struct virtio_net_hdr *vhdr;\n\n    bool isip4, isip6, istcp, isudp;\n\n    uint8_t *data;\n\n    int len;\n\n\n\n    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {\n\n        return;\n\n    }\n\n\n\n    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);\n\n    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);\n\n    if (!(isip4 || isip6) || !(istcp || isudp)) {\n\n        return;\n\n    }\n\n\n\n    vmxnet3_dump_virt_hdr(vhdr);\n\n\n\n    /* Validate packet len: csum_start + scum_offset + length of csum field */\n\n    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {\n\n        VMW_PKPRN(\"packet len:%d < csum_start(%d) + csum_offset(%d) + 2, \"\n\n                  \"cannot calculate checksum\",\n\n                  len, vhdr->csum_start, vhdr->csum_offset);\n\n        return;\n\n    }\n\n\n\n    data = (uint8_t *)pkt_data + vhdr->csum_start;\n\n    len = pkt_len - vhdr->csum_start;\n\n    /* Put the checksum obtained into the packet */\n\n    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));\n\n\n\n    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\n    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;\n\n}\n", "idx": 573, "substitutes": {"pkt": ["bwk", "macket", "cpnt", " packet", "bnt", "wacket", " pct", "pnt", "Pnt", "fet", "felt", " pwk", "pet", " pet", "bkt", " pnt", "melt", "facket", "mkt", "cpkt", "belt", "fnt", "fwk", "pwk", "pelt", "mnt", "wkt", "cpacket", "cpet", "wnt", "fkt", "pct", "packet", "backet", "wct", "Pkt", "Pct", "Packet"], "pkt_data": ["pkt_dat", "pkt_start", "pkt2dat", "pkt2len", "pkt2data", "pkg_length", "pkg_len", "packet_dat", "packet_data", "packet_len", "pkt_length", "pkg_start", "pkg_data"], "pkt_len": ["packet2seq", "pkt2length", "pkt64len", "packet2Len", "packet2length", "pkt64length", "pkt2len", "pkt_en", "pkt64Len", "pkt_Len", "packet_Len", "pkt2seq", "pkt_size", "packet_en", "pet_Len", "pkt2Len", "pet_len", "packet_len", "packet2len", "packet_size", "packet_length", "pkt_seq", "pkt_length", "pet_data", "pet_length", "packet_seq", "pkt64seq"], "vhdr": ["vhmt", "vghDR", "evbhrec", "evbhdi", "vmhrd", "evhdr", "ghrdr", " vhDR", "vmhlder", "svhrdr", "viewhDR", "vhrdr", "vithdi", "vvdr", "vrhder", "vihstr", "vohmt", "viewhrgr", "vphhr", "vshder", "evbhdr", "vhder", "viewhrrt", "vohrec", "vahdr", "vrhDR", " vphdr", " vhhr", "svrhrr", "vhrstr", "vmhlrd", "vghdc", "ghrstr", "svhrr", "vadhder", "vhlbr", "ghrd", "vhhr", "vhdvd", "vmhder", "vhrgr", "vhgr", "vshhr", "vbhdr", "vhlrid", "vithmt", " vphDR", "vohdr", " vhder", "vrhdr", "vbhmt", "viewhder", "vhdgr", "vethDR", " vghDR", "vhrrd", "vvbr", "vhrec", "vbhrc", "vohdi", "vhrhr", "viewhvd", "vithrec", "viewhrdr", "vchder", "vhlvd", " vphhr", "vhrt", "vghrt", "svhdr", "viewhrder", "svhrbr", "svrhdr", "vhdc", "vhlder", " vhrid", "varchdr", "vchrid", "vhlgr", "svhDR", " vshDR", "svchrc", "ghdr", "vphld", "evhdi", "vhrid", "vahder", "vphDR", "svrhder", "vadhld", "vhrd", "vhladr", "vbhdc", "vghder", "vphrd", " vhld", "viewhdc", "vhrc", "svchrid", "vadhrd", "vehdr", "evhrec", "vshdr", "varchder", "vmhdr", "varchDR", "vhldr", "vadhstr", "svhadr", "vhrDR", "vehrr", "vhdi", "vghdr", "vethdr", "svrhDR", "vbhrid", " vghdr", "svhder", "vhlrd", "vhrdc", "vihrd", "svchdr", "vphdr", " vghder", "viewhrDR", "vhradr", "vhrrid", " vshdr", "vchdr", "vbhder", " vphder", "vhstr", "vhddr", "vhld", " vghrid", "evbhmt", "vadhdr", "viewhrdc", "varchhr", "viewhrvd", "vithdr", "vahDR", "vhostdr", "vbhDR", "vvrid", "vohrid", "ghrrd", "vihdr", "vmhldr", "vshDR", "vohDR", "vvadr", "vhrrt", "vadhrec", "vhrder", "ghder", "vhadr", "vhostrd", "viewhrt", "vhrvd", "vethhr", "vhrbr", "vshrr", "svhrc", "evhDR", "vihder", "vhDR", "vadhDR", "svhbr", "vohder", "svchder", "viewhgr", "vbhdi", "vphder", "vhdder", "ghrder", " vshhr", "vchrc", "vahrid", "vhrr", "svhrrid", "evhmt", "svhradr", "vrhrr", "vbhrec", "viewhdr", "evbhDR", "vohrc", "vghrid", "svhrid", "vhbr", "vhostder", "vbhrt", "ghstr", "vehder", "vehDR", "vhvd"], "isip4": ["isIP8", "isep2", "iip8", "isipfour", "isepfour", "isidfour", "isid2", "iep44", "iipfour", "isp44", "isip2", "isIP6", "isip8", "iepfour", "isp6", "isep6", " isid4", " isipfour", "issid4", "issip6", "isep4", "iip4", " isid6", "isp8", "issid44", "isid44", "issip8", "isid4", " isip2", "isIP4", "isep8", "ispfour", "iep4", " isid2", "iep8", "isid6", "issip4", "isp4", "isid8", "isp2", "isep44", "iip44", "issip44", "issid8", " isidfour", "issid6", "isip44", "isIP44"], "isip6": ["issepsix", "isp3", "isi16", " isid3", "isip3", "issep12", "isql16", "isepsix", "isip16", " isid8", "isid16", "isql46", "isi6", "isip8", "isip46", "isp6", "isep6", "issipsix", " isid16", " isid6", "isql12", "issip12", "isqlsix", "issip6", "isp16", "isp8", "isi46", "isep12", "issip8", "isid3", "isep8", " isip3", "issep6", "isip12", "isid6", "isaf6", "isaf3", " isip16", "isaf16", "isi8", "isaf8", "isisix", "isipsix", "isql6", "isid8", " isid46", "issep8", " isip8", "isi12", "isql8", "isid46", " isip46"], "istcp": ["istpp", "irstcp", "istpc", "xtip", "pectp", "stcp", "stpe", "istmp", "irstp", "xtcp", "istep", "istp", "irstpc", "astpc", "irstpp", "irstmp", "ismip", "xtep", "pectpp", "astp", "astpp", "xtmp", "astcp", "distcp", "istip", "stmp", "ismmp", "ismcp", "distip", "stp", "pectpc", "pectcp", "distmp", "irstpe", "istpe", "astpe", "ismep", "distep", "astmp"], "isudp": ["isadhp", "isugpt", "issoodp", "isudl", "publ", "pudcp", "asubps", "isudsps", "isubcp", "isudsm", "isodcp", "isoodc", "asudm", "issoodpe", "isubc", "isugpe", "isubp", "isoodpt", "isudb", "isudps", "isadhpt", "pubc", "pudc", "asubm", "isugp", "isadhc", "pudl", "isuffb", "isubps", "pubp", "asudps", "isugc", "isuffps", "asudp", "pubcp", "isudm", "isodl", "isodp", "isubb", "isuffm", "isadhpe", "issoodpt", "issudpt", "asubb", "isubl", "isubm", "isudsb", "isudsp", "asubp", "issudpe", "isoodpe", "isudc", "isoodp", "pudp", "isudcp", "issudc", "issudp", "isudpe", "issoodc", "isadhcp", "asudb", "isadhl", "isudpt", "isuffp", "isodc"], "data": ["base", "missing", "name", "ata", "buffer", "li", "da", "dd", "lp", "a", "image", "ui", "new", "d", "di", "ad", "aa", "field", "id", "parent", "buf", "ada", "batch", "i", "next", "in", "body", "style", "dt", "index", "raw", "pad", "result", "alpha", "p", "block", "start", "zero", "input", "length", "f", "size", "DATA", "padding", "bytes", "valid", "addr", "val", "dat", "Data", "response", " DATA"], "len": ["pl", "fun", "name", "li", "split", "lp", "ni", "Len", "n", "alt", "lf", "ln", "sl", "sp", "bin", "fn", "end", "span", "pre", "bl", "lim", "pos", "dy", "nt", "err", "str", "lon", "l", "ind", "fin", "length", "size", " length", "f", "la", "el", "en", "seq", "lit", "line", "gen", "val", "count", "lo", "limit", "ann", "dat", "part", "db", "mem"]}}
{"project": "qemu", "commit_id": "84aa07f109f0afaeeec63c159f3a578b955c3de9", "target": 0, "func": "uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,\n\n                       uint32_t r3)\n\n{\n\n    uintptr_t ra = GETPC();\n\n    uint64_t destlen = get_length(env, r1 + 1);\n\n    uint64_t dest = get_address(env, r1);\n\n    uint64_t srclen = get_length(env, r3 + 1);\n\n    uint64_t src = get_address(env, r3);\n\n    uint8_t pad = a2 & 0xff;\n\n    uint32_t cc = 0;\n\n\n\n    if (!(destlen || srclen)) {\n\n        return cc;\n\n    }\n\n\n\n    if (srclen > destlen) {\n\n        srclen = destlen;\n\n    }\n\n\n\n    for (; destlen || srclen; src++, dest++, destlen--, srclen--) {\n\n        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;\n\n        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;\n\n        if (v1 != v2) {\n\n            cc = (v1 < v2) ? 1 : 2;\n\n            break;\n\n        }\n\n    }\n\n\n\n    set_length(env, r1 + 1, destlen);\n\n    /* can't use srclen here, we trunc'ed it */\n\n    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);\n\n    set_address(env, r1, dest);\n\n    set_address(env, r3, src);\n\n\n\n    return cc;\n\n}\n", "idx": 15615, "substitutes": {"env": ["en", "enh", "tx", "esp", "priv", "ah", "event", "h", "server", "np", "obj", "dev", "export", "c", "end", "here", "ec", "chal", "fen", "context", "done", "iv", "eu", "req", "vm", "txt", "w", "console", "loader", "equ", "viron", "her", "ext", "eni", "dt", "exec", "gui", "ev", "el", "core", "erv", "edge", "po", "ea", "ench", "cv", "config", "kn", "pg", "conn", "stage", "enable", "e", "exc", "engine", "nc", "site", "eng", "Environment", "state", "global", "ne", "que", "net", "ctx", "err", "qa", "enc", "ex", "er", "py", "this", "v", "conf", "energy", "buf", "dat", "shell", "esc", "environment", "vs", "opt"], "r1": ["p2", "r81", " r6", "rOne", " rOne", "R16", "arOne", "R3", "R4", " r16", " r2", "rc2", "r01", "p3", "sr2", "nr1", "R01", "ar2", " r4", " r81", "sr1", "v2", "p1", "r4", "R1", "nr16", " r01", "p01", "r2", "v6", "ar4", "v3", "rc3", "rc4", "r6", "sr4", "v1", "R81", "nr81", "ar1", "srOne", "r16", "rc1", "R2", "nr3", "R6"], "a2": ["A2", "A1", "alpha3", "alpha4", "A0", "a1", "va3", "a0", "A8", " a72", "A4", "as0", "alpha1", "as72", "alpha2", "va4", "A3", "va1", "va2", "A72", "a72", " a8", " a0", "a4", "a3", "as8", "as2", "a8"], "r3": ["rbThird", "rarthree", " r53", "er53", "dr03", "rr2003", " r6", " rThird", "ar3", "R3", " r2003", "er83", "rb3", " r2", " r9", "rr3", "r63", "rc63", "ar6", "arThree", "p3", "ar03", "ar53", "a53", "rb83", "rc03", "a03", "rbthree", "rar2003", "rthree", "dr9", "p03", "rr1", "R1", "dr53", "rar2", "r2", "er3", "r83", "Rthree", "rc3", "rarThree", "r9", "rcThree", "r6", "ar63", "p53", "p83", "r2003", " rthree", "er03", "r53", "rThird", "rb2", "ar1", "rarThird", " r03", "dr3", "rar3", "rb03", "rb53", "a3", "rrthree", "rThree", "rar63", "R2", "a9", "R53", "rr2", "R6", "rar03", "r03"], "src": ["RC", "rib", "proc", "uc", "bc", "slice", "sync", "dist", "rc", "cc", "config", "supp", "ctr", "sup", "https", "ub", "syn", "source", "req", "range", "sr", "st", "sq", "loc", "server", "uri", "access", "img", "rb", "desc", "comp", "b", "sb", "inst", "rw", "trans", "ape", "gb", "origin", "spec", "url", "cb", "sn", "sc", "ssl", "rob", "text", "target", "sl", "rt", "sur", "sh", "sub", "sel", "ource", "cur", "ruby", "addr"], "dest": ["ord", "tx", "uc", "ru", "d", "dist", "tmp", "rc", "config", "cdn", "priv", "da", "home", "sup", "source", "ident", "di", "txt", "asc", "dir", "loc", "conn", "de", "access", "dev", "rec", "rb", "desc", "data", "wb", "rw", "trans", "dat", "dep", "route", "dc", "gen", "target", "text", "sc", "cont", "sur", "ds", "Dest", "sub", "decl", "rest", "coord", "wd", "ptr", "comb", "go"], "destlen": ["destLen", "targetlength", "Destlength", "destli", " destli", "distl", "targetcount", "sourceLen", "desclength", " destl", " destpos", "descLen", "destlength", " destLen", " destlength", "destpos", "srclength", "srcel", "srcLen", "Destlen", "Destli", "destl", "desccount", "distlen", "sourcelength", "sourcepos", "targetlen", "distLen", "targetLen", "routelen", "sourcelen", "Destcount", "Destl", "descli", "destcount", "descl", "desclen", "distel", "srcli", "descel", "DestLen", "routelength", "destel", "srcpos", "routeLen", "srcl"], "srclen": ["serslen", "srgline", "hrclener", "serslhen", "srllenn", "nrcler", "srclend", "yrsleni", "serclena", "vraclen", "vrclenn", "srcelenn", "hrclen", "serslena", "srceler", "srClenc", "hrflend", "krclened", "vraclener", "yrslense", "srflen", "hrflon", "krslened", "vrclener", "sraclenn", "srblense", "sercleng", "srslened", "srcline", "nrclenn", "srslon", "srclun", "hrllener", "yrclenc", "srblenc", "yrclen", "nrceler", "srllener", "srblend", "srglenn", "srlcener", "srcilenn", "srglun", "srlcenn", "srclon", "srflon", "srclener", "srslenc", "hrlline", "srglen", "nrcelen", "krclun", "srlcaren", "srCleni", "vrclen", "srglened", "srclense", "srClena", "srClense", "nrclen", "srsleng", "srsclaren", "srcilan", "srslend", "srfleng", "srflhen", "hrclon", "srsclenn", "krslan", "serclen", "srbleni", "hrclenn", "srslense", "srslener", "srCleng", "yrclense", "sracline", "srcilun", "srsleni", "srlcen", "srselen", "srselenn", "srsclener", "hrllen", "srcleng", "srclenn", "srcelen", "yrslen", "vraclenn", "srlline", "hrflener", "srblener", "srslena", "yrslenc", "nrcelon", "srclan", "srllen", "hrllenn", "sraclen", "srsclen", "vraclaren", "sraclaren", "srslun", "krclen", "srclenc", "srciler", "srcler", "srflener", "srblen", "srClen", "srslan", "sersleng", "srslen", "vrclaren", "srseler", "hrcline", "srglener", "srcleni", "srflend", "srClhen", "srclhen", "srcilon", "srclened", "srglan", "srslhen", "sraclener", "yrcleni", "serclhen", "srflena", "hrflen", "srselon", "srclaren", "srblon", "nrcelenn", "krclan", "srclena", "hrclend", "krslun", "nrclon", "srcelon", "krslen", "srcilen", "srcilened"]}}
{"project": "qemu", "commit_id": "1f8431f42d833e8914f2d16ce4a49b7b72b90db0", "target": 0, "func": "bool machine_iommu(MachineState *machine)\n\n{\n\n    return machine->iommu;\n\n}\n", "idx": 2535, "substitutes": {"machine": ["vm", "service", "interface", "alias", "mc", "image", "oper", "computer", "field", "boot", "model", "instance", "super", "m", "proc", "Machine", "company", "inner", "master", "source", "address", "state", "private", "message", "money", "object", "node", "comment", "inst", "manager", "element", "rule", "link", "line", "mode", "slave", "agent", "part"]}}
{"project": "qemu", "commit_id": "6e6e55f5c2e5b520d6506c2716287ba3b5d1bbc8", "target": 0, "func": "static void QEMU_NORETURN help(void)\n\n{\n\n    const char *help_msg =\n\n           QEMU_IMG_VERSION\n\n           \"usage: qemu-img [standard options] command [command options]\\n\"\n\n           \"QEMU disk image utility\\n\"\n\n           \"\\n\"\n\n           \"    '-h', '--help'       display this help and exit\\n\"\n\n           \"    '-V', '--version'    output version information and exit\\n\"\n\n           \"    '-T', '--trace'      [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\"\n\n           \"                         specify tracing options\\n\"\n\n           \"\\n\"\n\n           \"Command syntax:\\n\"\n\n#define DEF(option, callback, arg_string)        \\\n\n           \"  \" arg_string \"\\n\"\n\n#include \"qemu-img-cmds.h\"\n\n#undef DEF\n\n#undef GEN_DOCS\n\n           \"\\n\"\n\n           \"Command parameters:\\n\"\n\n           \"  'filename' is a disk image filename\\n\"\n\n           \"  'objectdef' is a QEMU user creatable object definition. See the qemu(1)\\n\"\n\n           \"    manual page for a description of the object properties. The most common\\n\"\n\n           \"    object type is a 'secret', which is used to supply passwords and/or\\n\"\n\n           \"    encryption keys.\\n\"\n\n           \"  'fmt' is the disk image format. It is guessed automatically in most cases\\n\"\n\n           \"  'cache' is the cache mode used to write the output disk image, the valid\\n\"\n\n           \"    options are: 'none', 'writeback' (default, except for convert), 'writethrough',\\n\"\n\n           \"    'directsync' and 'unsafe' (default for convert)\\n\"\n\n           \"  'src_cache' is the cache mode used to read input disk images, the valid\\n\"\n\n           \"    options are the same as for the 'cache' option\\n\"\n\n           \"  'size' is the disk image size in bytes. Optional suffixes\\n\"\n\n           \"    'k' or 'K' (kilobyte, 1024), 'M' (megabyte, 1024k), 'G' (gigabyte, 1024M),\\n\"\n\n           \"    'T' (terabyte, 1024G), 'P' (petabyte, 1024T) and 'E' (exabyte, 1024P)  are\\n\"\n\n           \"    supported. 'b' is ignored.\\n\"\n\n           \"  'output_filename' is the destination disk image filename\\n\"\n\n           \"  'output_fmt' is the destination format\\n\"\n\n           \"  'options' is a comma separated list of format specific options in a\\n\"\n\n           \"    name=value format. Use -o ? for an overview of the options supported by the\\n\"\n\n           \"    used format\\n\"\n\n           \"  'snapshot_param' is param used for internal snapshot, format\\n\"\n\n           \"    is 'snapshot.id=[ID],snapshot.name=[NAME]', or\\n\"\n\n           \"    '[ID_OR_NAME]'\\n\"\n\n           \"  'snapshot_id_or_name' is deprecated, use 'snapshot_param'\\n\"\n\n           \"    instead\\n\"\n\n           \"  '-c' indicates that target image must be compressed (qcow format only)\\n\"\n\n           \"  '-u' enables unsafe rebasing. It is assumed that old and new backing file\\n\"\n\n           \"       match exactly. The image doesn't need a working backing file before\\n\"\n\n           \"       rebasing in this case (useful for renaming the backing file)\\n\"\n\n           \"  '-h' with or without a command shows this help and lists the supported formats\\n\"\n\n           \"  '-p' show progress of command (only certain commands)\\n\"\n\n           \"  '-q' use Quiet mode - do not print any output (except errors)\\n\"\n\n           \"  '-S' indicates the consecutive number of bytes (defaults to 4k) that must\\n\"\n\n           \"       contain only zeros for qemu-img to create a sparse image during\\n\"\n\n           \"       conversion. If the number of bytes is 0, the source will not be scanned for\\n\"\n\n           \"       unallocated or zero sectors, and the destination image will always be\\n\"\n\n           \"       fully allocated\\n\"\n\n           \"  '--output' takes the format in which the output must be done (human or json)\\n\"\n\n           \"  '-n' skips the target volume creation (useful if the volume is created\\n\"\n\n           \"       prior to running qemu-img)\\n\"\n\n           \"\\n\"\n\n           \"Parameters to check subcommand:\\n\"\n\n           \"  '-r' tries to repair any inconsistencies that are found during the check.\\n\"\n\n           \"       '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\\n\"\n\n           \"       kinds of errors, with a higher risk of choosing the wrong fix or\\n\"\n\n           \"       hiding corruption that has already occurred.\\n\"\n\n           \"\\n\"\n\n           \"Parameters to convert subcommand:\\n\"\n\n           \"  '-m' specifies how many coroutines work in parallel during the convert\\n\"\n\n           \"       process (defaults to 8)\\n\"\n\n           \"  '-W' allow to write to the target out of order rather than sequential\\n\"\n\n           \"\\n\"\n\n           \"Parameters to snapshot subcommand:\\n\"\n\n           \"  'snapshot' is the name of the snapshot to create, apply or delete\\n\"\n\n           \"  '-a' applies a snapshot (revert disk to saved state)\\n\"\n\n           \"  '-c' creates a snapshot\\n\"\n\n           \"  '-d' deletes a snapshot\\n\"\n\n           \"  '-l' lists all snapshots in the given image\\n\"\n\n           \"\\n\"\n\n           \"Parameters to compare subcommand:\\n\"\n\n           \"  '-f' first image format\\n\"\n\n           \"  '-F' second image format\\n\"\n\n           \"  '-s' run in Strict mode - fail on different image size or sector allocation\\n\"\n\n           \"\\n\"\n\n           \"Parameters to dd subcommand:\\n\"\n\n           \"  'bs=BYTES' read and write up to BYTES bytes at a time \"\n\n           \"(default: 512)\\n\"\n\n           \"  'count=N' copy only N input blocks\\n\"\n\n           \"  'if=FILE' read from FILE\\n\"\n\n           \"  'of=FILE' write to FILE\\n\"\n\n           \"  'skip=N' skip N bs-sized blocks at the start of input\\n\";\n\n\n\n    printf(\"%s\\nSupported formats:\", help_msg);\n\n    bdrv_iterate_format(format_print, NULL);\n\n    printf(\"\\n\");\n\n    exit(EXIT_SUCCESS);\n\n}\n", "idx": 11852, "substitutes": {"QEMU_NORETURN": ["QEMU_RESATURN", "QEMU_NORISTUN", "QEMU_NOREOUN", "QEMU_NOREOURN", "QEMU_RESETURN", "QEMU_NORATUN", "QEMU_RESATUN", "QEMU_RESATurn", "QEMU_NORETUR", "QEMU_NORATUR", "QEMU_NORISTUR", "QEMU_NORATURN", "QEMU_RESATUR", "QEMU_NORISTURN", "QEMU_RESETurn", "QEMU_NOREOurn", "QEMU_RESETUN", "QEMU_NORETUN", "QEMU_NORISTurn", "QEMU_NORATurn", "QEMU_RESETUR", "QEMU_NORETurn", "QEMU_NOREOUR"], "help_msg": ["help2msg", "help_info", "helplogmsg", "utillogmsg", "help_call", "util_info", "utillogMsg", "help2info", "utillogcall", "util_msg", "help2call", "help2Msg", "util_Msg", "helplogcall", "helploginfo", "help_Msg", "helplogMsg", "utilloginfo", "util_call"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)\n\n{\n\n    int rex;\n\n\n\n    if (opc & P_GS) {\n\n        tcg_out8(s, 0x65);\n\n    }\n\n    if (opc & P_DATA16) {\n\n        /* We should never be asking for both 16 and 64-bit operation.  */\n\n        assert((opc & P_REXW) == 0);\n\n        tcg_out8(s, 0x66);\n\n    }\n\n    if (opc & P_ADDR32) {\n\n        tcg_out8(s, 0x67);\n\n    }\n\n\n\n    rex = 0;\n\n    rex |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */\n\n    rex |= (r & 8) >> 1;                /* REX.R */\n\n    rex |= (x & 8) >> 2;                /* REX.X */\n\n    rex |= (rm & 8) >> 3;               /* REX.B */\n\n\n\n    /* P_REXB_{R,RM} indicates that the given register is the low byte.\n\n       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,\n\n       as otherwise the encoding indicates %[abcd]h.  Note that the values\n\n       that are ORed in merely indicate that the REX byte must be present;\n\n       those bits get discarded in output.  */\n\n    rex |= opc & (r >= 4 ? P_REXB_R : 0);\n\n    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);\n\n\n\n    if (rex) {\n\n        tcg_out8(s, (uint8_t)(rex | 0x40));\n\n    }\n\n\n\n    if (opc & (P_EXT | P_EXT38)) {\n\n        tcg_out8(s, 0x0f);\n\n        if (opc & P_EXT38) {\n\n            tcg_out8(s, 0x38);\n\n        }\n\n    }\n\n\n\n    tcg_out8(s, opc);\n\n}\n", "idx": 2195, "substitutes": {"s": ["sg", "js", "service", "opens", "cs", "sup", "http", "ss", "ctx", "ts", "ges", "self", "sb", "cpp", "d", "n", "is", "ions", "i", "g", "bis", "ses", "sf", "sync", "settings", "tests", "sets", "ds", "status", "ps", "gs", "native", "ns", "h", "c", "p", "services", "w", "e", "us", "f", "es", "setup", "ches", "sys", "sq", "sports", "u", "lines", "south", "o", "b", "su", "t", "site", "session", "os", "hs", "states", "se", "fs", "si", "ssl"], "opc": ["copci", "optc", "ospc", "ipcu", "OPc", " opz", "hopf", "ortc", "ospcu", "hoppc", "opt", "copcs", "ripcs", "ospci", "opcs", "libf", " opf", "ospcs", "oppcs", " opcs", "oopn", "opn", "copg", "ippc", "oopt", "operf", "optf", "ripc", "libpc", "copc", "opercs", "opercu", "upc", "OPci", "opcu", "ovcu", " opcu", "hopc", "opci", "copz", "oopcit", "copf", "opcit", "ipc", "ropg", " oplc", "ipcs", "upf", "libcs", "ripf", "ortcs", "oppcu", " opci", "oopc", "ovcs", "opf", "OPcu", "copcit", " opcit", "ovf", "optcu", "uplc", "oppc", "hopt", "ipf", "ropz", "oplc", "operc", " opg", "optlc", "ropf", "ortpc", "ripcu", "hopn", "ropn", "ortf", "oopci", "ropt", "ipci", "libc", " oppc", "oppf", "oopf", "opg", "ropc", "opz", "upcu", "OPcs", "hopcs", "ovc"], "r": ["dr", "q", "rs", "gr", "h", "rr", "d", "n", "lr", "rf", "kr", "i", "g", "rb", "m", "nr", "er", "ir", "fr", "z", "l", "p", "pr", "or", "w", "e", "c", "f", "ro", "br", "ar", "u", "R", "range", "o", "v", "sr", "b", "rx", "rar", "re", "reg", "rt", "rh", "rc"], "rm": ["rg", "dr", "cm", "vm", "rage", "mx", "rn", "bm", "rr", "rob", "lr", "rf", "vre", "adr", "rb", "m", "nr", "RM", "cr", "md", "rpm", "dm", "rl", "ref", "rem", "ro", "pm", "ore", "rd", "rom", "nm", "mr", "b", "rx", "rar", "re", "addr", "rt", "vr", "ril", "reg", "rh"], "x": ["xes", "q", "xt", "d", "n", "y", "i", "g", "m", "code", "tx", "lex", "X", "xs", "z", "xp", "xx", "h", "l", "p", "xc", "c", "w", "e", "f", "ar", "u", "o", "v", "ix", "b", "rx", "re", "ex", "rc"], "rex": ["Rex", "test", " cx", "xa", "rice", "cross", "ext", "nex", "breaker", "nexus", "xf", "gru", "frac", "gre", "com", "xxxx", "orig", "fax", "xy", "dx", "proxy", "rep", "none", "flex", "tx", "lex", "number", "xs", "coord", "xp", "abc", "fe", "xx", "exc", "result", "xc", "xff", "EX", "xb", "rench", "rax", "rez", "ticket", "xxxxxxxx", "prefix", "xe", "su", "cmp", "rx", "pex", "sex", "re", "gal", "ux", "cone", "ex", "res", "xi", "wx"]}}
{"project": "FFmpeg", "commit_id": "a1e093a6fb324612266d40e3168a14f58adab265", "target": 0, "func": "static int decode_element(AVCodecContext *avctx, void *data, int ch_index,\n\n                          int channels)\n\n{\n\n    ALACContext *alac = avctx->priv_data;\n\n    int has_size, bps, is_compressed, decorr_shift, decorr_left_weight, ret;\n\n    uint32_t output_samples;\n\n    int i, ch;\n\n\n\n    skip_bits(&alac->gb, 4);  /* element instance tag */\n\n    skip_bits(&alac->gb, 12); /* unused header bits */\n\n\n\n    /* the number of output samples is stored in the frame */\n\n    has_size = get_bits1(&alac->gb);\n\n\n\n    alac->extra_bits = get_bits(&alac->gb, 2) << 3;\n\n    bps = alac->sample_size - alac->extra_bits + channels - 1;\n\n    if (bps > 32) {\n\n        av_log(avctx, AV_LOG_ERROR, \"bps is unsupported: %d\\n\", bps);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    /* whether the frame is compressed */\n\n    is_compressed = !get_bits1(&alac->gb);\n\n\n\n    if (has_size)\n\n        output_samples = get_bits_long(&alac->gb, 32);\n\n    else\n\n        output_samples = alac->max_samples_per_frame;\n\n    if (!output_samples || output_samples > alac->max_samples_per_frame) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid samples per frame: %d\\n\",\n\n               output_samples);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!alac->nb_samples) {\n\n        /* get output buffer */\n\n        alac->frame.nb_samples = output_samples;\n\n        if ((ret = avctx->get_buffer(avctx, &alac->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return ret;\n\n        }\n\n    } else if (output_samples != alac->nb_samples) {\n\n        av_log(avctx, AV_LOG_ERROR, \"sample count mismatch: %u != %d\\n\",\n\n               output_samples, alac->nb_samples);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    alac->nb_samples = output_samples;\n\n    if (alac->direct_output) {\n\n        for (ch = 0; ch < channels; ch++)\n\n            alac->output_samples_buffer[ch] = (int32_t *)alac->frame.extended_data[ch_index + ch];\n\n    }\n\n\n\n    if (is_compressed) {\n\n        int16_t lpc_coefs[2][32];\n\n        int lpc_order[2];\n\n        int prediction_type[2];\n\n        int lpc_quant[2];\n\n        int rice_history_mult[2];\n\n\n\n        decorr_shift       = get_bits(&alac->gb, 8);\n\n        decorr_left_weight = get_bits(&alac->gb, 8);\n\n\n\n        for (ch = 0; ch < channels; ch++) {\n\n            prediction_type[ch]   = get_bits(&alac->gb, 4);\n\n            lpc_quant[ch]         = get_bits(&alac->gb, 4);\n\n            rice_history_mult[ch] = get_bits(&alac->gb, 3);\n\n            lpc_order[ch]         = get_bits(&alac->gb, 5);\n\n\n\n            /* read the predictor table */\n\n            for (i = lpc_order[ch] - 1; i >= 0; i--)\n\n                lpc_coefs[ch][i] = get_sbits(&alac->gb, 16);\n\n        }\n\n\n\n        if (alac->extra_bits) {\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                if(get_bits_left(&alac->gb) <= 0)\n\n                    return -1;\n\n                for (ch = 0; ch < channels; ch++)\n\n                    alac->extra_bits_buffer[ch][i] = get_bits(&alac->gb, alac->extra_bits);\n\n            }\n\n        }\n\n        for (ch = 0; ch < channels; ch++) {\n\n            int ret=rice_decompress(alac, alac->predict_error_buffer[ch],\n\n                            alac->nb_samples, bps,\n\n                            rice_history_mult[ch] * alac->rice_history_mult / 4);\n\n            if(ret<0)\n\n                return ret;\n\n\n\n            /* adaptive FIR filter */\n\n            if (prediction_type[ch] == 15) {\n\n                /* Prediction type 15 runs the adaptive FIR twice.\n\n                 * The first pass uses the special-case coef_num = 31, while\n\n                 * the second pass uses the coefs from the bitstream.\n\n                 *\n\n                 * However, this prediction type is not currently used by the\n\n                 * reference encoder.\n\n                 */\n\n                lpc_prediction(alac->predict_error_buffer[ch],\n\n                               alac->predict_error_buffer[ch],\n\n                               alac->nb_samples, bps, NULL, 31, 0);\n\n            } else if (prediction_type[ch] > 0) {\n\n                av_log(avctx, AV_LOG_WARNING, \"unknown prediction type: %i\\n\",\n\n                       prediction_type[ch]);\n\n            }\n\n            lpc_prediction(alac->predict_error_buffer[ch],\n\n                           alac->output_samples_buffer[ch], alac->nb_samples,\n\n                           bps, lpc_coefs[ch], lpc_order[ch], lpc_quant[ch]);\n\n        }\n\n    } else {\n\n        /* not compressed, easy case */\n\n        for (i = 0; i < alac->nb_samples; i++) {\n\n            if(get_bits_left(&alac->gb) <= 0)\n\n                return -1;\n\n            for (ch = 0; ch < channels; ch++) {\n\n                alac->output_samples_buffer[ch][i] =\n\n                         get_sbits_long(&alac->gb, alac->sample_size);\n\n            }\n\n        }\n\n        alac->extra_bits   = 0;\n\n        decorr_shift       = 0;\n\n        decorr_left_weight = 0;\n\n    }\n\n\n\n    if (channels == 2 && decorr_left_weight) {\n\n        decorrelate_stereo(alac->output_samples_buffer, alac->nb_samples,\n\n                           decorr_shift, decorr_left_weight);\n\n    }\n\n\n\n    if (alac->extra_bits) {\n\n        append_extra_bits(alac->output_samples_buffer, alac->extra_bits_buffer,\n\n                          alac->extra_bits, channels, alac->nb_samples);\n\n    }\n\n\n\n    if(av_sample_fmt_is_planar(avctx->sample_fmt)) {\n\n    switch(alac->sample_size) {\n\n    case 16: {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            int16_t *outbuffer = (int16_t *)alac->frame.extended_data[ch_index + ch];\n\n            for (i = 0; i < alac->nb_samples; i++)\n\n                *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n        }}\n\n        break;\n\n    case 24: {\n\n        for (ch = 0; ch < channels; ch++) {\n\n            for (i = 0; i < alac->nb_samples; i++)\n\n                alac->output_samples_buffer[ch][i] <<= 8;\n\n        }}\n\n        break;\n\n    }\n\n    }else{\n\n        switch(alac->sample_size) {\n\n        case 16: {\n\n            int16_t *outbuffer = ((int16_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        case 24: {\n\n            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i] << 8;\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        case 32: {\n\n            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;\n\n            for (i = 0; i < alac->nb_samples; i++) {\n\n                for (ch = 0; ch < channels; ch++)\n\n                    *outbuffer++ = alac->output_samples_buffer[ch][i];\n\n                outbuffer += alac->channels - channels;\n\n            }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 10750, "substitutes": {"avctx": ["afconn", "avalbc", "afctx", "afcup", "AVcf", "avalctx", "avalcontext", "navctx", "avebc", " avdc", "alconn", "Avctl", "avbc", "alctl", "afpkg", "avectx", " avca", "alcontext", "afmac", "avmac", "avemac", "afctl", "verpkg", "avcf", "navconn", "AVcontext", "avdc", "avedc", "avcup", "alctx", "verctx", "vercontext", "afcf", "verlc", "avconn", "aflc", "Avcf", " avmac", "AVlc", "avlc", "AVctx", "AVconn", "afbc", " avcontext", "verconn", "avalconn", "avcontext", "Avctx", " avcf", "navcf", "avpkg", "avca", "navcontext", "afca", "AVctl", "afdc", "alpkg", "avecf", "aveconn", "avecontext", "aveca", "avctl", "afcontext", "navcup", "verctl", "avecup", "navctl", "Avcontext"], "data": ["parent", "base", "context", "source", "media", "window", "da", "d", "config", "batch", "reader", "ata", "memory", "frame", "array", "body", "DATA", "dat", "input", "connection", "audio", "Data", "api", "image", "cache", "result", "buffer", "database"], "ch_index": ["ach_Index", "ch_Index", "chkslice", "chkIndex", "ach_level", "chslevel", "ch_level", "ach_slice", "chklevel", "chsindex", "ach_index", "ch_slice", "chsIndex", "chkindex", "chsslice"], "channels": [" chunks", "cars", "cords", "shannels", "channel", "chords", "Chords", "Chunks", "cannels", "shords", "Chanes", "chunks", "Chars", "shanes", "CHapters", "compunks", "compords", "shars", "companes", " chapters", "CHannel", "chanes", "tchannels", "tchunks", "cunks", " channel", "shunks", "Channels", "chars", "tchapters", "compannels", "CHannels", "chapters", "CHunks", "tchannel"], "alac": ["almac", "alec", "realacs", "alacl", "palacs", "pelacc", "pelax", "malac", "plax", "alsac", "realac", "elmac", "llax", "ilacc", "elact", "ellas", " aljac", "isalacer", "challac", " alacs", "alacc", "allac", "realanc", " alax", "calas", "balacc", "eliac", "palanc", " aloc", "aliacc", "alianc", "alacer", "alas", "llac", "plac", "balas", "ALac", "chalanc", "unalacc", "balact", "llanc", "aloc", "chalacl", "allas", "malacc", "isalAC", "alax", "ellmac", "alsec", "ralanc", "challacc", "alsacc", "aljac", "realacc", "aliiac", "calacs", "calec", " alas", "elacc", "pelac", "isalacl", " alec", " alanc", "alsoc", "ALacs", "llact", "ALAC", "ilas", "belacs", "alanc", "unalac", "belacc", "chalas", "chalacs", "elanc", "ellac", "eloc", "unalmac", "maliac", " alact", "calax", " alacc", "alsiac", "aliacl", "ralact", "llas", "plAC", "alioc", " alacl", "ALacc", "calmac", "ellacc", "calanc", "alsacs", "isaljac", "planc", "baloc", "elas", "challax", "aliacs", "belac", " alacer", "isalacc", "ralacc", "unalax", "palacc", "balanc", "isalanc", "isalac", "chalac", "aliac", "balmac", "alsmac", "calac", "isaloc", "elac", "challas", "alact", "balac", "llacc", "elacs", " alAC", "ilac", "placc", "palac", "caliac", "calacer", "placs", "calacc", "eljac", "ralac", "alacs", "malmac", "elAC", " almac", "belacl", "allanc", "ilanc", "alAC", "calAC", "alsacl", "chalacc", "pelAC", "allacc"], "has_size": ["hasRcount", "has_time", "is_count", "has_sized", "has_width", "hasRwidth", " has_time", "has67sized", "is_sized", "has_count", "hasRsized", "has_speed", "has67speed", "hasRsize", "full_speed", "full_sized", "has67size", "is_width", " has_group", "is_size", "full_size", "has_group"], "bps": ["lp", "vs", "apps", "bb", "abytes", "nb", "strings", "prefix", "lbs", "aps", "stats", "cases", "bp", "prot", "tips", "pps", "ops", "posts", "ipes", "ls", "pb", "parts", "pieces", "fp", "steps", "jobs", "bands", "bits", "rb", "planes", "offs", "pins", "objects", "lines", "bys", "plugins", "limits", "items", "fps", "eps", "bis", "codes", "hops", "details", "sb", "blocks", "bytes", "allows", "rates", "points", "ips", "params", "ps", "nets", "bs"], "is_compressed": ["is_cress", "is_Compressed", "is_suppression", "is_cressed", "is_Compression", "is_ompress", "is_composed", "is_compress", "is_Composed", "is_ompression", "is_suppressed", "is_compression", "is_Compress", "is_cured", "is_cression", "is_compured", "is_ompressed", "is_supposed", "is_suppured", "is_omposed", "is_Compured", "is_suppress"], "decorr_shift": ["decorr_offset", "decoris_left", "decorr\u00b7left", "decorr\u00b7shift", "decorr_left", "decorr\u00b7power", "decorr\u00b7offset", "decoris_power", "decoris_offset", "decorr_power", "decoris_shift"], "decorr_left_weight": ["decorr_left2count", "decorr_shift_weights", "decorr_shift_count", "decorr_left2weight", "decorr_left2shift", "decorr_shift_shift", "decorr_shift_weight", "decorr_left_count", "decorr_left_weights", "decorr_left2weights", "decorr_left_shift"], "ret": ["arr", "valid", "ext", "len", "val", "alt", "def", "nt", "ait", "temp", "Ret", "mem", "reply", "ref", "lit", "fit", "cb", "reg", "obj", "txt", "value", "utf", "rb", "rets", "bc", "rt", "res", "det", "format", "rc", "fun", "att", "req", "mat", "bis", "cur", "ben", "rep", "get", "bit", "fin", "re", "RET", "back", "out", "result", "rev", "ft", "match", "resp", "buffer", "success", "pet"], "output_samples": ["output_asamps", "output_setsamp", "output_sacks", "output_tales", "output_nonents", "output_suffipes", "output_lacks", "output_requamples", "output_sipes", "output\u00b7servicesamples", "output_sones", "output_outsamps", "output_outsiles", "output_setsamples", "output_esamp", "output_vamples", "output_pores", "output_nones", "output_damples", "output_namps", "output_sales", "output_tamps", "output_assips", "output_sips", "output_requones", "output_tamples", "output_siles", "output_nizes", "output_sances", "output_suamples", "output_Sonents", "output_lones", "output_linesills", "output_setsamps", "output_linesamples", "output\u00b7servicesases", "output_samp", "output_sesamp", "output_lannels", "output_seamples", "output_samps", "output_suffannels", "output_asamples", "output\u00b7samp", "output_vips", "output_outspects", "output_suffums", "output_sportsamps", "output_nannels", "output_asales", "output_assamples", "output\u00b7sonents", "output_sannels", "output_esamples", "output_requacks", "output_dannels", "output_dums", "output_sesances", "output_lums", "output\u00b7sases", "output_requamps", "output_dipes", "output_servicesamples", "output\u00b7linesonents", "output_Sills", "output_vamps", "output_lamps", "output\u00b7linesamples", "output_sample", "output\u00b7linesills", "output_pamps", "output_sases", "output_npects", "output\u00b7servicesamp", "output_nales", "output_sills", "output_namples", "output_esases", "output_lamples", "output_suores", "output_pamples", "output_assamps", "output_linesonents", "output_Sessions", "output\u00b7samples", "output_servicesamp", "output\u00b7servicesamps", "output_Samples", "output_outsamples", "output_seores", "output_sessions", "output_sesamps", "output_Samps", "output_servicesessions", "output_suample", "output_sportspects", "output_sores", "output_nips", "output_seample", "output_suffamples", "output\u00b7sills", "output_servicesamps", "output_nacks", "output_sportsiles", "output_sums", "output_lipes", "output_nills", "output_spects", "output_pample", "output_vizes", "output_servicesases", "output_tannels", "output_sizes", "output_niles", "output_namp", "output_setsances", "output_seamps", "output\u00b7samps", "output_nances", "output_suamps", "output_nases", "output_asannels", "output_sportsamples", "output_sesamples", "output_esamps", "output_sonents", "output_assizes"], "i": ["count", "l", "channel", "base", "it", "n", "b", "x", "k", "z", "num", "d", "c", "p", "e", "f", "j", "ai", "v", "chi", "pi", "bi", "ii", "I", "ip", "ci", "io"], "ch": ["count", "l", "channel", "chrom", "conf", "sh", "oy", "cmp", "arch", "ach", "ph", "conn", "ich", "chip", "b", "ver", "c", "cp", "qu", "batch", "och", "p", "app", "cb", "cf", "gh", "CH", "loc", "q", "cho", "f", "sk", "j", "code", "zh", "child", "th", "cht", "cha", "anch", "che", "ind", "cher", "bh", "ctx", "chi", "sch", "cl", "mot", "cor", "col", "Ch", "change", "h", "ech", "dev", "ci", "comp", "length", "cmd", "chan"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int select_watchdog(const char *p)\n\n{\n\n    WatchdogTimerModel *model;\n\n    QemuOpts *opts;\n\n\n\n    /* -watchdog ? lists available devices and exits cleanly. */\n\n    if (strcmp(p, \"?\") == 0) {\n\n        LIST_FOREACH(model, &watchdog_list, entry) {\n\n            fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                     model->wdt_name, model->wdt_description);\n\n        }\n\n        return 2;\n\n    }\n\n\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        if (strcasecmp(model->wdt_name, p) == 0) {\n\n            /* add the device */\n\n            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);\n\n            qemu_opt_set(opts, \"driver\", p);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Unknown -watchdog device. Supported devices are:\\n\");\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                 model->wdt_name, model->wdt_description);\n\n    }\n\n    return 1;\n\n}\n", "idx": 18345, "substitutes": {"p": ["pc", "wp", "m", "point", "s", "t", "data", "fp", "f", "jp", "name", "sp", "vp", "r", "pe", "n", "ar", "g", "i", "bp", "type", "cp", "lp", "python", "ap", "pb", "parser", "o", "ip", "l", "pair", "d", "pp", "path", "pre", "e", "pa", "q", "v", "par", "c", "ps", "b", "param", "h", "tp", "np", "P", "u"], "model": ["entry", "pattern", "child", "user", "comment", "service", "gu", "file", "package", "copy", "store", "bank", "config", "id", "language", "xml", "resource", "serial", "command", "source", "reader", "m", "mod", "name", "media", "cm", "document", "app", "models", "scope", "self", "lv", "style", "parent", "lc", "table", "null", "product", "cell", "connection", "code", "view", "core", "base", "image", "cookie", "script", "block", "type", "this", "ml", "sm", "email", "ga", "line", "Model", "live", "template", "project", "ma", "author", "session", "db", "record", "global", "where", "data", "mode", "pe", "feed", "module", "sl", "method", "shell", "get", "link", "cl", "client", "form", "message", "server", "el"], "opts": ["otts", "opents", "OPts", "OPt", " oputs", " opps", "ots", "opouts", "opert", "ops", "operouts", "opps", "opta", "otps", "opcs", "ocs", "optents", " opents", "optts", "ota", "operts", "OPps", "optps", "optuts", "operents", "otcs", " opouts", "optcs", " opt", "OPuts", "optt", "opt", "oputs", "optta", "otta", "optouts"]}}
{"project": "FFmpeg", "commit_id": "24947d4988012f1f0fd467c83418615adc11c3e8", "target": 1, "func": "static int vorbis_floor1_decode(vorbis_context *vc,\n\n                                vorbis_floor_data *vfu, float *vec)\n\n{\n\n    vorbis_floor1 *vf = &vfu->t1;\n\n    GetBitContext *gb = &vc->gb;\n\n    uint16_t range_v[4] = { 256, 128, 86, 64 };\n\n    unsigned range = range_v[vf->multiplier - 1];\n\n    uint16_t floor1_Y[258];\n\n    uint16_t floor1_Y_final[258];\n\n    int floor1_flag[258];\n\n    unsigned class, cdim, cbits, csub, cval, offset, i, j;\n\n    int book, adx, ady, dy, off, predicted, err;\n\n\n\n\n\n    if (!get_bits1(gb)) // silence\n\n        return 1;\n\n\n\n// Read values (or differences) for the floor's points\n\n\n\n    floor1_Y[0] = get_bits(gb, ilog(range - 1));\n\n    floor1_Y[1] = get_bits(gb, ilog(range - 1));\n\n\n\n    av_dlog(NULL, \"floor 0 Y %d floor 1 Y %d \\n\", floor1_Y[0], floor1_Y[1]);\n\n\n\n    offset = 2;\n\n    for (i = 0; i < vf->partitions; ++i) {\n\n        class = vf->partition_class[i];\n\n        cdim   = vf->class_dimensions[class];\n\n        cbits  = vf->class_subclasses[class];\n\n        csub = (1 << cbits) - 1;\n\n        cval = 0;\n\n\n\n        av_dlog(NULL, \"Cbits %u\\n\", cbits);\n\n\n\n        if (cbits) // this reads all subclasses for this partition's class\n\n            cval = get_vlc2(gb, vc->codebooks[vf->class_masterbook[class]].vlc.table,\n\n                            vc->codebooks[vf->class_masterbook[class]].nb_bits, 3);\n\n\n\n        for (j = 0; j < cdim; ++j) {\n\n            book = vf->subclass_books[class][cval & csub];\n\n\n\n            av_dlog(NULL, \"book %d Cbits %u cval %u  bits:%d\\n\",\n\n                    book, cbits, cval, get_bits_count(gb));\n\n\n\n            cval = cval >> cbits;\n\n            if (book > -1) {\n\n                floor1_Y[offset+j] = get_vlc2(gb, vc->codebooks[book].vlc.table,\n\n                vc->codebooks[book].nb_bits, 3);\n\n            } else {\n\n                floor1_Y[offset+j] = 0;\n\n            }\n\n\n\n            av_dlog(NULL, \" floor(%d) = %d \\n\",\n\n                    vf->list[offset+j].x, floor1_Y[offset+j]);\n\n        }\n\n        offset+=cdim;\n\n    }\n\n\n\n// Amplitude calculation from the differences\n\n\n\n    floor1_flag[0] = 1;\n\n    floor1_flag[1] = 1;\n\n    floor1_Y_final[0] = floor1_Y[0];\n\n    floor1_Y_final[1] = floor1_Y[1];\n\n\n\n    for (i = 2; i < vf->x_list_dim; ++i) {\n\n        unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs;\n\n\n\n        low_neigh_offs  = vf->list[i].low;\n\n        high_neigh_offs = vf->list[i].high;\n\n        dy  = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs];  // render_point begin\n\n        adx = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x;\n\n        ady = FFABS(dy);\n\n        err = ady * (vf->list[i].x - vf->list[low_neigh_offs].x);\n\n        off = err / adx;\n\n        if (dy < 0) {\n\n            predicted = floor1_Y_final[low_neigh_offs] - off;\n\n        } else {\n\n            predicted = floor1_Y_final[low_neigh_offs] + off;\n\n        } // render_point end\n\n\n\n        val = floor1_Y[i];\n\n        highroom = range-predicted;\n\n        lowroom  = predicted;\n\n        if (highroom < lowroom) {\n\n            room = highroom * 2;\n\n        } else {\n\n            room = lowroom * 2;   // SPEC mispelling\n\n        }\n\n        if (val) {\n\n            floor1_flag[low_neigh_offs]  = 1;\n\n            floor1_flag[high_neigh_offs] = 1;\n\n            floor1_flag[i]               = 1;\n\n            if (val >= room) {\n\n                if (highroom > lowroom) {\n\n                    floor1_Y_final[i] = val - lowroom + predicted;\n\n                } else {\n\n                    floor1_Y_final[i] = predicted - val + highroom - 1;\n\n                }\n\n            } else {\n\n                if (val & 1) {\n\n                    floor1_Y_final[i] = predicted - (val + 1) / 2;\n\n                } else {\n\n                    floor1_Y_final[i] = predicted + val / 2;\n\n                }\n\n            }\n\n        } else {\n\n            floor1_flag[i]    = 0;\n\n            floor1_Y_final[i] = predicted;\n\n        }\n\n\n\n        av_dlog(NULL, \" Decoded floor(%d) = %u / val %u\\n\",\n\n                vf->list[i].x, floor1_Y_final[i], val);\n\n    }\n\n\n\n// Curve synth - connect the calculated dots and convert from dB scale FIXME optimize ?\n\n\n\n    ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, vec, vf->list[1].x);\n\n\n\n    av_dlog(NULL, \" Floor decoded\\n\");\n\n\n\n    return 0;\n\n}\n", "idx": 4801, "substitutes": {"vc": ["nv", "vim", "gc", "vr", "ib", "asu", "vg", "rt", "v", "wx", "vd", "vm", "http", "ci", "vt", "bt", "sys", "uv", "fb", "db", "VC", "client", "gui", "cli", "cc", "cs", "bb", "wd", "dc", "lib", "ctx", "bc", "cb", "voc", "ic", "vp", "sv", "c", "lc", "lv", "api", "fc", "vv", "gg", "cv", "util", "cache", "cdn", "ctrl", "cop", "xc"], "vfu": ["svf", "vpu", "gpu", " vFU", "vorfs", "vorpu", "vFU", "vorf", " vpu", "svfu", " vfs", "gFU", "gfu", "gf", "ffu", "ffs", "svFU", "fpu", "svpu", "vorfu", "vfs", "ff"], "vec": ["buff", "vector", "buf", "window", "xy", "vals", "version", "ve", "length", "q", "cs", "def", "buffer", "len", "func", "fn", "binary", "lib", "score", "fps", "seq", "prop", "fs", "fc", "cv", "dim", "feature"], "vf": ["avf", " vb", "svf", "Vcf", "avc", " vfc", "svfen", "lfs", " vfen", "vvf", "vcf", "vvfen", "evcf", " vfe", "lfc", "evfs", "svfac", "Vfu", "mcf", "avcf", "evb", "svfe", "vfac", "svfu", " vfs", "vvcf", "evf", "vvfu", "svb", "Vf", "svfs", "Vfs", "mfe", "mf", "vfen", "mfs", "vfc", "svc", "vvfac", "vvc", " vfac", "avfs", "svcf", "vb", " vcf", "lf", "vfe", "vfs", "lcf", "svfc"], "gb": ["game", "plugin", "gp", "agg", "gc", "cfg", "bp", "vg", "gm", "hub", "vd", "ci", "gru", "rb", "vt", "Gb", "bg", "gnu", "sync", "bm", "gom", "database", "gpu", "uv", "db", "gu", "gio", "ga", "gow", "usb", "gin", "abb", "metadata", "pc", "gz", "bb", "eb", "hm", "sb", "gs", "rg", "gam", "binary", "storage", "lib", "bc", "GB", "cb", "multi", "nb", "mb", "gy", "kb", "range", "g", "bf", "gd", "gt", "gram", "gg", "cv", "git", "gn", "bn", "ui"], "range_v": ["ange_h", "range_u", "rangeallV", "range00V", "range00vector", "range_V", "ange_v", "range_vector", "ange_V", " range_u", "range_h", "range00u", " range_V", "range00v", "rangeallh", " range_vector", "rangeallv"], "floor1_Y": ["floor1PIP", "floor1FileGY", "floor2_y", "floor1PYY", "floor1AllY", "floor1JX", "floor1_P", "floor1HashP", "floor1LB", "floorOnePX", "floor1_GY", "floorOne_X", "floor1Py", "floor1LogY", "floor1_C", "floorOnePYY", "floor1JY", "floor1Filey", "floor1_YS", "floorOnePy", "floor1_X", "floor1FileDAY", "floorOne_YS", "floor1FileC", "floorOnePYS", "floor1_y", "floor1_IS", "floor1PYS", "floor1PB", "floorOne_YY", "floor1LogDAY", "floor1PP", "floor2_Y", "floor1JB", "floor2PYY", "floor1_IP", "floor2_YY", "floor1HashY", "floorOne_B", "floor151_GY", "floor1FileY", "floorOnePP", "floor151_y", "floor1PX", "floor151_C", "floor151_Y", "floor1Ly", "floor1_YY", "floor1LX", "floor1Jy", "floor1_B", "floor1LogIS", "floor2PIP", "floor1LY", "floor2Py", "floor2PY", "floor1AllP", "floorOnePY", "floor1FileIS", "floorOne_Y", "floor1Logy", "floor1PY", "floor1AllYS", "floor1HashYY", "floorOne_P", "floorOnePB", "floorOne_y", "floor1AllYY", "floor1HashYS", "floor1_DAY", "floor2_IP"], "floor1_Y_final": ["floor1_YRMAX", "floor1_y_Final", "floor1_YRFinal", "floor1_Y_MAX", "floor1_YRfinal", "floor1_y_final", "floor1_y_MAX", "floor1_Y_Final", "floor1_YRmax", "floor1_y_max", "floor1_Y_max"], "floor1_flag": ["floor1_Z", "floor1_flags"], "class": ["function", "plugin", "option", "Class", "name", "id", "count", "parent", "lass", "complete", "spec", "s", "component", "session", "config", "x", "object", "style", "com", "family", "use", "comp", "module", "unit", "cl", "bus", "package", "attr", "CLASS", "f", "url", "state", "length", "version", "code", "cell", "part", "classes", "sc", "section", "connection", "file", "full", "lib", "instance", "str", "lock", "bridge", "source", "seq", "p", "scale", "prop", "rule", "c", "attribute", "type", "user", "model", "cache", "test", "group", "current"], "cdim": ["xdim", "ndIM", "xdIM", "cdom", "xdom", "udims", " cdims", " cdom", "ndims", "cdims", "ydsim", "xdims", "CDim", "cdIM", " cdIM", "cdip", "ydima", "ndim", " cdsim", "ndom", "cdima", "CDims", " cdip", "cdsim", "CDIM", " cdima", "udim", "xdip", "CDip", "ydim", "udsim", "udima", "ydims"], "cbits": ["pvals", "acbs", "fops", " cwords", "vbits", "crbs", "ucits", "cplanes", "cvals", "dcval", "Cbit", " cvals", "Cubs", "pubs", "vwords", "cwords", " cplanes", " cbit", "corebits", "corevals", "cbs", "vvals", "Cwords", "cops", " cits", "cits", "dcparts", "pbits", "crvals", "lcbits", "ucints", "lcits", "fbits", "ucplanes", "cints", "fvals", "cubs", "tcparts", "Cvals", " cubs", "vbit", "lcops", "acval", " cbs", "crval", "acabs", "acbits", "lcplanes", "lcval", " cops", "cparts", "coreval", "tcval", "acvals", "lcints", "tcops", "Cbits", "Cval", "dcbits", "ucbits", "lcparts", " cints", "Cabs", "tcbits", "crbits", "Cints", "cbit", "coreops", "dcops", "pints", "fval"], "csub": ["csum", "codesuper", "ksuper", "lsub", "ksuc", "cksube", "nsug", "lsube", "rsuc", "codesuc", "rsub", "rsUB", "cksub", "lsug", "lsuper", "nsube", "ksubs", "nsub", "csube", "ksub", "csug", "cksuper", "nsuper", "ksum", "ksube", "codesUB", "cksum", "cksug", "csUB", "csuper", "lsubs", "lsum", "rsuper", "csuc", "codesub", "cksubs", "ksUB", "csubs"], "cval": ["pvals", "cret", "csel", "Cval", "Ceval", " cret", " cvalid", "dbits", " call", "lcsel", " cpos", "cuvalue", "dsel", "Call", "pvalue", "Cvals", " cvalues", "ceval", " ceval", "cueval", "cvalid", "dval", "pvalues", "call", " col", "dvals", "Cabs", "cuabs", "acval", "cachevalue", "cvalue", "cacheeval", "pall", "col", "cvals", "acol", "acvalid", "acvalue", " cvals", " cvalue", "acret", "pval", " csel", "Cvalue", "aceval", "lcval", "pvalid", "Cvalid", "cuval", "cvalues", "Cret", "cacheval", "lcbits", "acpos", "cachepos", "pol", "cpos", "lcvals", "Cvalues"], "offset": ["option", "o", "area", "position", "origin", "padding", "axis", "annot", "entry", "sort", "rot", "skip", "slice", "et", "alias", "optional", "Offset", "art", "loc", "f", "order", "url", "ii", "length", "align", "outer", "len", "error", "port", "after", "pad", "hop", "nb", "p", "end", "pos", "start", "range", "iso", "label", "index", "seed", "shift", "slot"], "i": ["gi", "o", "v", "id", "I", "a", "chi", "di", "s", "ci", "ni", "b", "x", "io", "xi", "si", "info", "m", "in", "qi", "ix", "l", "f", "yi", "pi", "phi", "d", "ii", "iu", "it", "ai", "u", "e", "udi", "uri", "w", "part", "k", "n", "mi", "ini", "lock", "ie", "p", "jit", "h", "z", "eni", "start", "line", "c", "ip", "ind", "y", "type", "li", "fi", "index", "ui"], "j": ["jet", "fr", "o", "ch", "v", "el", "oj", "jl", "note", "ji", "x", "b", "m", "qi", "kj", "l", "f", "job", "d", "ij", "ii", "aj", "u", "part", "e", "w", "J", "section", "jc", "k", "n", "uj", "jp", "jo", "ie", "p", "jit", "z", "un", "jj", "ld", "c", "range", "g", "y", "ja", "dj", "li", "adj", "journal", "js"], "book": ["base", "pack", "row", "build", "books", "hour", "bin", "block", "journal", "box", "count", "author", "trial", "session", " bus", "object", "style", "alias", "family", "b", "chapter", "record", "home", "kk", "uc", "unit", "valid", "db", "bus", "letter", "child", "version", "order", "sheet", "cc", "bb", "Book", "BOOK", "number", "code", "cell", " books", "file", "k", "lib", "bc", " record", "ab", "lock", "year", "coll", "week", "old", " count", "school", "un", "rule", "back", "c", "read", "label", "half", "month", "test", "group", "account", "library"], "adx": ["acp", "idx", "adX", "adp", "sdX", "acx", "sdp", "sdx", "sdw", "acX", "idX", "adw", "acw", "idw", "idp"], "ady": ["yy", "yx", "fy", "sy", "md", "wx", "ny", "kk", "ada", "eddy", "px", "ty", "wy", "ry", "ay", "adh", "oy", "asy", "ey", "yan", "idy", "ky", "ca", "edy", "hy", "dj", "mx", "axy", "az"], "dy": ["yy", "zy", "md", "dn", "di", "dd", "dx", "xy", "wy", "dq", "d", "py", "dir", "dp", "die", "da", "ds", "lon", "vy", "gy", "ld", "hi", "dj", "deb", "dl", "dt", "dim"], "off": ["flow", "o", "block", "offs", "op", "up", "home", "oa", "num", "length", "def", "down", "out", "dev", "over", "lon", "ox", "pos", "ip", "orig", "ov", "no", "on", "max", "mode", "ff", "low"], "predicted": ["predefined", "prediction", "condefined", "dedressed", "indressed", "indiction", "predressed", "condiction", "dediction", "dedicted", "condicted", "condressed", "indicted", "dedefined", "indefined"], "err": ["er", "iter", "rr", "bug", "exc", "order", "init", "later", "ev", "len", "error", "arr", "dev", "rx", "cb", "str", "score", "rev", "result", "req", "ver", "ind", "errors", "orig", "inner", "cache", "test"]}}
{"project": "qemu", "commit_id": "810f49b56a5d0cd6848856af51d3093ae9adc7b1", "target": 0, "func": "static void monitor_protocol_emitter(Monitor *mon, QObject *data)\n\n{\n\n    QDict *qmp;\n\n\n\n    qmp = qdict_new();\n\n\n\n    if (!monitor_has_error(mon)) {\n\n        /* success response */\n\n        if (data) {\n\n            assert(qobject_type(data) == QTYPE_QDICT);\n\n            qobject_incref(data);\n\n            qdict_put_obj(qmp, \"return\", data);\n\n        } else {\n\n            /* return an empty QDict by default */\n\n            qdict_put(qmp, \"return\", qdict_new());\n\n        }\n\n    } else {\n\n        /* error response */\n\n        qdict_put(mon->error->error, \"desc\", qerror_human(mon->error));\n\n        qdict_put(qmp, \"error\", mon->error->error);\n\n        QINCREF(mon->error->error);\n\n        QDECREF(mon->error);\n\n        mon->error = NULL;\n\n    }\n\n\n\n    if (mon->mc->id) {\n\n        qdict_put_obj(qmp, \"id\", mon->mc->id);\n\n        mon->mc->id = NULL;\n\n    }\n\n\n\n    monitor_json_emitter(mon, QOBJECT(qmp));\n\n    QDECREF(qmp);\n\n}\n", "idx": 13366, "substitutes": {"mon": ["date", "channel", "m", "mc", "meter", "Mon", "po", "part", "wm", "on", "bean", "chron", "un", "month", "connection", "mail", "wan", "manager", "tom", "mn", "user", "module", "plan", "met", "con", "mm", "method", "unit", "pid", "master", "dog", "key", "member", "conn", "col", "an", "mem", "mer", "mun", "mor", "nan", "atom", "plugin", "http", "mi", "monitor", "stat", "mo", "ann", "pm", "block", "MON", "pin", "bo", "don", "mag", "kin", "man", "demon", "com", "den", "lock", "num", "run", "dom", "wat", "mand", "mu", "message"], "data": ["ada", "map", "database", "record", "partial", "done", "part", "complete", "input", "xml", "d", "response", "array", "config", "val", "object", "da", "a", "api", "money", "missing", "module", "model", "raw", "valid", "value", "package", "meta", "o", "obj", "metadata", "params", "media", "p", "ad", "dev", "resource", "info", "options", "dict", "base", "monitor", "result", "parent", "dat", "none", "json", "number", "Data", "type", "body", "results", "change", "DATA", "dd", "cache", "empty", "python", "message"], "qmp": ["workmm", "qproc", "qumb", "qaMP", " qcmp", "quemm", "quesup", " qproc", "quproc", "aymp", "qsup", "qump", "workmb", " qcp", "qufp", "Qcomp", " qsup", " qpp", "quph", "workep", "qfp", "qap", "queomp", "quepac", "sqph", "sqpac", " qMP", "qcop", "qep", "quecop", " qomp", "qumt", "Qmm", "qcomp", "sqmp", "workcp", "qupar", "ayph", "qmb", "qMP", "quomp", "qusup", "workomp", "chmp", "qcp", "qucop", "qacomp", "workmp", "aypar", "qucmp", "quemp", "qucp", "qpac", "QMP", "Qmp", "quemb", "qamm", "quefp", "sqmt", "workpp", "workap", " qap", " qfp", "qomp", " qcomp", "qumm", "workcmp", "aymt", "sqcop", "qpar", "quep", "qcmp", "qmt", " qmb", "sqomp", "qpp", "qph", "workproc", "sqpar", "chomp", "quap", " qmm", "qupp", "qupac", "chep", "qmm", "chmm", "qamp"]}}
{"project": "qemu", "commit_id": "f3e4ce4af336f2ea306fa0f40ec1a5149864ca8c", "target": 1, "func": "static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)\n\n{\n\n    CommitBlockJob *s = container_of(job, CommitBlockJob, common);\n\n\n\n    if (speed < 0) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER, \"speed\");\n\n        return;\n\n    }\n\n    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);\n\n}\n", "idx": 1335, "substitutes": {"job": ["flow", "base", "server", "lock", "service", "build", "queue", "process", "image", "jobs", "section", "worker", "pb", "j", "sync", "project", "bug", "cb", "pool", "config", "status", "feed", "result", "block", "work", "child", "jp", "object", "exec", "node", "connection", "seq", "b", "plugin", "manager", "Job", "run", "db"], "speed": ["cost", "level", "service", "capacity", "mass", "time", "rate", "spec", "slow", "grade", "effect", "image", "gain", "high", "race", "weight", "scroll", "sk", "duration", "peed", "seed", "score", "slice", "settings", "source", "strike", "status", "mph", "step", "rank", "skill", "size", "length", "set", "power", "powered", "scale", "fee", "strength", "error", "sort", "stop", "sex", "Speed", "limit", "performance", "port"], "errp": ["errP", "erc", "rrfp", "erP", "errc", "errpe", "errfp", " errpe", "iterp", "rrP", "erf", "rrc", " errr", "err", " errP", "iterr", "errr", "erpe", "erp", " errc", "iterf", "iterpe", " errf", " errfp", "errf", "erfp", "rrp"], "s": ["sg", "submit", "js", "service", "sup", "ss", "spec", "sb", "r", "is", "sp", "sl", "sh", "ssh", "g", "m", "ses", "ls", "sf", "ds", "ps", "gs", "ns", "c", "p", "services", "e", "f", "secondary", "sq", "u", "o", "v", "b", "S", "session", "hs", "se", "si", "sym"]}}
{"project": "qemu", "commit_id": "03ae4133ab8675d4c67e6fdc8032de7c53a89514", "target": 0, "func": "static void ppc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    pcc->parent_realize = dc->realize;\n\n    pcc->pvr = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->pvr_mask = CPU_POWERPC_DEFAULT_MASK;\n\n    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_always;\n\n    dc->realize = ppc_cpu_realizefn;\n\n    dc->unrealize = ppc_cpu_unrealizefn;\n\n\n\n    pcc->parent_reset = cc->reset;\n\n    cc->reset = ppc_cpu_reset;\n\n\n\n    cc->class_by_name = ppc_cpu_class_by_name;\n\n    cc->has_work = ppc_cpu_has_work;\n\n    cc->do_interrupt = ppc_cpu_do_interrupt;\n\n    cc->dump_state = ppc_cpu_dump_state;\n\n    cc->dump_statistics = ppc_cpu_dump_statistics;\n\n    cc->set_pc = ppc_cpu_set_pc;\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = ppc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = ppc_cpu_get_phys_page_debug;\n\n    cc->vmsd = &vmstate_ppc_cpu;\n\n#if defined(TARGET_PPC64)\n\n    cc->write_elf64_note = ppc64_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = ppc64_cpu_write_elf64_qemunote;\n\n#endif\n\n#endif\n\n\n\n    cc->gdb_num_core_regs = 71;\n\n\n\n#ifdef USE_APPLE_GDB\n\n    cc->gdb_read_register = ppc_cpu_gdb_read_register_apple;\n\n    cc->gdb_write_register = ppc_cpu_gdb_write_register_apple;\n\n    cc->gdb_num_core_regs = 71 + 32;\n\n#endif\n\n\n\n#if defined(TARGET_PPC64)\n\n    cc->gdb_core_xml_file = \"power64-core.xml\";\n\n#else\n\n    cc->gdb_core_xml_file = \"power-core.xml\";\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->virtio_is_big_endian = ppc_cpu_is_big_endian;\n\n#endif\n\n\n\n    dc->fw_name = \"PowerPC,UNKNOWN\";\n\n}\n", "idx": 26886, "substitutes": {"oc": ["acc", "oca", "oci", "cca", "uc", "ogg", "anc", "c", "toc", "ob", "isc", "ec", "oper", "oco", "soc", "om", "bc", "mac", "ocr", "oid", "OC", "fc", "o", "unc", "loc", "voc", "ucc", "mc", "rc", "roc", "alloc", "co", "comp", "aco", "ocol", "usc", "coll", "org", "nc", "ac", "pc", "ok"], "data": ["load", "acc", "Data", "cm", "d", "config", "ds", "dd", "rec", "raw", "input", "dat", "dev", "board", "ci", "rc", "cache", "co", "device", "tc", "da", "src", "DATA", "func", "ac"], "pcc": ["facc", " pca", "ppcf", "Pcci", "ppcc", "cpuc", "fcca", "cpca", "ccf", "cpcci", "lpCC", "Pcc", "ppacc", "pca", " puc", "lpec", "prc", " prc", " pcca", "Pca", "PCC", "lprc", "puc", "pxc", "pacc", "lpcci", "cpcca", " pec", "pec", " pacc", "pcca", "lpcc", "cacc", "lpxc", "fcc", "Pcca", "ccc", "cpCC", " pxc", "pprc", "Pcf", "Pxc", "crc", " pCC", "Prc", " pcf", "fCC", "Pacc", "pcci", "lpcf", "Puc", "pcf", "Pec", "pCC", "cpcc", "lpcca"], "cc": ["acc", "sc", "code", "cm", "bec", "ctl", "cca", "uc", "cd", "kk", "anc", "c", "pg", "bb", "cci", "xc", "ec", "client", "cur", "config", "ect", "cus", "ct", "bc", "PC", "ce", "mac", "self", "cmp", "ee", "fc", "cell", "con", "cast", "cmd", "cl", "vc", " gcc", "cel", "CC", "ctx", "ci", "ucc", "cf", "mc", "rc", "cache", "co", "cn", "inc", "ga", "BC", "lc", "control", "ctrl", "comp", "gg", "ca", "tc", "go", "cu", "RC", "conn", "ck", "nc", "cs", "ac", "pc"], "dc": ["acc", "sc", "DC", "cca", "uc", "cd", "director", "auc", "c", "d", "cci", "doc", "ec", "ds", "cr", "bc", "mac", "db", "fc", "vc", "cdn", "disc", "di", "dt", "cf", "mc", "ga", "rc", "co", "inc", "cache", "design", "lc", "ca", "tc", "da", "conn", "cu", "duc", "ck", "df", "nc", "ac", "pc"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}\n", "idx": 4479, "substitutes": {"avctx": ["axcu", "avcn", "avca", "akcontext", "awctx", "AVcam", "axcontext", "afca", "avcam", "apcontext", "avectx", "afcv", "aflc", "awclient", "ajlc", "vrclient", "ajcv", "avcu", "AVctx", "AVcontext", "ajcp", "avecp", "vrcv", "akctx", "afcn", "afctx", "akcn", "axcam", "apctx", "abcontext", "avcv", "avcontext", "afcp", "afclient", "avcp", "ajcu", "avclient", "awcontext", "avecontext", "avlc", "afcontext", "ajctx", "afcam", "axctx", "ajcontext", "abcv", "apcn", "AVcu", "awcv", "akca", "apca", "vrcontext", "avelc", "afcu", "abcu", "abctx", "vrctx"], "afq": ["alfquery", "affz", "affdq", "awu", "alfq", " afqu", "awiq", "awl", "effqa", " afquery", "faQ", "afct", " afk", "awdq", " afqa", "avqa", "awQ", "effquest", " afl", "awquery", "afck", "awquest", "AFl", "effq", "ajq", "alfqa", "ajck", "afdq", "alfk", "affqt", "awq", "alfck", "fadq", "faq", "ampqu", "affqa", "faqt", " afct", "ampqa", "affq", "AFu", "afz", "awqt", "alfct", "alfquest", "affqu", "afqt", " afu", "effck", "AFq", "ampck", "awct", "afiq", "ampquest", "afk", "avquest", "avck", "afqa", "afl", "affQ", "afquery", "avq", "ampz", "awck", "afQ", "afquest", "afu", "awk", "afqu", "ajiq", "ampiq", " afz", "ampq", "ajquest", "AFk"]}}
{"project": "FFmpeg", "commit_id": "486637af8ef29ec215e0e0b7ecd3b5470f0e04e5", "target": 0, "func": "static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)\n\n{\n\n    int i;\n\n    float (*output)[256] = ctx->audio_block.block_output;\n\n\n\n    for (i = 0; i < 256; i++)\n\n        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);\n\n    memset(output[2], 0, sizeof(output[2]));\n\n    memset(output[3], 0, sizeof(output[3]));\n\n    memset(output[4], 0, sizeof(output[4]));\n\n}\n", "idx": 9238, "substitutes": {"ctx": ["conf", "cam", "context", "cmp", "Context", "cca", "conn", "tc", "src", "c", "cp", "config", "component", "fp", "cn", "cf", "loc", "bc", "cc", "cs", "ctrl", "cv", "ck", "ce", "rc", "cas", "conv", "tx", "pc", "cpp", "cms", "cm", "ca", "ci", "anc", "lc", "text", "mc", "kb", "sc", "exec"], "i": ["count", "l", "oi", "hi", "ui", "di", "it", "n", "si", "zi", "m", "id", "xi", "info", "b", "x", "k", "t", "ini", "d", "c", "ji", "p", "uri", "e", "mu", "yi", "f", "ie", "j", "ai", "code", "o", "multi", "index", "slice", "v", "gi", "ti", "qi", "pi", "bi", "ii", "u", "type", "h", "I", "li", "ci", "a", "io", "length", "ni", "y", "iu"], "output": ["region", "word", "block", "config", "target", "memory", "code", "external", "response", "content", "object", "document", "full", "put", "sort", "grade", "image", "eff", "reference", "filter", "generated", "application", "control", "draw", "value", "hidden", "unit", "module", "input", "current", "four", "position", "layer", "complete", "operation", "source", "model", "page", "data", "written", "flow", "resource", "version", "size", "software", "after", "oper", "fn", "result", "core", "Output", "byte", "display", "update", "queue", "number", "average", "console", "event", "address", "function", "option", "summary", "null", "out", "video", "write", "forward"]}}
{"project": "FFmpeg", "commit_id": "88ddcfa37f0067aae7457b44f433982f4c6d72ee", "target": 1, "func": "static av_cold int tdsc_init(AVCodecContext *avctx)\n\n{\n\n    TDSCContext *ctx = avctx->priv_data;\n\n    const AVCodec *codec;\n\n    int ret;\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_BGR24;\n\n\n\n    /* These needs to be set to estimate buffer and frame size */\n\n    if (!(avctx->width && avctx->height)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Video size not set.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* This value should be large enough for a RAW-only frame plus headers */\n\n    ctx->deflatelen = avctx->width * avctx->height * (3 + 1);\n\n    ret = av_reallocp(&ctx->deflatebuffer, ctx->deflatelen);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Allocate reference and JPEG frame */\n\n    ctx->refframe = av_frame_alloc();\n\n    ctx->jpgframe = av_frame_alloc();\n\n    if (!ctx->refframe || !ctx->jpgframe)\n\n        return AVERROR(ENOMEM);\n\n\n\n    /* Prepare everything needed for JPEG decoding */\n\n    codec = avcodec_find_decoder(AV_CODEC_ID_MJPEG);\n\n    if (!codec)\n\n        return AVERROR_BUG;\n\n    ctx->jpeg_avctx = avcodec_alloc_context3(codec);\n\n    if (!ctx->jpeg_avctx)\n\n        return AVERROR(ENOMEM);\n\n    ctx->jpeg_avctx->flags = avctx->flags;\n\n    ctx->jpeg_avctx->flags2 = avctx->flags2;\n\n    ctx->jpeg_avctx->dct_algo = avctx->dct_algo;\n\n    ctx->jpeg_avctx->idct_algo = avctx->idct_algo;;\n\n    ret = avcodec_open2(ctx->jpeg_avctx, codec, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Set the output pixel format on the reference frame */\n\n    ctx->refframe->format = avctx->pix_fmt;\n\n\n\n    return 0;\n\n}\n", "idx": 15987, "substitutes": {"avctx": ["ajwcs", "varconn", "ajcu", "airctx", "vertx", "avcas", "avhw", "varcv", "navctx", "afconfig", " avcmp", "avecci", "avcu", " avcontext", "avecmp", "AVkb", "varcci", "afcmd", "AVcas", "avecontext", "navcontext", "avconfig", "varcontext", "avalcpu", "afcas", "avalkw", "auwcs", "AVconfig", "afconn", "avca", "avcv", "aftx", "AVcontext", "avectx", "ajkw", "afcu", "AVconn", "averctx", "afcontext", "avecas", "avehw", "avcpu", "avkb", "avconn", " avcas", "AVcmd", "aircas", "ajcas", "avkw", "varcmp", "ajcv", "avecu", "vercontext", "aveca", "avtx", " avca", "ajctx", "aveconfig", "vercmp", "verctx", "aircontext", "afctx", "afcci", "avcci", "aukw", "avercontext", "aucpu", "afkb", "AVcmp", "varcas", "avwcs", "avcmp", "navkb", "AVhw", "avalwcs", "afcmp", "avecv", "afhw", "varctx", "avercmd", "avcmd", "auctx", "avalctx", "avercmp", "aircmp", "avcontext", " avhw", "aveconn", "afca", "navconn", "AVctx", "varcu", "ajcpu", "AVtx"], "ctx": ["sys", "context", "tx", "cam", "cm", "bc", "pkg", "cv", "ca", "qa", "sync", "config", "pc", "cc", "cdn", "Context", "gc", "ctrl", "lc", "ci", "cs", "connection", "conv", "wx", "cms", "cn", "wcs", "cmp", "loc", "conn", "kw", "np", "client", "uc", "nc", "ck", "data", "tc", "cus", "component", "cli", "co", "wp", "cfg", "c", "cca", "cu", "cat", "anc", "cb", "cas", "sci", "cmd", "cf", "aux", "cp", "exec", "coll", "vc", "xc", "kb", "css", "fc", "git", "hw", "alloc", "fw"], "codec": ["codecode", "Codesc", "codect", "opec", "opc", "odesc", " coddec", "codek", "cedeus", "codenc", "codc", " codenc", "odc", " codect", "cdesc", "Codac", "cmdcode", "codac", "predec", "coduc", " codek", "codeect", "cmdenc", " codesc", " codeus", "odac", "coddec", " codc", "codesc", " codac", "dbeus", "odenc", "cduc", "cedec", "codcode", " codep", "cmdec", "cedek", "codep", "cdec", "dbdec", "codeec", "predac", " coduc", "cdac", "ceddec", "cmdect", "opep", "codeus", "dbek", "dbec", "predesc", "preduc", "odec", "odep", " codcode", "openc", "Codec", "Codenc", "codeenc"], "ret": ["pet", "en", "reply", "art", "val", " resp", "def", "gt", "str", "fin", "rb", "bf", "att", "cat", "end", " result", "iter", "out", "fail", "RET", "off", "num", " fun", "ft", "rev", "len", "rets", "det", "arg", "error", "pass", "mt", "result", "url", "ur", "r", "ard", "res", "reg", "aid", "rf", "flag", "run", "red", "alt", "let", " alt", "fun", " len", "ref", "lit", " arg", " pat", "sb", "Ret", "nt", " success", "re", "rt", "usr", "bit", "err", "code", "back", "pt", "std", " reply", "feat", "lt", "success", "all", "last", "pat", "et"]}}
{"project": "qemu", "commit_id": "0b5538c300a56c3cfb33022840fe0b4968147e7a", "target": 1, "func": "void st_flush_trace_buffer(void)\n\n{\n\n    if (trace_file_enabled) {\n\n        flush_trace_file();\n\n    }\n\n\n\n    /* Discard written trace records */\n\n    trace_idx = 0;\n\n}\n", "idx": 280, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = (3 * dc +  1) >> 1;\n\n    dc = (3 * dc + 16) >> 5;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n", "idx": 121, "substitutes": {"dest": ["route", "rest", "dim", "txt", "success", "head", "de", "master", "trip", "err", "home", "opt", "address", "select", "trans", "shift", "path", "start", "option", "est", "name", "sup", "target", "access", "cl", "desc", "Dest", "ui", "id", "parent", "end", "cdn", "camp", "tmp", "coord", "hop", "text", "origin", "die", "session", "transform", "lit", "data", "loc", "member", "cb", "cont", "delete", "feat", "ident", "content", "result", "usr", "ctr", "node", "img", "dist", "mode", "done", "stage", "test", "null", "src", "class", "prop", "orig", "ord", "num", "output", "comb", "source", "temp", "status", "config", "dc", "wb", "draw", "contract", "miss", "west", "sort", "transfer", "table", "db"], "linesize": ["linsize", " linesiz", "inasized", "inasizes", " linesizes", "inasize", "linesized", "nssize", "codesize", "linespace", " linespace", " linesized", "linspace", "codessize", "codesiz", "linesiz", "linessize", " linessize", "nsized", "codespace", "linsiz", "linesizes", "nsizes", "nsize", "inassize", "linssize"], "block": ["unit", "match", "group", "lock", "row", "name", "buffer", "check", "def", "cl", "loc", "type", "bc", "chain", "section", "end", "num", "bl", "none", "event", "source", "config", "address", "word", "col", "ref", "copy", "cache", "contract", "exec", "object", "node", "comment", "Block", "blocks", "clean", "line", "load", "list", "map", "table", "pack"], "i": ["cli", "ami", "li", "gi", "ni", "ii", "zi", "ji", "pi", "ui", "oi", "d", "I", "n", "di", "k", "iu", "api", "j", "m", "ti", "multi", "index", "z", "ai", "ie", "x", "l", "c", "p", "ip", "bi", "hi", "e", "f", "col", "u", "v", "b", "uri", "ci", "io", "mu", "fi", "si", "xi"], "cm": ["cms", "vm", "DC", "cam", "ctx", "CM", "hem", "cum", "em", "cc", "mc", "dim", "bm", "sem", "km", "com", "co", "cy", "im", "mm", "tc", "iam", "param", "m", "gm", "cont", "cr", "om", "config", "address", "dc", "hm", "man", "c", "lc", "dm", "ram", "cn", "ca", "ctrl", "core", "wm", "pm", "cd", "cmd", "comm", "fm", "rm", "center", "rom", "asm", "rem", "um", "cp", "dem", "module", "cf", "car", "ci", "am", "mode", "que", "ym"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void collie_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    StrongARMState *s;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"sa1110\";\n\n    }\n\n\n\n    s = sa1110_init(sysmem, collie_binfo.ram_size, cpu_model);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    pflash_cfi01_register(SA_CS0, NULL, \"collie.fl1\", 0x02000000,\n\n                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 1);\n\n    pflash_cfi01_register(SA_CS1, NULL, \"collie.fl2\", 0x02000000,\n\n                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);\n\n\n\n    sysbus_create_simple(\"scoop\", 0x40800000, NULL);\n\n\n\n    collie_binfo.kernel_filename = kernel_filename;\n\n    collie_binfo.kernel_cmdline = kernel_cmdline;\n\n    collie_binfo.initrd_filename = initrd_filename;\n\n    collie_binfo.board_id = 0x208;\n\n    arm_load_kernel(s->cpu, &collie_binfo);\n\n}\n", "idx": 16524, "substitutes": {"machine": ["process", "part", "m", "instance", "session", "data", "mode", "user", "base", "image", "comment", "service", "M", "loader", "cpu", "module", "app", "node", "mc", "sim", "mini", "model", "manager", "mom", "self", "computer", "game", "object", "controller", "sm", "vm", "home", "host", "page", "l", "database", "parse", "space", "mobile", "mount", "device", "slave", "hard", "boot", "Machine", "template", "connection", "state", "project", "mac", "server", "message", "motion", "bug"], "cpu_model": ["cpu_system", "pu_model", "cpu1model", "cpuadmodel", "mem_language", "pu_size", "cpu_Model", "cpuadmode", " cpu_size", "cpu_view", " cpu_address", "gpu_mode", "cpusfile", "cpu1length", " cpu_length", "cpulexaddress", "cpu_file", "pu_mode", "cpu_mode", "cpu_size", "cpussize", "cpu_length", "gpu_system", "cpuadlength", " cpu_file", "cpu_language", "cpu_address", "cpu1system", "cpusmodel", " cpu_mode", "mem_mode", "cpuadsystem", " cpu_Model", "cpulexModel", "gpu_length", "cpu1mode", "mem_model", "cpulexmodel", "pu_view", "gpu_model", "cpulexmode", "cpuslength"], "kernel_filename": ["cachefulllength", "kernellockmaximum", "kernel_username", " kernel_size", "kernelldescription", "kernel_description", "contextmdatabase", "kernelmdescription", "contextmfilename", "interfaceldescription", " kernel_source", "interface_description", "interface_filename", "kernel_directory", "context_directory", "kernel\u00b7label", "kernel_label", "kernel_database", "kernel___filename", "kernelmdatabase", "kernelfulllabel", "interfacelsource", "kernel___size", "kernel___source", "contextmdirectory", "kernelndescription", "kernel_source", "kernellsource", "context_filename", "kernelmfilename", "kernelMfilename", "kernelMdescription", "kernel_size", "kernelfullmaximum", "interfacelname", "cache_label", "cachefullfilename", "contextmdescription", "interfacelfilename", "kernel\u00b7length", "interface_source", "kernelfullfilename", " kernel_username", "kernel\u00b7maximum", "cache_length", "kernel_name", "kernel\u00b7filename", "kernelMdatabase", "cachefulllabel", "kernellocklabel", "kernel___username", "cachefullmaximum", "kernellname", "kernelMdirectory", "kernelfulllength", "kernelmdirectory", "kernelnfilename", "kernel_length", "context_description", "interface_name", "kernellfilename", "kernel_maximum", "kernellockfilename", "cache_filename", "kernellocklength", "kernelnname", "context_database", "cache_maximum", "kernelnsource"], "kernel_cmdline": ["kernel_deflin", "kernel_programlock", "kernel_cmdlin", "kernel_ctxfile", "kernel_commandl", "kernel_ckfile", "kernel_classline", "kernel_rawword", "kernel_defline", "kernel_ckline", "kernel\u00b7cmdstyle", "kernel_ctxue", "kernel_classrange", "kernel_costword", "kernel_gradlock", "kernel_commandside", "kernel_rawline", "kernel_pathne", "kernel_cmdside", "kernel_ctxline", "kernel_costline", "kernel_pathline", "kernel_classlock", "kernel_programside", "kernel_gradl", "kernel_methodrange", "kernel_cmdword", "kernel\u00b7cmdline", "kernel_ckue", "kernel\u00b7cmdword", "kernel_cmdlock", "kernel_cmdue", "kernel_costne", "kernel_cmdstyle", "kernel_gradline", "kernel\u00b7costline", "kernel\u00b7costne", "kernel\u00b7coststyle", "kernel_ctxlin", "kernel_pathstyle", "kernel_cmdrange", "kernel_coststyle", "kernel_programline", "kernel_cmdfile", "kernel_programl", "kernel_commandrange", "kernel_methodline", "kernel_commandlock", "kernel_deffile", "kernel_defue", "kernel_cmdne", "kernel\u00b7cmdne", "kernel_cmdl", "kernel_cklin", "kernel_pathword", "kernel_rawne", "kernel\u00b7costword", "kernel_methodlock", "kernel_commandline", "kernel_gradside", "kernel_rawstyle"], "initrd_filename": ["initrd_width", "initrdxtail", "initrad_Filename", "initrd_username", "initrdJforward", "initdd_username", "initrd_location", "initrdUfilename", "initrdUusername", "initrdPfilename", "initrd_tail", "initrad_location", "initrdUfil", "initrd_fil", "initrt_filename", "initrdJlocation", "initdd_fil", "initrad_filename", "initrd_forward", "initradPforward", "initrdPFilename", "initrd_Filename", "initrdlockfilename", "initrdlockpassword", "initdd_tail", "initrs_password", "initrdPforward", "initrs_filename", "initrdlockFilename", "initrd2filename", "initrd2required", "initrdxusername", "initrt_name", "initrd_name", "initdd_filename", "initrt_width", "initrdxfilename", "initrd_password", "initradPfilename", "initrd2width", "initrs_Filename", "initrdJFilename", "initrdPlocation", "initradPlocation", "initrd_required", "initrdJfilename", "initrdUtail", "initradPFilename", "initrd2name", "initrt_required", "initrdxfil", "initrad_forward"], "s": ["ns", "spec", "m", "session", "sg", "t", "rs", "info", "f", "sp", "services", "service", "n", "sb", "sl", "ss", "y", "fs", "is", "o", "sk", "cs", "su", "e", "ssl", "ses", "sync", "c", "ps", "si", "sym", "p", "S", "b", "ks", "gs", "sys", "states", "os", "state", "server", "se", "sq", "less", "sa", "ds", "sf"], "dinfo": ["derror", "dconf", "dsi", " dconf", "fapi", "dnconf", "ffo", "mdfo", "pfo", "binfo", "dinit", "ddi", "sdignore", "binner", "dhand", "dfo", "nddi", "ndignore", "phand", "dinf", "drapi", "bdi", " dinit", "dinner", "dignore", "dninit", " derror", "dayinf", "binf", "dbignore", "dapi", " dinf", "finf", "dlconf", "drfo", "papi", "dlinfo", "ndinner", "dnsi", "sderror", "pignore", "pinfo", "mdinfo", "dlsi", "dayfo", "dayinfo", "dbinfo", "dbinf", "finfo", "sdinner", "dwork", "mdapi", "pinf", "drinfo", " dapi", "sdinfo", "pwork", " dwork", "dbhand", "sddi", "ndinfo", " dfo", "mdinf", "sdwork", "dayapi", "dninfo", "drinf", " dsi", "dlinit", "bhand", "bignore", "sdinf"], "sysmem": ["sysreg", "sysram", "ssmemory", "sysmemory", "syslim", " syslim", "ssmem", "cslim", "sreg", "csmem", "csdem", "sysdem", "ssreg", "smemory", "systemmemory", "systemram", " sysdem", "systemmem", "systemreg", "sslim", "slim", "systemlim", "systemdem", " sysram", "csram", "smem"]}}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n    qemu_mutex_init(&chr->chr_write_lock);\n\n    return chr;\n\n}\n", "idx": 9683, "substitutes": {"chr": ["ichri", "phre", " chrr", "Chrar", "chri", "echrr", "CHr", "ichre", "phr", "ichrb", " chrar", "Chrc", "phrc", " chR", "Chr", "chre", " chrc", "CHrr", "echlr", "phri", "echR", " chlr", "echr", "chrr", "ichrc", " chre", "Chrb", " chri", "CHR", "chR", " chrb", "chlr", "chrar", "chrc", "CHlr", "ichr", "ichrar", "chrb"]}}
{"project": "qemu", "commit_id": "3f2cbf0d1a1340bed4a63e05b044c46df93f4768", "target": 1, "func": "target_phys_addr_t cpu_get_phys_page_debug(CPUState *env, target_ulong addr)\n\n{\n\n    target_ulong pde_addr, pte_addr;\n\n    uint64_t pte;\n\n    target_phys_addr_t paddr;\n\n    uint32_t page_offset;\n\n    int page_size;\n\n\n\n    if (env->cr[4] & CR4_PAE_MASK) {\n\n        target_ulong pdpe_addr;\n\n        uint64_t pde, pdpe;\n\n\n\n#ifdef TARGET_X86_64\n\n        if (env->hflags & HF_LMA_MASK) {\n\n            uint64_t pml4e_addr, pml4e;\n\n            int32_t sext;\n\n\n\n            /* test virtual address sign extension */\n\n            sext = (int64_t)addr >> 47;\n\n            if (sext != 0 && sext != -1)\n\n                return -1;\n\n\n\n            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pml4e = ldq_phys(pml4e_addr);\n\n            if (!(pml4e & PG_PRESENT_MASK))\n\n                return -1;\n\n\n\n            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK))\n\n                return -1;\n\n        } else\n\n#endif\n\n        {\n\n            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK))\n\n                return -1;\n\n        }\n\n\n\n        pde_addr = ((pdpe & ~0xfff) + (((addr >> 21) & 0x1ff) << 3)) &\n\n            env->a20_mask;\n\n        pde = ldq_phys(pde_addr);\n\n        if (!(pde & PG_PRESENT_MASK)) {\n\n            return -1;\n\n        }\n\n        if (pde & PG_PSE_MASK) {\n\n            /* 2 MB page */\n\n            page_size = 2048 * 1024;\n\n            pte = pde & ~( (page_size - 1) & ~0xfff); /* align to page_size */\n\n        } else {\n\n            /* 4 KB page */\n\n            pte_addr = ((pde & ~0xfff) + (((addr >> 12) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            page_size = 4096;\n\n            pte = ldq_phys(pte_addr);\n\n        }\n\n        if (!(pte & PG_PRESENT_MASK))\n\n            return -1;\n\n    } else {\n\n        uint32_t pde;\n\n\n\n        if (!(env->cr[0] & CR0_PG_MASK)) {\n\n            pte = addr;\n\n            page_size = 4096;\n\n        } else {\n\n            /* page directory entry */\n\n            pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) & env->a20_mask;\n\n            pde = ldl_phys(pde_addr);\n\n            if (!(pde & PG_PRESENT_MASK))\n\n                return -1;\n\n            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {\n\n                pte = pde & ~0x003ff000; /* align to 4MB */\n\n                page_size = 4096 * 1024;\n\n            } else {\n\n                /* page directory entry */\n\n                pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & env->a20_mask;\n\n                pte = ldl_phys(pte_addr);\n\n                if (!(pte & PG_PRESENT_MASK))\n\n                    return -1;\n\n                page_size = 4096;\n\n            }\n\n        }\n\n        pte = pte & env->a20_mask;\n\n    }\n\n\n\n    page_offset = (addr & TARGET_PAGE_MASK) & (page_size - 1);\n\n    paddr = (pte & TARGET_PAGE_MASK) + page_offset;\n\n    return paddr;\n\n}\n", "idx": 15136, "substitutes": {"env": ["forge", "args", "edge", "en", "context", "qa", "enc", "cv", "ea", "config", "eye", "code", "enter", " environment", "eu", "oa", "pg", "manager", "event", "txt", "vm", "init", "fg", "server", "conf", "output", "conn", "np", "console", "obj", "loader", "hell", "dict", "e", "equ", "viron", "exc", "engine", "nc", "site", "her", "eng", "ext", "vs", "qt", "Environment", "ef", "assets", "state", "global", "eni", "shell", "dt", "ne", "cal", "que", "db", "ev", "cache", "ec", "emb", "ou", "environment", "el", "core", "et", "ctx", "err"], "addr": ["ord", "ode", "bridge", "Address", "rr", "en", "ha", "amp", "len", "inter", "adder", "arm", "amd", "config", "art", "memory", "oa", "nn", "er", "align", "anne", "rg", "cmp", "ace", "xp", "hash", "arg", "conn", "aug", "grad", "ad", "adr", "layer", "atom", "add", "address", "state", "ip", "url", "ridge", "route", "arr", "offset", "attr", "eth", "az", "ast", "rt", "host", "od", "db", "nr", "src", "seq", "dr", "ar", "hop", "order", "pad", "ptr", "asm", "node", "ost"], "pde_addr": ["pda__addr", "pda_ord", "pde__addr", "pde_layer", "pde_address", "pdc_addr", "pda_addr", "pda__ord", "pda__oa", "pde_ord", "pdu_addr", "pde_hop", "pde__address", "pda_address", "pdu_layer", "pde_ace", "pde__ord", "pde_oa", "pde_amd", "pda__address", "pdc_ace", "pda_oa", "pde__oa", "pdu_hop", "pdc_ord", "pdu_amd"], "pte_addr": ["pte_address", "pte_device", "ptee_amd", "ptee_device", "ptee_address", "pte_amd", "ptee_addr"], "pte": ["PTee", "PTd", "cte", "PTe", "ctee", "ptE", "ctE", "ctd", "PTE", "ptd", "aptd", "ptee", "aptE", "apte", "aptee"], "paddr": ["tpaddress", "tpcode", "tpaddr", "vpnode", "pcaddr", "vpaddr", "pcode", "vpcode", "pcnode", "vpaddress", "tpnode", "paddress", "pcaddress", "pnode", "pccode"], "page_offset": ["page\u00b7reset", "page2reset", "page_number", "page\u00b7size", "page\u00b7number", "page\u00b7offset", " page_reset", "page2offset", " page_number", "page2number", "page_reset", "page2size"], "page_size": [" page_len", "page64offset", "page64size", "page_len", "page64len"], "pdpe_addr": ["pdpe__addr", "pdpe_address", "pdke__orig", "pdpe__cmd", "pdke__address", "pdpe_ord", "pdque_layer", "pdke_orig", "pdke_addr", "pdfe_hop", "pdpe__ord", "pdpe_hop", "pdque_hop", "pdfe_int", "pdpo_addr", "pdpo_ord", "pdpe_cmd", "pdfe_lan", "pdpo_address", "pdpe_conn", "pdpe_layer", "pdpe__address", "pdfe_addr", "pdke_address", "pdque_addr", "pdpe_lan", "pdpe_orig", "pdque_conn", "pdke__hop", "pdpe_int", "pdfe_address", "pdpe__hop", "pdke_hop", "pdke__addr", "pdpe__orig", "pdpe__lan", "pdfe_cmd"], "pde": ["pne", "pdu", "gdu", "Pde", "dde", "copda", "hde", "pnode", "hdu", "pda", "gde", " pdu", " pnode", "hdc", " pdec", " pdc", "pdes", " pda", " pdes", "copde", "lpdc", "Pne", "copdec", "gdo", "pdec", "lpnode", "lpdu", "hnode", "copne", "gdes", "ddes", "lpde", "pdo", "ddo", "ddu", "pdc", " pdo", " pne", "Pda", "Pdec"], "pdpe": ["sdpe", "hdpes", "ddche", "pdde", "dpes", "ldper", "hdple", "hdte", "pdfe", "pcke", "draper", "pdoe", "eddper", "dfe", "pcque", "ldple", "padpe", "tdde", "hdper", "tdper", "ldke", "eddte", "pdper", "ddpe", "pdque", "ldche", "hdme", "tdfe", "sdque", "tdpe", "dsper", "tdte", "ddple", "drate", "drape", "dper", "pcpe", "tdpes", "tdple", "hdfe", "pdke", "dpe", "ldoe", "ddoe", "pdme", "hdde", "hdpe", "dte", "ldque", "ldpe", "hdche", "sdper", "pdple", "pdte", "pdpes", "dspe", "drame", "dke", "pdche", "padpes", "sdke", "padple", "tdke", "padde", "dste", "eddfe", "pcper", "hdke", "eddpe", "hdoe", "dsme"], "pml4e_addr": ["pml4er_address", "pml4e_offset", "pml4e_host", "pml4er_addr", "pml4er_offset", "pml4ee_len", "pml4e_hop", "pml4e__address", "pml4e_len", "pml4e_loc", "pml4ee_loc", "pml4exaddr", "pml4ee_addr", "pml4er_hop", "pml4e__hop", "pml4e_conn", "pml4e_func", "pml4er_host", "pml4e_address", "pml4ee_conn", "pml4er_func", "pml4exloc", "pml4exconn", "pml4e__offset", "pml4exlen", "pml4er_loc", "pml4e__addr"], "pml4e": ["pml004E", "pml8ee", "pwl12x", "pml12x", "pml4b", "pwl4pe", "pml6e", "pmal4b", "pmal6b", "pml4f", "pml5c", "pwl4e", "pmlfourer", "pml6ee", "pml12c", "pwl4E", "pwl12e", "pazel4e", "pwl12er", "pml5E", "pml12e", "pml04er", "pml4er", "pml6er", "pml04ee", "pml5x", "pml8f", "pml6f", "pmal6f", "pwl12c", "pml5e", "pml04b", "pml5pe", "pmal4f", "pml8e", "pmal4ee", "pml004c", "pml8er", "pml4ee", "pwl12E", "pwl12pe", "pml7e", "pwl4x", "pml6b", "pml5er", "pml7f", "pml04e", "pmal4e", "pml4c", "pazel4b", "pmal6e", "pwl4er", "pml4x", "pmal6ee", "pazel4ee", "pml12er", "pml12E", "pml7ee", "pml4E", "pml7b", "pml12pe", "pazel04er", "pazel04ee", "pml004er", "pml004e", "pazel04e", "pwl4c", "pml4pe", "pmlfoure", "pmlfourx", "pazel04b", "pml8b", "pmlfourpe", "pazel4er"], "sext": ["psexp", "tetxt", "tept", "selex", "netxt", "sept", "sect", "pselex", "pseext", "SEext", " setxt", "inext", "pexp", "neft", "teXT", "seext", " sexp", "texp", "inelect", "ineXT", "inexp", "pelect", "tect", "SExp", "SEpt", "select", "psext", "SExt", "seXT", " seft", "next", "sexp", " sept", "peXT", "seft", "SElex", "text", "psect", " selex", "nept", " seXT", "pext", "setxt", "pseXT", " select", "teft", "SEXT", " seext", "SEct", "psept"]}}
{"project": "qemu", "commit_id": "601b9a9008c5a612d76073bb3f178621cff41980", "target": 0, "func": "uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,\n\n                      uint64_t cpu_addr)\n\n{\n\n    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;\n\n\n\n    HELPER_LOG(\"%s: %016\" PRIx64 \" %08x %016\" PRIx64 \"\\n\",\n\n               __func__, order_code, r1, cpu_addr);\n\n\n\n    /* Remember: Use \"R1 or R1 + 1, whichever is the odd-numbered register\"\n\n       as parameter (input). Status (output) is always R1. */\n\n\n\n    switch (order_code) {\n\n    case SIGP_SET_ARCH:\n\n        /* switch arch */\n\n        break;\n\n    case SIGP_SENSE:\n\n        /* enumerate CPU status */\n\n        if (cpu_addr) {\n\n            /* XXX implement when SMP comes */\n\n            return 3;\n\n        }\n\n        env->regs[r1] &= 0xffffffff00000000ULL;\n\n        cc = 1;\n\n        break;\n\n#if !defined(CONFIG_USER_ONLY)\n\n    case SIGP_RESTART:\n\n        qemu_system_reset_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n    case SIGP_STOP:\n\n        qemu_system_shutdown_request();\n\n        cpu_loop_exit(CPU(s390_env_get_cpu(env)));\n\n        break;\n\n#endif\n\n    default:\n\n        /* unknown sigp */\n\n        fprintf(stderr, \"XXX unknown sigp: 0x%\" PRIx64 \"\\n\", order_code);\n\n        cc = SIGP_CC_NOT_OPERATIONAL;\n\n    }\n\n\n\n    return cc;\n\n}\n", "idx": 26152, "substitutes": {"env": ["fen", "gui", "file", "code", "obj", "args", "np", "ep", "er", "info", "exc", "server", "context", "manager", "enc", "ec", "en", "config", "conf", "style", "export", "opt", "priv", "state", "dict", "ev", "inst", "ea", "loader", "environment", "proc", "db", "e", "site", "esi", "err", "dev", "viron", "worker", "exe", "cp", "eu", "eni", "cache", "erv", "esp", "vm", "req", "ext", "conn", "v", "que", "equ", "eng"], "order_code": ["orderprecodes", "orderalcount", "order2Code", "orderpreclass", "orderprecode", "order2class", " order_class", "order_class", "sort_codes", " order_key", "sort_Code", "sort_call", "orderalcode", " order_call", "orderycall", "orderylevel", "order_codes", "order2call", "orderprecount", "orderalkey", " order_codes", "order2count", "order_key", "orderycodes", "orderalcodes", " order_count", "orderycode", "order_count", "order_Code", "order_level", "sort_code", " order_level", "order_call", "order2code", "order2codes"], "r1": ["order0", " r9", "r9", "order9", "R3", "R2", "r0", " r2", "r2", " r4", "e3", "R0", "R4", "sr1", "sr4", "order2", "e1", "order1", "sr0", "r3", " r0", "sr2", "R9", "e2", " r3", "r4", "R1"], "cpu_addr": ["cpu_offset", "gpu_ord", "cpu2addr", "cpu_ord", "gpu_addr", "gpu_offset", "cpu2address", "cpu_address", "cpu2ord", "cpu2offset", "cpu_port", "gpu_address", "gpu_port"]}}
{"project": "qemu", "commit_id": "b47b35250fbfa062aedf6ab6e5faab84c4a76f4f", "target": 1, "func": "FDCtrl *fdctrl_init_isa(DriveInfo **fds)\n\n{\n\n    ISADevice *dev;\n\n\n\n    dev = isa_create(\"isa-fdc\");\n\n    if (fds[0]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveA\", fds[0]->bdrv);\n\n    }\n\n    if (fds[1]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveB\", fds[1]->bdrv);\n\n    }\n\n    if (qdev_init(&dev->qdev) < 0)\n\n        return NULL;\n\n    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);\n\n}\n", "idx": 15201, "substitutes": {"fds": [" fd", "fdd", "qns", "fys", "fns", "fDS", "fd", "fsts", "fordd", " fdd", "cdds", "pDS", "forts", " fns", " fks", "dsts", "fks", "lDS", "qrs", "dDS", "pds", "pks", "cfds", " fDS", "ld", " fsk", "lda", " fts", "dks", "qnas", " fys", "cd", "frs", " fdds", "cfys", "fdds", "fords", "qds", "cfrs", "psts", "qts", "qdd", " fda", "fda", " frs", "dds", "cDS", "ldds", "forks", "lds", "qda", "cfsk", "qsk", "lns", "cds", " fnas", "qys", "fts", "fsk", "fnas", "qks", "lnas", " fsts"], "dev": ["bug", "device", "ani", "kind", "self", "d", "priv", "die", "server", " device", "def", "rad", "req", "ve", "user", "di", "Dev", "mod", "bus", "error", "v", "app", "conf", "gu", "var", "adv", "de", "valid", "w", "grad", "pub", "ad", "conn", "temp", "info", "ver", "data", "sd", "driver", "ready", "diff", "develop", "df", "dem", "serv", "end", "DEV", " Dev", "ow", "host", "od", "dd", "ev", "prop", "debug", "wd", "err"]}}
{"project": "FFmpeg", "commit_id": "90c6963daea9210d7d2104e2ece94dd4e2fffc17", "target": 1, "func": "void avfilter_link_free(AVFilterLink **link)\n\n{\n\n    if (!*link)\n\n        return;\n\n\n\n    if ((*link)->pool) {\n\n        int i;\n\n        for (i = 0; i < POOL_SIZE; i++) {\n\n            if ((*link)->pool->pic[i]) {\n\n                AVFilterBufferRef *picref = (*link)->pool->pic[i];\n\n                /* free buffer: picrefs stored in the pool are not\n\n                 * supposed to contain a free callback */\n\n                av_freep(&picref->buf->data[0]);\n\n                av_freep(&picref->buf);\n\n\n\n                av_freep(&picref->audio);\n\n                av_freep(&picref->video);\n\n                av_freep(&picref);\n\n            }\n\n        }\n\n        av_freep(&(*link)->pool);\n\n    }\n\n    av_freep(link);\n\n}\n", "idx": 21302, "substitutes": {"link": ["lc", "like", "name", "cross", "e", "key", "connection", "message", "file", "style", "parse", "hip", "plugin", "local", "f", "model", "info", "dd", "bug", "lock", "play", "list", "id", "ace", "sync", "load", "comment", "ink", "hack", "plug", "Link", "friend", "tag", "filter", "mail", "module", "source", "check", "match", "pull", "linked", "a", "line", "service", "install", "call", "child", "loc", "feed", "di", "parent", "lib", "http", "user", "li", "group", "lang", "ck", "image", "block", "pack", "l", "base", "links", "action", "url", "type"], "i": ["io", "ami", "name", "e", "ix", "fi", "qi", "ri", "ui", "pi", "key", "gi", "d", "uri", "chi", "ti", "I", "f", "ci", "y", "info", "phi", "m", "ini", "oi", "j", "u", "ip", "p", "abi", "o", "bi", "wei", "mi", "mu", "index", "si", "ii", "b", "ji", "iu", "ai", "xi", "base", "hi", "di", "multi", "v", "yi", "li", "l", "x", "zi", "ni", "type"], "picref": ["picdef", "docref", " picdef", "docreference", "picRef", "Picdef", "picreference", "nicreference", "pcdef", "icrel", "pictrel", "nicRef", "pcreference", "pcrel", " picblock", "pinreference", "pinref", "icRef", "icreference", "pcref", "pictRef", "pinflow", "picrel", "pictref", "Picrel", "PicRef", "pcRef", "nicref", " picRef", "docrel", "nicrel", "pcflow", "docflow", "Picref", "pictreference", "Picblock", "pinblock", " picreference", "picblock", "picflow", "Picreference", "pinrel", "icref", "pinRef"]}}
{"project": "FFmpeg", "commit_id": "ebbcdc9ac0ea190748a1605bda86ce84466c8b4e", "target": 0, "func": "static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)\n\n{\n\n    *range = 8 * (1 << (f_code - 1));\n\n    /* XXX: temporary kludge to avoid overflow for msmpeg4 */\n\n    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)\n\n\t*range *= 2;\n\n\n\n    if (s->unrestricted_mv) {\n\n        *xmin = -16;\n\n        *ymin = -16;\n\n        if (s->h263_plus)\n\n            *range *= 2;\n\n        if(s->avctx->codec->id!=CODEC_ID_MPEG4){\n\n            *xmax = s->mb_width*16;\n\n            *ymax = s->mb_height*16;\n\n        }else {\n\n            *xmax = s->width;\n\n            *ymax = s->height;\n\n        }\n\n    } else {\n\n        *xmin = 0;\n\n        *ymin = 0;\n\n        *xmax = s->mb_width*16 - 16;\n\n        *ymax = s->mb_height*16 - 16;\n\n    }\n\n}\n", "idx": 17807, "substitutes": {"s": ["ns", "spec", "sky", "service", "ss", "cs", "d", "qs", "sym", "p", "ks", "h", "us", "sets", "ms", "m", "ts", "sg", "rs", "aws", "sim", "self", "o", "su", "si", "S", "an", "ds", "f", "sb", "as", "l", "same", "w", "features", "bis", "sync", "c", "ps", "b", "sys", "your", "es", "states", "sq", "sf", "session", "t", "stats", "conf", "services", "n", "g", "i", "ls", "ops", "fs", "xs", "is", "site", "e", "ssl", "ses", "client", "js", "http", "gs", "its", "os", "parts", "se", "y", "u"], "range": ["scale", "fr", "offset", "cal", "lim", "view", "err", "call", "f", "base", "hide", "r", "ne", "role", "num", "query", "type", "Range", "max", "ge", " Range", "scope", "timeout", "date", "low", "gap", "force", "val", "array", "chain", "grade", "rule", "dy", "use", "no", "length", "ang", "ranged", "limit", "side", "span", "update", "line", "binary", "cache", "resource", "route", "domain", "row", "ange", "live", "repeat", "end", "diff", "version"], "xmin": ["xid", " xid", "Xstart", "ixmax", "Xmin", "axmin", "ixspan", "ystart", " xMin", "xspan", "Xid", "ixmin", "yMin", " xstart", "axmax", " xpart", "axstart", " xspan", "xstart", "xpart", "yid", "axpart", "yspan", "xMin", "Xmax", "ixMin", "ypart"], "ymin": ["rymon", "ymon", "ymit", "eymin", "Ymin", "mymid", "Ystart", "rymin", "xmid", " ymid", " ystart", "xmit", "ystart", "eymon", " ymon", "chmit", "chmin", "Ymon", "Ymini", "mystart", " ymit", "rystart", "ymid", "eymini", "chmon", "mymin", "xstart", "eystart", "rymini", "mymax", "chmax", "ymini", "xmon"], "xmax": ["yMAX", "Xend", "rxmin", "fxmin", "hmax", "Xmin", "hlast", "hmin", "Xdev", "rxlast", "yend", "mxmax", "fxlast", "xend", "xxend", "xxmax", "xxdev", "xxmin", "hend", "fxmax", "ylast", "xlast", "Xlast", "XMAX", "mxlast", "rxdev", "rxmax", "mxdev", "xdev", " xMAX", "fxend", "Xmax", "mxmin", "mxend", "xMAX"], "ymax": ["immax", "ymmase", "ymit", "ymaz", "ymase", "tmazon", "smaz", "smase", "mxax", "ymmatch", "mxatch", "immaz", "ymmax", "smazon", "ymmad", "ymad", "mxazon", "emmax", "emand", "pmand", "pmad", "iemase", "ymmand", "tmit", "emax", "iemoo", "tmatch", "ymoo", "dimatch", "ymazon", "mxase", "dimax", "iemax", "immase", "smax", "pmax", "ymmit", "dimazon", "dimit", "emad", "pmmax", "iemaz", "ymatch", "ymmmax", "ymand", "ymmazon", "smoo", "immoo", "tmax", "smatch"], "f_code": [" f_cod", "f_codes", "f6code", "f__codes", "c_id", "fqcode", "f__count", "fqid", "f__id", "f__code", "f_id", "c_count", "f6count", "f6codes", "c_codes", "f6cod", "c_code", "fqcodes", "fqcount", "f_cod", " f_count", " f_codes", "f_count"]}}
{"project": "qemu", "commit_id": "9e0ff75e5158c7dbb65ee447382bbdf4cafbef8b", "target": 1, "func": "char *vnc_display_local_addr(const char *id)\n\n{\n\n    VncDisplay *vs = vnc_display_find(id);\n\n\n\n\n    return vnc_socket_local_addr(\"%s:%s\", vs->lsock);\n\n}", "idx": 13726, "substitutes": {"id": ["path", "bid", "d", "rid", "code", "i", "mid", "vid", "name", "Id", "image", "ident", "ref", "key", "pid", "ID", "ids", "ad", "sid", "p", "data", "address", "ip", "end", "type", "q", "aid", "addr", "kid", "index", "start"], "vs": ["vers", "env", "bs", "fs", "vp", "rs", "Vs", "vid", "forces", "verts", "cs", "qs", "values", "os", "sk", "vm", "es", "v", "ps", "ss", "views", "ves", "ms", "VS", "alls", "obs", "vis", "ums", "lines", "gs", "ns", "sv", "va", "als", "plays", "ds", "ls", "ils", "vals", "ks"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void ide_atapi_cmd(IDEState *s)\n\n{\n\n    uint8_t *buf;\n\n\n\n    buf = s->io_buffer;\n\n#ifdef DEBUG_IDE_ATAPI\n\n    {\n\n        int i;\n\n        printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8));\n\n        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {\n\n            printf(\" %02x\", buf[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n    /*\n\n     * If there's a UNIT_ATTENTION condition pending, only command flagged with\n\n     * ALLOW_UA are allowed to complete. with other commands getting a CHECK\n\n     * condition response unless a higher priority status, defined by the drive\n\n     * here, is pending.\n\n     */\n\n    if (s->sense_key == UNIT_ATTENTION &&\n\n        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {\n\n        ide_atapi_cmd_check_status(s);\n\n        return;\n\n    }\n\n    /*\n\n     * When a CD gets changed, we have to report an ejected state and\n\n     * then a loaded state to guests so that they detect tray\n\n     * open/close and media change events.  Guests that do not use\n\n     * GET_EVENT_STATUS_NOTIFICATION to detect such tray open/close\n\n     * states rely on this behavior.\n\n     */\n\n    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&\n\n        !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {\n\n\n\n        if (s->cdrom_changed == 1) {\n\n            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n            s->cdrom_changed = 2;\n\n        } else {\n\n            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);\n\n            s->cdrom_changed = 0;\n\n        }\n\n\n\n        return;\n\n    }\n\n\n\n    /* Report a Not Ready condition if appropriate for the command */\n\n    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&\n\n        (!media_present(s) || !bdrv_is_inserted(s->bs)))\n\n    {\n\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n        return;\n\n    }\n\n\n\n    /* Execute the command */\n\n    if (atapi_cmd_table[s->io_buffer[0]].handler) {\n\n        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);\n\n        return;\n\n    }\n\n\n\n    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);\n\n}\n", "idx": 15495, "substitutes": {"s": ["rs", "qs", "new", "js", "si", "server", "ps", "params", "spec", "c", "is", "sl", "states", "in", "args", "south", "m", "self", "bis", "d", "t", "sg", "sync", "fs", "sym", "g", "cs", "es", "session", "client", "w", "u", "an", "b", "ns", "r", "sie", "sis", "sports", "sys", "service", "your", "uploads", "os", "sets", "opens", "o", "stage", "e", "site", "http", "sb", "f", "less", "state", "des", "services", "ls", "comments", "ses", "bs", "l", "a", "sites", "S", "settings", "this", "its", "sq", "v", "conf", "ss", "p", "se", "plugins", "ions", "n", "gs", "xs", "stats", "ssl", "ds", "su", "ts", "us", "y"], "buf": ["func", "args", "runner", "vec", "context", "uc", "bc", "queue", "fd", "cv", "tmp", "bs", "rc", "fb", "bd", "uf", "pool", "ref", "buffer", "bag", "fp", "br", "buff", "obj", "mem", "grab", "img", "rb", "pb", "data", "b", "wb", "Buffer", "box", "fab", "Buff", "f", "result", "flow", "sb", "ab", "block", "feed", "cb", "bo", "cap", "cmd", "cf", "aux", "db", "src", "seq", "cur", "pad", "ctx", "alloc"], "i": ["hi", "qi", "ui", "m", "I", "d", "ai", "ni", "xi", "id", "ini", "l", "gi", "iu", "a", "io", "oi", "ci", "h", "x", "di", "si", "ii", "key", "v", "uri", "o", "z", "u", "p", "e", "info", "fi", "mi", "li", "k", "ix", "multi", "j", "count", "n", "f", "length", "ti", "phi", "ip", "pi", "chi", "bi", "r", "ri", "zi", "abi", "index"]}}
{"project": "FFmpeg", "commit_id": "e3123856c79c36507772ada1bcda6cfe36a1e297", "target": 1, "func": "static int wsvqa_read_header(AVFormatContext *s,\n\n                             AVFormatParameters *ap)\n\n{\n\n    WsVqaDemuxContext *wsvqa = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    unsigned char *header;\n\n    unsigned char scratch[VQA_PREAMBLE_SIZE];\n\n    unsigned int chunk_tag;\n\n    unsigned int chunk_size;\n\n\n\n    /* initialize the video decoder stream */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, VQA_FRAMERATE);\n\n    wsvqa->video_stream_index = st->index;\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_WS_VQA;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n\n\n    /* skip to the start of the VQA header */\n\n    avio_seek(pb, 20, SEEK_SET);\n\n\n\n    /* the VQA header needs to go to the decoder */\n\n    st->codec->extradata_size = VQA_HEADER_SIZE;\n\n    st->codec->extradata = av_mallocz(VQA_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    header = (unsigned char *)st->codec->extradata;\n\n    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=\n\n        VQA_HEADER_SIZE) {\n\n        av_free(st->codec->extradata);\n\n        return AVERROR(EIO);\n\n    }\n\n    st->codec->width = AV_RL16(&header[6]);\n\n    st->codec->height = AV_RL16(&header[8]);\n\n\n\n    /* initialize the audio decoder stream for VQA v1 or nonzero samplerate */\n\n    if (AV_RL16(&header[24]) || (AV_RL16(&header[0]) == 1 && AV_RL16(&header[2]) == 1)) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        av_set_pts_info(st, 33, 1, VQA_FRAMERATE);\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        if (AV_RL16(&header[0]) == 1)\n\n            st->codec->codec_id = CODEC_ID_WESTWOOD_SND1;\n\n        else\n\n            st->codec->codec_id = CODEC_ID_ADPCM_IMA_WS;\n\n        st->codec->codec_tag = 0;  /* no tag */\n\n        st->codec->sample_rate = AV_RL16(&header[24]);\n\n        if (!st->codec->sample_rate)\n\n            st->codec->sample_rate = 22050;\n\n        st->codec->channels = header[26];\n\n        if (!st->codec->channels)\n\n            st->codec->channels = 1;\n\n        st->codec->bits_per_coded_sample = 16;\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_coded_sample / 4;\n\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n\n\n\n        wsvqa->audio_stream_index = st->index;\n\n        wsvqa->audio_samplerate = st->codec->sample_rate;\n\n        wsvqa->audio_channels = st->codec->channels;\n\n        wsvqa->audio_frame_counter = 0;\n\n    }\n\n\n\n    /* there are 0 or more chunks before the FINF chunk; iterate until\n\n     * FINF has been skipped and the file will be ready to be demuxed */\n\n    do {\n\n        if (avio_read(pb, scratch, VQA_PREAMBLE_SIZE) != VQA_PREAMBLE_SIZE) {\n\n            av_free(st->codec->extradata);\n\n            return AVERROR(EIO);\n\n        }\n\n        chunk_tag = AV_RB32(&scratch[0]);\n\n        chunk_size = AV_RB32(&scratch[4]);\n\n\n\n        /* catch any unknown header tags, for curiousity */\n\n        switch (chunk_tag) {\n\n        case CINF_TAG:\n\n        case CINH_TAG:\n\n        case CIND_TAG:\n\n        case PINF_TAG:\n\n        case PINH_TAG:\n\n        case PIND_TAG:\n\n        case FINF_TAG:\n\n        case CMDS_TAG:\n\n            break;\n\n\n\n        default:\n\n            av_log (s, AV_LOG_ERROR, \" note: unknown chunk seen (%c%c%c%c)\\n\",\n\n                scratch[0], scratch[1],\n\n                scratch[2], scratch[3]);\n\n            break;\n\n        }\n\n\n\n        avio_skip(pb, chunk_size);\n\n    } while (chunk_tag != FINF_TAG);\n\n\n\n    return 0;\n\n}\n", "idx": 19892, "substitutes": {"s": ["ns", "ans", "spec", "ts", "sg", "bs", "t", "rs", "aws", "f", "sv", "services", "service", "sb", "g", "sl", "ss", "src", "ls", "sec", "sim", "fs", "xs", "is", "cs", "su", "ins", "sn", "w", "bis", "qs", "sc", "ssl", "sr", "fts", "ses", "vs", "c", "si", "p", "S", "sts", "sci", "ks", "gs", "sys", "its", "es", "os", "us", "sets", "se", "sq", "sa", "ds", "sf"], "ap": ["pc", "wp", "au", "al", "sp", "pl", "ar", "ams", "ast", "am", "cp", "np", "pac", "att", "aps", "pp", "AP", "ac", "pi", "pa", "capt", "mp", "cap", "api", "pro", "tp", "arp", "attr", "amp"], "wsvqa": ["wssvcca", "wssvqa", "wordsvcca", "Wssvasa", "wsvqi", "Wsvqa", "wsVqi", "Wssvq", "wsvq", "wsvraga", "wsvasa", "wsvrq", "wsVcca", "Wssvaga", "wslvqa", "wsvcqi", "wsvcaga", "Wssvqa", "wssvq", "wssvaga", "wordsvqi", "wslvq", "Wsvasa", "wslvaga", "wordsvcqa", "wsvccca", "wordsvccca", "wordsvqa", "Wsvaga", "wslvasa", "wordsvaga", "Wsvq", "wsvrasa", "wssvasa", "wsVaga", "wsvaga", "wsVqa", "wssvqi", "wordsvcaga", "wsvcqa", "wsvrqa", "wsvcca", "wordsvcqi"], "pb": ["pc", "wp", "ab", "eb", "db", "bs", "aph", "fp", "platform", "vp", "pit", "pl", "bm", "ib", "sb", "pm", "bp", "cpp", "cb", "bc", "hub", "cp", "lp", "wb", "src", "fc", "xb", "lb", "PB", "dp", "prop", "pg", "gb", "rob", "summary", "bf", "bps", "queue", "pa", "bh", "fb", "buf", "rb", "afi", "p", "mp", "ppa", "orb", "param", "tp", "prot", "ub", "pt", "amp", "typ"], "st": ["set", "ist", "stat", "dd", "nt", "str", "ss", "ut", "ST", "store", "d", "sh", "irst", "stack", " est", "sts", "mt", "end", "pt", "sa", "est", "tt", "ts", "nd", "stim", "rest", "dest", "ste", "td", "ld", "stand", "art", "stop", "tta", "sc", "bl", "sth", "stress", "cr", "stage", "play", "St", "et", "ft", "fr", "sv", "ct", "ess", "fe", "sb", "src", "th", "sd", "sta", "l", "std", "back", "sn", "ad", "start", "sr", " St", "post", "ust", "put", "inst", "ace", "t", "sp", "ost", "sw", "sl", "ast", "lt", "cl", "cur", "kt", "storage", "se"], "header": ["offset", "user", "comment", "result", "num", "padding", "Header", "layer", "protection", "feature", "h", "carry", "input", "column", "bin", "content", "metadata", "name", "handle", "bridge", "document", "description", "summary", "title", "parent", "table", "tail", "iter", "port", "ver", "status", "code", "hash", "border", "block", "type", "match", "player", "byte", "filename", "date", "head", "page", "host", "digit", "yer", "position", "detail", "filter", "er", "frame", "version", "request", "data", "buffer", "option", "pixel", "channel", "headers", "index", "tag", "her", "cover", "event", "response", "dr", "driver", "error", "body", "message", "server", "section", "gender"], "scratch": ["encores", "ncores", " scores", "ncratch", "scores", "encratch"], "chunk_tag": ["chunk_length", "chunk_count", "chack2count", "chack_mode", "chack_tag", "chunk2length", "chack2tag", "chunk2mode", "chack_length", "chunk2tag", "chunk_mode", "chunk2count", "chack2length", "chack_count", "chack2mode"], "chunk_size": ["chunk_count", "chunks_SIZE", "chunk2weight", "chunk2size", "chunk_weight", "chunks_count", "chunk_SIZE", "chunk2count", "chunk2SIZE", "chunks_weight", "chunks_size"]}}
{"project": "qemu", "commit_id": "e549e7161f37416ff66971d77d021d30057045ca", "target": 1, "func": "static QObject *parse_keyword(JSONParserContext *ctxt)\n\n{\n\n    QObject *token, *ret;\n\n    JSONParserContext saved_ctxt = parser_context_save(ctxt);\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    return ret;\n\n\n\nout: \n\n    parser_context_restore(ctxt, saved_ctxt);\n\n\n\n    return NULL;\n\n}", "idx": 4256, "substitutes": {"ctxt": ["pttxt", "cttxt", "CTrt", "catext", "CTct", "nttxt", "actxt", "ptext", "ntxt", "CTxt", "actct", "ctrt", "CText", "CTert", "acttxt", "actert", "CTtxt", "ptxt", "ptx", "ctx", "ntct", "ntext", "actrt", "ctext", "actx", "ntert", "actext", "catx", "cattxt", "ctert", "CTx", "catxt", "ctct", "ntrt"], "token": ["iter", "socket", "data", "wt", "status", "track", "document", "connection", "cho", "bot", "pass", "stage", "tree", "user", "reference", "tool", "option", "name", "header", "word", "channel", "value", "pattern", "valid", "null", "atom", "tick", "number", "target", "comment", "sign", "path", "field", "node", "rule", "txt", "type", "cookie", "text", "element", "ok", "stat", "note", "po", "normal", "key", "version", "tn", "t", "lex", "variable", "start", "seed", "prefix", "o", "annot", "open", "complete", "scope", "session", "quote", "tag", "resource", "event", "attr", "call", "stop", "fn", "Token", "result", "context", "KEN", "root", "opt", "oken", "column", "request", "date"], "ret": ["base", "aug", "flag", "reg", "rt", "mem", "alt", "complete", "get", "val", "data", "format", "cat", "pret", "reply", "db", "key", "fin", "valid", "job", "lit", "ext", "att", " Ret", "url", "obj", "arg", "res", "active", "match", "def", "mt", "det", "auth", "arr", "RET", "bot", "feat", "rev", "result", "Ret", "ft", "usr", "re", "true", "fun", "hash", "gt", "utf", "success", "ref", "fi", "conn", "rets"]}}
{"project": "FFmpeg", "commit_id": "5d5118f81bd51b9c33500616b3c637123e8e4691", "target": 1, "func": "static inline void idct_col(int16_t *blk, const uint8_t *quant)\n\n{\n\n    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;\n\n    int t10, t11, t12, t13;\n\n    int s0, s1, s2, s3, s4, s5, s6, s7;\n\n\n\n    s0 = (int) blk[0 * 8] * quant[0 * 8];\n\n    s1 = (int) blk[1 * 8] * quant[1 * 8];\n\n    s2 = (int) blk[2 * 8] * quant[2 * 8];\n\n    s3 = (int) blk[3 * 8] * quant[3 * 8];\n\n    s4 = (int) blk[4 * 8] * quant[4 * 8];\n\n    s5 = (int) blk[5 * 8] * quant[5 * 8];\n\n    s6 = (int) blk[6 * 8] * quant[6 * 8];\n\n    s7 = (int) blk[7 * 8] * quant[7 * 8];\n\n\n\n    t0  =  (s3 * 19266 + s5 * 12873) >> 15;\n\n    t1  =  (s5 * 19266 - s3 * 12873) >> 15;\n\n    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;\n\n    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;\n\n    t4  = t0 * 2 + t2;\n\n    t5  = t1 * 2 + t3;\n\n    t6  = t2 - t3;\n\n    t7  = t3 * 2 + t6;\n\n    t8  = (t6 * 11585) >> 14;\n\n    t9  = (t7 * 11585) >> 14;\n\n    tA  = (s2 * 8867 - s6 * 21407) >> 14;\n\n    tB  = (s6 * 8867 + s2 * 21407) >> 14;\n\n    tC  = (s0 >> 1) - (s4 >> 1);\n\n    tD  = (s4 >> 1) * 2 + tC;\n\n    tE  = tC - (tA >> 1);\n\n    tF  = tD - (tB >> 1);\n\n    t10 = tF - t5;\n\n    t11 = tE - t8;\n\n    t12 = tE + (tA >> 1) * 2 - t9;\n\n    t13 = tF + (tB >> 1) * 2 - t4;\n\n\n\n    blk[0 * 8] = t13 + t4 * 2;\n\n    blk[1 * 8] = t12 + t9 * 2;\n\n    blk[2 * 8] = t11 + t8 * 2;\n\n    blk[3 * 8] = t10 + t5 * 2;\n\n    blk[4 * 8] = t10;\n\n    blk[5 * 8] = t11;\n\n    blk[6 * 8] = t12;\n\n    blk[7 * 8] = t13;\n\n}\n", "idx": 25081, "substitutes": {"blk": ["brk", "blke", " blsk", " blke", "blK", "BLq", "mlsk", "slb", "BLv", "llk", "llke", "nlb", " blq", "blv", "Blb", "Blsk", "brb", "mlkin", "brck", "blks", "BLk", "plks", "slsk", "nlk", "ylkin", "plck", "glck", "glK", "blq", "llsk", "llq", "blck", "blch", "plb", "mlK", " blb", " blku", "plke", "plv", "llks", "ylk", "nlsk", "plq", "silks", "glq", "blsk", "plsk", "plk", "blb", "mlk", "llck", "blku", " blK", "oblsk", "slku", "ylsk", "silk", " blck", "BLck", "brsk", "mlch", "oblk", " blch", "slk", "Blk", " blks", " blkin", "silch", " blv", "nlku", "oblck", "glk", "ylks", "llb", "oblb", "silK", "Blck", "blkin", "plK", "mlks"], "quant": ["requ", "sc", "Quant", "gap", "quick", "app", "cat", "dash", "frac", "text", "cur", "config", "pay", "quart", "pub", "form", "util", "compl", "serial", "rec", "pad", "press", "private", "qual", "ident", "charge", "percent", "patch", "spec", "sign", "stat", "client", "inc", "scale", "local", "integer", "quad", "complex", "comp", "buff", "product", "qu", "comment", "count", "total", "mix", "color", "mult", "qq", "print", "q", "event", "chart", "query", "draw", "post"], "t0": ["Tzero", "s00", "at0", "t000", "te0", "ta2", "tzero", "d02", "te02", "d0", "dt00", "dt0", "f8", "at1", "d00", "d000", "f2", "ta0", "at00", "f0", "f4", "T1", "ta8", "p2", "T4", "T00", "p8", "szero", "dt02", "T2", "te00", "atzero", "t00", "p4", "p0", "dt000", "f1", "T0", "ta4", "t02", "te000"], "t1": ["p3", "y3", "ta1", "f3", "y1", "p1", "d1", "ta7", "d2", "d4", "f4", "T1", "p7", "p2", "T4", "f5", "p5", "T7", "p4", "d7", "y4", "y5", "T3", "ta4", "f1", "ta3", "T2"], "t2": ["ta62", "ta2", "pB", "m5", "m4", "m2", "m0", "n4", "it4", "f2", "itB", "it62", "f0", "ta6", "n7", "f4", "n5", "p2", "T4", "f5", "p5", "T7", "p4", "p62", "ta5", "p0", "n2", "it2", "t62", "T5", "T2", "ta4", "taB"], "t3": ["pt5", "p3", "T03", "v3", "e8", "t03", "pt13", "v5", "s03", "the13", "pt2", "ta1", "p1", "v1", "ta6", "e5", "the5", "it13", "T1", "e3", "p7", "T6", "ft5", "v7", "the2", "T4", "ft3", "ft2", "ft8", "it3", "it5", "p5", "the3", "ta5", "it2", "T8", "T3", "T5", "e2", "ta03", "ta4", "pt3", "ta3", "T2"], "t4": ["tpB", "ta2", "i5", "fB", "tp2", "i2", "i4", "tp6", "f4", "ta8", "tp4", "f6", "ta5", "i8", "ta4", "f2"], "t5": ["p3", "ta45", "m45", "m5", "m4", "m6", "it6", "it4", "t45", "ta6", "p2", "p8", "it45", "it3", "it8", "it5", "p5", "ta5", "it2", "ta4"], "t6": ["e9", "ts8", "ts12", "pt8", "f8", "pt4", "f66", "f7", "f3", "ta7", "ta6", "e5", "e4", "f4", "ta8", "t06", "T6", "e12", " t06", "pt66", "T4", "ts6", "ts06", "e06", "f6", "pt6", "e6", "t66", "ta5", "T66", "T8", "ta9", "ta4", "e8", "ta3"], "t7": [" t97", " t07", "tt7", "tt07", "tt74", " t87", "t97", "ta13", "n87", "te74", "te87", "ta07", "n07", "ta7", "n7", "t87", "t07", "t74", "ta97", "te97", "n13", "te07", "ty13", "ta87", "ty87", "tt13", "ty07", "te13", " t74", "te7", "ty7"], "t8": ["it10", "taE", "f10", "te8", "f8", "it6", "TEight", "it86", "ta08", "teEight", "taEight", "ta8", "teE", "t86", "f6", "tEight", " t86", "it8", "TE", "te08", "f86", "t08", "T8", "T08"], "t9": ["pt11", "it49", "ta99", "t19", "ta09", "t49", "T9", "pt49", " t09", "d19", "it19", "ta8", "T99", "d9", "d11", "it11", "it9", "t99", "ta9", "pt19", "T09", "pt9", " t99", "d49", "T8", "t09"], "tA": ["teA", "yO", "mtA", "teI", "yC", "mtB", "tO", " tI", "mtC", "yA", "TB", "TI", "TC", "TA", "retO", "retB", "tI", "teC", "teB", "retA", "mtO", "yB", "retC"], "tB": ["taskL", "tR", " t42", "tiR", "ta42", "taskB", "taskBB", "tiB", " tb", "t42", "tiL", "tBB", "taskR", "TBB", "T42", "TL", "TB", "taBB", "tb", "Tb", " tBB", "tab", "tL", "TR", "tiBB", "taB"], "tC": ["taC", "TD", "taE", "pC", "wtE", "wtC", "yC", "vD", "atC", "ttB", "fB", "otc", "otP", " tc", "wtD", "atG", "yE", "vE", "taD", " tG", "pD", " tP", "fD", "wtB", "ttD", "TC", "TN", " tN", "TA", "tP", "atP", "ttE", "fC", "tN", "tc", "pA", "atc", "yD", "pN", "otC", "fE", "ttC", "tG", "yB", "vC", "vB", "otG", "taB"], "tD": ["tiC", "taC", "pC", "pB", "tiB", "tU", "tfD", "pD", "ptC", "tiU", "tfB", "tfC", "taF", "ptD", "tfU", "tiD", "ptB", "ptU", "taD", "pF", "taB"], "tE": ["mtV", "ttV", "tuC", "teL", "tuE", " tL", "mtC", "mtG", "timE", "teE", "tV", "ttE", "tuG", "tL", "timC", "teC", "tuV", "teB", "ttG", "mtE", "timL", "ttC", "tG", "timB"], "tF": ["tzP", "tzV", " tP", "tY", "tzY", "tV", "taV", " tY", " tV", "taP", "taY", "tP", "tzF", "taF"], "t10": ["s50", "set50", "f50", "t50", "s10", "s11", "f10", "set12", "s12", "f12", "set11", "set10", "f11"], "t11": ["t14", "T10", " t14", "f10", "T11", "T12", "f12", "f11", "T14", "f14"], "t12": ["t14", "t15", " t14", "p14", "all13", "all12", "p15", "all14", "p12", "all15", "p13", " t15"], "t13": ["s57", "t57", "tu19", "f13", "tu57", "s13", "s12", "f12", "tu13", "t19", "tu12", "f57", "s19", "f19"], "s0": ["s50", "si1", "ps8", "ps50", "s90", "ps0", " s12", "p1", "ses8", "si2", " s8", "ses1", "ses0", "s8", "p2", " s50", "t90", "s12", "ses50", "p90", "ps1", "p0", "si90", "si0", "si12"], "s1": ["p3", "ns9", "g3", "g4", "f7", "f3", "p1", "d1", "ns3", "d2", "p7", "n5", "p2", "d3", "f5", "s9", "ns4", "g9", "p5", "n2", "d7", "ss3", "ns1", "ss9", "g1", "ss1", "n1", "n7", "f1", "ss4"], "s2": ["c2", "d5", "m5", "m4", "d0", "c4", "m2", "is2", "g5", "g4", "p10", "ns10", "s10", "ns5", "f0", "d2", "e5", " s8", "d4", "e4", "s8", "f4", "c5", "p2", "is8", "ns2", "f5", "is5", "ns4", "g2", "e1", "p5", "p0", "p4", "c10", "g1", "e2", "m8", "is4", "f2"], "s3": ["p3", "d5", "S15", "s15", "m5", "m4", "m13", "s03", "g3", "S03", "S3", "s53", "sed", " s15", "g8", "f3", "S53", "p1", "p6", "sined", "s13", "d13", "sin53", " s8", "S8", "d4", "s8", "g53", "se5", "d3", "f6", "f5", "g03", "se4", "se3", "p5", "sin15", "sin3", "Sed", "m3", " s53", " s03", " sed", "se13", "f1"], "s4": ["d5", "g5", "g4", "n4", "p1", "d8", " s8", "d4", "s8", "n5", "p2", "d3", "w5", "w3", "w8", "n6", "g2", "w4", "p5", "p4", "n2", "g1", "p6"], "s5": ["c2", "d5", "e8", "su4", "i3", "c6", "i5", "su12", " s12", "p1", "d1", "p6", "d2", "e5", "ss5", "s8", "e3", "c5", "p2", "s12", "ss2", "f6", "f5", "c1", "e1", "p5", "i1", "d6", "su5", "ss12", "su2", "i8", "f1", "ss4", "f2"], "s6": ["si11", "n8", " s11", "f8", " s12", "n4", "g4", "ses11", "ses12", "si8", "f3", "g8", "g6", "s11", "ses8", " s8", "s8", "f4", "p7", "p2", "s12", "f6", "n6", "p8", "g2", "p4", "si12", "ses6", "si6", "n7", "p6"], "s7": ["ssl712", "z7", "sets712", "session712", "s07", "h13", " s667", "s17", "ssl718", "z07", "sys87", "v718", "es667", "z87", "l13", " s07", "es7", "ssl7", "s13", "z718", " s8", "sets7", "p07", "sys7", "sys07", "l5", "s8", "p7", "s57", "session7", "ssl17", "v7", "v87", "h5", " s13", "sets718", "p8", "l7", "session718", "sets17", "s87", "s712", "h7", " s57", "l57", "h57", "s667", "p667", "sys718", "es07", "session17", "v07", "es8", "s718"]}}
{"project": "qemu", "commit_id": "4f9242fc931ab5e5b1b753c8e5a76c50c0b0612e", "target": 0, "func": "static void reset(DeviceState *d)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n\n\n    trace_spapr_drc_reset(spapr_drc_index(drc));\n\n\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    /* immediately upon reset we can safely assume DRCs whose devices\n\n     * are pending removal can be safely removed, and that they will\n\n     * subsequently be left in an ISOLATED state. move the DRC to this\n\n     * state in these cases (which will in turn complete any pending\n\n     * device removals)\n\n     */\n\n    if (drc->awaiting_release) {\n\n        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);\n\n        /* generally this should also finalize the removal, but if the device\n\n         * hasn't yet been configured we normally defer removal under the\n\n         * assumption that this transition is taking place as part of device\n\n         * configuration. so check if we're still waiting after this, and\n\n         * force removal if we are\n\n         */\n\n        if (drc->awaiting_release) {\n\n            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);\n\n        }\n\n\n\n        /* non-PCI devices may be awaiting a transition to UNUSABLE */\n\n        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&\n\n            drc->awaiting_release) {\n\n            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);\n\n        }\n\n    }\n\n}\n", "idx": 23076, "substitutes": {"d": ["md", "i", "e", "cd", "driver", "dh", "ds", "ld", "f", "dn", "gd", "t", "r", "u", "m", "s", "da", "data", "ad", "state", "p", "dict", "o", "c", "dr", "dx", "sd", "dt", "a", "b", "dc", "dm", "fd", "bd", "D", "st", "z", "l", "dp"], "drc": ["drt", "sdrt", "sdrc", "trc", "brc", "datrc", " drec", "dsrc", "dsrec", "ldsrc", "lRC", "adru", "datru", "Drec", "datlc", "lirc", "pdrac", "ldRC", " drac", "adrec", "tdrt", " dsrc", "tdrc", "dnroc", "datrec", "dnrt", "dsc", "dirc", " dsc", "dsrt", "drrc", "drsrc", "ldrac", "droc", "adrc", "brec", "fRC", "lrc", "DRC", "Dru", "adrt", "lsrc", "tsc", "frec", " drt", " dRC", "prec", "adlc", "lrec", "flc", "tdsrc", "drec", "drsc", "Drc", "sdroc", "frc", "dru", " droc", "dssc", "adRC", "troc", "prc", "tdrec", "trt", "drRC", "ldrec", "ldirc", "dnrc", "datRC", "dsRC", "pdrec", "psc", "drac", "bsc", "sdRC", "dRC", "drrec", "pdrc", "drirc", "dlc", "pdroc", "dnRC", "psrc", "birc", "pdsc", "bRC", "adsrc", "ldrc", "dssrc", "bsrc", "ldsc", "pirc", "pdrt"], "drck": ["strcc", "hrck", "hrok", "derck", "hrock", "hrac", "drac", " drco", "hrco", "drrc", "DRck", " drcks", " drack", "drco", "derok", " drok", "drcks", "derco", "derac", "drok", "DRrc", "drcc", "drack", "DRack", "hrack", "hrrc", " drcc", " drac", "strack", "DRcks", "strcks", "drock", " drock", "DRock", "DRcc", " drrc", "strck"]}}
{"project": "qemu", "commit_id": "43771539d4666cba16298fc6b0ea63867425277c", "target": 0, "func": "static RAMBlock *qemu_get_ram_block(ram_addr_t addr)\n\n{\n\n    RAMBlock *block;\n\n\n\n    /* The list is protected by the iothread lock here.  */\n\n    block = ram_list.mru_block;\n\n    if (block && addr - block->offset < block->max_length) {\n\n        goto found;\n\n    }\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        if (addr - block->offset < block->max_length) {\n\n            goto found;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Bad ram offset %\" PRIx64 \"\\n\", (uint64_t)addr);\n\n    abort();\n\n\n\nfound:\n\n    ram_list.mru_block = block;\n\n    return block;\n\n}\n", "idx": 12314, "substitutes": {"addr": ["area", "args", "port", "Address", "rr", "rss", "docker", "amp", "adder", "inter", "array", "arm", "amd", "config", "art", "code", "name", "align", "image", "progress", "ref", "ace", "hash", " address", "error", "access", "grad", "ad", "size", "adr", "layer", "info", "resource", "data", "ext", "base", "pointer", "byte", "length", "arp", "point", "address", "ip", "number", "url", "ac", "offset", "clock", "network", "host", "ack", "mac", "ress", "nr", "src", "ar", "dr", "hop", "prefix", "seq", "pad", "len", "ptr", "slice", "node"], "block": ["map", "blocks", "tx", "bc", "build", "batch", "val", "i", "label", "def", "pre", "image", "new", "pool", "module", "raw", "loc", "frame", "limit", "base", "box", "list", "flow", "line", "out", "work", "off", "lock", "num", "index", "bin", "part", "sync", "id", "full", "key", "error", "check", "group", "clean", " Block", "pack", "page", "byte", "length", "result", "ip", "number", "clock", "function", "body", "link", "ack", "cache", "run", "condition", "config", "Block", "null", "ref", "unit", "buffer", "update", "square", "valid", "value", "o", "none", "point", "address", "type", "wall", "no", "bl", "prev", "node", "record", "object", "orig", "name", "row", "range", "chain", "inv", "open", "plugin", "parent"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&\n\n                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {\n\n        /* Magnitude subtraction of infinities */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN subtraction */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n", "idx": 18744, "substitutes": {"env": ["viron", "txt", "db", "session", "code", "global", "cal", "dep", "conf", "here", "forge", "engine", "eu", "exc", "loader", "enter", "cb", "oa", "np", "chal", "erv", "chev", "environment", "ext", "shell", "console", "manager", "en", "fen", "eng", "energy", "enc", "her", "context", "him", "kn", "Environment", "iss", "keeper", "config", "ev", "queue", "e", "bot", "qt", "c", "ea", "que", "cache", "ec", "proc", "er", "eni", "enh", "ah", "conn"], "arg1": ["paramb", "argumentone", "argone", " argb", "argsone", "args01", "argument1", "paramone", "argument01", "args2", "arg01", "Arg1", "Argone", "argument2", " argone", "Argb", "param1", "args1", "Arg2", "argb", " arg01", "param2"], "arg2": ["ig1", " argb", "ark2", "ark1", "argument1", "arg0", " arg0", "ark4", "Arg1", "argument2", " argtwo", "argument4", "igb", "Argb", "arg4", "Argtwo", "argtwo", "Arg2", "ark0", "igtwo", "argument0", "ig2", " arg4", "argb"], "farg1": ["fargumentone", "fax2", " fArgth", "fargb", "flodef8", " fargb", "fagn5", "fmag41", "farm2", "fplay1", "infargone", "farg8", "fmag51", "fargpart", "fargument1", "fvalone", "fdef2", "infargart", "fag61", "fplayone", "fgen100", " fargone", "fag1", "farg41", "farm91", "frarg91", "faxone", "farg100", " fargspart", "infgen1", " farg3", "flodef2", "infgen61", "fargument81", "fergpart", "fval1", "fmag2", "fargs3", "fagone", "fdef1", "frmag01", " fArg1", "farg1001", "frmag91", "fmag1", "frarg1", "fArgone", "fag1001", "infag1001", "farmone", "fargone", "floarg1", "infarg1", "fregone", "fvar100", " farg01", "floarg8", "fargs1", "fArg81", "fArg2", "floarg2", "fagn1", "infgenart", " fargs5", "infarg100", "fmag91", "fax1001", "fvarart", "fresult61", "ferg5", "fresultone", "fgen61", "fmag8", "fargument100", " fargs3", "fresult1", "fArgth", "fgen91", "infarg61", "fgenart", "farg61", "fplay81", "fgen41", "fax01", "fagnpart", "fargsb", "fplayth", " farg5", "frarg01", "frmag41", "fvar1", "farg81", "flodef51", "freg1", " fArg81", "farg5", "floarg51", "ferg1", "fargart", "fax1", "fvar61", "farg01", "fergb", "fmag01", "fargumentth", "fgen01", "infarg1001", "farm3", " fargsone", "figpart", "fargth", "fArg01", "fargspart", "farg91", "fArgb", "fargument61", "faxb", " farg81", "frarg41", " fArgone", "fval3", "fig1", "fargs5", "freg2", "infag61", "fig3", "fdef8", "fresult1001", "freg3", "farg51", "fargsone", "infag1", "fdef51", "fArg1", "farg3", "fargumentart", " fargs1", "infagone", "fvalpart", "flodef1", "farm41", "infgen100", "fax61", "frmag1", " fargth", "figone", " fargsb", "fgen1", "farm1", " fargpart", "farm01", "fagnb"], "farg2": ["fax2", " fax1", "fregtwo", " fcall7", "fuseii", "afargSecond", "fargb", " finctwo", "figSecond", "fang3", " fargb", " fax2", "fgen22", " farg9", " fang2", "fcall2", "fregsecond", " finc9", "fplay2", "fuse2", " farg92", "fargs2", "afig1", "fplay22", " farg3", " fargii", "farg9", "afargsecond", "frockii", "finctwo", "fig2", "fmag2", "fargTwo", "frock7", "fuse7", "fplay02", " faxb", "figb", "afigsecond", "afigTwo", "fang2", " fax02", " fcall92", " fcallii", "faggTwo", " farg7", "fargs1", "fArg2", "fArgTwo", "finc02", "fuse92", "fArgSecond", "fargii", "fagg9", "afigSecond", "fargSecond", "fargsb", "figsecond", "farg92", " finc02", "afigb", "afig2", "freg1", "finc2", "figTwo", "fgen2", "finc9", "fax1", "fmag02", "faggtwo", "fcall92", " fang02", "fargtwo", "fang22", "afigtwo", " fang22", " finc2", "farg7", " fcall2", "fArgb", "faggb", "faxb", "afargb", " fang3", "farg22", "fgen02", "fig1", "fgen3", " farg02", "freg2", "farg02", "fargsecond", "fargs02", "frock2", "figtwo", "afarg1", "fplay3", "farg3", " farg22", "fagg02", "fang02", "fmag9", "fcall7", "afargtwo", "fax02", "fcallii", " fargtwo", "fagg2", "afarg2", "fmagtwo", "frock92", "afargTwo", "faggSecond"]}}
{"project": "qemu", "commit_id": "6a84cb1f2822e494839b93dd8c7f7f8fa6c261a9", "target": 0, "func": "VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,\n\n                              char **serial)\n\n{\n\n    VirtIOBlock *s;\n\n    int cylinders, heads, secs;\n\n    static int virtio_blk_id;\n\n    DriveInfo *dinfo;\n\n\n\n    if (!conf->bs) {\n\n        error_report(\"virtio-blk-pci: drive property not set\");\n\n        return NULL;\n\n    }\n\n    if (!bdrv_is_inserted(conf->bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return NULL;\n\n    }\n\n\n\n    if (!*serial) {\n\n        /* try to fall back to value set with legacy -drive serial=... */\n\n        dinfo = drive_get_by_blockdev(conf->bs);\n\n        if (*dinfo->serial) {\n\n            *serial = strdup(dinfo->serial);\n\n        }\n\n    }\n\n\n\n    s = (VirtIOBlock *)virtio_common_init(\"virtio-blk\", VIRTIO_ID_BLOCK,\n\n                                          sizeof(struct virtio_blk_config),\n\n                                          sizeof(VirtIOBlock));\n\n\n\n    s->vdev.get_config = virtio_blk_update_config;\n\n    s->vdev.get_features = virtio_blk_get_features;\n\n    s->vdev.reset = virtio_blk_reset;\n\n    s->bs = conf->bs;\n\n    s->conf = conf;\n\n    s->serial = *serial;\n\n    s->rq = NULL;\n\n    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;\n\n    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);\n\n\n\n    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);\n\n\n\n    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);\n\n    s->qdev = dev;\n\n    register_savevm(dev, \"virtio-blk\", virtio_blk_id++, 2,\n\n                    virtio_blk_save, virtio_blk_load, s);\n\n    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);\n\n    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);\n\n\n\n    bdrv_iostatus_enable(s->bs);\n\n    add_boot_device_path(conf->bootindex, dev, \"/disk@0,0\");\n\n\n\n    return &s->vdev;\n\n}\n", "idx": 289, "substitutes": {"dev": ["flow", "vol", "def", "dd", "hw", "gr", "conn", "device", "spec", "data", "ver", "d", "google", "di", "sh", "der", "priv", "prof", "de", "client", "dom", "g", "DEV", "Dev", "ve", "info", "sync", "err", "temp", "ch", "ds", "block", "w", "prom", "gd", "cache", "comment", "v", "ev", "dem", "error", "os", "pro", "debug", "diff"], "conf": ["cm", "sub", "cs", "ctx", "sch", "fs", "cal", "def", "hz", "spec", "conn", "cc", "res", "cl", "host", " Conf", "com", "ck", "co", "bc", "sh", "cons", "con", "client", "py", "param", "g", "fab", "info", "cb", "bug", "cr", "arch", "ch", "config", "pub", "c", "aff", "lc", "f", "fam", "ref", "app", "cache", "ca", "sc", "exec", "cn", "core", "ram", "comment", "cd", "sum", "cp", "cell", "cf", "conv", "req", "bs", "ci", "Conf", "cfg", "init", "reg", "fi", "acc", "rc", "ssl"], "serial": ["vol", "cho", "device", "flash", "pixel", "address", "private", "power", "object", "comment", "smart", "valid", "path", "location", "vision", "pocket", "local", "spec", "zip", "template", "type", "unknown", "id", "pass", "model", "ser", "general", "Serial", "secret", "custom", "resource", "length", "patch", "driver", "iv", "sex", "usb", "io", "digital", "mobile", "version", "primary", "loc", "global", "boot", "remote", "instance", "sql", "util", "erial", "standard", "ident", "kid", "iso", "original", "specific", "public", "regular", "prefix", "error", "mode", "normal", "si", "series", "server", "micro", "material", "alias", "binary", "initial", "phone", "spot", "sync", "coll", "special", "random", "color", "specified", "quant", "rc"], "s": ["sg", "js", "sa", "qs", "n", "sl", "client", "j", "g", "ses", "ls", "sf", "args", "storage", "us", "self", "f", "secondary", "sys", "u", "sum", "fs", "sup", "stat", "spec", "ts", "sb", "uns", "request", "p", "e", "v", "su", "ves", "S", "os", "session", "ks", "t", "site", "hs", "sym", "ssl", "cs", "ss", "rs", "new", "r", "is", "i", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "south", "o", "sim", "si", "server", "service", "d", "sk", "comments", "sync", "l", "services", "w", "sq", "stats", "b", "full", "states"], "cylinders": ["shasts", "ellisters", "cilovies", "culinder", "skasts", "skisters", "ellarks", "culinders", "cilriers", "culovies", "cilinders", "sharks", "ellasts", "huminders", "humriers", "ellinders", "cylasts", "cylisters", "huminder", "cylinder", "skarks", "shinders", "cylarks", "cylovies", "culriers", "cilinder", "humovies", "cylriers", "shisters", "skinders"], "heads": ["opens", "views", "reads", "loads", "devices", "jobs", "head", "shows", "links", "hops", "locks", "ids", "checks", "comments", "frames", "bits", "outs", "holes", "mods", "boxes", "pages", "features", "height", "rows", "tails", "HEAD", "blocks", "types", "ks", "headers", "ashes", "depth", "olds", "versions", "plugins", "obs"], "secs": ["threadp", "consts", "reqp", "threadcs", "secp", "secses", "constp", "threads", "Secp", "threadses", "Secses", " secp", "reqs", "descs", "reqsets", "constses", "Secs", "reqseconds", "secseconds", " secsets", "descp", " secseconds", "Seccs", "seccs", "descsets", "descseconds", "secsets", "constcs"], "virtio_blk_id": ["virtio_blk_ids", "virtio_blck_id", "virtio_blck_name", "virtio_blk_type", "virtio_blk_name", "virtio_blkt_id", "virtio_blkt_name", "virtio_blkt_type", "virtio_blk_f", "virtio_blkt_f", "virtio_blk_info", "virtio_blck_ids", "virtio_blck_info"], "dinfo": ["ddata", "cddata", "linfo", "cdid", "fdhandler", " dvar", "rInfo", "ldfo", "bdinfo", "derror", "fdinf", " ddata", " dInfo", "ldata", "bdinf", "finfo", "sdhandler", "did", "ldid", "sdinf", " dinf", "dinf", " derror", "fdvar", "bdInfo", "sdvar", "sdinfo", "bderror", "fdinfo", "rdata", "dfo", "ldinfo", " dfo", "finf", "fInfo", " dhandler", "cdfo", "rinf", "linf", "lddata", "dInfo", "lInfo", "cdinfo", "dvar", "rinfo", "dhandler", " did"]}}
{"project": "qemu", "commit_id": "2725aec70114cf1bee00443aeb47a305f9b0c665", "target": 1, "func": "static void i440fx_update_memory_mappings(PCII440FXState *d)\n\n{\n\n    int i, r;\n\n    uint32_t smram;\n\n    bool smram_enabled;\n\n\n\n    memory_region_transaction_begin();\n\n    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,\n\n               &d->pam_regions[0]);\n\n    for(i = 0; i < 12; i++) {\n\n        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;\n\n        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,\n\n                   &d->pam_regions[i+1]);\n\n    }\n\n    smram = d->dev.config[I440FX_SMRAM];\n\n    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);\n\n    memory_region_set_enabled(&d->smram_region, !smram_enabled);\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 4360, "substitutes": {"d": ["D", "dr", "o", "od", "id", "md", "bd", "vd", "done", "rad", "dn", "dat", "di", "dd", "session", "config", "dos", "s", "b", "dh", "data", "pd", "sync", "x", "ad", "m", "dx", "draw", "l", "db", "nd", "f", "de", "ded", "td", "dom", "def", "wd", "e", "defined", "da", "dev", "driver", "ds", "sd", "t", "dc", "n", "cmd", "xd", "p", "did", "and", "ld", "c", "ind", "du", "ct", "fd", "gd", "dl", "dt", "dj", "g", "ed", "diff", "cd", "dict"], "i": ["gi", "name", "o", "ti", "v", "id", "I", "di", "ci", "ji", "ni", "x", "ri", "si", "io", "b", "xi", "info", "bi", "m", "in", "qi", "l", "f", "pi", "phi", "adi", "ii", "iu", "j", "ai", "cli", "u", "e", "ami", "uri", "t", "k", "n", "multi", "ini", "ie", "p", "mini", "eni", "oi", "ind", "c", "ip", "g", "type", "api", "y", "li", "inner", "fi", "index", "zi", "ui"], "r": ["dr", "fr", "er", "sr", "rt", "v", "rr", "rb", "b", "x", "rf", "rd", "rc", "ri", "m", "rh", "l", "ru", "f", "ir", "nr", "res", "u", "e", "w", "ar", "rg", "t", "k", "n", "rx", "err", "result", "p", "h", "R", "mr", "re", "c", "range", "g", "br", "rs", "kr"], "smram": [" smrom", "shgam", " smRAM", "smgram", "svrum", "mmrom", " smgam", "SMram", "smgam", "ymram", "sharm", "smran", " smrum", "sbmm", "sbrom", "mmgram", "SMRAM", "mmmm", "smRAM", " smgram", " smarm", "mmran", "slmm", "mgam", "SMran", "mram", "SMrum", "smrom", "svram", "slgram", "ymrum", "shrom", "slram", "ymgram", "slrom", "svgram", "ymRAM", "smmm", "mmrum", "shram", "smrum", "mrom", "marm", "SMgram", "sbram", "mmram", "smarm", "svran", "sbgram"], "smram_enabled": ["smam_led", "smram__disabled", "smam_Enabled", "smram_powered", "smrom_available", "smream_supported", "smram_enable", "smram_provided", "smrom_provided", "smrom_disabled", "smram_available", "smram_supported", "smream_enable", "smram__led", "smream_powered", "smream_enabled", "smram__enabled", "smam_enabled", "smram__Enabled", "smram_disabled", "smam_disabled", "smram_led", "smrom_enabled", "smram_Enabled"]}}
{"project": "FFmpeg", "commit_id": "0065d2d520caab2321b35a7bec5d62564913238b", "target": 0, "func": "static int parse(AVCodecParserContext *ctx,\n\n                 AVCodecContext *avctx,\n\n                 const uint8_t **out_data, int *out_size,\n\n                 const uint8_t *data, int size)\n\n{\n\n    VP9ParseContext *s = ctx->priv_data;\n\n    int marker;\n\n\n\n    if (size <= 0) {\n\n        *out_size = 0;\n\n        *out_data = data;\n\n\n\n        return 0;\n\n    }\n\n\n\n    if (s->n_frames > 0) {\n\n        *out_data = data;\n\n        *out_size = s->size[--s->n_frames];\n\n        parse_frame(ctx, *out_data, *out_size);\n\n\n\n        return s->n_frames > 0 ? *out_size : size /* i.e. include idx tail */;\n\n    }\n\n\n\n    marker = data[size - 1];\n\n    if ((marker & 0xe0) == 0xc0) {\n\n        int nbytes = 1 + ((marker >> 3) & 0x3);\n\n        int n_frames = 1 + (marker & 0x7), idx_sz = 2 + n_frames * nbytes;\n\n\n\n        if (size >= idx_sz && data[size - idx_sz] == marker) {\n\n            const uint8_t *idx = data + size + 1 - idx_sz;\n\n            int first = 1;\n\n\n\n            switch (nbytes) {\n\n#define case_n(a, rd) \\\n\n            case a: \\\n\n                while (n_frames--) { \\\n\n                    int sz = rd; \\\n\n                    idx += a; \\\n\n                    if (sz > size) { \\\n\n                        s->n_frames = 0; \\\n\n                        av_log(avctx, AV_LOG_ERROR, \\\n\n                               \"Superframe packet size too big: %d > %d\\n\", \\\n\n                               sz, size); \\\n\n                        return AVERROR_INVALIDDATA; \\\n\n                    } \\\n\n                    if (first) { \\\n\n                        first = 0; \\\n\n                        *out_data = data; \\\n\n                        *out_size = sz; \\\n\n                        s->n_frames = n_frames; \\\n\n                    } else { \\\n\n                        s->size[n_frames] = sz; \\\n\n                    } \\\n\n                    data += sz; \\\n\n                    size -= sz; \\\n\n                } \\\n\n                parse_frame(ctx, *out_data, *out_size); \\\n\n                return *out_size\n\n\n\n                case_n(1, *idx);\n\n                case_n(2, AV_RL16(idx));\n\n                case_n(3, AV_RL24(idx));\n\n                case_n(4, AV_RL32(idx));\n\n            }\n\n        }\n\n    }\n\n\n\n    *out_data = data;\n\n    *out_size = size;\n\n    parse_frame(ctx, data, size);\n\n\n\n    return size;\n\n}\n", "idx": 12192, "substitutes": {"ctx": ["mac", "cam", "context", "cmp", "Context", "cca", "conn", "tc", "sci", "c", "cp", "config", "cu", "cb", "cf", "lex", "wcs", "loc", "sq", "coll", "hw", "cc", "bc", "pkg", "cs", "ctrl", "ha", "cv", "ck", "sync", "rc", "cas", "conv", "cal", "ga", "tx", "kt", "jp", "pc", "xc", "nc", "grad", "ca", "cm", "vc", "anc", "lc", "crit", "cmd", "cus", "kb", "sc", "exec"], "avctx": ["avcv", "avcontext", "awctx", "AVcv", "aircontext", "AVcontext", "airctx", "avscl", "AVctx", "awcv", "aircv", "airscl", "AVscl", "awcontext", "awscl"], "out_data": ["outlexvalue", "out_source", "in_sample", "out_bytes", "out_scale", "outlexsize", "in_bytes", "outlexsource", "in_size", "out_sample", "in_window", "in_value", "out___size", "outingsize", "outPdata", "outPwindow", "in_cache", "in_resources", "outingdata", "in_source", "in_content", "outingbytes", "out_content", "out_window", "out_value", "outPsize", "outlexdata", "out_resources", "out___resources", "in_scale", "out___cache", "in_data", "outPscale", "out_cache", "outingsample", "out___data"], "out_size": ["out_storage", "out__scale", "outlexsum", " out_rate", "out_rate", "out__sum", " out_storage", "out_scale", "outNsized", "outlexsize", "out_sum", " out_scale", "in_size", "in_width", " out_width", "outNnumber", "out__size", "out_number", " out_capacity", "out64data", " out_len", "out64sized", "outlexscale", "out_sized", "out__storage", "outNsize", "out_len", " out_sum", "in_status", " out_number", "out_status", "out64size", " out_length", "outlexrate", " out_sized", "outNdata", "out_length", "in_data", "out_width", "out_capacity", "out64number"], "data": ["parent", "media", "record", "pad", "config", "package", "memory", "frame", "body", "none", "code", "values", "response", "content", "first", "offset", "change", "ma", "image", "buffer", "timeout", "date", "da", "missing", "i", "draw", "meta", "value", "DATA", "zero", "slice", "index", "input", "load", "Data", "storage", "bytes", "li", "one", "map", "zip", "sample", "source", "d", "array", "dat", "alpha", "resource", "raw", "done", "new", "message", "a", "result", "cache", "area", "byte", "scale", "start", "window", "batch", "p", "reader", "number", "empty", "next", "multi", "address", "results", "dd", "video", "length"], "size": ["count", "channel", "fail", "again", "word", "z", "SIZE", "shift", "sum", "max", "set", "loc", "frame", "body", "code", "content", "end", "grade", "offset", "type", "form", "row", "image", "iz", "timeout", "si", "n", "no", "go", "id", "i", "c", "work", "se", "e", "value", "or", "large", "group", "unit", "slice", "sized", "en", "load", "storage", "position", "error", "li", "file", "complete", "fee", "member", "len", "g", "handle", "second", "small", "page", "send", "from", "flow", "mode", "shape", "column", "sync", "raw", "sn", "new", "enc", "message", "engine", "ize", "area", "scale", "capacity", "pack", "line", "time", "p", "number", "empty", "Size", "sec", "name", "six", "address", "false", "cm", "pos", "gz", "length"], "s": ["l", "conf", "sg", "ts", "ks", "context", "sv", "ds", "si", "n", "g", "in", "is", "sf", "w", "m", "b", "t", "d", "i", "gs", "sa", "c", "service", "p", "ls", "e", "se", "parts", "xs", "sq", "rs", "outs", "f", "os", "cs", "sym", "o", "S", "es", "sync", "v", "space", "services", "sup", "r", "ns", "sb", "spec", "u", "sys", "h", "client", "a", "ses", "ps", "site", "y", "ss", "fs", "ssl", "sc"], "marker": ["callener", "marksorer", "arkorer", "Markner", " markger", "Markoder", "arketer", " Markger", "calleter", "signer", "Marketer", "marksener", "Markger", "marketer", "markedeter", "markser", "markedner", "markner", " markoder", "calloser", "signiner", "markiner", " markorer", "Markiner", " markiner", "marksger", "signeter", "caller", "markseter", "signener", "Markoser", "markers", "markeders", "markorer", "markoder", "markger", "arker", " markers", " markner", " Marker", " markoser", "arkiner", "signoser", "Markers", "markeder", "marksoser", " marketer", "Marker", "markoser", " markener", "marksiner", " Markiner", "markener", " Markoder"], "idx": ["Idx", " idxes", "idn", " idxs", "Idz", "adx", "ideX", "idex", " idz", " idX", "adz", "adxs", "adn", "indct", "idz", "indx", "idX", " idxx", "edxes", " idn", "indxp", "indxs", "adX", "edx", "edz", "indz", "idxp", "Idct", "midx", "pidz", "Idxp", "Idn", "edxs", "idez", " idct", "Idxs", "idxx", "adxes", "IdX", "pidx", "idexp", "indX", "idexx", "idxs", "idxes", "idct", "midX", "midz", "midxx", "pidxs", "idexs", "pidX"]}}
{"project": "FFmpeg", "commit_id": "a8d702859b8bd17978fb5d8cb1d6acc363031e80", "target": 1, "func": "static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb)\n\n{\n\n    MLPHeaderInfo mh;\n\n    int substr, ret;\n\n\n\n    if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0)\n\n        return ret;\n\n\n\n    if (mh.group1_bits == 0) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"invalid/unknown bits per sample\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.group2_bits > mh.group1_bits) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Channel group 2 cannot have more bits per sample than group 1.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Channel groups with differing sample rates are not currently supported.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.group1_samplerate == 0) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"invalid/unknown sampling rate\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.group1_samplerate > MAX_SAMPLERATE) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Sampling rate %d is greater than the supported maximum (%d).\\n\",\n\n               mh.group1_samplerate, MAX_SAMPLERATE);\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.access_unit_size > MAX_BLOCKSIZE) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Block size %d is greater than the supported maximum (%d).\\n\",\n\n               mh.access_unit_size, MAX_BLOCKSIZE);\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Block size pow2 %d is greater than the supported maximum (%d).\\n\",\n\n               mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.num_substreams == 0)\n\n        return AVERROR_INVALIDDATA;\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"MLP only supports up to 2 substreams.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.num_substreams > MAX_SUBSTREAMS) {\n\n\n                              \"%d substreams (more than the \"\n\n                              \"maximum supported by the decoder)\",\n\n                              mh.num_substreams);\n\n\n\n\n\n    m->access_unit_size      = mh.access_unit_size;\n\n    m->access_unit_size_pow2 = mh.access_unit_size_pow2;\n\n\n\n    m->num_substreams        = mh.num_substreams;\n\n    m->max_decoded_substream = m->num_substreams - 1;\n\n\n\n    m->avctx->sample_rate    = mh.group1_samplerate;\n\n    m->avctx->frame_size     = mh.access_unit_size;\n\n\n\n    m->avctx->bits_per_raw_sample = mh.group1_bits;\n\n    if (mh.group1_bits > 16)\n\n        m->avctx->sample_fmt = AV_SAMPLE_FMT_S32;\n\n    else\n\n        m->avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    m->params_valid = 1;\n\n    for (substr = 0; substr < MAX_SUBSTREAMS; substr++)\n\n        m->substream[substr].restart_seen = 0;\n\n\n\n    /* Set the layout for each substream. When there's more than one, the first\n\n     * substream is Stereo. Subsequent substreams' layouts are indicated in the\n\n     * major sync. */\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP) {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        m->substream[substr].ch_layout = mh.channel_layout_mlp;\n\n    } else {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        if (mh.num_substreams > 2)\n\n            if (mh.channel_layout_thd_stream2)\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream2;\n\n            else\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream1;\n\n        m->substream[substr].ch_layout = mh.channel_layout_thd_stream1;\n\n\n\n        if (m->avctx->channels<=2 && m->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) {\n\n            av_log(m->avctx, AV_LOG_DEBUG, \"Mono stream with 2 substreams, ignoring 2nd\\n\");\n\n            m->max_decoded_substream = 0;\n\n            if (m->avctx->channels==2)\n\n                m->avctx->channel_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n\n\n    m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20;\n\n\n\n    return 0;\n", "idx": 748, "substitutes": {"m": ["mn", "cm", "media", "vm", "mount", "ctx", "q", "em", "mod", "M", "mc", "bm", "km", "r", "d", "n", "ms", "im", "mm", "k", "y", "i", "g", "j", "model", "mac", "gm", "md", "om", "h", "l", "c", "p", "man", "e", "dm", "f", "jam", "arm", "message", "machine", "wm", "mp", "pm", "u", "rm", "fm", "v", "um", "tm", "mr", "sm", "b", "s", "t", "module", "manager", "am", "mu", "ym"], "gb": ["rg", "ctx", "gram", "kb", "ga", "gc", "sb", "bm", "hub", "ui", "mb", "gy", "gnu", "bc", "GB", "gin", "gg", "rb", "gm", "cgi", "kw", "gam", "bf", "gs", "Gb", "bd", "bg", " bc", "bb", "abb", "usb", "gd", "db", "xb"], "mh": ["dimhr", "bmhr", "dch", "cmch", " mhs", "emh", "dh", "dmah", "cmbh", "gph", "Mrh", "amih", "gmh", " mch", "emH", "mah", "mih", "amhr", "fmhs", "mhs", "ymsh", "mkh", "dmrh", "emhs", "h1", "vsh", " mph", "mhr", "pmh", "bmph", "emsh", "tmrh", "tmh", "hz", "mmH", "modelh", " mich", "paramrh", "Mch", "mbh", "pmhr", "mmph", "dmh", "modul", "vhs", "bmsh", "vh", "Mach", "fmch", "amz", "amv", "m1", "hih", "pmH", "hkh", "gmhr", "Mh", " m1", "hsh", "gach", "tmph", "gmrh", "ymh", "mich", "gh", "mz", "cmh", "ymkh", "dimh", "hah", "dmsh", "amph", "fmrh", " mkh", "modelhs", " mrh", "paramh", " mul", "mrh", "dimhs", "amh", "modach", "fmhr", " mih", "amH", "Mbh", "mph", "fmh", "hh", " mH", "mv", "amach", "ghr", "pmrh", " mz", "dimich", "dhr", "ymv", "model1", " mhr", "cmrh", " mah", "paramhs", "hul", " mbh", "vH", "gmH", " mv", "modh", "mmh", " msh", "mmsh", "msh", " mach", "mch", "Mich", "hv", "bmh", "tmsh", "Mhr", "mH", "hhs", "modelach", "modah", "Mhs", "tmah", "mul", "mmhr", "dhs", "hach", "mmv", "mach", "amhs", "tmv", "tmhr", "paramach"], "substr": ["subchar", "ubctr", "subctr", " subctr", "ubchar", "extctr", "ubStr", " subStr", "extStr", "extstr", " subchar", "ubstr", "extchar", "subStr"], "ret": ["match", "arg", "att", "mt", "def", "bit", "sb", "success", "r", "alt", "cur", "rets", "arr", "bl", "rep", "code", "ft", "nt", "back", "reply", "feat", "Ret", "status", "bf", "rc", "result", "ut", "len", "red", "ref", "rem", "rl", "flag", "gt", "art", "value", "en", "RET", "al", "lit", "re", "reg", "val", "rt", "let", "af", "det", "res", "bad"]}}
{"project": "FFmpeg", "commit_id": "89325417e7b33f4b08171d9d609c48662d96b2d3", "target": 1, "func": "static int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n    if (bytestream2_get_bytes_left(&s->g) < 36) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Insufficient space for SIZ\\n\");\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n    if (s->image_offset_x || s->image_offset_y) {\n        avpriv_request_sample(s->avctx, \"Support for image offsets\");\n        return AVERROR_PATCHWELCOME;\n    if (av_image_check_size(s->width, s->height, 0, s->avctx)) {\n        avpriv_request_sample(s->avctx, \"Large Dimensions\");\n        return AVERROR_PATCHWELCOME;\n    if (ncomponents <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              ncomponents);\n        return AVERROR_PATCHWELCOME;\n    s->ncomponents = ncomponents;\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Insufficient space for %d components in SIZ\\n\", s->ncomponents);\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n    if (i == possible_fmts_nb) {\n        if (ncomponents == 4 &&\n            s->cdy[0] == 1 && s->cdx[0] == 1 &&\n            s->cdy[1] == 1 && s->cdx[1] == 1 &&\n            s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) {\n            if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n                s->cdef[0] = 0;\n                s->cdef[1] = 1;\n                s->cdef[2] = 2;\n                s->cdef[3] = 3;\n                i = 0;\n    if (i == possible_fmts_nb) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d\\n\"\n               \"cdx[0]: %d, cdy[0]: %d\\n\"\n               \"cdx[1]: %d, cdy[1]: %d\\n\"\n               \"cdx[2]: %d, cdy[2]: %d\\n\"\n               \"cdx[3]: %d, cdy[3]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               s->cdx[0],\n               s->cdy[0],\n               ncomponents > 1 ? s->cdx[1] : 0,\n               ncomponents > 1 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0,\n               ncomponents > 3 ? s->cdx[3] : 0,\n               ncomponents > 3 ? s->cdy[3] : 0);\n        return AVERROR_PATCHWELCOME;\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;", "idx": 1318, "substitutes": {"s": ["sg", "js", "qs", "sites", "g", "ls", "ses", "sf", "args", "vs", "us", "self", "f", "secondary", "sys", "u", "your", "se", "fs", "parts", "spec", "ts", "sb", "aws", "format", "ims", "y", "uns", "xs", "sv", "sets", "p", "e", "lines", "conf", "as", "uses", "v", "su", "site", "S", "t", "os", "session", "ks", "its", "hs", "in", "sym", "ssl", "cs", "ss", "rs", "a", "data", "new", "r", "is", "ins", "ions", "bis", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "words", "size", "es", "o", "img", "si", "_", "service", "ops", "window", "d", "results", "ans", "ms", "comments", "params", "sync", "ats", "tests", "l", "services", "w", "sq", "stats", "b", "full", "states"], "i": ["li", "counter", "a", "ii", "pi", "ui", "I", "n", "di", "is", "iu", "j", "m", "ti", "multi", "temp", "ip", "l", "c", "p", "f", "v", "b", "t", "count", "io", "si", "xi"], "ncomponents": ["bcommonents", "ncountients", " nComponent", "ncommances", "ncompenses", "ncomponent", "ncommounds", "numparlements", "sncomponents", "nmacresses", "ncondonents", "ncomonents", "bcommenses", "ncontlements", "sncomparters", " nComponents", "npropones", "nummacresses", "sncompuments", "nspuments", "nquonents", "bcommlements", "numcomplements", "ncontresses", "sncommarters", "ncompounds", "ncommonents", "numcomponents", "nummacones", "numcompones", "ncaponents", "numcompresses", "numparresses", "nproponents", "numcompients", "nmaclements", "nquarters", "ncompuments", "ncomparters", "ncondlements", "ncommonent", "ncompresses", "bcomplements", "nsponents", "ncondenses", "ncaplements", "sncommones", "nparients", "nummaconents", "ncomounds", "ncompances", "ncondances", "sncommonents", "ncountlements", "ncommones", "nsparters", "sncompones", "numparonents", "bcompounds", "ncommarters", "bcomponents", "nquones", "ncompones", "nmaconents", "npropresses", "ncondonent", " ncompances", "nproplements", "ncountresses", "ncomlements", "ncondounds", "nparresses", " ncomplements", "nspones", " nCompances", "nparlements", "numparients", "ncountonents", "ncompients", "ncommenses", "nparonents", "ncomplements", "ncontones", " ncomponent", "ncontonents", "nComplements", " nComplements", "ncapients", "nComponent", "nComponents", "nummaclements", "ncommlements", "nquuments", "ncomenses", "sncommuments", "bcompenses", "nCompances", "ncommuments", "ncapresses", "bcommounds", "nmacones"], "possible_fmts": ["possible_mats", "possible_mt", "possible_cmts", "possible_fmats", "possible_FMts", "possible_FMters", "possible_fmters", "possible_mts", "possible_mters", "possible_cmt", "possible_FMats", "possible_FMt", "possible_cmters", "possible_cmats", "possible_fmt"]}}
{"project": "FFmpeg", "commit_id": "b164d66e35d349de414e2f0d7365a147aba8a620", "target": 0, "func": "static void predictor_decode_mono(APEContext *ctx, int count)\n\n{\n\n    APEPredictor *p = &ctx->predictor;\n\n    int32_t *decoded0 = ctx->decoded[0];\n\n    int32_t predictionA, currentA, A, sign;\n\n\n\n    currentA = p->lastA[0];\n\n\n\n    while (count--) {\n\n        A = *decoded0;\n\n\n\n        p->buf[YDELAYA] = currentA;\n\n        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];\n\n\n\n        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +\n\n                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +\n\n                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +\n\n                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];\n\n\n\n        currentA = A + (predictionA >> 10);\n\n\n\n        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);\n\n        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);\n\n\n\n        sign = APESIGN(A);\n\n        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;\n\n        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;\n\n        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;\n\n        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;\n\n\n\n        p->buf++;\n\n\n\n        /* Have we filled the history buffer? */\n\n        if (p->buf == p->historybuffer + HISTORY_SIZE) {\n\n            memmove(p->historybuffer, p->buf,\n\n                    PREDICTOR_SIZE * sizeof(*p->historybuffer));\n\n            p->buf = p->historybuffer;\n\n        }\n\n\n\n        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);\n\n        *(decoded0++) = p->filterA[0];\n\n    }\n\n\n\n    p->lastA[0] = currentA;\n\n}\n", "idx": 2093, "substitutes": {"ctx": ["cm", "parser", "np", "cli", "cam", "cs", "kb", "conn", "context", "cc", "anc", "mc", "cpp", "Context", "loc", "nc", "bc", "tc", "pb", "client", "cas", "tp", "fp", "tx", "cb", "utils", "config", "pkg", "c", "cv", "xc", "cn", "ca", "ctrl", "sc", "exec", "hp", "core", "cmd", "pc", "cca", "connection", "qa", "cp", "cf", "conv", "ci", "wp", "sci", "input", "rc"], "count": ["call", "base", "test", "group", "counter", "key", "context", "cc", "process", "type", "weight", "id", "parent", "num", "loop", "batch", "max", "comp", "code", "coll", "number", "cond", "C", "ind", "c", "force", "len", "length", "child", "col", "cache", "amount", "seq", "b", "depth", "Count", "val", "part", "list"], "p": ["this", "after", "q", "process", "get", "current", "n", "sp", "pb", "client", "j", "g", "er", "progress", "self", "private", "f", "prev", "u", "jp", "mp", "s", "at", "cp", "wp", "pp", "parser", "local", "pd", "pi", "ap", "k", "parent", "api", "y", "fp", "P", "python", "parse", "post", "pa", "pkg", "e", "per", "hp", "pm", "v", "plugin", "t", "gp", "np", "vp", "lp", "a", "data", "r", "press", "op", "py", "pre", "i", "m", "proc", "project", "ps", "h", "c", "app", "cache", "o", "bp", "http", "d", "pg", "cop", "it", "comp", "tp", "ip", "l", "w", "exec", "up", "pc", "point", "b", "full", "part"], "decoded0": [" decoded1", "decided4", "decoded1", " decided1", "decaned1", "decoded192", "decided1", "decrypted1", "decrypted0", "deccoded1", " decoded4", "decaned4", "decached4", " decoded192", "decided0", "decided192", " decided0", " decided192", "decrypted4", "deccoded4", "deccoded0", "decached192", "decoded4", " decided4", "deccoded192", "decached1", "decached0", "decaned0"], "predictionA": ["predictedY", "preditionC", "predictiona", " predictedA", "PredictedA", "predictedC", "PredictedB", "predictionB", " predictedN", "predisonN", "predisonA", "predictionsN", "predictionsY", "PredictionC", "Predictiona", "PredictionN", "predicationC", "predicationN", " predictionY", " predictedY", "predictedB", "PredictionB", "Predicteda", "predictedA", "predicationA", "predolutionA", "predictionsa", "predictedN", "predictionY", "predisonB", "predictionsB", "predolutionB", "preditionN", "PredictedN", "predisonY", "preditionA", "predictionN", " predictionN", " predictedB", "predicteda", "predictionC", "predictionsA", "PredictedC", "predolutiona", " predictionB", "PredictionA"], "currentA": ["CurrentY", "contentN", " currentY", "reportedN", "reportedY", "currentP", "reportedAverage", " currentD", " currentAn", "currentB", " currentP", "reportedB", " currentArray", "CurrentB", "CurrentA", "reportedP", "CurrentD", "CurrentP", "presentA", "currentD", "CurrentAverage", "currentY", "reportedD", "presentP", "presentAn", "contentA", "reportedAPI", "currentN", "contentAPI", "currentAPI", " currentAverage", "currentArray", "contentArray", " currentAPI", "reportedA", "currentAn", "currentAverage", " currentB", "reportedAn", "presentN", "reportedArray", " currentN"], "A": ["H", "Q", "HA", "Am", "G", "AA", "a", "sa", "array", "M", "U", "ASC", "CA", "Alpha", "B", "API", "I", "AC", "aa", "PA", "AR", "K", "AF", "W", "AP", "aw", "AV", "AW", "P", "X", "Sign", "EA", "C", "au", "ai", "NA", "N", "alpha", "L", "w", "AM", "V", "amp", "Adam", "T", "SA", "S", "Y", "LA", "am", "D", "mA"], "sign": ["match", " sig", "sub", "se", "check", "act", "ss", "key", "spec", "form", "ver", "type", "tick", "sh", "ign", " SIGN", "enc", "pass", "search", "max", "space", "scan", "lex", "Sign", "inc", "parse", "ident", "step", "x", "ind", "dash", "sw", "connect", "change", "SIGN", "ment", "set", "draw", "cap", "dig", "sq", "sc", "contract", "save", "fix", "min", "value", "sum", "vis", "pull", "scale", "action", "close", "mix", "IGN", "shape", "start", "plus", "keep", "pack"], "buf": ["nat", "ff", "src", "buffer", "append", "bh", "bag", "bn", "context", "queue", "header", "loc", "aux", "cat", "av", "bc", "buff", "cur", "hist", "bin", "prof", "num", "cas", "batch", "map", "auc", "lim", "rb", "code", "dest", "box", "comb", "cb", "hal", "feat", "config", "pool", "home", "pub", "raw", "begin", "pkg", "block", "cv", "vec", "doc", "wb", "cap", "cache", "br", "uv", "agg", "history", "bt", "la", "cmd", "alloc", "bg", "bu", "carry", "seq", "cf", "conv", "uf", "img", "uu", "fam", "uc", "rc", "port"]}}
{"project": "qemu", "commit_id": "de9e9d9f17a36ff76c1a02a5348835e5e0a081b0", "target": 0, "func": "static inline void gen_op_eval_fbo(TCGv dst, TCGv src,\n\n                                    unsigned int fcc_offset)\n\n{\n\n    gen_mov_reg_FCC0(dst, src, fcc_offset);\n\n    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);\n\n    tcg_gen_and_tl(dst, dst, cpu_tmp0);\n\n    tcg_gen_xori_tl(dst, dst, 0x1);\n\n}\n", "idx": 27257, "substitutes": {"dst": ["idbl", "nrc", "edst", "pST", "isdst", "idST", " drc", " dsts", "dsts", "edsc", "frc", "fdst", "sdsp", "fdost", "nput", "Dsrc", "prc", "idstop", "edstop", "DST", "sdST", "isdsc", "fdbl", "dST", " dost", "fst", "fdste", "dsrc", "pst", " dste", " dsp", "pdrc", "edST", "pdsrc", " dbl", "cdsrc", "sdstop", "dstop", "sdsc", "fsrc", "dbl", "sdst", "pddest", "sdsts", "nst", "fdest", "cdST", "isdsp", "idste", "dsp", " dsc", "ddest", "dost", "nST", " dST", "pput", " dput", "cdst", "drc", "dsc", "isdsts", " ddest", "Dsc", "idst", "idost", " dsrc", "dste", "pdst", "Dst", "cdsc", "dput", "idsc"], "src": ["sc", "obl", "sys", "sr", "rib", "uc", "b", "sn", "img", "rb", "config", "vr", "cur", "rin", "cb", "bc", "inst", "sync", "url", "rec", "cmp", "rss", "fc", "sur", "sta", "rl", "vc", "loc", "sub", "lib", "st", "sel", "ctx", "stat", "sb", "rc", "conv", "sup", "dist", "source", "dest", "stab", "sl", "attr", "ssl"], "fcc_offset": ["fct_offset", "fct_adjusted", "fCCsoffset", "fccsoffset", "fcc2ref", "fccsOffset", "fcc_adjusted", "fck_offset", "fck_Offset", "fcc_position", "fcc_off", "fcc2offset", "fcc_ref", "fCC_offset", "fck_off", "fcc2off", "fCC_ref", "fct_ref", "fCC_off", "fCCsoff", "fCCsref", "fcc_Offset", "fccsref", "fct_position", "fccsoff"]}}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static int segment_hls_window(AVFormatContext *s, int last)\n\n{\n\n    SegmentContext *seg = s->priv_data;\n\n    int i, ret = 0;\n\n    char buf[1024];\n\n\n\n    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,\n\n                              &s->interrupt_callback, NULL)) < 0)\n\n        goto fail;\n\n\n\n    avio_printf(seg->pb, \"#EXTM3U\\n\");\n\n    avio_printf(seg->pb, \"#EXT-X-VERSION:3\\n\");\n\n    avio_printf(seg->pb, \"#EXT-X-TARGETDURATION:%d\\n\", (int)seg->time);\n\n    avio_printf(seg->pb, \"#EXT-X-MEDIA-SEQUENCE:%d\\n\",\n\n                FFMAX(0, seg->number - seg->size));\n\n\n\n    av_log(s, AV_LOG_VERBOSE, \"EXT-X-MEDIA-SEQUENCE:%d\\n\",\n\n           FFMAX(0, seg->number - seg->size));\n\n\n\n    for (i = FFMAX(0, seg->number - seg->size);\n\n         i < seg->number; i++) {\n\n        avio_printf(seg->pb, \"#EXTINF:%d,\\n\", (int)seg->time);\n\n        if (seg->entry_prefix) {\n\n            avio_printf(seg->pb, \"%s\", seg->entry_prefix);\n\n        }\n\n        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);\n\n        if (ret < 0) {\n\n            ret = AVERROR(EINVAL);\n\n            goto fail;\n\n        }\n\n        avio_printf(seg->pb, \"%s\\n\", buf);\n\n    }\n\n\n\n    if (last)\n\n        avio_printf(seg->pb, \"#EXT-X-ENDLIST\\n\");\n\nfail:\n\n    avio_closep(&seg->pb);\n\n    return ret;\n\n}\n", "idx": 10620, "substitutes": {"s": ["conf", "session", "sg", "ts", "sv", "si", "g", "n", "sf", "stats", "m", "src", "b", "t", "gs", "sa", "c", "service", "serv", "p", "server", "ls", "e", "qs", "se", "xs", "js", "sq", "rs", "f", "args", "us", "o", "aws", "v", "es", "sync", "scope", "south", "sie", "sl", "services", "ns", "sb", "storage", "spec", "u", "self", "comm", "h", "sys", "client", "soc", "a", "su", "site", "ses", "ss", "sr", "core", "ssl", "sc"], "last": ["count", "later", "parent", "l", "timeout", "start", "show", "second", "Last", "info", "total", "latest", "reply", "max", "prev", "se", "cli", "final", "style", "loc", "lag", "sec", "next", "code", "size", "eval", "event", "state", "end", "old", "full", "first", "error", "after", "li", "length", "result", "use", "lo"], "seg": [" sek", "SEc", "kep", "eleig", "kel", "beg", "teig", "serge", "elega", "tegen", "sug", "ceg", "segm", "schega", "sege", "kege", "SEgo", "keG", "segs", "zego", "kegn", "neG", "gec", "negen", "zek", "serg", "SEp", "lec", "gee", "gego", "schege", "geg", "adeg", "kegg", "neig", "adeleg", "kec", "serig", "SEb", " segm", "sugment", "zega", "keg", "begg", "gega", "speb", "tege", "peg", "tega", " sega", "pseg", "bep", "schegn", "zeg", "selk", "persego", "schegg", "begm", "inego", "tegm", "segment", "sergen", "segn", "cege", "legen", "begs", "seig", " sego", "nego", "sep", "sega", " segen", "selgg", "pegen", "nep", "SEg", "SEge", "zep", "adegg", "tegn", "spegen", "pec", "speg", "scheg", "seleg", "persegen", "sel", "kego", "suga", "gep", "geig", "seeg", "pep", "schego", "parsegn", "tego", " see", "selge", "SEga", " segn", "seb", "keig", "selgn", "bega", "cega", "schegment", "kegen", "sek", "eleg", "neg", "parseg", "pega", "segen", "SEgen", "gege", "inega", "sego", "keleg", "ineg", "tee", "adep", "pege", "psegn", "psep", "spego", "segg", "nega", "seegs", "selga", "elege", "leg", " sege", "lel", "gegn", "perseg", "psegen", "gegm", "inege", "begen", "zege", "seep", "peig", "gegment", "selg", "sec", "sugn", "parsegen", "seegm", "beleg", "cegen", "gegen", " sep", " sec", "teg", "see", "SEig", "SEgn", "gegs", "perseb", "gel", "parsep", "psega", "kega", "seG", "geG"], "i": ["oi", "l", "ui", "di", "base", "it", "start", "n", "si", "in", "zi", "info", "xi", "id", "b", "ini", "z", "c", "line", "limit", "p", "ix", "uri", "e", "iter", "eni", "f", "ie", "j", "ai", "multi", "index", "slice", "ind", "mi", "ti", "gi", "phi", "name", "r", "abi", "qi", "bi", "pi", "ii", "type", "I", "li", "ip", "ci", "ni", "ski", "ri", "fi", "iu"], "buf": ["bag", "uf", " b", "seq", "Buffer", "img", "ff", "pad", "ba", "src", "fd", "b", "wb", " arr", "mem", " bu", "pool", "block", "data", "fb", "bd", "config", "fi", "pb", "cb", "fp", "queue", "rb", "loc", "tmp", "bc", "f", "alloc", "cv", "msg", "exc", "rc", "bh", "bed", "raw", "home", "ctx", "callback", "bytes", "h", "null", "ret", " buffer", "func", "buff", "br", "cmd", "result", "vec", "buffer", " buff", "text", "box", "uc"]}}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "static int kvm_put_xsave(CPUState *env)\n\n{\n\n#ifdef KVM_CAP_XSAVE\n\n    int i, r;\n\n    struct kvm_xsave* xsave;\n\n    uint16_t cwd, swd, twd, fop;\n\n\n\n    if (!kvm_has_xsave())\n\n        return kvm_put_fpu(env);\n\n\n\n    xsave = qemu_memalign(4096, sizeof(struct kvm_xsave));\n\n    memset(xsave, 0, sizeof(struct kvm_xsave));\n\n    cwd = swd = twd = fop = 0;\n\n    swd = env->fpus & ~(7 << 11);\n\n    swd |= (env->fpstt & 7) << 11;\n\n    cwd = env->fpuc;\n\n    for (i = 0; i < 8; ++i)\n\n        twd |= (!env->fptags[i]) << i;\n\n    xsave->region[0] = (uint32_t)(swd << 16) + cwd;\n\n    xsave->region[1] = (uint32_t)(fop << 16) + twd;\n\n    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,\n\n            sizeof env->fpregs);\n\n    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,\n\n            sizeof env->xmm_regs);\n\n    xsave->region[XSAVE_MXCSR] = env->mxcsr;\n\n    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;\n\n    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,\n\n            sizeof env->ymmh_regs);\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_XSAVE, xsave);\n\n    qemu_free(xsave);\n\n    return r;\n\n#else\n\n    return kvm_put_fpu(env);\n\n#endif\n\n}\n", "idx": 4615, "substitutes": {"env": ["energy", "reset", "el", "environment", "password", "style", "et", "gui", "gear", "conf", "ev", "code", "her", "exec", "equ", "Environment", "enh", "ec", "stage", "vert", "dt", "engine", "conn", "ah", "vm", "config", "qt", "nc", "eu", "inet", "cal", "eye", "server", "assets", "ini", "ne", "viron", "eve", "site", "En", " environment", "forge", "agen", "end", "eng", "er", "dat", "esp", "exc", "db", "atten", "export", "ext", "esi", "net", "np", "e", "que", "en", "dev", "erv", "global", "core", "ette", "loader", "dict", "enable", "fen", "ea", "v", "enc", "event", "args", "init", "n", "context", "eni", "console", "cv", "esm", "manager", "cdn"], "i": ["gi", "o", "ti", "v", "id", "I", "is", "a", "chi", "di", "s", "ci", "ni", "x", "b", "io", "si", "xi", "ri", "bi", "m", "in", "qi", "ix", "l", "f", "pi", "yi", "phi", "j", "iu", "ii", "d", "it", "ai", "vi", "u", "e", "w", "t", "k", "n", "multi", "mi", "ie", "p", "eni", "z", "hi", "c", "ip", "ind", "y", "li", "fi", "index", "zi", "ui"], "r": ["er", "sr", "v", "rb", "b", "x", "rc", "or", "m", "rh", "resource", "l", "ir", "ru", "like", "f", "attr", "d", "nr", "res", "e", "w", "ar", "rg", "arr", "ur", "k", "t", "n", "err", "rl", "lr", "str", "result", "p", "array", "run", "h", "R", "re", "mr", "c", "range", "g", "hr", "br", "rs", "rec"], "xsave": [" xparse", "axparse", "ypack", "mxsav", "xparse", "exparse", "axslave", "rxsav", "rxpose", "xiwrite", "xstore", "xisaving", "axappend", "xxstore", "exsav", "xpack", "sexsave", "txpose", "xpose", "mxsave", "xappend", "xapply", "xxappend", "crosssaving", "excreate", "xset", "xxparse", "sexape", " xave", "xsav", "sexsav", "rxsave", "yxscale", " xsav", "rxave", "wxstage", "Xsave", "axadd", "Xset", "plexapply", "xslave", " xstore", "xxsave", "plexset", "crossready", "xstage", "xisave", " xwrite", "xcreate", "xxwrite", "ysave", "sexparse", " xcreate", "exsave", "xxcreate", "txsav", "xscale", "yxsaving", "nexcreate", "mxadd", "axapply", "expack", "ysav", "crossave", "ycreate", " xappend", "nexsave", "Xparse", " xstage", "txsave", "axsav", "plexsave", "sexstage", "Xave", "Xpose", "xape", "exave", "axcreate", " xsaving", "xxslave", "xadd", "sexave", "wxsav", "xiready", "xxsav", "Xsav", "axwrite", "xicreate", "txave", "exslave", "xistore", "xwrite", " xapply", " xscale", "plexave", "crosssave", "xxapply", "Xready", "xxpack", "xready", "wxape", "xiave", "xave", "wxsave", " xape", "mxcreate", "xxadd", "axsave", "Xstage", "yxcreate", "xsaving", "yxsave", "nexscale", "Xsaving", "Xapply", " xset", "nexsaving"], "cwd": ["pcwn", "fnt", "cwl", "cwt", "cft", "fpt", "fcwa", "lcwn", "lcwk", "cwn", "rcwk", "cwk", "cnt", "scft", " cnt", "pcwd", "pcwk", "scwk", " cwt", "scmd", "cpt", "lcwd", "acmd", "cwa", "fcnt", "cws", "rcwd", "cmd", "fcpt", " cpt", "conft", "rcws", "scwd", "conmd", " cwl", "acwk", "conwk", "fcwd", "rcwl", "pcwt", "conwd", "acft", "lcwt", "fwa", " cwa", "fwd", " cwn", "acwl", " cws", "acwd", "acws", " cwk"], "swd": ["wwf", "swD", "wwl", "smd", "Sws", "ewf", "twp", "twsd", "SWds", "Swds", "wws", "ewd", "sms", "swl", "smsd", "ewp", " tws", "Swd", "SWD", "wwp", "Swl", "tws", "SWs", "SWd", " twt", "swt", " sws", "sws", " swf", " swt", " twds", "wwD", "swf", "twt", "twl", "swp", "ewds", " swds", "swds", "twds", "smp", " swp", "wwd", "swsd", "wwsd", "twD", "wwds"], "twd": ["wwf", " twl", "wwl", "twsd", " twc", "wws", "twc", "rwc", "swl", " tws", "rwl", "wxs", "sexf", "nwds", "tws", "swt", " twt", "sext", "nwsd", "wxd", "twf", "wwc", "sexl", "wwt", "wxt", "nwd", " twds", "twl", "twt", "swf", " twsd", "nwl", "swds", "twds", "rwd", "wwd", "rws", "wxl", "swsd", "sexd"], "fop": ["rfhop", "nop", " fhop", "coper", "infomp", "flops", "fops", "fomp", "homp", "infhop", " foper", "comp", "fhop", "floper", "infoper", "flop", "rfoper", "pop", "hoper", "nhop", "rfop", "flomp", "hop", "phop", "foper", "hhop", " fops", "noper", " fomp", "nomp", "cops", "infop", "cop", "poper"]}}
{"project": "qemu", "commit_id": "65f82df0d7a71ce1b10cd4c5ab08888d176ac840", "target": 1, "func": "process_tx_desc(E1000State *s, struct e1000_tx_desc *dp)\n\n{\n\n    uint32_t txd_lower = le32_to_cpu(dp->lower.data);\n\n    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);\n\n    unsigned int split_size = txd_lower & 0xffff, bytes, sz, op;\n\n    unsigned int msh = 0xfffff, hdr = 0;\n\n    uint64_t addr;\n\n    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;\n\n    struct e1000_tx *tp = &s->tx;\n\n\n\n    if (dtype == E1000_TXD_CMD_DEXT) {\t// context descriptor\n\n        op = le32_to_cpu(xp->cmd_and_length);\n\n        tp->ipcss = xp->lower_setup.ip_fields.ipcss;\n\n        tp->ipcso = xp->lower_setup.ip_fields.ipcso;\n\n        tp->ipcse = le16_to_cpu(xp->lower_setup.ip_fields.ipcse);\n\n        tp->tucss = xp->upper_setup.tcp_fields.tucss;\n\n        tp->tucso = xp->upper_setup.tcp_fields.tucso;\n\n        tp->tucse = le16_to_cpu(xp->upper_setup.tcp_fields.tucse);\n\n        tp->paylen = op & 0xfffff;\n\n        tp->hdr_len = xp->tcp_seg_setup.fields.hdr_len;\n\n        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);\n\n        tp->ip = (op & E1000_TXD_CMD_IP) ? 1 : 0;\n\n        tp->tcp = (op & E1000_TXD_CMD_TCP) ? 1 : 0;\n\n        tp->tse = (op & E1000_TXD_CMD_TSE) ? 1 : 0;\n\n        tp->tso_frames = 0;\n\n        if (tp->tucso == 0) {\t// this is probably wrong\n\n            DBGOUT(TXSUM, \"TCP/UDP: cso 0!\\n\");\n\n            tp->tucso = tp->tucss + (tp->tcp ? 16 : 6);\n\n        }\n\n        return;\n\n    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {\n\n        // data descriptor\n\n        if (tp->size == 0) {\n\n            tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8;\n\n        }\n\n        tp->cptse = ( txd_lower & E1000_TXD_CMD_TSE ) ? 1 : 0;\n\n    } else {\n\n        // legacy descriptor\n\n        tp->cptse = 0;\n\n    }\n\n\n\n    if (vlan_enabled(s) && is_vlan_txd(txd_lower) &&\n\n        (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) {\n\n        tp->vlan_needed = 1;\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header),\n\n                      le16_to_cpup((uint16_t *)(s->mac_reg + VET)));\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header + 2),\n\n                      le16_to_cpu(dp->upper.fields.special));\n\n    }\n\n        \n\n    addr = le64_to_cpu(dp->buffer_addr);\n\n    if (tp->tse && tp->cptse) {\n\n        hdr = tp->hdr_len;\n\n        msh = hdr + tp->mss;\n\n        do {\n\n            bytes = split_size;\n\n            if (tp->size + bytes > msh)\n\n                bytes = msh - tp->size;\n\n\n\n            bytes = MIN(sizeof(tp->data) - tp->size, bytes);\n\n            pci_dma_read(&s->dev, addr, tp->data + tp->size, bytes);\n\n            if ((sz = tp->size + bytes) >= hdr && tp->size < hdr)\n\n                memmove(tp->header, tp->data, hdr);\n\n            tp->size = sz;\n\n            addr += bytes;\n\n            if (sz == msh) {\n\n                xmit_seg(s);\n\n                memmove(tp->data, tp->header, hdr);\n\n                tp->size = hdr;\n\n            }\n\n        } while (split_size -= bytes);\n\n    } else if (!tp->tse && tp->cptse) {\n\n        // context descriptor TSE is not set, while data descriptor TSE is set\n\n        DBGOUT(TXERR, \"TCP segmentaion Error\\n\");\n\n    } else {\n\n\n        pci_dma_read(&s->dev, addr, tp->data + tp->size, split_size);\n\n        tp->size += split_size;\n\n    }\n\n\n\n    if (!(txd_lower & E1000_TXD_CMD_EOP))\n\n        return;\n\n    if (!(tp->tse && tp->cptse && tp->size < hdr))\n\n        xmit_seg(s);\n\n    tp->tso_frames = 0;\n\n    tp->sum_needed = 0;\n\n    tp->vlan_needed = 0;\n\n    tp->size = 0;\n\n    tp->cptse = 0;\n\n}", "idx": 12984, "substitutes": {"bytes": ["blocks", "units", "os", "files", "items", "ps", "flags", "eps", "data", "seconds", "byte", "frames", "gs", "bits", "days", "ns", "bps", "hops", "outs", "ops", "ds", "fee", "seq", "ips", "ls"], "sz": ["Sce", "lsize", "sce", "Size", " scl", " sce", "lsz", " size", "scl", "Sz", "lsce", "Scl", "lscl", "size"], "op": ["oper", "oid", "proc", "OP", "root", "ob", "cop", "top", "up", "or", "sp", "operation", "orb", "option", "pp", "pop", "cmp", "ap", "init", "operator", "update", "loc", "error", "app", "google", "o", "set", "open", "opus", "oc", "p", "oop", "http", "iop", "comp", "omp", "mode", "opp", "dot", "wp", "ocr", "OPER", "ip", "route", "Op", "cat", "type", "gen", "cmd", "ep", "ops", "cp", "om", "ips", "hop", "dr", "pos", "num", "copy", "off", "prev", "post", "opt", "opy", "bit"], "addr": ["args", "transfer", "port", "map", "tx", "extra", "apper", "sp", "mx", "pack", "nc", "data", "ptr", "arp", "wp", "address", "ip", " ip", "parser", "route", "rt", "dp", "mac", "src", "opt", "ctx", "gp"], "xp": ["zip", "XP", "adj", "osi", "hp", "tx", "Pg", "esp", "qa", "xml", "python", "pkg", "xe", "jp", "lvl", "vp", "fm", "pg", "wx", "fx", "lp", "dj", "isp", "project", "txt", "xt", "fp", "rpm", "imp", "bp", "p", "pipe", "eps", "nc", "cli", "yp", "sf", "ix", "qt", "omp", "expr", "wp", "xs", "axe", "php", "dp", "org", "cp", "ppo", "cpp", "exec", "xc", "hw", "xy", "hop", "opy", "ppa", "dm", "ctx", "asm", "esm", "gp"], "tp": ["port", "vp", "prot", "gt", "lp", "sth", "cmp", "fp", "tm", "np", "arp", "bps", "end", "tf", "TP", "sv", "cp", "typ", "d", "t", "id", "ctr", "api", "g", "tg", "txt", "tap", "bp", "mt", "s", "pack", "byte", "ip", "dt", "vt", "transfer", "sys", "tk", "mp", "ta", "sp", "http", "tc", "qt", "dp", "prefix", "php", "gp", "hp", "pkg", "_", "tmp", "jp", "pt", "utils", "py", "plugin", "p", "pb", "cli", "wp", "tif", "parser", "ht", "ssl", "all"]}}
{"project": "qemu", "commit_id": "333d50fe3d9a1ff0a6a1a44ef42a0d3a2a7f2abe", "target": 0, "func": "static int scsi_disk_emulate_mode_sense(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    int page, dbd, buflen, page_control;\n\n    uint8_t *p;\n\n    uint8_t dev_specific_param;\n\n\n\n    dbd = req->cmd.buf[1]  & 0x8;\n\n    page = req->cmd.buf[2] & 0x3f;\n\n    page_control = (req->cmd.buf[2] & 0xc0) >> 6;\n\n    DPRINTF(\"Mode Sense(%d) (page %d, len %d, page_control %d)\\n\",\n\n        (req->cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, len, page_control);\n\n    memset(outbuf, 0, req->cmd.xfer);\n\n    p = outbuf;\n\n\n\n    if (bdrv_is_read_only(s->bs)) {\n\n        dev_specific_param = 0x80; /* Readonly.  */\n\n    } else {\n\n        dev_specific_param = 0x00;\n\n    }\n\n\n\n    if (req->cmd.buf[0] == MODE_SENSE) {\n\n        p[1] = 0; /* Default media type.  */\n\n        p[2] = dev_specific_param;\n\n        p[3] = 0; /* Block descriptor length.  */\n\n        p += 4;\n\n    } else { /* MODE_SENSE_10 */\n\n        p[2] = 0; /* Default media type.  */\n\n        p[3] = dev_specific_param;\n\n        p[6] = p[7] = 0; /* Block descriptor length.  */\n\n        p += 8;\n\n    }\n\n\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n\n    if ((~dbd) & nb_sectors) {\n\n        if (req->cmd.buf[0] == MODE_SENSE) {\n\n            outbuf[3] = 8; /* Block descriptor length  */\n\n        } else { /* MODE_SENSE_10 */\n\n            outbuf[7] = 8; /* Block descriptor length  */\n\n        }\n\n        nb_sectors /= s->cluster_size;\n\n        if (nb_sectors > 0xffffff)\n\n            nb_sectors = 0;\n\n        p[0] = 0; /* media density code */\n\n        p[1] = (nb_sectors >> 16) & 0xff;\n\n        p[2] = (nb_sectors >> 8) & 0xff;\n\n        p[3] = nb_sectors & 0xff;\n\n        p[4] = 0; /* reserved */\n\n        p[5] = 0; /* bytes 5-7 are the sector size in bytes */\n\n        p[6] = s->cluster_size * 2;\n\n        p[7] = 0;\n\n        p += 8;\n\n    }\n\n\n\n    if (page_control == 3) { /* Saved Values */\n\n        return -1; /* ILLEGAL_REQUEST */\n\n    }\n\n\n\n    switch (page) {\n\n    case 0x04:\n\n    case 0x05:\n\n    case 0x08:\n\n    case 0x2a:\n\n        p += mode_sense_page(req, page, p, page_control);\n\n        break;\n\n    case 0x3f:\n\n        p += mode_sense_page(req, 0x08, p, page_control);\n\n        p += mode_sense_page(req, 0x2a, p, page_control);\n\n        break;\n\n    default:\n\n        return -1; /* ILLEGAL_REQUEST */\n\n    }\n\n\n\n    buflen = p - outbuf;\n\n    /*\n\n     * The mode data length field specifies the length in bytes of the\n\n     * following data that is available to be transferred. The mode data\n\n     * length does not include itself.\n\n     */\n\n    if (req->cmd.buf[0] == MODE_SENSE) {\n\n        outbuf[0] = buflen - 1;\n\n    } else { /* MODE_SENSE_10 */\n\n        outbuf[0] = ((buflen - 2) >> 8) & 0xff;\n\n        outbuf[1] = (buflen - 2) & 0xff;\n\n    }\n\n    if (buflen > req->cmd.xfer)\n\n        buflen = req->cmd.xfer;\n\n    return buflen;\n\n}\n", "idx": 12326, "substitutes": {"req": ["sem", "proc", "rs", "def", "low", "str", "mr", "rec", "tar", "requ", "rw", "spec", "serv", "cb", "pro", "call", "ru", "dq", "ra", "sr", "fr", "client", "grad", "resource", "require", "data", "r", "exec", "cache", "comm", "res", "reg", "rf", "rr", "gr", "tr", "config", "wx", "ref", "rh", "conn", "ir", "desc", "rx", "http", "comp", "qt", "j", "f", "query", "ro", "wa", "rob", "re", "rt", "cur", "ctx", "err", "input", "jp", "required", "row", "sq", "conf", "request", "crit", "q", "cmd", "org", "resp", "qq", "src", "seq"], "outbuf": ["bootbuff", "OUTbuf", "outbuffer", "outcb", "Outcb", "newbuff", "blockbuff", " outbuffer", "upbuff", "blockbuf", " outbuff", "OUTbuff", "infb", "Outbuff", " outuf", "newuf", "Outuf", "OUTbuffer", "OUTuf", "OUTcb", "incb", "inbuffer", "outfp", "inbuff", "Outbuf", "infp", "Outbuffer", "outbuff", "bootbuf", "newbuffer", "newbuf", "bootfp", "upfb", "bootfb", "blockuf", "upfp", "blockbuffer", "outfb", "upbuf", "inuf", "outuf", "inbuf"], "s": ["qs", "js", "si", "ps", "requ", "spec", "c", "serv", "st", "m", "self", "d", "t", "sync", "sg", "sym", "g", "cs", "session", "w", "b", "ns", "r", "sa", "sis", "ks", "sys", "service", "sp", "os", "o", "z", "e", "http", "j", "f", "services", "ls", "ses", "_", "l", "S", "sq", "v", "n", "gs", "ssl", "q", "ds", "su", "y"], "nb_sectors": ["nb_geeters", "nb_gector", "nb_enseats", "nb_tectors", "nb_vector", "nb_exctions", "nb_secs", "nb_secctors", "nb_veapters", "nb_seats", "nb_teors", "nb_exxes", "nb_vecs", "nb_seors", "nb_tegments", "nb_ensectors", "nb_serets", "nb_secors", "nb_pecs", "nb_peivers", "nb_pections", "nb_vegments", "nb_tragments", "nb_pectors", "nb_schegments", "nb_selos", "nb_sixctors", "nb_cecs", "nb_spectors", "nb_secgments", "nb_seapters", "nb_tractors", "nb_ensegments", "nb_pegments", "nb_seccs", "nb_cegments", "nb_gexes", "nb_seivers", "nb_secrets", "nb_verets", "nb_peats", "nb_vectors", "nb_exctors", "nb_vections", "nb_ceors", "nb_sections", "nb_vexes", "nb_seitors", "nb_legments", "nb_schelos", "nb_segments", "nb_traitors", "nb_schectors", "nb_leivers", "nb_ensecs", "nb_sector", "nb_gectors", "nb_lections", "nb_secctions", "nb_spegments", "nb_geapters", "nb_geitors", "nb_gecs", "nb_lectors", "nb_cectors", "nb_exgments", "nb_scheeters", "nb_ceats", "nb_gerets", "nb_seeters", "nb_gections", "nb_traors", "nb_sixlos", "nb_geors", "nb_gelos", "nb_geivers", "nb_spector", "nb_sixeters", "nb_gegments", "nb_sexes", "nb_tections", "nb_sixgments", "nb_secapters", "nb_ceitors", "nb_spections"], "page": ["en", "id", "pixel", "pages", "name", "row", "pg", "sp", "pp", "aa", "loc", "server", "pid", "limit", "col", "size", "rec", "pl", "min", "data", "length", "n", "Page", " Page", "result", "line", "f", "count", "ip", "number", "url", "next", "block", "c", "per", "type", "offset", "pri", "cache", "age", "pos", "order", "len", "net", "start"], "dbd": ["bdd", "devcd", "dbcd", "debn", "dbdc", " dbdn", "devd", "dbf", " dbn", "bmd", "dbdl", " dbcd", "ddds", "dbdn", "bdf", "dbid", "dbn", "bmdl", "dddc", "devdl", " dbds", "debdc", " dbdl", " dbid", "ddd", " dbdc", "bddc", "bddn", "devid", "ddf", " dbf", "bdds", "bmcd", "dbds", "debdn", "bmid", "bdn", "debd"], "buflen": ["buvelens", "bufline", "buselen", "auvelens", "buveline", "bugllen", "busellen", "bugline", "aufline", "auflen", "buflens", "auvelen", "buseline", "buglen", "auflens", "buselens", "bufllen", "auveline", "auvellen", "aufllen", "buvelen", "buvellen", "buglens"], "page_control": ["page_limit", " page_length", " page_lock", "page_con", "page__limit", "pagelexcontrol", "page_lock", "page_adjust", "page__control", " page_con", "page_length", " page_adjust", "page_controlled", "page__ctrl", "page_ctrl", " page_limit", " page_controlled", " page_ctrl", "pagelexlock", "pagelexadjust", "page__length"], "p": ["port", "it", "m", "hp", "part", "po", "d", "t", "after", "array", "jp", "l", "i", "pc", "up", "a", "pre", "api", "g", "sp", "h", "lp", "py", "x", "pp", "post", "ap", "fp", "v", "patch", "ps", "br", "o", "np", "w", "u", "params", "z", "e", "y", "pa", "b", "data", "k", "j", "op", "n", "f", "point", "wp", "at", "result", "pair", "c", "pin", "pe", "per", "pi", "q", "r", "cp", "param", "cache", "pos", "prev", "P", "tp"], "dev_specific_param": ["dev_specific_item", "dev_specificacnum", "dev_specific_ref", "dev_specific_part", "dev_special_par", "dev_special_channel", "dev_special_part", "dev_general_params", "dev_general_item", "dev_specific_channel", "dev_specificacpar", "dev_specific_params", "dev_specificaccm", "dev_specific_num", "dev_special_num", "dev_specificacparam", "dev_special_ref", "dev_general_num", "dev_special_cm", "dev_special_params", "dev_special_param", "dev_specific_par", "dev_general_param", "dev_specific_cm"]}}
{"project": "FFmpeg", "commit_id": "5a412a5c3cc216ae1d15e6b884bda7214b73a5b0", "target": 1, "func": "static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,\n\n                                   uint8_t **data, int *size)\n\n{\n\n    static const int extradata_nal_types_hevc[] = {\n\n        HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,\n\n    };\n\n    static const int extradata_nal_types_h264[] = {\n\n        H264_NAL_SPS, H264_NAL_PPS,\n\n    };\n\n\n\n    ExtractExtradataContext *s = ctx->priv_data;\n\n\n\n    H2645Packet h2645_pkt = { 0 };\n\n    int extradata_size = 0;\n\n    const int *extradata_nal_types;\n\n    int nb_extradata_nal_types;\n\n    int i, has_sps = 0, has_vps = 0, ret = 0;\n\n\n\n    if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n\n        extradata_nal_types    = extradata_nal_types_hevc;\n\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);\n\n    } else {\n\n        extradata_nal_types    = extradata_nal_types_h264;\n\n        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);\n\n    }\n\n\n\n    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,\n\n                                ctx, 0, 0, ctx->par_in->codec_id, 1);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < h2645_pkt.nb_nals; i++) {\n\n        H2645NAL *nal = &h2645_pkt.nals[i];\n\n        if (val_in_array(extradata_nal_types, nb_extradata_nal_types, nal->type)) {\n\n            extradata_size += nal->raw_size + 3;\n\n            if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {\n\n                if (nal->type == HEVC_NAL_SPS) has_sps = 1;\n\n                if (nal->type == HEVC_NAL_VPS) has_vps = 1;\n\n            } else {\n\n                if (nal->type == H264_NAL_SPS) has_sps = 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (extradata_size &&\n\n        ((ctx->par_in->codec_id == AV_CODEC_ID_HEVC && has_sps && has_vps) ||\n\n         (ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {\n\n        AVBufferRef *filtered_buf;\n\n        uint8_t *extradata, *filtered_data;\n\n\n\n        if (s->remove) {\n\n            filtered_buf = av_buffer_alloc(pkt->size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!filtered_buf) {\n\n                ret = AVERROR(ENOMEM);\n\n                goto fail;\n\n            }\n\n            filtered_data = filtered_buf->data;\n\n        }\n\n\n\n        extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!extradata) {\n\n            av_buffer_unref(&filtered_buf);\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n\n\n        *data = extradata;\n\n        *size = extradata_size;\n\n\n\n        for (i = 0; i < h2645_pkt.nb_nals; i++) {\n\n            H2645NAL *nal = &h2645_pkt.nals[i];\n\n            if (val_in_array(extradata_nal_types, nb_extradata_nal_types,\n\n                             nal->type)) {\n\n                AV_WB24(extradata, 1); // startcode\n\n                memcpy(extradata + 3, nal->raw_data, nal->raw_size);\n\n                extradata += 3 + nal->raw_size;\n\n            } else if (s->remove) {\n\n                AV_WB24(filtered_data, 1); // startcode\n\n                memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);\n\n                filtered_data += 3 + nal->raw_size;\n\n            }\n\n        }\n\n\n\n        if (s->remove) {\n\n            av_buffer_unref(&pkt->buf);\n\n            pkt->buf  = filtered_buf;\n\n            pkt->data = filtered_buf->data;\n\n            pkt->size = filtered_data - filtered_buf->data;\n\n        }\n\n    }\n\n\n\nfail:\n\n    ff_h2645_packet_uninit(&h2645_pkt);\n\n    return ret;\n\n}\n", "idx": 25179, "substitutes": {"ctx": ["exec", "txt", "tk", "sc", "cm", "kw", "np", "cca", "p", " context", "anc", "c", "pkg", "context", "cv", "qa", "qt", "sq", "config", "conf", "jp", "cb", "ct", "bc", "concept", "sync", "kb", "cmp", "fc", "cmd", "cms", "grad", "vc", "wcs", "Context", "cc", "cp", "ci", "cf", "client", "rc", "sci", "conv", "req", "cas", "git", "lc", "ctrl", "ca", "qs", "tc", "cu", "conn", "fp", "q", "ck", "tx", "cs", "cam", "pc", "kt"], "pkt": ["het", "pct", "Pelt", " packet", "pkg", "cpacket", "pke", "psth", "helt", "Psth", " pelt", "hkg", "packet", " pet", " pct", "hacket", "Pkg", "Packet", "pelt", "hke", "Pke", "pet", " pke", "cpkt", "cpct", " pkg", " psth", "Pkt", "hkt", "Pct", "Pet", "cpsth"], "data": ["load", "Data", "body", "args", "slice", "bin", "p", "batch", "name", "d", "buffer", "media", "read", "config", "next", "address", "type", "reader", "id", "message", "input", "dat", "start", "sample", "accept", "binary", "parent", "response", "cache", "missing", "device", "zip", "ata", "window", "bytes", "value", "DATA", "content", "memory", "draw", "result", "connection"], "size": ["code", "body", "args", "slice", "ize", "c", "empty", "sized", "name", "storage", "send", "sum", "capacity", "address", "type", "version", "Size", "depth", "SIZE", "cap", "small", "offset", "mode", "sec", "scale", "shape", "channel", "length", "bytes", "n", "len"], "extradata_nal_types_hevc": ["extradata_nal_types_kell", "extradata_nal_types_sheVC", "extradata_nal_types_shevc", "extradata_nal_types_peVC", "extradata_nal_types_shexc", "extradata_nal_types_shec", "extradata_nal_types_pell", "extradata_nal_types_kec", "extradata_nal_types_keVC", "extradata_nal_types_pexc", "extradata_nal_types_hec", "extradata_nal_types_hxc", "extradata_nal_types_pec", "extradata_nal_types_hell", "extradata_nal_types_hVC", "extradata_nal_types_hexc", "extradata_nal_types_hll", "extradata_nal_types_hc", "extradata_nal_types_pevc", "extradata_nal_types_hvc", "extradata_nal_types_heVC", "extradata_nal_types_kevc"], "extradata_nal_types_h264": ["extradata_nal_types_v24", "extradata_nal_types_H24", "extradata_nal_types_phavi", "extradata_nal_types_havi", "extradata_nal_types_ph24", "extradata_nal_types_he128", "extradata_nal_types_H64", "extradata_nal_types_ph64", "extradata_nal_types_H264", "extradata_nal_types_H265", "extradata_nal_types_ph128", "extradata_nal_types_he264", "extradata_nal_types_he24", "extradata_nal_types_h64", "extradata_nal_types_v264", "extradata_nal_types_ph264", "extradata_nal_types_he64", "extradata_nal_types_v64", "extradata_nal_types_h24", "extradata_nal_types_v128", "extradata_nal_types_p24", "extradata_nal_types_ph265", "extradata_nal_types_h128", "extradata_nal_types_v265", "extradata_nal_types_Havi", "extradata_nal_types_p264", "extradata_nal_types_pavi", "extradata_nal_types_p64", "extradata_nal_types_h265"], "s": ["sc", "ses", "w", "ss", "p", "parser", "c", "ns", "d", "sq", "sac", "sg", "e", "gs", "session", "spec", "sec", "sa", "h", "f", "qs", "n", "a", "t", "csv", "ssl", "cs", "g"], "extradata_nal_types": ["extradata_nals_type", "extradata_nal_properties", "extradata_nals_types", "extradata_nal_styles", "extradata_nal_resources", "extradata_nal_times", "extradata_nals_properties", "extradata_nals_ypes", "extradata_nal_ypes", "extradata_nal_pes", "extradata_nal_type", "extradata_nals_names", "extradata_naled_type", "extradata_naled_times", "extradata_nals_styles", "extradata_naled_types", "extradata_naled_pes", "extradata_nal_names", "extradata_nals_resources"], "nb_extradata_nal_types": ["nb_extradata_naler_ids", "nb_extradata_naled_types", "nb_extradata_nal_type", "nb_extradata_nals_types", "nb_extradata_naler_resources", "nb_extradata_naler_type", "nb_extradata_naled_plugins", "nb_extradata_nal_resources", "nb_extradata_nals_type", "nb_extradata_naled_ids", "nb_extradata_naler_types", "nb_extradata_naled_type", "nb_extradata_nals_names", "nb_extradata_nal_names", "nb_extradata_nal_ids", "nb_extradata_nals_ids", "nb_extradata_nal_plugins"], "i": ["gu", "jit", "k", "ie", "p", "b", "m", "yi", "c", "d", "ix", "x", "adi", "ti", "mi", "type", "phi", "qi", "it", "ri", "id", "num", "ani", "io", "ki", "u", "e", "key", "li", "gi", "zi", "multi", "start", "xi", "uri", "ii", "di", "ini", "ai", "si", "bi", "result", "ret", "ik", "fi", "eni", "im", "I", "f", "count", "mini", "n", "j", "ip", "index", "a", "chi", "y", "oi", "iu", "v", "ind", "pi", "in", "ui", "hi", "len"], "nal": ["namal", "neal", "ynale", "nanals", "nanal", "ynals", "nonals", " nals", "nalis", "naal", "rnmal", "nonal", " neal", "ynal", "nonale", "rnalis", "nanale", " nale", "naale", "neale", "naneal", "ynAL", "pnal", "nale", " nAL", "nealis", "rnale", "nmal", "pnals", "naalis", "nemal", "rnal", "nAL", "pnale", "pnAL", "noneal", "nals"]}}
{"project": "FFmpeg", "commit_id": "a55692a96099c40aabb25e1443890be99f9c845c", "target": 1, "func": "static int read_interval_packets(WriterContext *w, AVFormatContext *fmt_ctx,\n\n                                 const ReadInterval *interval, int64_t *cur_ts)\n\n{\n\n    AVPacket pkt, pkt1;\n\n    AVFrame *frame = NULL;\n\n    int ret = 0, i = 0, frame_count = 0;\n\n    int64_t start = -INT64_MAX, end = interval->end;\n\n    int has_start = 0, has_end = interval->has_end && !interval->end_is_offset;\n\n\n\n    av_init_packet(&pkt);\n\n\n\n    av_log(NULL, AV_LOG_VERBOSE, \"Processing read interval \");\n\n    log_read_interval(interval, NULL, AV_LOG_VERBOSE);\n\n\n\n    if (interval->has_start) {\n\n        int64_t target;\n\n        if (interval->start_is_offset) {\n\n            if (*cur_ts == AV_NOPTS_VALUE) {\n\n                av_log(NULL, AV_LOG_ERROR,\n\n                       \"Could not seek to relative position since current \"\n\n                       \"timestamp is not defined\\n\");\n\n                ret = AVERROR(EINVAL);\n\n\n\n            target = *cur_ts + interval->start;\n\n        } else {\n\n            target = interval->start;\n\n\n\n\n        av_log(NULL, AV_LOG_VERBOSE, \"Seeking to read interval start point %s\\n\",\n\n               av_ts2timestr(target, &AV_TIME_BASE_Q));\n\n        if ((ret = avformat_seek_file(fmt_ctx, -1, -INT64_MAX, target, INT64_MAX, 0)) < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Could not seek to position %\"PRId64\": %s\\n\",\n\n                   interval->start, av_err2str(ret));\n\n\n\n\n\n\n    frame = av_frame_alloc();\n\n\n\n\n\n    while (!av_read_frame(fmt_ctx, &pkt)) {\n\n        if (selected_streams[pkt.stream_index]) {\n\n            AVRational tb = fmt_ctx->streams[pkt.stream_index]->time_base;\n\n\n\n            if (pkt.pts != AV_NOPTS_VALUE)\n\n                *cur_ts = av_rescale_q(pkt.pts, tb, AV_TIME_BASE_Q);\n\n\n\n            if (!has_start && *cur_ts != AV_NOPTS_VALUE) {\n\n                start = *cur_ts;\n\n                has_start = 1;\n\n\n\n\n            if (has_start && !has_end && interval->end_is_offset) {\n\n                end = start + interval->end;\n\n                has_end = 1;\n\n\n\n\n            if (interval->end_is_offset && interval->duration_frames) {\n\n                if (frame_count >= interval->end)\n\n                    break;\n\n            } else if (has_end && *cur_ts != AV_NOPTS_VALUE && *cur_ts >= end) {\n\n                break;\n\n\n\n\n            frame_count++;\n\n            if (do_read_packets) {\n\n                if (do_show_packets)\n\n                    show_packet(w, fmt_ctx, &pkt, i++);\n\n                nb_streams_packets[pkt.stream_index]++;\n\n\n            if (do_read_frames) {\n\n                pkt1 = pkt;\n\n                while (pkt1.size && process_frame(w, fmt_ctx, frame, &pkt1) > 0);\n\n\n\n        av_free_packet(&pkt);\n\n\n    av_init_packet(&pkt);\n\n    pkt.data = NULL;\n\n    pkt.size = 0;\n\n    //Flush remaining frames that are cached in the decoder\n\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n\n        pkt.stream_index = i;\n\n        if (do_read_frames)\n\n            while (process_frame(w, fmt_ctx, frame, &pkt) > 0);\n\n\n\n\nend:\n\n    av_frame_free(&frame);\n\n    if (ret < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Could not read packets in interval \");\n\n        log_read_interval(interval, NULL, AV_LOG_ERROR);\n\n\n    return ret;\n", "idx": 21012, "substitutes": {"w": ["writer", "cam", "wcs", "ow", "g", "wa", "wr", "temp", "r", "m", "we", "aw", "rw", "iw", "wb", "W", "wp", "window", "sw", "RW", "fw", "wav", "wx", "tw", "hw", "kw", "wrap"], "fmt_ctx": ["fmt_reader", "frt_cmp", "fmt_coll", "fmt_cu", "fmtfloc", "fmt_sci", "fmt_context", "fmt2sci", "fmt2context", "fmtfrx", "frt_coll", "frt_reader", "fMT_context", "fmt_loc", "fmt_rx", "fMT_rx", "fmt_cmp", "frt_sci", "frt_cu", "fmtfctx", "fMT_loc", "fmtfcontext", "fmt2ctx", "fmt2cmp", "frt_ctx", "fMT_ctx", "frt_context"], "interval": ["extcal", "nerver", "interscel", "INTERsection", "sural", "intervol", "irval", "inseval", "extval", "intersval", "warval", "interchange", "extVAL", "infvol", "interref", "INTERref", " interruction", "interpoint", "intersvals", "warpol", "intercel", "intcel", "extpoint", "perref", "overval", "curval", "Intervals", "nerval", "interrupt", "iterchange", "inseVAL", "iterpol", " intervals", "iterval", " interpre", "INTERv", "iterver", "interpol", " interal", "surval", "INTERpol", "INTERver", "intcol", "perpre", "interv", "iterpoint", "infpol", "overpol", "INTERcal", "intervert", "curchange", "interVAL", " interver", "pervert", "irvals", " interv", "Interval", "iterrupt", "intervals", "extvert", " intercol", "extsection", "insever", "interrule", " interrule", "curpoint", "intvals", "iterpre", "warruction", "insepre", "insesection", "perv", "Intercel", "INTERval", "waral", "nerpol", "surruction", "itervol", "ircel", "INTERVAL", "extpol", "insecal", "intersrule", "iterVAL", "INTERpre", "nerVAL", "perVAL", "extchange", "intercol", "intval", "intersection", "ircol", " intercel", "infver", "interver", "oververt", " interpol", "infval", "interal", "extrupt", "surpol", "perval", "Interrule", "interpre", " interref", "currupt", " intervol", "perpol", "intercal", "overVAL", "interruction"], "cur_ts": [" cur_qs", " cur_ds", "curGats", "curGqs", "cur8times", " cur_TS", "Cur_ts", "cur2times", " cur_ats", "curLvalues", "cur2ts", "cur_uts", "cur_steps", "cur8TS", "cur2steps", " cur_times", " cur_values", "cur_ats", "rc\n", "cur_TS", "Cur\n", " cur\n", "cur_ds", "curLts", "Cur_TS", " cur_uts", "curGts", "cur8ts", "cur_times", "cur_qs", "cur2TS", "Cur_steps", "cur_values", "cur8uts", "Cur_times", "curLtimes", "curLds", "curGtimes", "cur\n"], "pkt": ["Packet", "cpet", " pct", "Pct", "pmt", "Pwk", "backet", "cpacket", "cpsth", "pet", "cpkt", "Pet", "pett", "fct", "promacket", "promkt", "cwk", " pett", " pwk", "pelt", "promct", "Psth", "fqt", "Pqt", "cpct", "opmt", "Pett", "bkt", "fet", " pelt", "bct", "celt", "Pmt", " pqt", "promett", " pet", "Pkt", "packet", "opct", "fkt", "pwk", " packet", "opacket", "psth", "pqt", "opkt", "bsth", "cpmt", "facket", "pct", "Pelt", "ckt", "cacket"], "pkt1": ["packet2", "pct2", " pqt1", "packet1", "pqt2", " pkt2", "pkt2", "pct1", " pqt2", "pqt1"], "frame": ["view", "e", "object", "event", "thread", "result", "part", "val", "feature", "parse", "f", "buffer", "fat", "sequence", "data", "state", "lock", "p", "ret", "point", "ace", "dr", "live", "fr", "window", "seq", "session", "call", "slice", "flow", "trace", "Frame", "range", "boot", "fram", "parent", "image", "block", "fi", "feat"], "target": ["feat", "port", "net", "Target", "arget", "start", "limit", "next", "conn", "gt", "end", "pattern", "valid", "object", "result", " offset", " ret", "project", "arg", "blank", "transform", "token", "weight", "buffer", "path", "master", "address", "cat", "data", "rel", "ret", "ip", "current", " Target", "point", "timeout", "client", "ctx", "tag", "goal", "source", "match", "ARGET", "ault", "window", "date", "core", "qa", "session", "top", " next", "test", "iter", "base", "global", "root", "range", "alt", "parent", "nt", "reset", "dest", "expected", "pointer", "gap", "offset", " result", "output", "format", "value"], "frame_count": ["frame___weight", "frame_id", "frame2id", "frame_counter", "frame___counter", "frame2counter", "frame2count", "block_weight", "block_counter", "block_count", "block_id", "frame2weight", "frame___count", "block___counter", "block___count", "block___weight", "block___id", "frame___id", "frame_weight"], "i": ["io", "ind", "ti", "I", "f", "ci", "t", "info", "it", "j", "ip", "p", "at", "id", "mi", "timeout", "c", "index", "num", "si", "ii", "slice", "ai", "len", "multi", "fi", "ni"], "stream_index": ["wave_position", "stream_config", "stream_number", " streamingconfig", "streamityupdate", "streamingconfig", "wavealposition", "streamityconfig", "wave_index", "streamityposition", "streamalindex", "streamingindex", " stream_int", "streamishposition", "streamalposition", "wavealindex", "stream_int", "wavealupdate", "stream_condition", "streamitycondition", "streamingnumber", "streamalcondition", " stream_number", "streamitynumber", " streamingnumber", "streamishindex", "stream_position", " stream_config", "wave_update", " streamingint", "wavealcondition", " streamingindex", "wave_condition", "streamityindex", "streamalupdate", "stream_update", "streamishupdate", "streamingint", "streamityint", "streamishcondition"]}}
{"project": "FFmpeg", "commit_id": "66f0c958bfd5475658b432d1af4d2e174b2dfcda", "target": 1, "func": "static int pxr24_uncompress(EXRContext *s, const uint8_t *src,\n\n                            int compressed_size, int uncompressed_size,\n\n                            EXRThreadData *td)\n\n{\n\n    unsigned long dest_len, expected_len = 0;\n\n    const uint8_t *in = td->tmp;\n\n    uint8_t *out;\n\n    int c, i, j;\n\n\n\n    for (i = 0; i < s->nb_channels; i++) {\n\n        if (s->channels[i].pixel_type == EXR_FLOAT) {\n\n            expected_len += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */\n\n        } else if (s->channels[i].pixel_type == EXR_HALF) {\n\n            expected_len += (td->xsize * td->ysize * 2);\n\n        } else {//UINT 32\n\n            expected_len += (td->xsize * td->ysize * 4);\n\n        }\n\n    }\n\n\n\n    dest_len = expected_len;\n\n\n\n    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {\n\n        return AVERROR_INVALIDDATA;\n\n    } else if (dest_len != expected_len) {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    out = td->uncompressed_data;\n\n    for (i = 0; i < td->ysize; i++)\n\n        for (c = 0; c < s->nb_channels; c++) {\n\n            EXRChannel *channel = &s->channels[c];\n\n            const uint8_t *ptr[4];\n\n            uint32_t pixel = 0;\n\n\n\n            switch (channel->pixel_type) {\n\n            case EXR_FLOAT:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + td->xsize;\n\n                ptr[2] = ptr[1] + td->xsize;\n\n                in     = ptr[2] + td->xsize;\n\n\n\n                for (j = 0; j < td->xsize; ++j) {\n\n                    uint32_t diff = (*(ptr[0]++) << 24) |\n\n                                    (*(ptr[1]++) << 16) |\n\n                                    (*(ptr[2]++) << 8);\n\n                    pixel += diff;\n\n                    bytestream_put_le32(&out, pixel);\n\n                }\n\n                break;\n\n            case EXR_HALF:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + td->xsize;\n\n                in     = ptr[1] + td->xsize;\n\n                for (j = 0; j < td->xsize; j++) {\n\n                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);\n\n\n\n                    pixel += diff;\n\n                    bytestream_put_le16(&out, pixel);\n\n                }\n\n                break;\n\n            case EXR_UINT:\n\n                ptr[0] = in;\n\n                ptr[1] = ptr[0] + s->xdelta;\n\n                ptr[2] = ptr[1] + s->xdelta;\n\n                ptr[3] = ptr[2] + s->xdelta;\n\n                in     = ptr[3] + s->xdelta;\n\n\n\n                for (j = 0; j < s->xdelta; ++j) {\n\n                    uint32_t diff = (*(ptr[0]++) << 24) |\n\n                    (*(ptr[1]++) << 16) |\n\n                    (*(ptr[2]++) << 8 ) |\n\n                    (*(ptr[3]++));\n\n                    pixel += diff;\n\n                    bytestream_put_le32(&out, pixel);\n\n                }\n\n                break;\n\n            default:\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n\n\n    return 0;\n\n}\n", "idx": 22009, "substitutes": {"s": ["sv", "sb", "hm", "e", "sym", "space", "sk", "support", "sl", "fs", "g", "ses", "this", "su", "rates", "d", "ks", "ds", "services", "f", "sys", "t", "u", "m", "ssl", "ts", "p", "cs", "ls", "sync", "sa", "sg", "js", "self", "sd", "sm", "sq", "sh", "si", "sc", "spec", "sts", "b", "service", "parts", "session", "S", "ns", "sf", "side", "ps", "south", "gs", "bs", "l", "ss", "settings"], "src": ["sb", "fc", "sel", "config", "sl", "input", "rin", "img", "scl", "secure", "gb", "ssl", "setup", "rc", "filename", "ctx", "cb", "source", "ipl", "sc", "sr", "rl", "sub", "tmp", "inst", "slice", "loc", "rs", "proc", "st", "dest", "rb", "stream", "attr", "url"], "compressed_size": ["compressed67area", "comppped_size", "compressed64sum", "compressed_sum", "compressed2size", "compressed64scale", "compressed2len", "compached_sum", "comppped_offset", "comppped_data", "compressed_data", "compached_size", "compressed67data", "compressed_len", "compressed_area", "compressed_scale", "compressed64len", "compressed2sum", "compressed67offset", "compressed67size", "compressed_offset", "compressed2scale", "comppped_area", "compached_len", "compached_scale", "compressed64size"], "uncompressed_size": ["uncompressedrize", "uncompressed_width", "uncompressed64size", "uncompured64width", "uncompressedrwidth", "uncompressed64ize", "uncompured_source", "uncompressed_ize", "uncompured_ize", "uncompressedrsize", "uncompured64size", "uncompured64source", "uncompressedrsource", "uncompressed64source", "uncompured_size", "uncompressed_source", "uncompressed64width", "uncompured_width", "uncompured64ize"], "td": ["md", "pb", "sb", "txt", "cd", "table", "rd", "uc", "conn", "ind", "amp", "edd", "std", "prot", "lv", "butt", "input", "kt", "db", "det", "wd", "dal", "d", "xd", "vd", "pd", "ti", "dh", "ld", "ds", "pc", "layer", "dn", "ud", "t", "cmd", "standard", "dd", "nd", "tp", "hd", "tif", "data", "ts", "ssl", "tc", "elt", "od", "thin", "header", "sd", "tf", "dt", "ta", "dc", "tmp", "dl", "fd", "tn", "bd", "dll", "cz", "tm", "dat", "nt", "lf", "cod", "li", "pt", "att", "TD", "ht", "gb", "ctl"], "dest_len": ["dest_l", "dest9ler", "expected_l", "expected64Len", "expected64lon", "gest___ler", "dest64len", " dest_val", "dest2limit", "dest___len", "dest___lin", "rest_limit", "dest_size", "dest9val", "dest___ler", "expected_Len", "dest__count", "dest_lon", "gest_ler", "gest___len", " dest_count", "dest_length", "dest_lock", "dest2lock", "dest2length", "dest2len", "expected64l", "gest___lin", "rest_length", "dest_ler", " dest_size", "dest__len", "dest64l", "expected64len", "dest_limit", "dest64lon", "gest_val", "dest9lin", "gest___val", "rest_lock", "dest9len", "gest_lin", "expected_len", "dest64Len", "dest_val", "dest_count", "dest_lin", "expected_lon", "rest_len", "dest__size", "gest_len", "dest_Len", "dest__val", "dest___val"], "in": ["conn", "err", "config", "ind", "input", "inc", "val", "part", "connection", "impl", "rin", "d", "bin", "gin", "rec", "pc", "img", "din", "ci", "win", "again", "r", "address", "m", "socket", "data", "ssl", "p", "id", "inner", "rc", "index", "pin", "ctx", "source", "inn", "In", "ii", "dc", "pull", "into", "IN", "min", "inst", "ins", "proc", "inside", "resource", "image", "att", "inch", "isin"], "out": ["io", "name", "outs", "password", "conn", "err", "config", "result", "part", "copy", "bin", "gin", "token", "temp", "process", "img", "device", "buffer", "exec", "again", "other", "cmd", "bit", "m", "data", "opt", "new", "p", "at", "version", "sync", "ext", "client", "OUT", "source", "window", "error", "call", "Out", "parent", "proc", "v", "dest", "image", "att", "server", "output", "attr", "sum"], "c": ["lc", "col", "e", "uc", "g", "d", "con", "pc", "f", "ci", "y", "t", "nc", "r", "u", "ac", "cp", "cache", "m", "p", "cs", "enc", "rc", "cn", " rc", "sc", "ch", "b", "cy", "n", "vc", "call", "C", "co", "z", "v", "ce", "h", "l", "x", "cu", "k", "count"], "i": ["io", "lc", "ami", "e", "ix", "start", "ie", "fi", "qi", "ri", "iii", "ui", "eni", "mini", "pi", "ki", "gi", "d", "uri", "my", "chi", "ti", "I", "f", "ci", "y", "u", "oi", "ini", "m", "phi", "info", "it", "init", "p", "ip", "id", "o", "bi", "q", "is", "mi", "inner", "index", "si", "ii", "b", "n", "iu", "ai", "xi", "di", "v", "multi", "yi", "li", "h", "im", "l", "x", "k", "ni"], "j": ["je", "ja", "oj", "e", "jl", "obj", "jp", "ind", "g", "key", "d", "f", "pos", "y", "t", "u", "other", "m", "p", "o", "q", "js", "aj", "el", "num", "J", "ch", "b", "ii", "ji", "ij", "fl", "n", "jc", "v", "z", "li", "h", "jo", "l", "x", "ne", "k"], "channel": ["member", "camera", "row", "attribute", "conn", "config", "character", "container", "chan", "cv", "connection", "cm", "queue", "player", "handler", "plugin", "pc", "type", "layer", "pixel", "can", "socket", "Channel", "component", "slot", "cup", "client", "ch", "sc", "window", "service", "wan", "core", "call", "chron", "chip", "page", "parent", "group", "server", "course"], "ptr": ["str", "port", "grad", "start", "err", "ref", "prot", "pe", "ctr", "tr", "wr", "pad", "pc", "img", "rect", "fp", "buffer", "pos", "pointers", "address", "cp", "data", "tp", "pp", "patch", "p", "uv", "arr", "point", "code", "addr", "elt", "np", "ext", "dr", "ctx", "pr", "pl", "fr", "ch", "rt", "pull", "tmp", "desc", "inst", "fd", "loc", "slice", "iter", "Ptr", "stage", "st", "proc", "buff", "dat", "pointer", "nt", "pair", "dest", "pty", "pt", "att", "offset", "sp", "attr", "inter", "ft"]}}
{"project": "FFmpeg", "commit_id": "221b804f3491638ecf2eec1302c669ad2d9ec799", "target": 1, "func": "static inline void yuv2packedXinC(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\n\n\t\t\t\t    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\n\n\t\t\t\t    uint8_t *dest, int dstW, int y)\n\n{\n\n\tint i;\n\n\tswitch(c->dstFormat)\n\n\t{\n\n\tcase PIX_FMT_BGR32:\n\n\tcase PIX_FMT_RGB32:\n\n\t\tYSCALE_YUV_2_RGBX_C(uint32_t)\n\n\t\t\t((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1];\n\n\t\t\t((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2];\n\n\t\t}\n\n\t\tbreak;\n\n\tcase PIX_FMT_RGB24:\n\n\t\tYSCALE_YUV_2_RGBX_C(uint8_t)\n\n\t\t\t((uint8_t*)dest)[0]= r[Y1];\n\n\t\t\t((uint8_t*)dest)[1]= g[Y1];\n\n\t\t\t((uint8_t*)dest)[2]= b[Y1];\n\n\t\t\t((uint8_t*)dest)[3]= r[Y2];\n\n\t\t\t((uint8_t*)dest)[4]= g[Y2];\n\n\t\t\t((uint8_t*)dest)[5]= b[Y2];\n\n\t\t\tdest+=6;\n\n\t\t}\n", "idx": 12809, "substitutes": {"c": ["m", "ch", "mc", "cm", "uc", "cam", "d", "cv", "enc", "ca", "t", "cc", "pc", "l", "C", "lc", "ci", "cs", "cit", "cy", "con", "ct", "cr", "cd", "u", "p", "e", "k", "tc", "b", "dc", "cu", "ac", "ce", "cf", "icc", "cp", "vc", "ec", "cpp"], "lumFilter": [" lrumFilter", " lrumfilter", "lumbListener", " lrumF", "lrumListener", "lumbfilter", "lumiListener", "lrumFilter", "lumbFilter", " lumfilter", "lumiF", "lumF", " lrumListener", " lumF", "lumListener", "lrumF", "lrumfilter", "lumfilter", " lumListener", "lumbF", "lumiFilter", "lumifilter"], "lumSrc": ["lumbAsrc", "lumOsource", "lumbAsuc", "lumAsrc", "lumAsRC", "lumOsRC", "lumOsuc", "lumbAsRC", "lumbSRC", "lumSRC", "lumbAsource", "lumAsource", "lumSource", "lumSuc", "lumbSrc", "lumbSuc", "lumAsuc", "lumbSource", "lumOsrc"], "lumFilterSize": ["lumFiltersize", "lumBufferC", "lumsFilterC", "lumFilterC", "lumBuffersize", "lumFsize", "lumBufferSize", "lumFC", "lumsFiltersize", "lumFSize", "lumsFilterSize"], "chrFilter": ["chmfilter", "chrumFormat", "chrfilter", "echrFil", "echrbfilter", "chmFormat", "chrbFormat", "chrbfilter", "chrbFilter", "echrFilter", "chmFilter", "echrbFil", "echrbFormat", "chrumFil", "chrFil", "chmFil", "chrumfilter", "chrumFilter", "chrbFil", "echrfilter", "echrbFilter", "echrFormat", "chrFormat"], "chrSrc": ["chrAsrc", "chrSubrc", "chrfSource", "chrfSRC", "chrSubource", "chrAsources", "chrSubources", "chrfSources", "chrAsRC", "chrSRC", "chrAsource", "chrfSrc", "chrSource", "chrSources", "chrSubRC"], "chrFilterSize": ["chreFilterSIZE", "chrfilterLen", "chreFilterSize", "chrFilterLen", "chrControlLen", "chreControlSIZE", "chrFiltersize", "chreFiltersize", "chrFilterSIZE", "chrfilterSize", "chrControlSize", "chrFilesize", "chrfilterSIZE", "chrFileSIZE", "chrfiltersize", "chrControlsize", "chreControlsize", "chrFileLen", "chrControlSIZE", "chreFilterLen", "chreControlLen", "chreControlSize", "chrFileSize"], "dest": ["dist", "shape", "flat", "loc", "end", "transform", "iter", "walk", "Dest", "class", "prop", "destroy", "num", "dim", "comb", "south", "ward", "draw", "done", " Dest", "d", "home", "sup", "txt", "sum", "img", "du", "data", "wb", "origin", "result", "route", "gen", "cont", "uv", "wd", "path", "transfer", "sort", "config", "source", "test", "desc", "includes", "usr", "replace", "err", "ord", "wh", "uc", " destination", "shift", "orig", "ident", "this", "feat", "sign", "move", "match", "mode", "trans", "store", "dc", "esc", "target", "src", "rest", "coord", "gest", "opt"], "dstW": [" dstH", " dSTW", " dSTw", " dSTVW", "dstH", "dostVW", "dSTH", "dostH", "dSTW", " dstw", "dSTw", "ddestH", "ddestW", "dostw", "ddestw", "dstVW", "ddestVW", " dstVW", " dSTH", "dostW", "dstw", "dSTVW"], "y": ["ny", "ch", "d", "ys", "t", "iy", "ey", "h", "py", "x", "w", "yi", "dy", "z", "p", "e", "b", "ay", "oy", "vy", "type", "Y", "yy", "ty"], "i": ["ui", "I", "d", "t", "l", "iu", "code", "ci", "h", "ii", "v", "w", "p", "e", "k", "li", "b", "j", "count", "n", "f", "end", "type", "pi", "start"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n", "idx": 8565, "substitutes": {"timer_list": ["tick_tree", "timer_record", "timerlisttest", "timer_count", "er_batch", "later_add", "meter_config", "timerlistget", "timer_stack", "timerappdef", "timerxList", "theme6stack", "timeridlist", "timerlistqueue", "timer2get", "timer_left", "timerlistlist", "theme_stack", "timerallconfig", "timer_table", "timerdrecord", "tick_List", " timer_diff", "timer_def", "meter_get", "timerkdiff", "timerxlist", "timer6LIST", "timerktable", "meterappdef", "timer0test", "theme0detail", "ticklisttree", "timer5stack", "theme_detail", "timer_type", "er_pair", "theme_LIST", "timer_queue", "theme_get", "timer_diff", "theme6list", "ticklistlist", "timerdlist", "timerAcount", "timerapplist", "meterappget", "timerlistList", "meter_def", "theme0get", "timer0detail", "theme_test", "timer6stack", "later_left", "ticklistList", "tick_queue", "timerlList", "timer0list", "timer5LIST", "tick_list", "timer6list", "timer_LIST", "timer6get", "timer_tree", "timerallget", "timerappget", "timerxpair", "timerklist", "ticklistqueue", "timeridleft", "timerAlist", "timerltree", "later_list", "timer_detail", "timer_config", "timer0get", "timeralldef", "er_list", "theme6get", "lateridbatch", "timerxrecord", "timer_lock", "timerappstack", "timer5get", "timerdList", "theme0list", "timerappLIST", "timer_batch", "timerlqueue", "timer_pair", "later_batch", "timerAtable", "theme0test", "er_type", "meterappconfig", "timer2config", "timer_List", "timer2list", "timer_add", " timer_count", "timer2def", "lateridlist", "timeralllist", "theme_list", "er_List", "timerllist", "timerlisttree", "timeridbatch", "timerappconfig", "timerlistdetail", "timerAdiff", "er_record", "er_lock", " timer_table", "lateridleft", "theme6LIST", "meter_list", "meterapplist", "timerkcount", "lateridadd", "timer_get", "timerdpair", "timer_test", "timeridadd", "timer5list"], "expire_time": ["expire___hour", "expirexmoney", "expireycount", "expireyhour", "expirexmode", "expire64money", "expire64hour", "expire___count", "expireytime", "expire64start", "expire_mode", "expire___time", "exake_start", "expiration_money", "expiration_timeout", "expire64timeout", "exire_money", "exire_count", "expireystart", "exire_Time", "expire__money", "expire___start", "expire_money", "exake___count", "exake___time", "expiration_time", "expire_Time", "expire_count", "expirextime", "expire_timeout", "expire64count", "expirefmoney", "expireftime", "expirefmode", "exire_time", "expire_hour", "exake_count", "exire_mode", "exake_hour", "expire__timeout", "exake___start", "expire64time", "expire__time", "expire_start", "exake_time", "exake___hour"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "static void avc_luma_midv_qrt_4w_msa(const uint8_t *src, int32_t src_stride,\n\n                                     uint8_t *dst, int32_t dst_stride,\n\n                                     int32_t height, uint8_t ver_offset)\n\n{\n\n    uint32_t loop_cnt;\n\n    v16i8 src0, src1, src2, src3, src4;\n\n    v16i8 mask0, mask1, mask2;\n\n    v8i16 hz_out0, hz_out1, hz_out2, hz_out3;\n\n    v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8;\n\n    v8i16 dst0, dst1, dst2, dst3, dst4, dst5, dst6, dst7;\n\n\n\n    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n\n\n    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src0, src1,\n\n                                                          mask0, mask1, mask2);\n\n    hz_out2 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3,\n\n                                                          mask0, mask1, mask2);\n\n\n\n    PCKOD_D2_SH(hz_out0, hz_out0, hz_out2, hz_out2, hz_out1, hz_out3);\n\n\n\n    hz_out4 = AVC_HORZ_FILTER_SH(src4, mask0, mask1, mask2);\n\n\n\n    for (loop_cnt = (height >> 2); loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src0, src1, src2, src3);\n\n        src += (4 * src_stride);\n\n        XORI_B4_128_SB(src0, src1, src2, src3);\n\n\n\n        hz_out5 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src0, src1,\n\n                                                              mask0, mask1,\n\n                                                              mask2);\n\n        hz_out7 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3,\n\n                                                              mask0, mask1,\n\n                                                              mask2);\n\n\n\n        PCKOD_D2_SH(hz_out5, hz_out5, hz_out7, hz_out7, hz_out6, hz_out8);\n\n\n\n        dst0 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out0, hz_out1, hz_out2,\n\n                                               hz_out3, hz_out4, hz_out5);\n\n        dst2 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out1, hz_out2, hz_out3,\n\n                                               hz_out4, hz_out5, hz_out6);\n\n        dst4 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out2, hz_out3, hz_out4,\n\n                                               hz_out5, hz_out6, hz_out7);\n\n        dst6 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5,\n\n                                               hz_out6, hz_out7, hz_out8);\n\n\n\n        if (ver_offset) {\n\n            dst1 = __msa_srari_h(hz_out3, 5);\n\n            dst3 = __msa_srari_h(hz_out4, 5);\n\n            dst5 = __msa_srari_h(hz_out5, 5);\n\n            dst7 = __msa_srari_h(hz_out6, 5);\n\n        } else {\n\n            dst1 = __msa_srari_h(hz_out2, 5);\n\n            dst3 = __msa_srari_h(hz_out3, 5);\n\n            dst5 = __msa_srari_h(hz_out4, 5);\n\n            dst7 = __msa_srari_h(hz_out5, 5);\n\n        }\n\n\n\n        SAT_SH4_SH(dst1, dst3, dst5, dst7, 7);\n\n\n\n        dst0 = __msa_aver_s_h(dst0, dst1);\n\n        dst1 = __msa_aver_s_h(dst2, dst3);\n\n        dst2 = __msa_aver_s_h(dst4, dst5);\n\n        dst3 = __msa_aver_s_h(dst6, dst7);\n\n\n\n        PCKEV_B2_SB(dst1, dst0, dst3, dst2, src0, src1);\n\n        XORI_B2_128_SB(src0, src1);\n\n\n\n        ST4x4_UB(src0, src1, 0, 2, 0, 2, dst, dst_stride);\n\n\n\n        dst += (4 * dst_stride);\n\n        hz_out0 = hz_out4;\n\n        hz_out1 = hz_out5;\n\n        hz_out2 = hz_out6;\n\n        hz_out3 = hz_out7;\n\n        hz_out4 = hz_out8;\n\n    }\n\n}\n", "idx": 13137, "substitutes": {"src": ["RC", "gz", "uc", "dist", "sync", "tmp", "rc", "config", "stream", "rs", "ctr", "sup", "source", "low", "sr", "cmp", "dest", "sq", "loc", "gru", "sil", "gn", "gl", "lib", "img", "rb", "sec", "desc", "comp", "pl", "sb", "inst", "scl", "gb", "url", "cb", "sc", "ssl", "rob", "sci", "bg", "sl", "chrom", "sub", "sel", "cur", "st", "fc", "ctx", "filename"], "src_stride": ["src_drides", "src_Strides", "src_bride", "src_strride", "src_brider", "src_brIDE", "src_Stride", "src_drider", "src_strides", "src_STRider", "src_trride", "src_striided", "src_strider", "src_tride", "src_STRides", "src_StrIDE", "src_brides", "src_striides", "src_striride", "src_strIDE", "src_brided", "src_STRided", "src_Strided", "src_STRide", "src_trided", "src_Strride", "src_brride", "src_trides", "src_drride", "src_striide", "src_STRIDE", "src_strided", "src_dride", "src_STRride"], "dst": ["bsp", "Dsp", "fest", "fsp", "fst", "Dest", "dest", "Dst", "Drc", "brc", "drc", "best", "frc", "dsp", "bst"], "dst_stride": ["dst_arrided", "dst_tride", "dst_trided", "dst_strride", "dst_strides", "dst_trides", "dst_divride", "dst_trride", "dst_strided", "dst_arrride", "dst_arrides", "dst_divides", "dst_divide", "dst_arride", "dst_divided"], "height": ["Height", "ch", "slice", "build", "input", "thin", "bottom", "top", "id", "i", "level", "shape", "def", "row", "gap", "h", "boost", "kw", "size", "img", "data", "op", "length", "th", "padding", "resolution", "prev", "diff", "timeout", "block", "dim", "hd", "headers", "layout", "high", "window", "windows", "depth", "header", "y", "index"], "ver_offset": ["block_padding", "blocklenmask", "verprepadding", "blocklenno", "ver_padding", "verpremask", "verlenoffset", "verlenno", "ver_no", "verlenpadding", "blocklenoffset", "block_no", "verpreno", "block_mask", "ver_mask", "blocklenpadding", "verpreoffset", "block_offset", "verlenmask"], "loop_cnt": ["loop_acct", "loop_secount", "loop_lcct", "loop_cct", "loop_acnc", "loop_Cant", "loop_lcnt", "loop_secnd", "loop_CNT", "loop_ncnt", "loop_dcnt", "loop_secnt", "loop_lcno", "loop_ctrl", "loop_lcnc", "loop_ncant", "loop_cNT", "loop_cno", "loop_counttrl", "loop_Count", "loop_acno", "loop_acnt", "loop_acnd", "loop_nctrl", "loop_ncNT", "loop_Ctrl", "loop_dcct", "loop_acNT", "loop_countnt", "loop_cnc", "loop_acount", "loop_cnd", "loop_dcnc", "loop_Cnd", "loop_countNT", "loop_Cnt", "loop_cant", "loop_dcno", "loop_count", "loop_secNT", "loop_countant"], "src0": [" src60", "loc3", "rc2", "seq1", "loc0", "rc0", "src60", "src00", " src00", "source2", "source1", "rc00", "source0", "loc1", "seq0", "rc3", "rc4", "source4", "seq2", "rc60", "loc2", "seq60", "rc1", "loc00"], "src1": ["loc3", "inst0", "inst1", "rc2", "source3", "loc0", "rc0", "inst2", "loc4", "source1", "source0", "loc8", "loc1", "rc3", "rc4", "rc8", "source4", "inst8", "loc2", "rc1", "src8"], "src2": ["source02", "loc3", "source8", "rc2", "loc0", "rc0", "loc4", "source2", " src8", "source1", "loc1", "rc3", "rc4", "rc02", "source4", "rc8", "src02", "loc2", "rc1", " src02", "src8"], "src3": ["loc3", "source03", "src03", "loc03", "rc2", "sur3", "source3", "dist1", "g", "src23", "rc03", "source2", "sur4", "source1", "sur5", "dist03", "rc5", "s", "loc1", "dist3", "rc3", "rc4", "rc23", "dist23", "source4", "dist2", "sur1", "src5", "source23", "loc2", " src5", "rc1", "source5"], "src4": ["source8", "rc44", "src44", "rc40", "rc2", "source3", " src40", "dist8", "source40", "source2", "source44", " src8", "dist44", "src40", "rc5", "dest2", "dest3", "dist4", "rc3", "rc4", "source4", "rc8", "dist2", "dest4", "src5", " src5", "source5", "dest8", "src8"], "mask0": ["ask50", "ask00", "ph1", "fix0", "miss2", "ask0", "sum2", "ph0", "ask2", "ph5", " mask50", "mask00", "fix5", "weight0", "sum1", "fix1", " mask5", "miss1", "weight00", "mask50", "shape2", "ask1", " mask00", "shape1", "shape5", "shape0", "weight1", "miss0", "miss00", "fix2", "ph2", "ask5", "sum0", "weight50", "mask5"], "mask1": ["ask3", "miss2", "miss8", "mark3", "weight2", "ask0", "mark4", "mark0", "mask3", "ask2", "weight0", "mark1", "weight4", "ask4", " mask4", "miss1", "ask1", "mask4", "mark2", "ask8", "weight1", "miss0", " mask3", "mask8", "miss4", " mask8"], "mask2": ["ask3", "miss2", "sum2", "mask3", "ask2", "sum4", "sum3", "ask4", " mask4", "miss3", "pack2", "sum5", "sum1", "ask6", "miss1", " mask5", " mask6", "ask1", "mask4", "pack3", "mask6", " mask3", "pack6", "ask5", "pack4", "miss4", "mask5"], "hz_out0": ["hz_mask0", "hz_option3", "hz_OUT12", "hz_OUT19", "hz_in0", "hz_in1", "hz_sum0", "hz_sum8", "hz_sum10", "hz_no0", "hz_OUT2", "hz_in12", "hz_in10", "hz_out10", "hz_again1", "hz_no3", "hz_mask12", "hz_again3", "hz_out12", "hz_no8", "hz_in19", "hz_OUT3", "hz_again0", "hz_in8", "hz_option8", "hz_option1", "hz_out19", "hz_OUT0", "hz_again19", "hz_in3", "hz_sum1", "hz_OUT1", "hz_no1", "hz_in2", "hz_exp1", "hz_exp0", "hz_exp8", "hz_exp10", "hz_mask1", "hz_mask2", "hz_option0"], "hz_out1": ["hz_in1", "hz_OUT2", "hz_outOne", "hz_nin1", "hz_in7", "hz_exp7", "hz_option11", "hz_nin2", "hz_optionOne", "hz_inOne", "hz_option2", "hz_OUTOne", "hz_in8", "hz_nin8", "hz_OUT11", "hz_option1", "hz_nin7", "hz_exp2", "hz_OUT1", "hz_in2", "hz_exp1", "hz_in11", "hz_out11", "hz_exp8"], "hz_out2": ["hz_Out2", "hz_copy2", "hz_copy5", "hz_OUT2", "hz_nin5", "hz_name1", "hz_option2", "hz_in4", "hz_Out4", "hz_nin4", "hz_option7", "hz_Out3", "hz_in02", "hz_name02", "hz_off1", "hz_OUT82", "hz_in7", "hz_off2", "hz_nin2", "hz_nin82", "hz_inTwo", "hz_name7", "hz_out02", "hz_OUT5", "hz_name2", "hz_in0", "hz_OutTwo", "hz_out82", "hz_option02", "hz_outTwo", "hz_in3", "hz_OUTTwo", "hz_in2", "hz_copy82", "hz_in1", "hz_off0", "hz_copy4", "hz_Out1", "hz_off3", "hz_option1", "hz_OUT4", "hz_OUT1", "hz_Out0"], "hz_out3": ["hz_update6", "hz_again305", "hz_num3", "hz_Out3", "hz_index305", "hz_index6", "hz_Out2", "hz_in1", "hz_num2", "hz_Out1", "hz_num1", "hz_update5", "hz_num03", "hz_Out03", "hz_again3", "hz_out03", "hz_index3", "hz_again6", "hz_update3", "hz_out305", "hz_again5", "hz_in3", "hz_in2", "hz_update305", "hz_index5", "hz_in03"], "hz_out4": ["hz_sum4", "hz_sum12", "hz_sum3", "hz_sum8", "hz_sum2", "hz_again2", "hz_sum32", "hz_out32", "hz_again12", "hz_again3", "hz_out12", "hz_again32", "hz_in8", "hz_in4", "hz_in3", "hz_again8", "hz_in32", "hz_in2", "hz_in12", "hz_again4"], "hz_out5": ["hz_inL", "hz_in5", "hz_outerL", "hz_in1", "hz_outer1", "hz_again2", "hz_outer2", "hz_again1", "hz_outer5", "hz_outL", "hz_again5", "hz_in2", "hz_againL"], "hz_out6": ["hz_index6", "hz_over12", "hz_index7", "hz_in7", "hz_index12", "hz_over6", "hz_out12", "hz_in6", "hz_over7", "hz_in2", "hz_index2", "hz_over2", "hz_in12"], "hz_out7": ["hz_exp57", "hz_nin57", "hz_out57", "hz_in7", "hz_exp7", "hz_in17", "hz_exp27", "hz_in27", "hz_nin27", "hz_in57", "hz_nin7", "hz_out17", "hz_exp17", "hz_nin17", "hz_out27"], "hz_out8": ["hz_in5", "hz_in1", "hz_again2", "hz_OUT2", "hz_OUT8", "hz_again1", "hz_in8", "hz_again5", "hz_OUT1", "hz_again8", "hz_in2", "hz_OUT5"], "dst0": ["lest1", "lst4", "dost2", "dest0", "lest2", "dsc2", "lst1", "lst0", "dest1", "dost1", "dost4", "lst2", "dest2", "dsc1", "lest4", "lest0", "dost0", "dest4", "dsc0", "dsc4"], "dst1": [" dsc1", "dest0", "dsp1", "dsc2", "dest1", "dst01", " dsc2", "dest2", " dsc01", "dsc1", " dsc0", " dst01", "dest01", "dsc01", "dsp0", "dsp01", "dsp2", "dsc0"], "dst2": ["ddest4", " dest2", "ddest5", " dest4", " dest1", "dconst2", "dest1", "dest5", "dest2", "dconst4", "dest4", "ddest1", "dconst1", " dest5", "dconst5", "ddest2"], "dst3": ["ddest4", " dest2", " dest3", " dest4", "ddest3", " dest1", "dest1", "dgest1", "dgest2", "dgest4", "dest2", "dest3", "dgest3", "dest4", "ddest1", "ddest2"], "dst4": ["dST5", " dest2", "dST54", " dest4", "dST4", "dgest54", "dgest2", "dgest5", "dgest4", "dest5", "dest2", " dest54", "dest4", " dest5", "dST2", " dst54", "dest54", "dst54"], "dst5": [" dest2", " dest4", "dsts4", " dest55", "dgest2", "dgest5", "dgest4", "dest5", "dest2", "dsts55", "dsts5", " dst55", "dsts2", "dst55", "dest4", " dest5", "dest55", "dgest55"], "dst6": ["destSix", "ddestSix", " dest8", "ddest8", "dstage6", "dstSix", "dst8", " dstSix", " destSix", "dstage8", " dest7", " dest6", "dstageSix", "dest6", "ddest7", "ddest6", " dst8", "dest8", "dest7", "dstage7"], "dst7": [" ddest7", " ddest6", "dST6", "dST77", "ddest8", "dst77", " ddest77", "dst8", "dST7", "dST8", " ddest8", " dst77", "dest6", "ddest7", "ddest6", "dest77", "ddest77", " dst8", "dest8", "dest7"]}}
{"project": "qemu", "commit_id": "21ef45d71221b4577330fe3aacfb06afad91ad46", "target": 1, "func": "static void gd_resize(DisplayChangeListener *dcl,\n\n                      DisplayState *ds)\n\n{\n\n    GtkDisplayState *s = ds->opaque;\n\n    cairo_format_t kind;\n\n    int stride;\n\n\n\n    DPRINTF(\"resize(width=%d, height=%d)\\n\",\n\n            ds_get_width(ds), ds_get_height(ds));\n\n\n\n    if (s->surface) {\n\n        cairo_surface_destroy(s->surface);\n\n    }\n\n\n\n    switch (ds->surface->pf.bits_per_pixel) {\n\n    case 8:\n\n        kind = CAIRO_FORMAT_A8;\n\n        break;\n\n    case 16:\n\n        kind = CAIRO_FORMAT_RGB16_565;\n\n        break;\n\n    case 32:\n\n        kind = CAIRO_FORMAT_RGB24;\n\n        break;\n\n    default:\n\n        g_assert_not_reached();\n\n        break;\n\n    }\n\n\n\n    stride = cairo_format_stride_for_width(kind, ds_get_width(ds));\n\n    g_assert(ds_get_linesize(ds) == stride);\n\n\n\n    s->surface = cairo_image_surface_create_for_data(ds_get_data(ds),\n\n                                                     kind,\n\n                                                     ds_get_width(ds),\n\n                                                     ds_get_height(ds),\n\n                                                     ds_get_linesize(ds));\n\n\n\n    if (!s->full_screen) {\n\n        GtkRequisition req;\n\n        double sx, sy;\n\n\n\n        if (s->free_scale) {\n\n            sx = s->scale_x;\n\n            sy = s->scale_y;\n\n\n\n            s->scale_y = 1.0;\n\n            s->scale_x = 1.0;\n\n        } else {\n\n            sx = 1.0;\n\n            sy = 1.0;\n\n        }\n\n\n\n        gtk_widget_set_size_request(s->drawing_area,\n\n                                    ds_get_width(ds) * s->scale_x,\n\n                                    ds_get_height(ds) * s->scale_y);\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n        gtk_widget_get_preferred_size(s->vbox, NULL, &req);\n\n#else\n\n        gtk_widget_size_request(s->vbox, &req);\n\n#endif\n\n\n\n        gtk_window_resize(GTK_WINDOW(s->window),\n\n                          req.width * sx, req.height * sy);\n\n    }\n\n}\n", "idx": 11368, "substitutes": {"dcl": ["ddcl", "dsCL", "dCL", "ddCl", " dCl", " dfl", "dscl", "dsfl", "dsCl", "ddCL", "dfl", "ddfl", " dCL", "dCl"], "ds": ["vs", "ld", "sem", "cdn", "des", "session", "gd", "ts", "ks", "dh", "did", "uds", "dom", "dds", "da", "die", "dt", "dos", "dal", "ads", "d", "gs", "data", "ys", "ls", "pd", "parts", "dist", "du", "xs", "js", "rs", "df", "os", "ded", "dl", "dr", "db", "cs", "dat", "sync", "sts", "md", "dd", "DS", "vd", "ans", "ns", "dc", "nas", "sd", "ms", "Ds", "dm", "sys", "od", "der", "ses", "fs", "ps", "del", "ss", "bs", "settings", "dx"], "s": ["l", "session", "is", "its", "m", "t", "gs", "parts", "state", "ns", "hs", "spec", "self", "params", "sg", "si", "n", "your", "b", "i", "iss", "c", "e", "args", "sq", "us", "f", "sym", "sets", "es", "r", "sis", "as", "u", "fs", "ps", "site", "ss", "ks", "sv", "g", "stats", "ops", "d", "sa", "ls", "os", "cs", "o", "sync", "sl", "new", "sb", "sys", "secondary", "a", "ssl", "vs", "conf", "ts", "service", "p", "qs", "ins", "xs", "js", "rs", "aws", "S", "sts", "states", "services", "h", "ses", "y", "bs"], "kind": ["parent", "ld", "rank", "gen", " kinds", "good", "kg", "std", "context", "str", "start", "Kind", "class", "def", "vid", "id", "method", "key", "nt", "die", "path", "k", "instance", "data", "head", "info", "draw", "lit", "args", "style", "xxx", "brand", "mode", "ie", "code", "mid", "child", "stroke", "actory", "kid", "shape", "nd", "ck", "name", "ind", "inner", "kt", "desc", "part", "cost", "spec", "ke", "need", "init", "concept", "type", "lang", "mean", "dev", "impl", "sid", "engine", "text", "feat", "depth", "ko"], "stride": ["striider", "striide", "Stride", " strided", "brided", "Strided", " strider", "briding", "strider", "bride", "striding", "striiding", "drided", "Strider", "trider", " striding", "Striding", "drider", "strided", "tride", "trided", "brider", "driding", "triding", "dride", "striided"], "req": ["sp", "cmp", "war", "rw", "org", "require", "ver", "ra", "ref", "qq", "tar", "reg", "dist", " reg", "ctr", "cur", "err", "spec", "get", "grad", "rx", "resp", " requirements", "fr", "iw", "gr", "serv", "e", "app", "request", "sq", "f", "j", "res", "r", "wx", "ur", "compl", "exec", "rf", "dq", "sem", "ru", " requisite", "seq", "str", "g", "conn", "util", "progress", "query", "tx", "jp", "a", "ret", "cache", "crit", "conf", "urg", "qt", "ry", "wa", "rr", "rec", "p", "js", "q", "sec", "requ", "lib", "Requ", "ctx", "pr", "pull", "client", "proc", " requ"], "sx": ["ssph", "Sx", "sfx", " smy", "spxe", "ppx", "sw", "ssfx", "ssw", "spy", " sph", " sX", "ssxe", "dw", "ssx", "ssy", "sxe", "py", " sxe", "sph", "dfx", "sX", "pX", "sct", "smy", " spx", "ssmy", " sct", " sfx", "px", "Spx", "spph", "spx", "Sy", "SX", "dx", "dy", "ssct"], "sy": ["ady", "hi", "si", "ry", "len", "asy", "ny", "phy", "ey", "sa", "ys", "fy", "thin", "ay", "sq", "zy", "lat", "yy", "gy", "sym", "py", "size", "syn", "sky", "ky", "south", "fun", "hy", "ty", "SY", "dy", "idy", "sys", "rx", "lon", "sat", "yn", "y", "ch", "Sy", "wy", "ity", "cy", "Ty"]}}
{"project": "qemu", "commit_id": "4ed7b2c3a78f785a1bcbe575e08c379b166723e3", "target": 1, "func": "static int local_open2(FsContext *fs_ctx, V9fsPath *dir_path, const char *name,\n\n                       int flags, FsCred *credp, V9fsFidOpenState *fs)\n\n{\n\n    char *path;\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n    V9fsString fullname;\n\n    char *buffer;\n\n\n\n    /*\n\n     * Mark all the open to not follow symlinks\n\n     */\n\n    flags |= O_NOFOLLOW;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    path = fullname.data;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(buffer, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set client credentials in .virtfs_metadata directory files */\n\n        err = local_set_mapped_file_attr(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n               (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    err = fd;\n\n    fs->fd = fd;\n\n    goto out;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(buffer);\n\n    errno = serrno;\n\n    g_free(buffer);\n\nout:\n\n    v9fs_string_free(&fullname);\n\n    return err;\n\n}\n", "idx": 16204, "substitutes": {"fs_ctx": ["fs__ctx", "fsdefctx", "fs32ctx", "fs_spec", "fs__gz", "fs_xc", "fs_lc", "FS_conn", "fs32cm", "vs_wcs", "flows_ctx", "fsMsci", "fs_cms", "fs_loc", "ds_tx", "irs_ctx", "fsdefconn", "FS_spec", "flows_xc", "sfMctx", "fs_anc", "sf_ctx", "fs_cu", "fs_wcs", "fs__anc", "ds_gz", "fs32tx", "fsMctx", "ds_ctx", "irs__anc", "fsvalspec", "FS_context", "sf_ctrl", "vs_local", "sfMsci", "fsvalcm", "vs_loc", "fs_context", "sf_cu", "fsdefcu", "flows_cm", "fsMwcs", "sfdefctrl", "fs___conn", "irs__ctx", "fsdefctrl", "fsvalcontext", "fs_sci", "fs_conn", "irs_anc", "sfdefcu", "fs__lc", "fsMloc", "fsMscope", "fsMlocal", "fsMlc", "fs_gz", "fs_local", "fs_tx", "fs32xc", "fs___ctrl", "sf_lc", "sfdefctx", "sfMscope", "fs__tx", "flows_tx", "FS_cm", "irs__conn", "sf_conn", "sf_scope", "vs_ctx", "irs_lc", "fs_scope", "sfdefconn", "sfMlc", "fs__cms", "FS_tx", "fs_cm", "fs_ctrl", "fs___ctx", "sf_sci", "irs__lc", "FS_ctx", "irs_conn", "ds_cms", "fs__conn", "fs___cu", "fsvalctx"], "dir_path": [" dir_fn", " dir_pointer", "dirallpath", "dirallctx", "dir_ctx", "dir_fn", " dir_ctx", " dir_name", " dir_context", "dirallcontext", "dir_name", "dir_pointer", "dir_context", "dirallfn"], "name": ["word", "part", "id", "home", "image", "x", "comment", "key", "Name", "NAME", "names", "size", "time", "info", "data", "ext", "base", "ix", "length", "n", "f", "parent", "url", "block", "type", "file", "host", " prefix", "content", "prefix", "space", "alias", "filename"], "flags": ["types", "args", "parts", "FLAG", "format", "ffff", "xml", "fl", "util", "locks", "fields", "utils", "prot", "tails", "FL", "fps", "details", "settings", "bytes", "status", "opens", "linux", "files", "items", "feat", "reads", "s", "options", "plugins", "includes", "faces", "nil", "features", "lines", "mask", "lag", "frames", "lf", "bits", "feed", "Flags", "ports", "stats", "ops", "links", "ds", "errors", "fee", "ints", "ips", "rules", "fts", "ils", "flag", "vals", "xxx"], "credp": ["ccrowdpc", "crimpo", "crowdpc", "lcrdpc", "Credf", " creditp", "Creds", "lcrdv", "creditsv", "credc", "ccrowdp", " cprivvp", "creditsp", " creditpi", "crsi", " cprivp", "crsm", "cribpc", "crimf", "creedc", "credo", "crdpc", "crimp", " credf", "crdp", "cannedo", "creds", "credpa", "lcrdp", "lcrdi", "cprivc", "cribpa", "Creditsp", "crcp", "lcredc", "cannedp", "Creder", "crsp", "Crder", "crcs", "creditpo", "lcredi", "crsc", "ccrowdf", "creditspm", "lcreditspm", "crdf", "crowdpa", "crdc", "creditsc", "crds", "crdpm", "cribpo", "cribf", "cdefpc", "Credp", "cribp", " credvp", "creditso", " credpo", "credpi", "crder", "lcredm", "lcrdm", "lcreditsv", "creedp", "Crdf", "lcredpc", "crdvp", "cessp", "crowdp", "cRedp", "ccedv", "ccredf", "caredc", " creditpo", "creditp", "credpm", "credpc", "cannedu", "credm", "cessv", "creditpi", "creditspa", "ccredpa", "caredvp", "Creditsu", "crdi", "ccedp", " credc", " cprivpo", "credi", "ccredpc", " cprivc", "credpo", "crdv", "lcreditsc", "Crds", "cdefp", "cesspc", "lcrdc", "creedm", "creditsu", "cessc", " credpi", "caredp", "crowdf", "Credu", "crcf", "crcer", "ccrowdpa", "lcredp", "crdpo", "creditspc", "cRedu", "ccredp", " creditf", "cprivvp", "cprivp", "caredpo", "creditsf", "cdefv", "credv", "credu", "Creditso", "cprivpo", "cribpi", "Crdp", "lcredv", "lcreditsp", "credf", "creditf", "creder", "crdm", "Credo", "creedi", "cdefc", "crimpi", "ccedpm", "ccedc", "credvp", "lcredpm", "cRedo"], "fs": ["Fs", "acs", "sys", "sync", "irs", "fb", "rs", "cs", "settings", "os", "fp", "files", "FS", "sec", "f", "ns", "feed", "stats", "cf", "states", "cache", "ls", "ts", "fc", "vals", "fw"], "path": ["channel", "port", "location", "context", "root", "self", "ath", "enc", "config", "mount", "code", "id", "stream", "object", "home", "child", "source", "directory", "image", "user", "method", "dir", "fn", "uri", "key", "loc", "password", "pass", "loader", "size", "p", "temp", "resource", "time", "buf", "pointer", "data", "entry", "length", "mode", "Path", "draft", "parent", "PATH", "url", "route", "c", "feed", "inner", "file", "text", "transform", "host", "cache", "pattern", "content", "prefix", "alias", "node"], "fullname": [" fullnumber", "flatname", "fullytext", "fultext", "flatword", "Fullpath", "flatkey", "flatpath", "fullName", "fulkey", " fullName", "shortpath", "fullypath", "Fullname", "fullystart", "fullnumber", " fullstart", "fullyname", "fullsize", "fulltext", " fullpath", "fulword", "flatnumber", " fullsize", "fullykey", "fullpath", "flattext", "FullName", "fullyword", "Fullsize", "flatstart", "shortname", "fullword", "fulname", "fullstart", "shortsize", "fullkey", "fullynumber", "shortName"], "buffer": ["area", "device", "port", "batch", "profile", "memory", "image", "pool", "available", "fp", "server", "table", "limit", "handler", "base", "Buffer", "reader", "timeout", "cb", "offset", "attr", "text", "iter", "window", "copy", "message", "seek", "bin", "slice", "seed", "uf", "FFER", "reference", "writer", "comment", "fr", "loader", "resource", "data", "b", "byte", "entry", "page", "length", "result", "url", "feed", "uffer", "function", "cache", "stack", "header", "ptr", "filename", "transfer", "queue", "fd", "source", "document", "layer", "flash", "f", "address", "token", "delay", "texture", "channel", "input", "stream", "player", "binary", "position", "buff", "bar", "size", "wave", "buf", "shell", "file", "pad", "callback"]}}
{"project": "FFmpeg", "commit_id": "f20b67173ca6a05b8c3dee02dad3b7243b96292b", "target": 0, "func": "static void apply_tns_filter(float *out, float *in, int order, int direction,\n\n                             float *tns_coefs, int ltp_used, int w, int filt,\n\n                             int start_i, int len)\n\n{\n\n    int i, j, inc, start = start_i;\n\n    float tmp[TNS_MAX_ORDER+1];\n\n    if (direction) {\n\n        inc = -1;\n\n        start = (start + len) - 1;\n\n    } else {\n\n        inc = 1;\n\n    }\n\n    if (!ltp_used) {    /* AR filter */\n\n        for (i = 0; i < len; i++, start += inc)\n\n            out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tns_coefs[j]*in[start - j*inc];\n\n    } else {            /* MA filter */\n\n        for (i = 0; i < len; i++, start += inc) {\n\n            tmp[0] = out[i] = in[start];\n\n            for (j = 1; j <= FFMIN(i, order); j++)\n\n                out[i] += tmp[j]*tns_coefs[j];\n\n            for (j = order; j > 0; j--)\n\n                tmp[j] = tmp[j - 1];\n\n        }\n\n    }\n\n}\n", "idx": 24761, "substitutes": {"out": ["ref", "temp", "code", "call", "OUT", "obj", "bin", "p", "m", "b", "c", "app", "image", "filter", "flag", "other", "data", "doc", "again", "up", "Out", "outs", "pass", "sync", "op", "all", "line", "o", "outside", "outer", "input", "at", "process", "inner", "flat", "object", "output", "group", "append", "parent", "copy", "new", "vert", "client", "cache", "co", "conv", "update", "array", "dot", "part", "source", "n", "list", "v", "init", "pre", "result"], "in": ["exec", "ref", "inside", "IN", "din", "bin", "this", "p", "m", "b", "c", "image", "In", "data", "config", "up", "again", "ins", "pass", "id", "ani", "rec", "orig", "line", "con", "arr", "work", "min", "input", "ic", "at", "inner", "ini", "inf", "ii", "ai", "nin", "binary", "new", "inn", "isin", "win", "update", "before", "part", "source", "n", "index", "a", "init", "ind", "pre", "ac", "table"], "order": ["use", "code", "er", "page", "info", "en", "next", "Order", "error", "end", "id", "rec", "orig", "iter", "seed", "reverse", "max", "min", "err", "dir", "ord", "oder", "start", "inner", "ini", "ii", "si", "ai", "grade", "sort", "rank", "asc", "record", "level", "first", "length", "orders", "part", "count", "rule", "limit", "list", "index", "init", "ind", "ordered", "r", "pos"], "direction": ["orient", "dc", "dim", "dy", "d", "oriented", "weight", "phase", "diff", "rec", "range", "directory", "depth", "step", "reverse", "linear", "unit", "dir", "di", "ii", "forward", "mode", "wd", "vert", "sort", "period", "ward", "quad", "length", "dist", "round", "gradient", "directed", "dest", "ind", "degree", "normal", "irection", "direct", "dn", "desc"], "tns_coefs": ["tns_coefds", "tns_coecs", "tns_coafs", "tns_coffsets", "tns_Coefs", "tns_coefments", "tns_coeffsets", "tns_Coefments", "tns_coeffments", "tns_coreferences", "tns_coffors", "tns_corefsets", "tns_coeffds", "tns_coefsets", "tns_cofferences", "tns_coecments", "tns_coffds", "tns_coffnames", "tns_coecds", "tns_coefnames", "tns_coecsets", "tns_coefors", "tns_coafds", "tns_Coffments", "tns_Coffs", "tns_Coefsets", "tns_coefferences", "tns_corefnames", "tns_corefs", "tns_coffments", "tns_coafors", "tns_Coffds", "tns_coffs", "tns_coeferences", "tns_coeffnames", "tns_coafsets", "tns_Coefds", "tns_coeffs", "tns_coeffors", "tns_Coffsets"], "ltp_used": ["ltnp_enabled", "ltps_used", "ltps_active", "ltp_using", "ltp_needed", "ltp_active", "ltnp_use", "ltnp_used", "ltnp_needed", "ltp_enabled", "ltps_using", "ltp_use"], "w": ["ow", "kw", "z", "c", "d", "sw", "wave", "weight", "wh", "wx", "iw", "wl", "wd", "wind", "win", "wp", "h", "aw", "f", "wt", "nw", "W", "v", "r", "nc", "wa", "wait"], "filt": ["ofilt", "tflt", "ofitter", "oflet", "tfilt", "tfitter", "flt", "efilt", "fitter", "tflet", "eflet", "eflt", "oflt", "flet", "efitter"], "start_i": [" start_p", "start_start", "end_j", "start_j", "start_I", " start_in", "start_p", "end_I", "end_i", "end_start", "start_in", " start_j"], "len": ["L", "seq", "fin", "z", "ll", "base", "en", "non", "end", "lon", "lf", "line", "el", "li", "Len", "min", "lu", "la", "start", "loc", "dl", "lib", "lin", "ii", "size", "ln", "length", "lc", "win", "part", "lp", "count", "f", "limit", "n", "list", "net", "lim", "ind", "pos", "l", "val", "lock"], "i": ["my", "k", "z", "yi", "p", "b", "m", "c", "ie", "info", "ix", "x", "api", "mi", "phi", "qi", "it", "ri", "id", "io", "u", "e", "li", "gi", "ic", "o", "zi", "ji", "start", "xi", "uri", "ii", "ini", "si", "ai", "di", "ni", "bi", "cli", "ci", "fi", "eni", "I", "f", "y", "oi", "n", "ip", "index", "a", "mini", "iu", "ind", "v", "pi", "r", "ui", "l", "hi", "init"], "j": ["obj", "jit", "k", "z", "ie", "p", "m", "b", "uj", "adj", "c", "d", "pt", "x", "job", "jing", "je", "jo", "jp", "py", "next", "aj", "qi", "jj", "it", "u", "jam", "key", "e", "bj", "ji", "o", "li", "start", "jc", "ii", "journal", "ij", "jet", "oj", "length", "note", "json", "h", "f", "y", "jl", "js", "n", "pr", "t", "jon", "index", "q", "v", "J", "ind", "ui", "l", "dj", "jen", "ja", "g"], "inc": ["acc", "pp", "k", "z", "dc", "p", "page", "keep", "c", "adj", "d", "enc", "circ", "diff", "ins", "inst", "end", "cycle", "num", "rec", "fr", "step", "sp", "iter", "INC", "min", "zi", "start", "dir", "loc", "inner", "ii", "inf", "ini", "lin", "sign", "ci", "sort", "rc", "Inc", "inn", "req", "asc", "lc", "update", "win", "zip", "ir", "f", "count", "n", "index", "incre", "inter", "init", "ind", "r", "alpha", "nc", "pack"], "tmp": ["temp", "pp", "txt", "code", "obj", "done", "np", "slice", "nm", "page", "b", "p", "emp", "stuff", "app", "rup", "data", "test", "job", "frac", "img", "rb", "py", "area", "jp", "cb", "up", "front", "proc", "pad", "cmp", "ppo", "mp", "sp", "amp", "ff", "input", "dat", "start", "nb", "prep", "flat", "st", "output", "copy", "cp", "sb", "fb", "pm", "cache", "now", "sup", "zip", "wp", "part", "perm", "src", "fp", "v", "dest", "pre", "map", "result", "attr", "post", "table", "params"]}}
{"project": "FFmpeg", "commit_id": "7104c23bd1a1dcb8a7d9e2c8838c7ce55c30a331", "target": 0, "func": "static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no)\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;\n\n    int A[2] = {0}, B[2], C[2];\n\n    int i, j;\n\n    int mx, my;\n\n    int avail_index = avail_indexes[subblock_no];\n\n    int c_off = part_sizes_w[block_type];\n\n\n\n    mv_pos += (subblock_no & 1) + (subblock_no >> 1)*s->b8_stride;\n\n    if(subblock_no == 3)\n\n        c_off = -1;\n\n\n\n    if(r->avail_cache[avail_index - 1]){\n\n        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][0];\n\n        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][1];\n\n    }\n\n    if(r->avail_cache[avail_index - 4]){\n\n        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][0];\n\n        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][1];\n\n    }else{\n\n        B[0] = A[0];\n\n        B[1] = A[1];\n\n    }\n\n    if(!r->avail_cache[avail_index - 4 + c_off]){\n\n        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)){\n\n            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][0];\n\n            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][1];\n\n        }else{\n\n            C[0] = A[0];\n\n            C[1] = A[1];\n\n        }\n\n    }else{\n\n        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][0];\n\n        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][1];\n\n    }\n\n    mx = mid_pred(A[0], B[0], C[0]);\n\n    my = mid_pred(A[1], B[1], C[1]);\n\n    mx += r->dmv[dmv_no][0];\n\n    my += r->dmv[dmv_no][1];\n\n    for(j = 0; j < part_sizes_h[block_type]; j++){\n\n        for(i = 0; i < part_sizes_w[block_type]; i++){\n\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][0] = mx;\n\n            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][1] = my;\n\n        }\n\n    }\n\n}\n", "idx": 27317, "substitutes": {"r": ["ru", "rs", "k", "sr", "er", "w", "this", "b", "m", "p", "c", "d", "dr", "rf", "x", "rb", "br", "mr", "ra", "tr", "fr", "self", "rss", "nor", "e", "R", "rh", "err", "l", "re", "rc", "rg", "kr", "ar", "ur", "as", "h", "ir", "rt", "f", "pr", "n", "t", "v", "rr", "result", "hr", "g"], "block_type": [" block_pos", "blockworkkey", "block_name", "blockingtype", "block_pos", "blockworktype", "blockingname", "blockinglock", "blockingkey", " block_key", " block_name", " block_lock", "block_key", "blockworklock", " block_no", "block_no", "block_number", " block_number", "block_lock", "blockworkname"], "subblock_no": ["subblockIDno", "subblock2number", "subblock_po", "subBlock_nr", "subblock1pos", "subBlock_num", "subblock_No", "subblock1num", "subblock2po", "subblock2pos", "subblock2no", "subblock2No", "subblock_pos", "subBlock_number", "subblock_nu", "subblockIDpos", "subblock2num", "subblock_nos", "subblock_num", "subblock_code", "subBlock_code", "subBlock_No", "subblockIDbo", "subblock1nos", "subblock2nr", "subblock_bo", "subBlock_po", "subBlock_pos", "subblock1number", "subBlock_bo", "subBlock_nos", "subblock_nr", "subblockIDnu", "subblock1No", "subblock1nr", "subblock2nos", "subblock1no", "subBlock_no", "subblock_number", "subBlock_nu"], "dmv_no": ["dmf2from", "dmv2number", "dmvblockno", "dmf_nos", "dmvdno", "dmv_number", "dmvdfrom", "dmvdnos", "dmv2nos", "dmvblocknos", "dmv2from", "dmf2number", "dmv_from", "dmf_no", "dmf_from", "dmvblockfrom", "dmf2no", "dmvdnumber", "dmf_number", "dmv_nos", "dmf2nos", "dmv2no", "dmvblocknumber"], "s": ["sys", "w", "sy", "server", "ns", "ts", "sq", "sync", "self", "u", "es", "gs", "stats", "south", "share", "http", "lines", "sym", "current", "f", "service", "js", "n", "sim", "fs", "t", "native", "S", "er", "p", "m", "b", "c", "se", "x", "sports", "storage", "ds", "us", "su", "is", "spec", "one", "services", "h", "sl", "settings", "in", "g", "side", "rs", "ses", "ss", "d", "conf", "sg", "e", "session", "sb", "setup", "client", "sf", "ssl", "sc", "opt", "site", "o", "multi", "si", "os", "ls", "y", "a", "an", "v", "l"], "A": ["S", "None", "L", "An", "AF", "Va", "Ar", "AA", "Am", "P", "API", "T", "File", "H", "AT", "AW", "X", "AS", "AV", "U", "AC", "Alpha", "GA", "M", "LA", "D", "IA", "This", "AD", "Y", "SA", "Array", "G", "All", "mA", "AM", "NA", "N", "Ca", "I", "At", "CA", "W", "MA", "a", "V", "E", "AU", "And", "AB", "Ab", "AP", "AR", "As", "F"], "B": ["OB", "S", "L", "BA", "Q", "DB", "IB", "b", "K", "VB", "P", "T", "BR", "H", "Z", "BS", "SB", "X", "EB", "PB", "LB", "U", "TB", "R", "Block", "M", "Bs", "D", "BF", "Y", "WB", "NB", "Bar", "Base", "GB", "Both", "G", "N", "I", "BE", "AB", "W", "MB", "V", "QB", "E", "J", "AP", "BB", "O", "BG", "UB", "F"], "C": ["S", "L", "CE", "Q", "CL", "GC", "DC", "c", "Code", "CU", "CS", "P", "T", "KC", "Ch", "Cl", "X", "YC", "Cache", "U", "EC", "AC", "R", "M", "CC", "D", "Cu", "CW", "Y", "Config", "CNN", "CI", "CV", "G", "CT", "N", "CP", "CN", "MC", "CA", "W", "V", "E", "Cons", "VC", "Sc", "Con", "Ca", "O", "F"], "i": ["k", "z", "p", "m", "b", "c", "d", "x", "mi", "phi", "it", "e", "li", "ii", "si", "ai", "ci", "h", "I", "f", "y", "n", "ip", "index", "iu", "pi"], "j": ["k", "w", "z", "p", "b", "m", "kj", "x", "je", "jp", "aj", "em", "ji", "o", "l", "ii", "ij", "h", "y", "n", "mm", "q", "v", "J", "pos", "g"], "mx": ["cm", "nm", "ml", " mc", "m", "px", "me", "ms", "jp", "mi", "hh", "nz", "wx", "ma", "max", "cl", " m", "mn", "ij", " mm", "ga", "ng", "xp", "rx", "mm", "avier", "mu", "ap"], "my": ["md", "micro", "th", "nm", "My", "me", "Mi", "mmm", "ms", "am", "hh", "mid", "nz", "MY", "mos", "yo", "mic", "hz", "sym", "mis", "mn", "pm", "mo", "mon", "ng", "MM", "mm"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int getopt(int argc, char *argv[], char *opts)\n\n{\n\n    static int sp = 1;\n\n    int c;\n\n    char *cp;\n\n\n\n    if (sp == 1)\n\n        if (optind >= argc ||\n\n            argv[optind][0] != '-' || argv[optind][1] == '\\0')\n\n            return EOF;\n\n        else if (!strcmp(argv[optind], \"--\")) {\n\n            optind++;\n\n            return EOF;\n\n        }\n\n    optopt = c = argv[optind][sp];\n\n    if (c == ':' || (cp = strchr(opts, c)) == NULL) {\n\n        fprintf(stderr, \": illegal option -- %c\\n\", c);\n\n        if (argv[optind][++sp] == '\\0') {\n\n            optind++;\n\n            sp = 1;\n\n        }\n\n        return '?';\n\n    }\n\n    if (*++cp == ':') {\n\n        if (argv[optind][sp+1] != '\\0')\n\n            optarg = &argv[optind++][sp+1];\n\n        else if(++optind >= argc) {\n\n            fprintf(stderr, \": option requires an argument -- %c\\n\", c);\n\n            sp = 1;\n\n            return '?';\n\n        } else\n\n            optarg = argv[optind++];\n\n        sp = 1;\n\n    } else {\n\n        if (argv[optind][++sp] == '\\0') {\n\n            sp = 1;\n\n            optind++;\n\n        }\n\n        optarg = NULL;\n\n    }\n\n\n\n    return c;\n\n}\n", "idx": 1145, "substitutes": {"argc": ["axdc", "argn", " argct", "arkci", "agv", "axci", "arglc", " argdc", "argct", "axlc", "axct", "axn", " argci", "argpc", "cmdc", "argci", " argn", "arklc", "arkc", "axc", "aglc", "agc", "cmddc", " arglc", "argdc", "agf", "axpc", "axv", "axf", " argf", "cmdn", "arkpc", " argpc", "cmdct", "argf"], "argv": ["Argv", "agve", "argumentv", "argumentf", "agv", "Argve", "argsl", "Argvs", "optc", " argl", "argssv", "optp", "ArgV", "paramf", "Argsv", "axvs", "axsv", "axver", "catf", "optl", "argumentver", "catvs", "Argc", "arkf", "argV", "agvs", "argumentc", " argvs", "argsp", "argve", "arkc", "paramvs", "axp", "axc", "Argf", "catv", "argumentp", " argsv", "optv", "argl", "arkl", "agf", "axv", "Argl", "axf", "argver", "arkv", "paramv", " argf", "argsv", " argV", " argver", "Argp", "argumentV", "argsf", " argp", "argvs", "argsc", "argf", "paramsv", "catve", "argp", "paramc"], "opts": ["coptes", "OPTS", "opoptions", "OPts", "optionTS", "optes", "otts", "opercs", "copoptions", "ipTS", "ipters", "optionts", "OPters", "optioncs", "ottes", "copcs", "opTS", "opcs", "opertes", "ipts", "ipcs", "otcs", "operts", "OPcs", "copts", "otoptions", "operoptions", "opters", "optionters"], "c": ["cm", "cs", "ctx", "csv", "cc", "cl", "cpp", "r", "d", "ct", "n", "cat", "nc", "bc", "co", "cy", "chain", "k", "con", "tc", "end", "i", "ac", "m", "code", "coll", "err", "cr", "ch", "config", "C", "dc", "ce", "h", "l", "p", "xc", "cu", "e", "lc", "f", "col", "cn", "sc", " pc", "cd", "cmd", "vc", "o", "pc", "v", "s", "cit", "b", "cmp", "cf", "t", "line", "ci", "count", " rc"], "cp": ["cm", "np", "cs", "ctx", "csv", "conn", "pe", "ype", "cpp", "yp", "cat", "ap", "pg", "pn", "ph", "cop", "pb", "op", "tp", "proc", "fp", "cb", "cr", "ep", "ch", "pointer", "CP", "ip", "p", "esp", "col", "hp", "cd", "jp", "mp", "cmd", "bp", "pc", "cmp", "cf", "ci", "wp", "gp", "pp"], "optind": ["argIND", "altend", "optiminst", "optimind", "optioninst", "optionIND", "optioninder", "octInd", "mpind", "propInd", "optioninit", "optioninn", " optint", "optiondir", "optinc", "optimiss", "expinc", "altiss", "optann", "optnd", "octinn", "expind", "optinit", "optionnd", "optinst", "optionini", "octend", "combind", "optIND", "varint", "optinn", "optimann", "optinder", "optionnt", "altind", "optionid", "mpInd", "optstart", "optid", "optionstart", "optii", "optiminn", "varind", "optimnd", "combint", "optionind", "optini", "mpina", " optend", " optann", "optionint", "optiminc", "optionann", " optii", "rootInd", "vertann", "octinc", "optdir", "rootIND", "optnt", "argInd", "optimInd", "rootind", "vertind", "argind", "propind", "varinder", "optionii", "optionina", "optimint", "optimii", "optiss", " optInd", "optioniss", "optimdir", "optimend", "optionend", " optinder", "optionInd", "optina", "optiminit", "vertnd", " optnt", "expInd", "propid", "optimini", "altint", "propinn", "octii", "optend", "mpIND", "optimIND", " optinit", "octind", "optimnt", " optinn", "optimid", "optioninc", "optimstart", "optInd", "vertint", "rootini", "argina", "combdir", "combstart", "optint", " optinst", "expid"], "sp": ["SP", "sg", " sc", "ct", "nc", "sl", "j", "sf", "opt", "isp", "ind", "sw", "f", "sc", "jp", "wp", "se", "start", "pp", "pl", "osp", "sup", "spl", "yp", "type", "ap", "sh", "click", "html", "span", "ny", "asp", "gap", "fp", "sv", "p", "ptr", "esp", "Sp", "amp", "sn", "serv", "sci", " SP", "gp", "pt", "sy", "np", " esp", "skip", "ss", "pe", "bsp", "loc", "page", "py", "i", "pre", "space", "slice", "ep", "st", "cap", "bp", "inst", "si", "service", "pg", "ph", "scope", "sk", "spe", "tp", "pos", "spot", "style", "ip", "pc", "line"]}}
{"project": "qemu", "commit_id": "b21da4e504fbdb907543a918b190783dc896d8e1", "target": 1, "func": "static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n                               unsigned int epid)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    int i;\n    trace_usb_xhci_ep_disable(slotid, epid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n    slot = &xhci->slots[slotid-1];\n    if (!slot->eps[epid-1]) {\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n        return CC_SUCCESS;\n    xhci_ep_nuke_xfers(xhci, slotid, epid);\n    epctx = slot->eps[epid-1];\n    if (epctx->nr_pstreams) {\n        xhci_free_streams(epctx);\n    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n    timer_free(epctx->kick_timer);\n    g_free(epctx);\n    slot->eps[epid-1] = NULL;\n    return CC_SUCCESS;", "idx": 9189, "substitutes": {"xhci": [" xhsci", " xphdc", "sexhlci", " xwsci", "xhcci", "xbhcit", "workhscu", "xbhcu", "Xhcci", "sexhcit", "xhlcin", "xehdc", "xhrcci", " xhcm", "xihcm", "xrhcit", "Xehcin", "xehsci", "xrhci", " xhco", "xrhcu", "xrhii", "xhlci", "xwsci", " xphcm", "xhscu", "xbhii", " xwci", "xhsri", " xhcci", "workhca", "xhii", " xphco", "Xehri", "xhcu", "xphco", "xehci", "xwri", "workhci", "Xhci", "xhlcit", "xhdc", "xehri", "xhtri", "xehcm", "xphdc", "xhrco", "xhtca", "xhtcu", "xwci", "xphcm", "Xehcci", "xhlii", "sexhci", "xihco", "xhtci", "xhcit", "xwcci", "xhsci", "xhco", "xhlri", "xwcu", "xhhcci", "Xehci", "xhhcin", "xbhci", "xhhci", "xhsca", "Xhri", "xehcci", "xihci", "sexhlcit", "xhri", "xhrsci", " xphci", "sexhlii", "xhrci", " xhdc", "workhsca", "workhcu", "sexhlcu", " xwco", "xhlcci", "xphci", "xehco", "xhca", "sexhcu", "sexhii", "xwca", "workhri", "xhcin", "xehcin", "Xhcin", "xwco", "workhsci", "xihdc", "xhlcu", "xhhri", "xhcm", " xwcci", "workhsri"], "slotid": ["slotname", " slotinfo", " slotno", "lotide", "slotinfo", "spotno", " slotId", "lotid", "spotid", " slotname", "socketname", "lotId", "socketno", "lotno", "spotname", "lotinfo", "spotId", "slotide", "spotinfo", "spotide", "socketid", "slotno", "lotname", "socketide", "slotId"], "epid": ["apId", "ekids", "apin", "epin", "oppath", "ppId", "ypID", "opid", "epnum", "evit", "ekId", "epsId", "espip", " epnum", " ep1", " epID", " epkid", "epx", "ekkid", "taskkid", "ypids", "amppid", " epin", "opx", "ep1", "ppit", "ppID", "eppid", "eppath", "lipid", "ypi", "epsID", "apid", "epi", "lip1", "epsi", "epID", "taskid", "epaid", "yppid", "ipit", "epkid", "ipkid", "eknum", "lipip", "ekx", "ipid", "ampid", "epId", "apkid", "epsid", "ampaid", "ipip", "ewId", " epId", "ampip", "yppath", " epit", "espit", "ekpath", "ekid", "epsit", "ewkid", "ipnum", "ppi", "ypid", " epip", " epaid", "opids", "ppid", "ypip", "ypit", "evId", "epspid", "ip1", "ipID", "espid", "ewin", "ppaid", "epids", "ypaid", "epip", "evid", "tasknum", "taskId", "ewid", "evi", "ypx", "epsip", "espID", " epi", "lipnum", "epsaid", "ipId", "epit"], "slot": ["lot", "channel", "shot", "session", "ion", "boot", "spot", "timeout", "tab", "kernel", "blog", "section", "shell", "Slot", "trial", "pit", "game", "tz", "job", "pool", "serv", "service", "server", "layout", "target", "role", "loc", "table", "socket", "slave", "rot", "entry", "profile", "slice", "lib", "module", "zone", "rol", "connection", "account", "sl", "option", "margin", "offset", "plugin", "cat", "lock", "hole", "li", "loop", "sit", "bin", "lc", "cell", "pot", "pty", "pin"], "epctx": ["eccf", "mpconn", "mploc", "mpcb", "ppconn", "ypcontext", "eccontext", "eccb", "ypcf", "EPtx", "mpcor", "ypconn", "ppctx", "ppcor", "EPcontext", "Epcmp", "ewcm", "EPctx", "ekctrl", "pctx", "ypctx", "ekcmd", "mpcontext", "ypcm", "yploc", "epctrl", "eptx", "EPcmp", "epcmp", "ipctx", "yptx", "pcontext", "iploc", "epcf", "ppcf", "mpcm", "ekconn", "ekctx", "mpctrl", "epcm", "Epcmd", "ekcmp", "ypcb", "ppcontext", "ewloc", "ptx", "eploc", "mptx", "ekcontext", "ecctx", "ipcmd", "ewctx", "pptx", "ecconn", "ekloc", " epctrl", "ipcmp", " epcontext", "Eploc", "mpcmp", "Epctx", "epcb", "ypcor", "ewcontext", " epconn", "epcor", "epconn", "pcmp", "epcmd", "epcontext", "mpctx"], "i": ["l", "it", "is", "n", "in", "id", "b", "k", "d", "c", "p", " I", "e", "or", "f", "j", "ai", "o", "ic", "r", "pi", "h", "I", "ip", "a", "io", "ri"]}}
{"project": "FFmpeg", "commit_id": "38d553322891c8e47182f05199d19888422167dc", "target": 1, "func": "int av_image_alloc(uint8_t *pointers[4], int linesizes[4],\n\n                   int w, int h, enum PixelFormat pix_fmt, int align)\n\n{\n\n    int i, ret;\n\n    uint8_t *buf;\n\n\n\n    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < 4; i++)\n\n        linesizes[i] = FFALIGN(linesizes[i], align);\n\n\n\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)\n\n        return ret;\n\n    buf = av_malloc(ret + align);\n\n    if (!buf)\n\n        return AVERROR(ENOMEM);\n\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {\n\n        av_free(buf);\n\n        return ret;\n\n    }\n\n    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)\n\n        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);\n\n\n\n    return ret;\n\n}\n", "idx": 18438, "substitutes": {"pointers": ["angles", "tips", "limits", "roots", "styles", "pieces", "pages", "fields", "weights", "faces", "ports", "cuts", "ices", "details", " pointer", "ips", "toc", "points", "ints", "wcs", "padding", "ctx", "rh", "ptr", "pos", "posts", "lines", "xs", "pointer", "rings", "balls", "path", "offs", "codes", "pins", "maps", "amps", "steps", "thumbnails", "ps", "rows", "p", "pad", "books", "tracks", "ipes", "holes", "parts", "cases", "opens", "sets", "notes", "inters", "eps", "locks"], "linesizes": [" linesamples", "lesizes", "linedizes", "linizations", "linsamples", "lineizers", " linesets", " linesizing", "lesizing", "linedizing", "lineizing", " linesize", "linesets", "lesizations", "inesizations", "inesamples", "linsizers", "inesets", "linesizations", "linesizers", "linets", "linedizations", "linsizes", "linizes", " linesizers", "linsizations", "inesizers", "linedize", "linsize", "lesamples", "linesamples", "lineizes", "linesizing", "lineizations", "inesizes", "linizers", "linesize", "lineize", "linizing", " linesizations", "linedamples", "linsizing"], "w": ["m", "wt", "fw", "s", "x", "f", "wrap", "all", "r", "n", "we", "window", "sw", "z", "max", "wb", "wd", "ew", "o", "l", "d", "hw", "W", "v", "temp", "c", "nw", "p", "rw", "b", "win", "wh", "wa", "aw", "a", "y", "u"], "h": ["m", "offset", "ch", "t", "x", "f", "oh", "hr", "r", "n", "gh", "g", "hi", "hd", "z", "rh", "loc", "padding", "uh", "help", "pointer", "head", "host", "l", "hw", "ht", "sh", "path", "height", "q", "bh", "v", "ih", "c", "cl", "p", "hm", "b", "hh", "ph", "ha", "hs", "ah", "H", "y", "u"], "pix_fmt": ["pix2frMT", "pix_tfprintf", "pix_funformat", "pix_frmt", "pix_frrt", "pix_formmat", "pix_lprintf", "pix_freemat", "pix_lrt", "pix_formkt", "pix_tfkt", "pix_fformat", "pix_formmt", "pix2fMT", "pix_fcMT", "pix_frformat", "pix_freert", "pix_fMT", "pix2frmt", "pix_freemt", "pix_fcformat", "pix_formMT", "pix_funkt", "pix_fkt", "pix_lmt", "pix_formrt", "pix2frformat", "pix_tfformat", "pix_frt", "pix_lmat", "pix_fcmt", "pix2frt", "pix_fmat", "pix_lformat", "pix2frrt", "pix_lMT", "pix_formformat", "pix_frMT", "pix_freeformat", "pix_funmt", "pix_fprintf", "pix_tfmt", "pix_fcprintf", "pix2fformat", "pix2fmt", "pix_tfrt", "pix_funMT", "pix_tfMT"], "align": ["IGN", "offset", "work", "ff", "mag", "al", "f", "ref", "x", "wrap", "ail", "coord", "border", "pixel", "angle", "padding", "aligned", "help", "xff", "ign", "balance", "margin", "array", " alignment", "format", "size", "alias", "ignment", "style", "adjust", "img", "lace", "arrow", "ag", "shift", "pad", "cache", "addr", "aff", "diff", "attr", "amp", "len"], "i": ["gi", "ti", "uri", "m", "j", "s", "t", "x", "f", "ix", "ini", "qi", "r", "io", "ai", "n", "phi", "type", "z", "ii", "in", "iu", "di", "ind", "index", "I", "multi", "zi", "o", "ip", "l", "d", "oi", "pi", "ui", "ci", "id", "e", "k", "v", "c", "ni", "si", "ri", "p", "xi", "b", "it", "eni", "fi", "y", "li", "ib", "u"], "ret": ["entry", "offset", "obj", "ref", "nt", "debug", "result", "run", "replace", "att", "feat", "reset", "id", "buff", "rev", "hard", "rep", "opt", "res", "end", "fi", "len", "part", "ff", "fat", "fun", "usr", "fin", "count", "arg", "art", "plain", "Ret", "bf", "cat", "RET", "pet", "ft", "status", "f", "base", "alt", "lit", "rt", "match", "mem", "bad", "val", "re", "aux", "ru", "back", "addr", "value", "reply", "success", "af", "wrap", "let", "buffer", "reg", "flag", "pass", "ext", "def", "rets", "prop", "complete", "fail", "img", "fd", "rb", "error", "nz", "red", "proc", "uf"], "buf": ["Buffer", "ab", "offset", "br", "ff", "data", "fp", "obj", "f", "ref", "func", "pool", "buffer", "rc", "vec", "lit", "fun", "result", "cb", "bc", "src", "Buff", "loc", "wb", "ctx", "pb", "ptr", "lb", "mem", "ba", "cas", "xff", "aux", "box", "back", "img", "queue", "bd", "fd", "buff", "fb", "v", "temp", "cur", "tmp", "seq", "rb", "uc", "off", "pad", "plug", "b", "alloc", "port", "bag", "callback", "uf", "cv"]}}
{"project": "FFmpeg", "commit_id": "c96f3750c22ef1576a46140f3101e3585041f41f", "target": 0, "func": "pp_mode *pp_get_mode_by_name_and_quality(const char *name, int quality)\n\n{\n\n    char temp[GET_MODE_BUFFER_SIZE];\n\n    char *p= temp;\n\n    static const char filterDelimiters[] = \",/\";\n\n    static const char optionDelimiters[] = \":\";\n\n    struct PPMode *ppMode;\n\n    char *filterToken;\n\n\n\n    ppMode= av_malloc(sizeof(PPMode));\n\n\n\n    ppMode->lumMode= 0;\n\n    ppMode->chromMode= 0;\n\n    ppMode->maxTmpNoise[0]= 700;\n\n    ppMode->maxTmpNoise[1]= 1500;\n\n    ppMode->maxTmpNoise[2]= 3000;\n\n    ppMode->maxAllowedY= 234;\n\n    ppMode->minAllowedY= 16;\n\n    ppMode->baseDcDiff= 256/8;\n\n    ppMode->flatnessThreshold= 56-16-1;\n\n    ppMode->maxClippedThreshold= 0.01;\n\n    ppMode->error=0;\n\n\n\n    memset(temp, 0, GET_MODE_BUFFER_SIZE);\n\n    av_strlcpy(temp, name, GET_MODE_BUFFER_SIZE - 1);\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"pp: %s\\n\", name);\n\n\n\n    for(;;){\n\n        char *filterName;\n\n        int q= 1000000; //PP_QUALITY_MAX;\n\n        int chrom=-1;\n\n        int luma=-1;\n\n        char *option;\n\n        char *options[OPTIONS_ARRAY_SIZE];\n\n        int i;\n\n        int filterNameOk=0;\n\n        int numOfUnknownOptions=0;\n\n        int enable=1; //does the user want us to enabled or disabled the filter\n\n\n\n        filterToken= strtok(p, filterDelimiters);\n\n        if(filterToken == NULL) break;\n\n        p+= strlen(filterToken) + 1; // p points to next filterToken\n\n        filterName= strtok(filterToken, optionDelimiters);\n\n        av_log(NULL, AV_LOG_DEBUG, \"pp: %s::%s\\n\", filterToken, filterName);\n\n\n\n        if(*filterName == '-'){\n\n            enable=0;\n\n            filterName++;\n\n        }\n\n\n\n        for(;;){ //for all options\n\n            option= strtok(NULL, optionDelimiters);\n\n            if(option == NULL) break;\n\n\n\n            av_log(NULL, AV_LOG_DEBUG, \"pp: option: %s\\n\", option);\n\n            if(!strcmp(\"autoq\", option) || !strcmp(\"a\", option)) q= quality;\n\n            else if(!strcmp(\"nochrom\", option) || !strcmp(\"y\", option)) chrom=0;\n\n            else if(!strcmp(\"chrom\", option) || !strcmp(\"c\", option)) chrom=1;\n\n            else if(!strcmp(\"noluma\", option) || !strcmp(\"n\", option)) luma=0;\n\n            else{\n\n                options[numOfUnknownOptions] = option;\n\n                numOfUnknownOptions++;\n\n            }\n\n            if(numOfUnknownOptions >= OPTIONS_ARRAY_SIZE-1) break;\n\n        }\n\n        options[numOfUnknownOptions] = NULL;\n\n\n\n        /* replace stuff from the replace Table */\n\n        for(i=0; replaceTable[2*i]!=NULL; i++){\n\n            if(!strcmp(replaceTable[2*i], filterName)){\n\n                int newlen= strlen(replaceTable[2*i + 1]);\n\n                int plen;\n\n                int spaceLeft;\n\n\n\n                if(p==NULL) p= temp, *p=0;      //last filter\n\n                else p--, *p=',';               //not last filter\n\n\n\n                plen= strlen(p);\n\n                spaceLeft= p - temp + plen;\n\n                if(spaceLeft + newlen  >= GET_MODE_BUFFER_SIZE - 1){\n\n                    ppMode->error++;\n\n                    break;\n\n                }\n\n                memmove(p + newlen, p, plen+1);\n\n                memcpy(p, replaceTable[2*i + 1], newlen);\n\n                filterNameOk=1;\n\n            }\n\n        }\n\n\n\n        for(i=0; filters[i].shortName!=NULL; i++){\n\n            if(   !strcmp(filters[i].longName, filterName)\n\n               || !strcmp(filters[i].shortName, filterName)){\n\n                ppMode->lumMode &= ~filters[i].mask;\n\n                ppMode->chromMode &= ~filters[i].mask;\n\n\n\n                filterNameOk=1;\n\n                if(!enable) break; // user wants to disable it\n\n\n\n                if(q >= filters[i].minLumQuality && luma)\n\n                    ppMode->lumMode|= filters[i].mask;\n\n                if(chrom==1 || (chrom==-1 && filters[i].chromDefault))\n\n                    if(q >= filters[i].minChromQuality)\n\n                            ppMode->chromMode|= filters[i].mask;\n\n\n\n                if(filters[i].mask == LEVEL_FIX){\n\n                    int o;\n\n                    ppMode->minAllowedY= 16;\n\n                    ppMode->maxAllowedY= 234;\n\n                    for(o=0; options[o]!=NULL; o++){\n\n                        if(  !strcmp(options[o],\"fullyrange\")\n\n                           ||!strcmp(options[o],\"f\")){\n\n                            ppMode->minAllowedY= 0;\n\n                            ppMode->maxAllowedY= 255;\n\n                            numOfUnknownOptions--;\n\n                        }\n\n                    }\n\n                }\n\n                else if(filters[i].mask == TEMP_NOISE_FILTER)\n\n                {\n\n                    int o;\n\n                    int numOfNoises=0;\n\n\n\n                    for(o=0; options[o]!=NULL; o++){\n\n                        char *tail;\n\n                        ppMode->maxTmpNoise[numOfNoises]=\n\n                            strtol(options[o], &tail, 0);\n\n                        if(tail!=options[o]){\n\n                            numOfNoises++;\n\n                            numOfUnknownOptions--;\n\n                            if(numOfNoises >= 3) break;\n\n                        }\n\n                    }\n\n                }\n\n                else if(filters[i].mask == V_DEBLOCK   || filters[i].mask == H_DEBLOCK\n\n                     || filters[i].mask == V_A_DEBLOCK || filters[i].mask == H_A_DEBLOCK){\n\n                    int o;\n\n\n\n                    for(o=0; options[o]!=NULL && o<2; o++){\n\n                        char *tail;\n\n                        int val= strtol(options[o], &tail, 0);\n\n                        if(tail==options[o]) break;\n\n\n\n                        numOfUnknownOptions--;\n\n                        if(o==0) ppMode->baseDcDiff= val;\n\n                        else ppMode->flatnessThreshold= val;\n\n                    }\n\n                }\n\n                else if(filters[i].mask == FORCE_QUANT){\n\n                    int o;\n\n                    ppMode->forcedQuant= 15;\n\n\n\n                    for(o=0; options[o]!=NULL && o<1; o++){\n\n                        char *tail;\n\n                        int val= strtol(options[o], &tail, 0);\n\n                        if(tail==options[o]) break;\n\n\n\n                        numOfUnknownOptions--;\n\n                        ppMode->forcedQuant= val;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        if(!filterNameOk) ppMode->error++;\n\n        ppMode->error += numOfUnknownOptions;\n\n    }\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"pp: lumMode=%X, chromMode=%X\\n\", ppMode->lumMode, ppMode->chromMode);\n\n    if(ppMode->error){\n\n        av_log(NULL, AV_LOG_ERROR, \"%d errors in postprocess string \\\"%s\\\"\\n\", ppMode->error, name);\n\n        av_free(ppMode);\n\n        return NULL;\n\n    }\n\n    return ppMode;\n\n}\n", "idx": 16452, "substitutes": {"name": ["part", "time", "code", "data", "info", "search", "base", "image", "comment", "ame", "n", "current", "block", "anc", "type", "max", "package", "Name", "filename", "label", "NAME", "alias", "new", "path", "size", "space", "memory", "w", "prefix", "key", "named", "q", "config", "length", "id", "v", "parent", "table", "address", "none", "resource", "names", "word", "version"], "quality": ["scale", "quant", " q", "base", "qual", "quiet", "query", "resolution", "Q", "priority", "Quality", "val", "secure", "format", "grade", " qual", "style", "comp", "q", "qa", "depth", "lock", "level", "weight", "valid", "value", "custom", "version"], "temp": ["pt", "dc", "wp", "Temp", "tem", "content", "t", "data", "base", "wrap", "pool", "buffer", "try", "str", "current", "block", "clean", "type", "method", "var", "cp", "package", "sw", "font", "zip", "mem", "copy", "enc", "fake", "context", "flat", "empty", "format", "path", "pre", "memory", "cel", "tc", "config", "pipe", "ex", "v", "EMP", "tmp", "c", "cur", "table", "emp", "test", "cache", "lock", "null", "output", "col", "form", "storage", "opt", "template", "iter", "source", "params", "input"], "p": ["pc", "m", "offset", "s", "j", "t", "data", "fp", "f", "jp", "sp", "r", "pe", "n", "g", "cp", "lp", "y", "pos", "l", "d", "array", "pp", "path", "pi", "pre", "start", "e", "q", "v", "c", "ps", "b", "pr", "h", "a", "tp", "php", "port", "it", "np", "params", "P"], "filterDelimiters": ["filterDeligniterers", "filterDelimitars", "filterDelimitserers", "filterDelimitearies", "filterDelignitserers", "filterDelimitings", "filterDelimiteings", "filterDelimalaries", "filterDelimiterters", "filterDelititerers", "filterDelititings", "filterDelignitsers", "filterDelimalers", "filterDelimiteters", "filterDelimitizars", "filterDelimalings", "filterDelititters", "filterDelititaries", "filterDelimitters", "filterDelimiteers", "filterDelimalters", "filterDelimitizerers", "filterDelimitears", "filterDelimitizings", "filterDelimitsers", "filterDelimitsings", "filterDelimitizers", "filterDelignitsars", "filterDelignitsings", "filterDelimitsars", "filterDelititers", "filterDelimiterings", "filterDelimitaries", "filterDeligniters", "filterDelignitings", "filterDelititeraries", "filterDelititerings", "filterDelimiterers", "filterDelimiteerers", "filterDelititerters", "filterDelimiteraries", "filterDelignitars"], "optionDelimiters": ["optionDelimimers", "optionDelimitererers", "optionDelititters", "optionDelamiterers", "optionDelimitedERS", "optionDelaritters", "optionDelititereners", "optionDelimITERS", "optionDelimitators", "optionDelimiteners", "optionDelamiters", "optionDelamitators", "optionDelimimerers", "optionDelimitters", "optionDelititerers", "optionDelimitereners", "optionDelimimators", "optionDelamitedERS", "optionDelariters", "optionDelimITers", "optionDelimITeners", "optionDelimitedeners", "optionDelititeners", "optionDelimiterer", "optionDelimiteders", "optionDelimITer", "optionDelititerters", "optionDelimitERS", "optionDelimiteder", "optionDelimimer", "optionDelimiterators", "optionDelimitederers", "optionDelititers", "optionDelariter", "optionDelaritERS", "optionDelititer", "optionDelimimters", "optionDelimiterERS", "optionDelimitedators", "optionDelarITer", "optionDelamiteders", "optionDelarITers", "optionDelamitedators", "optionDelarITERS", "optionDelarITters", "optionDelimitedters", "optionDelimiter", "optionDelititerer", "optionDelamitederers", "optionDelimiterters", "optionDelamitERS", "optionDelimimERS", "optionDelimiterers", "optionDelimITters"], "ppMode": ["ppEngine", " ppStream", "pMo", "ppOwner", "ppaMODE", " ppStatus", "ppStream", " ppModel", "cppEntry", "cppModel", "ppHalf", "wpConfig", "PPCopy", "PPRole", "PPMode", "PPKind", "cppMo", "ppManager", "ppaConfig", "ppConfig", "ppsManager", "wpMODE", "ppStatus", " ppCmd", "plModel", "ppKind", "ppaManager", "phpModule", "ppsMac", "cppSync", " ppDevice", "ppsModule", "ppMac", "ppCmd", "ppModule", "pxInfo", "ppSync", "bbDevice", "ampMode", "phpMo", "bbMode", "bbHalf", "ampEntry", "cppKind", "ppsEngine", "PPCmd", "peBlock", " ppBlock", "wpMode", "peModule", " ppMo", " ppCopy", " ppKind", " ppHalf", "ppsInfo", "ampMo", "pModule", "ppRole", "PPOwner", "wpCmd", "bbModule", "ppInfo", "pKind", "cppInfo", "cppMac", "PPManager", "pMode", "ppModel", " ppModule", " ppMODE", " ppEngine", "cppMask", "ppEntry", "pOwner", "PPMODE", "pCmd", "peMode", "cppMode", "pMech", "cppDevice", "ppaMode", "ppDevice", "ppMo", "phpMech", "bbSync", "PPModule", "pxMode", "plMode", "ppMech", "pStatus", "cppManager", "ppaMo", "ampManager", "ppMask", "pxModule", "ppBlock", "ppsRole", "PPMac", "ppaCmd", "ppMODE", "plStream", "PPEngine", "cppHalf", "cppCmd", " ppOwner", "cppConfig", "plKind", "pCopy", "ppsMask", "PPModel", " ppSync", "ppaEntry", "cppModule", "ppsMode", "peStatus", "pxMask", "pBlock", " ppMech", "cppRole", " ppManager", "ppCopy", "PPStream", "bbCmd", "cppMODE", "phpMode"], "filterToken": ["searchTokens", "filterTokens", "searchByte", "searchoken", "finaltoken", " filtertoken", "filValue", "outputName", "FilterTokens", "filterMin", "sortTokens", "filName", " filterByte", "filtertoken", "filtoken", "filTokens", " filterCode", "filToken", "outputKey", "filterKey", "sortCode", "sortName", " filterMin", "filterByte", " filterKey", "filCode", "searchName", "filoken", "outputValue", "FilterName", "filteroken", "finalToken", " filterTokens", " filterValue", "filKey", "sortToken", " filteroken", "filterCode", "filMin", "searchNode", "filterValue", "searchToken", "outputToken", "filByte", "filNode", "finalName", "finalMin", "FilterToken", " filterNode", "filterNode"], "filterName": ["searchname", "classToken", "formatText", "sortname", "filString", "formatToken", "formatname", " filterNo", "filName", " filterInfo", "filterNo", "FilterInfo", "sortNo", "filname", " filterCode", "channelname", "filToken", "maskCode", "filterText", " filterText", "sortName", " filterString", "channelName", "filtername", "formatName", "searchName", "FilterName", "maskInfo", "FilterPart", "filterString", "filPart", "sortToken", "FilterCode", "filterInfo", "classname", "channelText", " filterPart", "FilterString", "filterCode", "maskName", "channelToken", "searchToken", " filtername", "classNo", "filterPart", "FilterToken", "className", "maskToken"], "option": ["ion", "term", "archive", "user", "optional", "element", "token", "attribute", "op", "comment", "Option", "image", "choice", "color", "block", "cho", "type", "match", "package", "optim", "public", "function", "attr", "object", "equ", "other", "profile", "change", "alias", "original", "event", "text", "value", "key", "open", "update", "position", "argument", "item", "resource", "route", "opt", "connection", "ption", "operation", "section", "custom", "expression"], "options": ["classes", "values", "s", "optional", "settings", "eps", "times", "objects", "files", "ops", "object", "other", "array", "args", "config", "cache", "multiple", "opt", "names", "errors", "groups", "Options", "value", "params"], "OPTIONS_ARRAY_SIZE": ["OPTIONS_AROW_USE", "OPTIONS_AROW_MODE", "OPTIONS_AROW_SIZE", "OPTIONS_AROW_SEC", "OPTIONS_ARRAY_SEC", "OPTIONS_ARRAY_USE", "OPTIONS_ARRAY_MODE"], "i": ["m", "j", "info", "f", "n", "ii", "in", "di", "index", "I", "is", "ip", "l", "d", "pi", "ci", "id", "start", "e", "c", "ni", "b", "h", "it", "li", "u"], "numOfUnknownOptions": ["numOfUnknownOP", "numOfUnknownParts", "numOfKnownOption", "numofunknownOptions", "numofunknownParts", "numofUnknownOP", "numofunknownOption", "numOfunknownParts", "numofUnknownOption", "numofunknownOP", "numOfNewOptions", "numOfUnknownOption", "numOfKnownOptions", "numofUnknownOptions", "numOfNewOP", "numofUnknownParts", "numOfNewParts", "numOfunknownOP", "numOfunknownOptions", "numOfKnownOP", "numOfunknownOption", "numOfNewOption", "numOfKnownParts"], "error": ["code", "data", "info", "err", "call", "comment", "debug", "version", "result", "query", "block", "type", "close", "layer", "grade", "fail", "last", "delay", "batch", "parent", "loss", "patch", "row", "errors", "Error", "progress", "success", "warning", "bug"]}}
{"project": "FFmpeg", "commit_id": "f566ac48ce450b013ffd5547ace48df8c47981c6", "target": 0, "func": "static int get_video_buffer(AVFrame *frame, int align)\n\n{\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);\n\n    int ret, i;\n\n\n\n    if (!desc)\n\n        return AVERROR(EINVAL);\n\n\n\n    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)\n\n        return ret;\n\n\n\n    if (!frame->linesize[0]) {\n\n        ret = av_image_fill_linesizes(frame->linesize, frame->format,\n\n                                      frame->width);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        for (i = 0; i < 4 && frame->linesize[i]; i++)\n\n            frame->linesize[i] = FFALIGN(frame->linesize[i], align);\n\n    }\n\n\n\n    for (i = 0; i < 4 && frame->linesize[i]; i++) {\n\n        int h = FFALIGN(frame->height, 32);\n\n        if (i == 1 || i == 2)\n\n            h = -((-h) >> desc->log2_chroma_h);\n\n\n\n        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);\n\n        if (!frame->buf[i])\n\n            goto fail;\n\n\n\n        frame->data[i] = frame->buf[i]->data;\n\n    }\n\n    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {\n\n        av_buffer_unref(&frame->buf[1]);\n\n        frame->buf[1] = av_buffer_alloc(1024);\n\n        if (!frame->buf[1])\n\n            goto fail;\n\n        frame->data[1] = frame->buf[1]->data;\n\n    }\n\n\n\n    frame->extended_data = frame->data;\n\n\n\n    return 0;\n\nfail:\n\n    av_frame_unref(frame);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 2049, "substitutes": {"frame": ["figure", "video", "code", "file", "event", "framework", "feed", "iframe", "self", "force", "f", "plot", "object", "play", "ze", "zone", "board", "flow", "unit", "ise", "cycle", "Frame", "sequence", "host", "image", "position", "vert", "html", "parent", "dom", "model", "update", "component", "frames", "parse", "fe", "state", "layout", "e", "die", "flower", "scale", "load", "player", "family", "layer", "base", "scene", "version", "build", "fram", "data", "boot", "slice", "document", "live", "fake", "function", "setup", "design", "ide", "date", "fx", "node", "module", "cf", "rule", "series", "buffer", "def", "window", "header", "co", "show", "coll", "df", "fr", "style", "bug", "feature", "word", "block", "draw", "range", "point", "fb", "plane", "element", "hide", "full", "line", "motion", "view", "part", "table", "game"], "align": ["offset", "ext", "adjust", "binary", "amin", "alt", "ignment", "margin", "format", "ign", "arr", "style", "replace", "pad", "work", "x", "aligned", "aff", "balance", "len", "repeat", "length", "angle", "join", "aug", "padding", "border", "al", "addr", " alignment", "val", "lead", "diff", "in"], "desc": ["layer", "sub", "fd", "src", "ctx", "ext", "def", "esc", "spec", "conn", "dim", "txt", "loc", "d", "rec", "bc", "dict", "der", "env", "de", "enc", "des", "proc", "code", "info", "dep", "cb", "df", "config", "func", "asc", "description", "cod", "dc", "ec", "or", "doc", "diff", "lc", "design", "Desc", "ref", "col", "sc", "decl", "ca", "summary", "disc", "comment", "sec", "meta", "dir", "dist"], "ret": ["arg", "success", "alt", "rep", "code", "err", "replace", "Ret", "opt", "reset", "f", "en", "RET", "rt", "fun", "format", "rets", "fit", "end", "arr", "fail", "rc", "sr", "lit", "re", "val", "det", "nat", "att", "mt", "data", "xt", "out", "cat", "wrap", "back", "result", "fin", "ut", "len", "ref", "value", "obj", "error", "reg", "run", "res", "bad", "mem", "match", "test", "def", "bit", "cur", "it", "rb", "entry", "nt", "ft", "aud", "bf", "pret", "flag", "art", "std", "al"], "i": ["cli", "yi", "li", "gi", "a", "ni", "ii", "ui", "pi", "oi", "d", "I", "n", "di", "is", "id", "mi", "it", "iu", "k", "api", "j", "y", "g", "ri", "m", "eni", "anti", "info", "ti", "slice", "ini", "index", "multi", "z", "hi", "ai", "ie", "ip", "h", "x", "p", "l", "bi", "c", "e", "phi", "f", "lc", "u", "ori", "ki", "v", "o", "s", "qi", "b", "ix", "t", "uri", "ci", "io", "fi", "si", "in", "xi"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,\n\n\tunsigned int width, unsigned int height,\n\n\tint lumStride, int chromStride, int srcStride)\n\n{\n\n\tunsigned y;\n\n\tconst unsigned chromWidth= width>>1;\n\n\tfor(y=0; y<height; y+=2)\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\tasm volatile(\n\n\t\t\t\"xor %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\t\"pcmpeqw %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"psrlw $8, %%mm7\t\t\\n\\t\" // FF,00,FF,00...\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 64(%0, %%\"REG_a\", 4)\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\", 4), %%mm0\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq 8(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // U0V0 U0V0(0)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // U0V0 U0V0(4)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(0)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(4)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(0)\n\n\n\n\t\t\tMOVNTQ\" %%mm2, (%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"movq 16(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq 24(%0, %%\"REG_a\", 4), %%mm2\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq %%mm2, %%mm4\t\t\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // U0V0 U0V0(8)\n\n\t\t\t\"psrlw $8, %%mm2\t\t\\n\\t\" // U0V0 U0V0(12)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(8)\n\n\t\t\t\"pand %%mm7, %%mm4\t\t\\n\\t\" // Y0Y0 Y0Y0(12)\n\n\t\t\t\"packuswb %%mm2, %%mm1\t\t\\n\\t\" // UVUV UVUV(8)\n\n\t\t\t\"packuswb %%mm4, %%mm3\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm3, 8(%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // UVUV UVUV(8)\n\n\t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // V0V0 V0V0(0)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // V0V0 V0V0(8)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // U0U0 U0U0(0)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // U0U0 U0U0(8)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // VVVV VVVV(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // UUUU UUUU(0)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, (%2, %%\"REG_a\")\t\\n\\t\"\n\n\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth)\n\n\t\t\t: \"memory\", \"%\"REG_a\n\n\t\t);\n\n\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tasm volatile(\n\n\t\t\t\"xor %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 64(%0, %%\"REG_a\", 4)\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\", 4), %%mm0\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq 8(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"movq 16(%0, %%\"REG_a\", 4), %%mm2\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq 24(%0, %%\"REG_a\", 4), %%mm3\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"pand %%mm7, %%mm0\t\t\\n\\t\" // Y0Y0 Y0Y0(0)\n\n\t\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\" // Y0Y0 Y0Y0(4)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(8)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(12)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // YYYY YYYY(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%1, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, 8(%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth)\n\n\t\t\t: \"memory\", \"%\"REG_a\n\n\t\t);\n\n#else\n\n\t\tunsigned i;\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+0];\n\n\t\t\tudst[i] \t= src[4*i+1];\n\n\t\t\tydst[2*i+1] \t= src[4*i+2];\n\n\t\t\tvdst[i] \t= src[4*i+3];\n\n\t\t}\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+0];\n\n\t\t\tydst[2*i+1] \t= src[4*i+2];\n\n\t\t}\n\n#endif\n\n\t\tudst += chromStride;\n\n\t\tvdst += chromStride;\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\t}\n\n#ifdef HAVE_MMX\n\nasm volatile(   EMMS\" \\n\\t\"\n\n        \tSFENCE\" \\n\\t\"\n\n        \t:::\"memory\");\n\n#endif\n\n}\n", "idx": 16190, "substitutes": {"src": ["RC", "rib", "sys", "gz", "bc", "dist", "tmp", "rc", "config", "cdn", "rs", "iv", "source", "hub", "obl", "sr", "sq", "sit", "loc", "dest", "sil", "sound", "gl", "lib", "img", "rb", "sec", "ctx", "sb", "jpg", "inst", "scl", "stat", "gb", "spec", "rl", "url", "sci", "ssl", "rob", "sc", "sl", "rect", "sub", "sel", "cur", "ruby", "gal", "filename"], "ydst": ["dyst", "hdost", "hdstr", "iddST", "hdst", "ynsta", "iddstr", "ydstr", "ecdST", "hdest", "hdrest", "xdST", "eyst", "ynost", "dyost", "ynSt", "hdsta", "ecdstr", "ydost", "ydST", "iddbl", "dyrest", "ecdst", "hdSt", "xdstr", "dystr", "ydrest", "dySt", "ynst", "xdst", "ydest", "iddst", "eyest", "eyrest", "eystr", "ydsta", "xdbl", "dyest", "ydbl", "dysta", "ydSt", "ecdbl"], "udst": ["ddst", "hdost", "vdbl", "udast", "hdst", "udbl", "udost", "UDst", "hdast", "ddST", "UDbl", "udST", "hdST", "vdast", "ddost", "vdST", "vdost", "ddast", "UDost", "UDST", "ddbl"], "vdst": ["hdost", "iddST", "hdst", "udest", "udost", "hdest", "xdST", "hdset", "vdset", "udsrc", "iddsrc", "vdest", "vdsrc", "xdset", "xdest", "hdST", "iddset", "vdST", "vdost", "xdst", "hdsrc", "iddst", "iddost", "iddest"], "height": ["stroke", "Height", "d", "thin", "bottom", "level", "density", "shape", "style", "def", "h", "x", "crop", "rows", "w", "size", "images", "max", "length", "th", "padding", "resolution", "ensions", "diff", "holes", "dim", "layout", "window", "ty", "depth"], "lumStride": ["lUMStride", "lumsCride", "lumShuse", "lUMPrite", "lumsCrict", "lumstrite", "lumPride", "lUMStrite", "lUMPride", "lumstride", "lUMPr", "lumsStrict", "lumsCuse", "lumPerve", "lumSTride", "lumCrite", "lumsStrite", "lumShrite", "lumPrite", "lumCrict", "lumsCrite", "lumShride", "lumShrict", "lumsterve", "lumStr", "lumsStride", "lumSTrite", "lumsStuse", "lumStuse", "lumStrict", "lumPr", "lumSTerve", "lUMPerve", "lumCuse", "lumSterve", "lumstr", "lumSTr", "lUMStr", "lumCride", "lumStrite", "lUMSterve"], "chromStride": ["chromContrip", "romstrip", "romStipe", "chromScrip", "chromstipe", "chromScrite", "chromstrip", "chromContipe", "chromStrite", "chromstride", "chromStipe", "chromScride", "chromContrite", "romStrite", "romStrip", "chromScipe", "romstipe", "romstrite", "chromStrip", "romStride", "chromstrite", "chromContride", "romstride"], "srcStride": ["srcstrite", "srcstructure", "srcStructure", "srcEstride", "srcStrict", " srcstri", "srcBlrite", "sourceStrite", "srcSTrite", "srcSTride", " srcstride", "sourceStride", "srcSlride", "srcSlrate", "srcstride", "srcSTrict", "srcSlrict", " srcStrite", "srcStrate", " srcStructure", "sourceStrate", "sourceStrict", "srcEstrite", "srcBlructure", "srcStri", "srcSTrate", "srcBlride", "srcEstri", " srcstructure", " srcStri", "srcstri", "srcEstructure", "srcSlrite", "srcBlri", "srcStrite", " srcstrite"], "y": ["ny", "yt", "hy", "d", "ys", "t", "sky", "my", "ey", "yd", "py", "h", "x", "cy", "ym", "ye", "w", "dy", "yi", "col", "z", "yl", "ady", "p", "yr", "yo", "j", "n", "f", "yn", "oy", "c", "vy", "ay", "ry", "year", "Y", " Y", "ya", "ky", "xy", " cy", "yy", "wy", "ty", "zy", "sy"]}}
{"project": "qemu", "commit_id": "57ef3f1278585fbac5f6102362d3c5e066976fdc", "target": 0, "func": "bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)\n\n{\n\n    BdrvOpBlocker *blocker;\n\n    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);\n\n    if (!QLIST_EMPTY(&bs->op_blockers[op])) {\n\n        blocker = QLIST_FIRST(&bs->op_blockers[op]);\n\n        if (errp) {\n\n            *errp = error_copy(blocker->reason);\n\n            error_prepend(errp, \"Node '%s' is busy: \",\n\n                          bdrv_get_device_or_node_name(bs));\n\n        }\n\n        return true;\n\n    }\n\n    return false;\n\n}\n", "idx": 21430, "substitutes": {"bs": ["obs", "bc", "pb", "sb", "bos", "lbs", "outs", "lb", "bis", "ba", "obj", "fs", "ses", "ubs", "db", "fb", "bb", "ops", "bytes", "bid", "bl", "ds", "bes", "bing", "bas", "os", "vs", "cs", "ls", "bps", "js", "b", "bits", "blocks", "ns", "BS", "iss", "ps", "rs", "banks", "ins", "gs", "bot", "rb", "base", "ss", "las"], "op": ["io", "rol", "step", "name", "opp", "prev", "obj", "off", "ap", "app", "option", "Op", "hop", "OP", "loop", "post", "key", "ops", "cop", "rop", "node", " cop", "f", "cmp", "pre", "info", "bit", "ok", "opt", "pp", "p", "ip", "oper", "id", "ep", "o", "operation", "mod", "code", "open", "ext", "ocl", "ask", "pop", "mp", "comp", "ic", "ype", "top", "oop", "doc", "ipop", "http", "root", "vert", "sp", "typ", "block", "oc", "x", "opus", "prop", "type"], "errp": ["errcp", " errlp", "errps", "rrP", "asterlp", "prop", " errn", "errper", "ryn", "rylp", "rrp", " errcp", "prpa", "asterper", "errn", "errop", " errpc", "ern", "asterr", "errpc", "rrpc", "errpa", "errP", "rrop", " errps", "prp", "ryr", "rycp", "rypa", " errpa", "ercp", "asterp", " errper", "rrpa", "prpc", "errlp", " errP", "ryp", "erpa", "erp", "erP", "errr", "ryper", " errr", "erpc", "erps", " errop", "rrps"], "blocker": ["Blocker", "boxer", "baner", " blockter", "blockter", "banner", "Blockiner", " blockler", " blockers", "lockers", "lockter", "blockacer", "lockler", "lockner", "Blockacer", " blockiner", "baners", "Blockler", "locker", "boxiner", "Blockers", "blockner", "blockers", "banter", "blockiner", "Blockner", "boxacer", " blockner", " blockacer", "blockler"]}}
{"project": "FFmpeg", "commit_id": "253d0be6a1ecc343d29ff8e1df0ddf961ab9c772", "target": 0, "func": "static int parse_presentation_segment(AVCodecContext *avctx,\n\n                                      const uint8_t *buf, int buf_size,\n\n                                      int64_t pts)\n\n{\n\n    PGSSubContext *ctx = avctx->priv_data;\n\n\n\n    int x, y, ret;\n\n\n\n    int w = bytestream_get_be16(&buf);\n\n    int h = bytestream_get_be16(&buf);\n\n\n\n    ctx->presentation.pts = pts;\n\n\n\n    av_dlog(avctx, \"Video Dimensions %dx%d\\n\",\n\n            w, h);\n\n    ret = ff_set_dimensions(avctx, w, h);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Skip 1 bytes of unknown, frame rate? */\n\n    buf++;\n\n\n\n    ctx->presentation.id_number = bytestream_get_be16(&buf);\n\n\n\n    /*\n\n     * Skip 3 bytes of unknown:\n\n     *     state\n\n     *     palette_update_flag (0x80),\n\n     *     palette_id_to_use,\n\n     */\n\n    buf += 3;\n\n\n\n    ctx->presentation.object_number = bytestream_get_byte(&buf);\n\n    ctx->presentation.composition_flag = 0;\n\n    if (!ctx->presentation.object_number)\n\n        return 0;\n\n\n\n    /*\n\n     * Skip 3 bytes of unknown:\n\n     *     object_id_ref (2 bytes),\n\n     *     window_id_ref,\n\n     */\n\n    buf += 3;\n\n    ctx->presentation.composition_flag = bytestream_get_byte(&buf);\n\n\n\n    x = bytestream_get_be16(&buf);\n\n    y = bytestream_get_be16(&buf);\n\n\n\n    /* TODO If cropping, cropping_x, cropping_y, cropping_width, cropping_height (all 2 bytes).*/\n\n\n\n    av_dlog(avctx, \"Subtitle Placement x=%d, y=%d\\n\", x, y);\n\n\n\n    if (x > avctx->width || y > avctx->height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\\n\",\n\n               x, y, avctx->width, avctx->height);\n\n        x = 0; y = 0;\n\n    }\n\n\n\n    /* Fill in dimensions */\n\n    ctx->presentation.x = x;\n\n    ctx->presentation.y = y;\n\n\n\n    return 0;\n\n}\n", "idx": 10253, "substitutes": {"avctx": ["afconn", "avcmp", "afctx", "AVcf", "AVconfig", "avelc", "ajcmp", "aucas", "afcas", "vercmd", "aucca", "afpkg", "afcmp", "avectx", "avecmp", "alcontext", "evcf", "afcmd", "auctx", "AVctrl", "avcf", "avecu", "AVcmp", "evcontext", "AVpkg", "AVcontext", "alconv", "avcu", "alctx", "afcu", "verctx", "vercontext", "afcf", "aveconfig", "avconn", "avcmd", "avconv", "aflc", "AVlc", "ajctx", "ajcontext", "AVcmd", "afconfig", "AVctx", "aveconv", "avconfig", "AVconn", "avlc", "avcontext", "afconv", "alcca", "avepkg", "evconn", "avcas", "avctrl", "evctx", "ajcmd", "avpkg", "alcas", "alpkg", "avecf", "AVcu", "aveconn", "avecontext", "aucontext", "afcontext", "ajctrl", "afctrl", "avcca", "afcca", "verconfig"], "buf": ["bag", "uf", "seq", "uu", "img", "context", "proc", "ph", "af", "wa", "src", "fd", "b", "brace", "mount", "auc", "wb", "fw", "ab", "pool", "data", "fb", "batch", "ref", "config", "pb", "bu", "cb", "fp", "queue", "gb", "cf", "rb", "bc", "pkg", "ha", "bound", "alloc", "cv", "aux", "exc", "fam", "rc", "uh", "Buff", "bh", "cas", "home", "conv", "cur", "font", "req", "port", "begin", "uint", "h", "loop", "row", "func", "vec", "buff", "cmd", "br", "feat", "text", "buffer", "box", "uc", "runner"], "buf_size": [" buffer_length", "buf2size", " buffer_SIZE", "buf2name", "buf_name", " buffer_name", "buf2SIZE", "buf2length", "buf_length", " buffer_size", "buf_SIZE"], "pts": ["ntg", "prs", "prd", "pxc", "ptg", "ctns", "portgs", "pxns", " ptsps", " ptsts", "ptc", " ptd", "ntts", "aptd", " ptss", "ports", "cts", "ptd", "portd", " ptsd", "ntgs", "ptps", " ptps", "ptgs", "pxs", "ctc", "aptc", "ptns", "prgs", "aptns", "nts", "ntd", "ntps", "apts", "ctd", "pxd", "ptts", " ptts", "prg", "portg"], "ctx": ["conf", "co", "cam", "context", "cmp", "cca", "conn", "tc", "sci", "fw", "c", "cp", "data", "config", "p", "cu", "cb", "cli", "qa", "cf", "cn", "wcs", "loc", "coll", "hw", "cc", "bc", "cs", "ctrl", "cus", "cv", "ck", "aux", "ce", "cas", "conv", "tx", "pc", "xc", "cpp", "cms", "nc", "cfg", "cm", "ca", "gc", "client", "ci", "fc", "comp", "css", "vc", "lc", "cmd", "pkg", "mc", "kb", "sc", "exec"], "x": ["l", "xp", "ax", "m", "pl", "t", "path", "z", "code", "v", "port", "rx", "image", "n", "val", "key", "view", "w", "id", "xi", "b", "k", "i", "c", "X", "work", "e", "pe", "value", "f", "index", "r", "en", "position", "wx", "u", "ww", "sex", "hi", "location", "d", "data", "coord", "xxx", "host", "o", "shape", "fx", "tx", "xc", "xy", "xe", "px", "a", "dx", "in", "wa", "xx", "time", "p", "ix", "xs", "q", "height", "name", "address", "h", "length", "ex"], "y": ["l", "ym", "ady", "hi", "isy", "area", "yt", "oy", "n", "ry", "wa", "w", "id", "m", "ny", "bar", "t", "b", "z", "vy", "ey", "d", "i", "ye", "s", "cy", "p", "ys", "iy", "yi", "ish", "value", "pt", "ay", "q", "zy", "f", "yy", "sy", "j", "height", "gy", "o", "py", "index", "v", "name", "ky", "yl", "ery", "hy", "acy", "Y", "ty", "ies", "ii", "type", "h", "yan", "xy", "lon", "yn", "ya", "image", "length", "wy", "dy", "yo"], "ret": ["rf", "flag", "str", "alt", "val", "ry", "len", "def", "id", "nt", "Ret", "num", "last", "feat", "red", "reply", "ref", "run", "lit", "obj", "reg", "pt", "rb", "rets", "f", "code", "rt", "res", "bf", "det", "wait", "rc", "md", "r", "att", "fun", "err", "en", "ben", "end", "art", "read", "re", "RET", "rx", "back", "mt", "result", "rev", "ft", "resp", "match", "fi", "success"]}}
{"project": "qemu", "commit_id": "c951d9a6751576a076ac80a5e5145ceb8d794d38", "target": 1, "func": "static void file_completion(const char *input)\n\n{\n\n    DIR *ffs;\n\n    struct dirent *d;\n\n    char path[1024];\n\n    char file[1024], file_prefix[1024];\n\n    int input_path_len;\n\n    const char *p;\n\n\n\n    p = strrchr(input, '/');\n\n    if (!p) {\n\n        input_path_len = 0;\n\n        pstrcpy(file_prefix, sizeof(file_prefix), input);\n\n        pstrcpy(path, sizeof(path), \".\");\n\n    } else {\n\n        input_path_len = p - input + 1;\n\n        memcpy(path, input, input_path_len);\n\n        if (input_path_len > sizeof(path) - 1)\n\n            input_path_len = sizeof(path) - 1;\n\n        path[input_path_len] = '\\0';\n\n        pstrcpy(file_prefix, sizeof(file_prefix), p + 1);\n\n    }\n\n#ifdef DEBUG_COMPLETION\n\n    monitor_printf(cur_mon, \"input='%s' path='%s' prefix='%s'\\n\",\n\n                   input, path, file_prefix);\n\n#endif\n\n    ffs = opendir(path);\n\n    if (!ffs)\n\n        return;\n\n    for(;;) {\n\n        struct stat sb;\n\n        d = readdir(ffs);\n\n        if (!d)\n\n            break;\n\n\n\n        if (strcmp(d->d_name, \".\") == 0 || strcmp(d->d_name, \"..\") == 0) {\n\n            continue;\n\n        }\n\n\n\n        if (strstart(d->d_name, file_prefix, NULL)) {\n\n            memcpy(file, input, input_path_len);\n\n            if (input_path_len < sizeof(file))\n\n                pstrcpy(file + input_path_len, sizeof(file) - input_path_len,\n\n                        d->d_name);\n\n            /* stat the file to find out if it's a directory.\n\n             * In that case add a slash to speed up typing long paths\n\n             */\n\n            stat(file, &sb);\n\n            if(S_ISDIR(sb.st_mode))\n\n                pstrcat(file, sizeof(file), \"/\");\n\n            readline_add_completion(cur_mon->rs, file);\n\n        }\n\n    }\n\n    closedir(ffs);\n\n}\n", "idx": 12079, "substitutes": {"input": ["ahead", "param", "wp", "Input", "img", "initial", "accept", "field", "in", "source", "prefix", "view", "temp", "id", "password", "include", "data", "c", "batch", "output", "ix", "qa", "local", "config", "request", "xml", "value", "before", "q", "empty", "array", "padding", "P", "binary", "xxx", "f", "progress", "inc", "current", "raw", "inner", "buffer", "integer", "address", "pull", "dc", "error", "enc", "init", "u", "form", "command", "null", "import", "image", "bin", "text", "inf", "uc", "pattern"], "ffs": ["affs", "cfs", "FFsb", "ffsd", "cfsl", "ufrows", "ffrows", "fundouts", " effns", " effsd", "ffieldns", "ppsys", " ffo", "bufouts", "ufs", "lfs", " ffns", "ffds", " ffrows", "pps", "FFrows", "fundsd", "ffields", "ffsi", "bufs", "lfsys", "ufsb", " effs", "fundsi", "ffsl", "FFS", "ffns", "ffS", "ffieldsd", "ffouts", "affouts", " ffsb", "ffo", "cfds", "ppds", "bufsi", "lfsl", "ffsb", " ffS", "uffds", "ffieldo", " ffsd", "uffsl", "ufS", "lfds", "affds", "FFs", "funds", "affsi", "affsd", "ffsys", "uffs", " effo", "bufsd", "affsys"], "d": ["dp", "ld", "diff", "l", "dh", "ds", "n", "did", "dom", "g", "dict", "da", "w", "m", "id", "fd", "b", "dos", "t", "z", "ud", "k", "i", "de", "c", "data", "ad", "bd", "s", "e", "pd", "cd", "du", "dn", "f", "ded", "j", "dl", "db", "dir", "dat", "o", "dr", "xd", "nd", "md", "r", "done", "end", "dd", "vd", "dc", "sd", "u", "dy", "dm", "od", "dad", "D"], "path": ["parent", "Path", "session", "base", "word", "python", "config", "xml", "txt", "po", "code", "call", "process", "content", "object", "port", "PATH", "full", "form", "self", "url", "image", "text", "chain", "php", "prefix", "key", "view", "w", "id", "c", "work", "output", "request", "value", "ath", "binary", "index", "space", "current", "list", "root", "directory", "location", "context", "source", "method", "temp", "password", "data", "stream", "local", "array", "progress", "sync", "home", "raw", "part", "enc", "cat", "message", "cache", "core", "uc", "param", "pass", "pointer", "empty", "dir", "child", "route", "name", "folder", "user", "transform", "length", "pattern"], "file": ["parent", "l", "play", "session", "base", "le", "field", "word", "point", "http", "fd", "block", "feed", "al", "connection", "object", "document", "port", "full", "type", "self", "change", "image", "text", "php", "sf", "id", "b", "plain", "c", "rule", "work", "f", "binary", "db", "bf", "live", "read", "directory", "rl", "zip", "source", "ile", "temp", "model", "page", "data", "local", "fp", "flow", "resource", "home", "sl", "message", "use", "cache", "un", "files", "filename", "line", "time", "run", "server", "dir", "lib", "name", "folder", "function", "user", "mail", "h", "File", "bin"], "file_prefix": [" file_pointer", "place_prefix", "file_fix", "file_directory", "routebookdirectory", "filename___reset", "file_padding", "money_padding", "route_radius", "file_offset", "place_area", " file_offset", "file___prefix", "file_exclusive", "file___queue", "place_context", "file_area", "file___name", "route_directory", "money_prefix", "filebookdirectory", "file64exclusive", "file___directory", "file___exclusive", "place_padding", "file__area", "file_radius", "route_exclusive", "file_name", "file__context", "filebookexclusive", "file_reset", "file___radius", "file64prefix", "input_prefix", "file_runner", "money_runner", "filename_name", "filename___prefix", "file64radius", "money_zone", "file_queue", " file_post", "routebookprefix", " file_fix", "filebookprefix", "route_prefix", " file_pad", "filename___name", "input_fix", "filename_reset", "file_zone", "input_name", "file_context", "file_pointer", "file_pad", "file64queue", "filename_queue", "file64reset", "file64directory", "file_post", "filename___queue", "filebookradius", "file__padding", "file64name", "routebookradius", "filename_prefix", "file___reset", "file__prefix", "routebookexclusive"], "input_path_len": ["input_depth_start", "input_prefix_length", "input_path_length", "input_length_line", "input_path64lf", "input_path_pos", "input_text_val", "input_path_line", "input_length0size", "input_Path_part", "input_prefix_len", "input_text0len", "input_text_length", "input_text0length", "input_path_part", "input_pointer_len", "input_depth_length", "input_text0l", "input_length_len", "input_path2line", "input_path2val", "input_length_length", "input_path2l", "input_path_left", "input_path0len", "input_path2length", "input_length_lf", "input_prefix_le", "input_length_l", "input_path64val", "input_length0val", "input_length_val", "input_Path_len", "input_path_start", "input_path_l", "input_path0val", "input_length_left", "input_path0size", "input_pathvlen", "input_pathvsize", "input_text0val", "input_pointer_Len", "input_pathjleft", "input_Path_l", "input_pathvline", "input_depth_line", "input_path_val", "input_path64size", "input_pointer_l", "input_path0lf", "input_pathvLen", "input_length_size", "input_text_len", "input_path_ln", "input_length0lf", "input_path_size", "input_pathjlen", "input_path0l", "input_path2len", "input_prefix_l", "input_length0len", "input_pointer_ln", "input_pointer_pos", "input_path64len", "input_pathjLen", "input_pointer_length", "input_pathjline", "input_path_lf", "input_path_le", "input_text_l", "input_path0length", "input_path_Len", "input_depth_len", "input_Path_Len", "input_length_pos", "input_length_Len"], "p": ["lp", "l", "dp", "sp", "wp", "up", "start", "n", "g", "prefix", "pad", "m", "bp", "point", "t", "b", "x", "pa", "pp", "i", "c", "cp", "python", "prev", "e", "fp", "np", "pe", "po", "q", "P", "f", "pn", "padding", "op", "primary", "j", "progress", "o", "v", "r", "pr", "pre", "port", "tp", "jp", "patch", "pi", "pc", "u", "ip", "api", "ps", "press", "y", "ap", "vp"], "sb": [" b", "sp", "sg", "sh", "ib", "bb", "std", "ds", "si", "nb", "abb", "sf", "ba", "info", "bp", "src", "b", "wb", "stat", "SB", " eb", "sa", "vm", "fb", "pb", "obj", "cb", "gb", "split", "stab", "rb", " s", "bc", "bt", "db", "bf", "bj", "bg", " sd", "sync", "sl", "lb", "sn", "sth", "sm", "vd", "sd", " ga", " db", "ob", "kb", "sc"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,\n\n                        uint8_t *buf, int len, int is_write)\n\n{\n\n    int l;\n\n    target_phys_addr_t phys_addr;\n\n    target_ulong page;\n\n\n\n    while (len > 0) {\n\n        page = addr & TARGET_PAGE_MASK;\n\n        phys_addr = cpu_get_phys_page_debug(env, page);\n\n        /* if no physical page mapped, return an error */\n\n        if (phys_addr == -1)\n\n            return -1;\n\n        l = (page + TARGET_PAGE_SIZE) - addr;\n\n        if (l > len)\n\n            l = len;\n\n        phys_addr += (addr & ~TARGET_PAGE_MASK);\n\n        if (is_write)\n\n            cpu_physical_memory_write_rom(phys_addr, buf, l);\n\n        else\n\n            cpu_physical_memory_rw(phys_addr, buf, l, is_write);\n\n        len -= l;\n\n        buf += l;\n\n        addr += l;\n\n    }\n\n    return 0;\n\n}\n", "idx": 10278, "substitutes": {"env": ["qt", "ext", "que", "viron", "vt", "environment", "config", "e", "np", "txt", "esi", "erv", "ec", "eni", "priv", "ev", "inv", "forge", "energy", "exc", "ea", "oa", "exe", "zen", "en", "eng", "Environment", "enc", "emb", "ef", "et", "impl", "her", "eu", "fi", "ens", "runner"], "addr": ["lp", "stall", "ack", "pad", "fd", "x", "bridge", "ad", "ref", "ace", "afi", "memory", "loc", "dl", "device", "align", "lb", "nr", "asm", "offset", "hop", "url", "pkg", "ld", "alias", "ord", "id", "mem", "work", "e", "r", "en", "layer", "lc", "cpu", "seq", "alt", "conn", "src", "data", "add", "ls", "coord", "ptr", "eni", "socket", "dr", "host", "size", "alloc", "edge", "oa", "rc", "order", "sl", "node", "aa", "hl", "lan", "adr", "start", "pointer", "ell", "el", "p", "rs", "lr", "la", "ea", "route", "address", "pos", "ip"], "buf": ["bag", "uf", "seq", "ff", "src", "fd", "b", "que", "path", "wb", "mem", "pool", "fi", "data", "fb", "batch", "config", "pb", "cb", "fp", "queue", "feed", "rb", "array", "bc", "alloc", "cv", "rc", "cas", "home", "ctx", "lb", "port", "offset", "url", "result", "vec", "buff", "cmd", "proc", "br", "buffer", "uc", "runner"], "len": ["lp", " el", "seq", "ler", "le", "lf", "base", "il", "n", "val", "in", "lv", "nt", "lim", "low", "pl", "i", "ell", "line", "limit", "el", "ls", "lit", "loc", "la", "dl", "fl", "bl", "non", "ll", "min", "sl", "L", "en", "lb", "fin", "lock", "lang", "den", "hl", "li", "pos", "lon", "url", "length", "Len", "lc", "lan", "ln", "lin"], "is_write": [" is_writ", "has_sync", "is_call", "is_flow", "isaycall", "isaywrite", "islandcreate", "has_written", "is_writ", "isaywrit", "isplandread", "islandwrite", "islandwriter", "has_flow", "isp_writer", "has_write", "islandread", "is_read", " is_call", "is_sync", "isp_create", "is_create", "isp_write", "isplandwriter", "is_written", "is_writer", "isp_read", "isplandcreate", "isplandwrite"], "l": ["lp", "ld", "le", "lf", "il", "n", "ul", "pl", "b", "ol", "z", "d", "i", " L", "ell", "line", "el", "p", "ls", "e", "limit", "lu", "lit", "loc", "la", "dl", "fl", "o", "bl", "ll", "v", "sl", "r", "L", "lb", "en", "u", "lang", "nl", "hl", "li", "url", "length", "lc", "y", "jl", "rl", "ln", "lin", "kl"], "phys_addr": ["phys__pointer", "phys__address", "physical_addr", "phys_dr", "phys___pointer", " phys_rt", "las_az", "phys2addr", "physical_adr", "cpu_address", "phys_ref", "phys_align", "phy_addr", "phys_address", "physical_pointer", "physkaddr", "phys___addr", "phys_rt", "phys___address", " phys_ord", "phy_oa", "phys__adr", "physkaddress", "las_dr", "phys_adr", "phys_ord", "las_align", "physical_address", "phys__addr", "phys_adder", "cpu_ord", "phys_ace", "phys_oa", "phy_adder", "phys_pointer", "physkdr", "cpu_ref", " phys_ace", "phys2ord", "phys2ace", "phys2rt", "las_address", "phy_address", "physkalign", "phys_az", "cpu_addr", "phys___adr", "las_addr"], "page": ["count", "lp", "area", "byte", "pg", "n", "id", "fr", "pl", "net", "num", "x", "pid", "ver", "pp", "pointer", "c", "line", "data", "p", "ref", "server", "e", "limit", "el", "pe", "memory", "number", "pages", "array", "loc", "stop", "padding", "next", "size", "inc", "name", "sl", "end", "age", "address", "en", "pc", "Page", "offset", "hop", "node", "aa", "pos", "ip", "row", "url", "site", "cache", "buffer"]}}
{"project": "qemu", "commit_id": "0fdddf80a88ac2efe068990d1878f472bb6b95d9", "target": 0, "func": "static void win32_rearm_timer(struct qemu_alarm_timer *t)\n\n{\n\n    struct qemu_alarm_win32 *data = t->priv;\n\n    uint64_t nearest_delta_us;\n\n\n\n    if (!active_timers[QEMU_TIMER_REALTIME] &&\n\n                !active_timers[QEMU_TIMER_VIRTUAL])\n\n        return;\n\n\n\n    nearest_delta_us = qemu_next_deadline_dyntick();\n\n    nearest_delta_us /= 1000;\n\n\n\n    timeKillEvent(data->timerId);\n\n\n\n    data->timerId = timeSetEvent(1,\n\n                        data->period,\n\n                        host_alarm_handler,\n\n                        (DWORD)t,\n\n                        TIME_ONESHOT | TIME_PERIODIC);\n\n\n\n    if (!data->timerId) {\n\n        fprintf(stderr, \"Failed to re-arm win32 alarm timer %ld\\n\",\n\n                GetLastError());\n\n\n\n        timeEndPeriod(data->period);\n\n        exit(1);\n\n    }\n\n}\n", "idx": 12038, "substitutes": {"t": ["l", "ts", "ta", "tr", "n", "w", "m", "tc", "trial", "dt", "nt", "b", "tt", "tz", "k", "tty", "d", "i", "z", "tu", "c", "time", "p", "tick", "e", "f", "ut", "T", "tf", "o", "v", "timer", "ti", "r", "ty", "tp", "tim", "tm", "unt", "u", "a", "out", "y", "td", "te"], "data": ["parent", "session", "ui", "di", "timeout", "ta", "debug", "start", "wa", "window", "date", "def", "da", "info", "w", "m", "key", "dt", "template", "temp", "update", "missing", "send", "d", "rec", "i", "ad", "time", "config", "reader", "p", "e", "ata", "ada", "action", "memory", "style", "off", "er", "DATA", "dat", "alpha", "index", "size", "module", "input", "connection", "event", "id", "done", "tx", "Data", "error", "after", "u", "type", "change", "li", "api", "message", "a", "extra", "client", "result", "cache", "database", "exec"], "nearest_delta_us": ["nearest_delta_used", "nearest_delta2US", "nearest_delt_au", "nearest_delt_us", "nearest_delt_use", "nearest_delta_US", "nearest_delta2use", "nearest_delta_au", "nearest_delta2us", "nearest_delt_u", "nearest_delta_u", "nearest_deltaptuse", "nearest_dota_US", "nearest_dota_us", "nearest_delta_aus", "nearest_dota_aus", "nearest_dota_use", "nearest_deltaptau", "nearest_delta2aus", "nearest_delt_US", "nearest_delt_used", "nearest_deltaptus", "nearest_deltaptu", "nearest_delta_use"]}}
{"project": "qemu", "commit_id": "80fb34eda099e7cc519a91e9701ab3c0262717b3", "target": 1, "func": "bool qio_task_propagate_error(QIOTask *task,\n\n                              Error **errp)\n\n{\n\n    if (task->err) {\n\n        error_propagate(errp, task->err);\n\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}", "idx": 8111, "substitutes": {"task": ["patch", "game", "master", "pack", "clean", "complete", "parent", "device", "scope", "config", "kick", "object", "module", "tty", "asks", "tag", "tx", "resource", "event", "project", "content", "call", "ack", "target", "item", "error", "message", "instance", "empty", "ask", "exec", "process", "result", "theme", "work", "load", "source", "this", "tile", "level", "rule", "slave", "contract", "type", "thread", "Task", "test", "app", "command", "worker"], "errp": ["errvp", "rp", " errvp", "erP", "resultp", "resultP", "rvp", " errcp", "errP", "irvp", " errP", "resultps", "erps", "rP", " errps", "irp", "irps", "ercp", "errps", "resultcp", "erp", "rps", "errcp", "irP"]}}
{"project": "FFmpeg", "commit_id": "cb85779d459c6486acbbf060b3f169779424583e", "target": 0, "func": "static int decode_frame(AVCodecContext *avctx,\n\n                        void *data,\n\n                        int *got_frame,\n\n                        AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    DPXContext *const s = avctx->priv_data;\n\n    AVFrame *picture  = data;\n\n    AVFrame *const p = &s->picture;\n\n    uint8_t *ptr[AV_NUM_DATA_POINTERS];\n\n\n\n    unsigned int offset;\n\n    int magic_num, endian;\n\n    int x, y, i, ret;\n\n    int w, h, bits_per_color, descriptor, elements, packing, total_size;\n\n\n\n    unsigned int rgbBuffer = 0;\n\n    int n_datum = 0;\n\n\n\n    if (avpkt->size <= 1634) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small for DPX header\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    magic_num = AV_RB32(buf);\n\n    buf += 4;\n\n\n\n    /* Check if the files \"magic number\" is \"SDPX\" which means it uses\n\n     * big-endian or XPDS which is for little-endian files */\n\n    if (magic_num == AV_RL32(\"SDPX\")) {\n\n        endian = 0;\n\n    } else if (magic_num == AV_RB32(\"SDPX\")) {\n\n        endian = 1;\n\n    } else {\n\n        av_log(avctx, AV_LOG_ERROR, \"DPX marker not found\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    offset = read32(&buf, endian);\n\n    if (avpkt->size <= offset) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid data start offset\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    // Need to end in 0x304 offset from start of file\n\n    buf = avpkt->data + 0x304;\n\n    w = read32(&buf, endian);\n\n    h = read32(&buf, endian);\n\n    if ((ret = av_image_check_size(w, h, 0, avctx)) < 0)\n\n        return ret;\n\n\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n\n\n    // Need to end in 0x320 to read the descriptor\n\n    buf += 20;\n\n    descriptor = buf[0];\n\n\n\n    // Need to end in 0x323 to read the bits per color\n\n    buf += 3;\n\n    avctx->bits_per_raw_sample =\n\n    bits_per_color = buf[0];\n\n    buf++;\n\n    packing = *((uint16_t*)buf);\n\n\n\n    buf += 824;\n\n    avctx->sample_aspect_ratio.num = read32(&buf, endian);\n\n    avctx->sample_aspect_ratio.den = read32(&buf, endian);\n\n    if (avctx->sample_aspect_ratio.num > 0 && avctx->sample_aspect_ratio.den > 0)\n\n        av_reduce(&avctx->sample_aspect_ratio.num, &avctx->sample_aspect_ratio.den,\n\n                   avctx->sample_aspect_ratio.num,  avctx->sample_aspect_ratio.den,\n\n                  0x10000);\n\n    else\n\n        avctx->sample_aspect_ratio = (AVRational){ 0, 1 };\n\n\n\n    switch (descriptor) {\n\n        case 51: // RGBA\n\n            elements = 4;\n\n            break;\n\n        case 50: // RGB\n\n            elements = 3;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported descriptor %d\\n\", descriptor);\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch (bits_per_color) {\n\n        case 8:\n\n            if (elements == 4) {\n\n                avctx->pix_fmt = AV_PIX_FMT_RGBA;\n\n            } else {\n\n                avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n            }\n\n            total_size = avctx->width * avctx->height * elements;\n\n            break;\n\n        case 10:\n\n            if (!packing) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Packing to 32bit required\\n\");\n\n                return -1;\n\n            }\n\n            avctx->pix_fmt = AV_PIX_FMT_GBRP10;\n\n            total_size = (avctx->width * avctx->height * elements + 2) / 3 * 4;\n\n            break;\n\n        case 12:\n\n            if (!packing) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Packing to 16bit required\\n\");\n\n                return -1;\n\n            }\n\n            if (endian) {\n\n                avctx->pix_fmt = AV_PIX_FMT_GBRP12BE;\n\n            } else {\n\n                avctx->pix_fmt = AV_PIX_FMT_GBRP12LE;\n\n            }\n\n            total_size = 2 * avctx->width * avctx->height * elements;\n\n            break;\n\n        case 16:\n\n            if (endian) {\n\n                avctx->pix_fmt = elements == 4 ? AV_PIX_FMT_RGBA64BE : AV_PIX_FMT_RGB48BE;\n\n            } else {\n\n                avctx->pix_fmt = elements == 4 ? AV_PIX_FMT_RGBA64LE : AV_PIX_FMT_RGB48LE;\n\n            }\n\n            total_size = 2 * avctx->width * avctx->height * elements;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"Unsupported color depth : %d\\n\", bits_per_color);\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->picture.data[0])\n\n        avctx->release_buffer(avctx, &s->picture);\n\n    if ((ret = ff_get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    // Move pointer to offset from start of file\n\n    buf =  avpkt->data + offset;\n\n\n\n    for (i=0; i<AV_NUM_DATA_POINTERS; i++)\n\n        ptr[i] = p->data[i];\n\n\n\n    if (total_size > avpkt->size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Overread buffer. Invalid header?\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    switch (bits_per_color) {\n\n    case 10:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            uint16_t *dst[3] = {(uint16_t*)ptr[0],\n\n                                (uint16_t*)ptr[1],\n\n                                (uint16_t*)ptr[2]};\n\n            for (y = 0; y < avctx->width; y++) {\n\n                *dst[2]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                *dst[0]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                *dst[1]++ = read10in32(&buf, &rgbBuffer,\n\n                                       &n_datum, endian);\n\n                // For 10 bit, ignore alpha\n\n                if (elements == 4)\n\n                    read10in32(&buf, &rgbBuffer,\n\n                               &n_datum, endian);\n\n            }\n\n            for (i = 0; i < 3; i++)\n\n                ptr[i] += p->linesize[i];\n\n        }\n\n        break;\n\n    case 12:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            uint16_t *dst[3] = {(uint16_t*)ptr[0],\n\n                                (uint16_t*)ptr[1],\n\n                                (uint16_t*)ptr[2]};\n\n            for (y = 0; y < avctx->width; y++) {\n\n                *dst[2] = *((uint16_t*)buf);\n\n                *dst[2] = (*dst[2] >> 4) | (*dst[2] << 12);\n\n                dst[2]++;\n\n                buf += 2;\n\n                *dst[0] = *((uint16_t*)buf);\n\n                *dst[0] = (*dst[0] >> 4) | (*dst[0] << 12);\n\n                dst[0]++;\n\n                buf += 2;\n\n                *dst[1] = *((uint16_t*)buf);\n\n                *dst[1] = (*dst[1] >> 4) | (*dst[1] << 12);\n\n                dst[1]++;\n\n                buf += 2;\n\n                // For 12 bit, ignore alpha\n\n                if (elements == 4)\n\n                    buf += 2;\n\n            }\n\n            for (i = 0; i < 3; i++)\n\n                ptr[i] += p->linesize[i];\n\n        }\n\n        break;\n\n    case 16:\n\n        elements *= 2;\n\n    case 8:\n\n        for (x = 0; x < avctx->height; x++) {\n\n            memcpy(ptr[0], buf, elements*avctx->width);\n\n            ptr[0] += p->linesize[0];\n\n            buf += elements*avctx->width;\n\n        }\n\n        break;\n\n    }\n\n\n\n    *picture   = s->picture;\n\n    *got_frame = 1;\n\n\n\n    return buf_size;\n\n}\n", "idx": 24478, "substitutes": {"avctx": ["apcontext", "avcms", "AVfw", "navcontext", "alconn", "afkb", "avalobj", "avcontext", "avesync", "afcontext", "avectx", "ajctx", "avekb", "akctx", "alcb", "avcv", "avecmp", "affw", "akcontext", "AVcontext", "afcca", "akloc", "avcu", "afsync", "avepkg", "avcoll", "afctrl", "avcca", "avalcontext", " avloc", "avsci", "afctx", "avconfig", "avpkg", "avalctx", "avectrl", "avfw", "avecms", "avloc", "avecoll", "avctrl", "navsync", "avalcms", "AVctx", "verctx", "afcv", "avcb", "afobj", "alctx", "apcu", "ajcoll", "avalcmp", "avecontext", "avefw", "AVconn", "avcmp", "verconn", "apctx", "avsync", "afcms", "avalcu", "avecv", " avsci", "ajctrl", "afcb", "avesci", "avconn", "alcontext", "afcoll", "ajpkg", "afconn", "vercb", "ajcontext", "akconn", "afpkg", "avecca", "ajkb", "avkb", "aveconfig", "vercontext", "afcu", "ajcms", "aveconn", "avobj", " avconn", "aveobj", "afsci", " avcontext", "navcv", "afloc", " avconfig", "apcms", "navctx", "afcmp", "ajcca", "afconfig"], "data": ["Data", "body", "code", "package", "download", "batch", "frame", "name", "context", "image", "d", "buffer", "queue", "base", "media", "doc", "config", "read", "next", "reader", "id", "pad", "feed", "open", "message", "padding", "input", "dat", "start", "command", "sample", "original", "mode", "parent", "client", "size", "video", "cache", "response", "channel", "device", "length", "window", "bytes", "value", "da", "a", "DATA", "content", "header", "database", "memory", "meta", "result", "pos", "connection"], "got_frame": ["numacchannel", "numgtime", "num_frame", "num_time", "numgtrace", "numgframe", "get_channel", "num_channel", "numgchannel", "numactrace", "get_frame", "num_trace", "numactime", "get_time", "numacframe", "get_trace"], "avpkt": ["avperkt", "avegkt", "avPacket", "abcct", "avcft", "AVPcf", "avbpct", "abcacket", "avparut", "avpept", "avpect", "avepkn", "AVPke", "avparkat", "avopkt", "avput", "avfkt", "avpbkt", "avgut", "AVpcf", "avperkn", "avcpct", "avopdt", "avgkt", "AVPacket", "avbpft", "avepkt", "avPcf", "avbpett", "afpct", "avgacket", "avepkat", "avpcf", "afpacket", "avpett", "avperkat", "AVPpt", "avfdt", "avPett", "avPft", "avfft", "avpbke", "affct", "avfcf", "AVPett", "avppt", "avpeke", "avpct", "avegkn", "avparkn", "abcft", "AVpkt", "avcct", "avPkt", "avPpt", "avjpacket", "AVpett", "abpkt", "affacket", "avcdt", "avgkn", "afpdt", "avpkn", "avjpcf", "AVpft", "AVPft", "avbpkt", "avjpkt", "avpft", "avpbpt", "avPct", "avcacket", "avgkat", "abpft", "avpbct", "avfacket", "afpkt", "avopacket", "avgct", "affdt", "AVpacket", "avcpft", "avegut", "aveput", "avpke", "avPke", "AVPkt", "avjpct", "avgft", "avfct", "affkt", "avpekt", "avperut", "abpacket", "avcpett", "AVpke", "avcpkt", "abckt", "avopct", "AVppt", "avparkt", "avpacket", "AVpct", "abpct", "avpkat", "avegkat", "AVPct", "avpdt", "avckt"], "buf": ["font", "socket", "bag", "exc", "batch", "wb", "pkg", "Buff", "usb", "buffer", "cb", "begin", "cmd", "fw", "pool", "cf", "conv", "uu", "buff", "window", "fp", "r", "pack", "wa", "b", "c", "cv", "msg", "queue", "text", "port", "proc", "feed", "ff", "uint", "cap", "cache", "feat", "cas", "tc", "src", "func", "block", "fd", "fun", "uf", "uc", "usr", "context", "d", "rb", "bus", "all", "raw", "brace", "tmp", "box", "fb", "fi", "utf", "alloc", "Buffer", "length", "ha", "header", "_", "seq", "shift", "vec", "img", "cur", "config", "br", "prop", "aka", "bc", "pad", "rw", "aux", "home", "loc", "ctx", "rc", "xff", "loop", "result"], "s": ["S", "space", "sc", "sys", "ss", "m", "c", "bis", "d", "sq", "ds", "sac", "conf", "ps", "sg", "sync", "e", "es", "share", "session", "sv", "si", "sym", "stat", "sb", "sec", "services", "sup", "as", "f", "fs", "service", "a", "an", "q", "v", "r", "sf", "ssl", "cs", "g"], "picture": ["gif", "summary", "space", "package", "obj", "slice", "Picture", "family", "info", "definition", "frame", "image", "camera", "buffer", "detail", "photo", "media", "img", "config", "feature", "plugin", "profile", "movie", "piece", "conference", "guide", "share", "uri", "slot", "library", "ctx", "fi", "video", "cache", "brush", "details", "pict", "png", "meta", "room", "cam", "pic"], "p": ["np", "b", "m", "c", "d", "P", "py", "jp", "ps", "proc", "u", "mp", "e", "pd", "f", "n", "a", "fp", "v", "r", "pi", "vp", "l", "pc", "g"], "ptr": ["seq", "obj", "pt", "cv", "dr", "buffer", "vec", "br", "pointer", "inst", "ch", "tr", "proc", "pad", "mem", "arr", "str", "ef", "nt", "fi", "ctr", "alloc", "Ptr", "addr", "transfer", "src"], "AV_NUM_DATA_POINTERS": ["AV_NUM_DATA_POATCHS", "AV_NUM_DATA_PRINTINGS", "AV_NUM_DATA_PROTER", "AV_NUM_DATA_POOTS", "AV_NUM_DATA_POOTERS", "AV_NUM_DATA_POINTER", "AV_NUM_DATA_PROTINGS", "AV_NUM_DATA_POOTER", "AV_NUM_DATA_POILER", "AV_NUM_DATA_POILS", "AV_NUM_DATA_POATCHINGS", "AV_NUM_DATA_PROTERS", "AV_NUM_DATA_POOTINGS", "AV_NUM_DATA_PROTS", "AV_NUM_DATA_POATCHERS", "AV_NUM_DATA_PRINTERS", "AV_NUM_DATA_POATCHER", "AV_NUM_DATA_POILERS", "AV_NUM_DATA_POINTINGS", "AV_NUM_DATA_POINTS", "AV_NUM_DATA_POILINGS", "AV_NUM_DATA_PRINTER", "AV_NUM_DATA_PRINTS"], "offset": ["ref", "skip", "from", "shift", "info", "position", "image", "base", "no", "fff", "align", "error", "Offset", "end", "num", " offsets", "o", "ff", "padding", "start", "nb", "set", "loc", "unc", "slot", "lace", "nt", "parent", " error", "size", "ffff", "now", "origin", "off", "timeout", "part", "aw", "f", "limit", "index", "fp", "et", "pos", "len"], "magic_num": ["magic67no", " magic_bin", " magic_common", "magic_nom", "magic67common", "magic_sum", " magic_sum", "magic67num", "magic_number", " magic_nu", "magic_no", "magic_nu", " magic_type", "magicialnumber", "magicialsum", "magic_common", "magicialnum", "magic_bin", "magic__nu", "magic_fun", " magic_number", " magic_nom", "magic_type", "magic__number", "magic__nom", "magic2num", "magic2fun", " magic_fun", "magic67bin", "magic__num", "magic2no", "magicialtype", " magic_no", "magic2bin"], "endian": ["endedrian", "ENDian", " endrian", "endio", "endiana", "appendio", "endedio", "ENDiet", "endnet", "angio", " endiet", "endrian", "endsians", " endians", " endig", "endedian", "endiet", "ENDio", "endserman", "angiana", "endedig", "endednet", " enderman", " endiar", "endsiar", " endiana", " endior", "endederman", "endedians", "endiar", "endien", " endio", "endedior", "endians", "angian", " endnet", "endsrian", "appendien", "appendian", "endsnet", "endediar", "angians", "endsig", "endig", "enderman", "endsian", " endien", "appendiet", "endior", "ENDien", "endediana", "endsior"], "x": ["z", "c", "d", "image", "ix", " image", " X", "X", "num", " index", "o", "dx", "win", "f", "n", "index", "v", "r", "ex", "l", "g"], "y": ["height", "z", "b", "m", "c", "dy", "d", "phi", "vy", "u", "e", "o", "Y", "f", "n", "t", "a", "q", "v", "r", "l", "hi", "g"], "i": ["b", "m", "c", "ix", "mi", "phi", "it", "io", "u", "xi", "ii", "ini", "si", "ai", "ni", "ci", "f", "I", "j", "index", "ip", "v", "pi", "l", "hi"], "ret": ["ref", "temp", "code", "ft", "res", "info", "flag", "back", "no", "success", "fail", "att", "def", "error", "id", "rets", "mem", "get", "tmp", "bit", "lit", "det", "RET", "re", "nt", "reply", "rc", "utf", "feat", "bad", "timeout", "Ret", "count", "entry", "rt", "used", "status", "part", "alt", "reg", "resp", "value", "match", "out", "r", "result", "len", "val", "fun"], "w": ["height", "ow", "kw", "k", "z", "b", "m", "ww", "c", "sh", "d", "wo", "wb", "sw", "weight", "wh", "end", "u", "wx", "hw", "max", "work", "l", "wl", "fw", "wd", "ew", "size", "win", "wid", "wal", "f", "wt", "aw", "n", "W", "t", "q", "v", "r", "we", "wi", "wa", " W", "g"], "h": ["height", "hm", "ht", "z", "m", "b", "c", "sh", "d", "hr", "hd", "ih", "bh", "H", "end", "ah", "u", "uh", "e", "hp", "o", "padding", "rh", "ul", "hs", "size", "gh", "f", "n", "ha", "q", "v", "r", "l", "hi", "ph", "oh", "g"], "bits_per_color": ["bits_per_colour", "bits_per_texture", "bits_per_pixel", "bits_perfcolor", "bits_perftexture", "bits_perfpixel", "bits_per_channel", "bits_perfsize", "bits_per_size"], "descriptor": ["desccriptors", "descructors", "descributor", "escriptcer", "decributoring", "descstructoring", "desccription", "descstructor", "descributoring", "describution", "esccriptor", "descpectoring", "descpectors", "decriptOR", "escriptor", "descruction", "decributor", "descpection", "descriptors", "desccriptcer", "descriptOR", "descriptcer", "descpector", "escription", "descpectOR", "escriptors", "decriptoring", "decributOR", "esccriptors", "decribution", "descstructOR", "desccriptor", "esccriptcer", "descructor", "descributOR", "decription", "descstruction", "esccription", "decriptor", "description", "descpectcer", "descructcer", "descriptoring"], "elements": ["peodes", "element", "Eles", "pelement", " element", " eles", "pelements", "Eodes", "Elements", "eles", "eodes", "peles", "Element", " eodes"], "packing": ["space", "mask", "kw", "secret", "adding", "slice", "setting", "reading", "stuff", "pkg", "using", "buffer", "queue", "storage", "capacity", "ping", "counter", "rows", "loading", "extra", "padding", "spec", "tracking", "sequence", "writing", "including", "xff", "ipping", "missing", "xxx", "checking", "packed", "processing", "working", "leading", "ending", "checks", "running", "icing", "pack", "aging", "packs", "power"], "total_size": ["total_sum", "total_count", "total67size", "total67sum", " total_count", "total67count", " total_sum", " total_len", "total_len", "total67len"]}}
{"project": "FFmpeg", "commit_id": "a38758a97efe9c2de48b5429fd2fdebd55ba6a64", "target": 1, "func": "int ff_h264_fill_default_ref_list(H264Context *h, H264SliceContext *sl)\n\n{\n\n    int i, len;\n\n\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {\n\n        H264Picture *sorted[32];\n\n        int cur_poc, list;\n\n        int lens[2];\n\n\n\n        if (FIELD_PICTURE(h))\n\n            cur_poc = h->cur_pic_ptr->field_poc[h->picture_structure == PICT_BOTTOM_FIELD];\n\n        else\n\n            cur_poc = h->cur_pic_ptr->poc;\n\n\n\n        for (list = 0; list < 2; list++) {\n\n            len  = add_sorted(sorted,       h->short_ref, h->short_ref_count, cur_poc, 1 ^ list);\n\n            len += add_sorted(sorted + len, h->short_ref, h->short_ref_count, cur_poc, 0 ^ list);\n\n            av_assert0(len <= 32);\n\n\n\n            len  = build_def_list(h->default_ref_list[list], FF_ARRAY_ELEMS(h->default_ref_list[0]),\n\n                                  sorted, len, 0, h->picture_structure);\n\n            len += build_def_list(h->default_ref_list[list] + len,\n\n                                  FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,\n\n                                  h->long_ref, 16, 1, h->picture_structure);\n\n            av_assert0(len <= 32);\n\n\n\n            if (len < sl->ref_count[list])\n\n                memset(&h->default_ref_list[list][len], 0, sizeof(H264Ref) * (sl->ref_count[list] - len));\n\n            lens[list] = len;\n\n        }\n\n\n\n        if (lens[0] == lens[1] && lens[1] > 1) {\n\n            for (i = 0; i < lens[0] &&\n\n                        h->default_ref_list[0][i].parent->f.buf[0]->buffer ==\n\n                        h->default_ref_list[1][i].parent->f.buf[0]->buffer; i++);\n\n            if (i == lens[0]) {\n\n                FFSWAP(H264Ref, h->default_ref_list[1][0], h->default_ref_list[1][1]);\n\n            }\n\n        }\n\n    } else {\n\n        len  = build_def_list(h->default_ref_list[0], FF_ARRAY_ELEMS(h->default_ref_list[0]),\n\n                              h->short_ref, h->short_ref_count, 0, h->picture_structure);\n\n        len += build_def_list(h->default_ref_list[0] + len,\n\n                              FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,\n\n                              h-> long_ref, 16, 1, h->picture_structure);\n\n        av_assert0(len <= 32);\n\n\n\n        if (len < sl->ref_count[0])\n\n            memset(&h->default_ref_list[0][len], 0, sizeof(H264Ref) * (sl->ref_count[0] - len));\n\n    }\n\n#ifdef TRACE\n\n    for (i = 0; i < sl->ref_count[0]; i++) {\n\n        tprintf(h->avctx, \"List0: %s fn:%d 0x%p\\n\",\n\n                (h->default_ref_list[0][i].parent->long_ref ? \"LT\" : \"ST\"),\n\n                h->default_ref_list[0][i].pic_id,\n\n                h->default_ref_list[0][i].parent->f.data[0]);\n\n    }\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {\n\n        for (i = 0; i < sl->ref_count[1]; i++) {\n\n            tprintf(h->avctx, \"List1: %s fn:%d 0x%p\\n\",\n\n                    (h->default_ref_list[1][i].parent->long_ref ? \"LT\" : \"ST\"),\n\n                    h->default_ref_list[1][i].pic_id,\n\n                    h->default_ref_list[1][i].parent->f.data[0]);\n\n        }\n\n    }\n\n#endif\n\n    return 0;\n\n}\n", "idx": 24818, "substitutes": {"h": ["her", "hm", "hel", "ht", "th", "w", "z", "p", "m", "c", "kh", "hash", "b", "image", "hd", "hr", "history", "img", "ih", "hist", "en", "bh", "H", "hh", "FH", "ch", "ah", "uh", "u", "hl", "e", "hp", "hw", "o", "rh", "dh", "http", "s", "ul", "adh", "hs", "ctx", "gh", "eh", "f", "t", "host", "ha", "header", "enh", "v", "q", "zh", "g", "r", "l", "hi", "he", "ph", "oh", "sh"], "sl": ["sch", "sc", "SL", "tl", "ml", "sn", "p", "spl", "c", "sw", "api", "ph", "ih", "cur", "util", "fr", "url", "su", "sth", "hl", "al", "el", "cl", "s", "ul", "lr", "loc", "l", "pl", "fl", "si", "sel", "sb", "sec", "gl", "sa", "il", "lc", "serv", "ls", "f", "sil", "src", "coll", "Sl", "sf", "ssl", "kl", "sh"], "i": ["code", "z", "ie", "p", "b", "yi", "c", "d", "ix", "x", "ti", "phi", "qi", "ri", "id", "num", "ani", "ui", "u", "io", "e", "li", "ji", "gi", "zi", "start", "xi", "ii", "bi", "ini", "ai", "di", "ni", "si", "ci", "fi", "eni", "field", "I", "f", "count", "ki", "n", "j", "index", "ip", "chi", "y", "iu", "ind", "v", "pi", "pos", "r", "l", "mu"], "len": ["ref", "L", "fin", "z", "ie", "name", "ld", "num", "url", "split", "lf", "el", "li", "min", "lu", "lit", "lang", "dl", "lib", "lin", "fl", "syn", "part", "lp", "n", "limit", "val", "body", "p", "en", "ler", "lon", "line", "cache", "il", "fun", "bin", "bl", "compl", "span", "Len", "str", "err", "la", "led", "le", "size", "length", "lc", "count", "sil", "pos", "seq", "ll", "fn", "vec", "id", "ul", "rev", "lt", "vert", "ln", "elt", "conn", "lim", "v", "pre", "l"], "sorted": ["islied", "sitesressed", "opensressed", "fources", "unsort", "unsorter", "sorting", " sort", "gorted", " sorter", "gorting", "Sort", "isressed", "sources", "siteslied", "sorter", "isored", "psources", " sources", "unsorted", "sitesored", "psorted", "sitesorted", "opensored", "gorter", "Sorting", "psorts", "psorting", "slied", "opensorted", "sort", "openslied", "Sorted", " sorters", "sorters", "sored", "gort", "sorts", "forts", "Sorter", " sorting", "sressed", "forting", " sorts", "forted", "isorted", "Sorters", "unsorters"], "cur_poc": ["cur_mpac", "cur_Pect", "cur_joc", "cur_POC", "cur_peroint", "cur_fOC", "cur_vpect", "cur_Poo", "cur_proc", "cur_phpoc", "cur_mpoc", "cur_npoo", "cur_soc", "cur_perow", "cur_npac", "cur_vpock", "cur_Pow", "cur_vpac", "cur_peroc", "cur_point", "cur_pac", "cur_phproc", "cur_sac", "cur_soint", "cur_mproc", "cur_poo", "cur_Perc", "cur_ferc", "cur_wpoc", "cur_perac", "cur_npoci", "cur_phpoint", "cur_Proc", "cur_vpoc", "cur_perc", "cur_Poc", "cur_Pac", "cur_piac", "cur_pOC", "cur_wpac", "cur_wpoci", "cur_Point", "cur_pioc", "cur_piect", "cur_Pock", "cur_jOC", "cur_fac", "cur_jac", "cur_mpoint", "cur_wpoo", "cur_pock", "cur_pect", "cur_piock", "cur_sow", "cur_jerc", "cur_Poci", "cur_foc", "cur_pow", "cur_npoc", "cur_phpac", "cur_poci"], "list": ["chain", "L", "acl", "batch", "keep", "name", "base", "ld", "hl", "li", "arr", "cl", "lu", "lat", "set", "dl", "st", "part", "lp", "entry", "n", "match", "val", "code", "low", "tl", "p", "c", "x", "test", "queue", "en", "diff", "ler", "key", "old", "cache", "feat", "lv", "coll", "block", "g", "load", "rest", "this", "bl", "cont", "all", "e", "str", "err", "la", "pl", "cli", "parent", "view", "length", "lc", "count", "alt", "null", "full", "pos", "seq", "page", "config", "lex", "type", "id", "List", "rel", "ul", "gl", "lists", "listed", "loop", "LIST", "index", "v", "pre", "range", "l"], "lens": ["Lens", "slen", " loss", "elen", " lizes", "olening", " lenses", " lkens", "slens", "elenth", "lents", "lening", "lenth", "celkens", "olkens", "flents", "Lents", "elents", "lkens", "celening", "Lenth", "elowers", "Len", " lents", " lenth", "celens", "elenses", "olenth", "flens", "sloss", "loss", "eloss", "flowers", "lizes", "slenth", "slenses", "elizes", "flizes", " lowers", "lenses", "lowers", "slents", " lening", "olens", "Lenses", "Loss", "elens", "celenth"]}}
{"project": "FFmpeg", "commit_id": "18516d3e695980525bd9758dc7b8a8e36cd3f09e", "target": 1, "func": "static int dxva2_map_frame(AVHWFramesContext *ctx, AVFrame *dst, const AVFrame *src,\n\n                           int flags)\n\n{\n\n    IDirect3DSurface9 *surface = (IDirect3DSurface9*)src->data[3];\n\n    DXVA2Mapping      *map;\n\n    D3DSURFACE_DESC    surfaceDesc;\n\n    D3DLOCKED_RECT     LockedRect;\n\n    HRESULT            hr;\n\n    int i, err, nb_planes;\n\n    int lock_flags = 0;\n\n\n\n    nb_planes = av_pix_fmt_count_planes(dst->format);\n\n\n\n    hr = IDirect3DSurface9_GetDesc(surface, &surfaceDesc);\n\n    if (FAILED(hr)) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Error getting a surface description\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    if (!(flags & AV_HWFRAME_MAP_WRITE))\n\n        lock_flags |= D3DLOCK_READONLY;\n\n    if (flags & AV_HWFRAME_MAP_OVERWRITE)\n\n        lock_flags |= D3DLOCK_DISCARD;\n\n\n\n    hr = IDirect3DSurface9_LockRect(surface, &LockedRect, NULL, lock_flags);\n\n    if (FAILED(hr)) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unable to lock DXVA2 surface\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    map = av_mallocz(sizeof(*map));\n\n    if (!map)\n\n        goto fail;\n\n\n\n    err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,\n\n                                dxva2_unmap_frame, map);\n\n    if (err < 0) {\n\n        av_freep(&map);\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < nb_planes; i++)\n\n        dst->linesize[i] = LockedRect.Pitch;\n\n\n\n    av_image_fill_pointers(dst->data, dst->format, surfaceDesc.Height,\n\n                           (uint8_t*)LockedRect.pBits, dst->linesize);\n\n\n\n    if (dst->format == AV_PIX_FMT_PAL8)\n\n        dst->data[1] = (uint8_t*)map->palette_dummy;\n\n\n\n    return 0;\n\nfail:\n\n    IDirect3DSurface9_UnlockRect(surface);\n\n    return err;\n\n}\n", "idx": 21037, "substitutes": {"ctx": ["conv", "lc", "bc", "txt", "cam", "wcs", "cc", "support", "conn", "sci", "config", "pkg", "cv", "kt", "cm", "tx", "ca", "anc", "cas", "fp", "cmp", "ci", "nc", "cmd", "cp", "setup", "xc", "cs", "ctrl", "kb", "context", "cf", "cli", "rc", "c", "cb", "client", "cn", "sc", "ann", "qa", "fw", "loc", "cca", "utils", "wx", "cms", "kw", "ck", "sq", "vc"], "dst": ["Dst", "adsc", "sdste", "Dsc", "post", "dist", "idust", "wust", "sdst", "sdsts", "Dsts", "nste", "pdst", "idsts", "Dste", "dnsc", "Dost", "wst", " dost", "idste", "dsc", "fdsp", " dsc", "idst", "nst", "dsost", "adST", "sdsc", "adst", "nist", " dstream", "dste", "Dput", "pST", " dsp", "wput", "dnsts", "DST", " dST", "dsp", "idist", "nsts", "dost", "fdstream", " dstack", "fdsc", "dssc", "Drest", "dust", "dstream", " dste", "pdsts", "wsts", " dsts", "dnost", "fdst", "adost", "dsst", "dsST", "psc", " drest", "dST", "pdstack", "dnrest", "idput", "dstack", "pst", "dsts", "pdsc", "Dust", "drest", "dnsp", "dput", "dnstream", "dnst", "Dstack", "Dist"], "src": ["conv", "bc", "pb", "sb", "sel", "support", "uc", "sl", "scene", "cv", "impl", "func", "rin", "cur", "img", "scl", "sth", "rob", "storage", "ssl", "setup", "sync", "buf", "rc", "reflect", "cb", "source", "roc", "sc", "RC", "sr", "rl", "sub", "ptr", "sur", "inst", "sup", "loc", "req", "st", "proc", "dest", "rb", "stream", "bs", "sn", "sq", "gb"], "flags": ["ips", "types", "ints", "fs", "features", "xs", "lines", "locks", "ops", "properties", "nl", "fps", "planes", "args", "faces", "vals", "ports", "stats", "ants", "settings", "Flags", "lag", "frames", "styles", "bits", "limits", "flag", "FLAG", "fl", "fd", "details", "mask", "ns", "fields", "utils", "options", "alls", "lf", "links", "ats", "files", "atts", "fi", "format"], "surface": ["package", "port", "area", "sym", "sample", "scene", "ser", "metadata", "rect", "pad", "cur", "layer", "dra", "slave", "FACE", "master", "data", "faces", "sheet", "ample", "sa", "filename", "tile", "reflect", "source", "sea", "material", "sc", "sr", "ptr", "face", "sur", "save", "desc", "slice", "sf", " Surface", "skin", "cover", "aster", "sta", "texture"], "map": ["port", "plane", "shape", "ap", "app", "scale", "maps", "apper", "file", "pad", "bridge", "wave", "node", "img", "per", "master", "address", "m", "Map", "data", "cache", "msg", "zip", "lock", "arr", "change", "code", "work", "addr", "mi", "tool", "tile", "move", "module", "pl", "match", "sh", "mp", "create", "replace", "mem", "rule", "save", "mage", "mask", "bm", "test", "co", "mg", "ape", "MAP", "image", "ge", "cover", "pack", "block", "scope", "aster", "cap"], "surfaceDesc": ["surfaceInfo", "faceDescription", " surfaceDescription", "faceInfo", " SurfaceDesc", "sourceDes", " SurfaceStruct", "sourceStruct", " surfaceDes", " surfacedesc", "surfaceDescription", "surfaceDes", " SurfaceInfo", "faceDesc", "surfacedesc", " Surfacedesc", "sourceDesc", "sourceDescription", " surfaceStruct", "sourcedesc", "facedesc", "faceDes", "surfaceStruct", " surfaceInfo", " SurfaceDescription"], "LockedRect": ["LockerRect", "LlockedRect", "IlotedRect", "LockingRECT", "LockRECT", "Liedrect", "LockerRECT", "Blockedrect", " LockingText", " LockingRECT", "LockedBox", "Slockingrect", "LiedRect", "BlockingRect", "IlockedText", "LotedText", "LockingRect", " LockedText", "Lockingrect", "Lockerrect", "IlockedRect", "LippedRECT", "Lockrect", "IlotedBox", "Slockedrect", "LockerText", "LlockedText", " Lockedrect", " Lockingrect", "LockingText", " LockedRECT", "LotedRect", "LotedRECT", "LockRect", "LrictedRect", "Llockedrect", "BlockedRect", "LotedBox", "LrictedRECT", "Lippedrect", "SlockedRECT", " LockingRect", "BlockingRECT", "Blockingrect", "IlotedText", "SlockingRECT", "BlockedRECT", "LlockedRECT", "LockingBox", "IlockedRECT", "Lockedrect", "IlotedRECT", "LockedText", "IlockedBox", "SlockingRect", "LiedRECT", "LippedRect", "SlockedRect", "LrictedBox", "LockedRECT", "LrictedText"], "hr": ["ih", "str", "e", "rd", "ig", "ref", "ride", "sl", "g", "cv", "ctr", "rx", "rin", "rr", "wr", "tr", "rec", "yr", "img", "lr", "f", "hei", "r", "s", "her", "p", "arr", "rh", "code", "dr", "rc", "fe", "resh", "fr", "pr", "roc", "shr", "ar", "RR", "a", "vr", "sr", "pull", "ocr", "hl", "cr", "er", "gr", "br", "mr", "req", "HR", "rs", "hour", "kr", "h", "ir", "ec", "rg"], "i": ["io", "uli", "ix", "start", "ik", "ie", "fi", "qi", "e", "ind", "ri", "ui", "eni", "gi", "d", "uri", "ti", "I", "l", "f", "layer", "ci", "y", "t", "phi", "r", "info", "ini", "it", "j", "oi", "u", "adi", "p", "ip", "id", "code", "ani", "mi", "c", "index", "si", "ii", "b", "line", "n", "iu", "ai", "xi", "di", "multi", "v", "li", "h", "pi", "x", "zi", "k", "ni", "ori"], "err": ["str", "delay", "ind", "ctr", "der", "Er", "rr", "yr", "r", "init", "cache", "bug", "arr", "act", "or", "rh", "code", "inner", "dy", "dr", "cb", "nr", "fr", "ar", "rar", "ver", "sr", "arm", "error", "min", "magic", "er", "gr", "len", "loc", "test", "iter", "req", "mr", "try", "br", "ner", "rage", "ler", "user", "kr", "ir", "fi", "resp", "attr"], "nb_planes": ["nbOfviews", "nbxframes", "nb_rows", "nbxviews", "nb_plates", "np_frames", "nb__frames", "npxframes", "npxplates", "nb_liners", "lnOflevels", "lnOfviews", "npxplanes", "nballrows", "nballplanes", "lnOfplanes", "npxrows", "nbxrows", "nbxlevels", "np_rows", "nbxplates", "nbxplanes", "np_planes", "num_bands", "nb_levels", "nb_views", "nbOfplanes", "lnOfbands", "num_liners", "nb_frames", "nbOflevels", "nballplates", "ln_views", "np_plates", "nballframes", "ln_planes", "nb_bands", "nbxbands", "num_frames", "nb__plates", "nb__rows", "num_planes", "nbOfbands", "nb__planes", "ln_bands", "ln_levels"]}}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int encode_frame(FlacEncodeContext *s)\n\n{\n\n    int ch, count;\n\n\n\n    count = count_frame_header(s);\n\n\n\n    for (ch = 0; ch < s->channels; ch++)\n\n        count += encode_residual_ch(s, ch);\n\n\n\n    count += (8 - (count & 7)) & 7; // byte alignment\n\n    count += 16;                    // CRC-16\n\n\n\n    return count >> 3;\n\n}\n", "idx": 12429, "substitutes": {"s": ["south", "sys", "ses", "m", "self", "d", "t", "sg", "fs", "i", "rs", "sym", "ches", "a", "g", "cs", "qs", "S", "settings", "os", "sets", "si", "es", "js", "sq", "conf", "ss", "o", "p", "e", "ions", "http", "sf", "sb", "b", "f", "gs", "c", "ns", "xs", "is", "ssl", "ops", "services", "cpp", "ds", "ts", "ctx", "ks"], "ch": ["channel", "che", "patch", "enc", "ach", "code", "i", "CH", "cht", "cor", "h", "sk", "v", "cha", "conf", "app", "cher", "mot", "conn", "ech", "col", "och", "sch", "ind", "dev", "p", "e", "arch", "chart", "cry", "cho", "chn", "k", "anch", "b", "length", "f", "Ch", "th", "bh", "oy", "c", "chan", "cb", "chi", "ht", "ich", "q", "change", "ur", "coll", "zh", "cp", "sh", "work", "el", "y", "err"], "count": ["call", "carry", "build", "allow", "cc", "id", "code", "l", "child", "current", "range", "name", "cond", "low", "weight", "sum", "comment", "key", "force", "error", "conf", "catch", "col", "size", "ind", "Count", "p", "found", "e", "max", "base", "length", "f", "n", "list", "c", "start", "try", "find", "type", "offset", "now", "body", "process", "cache", "num", "cur", "core", "len", "depth", "index", "err"]}}
{"project": "FFmpeg", "commit_id": "c0175fa92b7edd45a06e4ab16c8e83da0c94a9f6", "target": 1, "func": "static int roq_read_packet(AVFormatContext *s,\n\n                           AVPacket *pkt)\n\n{\n\n    RoqDemuxContext *roq = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int ret = 0;\n\n    unsigned int chunk_size;\n\n    unsigned int chunk_type;\n\n    unsigned int codebook_size;\n\n    unsigned char preamble[RoQ_CHUNK_PREAMBLE_SIZE];\n\n    int packet_read = 0;\n\n    int64_t codebook_offset;\n\n\n\n    while (!packet_read) {\n\n\n\n        if (avio_feof(s->pb))\n\n            return AVERROR(EIO);\n\n\n\n        /* get the next chunk preamble */\n\n        if ((ret = avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE)) !=\n\n            RoQ_CHUNK_PREAMBLE_SIZE)\n\n            return AVERROR(EIO);\n\n\n\n        chunk_type = AV_RL16(&preamble[0]);\n\n        chunk_size = AV_RL32(&preamble[2]);\n\n        if(chunk_size > INT_MAX)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        chunk_size = ffio_limit(pb, chunk_size);\n\n\n\n        switch (chunk_type) {\n\n\n\n        case RoQ_INFO:\n\n            if (roq->video_stream_index == -1) {\n\n                AVStream *st = avformat_new_stream(s, NULL);\n\n                if (!st)\n\n                    return AVERROR(ENOMEM);\n\n                avpriv_set_pts_info(st, 63, 1, roq->frame_rate);\n\n                roq->video_stream_index = st->index;\n\n                st->codecpar->codec_type   = AVMEDIA_TYPE_VIDEO;\n\n                st->codecpar->codec_id     = AV_CODEC_ID_ROQ;\n\n                st->codecpar->codec_tag    = 0;  /* no fourcc */\n\n\n\n                if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) != RoQ_CHUNK_PREAMBLE_SIZE)\n\n                    return AVERROR(EIO);\n\n                st->codecpar->width  = roq->width  = AV_RL16(preamble);\n\n                st->codecpar->height = roq->height = AV_RL16(preamble + 2);\n\n                break;\n\n            }\n\n            /* don't care about this chunk anymore */\n\n            avio_skip(pb, RoQ_CHUNK_PREAMBLE_SIZE);\n\n            break;\n\n\n\n        case RoQ_QUAD_CODEBOOK:\n\n            if (roq->video_stream_index < 0)\n\n                return AVERROR_INVALIDDATA;\n\n            /* packet needs to contain both this codebook and next VQ chunk */\n\n            codebook_offset = avio_tell(pb) - RoQ_CHUNK_PREAMBLE_SIZE;\n\n            codebook_size = chunk_size;\n\n            avio_skip(pb, codebook_size);\n\n            if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) !=\n\n                RoQ_CHUNK_PREAMBLE_SIZE)\n\n                return AVERROR(EIO);\n\n            chunk_size = AV_RL32(&preamble[2]) + RoQ_CHUNK_PREAMBLE_SIZE * 2 +\n\n                codebook_size;\n\n\n\n            if (chunk_size > INT_MAX)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            /* rewind */\n\n            avio_seek(pb, codebook_offset, SEEK_SET);\n\n\n\n            /* load up the packet */\n\n            ret= av_get_packet(pb, pkt, chunk_size);\n\n            if (ret != chunk_size)\n\n                return AVERROR(EIO);\n\n            pkt->stream_index = roq->video_stream_index;\n\n            pkt->pts = roq->video_pts++;\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        case RoQ_SOUND_MONO:\n\n        case RoQ_SOUND_STEREO:\n\n            if (roq->audio_stream_index == -1) {\n\n                AVStream *st = avformat_new_stream(s, NULL);\n\n                if (!st)\n\n                    return AVERROR(ENOMEM);\n\n                avpriv_set_pts_info(st, 32, 1, RoQ_AUDIO_SAMPLE_RATE);\n\n                roq->audio_stream_index = st->index;\n\n                st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n\n                st->codecpar->codec_id = AV_CODEC_ID_ROQ_DPCM;\n\n                st->codecpar->codec_tag = 0;  /* no tag */\n\n                if (chunk_type == RoQ_SOUND_STEREO) {\n\n                    st->codecpar->channels       = 2;\n\n                    st->codecpar->channel_layout = AV_CH_LAYOUT_STEREO;\n\n                } else {\n\n                    st->codecpar->channels       = 1;\n\n                    st->codecpar->channel_layout = AV_CH_LAYOUT_MONO;\n\n                }\n\n                roq->audio_channels    = st->codecpar->channels;\n\n                st->codecpar->sample_rate = RoQ_AUDIO_SAMPLE_RATE;\n\n                st->codecpar->bits_per_coded_sample = 16;\n\n                st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *\n\n                    st->codecpar->bits_per_coded_sample;\n\n                st->codecpar->block_align = st->codecpar->channels * st->codecpar->bits_per_coded_sample;\n\n            }\n\n        case RoQ_QUAD_VQ:\n\n            if (chunk_type == RoQ_QUAD_VQ) {\n\n                if (roq->video_stream_index < 0)\n\n                    return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            /* load up the packet */\n\n            if (av_new_packet(pkt, chunk_size + RoQ_CHUNK_PREAMBLE_SIZE))\n\n                return AVERROR(EIO);\n\n            /* copy over preamble */\n\n            memcpy(pkt->data, preamble, RoQ_CHUNK_PREAMBLE_SIZE);\n\n\n\n            if (chunk_type == RoQ_QUAD_VQ) {\n\n                pkt->stream_index = roq->video_stream_index;\n\n                pkt->pts = roq->video_pts++;\n\n            } else {\n\n                pkt->stream_index = roq->audio_stream_index;\n\n                pkt->pts = roq->audio_frame_count;\n\n                roq->audio_frame_count += (chunk_size / roq->audio_channels);\n\n            }\n\n\n\n            pkt->pos= avio_tell(pb);\n\n            ret = avio_read(pb, pkt->data + RoQ_CHUNK_PREAMBLE_SIZE,\n\n                chunk_size);\n\n            if (ret != chunk_size)\n\n                ret = AVERROR(EIO);\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"  unknown RoQ chunk (%04X)\\n\", chunk_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22426, "substitutes": {"s": ["sim", "sv", "sb", "e", "sed", "support", "sym", "qs", "sie", "sl", "sci", "g", "ses", "xs", "d", "sets", "ops", "ks", "ds", "services", "f", "sys", "t", "r", "ssl", "os", "p", "cs", "ls", "sync", "stats", "sa", "sg", "c", "js", "self", "spec", "single", "sq", "client", "si", "sc", "sr", "b", "service", "aws", "session", "S", "ns", "sf", "south", "ps", "gs", "rs", "conf", "su", "ss"], "pkt": ["Packet", "ppkt", "ppct", " pct", "ppacket", " packet", "Pct", "psth", " psth", "pct", "Pkt", "packet", "Psth", "ppsth"], "roq": ["boq", "boqa", "roqs", " roqu", "ROq", "riflow", "troqs", "broquest", "roqu", "grok", "proqs", "groquest", "groq", "croqa", "croq", "groqt", "rouqu", "croqt", "troqu", "koqu", " roQ", "broqs", "bok", "troz", "troQ", "roz", "troquest", "resourceqa", "groqa", "ROql", "rok", "rouquest", "roqt", "groqs", "roqa", "ROqt", "koq", "croqs", "rouQ", "ROqa", "rouq", "roql", "groqu", "troq", " roquest", "koQ", "rik", "resourcez", "roQ", "groQ", "roflow", "troqa", "proq", "broz", "broq", "boflow", "riq", "resourceql", "troql", "roquest", "ROqs", "ROz", "proquest", "proz", "riqa", "groflow", "resourceq", "koquest"], "pb": ["platform", "bc", "sb", "fc", "summary", "uf", "lb", "lp", "prot", "pkg", "cv", "db", "fb", "pm", "bb", "pit", "phrase", "pd", "bp", "pc", "plugin", "fp", "pg", "gb", "rob", "eb", "lab", "cp", "PB", "tp", "pp", "p", "np", "wb", "bps", "ctx", "cb", "pl", "ib", "wp", "mp", "b", "ub", "cpp", "tmp", "hub", "bm", "ab", "bh", "bs", "rb", "vp", "typ", "xb", "dp", "ppa", "pa"], "chunk_size": ["chunklexsum", "chick_number", "chunks_size", "chunk_cache", "chunkactype", "chunklexSIZE", "chunks_type", "chunkacsn", "chunk_sn", "chunk_number", "chickersized", "chummy_speed", "chunks_strength", "chunkerid", "chunks_sn", "chummy_value", "chunk_sized", "chunc_size", "chunk_weight", "chunc_sum", "chick_sized", "chunkersized", "chunkersize", "chunk_strength", "chunkacsize", "chunk_speed", "chickersize", "chick_size", "chunk_value", "chummy_form", "chunkacstrength", "chunklexlength", "chummy_size", "chunklexsize", "chunc_SIZE", "chunk_sum", "chunkernumber", "chunk_length", "chunc_length", "chick_id", "chickernumber", "chunk_form", "chunk_id", "chickerid", "chunk_SIZE"], "chunk_type": ["chunk_family", "chunk6style", "chunknid", "chunker_number", "chunker_id", "chunkertype", "chunk8type", "chunk_name", "chunk_style", "chunknname", "chunker_type", "chunk8id", "chunk8index", "chunkerindex", "chunknnumber", "chunk_id", "chunk_number", "chunk6family", "chunk_index", "chunk6size", "chunkersize", "chunkerid", "chunk6type", "chunk8size", "chunker_name", "chunkntype"], "codebook_size": ["codebox_capacity", "codebox_length", "codebookssize", "codebox_size", "codebookscapacity", "codebook_length", "codebox_len", "codebookslength", "codebookslen", "codebook_len", "codebook_capacity"], "preamble": ["promle", "pamble", " preambled", "pawnbled", "prawbles", " pepble", "Prambled", "PramBLE", "Pramle", "ppREAMback", "Preambler", "Preamback", "ppreamBLE", "pREAMle", "pymback", "pambled", "piddBLE", "pramBLE", "pepBLE", "PREAMbler", " pepl", "pepback", "pucbles", " peple", "piddle", "praml", "promble", "prawback", "pREAMbled", "pREAMbe", "preamle", "Preambe", "pREAMback", "pawnle", "pREAMl", "PreamBLE", " pepbled", "pawnBLE", "pepble", "piddbled", "prambles", "pucble", "PREAMl", "preamback", "Preamle", "piddble", "pepl", "pymble", "prawble", "Preambles", "preambled", "preambler", "pymbler", "prambled", "Pramble", "preambe", "ppreamle", "pyml", "Prambles", "pamle", "Prambe", "pramle", "pREAMbler", "prawle", "PREAMble", "pREAMBLE", "pawnble", "prombled", "Preamble", " preamle", "pREAMble", "pramble", "proml", "pucbe", "ppREAMle", " preaml", "prawbe", "preaml", "Preaml", "preambles", "Preambled", "peple", "prawBLE", "pambe", "ppreamback", "pucle", "PREAMback", "pepbler", "pepbled", "ppreamble", "ppREAMBLE", "ppREAMble", "prambe", "preamBLE"], "codebook_offset": ["codeboard_position", "codeboard__offset", "codebook_position", "codebook_no", "codebook__len", "codebook__offset", "codeboard_len", "codeboard__len", "codeboard_no", "codeboard__position", "codebook__no", "codebook__position", "codeboard__no", "codebook_len", "codeboard_offset"], "st": ["lc", "str", "sv", "sb", "est", "ut", "stack", "start", "sk", "ast", "obj", "ct", "sl", "std", "ost", "kt", "St", "d", "tt", "mt", "ld", "bl", "sth", "art", "t", "rest", "nd", "ts", "sty", "sa", "fe", "sd", "et", "ste", "sh", "fr", "sc", "sts", "sr", "set", "tmp", "se", "spect", "sw", "inst", "src", "ist", "put", "stage", "ST", "nt", "sp", "sn", "stream", "pt", "ust", "sta", "ss", "ft"]}}
{"project": "FFmpeg", "commit_id": "2c90316b46fce5785bc6af72c8fd369c31666604", "target": 1, "func": "static int hls_read_header(AVFormatContext *s)\n\n{\n\n    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;\n\n    HLSContext *c = s->priv_data;\n\n    int ret = 0, i;\n\n    int highest_cur_seq_no = 0;\n\n\n\n    c->ctx                = s;\n\n    c->interrupt_callback = &s->interrupt_callback;\n\n    c->strict_std_compliance = s->strict_std_compliance;\n\n\n\n    c->first_packet = 1;\n\n    c->first_timestamp = AV_NOPTS_VALUE;\n\n    c->cur_timestamp = AV_NOPTS_VALUE;\n\n\n\n    if (u) {\n\n        // get the previous user agent & set back to null if string size is zero\n\n        update_options(&c->user_agent, \"user-agent\", u);\n\n\n\n        // get the previous cookies & set back to null if string size is zero\n\n        update_options(&c->cookies, \"cookies\", u);\n\n\n\n        // get the previous headers & set back to null if string size is zero\n\n        update_options(&c->headers, \"headers\", u);\n\n\n\n        // get the previous http proxt & set back to null if string size is zero\n\n        update_options(&c->http_proxy, \"http_proxy\", u);\n\n    }\n\n\n\n    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)\n\n        goto fail;\n\n\n\n    if ((ret = save_avio_options(s)) < 0)\n\n        goto fail;\n\n\n\n    /* Some HLS servers don't like being sent the range header */\n\n    av_dict_set(&c->avio_opts, \"seekable\", \"0\", 0);\n\n\n\n    if (c->n_variants == 0) {\n\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n\n        ret = AVERROR_EOF;\n\n        goto fail;\n\n    }\n\n    /* If the playlist only contained playlists (Master Playlist),\n\n     * parse each individual playlist. */\n\n    if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {\n\n        for (i = 0; i < c->n_playlists; i++) {\n\n            struct playlist *pls = c->playlists[i];\n\n            if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)\n\n                goto fail;\n\n        }\n\n    }\n\n\n\n    if (c->variants[0]->playlists[0]->n_segments == 0) {\n\n        av_log(NULL, AV_LOG_WARNING, \"Empty playlist\\n\");\n\n        ret = AVERROR_EOF;\n\n        goto fail;\n\n    }\n\n\n\n    /* If this isn't a live stream, calculate the total duration of the\n\n     * stream. */\n\n    if (c->variants[0]->playlists[0]->finished) {\n\n        int64_t duration = 0;\n\n        for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++)\n\n            duration += c->variants[0]->playlists[0]->segments[i]->duration;\n\n        s->duration = duration;\n\n    }\n\n\n\n    /* Associate renditions with variants */\n\n    for (i = 0; i < c->n_variants; i++) {\n\n        struct variant *var = c->variants[i];\n\n\n\n        if (var->audio_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group);\n\n        if (var->video_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group);\n\n        if (var->subtitles_group[0])\n\n            add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group);\n\n    }\n\n\n\n    /* Create a program for each variant */\n\n    for (i = 0; i < c->n_variants; i++) {\n\n        struct variant *v = c->variants[i];\n\n        AVProgram *program;\n\n\n\n        program = av_new_program(s, i);\n\n        if (!program)\n\n            goto fail;\n\n        av_dict_set_int(&program->metadata, \"variant_bitrate\", v->bandwidth, 0);\n\n    }\n\n\n\n    /* Select the starting segments */\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n\n\n        if (pls->n_segments == 0)\n\n            continue;\n\n\n\n        pls->cur_seq_no = select_cur_seq_no(c, pls);\n\n        highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no);\n\n    }\n\n\n\n    /* Open the demuxer for each playlist */\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n        AVInputFormat *in_fmt = NULL;\n\n\n\n        if (!(pls->ctx = avformat_alloc_context())) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n\n\n        if (pls->n_segments == 0)\n\n            continue;\n\n\n\n        pls->index  = i;\n\n        pls->needed = 1;\n\n        pls->parent = s;\n\n\n\n        /*\n\n         * If this is a live stream and this playlist looks like it is one segment\n\n         * behind, try to sync it up so that every substream starts at the same\n\n         * time position (so e.g. avformat_find_stream_info() will see packets from\n\n         * all active streams within the first few seconds). This is not very generic,\n\n         * though, as the sequence numbers are technically independent.\n\n         */\n\n        if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 &&\n\n            highest_cur_seq_no < pls->start_seq_no + pls->n_segments) {\n\n            pls->cur_seq_no = highest_cur_seq_no;\n\n        }\n\n\n\n        pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE);\n\n        if (!pls->read_buffer){\n\n            ret = AVERROR(ENOMEM);\n\n            avformat_free_context(pls->ctx);\n\n            pls->ctx = NULL;\n\n            goto fail;\n\n        }\n\n        ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls,\n\n                          read_data, NULL, NULL);\n\n        pls->pb.seekable = 0;\n\n        ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url,\n\n                                    NULL, 0, 0);\n\n        if (ret < 0) {\n\n            /* Free the ctx - it isn't initialized properly at this point,\n\n             * so avformat_close_input shouldn't be called. If\n\n             * avformat_open_input fails below, it frees and zeros the\n\n             * context, so it doesn't need any special treatment like this. */\n\n            av_log(s, AV_LOG_ERROR, \"Error when loading first segment '%s'\\n\", pls->segments[0]->url);\n\n            avformat_free_context(pls->ctx);\n\n            pls->ctx = NULL;\n\n            goto fail;\n\n        }\n\n        pls->ctx->pb       = &pls->pb;\n\n        pls->ctx->io_open  = nested_io_open;\n\n\n\n        if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)\n\n            goto fail;\n\n\n\n        ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL);\n\n        if (ret < 0)\n\n            goto fail;\n\n\n\n        if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) {\n\n            ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra);\n\n            avformat_queue_attached_pictures(pls->ctx);\n\n            ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);\n\n            pls->id3_deferred_extra = NULL;\n\n        }\n\n\n\n        if (pls->is_id3_timestamped == -1)\n\n            av_log(s, AV_LOG_WARNING, \"No expected HTTP requests have been made\\n\");\n\n\n\n        /*\n\n         * For ID3 timestamped raw audio streams we need to detect the packet\n\n         * durations to calculate timestamps in fill_timing_for_id3_timestamped_stream(),\n\n         * but for other streams we can rely on our user calling avformat_find_stream_info()\n\n         * on us if they want to.\n\n         */\n\n        if (pls->is_id3_timestamped) {\n\n            ret = avformat_find_stream_info(pls->ctx, NULL);\n\n            if (ret < 0)\n\n                goto fail;\n\n        }\n\n\n\n        pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER);\n\n\n\n        /* Create new AVStreams for each stream in this playlist */\n\n        ret = update_streams_from_subdemuxer(s, pls);\n\n        if (ret < 0)\n\n            goto fail;\n\n\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO);\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO);\n\n        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE);\n\n    }\n\n\n\n    update_noheader_flag(s);\n\n\n\n    return 0;\n\nfail:\n\n    free_playlist_list(c);\n\n    free_variant_list(c);\n\n    free_rendition_list(c);\n\n    return ret;\n\n}\n", "idx": 21925, "substitutes": {"s": ["sv", "sb", "e", "sym", "qs", "es", "sl", "fs", "g", "ses", "d", "sets", "ops", "site", "ks", "l", "ds", "services", "f", "sys", "t", "y", "r", "m", "args", "ssl", "os", "p", "cs", "ts", "o", "sync", "is", "sg", "ctx", "js", "spec", "settings", "sq", "si", "sc", "a", "b", "service", "se", "aws", "n", "S", "sup", "ns", "comments", "sf", "rs", "gs", "conf", "sec", "server", "su", "ss"], "u": ["ut", "ru", "uf", "e", "un", "ul", "uc", "eu", "ur", "ui", "g", "gnu", "you", "null", "uri", "ou", "l", "f", "t", "universal", "m", "ue", "lu", "p", "us", "uv", "uno", "tu", "tc", "o", "uci", "cli", "q", "client", "mu", "hu", "a", "b", "U", "uu", "iu", "util", "up", "user", "uid", "h", "nu", "su", "api", "cu"], "c": ["lc", "bc", "col", "fc", "arc", "cc", "e", "uc", "conn", "ct", "g", "this", "coll", "com", "cm", "d", "con", "rec", "ca", "pc", "cur", "cl", "f", "ci", "t", "nc", "cp", "ac", "m", "r", "cache", "cat", "p", "cf", "cs", "xc", "enc", "mc", "o", "client", "ctx", "cb", "cn", "ch", "sc", "b", "dc", "ic", "cy", "cr", "n", "C", "co", "ec", "ce", "conf", "sec", "h", "l", "cu", "k", "vc"], "i": ["io", "ix", "e", "ie", "qi", "ri", "ui", "eni", "g", "mini", "gi", "my", "uri", "d", "ti", "I", "f", "ci", "t", "y", "info", "m", "ini", "oi", "j", "phi", "p", "ip", "id", "o", "bi", "inner", "mi", "mu", "index", "si", "b", "ii", "x", "in", "n", "iu", "ai", "xi", "hi", "di", "multi", "yi", "li", "z", "h", "pi", "fi", "ni"], "pls": [" Plz", "plz", " plb", "pln", "PLn", " plgs", " plz", " pli", "coln", "plp", "PLp", "coli", " plp", " cls", "PLi", "PLs", " Pls", " Plp", " Plgs", "cols", " clgs", " Pli", " cli", " clz", "plb", " pln", "plgs", " Plb", "PLb", "pli"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,\n\n                                            const char *json_string)\n\n{\n\n    return visitor_input_test_init_internal(data, json_string, NULL);\n\n}\n", "idx": 17085, "substitutes": {"data": ["Data", "init", "view", "text", "base", "image", "json", "buffer", "input", "result", "window", "type", "raw", "model", "alpha", "self", "parser", "object", "empty", "database", "config", "start", "batch", "client", "parent", "da", "test", "cache", "dat", "null", "a", "DATA", "valid", "writer", "reader"], "json_string": ["json1list", "json_version", "query_text", "json2string", " json_data", "json1type", "json_type", " json_type", "json_data", "json1string", "json_list", "json1data", "json2strings", "query_strings", "json_strings", "query_string", "query_version", "json2version", " json_list", "json_text", "json2text"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_rt_frame(int usig, struct emulated_sigaction *ka, \n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUState *env)\n\n{\n\n\tstruct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));\n\n\tint err = 0;\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))\n\n            return 1;\n\n#endif\n\n\t__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);\n\n\t__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n\t/* Clear all the bits of the ucontext we don't use.  */\n\n\terr |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));\n\n\n\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/\n\n\t\t\t\tenv, set->sig[0]);\n\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\n\n\tif (err == 0)\n\n\t\terr = setup_return(env, ka, &frame->retcode, frame, usig);\n\n\n\n\tif (err == 0) {\n\n\t\t/*\n\n\t\t * For realtime signals we must also set the second and third\n\n\t\t * arguments for the signal handler.\n\n\t\t *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06\n\n\t\t */\n\n            env->regs[1] = (target_ulong)frame->pinfo;\n\n            env->regs[2] = (target_ulong)frame->puc;\n\n\t}\n\n\n\n        //\treturn err;\n\n}\n", "idx": 8145, "substitutes": {"usig": ["usigma", "rusigen", " usigen", "versigma", "usigs", " usigh", "usigh", "usesig", "usiger", " usiger", "rusig", "usesigen", "usigen", "rusigh", "usesigma", "usesigh", "usesiger", "versigs", " usigs", "versiger", "rusiger", "usesigs", "versig", " usigma"], "ka": ["ko", "KA", "ea", "na", "java", "ker", "aka", "ket", "a", "oka", "ua", "ki", "la", "channel", "config", "che", "ada", "oa", "wa", "ae", "market", "ia", "ya", "ma", "ga", "ra", "ema", "ai", "sc", "en", "da", "fram", "ctx", "sea", "ba", "ama", "qua", "context", "ca", "qa", "eni", "kee", "sa", "ta", "ke", "ja", "jam", "ku", "au", "ha", "ok"], "info": ["stat", "name", "area", "ret", "inf", "diff", "ui", "id", "http", "INFO", "ci", "config", "information", "si", "i", "alias", "inter", "abi", "raf", "image", "loc", "ir", "f", " inf", "isu", "ii", "fo", "py", "init", "ai", "conf", "code", "uri", "error", "mi", "ini", "where", "start", "hi", "txt", "api", "iso", "util", "desc", "fi", "index", "isf", "summary", "conn", "Info", "setup"], "set": ["stat", "base", "kit", "ch", "act", "sets", "reset", "build", "block", "not", "is", "spec", "dat", "send", "chain", "config", "setting", "get", "sem", "ex", "see", "sche", "use", "et", "SET", "update", "sys", "export", "Set", "state", "call", "init", "net", "match", "e", "sh", "sc", "section", "en", "se", "exec", "context", "parse", "ne", "ec", "settings", "ut", "run", "vert", "start", "gen", "ind", "sel", "c", "clear", "site", " en", "end", "setup"], "env": ["enable", "fen", "osc", "eng", "act", "ea", "ect", "ep", "v", "el", "ef", "vm", "dat", "scope", "config", "qt", "environment", "exc", "et", "enc", "eu", "inet", "db", "inc", "export", "ext", "state", "org", "obj", "esi", "server", "init", "net", "conf", "ev", "np", "e", "her", "que", "en", "dev", "ctx", "ini", "ey", "equ", "me", "context", "ne", "Environment", "ec", "req", "chn", "eni", "ner", "vert", "viron", "ind", "enos", "dt", "core", "ette", "cv", "manager", " en", "conn", "end", "dict"], "frame": ["flow", "layer", "position", "el", "component", "force", "object", "iframe", "style", "data", "ise", "invoke", "sequence", "f", "state", "flo", "code", "zone", "error", "connection", "file", "fram", "motion", "err", "framework", "boot", "cpu", "line", "fi", "view", "setup", "function", "base", "fire", "row", "build", "channel", "config", "update", "slice", "module", "fb", "fake", "driver", "ctx", "raise", "parse", "scale", "runner", "node", "ke", "class", "cf", "element", "ze", "feature", "game", "fr", "block", "show", "sche", "image", "Frame", "db", "profile", "version", "e", "point", "que", "message", "run", "ind", "cast", "thread", "core", "frames", "trace", "cfg", "coe", "scope", "session", "fact", "za", "event", "call", "fe", "init", "part", "plane", "load", "lock", "result", "context", "processor", "figure", "fc", "sample", "role"]}}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void xen_remap_bucket(MapCacheEntry *entry,\n\n                             hwaddr size,\n\n                             hwaddr address_index)\n\n{\n\n    uint8_t *vaddr_base;\n\n    xen_pfn_t *pfns;\n\n    int *err;\n\n    unsigned int i;\n\n    hwaddr nb_pfn = size >> XC_PAGE_SHIFT;\n\n\n\n    trace_xen_remap_bucket(address_index);\n\n\n\n    pfns = g_malloc0(nb_pfn * sizeof (xen_pfn_t));\n\n    err = g_malloc0(nb_pfn * sizeof (int));\n\n\n\n    if (entry->vaddr_base != NULL) {\n\n        if (munmap(entry->vaddr_base, entry->size) != 0) {\n\n            perror(\"unmap fails\");\n\n            exit(-1);\n\n        }\n\n    }\n\n    g_free(entry->valid_mapping);\n\n    entry->valid_mapping = NULL;\n\n\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        pfns[i] = (address_index << (MCACHE_BUCKET_SHIFT-XC_PAGE_SHIFT)) + i;\n\n    }\n\n\n\n    vaddr_base = xc_map_foreign_bulk(xen_xc, xen_domid, PROT_READ|PROT_WRITE,\n\n                                     pfns, err, nb_pfn);\n\n    if (vaddr_base == NULL) {\n\n        perror(\"xc_map_foreign_bulk\");\n\n        exit(-1);\n\n    }\n\n\n\n    entry->vaddr_base = vaddr_base;\n\n    entry->paddr_index = address_index;\n\n    entry->size = size;\n\n    entry->valid_mapping = (unsigned long *) g_malloc0(sizeof(unsigned long) *\n\n            BITS_TO_LONGS(size >> XC_PAGE_SHIFT));\n\n\n\n    bitmap_zero(entry->valid_mapping, nb_pfn);\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        if (!err[i]) {\n\n            bitmap_set(entry->valid_mapping, i, 1);\n\n        }\n\n    }\n\n\n\n    g_free(pfns);\n\n    g_free(err);\n\n}\n", "idx": 18512, "substitutes": {"entry": ["extra", "element", "comment", "service", "inc", "package", "ie", "enc", "import", "comp", "config", "end", "it", "command", "source", "reader", "plugin", " Entry", "archive", "name", "engine", "ge", "entity", "existing", "parse", "the", "Entry", "key", "update", "lc", "cat", "si", "table", "item", "cell", "row", "export", "connection", "ent", "view", "image", "component", "try", "match", "ry", "ae", "post", "address", "lock", "ace", "session", "record", "data", "info", "feed", "option", "enter", "module", "index", "member", "get", "parser", "ce", "event", "cel", "add", "e", "ries", "cur", "insert", "cache", "error", "server", "se", "inner"], "size": ["set", "offset", "file", "num", "six", "max", "strength", "sec", "empty", "location", "sh", "new", "path", "large", "length", "send", "external", "bytes", "Size", "len", "scale", "content", "name", "handle", "engine", "from", "cm", "timeout", "count", "si", "shift", "gz", "weight", "code", "time", "core", "SIZE", "sized", "block", "loc", "speed", "memory", "sn", "ize", "security", "sync", "c", "address", "fee", "sum", "s", "small", "capacity", "data", "mode", "shape", "gc", "password", "member", "ui", "use", "limit", "e", "unit", "cache", "storage", "number", "body"], "address_index": ["address_ind", "ip_id", "position_index", "address_length", "address2index", " address_position", " address_address", "address2Index", "ip__slice", "address__id", "address2prefix", "address__address", "address__slice", " address_length", "address__index", " address_ind", "position2index", "address_Index", "position_offset", "position_prefix", "address_start", "address_position", "address2id", "address__ind", " address_slice", "address_offset", "address__list", "address_slice", "address_prefix", "address_list", "address2offset", "ip_start", "ip_slice", "ip__start", "position2prefix", "position2offset", "address_id", " address_list", "position2Index", "ip__id", "address2slice", "ip__index", "address2start", "address__start", "ip_index", "address_address", "position_Index"], "vaddr_base": ["vaddr2area", "vsp_base", "vsp__count", "vaddr__count", "vattr_bas", "vaddr_bas", "vsp__base", "vaddr2Base", "vdr_index", "vaddr_area", "vaddr_bi", "vaddr2cache", "vaddr_prefix", "vaddr2base", "vaddr_address", "vsp_Base", "vrt_bas", "vaddress_bas", "vaddress_home", "vad_full", "vattr_full", "vaddr_cache", "vaddr_count", "vaddr_home", "vaddress_base", "vdr_base", "vsp__len", "vad_base", "vaddr_based", "vad_Base", "vattr_address", "vaddr__len", "vrt_base", "vdr_prefix", "vdr_bas", "vsp_count", "vrt_area", "vaddr_len", "vaddr_full", "vaddr_index", "vsp__Base", "vaddress_based", "vsp_len", "vaddr__base", "vad_bi", "vaddr_Base", "vaddr__Base", "vattr_base"], "pfns": ["pcfails", "pafns", "pfxks", "vfks", "Pfails", "pfks", "pdfts", "pffs", "pdfns", "Pfks", "psfirs", "pfcns", "pofls", "pfcnc", "pfnes", "pfn", "pcfks", "psfns", "pfsails", "pafnc", "pcfls", "poffs", "pfsbs", "pdfls", "psfnes", "pdfnc", "Pcfails", "pcfnc", "pcfbs", "pfdls", "pfls", "Pfbs", "vfns", "pfbs", "prefks", "pofns", "Pcfns", "pfdks", " pdefnc", " pfls", "pdefls", "prefns", "pofks", "tfcn", "pfxns", "pcfns", "tfcns", "pfdfs", "pfcls", " pdefns", "pofbs", "tfls", "Pcffs", "pafn", "pfcn", "pfnc", "pfxnes", "tfnc", " pfts", "tfn", "tfns", "Pcfbs", " pdefts", "vfnes", "pcffs", "pcfn", " pdefls", "Pfns", "pfsls", "vfxns", "Pcfls", "pdefns", "pfxirs", "psfks", "prefirs", "pfirs", "tfcnc", "vfxks", "prefnes", "vfirs", " pfnc", "pdefts", "pfdns", "pfails", "vfxirs", "pfsns", "pafls", "Pcfks", "pcfts", "tfcls", "Pffs", "pdefnc", "Pfls", "vfxnes", "pofails", "pfts"], "err": ["status", "rr", "ner", "rage", "fr", "ch", "conf", "f", "eor", "runner", "sp", "ini", "rc", "r", "inc", "phi", "result", "ar", "str", "late", "ok", "cb", "icer", "nor", "arm", "rh", "loc", "msg", "finder", "ind", "der", "ise", "resp", "arr", "fer", "gr", "bug", "nr", "aster", "order", "mr", "rar", "aa", "rn", "ler", "dr", "lr", "acer", "req", "erg", "yr", "ir", "p", "test", "Error", "error", "Er", "res", "er", "errors", "iter", "fi", "inner", "attr", "len"], "i": ["uri", "gi", "ti", "m", "bi", "ei", "init", "j", "ji", "info", "x", "f", "ix", "ini", "qi", "r", "io", "mi", "n", "phi", "ai", "hi", "z", "ii", "in", "ie", "di", "iu", "index", "ori", "I", "mini", "multi", "zi", "o", "ip", "chi", "l", "d", "oi", "yi", "pi", "ui", "ci", "id", "start", "e", "v", "c", "ni", "si", "ri", "p", "xi", "b", "mu", "u", "a", "it", "eni", "fi", "inner", "y", "li", "len"]}}
{"project": "qemu", "commit_id": "093209cd681fe9fb65bd8a1c2ff711b8168bbfcd", "target": 0, "func": "static void ppc_core99_init (ram_addr_t ram_size,\n\n                             const char *boot_device,\n\n                             const char *kernel_filename,\n\n                             const char *kernel_cmdline,\n\n                             const char *initrd_filename,\n\n                             const char *cpu_model)\n\n{\n\n    CPUState *env = NULL, *envs[MAX_CPUS];\n\n    char *filename;\n\n    qemu_irq *pic, **openpic_irqs;\n\n    int unin_memory;\n\n    int linux_boot, i;\n\n    ram_addr_t ram_offset, bios_offset, vga_bios_offset;\n\n    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;\n\n    PCIBus *pci_bus;\n\n    MacIONVRAMState *nvr;\n\n    int nvram_mem_index;\n\n    int vga_bios_size, bios_size;\n\n    int pic_mem_index, dbdma_mem_index, cuda_mem_index, escc_mem_index;\n\n    int ide_mem_index[3];\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    void *fw_cfg;\n\n    void *dbdma;\n\n    uint8_t *vga_bios_ptr;\n\n    int machine_arch;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n#ifdef TARGET_PPC64\n\n        cpu_model = \"970fx\";\n\n#else\n\n        cpu_model = \"G4\";\n\n#endif\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        /* Set time-base frequency to 100 Mhz */\n\n        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n#if 0\n\n        env->osi_call = vga_osi_call;\n\n#endif\n\n        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);\n\n        envs[i] = env;\n\n    }\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(NULL, \"ppc_core99.ram\", ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = qemu_ram_alloc(NULL, \"ppc_core99.bios\", BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n\n\n    /* Load OpenBIOS (ELF) */\n\n    if (filename) {\n\n        bios_size = load_elf(filename, NULL, NULL, NULL,\n\n                             NULL, NULL, 1, ELF_MACHINE, 0);\n\n\n\n        qemu_free(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PowerPC bios '%s'\\n\", bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    /* allocate and load VGA BIOS */\n\n    vga_bios_offset = qemu_ram_alloc(NULL, \"ppc_core99.vbios\", VGA_BIOS_SIZE);\n\n    vga_bios_ptr = qemu_get_ram_ptr(vga_bios_offset);\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME);\n\n    if (filename) {\n\n        vga_bios_size = load_image(filename, vga_bios_ptr + 8);\n\n        qemu_free(filename);\n\n    } else {\n\n        vga_bios_size = -1;\n\n    }\n\n    if (vga_bios_size < 0) {\n\n        /* if no bios is present, we can still work */\n\n        fprintf(stderr, \"qemu: warning: could not load VGA bios '%s'\\n\",\n\n                VGABIOS_FILENAME);\n\n        vga_bios_size = 0;\n\n    } else {\n\n        /* set a specific header (XXX: find real Apple format for NDRV\n\n           drivers) */\n\n        vga_bios_ptr[0] = 'N';\n\n        vga_bios_ptr[1] = 'D';\n\n        vga_bios_ptr[2] = 'R';\n\n        vga_bios_ptr[3] = 'V';\n\n        cpu_to_be32w((uint32_t *)(vga_bios_ptr + 4), vga_bios_size);\n\n        vga_bios_size += 8;\n\n\n\n        /* Round to page boundary */\n\n        vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) &\n\n            TARGET_PAGE_MASK;\n\n    }\n\n\n\n    if (linux_boot) {\n\n        uint64_t lowaddr = 0;\n\n        int bswap_needed;\n\n\n\n#ifdef BSWAP_NEEDED\n\n        bswap_needed = 1;\n\n#else\n\n        bswap_needed = 0;\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, kernel_base,\n\n                                    ram_size - kernel_base, bswap_needed,\n\n                                    TARGET_PAGE_SIZE);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              kernel_base,\n\n                                              ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                         initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        /* We consider that NewWorld PowerMac never have any floppy drive\n\n         * For now, OHW cannot boot from the network.\n\n         */\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'c' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0x80000000;\n\n\n\n    /* Register 8 MB of ISA IO space */\n\n    isa_mmio_init(0xf2000000, 0x00800000, 1);\n\n\n\n    /* UniN init */\n\n    unin_memory = cpu_register_io_memory(unin_read, unin_write, NULL);\n\n    cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory);\n\n\n\n    openpic_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));\n\n    openpic_irqs[0] =\n\n        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        /* Mac99 IRQ connection between OpenPIC outputs pins\n\n         * and PowerPC input pins\n\n         */\n\n        switch (PPC_INPUT(env)) {\n\n        case PPC_FLAGS_INPUT_6xx:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];\n\n            /* Not connected ? */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            /* Check this */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];\n\n            break;\n\n#if defined(TARGET_PPC64)\n\n        case PPC_FLAGS_INPUT_970:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];\n\n            /* Not connected ? */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            /* Check this */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];\n\n            break;\n\n#endif /* defined(TARGET_PPC64) */\n\n        default:\n\n            hw_error(\"Bus model not supported on mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n    pic = openpic_init(NULL, &pic_mem_index, smp_cpus, openpic_irqs, NULL);\n\n    if (PPC_INPUT(env) == PPC_FLAGS_INPUT_970) {\n\n        /* 970 gets a U3 bus */\n\n        pci_bus = pci_pmac_u3_init(pic);\n\n        machine_arch = ARCH_MAC99_U3;\n\n    } else {\n\n        pci_bus = pci_pmac_init(pic);\n\n        machine_arch = ARCH_MAC99;\n\n    }\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus, vga_bios_offset, vga_bios_size);\n\n\n\n    escc_mem_index = escc_init(0x80013000, pic[0x25], pic[0x24],\n\n                               serial_hds[0], serial_hds[1], ESCC_CLOCK, 4);\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init_nofail(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n    dbdma = DBDMA_init(&dbdma_mem_index);\n\n\n\n    /* We only emulate 2 out of 3 IDE controllers for now */\n\n    ide_mem_index[0] = -1;\n\n    hd[0] = drive_get(IF_IDE, 0, 0);\n\n    hd[1] = drive_get(IF_IDE, 0, 1);\n\n    ide_mem_index[1] = pmac_ide_init(hd, pic[0x0d], dbdma, 0x16, pic[0x02]);\n\n    hd[0] = drive_get(IF_IDE, 1, 0);\n\n    hd[1] = drive_get(IF_IDE, 1, 1);\n\n    ide_mem_index[2] = pmac_ide_init(hd, pic[0x0e], dbdma, 0x1a, pic[0x02]);\n\n\n\n    /* cuda also initialize ADB */\n\n    if (machine_arch == ARCH_MAC99_U3) {\n\n        usb_enabled = 1;\n\n    }\n\n    cuda_init(&cuda_mem_index, pic[0x19]);\n\n\n\n    adb_kbd_init(&adb_bus);\n\n    adb_mouse_init(&adb_bus);\n\n\n\n    macio_init(pci_bus, PCI_DEVICE_ID_APPLE_UNI_N_KEYL, 0, pic_mem_index,\n\n               dbdma_mem_index, cuda_mem_index, NULL, 3, ide_mem_index,\n\n               escc_mem_index);\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    /* U3 needs to use USB for input because Linux doesn't support via-cuda\n\n       on PPC64 */\n\n    if (machine_arch == ARCH_MAC99_U3) {\n\n        usbdevice_create(\"keyboard\");\n\n        usbdevice_create(\"mouse\");\n\n    }\n\n\n\n    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)\n\n        graphic_depth = 15;\n\n\n\n    /* The NewWorld NVRAM is not located in the MacIO device */\n\n    nvr = macio_nvram_init(&nvram_mem_index, 0x2000, 1);\n\n    pmac_format_nvram_partition(nvr, 0x2000);\n\n    macio_nvram_map(nvr, 0xFFF04000);\n\n    /* No PCI init: the BIOS will do it */\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, machine_arch);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(\"cmdline\", CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());\n\n    if (kvm_enabled()) {\n\n#ifdef CONFIG_KVM\n\n        uint8_t *hypercall;\n\n\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq());\n\n        hypercall = qemu_malloc(16);\n\n        kvmppc_get_hypercall(env, hypercall, 16);\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());\n\n#endif\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, get_ticks_per_sec());\n\n    }\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 6829, "substitutes": {"ram_size": ["mem_offset", "mem_source", "gram_type", "ramlsize", " ram_speed", "ramloffset", " ram_width", "ram_source", "ram_length", "ram_bytes", "ram_center", "mem_size", "gram_offset", "ramlcenter", "gram_length", "mem_center", " ram_bytes", "ram_speed", "ramlsource", "gram_size", "ram_type", "ram_width"], "boot_device": ["bootalmode", "boot_server", "bootaldevice", "boot_dev", "boot_mode", "kernel_server", "kernel_mode", "kernel_dev", "bootaldev", "kernel_device", "bootalserver"], "kernel_filename": ["cpu_memory", "kernel__memory", "kernel_file", "kernelfusername", " kernel_location", "kernel__name", "kernel__filename", " kernel_name", "kernel__username", "cpu_name", "kernel_location", "kernel_name", "kernelfmemory", "kernel_username", "cpu_username", " kernel_file", "cpu_filename", "kernel_memory", "kernelfname", "kernelffilename"], "kernel_cmdline": ["kernel_commandle", "kernel_commle", "kernel_commlink", "kernel_cmdle", "kernel_bootle", "kernel_commandlink", "kernel_bootline", "kernel_bootlink", "kernel_commandline", "kernel_cmdlink", "kernel_commline"], "initrd_filename": ["initrd_memory", "initrt_file", "initrdmfile", "initrt_filename", "initrt_memory", "initrd_file", "initrt_size", "initrdmsize", "initrdmfilename", "initrdmmemory"], "cpu_model": ["cpu_field", "cpu_models", "cpu64mode", "cpu_rule", "cpu_slave", " cpu_models", "gpu_field", "cpu_device", "gpu_rule", "gpu_model", "cpu__mode", "CPU_model", "cpujmode", "processor_model", "cpu_Model", "gpu_Model", " cpu_mode", "CPU_format", "cpu__model", "CPU_mode", "cpu_module", "cpu64model", " cpu_type", "cpu_format", "cpu_type", "cpu64format", "cpu_function", "cpu_name", "cpu__device", "cpu_mode", "processor_name", "CPU_device", " cpu_slave", "processor_function", "processor_mode", "cpujfunction", "cpu__format", " cpu_module", "cpu64device", "cpujmodel", "cpujname"], "env": ["enable", "ah", "fg", "act", "ea", "v", "el", "dat", "scope", "session", "config", "vel", "environment", "inv", "exc", "style", "et", "enc", "nc", "in", "loc", "eu", "inet", "db", "export", "gui", "state", "obj", "args", "assets", "py", "cli", "net", "conf", "ev", "dir", "impl", "code", "np", "init", "e", "vs", "en", "here", "dev", "ctx", "bc", "err", "exec", "ini", "Environment", "lock", "equ", "context", "end", "ne", "eval", "stage", "ec", "h", "output", "eni", "iv", "viron", "pect", "global", "opt", "engine", "cache", "img", "conn", "ass", "dict"], "envs": ["Enfs", " environments", "ENvs", "Env", " enums", "ENfs", "ENv", " enfs", "ENums", "ENns", "Enns", "ENvironments", "environments", "Environments", " enns", "Enums", "enums", "enfs", "enns", "Envs"], "MAX_CPUS": ["MAX_MPUS", "MAX_CFUS", "MAX_MPU", "MAX_CPUs", "MAXNcpU", "MAXNCPU", "MAXNCPUS", "MAX_CPUI", "MAX_CPU", "MAX_CFUs", "MAX_cpUS", "MAXNcpUS", "MAX_CFU", "MAX_cpUI", "MAXNcpUI", "MAX_CFUI", "MAX_cpUs", "MAXNCPUs", "MAX_cpU", "MAX_MPUs", "MAXNCPUI", "MAX_MPUI", "MAXNcpUs"], "filename": ["name", "files", "username", "Filename", "b", "tty", "File", "f", "fil", "uri", "file", "binary", "fn", "path", "fp", "dll", "nil", "processor", "output", "wav", "memory", "kl", "fd", "directory", "prefix"], "pic": ["pot", "ig", "bin", "mic", "pin", "quad", "config", "xi", "sync", "image", "pins", "mac", "drive", "bus", "pi", "pc", "cli", "nic", "disk", "lib", "ic", "cpu", "fs", "proc", "lc", "fc", "vc", "fi", "cache"], "openpic_irqs": ["openpic_irsqs", "openpic_irqq", "openpic_irks", "openpic_rinks", "openpic_rinqs", "openpic_irsks", "openpic_rinq", "openpic_mirq", "openpic_irq", "openpic_mirqs", "openpic_irsqq", "openpic_mirks", "openpic_mirqq", "openpic_rinqq", "openpic_irsq"], "unin_memory": ["cpu_memory", "cpu00master", "cpualbase", "vidia_usage", "vidia_base", "vidia_master", "cpu00usage", "cpualmemory", "cpu_base", "cpualusage", "cpualmaster", "cpu_master", "cpu00memory", "cpu_usage", "vidia_memory", "cpu00base"], "linux_boot": ["linux68setup", "linux_host", "physical_Boot", "linux68boot", " linux_host", "linux_base", "linux68host", " linux_Boot", "physical_base", "linux68Boot", "physical_boot", "linux_Boot", "linux_run", "linux_setup", " linux_setup", "physical_run"], "i": ["gi", "ei", "ti", "v", "I", "chi", "di", "ci", "ni", "xi", "ri", "si", "io", "slice", "info", "m", "image", "in", "qi", "ix", "l", "gu", "f", "yi", "pi", "phi", "adi", "j", "ii", "iu", "linux", "ij", "ai", "cli", "uli", "d", "u", "udi", "ami", "uri", "k", "n", "multi", "mi", "ski", "ini", "ie", "p", "h", "mini", "eni", "hi", "c", "ip", "li", "anti", "fi", "index", "ui"], "ram_offset": ["ram67index", "ram67size", "ram67offset", "ram_base", "ream_size", "ream_base", "ram_format", "ramFoffset", "ramFposition", "ram_reset", "gram_index", "ramFsize", "gram_offset", "ramlexshift", "ramlexreset", "ream_format", "ramlexsize", "ram_position", "ream_offset", "gram_reset", "ram_index", "gram_size", "ram67position", "ramlexoffset", "ram_shift", "gram_position", "ramFindex", "gram_shift"], "bios_offset": ["bio_len", "bio_base", "bio_error", "bios_len", "bio_size", "bios_error", "bios_base", "bio_offset"], "vga_bios_offset": ["vga_bios_position", "vga_bio_position", "vga_bio_index", "vga_bio_offset", "vga_bio_size", "vga_bios_index"], "kernel_base": ["kernel_file", "kernel__base", "kernel__size", "kernel_range", " kernel_range", "kernel__file", "kernel__range", " kernel_file"], "kernel_size": ["kernel_speed", " kernel_speed", " kernel_name", "kernel_name"], "initrd_base": ["initrt_core", "initrd_core", "initrd_offset", "initrt_size", "initrt_base", "initrt_offset"], "initrd_size": ["initrt_scale", "initrd_loc", "initrd_name", "initrt_size", "initrd_scale", "initrt_loc", "initrt_name"], "pci_bus": ["pci_usb", "pci_boot", "pki_BUS", "pki_usb", "pki_bus", "pki_boot", "pci_BUS"], "nvr": ["NVR", "nmr", "nVR", "rnvm", "rnvr", "rnVR", "nvm", "Nmr", "Nvr", "rnmr", " nvm", " nVR", " nmr", "Nvm"], "nvram_mem_index": ["nvram_memxlength", "nvram_ram_size", "nvram_mem_size", "nvram_memxindex", "nvram_memxsize", "nvram_ram_loc", "nvram_memxloc", "nvram_mem_loc", "nvram_ram_index", "nvram_ram_length", "nvram_mem_length"], "vga_bios_size": ["vga_bios_loc", "vga_bio_loc", "vga_bios_count", "vga_bio_size", "vga_bio_count"], "bios_size": ["bios_index", "biol_capacity", "biol_index", "bios6size", "biol6capacity", "biol6size", "bios_capacity", "bios6offset", "bios6capacity", "biol_size", "biol6offset", "bios6index", "biol6index", "biol_offset"], "pic_mem_index": ["pic_mem_size", "pic_mem_set", "pic_thread_num", "pic_mempset", "pic_thread_index", "pic_mem_num", "pic_thread_set", "pic_mempindex", "pic_thread_size", "pic_mempsize", "pic_mempnum"], "dbdma_mem_index": ["dbdma_thread_index", "dbdma_thread_size", "dbdma_mem_id", "dbdma_thread_id", "dbdma_mem_size"], "cuda_mem_index": ["cuda_memxnum", "cuda_memxindex", "cuda_mem_ind", "cuda_lif_num", "cuda_lif_align", "cuda_mem_num", "cuda_memxind", "cuda_lif_ind", "cuda_lif_index", "cuda_mem_align", "cuda_memxalign"], "escc_mem_index": ["escc_memory_count", "escc_mem_count", "escc_memory_index", "escc_memgindex", "escc_memgcount", "escc_memory_ind", "escc_memgind", "escc_mem_ind"], "ide_mem_index": ["ide_memxslice", "ide_disk_slice", "ide_disk_index", "ide_diskxmin", "ide_memxindex", "ide_mem_min", "ide_diskxslice", "ide_mem_slice", "ide_memxmin", "ide_diskxindex", "ide_disk_min"], "ppc_boot_device": ["ppc_bus2unit", "ppc_boot_model", "ppc_boot_unit", "ppc_boot2device", "ppc_bus2device", "ppc_boot2model", "ppc_bus_dev", "ppc_boot_dev", "ppc_bus_model", "ppc_bus_device", "ppc_boot2unit", "ppc_bus2model", "ppc_boot2dev", "ppc_bus_unit", "ppc_bus2dev"], "hd": ["hp", "dri", "dr", "gc", "hw", "md", "vd", "di", "dd", "HD", "pd", "hid", "rh", "hs", "wd", "udi", "hm", "da", "xd", "eni", "ht", "ld", "du", "gd", "lv", "dt", "ha", "nd", "cd"], "MAX_IDE_BUS": ["MAX_DIPOUS", "MAX_IDEADUS", "MAX_DI_PATH", "MAX_IDE_USE", "MAX_IDEPOUSE", "MAX_IDEADPATH", "MAX_IDEADBUS", "MAX_DIPOPATH", "MAX_IDE_US", "MAX_DI_US", "MAX_IDEPOPATH", "MAX_IDEPOBUS", "MAX_DI_BUS", "MAX_DIPOUSE", "MAX_DI_USE", "MAX_DIPOBUS", "MAX_IDEPOUS", "MAX_IDEADUSE", "MAX_IDE_PATH"], "MAX_IDE_DEVS": ["MAX_IDE_DEFS", "MAX_IDE_TEFS", "MAX_IDE_DEV", "MAX_IDE_TEVS", "MAX_IDE_DIVICE", "MAX_IDE_DIV", "MAX_IDE_TEVICE", "MAX_IDE_TEV", "MAX_IDE_DVICE", "MAX_IDE_DIVS", "MAX_IDE_DFS", "MAX_IDE_DEVICE", "MAX_IDE_DV", "MAX_IDE_DIFS", "MAX_IDE_DVS"], "fw_cfg": ["fw_cow", "fw__cow", "fw_cf", "fw__config", "hw_cf", "fw_config", "hw_cow", "hw_cfg", "hw_config", "fw__cf", "fw__cfg"], "dbdma": ["dbnna", "dbhna", " dbnmm", "dbnpa", " dbdmm", "dbnmm", " dbnna", "dbdsna", "dbdmm", " dbdna", "dbhmm", "dbdsmm", "dbdpa", " dbnma", "dbdspa", "dbhpa", "dbnma", "dbhma", " dbdpa", " dbnpa", "dbdsma", "dbdna"], "vga_bios_ptr": ["vga_bios_pointer", "vga_bias_offset", "vga_bias_addr", "vga_bias_pointer", "vga_bias_ptr", "vga_bios_addr"], "machine_arch": ["machine__version", "usb_platform", "machine__platform", "machine_brand", "usb_brand", "machine_platform", "machine__brand", "usb_arch", "machine_version", "machine__arch", "usb_version"]}}
{"project": "FFmpeg", "commit_id": "934fe00680a1139cbc0950641655af5923dd7763", "target": 0, "func": "static int opt_input_file(OptionsContext *o, const char *opt, const char *filename)\n\n{\n\n    AVFormatContext *ic;\n\n    AVInputFormat *file_iformat = NULL;\n\n    int err, i, ret;\n\n    int64_t timestamp;\n\n    uint8_t buf[128];\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;                     // number of streams before avformat_find_stream_info\n\n\n\n    if (o->format) {\n\n        if (!(file_iformat = av_find_input_format(o->format))) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Unknown input format: '%s'\\n\", o->format);\n\n            exit_program(1);\n\n        }\n\n    }\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    using_stdin |= !strncmp(filename, \"pipe:\", 5) ||\n\n                    !strcmp(filename, \"/dev/stdin\");\n\n\n\n    /* get default parameters from command line */\n\n    ic = avformat_alloc_context();\n\n    if (!ic) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        exit_program(1);\n\n    }\n\n    if (o->nb_audio_sample_rate) {\n\n        snprintf(buf, sizeof(buf), \"%d\", o->audio_sample_rate[o->nb_audio_sample_rate - 1].u.i);\n\n        av_dict_set(&format_opts, \"sample_rate\", buf, 0);\n\n    }\n\n    if (o->nb_audio_channels) {\n\n        snprintf(buf, sizeof(buf), \"%d\", o->audio_channels[o->nb_audio_channels - 1].u.i);\n\n        av_dict_set(&format_opts, \"channels\", buf, 0);\n\n    }\n\n    if (o->nb_frame_rates) {\n\n        av_dict_set(&format_opts, \"framerate\", o->frame_rates[o->nb_frame_rates - 1].u.str, 0);\n\n    }\n\n    if (o->nb_frame_sizes) {\n\n        av_dict_set(&format_opts, \"video_size\", o->frame_sizes[o->nb_frame_sizes - 1].u.str, 0);\n\n    }\n\n    if (o->nb_frame_pix_fmts)\n\n        av_dict_set(&format_opts, \"pixel_format\", o->frame_pix_fmts[o->nb_frame_pix_fmts - 1].u.str, 0);\n\n\n\n    ic->video_codec_id   = video_codec_name ?\n\n        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0)->id : CODEC_ID_NONE;\n\n    ic->audio_codec_id   = audio_codec_name ?\n\n        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0)->id : CODEC_ID_NONE;\n\n    ic->subtitle_codec_id= subtitle_codec_name ?\n\n        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0)->id : CODEC_ID_NONE;\n\n    ic->flags |= AVFMT_FLAG_NONBLOCK;\n\n    ic->interrupt_callback = int_cb;\n\n\n\n    if (loop_input) {\n\n        av_log(NULL, AV_LOG_WARNING, \"-loop_input is deprecated, use -loop 1\\n\");\n\n        ic->loop_input = loop_input;\n\n    }\n\n\n\n    /* open the input file with generic avformat function */\n\n    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(filename, err);\n\n        exit_program(1);\n\n    }\n\n    assert_avoptions(format_opts);\n\n\n\n    /* apply forced codec ids */\n\n    for (i = 0; i < ic->nb_streams; i++)\n\n        choose_decoder(o, ic, ic->streams[i]);\n\n\n\n    /* Set AVCodecContext options for avformat_find_stream_info */\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    /* If not enough info to get the stream parameters, we decode the\n\n       first frames to get it. (used in mpeg case for example) */\n\n    ret = avformat_find_stream_info(ic, opts);\n\n    if (ret < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"%s: could not find codec parameters\\n\", filename);\n\n        av_close_input_file(ic);\n\n        exit_program(1);\n\n    }\n\n\n\n    timestamp = o->start_time;\n\n    /* add the stream start time */\n\n    if (ic->start_time != AV_NOPTS_VALUE)\n\n        timestamp += ic->start_time;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (o->start_time != 0) {\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            av_log(NULL, AV_LOG_WARNING, \"%s: could not seek to position %0.3f\\n\",\n\n                   filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    /* update the current parameters so that they match the one of the input stream */\n\n    add_input_streams(o, ic);\n\n\n\n    /* dump the file content */\n\n    av_dump_format(ic, nb_input_files, filename, 0);\n\n\n\n    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);\n\n    input_files[nb_input_files - 1].ctx        = ic;\n\n    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;\n\n    input_files[nb_input_files - 1].ts_offset  = o->input_ts_offset - (copy_ts ? 0 : timestamp);\n\n    input_files[nb_input_files - 1].nb_streams = ic->nb_streams;\n\n    input_files[nb_input_files - 1].rate_emu   = o->rate_emu;\n\n\n\n    for (i = 0; i < o->nb_dump_attachment; i++) {\n\n        int j;\n\n\n\n        for (j = 0; j < ic->nb_streams; j++) {\n\n            AVStream *st = ic->streams[j];\n\n\n\n            if (check_stream_specifier(ic, st, o->dump_attachment[i].specifier) == 1)\n\n                dump_attachment(st, o->dump_attachment[i].u.str);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n\n\n    reset_options(o, 1);\n\n    return 0;\n\n}\n", "idx": 22459, "substitutes": {"o": ["io", "e", "ow", "oo", "O", "object", "off", "oe", "obj", "ao", "oa", "ol", "ou", "so", "node", "no", "f", "ro", "po", "op", "t", "oi", "u", "m", "wo", "original", "mo", "custom", "one", "ob", "os", "oc", "p", "od", "ant", "c", "lo", "module", "oid", "ocr", "go", "fo", "bo", "ov", "online", "to", "n", "co", "iso", "ot", "ko", "http", "from", "image", "l", "k", "ilo", "vo"], "opt": ["io", "obj", "config", "option", "text", "Opt", "rec", "path", "op", "alloc", "cmd", "info", "cat", "enc", "open", "timeout", "ctx", "Option", "w", "loc", "options", "root", "proc", "fn", "oc", "attr", "url"], "filename": ["name", "txt", "binary", "download", "il", "utf", "file", "fb", "phrase", "microsoft", "fax", "json", "lua", "uri", "ln", "png", "fp", "f", "path", "login", "msg", "nil", "wl", "kl", "prefix", "directory", "subject", "which", "sheet", "timeout", "println", "kn", "nuclear", "title", "source", "document", "ename", "location", "src", "fd", "length", "wav", "dll", "jpg", "sf", "tty", "bf", "fil", "fn", "username", "files", "l", "Filename", "url"], "ic": ["lc", "bc", "fc", "ik", "ig", "fi", "ici", "ican", "ct", "nic", "IC", "aci", "aic", "pc", "mic", "anc", "ci", "isc", "ac", "ico", "mc", "xc", "pic", "tc", "ant", "au", "c", "ctx", "icc", "iac", "cy", "cci", "ics", "gc", "ai", "xi", "ec", "icer", "cit", "voc", "oc", "lic", "cu", "acs", "vc"], "file_iformat": ["file_iformart", "file_iolac", "file_iformant", "file_iolant", "file_iplac", "file_iformata", "file__iformat", "file_isolat", "file__iformac", "file_isolata", "file_iliart", "file_iplat", "file_iformt", "file__iolt", "file_iddant", "file_iddac", "file__iformt", "file_iolata", "file_iliat", "file_isolit", "file_iddt", "file_isolart", "file_iolart", "file_iformit", "file_iolit", "file_iplt", "file__iformant", "file__iolac", "file_iliata", "file_iddat", "file_iformac", "file__iolant", "file_iliit", "file_iplant", "file__iolat", "file_iolt", "file_iolat"], "err": ["status", " typ", " error", " aux", " pri", "result", "rr", " resp", " len", " fe", "res", "stat", "id", " seq", "var", "rc", "out", "cb", " rc", "seq", "error", "fd", "len", "req", "nt", "h", "resp", "fun"], "i": ["io", "ix", "e", "ind", "ui", "d", "ti", "I", "l", "f", "ci", "t", "info", "u", "ini", "m", "it", "r", "s", "ip", "p", "id", "is", "mi", "c", "index", "si", "ii", "b", "n", "iu", "ai", "v", "z", "li", "h", "pi", "x", "zi", "k", "ni", "count"], "ret": ["status", "bc", "en", "result", "val", "wa", "Ret", "no", "buffer", "res", "cat", "rc", "cb", "aux", "RET", "rt", "mem", "flag", "seq", "len", "back", "alt", "ry", "nt", "fi"], "timestamp": ["frametime", "microoffset", "framestamp", "framest", "microestamp", "framoffset", "timest", "imoffset", "imestamp", "timoffset", "microetime", "microest", "timetime", "imest", "imetime"], "buf": ["begin", "bc", "config", "buffer", "alloc", "msg", "bg", "data", "context", "wb", "pool", "header", "font", "la", "mem", "window", "bo", "ff", "src", "br", "bd", "batch", "wx", "doc", "proc", "rb", "fam", "feat", "output", "cap", "str", "uf", "text", "cv", "null", "fp", "ucc", "bed", "rc", "cb", "desc", "bh", "bag", "vec", "conv", "uc", "ref", "fb", "queue", "func", "bytes", "bin", "Buff", "img", "f", "box", "bn", "byte", "b", "tmp", "usr", "fd", "loc", "buff", "bf", "pb", "port", "cur", "ctx", "aux", "seq", "auc", "block", "url"], "opts": [" opttr", " opttes", "operts", "optes", "opertr", "opfs", " opfs", " optes", " optts", "opertes", " optfs", "optr", " optr", "operfs"], "orig_nb_streams": [" orig_nb_streamries", " orig_nb_roundd", " orig_nb_threadd", " orig_nb_inputries", " orig_nb_roundries", " orig_nb_threadries", " orig_nb_inputd", " orig_nb_rounding", " orig_nb_inputing", " orig_nb_inputs", " orig_nb_threading", " orig_nb_rounds", " orig_nb_streaming", " orig_nb_streamd", " orig_nb_threads"]}}
{"project": "FFmpeg", "commit_id": "d82eccea2bf905cd51889954658f4e7f64876df8", "target": 1, "func": "static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,\n\n                                                    int16_t *block, int n)\n\n{\n\n    int level, i, j, run;\n\n    RLTable *rl = &ff_rl_mpeg1;\n\n    uint8_t * const scantable = s->intra_scantable.permutated;\n\n    const int qscale          = s->qscale;\n\n    OPEN_READER(re, &s->gb);\n\n    i = -1;\n\n\n\n    // special case for first coefficient, no need to add second VLC table\n\n    UPDATE_CACHE(re, &s->gb);\n\n    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {\n\n        level = (3 * qscale) >> 1;\n\n        if (GET_CACHE(re, &s->gb) & 0x40000000)\n\n            level = -level;\n\n        block[0] = level;\n\n        i++;\n\n        SKIP_BITS(re, &s->gb, 2);\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            goto end;\n\n    }\n\n\n\n    /* now quantify & encode AC coefficients */\n\n    for (;;) {\n\n        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);\n\n\n\n        if (level != 0) {\n\n            i += run;\n\n            j  = scantable[i];\n\n            level = ((level * 2 + 1) * qscale) >> 1;\n\n            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n\n            SKIP_BITS(re, &s->gb, 1);\n\n        } else {\n\n            /* escape */\n\n            run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);\n\n            UPDATE_CACHE(re, &s->gb);\n\n            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);\n\n\n\n            i += run;\n\n            j  = scantable[i];\n\n            if (level < 0) {\n\n                level = ((-level * 2 + 1) * qscale) >> 1;\n\n                level = -level;\n\n            } else {\n\n                level = ((level * 2 + 1) * qscale) >> 1;\n\n            }\n\n        }\n\n\n\n        block[j] = level;\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            break;\n\n        UPDATE_CACHE(re, &s->gb);\n\n    }\n\nend:\n\n    LAST_SKIP_BITS(re, &s->gb, 2);\n\n    CLOSE_READER(re, &s->gb);\n\n    s->block_last_index[n] = i;\n\n    return 0;\n\n}\n", "idx": 6972, "substitutes": {"s": ["serv", "sf", "S", "b", "f", "d", "service", "conf", "w", "same", "h", "aws", "sa", "g", "sym", "sets", "is", "services", "its", "states", "server", "sl", "ls", "sie", "ops", "ds", "ts", "settings", "sv", "fs", "sq", "ms", "site", "rs", "sr", "sec", "sg", "sche", "sync", "ses", "cs", "u", "e", "sb", "qs", "t", "p", "re", "ges", "c", "os", "ssl", "sup", "r", "ps", "o", "v", "http", "session", "si", "sys", "m", "side", "ns", "space", "res", "ss", "gs", "su", "sample", "es", "js"], "block": ["Block", "base", "row", "layer", "bin", "box", "channel", "chain", "session", "list", "b", "object", "bit", "record", "unit", "buffer", "clock", "section", "lock", "coll", "array", "blocks", "batch", "frame", "un", "re", "BL", "line", "node", "rule", "range", "type", "bl", "ref", "cache", "group", "r", "rec", "view"], "n": ["nl", "nn", "b", "nc", "l", " N", "num", "N", "ns", "d", "len", "e", "all", "w", "en", "k", "nat", "nb", "p", "ne", "z", "ner", "ln", "c", "g", "r", "rec"], "level": ["layer", "local", "ll", "unit", "letter", "f", "weight", "d", "code", "len", "all", "col", "depth", "file", "pass", "stage", "where", "line", "lc", "index", "mode", "le", "row", "build", "id", "count", "value", "val", "url", "limit", "sol", "loop", "round", "lo", "sc", "path", "str", "scale", "fail", "ld", "rule", "type", "model", "rol", "low", "size", "clean", "vel", "loc", "inc", "key", "cl", "Level", "temp", "global", "ul", "location", "wl", "VEL", "set", "levels", "la", "total", "ell", "l", "child", "call", "length", "roll", "full", "day", "lock", "coll", "lvl", "cost", "step"], "i": ["uni", "gi", "layer", "o", "position", "ti", "v", "id", "I", "is", "di", "ci", "ni", "x", "b", "si", "io", "xi", "slice", "ri", "info", "bi", "in", "qi", "l", "f", "pi", "yi", "phi", "iu", "ii", "it", "ai", "init", "u", "e", "uri", "ori", "k", "mi", "ini", "ie", "p", "z", "start", "hi", "c", "ip", "ind", "y", "li", "index", "r", "ui"], "j": ["jet", "o", "el", "v", "note", "jl", "jump", "ji", "op", "b", "ani", "rel", "m", "kj", "l", "job", "ij", "aj", "q", "J", "jc", "k", "uj", "jp", "err", "str", "jo", "p", "jit", "un", "z", "pos", "jj", "ind", "g", "dj", "ja", "br", "li", "adj", "syn", "r", "js"], "run": ["base", "name", "row", "layer", "clean", "build", "reg", "play", "runs", "nn", "config", "update", "val", "skip", "use", "sync", "vel", "unit", "ran", "inc", "num", "ru", "job", "child", "order", "call", "weight", "limit", "version", "mod", "loop", "round", "len", "con", "Run", "day", "win", "pass", "go", "exec", "running", "output", "runner", "un", "batch", "pos", "step", "fun", "type", "thread", "UN", "index", "set", "r", "min", "max", "end", "add"], "rl": ["nl", "fr", "vr", "lb", "sr", "rt", "el", "rr", "rb", "rc", "rel", "lp", "ll", "l", "repl", "ru", "tl", "fl", "ls", "sl", "sb", "rg", "lr", "ruby", "gb", "mr", "sel", "bf", "ssl", "ro", "lc", "lv", "dl", "il", "fc", "pl", "rs", "rol", "r", "ctrl"], "scantable": ["scandor", "Scandiable", "scentiable", "Scantiable", "Scandor", "scantsiable", "scaptables", "Scaptable", "scactables", "scaptor", "scantible", "Scantables", "scentible", "scentables", "scactable", "scantsable", "scandables", "scaptable", "Scandables", "Scaptables", "scantsables", "scactiable", "scantables", "Scantible", "scantor", "scactible", "scantiable", "scantsible", "Scantable", "scentable", "Scaptible", "Scaptiable", "Scandible", "scandible", "scaptible", "scantsor", "scaptiable", "scandable", "Scandable", "Scantor", "scandiable"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    if (addr == OMAP_MPUI_BASE)\t/* CMR */\n\n        return 0xfe4d;\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 23516, "substitutes": {"opaque": ["appacity", "operacity", "operaque", "transacity", " opaco", "oppaco", "opaco", "oppaque", "oppacity", "transonymous", "appque", "operque", "opacity", "operonymous", " opque", " opacity", "transaque", "opque", "apponymous", "appaque", "transque", "oppque", "operaco", "oponymous"], "addr": ["route", "port", "handle", "target", "start", "asm", "conn", "adr", "config", "part", "eth", "mode", "oa", "ord", "func", "afi", "pad", "host", "align", "node", "layer", "pos", "cmp", "cmd", "address", "data", "args", "ad", "state", "ip", "p", "ace", "point", "work", "code", "prefix", "dr", "ctx", "cb", "nr", "arch", "index", "byte", "x", "ptr", "dc", "Address", "seq", "alias", "error", "src", "len", "loc", "pointer", "image", "offset", "base", "inter", "padding", "type"], "size": ["name", "e", "en", "scale", "g", "sized", "Size", "bytes", "align", "ize", "address", "s", "data", "fee", "or", "code", "sync", "rc", "c", "small", "capacity", " address", "length", "len", "loc", "large", "sec", "SIZE", "from", "empty", "offset", "x", "type"]}}
{"project": "qemu", "commit_id": "6a2a5aae02b9a0b53807b9ad91f15cd4988781f9", "target": 0, "func": "static void sm501_disp_ctrl_write(void *opaque, hwaddr addr,\n\n                                  uint64_t value, unsigned size)\n\n{\n\n    SM501State *s = (SM501State *)opaque;\n\n    SM501_DPRINTF(\"sm501 disp ctrl regs : write addr=%x, val=%x\\n\",\n\n                  (unsigned)addr, (unsigned)value);\n\n\n\n    switch (addr) {\n\n    case SM501_DC_PANEL_CONTROL:\n\n        s->dc_panel_control = value & 0x0FFF73FF;\n\n        break;\n\n    case SM501_DC_PANEL_PANNING_CONTROL:\n\n        s->dc_panel_panning_control = value & 0xFF3FFF3F;\n\n        break;\n\n    case SM501_DC_PANEL_FB_ADDR:\n\n        s->dc_panel_fb_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_PANEL_FB_OFFSET:\n\n        s->dc_panel_fb_offset = value & 0x3FF03FF0;\n\n        break;\n\n    case SM501_DC_PANEL_FB_WIDTH:\n\n        s->dc_panel_fb_width = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_FB_HEIGHT:\n\n        s->dc_panel_fb_height = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_TL_LOC:\n\n        s->dc_panel_tl_location = value & 0x07FF07FF;\n\n        break;\n\n    case SM501_DC_PANEL_BR_LOC:\n\n        s->dc_panel_br_location = value & 0x07FF07FF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_H_TOT:\n\n        s->dc_panel_h_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_H_SYNC:\n\n        s->dc_panel_h_sync = value & 0x00FF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_V_TOT:\n\n        s->dc_panel_v_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_V_SYNC:\n\n        s->dc_panel_v_sync = value & 0x003F0FFF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_HWC_ADDR:\n\n        s->dc_panel_hwc_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_LOC:\n\n        s->dc_panel_hwc_location = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_COLOR_1_2:\n\n        s->dc_panel_hwc_color_1_2 = value;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_COLOR_3:\n\n        s->dc_panel_hwc_color_3 = value & 0x0000FFFF;\n\n        break;\n\n\n\n    case SM501_DC_CRT_CONTROL:\n\n        s->dc_crt_control = value & 0x0003FFFF;\n\n        break;\n\n    case SM501_DC_CRT_FB_ADDR:\n\n        s->dc_crt_fb_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_CRT_FB_OFFSET:\n\n        s->dc_crt_fb_offset = value & 0x3FF03FF0;\n\n        break;\n\n    case SM501_DC_CRT_H_TOT:\n\n        s->dc_crt_h_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_H_SYNC:\n\n        s->dc_crt_h_sync = value & 0x00FF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_V_TOT:\n\n        s->dc_crt_v_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_V_SYNC:\n\n        s->dc_crt_v_sync = value & 0x003F0FFF;\n\n        break;\n\n\n\n    case SM501_DC_CRT_HWC_ADDR:\n\n        s->dc_crt_hwc_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_CRT_HWC_LOC:\n\n        s->dc_crt_hwc_location = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_HWC_COLOR_1_2:\n\n        s->dc_crt_hwc_color_1_2 = value;\n\n        break;\n\n    case SM501_DC_CRT_HWC_COLOR_3:\n\n        s->dc_crt_hwc_color_3 = value & 0x0000FFFF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_PALETTE ... SM501_DC_PANEL_PALETTE + 0x400 * 3 - 4:\n\n        sm501_palette_write(opaque, addr - SM501_DC_PANEL_PALETTE, value);\n\n        break;\n\n\n\n    default:\n\n        printf(\"sm501 disp ctrl : not implemented register write.\"\n\n               \" addr=%x, val=%x\\n\", (int)addr, (unsigned)value);\n\n        abort();\n\n    }\n\n}\n", "idx": 13829, "substitutes": {"opaque": ["opatile", "transaque", "transacity", "opac", "ipque", "transula", "operacity", "ipula", "operaque", "ipac", "ipacity", "opacity", "ipaque", "operque", "operatile", " opque", "opque", " opacity", "opula", "ipatile", "operula", "operac", " opatile", "transac"], "addr": ["func", "ord", "device", "alt", "port", "Address", "rc", "config", "val", "enter", "name", "align", "x", "ref", "buffer", "cmp", " address", "v", "ad", "p", "direction", "buf", "data", "pointer", "ext", "callback", "mode", "add", "address", "pair", "ip", "number", "padding", "block", "type", "offset", "cb", "eth", "attr", "cmd", "r", "host", "mac", "src", "off", "prefix", "pad", "len", "ptr", "node", "message"], "value": ["device", "native", "val", "memory", "sample", "VALUE", "image", "new", "ve", "hello", "total", "server", "begin", "media", "Value", "flow", "padding", "end", "single", "offset", "get", "command", "fee", "num", "index", "message", "termin", "bin", "done", "home", "reference", "sum", "comment", "key", "w", "resource", "data", "length", "json", "number", "create", "function", "selected", "archive", "alt", "format", "complete", "service", "style", "current", "large", "values", "source", "null", "description", "option", "buffer", "unit", "valid", "slave", "element", "document", "info", "max", "multi", "address", "feature", "type", "handle", "node", "name", "v", "uri", "buf", "component", "mode", "store", "attribute", "scale", "content", "join", "start"], "size": [" mode", " bytes", "val", "name", " length", "bytes", "buffer", "v", " values", " buffer", "buf", "data", "length", "mode", "state", "address", "SIZE", "type", "ptr"], "s": ["south", "sys", "m", "ses", "self", "service", "t", "d", "sg", "fs", "native", "l", "i", "sym", "rs", "g", "qs", "S", "hs", "manager", "os", "new", "status", "sets", "si", "js", "es", "session", "v", "conf", "ss", "storage", "client", "o", "ps", "w", "an", "u", "p", "e", "site", "b", "sb", "sf", "http", "n", "f", "stat", "gs", "spec", "state", "c", "ns", "single", "is", "ssl", "side", "sl", "states", "r", "ds", "sa", "ls", "ts", "us", "y", "aws"]}}
{"project": "qemu", "commit_id": "bf43330aa418908f7a5e2acda28ac1a8ed0d8ad6", "target": 1, "func": "void cpu_tick_set_count(CPUTimer *timer, uint64_t count)\n\n{\n\n    uint64_t real_count = count & ~timer->disabled_mask;\n\n    uint64_t disabled_bit = count & timer->disabled_mask;\n\n\n\n    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -\n\n                    cpu_to_timer_ticks(real_count, timer->frequency);\n\n\n\n    TIMER_DPRINTF(\"%s set_count count=0x%016lx (%s) p=%p\\n\",\n\n                  timer->name, real_count,\n\n                  timer->disabled?\"disabled\":\"enabled\", timer);\n\n\n\n    timer->disabled = disabled_bit ? 1 : 0;\n\n    timer->clock_offset = vm_clock_offset;\n\n}\n", "idx": 963, "substitutes": {"timer": ["Timer", "icer", "server", "outer", "imer", "buffer", "ext", "time", "inter", "term", "counter", "peer", "txt", "tim", "acker", "ee", "clock", "caster", "browser", "tick", "worker", "tc", "ger", "roller", "ter", "icker", "later", "inner", "amer", "er", "master", "ti", "err", "event", "temp", "runner", "writer", "reader", "maker", "ler", "lc", "theme", "loader", "message", "handler", "mom", "processor", "driver", "tm", "mr", "thread", "hour", "iner", "acer", "manager", "cer", "sim", "player", "timeout", "walker"], "count": ["match", "call", "base", "mount", "name", "check", "lock", "read", "time", "offset", "counter", "large", "cc", "process", "current", "clock", "weight", "empty", "num", "max", "code", "number", "cond", "force", "work", "c", "cpu", "size", "length", "len", "child", "core", "cache", "app", "amount", "sum", "seq", "thread", "path", "full", "Count", "load", "ast", "start", "cast"]}}
{"project": "qemu", "commit_id": "c1990ebfa11265d3aa9b6a4d5d1a02bd3f9ac5c6", "target": 1, "func": "QObject *json_parser_parse_err(QList *tokens, va_list *ap, Error **errp)\n\n{\n\n    JSONParserContext ctxt = {};\n\n    QList *working = qlist_copy(tokens);\n\n    QObject *result;\n\n\n\n    result = parse_value(&ctxt, &working, ap);\n\n\n\n    QDECREF(working);\n\n\n\n    error_propagate(errp, ctxt.err);\n\n\n\n    return result;\n\n}\n", "idx": 5624, "substitutes": {"tokens": ["tokenos", "targents", "targens", "atokenents", "targets", "toksenos", "toksets", "paken", "pakenos", "token", "atokenens", "pakens", "tokenets", "pakets", "atokents", "pokets", "takens", "poken", "toksens", "atoken", "tokenens", "tokenents", "tokets", "targen", "toksen", "atokets", "toksents", "pokens", "taken", "tokents", "tokenen", "atokenets", "takets", "atokens", "pokenos", "atokenen", "takenos", "tokenenos"], "ap": ["as", "ep", "al", "pa", "gap", "ax", "apt", "AP", "mp", "at", "arp", "aper", "ak", "ar", "ape", "ab", "Ap", "apper", "aps", "jp", "p", "amp", "apy", "tap", "sp", "cap", "ip", " AP", "api", "rap", "apa", "ac", "au", "app", "rep", "ps", "af"], "errp": ["erfp", "erP", "rorpp", "erpp", " errfp", " errlp", "interfp", "errP", " errP", "interP", "err", "errlp", "rorp", "errpp", "interlp", "erlp", "interp", "errr", "erp", "errfp", " errpp", "rorr", "rorfp", " errr"], "working": ["base", "containing", "ing", "reading", "using", "padding", "testing", "workers", "works", "writing", "starting", "setting", "binding", "loading", "data", "ping", "missing", "resource", "Working", "obj", "acting", "moving", "w", "existing", "won", "raw", "calling", "learning", "looking", "ising", "work", "array", "p", "forcing", "running", "checking", "new", "opening", "processing", "packing", "inner", "going", "worker", "prefix"], "result": ["master", "complete", "parent", "value", "object", "data", "final", "valid", "resource", "results", "f", "attr", "order", "obj", "arg", "res", "match", "answer", "comment", "arr", "message", "raw", "json", "func", "df", "instance", "other", "err", "response", "work", "array", "p", "output", "root", "new", "Result", "math", "page", "product", "success", "cache", "element", "current", "next", "r", "date", "found", "dict"]}}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,\n\n                                             GIOCondition condition,\n\n                                             gpointer user_data)\n\n{\n\n    QIOTask *task = user_data;\n\n    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(\n\n        qio_task_get_source(task));\n\n\n\n    qio_channel_tls_handshake_task(\n\n       tioc, task);\n\n\n\n    object_unref(OBJECT(tioc));\n\n\n\n    return FALSE;\n\n}\n", "idx": 26330, "substitutes": {"ioc": [" ioco", " iucc", "iucc", "atioco", "tiucc", "tioco", "tiroc", "atioc", "ioco", "iroc", "atiucc", " iroc", "atiroc"], "condition": ["chain", " cond", "processor", " thread", " proc", " interrupt", "ec", "bc", "proc", "reason", "self", " event", " prec", "parent", "cond", " error", "comp", "ruction", " block", " exc", "tc", "null", "func", "container", "block", "tx", " exception"], "user_data": ["userfulldata", "user_reader", " user_package", "userfulldevice", "custom_device", " user_done", "useruserreader", "userpooldone", "user_done", "userpooldata", "custom_reader", "userpoolclass", "user_class", "user_device", " user_class", "useringdone", "useruserinfo", "userfullreader", "useringdata", "useringpackage", "user_package", "userfullinfo", "custom_data", "user_info", "userpoolpackage", "custom_info", "useruserdata", "useruserdevice", "useringclass"], "task": ["exec", "socket", "thread", "app", "master", "server", "image", "job", "data", "test", "config", "address", "type", "instance", "trip", "ask", "sync", "key", "piece", "message", "resource", "work", "process", "session", "contract", "Task", "object", "worker", "role", "result", "target", "client", "channel", "device", "transfer", "course", "slave", "source", "child", "t", "conn", "content", "event", "route", "tty", "tx", "connection", "table", "tag"], "tioc": [" tiuc", "shiroc", "TIuc", "shiuc", "nioc", "tiec", "idioci", "kiocation", "tiOC", "sioc", "kioci", "idiocl", "shioc", "siOC", "TIoc", "tiocation", "siuc", "siec", "tiocon", "tiuc", "TIec", "niroc", "siroc", " tiOC", "shiocon", "tioci", "niocon", "siocon", "idioc", "kioc", "siocl", "tiocl", "sioci", " tiec", "kiocl", "niuc", "TIOC", "idiocation", "siocation", "tiroc"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void omap_pwt_write(void *opaque, target_phys_addr_t addr,\n\n                           uint64_t value, unsigned size)\n\n{\n\n    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;\n\n    int offset = addr & OMAP_MPUI_REG_MASK;\n\n\n\n    if (size != 1) {\n\n        return omap_badwidth_write8(opaque, addr, value);\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* FRC */\n\n        s->frc = value & 0x3f;\n\n        break;\n\n    case 0x04:\t/* VRC */\n\n        if ((value ^ s->vrc) & 1) {\n\n            if (value & 1)\n\n                printf(\"%s: %iHz buzz on\\n\", __FUNCTION__, (int)\n\n                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */\n\n                                ((omap_clk_getrate(s->clk) >> 3) /\n\n                                 /* Pre-multiplexer divider */\n\n                                 ((s->gcr & 2) ? 1 : 154) /\n\n                                 /* Octave multiplexer */\n\n                                 (2 << (value & 3)) *\n\n                                 /* 101/107 divider */\n\n                                 ((value & (1 << 2)) ? 101 : 107) *\n\n                                 /*  49/55 divider */\n\n                                 ((value & (1 << 3)) ?  49 : 55) *\n\n                                 /*  50/63 divider */\n\n                                 ((value & (1 << 4)) ?  50 : 63) *\n\n                                 /*  80/127 divider */\n\n                                 ((value & (1 << 5)) ?  80 : 127) /\n\n                                 (107 * 55 * 63 * 127)));\n\n            else\n\n                printf(\"%s: silence!\\n\", __FUNCTION__);\n\n        }\n\n        s->vrc = value & 0x7f;\n\n        break;\n\n    case 0x08:\t/* GCR */\n\n        s->gcr = value & 3;\n\n        break;\n\n    default:\n\n        OMAP_BAD_REG(addr);\n\n        return;\n\n    }\n\n}\n", "idx": 2084, "substitutes": {"opaque": ["opacity", " opque", "patile", "pac", "operae", "iopca", " opatile", "operca", "opca", "opac", " opac", "operaque", "iopaque", "operatile", " oprobe", " opacity", "oprobe", "hopaque", "pae", "operac", "iopacity", " opae", "operacity", "hopacity", "operrobe", " opca", "hoprobe", "opatile", "opae", "paque", "opque", "hopque", "operque"], "addr": ["oa", "dr", "layer", "base", "delay", "server", "src", "offset", "target", "a", "array", "device", "alias", "ock", "host", "sid", "data", "r", "ad", "align", "alt", "slot", "id", "ord", "ada", "off", "adr", "pos", "mac", "eni", "code", "entry", "index", "pointer", "address", "ack", "pad", "x", "p", "afi", "start", "ptr", "e", "len", "ref", "Address", "cmd", "node", "padding", "point", "prefix", "asm", "seq", "amd", "cmp", "error", "socket", "mode", "part", "ace", "rc", "port"], "value": ["VALUE", "key", "current", "video", "trial", "password", "address", "set", "child", "message", "reference", "object", "comment", "fee", "valid", "all", "port", "name", "image", "type", "format", "parent", "end", "buf", "pair", "python", "p", "resource", "length", "v", "scale", "wave", "val", "one", "response", "serial", "media", "version", "offset", "Value", "byte", "data", "complete", "member", "hello", "paid", "m", "native", "function", "content", "result", "h", "values", "node", "reg", "volume", "slave", "timeout", "cost", "match", "null", "server", "service", "total", "buffer", "gi", "array", "memory", "d", "num", "initial", "vector", "variable", "item", "entry", "attribute", "number", "expression", "w", "money", "amount", "padding", "price"], "size": ["SIZE", "name", "capacity", "offset", "ize", "sized", "data", "small", "align", "empty", " address", "from", "code", "sync", "number", "address", "or", "shift", "e", "length", "len", " length", "Size", "sec", "en", "padding", "fee", "scale", "bytes", "val", "count", "timeout"], "s": ["sg", "js", "service", "this", "cs", "ss", "rs", "a", "spec", "ts", "sb", "new", "r", "d", "is", "ins", "scope", "g", "side", "params", "m", "ses", "ls", "args", "sf", "sync", "uns", "settings", "ds", "sets", "ps", "gs", "address", "native", "ns", "h", "c", "p", "sie", "services", "w", "e", "f", "es", "self", "sys", "sq", "us", "conf", "secondary", "sec", "o", "v", "stats", "b", "su", "S", "t", "session", "os", "socket", "site", "hs", "states", "fs", "si", "sym", "ssl"]}}
{"project": "qemu", "commit_id": "64c9bc181fc78275596649f591302d72df2d3071", "target": 0, "func": "static void do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n\n\n    assert(p->ep->nr == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            usb_device_handle_control(s, p, request, value, index,\n\n                                      s->setup_len, s->data_buf);\n\n            if (p->status == USB_RET_ASYNC) {\n\n                return;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            p->actual_length = 0;\n\n        }\n\n        break;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len) {\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            }\n\n            return;\n\n        }\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        p->status = USB_RET_STALL;\n\n        break;\n\n\n\n    default:\n\n        p->status = USB_RET_STALL;\n\n    }\n\n}\n", "idx": 2047, "substitutes": {"s": ["sg", "js", "qs", "n", "sp", "g", "ses", "ls", "vs", "self", "us", "f", "sys", "u", "se", "fs", "parts", "spec", "ts", "sb", "ips", "aws", "y", "xs", "sv", "sets", "e", "conf", "as", "v", "su", "site", "S", "t", "ks", "os", "session", "bs", "its", "sym", "ssl", "cs", "ss", "rs", "new", "r", "is", "ins", "i", "m", "ds", "ps", "gs", "ns", "h", "c", "es", "o", "si", "service", "ops", "d", "ms", "params", "sync", "l", "services", "w", "sq", "b", "states"], "p": ["np", "vp", "q", "lp", "pe", "data", "pi", "r", "d", "press", "n", "ap", "sp", "cop", "k", "pb", "op", "api", "pre", "i", "j", "py", "tp", "g", "m", "proc", "y", "fp", "P", "ep", "parse", "ps", "post", "pa", "ip", "c", "l", "h", "e", "per", "f", "app", "cache", "u", "jp", "mp", "php", "up", "pm", "o", "pc", "bp", "v", "cp", "b", "t", "ic", "pro", "wp", "gp", "pp"], "request": ["cost", "call", "version", "buffer", "time", "key", "claim", "command", "charge", "queue", "access", "data", "url", "complete", "header", "report", "requ", "type", "use", "open", "callback", "id", "query", "parent", "frame", "pair", "initial", "rf", "hello", "create", "event", "config", "address", "begin", "result", "work", "setup", "resource", "condition", "du", "repeat", "child", "message", "demand", "pull", "Request", "fee", "req", "rx", "session", "require", "response", "input"], "value": ["flow", "ue", "VALUE", "media", "server", "name", "version", "buffer", "key", "Value", "data", "complete", "show", "dollar", "sample", "end", "pair", "hello", "update", "max", "output", "info", "password", "number", "description", "function", "result", "change", "values", "resource", "set", "message", "money", "min", "range", "v", "fee", "rule", "element", "wa", "view", "val", "response", "input", "option"], "index": ["match", "include", "Index", "call", "append", "offset", "find", "key", "context", "data", "image", "weight", "position", "page", "type", "open", "id", "end", "search", "i", "update", "pos", "none", "slice", "pointer", "address", "x", "ind", "connect", "condition", "len", "length", "size", "point", "action", "element", "inc", "start", "diff", "in", "option"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,\n\n                              int buf_size, int buf_size2)\n\n{\n\n    RVDecContext *rv = avctx->priv_data;\n\n    MpegEncContext *s = &rv->m;\n\n    int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret;\n\n\n\n    active_bits_size = buf_size * 8;\n\n    init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8);\n\n    if (s->codec_id == AV_CODEC_ID_RV10)\n\n        mb_count = rv10_decode_picture_header(s);\n\n    else\n\n        mb_count = rv20_decode_picture_header(rv);\n\n    if (mb_count < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"HEADER ERROR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->mb_x >= s->mb_width ||\n\n        s->mb_y >= s->mb_height) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"POS ERROR %d %d\\n\", s->mb_x, s->mb_y);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    mb_pos = s->mb_y * s->mb_width + s->mb_x;\n\n    left   = s->mb_width * s->mb_height - mb_pos;\n\n    if (mb_count > left) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"COUNT ERROR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {\n\n        // FIXME write parser so we always have complete frames?\n\n        if (s->current_picture_ptr) {\n\n            ff_er_frame_end(&s->er);\n\n            ff_MPV_frame_end(s);\n\n            s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;\n\n        }\n\n        if ((ret = ff_MPV_frame_start(s, avctx)) < 0)\n\n            return ret;\n\n        ff_mpeg_er_frame_start(s);\n\n    } else {\n\n        if (s->current_picture_ptr->f.pict_type != s->pict_type) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Slice type mismatch\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    av_dlog(avctx, \"qscale=%d\\n\", s->qscale);\n\n\n\n    /* default quantization values */\n\n    if (s->codec_id == AV_CODEC_ID_RV10) {\n\n        if (s->mb_y == 0)\n\n            s->first_slice_line = 1;\n\n    } else {\n\n        s->first_slice_line = 1;\n\n        s->resync_mb_x      = s->mb_x;\n\n    }\n\n    start_mb_x     = s->mb_x;\n\n    s->resync_mb_y = s->mb_y;\n\n    if (s->h263_aic) {\n\n        s->y_dc_scale_table =\n\n        s->c_dc_scale_table = ff_aic_dc_scale_table;\n\n    } else {\n\n        s->y_dc_scale_table =\n\n        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;\n\n    }\n\n\n\n    if (s->modified_quant)\n\n        s->chroma_qscale_table = ff_h263_chroma_qscale_table;\n\n\n\n    ff_set_qscale(s, s->qscale);\n\n\n\n    s->rv10_first_dc_coded[0] = 0;\n\n    s->rv10_first_dc_coded[1] = 0;\n\n    s->rv10_first_dc_coded[2] = 0;\n\n    s->block_wrap[0] =\n\n    s->block_wrap[1] =\n\n    s->block_wrap[2] =\n\n    s->block_wrap[3] = s->b8_stride;\n\n    s->block_wrap[4] =\n\n    s->block_wrap[5] = s->mb_stride;\n\n    ff_init_block_index(s);\n\n\n\n    /* decode each macroblock */\n\n    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {\n\n        int ret;\n\n        ff_update_block_index(s);\n\n        av_dlog(avctx, \"**mb x=%d y=%d\\n\", s->mb_x, s->mb_y);\n\n\n\n        s->mv_dir  = MV_DIR_FORWARD;\n\n        s->mv_type = MV_TYPE_16X16;\n\n        ret = ff_h263_decode_mb(s, s->block);\n\n\n\n        // Repeat the slice end check from ff_h263_decode_mb with our active\n\n        // bitstream size\n\n        if (ret != SLICE_ERROR) {\n\n            int v = show_bits(&s->gb, 16);\n\n\n\n            if (get_bits_count(&s->gb) + 16 > active_bits_size)\n\n                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;\n\n\n\n            if (!v)\n\n                ret = SLICE_END;\n\n        }\n\n        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&\n\n            8 * buf_size2 >= get_bits_count(&s->gb)) {\n\n            active_bits_size = buf_size2 * 8;\n\n            av_log(avctx, AV_LOG_DEBUG, \"update size from %d to %d\\n\",\n\n                   8 * buf_size, active_bits_size);\n\n            ret = SLICE_OK;\n\n        }\n\n\n\n        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"ERROR at MB %d %d\\n\", s->mb_x,\n\n                   s->mb_y);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (s->pict_type != AV_PICTURE_TYPE_B)\n\n            ff_h263_update_motion_val(s);\n\n        ff_MPV_decode_mb(s, s->block);\n\n        if (s->loop_filter)\n\n            ff_h263_loop_filter(s);\n\n\n\n        if (++s->mb_x == s->mb_width) {\n\n            s->mb_x = 0;\n\n            s->mb_y++;\n\n            ff_init_block_index(s);\n\n        }\n\n        if (s->mb_x == s->resync_mb_x)\n\n            s->first_slice_line = 0;\n\n        if (ret == SLICE_END)\n\n            break;\n\n    }\n\n\n\n    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,\n\n                    ER_MB_END);\n\n\n\n    return active_bits_size;\n\n}\n", "idx": 2130, "substitutes": {"avctx": ["afconfig", "AVctx", "ajctx", "AVcv", "avectx", " avnp", "afcmp", "afctx", "afcontext", "AVctrl", " avctrl", "avecf", "afpkg", "navctx", " avtc", " avcmp", "AVloc", "avcf", " avcontext", " avcf", "avpkg", "AVconfig", "verconfig", "avnp", "AVcoll", "ajcv", "AVpkg", "AVctl", "svctx", "avctrl", "ajctrl", "avtc", "afcoll", "afloc", "navcontext", "afnp", "afcf", "svctl", "avcoll", "avloc", "avctl", "navpkg", "avcontext", "navctl", "avconfig", "aveloc", "svpkg", "avecontext", "svcontext", "ajtc", "verctx", " avcv", "avcmp", "avecoll", "AVtc", " avpkg", "avenp", "avcv", "vercoll", "AVcmp", "AVcontext", "vercontext"], "buf": ["fd", "src", "buffer", "ctx", "bh", "bag", "context", "sb", "queue", "data", "bc", "buff", "pb", "tmp", "batch", "rb", "fp", "cb", "pool", "config", "cv", "vec", "f", "wb", "bd", "br", "gb", "cmd", "alloc", "bb", "fb", "b", "seq", "cf", "conv", "uf", "fi", "rc"], "buf_size": ["bufaccount", "buf_fee", "byte_scale", "buflexsize", "byte_uri", "byteaccount", "bufacunit", "buf_scale", "buf_count", "byteacfee", "buflexize", "buf_ize", "buf_sized", "buf_uri", "fb_size", "byteacunit", "fblexclean", "fblexize", "buflexclean", "byte_size", "byteacsize", "fblexsize", "byte_count", "bufacsize", "fb_sized", "byte_fee", "buf_clean", "bufacfee", "fb_ize", "fb_clean", "byte_unit", "buflexsized", "buf_unit", "byte_sized", "fblexsized"], "buf_size2": ["buf_ize182", "buf_size182", "buf_size192", "buf_ize192", "buf_scale2", "buf_rate2", "buf_end2", "buf_scaleTwo", "buf_scale1", "buf_rateTwo", "buf_ize2", "buf_scale182", "buf_end182", "buf_sizeTwo", "buf_rate1", "buf_size1", "buf_scale192", "buf_end192"], "rv": ["rrvd", "RV", "prvp", "rvd", "rrf", "rp", "rrv", " rvp", "prvd", "rvp", " rf", "srvp", "Rvp", "rV", "srv", "srV", "prv", "rf", "Rf", "Rp", "srf", "srp", "prf", "Rv", " rp", "Rvd", " rvd", "srvd", " rV", "rrvp"], "s": ["sg", "js", "sa", "qs", "n", "sites", "sl", "g", "ses", "ls", "vs", "self", "us", "f", "sys", "u", "sum", "your", "se", "fs", "parts", "spec", "ts", "sb", "aws", "ims", "y", "uns", "xs", "sv", "request", "sets", "p", "e", "conf", "as", "v", "less", "su", "site", "S", "os", "ks", "t", "session", "its", "bs", "hs", "sym", "ssl", "cs", "ctx", "ss", "a", "rs", "r", "is", "ins", "i", "m", "settings", "ds", "als", "ps", "gs", "ns", "h", "c", "es", "posts", "sec", "o", "times", "si", "server", "service", "http", "ops", "d", "ans", "side", "comments", "params", "sync", "l", "services", "w", "features", "sq", "stats", "b", "states"], "mb_count": ["av_size", "mb64type", "mballcatch", "mb64num", "mem64count", "mb64count", "avFoffset", "mb_len", "mbJoffset", "bb_weight", "mbJcond", "mem_index", "mb_type", "mb_cond", "mb64index", "mb_num", "mbFcond", "mb67len", "mb67count", "rb_number", "mp_catch", "mbFsize", "av_cond", "mb67pos", "mballnumber", "rb_count", "mem_num", "mp_number", "avFcount", "mb_catch", "mbFcount", "mb_offset", "mem64type", "rb_add", "bb_pos", "av_count", "mp_count", "mbJcount", "mb_add", "avFcond", "avFsize", "mb_number", "mb_index", "bb_len", "mem64num", "av_offset", "mem_count", "mbFoffset", "mbJsize", "mb_weight", "mem64index", "mb_size", "mb67weight", "mem_type", "mballcount", "bb_count"], "mb_pos": ["MB_po", "mb5count", "MB_count", "emb_gen", "mb2pos", "mb_length", "mbfpos", "mb5pos", "mbJlength", "emb_position", "mb2count", "mb_gen", "mb__length", "emb_pos", "mb_po", "mb2len", "mb_len", "mb__pos", "mbflen", "mp_length", "MB_len", "mb__position", "mb2po", "mbfcount", "mb_position", "mbJposition", "mp_position", "mb__len", "mb5position", "mbJlen", "mb5gen", "emb_count", "mbfpo", "mbJpos", "mp_pos", "mp_len", "MB_pos"], "start_mb_x": ["start_mp_y", "start_mb_pos", "start_mp_pos", "start_mb_y", "start_mbvx", "start_mbvy", "start_mbvpos", "start_mp_x"], "active_bits_size": ["active_bytes_size", "active_bits___rate", "active_bits___size", "active_bits_rate", "active_bits_ize", "active_bits___ize", "active_bytes_rate", "active_bytes_ci", "active_bits_ci", "active_bytes_ize"], "ret": ["match", "arg", "fun", "att", "ext", "def", "bit", "success", "get", " Ret", "r", "alt", "job", "pet", "rets", "tmp", "arr", "rep", "info", "nt", "ft", "rev", "live", "back", "reply", "status", "rc", "temp", "Ret", "err", "last", "result", "bot", "reset", "len", "ref", "flag", "red", "value", "RET", "al", "lit", "re", "reg", "val", "det", "res"], "mb_x": ["mb_ya", "bb_x", "bb_ax", "MB_y", "mb_width", "mbDya", "mp_z", "bb_width", "mb___ax", "MB_count", "mbkheight", "mbDy", "mb___width", "mb8y", "mbkz", "mbkx", "mbky", "mb___xx", "mp_ya", "mb__y", "mb__z", "mb8x", "MB_x", "mbDx", "mb__x", "mb_z", "mp_height", "mp_x", "mb___x", "mp_y", "mp_w", "mb_w", "MB_width", "mb_ax", "mb8width", "mb__w", "bb_xx", "mb_height", "mbDw", "mb_xx", "mb8count"], "mb_y": ["mbJx", "mp_zy", "MB_y", "mb_width", "mp_length", "mbkarea", "mbFx", "mbFyd", "mb_sy", "mp_wy", "mbJy", "mbJzy", "mbFy", "mbklength", "mp_width", "mb_cy", "mbkx", "mbky", "mp_yd", "mb_yl", "MB_yl", "mb_wy", "mp_sy", "mb_area", "mbFwy", "MB_cy", "MB_x", "mp_area", "mp_height", "mp_x", "mb_zy", "mb_yd", "mp_y", "mb_length", "mb_height", "mbJsy"]}}
{"project": "qemu", "commit_id": "1e577cc7cffd3de14dbd321de5c3ef191c6ab07f", "target": 0, "func": "void arm_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,\n\n                        int flags)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    int i;\n\n\n\n    if (is_a64(env)) {\n\n        aarch64_cpu_dump_state(cs, f, cpu_fprintf, flags);\n\n        return;\n\n    }\n\n\n\n    for(i=0;i<16;i++) {\n\n        cpu_fprintf(f, \"R%02d=%08x\", i, env->regs[i]);\n\n        if ((i % 4) == 3)\n\n            cpu_fprintf(f, \"\\n\");\n\n        else\n\n            cpu_fprintf(f, \" \");\n\n    }\n\n\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        uint32_t xpsr = xpsr_read(env);\n\n        const char *mode;\n\n\n\n        if (xpsr & XPSR_EXCP) {\n\n            mode = \"handler\";\n\n        } else {\n\n            if (env->v7m.control & R_V7M_CONTROL_NPRIV_MASK) {\n\n                mode = \"unpriv-thread\";\n\n            } else {\n\n                mode = \"priv-thread\";\n\n            }\n\n        }\n\n\n\n        cpu_fprintf(f, \"XPSR=%08x %c%c%c%c %c %s\\n\",\n\n                    xpsr,\n\n                    xpsr & XPSR_N ? 'N' : '-',\n\n                    xpsr & XPSR_Z ? 'Z' : '-',\n\n                    xpsr & XPSR_C ? 'C' : '-',\n\n                    xpsr & XPSR_V ? 'V' : '-',\n\n                    xpsr & XPSR_T ? 'T' : 'A',\n\n                    mode);\n\n    } else {\n\n        uint32_t psr = cpsr_read(env);\n\n        const char *ns_status = \"\";\n\n\n\n        if (arm_feature(env, ARM_FEATURE_EL3) &&\n\n            (psr & CPSR_M) != ARM_CPU_MODE_MON) {\n\n            ns_status = env->cp15.scr_el3 & SCR_NS ? \"NS \" : \"S \";\n\n        }\n\n\n\n        cpu_fprintf(f, \"PSR=%08x %c%c%c%c %c %s%s%d\\n\",\n\n                    psr,\n\n                    psr & CPSR_N ? 'N' : '-',\n\n                    psr & CPSR_Z ? 'Z' : '-',\n\n                    psr & CPSR_C ? 'C' : '-',\n\n                    psr & CPSR_V ? 'V' : '-',\n\n                    psr & CPSR_T ? 'T' : 'A',\n\n                    ns_status,\n\n                    cpu_mode_names[psr & 0xf], (psr & 0x10) ? 32 : 26);\n\n    }\n\n\n\n    if (flags & CPU_DUMP_FPU) {\n\n        int numvfpregs = 0;\n\n        if (arm_feature(env, ARM_FEATURE_VFP)) {\n\n            numvfpregs += 16;\n\n        }\n\n        if (arm_feature(env, ARM_FEATURE_VFP3)) {\n\n            numvfpregs += 16;\n\n        }\n\n        for (i = 0; i < numvfpregs; i++) {\n\n            uint64_t v = float64_val(env->vfp.regs[i]);\n\n            cpu_fprintf(f, \"s%02d=%08x s%02d=%08x d%02d=%016\" PRIx64 \"\\n\",\n\n                        i * 2, (uint32_t)v,\n\n                        i * 2 + 1, (uint32_t)(v >> 32),\n\n                        i, v);\n\n        }\n\n        cpu_fprintf(f, \"FPSCR: %08x\\n\", (int)env->vfp.xregs[ARM_VFP_FPSCR]);\n\n    }\n\n}\n", "idx": 21324, "substitutes": {"cs": ["lc", "cc", "ix", "wcs", "Cs", "sk", "qs", "conn", "fs", "cons", "ses", "ca", "ks", "css", "pc", "ds", "cas", "CS", "ci", "sys", "nc", "s", "args", "cache", "ys", "vs", "cf", "ace", "ls", "sync", "rc", "c", "ctx", "spec", "si", "sc", "ics", "ns", "ps", "rs", "gs", "bs", "ec", "acs"], "f": ["fa", "of", "fc", "e", "fs", "g", "fb", "file", "d", "framework", "func", "rf", "fp", "function", "df", "exec", "r", "m", "s", "j", "xf", "p", "fx", "cf", "o", "af", "filename", "c", "cb", "fe", "fr", "tf", "form", "b", "w", "fm", "ff", "fd", "F", "fw", "sf", "feed", "buff", "fen", "v", "bf", "fn", "lf", "h", "files", "l", "fi", "fo", "fun"], "cpu_fprintf": ["cpu_efformat", "cpu_lfmt", "cpu_rfprintf", "cpu_rfmt", "cpu_efprint", "cpu_fmt", "cpu_cprintf", "cpu_bmt", "cpu_bprint", "cpu_efdump", "cpu_Fprintf", "cpu_Fprintln", "cpu_efprintf", "cpu_sfprint", "cpu_frint", "cpu_cprintln", "cpu_lfprintln", "cpu_bappend", "cpu_fxprint", "cpu_cfprintln", "cpu_fdump", "cpu_bdump", "cpu_rfrite", "cpu_fxlt", "cpu_flt", "cpu_lfrint", "cpu_sflt", "cpu_bprintf", "cpu_fprint", "cpu_Frite", "cpu_Fformat", "cpu_fxrite", "cpu_dmt", "cpu_sfprintf", "cpu_fappend", "cpu_fformat", "cpu_rfprint", "cpu_rfformat", "cpu_bformat", "cpu_cfformat", "cpu_dprint", "cpu_fprintln", "cpu_cdump", "cpu_frite", "cpu_cmt", "cpu_cformat", "cpu_rfdump", "cpu_dappend", "cpu_cfprintf", "cpu_fxprintln", "cpu_cprint", "cpu_cfmt", "cpu_fxprintf", "cpu_fxformat", "cpu_bprintln", "cpu_lfprintf", "cpu_rfprintln", "cpu_dprintf", "cpu_brint"], "flags": ["items", "includes", "ags", "ints", "fs", "features", "func", "ffff", "ops", "plugins", "fish", "nl", "fps", "fee", "faces", "ils", "vals", "stats", "ants", "Flags", "settings", "lag", "reads", "forces", "bits", "flag", "FLAG", "fd", "details", " Flags", "fields", "sf", "utils", "alls", "acks", "lf", "files", "ips", "fi", "fun"], "cpu": ["lc", "bc", "platform", "computer", "fc", "bench", "gpu", "conn", "cv", "cm", " cp", "processor", "pc", "CPU", "anc", "nc", "cp", "cache", "cf", "mc", "uno", "uci", "np", "cli", "c", "ctx", "cn", "roc", "cal", "uca", "loader", "python", "core", "n", "utils", "proc", "vm", "clock", "fi", "pu"], "env": ["bc", "exe", "config", "eni", "exc", "que", "context", "iss", "osc", "proc", "v", "conf", "ev", "fi", "conn", "db", "cv", "oa", "eng", "style", "site", "anc", "state", "lock", "enc", "assets", "code", "ext", "c", "spec", "et", "cfg", "equ", "esm", "ass", "desc", "em", "sf", "fen", "qt", "ce", "scope", "net", "e", "forge", "err", "eu", "esp", "ea", "exec", "cli", "Environment", "el", "si", "enable", "dt", "gui", "loader", "intern", "core", "inst", "er", "skin", "stage", "param", "ne", "ec", "enh", "en", "shell", "energy", "engine", "nc", "args", "cache", "vs", "np", "kn", "settings", "cal", "viron", "console", "vm", "server", "environment"], "i": ["io", "col", "uli", "ix", "e", "start", "fi", "qi", "name", "ind", "ri", "ui", "eni", "key", "gi", "d", "uri", "ti", "I", "l", "ci", "t", "u", "oi", "m", "phi", "it", "j", "ip", "abi", "p", "id", "o", "bi", "wei", "c", "mu", "index", "si", "ii", "b", "in", "counter", "min", "n", "child", "iu", "slice", "ai", "xi", "hi", "di", "multi", "v", "li", "pi", "x", "zi", "k", "ni", "count"], "mode": ["status", "route", "md", "member", "view", "name", "phase", "kind", "password", "language", "option", "scale", "driver", "lane", "project", "key", "shell", "time", "phrase", "style", "plugin", "access", "device", "no", "model", "track", "slave", "disable", "MODE", "m", "bit", "size", "program", "state", "version", "ace", "mod", "code", "mm", "id", "mac", "normal", "strip", "mission", "day", "module", "tag", "dim", "direction", "role", "line", "date", "mask", "maybe", "stage", "range", "chrom", "ward", "scope", "Mode", "command", "theme", "type"], "ns_status": ["ns__level", "ns__status", "ns_magic", "css_num", "ns_score", "net_status", "css_magic", "ns__num", "ns_level", "net_level", "ns__score", "ns_num", "css_status", "net_score", "ns__magic"]}}
{"project": "qemu", "commit_id": "da57febfed7bad11be79f047b59719c38abd0712", "target": 0, "func": "DeviceState *qdev_try_create(BusState *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n\n\n    if (object_class_by_name(name) == NULL) {\n\n        return NULL;\n\n    }\n\n    dev = DEVICE(object_new(name));\n\n    if (!dev) {\n\n        return NULL;\n\n    }\n\n\n\n    if (!bus) {\n\n        bus = sysbus_get_default();\n\n    }\n\n\n\n    qdev_set_parent_bus(dev, bus);\n\n    qdev_prop_set_globals(dev);\n\n\n\n    return dev;\n\n}\n", "idx": 7579, "substitutes": {"bus": ["vol", "base", "plugin", "ch", "block", "hub", "local", "http", "id", "parent", "BUS", "device", "config", "plug", "bug", "io", "home", "use", "lab", "cat", "sync", "Bus", "loc", "db", "f", "book", "usb", "state", "loop", "us", "kind", "mount", "se", "driver", "lib", "bc", "pass", "self", "lock", "bridge", "controller", "serial", "root", "boot", "pos", "os", "class", "cache", "host", "ass"], "name": ["base", "address", "id", "parent", "unknown", "device", "word", "object", "data", "alias", "named", "info", "names", "key", "package", "null", "version", "Name", "part", "code", "NAME", "size", "connection", "ame", "n", "path", "self", "str", "nam", "none", "new", "type", "class", "prefix"], "dev": ["ch", "od", "local", "rad", "di", "Dev", "dd", "device", "adv", "bug", "val", "data", "enc", "ad", "dem", "der", "debug", "valid", "gu", "private", "de", "d", "ve", "mod", "obj", "dist", "conf", "ev", "def", "DEV", "wd", "priv", " Dev", "kind", "error", "inst", "die", "driver", "sd", "dc", "comment", "instance", "err", "self", "result", "p", "pub", "serial", "h", "prop", "development", "ver", "var", "gd", "cache", "fi", "app", "test", "prov", "grad", "conn", "diff", "cd"]}}
{"project": "qemu", "commit_id": "79853e18d904b0a4bcef62701d48559688007c93", "target": 0, "func": "static void spapr_hotplug_req_event(sPAPRDRConnector *drc, uint8_t hp_action)\n\n{\n\n    struct hp_log_full *new_hp;\n\n    struct rtas_error_log *hdr;\n\n    struct rtas_event_log_v6 *v6hdr;\n\n    struct rtas_event_log_v6_maina *maina;\n\n    struct rtas_event_log_v6_mainb *mainb;\n\n    struct rtas_event_log_v6_hp *hp;\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    sPAPRDRConnectorType drc_type = drck->get_type(drc);\n\n\n\n    new_hp = g_malloc0(sizeof(struct hp_log_full));\n\n    hdr = &new_hp->hdr;\n\n    v6hdr = &new_hp->v6hdr;\n\n    maina = &new_hp->maina;\n\n    mainb = &new_hp->mainb;\n\n    hp = &new_hp->hp;\n\n\n\n    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6\n\n                               | RTAS_LOG_SEVERITY_EVENT\n\n                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED\n\n                               | RTAS_LOG_OPTIONAL_PART_PRESENT\n\n                               | RTAS_LOG_INITIATOR_HOTPLUG\n\n                               | RTAS_LOG_TYPE_HOTPLUG);\n\n    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)\n\n                                       - sizeof(new_hp->hdr));\n\n\n\n    spapr_init_v6hdr(v6hdr);\n\n    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);\n\n\n\n    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);\n\n    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));\n\n    mainb->subsystem_id = 0x80; /* External environment */\n\n    mainb->event_severity = 0x00; /* Informational / non-error */\n\n    mainb->event_subtype = 0x00; /* Normal shutdown */\n\n\n\n    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);\n\n    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));\n\n    hp->hdr.section_version = 1; /* includes extended modifier */\n\n    hp->hotplug_action = hp_action;\n\n\n\n\n\n    switch (drc_type) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n        hp->drc.index = cpu_to_be32(drck->get_index(drc));\n\n        hp->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX;\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;\n\n        break;\n\n    default:\n\n        /* we shouldn't be signaling hotplug events for resources\n\n         * that don't support them\n\n         */\n\n        g_assert(false);\n\n        return;\n\n    }\n\n\n\n    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq));\n\n}\n", "idx": 5298, "substitutes": {"drc": ["lRC", "drec", "brc", "lsrc", "dsrc", "dRC", "bRC", "bsrc", "fpc", "tRC", "lrc", " dsrc", " dpc", "lrec", "trec", "tpc", "frc", "dpc", "fRC", "frec", "trc", "fsrc", " dRC", " drec", "brec"], "hp_action": ["HP_index", "HP_action", "hpfid", "HP_act", "hpfindex", "hp_index", "hp_id", "HP_id", "hpfaction", "hpfact", "hp_act"], "new_hp": ["new_bh", "new___bh", "NEW_hp", "new67gp", "old_gp", "finalFht", "newJhp", "old_hp", "newFgp", "new_hw", "NEW_bh", "new_hap", "newJgp", "new_gp", "NEW_cp", "new___hw", "NEW_hap", "old_cpp", "newFmph", "new_mph", "finalFhp", "new_hy", " new_hop", "final_mph", "final_hp", "newFhp", "new_ht", "final_gp", "newFht", "new67cp", " new_cp", "finalFmph", "new_cpp", "new_ih", "finalFgp", "newJcp", "old_ih", " new_hy", "new___hp", "new___hap", "new_hop", " new_gp", "new_cp", "new_wp", "new67hp", "old_cp", "old_hop", " new_wp", "new67hy", "NEW_gp", "final_ht", "NEW_hw"], "hdr": ["hmdr", " hDR", "hstr", "hmirt", "ahdu", "ohrid", "Hride", "ohder", "bhstr", "hirt", "shride", "enhDR", "dhrid", "ohdr", "hmstr", "hder", "hrt", "hgr", "ghdu", "Hbr", "thdu", "phDR", "shint", "ghder", "bhdr", "chmt", "hhDR", "shDR", "hhrs", "thstr", "shrc", "hrc", " hrt", "hbr", "Hint", " hrs", "shdr", "hegr", "ahder", "shirt", "dhdr", "hride", "ghint", "dhgr", "heder", "ohgr", "dhder", " hrid", "hhbr", "Hrs", "qrid", "hmt", "ghstr", "ahdr", "hrs", "enhdr", "HDR", "hrid", "adhrid", " hint", "phrid", "hrint", "ghirt", "adhDR", "bhirt", "hdu", "hedr", " hmt", "chint", "hhdr", "ghrt", " hirt", "qdr", "enhmt", " hstr", " hbr", "hint", "chdr", "ghdr", "thder", "Hrc", "enhrid", "qmt", "shrid", "shrt", "phrt", "phdr", "adhdr", "Hdr", "hrrc", "chrid", "qint", "hrdr", "hDR", "ahstr", "thdr", "herid", "hrride", "adhmt"], "v6hdr": ["v0hdr", "v6hver", "v6hmrt", "v3bhct", "v6thdr", "v0hld", "v6hydr", "v3bhrid", "v6phr", "v6hlld", "v3hct", "v6hrt", "v8hint", "v6hmr", "v8wver", "v16hDR", "v0hrt", "v6shver", "v6chDR", "v6bhhr", "v6shint", "v8host", "v16hmDR", "v6bhrr", "v16hmhr", "v6phhr", "v6hld", "v6shost", "v6bhld", "v6wint", "v6bhct", "v8wost", "v6hyint", "v6hr", "v6hlrt", "v6bhdr", "v16hhr", "v6hrid", "v16hmr", "v6bhrt", "v3bhdr", "v6hhr", "v6phdr", "v6hldr", "v6hint", "v0hrr", "v6hlrr", "v6thDR", "v6wdr", "v3hDR", "v6hmhr", "v3hrid", "v6hct", "v16hr", "v6chdr", "v6hmrr", "v0hmld", "v6shdr", "v6chct", "v6phDR", "v6bhr", "v8wdr", "v6hrr", "v6thrid", "v6wver", "v8hver", "v6hyver", "v6host", "v6wost", "v0hmdr", "v8hdr", "v6bhrid", "v16hmdr", "v6hmld", "v6hmdr", "v6chrid", "v0hmrr", "v6hmDR", "v6bhDR", "v6hyost", "v3hdr", "v16hdr", "v0hmrt", "v6hDR", "v8wint", "v6thct", "v3bhDR"], "maina": ["Mainaa", "mainc", "minaa", "masteras", " mainc", "minA", " maine", "masteraa", " mainaa", "minas", "mainaa", " mainA", "mainA", "masterb", "minb", "mastera", "masteri", " mainas", "masterc", "Mainb", "maine", "maini", "mastere", "mini", "MainA", "mainas", "mine", "Maina", "Mainc", "mina", " maini"], "mainb": ["primaryb", "Mainbody", "mainobject", "minobject", "defaultc", "centralf", " mainc", "westab", "centralb", "centrala", "defaultb", "minb", " mainobject", "primarya", " maink", " mainbad", "mainas", "mine", "mainf", " mainbody", "Mainc", " mainbar", "publicback", "publick", "minB", " maine", " mainba", "westa", "Mainbar", "masterb", "donbad", "mastera", " mainab", "publicb", "sideobject", "dateas", "Mainb", "maine", "defaulta", "sidebe", "sideb", "primaryas", "Mainab", "primaryba", "mina", "weste", "donk", "donback", "mainB", "masterab", "mainc", "dateb", "centralk", "mainbar", "mainbe", "masterB", "donb", "sidea", "defaultbody", "publicbad", "minbar", "westb", "mainbody", "Mainas", "minbe", "mainba", "mainback", "mink", "masterbar", "maink", " mainB", "minf", "minab", "centralba", "dateba", " mainf", "mainbad", "minba", "mainab", "datea", "Maina", " mainbe", "Mainba", " mainback"], "hp": ["cp", "health", "gp", "hw", "hap", "bp", "imp", "HP", "phy", "pai", "ih", "config", "drm", "dh", "xp", "wm", "ssh", "wp", "lp", "rh", "him", "php", "prot", "cli", "ph", "hs", "np", "hm", "dp", "hh", "hl", "jp", "fp", "hop", "p", "h", "vp", "hy", "ht", "mph", "ip", "ssl", "tp", "adj", "ha", "cpp", "bh", "pkg"], "drck": ["rq", "drcc", "prk", "hrk", "drq", "hrq", "hrcc", " drq", "DRcc", "rck", "hrke", "DRke", " drcc", "DRck", "hrck", " drack", "hrack", "prke", "drk", "rcc", "drack", "prcc", "prck", "DRk", "rack", "drke"]}}
{"project": "FFmpeg", "commit_id": "170870b77c8c71304f9eae946d49aa5e30a464bc", "target": 1, "func": "static int sdp_parse_rtpmap(AVFormatContext *s,\n\n                            AVCodecContext *codec, RTSPStream *rtsp_st,\n\n                            int payload_type, const char *p)\n\n{\n\n    char buf[256];\n\n    int i;\n\n    AVCodec *c;\n\n    const char *c_name;\n\n\n\n    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and\n\n     * see if we can handle this kind of payload.\n\n     * The space should normally not be there but some Real streams or\n\n     * particular servers (\"RealServer Version 6.1.3.970\", see issue 1658)\n\n     * have a trailing space. */\n\n    get_word_sep(buf, sizeof(buf), \"/ \", &p);\n\n    if (payload_type >= RTP_PT_PRIVATE) {\n\n        RTPDynamicProtocolHandler *handler;\n\n        for (handler = RTPFirstDynamicPayloadHandler;\n\n             handler; handler = handler->next) {\n\n            if (!strcasecmp(buf, handler->enc_name) &&\n\n                codec->codec_type == handler->codec_type) {\n\n                codec->codec_id          = handler->codec_id;\n\n                rtsp_st->dynamic_handler = handler;\n\n                if (handler->open)\n\n                    rtsp_st->dynamic_protocol_context = handler->open();\n\n                break;\n\n            }\n\n        }\n\n    } else {\n\n        /* We are in a standard case\n\n         * (from http://www.iana.org/assignments/rtp-parameters). */\n\n        /* search into AVRtpPayloadTypes[] */\n\n        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);\n\n    }\n\n\n\n    c = avcodec_find_decoder(codec->codec_id);\n\n    if (c && c->name)\n\n        c_name = c->name;\n\n    else\n\n        c_name = (char *) NULL;\n\n\n\n    if (c_name) {\n\n        get_word_sep(buf, sizeof(buf), \"/\", &p);\n\n        i = atoi(buf);\n\n        switch (codec->codec_type) {\n\n        case CODEC_TYPE_AUDIO:\n\n            av_log(s, AV_LOG_DEBUG, \"audio codec set to: %s\\n\", c_name);\n\n            codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;\n\n            codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;\n\n            if (i > 0) {\n\n                codec->sample_rate = i;\n\n                get_word_sep(buf, sizeof(buf), \"/\", &p);\n\n                i = atoi(buf);\n\n                if (i > 0)\n\n                    codec->channels = i;\n\n                // TODO: there is a bug here; if it is a mono stream, and\n\n                // less than 22000Hz, faad upconverts to stereo and twice\n\n                // the frequency.  No problem, but the sample rate is being\n\n                // set here by the sdp line. Patch on its way. (rdm)\n\n            }\n\n            av_log(s, AV_LOG_DEBUG, \"audio samplerate set to: %i\\n\",\n\n                   codec->sample_rate);\n\n            av_log(s, AV_LOG_DEBUG, \"audio channels set to: %i\\n\",\n\n                   codec->channels);\n\n            break;\n\n        case CODEC_TYPE_VIDEO:\n\n            av_log(s, AV_LOG_DEBUG, \"video codec set to: %s\\n\", c_name);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    return -1;\n\n}\n", "idx": 6125, "substitutes": {"s": ["sets", "http", "spec", "session", "b", "sys", "ses", "services", "m", "tools", "f", "client", "ns", "stats", "server", "cli", "us", "cs", "service", "sports", "conf", "e", "sc", "parser", "gs", "sb", "bis", "t", "ds", "lex", "aws", "fs", "os", "g", "ssl", "sq", "rs", "r", "ps", "setup", "js"], "codec": ["codroc", "codeocol", "codocol", "codeef", "taxesc", "codentity", "codeus", " codrec", " codeco", "oddec", "CodEC", "modec", "codenc", "metesc", "coderc", "codeenc", "copesc", "libec", " codect", "codeEC", "genesc", "Codesc", " codentity", "codeac", "libEC", "odec", "codefc", "equec", "codeco", "validec", "Codef", "predef", "predrec", "codeca", "Codect", "codeeca", "moduc", "codex", "odeca", "metex", "odex", "codeuc", "Coduc", "taxeco", "coddec", " codocol", "modeus", "predEC", "libesc", " codroc", "codedec", "libef", "metdec", "odocol", "codac", " codEC", "odrec", "oduc", "genroc", "copac", "codeex", "codfc", "defesc", "taxentity", "defec", "odEC", "metec", "genec", "predeca", "Codex", "codrec", " coderc", "Codec", " codef", " coduc", "metenc", "copec", "odenc", "validentity", "odef", "defef", "codEC", "codesc", "codeec", "predec", "codef", "codeeus", "codeesc", "taxec", "odroc", "odesc", " codeus", "coduc", "modfc", "equuc", " codesc", "codeect", "metuc", " codeca", "validesc", " codfc", "copef", "codect", "defac", "valideco", "equeca", "codeerc", "Coderc", "equex", "preduc"], "rtsp_st": ["rtsv_sts", "rtsv_sta", "rtsp_sth", "rtsv_st", "rtsfp_st", "rtsp1stream", "rtspfst", "rtspJst", "rtsp2st", "rtsv_stream", "rtsfp_sth", "rtsv_sth", "rtsp1sth", "rtsp2sta", "rtsp1ST", "rtsp_ST", "rtsp_inst", "rtspfstream", "rtspfsth", "rtspJsth", "rtsfp_stream", "rtspJinst", "rtsp_sts", "rtsp2stream", "rtsp_stream", "rtsp1st", "rtsp2sts", "rtspJstream", "rtsp_sta", "rtsv_inst", "rtsfp_ST", "rtspfinst"], "payload_type": ["payload_number", "payec_id", "payloadaltype", "payload_types", "payec_type", "payloadalnumber", "payload_name", "payec_number", "payloadalid", "payec_types", "payec_name", "payload_id"], "p": ["P", "o", "bp", "padding", "v", "pa", "b", "op", "format", "wp", "ap", "lp", "pe", "m", "l", "f", "pi", "at", "d", "j", "pc", "q", "param", "np", "e", "point", "port", "t", "n", "ctx", "fp", "h", "vp", "sp", "ip", "g", "type", "api", "tp", "params", "r", "ps"], "buf": ["rb", "b", "data", "auc", "queue", "bi", "uc", "f", "buffer", "bag", "func", "bc", "ab", "pool", "proc", "pb", "img", "bh", "msg", "bed", "fam", "lb", "cur", "config", "fb", "uf", "ru", "binary", "received", "ctx", "filename", "font", "batch", "wav", "bags", "cap", "txt", "text", "addr", "ff", "brace", "feed", "vec", "block", "box", "bd", "rc", "exc", "map", "grab", "db", "wb", "conv", "que", "Buffer", "cmd", "feat", "input", "prop", "orig", "fd", "desc", "cache", "src", " b", "buff", "la", "Buff", " buffer", "bus", "cb", "result", "seq", "bf", "br", "cv", "pkg"], "i": ["gi", "ri", "area", "ti", "v", "wei", "I", "is", "alpha", "count", "di", "ci", "ki", "ji", "ni", "xi", "b", "si", "io", "slice", "abi", "x", "info", "bi", "m", "qi", "l", "f", "pi", "phi", "adi", "j", "iu", "ii", "d", "esi", "ai", "cli", "init", "length", "u", "it", "e", "ami", "uri", "ori", "t", "n", "multi", "mi", "ini", "ie", "mini", "eni", "hi", "ip", "type", "api", "y", "li", "anti", "index", "zi", "diff", "mu", "ui"], "c": ["cmp", "oc", "ch", "anc", "o", "v", "ci", "chain", "b", "nc", "rec", "rc", "cy", "enc", "co", "C", "m", "uc", "in", "cm", "l", "cl", "f", "client", "d", "pc", "cc", "cs", "ce", "u", "arc", "code", "con", "e", "mc", "col", "dc", "k", "n", "ctx", "t", "bc", "cu", "coll", "ca", "ec", "h", "g", "ct", "cn", "lc", "cf", "fc", "ac", "cache", "r", "ctrl", "cd", "xc", "tc"], "c_name": [" c_data", "c_la", "c_num", "c___key", " c_prefix", "c___id", "c_NAME", "p_name", " c_value", "C_block", "enc_name", "cJsize", "c__prefix", "c_prefix", "cJprefix", "cJno", "c___name", "c_key", "c2num", " c_no", "enc_type", "C_name", "c_size", "c__data", "cJvalue", "c__size", "c_data", "c_value", "C_id", "enc_num", "c2type", "p_la", "c___block", "c_block", "cJNAME", "p_id", "cJname", "C_key", "c_id", " c_NAME", "c2name", "cJdata", "c__name", " c_size", "c_no", "c_type", "c2key", "enc_key"], "handler": ["writer", "layer", "band", "entry", "hand", "object", "handled", "route", "f", "job", "magic", "service", "code", "error", "connection", "file", "callback", "controller", "reader", "h", "filter", "page", "folder", "function", "plugin", "name", "channel", "config", "slice", "widget", "server", "cher", "loop", "later", "man", "definition", "item", "driver", "lib", "path", "field", "application", "ctx", "response", "runner", "type", "model", "cookie", "command", "end", "address", "area", "er", "feed", "or", "phase", "holder", "key", "package", "guard", "parser", "message", "fd", "api", "core", "loader", "wrapper", "event", "client", "player", "child", "handle", "lr", "result", "Handler", "pointer", "inner", "manager", "worker"]}}
{"project": "qemu", "commit_id": "684e508c23d28af8d6ed2c62738a0f60447c8274", "target": 1, "func": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_max_ns);\n\n\n\n        if (max_ns) {\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 6206, "substitutes": {"ctx": ["cp", "cmp", "gc", "anc", "cr", "fw", "ci", "config", "nc", "rc", "cca", "sync", "cus", "comp", "loc", "cm", "support", "tx", "cl", "event", "client", "ga", "call", "pc", "cc", "cli", "cs", "ck", "sc", "connection", "conn", "cmd", "instance", "bc", "cb", "cms", "Context", "cu", "jp", "context", "kw", "ca", "qa", "css", "req", "c", "ct", "cn", "cf", "lc", "thread", "util", "fc", "cv", "vc", "cas", "grad", "ctrl", "pkg", "xc", "tc"], "blocking": ["padding", "using", "regular", "block", "testing", "http", "complete", "starting", "including", "loading", "successful", "rolling", "ocking", "cl", "client", "background", "enabled", "cli", "locking", "buffer", "exclusive", "full", "calling", "bc", "working", "exec", "interrupted", "running", "blocks", "restricted", "protected", "locked", "ssl", "bl", "partial", "quiet", "prefix"]}}
{"project": "qemu", "commit_id": "595ab64169be9063d64c3b1aa1c249fbe2662221", "target": 1, "func": "static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    ssize_t len;\n\n\n\n    do {\n\n        len = qemu_recv(s->fd, buf, size, 0);\n\n    } while (len == -1 && socket_error() == EINTR);\n\n\n\n    if (len == -1)\n\n        len = -socket_error();\n\n\n\n    return len;\n\n}\n", "idx": 13736, "substitutes": {"opaque": [" opaques", "opace", "oppaques", "oppity", "oppca", "opity", "oopca", "oppaque", "opaques", "iopace", "opca", " opicit", "oopaque", "iopaque", "phpace", " opque", "oopity", "opque", "iopque", "phpicit", "phpque", " opace", "phpaque", " opity", "oopaques", "opicit", " opca", "iopicit"], "buf": ["vec", "port", "context", "blocks", "bc", "queue", "fd", "cv", "fl", "batch", "config", "fb", "uf", "bound", "bytes", "pool", "buffer", "bag", "loc", "fp", "buff", "rb", "pb", "data", "b", "base", "Buffer", "box", "length", "wb", "f", "ab", "c", "cb", "cap", "que", "db", "cache", "src", "seq", "ctx", "lim", "alloc"], "pos": [" offset", "port", "val", " position", "os", "str", "position", "loc", "limit", "set", " index", "p", "pointer", "base", "from", "address", "block", "end", "offset", " positions", " start", "seq", "Pos", "off", "no", "addr", "start"], "size": ["args", "en", "small", "enc", "id", "code", "name", "Size", "bytes", "position", "loc", "limit", "z", "ize", "p", "e", "data", "length", "count", "n", "address", "c", "timeout", "end", "SIZE", "offset", "sn", "cache", "empty", "start"], "s": ["sys", "ses", "m", "service", "sync", "fs", "sym", "syn", "S", "os", "si", "es", "js", "sq", "session", "server", "o", "p", "e", "sec", "socket", "http", "sb", "f", "gs", "spec", "c", "ns", "is", "ssl", "sl", "ops", "ds", "sie", "sa", "ls", "ips", "ts"], "len": ["ln", "vec", "en", "rev", "hl", "_", "fl", "Len", "rc", " lang", "l", "val", "i", "code", "pre", " length", "lc", "fun", " el", "h", " lib", "bytes", "str", "ie", "js", "fn", "limit", "lib", " l", "dy", "ll", "z", "e", "fin", "lt", "li", "data", "length", "ler", "n", "count", "f", "line", "lf", "url", " err", "body", "nt", "all", "le", "sl", "elt", "db", "El", "ls", "num", "no", "el", "err"]}}
{"project": "FFmpeg", "commit_id": "138568e9da0e3abfc818329ab12ea3fb667639fb", "target": 0, "func": "static int mov_read_ctts(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)\n\n{\n\n    AVStream *st = c->fc->streams[c->fc->nb_streams-1];\n\n    MOVStreamContext *sc = st->priv_data;\n\n    unsigned int i, entries;\n\n\n\n    get_byte(pb); /* version */\n\n    get_be24(pb); /* flags */\n\n    entries = get_be32(pb);\n\n    if(entries >= UINT_MAX / sizeof(MOV_stts_t))\n\n        return -1;\n\n\n\n    sc->ctts_count = entries;\n\n    sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t));\n\n    if (!sc->ctts_data)\n\n        return -1;\n\n    dprintf(c->fc, \"track[%i].ctts.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    for(i=0; i<entries; i++) {\n\n        int count    =get_be32(pb);\n\n        int duration =get_be32(pb);\n\n\n\n        if (duration < 0) {\n\n            av_log(c->fc, AV_LOG_ERROR, \"negative ctts, ignoring\\n\");\n\n            sc->ctts_count = 0;\n\n            url_fskip(pb, 8 * (entries - i - 1));\n\n            break;\n\n        }\n\n        sc->ctts_data[i].count   = count;\n\n        sc->ctts_data[i].duration= duration;\n\n\n\n        sc->time_rate= ff_gcd(sc->time_rate, duration);\n\n    }\n\n    return 0;\n\n}\n", "idx": 11795, "substitutes": {"c": ["cr", "l", "conf", "arc", "co", "oc", "C", "g", "w", "tc", "t", "d", "con", "cp", "s", "p", "cd", "e", "cu", "cf", "ec", "cod", "coll", "bc", "cc", "f", "ac", "cs", "ctrl", "cv", "mc", "ce", "ic", "ctx", "cur", "cl", "dc", "pc", "xc", "enc", "cpp", "u", "nc", "icc", "ca", "cm", "gc", "ci", "vc", "lc", "ch", "cache", "cus", "uc", "cy", "fc"], "pb": ["lp", "dp", "uf", "bb", "wp", "pg", "bp", "prot", "pl", "tc", "bm", "b", "lab", "ab", "wb", "pa", "buf", "cp", "fb", "p", "pd", "cb", "fp", "gb", "pro", "pt", "rb", "pm", "bc", "db", "bf", "mp", "eb", "py", "bps", "bh", "phrase", "ctx", "lb", "tp", "jp", "sb", "pc", "PB", "cpp", "hub", "plugin", "emb", "platform", "mb", "api", "ob", "xb", "proc", "rob", "fc"], "atom": [" bom", " param", "bb", "abc", " biom", " plat", " Atom", " arr", " om", " ab", " mom", " gate", " program", "orb", " atoms", " app", " slab", "AT", " dom", " tom", "cm", " symb", " form", "OM", " org", " tab", "om", " orb"], "st": ["cr", "l", "sp", "std", "ds", "str", "sf", "stage", "src", "t", "sa", "ct", "s", "se", "e", "ec", "sec", "bc", "inst", "contract", "sts", "sl", "sn", "sth", "ste", "cl", "sb", "pc", "sd", "St", "ST", "lc", "ss", "uc", "fc"], "sc": ["cr", "sp", "asc", "SC", "sh", "context", "si", "cca", "tc", "src", "go", "auc", "sw", "RC", "sci", "cer", "capt", "config", "cd", "osc", "gb", "uci", "cf", "Sc", "ec", "sq", "loc", "bc", "cc", "cs", "isc", "sub", "cv", "mc", "scope", "sync", "rc", "inc", "sche", "ctx", "sup", "cl", "desc", "pc", "spec", "enc", "cms", "FC", "sim", "cm", "ca", "usc", "soc", "esc", "comp", "css", "lc", "ch", "ss", "sr", "ocr", "cus", "uc", "core", "cy", "acc", "fc"], "i": ["count", "l", "oi", "hi", "ui", "di", "it", "start", "si", "n", "zi", "key", "id", "info", "xi", "m", "b", "ami", "ini", "z", "x", "t", "d", "p", "ix", "uri", "e", "cli", "mu", "esi", "eni", "f", "ie", "j", "code", "ai", "multi", "slice", "v", "name", "gi", "ti", "mi", "phi", "r", "abi", "qi", "ij", "ei", "counter", "bi", "pi", "ii", "u", "type", "I", "li", "ip", "ci", "api", "length", "ni", "y", "io", "ri", "lc", "fi", "iu"], "entries": ["ntrys", "intents", "entsriers", "country", "antry", "endresses", "sentrys", "Entrys", "attries", "entents", "entsries", "enturies", "entencies", "centories", "ntries", "sentries", "sentry", "anturies", "enties", "entrants", "ntrants", "entriers", "mentries", "centrys", "Entries", "estrations", "countries", "Entrics", "ientrics", "menties", "nties", "centries", "attresses", "ientry", "sentents", "idents", "attrations", "entrics", "entsories", "endies", "attrys", "entrys", "intresses", "mentrations", "intries", "idories", "ntrations", "Entry", "centrations", "idries", "antrants", "nturies", "entry", "entrations", "centents", "entresses", "mentencies", "entsents", "antries", "entories", "esties", "intry", "endrys", "idriers", "endries", "intrys", "countents", "countrys", "ientries", "ntencies", "estries", "ntrics", "ienturies", "ientrants", "ntry", "centriers", "Enties", "ientrys", "attry", "estencies", "endry", "centry"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "bool qemu_co_enter_next(CoQueue *queue)\n\n{\n\n    Coroutine *next;\n\n\n\n    next = QSIMPLEQ_FIRST(&queue->entries);\n\n    if (!next) {\n\n        return false;\n\n    }\n\n\n\n    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);\n\n    qemu_coroutine_enter(next, NULL);\n\n    return true;\n\n}\n", "idx": 1381, "substitutes": {"queue": ["route", "ue", "group", "server", "cycle", "delay", "buffer", "q", "channel", "sequence", "command", "context", "menu", "Queue", "page", "job", "list", "loop", "batch", "future", "code", "file", "event", "config", "feed", "cache", "message", "gui", "connection", "collection", "prefix", "seq", "lib", "plugin", "qa", "module", "manager", "line", "que", "console"], "next": ["flow", " Next", "same", "server", "after", "primary", "offset", "key", "sequence", "second", "success", "new", "current", "data", "more", "page", "open", "end", "frame", "client", "first", "Next", "future", "code", "entry", "big", "forward", "reply", "pointer", "last", "business", "step", "foo", "self", "iterator", "prev", "front", " NEXT", "core", "object", "value", "obj", "sec", "range", "up", "seq", "link", "valid", "line", "good", "latest", "one", "start", "pack", "done"]}}
{"project": "qemu", "commit_id": "f65ed4c1529f29a7d62d6733eaa50bed24a4b2ed", "target": 1, "func": "int kvm_init(int smp_cpus)\n{\n    KVMState *s;\n    int ret;\n    int i;\n    if (smp_cpus > 1)\n        return -EINVAL;\n    s = qemu_mallocz(sizeof(KVMState));\n    if (s == NULL)\n        return -ENOMEM;\n    for (i = 0; i < ARRAY_SIZE(s->slots); i++)\n        s->slots[i].slot = i;\n    s->vmfd = -1;\n    s->fd = open(\"/dev/kvm\", O_RDWR);\n    if (s->fd == -1) {\n        fprintf(stderr, \"Could not access KVM kernel module: %m\\n\");\n        ret = -errno;\n        goto err;\n    }\n    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);\n    if (ret < KVM_API_VERSION) {\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm version too old\\n\");\n        goto err;\n    }\n    if (ret > KVM_API_VERSION) {\n        ret = -EINVAL;\n        fprintf(stderr, \"kvm version not supported\\n\");\n        goto err;\n    }\n    s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0);\n    if (s->vmfd < 0)\n        goto err;\n    /* initially, KVM allocated its own memory and we had to jump through\n     * hooks to make phys_ram_base point to this.  Modern versions of KVM\n     * just use a user allocated buffer so we can use phys_ram_base\n     * unmodified.  Make sure we have a sufficiently modern version of KVM.\n     */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_USER_MEMORY);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr, \"kvm does not support KVM_CAP_USER_MEMORY\\n\");\n        goto err;\n    }\n    /* There was a nasty bug in < kvm-80 that prevents memory slots from being\n     * destroyed properly.  Since we rely on this capability, refuse to work\n     * with any kernel without this capability. */\n    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION,\n                    KVM_CAP_DESTROY_MEMORY_REGION_WORKS);\n    if (ret <= 0) {\n        if (ret == 0)\n            ret = -EINVAL;\n        fprintf(stderr,\n                \"KVM kernel module broken (DESTROY_MEMORY_REGION)\\n\"\n                \"Please upgrade to at least kvm-81.\\n\");\n        goto err;\n    }\n    ret = kvm_arch_init(s, smp_cpus);\n    if (ret < 0)\n        goto err;\n    kvm_state = s;\n    return 0;\nerr:\n    if (s) {\n        if (s->vmfd != -1)\n            close(s->vmfd);\n        if (s->fd != -1)\n            close(s->fd);\n    }\n    qemu_free(s);\n    return ret;\n}", "idx": 9418, "substitutes": {"smp_cpus": ["smp_gpus", "smp_puses", "smp_mpu", "smp_pul", "smp_cpu", "smp_gpis", "smp_mpis", "smp_gpul", "smp_gpuses", "smp_ipu", "smp_cpul", "smp_cpuses", "smp_ipis", "smp_mpul", "smp_cpis", "smp_mpuses", "smp_gpu", "smp_pus", "smp_ipus", "smp_mpus", "smp_pis", "smp_ipuses"], "s": ["l", "session", "is", "m", "http", "t", "x", "gs", "set", "sk", "v", "state", "bis", "groups", "ns", "spec", "self", "settings", "sg", "ds", "si", "n", "your", "sf", "w", "b", "k", "c", "se", "e", "args", "sq", "us", "f", "j", "sym", "sets", "scope", "es", "current", "sup", "r", "storage", "as", "ps", "su", "site", "fs", "ss", "secure", "g", "stat", "d", "sa", "ls", "status", "socket", "os", "cs", "o", "sync", "south", "sl", "native", "new", "sb", "sys", "secondary", "ssl", "conf", "ts", "in", "service", "p", "server", "qs", "tests", "xs", "js", "rs", "sec", "aws", "S", "states", "services", "h", "client", "ses", "y"], "ret": ["true", "af", "fail", "red", "ref", "arg", "cb", "reg", "gt", "code", "al", "opt", "end", "att", "err", "hash", "re", " RET", "let", "url", "resp", "arr", "flag", "val", "key", "id", "no", "Ret", "mem", "post", "fit", "ut", "j", "db", "res", "bf", "det", "lt", "art", "error", "back", "not", "sat", "mt", "rl", "bad", "str", "nb", "len", "alt", "def", "nt", "conn", "num", " Ret", "pat", "reply", "status", "rb", "rt", "rc", "fun", "req", "part", "cat", "result", "success", "pass", "valid", "info", "sur", "job", "lit", "pt", "rets", "bot", "bit", "RET", "ft", "rev", "match", "feat", "pet"], "i": ["oi", "l", "sp", "ui", "dim", "di", "base", "it", "si", "n", "zi", "key", "m", "xi", "id", "b", "x", "t", "ini", "k", "d", "uli", "c", "p", "ix", "uri", "e", "mu", "eni", "f", "ie", "j", "ai", "o", "multi", "index", "slice", "gi", "mi", "ind", "ti", "phi", "abi", "qi", "err", "pi", "bi", "part", "ii", "init", "u", "uni", "I", "li", "ip", "ci", "ni", "io", "y", "ri", "fi", "iu", "ki"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,\n\n                                        QGuestAllocator *alloc, uint16_t entry)\n\n{\n\n    uint16_t vector;\n\n    uint32_t control;\n\n    void *addr;\n\n\n\n    g_assert(d->pdev->msix_enabled);\n\n    addr = d->pdev->msix_table + (entry * 16);\n\n\n\n    g_assert_cmpint(entry, >=, 0);\n\n    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));\n\n    d->config_msix_entry = entry;\n\n\n\n    d->config_msix_data = 0x12345678;\n\n    d->config_msix_addr = guest_alloc(alloc, 4);\n\n\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,\n\n                                                    d->config_msix_addr & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,\n\n                                            (d->config_msix_addr >> 32) & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);\n\n\n\n    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,\n\n                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);\n\n\n\n    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);\n\n    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);\n\n    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);\n\n}\n", "idx": 10727, "substitutes": {"d": ["ld", "l", "gd", "di", "mad", "dh", "ds", "n", "g", "dom", "in", "dict", "da", "id", "m", "dt", "dos", "fd", "b", "t", "z", "dj", "k", "ud", "de", "i", "c", "data", "ad", "bd", "p", "wd", "s", "e", "cd", "pd", "du", "q", "dn", "df", "f", "dr", "dl", "j", "db", "dat", "xd", "nd", "md", "done", "mod", "dd", "old", "vd", "dc", "sd", "ct", "plugin", "dm", "h", "od", "der", "dad", "td", "D"], "alloc": ["mac", "arc", "oc", "ack", "abc", "val", "access", "win", "nt", "org", "src", "pl", "pack", "rec", "buf", "doc", "block", "slot", "c", "config", "util", "exec", "ptr", "ec", "loc", "oci", "hw", "sec", "ac", "vol", "oca", "aux", "gate", "ea", "rc", "ctx", "loader", "offset", "init", "use", "anc", "roc", "sc", "acc", "rac"], "entry": ["count", "element", "byte", "Entry", "start", "enter", "ry", "section", "prefix", "record", "pad", "id", "nt", "info", "version", "card", "letter", "data", "config", "uri", "reader", "server", "e", "zero", "add", "driver", "feed", "value", "number", "or", "array", "sec", "ie", "dr", "code", "ctrl", "slice", "index", "size", "route", "module", "parse", "rc", "inc", "event", "input", "r", "end", "address", "option", "port", "ident", "error", "offset", "pair", "command", "row", "attribute", "import", "image", "insert", "cell", "length", "seed"], "vector": ["Vector", "element", "ion", "timeout", "character", "point", "password", "shadow", "letter", "buf", "block", "config", "server", "reader", "uri", "output", "driver", "collection", "value", "number", "writer", "array", "serial", "sequence", "manager", "device", "zero", "version", "index", "v", "connection", "object", "address", "document", "uration", "port", "token", "variable", "counter", "position", "controller", "command", "volume", "ault", "header", "io", "length", "vec", "buffer", "volt", "direction"], "control": ["ion", "timeout", "holder", "character", "ack", "handle", "comment", "info", "board", "card", "controlled", "update", "data", "block", "rule", "config", "Control", "output", "reader", "add", "driver", "feed", "bug", "sequence", "trl", "ctrl", "sub", "lib", "rol", "ride", "per", "event", "current", "contact", "guard", "protected", "edit", "object", "address", "state", "port", "roll", "variable", "support", "pull", "error", "oper", "controller", "form", "command", "io", "cell", "safe", "forward", "sc"], "addr": ["alias", "adr", "Address", "oc", "ack", "arm", "enter", "alt", "val", "ord", "pad", "nt", "org", "src", "rr", "x", "pointer", "ad", "work", "add", "ace", "coord", "attr", "usr", "env", "amd", "act", "ptr", "loc", "eni", "dr", "host", "rt", "pkg", "call", "index", "size", "oa", "edge", "route", "ort", "module", "order", "align", "ar", "md", "end", "address", "kt", "dd", "nr", "part", "art", "dc", "hop", "offset", "hash", "node", "eth", "vr", "nc", "layer", "grad", "od", "pair", "ip", "udder", "url", "ard", "adder", "nn", "direction"]}}
{"project": "qemu", "commit_id": "096685fc2a955ea17d5363ab452e301be2b43873", "target": 1, "func": "static uint64_t omap2_inth_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    struct omap_intr_handler_s *s = (struct omap_intr_handler_s *) opaque;\n\n    int offset = addr;\n\n    int bank_no, line_no;\n\n    struct omap_intr_handler_bank_s *bank = NULL;\n\n\n\n    if ((offset & 0xf80) == 0x80) {\n\n        bank_no = (offset & 0x60) >> 5;\n\n        if (bank_no < s->nbanks) {\n\n            offset &= ~0x60;\n\n            bank = &s->bank[bank_no];\n\n\n\n\n        }\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* INTC_REVISION */\n\n        return s->revision;\n\n\n\n    case 0x10:\t/* INTC_SYSCONFIG */\n\n        return (s->autoidle >> 2) & 1;\n\n\n\n    case 0x14:\t/* INTC_SYSSTATUS */\n\n        return 1;\t\t\t\t\t\t/* RESETDONE */\n\n\n\n    case 0x40:\t/* INTC_SIR_IRQ */\n\n        return s->sir_intr[0];\n\n\n\n    case 0x44:\t/* INTC_SIR_FIQ */\n\n        return s->sir_intr[1];\n\n\n\n    case 0x48:\t/* INTC_CONTROL */\n\n        return (!s->mask) << 2;\t\t\t\t\t/* GLOBALMASK */\n\n\n\n    case 0x4c:\t/* INTC_PROTECTION */\n\n\n\n\n    case 0x50:\t/* INTC_IDLE */\n\n        return s->autoidle & 3;\n\n\n\n    /* Per-bank registers */\n\n    case 0x80:\t/* INTC_ITR */\n\n        return bank->inputs;\n\n\n\n    case 0x84:\t/* INTC_MIR */\n\n        return bank->mask;\n\n\n\n    case 0x88:\t/* INTC_MIR_CLEAR */\n\n    case 0x8c:\t/* INTC_MIR_SET */\n\n\n\n\n    case 0x90:\t/* INTC_ISR_SET */\n\n        return bank->swi;\n\n\n\n    case 0x94:\t/* INTC_ISR_CLEAR */\n\n\n\n\n    case 0x98:\t/* INTC_PENDING_IRQ */\n\n        return bank->irqs & ~bank->mask & ~bank->fiq;\n\n\n\n    case 0x9c:\t/* INTC_PENDING_FIQ */\n\n        return bank->irqs & ~bank->mask & bank->fiq;\n\n\n\n    /* Per-line registers */\n\n    case 0x100 ... 0x300:\t/* INTC_ILR */\n\n        bank_no = (offset - 0x100) >> 7;\n\n        if (bank_no > s->nbanks)\n\n            break;\n\n        bank = &s->bank[bank_no];\n\n        line_no = (offset & 0x7f) >> 2;\n\n        return (bank->priority[line_no] << 2) |\n\n                ((bank->fiq >> line_no) & 1);\n\n    }\n\n\n\n}", "idx": 17805, "substitutes": {"opaque": [" opque", "copaque", "obaques", "obaque", "OPaco", "pque", " opaco", "OPque", " opcode", "opcode", "paques", "opaco", "paque", "OPaque", "copque", "obque", "obcode", "opaques", "pcode", "copaco", "opque", " opaques"], "addr": ["point", "offset", "ocol", "Address", "data", "code", "x", "mode", "ref", "eth", "rc", "r", "align", "hop", "src", "node", "ptr", "pos", "byte", "pointer", "setup", " address", "nr", "alias", "oid", "ock", "prefix", "ad", "mid", "dr", "asm", "seq", "afi", "address", "pad", "ada", "adr", "sid", "ace", "amd", "mt", "mac", "amp", "len"], "size": ["offset", "data", "SIZE", "align", "block", "type", " bytes", "args", "ize", "length", "blocks", "address", "number", "a", "bytes", "Size", "len"], "s": ["ns", "ic", "spec", "words", "sky", "settings", "service", "ions", "ers", "ss", "als", "cs", "d", "new", "socket", "acks", "ant", "ments", "sym", "p", "ks", "h", "banks", "sets", "comments", "sa", "m", "ts", "sg", "rs", "aws", "self", "lines", "o", "sk", "su", "ing", "outs", "sc", " services", "v", "si", "S", "single", "a", "ings", "an", "ches", "ds", "f", "sv", "r", "sb", "or", "this", "l", "ins", "w", "sync", "c", "ps", "b", "sys", "your", "er", "es", "sq", "ies", "sf", "t", "rates", "services", "n", "g", "i", "ls", "ops", "fs", "xs", "is", "parser", "ed", "space", "sites", "e", "ssl", "ses", "client", "support", "http", "gs", "storage", "its", "os", "south", "server", "se", "y", "u"], "bank_no": ["codeIDno", "bank_id", "bankJstate", "rule_number", "rule_code", "code_yes", "codeIDyes", "bank_eno", "bank_count", "code_nor", "bankJno", " bank_num", "bankIDmo", "code_no", "bank_mo", "bank_num", " bank_state", "work_yes", "bank_code", "Bank_no", "bank_name", "work_number", "bankJnumber", "bankIDyes", "bank_nor", "rule_no", "rule_note", " bank_NO", "bankFid", "bankIDcount", "bank_NO", "bankFcode", "bank_yes", "Bank_id", "codeIDname", "line_count", "bankFno", "Bank_code", " bank_number", "bankJeno", "bankIDnor", "bankIDname", "bankFyes", " bank_eno", "line_name", "bank_note", "Bank_yes", "codeIDnor", "line_mo", "bank_number", "bankIDno", "bank_state", "work_no", "work_nor", "code_name"], "line_no": ["flow_num", "Line_no", "Line_number", "flow_size", "block_number", "line_size", "line_No", "block_num", "bank_name", "line_num", "line_nr", "flow_no", "bank_na", "Line_eno", "block_no", "line_na", "line_sn", "line_name", "block_nr", "bank_number", "Line_sn", "flow_No", "line_eno", "line_number"], "bank": ["ic", "spec", "bi", "issue", "shadow", "child", "sky", "comment", "service", "library", "file", "bm", "pack", "anc", "Bank", "package", "machine", "rec", "prefix", "config", "ant", "account", "p", "feature", "banks", "scan", "command", "ve", "sa", "input", "board", "plugin", "bin", "work", "ank", "name", "bridge", "acc", "query", "app", "bb", "bird", "sk", "parse", "camp", "ay", "key", "sc", "pa", "k", "parent", "table", "can", "field", "order", "an", "view", "core", "base", "cookie", "plan", "sb", "root", "block", "type", "match", "node", "model", "byte", "bid", "ca", "go", "sn", "abi", "q", "ga", "b", "ban", "rate", "project", "pay", "book", "rank", "session", "group", "record", "data", "conf", "buffer", "feed", "g", "module", "parser", "bo", "gp", "rule", "pal", "com", "support", "bn", "cache", "error", "storage", "se", "u"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_st16(TCGv val, TCGv addr, int index)\n\n{\n\n    tcg_gen_qemu_st16(val, addr, index);\n\n    dead_tmp(val);\n\n}\n", "idx": 6335, "substitutes": {"val": ["base", "pid", "play", "reg", "bin", "el", "v", "pr", "rt", "parent", "value", "rb", "x", "data", "Val", "pt", "fb", "valid", "vals", "call", "VAL", "obj", "pc", "arg", "py", "def", "arr", "aval", "func", "lib", "rx", "empty", "exec", "p", "old", "temp", "eval", "this", "prop", "fail", "gen", "rule", "sel", "var", "ind", "ref", "grad"], "addr": ["base", "address", "dr", "name", "arm", "md", "dd", "x", "ad", "holder", "offset", "attr", "adder", "obj", "arg", "align", "part", "wd", "point", "ard", "func", "pad", "rx", "str", "callback", "work", "prefix", "amp", "frame", "ptr", "pos", "pointer", "node", "amd", "adr", "ord", "ref", "src", "host", "grad", "add"], "index": ["find", "address", "name", "position", "id", "value", "x", "i", "slice", "loc", "image", "inc", "ion", "num", "offset", "call", "weight", "length", "number", "action", "point", "part", "pos", "pointer", "level", "ind", "type", "element", "Index", "ref", "diff", "end"]}}
{"project": "qemu", "commit_id": "b4f72e31b924bec2c18fe0b2a8c6462dbed9dcb2", "target": 1, "func": "static int net_connect(struct XenDevice *xendev)\n\n{\n\n    struct XenNetDev *netdev = container_of(xendev, struct XenNetDev, xendev);\n\n    int rx_copy;\n\n\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"tx-ring-ref\",\n\n                             &netdev->tx_ring_ref) == -1) {\n\n        return -1;\n\n    }\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"rx-ring-ref\",\n\n                             &netdev->rx_ring_ref) == -1) {\n\n        return 1;\n\n    }\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"event-channel\",\n\n                             &netdev->xendev.remote_port) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"request-rx-copy\", &rx_copy) == -1) {\n\n        rx_copy = 0;\n\n    }\n\n    if (rx_copy == 0) {\n\n        xen_be_printf(&netdev->xendev, 0, \"frontend doesn't support rx-copy.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\n\n                                          netdev->xendev.dom,\n\n                                          netdev->tx_ring_ref,\n\n                                          PROT_READ | PROT_WRITE);\n\n    netdev->rxs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\n\n                                          netdev->xendev.dom,\n\n                                          netdev->rx_ring_ref,\n\n                                          PROT_READ | PROT_WRITE);\n\n    if (!netdev->txs || !netdev->rxs) {\n\n        return -1;\n\n    }\n\n    BACK_RING_INIT(&netdev->tx_ring, netdev->txs, XC_PAGE_SIZE);\n\n    BACK_RING_INIT(&netdev->rx_ring, netdev->rxs, XC_PAGE_SIZE);\n\n\n\n    xen_be_bind_evtchn(&netdev->xendev);\n\n\n\n    xen_be_printf(&netdev->xendev, 1, \"ok: tx-ring-ref %d, rx-ring-ref %d, \"\n\n                  \"remote port %d, local port %d\\n\",\n\n                  netdev->tx_ring_ref, netdev->rx_ring_ref,\n\n                  netdev->xendev.remote_port, netdev->xendev.local_port);\n\n\n\n    net_tx_packets(netdev);\n\n    return 0;\n\n}\n", "idx": 5172, "substitutes": {"xendev": ["xstartow", "xendingow", "crossenderv", "xendingef", "xedgeerv", "exendec", "exendir", "rxendedever", "xenddev", "rxendev", "xendedever", "xendingdev", " xendov", " xendruction", "xendingtr", "xentdev", "longendere", "yenderv", "xndexp", " xENDrib", "tendec", "xndov", "exndore", "exnderv", "lexendstr", " xENDerv", "xendedruction", "tenddev", "xENDrib", "crossendurt", "xendsov", "xenee", "xadore", " xstartev", "exenddev", "xstarterv", "yendexp", "xenev", "xendingere", "xendedev", "yendederv", "xndow", "xtendsov", " xenderv", "xedgeev", " xstartee", "xaddev", "xenef", "xendingee", "xendingurt", "yendedel", "crossendingerv", "xendsdev", "xendef", "lexendserv", "xendingov", "xedgedev", " xENDov", "xendingev", "xestdev", "lexendsev", "exnddev", "xtendserv", " xENDev", "xendingec", "xstartov", " xenddev", "xtendev", "xendov", "xstartdev", "xendedtr", "xENDev", "xendurt", "yendel", "rxendov", "yendedexp", "xendedec", "xendserv", "tendov", "yendedir", "longendingev", "longendee", "yendev", "xendedef", "xndore", "xndir", "xenderv", "exenderv", "xtendsev", "yendir", "xendedexp", "rxendeddev", "xendexp", "xstartev", "xentov", "exendow", "tendeddev", "xedgeexp", "xendel", "rxendedev", "xtenderv", "exndov", "xestec", "exndec", "lexendev", " xendingerv", "xendore", "xendere", "xnderv", "xendsel", "xndee", "xendsef", "xenerv", " xendingruction", "tendedov", "xendever", "exndow", " xendrib", "lexendtr", "xadev", "xndever", "xendsore", "xENDerv", "yendedev", "xadov", "xendtr", "xendruction", " xendee", " xendingov", "xendedel", "lexendef", "xestir", "longendingerv", " xendingev", "xndec", "longendingere", "crossendov", "lexendsef", "xendingel", "xendedere", "xendir", "xendingruction", "crossendev", "crossendingurt", "rxendedov", "exndev", "xendederv", " xstartdev", "xendingerv", "xendedurt", "xENDov", "yendeddev", "xendsir", "xendsec", "xestev", "xendeddev", "longendev", "xendrib", "tendedec", "exendov", "rxendever", "exndir", "xentever", "xendee", "xtendsef", "xendsev", "xstartee", "xendec", "yenddev", "xndev", "xenturt", "xenterv", "exendev", "xendow", "xenruction", "exendore", "longendingee", "xtendef", "tendev", "xenrib", "xendstr", "xendedrib", "xtendov", "rxenddev", "xenere", "xendedee", "crossendingev", "xnddev", "xendingir", "xenov", "longenderv", "crossendingov", "xentev", "lexenderv", "tendedev", " xstartov", "xendedir", "xendedov"], "netdev": ["bootdevelopment", "ntdevice", "webvalid", "networkself", "tundev", "netev", "ortdev", "netapp", "mindevelopment", " netd", "natdevice", "webapp", " netapp", "netdebug", "ntself", " netengine", "natdevelopment", "webDev", "netdiff", "networkd", "fatev", "NETdev", "netblock", "webself", "bootev", "netend", "netdevelopment", "potself", " netDEV", "netpack", "webrad", "natev", "networkend", "nutdiv", "motdiv", "webdevelopment", "enDev", "natdev", "minrad", "motblock", " netbreak", "fatbreak", "fatrad", "networkdevice", "melself", "actdevice", "networkdebug", "actd", "netpub", "netbreak", "networkdiv", "endev", "fatd", "networkdev", "nutdevelopment", "natblock", "userdiv", "networkdevelopment", "weberror", "minev", "fatDEV", "ntDEV", "webdiv", "motconf", "actdiv", "ntpack", "networkver", "networkvalid", "bootvalid", "networkpub", "actdev", "portbreak", " netver", "meldev", "motdev", "networkev", "webd", "webdebug", " netrad", " neterror", "ntev", "end", "networkrad", "networkdiff", "motdevelopment", "netver", "netvalid", "natdiv", "tundiv", "ntdevelopment", "ortend", "netDev", "webdev", "netrad", "netself", "Netdev", "netdevice", "bootdev", "networkDev", " netdevice", "nutprov", "netconf", "portrad", " netblock", "networkpack", "networkflow", " netdiff", "portdev", " netdiv", "portdevice", " netpub", "meldevice", "endevice", "bootpub", "netflow", "fatdevice", "userdev", "webdevice", "fatdev", "natengine", "netprov", "nutdev", "netdiv", "Netapp", "ortdevelopment", "enprov", "networkengine", "neterror", "tunblock", " netflow", "userDEV", "networkapp", " netdevelopment", "networkbreak", " netvalid", "ntdiff", "networkconf", "webdiff", "Netdevice", "motprov", "fatdiv", "tunrad", "networkprov", "motev", "NETdiv", "mindev", "natconf", "userblock", "potdev", "ortev", "webev", "netDEV", "potev", "NETd", "networkerror", "networkblock", "bootrad", "fatblock", "webpack", "networkDEV", "netengine", "webprov", "enerror", " netself", "motend", "ntrad", "netd", "webver", "meldebug", "ntdev", "potdiff", " netev", "webblock", "webflow", "NETver"], "rx_copy": ["rr_copy", " tx_copy", "rxfCopy", "rx_repeat", "rx__cop", "rx__copy", "rx_leave", "rxfslave", "rxlogmatch", " tx_store", "rx_store", " tx_slave", "rx_left", "rx_slave", "rx_Copy", "rr_left", "rx_size", "tx_cop", "rxfcopy", "tx_size", "rx_match", "rxlogleave", "rx_cop", "rxfstore", "tx_copy", "tx_leave", "rxlogcopy", "rx__left", "rr_cop", "tx_match", "tx_repeat", " tx_Copy"]}}
{"project": "qemu", "commit_id": "a3f1afb43a09e4577571c044c48f2ba9e6e4ad06", "target": 0, "func": "static int zero_single_l2(BlockDriverState *bs, uint64_t offset,\n\n    unsigned int nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_offset;\n\n\n\n        old_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /* Update L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (old_offset & QCOW_OFLAG_COMPRESSED) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);\n\n        } else {\n\n            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        }\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nb_clusters;\n\n}\n", "idx": 19119, "substitutes": {"bs": ["ns", "ms", "ros", "bi", "ts", "lbs", "fps", "ras", "base", "ob", "las", "plugins", "ubs", "sb", "cb", "bc", "ls", "ss", "pb", "fs", "lb", "bb", "bid", "cs", "css", "gb", "bos", "ins", "bps", "obs", "outs", "ac", "BS", "iss", "abi", "bis", "bl", "vs", "bh", "ses", "fb", "js", "sync", "bas", "bits", "b", "gs", "ec", "es", "os", "bes", "banks", "us", "sa", "ds"], "offset": ["part", "data", "fp", "Offset", "base", "bit", "optional", "align", "reference", "utils", "padding", "index", "pos", "timeout", "pointer", "store", "location", "slot", "inet", "alias", "size", "seed", "initial", "reset", "prefix", "length", "start", "position", "slave", "off", "table", "address", "url", "alloc", "clock", "addr", " offsets", "len"], "nb_clusters": ["nb_blicas", "nb4clusters", "nb_ccocations", "nb_clores", "nb_clances", "nb_gluster", "nb_slores", "nb_clards", "nb_CLances", "nb_clroups", "nb4splocations", "nb_flocations", "nb_shusters", "nb_flusters", "nb_chards", "nb4splows", "nb_plusters", "nb_glicas", "nb_collows", "nb_splusters", "nb_plodes", "nb_clicas", "nb_nancers", "nb4clards", "nb_CLicas", "nb_conards", "nb_ccusters", "nb_ccards", "nb_glances", "nb_splocations", "nb_blubes", "nb_splows", "nb_clurs", "nb_chusters", "nb_clodes", "nb_clubes", "nb_shroups", "nb_plancers", "nb_shurs", "nb_nubes", "nb_nusters", "nb_CLows", "nb_cluster", "nb_bluster", "nb_glusters", "nb_slusters", "nb_clancers", "nb_conurs", "nb_conroups", "nb_clows", "nb4splards", "nb_flards", "nb4splusters", "nb_conusters", "nb4clocations", "nb_ccows", "nb_CLusters", "nb_clocations", "nb_collores", "nb_CLuster", "nb_blodes", "nb_slows", "nb4clows", "nb_collusters", "nb_shards", "nb_flows", "nb_CLores", "nb_colluster", "nb_chroups", "nb_blusters", "nb_churs", "nb_blancers", "nb_nodes", "nb_plubes", "nb_blances", "nb_splards", "nb_sluster"], "s": ["ns", "spec", "ts", "session", "t", "stats", "sv", "settings", "services", "service", "sie", "sb", "g", "sl", "ss", "ls", "is", "o", "cs", "su", "site", "bis", "e", "ssl", "ses", "sync", "js", "c", "ps", "si", "sym", "p", "S", "b", "gs", "sys", "storage", "a", "os", "state", "us", "se", "states", "server", "sa", "ds"], "l2_table": ["l2_result", "ltwo_tab", "l2_cache", "l1_body", "l2_comment", "ltwotresult", "ltwo_result", "l2__table", "l2ttab", "l2tinterface", "l2__cache", "l2_count", "l1_table", "l12_interface", "l2__body", "l2fquery", "l12_table", "l42amtable", "l2amcache", "l42amcache", "l2fresult", "l42_tab", "l42_table", "l4_list", "l2amtab", "l12ttable", "l42_module", "l12_result", "l2_tab", "ltwottab", "l2ftable", "l12tcache", "l4_result", "l42_cache", "l1_tree", "ltwo_table", "l2_interface", "l2tcache", "l2_body", "l2ttable", "l2tresult", "l2_tree", "l2amtable", "l12tinterface", "ltwo_query", "l2_query", "ltwottable", "l12tresult", "l2__tree", "l2tquery", "l1_count", "l1_cache", "l2_module", "l42amtab", "l2ammodule", "l2ftab", "l1_module", "l4_comment", "l1_chain", "l42ammodule", "l2_list", "ltwotquery", "l12_cache", "l2_chain", "l4_table", "l1_index"], "l2_index": ["l2_alias", "l2Eindex", "l1_size", "l2_lock", "l2Elock", "lto_size", "lto_action", "l2jalias", "l2Eshape", "l21Eindex", "l2_count", "ltwo_index", "l2_length", "l2_size", "l96_shape", "l2__style", "ltwojindex", "l96__shape", "l2__index", "l2__shape", "l96_index", "l21Edate", "l6_size", "l1_length", "ltwojoutput", "l6_index", "l2_style", "l6_position", "l2_output", "ltwo_output", "l96__style", "l21_lock", "l96_style", "ltwojalias", "l2_shape", "l2jindex", "l21_shape", "lto_index", "ltwojlock", "l2_action", "l2_pointer", "l1_count", "l21Elock", "ltwo_lock", "l6_pointer", "ltwo_alias", "l21Eshape", "l2joutput", "l2jlock", "l2_date", "lto_position", "l96__index", "l21_date", "l21_index", "l2Edate", "l1_index", "l2_position"], "ret": ["bit", "ref", "full", "nt", "result", "num", "run", "att", "reset", "id", "fit", "rev", "hard", "pat", "res", "mt", "conn", "len", "part", "j", "pub", "rc", "fun", "fin", "arg", "art", "Ret", "bf", "pre", "cat", " Ret", "gt", "RET", "ft", "iter", "f", "base", "err", "alt", "hash", "lit", "rt", "bad", "val", "re", "back", "post", "rl", "b", "reply", "success", "db", "info", "af", "reg", "flag", "pass", "ext", "active", "def", "rets", "en", "ber", "out", "complete", "fail", "det", "bot", "_", "error"], "i": ["gi", "ti", "uri", "bi", "m", "j", "init", "info", "x", "f", "ref", "base", "ix", "ini", "qi", "r", "ai", "mi", "n", "io", "current", "ii", "ie", "iu", "di", "index", "slice", "I", "multi", "en", "zi", "out", "is", "ip", "l", "d", "val", "oi", "yi", "pi", "ui", "reset", "ci", "abi", "id", "start", "e", "v", "ni", "c", "ki", "si", "ri", "p", "xi", "b", "mu", "uli", "u", "rep", "it", "eni", "fi", "y", "li", "len"], "old_offset": [" old_auto", "old__offset", "oldapppointer", "oldacauto", "old_object", "condappobject", "cond_object", "oldacaddress", " old_Offset", "oldacaddr", "old__attribute", "old__auto", "oldaclocation", "low_Offset", "low_offset", "old_addr", "old_auto", "old_Offset", "old_location", "oldappobject", "old__location", " old_index", "condappoffset", "old_attribute", "old_index", "oldappattribute", " old_error", "oldacOffset", "low_addr", "cond_offset", "old__object", "condapppointer", "cond_attribute", "oldacoffset", "cond_pointer", "old_pointer", "old_error", "old__pointer", "condappattribute", "low_address", " old_location", "old_address", "oldappoffset"]}}
{"project": "qemu", "commit_id": "3a51dee658b9cc781acd57dd11bffbd1e402f93d", "target": 0, "func": "static void ide_identify(IDEState *s)\n\n{\n\n    uint16_t *p;\n\n    unsigned int oldsize;\n\n\n\n    memset(s->io_buffer, 0, 512);\n\n    p = (uint16_t *)s->io_buffer;\n\n    stw(p + 0, 0x0040);\n\n    stw(p + 1, s->cylinders); \n\n    stw(p + 3, s->heads);\n\n    stw(p + 4, 512 * s->sectors); /* sectors */\n\n    stw(p + 5, 512); /* sector size */\n\n    stw(p + 6, s->sectors); \n\n    stw(p + 20, 3); /* buffer type */\n\n    stw(p + 21, 512); /* cache size in sectors */\n\n    stw(p + 22, 4); /* ecc bytes */\n\n    padstr((uint8_t *)(p + 27), \"QEMU HARDDISK\", 40);\n\n#if MAX_MULT_SECTORS > 1    \n\n    stw(p + 47, MAX_MULT_SECTORS);\n\n#endif\n\n    stw(p + 48, 1); /* dword I/O */\n\n    stw(p + 49, 1 << 9); /* LBA supported, no DMA */\n\n    stw(p + 51, 0x200); /* PIO transfer cycle */\n\n    stw(p + 52, 0x200); /* DMA transfer cycle */\n\n    stw(p + 54, s->cylinders);\n\n    stw(p + 55, s->heads);\n\n    stw(p + 56, s->sectors);\n\n    oldsize = s->cylinders * s->heads * s->sectors;\n\n    stw(p + 57, oldsize);\n\n    stw(p + 58, oldsize >> 16);\n\n    if (s->mult_sectors)\n\n        stw(p + 59, 0x100 | s->mult_sectors);\n\n    stw(p + 60, s->nb_sectors);\n\n    stw(p + 61, s->nb_sectors >> 16);\n\n    stw(p + 80, (1 << 1) | (1 << 2));\n\n    stw(p + 82, (1 << 14));\n\n    stw(p + 83, (1 << 14));\n\n    stw(p + 84, (1 << 14));\n\n    stw(p + 85, (1 << 14));\n\n    stw(p + 86, 0);\n\n    stw(p + 87, (1 << 14));\n\n}\n", "idx": 7430, "substitutes": {"s": ["sf", "S", "a", "comm", "b", "data", "i", "f", "parts", "state", "d", "service", "hs", "conf", "w", "h", "aws", "sa", "g", "sym", "y", "tp", "sets", "is", "spec", "services", "its", "states", "ls", "sl", "sie", "ds", "ts", "settings", "sv", "fs", "sq", "site", "lines", "rs", "as", "ans", "ins", "sg", "sync", "ses", "ions", "j", "cs", "sis", "e", "sb", "t", "qs", "c", "os", "ssl", "r", "ps", "o", "v", "session", "words", "si", "sys", "m", "l", "xs", "side", "ns", "us", "ss", "gs", "n", "params", "es", "js"], "p": ["hp", "press", "a", "progress", "pat", "b", "x", "data", "i", "f", "pi", "mp", "d", "pop", "per", "fp", "vp", "sp", "proc", "g", "y", "page", "tp", "current", "pb", "cp", "P", "wp", "pe", "ap", "at", "it", "port", "jp", "z", "ip", "pl", "patch", "er", "bp", "pro", "pa", "tmp", "po", "pp", "op", "or", "lp", "post", "j", "pc", "ph", "np", "u", "e", "dp", "point", "t", "k", "c", "api", "r", "ps", "o", "v", "pr", "prev", "pre", "up", "m", "l", "pg", "q", "part", "n", "pointer", "br"], "oldsize": ["olderweight", " oldSize", "OLDSize", "lowsmall", " oldweight", "lowloc", "oldaddress", "oldsmall", " oldsmall", "oldscale", "OLDsize", "prevscale", "prevSIZE", "lowaddress", " oldaddress", "lowsize", "oldloc", "oldweight", " oldscale", "oldSIZE", "olderaddress", "OldSize", " oldSIZE", " oldloc", "OLDscale", "OLDsmall", "OLDloc", "OLDaddress", "Oldsmall", "Oldsize", "OLDweight", "OLDSIZE", "oldersmall", "oldersize", "prevsize", "prevshape", "oldshape", "Oldaddress", "oldSize", "OLDshape", " oldshape"]}}
{"project": "qemu", "commit_id": "68931a4082812f56657b39168e815c48f0ab0a8c", "target": 0, "func": "static void xtensa_kc705_init(MachineState *machine)\n\n{\n\n    static const LxBoardDesc kc705_board = {\n\n        .flash_base = 0xf0000000,\n\n        .flash_size = 0x08000000,\n\n        .flash_boot_base = 0x06000000,\n\n        .flash_sector_size = 0x20000,\n\n        .sram_size = 0x2000000,\n\n    };\n\n    lx_init(&kc705_board, machine);\n\n}\n", "idx": 17240, "substitutes": {"machine": ["process", "m", "instance", "data", "mode", "base", "image", "net", "engine", "service", "M", "loader", "node", "mc", "manager", "model", "computer", "controller", "vm", "link", "database", "mobile", "mount", "parent", "device", "cache", "interface", "monitor", "Machine", "agent", "connection", "state", "mac", "server", "port", "motion"]}}
{"project": "FFmpeg", "commit_id": "02591641f88097aec2a573f0ae384c8b87bcfe3b", "target": 1, "func": "static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)\n\n{\n\n    int sum, i, j;\n\n    int coeffs[pred_order];\n\n\n\n    for (i=0; i<pred_order; i++)\n\n        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);\n\n\n\n    for (i=0; i < s->blocksize; i++) {\n\n        sum = s->lpcqoffset;\n\n        for (j=0; j<pred_order; j++)\n\n            sum += coeffs[j] * s->decoded[channel][i-j-1];\n\n        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);\n\n    }\n\n}\n", "idx": 22003, "substitutes": {"s": ["sb", "e", "sym", "qs", "es", "fs", "g", "ses", "xs", "d", "sets", "site", "ks", "l", "ds", "services", "f", "sys", "t", "u", "m", "args", "ssl", "os", "ts", "p", "cs", "o", "context", "sync", "is", "ss", "ls", "sg", "c", "ctx", "js", "self", "spec", "settings", "si", "a", "b", "service", "n", "S", "ns", "states", "session", "sf", "side", "ps", "gs", "v", "conf", "server", "su", "sq", "gb"], "channel": ["course", "col", "fc", "name", "phase", "row", "sch", "config", "scale", "category", "prot", "character", "chan", "mode", "cm", "queue", "connection", "uri", "column", "pixel", "path", "section", "nc", "axis", "cat", "Channel", "version", "component", "unit", "code", "context", "network", "c", "cb", "sector", "frame", "source", "byte", "sc", "ch", "wan", "core", "qa", "chron", "range", "gap", "block", "server", "base", "video", "type"], "residual_size": ["residinal_len", "residinal_count", "residUAL_size", "residual_count", "residual1count", "residual1len", "residual1size", "residual_len", "residUAL_scale", "residual_name", "residual_scale", "residinal_size", "residUAL_name"], "pred_order": ["predsorders", " pred_size", " pred_row", "orig_orig", "pred_size", "pred67orig", "pred67order", " pred_orig", " pred_asc", "orig_order", "predingorder", "orig_size", "predingORD", "pred_orig", "pred_asc", "predsORD", " pred_ord", " pred_orders", "pred_ORD", "predingord", "predsord", "pred_row", "pred_ord", "predingorders", " pred_ORD", "predsorder", "pred67asc", "orig_orders", "pred67size", "pred_orders"], "sum": ["sim", "summary", "e", "ul", "sk", "scale", "Sum", "g", "cost", "gram", "val", "av", "average", "su", "style", "sign", "weight", "f", "offset", "fat", "u", "info", "used", "fee", "size", "use", "p", "mean", "diff", "us", "am", "cum", "out", "num", "add", "beta", "si", "sh", "pass", "cal", "b", "sub", "value", "hash", "ass", "vol", "n", "min", "total", "loss", "v", "alpha", "mix", "up", "user", "all", "ge", "l", "um", "max", "count"], "i": ["io", "ami", "ix", "e", "ik", "ie", "fi", "qi", "start", "ind", "ri", "ui", "eni", "pi", "ki", "gi", "d", "uri", "I", "f", "ci", "y", "u", "oi", "ini", "m", "it", "adi", "p", "ip", "id", "o", "bi", "is", "mi", "c", "index", "si", "a", "ii", "b", "ji", "n", "iu", "ai", "xi", "ei", "di", "z", "v", "multi", "li", "h", "api", "im", "l", "x", "zi", "k", "ni", "ori"], "j": ["ja", "jit", "je", "oj", "e", "ix", "jl", "ie", "syn", "qi", "jp", "adj", "g", "key", "d", "f", "ci", "jj", "y", "r", "u", "m", "it", "p", "job", "o", "ani", "js", "aj", "index", "c", "fr", "si", "J", "ch", "ii", "b", "ji", "ij", "n", "jc", "z", "v", "li", "h", "jo", "l", "x", "k"], "coeffs": ["coeffd", "coEFFs", "coeffi", "coffes", "coefficientss", "coffs", " coefments", "coffe", "coEFFp", "coefficientsi", "cocoste", "coefficientsp", " coffs", "coefficientse", "coefficients", " coffe", "coefments", "coefficientses", "coeffe", "coffi", " coeffe", "coefficientsd", "coffd", "coefficientsments", " coeffments", "coefp", " coffes", "coeffes", " coffp", " coeffd", "coefficientes", " coeffi", " coefs", " coefp", "cocosti", "cocostes", "coefficientp", " coeffes", " coeffp", "coEFFi", " coffd", "coeffments", "coefi", "cocosts", "coefs", "coefficientd", "coEFFments", "coeffp", " coefi", "coffp", " coffi"]}}
{"project": "FFmpeg", "commit_id": "6a99310fce49f51773ab7d8ffa4f4748bbf58db9", "target": 1, "func": "static int decode_channel_residues(WmallDecodeCtx *s, int ch, int tile_size)\n\n{\n\n    int i = 0;\n\n    unsigned int ave_mean;\n\n    s->transient[ch] = get_bits1(&s->gb);\n\n    if (s->transient[ch]) {\n\n        s->transient_pos[ch] = get_bits(&s->gb, av_log2(tile_size));\n\n        if (s->transient_pos[ch])\n\n            s->transient[ch] = 0;\n\n        s->channel[ch].transient_counter =\n\n            FFMAX(s->channel[ch].transient_counter, s->samples_per_frame / 2);\n\n    } else if (s->channel[ch].transient_counter)\n\n        s->transient[ch] = 1;\n\n\n\n    if (s->seekable_tile) {\n\n        ave_mean = get_bits(&s->gb, s->bits_per_sample);\n\n        s->ave_sum[ch] = ave_mean << (s->movave_scaling + 1);\n\n    }\n\n\n\n    if (s->seekable_tile) {\n\n        if (s->do_inter_ch_decorr)\n\n            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample + 1);\n\n        else\n\n            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample);\n\n        i++;\n\n    }\n\n    for (; i < tile_size; i++) {\n\n        int quo = 0, rem, rem_bits, residue;\n\n        while(get_bits1(&s->gb)) {\n\n            quo++;\n\n            if (get_bits_left(&s->gb) <= 0)\n\n                return -1;\n\n        }\n\n        if (quo >= 32)\n\n            quo += get_bits_long(&s->gb, get_bits(&s->gb, 5) + 1);\n\n\n\n        ave_mean = (s->ave_sum[ch] + (1 << s->movave_scaling)) >> (s->movave_scaling + 1);\n\n        if (ave_mean <= 1)\n\n            residue = quo;\n\n        else {\n\n            rem_bits = av_ceil_log2(ave_mean);\n\n            rem      = rem_bits ? get_bits(&s->gb, rem_bits) : 0;\n\n            residue  = (quo << rem_bits) + rem;\n\n        }\n\n\n\n        s->ave_sum[ch] = residue + s->ave_sum[ch] -\n\n                         (s->ave_sum[ch] >> s->movave_scaling);\n\n\n\n        if (residue & 1)\n\n            residue = -(residue >> 1) - 1;\n\n        else\n\n            residue = residue >> 1;\n\n        s->channel_residues[ch][i] = residue;\n\n    }\n\n\n\n    return 0;\n\n\n\n}\n", "idx": 12095, "substitutes": {"s": ["l", "session", "is", "its", "m", "http", "t", "gs", "parts", "set", "v", "full", "ns", "details", "spec", "has", "self", "settings", "sg", "ds", "n", "si", "sites", "sf", "w", "b", "c", "e", "se", "sq", "us", "f", "sym", "sets", "es", "sup", "as", "u", "this", "rates", "sim", "fs", "su", "ps", "site", "ss", "ks", "sv", "g", "features", "stats", "ops", "d", "ys", "ls", "os", "cs", "o", "sync", "sb", "sys", "a", "ssl", "vs", "conf", "ts", "ims", "service", "p", "server", "qs", "ins", "xs", "js", "rs", "aws", "S", "states", "services", "ches", "ms", "less", "h", "ses", "uns"], "ch": ["l", "channel", "img", "arch", "ach", "ich", "ver", "cb", "CH", "sk", "code", "v", "chart", "ce", "cher", "cur", " chunk", "Ch", "change", "form", "ech", "ht", "fr", "chip", "b", "gr", "c", "chu", "work", "chn", "cf", "cho", "f", "j", "th", "cha", "che", "sch", "cl", "col", "cel", "cell", "chan", "sh", "g", "ph", "conn", "cp", "och", "coll", "zh", "bh", "chi", "cat", "vc", "br", "conf", "chrom", "p", "gh", "q", "cht", "chy", "cham", "ches", "cor", "h", "cm", "ci", "y", "cy"], "tile_size": ["chip_length", "component64scale", "component64sized", "tile6count", "layer_count", "tile_count", "tile_sized", "component_length", "component64length", "tile6scale", "component_scale", "tile64scale", "component_size", "chip_scale", "tile64length", "tile1length", "tile1scale", "tile_scale", "tile6size", "tile64sized", "tile6capacity", "tile_capacity", "tile1size", "component_sized", "layer_scale", "chip_size", "layer_size", "tile64size", "component64size", "tile_length", "layer_capacity"], "ave_mean": ["ve_size", "aveXmark", "avethemal", "save_mean", "ave__sum", "ave67mal", "ave67average", "av_mean", "aves_average", "ave_average", "ve_mean", "aves_mean", "aveXaverage", "ave\u00b7mid", "ave__average", "ave_size", "ave_mark", "av_sum", "aveXmal", "ave\u00b7mean", "ve_sum", "avethemean", "aving_sum", "ave_mid", "ve_average", "ave__mean", "ave_mal", "aves_mal", "ave67sum", "ave_sum", "av_average", "ave2mean", "ave\u00b7average", "save_sum", "aving_average", "save_mid", "aving_mal", "ave2sum", "ave2size", "avethemark", "aveXmean", "av__mean", "ave\u00b7sum", "av__average", "ave67mean", "save_average", "ave2average", "aving_mean", "aves_mark", "ave__mal", "av__sum", "avetheaverage", "av__mal", "av_mal"], "i": ["ui", "di", "it", "si", "zi", "xi", "ini", "c", "ji", "p", "uri", "yi", "mini", "ie", "j", "ai", "o", "multi", "slice", "wei", "ind", "ti", "phi", "gi", "mi", "chi", "abi", "qi", "im", "pi", "bi", "ii", "uni", "u", "I", "li", "ip", "ci", "ori", "io", "ni", "ski", "ri", "fi", "iu", "ki"], "rem": ["original", "temp", "prom", "rub", "dem", "rec", "ref", "pri", "reg", "rom", "res", "keep", "remote", "REM", "pull", "orig", "re", "comm", "cm", "change", "extra", "ret", "br", "rm", "pop", "ex"], "rem_bits": ["rem_runs", "rem__bits", "rem_s", "rem_\n", "rem__runs", "rem_locks", "rem_bytes", " rem_s", "rem__locks", " rem_locks", "rem__bytes", " rem_runs", " rem_bytes", " rem_\n"], "residue": ["resinUE", "resigUE", "residUE", "resyue", "residuum", "respicience", "residsuer", "resigance", " residsue", " residience", "Residance", "resyues", "resigue", "residsience", "resyience", "residuer", "Resinuum", "residsues", "residsance", "Resinance", "residsue", "ResinUE", "residsuum", "respicue", "residsUE", " residsues", " residsience", " residsuer", "resinuum", "resyuer", " residuer", "residues", "respicues", "respicuer", "ResidUE", "residance", "Resinue", "residience", "Residuum", "resinue", "resiguum", "resinance", " residues", "Residue"], "quo": ["quoi", "aquo", " qui", "qui", "queos", "Qubo", "Quow", " quoa", "queoo", "heloo", "qo", "Quo", " quoi", "aqui", "quoa", "aquoi", "cloi", "aquoo", "quow", "cloo", "quei", "queoi", " quos", "Quoid", "aquow", "Quoi", " quko", "qoa", "aquoid", "clbo", "Quoo", "quoo", "clos", "helo", " qubo", "queoid", "heloa", "helko", "qubo", " quoo", "aquos", "clo", "queow", "quoid", "quebo", "quko", "quos", "qko", "qoo", "aqubo", "queo"]}}
{"project": "FFmpeg", "commit_id": "cbbb2067341d7c2d98f560f81c6fb103af33a490", "target": 1, "func": "static int vdpau_frames_init(AVHWFramesContext *ctx)\n\n{\n\n    VDPAUDeviceContext *device_priv = ctx->device_ctx->internal->priv;\n\n    VDPAUFramesContext        *priv = ctx->internal->priv;\n\n\n\n    int i;\n\n\n\n    switch (ctx->sw_format) {\n\n    case AV_PIX_FMT_YUV420P: priv->chroma_type = VDP_CHROMA_TYPE_420; break;\n\n    case AV_PIX_FMT_YUV422P: priv->chroma_type = VDP_CHROMA_TYPE_422; break;\n\n    case AV_PIX_FMT_YUV444P: priv->chroma_type = VDP_CHROMA_TYPE_444; break;\n\n    default:\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported data layout: %s\\n\",\n\n               av_get_pix_fmt_name(ctx->sw_format));\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(vdpau_pix_fmts); i++) {\n\n        if (vdpau_pix_fmts[i].chroma_type == priv->chroma_type) {\n\n            priv->chroma_idx  = i;\n\n            priv->pix_fmts    = device_priv->pix_fmts[i];\n\n            priv->nb_pix_fmts = device_priv->nb_pix_fmts[i];\n\n            break;\n\n        }\n\n    }\n\n    if (!priv->pix_fmts) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported chroma type: %d\\n\", priv->chroma_type);\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (!ctx->pool) {\n\n        ctx->internal->pool_internal = av_buffer_pool_init2(sizeof(VdpVideoSurface), ctx,\n\n                                                            vdpau_pool_alloc, NULL);\n\n        if (!ctx->internal->pool_internal)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    priv->get_data = device_priv->get_data;\n\n    priv->put_data = device_priv->put_data;\n\n\n\n    return 0;\n\n}\n", "idx": 8217, "substitutes": {"ctx": ["parent", "cdn", "mac", "conf", "co", "cam", "context", "cmp", "cci", "Context", "media", "cca", "conn", "tc", "cz", "auc", "sci", "c", "ct", "cp", "config", "cu", "qa", "cb", "cli", "cf", "cn", "wcs", "act", "loc", "coll", "hw", "cc", "bc", "cs", "ctrl", "cv", "ck", "ce", "sync", "cas", "voc", "conv", "ga", "tx", "acl", "pc", "xc", "kw", "cms", "concept", "nc", "gc", "cm", "ca", "ocr", "client", "ci", " context", "sys", "vc", "anc", "cmd", "crit", "pkg", "lc", "cus", "kb", "sc", "exec"], "device_priv": ["devicealpriv", " device_private", "deviceCpriv", " device_public", "device_private", "device_dat", "deviceingpriv", "deviceingpublic", "deviceJprivate", "device_size", "devicePpriv", " device_size", "device_pub", "deviceJpriv", " device_pub", "devicePpub", "deviceCpublic", "device_riv", "devicealpub", "deviceingpub", "device_public", "package_cert", " device_dat", "devicePprivate", "device_data", "deviceingriv", "deviceCprivate", " device_access", "deviceCaccess", "deviceJcert", "devicePdata", "package_private", "device_cert", "deviceJneg", "devicealsize", " device_riv", "package_priv", " device_data", "device_access", "device_neg", "devicealdat", "package_neg"], "priv": ["por", "tr", "access", "auth", "rw", "org", "pred", "vt", "config", "rib", "pb", "cb", "attr", "txt", "sk", "fam", "state", "err", "prep", "ca", "buff", "ocr", "ee", "rate", "prem", "gr", "pro", "or", "prop", "Priv", "voc", "ty", "storage", "impl", "aud", "ch", "anc", "fee", "exec", "prof", "conn", "usa", "temp", "consumer", "public", "cer", "stat", "cp", "data", "pri", "util", "gb", "mini", "ptr", "riv", "coll", "cs", "progress", "alloc", "rc", "sta", "req", "neg", "tx", "pi", "kw", "allow", "dev", "cache", "vc", "uc", "ki", "conf", "comment", "info", "auc", "p", "reader", "private", "sec", "pub", "cert", "inner", "raf", "cfg", "client", "soc", "ci", "api", "fac", "proc", "roc", "typ", "cy"], "i": ["count", "oi", "diff", "l", "hi", "ui", "di", "it", "start", "n", "si", "in", "zi", "adi", "id", "m", "xi", "info", "temp", "k", "t", "ini", "x", "b", "d", "c", "ji", "s", "block", "uri", "p", "e", "yi", "cli", "mu", "esi", "f", "ie", "j", "code", "ai", "o", "multi", "index", "slice", "v", "gi", "ti", "ind", "mi", "phi", "chi", "qi", "pi", "bi", "ii", "idi", "u", "type", "I", "li", "ip", "ci", "api", "io", "lc", "y", "ri", "fi", "iu"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,\n\n                                            target_phys_addr_t base,\n\n                                            qemu_irq txirq, qemu_irq rxirq,\n\n                                            qemu_irq *dma, omap_clk clk)\n\n{\n\n    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)\n\n            g_malloc0(sizeof(struct omap_mcbsp_s));\n\n\n\n    s->txirq = txirq;\n\n    s->rxirq = rxirq;\n\n    s->txdrq = dma[0];\n\n    s->rxdrq = dma[1];\n\n    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);\n\n    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);\n\n    omap_mcbsp_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, \"omap-mcbsp\", 0x800);\n\n    memory_region_add_subregion(system_memory, base, &s->iomem);\n\n\n\n    return s;\n\n}\n", "idx": 27311, "substitutes": {"system_memory": [" system_network", "module_memory", " system_storage", "system_connection", "system_storage", "module_connection", "module_image", "system_image", "system_media", " system_media", "module_network", "system_network"], "base": ["byte", "info", "b", "p", "bas", "server", "name", "c", "i", "unk", "ix", "buffer", "data", "bf", "gb", "address", "us", "ada", "prefix", "bro", "end", "u", "mx", "is", "e", "du", "ba", "work", "padding", "la", "bi", "Base", "ape", "scale", "weak", "au", "f", "fs", "ip", "net", "null", "be", "full", "root", "r", "core", "ace", "pc", "area"], "txirq": ["txiraqu", "rxpirk", "txpirq", "txidp", "txigrqu", "rxirqu", "tyirap", "rxirp", "txigrque", "tyirq", "tyirp", "txirk", "txigrk", "txirap", "rxpirqs", "txiraq", "txirtque", "txdrk", "txidqs", "txpirk", "txirqu", "txirtq", "txidque", "txdrque", "txpirqu", "txirce", "rxpirp", "txpirque", "rxpirq", "tyirqu", "tyiraqu", "txpirce", "txirp", "tyiraq", "txpirqs", "txdrq", "txidq", "txigrq", "txdrqu", "rxpirque", "tyirace", "rxpirqu", "rxirqs", "txirque", "txirtqs", "txirtp", "txirqs", "rxirque", "txirace", "txpirp", "tyirce", "rxirk"], "rxirq": ["rxrinqs", "rxirquest", "rxierq", "rxierw", "rhirquest", "rxdrqu", "rxirisquest", "rxirqu", "rxidque", "rpmirq", "rxirw", "rxirtc", "rxirtk", "rdirtq", "rxdrque", "rdirq", "rhdrqs", "rxirisqs", "rxirtq", "rdirw", "rdirque", "rdirtw", "rpmirk", "rxdrquest", "rpmirtk", "rxidqu", "rhirq", "rdirtque", "rxrinquest", "rxidq", "rdirtc", "rhirqa", "rhirqs", "rxdrqs", "rxirtqu", "rxdrq", "rdirc", "rhdrq", "rpmirtq", "rxidk", "rhdrquest", "rxierc", "rxrinq", "rxrinqa", "rxdrw", "rxierque", "rpmirtque", "rxirc", "rxdrk", "rhdrqa", "rxirqs", "rxdrc", "rxirisq", "rxirtw", "rxirqa", "rxirtque", "rxirque", "rxdrqa", "rxirisqa", "rpmirque", "rpmirqu", "rpmirtqu", "rxirk"], "dma": ["dme", "fmas", "xdmas", "ndmas", " dwa", "pma", " dmma", "ndpa", "ndma", "dtma", "dtmas", "dmas", "dwa", "xdme", " dga", "pme", "dhwa", "dhpa", "fmma", "xdga", "dmma", " dpa", "pga", "xdma", " dme", " dmas", "pmas", "dtga", "fma", "dtmma", "ndwa", "dhma", "dpa", "dga", "dhmas", "fga"], "clk": ["plks", "mlk", "plk", "plK", " clks", "mlks", "mlw", "mlK", "clks", "clw", " clw", " clK", "clK", "plw"], "s": ["sys", "w", "z", " args", "ns", "ts", "or", "sq", " parts", "ps", "secondary", "states", "sync", "self", " shares", "u", "es", "gs", "south", "stats", "sym", "f", "service", "fs", "js", "qs", "n", "t", "status", "ves", "r", " values", "S", "p", "m", "b", "c", "x", "ing", "ds", "su", "is", "sets", "ions", "spec", "new", " is", "services", "ows", "sl", "settings", "in", "its", "side", "g", "rs", "ses", "args", "ss", "d", " returns", "conf", "sg", "izes", "e", "session", "sb", "ches", "null", "ssl", "cs", "i", "ures", "site", "o", "si", "os", "ls", "y", "a", "v", "l"]}}
{"project": "FFmpeg", "commit_id": "5ad4335c2233d5a6d9487d2d56387b7484aecded", "target": 0, "func": "void vp8_mc(VP8Context *s, int luma,\n\n            uint8_t *dst, uint8_t *src, const VP56mv *mv,\n\n            int x_off, int y_off, int block_w, int block_h,\n\n            int width, int height, int linesize,\n\n            vp8_mc_func mc_func[3][3])\n\n{\n\n    if (AV_RN32A(mv)) {\n\n        static const uint8_t idx[3][8] = {\n\n            { 0, 1, 2, 1, 2, 1, 2, 1 }, // nr. of left extra pixels,\n\n                                        // also function pointer index\n\n            { 0, 3, 5, 3, 5, 3, 5, 3 }, // nr. of extra pixels required\n\n            { 0, 2, 3, 2, 3, 2, 3, 2 }, // nr. of right extra pixels\n\n        };\n\n        int mx = (mv->x << luma)&7, mx_idx = idx[0][mx];\n\n        int my = (mv->y << luma)&7, my_idx = idx[0][my];\n\n\n\n        x_off += mv->x >> (3 - luma);\n\n        y_off += mv->y >> (3 - luma);\n\n\n\n        // edge emulation\n\n        src += y_off * linesize + x_off;\n\n        if (x_off < mx_idx || x_off >= width  - block_w - idx[2][mx] ||\n\n            y_off < my_idx || y_off >= height - block_h - idx[2][my]) {\n\n            s->dsp.emulated_edge_mc(s->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize,\n\n                                block_w + idx[1][mx], block_h + idx[1][my],\n\n                                x_off - mx_idx, y_off - my_idx, width, height);\n\n            src = s->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n        }\n\n        mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my);\n\n    } else\n\n        mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n}\n", "idx": 19538, "substitutes": {"s": ["ns", "spec", "m", "session", "sg", "stats", "t", "request", "rs", "f", "conf", "services", "sp", "service", "r", "n", "sb", "g", "sl", "ss", "ops", "fs", "self", "cs", "d", "su", "space", "site", "w", "qs", "e", "ssl", "ses", "sync", "private", "c", "js", "si", "p", "secondary", "S", "b", "http", "gs", "sys", "a", "south", "server", "sq", "sf"], "luma": ["Lama", "laea", "sluna", "sluca", "maea", "mama", " lamin", "duma", "dumo", "litaea", "laos", "lumo", "lasm", " lama", "elama", "lamin", "luna", "lituna", "maga", "maos", "luca", "plaea", "slaga", "litumen", "elta", "lama", "flasm", "lituma", "muca", "fluma", "muma", " laga", " luca", "plama", "litaos", "lcasm", "duna", "sluma", "lcama", " lumen", "lta", "litumo", " lumo", "dumen", "plaos", "lumen", " lta", "eluma", "Luca", "lcuma", "lcamin", "flamin", "pluma", "litama", "Luma", "Lta", " luna", "muna", "eluca", " lasm", "laga", "flama"], "dst": ["nsc", "nsts", "dsp", "Dst", " dsp", "bst", "Dsp", "bbl", "fst", "fbl", "wsp", "bsp", "wst", "nsp", "fsc", "Dsc", "idst", " dost", "dsc", "Dsts", "idft", "idost", "wsts", " dft", "nst", " dsc", "idsc", "fsp", "fft", "dost", "bsts", " dsts", "fsts", "wbl", "dsts", "dbl", "dft", "fost"], "src": ["href", "sur", "rs", "wx", "rest", "irc", "dest", "cdn", "rc", "border", "syn", "rel", "sb", "channel", "gin", "cb", "sl", "attr", "stream", "loc", "ls", "sel", "ctx", "slice", "zx", "sec", "filename", "replace", "low", "gb", "rob", "path", "background", "rib", "use", "sn", "sub", "img", "config", "sr", "sc", "gl", "ssl", "ruby", "sync", "send", "target", "req", "rb", "tmp", "bg", "uc", "url", "lib", "rss", "sci", "seq", "http", "gz", "output", "inst", "origin", "sq", "source", "dist", "input"], "mv": [" mvp", "hvc", "pvs", "pj", "pf", "mf", "amj", "cmh", "Mj", "Mq", "hvs", "mrvc", "mvc", " mvc", "Mf", " mself", "Mself", "amf", "pvc", "mrvs", "rc", "mw", "pq", " mver", " mx", "pv", "mver", "mself", "hv", "cmx", "mc", "amq", "Mx", "hvp", "vself", "Mb", "mov", " mw", "vver", "cmver", "mq", "amv", "mj", " mvs", " mov", "pvp", "mrver", "mb", "cmv", "vov", "mx", "rb", "rw", "Mw", "mvp", "vv", " mc", "Mov", "rv", "hver", "mh", "Mc", "Mv", "mrv", " mh", " mb", "mvs", "vh", "vx"], "x_off": [" x_ff", "x_offset", "tx67offs", "tx67error", "X_off", "tx_off", " x_fail", "xPoff", "x67off", "x_ff", "x__ff", "tx_error", "x_Off", "x__online", "x_no", "y_no", "x_OFF", " x_offs", "x67offs", "x_online", "x_mode", "x_fail", "x_on", "X_on", "y_mode", "x__off", "x_error", "X_Off", " x_online", "xPno", "tx67off", " x_offset", "tx_offs", "x_offs", "xPmode", "x67error", "X_OFF", " x_OFF", "x__OFF"], "y_off": ["yPOff", "yalloff", "y_left", "y_Off", "ry_OFF", " y_obj", "yallleft", " y_OFF", "y67dead", "y67off", "y_error", "x_Off", "y_max", "yallOFF", "y67down", "yPobj", "x_OFF", "ry_offs", "ry_over", "ry_off", "my_on", " y_ON", "y_obj", "yPoff", "x_error", "y_over", "yPoffs", "y_down", "my_max", "y_offs", "x_offs", "y_ON", "y_OFF", " y_offs", " y_left", "yalloffs", "y_on", "y_dead", "y67ON", "x_left", " y_down", " y_dead", "yPleft", "my_off"], "block_w": ["blockshw", "block67tw", "blockJw", "block_b", "blockshh", "blockJh", " block_b", " block_wall", " block_v", " block_tw", "byte_w", "byte_h", "byte_wt", "blockshv", "blockJwt", "block67w", "block6w", "byte_we", "block_wt", "blocklexb", "blocklextw", "blockshwall", "block_tw", "block_wall", "block_we", "block6h", "block6wall", "block67we", "block67h", "block_v", "block67b", "block6v", "blocklexw", "blockJwe", "block67wt", "blocklexh"], "block_h": ["blockrictsh", "block1w", "block_ht", "block1bh", " block_bh", "block67h", "Block_hs", "block1m", "blockrictht", "block_hs", "block17w", "block_n", "blocklexht", "Block_n", "blockrictw", "blocklexsh", "blocklexh", "block27hs", "block27w", "block_sh", "blocklexbh", "block27n", "Block_h", "block17bh", "block_bh", "block67n", " block_height", "block17h", "blockrictbh", "blockricth", "blockrictheight", " block_sh", "block_m", " block_m", "block1h", "block17m", "block27h", "block_height", "block67hs", "block67w", " block_ht", "Block_w"], "height": ["rank", "thin", "shape", "view", "x", "wrap", "volume", "window", "gh", "block", "rh", "th", "padding", "resolution", "dim", "alpha", "upper", "han", "gap", " heights", "hold", "size", "hang", "build", "style", "dy", "w", "length", "pull", "layout", "ths", "history", "rows", "crop", "Height", "depth", "hh", "h", "row", "ty", "holes", "density", "y", "bottom"], "linesize": ["linksgment", "pagesization", "worksize", "linksIZE", "elinesIZE", "timesizing", "lesizer", "linessize", "linersize", "linersizes", "linesizer", "limitsizing", "linesizing", "timesization", "linesized", "pagessize", " lines8", "linedgment", "elinesizer", "linedizes", "insizing", " linesizing", "linersIZE", "pagesizer", "linesization", "pagesize", " lines\n", "linedize", "lesize", "timesIZE", "lineserial", "inesIZE", "insize", "linersizer", "lesization", "lines8", "linksiz", "linksization", "limitsize", "elineserial", "linksizer", "timesize", "linesIZE", "pagesIZE", "linersized", "limitsIZE", "linersgment", "elinesize", "linerssize", "pagesizing", "worksIZE", "worksizing", "line8", "lines\n", "insization", "linksized", "lesiz", "inesize", " linesizer", "pagesized", "linesizes", "lins\n", " linesization", "linkssize", " linesiz", "inesizing", "insIZE", "limitsizer", "linksizes", "line\n", "linksize", "linedizer", "worksizer", "linesgment", " linesIZE", "inesization", " lineserial", "linesiz", "linerserial", "lins8"], "mc_func": ["MC2fun", "mc_function", "pc_callback", "mc2fun", "MC_fun", "pc_function", "MC_func", "pc_func", "pc_fun", "mcallfunction", "mcallcallback", "MC2cc", "mc5unc", "mcallfunc", "mc_unc", "MC2function", "MC_unc", "MC_cc", "mc2cc", "MC_fn", "mc5fn", "mc5func", "mc_fn", "MC2func", "MC_function", "mc2func", "mc_cc", "mc_callback", "mc2function", "mc_fun", "mcallfun", "mc5cc"], "idx": ["sidw", "idxc", "Idw", "idw", "idsxes", "namexs", "idX", "namex", " idxc", "Idz", "sidy", "idsf", "namey", "IDns", "idz", "idsxc", "idy", "IDy", "idns", "idex", "idsX", "aidy", " idns", "idexes", "sidX", "aidx", "idsxs", "namexes", " idz", "Idf", "idsy", "Idx", "Idxes", "sidxc", "IDX", "idf", "sidns", "sidxs", "Idxs", " idX", "idsx", "IDz", "IDw", "IdX", "idxes", "sidx", "IDxc", "idey", "ideX", " idf", "idxs", "Idy", "Idxc", " idxs", "aidz", "aidX", " idy", "IDx", "IDxs"]}}
{"project": "FFmpeg", "commit_id": "e16e49ac90f6da9e019fdf23084cbb256d14bd9c", "target": 0, "func": "static void term_exit(void)\n\n{\n\n#ifndef __MINGW32__\n\n    tcsetattr (0, TCSANOW, &oldtty);\n\n#endif\n\n}\n", "idx": 22392, "substitutes": {}}
{"project": "qemu", "commit_id": "ee9a569ab88edd0755402aaf31ec0c69decf7756", "target": 0, "func": "void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)\n\n{\n\n    tcet->bypass = bypass;\n\n}\n", "idx": 1909, "substitutes": {"tcet": ["tgen", "tcacket", "pcet", "tcET", "tcen", " tcacket", "cuet", "tmET", "TCET", "TCable", "cuable", "tmet", "pcET", "TCet", " tcen", " tcET", "cuen", "TCen", "tgET", "pcacket", "tmen", "tget", "tcable", "tgacket", "tmable", "cuET", "pcen"], "bypass": ["samePass", "viafill", " byrupt", "BYPASS", "byread", "byPASS", "byride", "ByPass", "byfill", "Byrupt", "viapass", "byPass", "sameride", "bytepass", "samepass", " byPass", "Bypass", "ByPASS", " byread", "BYPass", "perPass", " byride", " byfill", "perread", "samePASS", "perpass", "byterupt", "BYride", "byrupt", "viaread", "BYpass", " byPASS", "perfill", "bytePass", "viaPass", "bytePASS"]}}
{"project": "FFmpeg", "commit_id": "21bffa93a6fc73e1f1859f8bc224409eaaf27658", "target": 1, "func": "static void mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s)\n\n{\n\n    AVStream       *video_st    = s->streams[0];\n\n    AVCodecParameters *video_par = s->streams[0]->codecpar;\n\n    AVCodecParameters *audio_par = s->streams[1]->codecpar;\n\n    int audio_rate = audio_par->sample_rate;\n\n    // TODO: should be avg_frame_rate\n\n    int frame_rate = ((video_st->time_base.den) * (0x10000)) / (video_st->time_base.num);\n\n    int audio_kbitrate = audio_par->bit_rate / 1000;\n\n    int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate);\n\n\n\n    avio_wb32(pb, 0x94); /* size */\n\n    ffio_wfourcc(pb, \"uuid\");\n\n    ffio_wfourcc(pb, \"PROF\");\n\n\n\n    avio_wb32(pb, 0x21d24fce); /* 96 bit UUID */\n\n    avio_wb32(pb, 0xbb88695c);\n\n    avio_wb32(pb, 0xfac9c740);\n\n\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x3);  /* 3 sections ? */\n\n\n\n    avio_wb32(pb, 0x14); /* size */\n\n    ffio_wfourcc(pb, \"FPRF\");\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n    avio_wb32(pb, 0x0);  /* ? */\n\n\n\n    avio_wb32(pb, 0x2c);  /* size */\n\n    ffio_wfourcc(pb, \"APRF\"); /* audio */\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, 0x2);   /* TrackID */\n\n    ffio_wfourcc(pb, \"mp4a\");\n\n    avio_wb32(pb, 0x20f);\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, audio_kbitrate);\n\n    avio_wb32(pb, audio_kbitrate);\n\n    avio_wb32(pb, audio_rate);\n\n    avio_wb32(pb, audio_par->channels);\n\n\n\n    avio_wb32(pb, 0x34);  /* size */\n\n    ffio_wfourcc(pb, \"VPRF\");   /* video */\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, 0x1);    /* TrackID */\n\n    if (video_par->codec_id == AV_CODEC_ID_H264) {\n\n        ffio_wfourcc(pb, \"avc1\");\n\n        avio_wb16(pb, 0x014D);\n\n        avio_wb16(pb, 0x0015);\n\n    } else {\n\n        ffio_wfourcc(pb, \"mp4v\");\n\n        avio_wb16(pb, 0x0000);\n\n        avio_wb16(pb, 0x0103);\n\n    }\n\n    avio_wb32(pb, 0x0);\n\n    avio_wb32(pb, video_kbitrate);\n\n    avio_wb32(pb, video_kbitrate);\n\n    avio_wb32(pb, frame_rate);\n\n    avio_wb32(pb, frame_rate);\n\n    avio_wb16(pb, video_par->width);\n\n    avio_wb16(pb, video_par->height);\n\n    avio_wb32(pb, 0x010001); /* ? */\n\n}\n", "idx": 3610, "substitutes": {"pb": ["ob", "pl", "fc", "np", "vp", "ctx", "bh", "lp", "pd", "ppa", "sb", "bps", "wikipedia", "bm", "lb", "cpp", "hub", "prot", "summary", "rob", "prop", "pg", "bc", "dl", "platform", "api", "blog", "py", "PB", "tp", "rb", "proc", "fp", "pid", "bf", "post", "phys", "pkg", "p", "nb", "lc", "wb", "attr", "posts", "gb", "jp", "pm", "mp", "bt", "www", "amp", "obj", "pc", "bp", "bb", "um", "fb", "cp", "plugin", "b", "uf", "bs", "wp", "dp", "wat", "typ", "db", "xb"], "s": ["sg", "js", "service", "ctx", "ss", "ops", "rs", "ts", "sa", "qs", "sb", "spec", "aws", "is", "sl", "g", "ses", "ls", "sf", "fts", "sync", "sv", "storage", "ds", "ps", "gs", "ns", "h", "l", "c", "p", "services", "e", "f", "es", "sys", "sq", "v", "b", "su", "t", "os", "ks", "bs", "hs", "fs", "si", "ssl"], "video_st": ["video_str", "audio_st", "media_st", "video_inst", "videoacst", "videoacstr", "audio_str", "audio_inst", "media_stream", "video_sta", "media_std", "media_src", "videoacsta", "audio_sta", "video_sth", "video_stream", "audio_sth", "videoacsth", "video_std", "video_src"], "video_par": ["audio_per", "video5rec", "video_per", "video_params", "video_sp", "videoJsp", "video5par", "videoJper", "document_rec", "document_param", "videoJpar", "document_par", "video_rec", "videoJparams", "audio_sp", "video5param", "video5parse", "video_parse", "video_param", "audio_params", "document_parse"], "audio_par": [" video_rec", "video_comp", "video_rec", "audio_base", " video__rec", "audioJdis", " video_base", " video_params", "audio__rec", "video_dis", "video_pc", "audioJrec", "video_params", "video_sp", "audio_rec", " video__par", "audio__par", "audio_per", "audioJsp", "audio_dis", " audio_proc", " audio_comp", "audio__params", "audio_comp", "audio_sp", "audio_proc", " audio_per", " video__base", "audioJpar", "audio_pc", " video__params", "audio__base", "audio_params"]}}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static void virtio_notify(struct subchannel_id schid)\n\n{\n\n    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);\n\n}\n", "idx": 12376, "substitutes": {"schid": ["appID", "chx", " schids", "schids", "skname", "skx", "chID", "appname", "chids", "schx", "appid", "SchID", "schname", "Schids", "appids", "skids", "skid", "chid", "Schname", " schx", "schID", "Schid", " schname", "chname"]}}
{"project": "FFmpeg", "commit_id": "066fff755a5d8edc660c010ddb08474d208eeade", "target": 0, "func": "static void vp6_parse_coeff_models(VP56Context *s)\n\n{\n\n    VP56RangeCoder *c = &s->c;\n\n    VP56Model *model = s->modelp;\n\n    int def_prob[11];\n\n    int node, cg, ctx, pos;\n\n    int ct;    /* code type */\n\n    int pt;    /* plane type (0 for Y, 1 for U or V) */\n\n\n\n    memset(def_prob, 0x80, sizeof(def_prob));\n\n\n\n    for (pt=0; pt<2; pt++)\n\n        for (node=0; node<11; node++)\n\n            if (vp56_rac_get_prob(c, vp6_dccv_pct[pt][node])) {\n\n                def_prob[node] = vp56_rac_gets_nn(c, 7);\n\n                model->coeff_dccv[pt][node] = def_prob[node];\n\n            } else if (s->framep[VP56_FRAME_CURRENT]->key_frame) {\n\n                model->coeff_dccv[pt][node] = def_prob[node];\n\n            }\n\n\n\n    if (vp56_rac_get(c)) {\n\n        for (pos=1; pos<64; pos++)\n\n            if (vp56_rac_get_prob(c, vp6_coeff_reorder_pct[pos]))\n\n                model->coeff_reorder[pos] = vp56_rac_gets(c, 4);\n\n        vp6_coeff_order_table_init(s);\n\n    }\n\n\n\n    for (cg=0; cg<2; cg++)\n\n        for (node=0; node<14; node++)\n\n            if (vp56_rac_get_prob(c, vp6_runv_pct[cg][node]))\n\n                model->coeff_runv[cg][node] = vp56_rac_gets_nn(c, 7);\n\n\n\n    for (ct=0; ct<3; ct++)\n\n        for (pt=0; pt<2; pt++)\n\n            for (cg=0; cg<6; cg++)\n\n                for (node=0; node<11; node++)\n\n                    if (vp56_rac_get_prob(c, vp6_ract_pct[ct][pt][cg][node])) {\n\n                        def_prob[node] = vp56_rac_gets_nn(c, 7);\n\n                        model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n\n                    } else if (s->framep[VP56_FRAME_CURRENT]->key_frame) {\n\n                        model->coeff_ract[pt][ct][cg][node] = def_prob[node];\n\n                    }\n\n\n\n    if (s->use_huffman) {\n\n        for (pt=0; pt<2; pt++) {\n\n            vp6_build_huff_tree(s, model->coeff_dccv[pt],\n\n                                vp6_huff_coeff_map, 12, &s->dccv_vlc[pt]);\n\n            vp6_build_huff_tree(s, model->coeff_runv[pt],\n\n                                vp6_huff_run_map, 9, &s->runv_vlc[pt]);\n\n            for (ct=0; ct<3; ct++)\n\n                for (cg = 0; cg < 6; cg++)\n\n                    vp6_build_huff_tree(s, model->coeff_ract[pt][ct][cg],\n\n                                        vp6_huff_coeff_map, 12,\n\n                                        &s->ract_vlc[pt][ct][cg]);\n\n        }\n\n        memset(s->nb_null, 0, sizeof(s->nb_null));\n\n    } else {\n\n    /* coeff_dcct is a linear combination of coeff_dccv */\n\n    for (pt=0; pt<2; pt++)\n\n        for (ctx=0; ctx<3; ctx++)\n\n            for (node=0; node<5; node++)\n\n                model->coeff_dcct[pt][ctx][node] = av_clip(((model->coeff_dccv[pt][node] * vp6_dccv_lc[ctx][node][0] + 128) >> 8) + vp6_dccv_lc[ctx][node][1], 1, 255);\n\n    }\n\n}\n", "idx": 26988, "substitutes": {"s": ["S", "space", "sc", "ses", "models", "sys", "args", "ss", "p", "m", "b", "i", "ns", "d", "se", "ts", "sq", "config", "conf", "ps", "sg", "ks", "states", "self", "su", "u", "e", "es", "set", "session", "spec", "sv", "si", "os", "sb", "services", "sec", "series", "serv", "f", "fs", "service", "js", "n", "qs", "src", "t", "a", "v", "sl", "r", "sf", "settings", "ssl", "cs", "params", "g"], "c": ["chain", "sc", "code", "cm", "k", "dc", "uc", "z", "p", "m", "b", "cat", "C", "d", "x", "ec", "config", "cus", "center", "cy", "cycle", "ch", "u", "e", "cell", "con", "cl", "ic", "vc", "ac", "controller", "cc", "ci", "cn", "cf", "mc", "roc", "cache", "channel", "com", "rc", "lc", "comp", "h", "ca", "f", "n", "cu", "t", "coll", "q", "arc", "v", "r", "nc", "l", "cs", "ce", "pc", "g"], "model": ["gu", "gui", "models", "code", "package", "body", "scope", "ml", "p", "m", "server", "Model", "engine", "image", "manager", "template", "module", "me", "data", "base", "storage", "style", "config", "conf", "member", "type", "global", "form", "instance", "util", "store", "method", "db", "cell", "message", "command", "session", "lib", "mode", "cal", "parent", "copy", "client", "record", "view", "ga", "xml", "ca", "f", "comment", "sim", "service", "mm", "bm", "coll", "core", "v", "builder", "query", "block", "document"], "def_prob": ["def_probs", "def_prof", "def_funbs", "defedprobs", "def_priber", "def_Probe", "def_Probi", "defedprobe", "def_prem", "def_cober", "defedprober", "def_Probs", "def_funb", "def_defb", "def_Prob", "def_perm", "def_prober", "def_cobs", "def_propb", "def_propbs", "def_pribe", "def_defbe", "def_proc", "def_prib", "def_cobi", "def_perf", "def_probi", "def_propp", "def_perbs", "defedcobs", "def_perb", "def_defbs", "def_cob", "defedcobe", "def_preb", "def_propf", "def_prebs", "def_prep", "def_funp", "def_Prop", "def_perbe", "def_probe", "def_propm", "def_defp", "defedcob", "defedprob", "def_prop", "defedcober", "def_funbe", "def_prebe", "def_prom", "def_prec", "def_pref", "def_Proc", "def_cobe", "def_perc", "def_pribs"], "node": ["ref", "call", "nm", "pn", "name", "card", "callback", "enc", "num", "ne", "seed", "cmd", "nd", "set", "object", "nt", "edge", "word", "coord", "hop", "note", "part", "n", "row", "core", "nc", "dn", "layer", "remote", "day", "anc", "msg", "en", "col", "live", "op", "Node", "line", "point", "cell", "path", "ko", "wd", "custom", "shape", "stage", "src", "od", "event", "block", "len", "pc", "load", "gen", "d", "no", "component", "nn", "global", "cdn", "peer", "session", "anch", "parent", "cp", "ng", "source", "nw", "na", "host", "full", "post", "location", "tree", "cod", "package", "dc", "page", "position", "image", "fn", "cur", "config", "type", "end", "id", "depth", "site", "loc", "ni", "local", "device", "slave", "child", "index", "conn", "route", "ode", "dest"], "cg": [" cgs", "ecgin", "pg", "Cgh", "acga", "ncgs", "Cgu", " cgh", "ecgen", "Cg", "lcgs", "cgn", "ngu", "ecgy", "lcgn", "acg", " cmg", "ngm", "pgm", "pgen", "ngn", "lcga", "cachegu", "cachegs", "ucgu", "lcg", " cgi", "ecgn", "Cgn", "Cgi", "ncgy", "lcgu", "Cga", "acgn", "cgin", "ucg", "cgh", " cgy", "acmg", "pga", "lcgi", "ecg", "cgs", " cgc", "pgn", "pgu", "ncgin", "ucgi", "ncg", "cgp", "rcgs", "pgp", "rcgi", "cgm", " cgm", "rcg", "cgy", "ecgs", "ucgh", "pmg", "ng", "ngc", "cmg", "nmg", " cgen", " cgn", "cga", " cga", "cgc", "acgi", "acgu", "cachega", " cgu", "acgs", "Cgs", "ecgp", "cgu", "cacheg", " cgin", "cgi", "cgen", "rcgu", "pgi", "pgc", " cgp"], "ctx": ["cm", "obj", "cca", "dc", "anc", "qa", "xc", "sq", "config", "act", "bc", "cmd", "loc", "wd", "cc", "ci", "cp", "cf", "cn", "rc", "gc", "rx", "na", "conn", "init", "nc", "tx", "ac", "gt"], "pos": ["ref", "pp", "seq", "neg", "obj", "slice", "pot", "p", "ass", "i", "position", "x", "doc", "no", "prop", "col", "type", "ps", "def", "act", "pass", "port", "op", "num", "sp", "unit", "o", "pse", "vid", "val", "axis", "loc", "l", "Pos", "pl", "offset", "slot", "ko", "parent", "nt", "os", "size", "comp", "part", "f", "po", "pr", "n", "j", "index", "coll", "ind", "block", "post", "len", "pc", "pose", "pid"], "ct": ["xx", "apt", "ht", "th", "cod", "cca", "ft", "dc", "nat", "cd", "cat", "cent", "enc", "xc", "qt", "capt", "ld", "ect", "ant", "config", "cr", "col", "act", "bc", "opt", "cont", "sth", "unit", "cmd", "cl", "lat", "vc", "val", "mt", "lit", "loc", "st", "dt", "wd", "nt", "cc", "ci", "lt", "cn", "ot", "pet", "CT", "rt", "count", "wt", "n", "post", "conn", "t", "sl", "ind", "Ct", "nc", "et", "pc", "gt", "kt"], "pt": ["ht", "thread", "ft", "pn", "pg", "px", "ld", "ept", "ps", "station", "cmd", "cl", "mt", "st", "dt", "nt", "cond", "ptr", "pet", "rect", "part", "j", "t", "et", "val", "gt", "day", "obj", "pot", "p", "qt", "text", "col", "port", "xt", "line", "point", "pit", "patch", "tp", " pts", "sl", "pc", "kt", "pp", "act", "sth", "peer", "pl", "anch", "parent", "count", "po", "host", "post", "tx", "pid", "pa", "apt", "pty", "yt", "br", "type", "platform", "td", "loc", "lt", "pm", "vert", "ot", "round", "rt", "pr", "ind", "PT"]}}
{"project": "qemu", "commit_id": "5d1abf234462d13bef3617cc2c55b6815703ddf2", "target": 0, "func": "static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev,\n\n                                  DeviceState *dev, Error **errp)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n\n    S390PCIBusDevice *pbdev;\n\n    S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev)\n\n                                           ->qbus.parent);\n\n\n\n    pbdev = &s->pbdev[PCI_SLOT(pci_dev->devfn)];\n\n\n\n    pbdev->fid = s390_pci_get_pfid(pci_dev);\n\n    pbdev->pdev = pci_dev;\n\n    pbdev->configured = true;\n\n    pbdev->fh = s390_pci_get_pfh(pci_dev);\n\n\n\n    s390_pcihost_setup_msix(pbdev);\n\n\n\n    if (dev->hotplugged) {\n\n        s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY,\n\n                                     pbdev->fh, pbdev->fid);\n\n        s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED,\n\n                                     pbdev->fh, pbdev->fid);\n\n    }\n\n}\n", "idx": 12133, "substitutes": {"hotplug_dev": ["hotplugin_def", "hotplugin_ev", "hotplug_def", "hotplug_ev", "hotplugin_device", "hotplug_device", "hotplugin_dev"], "dev": ["diff", "conf", "kind", "gu", "di", "debug", "dom", "comment", "Dev", "w", "conn", "def", "info", "die", "prom", "development", "dem", "adv", "d", "ver", "de", "data", "server", "app", "pro", "driver", "bug", "priv", "rad", "nov", "ev", "device", "v", "state", "md", "mod", "err", "user", "dc", "error", " Dev", "spec", "grad", "engine", "cmd", "DEV"], "errp": ["erp", "rrp", "errap", "rrip", " errerror", "rrerror", "errerror", "erip", " errip", "rrap", "errip", "erap", " errap", "ererror"], "pci_dev": ["pcu_server", "pci_div", "pci__dev", "pdi_mod", "pci_mod", "pcf_home", "pci_de", "pcf_device", "pcu_ev", "pciOserial", "pdi_div", "pdi_dev", "pcu_device", "pci00ev", "pci__ev", "pci_home", "pci00device", "pcf_dev", "pci00dev", "ppi_def", "pci_server", "pci_device", "pciOdev", "pci_serial", "pci__de", "ppi_de", "pciOhome", "pci_def", "pcf_serial", "ppi_device", "pcu_dev", "pcu_def", "ppi_dev", "pciOdevice", "pci__def", "pci00server", "pci_ev", "pci__device", "pdi_server", "pdi_device"], "pbdev": ["pbconf", "pcDEV", "pgdevice", "lpapp", "ebbug", "fbdiff", "pbbug", "pcdevelopment", "lbdebug", "bpconf", "pbdevice", "ebdevice", "lpdev", "PBdi", "lpcomment", "pberror", "pbdi", "pcdevice", "pcdebug", "pgcomment", "PBver", "lpdiv", "ebvar", "pgapp", "pbDEV", "wpbug", "pbdevelopment", "sbdebug", "ebdev", "pcdiv", "lpvalid", "lbdiv", "bmdevelopment", "bmdev", "sbdiv", "fbdev", "lpdebug", "cbDEV", "pbserial", "bpDEV", "PBconn", "lpdef", "labcomment", "pcdev", "sbdevice", "pbdef", "pgdevelopment", "sbdev", "pgdev", "labtest", "pbtest", "pgdef", "sbconn", "lbDEV", "pgver", "lbdata", "labvalid", "lpdata", "pcver", "lbver", "ppDEV", "bmdevice", "pbver", "pcdiff", "bpdev", "labdevice", "cbserial", "lbdiff", "fbdevelopment", "pgtest", "ppserial", "PBdiff", "lpdevelopment", "lpserial", "PBdata", "labdevelopment", "lpdiff", "pbapp", "lbconf", "PBdev", "wpvar", "lbdev", "bpdebug", "labdiff", "wpdev", "pbvalid", "pbvar", "cbdevice", "pbconn", "lbdevice", "cbdev", "lperror", "labdev", "sbdi", "PBdef", "pbdiv", "pbdata", "fbdevice", "bmerror", "lpdevice", "PBdevelopment", "fberror", "bpdi", "lbdevelopment", "lbvar", "bpdiv", "PBdevice", "lbdef", "PBdiv", "ppdevice", "pbdebug", "lbbug", "pbcomment", "pgvalid", "ppdev", "bpconn", "lpver", "pbdiff", "lptest", "PBapp", "lpDEV", "wpdevice", "pcconf"], "s": ["session", "sg", "ds", "n", "g", "start", "w", "m", "t", "b", "d", "i", "service", "c", "p", "server", "e", "sq", "f", "resource", "o", "S", "v", "sync", "south", "sl", "services", "r", "ns", "sb", "side", "params", "a", "ss", "ssl"]}}
{"project": "FFmpeg", "commit_id": "cf7d2f2d2134c0854edf2db91e7436ac2bc9874f", "target": 0, "func": "static av_cold int dnxhd_encode_init(AVCodecContext *avctx)\n\n{\n\n    DNXHDEncContext *ctx = avctx->priv_data;\n\n    int i, index, bit_depth, ret;\n\n\n\n    switch (avctx->pix_fmt) {\n\n    case AV_PIX_FMT_YUV422P:\n\n        bit_depth = 8;\n\n        break;\n\n    case AV_PIX_FMT_YUV422P10:\n\n        bit_depth = 10;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"pixel format is incompatible with DNxHD\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->cid = ff_dnxhd_find_cid(avctx, bit_depth);\n\n    if (!ctx->cid) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"video parameters incompatible with DNxHD\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    av_log(avctx, AV_LOG_DEBUG, \"cid %d\\n\", ctx->cid);\n\n\n\n    index = ff_dnxhd_get_cid_table(ctx->cid);\n\n    if (index < 0)\n\n        return index;\n\n    ctx->cid_table = &ff_dnxhd_cid_table[index];\n\n\n\n    ctx->m.avctx    = avctx;\n\n    ctx->m.mb_intra = 1;\n\n    ctx->m.h263_aic = 1;\n\n\n\n    avctx->bits_per_raw_sample = ctx->cid_table->bit_depth;\n\n\n\n    ff_blockdsp_init(&ctx->bdsp, avctx);\n\n    ff_fdctdsp_init(&ctx->m.fdsp, avctx);\n\n    ff_mpv_idct_init(&ctx->m);\n\n    ff_mpegvideoencdsp_init(&ctx->m.mpvencdsp, avctx);\n\n    ff_pixblockdsp_init(&ctx->m.pdsp, avctx);\n\n    if (!ctx->m.dct_quantize)\n\n        ctx->m.dct_quantize = ff_dct_quantize_c;\n\n\n\n    if (ctx->cid_table->bit_depth == 10) {\n\n        ctx->m.dct_quantize     = dnxhd_10bit_dct_quantize;\n\n        ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;\n\n        ctx->block_width_l2     = 4;\n\n    } else {\n\n        ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;\n\n        ctx->block_width_l2     = 3;\n\n    }\n\n\n\n    if (ARCH_X86)\n\n        ff_dnxhdenc_init_x86(ctx);\n\n\n\n    ctx->m.mb_height = (avctx->height + 15) / 16;\n\n    ctx->m.mb_width  = (avctx->width  + 15) / 16;\n\n\n\n    if (avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) {\n\n        ctx->interlaced   = 1;\n\n        ctx->m.mb_height /= 2;\n\n    }\n\n\n\n    ctx->m.mb_num = ctx->m.mb_height * ctx->m.mb_width;\n\n\n\n#if FF_API_QUANT_BIAS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (ctx->intra_quant_bias == FF_DEFAULT_QUANT_BIAS &&\n\n        avctx->intra_quant_bias != FF_DEFAULT_QUANT_BIAS)\n\n        ctx->intra_quant_bias = avctx->intra_quant_bias;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    // XXX tune lbias/cbias\n\n    if ((ret = dnxhd_init_qmat(ctx, ctx->intra_quant_bias, 0)) < 0)\n\n        return ret;\n\n\n\n    /* Avid Nitris hardware decoder requires a minimum amount of padding\n\n     * in the coding unit payload */\n\n    if (ctx->nitris_compat)\n\n        ctx->min_padding = 1600;\n\n\n\n    if ((ret = dnxhd_init_vlc(ctx)) < 0)\n\n        return ret;\n\n    if ((ret = dnxhd_init_rc(ctx)) < 0)\n\n        return ret;\n\n\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size,\n\n                      ctx->m.mb_height * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs,\n\n                      ctx->m.mb_height * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits,\n\n                      ctx->m.mb_num * sizeof(uint16_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale,\n\n                      ctx->m.mb_num * sizeof(uint8_t), fail);\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (avctx->thread_count > MAX_THREADS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"too many threads\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->thread[0] = ctx;\n\n    for (i = 1; i < avctx->thread_count; i++) {\n\n        ctx->thread[i] = av_malloc(sizeof(DNXHDEncContext));\n\n        memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext));\n\n    }\n\n\n\n    return 0;\n\nfail:  // for FF_ALLOCZ_OR_GOTO\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 5539, "substitutes": {"avctx": ["avecv", " avcf", "avercontext", "abcmp", "navcontext", "aveloc", "afxc", "avcb", "afctx", "AVctl", "Avbc", "Avcmp", "AVcb", "aveca", "avkb", "navctx", "AVca", " avcontext", "avca", "AVcv", " avca", "airctx", "avcmd", "avercp", "afloc", "afcmp", "AVloc", "avcmp", "avectl", "abcontext", "avcv", "AVcmd", "avxc", "aircb", "AVcmp", "aveconn", "Avctx", "avecontext", "AVcp", "averpkg", "AVxc", "navcmd", "AVconfig", "AVcu", "AVconn", "averkb", "avbc", "avekb", "Avcu", " avxc", "vercontext", "avcu", "avconfig", "AVcontext", "averctx", "afcmd", "avecp", "afkb", "vercb", "avcontext", "afpkg", "airconn", "avloc", "AVbc", "vercv", "AVkb", "avconn", "abctx", " avcmp", "vercmd", "avctl", "AVcf", "verconn", "averctl", "avectx", "avepkg", "Avcf", "AVctx", "avcf", " avcmd", "avcp", "Avcontext", "verctx", " avctl", "aircontext", "afconn", "avpkg", " avbc", "afcontext", "afconfig", " avconn", "vercmp", "avecmp", "afcu", "navconn", "abconfig"], "ctx": ["cp", "cmp", "hw", "anc", "act", "cfg", "fw", "la", "ci", "component", "config", "nc", "data", "cus", "cca", "rc", "comp", "cat", "co", "concept", "loc", "cm", "support", "tx", "cal", "client", "conv", "media", "pc", "cc", "sci", "cs", "conf", "cli", "ck", "sc", "connection", "cam", "conn", "fn", "cmd", "wcs", "bc", "cu", "cms", "cb", "fp", "instance", "jp", "context", "prefix", "exec", "kw", "ca", "qa", "input", "msg", "kb", "utils", "c", "txt", "sq", "cf", "lc", "cn", "fc", "chan", "cv", "vc", "cas", "ctrl", "pkg", "xc", "tc"], "i": ["base", "ti", "ib", "I", "count", "di", "ci", "x", "ri", "si", "io", "info", "num", "pi", "j", "ii", "iu", "it", "ai", "e", "uri", "k", "c", "ip", "ind", "li", "ui"], "index": ["position", "check", "x", "weight", "active", "connect", "match", "len", "all", "error", "connection", "empty", "zero", "head", "page", "query", "conn", "option", "append", "id", "value", "update", "val", "list", "slice", "info", "office", "null", "ini", "search", "type", "element", "partial", "no", "end", "condition", "address", "sync", "loc", "inc", "key", "num", "action", "e", "point", "section", "out", "instance", "input", "pos", "ind", "include", "find", "cmp", "offset", "insert", "length", "fe", "part", "example", "full", "coll", "result", "inner", "Index", "date", "diff"], "bit_depth": ["bitSdepth", "bit_rate", "bit_len", " bit_deep", " bit_Depth", "bit_size", "bitalllen", "bitStable", "bit2height", " bit2Depth", "bitSdeep", " bit_roots", "bitallsource", "bin_depth", "bit32Depth", "byte_depth", "bin_deep", "bit_height", "byte_length", "bit_Depth", "bit32depth", " bit_count", " bit_size", "bit_table", "bit_roots", "bit64deep", "bit64count", "bitalldepth", "bit_dist", " bit2rate", " bit_height", "bit2depth", "bitalllength", " bit_rate", "bit_source", " bit_dist", "bit64Depth", " bit2depth", " bit2height", "byte_deep", "bin_table", "bit32height", "byte_source", "byte_dist", "bit_count", "bit64depth", "bit32rate", "bit_length", "bit2Depth", "bit2rate", "bit_deep", "byte_len"], "ret": ["abc", "gc", "row", "reg", "mem", "alt", "entry", "val", "rc", "reply", "obj", "arg", "res", "col", "arr", "feat", "rev", "result", "seq", "batch", "orig", "resp", "success", "ref", "aux", "rem"]}}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "QJSON *qjson_new(void)\n\n{\n\n    QJSON *json = QJSON(object_new(TYPE_QJSON));\n\n    return json;\n\n}\n", "idx": 18220, "substitutes": {"json": ["status", "tree", "j", "global", "fruit", "data", "obj", "feed", "result", "pack", "son", "java", "module", "current", "raw", "aj", "object", "array", "new", "build", "config", "response", "key", "xxx", "jack", "update", "javascript", "js", "temp", "parent", "xml", "output", "body", "api", "ja", "twitter", "py", "JSON", "journal", "server", "value"]}}
{"project": "qemu", "commit_id": "25d9747b6427de8253221d544b45e50888d4cef7", "target": 1, "func": "static int floppy_probe_device(const char *filename)\n\n{\n\n    int fd, ret;\n\n    int prio = 0;\n\n    struct floppy_struct fdparam;\n\n    struct stat st;\n\n\n\n    if (strstart(filename, \"/dev/fd\", NULL) &&\n\n        !strstart(filename, \"/dev/fdset/\", NULL)) {\n\n        prio = 50;\n\n    }\n\n\n\n    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);\n\n    if (fd < 0) {\n\n        goto out;\n\n    }\n\n    ret = fstat(fd, &st);\n\n    if (ret == -1 || !S_ISBLK(st.st_mode)) {\n\n        goto outc;\n\n    }\n\n\n\n    /* Attempt to detect via a floppy specific ioctl */\n\n    ret = ioctl(fd, FDGETPRM, &fdparam);\n\n    if (ret >= 0)\n\n        prio = 100;\n\n\n\noutc:\n\n    qemu_close(fd);\n\nout:\n\n    return prio;\n\n}\n", "idx": 444, "substitutes": {"filename": ["files", "name", "buffer", "named", "utf", "ppa", "txt", "binary", "tty", "folder", "fn", "wl", "buf", "fax", "lua", "fil", "nil", "Filename", "fp", "file", "sf", "ilk", "database", "sudo", "feat", "kn", "bf", "word", "l", "which", "dll", "f", "kl", "length", "wb", "STDOUT", "microsoft", "username", "il", "pty", "phrase", "prefix", "tools", "path", "socket", "FH", "whatever", "println", "directory"], "fd": ["fc", "ff", "ld", "fun", "fs", "da", "dd", "ud", "pd", "FD", "conn", "sd", "fed", "fw", "fa", "out", "d", "ad", "xd", "dl", "lf", "fl", "ln", "fn", "buf", "draft", "pipe", "fp", "file", "sf", "df", "dt", "ds", "md", "cod", "cond", "bf", "feed", "dc", "fe", "temp", "ind", "c", "fin", "f", "hd", "bd", " fid", "cd", "exec", "fat", "handler", "fx", "wd", "die", "connection", "fb", "cf", "od", "ecd", "vd", "FH", "ded", "nd", "dat", "dir", "fi", "gd", "db"], "ret": ["rot", "ort", "fun", "att", "mt", "def", "conn", "success", "out", "ct", "alt", "ry", "pet", "rets", "ben", "rf", "py", "pass", "j", "fail", "lt", "ait", "ft", "nt", "err", "rev", "cond", "reply", "status", "Ret", "feat", "bf", "dt", "result", "pret", "fin", "try", "rl", "len", "ref", "fat", "resp", "std", "art", "en", "sec", "obj", "RET", "rx", "lit", "re", "ann", "rt", "val", "reg", "pt", "let", "fi", "det", "res", "db"], "fdparam": ["draftparam", "dresource", "fpar", "FDparams", "dlresource", "fparams", "FDresource", "dParam", "fdresource", "fdpar", "dparam", "dlparam", "FDparam", "fdParam", "fdparams", "dlparams", "fparam", "dparams", "FDParam", "dlParam", "draftparams", "draftpar", "FDpar"], "st": ["stage", "ist", "src", "rest", "ss", "dd", "stat", "sd", "sb", "d", "ct", " est", "store", "spect", "St", "ste", "ft", "nt", "str", "storage", "fe", "et", "ut", "state", "put", "ST", "sc", "stab", "stream", "std", "obj", "rd", "sts", "sta", "inst", "t", "stop", "station", "ost", "td", "ast", "pt", "fi", "start", "sth", "est"]}}
{"project": "qemu", "commit_id": "42a6686b2f6199d086a58edd7731faeb2dbe7c14", "target": 0, "func": "void HELPER(v7m_msr)(CPUARMState *env, uint32_t maskreg, uint32_t val)\n\n{\n\n    /* We're passed bits [11..0] of the instruction; extract\n\n     * SYSm and the mask bits.\n\n     * Invalid combinations of SYSm and mask are UNPREDICTABLE;\n\n     * we choose to treat them as if the mask bits were valid.\n\n     * NB that the pseudocode 'mask' variable is bits [11..10],\n\n     * whereas ours is [11..8].\n\n     */\n\n    uint32_t mask = extract32(maskreg, 8, 4);\n\n    uint32_t reg = extract32(maskreg, 0, 8);\n\n\n\n    if (arm_current_el(env) == 0 && reg > 7) {\n\n        /* only xPSR sub-fields may be written by unprivileged */\n\n        return;\n\n    }\n\n\n\n    switch (reg) {\n\n    case 0 ... 7: /* xPSR sub-fields */\n\n        /* only APSR is actually writable */\n\n        if (!(reg & 4)) {\n\n            uint32_t apsrmask = 0;\n\n\n\n            if (mask & 8) {\n\n                apsrmask |= XPSR_NZCV | XPSR_Q;\n\n            }\n\n            if ((mask & 4) && arm_feature(env, ARM_FEATURE_THUMB_DSP)) {\n\n                apsrmask |= XPSR_GE;\n\n            }\n\n            xpsr_write(env, val, apsrmask);\n\n        }\n\n        break;\n\n    case 8: /* MSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->v7m.other_sp = val;\n\n        } else {\n\n            env->regs[13] = val;\n\n        }\n\n        break;\n\n    case 9: /* PSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->regs[13] = val;\n\n        } else {\n\n            env->v7m.other_sp = val;\n\n        }\n\n        break;\n\n    case 16: /* PRIMASK */\n\n        env->v7m.primask[env->v7m.secure] = val & 1;\n\n        break;\n\n    case 17: /* BASEPRI */\n\n        env->v7m.basepri[env->v7m.secure] = val & 0xff;\n\n        break;\n\n    case 18: /* BASEPRI_MAX */\n\n        val &= 0xff;\n\n        if (val != 0 && (val < env->v7m.basepri[env->v7m.secure]\n\n                         || env->v7m.basepri[env->v7m.secure] == 0)) {\n\n            env->v7m.basepri[env->v7m.secure] = val;\n\n        }\n\n        break;\n\n    case 19: /* FAULTMASK */\n\n        env->v7m.faultmask = val & 1;\n\n        break;\n\n    case 20: /* CONTROL */\n\n        /* Writing to the SPSEL bit only has an effect if we are in\n\n         * thread mode; other bits can be updated by any privileged code.\n\n         * switch_v7m_sp() deals with updating the SPSEL bit in\n\n         * env->v7m.control, so we only need update the others.\n\n         */\n\n        if (!arm_v7m_is_handler_mode(env)) {\n\n            switch_v7m_sp(env, (val & R_V7M_CONTROL_SPSEL_MASK) != 0);\n\n        }\n\n        env->v7m.control &= ~R_V7M_CONTROL_NPRIV_MASK;\n\n        env->v7m.control |= val & R_V7M_CONTROL_NPRIV_MASK;\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"Attempt to write unknown special\"\n\n                                       \" register %d\\n\", reg);\n\n        return;\n\n    }\n\n}\n", "idx": 12452, "substitutes": {"env": ["en", "esp", "oa", "ah", "event", "gear", "server", "np", "obj", "dev", "export", "c", "end", "ep", "here", "ec", "lock", "ef", "args", "context", "rev", "iv", "eu", "vm", "txt", "skin", "console", "loader", "equ", "viron", "data", "ext", "entry", "eni", "qv", "uv", "cal", "exec", "gui", "cache", "ev", "ou", "el", "iss", "erv", "edge", "queue", "po", "ea", "cv", "config", "un", "style", "init", "scope", "app", "output", "conn", "stage", "e", "enable", "exc", "engine", "nc", "site", "eng", "qt", "Environment", "state", "global", "ne", "que", "inet", "net", "ctx", "err", "enc", "eye", "code", "er", "act", "v", "energy", "dat", "shell", "esc", "org", "db", "vel", "emb", "environment", "vs", "et", "esi", "esm"], "maskreg": ["filterbar", "filterregister", "maskrun", "switchReg", "switchrun", "filterrec", "askregister", "markREG", "askreg", "flagrec", "maskblock", " maskrec", "askbar", "markblock", "flagReg", "flagrun", "maskregister", "filterreg", " maskbar", "filterblock", "switchrec", "filterREG", "askrun", "maskREG", " maskREG", "flagreg", "maskReg", "markregister", "markreg", "switchreg", "maskrec", "askrec", "askReg", "askREG", "maskbar", "askblock"], "val": ["tx", "fl", "local", "def", "pre", "eval", "x", "vol", "loc", "pol", "ind", "mem", "dev", "Value", "sol", "pl", "base", "count", "play", "serv", "end", "text", "sl", "fail", "rot", "index", "bin", "arg", "key", "lib", "ut", "data", "b", "entry", "ann", "item", "arr", "cal", "pr", "al", "reg", "el", "vals", "alt", "slot", "config", "VAL", "test", "fx", "pret", "ref", "buffer", "unit", "update", "lit", "live", "pid", "valid", "value", "mask", "fe", "Val", "sel", "pos", "bl", "it", "ret", "enc", "pal", "pt", "cond", "v", "sil", "var", "col", "p", "ee", "buf", "ol", "rule", "all", "aval", "len"]}}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                SDHCI_GET_CLASS(s)->write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17576, "substitutes": {"s": ["ns", "ms", "status", "m", "ts", "rates", "rs", "t", "stats", "f", "conf", "uns", "settings", "services", "service", "r", "n", "sie", "sb", "g", "current", "ss", "ls", "ops", "this", "fs", "self", "xs", "is", "o", "changes", "cs", "l", "d", "new", "args", "qs", "e", "ssl", "ses", "sync", "c", "ps", "js", "si", "sym", "p", "S", "b", "ks", "gs", "sys", "storage", "its", "a", "es", "os", "state", "us", "hs", "sets", "states", "sq", "parts", "south", "php", "ds", "u"], "value": ["set", "values", "status", "scale", "content", "Value", "offset", "data", "info", "text", "name", "image", "buffer", "money", "result", "current", "type", "max", "index", "timeout", "byte", "range", "store", "val", "d", "balance", "array", "flow", "w", "length", "response", "key", "start", "id", "v", "VALUE", "si", "shift", "address", "total", "fee", "u", "number", "message", "state", "end", "version", "expression"], "size": ["set", "scale", "offset", "code", "small", "data", "capacity", "SIZE", "name", "time", "from", "sized", "g", "type", "z", "six", "sec", "timeout", "ui", "style", "ci", "security", "ize", "length", "ish", "c", "unit", "si", "shift", "address", "fee", "storage", "Size", "now", "len"], "i": ["ti", "m", "bi", "j", "ji", "t", "data", "x", "f", "ix", "ini", "r", "io", "ai", "n", "mi", "z", "ie", "ii", "iu", "index", "di", "I", "multi", "zi", "is", "o", "ip", "l", "d", "oi", "pi", "ui", "ci", "length", "id", "e", "k", "v", "c", "ni", "si", "p", "b", "iv", "a", "ia", "it", "eni", "fi", "li", "u"], "data_count": ["data_size", " data_cache", " data_size", " data_length", "data_width", " data_offset", "dataacdata", " data_data", "data\u00b7current", "data\u00b7count", "data_counter", "data_current", "dataarddepth", "data\u00b7depth", "data_cache", "dataardsize", "dataardcount", "data\u00b7size", " data_width", " data_depth", "dataaccount", "dataacdepth", "data_length", " data_current", " data_counter", "dataacsize", "data_depth", "dataarddata", "data_offset", "data_data"]}}
{"project": "FFmpeg", "commit_id": "a150bad4062a29fc11b32117bc1ade38115cd95b", "target": 0, "func": "AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,\n\n                                                            int perms)\n\n{\n\n    AVFilterBufferRef *picref =\n\n        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,\n\n                                                  frame->width, frame->height,\n\n                                                  frame->format);\n\n    if (!picref)\n\n        return NULL;\n\n    avfilter_copy_frame_props(picref, frame);\n\n    return picref;\n\n}\n", "idx": 7659, "substitutes": {"frame": ["game", "base", "scene", "flow", "fr", "row", "build", "feed", "position", "el", "component", "flower", "config", "layout", "update", "object", "iframe", "data", "slice", "style", "module", "za", "image", "Frame", "draw", "window", "fb", "live", "rame", "state", "series", "fe", "property", "buffer", "e", "point", "part", "file", "fram", "motion", "view", "plane", "feat", "framework", "filename", "coll", "parse", "scale", "ground", "line", "filter", "node", "setup", "video", "model", "frames", "figure", "cf", "element", "panel", "feature"], "perms": ["PERmissions", " perm", "percs", "arm", " permm", "arms", "Perm", "arps", " perps", "perm", " percs", "Perps", "perfs", "Percs", "Perms", "perps", " perfs", "arfs", "Permm", " permissions", "permm", "Permissions", "PERcs", "PERms", "PERmm", "Perfs", "permissions"], "picref": ["fcref", "picurl", "icRef", "lcRef", "fcurl", " picbf", "icreference", "picval", " picurl", "lcreference", "picreference", "fcval", "icurl", "pcref", "fcbf", "picRef", "camref", "fcdef", "fcreference", "cambf", "pcreference", "icref", "icdef", "picdef", " picval", " picdef", "lcval", " picreference", "camRef", " picRef", "fcRef", "picbf", "pcRef", "pcdef", "lcref", "camreference"]}}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)\n\n{\n\n    QObject *token;\n\n    const char *val;\n\n\n\n    if (ap == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    assert(token && token_get_type(token) == JSON_ESCAPE);\n\n    val = token_get_value(token);\n\n\n\n    if (!strcmp(val, \"%p\")) {\n\n        return va_arg(*ap, QObject *);\n\n    } else if (!strcmp(val, \"%i\")) {\n\n        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));\n\n    } else if (!strcmp(val, \"%d\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, int)));\n\n    } else if (!strcmp(val, \"%ld\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, long)));\n\n    } else if (!strcmp(val, \"%lld\") ||\n\n               !strcmp(val, \"%I64d\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, long long)));\n\n    } else if (!strcmp(val, \"%s\")) {\n\n        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));\n\n    } else if (!strcmp(val, \"%f\")) {\n\n        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));\n\n    }\n\n    return NULL;\n\n}\n", "idx": 4217, "substitutes": {"ctxt": ["CTXT", "pttxt", "ctXT", "cfXT", "cfext", "cttxt", "CTxt", "CTtxt", "cftxt", "ptxt", "ptXT", "cfxt", "CText", "ctext", "ptext"], "ap": ["archive", "cp", "address", "hap", "bp", "ep", "al", "pa", "esp", "gap", "op", "apache", "ax", "data", "oa", "pod", "apt", "ae", "xml", "map", " sap", "apped", "AP", "attr", "snap", "aj", "arp", "aper", "av", "pac", "np", "acl", "ak", "ar", "aped", "auth", "arr", "lap", "aval", "ctx", "ape", "ab", "jp", "apper", "aps", "Ap", "p", "array", "context", "amp", "lex", "apy", "tap", "sp", "nav", "cap", "ip", " AP", "api", "tp", "apa", "ac", "ha", "app", "au", "awa", "af"], "token": ["writer", "tool", "stat", "o", "iter", "kn", "not", "annot", "parent", "note", "word", "channel", "session", "aa", "po", "quote", "object", "data", "socket", "wt", "key", "tag", "resource", "valid", "event", "offset", "child", "call", "atom", "service", "document", "tick", "number", "stop", "len", "ak", "error", "item", "target", "an", "cho", "t", "fn", "Token", "sign", "ant", "translation", "KEN", "root", "lex", "oken", "node", "rule", "tree", "type", "user", "cookie", "text", "element", "seed", "prefix"], "val": ["base", "vol", "ot", "name", "serv", "na", "v", "el", "al", "pr", "rt", "value", "pa", "x", "data", "b", "format", "elt", "op", "Val", "pt", "unit", "loc", "valid", "vals", "tx", "key", "lit", "cal", "VAL", "sl", "fl", "arg", "vale", "split", "part", "len", "ol", "aval", "lat", "ctx", "str", "p", "eval", "doc", "pos", "true", "rule", "sel", "ul", "var", "vl", "il", "label", "li", "bl", "text", "pl", "fi", "au", "ref", "pol", "cel"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_disk_realize(SCSIDevice *dev, Error **errp)\n\n{\n\n    DriveInfo *dinfo;\n\n    Error *local_err = NULL;\n\n\n\n    if (!dev->conf.bs) {\n\n        scsi_realize(dev, &local_err);\n\n        assert(local_err);\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    dinfo = drive_get_by_blockdev(dev->conf.bs);\n\n    if (dinfo->media_cd) {\n\n        scsi_cd_realize(dev, errp);\n\n    } else {\n\n        scsi_hd_realize(dev, errp);\n\n    }\n\n}\n", "idx": 886, "substitutes": {"dev": ["serial", "vol", "ow", "cam", "dn", "def", "hw", "spec", "conn", "device", "sd", "mod", "ga", "data", "development", "d", "ver", "ad", "di", "google", "priv", "prof", "de", "client", "end", "dom", "api", "Dev", "info", "bug", "err", "temp", "ch", "pub", "dc", "disk", "bus", "block", "gu", "p", "w", "self", "gd", "app", "conf", "cache", "obj", "die", "comment", "driver", "ev", "rad", "dem", "req", "var", "error", "valid", "od", "nov", "debug", "diff", "fi", "user"], "errp": ["errP", "rrfp", "erP", "Erp", "airp", "errc", "rrpc", "verP", "errpe", "errorpc", "errorpr", "airlp", "errfp", "errpc", "barlp", " errpe", "rrP", "rrr", "errorP", " errr", "errproc", "Erpc", "airpe", "airc", "verpc", "erproc", " errlp", "barr", "ErP", "resultp", "errr", "verp", "barp", "resultpe", " errpc", "errorp", "verpr", "erp", "rrproc", " errc", "Erpr", "errpr", "errorfp", "errlp", "resultc", "errorproc", "rrlp", "barpc", "resultlp", "erfp", "rrp"], "dinfo": ["ddata", " dcheck", " dbi", "dlfo", "hdinfo", "ldfo", "dlink", "bdinfo", " dInfo", "ldinf", "dcheck", "hdbi", "Dfo", "vdlink", "dllink", "dlinfo", "Dinfo", "dlcheck", "vdfo", "dldata", "DInfo", "bdfo", "vddata", " dinf", "dinf", "bddata", "hdcheck", "dbi", "ldInfo", "dlbi", "bdlink", "hdinf", "dfo", "ldinfo", " dfo", "vdinfo", "dlinf", "Dinf", "dInfo"], "local_err": ["remote_error", "localFerr", "localIPresult", "local_errors", "local_er", "localIPerr", " local_error", "localJtemp", "localJer", "remote_err", " local_er", "localJerrors", "local_str", " local_result", "remote_str", "local_result", "local_error", "local_temp", "localFerrors", "localIPerror", "localFtemp", "localJerr", " local_errors", " local_temp", "localFer"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void blk_send_response_all(struct XenBlkDev *blkdev)\n\n{\n\n    struct ioreq *ioreq;\n\n    int send_notify = 0;\n\n\n\n    while (!LIST_EMPTY(&blkdev->finished)) {\n\n        ioreq = LIST_FIRST(&blkdev->finished);\n\n\tsend_notify += blk_send_response_one(ioreq);\n\n\tioreq_release(ioreq);\n\n    }\n\n    if (send_notify)\n\n\txen_be_send_notify(&blkdev->xendev);\n\n}\n", "idx": 16542, "substitutes": {"blkdev": ["Blkprom", "BlkDev", "plkprom", "plktprom", "plktdevice", "Blckdevice", "Blkdiv", "blukprom", "BlbDev", "Blckdev", "plktev", "blbconn", "Blkdevice", "blckdiv", "blkconn", "belkdev", "blckprom", "plkev", "blokev", "blktdevice", "blckdevice", "blkdiv", "Blbconn", "Blkconn", "blokprom", "blokDev", "belkdiv", "blakdevice", "blokdiv", "belkdevice", "plkdev", "blkdevice", "blakconn", "blckdev", "blktprom", "blakdev", "plktdev", "blukdiv", "blokdevice", "blbdev", "belokdevice", "blkprom", "blkDev", "blokconn", "blbdevice", "blktdev", "blktdiv", "blbDev", "Blbdevice", "blokdev", "blukdev", "Blckdiv", "Blbdev", "blktev", "Blkdev", "blkev", "plkdevice", "Blckprom", "blukdevice", "blukev", "blakDev", "belokdev", "belokdiv"], "ioreq": ["iourc", "ioresqual", "ioresv", "ioseqs", "iniorequest", " iorequ", "iouc", "ioorquest", "inioreq", "iouq", "ioyarch", "atioryqs", "ioryqs", "iourv", "iourq", "iorestqs", "ioserq", "inioredq", "iorev", "ioryqual", "ioresq", "iorearch", " ioresq", "ioroqu", "inioreck", " iosequ", "atiorequal", "ioreqs", " ioseq", "iosel", "ioryq", "atioryqual", "inioredck", "ioredquest", "atioryq", "iniorel", " ioresquest", "ioresqs", " ioseqs", "pioserid", "atioryc", "iorestquest", " iorequest", "iosec", "iorequal", "iouqs", "ioorck", "iorequest", "iosequ", "ioredck", "ioserid", " iorec", "iorestq", "ioresc", "ioroquest", "ioryc", "ioreck", "iosev", " ioreqs", " iosequest", "ioredl", "ioseck", "iosequest", "atioreqs", "pioserarch", "iorel", "iouqual", "pioserck", "iorestqu", "ioyid", "ioreid", "inioredl", "ioriq", "inioredquest", "atiorec", "piorearch", "ioorq", "iorequ", "iorick", "iourquest", "atioreq", " ioresv", "ioorl", "pioreq", "ioresquest", "pioreck", "ioseq", "ioroq", " ioresc", "ioriid", "ioserck", "pioserq", "ioyck", "ioyq", "ioroqs", "ioserarch", "ioriarch", "ioredq", "iorec", "pioreid", " iorev"]}}
{"project": "FFmpeg", "commit_id": "c43485f70765cb488bfdf95dc783bb9b14eb1179", "target": 1, "func": "static int decode_hq_slice(AVCodecContext *avctx, void *arg)\n\n{\n\n    int i, quant, level, orientation, quant_idx;\n\n    uint8_t quants[MAX_DWT_LEVELS][4];\n\n    DiracContext *s = avctx->priv_data;\n\n    DiracSlice *slice = arg;\n\n    GetBitContext *gb = &slice->gb;\n\n\n\n    skip_bits_long(gb, 8*s->highquality.prefix_bytes);\n\n    quant_idx = get_bits(gb, 8);\n\n\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n\n    for (level = 0; level < s->wavelet_depth; level++) {\n\n        for (orientation = !!level; orientation < 4; orientation++) {\n\n            quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0);\n\n            quants[level][orientation] = quant;\n\n        }\n\n    }\n\n\n\n    /* Luma + 2 Chroma planes */\n\n    for (i = 0; i < 3; i++) {\n\n        int64_t length = s->highquality.size_scaler * get_bits(gb, 8);\n\n        int64_t bits_left = 8 * length;\n\n        int64_t bits_end = get_bits_count(gb) + bits_left;\n\n\n\n        if (bits_end >= INT_MAX) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"end too far away\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n\n            for (orientation = !!level; orientation < 4; orientation++) {\n\n                decode_subband(s, gb, quants[level][orientation], slice->slice_x, slice->slice_y, bits_end,\n\n                               &s->plane[i].band[level][orientation], NULL);\n\n            }\n\n        }\n\n        skip_bits_long(gb, bits_end - get_bits_count(gb));\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 3160, "substitutes": {"avctx": ["AVctx", "ajctx", "avecm", "awcb", "awconfig", "avectx", "Avcb", "afctx", "accontext", "afcontext", "AVcb", "abcb", "Avcontext", "acctx", "Avctx", "AVconfig", "accb", "awcontext", "ajcu", "AVctl", "abctx", "afcu", "avcb", "ajcontext", "afcm", "acctl", "avctl", "abconfig", "avconfig", "avcontext", "abcontext", "avecontext", "avcu", "awctx", "avcm", "AVcontext", "ajcm", "Avctl", "avecu"], "arg": ["argument", "call", "parser", "ig", "target", "spec", "array", "alias", "slot", "use", "cand", "Arg", "lang", "ag", "ark", "arr", "gap", "param", "pass", "enc", "args", "parse", "abc", "ang", "or", "arc", "flag", "ar", "ray", "alloc", "amp", "ay", "agi", "cell", "gen", "val", "load", "ace", "can"], "i": ["lock", "li", "gi", "ni", "ii", "zi", "chi", "pi", "ui", "oi", "mini", "d", "I", "n", "type", "di", "uni", "id", "mi", "iu", "g", "j", "m", "eni", "ri", "ti", "ini", "index", "multi", "ai", "ie", "x", "ind", "c", "p", "ip", "l", "phi", "e", "f", "u", "o", "v", "b", "ix", "qi", "depth", "uri", "ci", "io", "si", "in", "xi"], "quant": ["serial", "cost", "quiet", "total", "q", "quad", "local", "channel", "bit", "spec", "charge", "dim", "d", "requ", "cat", "pick", "id", "cur", "query", "mult", "client", "gap", "comp", "package", "component", "multipl", "frac", "secure", "util", "aud", "str", "inc", "post", "pad", "rank", "length", "draw", "patch", "text", "specific", "std", "comment", "quality", "round", "scale", "prefix", "qa", "qual", "req", "mix", "depth", "quick", "gen", "tax", "direct", "count", "volume", "qt", "complex", "diff", "qu", "integer"], "level": ["vol", "lock", "ul", "key", "url", "weight", "lvl", "field", "enc", "code", "file", "index", "child", "sc", "where", "quality", "round", "levels", "path", "wall", "limit", "pri", "flow", "pl", "unit", "ld", "name", "local", "time", "spec", "cl", "type", "id", "parent", "found", "pass", "model", "fail", "update", "inc", "step", "lc", "condition", "length", "resource", "la", "scale", "less", "count", "serial", "layer", "version", "half", "pe", "loc", "di", "loop", "year", "vel", "size", "value", "el", "Level", "old", "error", "rule", "low", "mode", "lo", "si", "stage", "cost", "letter", "ale", "fl", "wl", "coll", "sync", "style", "source", "temp", "status", "l", "block", "col", "rel", "pull", "thread", "clean", "depth", "full", "line", "day", "rol"], "orientation": ["equimation", "ortotation", "orientformation", "occupination", "rientrency", "organation", "directionution", "homity", "orientedration", "rotational", "variations", "oriento", "directionination", " orientations", "orientatio", "riention", "directionATION", "variation", " oriention", " orientruction", "designution", "conductity", " orientition", "rientoration", "conductaton", "rientraction", "directionational", "orientedination", "rientition", "designuation", "rotraction", "occupational", "location", "iterimation", "orientotation", "homization", "iteration", "ortimation", "orientity", "rientity", "orientoration", "iterotation", "equation", "directionration", "designity", "variational", "ortational", "ortriction", "conductation", "rientformation", "locimation", "occupning", "orientning", "designaton", "orientraction", " orientatio", "designrency", "orientruction", "occupration", "rotity", " orientraction", "orientition", "occupization", "rotformation", "rientration", "rientation", "orientuation", "orientution", "rientuation", "conductization", "iterational", "homation", "rientATION", "occupancy", "rototation", "variATION", "orientational", "oriention", "orientration", "equo", " orientformation", "rientruction", "variancy", "orientedization", "designization", "directionatio", "directionation", "rotation", "orientriction", "orientimation", " orientity", "designation", "ortation", "rientatio", "variution", "rientimation", "directionruction", "orientedning", "organuation", "directionion", "orientedatio", "orientaton", " orientational", "orientedriction", "orientancy", "rotimation", "organrency", "orientrency", "designational", "orientization", "occupatio", "directionition", "rientational", " orientoration", "orientations", "equration", "orientedation", "ortning", "ortization", "occupations", "orientination", "riento", "homaton", "locration", "organATION", "designATION", " orientancy", "directionoration", "occupation", "loco", "orientATION", "occupriction"], "quant_idx": ["quant_minxes", "quant2aidn", "quant_endx", "quant_pidxes", "quant_adxe", "quant_aidx", "quant__endX", "quant_aidxes", "quant2idx", "quant_fx", "quant_fxes", "quant_idxe", "quant2aidxs", "quant_idxs", "quant_pidx", "quant_dv", "quant_dx", "quant0pidx", "quant_idn", "quant_pidn", "quant_adx", "quant_pidxs", "quant_aidn", "quant2idxes", "quant_pidb", "quant_idxes", "quant_pidv", "quant0idx", "quant_fv", "quant_minxs", "quant0pidb", "quant_idX", "quant0idb", "quant__endv", "quant_idexes", "quant2idxs", "quant_idv", "quant__idX", "quant_endxe", "quant_minn", "quant_dX", "quant2idn", "quant0idxes", "quant_dxe", "quant__endx", "quant_idex", "quant0pidv", "quant_endv", "quant_adX", "quant__idxe", "quant2aidxes", "quant_idb", "quant_fb", "quant_ideb", "quant2aidx", "quant0pidxes", "quant_endX", "quant_aidxs", "quant_idev", "quant_adv", "quant__idx", "quant__endxe", "quant__idv", "quant_minx", "quant0idv"], "quants": ["quapters", "qents", "quancy", "inquantis", "quantis", "acquances", "aquapters", "requancy", "Quantis", "qancy", "inquatts", "acquant", "requents", " quantis", "aquants", "quatts", "requant", "quents", "quances", "inquants", "inquant", "aquents", "Quant", "aquant", "Quants", "qant", "requants", "acquants", " quatts", "aquances", "acquapters", "Quatts", " quapters", "qants", "aquancy", " quances"], "MAX_DWT_LEVELS": ["MAX_DWT_LELLP", "MAX_DWT_LVEL5", "MAX_DWT_LVELN", "MAX_DWT_LEvel5", "MAX_DWT_LELLS", "MAX_DWT_LVELS", "MAX_DWT_LEVEL5", "MAX_DWT_LEALLN", "MAX_DWT_LLLP", "MAX_DWT_LLL5", "MAX_DWT_LEALL5", "MAX_DWT_LELLN", "MAX_DWT_LEVELN", "MAX_DWT_LEvelP", "MAX_DWT_LEVELP", "MAX_DWT_LEvelS", "MAX_DWT_LELL5", "MAX_DWT_LVELP", "MAX_DWT_LEALLP", "MAX_DWT_LLLN", "MAX_DWT_LEvelN", "MAX_DWT_LEALLS", "MAX_DWT_LLLS"], "s": ["sg", "sa", "qs", "n", "sl", "j", "g", "ses", "ls", "sf", "storage", "self", "f", "sys", "sc", "u", "sky", "se", "fs", "parts", "sup", "spec", "sb", "aws", "sv", "utils", "p", "e", "core", "conf", "su", "site", "S", "t", "session", "serv", "os", "sci", "sym", "ssl", "cs", "ctx", "ss", "rs", "a", "data", "r", "is", "bis", "space", "m", "settings", "ds", "ps", "gs", "ns", "h", "c", "rates", "es", "si", "service", "ops", "d", "scope", "side", "params", "details", "sync", "l", "services", "sq", "b"], "slice": ["unit", "layer", "match", "parser", "sub", "np", "rice", "service", "crop", "split", "shape", "array", "pe", "dim", "ii", "sb", "zip", "image", "binary", "slot", "ge", "sl", "sample", "gate", "seed", "package", " sliced", "gm", "source", "index", "parse", "storage", "ie", "thin", "p", "diff", "sq", "sc", "range", "node", " slicing", "ring", "v", "scale", "uri", "ci", "view", "sci", "slave", "gp", "se", "edge", "Sl", "si", "ice", "game"], "gb": ["rg", "sg", "cli", "gio", "gpu", "cs", "ctx", "gram", "quad", "kb", "ga", "bo", "sb", "gc", "dim", "bm", "lb", "hub", "binary", "gy", "ui", "mb", "gh", "eb", "pg", "ge", "buff", "bc", "sl", "gz", "xy", "gate", "GB", "gin", "g", "gg", "rb", "gm", "gn", "cb", "cgi", "gem", "storage", "gam", "gs", "bf", "phy", "ged", "gold", "cd", "agg", "bg", "bb", "pc", "lib", "b", "plugin", "abb", "gen", "ci", "cfg", "kg", "gal", "gp", "gd", "db", "xb"]}}
{"project": "FFmpeg", "commit_id": "17ee7b5515cd1006a1f7ba4a9cced14f6526c1b0", "target": 0, "func": "static void print_report(AVFormatContext **output_files,\n\n                         AVOutputStream **ost_table, int nb_ostreams,\n\n                         int is_last_report)\n\n{\n\n    char buf[1024];\n\n    AVOutputStream *ost;\n\n    AVFormatContext *oc;\n\n    int64_t total_size;\n\n    AVCodecContext *enc;\n\n    int frame_number, vid, i;\n\n    double bitrate, ti1, pts;\n\n    static int64_t last_time = -1;\n\n    static int qp_histogram[52];\n\n\n\n    if (!is_last_report) {\n\n        int64_t cur_time;\n\n        /* display the report every 0.5 seconds */\n\n        cur_time = av_gettime();\n\n        if (last_time == -1) {\n\n            last_time = cur_time;\n\n            return;\n\n        }\n\n        if ((cur_time - last_time) < 500000)\n\n            return;\n\n        last_time = cur_time;\n\n    }\n\n\n\n\n\n    oc = output_files[0];\n\n\n\n    total_size = avio_size(oc->pb);\n\n    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too\n\n        total_size= avio_tell(oc->pb);\n\n\n\n    buf[0] = '\\0';\n\n    ti1 = 1e10;\n\n    vid = 0;\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        float q= -1;\n\n        ost = ost_table[i];\n\n        enc = ost->st->codec;\n\n        if(!ost->st->stream_copy && enc->coded_frame)\n\n            q= enc->coded_frame->quality/(float)FF_QP2LAMBDA;\n\n        if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"q=%2.1f \", q);\n\n        }\n\n        if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            float t = (av_gettime()-timer_start) / 1000000.0;\n\n\n\n            frame_number = ost->frame_number;\n\n            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"frame=%5d fps=%3d q=%3.1f \",\n\n                     frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);\n\n            if(is_last_report)\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"L\");\n\n            if(qp_hist){\n\n                int j;\n\n                int qp= lrintf(q);\n\n                if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram))\n\n                    qp_histogram[qp]++;\n\n                for(j=0; j<32; j++)\n\n                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"%X\", (int)lrintf(log(qp_histogram[j]+1)/log(2)));\n\n            }\n\n            if (enc->flags&CODEC_FLAG_PSNR){\n\n                int j;\n\n                double error, error_sum=0;\n\n                double scale, scale_sum=0;\n\n                char type[3]= {'Y','U','V'};\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"PSNR=\");\n\n                for(j=0; j<3; j++){\n\n                    if(is_last_report){\n\n                        error= enc->error[j];\n\n                        scale= enc->width*enc->height*255.0*255.0*frame_number;\n\n                    }else{\n\n                        error= enc->coded_frame->error[j];\n\n                        scale= enc->width*enc->height*255.0*255.0;\n\n                    }\n\n                    if(j) scale/=4;\n\n                    error_sum += error;\n\n                    scale_sum += scale;\n\n                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"%c:%2.2f \", type[j], psnr(error/scale));\n\n                }\n\n                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"*:%2.2f \", psnr(error_sum/scale_sum));\n\n            }\n\n            vid = 1;\n\n        }\n\n        /* compute min output value */\n\n        pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base);\n\n        if ((pts < ti1) && (pts > 0))\n\n            ti1 = pts;\n\n    }\n\n    if (ti1 < 0.01)\n\n        ti1 = 0.01;\n\n\n\n    if (verbose || is_last_report) {\n\n        bitrate = (double)(total_size * 8) / ti1 / 1000.0;\n\n\n\n        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),\n\n            \"size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s\",\n\n            (double)total_size / 1024, ti1, bitrate);\n\n\n\n        if (nb_frames_dup || nb_frames_drop)\n\n          snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \" dup=%d drop=%d\",\n\n                  nb_frames_dup, nb_frames_drop);\n\n\n\n        if (verbose >= 0)\n\n            fprintf(stderr, \"%s    \\r\", buf);\n\n\n\n        fflush(stderr);\n\n    }\n\n\n\n    if (is_last_report && verbose >= 0){\n\n        int64_t raw= audio_size + video_size + extra_size;\n\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\\n\",\n\n                video_size/1024.0,\n\n                audio_size/1024.0,\n\n                extra_size/1024.0,\n\n                100.0*(total_size - raw)/raw\n\n        );\n\n    }\n\n}\n", "idx": 2110, "substitutes": {"output_files": ["output_bytes", "output_frames", "input_images", " output_frames", "input_bytes", "input_files", "output_images", "outputmatimages", "output_file", "outputmatfile", "input_file", " output_file", " output_images", "outputmatfiles", "outputmatbytes"], "ost_table": ["ostalltable", "ostsbuffer", "rss_buffer", "ost_system", "ostallbuffer", "ost_file", "ostsfile", "output_list", "rss_list", "ostalllist", "ost_buffer", "oststable", "rss_table", "ost_list", "ostallsystem", "output_table", "output_buffer", "rss_system", "output_file", "ostslist"], "nb_ostreams": ["nb_odaccountlets", "nb_streames", "nb_ostaccountes", "nb_oststreamers", "nb_ostroundlets", "nb_ststreames", "nb_odaccounts", "nb_ostloges", "nb_ostraws", "nb_streamd", "nb_ostrounds", "nb_ostreamlets", "nb_ststreams", "nb_odaccountsites", "nb_ostrawers", "nb_streams", "nb_ostecs", "nb_ostreames", "nb_ostlogs", "nb_oststreamd", "nb_ostaccounts", "nb_osteclets", "nb_odreams", "nb_ostreamd", "nb_odreamsites", "nb_odreamlets", "nb_ostlogd", "nb_ostroundsites", "nb_ststreamd", "nb_osteces", "nb_ostrawes", "nb_ostaccountlets", "nb_ostlogers", "nb_ostecsites", "nb_oststreams", "nb_oststreames", "nb_ststreamers", "nb_ostaccountsites", "nb_streamers", "nb_odaccountes", "nb_ostreamers", "nb_ostreamsites", "nb_odreames", "nb_ostroundes", "nb_ostrawd"], "is_last_report": ["is_last_info", "is_full_summary", "is_full_print", "is_this_run", "is_last_time", "is_next_write", "is_lastayprint", "is_lastalinfo", "is_lastalsummary", "is_lastmreport", "is_full_info", "is_lastalprint", "is_last_run", "is_last_print", "is_this_reported", "is_full_report", "is_lastmrun", "is_next_reported", "is_last__report", "is_lastayinfo", "is_last__run", "is_lastalreport", "is_lastaysummary", "is_last_summary", "is_next_report", "is_lastmsource", "is_last_source", "is_last_reported", "is_next_time", "is_lastmreported", "is_last_write", "is_last__source", "is_this_source", "is_lastayreport", "is_last__reported", "is_this_report"], "buf": ["grab", "Buff", "queue", "txt", "lb", "aux", "pb", "cv", "vec", "btn", "f", "seq", "uf", "af", "uu", "port", "bed", "bag", "raf", "bc", "buff", "tmp", "batch", "fab", "fp", "pkg", "bus", "bd", "text", "bu", "border", "ctx", "bh", "fw", "data", "ab", "loc", "prof", "bur", "proc", "cb", "pool", "feat", "pad", "usr", "h", "Buffer", "br", "cap", "cache", "front", "cmd", "bb", "ucc", "bytes", "img", "msg", "uc", "fd", "src", "buffer", "ph", "wav", "auc", "rb", "box", "config", "bf", "wb", "bg", "fb", "b", "font", "fam", " buffer", "rc"], "ost": ["ob", "ist", "orb", "ld", "src", "roc", "host", "oper", "ott", "annot", "oop", "osi", "obo", "rob", "loc", "ct", "osta", "rog", "voc", "oid", "sl", "ocol", "op", "ood", "iol", "adr", "nt", "om", "odi", "st", "post", "opt", "OC", "et", "oss", "ocr", "iot", "org", "soc", "oster", "obj", "OST", "o", "sta", "inst", "od", "os", "omp", "omm", "ast", "oh", "ot", "obs", "est"], "oc": ["ob", "orb", "oci", "http", "ogg", "roc", "osc", "cc", "oper", "og", "loc", "co", "rec", "voc", "cur", "oid", "ocl", "op", "ocol", "toc", "output", "ac", "oo", "cot", "ok", "nt", "om", "mot", "config", "ec", "oco", "OC", "c", "ocr", "org", "soc", "obj", "o", "pc", "iv", "od", "os", "oca", "uc", "ou", "obs"], "total_size": ["last_size", "total64time", "total64speed", "total_speed", " total_speed", "total67source", " total_storage", "last_number", "totallextime", "total_time", "total_number", "total67storage", "total_grade", "total64shape", " total_capacity", " total_time", "total67time", " total_source", "total67size", "total_capacity", "totallexspeed", "total64size", "last_time", "totallexshape", "total_source", " total_grade", "total_shape", " total_shape", "totallexsize", "total_storage"], "enc": ["ob", "fc", "emb", "ctx", "act", "ext", "roc", "ant", "conn", "anc", "ens", "nec", "equ", "loc", "ct", "nc", "rec", "voc", "cur", "sl", "env", "eng", "ent", "iq", "comp", "auc", "ac", "cot", "proc", "ENC", "code", "coll", "nt", "fr", "util", "ch", "cod", "ec", "orc", "sel", "ang", "c", "et", "Enc", "sys", "exec", "obj", "vc", "en", "sec", "ssl", "hl", "lib", "cel", "iv", "ev", "inst", "od", "ic", "ew", "img", "qt", "inc", "arch", "ot", "ou", "oder"], "frame_number": ["frame_reference", " frame_reference", "frame_no", "frame_object", " frame_no", "frame_position", " frame_object", "frameidno", "frame64length", "frame_size", "frame_source", "frameIdsource", " frame_notation", "frameIdobject", "frame_notation", "frameidnumber", " frame_size", "frameIdno", "frame_resolution", "frameidsource", " frame_resolution", " frame_position", "frame64size", " frame_length", "frame_length", "frame64no", "frame64number", "frameIdnumber", "frameidobject", " frame_source", " frame_len", "frame_len"], "vid": ["dr", "vision", "verb", "version", "vp", "act", "lan", "quad", "vt", "device", "liv", "host", "sid", "pi", "ver", "di", "nc", "vert", "kind", "id", "oid", "bid", "virt", "cat", "voc", "cdn", "duration", "seed", "year", "slice", "rev", "index", "pid", "aud", "feat", "vv", "cod", "live", "dc", "ip", "cv", "vs", "vec", "vc", "win", "v", "voice", "iv", "vi", "uid", "var", "uri", "vd", "ci", "volume", "vr", "pin", "VID", "gd", "vir", "port"], "i": ["oci", "yi", "ami", "li", "gi", "ni", "ii", "zi", "chi", "isin", "pi", "ui", "oi", "I", "di", "n", "udi", "id", "mi", "it", "iu", "y", "eni", "ri", "anti", "inner", "info", "ti", "ini", "index", "pid", "ani", "multi", "ai", "ie", "ip", "l", "c", "p", "phi", "adi", "e", "hi", "x", "u", "ori", "v", "vi", "qi", "uri", "ci", "io", "fi", "si", "xi"], "bitrate": ["bytewidth", "bitsrate", "byterate", "bitswidth", "bytespeed", "bitsspeed", "bitwidth", " bitwidth", "bitspeed", " bitspeed"], "ti1": ["ta2", "tu0", "tu1", "TI2", "ti0", "taone", "si1", "ta0", "TI0", "si0", "TI1", "tu2", "si2", "tione", "ta1", "sione", "ti2", "tuone"], "pts": ["hosti", "ntsets", "ctsets", "cts", "ptps", "pti", "nts", "ntps", "ptsets", "hostps", "cti", "hostsets", "hosts", "ctps", "nti"], "qp_histogram": ["qp_memograms", "qp2Histor", "qp_Histogram", "qp_highograms", "qp_Histograms", "qp2histbar", "qp2Histograms", "qp_highbar", "qp_histograms", "qp_histbar", "qp2histograms", "qp_Histbar", "qp_memogram", "qp2Histbar", "qp_Histor", "qp_highogram", "qp2Histogram", "qp_membar", "qp_histor", "qp2histogram", "qp2histor", "qp_highor", "qp_memor"], "cur_time": ["curltimes", "curJtimes", "recentltime", "last_time", "last_name", "cur_volume", "curltime", " last_depth", "recentltimes", " last_time", "cur_ime", "curJtime", "recent_name", "recent_delay", " cur_times", " last_times", "recent_times", "cur_delay", "recent_time", "curlname", "curldelay", "curJfile", "cur_weight", "curJname", " cur_volume", " cur_weight", " cur_id", "cur_id", "last_file", " cur_ime", "recentldelay", "cur_depth", "cur_file", "cur_times", "recentlname", "last_times", "cur_name"]}}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_send_command(SDHCIState *s)\n\n{\n\n    SDRequest request;\n\n    uint8_t response[16];\n\n    int rlen;\n\n\n\n    s->errintsts = 0;\n\n    s->acmd12errsts = 0;\n\n    request.cmd = s->cmdreg >> 8;\n\n    request.arg = s->argument;\n\n    DPRINT_L1(\"sending CMD%u ARG[0x%08x]\\n\", request.cmd, request.arg);\n\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n\n\n\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n\n        if (rlen == 4) {\n\n            s->rspreg[0] = (response[0] << 24) | (response[1] << 16) |\n\n                           (response[2] << 8)  |  response[3];\n\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n\n            DPRINT_L1(\"Response: RSPREG[31..0]=0x%08x\\n\", s->rspreg[0]);\n\n        } else if (rlen == 16) {\n\n            s->rspreg[0] = (response[11] << 24) | (response[12] << 16) |\n\n                           (response[13] << 8) |  response[14];\n\n            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |\n\n                           (response[9] << 8)  |  response[10];\n\n            s->rspreg[2] = (response[3] << 24) | (response[4] << 16) |\n\n                           (response[5] << 8)  |  response[6];\n\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n\n                            response[2];\n\n            DPRINT_L1(\"Response received:\\n RSPREG[127..96]=0x%08x, RSPREG[95..\"\n\n                  \"64]=0x%08x,\\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\\n\",\n\n                  s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]);\n\n        } else {\n\n            ERRPRINT(\"Timeout waiting for command response\\n\");\n\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n\n                s->norintsts |= SDHC_NIS_ERR;\n\n            }\n\n        }\n\n\n\n        if ((s->norintstsen & SDHC_NISEN_TRSCMP) &&\n\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n\n            s->norintsts |= SDHC_NIS_TRSCMP;\n\n        }\n\n    }\n\n\n\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n\n        s->norintsts |= SDHC_NIS_CMDCMP;\n\n    }\n\n\n\n    sdhci_update_irq(s);\n\n\n\n    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n\n        s->data_count = 0;\n\n        sdhci_data_transfer(s);\n\n    }\n\n}\n", "idx": 6891, "substitutes": {"s": ["sf", "S", "a", "b", "i", "status", "private", "f", "d", "service", "hs", "conf", "w", "self", "h", "aws", "g", "sym", "y", "sets", "is", "spec", "services", "its", "states", "server", "ls", "ops", "ds", "ts", "settings", "fs", "sq", "site", "rs", "ins", "sg", "sync", "ses", "cs", "u", "submit", "e", "sb", "ks", "secondary", "t", "qs", "p", "c", "os", "ssl", "ps", "o", "v", "http", "session", "si", "sys", "m", "l", "xs", "side", "ns", "stats", "args", "us", "ss", "gs", "n", "su", "params", "es", "js"], "request": ["condition", "er", "Request", "method", "complete", "http", "requ", "session", "config", "consumer", "object", "data", "password", "wa", "info", "reply", "xml", "status", "enter", "resource", "argument", "event", "client", "child", "order", "call", "server", "create", "QUEST", "q", "subject", "initial", "e", "submit", "error", "message", "instance", "join", "application", "work", "result", "p", "input", "parse", "question", "output", "req", "quest", "re", "transfer", "type", "report", "sq", "query", "user", "test", "command", "worker", "hello"], "response": ["four", "position", "successful", "environment", "object", "data", "database", "status", "sequence", "document", "service", "initial", "error", "connection", "json", "array", "output", "resp", "page", "current", "index", "onse", "view", "function", "value", "ception", "update", "Response", "server", "subject", "description", "received", "application", "respond", "remote", "operation", "model", "product", "site", "account", "python", "block", "change", "image", "profile", "version", "e", "message", "p", "collection", "location", "api", "r", "hello", "o", "v", "complete", "wave", "session", "get", "reply", "body", "resource", "event", "client", "args", "res", "answer", "respons", "example", "when", "other", "result", "report", "success"], "rlen": ["hrlen", "rrlen", "frlength", "llength", "rden", " rren", "rbl", "Rlength", "bLen", "rrlon", "blon", "hrren", "blen", "rlon", "srden", " rden", " rlon", "Ren", "rlength", "frden", "cren", "hrbl", "llen", " rlength", " rLen", "len", "RLen", "ren", "Rlen", "srlength", "frlen", "rLen", "frLen", "rrlength", "crlength", "rren", "crlen", "crLen", "blength", "lLen", "hrLen", "srren", "srbl", "srLen", "rrLen", " rbl", "srlen"]}}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void openrisc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(occ);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    occ->parent_realize = dc->realize;\n\n    dc->realize = openrisc_cpu_realizefn;\n\n\n\n    occ->parent_reset = cc->reset;\n\n    cc->reset = openrisc_cpu_reset;\n\n\n\n    cc->class_by_name = openrisc_cpu_class_by_name;\n\n    cc->has_work = openrisc_cpu_has_work;\n\n    cc->do_interrupt = openrisc_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;\n\n    cc->dump_state = openrisc_cpu_dump_state;\n\n    cc->set_pc = openrisc_cpu_set_pc;\n\n    cc->gdb_read_register = openrisc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = openrisc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;\n\n    dc->vmsd = &vmstate_openrisc_cpu;\n\n#endif\n\n    cc->gdb_num_core_regs = 32 + 3;\n\n\n\n    /*\n\n     * Reason: openrisc_cpu_initfn() calls cpu_exec_init(), which saves\n\n     * the object in cpus -> dangling pointer after final\n\n     * object_unref().\n\n     */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n", "idx": 16924, "substitutes": {"oc": ["pc", "org", "rog", "ob", "rc", "inc", "acc", "oca", "anc", "toc", "loc", "ocr", "aco", "oper", "fc", "mc", "abc", "object", "o", "auc", "roc", "usc", "nc", "ac", "oid", "oci", "config", "soc", "ucc", "c", "uc", "oco", "ec", "alloc", "oo", "OC", "co", "voc"], "data": ["Data", "dd", "record", "func", "inc", "coll", "di", "bb", "def", "ee", "design", "d", "config", "ad", "da", "doc", "cache", "fee", "dat", "cd", "DATA", "co", "desc", "ds"], "occ": ["org", "ct", "coe", "rc", "ai", "cm", "inc", "bec", "acc", "exc", "oca", "nec", "cf", "coll", "anc", "bc", "loc", "aco", "fc", "mc", "abc", "ae", "auc", "ca", "roc", "rec", "usc", "nc", "ac", "oci", "aa", "rn", "xc", "ucc", "cl", "oe", "c", "account", "uc", "misc", "ec", "proc", "ace", "OC", "co", "circ", "Occ", "cci"], "cc": ["pc", "ect", "code", "func", "che", "cca", "cus", "vc", "CC", "ct", "rc", "gc", "cm", "inc", "bec", "cf", "acc", "coll", "bc", "cp", "PC", "fc", "mc", "ctx", "abc", "self", "ctrl", "ca", "cs", "pg", "roc", "cms", "ce", "nc", "ac", "go", "cel", "DC", "ci", "con", "xc", "tc", "config", "sc", "cu", "ga", "ucc", "client", "cl", "c", "lc", " gcc", "uc", "ck", "cache", "ec", "cd", "WC", "cn", "cast", "co", " CC", "kk", "cci"], "dc": ["pc", "dn", "db", "cdn", "cca", "vc", "rc", "duc", "inc", "de", "cf", "acc", "anc", "bc", "dt", "fc", "mc", "di", "design", "d", "df", "nc", "ac", "disc", "DC", "tc", "bd", "fd", "ga", "ucc", "c", "da", "uc", "cmd", "doc", "ck", "dat", "ec", "cd", "conn", "ds", "director"]}}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_sys_interrupts(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    uint32_t op2;\n\n    uint32_t r1;\n\n    TCGLabel *l1;\n\n    TCGv tmp;\n\n\n\n    op2 = MASK_OP_SYS_OP2(ctx->opcode);\n\n    r1  = MASK_OP_SYS_S1D(ctx->opcode);\n\n\n\n    switch (op2) {\n\n    case OPC2_32_SYS_DEBUG:\n\n        /* raise EXCP_DEBUG */\n\n        break;\n\n    case OPC2_32_SYS_DISABLE:\n\n        tcg_gen_andi_tl(cpu_ICR, cpu_ICR, ~MASK_ICR_IE);\n\n        break;\n\n    case OPC2_32_SYS_DSYNC:\n\n        break;\n\n    case OPC2_32_SYS_ENABLE:\n\n        tcg_gen_ori_tl(cpu_ICR, cpu_ICR, MASK_ICR_IE);\n\n        break;\n\n    case OPC2_32_SYS_ISYNC:\n\n        break;\n\n    case OPC2_32_SYS_NOP:\n\n        break;\n\n    case OPC2_32_SYS_RET:\n\n        gen_compute_branch(ctx, op2, 0, 0, 0, 0);\n\n        break;\n\n    case OPC2_32_SYS_FRET:\n\n        gen_fret(ctx);\n\n        break;\n\n    case OPC2_32_SYS_RFE:\n\n        gen_helper_rfe(cpu_env);\n\n        tcg_gen_exit_tb(0);\n\n        ctx->bstate = BS_BRANCH;\n\n        break;\n\n    case OPC2_32_SYS_RFM:\n\n        if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM) {\n\n            tmp = tcg_temp_new();\n\n            l1 = gen_new_label();\n\n\n\n            tcg_gen_ld32u_tl(tmp, cpu_env, offsetof(CPUTriCoreState, DBGSR));\n\n            tcg_gen_andi_tl(tmp, tmp, MASK_DBGSR_DE);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, tmp, 1, l1);\n\n            gen_helper_rfm(cpu_env);\n\n            gen_set_label(l1);\n\n            tcg_gen_exit_tb(0);\n\n            ctx->bstate = BS_BRANCH;\n\n            tcg_temp_free(tmp);\n\n        } else {\n\n            /* generate privilege trap */\n\n        }\n\n        break;\n\n    case OPC2_32_SYS_RSLCX:\n\n        gen_helper_rslcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_SVLCX:\n\n        gen_helper_svlcx(cpu_env);\n\n        break;\n\n    case OPC2_32_SYS_RESTORE:\n\n        if (tricore_feature(env, TRICORE_FEATURE_16)) {\n\n            if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM ||\n\n                (ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_UM1) {\n\n                tcg_gen_deposit_tl(cpu_ICR, cpu_ICR, cpu_gpr_d[r1], 8, 1);\n\n            } /* else raise privilege trap */\n\n        } /* else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_SYS_TRAPSV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_SV, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_SOVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    case OPC2_32_SYS_TRAPV:\n\n        l1 = gen_new_label();\n\n        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_V, 0, l1);\n\n        generate_trap(ctx, TRAPC_ASSERT, TIN5_OVF);\n\n        gen_set_label(l1);\n\n        break;\n\n    }\n\n}\n", "idx": 27129, "substitutes": {"env": ["obj", "np", "exc", "context", "cv", "enc", "ec", "qt", "en", "config", "cb", "priv", "inst", "ev", "ea", "environment", "proc", "db", "buf", "cfg", "viron", "impl", "ptr", "src", "conn", "bg", "tx"], "ctx": ["exec", "txt", "sc", "kw", "cm", "obj", "np", "cca", "scope", " context", "c", "pkg", "context", "cv", "connection", "qa", "xc", "qt", "gru", "sq", "config", "component", "jp", "cb", "bc", "ch", "sync", "kb", "linux", "cmp", "gpu", "wx", "buf", "chan", "hw", "cfg", "cmd", "grad", "vc", "cpu", "loc", "wcs", "cli", "Context", "cc", "cp", "ci", "cf", "mc", "rc", "utils", "sci", "conv", "client", "cas", "xs", "lc", "ctrl", "tc", "src", "conn", "qq", "fp", "ck", "nc", "tx", "cs"], "op2": ["opt4", "hop2", "opt1", "op52", "hop4", "op4", "OP52", "op1", "OP02", " op4", " op52", " opTwo", "oper3", "op02", " op1", "op3", "ip4", "opt3", "ip2", "OP2", "hop1", "hopTwo", "oper1", " op02", "oper4", "ip3", "oper2", "hop02", "opTwo", "OP1", "opt2", "hop52", "OPTwo", "OP4"], "r1": ["ur2", "ur61", "l2", "v0", "l61", "v1", "ur3", "v4", "r61", "r0", " r2", "r2", " r4", "R0", "R4", "ur1", "l3", " r61", "r3", " r0", " r3", "r4", "R1"], "l1": ["l9", "rl9", "l2", "l8", "l11", "rl1", "el1", "Lone", "r7", "r9", "p1", "r2", "L1", " l8", "p2", "el2", "rl7", "L8", "nl1", "lone", "l7", "rl2", " l2", " lone", "r11", "rone", "p11", "nl11", "el7", "r8", "L2", "el9", "nl2"], "tmp": ["temp", "txt", "obj", "cm", "np", "bag", "slice", "kk", "emp", "app", "cv", "bb", "job", "xc", "Temp", "storage", "img", "rb", "config", "data", "jp", "vt", "cb", "bp", "front", "test", "proc", "su", "cmp", "wx", "mp", "buf", "TB", "obb", "api", "pb", "input", "nb", "session", "output", "handler", "result", "sb", "fb", "lab", "cp", "cache", "now", "vm", "timer", "tab", "sup", "tf", "tc", "tp", "src", "appy", "cpp", "bg", "mk", "fp", "v", "bt"]}}
{"project": "qemu", "commit_id": "0c402e5abb8c2755390eee864b43a98280fc2453", "target": 0, "func": "static int usb_host_scan_dev(void *opaque, USBScanFunc *func)\n\n{\n\n    FILE *f = NULL;\n\n    char line[1024];\n\n    char buf[1024];\n\n    int bus_num, addr, speed, device_count, class_id, product_id, vendor_id;\n\n    char product_name[512];\n\n    int ret = 0;\n\n\n\n    if (!usb_host_device_path) {\n\n        perror(\"husb: USB Host Device Path not set\");\n\n        goto the_end;\n\n    }\n\n    snprintf(line, sizeof(line), \"%s/devices\", usb_host_device_path);\n\n    f = fopen(line, \"r\");\n\n    if (!f) {\n\n        perror(\"husb: cannot open devices file\");\n\n        goto the_end;\n\n    }\n\n\n\n    device_count = 0;\n\n    bus_num = addr = class_id = product_id = vendor_id = 0;\n\n    speed = -1; /* Can't get the speed from /[proc|dev]/bus/usb/devices */\n\n    for(;;) {\n\n        if (fgets(line, sizeof(line), f) == NULL) {\n\n            break;\n\n        }\n\n        if (strlen(line) > 0) {\n\n            line[strlen(line) - 1] = '\\0';\n\n        }\n\n        if (line[0] == 'T' && line[1] == ':') {\n\n            if (device_count && (vendor_id || product_id)) {\n\n                /* New device.  Add the previously discovered device.  */\n\n                ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                           product_id, product_name, speed);\n\n                if (ret) {\n\n                    goto the_end;\n\n                }\n\n            }\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Bus=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            bus_num = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Dev#=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            addr = atoi(buf);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Spd=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            if (!strcmp(buf, \"5000\")) {\n\n                speed = USB_SPEED_SUPER;\n\n            } else if (!strcmp(buf, \"480\")) {\n\n                speed = USB_SPEED_HIGH;\n\n            } else if (!strcmp(buf, \"1.5\")) {\n\n                speed = USB_SPEED_LOW;\n\n            } else {\n\n                speed = USB_SPEED_FULL;\n\n            }\n\n            product_name[0] = '\\0';\n\n            class_id = 0xff;\n\n            device_count++;\n\n            product_id = 0;\n\n            vendor_id = 0;\n\n        } else if (line[0] == 'P' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Vendor=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            vendor_id = strtoul(buf, NULL, 16);\n\n            if (get_tag_value(buf, sizeof(buf), line, \"ProdID=\", \" \") < 0) {\n\n                goto fail;\n\n            }\n\n            product_id = strtoul(buf, NULL, 16);\n\n        } else if (line[0] == 'S' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Product=\", \"\") < 0) {\n\n                goto fail;\n\n            }\n\n            pstrcpy(product_name, sizeof(product_name), buf);\n\n        } else if (line[0] == 'D' && line[1] == ':') {\n\n            if (get_tag_value(buf, sizeof(buf), line, \"Cls=\", \" (\") < 0) {\n\n                goto fail;\n\n            }\n\n            class_id = strtoul(buf, NULL, 16);\n\n        }\n\n    fail: ;\n\n    }\n\n    if (device_count && (vendor_id || product_id)) {\n\n        /* Add the last device.  */\n\n        ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,\n\n                   product_id, product_name, speed);\n\n    }\n\n the_end:\n\n    if (f) {\n\n        fclose(f);\n\n    }\n\n    return ret;\n\n}\n", "idx": 26884, "substitutes": {"opaque": ["pacity", "opifice", "compacity", "obacity", "compifice", "opatile", "copifice", "copica", "Opifice", "Opaque", "compaque", "patile", "opica", "paque", "compica", "opacity", "Opica", "obatile", "compatile", "copaque", "obaque"], "func": ["exec", "code", "package", "lambda", "wrapper", "oc", "b", "parser", "function", "callback", "asm", "fn", "job", "Function", "cb", "bc", "wrap", "util", "proc", "self", "fc", "aux", "con", "work", "rl", "unc", "loc", "worker", "cc", "ctx", "ln", "conv", "xxx", "lc", "layer", "loop", "apply", "conn", "attr", "nc", "pc", "fun"], "f": ["fen", "fe", "w", "fo", "i", "p", "b", "m", "c", "d", "of", "rf", "x", "bf", "fm", "fr", "u", "e", "fc", "lf", "feed", "o", "ff", "fw", "handler", "fb", "fi", "cf", "fu", "h", "fun", "fs", "fa", "t", "fp", "v", "r", "g", "sf", "df", "l", "fd", "file", "F"], "line": ["Line", "server", "frame", "name", "time", "buffer", "base", "sync", "url", "ne", "lf", "el", "cl", "tick", "lines", "lin", "word", "pin", "strip", "zip", "LINE", "entry", "status", "limit", "list", "de", "row", "val", "code", "slice", "user", "liner", "c", "engine", "text", "link", "cell", "key", "path", "lane", "sl", "block", " lines", "len", "file", "byte", "d", "data", "band", "error", "db", "e", "message", "str", "err", "la", "lined", "mode", "board", "lc", "ine", "source", "lo", "stack", "header", "pos", "connection", "lock", "ze", "look", "seq", "page", "style", "pass", "write", "end", "id", "unit", "cpu", "loc", "run", "ln", "device", "comment", "nl", "route", "l"], "buf": ["bag", "exc", "batch", "frame", "wb", "pkg", "buffer", "gru", "gb", "cb", "bang", "cmd", "bridge", "lines", "fw", "ptr", "buff", "r", "desc", "ru", "code", "b", "c", "cv", "msg", "grab", "queue", "text", "filename", "port", "proc", "feed", "ff", "path", "cap", "vag", "cache", "feat", "h", "src", "block", "que", "fd", "file", "uf", "uc", "context", "data", "rb", "band", "bus", "brace", "str", "la", "box", "fi", "fb", "rx", "stack", "ha", "uber", "seq", "uno", "vec", "config", "br", "aka", "prof", "home", "loc", "ctx", "off", "loop", "conn", "runner", "v"], "bus_num": ["class_count", "bus_id", "device_id", "device_name", "bus_name", "class_num", "bus_number", "bus_loc", " bus_number", "device_loc", "class_number", " bus_id", "device_info", " bus_name", "bus_info", "bus_count", "device_num"], "addr": ["md", "ref", "wrapper", "over", "name", "pkg", "dr", "enable", "data", "en", "vr", "ad", "align", "address", "access", "dd", "error", "id", "alias", "url", "pad", "cmp", "proc", "amp", "el", "adr", "cmd", "start", "advert", "ord", "loc", "ann", "offset", "rc", "hop", "ptr", "oa", "device", "dist", "amd", "rt", "ack", "nr", "ip", "src", "conn", "host", "desc", "route", "attr", "ace", "nc", "pos", "len", "layer"], "speed": ["strength", "skip", "slice", "class", "driver", "effect", "sn", "score", "engine", "cost", "name", "quick", "time", "force", "kick", "weight", "style", "peed", "delay", "send", "type", "pass", "race", "Speed", "sync", "id", "sex", "state", "reason", "seed", "unit", "start", "gain", "spec", "offset", "spin", "mode", "sign", "grade", "order", "size", "rate", "rank", "scale", "sort", "level", "direction", "length", "dist", "source", "service", "status", "powered", "index", "slow", "performance", "power"], "device_count": ["product_count", "device_id", "device_name", "product_code", " device_id", " device_num", "driver_count", "driver_code", "device_Count", "driver_Count", "device_list", "device_code", " device_list", "driver_id", "device_num"], "class_id": ["class__name", "product_like", "class_count", "product_num", "product_count", "product_code", "class_name", "class__code", "class_num", "class__id", "classalname", "class_like", "class_pid", "class_code", "product_pid", "classallike", "class_ids", "class__ids", "product_ids", "classalid", "classalcount"], "product_id": ["product_number", "product_type", "product_no", " product_number", "productappids", " product_type", "class_name", "productapppid", " product_kid", "class_pid", "productapptype", "productappname", "product_pid", " product_no", "product_kid", "productappno", "class_ids", "product_ids", "productappid"], "vendor_id": ["vendoreeid", "vendor_type", "vendorPoolid", "vendor_ids", "vender_source", "vendor__ids", "vendor_side", "vendorPoolname", "vender_id", "vendor__id", "vender_type", "vendor__ad", "vendoreelength", "vendor_source", "vendor_name", "vendor__name", "vender_name", "vender_ids", "vendor_ad", "vendorPoolids", "vendoreename", "vendorPoolside", "vender_side", "vendoreetype", "vendor_length", "vender_length"], "product_name": ["product_number", "product_list", "product_type", " product_number", " product_type", "productactype", "productaclist", " product_list", "productacid", "productacname"]}}
{"project": "FFmpeg", "commit_id": "951e715cebfaffced7f13c1525771ff917fe1d38", "target": 1, "func": "static int video_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFrame *frame = avcodec_alloc_frame();\n\n    int64_t pts_int;\n\n    double pts;\n\n    int ret;\n\n\n\n#if CONFIG_AVFILTER\n\n    AVFilterGraph *graph = avfilter_graph_alloc();\n\n    AVFilterContext *filt_out = NULL;\n\n    int64_t pos;\n\n    int last_w = is->video_st->codec->width;\n\n    int last_h = is->video_st->codec->height;\n\n\n\n    if ((ret = configure_video_filters(graph, is, vfilters)) < 0)\n\n        goto the_end;\n\n    filt_out = is->out_video_filter;\n\n#endif\n\n\n\n    for (;;) {\n\n#if !CONFIG_AVFILTER\n\n        AVPacket pkt;\n\n#else\n\n        AVFilterBufferRef *picref;\n\n        AVRational tb;\n\n#endif\n\n        while (is->paused && !is->videoq.abort_request)\n\n            SDL_Delay(10);\n\n#if CONFIG_AVFILTER\n\n        if (   last_w != is->video_st->codec->width\n\n            || last_h != is->video_st->codec->height) {\n\n            av_dlog(NULL, \"Changing size %dx%d -> %dx%d\\n\", last_w, last_h,\n\n                    is->video_st->codec->width, is->video_st->codec->height);\n\n            avfilter_graph_free(&graph);\n\n            graph = avfilter_graph_alloc();\n\n            if ((ret = configure_video_filters(graph, is, vfilters)) < 0)\n\n                goto the_end;\n\n            filt_out = is->out_video_filter;\n\n            last_w = is->video_st->codec->width;\n\n            last_h = is->video_st->codec->height;\n\n        }\n\n        ret = get_filtered_video_frame(filt_out, frame, &picref, &tb);\n\n        if (picref) {\n\n            pts_int = picref->pts;\n\n            pos     = picref->pos;\n\n            frame->opaque = picref;\n\n        }\n\n\n\n        if (av_cmp_q(tb, is->video_st->time_base)) {\n\n            av_unused int64_t pts1 = pts_int;\n\n            pts_int = av_rescale_q(pts_int, tb, is->video_st->time_base);\n\n            av_dlog(NULL, \"video_thread(): \"\n\n                    \"tb:%d/%d pts:%\"PRId64\" -> tb:%d/%d pts:%\"PRId64\"\\n\",\n\n                    tb.num, tb.den, pts1,\n\n                    is->video_st->time_base.num, is->video_st->time_base.den, pts_int);\n\n        }\n\n#else\n\n        ret = get_video_frame(is, frame, &pts_int, &pkt);\n\n#endif\n\n\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (!ret)\n\n            continue;\n\n\n\n        pts = pts_int * av_q2d(is->video_st->time_base);\n\n\n\n#if CONFIG_AVFILTER\n\n        ret = output_picture2(is, frame, pts, pos);\n\n#else\n\n        ret = output_picture2(is, frame, pts,  pkt.pos);\n\n        av_free_packet(&pkt);\n\n#endif\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (step)\n\n            if (cur_stream)\n\n                stream_pause(cur_stream);\n\n    }\n\n the_end:\n\n#if CONFIG_AVFILTER\n\n    avfilter_graph_free(&graph);\n\n#endif\n\n    av_free(frame);\n\n    return 0;\n\n}\n", "idx": 6489, "substitutes": {"arg": ["abc", "as", "ig", "play", "ag", "emb", "Ar", "val", "rc", "inter", "enc", "Args", "ray", "ad", "or", "ace", "inc", "argument", "like", "args", "param", "arc", "ar", "arr", "ang", "p", "array", "parse", "amp", "asm", "AR", "Arg", "var", "g", "util", "ref", "fi", "mor", "par"], "is": ["isi", "serv", "ris", "rid", "i", "IS", "obs", "iris", "ii", "active", "bs", "ar", "any", "nis", "iz", "irc", "id", "bits", "s", "see", "info", "its", "ls", "iss", "ai", "it", "uri", "ops", "bis", "vis", "ini", "ie", "ais", "parse", "his", "ip", "ms", "iso", "isc", "ui", "as", "kit", "are", "lis", "op", "ri", "or", "ses", "image", "isl", "has", "esi", "isa", "the", "ics", "sis", "vs", "mis", "ist", "inst", "isin", "ic", "css", "os", "im", "api", "app", "Is", "http", "mes", "get", "si", "sys", "in", "ir", "init", "us", "ss", "full", "ori", "eni", "il", "es"], "frame": ["game", "base", "flow", "fr", "block", "parent", "note", "session", "config", "layout", "force", "feature", "iframe", "slice", "za", "image", "Frame", "draw", "live", "fb", " Frame", "window", "f", "fake", "picture", "rame", "state", "series", "document", "fe", "part", "point", "file", "fram", "plane", "cycle", "framework", "boot", "fab", "shot", "line", "node", "setup", "thread", "video", "model", "frames", "element", "ref", "fi", "host", "ze", "view"], "pts_int": ["pts_bit", "PT\n", "pts_str", "pts1bit", "pt\n", "ptts_inter", "ct\n", "point\n", "pts1int", "pts_full", "ptsets_full", "ptsets_int", "ptts_long", "pts_inter", "ptts_int", "pts_long", "ptts_str", "ptsets_bit", "pts1full"], "pts": ["periods", "ctsets", "ptcount", "ptsets", "ctcount", "PTs", "ctls", "ptS", "periodcount", "PTcount", "ctsi", " ptsets", "cts", "PTS", " prefsi", " prefs", "periodS", " prefsets", "ctS", "ctd", "PTd", "ptd", "periodd", " prefls", "ptsi", " ptsi", " ptls", "ptls"], "ret": ["reg", "mem", "rt", "id", "alt", "nt", "rot", "val", "cat", "let", "reply", "status", " RET", "fin", " Ret", "lit", "att", "obj", "res", "match", "def", "part", "len", "mt", "det", "arr", "RET", "feat", "rev", "result", "seq", "Ret", "ft", "ut", "opt", "re", "fun", "back", "hash", "resp", "gt", "ref", "conn", "rets"], "graph": ["flow", "gp", "complex", "feed", "hub", "parent", "shadow", "shape", "scope", "session", "edge", "layout", "config", "stack", "growth", "stream", "widget", "module", "gpu", "image", "draw", "dot", "pg", "document", "connect", "man", "facebook", "proxy", "connection", "gener", "path", "hou", "go", "ghost", "container", "bridge", "context", "pool", "h", "network", "gen", "hog", "raph", "node", "tree", "g", "closure", "Graph", "gd", "model", "query", "gh", "ha", "cache", "group", "grad", "conn", "google", "view"], "filt_out": ["flt_work", "failJout", "facet_in", "fft_out", "filt_string", "failJstring", "filterexternal", "filt_Out", "fail_out", "fail_in", "filterout", "fail_string", "failJin", "filt_work", "flt_in", "filterstring", "fft_string", "flt_out", "facet_out", "failJref", "facet_list", "fft_external", "filt_ref", "filtJin", "filtJstring", "filt_list", "filtJout", "flt_Out", "filt_external", "filt_in", "filtJref", "fail_ref"], "pos": ["points", "base", "pid", "axis", "position", "padding", "block", "count", "alt", "spec", "channel", "po", "rot", "val", "sum", "data", "style", "bit", "rel", "body", "pt", "vals", "offset", "obj", "args", "pc", "POS", "conf", "Pos", "part", "len", "code", "col", "depth", "port", "lat", "vis", "str", "seq", "prop", "start", "fs", "pose", "os", "doc", "pointer", "cap", "type", "bl", "cache", "ref", "index", "src", "neg", "slot"], "pkt": ["pbct", "Pkt", "bct", "pbacket", "pbft", "pft", "pct", "packet", "Pct", "bkt", "bft", "Pft", "pbkt", "Packet", "backet"], "picref": ["picre", "synRef", "fcref", "nicREF", "cusreference", " picrel", "icRef", "pictREF", "picrel", "chatref", "PicRef", "icror", "pcrel", "synreference", "Picalt", "licRef", "chatror", "synrel", "icreference", " picalt", "pcalt", "PicREF", "pictref", "chatreference", "fcrel", "picalt", "pictalt", "licreference", "picreference", "picREF", "cusref", "pcref", "pinrel", "licrel", "pinror", "picRef", " picREF", "nicref", "Picref", "chatrel", "fcreference", "pinreference", "pcreference", "icref", "picror", "pictreference", " picreference", "cusre", "Picreference", "fcRef", "nicreference", "cusREF", "icrel", "synref", "pcRef", "nicre", "pinalt", "licref", "pinref", "Picrel", "Picre"], "tb": ["ptbm", " ptbm", "tbm", "btz", "tzb", "ptbs", "btb", " tbl", "itp", "ctbs", " ptbs", "ptb", "itbs", "ctp", " tbs", "tbs", " ptb", "atb", "btbs", "btzb", "itbl", " tbm", "atzb", "tz", "ttbs", "ttz", "ttb", "ctb", " tp", "atz", "ctbl", "tp", "itb", "ttzb", "tbl", "atbs"]}}
{"project": "qemu", "commit_id": "ad0ebb91cd8b5fdc4a583b03645677771f420a46", "target": 1, "func": "static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,\n\n                              target_ulong opcode, target_ulong *args)\n\n{\n\n    target_ulong liobn = args[0];\n\n    target_ulong ioba = args[1];\n\n    target_ulong tce = args[2];\n\n    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);\n\n    VIOsPAPR_RTCE *rtce;\n\n\n\n    if (!dev) {\n\n        hcall_dprintf(\"LIOBN 0x\" TARGET_FMT_lx \" does not exist\\n\", liobn);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);\n\n\n\n#ifdef DEBUG_TCE\n\n    fprintf(stderr, \"spapr_vio_put_tce on %s  ioba 0x\" TARGET_FMT_lx\n\n            \"  TCE 0x\" TARGET_FMT_lx \"\\n\", dev->qdev.id, ioba, tce);\n\n#endif\n\n\n\n    if (ioba >= dev->rtce_window_size) {\n\n        hcall_dprintf(\"Out-of-bounds IOBA 0x\" TARGET_FMT_lx \"\\n\", ioba);\n\n        return H_PARAMETER;\n\n    }\n\n\n\n    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);\n\n    rtce->tce = tce;\n\n\n\n    return H_SUCCESS;\n\n}\n", "idx": 937, "substitutes": {"env": ["eu", "ext", "txt", "visor", "environment", "priv", "dict", "eng", "enc", "ef", "proc", "dest", "estate", "err", "impl", "ec", "opt", "exc", "conf", "viron", "obj", "en", "ev", "iv", "inst", "cfg", "emb"], "spapr": ["sprapri", "spapro", "spepR", "spAPR", "sprapro", "spAPro", "spAPrs", "spaperi", "spapsR", "speprar", "spAPr", "SpapR", "spaper", "SpapsR", "spraprar", "sprapr", "mpaprar", "Spapr", "mpapR", "Spapsrs", "spraprs", "Spapsr", "mprapR", "spaprar", "spaperar", "mprapr", "Spapsro", "Spapro", "mprapri", "spapsrs", "spepri", "mpraprar", "spapri", "mpapri", "sprapR", "spapsr", "mpapr", "spapR", "spapeR", "spepr", "spaprs", "spapsro", "Spaprs"], "opcode": ["opcodes", "ipcodes", "ipbar", "mpbe", "mpbar", "ipbe", "mpcodes", "mpcode", "epbar", "ipcode", "epcode", "epcodes", "opbar", "opbe", "epbe"], "args": ["argument", "keys", "call", "limits", "arg", "missing", "fun", "same", "extra", "array", "host", "data", "members", "flags", "strings", "seconds", "aws", "use", "ins", "Arg", "objects", "ms", "lang", "empty", "ims", "arms", "enc", "py", "options", "params", "event", "bug", "ports", "names", "parse", "ras", "ams", "config", "gs", "function", "p", "vs", "w", "self", "atts", "words", "lines", "fires", "as", "fields", " arguments", "stats", "Args", "ages", "ex", "apps", "parts"], "dev": ["serial", "adv", "def", "dd", "conn", "device", "mod", "sd", "host", "data", "development", "ver", "d", "di", "rec", "sh", "ad", "priv", "prof", "de", "client", "dom", "Dev", "DEV", "develop", "des", "info", "nt", "bug", "md", "ch", "pub", "user", "dc", "gu", "p", "block", "w", "private", "dm", "app", "conf", "cache", "obj", "comment", "die", "driver", "v", "ev", "dem", "rad", "inst", "var", "error", "valid", "debug", "root", "diff", "gd", "dist", "mem"], "rtce": ["tCE", "tge", "rotse", "rtco", "rotCE", "RTfe", "rotfe", "gtCE", "ttcel", "tcel", "ttco", "ttced", "ctce", "rtcel", "rotce", "rtse", "gtce", "ttce", "rtfe", "RTge", "RTse", "gtfe", "tced", "rtCE", "rtge", "ttge", "RTco", "gtse", "ctcel", "RTce", "RTCE", "ctced", "rtced", "tce", "ctCE", "ttCE", "tco"]}}
