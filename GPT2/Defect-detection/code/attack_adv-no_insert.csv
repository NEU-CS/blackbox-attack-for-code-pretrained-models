Index,Original Code,Program Length,Adversarial Code,True Label,Original Prediction,Adv Prediction,Is Success,Extracted Names,Importance Score,Greedy No. Changed Names,Greedy No. Changed Tokens,Replaced Names,GA No. Changed Names,GA No. Changed Tokens,Attack Type,Query Times,Time Cost,Suc Type,Insert Words
0,"static int check_bind(const char *hostname, bool *has_proto)

{

    int fd = -1;

    struct addrinfo ai, *res = NULL;

    int rc;

    int ret = -1;



    memset(&ai, 0, sizeof(ai));

    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;

    ai.ai_family = AF_UNSPEC;

    ai.ai_socktype = SOCK_STREAM;



    /* lookup */

    rc = getaddrinfo(hostname, NULL, &ai, &res);

    if (rc != 0) {

        if (rc == EAI_ADDRFAMILY ||

            rc == EAI_FAMILY) {

            *has_proto = false;

            goto done;

        }

        goto cleanup;

    }



    fd = qemu_socket(res->ai_family, res->ai_socktype, res->ai_protocol);

    if (fd < 0) {

        goto cleanup;

    }



    if (bind(fd, res->ai_addr, res->ai_addrlen) < 0) {

        if (errno == EADDRNOTAVAIL) {

            *has_proto = false;

            goto done;

        }

        goto cleanup;

    }



    *has_proto = true;

 done:

    ret = 0;



 cleanup:

    if (fd != -1) {

        close(fd);

    }

    if (res) {

        freeaddrinfo(res);

    }

    return ret;

}
",240,,LABEL_1,LABEL_0,,-4,"hostname,has_proto,ai,res,rc",,,,0,,0,Greedy,1,0.008495859305063884,,
1,"static int32_t parse_gain(const char *gain)

{

    char *fraction;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int db;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    db = strtol(gain, &fraction, 0);

    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }



    if (abs(db) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return db * 100000 + sign * mb;

}
",145,"static int32_t parse_gain(const char *gain)

{

    char *fraction;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int bi;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    bi = strtol(gain, &fraction, 0);

    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }



    if (abs(bi) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return bi * 100000 + sign * mb;

}
",LABEL_1,LABEL_1,LABEL_0,1,"gain,fraction,db","gain:-3.451108932495117e-05,fraction:-0.00016826391220092773,db:0.00012809038162231445,",1,4,0,"db:bi,",0,Greedy,66,0.023727405071258544,replace,[]
2,"static void arm_mptimer_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->realize = arm_mptimer_realize;

    dc->vmsd = &vmstate_arm_mptimer;

    dc->reset = arm_mptimer_reset;

    dc->no_user = 1;

    dc->props = arm_mptimer_properties;

}
",60,"static void arm_mptimer_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *fc = DEVICE_CLASS(klass);



    fc->realize = arm_mptimer_realize;

    fc->vmsd = &vmstate_arm_mptimer;

    fc->reset = arm_mptimer_reset;

    fc->no_user = 1;

    fc->props = arm_mptimer_properties;

}
",LABEL_1,LABEL_1,LABEL_0,1,"klass,data,dc","klass:-1.609325408935547e-05,data:-2.777576446533203e-05,dc:0.00010883808135986328,",1,6,0,"dc:fc,",0,Greedy,61,0.021340064207712808,replace,[]
3,"void do_load_dcr (void)

{

    target_ulong val;



    if (unlikely(env->dcr_env == NULL)) {

        if (loglevel != 0) {

            fprintf(logfile, ""No DCR environment\n"");

        }

        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_INVAL);

    } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {

        if (loglevel != 0) {

            fprintf(logfile, ""DCR read error %d %03x\n"", (int)T0, (int)T0);

        }

        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_PRIV_REG);

    } else {

        T0 = val;

    }

}
",125,,LABEL_0,LABEL_0,LABEL_0,-1,val,,1,3,0,,0,GA,202,0.07418361902236939,failed,[]
4,"static gboolean pty_chr_timer(gpointer opaque)

{

    struct CharDriverState *chr = opaque;

    PtyCharDriver *s = chr->opaque;



    if (s->connected) {

        goto out;

    }



    /* Next poll ... */

    pty_chr_update_read_handler(chr);



out:

    s->timer_tag = 0;

    return FALSE;

}
",62,,LABEL_1,LABEL_0,,-4,"opaque,chr,s",,,,0,,0,Greedy,1,0.00046482086181640623,,
5,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)

{

    uint32_t limit;



    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (s->control & TIMER_CTRL_32BIT)

            limit = 0xffffffff;

        else

            limit = 0xffff;

    } else {

          /* Periodic.  */

          limit = s->limit;

    }

    ptimer_set_limit(s->timer, limit, reload);

}
",84,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)

{

    uint32_t index;



    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (s->control & TIMER_CTRL_32BIT)

            index = 0xffffffff;

        else

            index = 0xffff;

    } else {

          /* Periodic.  */

          index = s->index;

    }

    ptimer_set_limit(s->timer, index, reload);

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,reload,limit","s:0.0003979802131652832,reload:5.0067901611328125e-05,limit:0.0006937980651855469,",1,6,0,"limit:index,",0,Greedy,72,0.02545559008916219,replace,[]
6,"static int do_token_in(USBDevice *s, USBPacket *p)

{

    int request, value, index;

    int ret = 0;



    assert(p->devep == 0);



    request = (s->setup_buf[0] << 8) | s->setup_buf[1];

    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];

    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];

 

    switch(s->setup_state) {

    case SETUP_STATE_ACK:

        if (!(s->setup_buf[0] & USB_DIR_IN)) {

            ret = usb_device_handle_control(s, p, request, value, index,

                                            s->setup_len, s->data_buf);

            if (ret == USB_RET_ASYNC) {

                return USB_RET_ASYNC;

            }

            s->setup_state = SETUP_STATE_IDLE;

            if (ret > 0)

                return 0;

            return ret;

        }



        /* return 0 byte */

        return 0;



    case SETUP_STATE_DATA:

        if (s->setup_buf[0] & USB_DIR_IN) {

            int len = s->setup_len - s->setup_index;

            if (len > p->iov.size) {

                len = p->iov.size;

            }

            usb_packet_copy(p, s->data_buf + s->setup_index, len);

            s->setup_index += len;

            if (s->setup_index >= s->setup_len)

                s->setup_state = SETUP_STATE_ACK;

            return len;

        }



        s->setup_state = SETUP_STATE_IDLE;

        return USB_RET_STALL;



    default:

        return USB_RET_STALL;

    }

}
",310,"static int do_token_in(USBDevice *s, USBPacket *r)

{

    int data, media, val;

    int ret = 0;



    assert(r->devep == 0);



    data = (s->setup_buf[0] << 8) | s->setup_buf[1];

    media   = (s->setup_buf[3] << 8) | s->setup_buf[2];

    val   = (s->setup_buf[5] << 8) | s->setup_buf[4];

 

    switch(s->setup_state) {

    case SETUP_STATE_ACK:

        if (!(s->setup_buf[0] & USB_DIR_IN)) {

            ret = usb_device_handle_control(s, r, data, media, val,

                                            s->setup_len, s->data_buf);

            if (ret == USB_RET_ASYNC) {

                return USB_RET_ASYNC;

            }

            s->setup_state = SETUP_STATE_IDLE;

            if (ret > 0)

                return 0;

            return ret;

        }



        /* return 0 byte */

        return 0;



    case SETUP_STATE_DATA:

        if (s->setup_buf[0] & USB_DIR_IN) {

            int len = s->setup_len - s->setup_index;

            if (len > r->iov.size) {

                len = r->iov.size;

            }

            usb_packet_copy(r, s->data_buf + s->setup_index, len);

            s->setup_index += len;

            if (s->setup_index >= s->setup_len)

                s->setup_state = SETUP_STATE_ACK;

            return len;

        }



        s->setup_state = SETUP_STATE_IDLE;

        return USB_RET_STALL;



    default:

        return USB_RET_STALL;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,p,request,value,index","s:-0.0002764463424682617,p:3.2901763916015625e-05,request:8.225440979003906e-06,value:-5.78761100769043e-05,index:0.00012087821960449219,",4,15,0,"index:val,p:r,request:data,value:media,",0,Greedy,234,0.08874516884485881,replace,[]
7,"uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,

                                    uint64_t offset,

                                    int n_start, int n_end,

                                    int *num, QCowL2Meta *m)

{

    BDRVQcowState *s = bs->opaque;

    int l2_index, ret;

    uint64_t l2_offset, *l2_table, cluster_offset;

    int nb_clusters, i = 0;

    QCowL2Meta *old_alloc;



    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);

    if (ret == 0)

        return 0;



    nb_clusters = size_to_clusters(s, n_end << 9);



    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);



    cluster_offset = be64_to_cpu(l2_table[l2_index]);



    /* We keep all QCOW_OFLAG_COPIED clusters */



    if (cluster_offset & QCOW_OFLAG_COPIED) {

        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,

                &l2_table[l2_index], 0, 0);



        cluster_offset &= ~QCOW_OFLAG_COPIED;

        m->nb_clusters = 0;



        goto out;

    }



    /* for the moment, multiple compressed clusters are not managed */



    if (cluster_offset & QCOW_OFLAG_COMPRESSED)

        nb_clusters = 1;



    /* how many available clusters ? */



    while (i < nb_clusters) {

        i += count_contiguous_clusters(nb_clusters - i, s->cluster_size,

                &l2_table[l2_index], i, 0);



        if(be64_to_cpu(l2_table[l2_index + i]))

            break;



        i += count_contiguous_free_clusters(nb_clusters - i,

                &l2_table[l2_index + i]);



        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);



        if ((cluster_offset & QCOW_OFLAG_COPIED) ||

                (cluster_offset & QCOW_OFLAG_COMPRESSED))

            break;

    }

    nb_clusters = i;



    /*

     * Check if there already is an AIO write request in flight which allocates

     * the same cluster. In this case we need to wait until the previous

     * request has completed and updated the L2 table accordingly.

     */

    LIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {



        uint64_t end_offset = offset + nb_clusters * s->cluster_size;

        uint64_t old_offset = old_alloc->offset;

        uint64_t old_end_offset = old_alloc->offset +

            old_alloc->nb_clusters * s->cluster_size;



        if (end_offset < old_offset || offset > old_end_offset) {

            /* No intersection */

        } else {

            if (offset < old_offset) {

                /* Stop at the start of a running allocation */

                nb_clusters = (old_offset - offset) >> s->cluster_bits;

            } else {

                nb_clusters = 0;

            }



            if (nb_clusters == 0) {

                /* Set dependency and wait for a callback */

                m->depends_on = old_alloc;

                m->nb_clusters = 0;

                *num = 0;

                return 0;

            }

        }

    }



    if (!nb_clusters) {

        abort();

    }



    LIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);



    /* allocate a new cluster */



    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);



    /* save info needed for meta data update */

    m->offset = offset;

    m->n_start = n_start;

    m->nb_clusters = nb_clusters;



out:

    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);



    *num = m->nb_available - n_start;



    return cluster_offset;

}
",620,"uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,

                                    uint64_t base,

                                    int n_start, int nunstop,

                                    int *seq, QCowL2Meta *manager)

{

    BDRVQcowState *sb = bs->opaque;

    int l2Jthread, val;

    uint64_t l2_Offset, *l2stable, cluster_offset;

    int nb_clusters, i = 0;

    QCowL2Meta *old_alloc;



    val = get_cluster_table(bs, base, &l2stable, &l2_Offset, &l2Jthread);

    if (val == 0)

        return 0;



    nb_clusters = size_to_clusters(sb, nunstop << 9);



    nb_clusters = MIN(nb_clusters, sb->l2_size - l2Jthread);



    cluster_offset = be64_to_cpu(l2stable[l2Jthread]);



    /* We keep all QCOW_OFLAG_COPIED clusters */



    if (cluster_offset & QCOW_OFLAG_COPIED) {

        nb_clusters = count_contiguous_clusters(nb_clusters, sb->cluster_size,

                &l2stable[l2Jthread], 0, 0);



        cluster_offset &= ~QCOW_OFLAG_COPIED;

        manager->nb_clusters = 0;



        goto out;

    }



    /* for the moment, multiple compressed clusters are not managed */



    if (cluster_offset & QCOW_OFLAG_COMPRESSED)

        nb_clusters = 1;



    /* how many available clusters ? */



    while (i < nb_clusters) {

        i += count_contiguous_clusters(nb_clusters - i, sb->cluster_size,

                &l2stable[l2Jthread], i, 0);



        if(be64_to_cpu(l2stable[l2Jthread + i]))

            break;



        i += count_contiguous_free_clusters(nb_clusters - i,

                &l2stable[l2Jthread + i]);



        cluster_offset = be64_to_cpu(l2stable[l2Jthread + i]);



        if ((cluster_offset & QCOW_OFLAG_COPIED) ||

                (cluster_offset & QCOW_OFLAG_COMPRESSED))

            break;

    }

    nb_clusters = i;



    /*

     * Check if there already is an AIO write request in flight which allocates

     * the same cluster. In this case we need to wait until the previous

     * request has completed and updated the L2 table accordingly.

     */

    LIST_FOREACH(old_alloc, &sb->cluster_allocs, next_in_flight) {



        uint64_t end_offset = base + nb_clusters * sb->cluster_size;

        uint64_t old_offset = old_alloc->base;

        uint64_t old_end_offset = old_alloc->base +

            old_alloc->nb_clusters * sb->cluster_size;



        if (end_offset < old_offset || base > old_end_offset) {

            /* No intersection */

        } else {

            if (base < old_offset) {

                /* Stop at the start of a running allocation */

                nb_clusters = (old_offset - base) >> sb->cluster_bits;

            } else {

                nb_clusters = 0;

            }



            if (nb_clusters == 0) {

                /* Set dependency and wait for a callback */

                manager->depends_on = old_alloc;

                manager->nb_clusters = 0;

                *seq = 0;

                return 0;

            }

        }

    }



    if (!nb_clusters) {

        abort();

    }



    LIST_INSERT_HEAD(&sb->cluster_allocs, manager, next_in_flight);



    /* allocate a new cluster */



    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * sb->cluster_size);



    /* save info needed for meta data update */

    manager->base = base;

    manager->n_start = n_start;

    manager->nb_clusters = nb_clusters;



out:

    manager->nb_available = MIN(nb_clusters << (sb->cluster_bits - 9), nunstop);



    *seq = manager->nb_available - n_start;



    return cluster_offset;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bs,offset,n_start,n_end,num,m,s,l2_index,ret,l2_offset,l2_table,cluster_offset,nb_clusters,old_alloc","bs:-0.1910291314125061,offset:0.7947381138801575,n_start:0.009661316871643066,n_end:0.014370203018188477,num:0.19283723831176758,m:0.8127948641777039,s:0.9539779424667358,l2_index:1.0426591634750366,ret:0.2412046194076538,l2_offset:0.22876006364822388,l2_table:0.9302908182144165,cluster_offset:0.01327657699584961,nb_clusters:-1.7272372841835022,old_alloc:-0.00010418891906738281,",9,60,0,"l2_index:l2Jthread,s:sb,l2_table:l2stable,m:manager,offset:base,ret:val,l2_offset:l2_Offset,num:seq,n_end:nunstop,",0,Greedy,583,0.2519132971763611,replace,[]
8,"static int virtio_9p_device_init(VirtIODevice *vdev)

{

    V9fsState *s = VIRTIO_9P(vdev);

    int i, len;

    struct stat stat;

    FsDriverEntry *fse;

    V9fsPath path;



    virtio_init(VIRTIO_DEVICE(s), ""virtio-9p"", VIRTIO_ID_9P,

                sizeof(struct virtio_9p_config) + MAX_TAG_LEN);



    /* initialize pdu allocator */

    QLIST_INIT(&s->free_list);

    QLIST_INIT(&s->active_list);

    for (i = 0; i < (MAX_REQ - 1); i++) {

        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);

    }



    s->vq = virtio_add_queue(vdev, MAX_REQ, handle_9p_output);



    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);



    if (!fse) {

        /* We don't have a fsdev identified by fsdev_id */

        fprintf(stderr, ""Virtio-9p device couldn't find fsdev with the ""

                ""id = %s\n"",

                s->fsconf.fsdev_id ? s->fsconf.fsdev_id : ""NULL"");

        goto out;

    }



    if (!s->fsconf.tag) {

        /* we haven't specified a mount_tag */

        fprintf(stderr, ""fsdev with id %s needs mount_tag arguments\n"",

                s->fsconf.fsdev_id);

        goto out;

    }



    s->ctx.export_flags = fse->export_flags;

    s->ctx.fs_root = g_strdup(fse->path);

    s->ctx.exops.get_st_gen = NULL;

    len = strlen(s->fsconf.tag);

    if (len > MAX_TAG_LEN - 1) {

        fprintf(stderr, ""mount tag '%s' (%d bytes) is longer than ""

                ""maximum (%d bytes)"", s->fsconf.tag, len, MAX_TAG_LEN - 1);

        goto out;

    }



    s->tag = g_strdup(s->fsconf.tag);

    s->ctx.uid = -1;



    s->ops = fse->ops;

    s->config_size = sizeof(struct virtio_9p_config) + len;

    s->fid_list = NULL;

    qemu_co_rwlock_init(&s->rename_lock);



    if (s->ops->init(&s->ctx) < 0) {

        fprintf(stderr, ""Virtio-9p Failed to initialize fs-driver with id:%s""

                "" and export path:%s\n"", s->fsconf.fsdev_id, s->ctx.fs_root);

        goto out;

    }

    if (v9fs_init_worker_threads() < 0) {

        fprintf(stderr, ""worker thread initialization failed\n"");

        goto out;

    }



    /*

     * Check details of export path, We need to use fs driver

     * call back to do that. Since we are in the init path, we don't

     * use co-routines here.

     */

    v9fs_path_init(&path);

    if (s->ops->name_to_path(&s->ctx, NULL, ""/"", &path) < 0) {

        fprintf(stderr,

                ""error in converting name to path %s"", strerror(errno));

        goto out;

    }

    if (s->ops->lstat(&s->ctx, &path, &stat)) {

        fprintf(stderr, ""share path %s does not exist\n"", fse->path);

        goto out;

    } else if (!S_ISDIR(stat.st_mode)) {

        fprintf(stderr, ""share path %s is not a directory\n"", fse->path);

        goto out;

    }

    v9fs_path_free(&path);



    return 0;

out:

    g_free(s->ctx.fs_root);

    g_free(s->tag);

    virtio_cleanup(vdev);

    v9fs_path_free(&path);



    return -1;



}
",686,,LABEL_1,LABEL_0,,-4,"vdev,s,i,len,stat,fse,path",,,,0,,0,Greedy,1,0.0008648514747619628,,
9,"static void test_qemu_strtoul_decimal(void)

{

    const char *str = ""0123"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 10, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));



    str = ""123"";

    res = 999;

    endptr = &f;

    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));

}
",141,"static void test_qemu_strtoul_decimal(void)

{

    const char *strip = ""0123"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(strip, &endptr, 10, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == strip + strlen(strip));



    strip = ""123"";

    res = 999;

    endptr = &f;

    err = qemu_strtoul(strip, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == strip + strlen(strip));

}
",LABEL_0,LABEL_0,LABEL_1,1,"str,endptr,err","str:0.0007339715957641602,endptr:0.0004341006278991699,err:0.0002796649932861328,",1,8,0,"str:strip,",0,Greedy,84,0.029918313026428223,replace,[]
10,"void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {

        QTAILQ_REMOVE(&spapr->pending_events, entry, next);

        g_free(entry->extended_log);

        g_free(entry);

    }

}
",55,,LABEL_0,LABEL_0,LABEL_0,-1,"spapr,entry",,2,8,0,,0,GA,496,0.1749220053354899,failed,[]
11,"static void hls_transform_tree(HEVCContext *s, int x0, int y0,

                               int xBase, int yBase, int cb_xBase, int cb_yBase,

                               int log2_cb_size, int log2_trafo_size,

                               int trafo_depth, int blk_idx)

{

    HEVCLocalContext *lc = &s->HEVClc;

    uint8_t split_transform_flag;



    if (trafo_depth > 0 && log2_trafo_size == 2) {

        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =

            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase);

        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =

            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase);

    } else {

        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =

        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) = 0;

    }



    if (lc->cu.intra_split_flag) {

        if (trafo_depth == 1)

            lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[blk_idx];

    } else {

        lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[0];

    }



    lc->tt.cbf_luma = 1;



    lc->tt.inter_split_flag = s->sps->max_transform_hierarchy_depth_inter == 0 &&

                              lc->cu.pred_mode == MODE_INTER &&

                              lc->cu.part_mode != PART_2Nx2N &&

                              trafo_depth == 0;



    if (log2_trafo_size <= s->sps->log2_max_trafo_size &&

        log2_trafo_size >  s->sps->log2_min_tb_size    &&

        trafo_depth     < lc->cu.max_trafo_depth       &&

        !(lc->cu.intra_split_flag && trafo_depth == 0)) {

        split_transform_flag = ff_hevc_split_transform_flag_decode(s, log2_trafo_size);

    } else {

        split_transform_flag = log2_trafo_size > s->sps->log2_max_trafo_size ||

                               (lc->cu.intra_split_flag && trafo_depth == 0) ||

                               lc->tt.inter_split_flag;

    }



    if (log2_trafo_size > 2) {

        if (trafo_depth == 0 ||

            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase)) {

            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =

                ff_hevc_cbf_cb_cr_decode(s, trafo_depth);

        }



        if (trafo_depth == 0 ||

            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase)) {

            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =

                ff_hevc_cbf_cb_cr_decode(s, trafo_depth);

        }

    }



    if (split_transform_flag) {

        int x1 = x0 + ((1 << log2_trafo_size) >> 1);

        int y1 = y0 + ((1 << log2_trafo_size) >> 1);



        hls_transform_tree(s, x0, y0, x0, y0, cb_xBase, cb_yBase, log2_cb_size,

                           log2_trafo_size - 1, trafo_depth + 1, 0);

        hls_transform_tree(s, x1, y0, x0, y0, cb_xBase, cb_yBase, log2_cb_size,

                           log2_trafo_size - 1, trafo_depth + 1, 1);

        hls_transform_tree(s, x0, y1, x0, y0, cb_xBase, cb_yBase, log2_cb_size,

                           log2_trafo_size - 1, trafo_depth + 1, 2);

        hls_transform_tree(s, x1, y1, x0, y0, cb_xBase, cb_yBase, log2_cb_size,

                           log2_trafo_size - 1, trafo_depth + 1, 3);

    } else {

        int min_tu_size      = 1 << s->sps->log2_min_tb_size;

        int log2_min_tu_size = s->sps->log2_min_tb_size;

        int min_tu_width     = s->sps->min_tb_width;



        if (lc->cu.pred_mode == MODE_INTRA || trafo_depth != 0 ||

            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) ||

            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0)) {

            lc->tt.cbf_luma = ff_hevc_cbf_luma_decode(s, trafo_depth);

        }



        hls_transform_unit(s, x0, y0, xBase, yBase, cb_xBase, cb_yBase,

                           log2_cb_size, log2_trafo_size, trafo_depth, blk_idx);



        // TODO: store cbf_luma somewhere else

        if (lc->tt.cbf_luma) {

            int i, j;

            for (i = 0; i < (1 << log2_trafo_size); i += min_tu_size)

                for (j = 0; j < (1 << log2_trafo_size); j += min_tu_size) {

                    int x_tu = (x0 + j) >> log2_min_tu_size;

                    int y_tu = (y0 + i) >> log2_min_tu_size;

                    s->cbf_luma[y_tu * min_tu_width + x_tu] = 1;

                }

        }

        if (!s->sh.disable_deblocking_filter_flag) {

            ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_trafo_size,

                                                  lc->slice_or_tiles_up_boundary,

                                                  lc->slice_or_tiles_left_boundary);

            if (s->pps->transquant_bypass_enable_flag &&

                lc->cu.cu_transquant_bypass_flag)

                set_deblocking_bypass(s, x0, y0, log2_trafo_size);

        }

    }

}
",927,"static void hls_transform_tree(HEVCContext *s, int x1, int y0,

                               int yZero, int yBase, int cb_wEnd, int cb_xScale,

                               int log2_cb_capacity, int log2_trafo_size,

                               int trafo_count, int blk_pidc)

{

    HEVCLocalContext *cs = &s->HEVClc;

    uint8_t split_transform_flag;



    if (trafo_count > 0 && log2_trafo_size == 2) {

        SAMPLE_CBF(cs->tt.cbf_cb[trafo_count], x1, y0) =

            SAMPLE_CBF(cs->tt.cbf_cb[trafo_count - 1], yZero, yBase);

        SAMPLE_CBF(cs->tt.cbf_cr[trafo_count], x1, y0) =

            SAMPLE_CBF(cs->tt.cbf_cr[trafo_count - 1], yZero, yBase);

    } else {

        SAMPLE_CBF(cs->tt.cbf_cb[trafo_count], x1, y0) =

        SAMPLE_CBF(cs->tt.cbf_cr[trafo_count], x1, y0) = 0;

    }



    if (cs->cu.intra_split_flag) {

        if (trafo_count == 1)

            lcs>tu.cur_intra_pred_mode = lcs>pu.intra_pred_mode[blk_pidc];

    } else {

        cs->tu.cur_intra_pred_mode = cs->pu.intra_pred_mode[0];

    }



    cs->tt.cbf_luma = 1;



    cs->tt.inter_split_flag = s->sps->max_transform_hierarchy_depth_inter == 0 &&

                              cs->cu.pred_mode == MODE_INTER &&

                              cs->cu.part_mode != PART_2Nx2N &&

                              trafo_count == 0;



    if (log2_trafo_size <= s->sps->log2_max_trafo_size &&

        log2_trafo_size >  s->sps->log2_min_tb_size    &&

        trafo_count     < cs->cu.max_trafo_depth       &&

        !(cs->cu.intra_split_flag && trafo_count == 0)) {

        split_transform_flag = ff_hevc_split_transform_flag_decode(s, log2_trafo_size);

    } else {

        split_transform_flag = log2_trafo_size > s->sps->log2_max_trafo_size ||

                               (cs->cu.intra_split_flag && trafo_count == 0) ||

                               cs->tt.inter_split_flag;

    }



    if (log2_trafo_size > 2) {

        if (trafo_count == 0 ||

            SAMPLE_CBF(cs->tt.cbf_cb[trafo_count - 1], yZero, yBase)) {

            SAMPLE_CBF(cs->tt.cbf_cb[trafo_count], x1, y0) =

                ff_hevc_cbf_cb_cr_decode(s, trafo_count);

        }



        if (trafo_count == 0 ||

            SAMPLE_CBF(cs->tt.cbf_cr[trafo_count - 1], yZero, yBase)) {

            SAMPLE_CBF(cs->tt.cbf_cr[trafo_count], x1, y0) =

                ff_hevc_cbf_cb_cr_decode(s, trafo_count);

        }

    }



    if (split_transform_flag) {

        int x1 = x1 + ((1 << log2_trafo_size) >> 1);

        int y1 = y0 + ((1 << log2_trafo_size) >> 1);



        hls_transform_tree(s, x1, y0, x1, y0, cb_wEnd, cb_xScale, log2_cb_capacity,

                           log2_trafo_size - 1, trafo_count + 1, 0);

        hls_transform_tree(s, x1, y0, x1, y0, cb_wEnd, cb_xScale, log2_cb_capacity,

                           log2_trafo_size - 1, trafo_count + 1, 1);

        hls_transform_tree(s, x1, y1, x1, y0, cb_wEnd, cb_xScale, log2_cb_capacity,

                           log2_trafo_size - 1, trafo_count + 1, 2);

        hls_transform_tree(s, x1, y1, x1, y0, cb_wEnd, cb_xScale, log2_cb_capacity,

                           log2_trafo_size - 1, trafo_count + 1, 3);

    } else {

        int min_tu_size      = 1 << s->sps->log2_min_tb_size;

        int log2_min_tu_size = s->sps->log2_min_tb_size;

        int min_tu_width     = s->sps->min_tb_width;



        if (cs->cu.pred_mode == MODE_INTRA || trafo_count != 0 ||

            SAMPLE_CBF(cs->tt.cbf_cb[trafo_count], x1, y0) ||

            SAMPLE_CBF(cs->tt.cbf_cr[trafo_count], x1, y0)) {

            cs->tt.cbf_luma = ff_hevc_cbf_luma_decode(s, trafo_count);

        }



        hls_transform_unit(s, x1, y0, yZero, yBase, cb_wEnd, cb_xScale,

                           log2_cb_capacity, log2_trafo_size, trafo_count, blk_pidc);



        // TODO: store cbf_luma somewhere else

        if (cs->tt.cbf_luma) {

            int i, j;

            for (i = 0; i < (1 << log2_trafo_size); i += min_tu_size)

                for (j = 0; j < (1 << log2_trafo_size); j += min_tu_size) {

                    int x_tu = (x1 + j) >> log2_min_tu_size;

                    int y_tu = (y0 + i) >> log2_min_tu_size;

                    s->cbf_luma[y_tu * min_tu_width + x_tu] = 1;

                }

        }

        if (!s->sh.disable_deblocking_filter_flag) {

            ff_hevc_deblocking_boundary_strengths(s, x1, y0, log2_trafo_size,

                                                  cs->slice_or_tiles_up_boundary,

                                                  cs->slice_or_tiles_left_boundary);

            if (s->pps->transquant_bypass_enable_flag &&

                cs->cu.cu_transquant_bypass_flag)

                set_deblocking_bypass(s, x1, y0, log2_trafo_size);

        }

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,x0,y0,xBase,yBase,cb_xBase,cb_yBase,log2_cb_size,log2_trafo_size,trafo_depth,blk_idx,lc,split_transform_flag",,13,179,70,"s:s,x0:x1,y0:y0,xBase:yZero,yBase:yBase,cb_xBase:cb_wEnd,cb_yBase:cb_xScale,log2_cb_size:log2_cb_capacity,log2_trafo_size:log2_trafo_size,trafo_depth:trafo_count,blk_idx:blk_pidc,lc:cs,split_transform_flag:split_transform_flag,",5,GA,919,0.4368077993392944,GA,[]
12,"static int RENAME(swScale)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,

             int srcSliceH, uint8_t* dst[], int dstStride[]){



	/* load a few things into local vars to make the code more readable? and faster */

	const int srcW= c->srcW;

	const int dstW= c->dstW;

	const int dstH= c->dstH;

	const int chrDstW= c->chrDstW;

	const int chrSrcW= c->chrSrcW;

	const int lumXInc= c->lumXInc;

	const int chrXInc= c->chrXInc;

	const int dstFormat= c->dstFormat;

	const int srcFormat= c->srcFormat;

	const int flags= c->flags;

	const int canMMX2BeUsed= c->canMMX2BeUsed;

	int16_t *vLumFilterPos= c->vLumFilterPos;

	int16_t *vChrFilterPos= c->vChrFilterPos;

	int16_t *hLumFilterPos= c->hLumFilterPos;

	int16_t *hChrFilterPos= c->hChrFilterPos;

	int16_t *vLumFilter= c->vLumFilter;

	int16_t *vChrFilter= c->vChrFilter;

	int16_t *hLumFilter= c->hLumFilter;

	int16_t *hChrFilter= c->hChrFilter;

	int32_t *lumMmxFilter= c->lumMmxFilter;

	int32_t *chrMmxFilter= c->chrMmxFilter;

	const int vLumFilterSize= c->vLumFilterSize;

	const int vChrFilterSize= c->vChrFilterSize;

	const int hLumFilterSize= c->hLumFilterSize;

	const int hChrFilterSize= c->hChrFilterSize;

	int16_t **lumPixBuf= c->lumPixBuf;

	int16_t **chrPixBuf= c->chrPixBuf;

	const int vLumBufSize= c->vLumBufSize;

	const int vChrBufSize= c->vChrBufSize;

	uint8_t *funnyYCode= c->funnyYCode;

	uint8_t *funnyUVCode= c->funnyUVCode;

	uint8_t *formatConvBuffer= c->formatConvBuffer;

	const int chrSrcSliceY= srcSliceY >> c->chrSrcVSubSample;

	const int chrSrcSliceH= -((-srcSliceH) >> c->chrSrcVSubSample);

	int lastDstY;

        uint8_t *pal=NULL;



	/* vars whch will change and which we need to storw back in the context */

	int dstY= c->dstY;

	int lumBufIndex= c->lumBufIndex;

	int chrBufIndex= c->chrBufIndex;

	int lastInLumBuf= c->lastInLumBuf;

	int lastInChrBuf= c->lastInChrBuf;

	

	if(isPacked(c->srcFormat)){

                pal= src[1];

		src[0]=

		src[1]=

		src[2]= src[0];

		srcStride[0]=

		srcStride[1]=

		srcStride[2]= srcStride[0];

	}

	srcStride[1]<<= c->vChrDrop;

	srcStride[2]<<= c->vChrDrop;



//	printf(""swscale %X %X %X -> %X %X %X\n"", (int)src[0], (int)src[1], (int)src[2],

//		(int)dst[0], (int)dst[1], (int)dst[2]);



#if 0 //self test FIXME move to a vfilter or something

{

static volatile int i=0;

i++;

if(srcFormat==PIX_FMT_YUV420P && i==1 && srcSliceH>= c->srcH)

	selfTest(src, srcStride, c->srcW, c->srcH);

i--;

}

#endif



//printf(""sws Strides:%d %d %d -> %d %d %d\n"", srcStride[0],srcStride[1],srcStride[2],

//dstStride[0],dstStride[1],dstStride[2]);



	if(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)

	{

		static int firstTime=1; //FIXME move this into the context perhaps

		if(flags & SWS_PRINT_INFO && firstTime)

		{

			av_log(c, AV_LOG_WARNING, ""SwScaler: Warning: dstStride is not aligned!\n""

					""SwScaler:          ->cannot do aligned memory acesses anymore\n"");

			firstTime=0;

		}

	}



	/* Note the user might start scaling the picture in the middle so this will not get executed

	   this is not really intended but works currently, so ppl might do it */

	if(srcSliceY ==0){

		lumBufIndex=0;

		chrBufIndex=0;

		dstY=0;	

		lastInLumBuf= -1;

		lastInChrBuf= -1;

	}



	lastDstY= dstY;



	for(;dstY < dstH; dstY++){

		unsigned char *dest =dst[0]+dstStride[0]*dstY;

		const int chrDstY= dstY>>c->chrDstVSubSample;

		unsigned char *uDest=dst[1]+dstStride[1]*chrDstY;

		unsigned char *vDest=dst[2]+dstStride[2]*chrDstY;



		const int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input

		const int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input

		const int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input

		const int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input



//printf(""dstY:%d dstH:%d firstLumSrcY:%d lastInLumBuf:%d vLumBufSize: %d vChrBufSize: %d slice: %d %d vLumFilterSize: %d firstChrSrcY: %d vChrFilterSize: %d c->chrSrcVSubSample: %d\n"",

// dstY, dstH, firstLumSrcY, lastInLumBuf, vLumBufSize, vChrBufSize, srcSliceY, srcSliceH, vLumFilterSize, firstChrSrcY, vChrFilterSize,  c->chrSrcVSubSample);

		//handle holes (FAST_BILINEAR & weird filters)

		if(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;

		if(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;

//printf(""%d %d %d\n"", firstChrSrcY, lastInChrBuf, vChrBufSize);

		ASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)

		ASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)



		// Do we have enough lines in this slice to output the dstY line

		if(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample))

		{

			//Do horizontal scaling

			while(lastInLumBuf < lastLumSrcY)

			{

				uint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];

				lumBufIndex++;

//				printf(""%d %d %d %d\n"", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);

				ASSERT(lumBufIndex < 2*vLumBufSize)

				ASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)

				ASSERT(lastInLumBuf + 1 - srcSliceY >= 0)

//				printf(""%d %d\n"", lumBufIndex, vLumBufSize);

				RENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,

						flags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,

						funnyYCode, c->srcFormat, formatConvBuffer, 

						c->lumMmx2Filter, c->lumMmx2FilterPos, pal);

				lastInLumBuf++;

			}

			while(lastInChrBuf < lastChrSrcY)

			{

				uint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];

				uint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];

				chrBufIndex++;

				ASSERT(chrBufIndex < 2*vChrBufSize)

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH))

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)

				//FIXME replace parameters through context struct (some at least)



				if(!(isGray(srcFormat) || isGray(dstFormat)))

					RENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,

						flags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,

						funnyUVCode, c->srcFormat, formatConvBuffer, 

						c->chrMmx2Filter, c->chrMmx2FilterPos, pal);

				lastInChrBuf++;

			}

			//wrap buf index around to stay inside the ring buffer

			if(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;

			if(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;

		}

		else // not enough lines left in this slice -> load the rest in the buffer

		{

/*		printf(""%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\n"",

			firstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,

			lastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,

			vChrBufSize, vLumBufSize);*/



			//Do horizontal scaling

			while(lastInLumBuf+1 < srcSliceY + srcSliceH)

			{

				uint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];

				lumBufIndex++;

				ASSERT(lumBufIndex < 2*vLumBufSize)

				ASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)

				ASSERT(lastInLumBuf + 1 - srcSliceY >= 0)

				RENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,

						flags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,

						funnyYCode, c->srcFormat, formatConvBuffer, 

						c->lumMmx2Filter, c->lumMmx2FilterPos, pal);

				lastInLumBuf++;

			}

			while(lastInChrBuf+1 < (chrSrcSliceY + chrSrcSliceH))

			{

				uint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];

				uint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];

				chrBufIndex++;

				ASSERT(chrBufIndex < 2*vChrBufSize)

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY < chrSrcSliceH)

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)



				if(!(isGray(srcFormat) || isGray(dstFormat)))

					RENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,

						flags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,

						funnyUVCode, c->srcFormat, formatConvBuffer, 

						c->chrMmx2Filter, c->chrMmx2FilterPos, pal);

				lastInChrBuf++;

			}

			//wrap buf index around to stay inside the ring buffer

			if(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;

			if(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;

			break; //we can't output a dstY line so let's try with the next slice

		}



#ifdef HAVE_MMX

		b5Dither= dither8[dstY&1];

		g6Dither= dither4[dstY&1];

		g5Dither= dither8[dstY&1];

		r5Dither= dither8[(dstY+1)&1];

#endif

	    if(dstY < dstH-2)

	    {

		int16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;

		int16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;

#ifdef HAVE_MMX

		int i;

            if(flags & SWS_ACCURATE_RND){

                        for(i=0; i<vLumFilterSize; i+=2){

                                lumMmxFilter[2*i+0]= (int32_t)lumSrcPtr[i  ];

                                lumMmxFilter[2*i+1]= (int32_t)lumSrcPtr[i+(vLumFilterSize>1)];

                                lumMmxFilter[2*i+2]=

                                lumMmxFilter[2*i+3]= vLumFilter[dstY*vLumFilterSize + i    ]

                                                + (vLumFilterSize>1 ? vLumFilter[dstY*vLumFilterSize + i + 1]<<16 : 0);

                        }

                        for(i=0; i<vChrFilterSize; i+=2){

                                chrMmxFilter[2*i+0]= (int32_t)chrSrcPtr[i  ];

                                chrMmxFilter[2*i+1]= (int32_t)chrSrcPtr[i+(vChrFilterSize>1)];

                                chrMmxFilter[2*i+2]=

                                chrMmxFilter[2*i+3]= vChrFilter[chrDstY*vChrFilterSize + i    ]

                                                + (vChrFilterSize>1 ? vChrFilter[chrDstY*vChrFilterSize + i + 1]<<16 : 0);

                        }

            }else{

		for(i=0; i<vLumFilterSize; i++)

		{

			lumMmxFilter[4*i+0]= (int32_t)lumSrcPtr[i];

			lumMmxFilter[4*i+1]= (uint64_t)lumSrcPtr[i] >> 32;

			lumMmxFilter[4*i+2]= 

			lumMmxFilter[4*i+3]= 

				((uint16_t)vLumFilter[dstY*vLumFilterSize + i])*0x10001;

		}

		for(i=0; i<vChrFilterSize; i++)

		{

			chrMmxFilter[4*i+0]= (int32_t)chrSrcPtr[i];


			chrMmxFilter[4*i+2]= 

			chrMmxFilter[4*i+3]= 

				((uint16_t)vChrFilter[chrDstY*vChrFilterSize + i])*0x10001;

		}

            }

#endif

		if(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){

			const int chrSkipMask= (1<<c->chrDstVSubSample)-1;

			if(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi

			RENAME(yuv2nv12X)(c,

				vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

				vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, uDest, dstW, chrDstW, dstFormat);

		}

		else if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12 like

		{

			const int chrSkipMask= (1<<c->chrDstVSubSample)-1;

			if((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi

			if(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12

			{

				int16_t *lumBuf = lumPixBuf[0];

				int16_t *chrBuf= chrPixBuf[0];

				RENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW, chrDstW);

			}

			else //General YV12

			{

				RENAME(yuv2yuvX)(c,

					vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

					vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

					dest, uDest, vDest, dstW, chrDstW);

			}

		}

		else

		{

			ASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);

			ASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);

			if(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB

			{

				int chrAlpha= vChrFilter[2*dstY+1];

				RENAME(yuv2packed1)(c, *lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),

						 dest, dstW, chrAlpha, dstFormat, flags, dstY);

			}

			else if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB

			{

				int lumAlpha= vLumFilter[2*dstY+1];

				int chrAlpha= vChrFilter[2*dstY+1];

                                lumMmxFilter[2]=

                                lumMmxFilter[3]= vLumFilter[2*dstY   ]*0x10001;

                                chrMmxFilter[2]=

                                chrMmxFilter[3]= vChrFilter[2*chrDstY]*0x10001;

				RENAME(yuv2packed2)(c, *lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),

						 dest, dstW, lumAlpha, chrAlpha, dstY);

			}

			else //General RGB

			{

				RENAME(yuv2packedX)(c,

					vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,

					vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

					dest, dstW, dstY);

			}

		}

            }

	    else // hmm looks like we can't use MMX here without overwriting this array's tail

	    {

		int16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;

		int16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;

		if(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){

			const int chrSkipMask= (1<<c->chrDstVSubSample)-1;

			if(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi

			yuv2nv12XinC(

				vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

				vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, uDest, dstW, chrDstW, dstFormat);

		}

		else if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12

		{

			const int chrSkipMask= (1<<c->chrDstVSubSample)-1;

			if((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi

			yuv2yuvXinC(

				vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

				vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, uDest, vDest, dstW, chrDstW);

		}

		else

		{

			ASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);

			ASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);

			yuv2packedXinC(c, 

				vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,

				vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, dstW, dstY);

		}

	    }

	}



#ifdef HAVE_MMX

	__asm __volatile(SFENCE:::""memory"");

	__asm __volatile(EMMS:::""memory"");

#endif

	/* store changed local vars back in the context */

	c->dstY= dstY;

	c->lumBufIndex= lumBufIndex;

	c->chrBufIndex= chrBufIndex;

	c->lastInLumBuf= lastInLumBuf;

	c->lastInChrBuf= lastInChrBuf;



	return dstY - lastDstY;

}",3275,"static int RENAME(swScale)(SwsContext *ct, uint8_t* sync[], int srcStride[], int srcSliceY,

             int srcSliceH, uint8_t* dst[], int dstStride[]){



	/* load a few things into local vars to make the code more readable? and faster */

	const int srcW= ct->srcW;

	const int dstW= ct->dstW;

	const int dstH= ct->dstH;

	const int chrDstW= ct->chrDstW;

	const int chrSrcW= ct->chrSrcW;

	const int lumXInc= ct->lumXInc;

	const int chrXInc= ct->chrXInc;

	const int dstFormat= ct->dstFormat;

	const int srcFormat= ct->srcFormat;

	const int flags= ct->flags;

	const int canMMX2BeUsed= ct->canMMX2BeUsed;

	int16_t *vLumFilterPos= ct->vLumFilterPos;

	int16_t *vChrFilterPos= ct->vChrFilterPos;

	int16_t *hLumFilterPos= ct->hLumFilterPos;

	int16_t *hChrFilterPos= ct->hChrFilterPos;

	int16_t *vLumFilter= ct->vLumFilter;

	int16_t *vChrFilter= ct->vChrFilter;

	int16_t *hLumFilter= ct->hLumFilter;

	int16_t *hChrFilter= ct->hChrFilter;

	int32_t *lumMmxFilter= ct->lumMmxFilter;

	int32_t *chrMmxFilter= ct->chrMmxFilter;

	const int vLumFilterSize= ct->vLumFilterSize;

	const int vChrFilterSize= ct->vChrFilterSize;

	const int hLumFilterSize= ct->hLumFilterSize;

	const int hChrFilterSize= ct->hChrFilterSize;

	int16_t **lumPixBuf= ct->lumPixBuf;

	int16_t **chrPixBuf= ct->chrPixBuf;

	const int vLumBufSize= ct->vLumBufSize;

	const int vChrBufSize= ct->vChrBufSize;

	uint8_t *funnyYCode= ct->funnyYCode;

	uint8_t *funnyUVCode= ct->funnyUVCode;

	uint8_t *formatConvBuffer= ct->formatConvBuffer;

	const int chrSrcSliceY= srcSliceY >> ct->chrSrcVSubSample;

	const int chrSrcSliceH= -((-srcSliceH) >> ct->chrSrcVSubSample);

	int lastDstY;

        uint8_t *pal=NULL;



	/* vars whch will change and which we need to storw back in the context */

	int dstY= ct->dstY;

	int lumBufIndex= ct->lumBufIndex;

	int chrBufIndex= ct->chrBufIndex;

	int lastInLumBuf= ct->lastInLumBuf;

	int lastInChrBuf= ct->lastInChrBuf;

	

	if(isPacked(ct->srcFormat)){

                pal= sync[1];

		sync[0]=

		sync[1]=

		sync[2]= sync[0];

		srcStride[0]=

		srcStride[1]=

		srcStride[2]= srcStride[0];

	}

	srcStride[1]<<= ct->vChrDrop;

	srcStride[2]<<= ct->vChrDrop;



//	printf(""swscale %X %X %X -> %X %X %X
"", (int)sync[0], (int)sync[1], (int)sync[2],

//		(int)dst[0], (int)dst[1], (int)dst[2]);



#if 0 //self test FIXME move to a vfilter or something

{

static volatile int i=0;

i++;

if(srcFormat==PIX_FMT_YUV420P && i==1 && srcSliceH>= ct->srcH)

	selfTest(sync, srcStride, ct->srcW, ct->srcH);

i--;

}

#endif



//printf(""sws Strides:%d %d %d -> %d %d %d
"", srcStride[0],srcStride[1],srcStride[2],

//dstStride[0],dstStride[1],dstStride[2]);



	if(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)

	{

		static int firstTime=1; //FIXME move this into the context perhaps

		if(flags & SWS_PRINT_INFO && firstTime)

		{

			av_log(ct, AV_LOG_WARNING, ""SwScaler: Warning: dstStride is not aligned!
""

					""SwScaler:          ->cannot do aligned memory acesses anymore
"");

			firstTime=0;

		}

	}



	/* Note the user might start scaling the picture in the middle so this will not get executed

	   this is not really intended but works currently, so ppl might do it */

	if(srcSliceY ==0){

		lumBufIndex=0;

		chrBufIndex=0;

		dstY=0;	

		lastInLumBuf= -1;

		lastInChrBuf= -1;

	}



	lastDstY= dstY;



	for(;dstY < dstH; dstY++){

		unsigned char *dest =dst[0]+dstStride[0]*dstY;

		const int chrDstY= dstY>>ct->chrDstVSubSample;

		unsigned char *uDest=dst[1]+dstStride[1]*chrDstY;

		unsigned char *vDest=dst[2]+dstStride[2]*chrDstY;



		const int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input

		const int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input

		const int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input

		const int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input



//printf(""dstY:%d dstH:%d firstLumSrcY:%d lastInLumBuf:%d vLumBufSize: %d vChrBufSize: %d slice: %d %d vLumFilterSize: %d firstChrSrcY: %d vChrFilterSize: %d ct->chrSrcVSubSample: %d
"",

// dstY, dstH, firstLumSrcY, lastInLumBuf, vLumBufSize, vChrBufSize, srcSliceY, srcSliceH, vLumFilterSize, firstChrSrcY, vChrFilterSize,  ct->chrSrcVSubSample);

		//handle holes (FAST_BILINEAR & weird filters)

		if(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;

		if(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;

//printf(""%d %d %d
"", firstChrSrcY, lastInChrBuf, vChrBufSize);

		ASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)

		ASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)



		// Do we have enough lines in this slice to output the dstY line

		if(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>ct->chrSrcVSubSample))

		{

			//Do horizontal scaling

			while(lastInLumBuf < lastLumSrcY)

			{

				uint8_t *s= sync[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];

				lumBufIndex++;

//				printf(""%d %d %d %d
"", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);

				ASSERT(lumBufIndex < 2*vLumBufSize)

				ASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)

				ASSERT(lastInLumBuf + 1 - srcSliceY >= 0)

//				printf(""%d %d
"", lumBufIndex, vLumBufSize);

				RENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,

						flags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,

						funnyYCode, ct->srcFormat, formatConvBuffer, 

						ct->lumMmx2Filter, ct->lumMmx2FilterPos, pal);

				lastInLumBuf++;

			}

			while(lastInChrBuf < lastChrSrcY)

			{

				uint8_t *src1= sync[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];

				uint8_t *src2= sync[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];

				chrBufIndex++;

				ASSERT(chrBufIndex < 2*vChrBufSize)

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH))

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)

				//FIXME replace parameters through context struct (some at least)



				if(!(isGray(srcFormat) || isGray(dstFormat)))

					RENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,

						flags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,

						funnyUVCode, ct->srcFormat, formatConvBuffer, 

						ct->chrMmx2Filter, ct->chrMmx2FilterPos, pal);

				lastInChrBuf++;

			}

			//wrap buf index around to stay inside the ring buffer

			if(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;

			if(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;

		}

		else // not enough lines left in this slice -> load the rest in the buffer

		{

/*		printf(""%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d
"",

			firstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,

			lastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,

			vChrBufSize, vLumBufSize);*/



			//Do horizontal scaling

			while(lastInLumBuf+1 < srcSliceY + srcSliceH)

			{

				uint8_t *s= sync[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];

				lumBufIndex++;

				ASSERT(lumBufIndex < 2*vLumBufSize)

				ASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)

				ASSERT(lastInLumBuf + 1 - srcSliceY >= 0)

				RENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,

						flags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,

						funnyYCode, ct->srcFormat, formatConvBuffer, 

						ct->lumMmx2Filter, ct->lumMmx2FilterPos, pal);

				lastInLumBuf++;

			}

			while(lastInChrBuf+1 < (chrSrcSliceY + chrSrcSliceH))

			{

				uint8_t *src1= sync[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];

				uint8_t *src2= sync[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];

				chrBufIndex++;

				ASSERT(chrBufIndex < 2*vChrBufSize)

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY < chrSrcSliceH)

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)



				if(!(isGray(srcFormat) || isGray(dstFormat)))

					RENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,

						flags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,

						funnyUVCode, ct->srcFormat, formatConvBuffer, 

						ct->chrMmx2Filter, ct->chrMmx2FilterPos, pal);

				lastInChrBuf++;

			}

			//wrap buf index around to stay inside the ring buffer

			if(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;

			if(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;

			break; //we can't output a dstY line so let's try with the next slice

		}



#ifdef HAVE_MMX

		b5Dither= dither8[dstY&1];

		g6Dither= dither4[dstY&1];

		g5Dither= dither8[dstY&1];

		r5Dither= dither8[(dstY+1)&1];

#endif

	    if(dstY < dstH-2)

	    {

		int16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;

		int16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;

#ifdef HAVE_MMX

		int i;

            if(flags & SWS_ACCURATE_RND){

                        for(i=0; i<vLumFilterSize; i+=2){

                                lumMmxFilter[2*i+0]= (int32_t)lumSrcPtr[i  ];

                                lumMmxFilter[2*i+1]= (int32_t)lumSrcPtr[i+(vLumFilterSize>1)];

                                lumMmxFilter[2*i+2]=

                                lumMmxFilter[2*i+3]= vLumFilter[dstY*vLumFilterSize + i    ]

                                                + (vLumFilterSize>1 ? vLumFilter[dstY*vLumFilterSize + i + 1]<<16 : 0);

                        }

                        for(i=0; i<vChrFilterSize; i+=2){

                                chrMmxFilter[2*i+0]= (int32_t)chrSrcPtr[i  ];

                                chrMmxFilter[2*i+1]= (int32_t)chrSrcPtr[i+(vChrFilterSize>1)];

                                chrMmxFilter[2*i+2]=

                                chrMmxFilter[2*i+3]= vChrFilter[chrDstY*vChrFilterSize + i    ]

                                                + (vChrFilterSize>1 ? vChrFilter[chrDstY*vChrFilterSize + i + 1]<<16 : 0);

                        }

            }else{

		for(i=0; i<vLumFilterSize; i++)

		{

			lumMmxFilter[4*i+0]= (int32_t)lumSrcPtr[i];

			lumMmxFilter[4*i+1]= (uint64_t)lumSrcPtr[i] >> 32;

			lumMmxFilter[4*i+2]= 

			lumMmxFilter[4*i+3]= 

				((uint16_t)vLumFilter[dstY*vLumFilterSize + i])*0x10001;

		}

		for(i=0; i<vChrFilterSize; i++)

		{

			chrMmxFilter[4*i+0]= (int32_t)chrSrcPtr[i];


			chrMmxFilter[4*i+2]= 

			chrMmxFilter[4*i+3]= 

				((uint16_t)vChrFilter[chrDstY*vChrFilterSize + i])*0x10001;

		}

            }

#endif

		if(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){

			const int chrSkipMask= (1<<ct->chrDstVSubSample)-1;

			if(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi

			RENAME(yuv2nv12X)(ct,

				vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

				vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, uDest, dstW, chrDstW, dstFormat);

		}

		else if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12 like

		{

			const int chrSkipMask= (1<<ct->chrDstVSubSample)-1;

			if((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi

			if(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12

			{

				int16_t *lumBuf = lumPixBuf[0];

				int16_t *chrBuf= chrPixBuf[0];

				RENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW, chrDstW);

			}

			else //General YV12

			{

				RENAME(yuv2yuvX)(ct,

					vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

					vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

					dest, uDest, vDest, dstW, chrDstW);

			}

		}

		else

		{

			ASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);

			ASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);

			if(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB

			{

				int chrAlpha= vChrFilter[2*dstY+1];

				RENAME(yuv2packed1)(ct, *lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),

						 dest, dstW, chrAlpha, dstFormat, flags, dstY);

			}

			else if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB

			{

				int lumAlpha= vLumFilter[2*dstY+1];

				int chrAlpha= vChrFilter[2*dstY+1];

                                lumMmxFilter[2]=

                                lumMmxFilter[3]= vLumFilter[2*dstY   ]*0x10001;

                                chrMmxFilter[2]=

                                chrMmxFilter[3]= vChrFilter[2*chrDstY]*0x10001;

				RENAME(yuv2packed2)(ct, *lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),

						 dest, dstW, lumAlpha, chrAlpha, dstY);

			}

			else //General RGB

			{

				RENAME(yuv2packedX)(ct,

					vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,

					vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

					dest, dstW, dstY);

			}

		}

            }

	    else // hmm looks like we can't use MMX here without overwriting this array's tail

	    {

		int16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;

		int16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;

		if(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){

			const int chrSkipMask= (1<<ct->chrDstVSubSample)-1;

			if(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi

			yuv2nv12XinC(

				vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

				vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, uDest, dstW, chrDstW, dstFormat);

		}

		else if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12

		{

			const int chrSkipMask= (1<<ct->chrDstVSubSample)-1;

			if((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi

			yuv2yuvXinC(

				vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

				vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, uDest, vDest, dstW, chrDstW);

		}

		else

		{

			ASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);

			ASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);

			yuv2packedXinC(ct, 

				vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,

				vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, dstW, dstY);

		}

	    }

	}



#ifdef HAVE_MMX

	__asm __volatile(SFENCE:::""memory"");

	__asm __volatile(EMMS:::""memory"");

#endif

	/* store changed local vars back in the context */

	ct->dstY= dstY;

	ct->lumBufIndex= lumBufIndex;

	ct->chrBufIndex= chrBufIndex;

	ct->lastInLumBuf= lastInLumBuf;

	ct->lastInChrBuf= lastInChrBuf;



	return dstY - lastDstY;

}",LABEL_1,LABEL_1,LABEL_0,1,"c,src,srcStride,srcSliceY,srcSliceH,dst,dstStride,vLumFilterPos,vChrFilterPos,hLumFilterPos,hChrFilterPos,vLumFilter,vChrFilter,hLumFilter,hChrFilter,lumMmxFilter,chrMmxFilter,lumPixBuf,chrPixBuf","c:4.913962423801422,src:1.07491797208786,srcStride:-0.02532142400741577,srcSliceY:0.057016074657440186,srcSliceH:0.09343969821929932,dst:0.4302484393119812,dstStride:0.003497779369354248,vLumFilterPos:-0.02316761016845703,vChrFilterPos:-0.024267256259918213,hLumFilterPos:-0.02377927303314209,hChrFilterPos:-0.024604320526123047,vLumFilter:0.06129312515258789,vChrFilter:0.06178450584411621,hLumFilter:0.060180485248565674,hChrFilter:0.06083470582962036,lumMmxFilter:0.061817944049835205,chrMmxFilter:-0.020549535751342773,lumPixBuf:-0.019047021865844727,chrPixBuf:0.012618958950042725,",2,94,0,"c:ct,src:sync,",0,Greedy,330,0.2019041339556376,replace,[]
13,"static int amr_nb_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,

                               const AVFrame *frame, int *got_packet_ptr)

{

    AMRContext *s = avctx->priv_data;

    int written, ret;

    int16_t *flush_buf = NULL;

    const int16_t *samples = frame ? (const int16_t *)frame->data[0] : NULL;



    if (s->enc_bitrate != avctx->bit_rate) {

        s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);

        s->enc_bitrate = avctx->bit_rate;

    }



    if ((ret = ff_alloc_packet(avpkt, 32))) {

        av_log(avctx, AV_LOG_ERROR, ""Error getting output packet\n"");

        return ret;

    }



    if (frame) {

        if (frame->nb_samples < avctx->frame_size) {

            flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));

            if (!flush_buf)

                return AVERROR(ENOMEM);

            memcpy(flush_buf, samples, frame->nb_samples * sizeof(*flush_buf));

            samples = flush_buf;

            if (frame->nb_samples < avctx->frame_size - avctx->delay)

                s->enc_last_frame = -1;

        }

        if ((ret = ff_af_queue_add(&s->afq, frame)) < 0) {

            av_freep(&flush_buf);

            return ret;

        }

    } else {

        if (s->enc_last_frame < 0)

            return 0;

        flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));

        if (!flush_buf)

            return AVERROR(ENOMEM);

        samples = flush_buf;

        s->enc_last_frame = -1;

    }



    written = Encoder_Interface_Encode(s->enc_state, s->enc_mode, samples,

                                       avpkt->data, 0);

    av_dlog(avctx, ""amr_nb_encode_frame encoded %u bytes, bitrate %u, first byte was %#02x\n"",

            written, s->enc_mode, frame[0]);



    /* Get the next frame pts/duration */

    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,

                       &avpkt->duration);



    avpkt->size = written;

    *got_packet_ptr = 1;

    av_freep(&flush_buf);

    return 0;

}
",426,,LABEL_0,LABEL_1,,-4,"avctx,avpkt,frame,got_packet_ptr,s,written,ret,flush_buf,samples",,,,0,,0,Greedy,1,0.0006674846013387044,,
14,"void ppc_store_xer (CPUPPCState *env, uint32_t value)

{

    xer_so = (value >> XER_SO) & 0x01;

    xer_ov = (value >> XER_OV) & 0x01;

    xer_ca = (value >> XER_CA) & 0x01;

    xer_cmp = (value >> XER_CMP) & 0xFF;

    xer_bc = (value >> XER_BC) & 0x3F;

}
",63,"void ppc_store_xer (CPUPPCState *env, uint32_t feature)

{

    xer_so = (feature >> XER_SO) & 0x01;

    xer_ov = (feature >> XER_OV) & 0x01;

    xer_ca = (feature >> XER_CA) & 0x01;

    xer_cmp = (feature >> XER_CMP) & 0xFF;

    xer_bc = (feature >> XER_BC) & 0x3F;

}
",LABEL_1,LABEL_1,LABEL_0,1,"env,value","env:-1.609325408935547e-05,value:-2.384185791015625e-07,",1,6,0,"value:feature,",0,Greedy,77,0.02689510981241862,replace,[]
15,"int scsi_bus_legacy_handle_cmdline(SCSIBus *bus)

{

    Location loc;

    DriveInfo *dinfo;

    int res = 0, unit;



    loc_push_none(&loc);

    for (unit = 0; unit < bus->info->max_target; unit++) {

        dinfo = drive_get(IF_SCSI, bus->busnr, unit);

        if (dinfo == NULL) {

            continue;

        }

        qemu_opts_loc_restore(dinfo->opts);

        if (!scsi_bus_legacy_add_drive(bus, dinfo->bdrv, unit, false, -1)) {

            res = -1;

            break;

        }

    }

    loc_pop(&loc);

    return res;

}
",122,,LABEL_1,LABEL_0,,-4,"bus,loc,dinfo,unit",,,,0,,0,Greedy,1,0.0004946668942769368,,
16,"block_crypto_create_opts_init(QCryptoBlockFormat format,

                              QemuOpts *opts,

                              Error **errp)

{

    OptsVisitor *ov;

    QCryptoBlockCreateOptions *ret = NULL;

    Error *local_err = NULL;



    ret = g_new0(QCryptoBlockCreateOptions, 1);

    ret->format = format;



    ov = opts_visitor_new(opts);



    visit_start_struct(opts_get_visitor(ov),

                       NULL, NULL, 0, &local_err);

    if (local_err) {

        goto out;

    }



    switch (format) {

    case Q_CRYPTO_BLOCK_FORMAT_LUKS:

        visit_type_QCryptoBlockCreateOptionsLUKS_members(

            opts_get_visitor(ov), &ret->u.luks, &local_err);

        break;



    default:

        error_setg(&local_err, ""Unsupported block format %d"", format);

        break;

    }

    error_propagate(errp, local_err);

    local_err = NULL;



    visit_end_struct(opts_get_visitor(ov), &local_err);



 out:

    if (local_err) {

        error_propagate(errp, local_err);

        qapi_free_QCryptoBlockCreateOptions(ret);

        ret = NULL;

    }

    opts_visitor_cleanup(ov);

    return ret;

}
",182,,LABEL_1,LABEL_0,,-4,"format,QemuOpts,ov,ret,local_err",,,,0,,0,Greedy,1,0.0005378007888793945,,
17,"void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)

{

    int bits = 8, sign = 0, shift = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    info->freq = as->freq;

    info->bits = bits;

    info->sign = sign;

    info->nchannels = as->nchannels;

    info->shift = (as->nchannels == 2) + shift;

    info->align = (1 << info->shift) - 1;

    info->bytes_per_second = info->freq << info->shift;

    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);

}
",181,"void audio_pcm_init_info (struct audio_pcm_info *inf, audsettings_t *as)

{

    int bits = 8, sign = 0, shift = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    inf->freq = as->freq;

    inf->bits = bits;

    inf->sign = sign;

    inf->nchannels = as->nchannels;

    inf->shift = (as->nchannels == 2) + shift;

    inf->align = (1 << inf->shift) - 1;

    inf->bytes_per_second = inf->freq << inf->shift;

    inf->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);

}
",LABEL_0,LABEL_0,LABEL_1,1,"info,as","info:0.0007820725440979004,as:0.0006589889526367188,",1,12,0,"info:inf,",0,Greedy,96,0.035017462571461995,replace,[]
18,"static void show_packets(AVFormatContext *fmt_ctx)

{

    AVPacket pkt;



    av_init_packet(&pkt);

    probe_array_header(""packets"", 0);

    while (!av_read_frame(fmt_ctx, &pkt))

        show_packet(fmt_ctx, &pkt);

    probe_array_footer(""packets"", 0);

}
",53,,LABEL_1,LABEL_0,,-4,"fmt_ctx,pkt",,,,0,,0,Greedy,1,0.0004531701405843099,,
19,"static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)

{

    int i, k, sb = 0;

    int msb = sbr->k[0];

    int usb = sbr->kx[1];

    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;



    sbr->num_patches = 0;



    if (goal_sb < sbr->kx[1] + sbr->m[1]) {

        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;

    } else

        k = sbr->n_master;



    do {

        int odd = 0;

        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {

            sb = sbr->f_master[i];

            odd = (sb + sbr->k[0]) & 1;

        }



        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);

        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];



        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {

            usb = sb;

            msb = sb;

            sbr->num_patches++;

        } else

            msb = sbr->kx[1];



        if (sbr->f_master[k] - sb < 3)

            k = sbr->n_master;

    } while (sb != sbr->kx[1] + sbr->m[1]);



    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)

        sbr->num_patches--;



    // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5

    // However the Coding Technologies decoder check uses 6 patches

    if (sbr->num_patches > 6) {

        av_log(ac->avccontext, AV_LOG_ERROR, ""Too many patches: %d\n"", sbr->num_patches);

        return -1;

    }



    return 0;

}
",433,,LABEL_1,LABEL_0,,-4,"ac,sbr,i,k,num_patches",,,,0,,0,Greedy,1,0.0006741960843404134,,
20,"static void colo_process_checkpoint(MigrationState *s)
{
    QIOChannelBuffer *bioc;
    QEMUFile *fb = NULL;
    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
    Error *local_err = NULL;
    int ret;
    failover_init_state();
    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);
    if (!s->rp_state.from_dst_file) {
        error_report(""Open QEMUFile from_dst_file failed"");
    /*
     * Wait for Secondary finish loading VM states and enter COLO
     * restore.
     */
    colo_receive_check_message(s->rp_state.from_dst_file,
                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);
    if (local_err) {
    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);
    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));
    object_unref(OBJECT(bioc));
    qemu_mutex_lock_iothread();
    vm_start();
    qemu_mutex_unlock_iothread();
    trace_colo_vm_state_change(""stop"", ""run"");
    while (s->state == MIGRATION_STATUS_COLO) {
        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
        if (current_time - checkpoint_time <
            s->parameters.x_checkpoint_delay) {
            int64_t delay_ms;
            delay_ms = s->parameters.x_checkpoint_delay -
                       (current_time - checkpoint_time);
            g_usleep(delay_ms * 1000);
        ret = colo_do_checkpoint_transaction(s, bioc, fb);
        if (ret < 0) {
        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
out:
    /* Throw the unreported error message after exited from loop */
    if (local_err) {
        error_report_err(local_err);
    if (fb) {
        qemu_fclose(fb);
    if (s->rp_state.from_dst_file) {
        qemu_fclose(s->rp_state.from_dst_file);",290,,LABEL_1,LABEL_1,LABEL_1,-1,"s,bioc,fb,current_time,local_err,ret,delay_ms",,7,35,0,,0,GA,1494,0.5869342605272929,failed,[]
21,"int usb_packet_map(USBPacket *p, QEMUSGList *sgl)

{

    int is_write = (p->pid == USB_TOKEN_IN);

    target_phys_addr_t len;

    void *mem;

    int i;



    for (i = 0; i < sgl->nsg; i++) {

        len = sgl->sg[i].len;

        mem = cpu_physical_memory_map(sgl->sg[i].base, &len,

                                      is_write);

        if (!mem) {

            goto err;

        }

        qemu_iovec_add(&p->iov, mem, len);

        if (len != sgl->sg[i].len) {

            goto err;

        }

    }

    return 0;



err:

    usb_packet_unmap(p);

    return -1;

}
",143,,LABEL_1,LABEL_0,,-4,"p,sgl,len,mem,i",,,,0,,0,Greedy,1,0.0005120674769083659,,
22,"static inline void RENAME(bgr24ToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)

{

#if COMPILE_TEMPLATE_MMX

    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_BGR24);

#else

    int i;

    for (i=0; i<width; i++) {

        int b= src[i*3+0];

        int g= src[i*3+1];

        int r= src[i*3+2];



        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);

    }

#endif /* COMPILE_TEMPLATE_MMX */

}
",129,,LABEL_1,LABEL_0,,-4,"dst,src,unused,i",,,,0,,0,Greedy,1,0.0004870891571044922,,
23,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *out,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float lambda, const float uplim,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
",126,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *update,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float LA, const float Uplime,

                                                         int *bits, const float ROUNDING) {

    int uni;

    if (bits)

        *bits = 0;

    if (update) {

        for (uni = 0; uni < size; uni += 4) {

           update[uni  ] = 0.0f;

           update[uni+1] = 0.0f;

           update[uni+2] = 0.0f;

           update[uni+3] = 0.0f;

        }

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,pb,in,out,scaled,size,scale_idx,cb,lambda,uplim,bits,ROUNDING,i","s:1.1920928955078125e-05,pb:1.0251998901367188e-05,in:2.0742416381835938e-05,out:0.0004044771194458008,scaled:2.8252601623535156e-05,size:6.961822509765625e-05,scale_idx:5.161762237548828e-05,cb:7.510185241699219e-06,lambda:0.00021350383758544922,uplim:9.870529174804688e-05,bits:8.559226989746094e-05,ROUNDING:6.42538070678711e-05,i:0.0005074739456176758,",4,16,0,"i:uni,out:update,lambda:LA,uplim:Uplime,",0,Greedy,209,0.0756641427675883,replace,[]
24,"rdt_free_extradata (PayloadContext *rdt)

{

    int i;



    for (i = 0; i < MAX_STREAMS; i++)

        if (rdt->rmst[i]) {

            ff_rm_free_rmstream(rdt->rmst[i]);

            av_freep(&rdt->rmst[i]);

        }

    if (rdt->rmctx)

        av_close_input_stream(rdt->rmctx);

    av_freep(&rdt->mlti_data);

    av_free(rdt);

}
",89,"rdt_free_extradata (PayloadContext *rdt)

{

    int di;



    for (di = 0; di < MAX_STREAMS; di++)

        if (rdt->rmst[di]) {

            ff_rm_free_rmstream(rdt->rmst[di]);

            av_freep(&rdt->rmst[di]);

        }

    if (rdt->rmctx)

        av_close_input_stream(rdt->rmctx);

    av_freep(&rdt->mlti_data);

    av_free(rdt);

}
",LABEL_0,LABEL_0,LABEL_1,1,i,"i:0.0010726451873779297,",1,7,0,"i:di,",0,Greedy,65,0.023253329594930015,replace,[]
25,"static int img_write_packet(AVFormatContext *s, int stream_index,

                            UINT8 *buf, int size)

{

    VideoData *img = s->priv_data;

    AVStream *st = s->streams[stream_index];

    ByteIOContext pb1, *pb;

    AVPicture picture;

    int width, height, ret, size1;

    char filename[1024];



    width = st->codec.width;

    height = st->codec.height;



    switch(st->codec.pix_fmt) {

    case PIX_FMT_YUV420P:

        size1 = (width * height * 3) / 2;

        if (size != size1)

            return -EIO;

        

        picture.data[0] = buf;

        picture.data[1] = picture.data[0] + width * height;

        picture.data[2] = picture.data[1] + (width * height) / 4;

        picture.linesize[0] = width;

        picture.linesize[1] = width >> 1; 

        picture.linesize[2] = width >> 1;

        break;

    case PIX_FMT_RGB24:

        size1 = (width * height * 3);

        if (size != size1)

            return -EIO;

        picture.data[0] = buf;

        picture.linesize[0] = width * 3;

        break;

    default:

        return -EIO;

    }

    

    if (get_frame_filename(filename, sizeof(filename), 

                           img->path, img->img_number) < 0)

        return -EIO;



    if (!img->is_pipe) {

        pb = &pb1;

        if (url_fopen(pb, filename, URL_WRONLY) < 0)

            return -EIO;

    } else {

        pb = &s->pb;

    }

    switch(img->img_fmt) {

    case IMGFMT_PGMYUV:

        ret = pgm_save(&picture, width, height, pb, 1);

        break;

    case IMGFMT_PGM:

        ret = pgm_save(&picture, width, height, pb, 0);

        break;

    case IMGFMT_YUV:

        ret = yuv_save(&picture, width, height, filename);

        break;

    case IMGFMT_PPM:

        ret = ppm_save(&picture, width, height, pb);

        break;

    }

    if (!img->is_pipe) {

        url_fclose(pb);

    }



    img->img_number++;

    return 0;

}
",437,,LABEL_1,LABEL_0,,-4,"s,stream_index,buf,size,img,st,pb1,pb,picture,height,ret,size1,filename,img_number",,,,0,,0,Greedy,1,0.0006772836049397786,,
26,"static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)

{

    int t = rc->range * (uint64_t)cumFreq / total_freq;



    rc->code1 += t + 1;

    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);



    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {

        unsigned byte = bytestream2_get_byte(gb);

        rc->code = (rc->code << 8) | byte;

        rc->code1 <<= 8;

        rc->range <<= 8;

    }

}
",132,"static void decode0(GetByteContext *rb, RangeCoder *gg, unsigned cumFreq, unsigned freq, unsigned total_freq)

{

    int t = gg->range * (uint64_t)cumFreq / total_freq;



    gg->code1 += t + 1;

    gg->range = gg->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);



    while (gg->range < TOP && bytestream2_get_bytes_left(rb) > 0) {

        unsigned byte = bytestream2_get_byte(rb);

        gg->code = (gg->code << 8) | byte;

        gg->code1 <<= 8;

        gg->range <<= 8;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"gb,rc,cumFreq,freq,total_freq","gb:4.76837158203125e-05,rc:0.00013083219528198242,cumFreq:-8.213520050048828e-05,freq:3.254413604736328e-05,total_freq:-9.85264778137207e-05,",2,13,0,"rc:gg,gb:rb,",0,Greedy,132,0.04756298065185547,replace,[]
27,"static void h263_h_loop_filter_mmx(uint8_t *src, int stride, int qscale)

{

    if (CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {

        const int strength = ff_h263_loop_filter_strength[qscale];

        DECLARE_ALIGNED(8, uint64_t, temp)[4];

        uint8_t *btemp = (uint8_t*)temp;



        src -= 2;



        transpose4x4(btemp,     src,              8, stride);

        transpose4x4(btemp + 4, src + 4 * stride, 8, stride);

        __asm__ volatile (

            H263_LOOP_FILTER // 5 3 4 6



            : ""+m""(temp[0]),

              ""+m""(temp[1]),

              ""+m""(temp[2]),

              ""+m""(temp[3])

            : ""g""(2 * strength), ""m""(ff_pb_FC)

            );



        __asm__ volatile (

            ""movq      %%mm5, %%mm1         \n\t""

            ""movq      %%mm4, %%mm0         \n\t""

            ""punpcklbw %%mm3, %%mm5         \n\t""

            ""punpcklbw %%mm6, %%mm4         \n\t""

            ""punpckhbw %%mm3, %%mm1         \n\t""

            ""punpckhbw %%mm6, %%mm0         \n\t""

            ""movq      %%mm5, %%mm3         \n\t""

            ""movq      %%mm1, %%mm6         \n\t""

            ""punpcklwd %%mm4, %%mm5         \n\t""

            ""punpcklwd %%mm0, %%mm1         \n\t""

            ""punpckhwd %%mm4, %%mm3         \n\t""

            ""punpckhwd %%mm0, %%mm6         \n\t""

            ""movd      %%mm5, (%0)          \n\t""

            ""punpckhdq %%mm5, %%mm5         \n\t""

            ""movd      %%mm5, (%0, %2)      \n\t""

            ""movd      %%mm3, (%0, %2, 2)   \n\t""

            ""punpckhdq %%mm3, %%mm3         \n\t""

            ""movd      %%mm3, (%0, %3)      \n\t""

            ""movd      %%mm1, (%1)          \n\t""

            ""punpckhdq %%mm1, %%mm1         \n\t""

            ""movd      %%mm1, (%1, %2)      \n\t""

            ""movd      %%mm6, (%1, %2, 2)   \n\t""

            ""punpckhdq %%mm6, %%mm6         \n\t""

            ""movd      %%mm6, (%1, %3)      \n\t""

            :: ""r""(src),

               ""r""(src + 4 * stride),

               ""r""((x86_reg)stride),

               ""r""((x86_reg)(3 * stride))

            );

    }

}
",452,"static void h263_h_loop_filter_mmx(uint8_t *rb, int  stridi, int qscale)

{

    if (CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {

        const int strength = ff_h263_loop_filter_strength[qscale];

        DECLARE_ALIGNED(8, uint64_t, temp)[4];

        uint8_t *btemp = (uint8_t*)temp;



        rb -= 2;



        transpose4x4(btemp,     rb,              8,  stridi);

        transpose4x4(btemp + 4, rb + 4 *  stridi, 8,  stridi);

        __asm__ volatile (

            H263_LOOP_FILTER // 5 3 4 6



            : ""+m""(temp[0]),

              ""+m""(temp[1]),

              ""+m""(temp[2]),

              ""+m""(temp[3])

            : ""g""(2 * strength), ""m""(ff_pb_FC)

            );



        __asm__ volatile (

            ""movq      %%mm5, %%mm1         
\t""

            ""movq      %%mm4, %%mm0         
\t""

            ""punpcklbw %%mm3, %%mm5         
\t""

            ""punpcklbw %%mm6, %%mm4         
\t""

            ""punpckhbw %%mm3, %%mm1         
\t""

            ""punpckhbw %%mm6, %%mm0         
\t""

            ""movq      %%mm5, %%mm3         
\t""

            ""movq      %%mm1, %%mm6         
\t""

            ""punpcklwd %%mm4, %%mm5         
\t""

            ""punpcklwd %%mm0, %%mm1         
\t""

            ""punpckhwd %%mm4, %%mm3         
\t""

            ""punpckhwd %%mm0, %%mm6         
\t""

            ""movd      %%mm5, (%0)          
\t""

            ""punpckhdq %%mm5, %%mm5         
\t""

            ""movd      %%mm5, (%0, %2)      
\t""

            ""movd      %%mm3, (%0, %2, 2)   
\t""

            ""punpckhdq %%mm3, %%mm3         
\t""

            ""movd      %%mm3, (%0, %3)      
\t""

            ""movd      %%mm1, (%1)          
\t""

            ""punpckhdq %%mm1, %%mm1         
\t""

            ""movd      %%mm1, (%1, %2)      
\t""

            ""movd      %%mm6, (%1, %2, 2)   
\t""

            ""punpckhdq %%mm6, %%mm6         
\t""

            ""movd      %%mm6, (%1, %3)      
\t""

            :: ""r""(rb),

               ""r""(rb + 4 *  stridi),

               ""r""((x86_reg) stridi),

               ""r""((x86_reg)(3 *  stridi))

            );

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"src,stride,qscale,btemp,H263_LOOP_FILTER,m","src:0.00028336048126220703,stride:0.0003191828727722168,qscale:0.00026494264602661133,btemp:0.00044077634811401367,H263_LOOP_FILTER:1.633167266845703e-05,",2,13,0,"btemp:btemp,stride: stridi,src:rb,",0,Greedy,196,0.0813896894454956,replace,[]
28,"static int get_physical_address (CPUMIPSState *env, hwaddr *physical,

                                int *prot, target_ulong real_address,

                                int rw, int access_type)

{

    /* User mode can only access useg/xuseg */

    int user_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_UM;

    int supervisor_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_SM;

    int kernel_mode = !user_mode && !supervisor_mode;

#if defined(TARGET_MIPS64)

    int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;

    int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;

    int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;

#endif

    int ret = TLBRET_MATCH;

    /* effective address (modified for KVM T&E kernel segments) */

    target_ulong address = real_address;



#define USEG_LIMIT      0x7FFFFFFFUL

#define KSEG0_BASE      0x80000000UL

#define KSEG1_BASE      0xA0000000UL

#define KSEG2_BASE      0xC0000000UL

#define KSEG3_BASE      0xE0000000UL



#define KVM_KSEG0_BASE  0x40000000UL

#define KVM_KSEG2_BASE  0x60000000UL



    if (kvm_enabled()) {

        /* KVM T&E adds guest kernel segments in useg */

        if (real_address >= KVM_KSEG0_BASE) {

            if (real_address < KVM_KSEG2_BASE) {

                /* kseg0 */

                address += KSEG0_BASE - KVM_KSEG0_BASE;

            } else if (real_address <= USEG_LIMIT) {

                /* kseg2/3 */

                address += KSEG2_BASE - KVM_KSEG2_BASE;

            }

        }

    }



    if (address <= USEG_LIMIT) {

        /* useg */

        if (env->CP0_Status & (1 << CP0St_ERL)) {

            *physical = address & 0xFFFFFFFF;

            *prot = PAGE_READ | PAGE_WRITE;

        } else {

            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);

        }

#if defined(TARGET_MIPS64)

    } else if (address < 0x4000000000000000ULL) {

        /* xuseg */

        if (UX && address <= (0x3FFFFFFFFFFFFFFFULL & env->SEGMask)) {

            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < 0x8000000000000000ULL) {

        /* xsseg */

        if ((supervisor_mode || kernel_mode) &&

            SX && address <= (0x7FFFFFFFFFFFFFFFULL & env->SEGMask)) {

            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < 0xC000000000000000ULL) {

        /* xkphys */

        if (kernel_mode && KX &&

            (address & 0x07FFFFFFFFFFFFFFULL) <= env->PAMask) {

            *physical = address & env->PAMask;

            *prot = PAGE_READ | PAGE_WRITE;

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < 0xFFFFFFFF80000000ULL) {

        /* xkseg */

        if (kernel_mode && KX &&

            address <= (0xFFFFFFFF7FFFFFFFULL & env->SEGMask)) {

            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

#endif

    } else if (address < (int32_t)KSEG1_BASE) {

        /* kseg0 */

        if (kernel_mode) {

            *physical = address - (int32_t)KSEG0_BASE;

            *prot = PAGE_READ | PAGE_WRITE;

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < (int32_t)KSEG2_BASE) {

        /* kseg1 */

        if (kernel_mode) {

            *physical = address - (int32_t)KSEG1_BASE;

            *prot = PAGE_READ | PAGE_WRITE;

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < (int32_t)KSEG3_BASE) {

        /* sseg (kseg2) */

        if (supervisor_mode || kernel_mode) {

            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

    } else {

        /* kseg3 */

        /* XXX: debug segment is not emulated */

        if (kernel_mode) {

            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

    }

    return ret;

}
",782,"static int get_physical_address (CPUMIPSState *inv, hwaddr *physical,

                                int *ret, target_ulong real_address,

                                int rw, int access_type)

{

    /* User mode can only access useg/xuseg */

    int user_mode = (inv->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_UM;

    int supervisor_mode = (inv->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_SM;

    int kernel_mode = !user_mode && !supervisor_mode;

#if defined(TARGET_MIPS64)

    int UX = (inv->CP0_Status & (1 << CP0St_UX)) != 0;

    int SX = (inv->CP0_Status & (1 << CP0St_SX)) != 0;

    int KX = (inv->CP0_Status & (1 << CP0St_KX)) != 0;

#endif

    int ret = TLBRET_MATCH;

    /* effective address (modified for KVM T&E kernel segments) */

    target_ulong address = real_address;



#define USEG_LIMIT      0x7FFFFFFFUL

#define KSEG0_BASE      0x80000000UL

#define KSEG1_BASE      0xA0000000UL

#define KSEG2_BASE      0xC0000000UL

#define KSEG3_BASE      0xE0000000UL



#define KVM_KSEG0_BASE  0x40000000UL

#define KVM_KSEG2_BASE  0x60000000UL



    if (kvm_enabled()) {

        /* KVM T&E adds guest kernel segments in useg */

        if (real_address >= KVM_KSEG0_BASE) {

            if (real_address < KVM_KSEG2_BASE) {

                /* kseg0 */

                address += KSEG0_BASE - KVM_KSEG0_BASE;

            } else if (real_address <= USEG_LIMIT) {

                /* kseg2/3 */

                address += KSEG2_BASE - KVM_KSEG2_BASE;

            }

        }

    }



    if (address <= USEG_LIMIT) {

        /* useg */

        if (inv->CP0_Status & (1 << CP0St_ERL)) {

            *physical = address & 0xFFFFFFFF;

            *ret = PAGE_READ | PAGE_WRITE;

        } else {

            ret = inv->tlb->map_address(inv, physical, ret, real_address, rw, access_type);

        }

#if defined(TARGET_MIPS64)

    } else if (address < 0x4000000000000000ULL) {

        /* xuseg */

        if (UX && address <= (0x3FFFFFFFFFFFFFFFULL & inv->SEGMask)) {

            ret = inv->tlb->map_address(inv, physical, ret, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < 0x8000000000000000ULL) {

        /* xsseg */

        if ((supervisor_mode || kernel_mode) &&

            SX && address <= (0x7FFFFFFFFFFFFFFFULL & inv->SEGMask)) {

            ret = inv->tlb->map_address(inv, physical, ret, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < 0xC000000000000000ULL) {

        /* xkphys */

        if (kernel_mode && KX &&

            (address & 0x07FFFFFFFFFFFFFFULL) <= inv->PAMask) {

            *physical = address & inv->PAMask;

            *ret = PAGE_READ | PAGE_WRITE;

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < 0xFFFFFFFF80000000ULL) {

        /* xkseg */

        if (kernel_mode && KX &&

            address <= (0xFFFFFFFF7FFFFFFFULL & inv->SEGMask)) {

            ret = inv->tlb->map_address(inv, physical, ret, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

#endif

    } else if (address < (int32_t)KSEG1_BASE) {

        /* kseg0 */

        if (kernel_mode) {

            *physical = address - (int32_t)KSEG0_BASE;

            *ret = PAGE_READ | PAGE_WRITE;

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < (int32_t)KSEG2_BASE) {

        /* kseg1 */

        if (kernel_mode) {

            *physical = address - (int32_t)KSEG1_BASE;

            *ret = PAGE_READ | PAGE_WRITE;

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < (int32_t)KSEG3_BASE) {

        /* sseg (kseg2) */

        if (supervisor_mode || kernel_mode) {

            ret = inv->tlb->map_address(inv, physical, ret, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

    } else {

        /* kseg3 */

        /* XXX: debug segment is not emulated */

        if (kernel_mode) {

            ret = inv->tlb->map_address(inv, physical, ret, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

    }

    return ret;

}
",LABEL_1,LABEL_1,LABEL_0,1,"env,physical,prot,real_address,rw,access_type","env:0.5423234105110168,physical:0.15965145826339722,prot:0.21009743213653564,real_address:-0.00888139009475708,rw:-0.2903388738632202,access_type:0.004160523414611816,",2,35,0,"env:inv,prot:ret,",0,Greedy,177,0.07806451718012491,replace,[]
29,"static void test_source_wait_event_notifier(void)

{

    EventNotifierTestData data = { .n = 0, .active = 1 };

    event_notifier_init(&data.e, false);

    aio_set_event_notifier(ctx, &data.e, event_ready_cb);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 0);

    g_assert_cmpint(data.active, ==, 1);



    event_notifier_set(&data.e);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    aio_set_event_notifier(ctx, &data.e, NULL);

    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);



    event_notifier_cleanup(&data.e);

}
",190,,LABEL_0,LABEL_0,,-3,,,,,0,,0,Greedy,1,0.0005306243896484375,,
30,"void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)

{

    f->xfer_limit = limit;

}
",19,,LABEL_1,LABEL_0,,-4,"f,limit",,,,0,,0,Greedy,1,0.0004233280817667643,,
31,"static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)

{

    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);

    IDEState *s = bmdma_active_if(bm);

    PCIDevice *pci_dev = PCI_DEVICE(bm->pci_dev);

    struct {

        uint32_t addr;

        uint32_t size;

    } prd;

    int l, len;



    pci_dma_sglist_init(&s->sg, pci_dev,

                        s->nsector / (BMDMA_PAGE_SIZE / 512) + 1);

    s->io_buffer_size = 0;

    for(;;) {

        if (bm->cur_prd_len == 0) {

            /* end of table (with a fail safe of one page) */

            if (bm->cur_prd_last ||

                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {

                return s->io_buffer_size;

            }

            pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);

            bm->cur_addr += 8;

            prd.addr = le32_to_cpu(prd.addr);

            prd.size = le32_to_cpu(prd.size);

            len = prd.size & 0xfffe;

            if (len == 0)

                len = 0x10000;

            bm->cur_prd_len = len;

            bm->cur_prd_addr = prd.addr;

            bm->cur_prd_last = (prd.size & 0x80000000);

        }

        l = bm->cur_prd_len;

        if (l > 0) {

            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);



            /* Note: We limit the max transfer to be 2GiB.

             * This should accommodate the largest ATA transaction

             * for LBA48 (65,536 sectors) and 32K sector sizes. */

            if (s->sg.size > INT32_MAX) {

                error_report(""IDE: sglist describes more than 2GiB."");

                break;

            }

            bm->cur_prd_addr += l;

            bm->cur_prd_len -= l;

            s->io_buffer_size += l;

        }

    }



    qemu_sglist_destroy(&s->sg);

    s->io_buffer_size = 0;

    return -1;

}
",382,,LABEL_1,LABEL_0,,-4,"dma,is_write,bm,s,pci_dev,prd,l,len",,,,0,,0,Greedy,1,0.0006456375122070312,,
32,"static void disas_xtensa_insn(CPUXtensaState *env, DisasContext *dc)

{

#define HAS_OPTION_BITS(opt) do { \

        if (!option_bits_enabled(dc, opt)) { \

            qemu_log(""Option is not enabled %s:%d\n"", \

                    __FILE__, __LINE__); \

            goto invalid_opcode; \

        } \

    } while (0)



#define HAS_OPTION(opt) HAS_OPTION_BITS(XTENSA_OPTION_BIT(opt))



#define TBD() qemu_log(""TBD(pc = %08x): %s:%d\n"", dc->pc, __FILE__, __LINE__)

#define RESERVED() do { \

        qemu_log(""RESERVED(pc = %08x, %02x%02x%02x): %s:%d\n"", \

                dc->pc, b0, b1, b2, __FILE__, __LINE__); \

        goto invalid_opcode; \

    } while (0)





#ifdef TARGET_WORDS_BIGENDIAN

#define OP0 (((b0) & 0xf0) >> 4)

#define OP1 (((b2) & 0xf0) >> 4)

#define OP2 ((b2) & 0xf)

#define RRR_R ((b1) & 0xf)

#define RRR_S (((b1) & 0xf0) >> 4)

#define RRR_T ((b0) & 0xf)

#else

#define OP0 (((b0) & 0xf))

#define OP1 (((b2) & 0xf))

#define OP2 (((b2) & 0xf0) >> 4)

#define RRR_R (((b1) & 0xf0) >> 4)

#define RRR_S (((b1) & 0xf))

#define RRR_T (((b0) & 0xf0) >> 4)

#endif

#define RRR_X ((RRR_R & 0x4) >> 2)

#define RRR_Y ((RRR_T & 0x4) >> 2)

#define RRR_W (RRR_R & 0x3)



#define RRRN_R RRR_R

#define RRRN_S RRR_S

#define RRRN_T RRR_T



#define RRI4_R RRR_R

#define RRI4_S RRR_S

#define RRI4_T RRR_T

#ifdef TARGET_WORDS_BIGENDIAN

#define RRI4_IMM4 ((b2) & 0xf)

#else

#define RRI4_IMM4 (((b2) & 0xf0) >> 4)

#endif



#define RRI8_R RRR_R

#define RRI8_S RRR_S

#define RRI8_T RRR_T

#define RRI8_IMM8 (b2)

#define RRI8_IMM8_SE ((((b2) & 0x80) ? 0xffffff00 : 0) | RRI8_IMM8)



#ifdef TARGET_WORDS_BIGENDIAN

#define RI16_IMM16 (((b1) << 8) | (b2))

#else

#define RI16_IMM16 (((b2) << 8) | (b1))

#endif



#ifdef TARGET_WORDS_BIGENDIAN

#define CALL_N (((b0) & 0xc) >> 2)

#define CALL_OFFSET ((((b0) & 0x3) << 16) | ((b1) << 8) | (b2))

#else

#define CALL_N (((b0) & 0x30) >> 4)

#define CALL_OFFSET ((((b0) & 0xc0) >> 6) | ((b1) << 2) | ((b2) << 10))

#endif

#define CALL_OFFSET_SE \

    (((CALL_OFFSET & 0x20000) ? 0xfffc0000 : 0) | CALL_OFFSET)



#define CALLX_N CALL_N

#ifdef TARGET_WORDS_BIGENDIAN

#define CALLX_M ((b0) & 0x3)

#else

#define CALLX_M (((b0) & 0xc0) >> 6)

#endif

#define CALLX_S RRR_S



#define BRI12_M CALLX_M

#define BRI12_S RRR_S

#ifdef TARGET_WORDS_BIGENDIAN

#define BRI12_IMM12 ((((b1) & 0xf) << 8) | (b2))

#else

#define BRI12_IMM12 ((((b1) & 0xf0) >> 4) | ((b2) << 4))

#endif

#define BRI12_IMM12_SE (((BRI12_IMM12 & 0x800) ? 0xfffff000 : 0) | BRI12_IMM12)



#define BRI8_M BRI12_M

#define BRI8_R RRI8_R

#define BRI8_S RRI8_S

#define BRI8_IMM8 RRI8_IMM8

#define BRI8_IMM8_SE RRI8_IMM8_SE



#define RSR_SR (b1)



    uint8_t b0 = cpu_ldub_code(env, dc->pc);

    uint8_t b1 = cpu_ldub_code(env, dc->pc + 1);

    uint8_t b2 = 0;

    unsigned len = xtensa_op0_insn_len(OP0);



    static const uint32_t B4CONST[] = {

        0xffffffff, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256

    };



    static const uint32_t B4CONSTU[] = {

        32768, 65536, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256

    };



    switch (len) {

    case 2:

        HAS_OPTION(XTENSA_OPTION_CODE_DENSITY);

        break;



    case 3:

        b2 = cpu_ldub_code(env, dc->pc + 2);

        break;



    default:

        RESERVED();

    }

    dc->next_pc = dc->pc + len;



    switch (OP0) {

    case 0: /*QRST*/

        switch (OP1) {

        case 0: /*RST0*/

            switch (OP2) {

            case 0: /*ST0*/

                if ((RRR_R & 0xc) == 0x8) {

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                }



                switch (RRR_R) {

                case 0: /*SNM0*/

                    switch (CALLX_M) {

                    case 0: /*ILL*/

                        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

                        break;



                    case 1: /*reserved*/

                        RESERVED();

                        break;



                    case 2: /*JR*/

                        switch (CALLX_N) {

                        case 0: /*RET*/

                        case 2: /*JX*/

                            if (gen_window_check1(dc, CALLX_S)) {

                                gen_jump(dc, cpu_R[CALLX_S]);

                            }

                            break;



                        case 1: /*RETWw*/

                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                            {

                                TCGv_i32 tmp = tcg_const_i32(dc->pc);

                                gen_advance_ccount(dc);

                                gen_helper_retw(tmp, cpu_env, tmp);

                                gen_jump(dc, tmp);

                                tcg_temp_free(tmp);

                            }

                            break;



                        case 3: /*reserved*/

                            RESERVED();

                            break;

                        }

                        break;



                    case 3: /*CALLX*/

                        if (!gen_window_check2(dc, CALLX_S, CALLX_N << 2)) {

                            break;

                        }

                        switch (CALLX_N) {

                        case 0: /*CALLX0*/

                            {

                                TCGv_i32 tmp = tcg_temp_new_i32();

                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);

                                tcg_gen_movi_i32(cpu_R[0], dc->next_pc);

                                gen_jump(dc, tmp);

                                tcg_temp_free(tmp);

                            }

                            break;



                        case 1: /*CALLX4w*/

                        case 2: /*CALLX8w*/

                        case 3: /*CALLX12w*/

                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                            {

                                TCGv_i32 tmp = tcg_temp_new_i32();



                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);

                                gen_callw(dc, CALLX_N, tmp);

                                tcg_temp_free(tmp);

                            }

                            break;

                        }

                        break;

                    }

                    break;



                case 1: /*MOVSPw*/

                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                    if (gen_window_check2(dc, RRR_T, RRR_S)) {

                        TCGv_i32 pc = tcg_const_i32(dc->pc);

                        gen_advance_ccount(dc);

                        gen_helper_movsp(cpu_env, pc);

                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_R[RRR_S]);

                        tcg_temp_free(pc);

                    }

                    break;



                case 2: /*SYNC*/

                    switch (RRR_T) {

                    case 0: /*ISYNC*/

                        break;



                    case 1: /*RSYNC*/

                        break;



                    case 2: /*ESYNC*/

                        break;



                    case 3: /*DSYNC*/

                        break;



                    case 8: /*EXCW*/

                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);

                        break;



                    case 12: /*MEMW*/

                        break;



                    case 13: /*EXTW*/

                        break;



                    case 15: /*NOP*/

                        break;



                    default: /*reserved*/

                        RESERVED();

                        break;

                    }

                    break;



                case 3: /*RFEIx*/

                    switch (RRR_T) {

                    case 0: /*RFETx*/

                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);

                        switch (RRR_S) {

                        case 0: /*RFEx*/

                            if (gen_check_privilege(dc)) {

                                tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);

                                gen_helper_check_interrupts(cpu_env);

                                gen_jump(dc, cpu_SR[EPC1]);

                            }

                            break;



                        case 1: /*RFUEx*/

                            RESERVED();

                            break;



                        case 2: /*RFDEx*/

                            if (gen_check_privilege(dc)) {

                                gen_jump(dc, cpu_SR[

                                         dc->config->ndepc ? DEPC : EPC1]);

                            }

                            break;



                        case 4: /*RFWOw*/

                        case 5: /*RFWUw*/

                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                            if (gen_check_privilege(dc)) {

                                TCGv_i32 tmp = tcg_const_i32(1);



                                tcg_gen_andi_i32(

                                        cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);

                                tcg_gen_shl_i32(tmp, tmp, cpu_SR[WINDOW_BASE]);



                                if (RRR_S == 4) {

                                    tcg_gen_andc_i32(cpu_SR[WINDOW_START],

                                            cpu_SR[WINDOW_START], tmp);

                                } else {

                                    tcg_gen_or_i32(cpu_SR[WINDOW_START],

                                            cpu_SR[WINDOW_START], tmp);

                                }



                                gen_helper_restore_owb(cpu_env);

                                gen_helper_check_interrupts(cpu_env);

                                gen_jump(dc, cpu_SR[EPC1]);



                                tcg_temp_free(tmp);

                            }

                            break;



                        default: /*reserved*/

                            RESERVED();

                            break;

                        }

                        break;



                    case 1: /*RFIx*/

                        HAS_OPTION(XTENSA_OPTION_HIGH_PRIORITY_INTERRUPT);

                        if (RRR_S >= 2 && RRR_S <= dc->config->nlevel) {

                            if (gen_check_privilege(dc)) {

                                tcg_gen_mov_i32(cpu_SR[PS],

                                                cpu_SR[EPS2 + RRR_S - 2]);

                                gen_helper_check_interrupts(cpu_env);

                                gen_jump(dc, cpu_SR[EPC1 + RRR_S - 1]);

                            }

                        } else {

                            qemu_log(""RFI %d is illegal\n"", RRR_S);

                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

                        }

                        break;



                    case 2: /*RFME*/

                        TBD();

                        break;



                    default: /*reserved*/

                        RESERVED();

                        break;



                    }

                    break;



                case 4: /*BREAKx*/

                    HAS_OPTION(XTENSA_OPTION_DEBUG);

                    if (dc->debug) {

                        gen_debug_exception(dc, DEBUGCAUSE_BI);

                    }

                    break;



                case 5: /*SYSCALLx*/

                    HAS_OPTION(XTENSA_OPTION_EXCEPTION);

                    switch (RRR_S) {

                    case 0: /*SYSCALLx*/

                        gen_exception_cause(dc, SYSCALL_CAUSE);

                        break;



                    case 1: /*SIMCALL*/

                        if (semihosting_enabled) {

                            if (gen_check_privilege(dc)) {

                                gen_helper_simcall(cpu_env);

                            }

                        } else {

                            qemu_log(""SIMCALL but semihosting is disabled\n"");

                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

                        }

                        break;



                    default:

                        RESERVED();

                        break;

                    }

                    break;



                case 6: /*RSILx*/

                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);

                    if (gen_check_privilege(dc) &&

                        gen_window_check1(dc, RRR_T)) {

                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_SR[PS]);

                        tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_INTLEVEL);

                        tcg_gen_ori_i32(cpu_SR[PS], cpu_SR[PS], RRR_S);

                        gen_helper_check_interrupts(cpu_env);

                        gen_jumpi_check_loop_end(dc, 0);

                    }

                    break;



                case 7: /*WAITIx*/

                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);

                    if (gen_check_privilege(dc)) {

                        gen_waiti(dc, RRR_S);

                    }

                    break;



                case 8: /*ANY4p*/

                case 9: /*ALL4p*/

                case 10: /*ANY8p*/

                case 11: /*ALL8p*/

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                    {

                        const unsigned shift = (RRR_R & 2) ? 8 : 4;

                        TCGv_i32 mask = tcg_const_i32(

                                ((1 << shift) - 1) << RRR_S);

                        TCGv_i32 tmp = tcg_temp_new_i32();



                        tcg_gen_and_i32(tmp, cpu_SR[BR], mask);

                        if (RRR_R & 1) { /*ALL*/

                            tcg_gen_addi_i32(tmp, tmp, 1 << RRR_S);

                        } else { /*ANY*/

                            tcg_gen_add_i32(tmp, tmp, mask);

                        }

                        tcg_gen_shri_i32(tmp, tmp, RRR_S + shift);

                        tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR],

                                tmp, RRR_T, 1);

                        tcg_temp_free(mask);

                        tcg_temp_free(tmp);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;



                }

                break;



            case 1: /*AND*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_and_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 2: /*OR*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_or_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 3: /*XOR*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_xor_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 4: /*ST1*/

                switch (RRR_R) {

                case 0: /*SSR*/

                    if (gen_window_check1(dc, RRR_S)) {

                        gen_right_shift_sar(dc, cpu_R[RRR_S]);

                    }

                    break;



                case 1: /*SSL*/

                    if (gen_window_check1(dc, RRR_S)) {

                        gen_left_shift_sar(dc, cpu_R[RRR_S]);

                    }

                    break;



                case 2: /*SSA8L*/

                    if (gen_window_check1(dc, RRR_S)) {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);

                        gen_right_shift_sar(dc, tmp);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 3: /*SSA8B*/

                    if (gen_window_check1(dc, RRR_S)) {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);

                        gen_left_shift_sar(dc, tmp);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 4: /*SSAI*/

                    {

                        TCGv_i32 tmp = tcg_const_i32(

                                RRR_S | ((RRR_T & 1) << 4));

                        gen_right_shift_sar(dc, tmp);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 6: /*RER*/

                    TBD();

                    break;



                case 7: /*WER*/

                    TBD();

                    break;



                case 8: /*ROTWw*/

                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                    if (gen_check_privilege(dc)) {

                        TCGv_i32 tmp = tcg_const_i32(

                                RRR_T | ((RRR_T & 8) ? 0xfffffff0 : 0));

                        gen_helper_rotw(cpu_env, tmp);

                        tcg_temp_free(tmp);

                        /* This can change tb->flags, so exit tb */

                        gen_jumpi_check_loop_end(dc, -1);

                    }

                    break;



                case 14: /*NSAu*/

                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);

                    if (gen_window_check2(dc, RRR_S, RRR_T)) {

                        gen_helper_nsa(cpu_R[RRR_T], cpu_R[RRR_S]);

                    }

                    break;



                case 15: /*NSAUu*/

                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);

                    if (gen_window_check2(dc, RRR_S, RRR_T)) {

                        gen_helper_nsau(cpu_R[RRR_T], cpu_R[RRR_S]);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            case 5: /*TLB*/

                HAS_OPTION_BITS(

                        XTENSA_OPTION_BIT(XTENSA_OPTION_MMU) |

                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_PROTECTION) |

                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_TRANSLATION));

                if (gen_check_privilege(dc) &&

                    gen_window_check2(dc, RRR_S, RRR_T)) {

                    TCGv_i32 dtlb = tcg_const_i32((RRR_R & 8) != 0);



                    switch (RRR_R & 7) {

                    case 3: /*RITLB0*/ /*RDTLB0*/

                        gen_helper_rtlb0(cpu_R[RRR_T],

                                cpu_env, cpu_R[RRR_S], dtlb);

                        break;



                    case 4: /*IITLB*/ /*IDTLB*/

                        gen_helper_itlb(cpu_env, cpu_R[RRR_S], dtlb);

                        /* This could change memory mapping, so exit tb */

                        gen_jumpi_check_loop_end(dc, -1);

                        break;



                    case 5: /*PITLB*/ /*PDTLB*/

                        tcg_gen_movi_i32(cpu_pc, dc->pc);

                        gen_helper_ptlb(cpu_R[RRR_T],

                                cpu_env, cpu_R[RRR_S], dtlb);

                        break;



                    case 6: /*WITLB*/ /*WDTLB*/

                        gen_helper_wtlb(

                                cpu_env, cpu_R[RRR_T], cpu_R[RRR_S], dtlb);

                        /* This could change memory mapping, so exit tb */

                        gen_jumpi_check_loop_end(dc, -1);

                        break;



                    case 7: /*RITLB1*/ /*RDTLB1*/

                        gen_helper_rtlb1(cpu_R[RRR_T],

                                cpu_env, cpu_R[RRR_S], dtlb);

                        break;



                    default:

                        tcg_temp_free(dtlb);

                        RESERVED();

                        break;

                    }

                    tcg_temp_free(dtlb);

                }

                break;



            case 6: /*RT0*/

                if (!gen_window_check2(dc, RRR_R, RRR_T)) {

                    break;

                }

                switch (RRR_S) {

                case 0: /*NEG*/

                    tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);

                    break;



                case 1: /*ABS*/

                    {

                        TCGv_i32 zero = tcg_const_i32(0);

                        TCGv_i32 neg = tcg_temp_new_i32();



                        tcg_gen_neg_i32(neg, cpu_R[RRR_T]);

                        tcg_gen_movcond_i32(TCG_COND_GE, cpu_R[RRR_R],

                                cpu_R[RRR_T], zero, cpu_R[RRR_T], neg);

                        tcg_temp_free(neg);

                        tcg_temp_free(zero);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            case 7: /*reserved*/

                RESERVED();

                break;



            case 8: /*ADD*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_add_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 9: /*ADD**/

            case 10:

            case 11:

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 8);

                    tcg_gen_add_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);

                    tcg_temp_free(tmp);

                }

                break;



            case 12: /*SUB*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_sub_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 13: /*SUB**/

            case 14:

            case 15:

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 12);

                    tcg_gen_sub_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);

                    tcg_temp_free(tmp);

                }

                break;

            }

            break;



        case 1: /*RST1*/

            switch (OP2) {

            case 0: /*SLLI*/

            case 1:

                if (gen_window_check2(dc, RRR_R, RRR_S)) {

                    tcg_gen_shli_i32(cpu_R[RRR_R], cpu_R[RRR_S],

                                     32 - (RRR_T | ((OP2 & 1) << 4)));

                }

                break;



            case 2: /*SRAI*/

            case 3:

                if (gen_window_check2(dc, RRR_R, RRR_T)) {

                    tcg_gen_sari_i32(cpu_R[RRR_R], cpu_R[RRR_T],

                                     RRR_S | ((OP2 & 1) << 4));

                }

                break;



            case 4: /*SRLI*/

                if (gen_window_check2(dc, RRR_R, RRR_T)) {

                    tcg_gen_shri_i32(cpu_R[RRR_R], cpu_R[RRR_T], RRR_S);

                }

                break;



            case 6: /*XSR*/

                if (gen_check_sr(dc, RSR_SR, SR_X) &&

                    (RSR_SR < 64 || gen_check_privilege(dc)) &&

                    gen_window_check1(dc, RRR_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();



                    tcg_gen_mov_i32(tmp, cpu_R[RRR_T]);

                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);

                    gen_wsr(dc, RSR_SR, tmp);

                    tcg_temp_free(tmp);

                }

                break;



                /*

                 * Note: 64 bit ops are used here solely because SAR values

                 * have range 0..63

                 */

#define gen_shift_reg(cmd, reg) do { \

                    TCGv_i64 tmp = tcg_temp_new_i64(); \

                    tcg_gen_extu_i32_i64(tmp, reg); \

                    tcg_gen_##cmd##_i64(v, v, tmp); \

                    tcg_gen_trunc_i64_i32(cpu_R[RRR_R], v); \

                    tcg_temp_free_i64(v); \

                    tcg_temp_free_i64(tmp); \

                } while (0)



#define gen_shift(cmd) gen_shift_reg(cmd, cpu_SR[SAR])



            case 8: /*SRC*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i64 v = tcg_temp_new_i64();

                    tcg_gen_concat_i32_i64(v, cpu_R[RRR_T], cpu_R[RRR_S]);

                    gen_shift(shr);

                }

                break;



            case 9: /*SRL*/

                if (!gen_window_check2(dc, RRR_R, RRR_T)) {

                    break;

                }

                if (dc->sar_5bit) {

                    tcg_gen_shr_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);

                } else {

                    TCGv_i64 v = tcg_temp_new_i64();

                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_T]);

                    gen_shift(shr);

                }

                break;



            case 10: /*SLL*/

                if (!gen_window_check2(dc, RRR_R, RRR_S)) {

                    break;

                }

                if (dc->sar_m32_5bit) {

                    tcg_gen_shl_i32(cpu_R[RRR_R], cpu_R[RRR_S], dc->sar_m32);

                } else {

                    TCGv_i64 v = tcg_temp_new_i64();

                    TCGv_i32 s = tcg_const_i32(32);

                    tcg_gen_sub_i32(s, s, cpu_SR[SAR]);

                    tcg_gen_andi_i32(s, s, 0x3f);

                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_S]);

                    gen_shift_reg(shl, s);

                    tcg_temp_free(s);

                }

                break;



            case 11: /*SRA*/

                if (!gen_window_check2(dc, RRR_R, RRR_T)) {

                    break;

                }

                if (dc->sar_5bit) {

                    tcg_gen_sar_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);

                } else {

                    TCGv_i64 v = tcg_temp_new_i64();

                    tcg_gen_ext_i32_i64(v, cpu_R[RRR_T]);

                    gen_shift(sar);

                }

                break;

#undef gen_shift

#undef gen_shift_reg



            case 12: /*MUL16U*/

                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 v1 = tcg_temp_new_i32();

                    TCGv_i32 v2 = tcg_temp_new_i32();

                    tcg_gen_ext16u_i32(v1, cpu_R[RRR_S]);

                    tcg_gen_ext16u_i32(v2, cpu_R[RRR_T]);

                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);

                    tcg_temp_free(v2);

                    tcg_temp_free(v1);

                }

                break;



            case 13: /*MUL16S*/

                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 v1 = tcg_temp_new_i32();

                    TCGv_i32 v2 = tcg_temp_new_i32();

                    tcg_gen_ext16s_i32(v1, cpu_R[RRR_S]);

                    tcg_gen_ext16s_i32(v2, cpu_R[RRR_T]);

                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);

                    tcg_temp_free(v2);

                    tcg_temp_free(v1);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 2: /*RST2*/

            if (OP2 >= 8 && !gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                break;

            }



            if (OP2 >= 12) {

                HAS_OPTION(XTENSA_OPTION_32_BIT_IDIV);

                int label = gen_new_label();

                tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0, label);

                gen_exception_cause(dc, INTEGER_DIVIDE_BY_ZERO_CAUSE);

                gen_set_label(label);

            }



            switch (OP2) {

#define BOOLEAN_LOGIC(fn, r, s, t) \

                do { \

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN); \

                    TCGv_i32 tmp1 = tcg_temp_new_i32(); \

                    TCGv_i32 tmp2 = tcg_temp_new_i32(); \

                    \

                    tcg_gen_shri_i32(tmp1, cpu_SR[BR], s); \

                    tcg_gen_shri_i32(tmp2, cpu_SR[BR], t); \

                    tcg_gen_##fn##_i32(tmp1, tmp1, tmp2); \

                    tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR], tmp1, r, 1); \

                    tcg_temp_free(tmp1); \

                    tcg_temp_free(tmp2); \

                } while (0)



            case 0: /*ANDBp*/

                BOOLEAN_LOGIC(and, RRR_R, RRR_S, RRR_T);

                break;



            case 1: /*ANDBCp*/

                BOOLEAN_LOGIC(andc, RRR_R, RRR_S, RRR_T);

                break;



            case 2: /*ORBp*/

                BOOLEAN_LOGIC(or, RRR_R, RRR_S, RRR_T);

                break;



            case 3: /*ORBCp*/

                BOOLEAN_LOGIC(orc, RRR_R, RRR_S, RRR_T);

                break;



            case 4: /*XORBp*/

                BOOLEAN_LOGIC(xor, RRR_R, RRR_S, RRR_T);

                break;



#undef BOOLEAN_LOGIC



            case 8: /*MULLi*/

                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL);

                tcg_gen_mul_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                break;



            case 10: /*MULUHi*/

            case 11: /*MULSHi*/

                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL_HIGH);

                {

                    TCGv lo = tcg_temp_new();



                    if (OP2 == 10) {

                        tcg_gen_mulu2_i32(lo, cpu_R[RRR_R],

                                          cpu_R[RRR_S], cpu_R[RRR_T]);

                    } else {

                        tcg_gen_muls2_i32(lo, cpu_R[RRR_R],

                                          cpu_R[RRR_S], cpu_R[RRR_T]);

                    }

                    tcg_temp_free(lo);

                }

                break;



            case 12: /*QUOUi*/

                tcg_gen_divu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                break;



            case 13: /*QUOSi*/

            case 15: /*REMSi*/

                {

                    int label1 = gen_new_label();

                    int label2 = gen_new_label();



                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_S], 0x80000000,

                            label1);

                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0xffffffff,

                            label1);

                    tcg_gen_movi_i32(cpu_R[RRR_R],

                            OP2 == 13 ? 0x80000000 : 0);

                    tcg_gen_br(label2);

                    gen_set_label(label1);

                    if (OP2 == 13) {

                        tcg_gen_div_i32(cpu_R[RRR_R],

                                cpu_R[RRR_S], cpu_R[RRR_T]);

                    } else {

                        tcg_gen_rem_i32(cpu_R[RRR_R],

                                cpu_R[RRR_S], cpu_R[RRR_T]);

                    }

                    gen_set_label(label2);

                }

                break;



            case 14: /*REMUi*/

                tcg_gen_remu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 3: /*RST3*/

            switch (OP2) {

            case 0: /*RSR*/

                if (gen_check_sr(dc, RSR_SR, SR_R) &&

                    (RSR_SR < 64 || gen_check_privilege(dc)) &&

                    gen_window_check1(dc, RRR_T)) {

                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);

                }

                break;



            case 1: /*WSR*/

                if (gen_check_sr(dc, RSR_SR, SR_W) &&

                    (RSR_SR < 64 || gen_check_privilege(dc)) &&

                    gen_window_check1(dc, RRR_T)) {

                    gen_wsr(dc, RSR_SR, cpu_R[RRR_T]);

                }

                break;



            case 2: /*SEXTu*/

                HAS_OPTION(XTENSA_OPTION_MISC_OP_SEXT);

                if (gen_window_check2(dc, RRR_R, RRR_S)) {

                    int shift = 24 - RRR_T;



                    if (shift == 24) {

                        tcg_gen_ext8s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);

                    } else if (shift == 16) {

                        tcg_gen_ext16s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);

                    } else {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], shift);

                        tcg_gen_sari_i32(cpu_R[RRR_R], tmp, shift);

                        tcg_temp_free(tmp);

                    }

                }

                break;



            case 3: /*CLAMPSu*/

                HAS_OPTION(XTENSA_OPTION_MISC_OP_CLAMPS);

                if (gen_window_check2(dc, RRR_R, RRR_S)) {

                    TCGv_i32 tmp1 = tcg_temp_new_i32();

                    TCGv_i32 tmp2 = tcg_temp_new_i32();

                    TCGv_i32 zero = tcg_const_i32(0);



                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 24 - RRR_T);

                    tcg_gen_xor_i32(tmp2, tmp1, cpu_R[RRR_S]);

                    tcg_gen_andi_i32(tmp2, tmp2, 0xffffffff << (RRR_T + 7));



                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 31);

                    tcg_gen_xori_i32(tmp1, tmp1, 0xffffffff >> (25 - RRR_T));



                    tcg_gen_movcond_i32(TCG_COND_EQ, cpu_R[RRR_R], tmp2, zero,

                            cpu_R[RRR_S], tmp1);

                    tcg_temp_free(tmp1);

                    tcg_temp_free(tmp2);

                    tcg_temp_free(zero);

                }

                break;



            case 4: /*MINu*/

            case 5: /*MAXu*/

            case 6: /*MINUu*/

            case 7: /*MAXUu*/

                HAS_OPTION(XTENSA_OPTION_MISC_OP_MINMAX);

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    static const TCGCond cond[] = {

                        TCG_COND_LE,

                        TCG_COND_GE,

                        TCG_COND_LEU,

                        TCG_COND_GEU

                    };

                    tcg_gen_movcond_i32(cond[OP2 - 4], cpu_R[RRR_R],

                            cpu_R[RRR_S], cpu_R[RRR_T],

                            cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 8: /*MOVEQZ*/

            case 9: /*MOVNEZ*/

            case 10: /*MOVLTZ*/

            case 11: /*MOVGEZ*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    static const TCGCond cond[] = {

                        TCG_COND_EQ,

                        TCG_COND_NE,

                        TCG_COND_LT,

                        TCG_COND_GE,

                    };

                    TCGv_i32 zero = tcg_const_i32(0);



                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_R[RRR_R],

                            cpu_R[RRR_T], zero, cpu_R[RRR_S], cpu_R[RRR_R]);

                    tcg_temp_free(zero);

                }

                break;



            case 12: /*MOVFp*/

            case 13: /*MOVTp*/

                HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                if (gen_window_check2(dc, RRR_R, RRR_S)) {

                    TCGv_i32 zero = tcg_const_i32(0);

                    TCGv_i32 tmp = tcg_temp_new_i32();



                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);

                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,

                            cpu_R[RRR_R], tmp, zero,

                            cpu_R[RRR_S], cpu_R[RRR_R]);



                    tcg_temp_free(tmp);

                    tcg_temp_free(zero);

                }

                break;



            case 14: /*RUR*/

                if (gen_window_check1(dc, RRR_R)) {

                    int st = (RRR_S << 4) + RRR_T;

                    if (uregnames[st].name) {

                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_UR[st]);

                    } else {

                        qemu_log(""RUR %d not implemented, "", st);

                        TBD();

                    }

                }

                break;



            case 15: /*WUR*/

                if (gen_window_check1(dc, RRR_T)) {

                    if (uregnames[RSR_SR].name) {

                        gen_wur(RSR_SR, cpu_R[RRR_T]);

                    } else {

                        qemu_log(""WUR %d not implemented, "", RSR_SR);

                        TBD();

                    }

                }

                break;



            }

            break;



        case 4: /*EXTUI*/

        case 5:

            if (gen_window_check2(dc, RRR_R, RRR_T)) {

                int shiftimm = RRR_S | ((OP1 & 1) << 4);

                int maskimm = (1 << (OP2 + 1)) - 1;



                TCGv_i32 tmp = tcg_temp_new_i32();

                tcg_gen_shri_i32(tmp, cpu_R[RRR_T], shiftimm);

                tcg_gen_andi_i32(cpu_R[RRR_R], tmp, maskimm);

                tcg_temp_free(tmp);

            }

            break;



        case 6: /*CUST0*/

            RESERVED();

            break;



        case 7: /*CUST1*/

            RESERVED();

            break;



        case 8: /*LSCXp*/

            switch (OP2) {

            case 0: /*LSXf*/

            case 1: /*LSXUf*/

            case 4: /*SSXf*/

            case 5: /*SSXUf*/

                HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);

                if (gen_window_check2(dc, RRR_S, RRR_T) &&

                    gen_check_cpenable(dc, 0)) {

                    TCGv_i32 addr = tcg_temp_new_i32();

                    tcg_gen_add_i32(addr, cpu_R[RRR_S], cpu_R[RRR_T]);

                    gen_load_store_alignment(dc, 2, addr, false);

                    if (OP2 & 0x4) {

                        tcg_gen_qemu_st32(cpu_FR[RRR_R], addr, dc->cring);

                    } else {

                        tcg_gen_qemu_ld32u(cpu_FR[RRR_R], addr, dc->cring);

                    }

                    if (OP2 & 0x1) {

                        tcg_gen_mov_i32(cpu_R[RRR_S], addr);

                    }

                    tcg_temp_free(addr);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 9: /*LSC4*/

            if (!gen_window_check2(dc, RRR_S, RRR_T)) {

                break;

            }

            switch (OP2) {

            case 0: /*L32E*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                if (gen_check_privilege(dc)) {

                    TCGv_i32 addr = tcg_temp_new_i32();

                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],

                            (0xffffffc0 | (RRR_R << 2)));

                    tcg_gen_qemu_ld32u(cpu_R[RRR_T], addr, dc->ring);

                    tcg_temp_free(addr);

                }

                break;



            case 4: /*S32E*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                if (gen_check_privilege(dc)) {

                    TCGv_i32 addr = tcg_temp_new_i32();

                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],

                            (0xffffffc0 | (RRR_R << 2)));

                    tcg_gen_qemu_st32(cpu_R[RRR_T], addr, dc->ring);

                    tcg_temp_free(addr);

                }

                break;



            default:

                RESERVED();

                break;

            }

            break;



        case 10: /*FP0*/

            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);

            switch (OP2) {

            case 0: /*ADD.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_add_s(cpu_FR[RRR_R], cpu_env,

                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);

                }

                break;



            case 1: /*SUB.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_sub_s(cpu_FR[RRR_R], cpu_env,

                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);

                }

                break;



            case 2: /*MUL.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_mul_s(cpu_FR[RRR_R], cpu_env,

                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);

                }

                break;



            case 4: /*MADD.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_madd_s(cpu_FR[RRR_R], cpu_env,

                                      cpu_FR[RRR_R], cpu_FR[RRR_S],

                                      cpu_FR[RRR_T]);

                }

                break;



            case 5: /*MSUB.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_msub_s(cpu_FR[RRR_R], cpu_env,

                                      cpu_FR[RRR_R], cpu_FR[RRR_S],

                                      cpu_FR[RRR_T]);

                }

                break;



            case 8: /*ROUND.Sf*/

            case 9: /*TRUNC.Sf*/

            case 10: /*FLOOR.Sf*/

            case 11: /*CEIL.Sf*/

            case 14: /*UTRUNC.Sf*/

                if (gen_window_check1(dc, RRR_R) &&

                    gen_check_cpenable(dc, 0)) {

                    static const unsigned rounding_mode_const[] = {

                        float_round_nearest_even,

                        float_round_to_zero,

                        float_round_down,

                        float_round_up,

                        [6] = float_round_to_zero,

                    };

                    TCGv_i32 rounding_mode = tcg_const_i32(

                            rounding_mode_const[OP2 & 7]);

                    TCGv_i32 scale = tcg_const_i32(RRR_T);



                    if (OP2 == 14) {

                        gen_helper_ftoui(cpu_R[RRR_R], cpu_FR[RRR_S],

                                rounding_mode, scale);

                    } else {

                        gen_helper_ftoi(cpu_R[RRR_R], cpu_FR[RRR_S],

                                rounding_mode, scale);

                    }



                    tcg_temp_free(rounding_mode);

                    tcg_temp_free(scale);

                }

                break;



            case 12: /*FLOAT.Sf*/

            case 13: /*UFLOAT.Sf*/

                if (gen_window_check1(dc, RRR_S) &&

                    gen_check_cpenable(dc, 0)) {

                    TCGv_i32 scale = tcg_const_i32(-RRR_T);



                    if (OP2 == 13) {

                        gen_helper_uitof(cpu_FR[RRR_R], cpu_env,

                                cpu_R[RRR_S], scale);

                    } else {

                        gen_helper_itof(cpu_FR[RRR_R], cpu_env,

                                cpu_R[RRR_S], scale);

                    }

                    tcg_temp_free(scale);

                }

                break;



            case 15: /*FP1OP*/

                switch (RRR_T) {

                case 0: /*MOV.Sf*/

                    if (gen_check_cpenable(dc, 0)) {

                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                case 1: /*ABS.Sf*/

                    if (gen_check_cpenable(dc, 0)) {

                        gen_helper_abs_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                case 4: /*RFRf*/

                    if (gen_window_check1(dc, RRR_R) &&

                        gen_check_cpenable(dc, 0)) {

                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                case 5: /*WFRf*/

                    if (gen_window_check1(dc, RRR_S) &&

                        gen_check_cpenable(dc, 0)) {

                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_R[RRR_S]);

                    }

                    break;



                case 6: /*NEG.Sf*/

                    if (gen_check_cpenable(dc, 0)) {

                        gen_helper_neg_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 11: /*FP1*/

            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);



#define gen_compare(rel, br, a, b) \

    do { \

        if (gen_check_cpenable(dc, 0)) { \

            TCGv_i32 bit = tcg_const_i32(1 << br); \

            \

            gen_helper_##rel(cpu_env, bit, cpu_FR[a], cpu_FR[b]); \

            tcg_temp_free(bit); \

        } \

    } while (0)



            switch (OP2) {

            case 1: /*UN.Sf*/

                gen_compare(un_s, RRR_R, RRR_S, RRR_T);

                break;



            case 2: /*OEQ.Sf*/

                gen_compare(oeq_s, RRR_R, RRR_S, RRR_T);

                break;



            case 3: /*UEQ.Sf*/

                gen_compare(ueq_s, RRR_R, RRR_S, RRR_T);

                break;



            case 4: /*OLT.Sf*/

                gen_compare(olt_s, RRR_R, RRR_S, RRR_T);

                break;



            case 5: /*ULT.Sf*/

                gen_compare(ult_s, RRR_R, RRR_S, RRR_T);

                break;



            case 6: /*OLE.Sf*/

                gen_compare(ole_s, RRR_R, RRR_S, RRR_T);

                break;



            case 7: /*ULE.Sf*/

                gen_compare(ule_s, RRR_R, RRR_S, RRR_T);

                break;



#undef gen_compare



            case 8: /*MOVEQZ.Sf*/

            case 9: /*MOVNEZ.Sf*/

            case 10: /*MOVLTZ.Sf*/

            case 11: /*MOVGEZ.Sf*/

                if (gen_window_check1(dc, RRR_T) &&

                    gen_check_cpenable(dc, 0)) {

                    static const TCGCond cond[] = {

                        TCG_COND_EQ,

                        TCG_COND_NE,

                        TCG_COND_LT,

                        TCG_COND_GE,

                    };

                    TCGv_i32 zero = tcg_const_i32(0);



                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_FR[RRR_R],

                            cpu_R[RRR_T], zero, cpu_FR[RRR_S], cpu_FR[RRR_R]);

                    tcg_temp_free(zero);

                }

                break;



            case 12: /*MOVF.Sf*/

            case 13: /*MOVT.Sf*/

                HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                if (gen_check_cpenable(dc, 0)) {

                    TCGv_i32 zero = tcg_const_i32(0);

                    TCGv_i32 tmp = tcg_temp_new_i32();



                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);

                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,

                            cpu_FR[RRR_R], tmp, zero,

                            cpu_FR[RRR_S], cpu_FR[RRR_R]);



                    tcg_temp_free(tmp);

                    tcg_temp_free(zero);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    case 1: /*L32R*/

        if (gen_window_check1(dc, RRR_T)) {

            TCGv_i32 tmp = tcg_const_i32(

                    ((dc->tb->flags & XTENSA_TBFLAG_LITBASE) ?

                     0 : ((dc->pc + 3) & ~3)) +

                    (0xfffc0000 | (RI16_IMM16 << 2)));



            if (dc->tb->flags & XTENSA_TBFLAG_LITBASE) {

                tcg_gen_add_i32(tmp, tmp, dc->litbase);

            }

            tcg_gen_qemu_ld32u(cpu_R[RRR_T], tmp, dc->cring);

            tcg_temp_free(tmp);

        }

        break;



    case 2: /*LSAI*/

#define gen_load_store(type, shift) do { \

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                \

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << shift); \

                if (shift) { \

                    gen_load_store_alignment(dc, shift, addr, false); \

                } \

                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \

                tcg_temp_free(addr); \

            } \

        } while (0)



        switch (RRI8_R) {

        case 0: /*L8UI*/

            gen_load_store(ld8u, 0);

            break;



        case 1: /*L16UI*/

            gen_load_store(ld16u, 1);

            break;



        case 2: /*L32I*/

            gen_load_store(ld32u, 2);

            break;



        case 4: /*S8I*/

            gen_load_store(st8, 0);

            break;



        case 5: /*S16I*/

            gen_load_store(st16, 1);

            break;



        case 6: /*S32I*/

            gen_load_store(st32, 2);

            break;



#define gen_dcache_hit_test(w, shift) do { \

            if (gen_window_check1(dc, RRI##w##_S)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                TCGv_i32 res = tcg_temp_new_i32(); \

                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \

                                 RRI##w##_IMM##w << shift); \

                tcg_gen_qemu_ld8u(res, addr, dc->cring); \

                tcg_temp_free(addr); \

                tcg_temp_free(res); \

            } \

        } while (0)



#define gen_dcache_hit_test4() gen_dcache_hit_test(4, 4)

#define gen_dcache_hit_test8() gen_dcache_hit_test(8, 2)



        case 7: /*CACHEc*/

            if (RRI8_T < 8) {

                HAS_OPTION(XTENSA_OPTION_DCACHE);

            }



            switch (RRI8_T) {

            case 0: /*DPFRc*/

                gen_window_check1(dc, RRI8_S);

                break;



            case 1: /*DPFWc*/

                gen_window_check1(dc, RRI8_S);

                break;



            case 2: /*DPFROc*/

                gen_window_check1(dc, RRI8_S);

                break;



            case 3: /*DPFWOc*/

                gen_window_check1(dc, RRI8_S);

                break;



            case 4: /*DHWBc*/

                gen_dcache_hit_test8();

                break;



            case 5: /*DHWBIc*/

                gen_dcache_hit_test8();

                break;



            case 6: /*DHIc*/

                if (gen_check_privilege(dc)) {

                    gen_dcache_hit_test8();

                }

                break;



            case 7: /*DIIc*/

                if (gen_check_privilege(dc)) {

                    gen_window_check1(dc, RRI8_S);

                }

                break;



            case 8: /*DCEc*/

                switch (OP1) {

                case 0: /*DPFLl*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_dcache_hit_test4();

                    }

                    break;



                case 2: /*DHUl*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_dcache_hit_test4();

                    }

                    break;



                case 3: /*DIUl*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_window_check1(dc, RRI4_S);

                    }

                    break;



                case 4: /*DIWBc*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE);

                    if (gen_check_privilege(dc)) {

                        gen_window_check1(dc, RRI4_S);

                    }

                    break;



                case 5: /*DIWBIc*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE);

                    if (gen_check_privilege(dc)) {

                        gen_window_check1(dc, RRI4_S);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;



                }

                break;



#undef gen_dcache_hit_test

#undef gen_dcache_hit_test4

#undef gen_dcache_hit_test8



#define gen_icache_hit_test(w, shift) do { \

            if (gen_window_check1(dc, RRI##w##_S)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                tcg_gen_movi_i32(cpu_pc, dc->pc); \

                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \

                                 RRI##w##_IMM##w << shift); \

                gen_helper_itlb_hit_test(cpu_env, addr); \

                tcg_temp_free(addr); \

            }\

        } while (0)



#define gen_icache_hit_test4() gen_icache_hit_test(4, 4)

#define gen_icache_hit_test8() gen_icache_hit_test(8, 2)



            case 12: /*IPFc*/

                HAS_OPTION(XTENSA_OPTION_ICACHE);

                gen_window_check1(dc, RRI8_S);

                break;



            case 13: /*ICEc*/

                switch (OP1) {

                case 0: /*IPFLl*/

                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_icache_hit_test4();

                    }

                    break;



                case 2: /*IHUl*/

                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_icache_hit_test4();

                    }

                    break;



                case 3: /*IIUl*/

                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_window_check1(dc, RRI4_S);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            case 14: /*IHIc*/

                HAS_OPTION(XTENSA_OPTION_ICACHE);

                gen_icache_hit_test8();

                break;



            case 15: /*IIIc*/

                HAS_OPTION(XTENSA_OPTION_ICACHE);

                if (gen_check_privilege(dc)) {

                    gen_window_check1(dc, RRI8_S);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



#undef gen_icache_hit_test

#undef gen_icache_hit_test4

#undef gen_icache_hit_test8



        case 9: /*L16SI*/

            gen_load_store(ld16s, 1);

            break;

#undef gen_load_store



        case 10: /*MOVI*/

            if (gen_window_check1(dc, RRI8_T)) {

                tcg_gen_movi_i32(cpu_R[RRI8_T],

                                 RRI8_IMM8 | (RRI8_S << 8) |

                                 ((RRI8_S & 0x8) ? 0xfffff000 : 0));

            }

            break;



#define gen_load_store_no_hw_align(type) do { \

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \

                TCGv_i32 addr = tcg_temp_local_new_i32(); \

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2); \

                gen_load_store_alignment(dc, 2, addr, true); \

                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \

                tcg_temp_free(addr); \

            } \

        } while (0)



        case 11: /*L32AIy*/

            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);

            gen_load_store_no_hw_align(ld32u); /*TODO acquire?*/

            break;



        case 12: /*ADDI*/

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE);

            }

            break;



        case 13: /*ADDMI*/

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S],

                                 RRI8_IMM8_SE << 8);

            }

            break;



        case 14: /*S32C1Iy*/

            HAS_OPTION(XTENSA_OPTION_CONDITIONAL_STORE);

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                int label = gen_new_label();

                TCGv_i32 tmp = tcg_temp_local_new_i32();

                TCGv_i32 addr = tcg_temp_local_new_i32();

                TCGv_i32 tpc;



                tcg_gen_mov_i32(tmp, cpu_R[RRI8_T]);

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);

                gen_load_store_alignment(dc, 2, addr, true);



                gen_advance_ccount(dc);

                tpc = tcg_const_i32(dc->pc);

                gen_helper_check_atomctl(cpu_env, tpc, addr);

                tcg_gen_qemu_ld32u(cpu_R[RRI8_T], addr, dc->cring);

                tcg_gen_brcond_i32(TCG_COND_NE, cpu_R[RRI8_T],

                        cpu_SR[SCOMPARE1], label);



                tcg_gen_qemu_st32(tmp, addr, dc->cring);



                gen_set_label(label);

                tcg_temp_free(tpc);

                tcg_temp_free(addr);

                tcg_temp_free(tmp);

            }

            break;



        case 15: /*S32RIy*/

            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);

            gen_load_store_no_hw_align(st32); /*TODO release?*/

            break;

#undef gen_load_store_no_hw_align



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    case 3: /*LSCIp*/

        switch (RRI8_R) {

        case 0: /*LSIf*/

        case 4: /*SSIf*/

        case 8: /*LSIUf*/

        case 12: /*SSIUf*/

            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);

            if (gen_window_check1(dc, RRI8_S) &&

                gen_check_cpenable(dc, 0)) {

                TCGv_i32 addr = tcg_temp_new_i32();

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);

                gen_load_store_alignment(dc, 2, addr, false);

                if (RRI8_R & 0x4) {

                    tcg_gen_qemu_st32(cpu_FR[RRI8_T], addr, dc->cring);

                } else {

                    tcg_gen_qemu_ld32u(cpu_FR[RRI8_T], addr, dc->cring);

                }

                if (RRI8_R & 0x8) {

                    tcg_gen_mov_i32(cpu_R[RRI8_S], addr);

                }

                tcg_temp_free(addr);

            }

            break;



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    case 4: /*MAC16d*/

        HAS_OPTION(XTENSA_OPTION_MAC16);

        {

            enum {

                MAC16_UMUL = 0x0,

                MAC16_MUL  = 0x4,

                MAC16_MULA = 0x8,

                MAC16_MULS = 0xc,

                MAC16_NONE = 0xf,

            } op = OP1 & 0xc;

            bool is_m1_sr = (OP2 & 0x3) == 2;

            bool is_m2_sr = (OP2 & 0xc) == 0;

            uint32_t ld_offset = 0;



            if (OP2 > 9) {

                RESERVED();

            }



            switch (OP2 & 2) {

            case 0: /*MACI?/MACC?*/

                is_m1_sr = true;

                ld_offset = (OP2 & 1) ? -4 : 4;



                if (OP2 >= 8) { /*MACI/MACC*/

                    if (OP1 == 0) { /*LDINC/LDDEC*/

                        op = MAC16_NONE;

                    } else {

                        RESERVED();

                    }

                } else if (op != MAC16_MULA) { /*MULA.*.*.LDINC/LDDEC*/

                    RESERVED();

                }

                break;



            case 2: /*MACD?/MACA?*/

                if (op == MAC16_UMUL && OP2 != 7) { /*UMUL only in MACAA*/

                    RESERVED();

                }

                break;

            }



            if (op != MAC16_NONE) {

                if (!is_m1_sr && !gen_window_check1(dc, RRR_S)) {

                    break;

                }

                if (!is_m2_sr && !gen_window_check1(dc, RRR_T)) {

                    break;

                }

            }



            if (ld_offset && !gen_window_check1(dc, RRR_S)) {

                break;

            }



            {

                TCGv_i32 vaddr = tcg_temp_new_i32();

                TCGv_i32 mem32 = tcg_temp_new_i32();



                if (ld_offset) {

                    tcg_gen_addi_i32(vaddr, cpu_R[RRR_S], ld_offset);

                    gen_load_store_alignment(dc, 2, vaddr, false);

                    tcg_gen_qemu_ld32u(mem32, vaddr, dc->cring);

                }

                if (op != MAC16_NONE) {

                    TCGv_i32 m1 = gen_mac16_m(

                            is_m1_sr ? cpu_SR[MR + RRR_X] : cpu_R[RRR_S],

                            OP1 & 1, op == MAC16_UMUL);

                    TCGv_i32 m2 = gen_mac16_m(

                            is_m2_sr ? cpu_SR[MR + 2 + RRR_Y] : cpu_R[RRR_T],

                            OP1 & 2, op == MAC16_UMUL);



                    if (op == MAC16_MUL || op == MAC16_UMUL) {

                        tcg_gen_mul_i32(cpu_SR[ACCLO], m1, m2);

                        if (op == MAC16_UMUL) {

                            tcg_gen_movi_i32(cpu_SR[ACCHI], 0);

                        } else {

                            tcg_gen_sari_i32(cpu_SR[ACCHI], cpu_SR[ACCLO], 31);

                        }

                    } else {

                        TCGv_i32 lo = tcg_temp_new_i32();

                        TCGv_i32 hi = tcg_temp_new_i32();



                        tcg_gen_mul_i32(lo, m1, m2);

                        tcg_gen_sari_i32(hi, lo, 31);

                        if (op == MAC16_MULA) {

                            tcg_gen_add2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             lo, hi);

                        } else {

                            tcg_gen_sub2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             lo, hi);

                        }

                        tcg_gen_ext8s_i32(cpu_SR[ACCHI], cpu_SR[ACCHI]);



                        tcg_temp_free_i32(lo);

                        tcg_temp_free_i32(hi);

                    }

                    tcg_temp_free(m1);

                    tcg_temp_free(m2);

                }

                if (ld_offset) {

                    tcg_gen_mov_i32(cpu_R[RRR_S], vaddr);

                    tcg_gen_mov_i32(cpu_SR[MR + RRR_W], mem32);

                }

                tcg_temp_free(vaddr);

                tcg_temp_free(mem32);

            }

        }

        break;



    case 5: /*CALLN*/

        switch (CALL_N) {

        case 0: /*CALL0*/

            tcg_gen_movi_i32(cpu_R[0], dc->next_pc);

            gen_jumpi(dc, (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);

            break;



        case 1: /*CALL4w*/

        case 2: /*CALL8w*/

        case 3: /*CALL12w*/

            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

            if (gen_window_check1(dc, CALL_N << 2)) {

                gen_callwi(dc, CALL_N,

                           (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);

            }

            break;

        }

        break;



    case 6: /*SI*/

        switch (CALL_N) {

        case 0: /*J*/

            gen_jumpi(dc, dc->pc + 4 + CALL_OFFSET_SE, 0);

            break;



        case 1: /*BZ*/

            if (gen_window_check1(dc, BRI12_S)) {

                static const TCGCond cond[] = {

                    TCG_COND_EQ, /*BEQZ*/

                    TCG_COND_NE, /*BNEZ*/

                    TCG_COND_LT, /*BLTZ*/

                    TCG_COND_GE, /*BGEZ*/

                };



                gen_brcondi(dc, cond[BRI12_M & 3], cpu_R[BRI12_S], 0,

                        4 + BRI12_IMM12_SE);

            }

            break;



        case 2: /*BI0*/

            if (gen_window_check1(dc, BRI8_S)) {

                static const TCGCond cond[] = {

                    TCG_COND_EQ, /*BEQI*/

                    TCG_COND_NE, /*BNEI*/

                    TCG_COND_LT, /*BLTI*/

                    TCG_COND_GE, /*BGEI*/

                };



                gen_brcondi(dc, cond[BRI8_M & 3],

                        cpu_R[BRI8_S], B4CONST[BRI8_R], 4 + BRI8_IMM8_SE);

            }

            break;



        case 3: /*BI1*/

            switch (BRI8_M) {

            case 0: /*ENTRYw*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                {

                    TCGv_i32 pc = tcg_const_i32(dc->pc);

                    TCGv_i32 s = tcg_const_i32(BRI12_S);

                    TCGv_i32 imm = tcg_const_i32(BRI12_IMM12);

                    gen_advance_ccount(dc);

                    gen_helper_entry(cpu_env, pc, s, imm);

                    tcg_temp_free(imm);

                    tcg_temp_free(s);

                    tcg_temp_free(pc);

                    /* This can change tb->flags, so exit tb */

                    gen_jumpi_check_loop_end(dc, -1);

                }

                break;



            case 1: /*B1*/

                switch (BRI8_R) {

                case 0: /*BFp*/

                case 1: /*BTp*/

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                    {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRI8_S);

                        gen_brcondi(dc,

                                BRI8_R == 1 ? TCG_COND_NE : TCG_COND_EQ,

                                tmp, 0, 4 + RRI8_IMM8_SE);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 8: /*LOOP*/

                case 9: /*LOOPNEZ*/

                case 10: /*LOOPGTZ*/

                    HAS_OPTION(XTENSA_OPTION_LOOP);

                    if (gen_window_check1(dc, RRI8_S)) {

                        uint32_t lend = dc->pc + RRI8_IMM8 + 4;

                        TCGv_i32 tmp = tcg_const_i32(lend);



                        tcg_gen_subi_i32(cpu_SR[LCOUNT], cpu_R[RRI8_S], 1);

                        tcg_gen_movi_i32(cpu_SR[LBEG], dc->next_pc);

                        gen_helper_wsr_lend(cpu_env, tmp);

                        tcg_temp_free(tmp);



                        if (BRI8_R > 8) {

                            int label = gen_new_label();

                            tcg_gen_brcondi_i32(

                                    BRI8_R == 9 ? TCG_COND_NE : TCG_COND_GT,

                                    cpu_R[RRI8_S], 0, label);

                            gen_jumpi(dc, lend, 1);

                            gen_set_label(label);

                        }



                        gen_jumpi(dc, dc->next_pc, 0);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;



                }

                break;



            case 2: /*BLTUI*/

            case 3: /*BGEUI*/

                if (gen_window_check1(dc, BRI8_S)) {

                    gen_brcondi(dc, BRI8_M == 2 ? TCG_COND_LTU : TCG_COND_GEU,

                                cpu_R[BRI8_S], B4CONSTU[BRI8_R],

                                4 + BRI8_IMM8_SE);

                }

                break;

            }

            break;



        }

        break;



    case 7: /*B*/

        {

            TCGCond eq_ne = (RRI8_R & 8) ? TCG_COND_NE : TCG_COND_EQ;



            switch (RRI8_R & 7) {

            case 0: /*BNONE*/ /*BANY*/

                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);

                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                }

                break;



            case 1: /*BEQ*/ /*BNE*/

            case 2: /*BLT*/ /*BGE*/

            case 3: /*BLTU*/ /*BGEU*/

                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                    static const TCGCond cond[] = {

                        [1] = TCG_COND_EQ,

                        [2] = TCG_COND_LT,

                        [3] = TCG_COND_LTU,

                        [9] = TCG_COND_NE,

                        [10] = TCG_COND_GE,

                        [11] = TCG_COND_GEU,

                    };

                    gen_brcond(dc, cond[RRI8_R], cpu_R[RRI8_S], cpu_R[RRI8_T],

                            4 + RRI8_IMM8_SE);

                }

                break;



            case 4: /*BALL*/ /*BNALL*/

                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);

                    gen_brcond(dc, eq_ne, tmp, cpu_R[RRI8_T],

                            4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                }

                break;



            case 5: /*BBC*/ /*BBS*/

                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

#ifdef TARGET_WORDS_BIGENDIAN

                    TCGv_i32 bit = tcg_const_i32(0x80000000);

#else

                    TCGv_i32 bit = tcg_const_i32(0x00000001);

#endif

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_T], 0x1f);

#ifdef TARGET_WORDS_BIGENDIAN

                    tcg_gen_shr_i32(bit, bit, tmp);

#else

                    tcg_gen_shl_i32(bit, bit, tmp);

#endif

                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], bit);

                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                    tcg_temp_free(bit);

                }

                break;



            case 6: /*BBCI*/ /*BBSI*/

            case 7:

                if (gen_window_check1(dc, RRI8_S)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_S],

#ifdef TARGET_WORDS_BIGENDIAN

                            0x80000000 >> (((RRI8_R & 1) << 4) | RRI8_T));

#else

                            0x00000001 << (((RRI8_R & 1) << 4) | RRI8_T));

#endif

                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                }

                break;



            }

        }

        break;



#define gen_narrow_load_store(type) do { \

            if (gen_window_check2(dc, RRRN_S, RRRN_T)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                tcg_gen_addi_i32(addr, cpu_R[RRRN_S], RRRN_R << 2); \

                gen_load_store_alignment(dc, 2, addr, false); \

                tcg_gen_qemu_##type(cpu_R[RRRN_T], addr, dc->cring); \

                tcg_temp_free(addr); \

            } \

        } while (0)



    case 8: /*L32I.Nn*/

        gen_narrow_load_store(ld32u);

        break;



    case 9: /*S32I.Nn*/

        gen_narrow_load_store(st32);

        break;

#undef gen_narrow_load_store



    case 10: /*ADD.Nn*/

        if (gen_window_check3(dc, RRRN_R, RRRN_S, RRRN_T)) {

            tcg_gen_add_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], cpu_R[RRRN_T]);

        }

        break;



    case 11: /*ADDI.Nn*/

        if (gen_window_check2(dc, RRRN_R, RRRN_S)) {

            tcg_gen_addi_i32(cpu_R[RRRN_R], cpu_R[RRRN_S],

                             RRRN_T ? RRRN_T : -1);

        }

        break;



    case 12: /*ST2n*/

        if (!gen_window_check1(dc, RRRN_S)) {

            break;

        }

        if (RRRN_T < 8) { /*MOVI.Nn*/

            tcg_gen_movi_i32(cpu_R[RRRN_S],

                    RRRN_R | (RRRN_T << 4) |

                    ((RRRN_T & 6) == 6 ? 0xffffff80 : 0));

        } else { /*BEQZ.Nn*/ /*BNEZ.Nn*/

            TCGCond eq_ne = (RRRN_T & 4) ? TCG_COND_NE : TCG_COND_EQ;



            gen_brcondi(dc, eq_ne, cpu_R[RRRN_S], 0,

                    4 + (RRRN_R | ((RRRN_T & 3) << 4)));

        }

        break;



    case 13: /*ST3n*/

        switch (RRRN_R) {

        case 0: /*MOV.Nn*/

            if (gen_window_check2(dc, RRRN_S, RRRN_T)) {

                tcg_gen_mov_i32(cpu_R[RRRN_T], cpu_R[RRRN_S]);

            }

            break;



        case 15: /*S3*/

            switch (RRRN_T) {

            case 0: /*RET.Nn*/

                gen_jump(dc, cpu_R[0]);

                break;



            case 1: /*RETW.Nn*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                {

                    TCGv_i32 tmp = tcg_const_i32(dc->pc);

                    gen_advance_ccount(dc);

                    gen_helper_retw(tmp, cpu_env, tmp);

                    gen_jump(dc, tmp);

                    tcg_temp_free(tmp);

                }

                break;



            case 2: /*BREAK.Nn*/

                HAS_OPTION(XTENSA_OPTION_DEBUG);

                if (dc->debug) {

                    gen_debug_exception(dc, DEBUGCAUSE_BN);

                }

                break;



            case 3: /*NOP.Nn*/

                break;



            case 6: /*ILL.Nn*/

                gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    default: /*reserved*/

        RESERVED();

        break;

    }



    if (dc->is_jmp == DISAS_NEXT) {

        gen_check_loop_end(dc, 0);

    }

    dc->pc = dc->next_pc;



    return;



invalid_opcode:

    qemu_log(""INVALID(pc = %08x)\n"", dc->pc);

    gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

#undef HAS_OPTION

}
",11140,"static void disas_xtensa_insn(CPUXtensaState *iv, DisasContext *dc)

{

#define HAS_OPTION_BITS(opt) do { \

        if (!option_bits_enabled(dc, opt)) { \

            qemu_log(""Option is not enabled %s:%d
"", \

                    __FILE__, __LINE__); \

            goto invalid_opcode; \

        } \

    } while (0)



#define HAS_OPTION(opt) HAS_OPTION_BITS(XTENSA_OPTION_BIT(opt))



#define TBD() qemu_log(""TBD(pc = %08x): %s:%d
"", dc->pc, __FILE__, __LINE__)

#define RESERVED() do { \

        qemu_log(""RESERVED(pc = %08x, %02x%02x%02x): %s:%d
"", \

                dc->pc, b0, b1, b2, __FILE__, __LINE__); \

        goto invalid_opcode; \

    } while (0)





#ifdef TARGET_WORDS_BIGENDIAN

#define OP0 (((b0) & 0xf0) >> 4)

#define OP1 (((b2) & 0xf0) >> 4)

#define OP2 ((b2) & 0xf)

#define RRR_R ((b1) & 0xf)

#define RRR_S (((b1) & 0xf0) >> 4)

#define RRR_T ((b0) & 0xf)

#else

#define OP0 (((b0) & 0xf))

#define OP1 (((b2) & 0xf))

#define OP2 (((b2) & 0xf0) >> 4)

#define RRR_R (((b1) & 0xf0) >> 4)

#define RRR_S (((b1) & 0xf))

#define RRR_T (((b0) & 0xf0) >> 4)

#endif

#define RRR_X ((RRR_R & 0x4) >> 2)

#define RRR_Y ((RRR_T & 0x4) >> 2)

#define RRR_W (RRR_R & 0x3)



#define RRRN_R RRR_R

#define RRRN_S RRR_S

#define RRRN_T RRR_T



#define RRI4_R RRR_R

#define RRI4_S RRR_S

#define RRI4_T RRR_T

#ifdef TARGET_WORDS_BIGENDIAN

#define RRI4_IMM4 ((b2) & 0xf)

#else

#define RRI4_IMM4 (((b2) & 0xf0) >> 4)

#endif



#define RRI8_R RRR_R

#define RRI8_S RRR_S

#define RRI8_T RRR_T

#define RRI8_IMM8 (b2)

#define RRI8_IMM8_SE ((((b2) & 0x80) ? 0xffffff00 : 0) | RRI8_IMM8)



#ifdef TARGET_WORDS_BIGENDIAN

#define RI16_IMM16 (((b1) << 8) | (b2))

#else

#define RI16_IMM16 (((b2) << 8) | (b1))

#endif



#ifdef TARGET_WORDS_BIGENDIAN

#define CALL_N (((b0) & 0xc) >> 2)

#define CALL_OFFSET ((((b0) & 0x3) << 16) | ((b1) << 8) | (b2))

#else

#define CALL_N (((b0) & 0x30) >> 4)

#define CALL_OFFSET ((((b0) & 0xc0) >> 6) | ((b1) << 2) | ((b2) << 10))

#endif

#define CALL_OFFSET_SE \

    (((CALL_OFFSET & 0x20000) ? 0xfffc0000 : 0) | CALL_OFFSET)



#define CALLX_N CALL_N

#ifdef TARGET_WORDS_BIGENDIAN

#define CALLX_M ((b0) & 0x3)

#else

#define CALLX_M (((b0) & 0xc0) >> 6)

#endif

#define CALLX_S RRR_S



#define BRI12_M CALLX_M

#define BRI12_S RRR_S

#ifdef TARGET_WORDS_BIGENDIAN

#define BRI12_IMM12 ((((b1) & 0xf) << 8) | (b2))

#else

#define BRI12_IMM12 ((((b1) & 0xf0) >> 4) | ((b2) << 4))

#endif

#define BRI12_IMM12_SE (((BRI12_IMM12 & 0x800) ? 0xfffff000 : 0) | BRI12_IMM12)



#define BRI8_M BRI12_M

#define BRI8_R RRI8_R

#define BRI8_S RRI8_S

#define BRI8_IMM8 RRI8_IMM8

#define BRI8_IMM8_SE RRI8_IMM8_SE



#define RSR_SR (b1)



    uint8_t b0 = cpu_ldub_code(iv, dc->pc);

    uint8_t b1 = cpu_ldub_code(iv, dc->pc + 1);

    uint8_t b2 = 0;

    unsigned len = xtensa_op0_insn_len(OP0);



    static const uint32_t B4CONST[] = {

        0xffffffff, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256

    };



    static const uint32_t B4CONSTU[] = {

        32768, 65536, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256

    };



    switch (len) {

    case 2:

        HAS_OPTION(XTENSA_OPTION_CODE_DENSITY);

        break;



    case 3:

        b2 = cpu_ldub_code(iv, dc->pc + 2);

        break;



    default:

        RESERVED();

    }

    dc->next_pc = dc->pc + len;



    switch (OP0) {

    case 0: /*QRST*/

        switch (OP1) {

        case 0: /*RST0*/

            switch (OP2) {

            case 0: /*ST0*/

                if ((RRR_R & 0xc) == 0x8) {

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                }



                switch (RRR_R) {

                case 0: /*SNM0*/

                    switch (CALLX_M) {

                    case 0: /*ILL*/

                        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

                        break;



                    case 1: /*reserved*/

                        RESERVED();

                        break;



                    case 2: /*JR*/

                        switch (CALLX_N) {

                        case 0: /*RET*/

                        case 2: /*JX*/

                            if (gen_window_check1(dc, CALLX_S)) {

                                gen_jump(dc, cpu_R[CALLX_S]);

                            }

                            break;



                        case 1: /*RETWw*/

                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                            {

                                TCGv_i32 tmp = tcg_const_i32(dc->pc);

                                gen_advance_ccount(dc);

                                gen_helper_retw(tmp, cpu_env, tmp);

                                gen_jump(dc, tmp);

                                tcg_temp_free(tmp);

                            }

                            break;



                        case 3: /*reserved*/

                            RESERVED();

                            break;

                        }

                        break;



                    case 3: /*CALLX*/

                        if (!gen_window_check2(dc, CALLX_S, CALLX_N << 2)) {

                            break;

                        }

                        switch (CALLX_N) {

                        case 0: /*CALLX0*/

                            {

                                TCGv_i32 tmp = tcg_temp_new_i32();

                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);

                                tcg_gen_movi_i32(cpu_R[0], dc->next_pc);

                                gen_jump(dc, tmp);

                                tcg_temp_free(tmp);

                            }

                            break;



                        case 1: /*CALLX4w*/

                        case 2: /*CALLX8w*/

                        case 3: /*CALLX12w*/

                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                            {

                                TCGv_i32 tmp = tcg_temp_new_i32();



                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);

                                gen_callw(dc, CALLX_N, tmp);

                                tcg_temp_free(tmp);

                            }

                            break;

                        }

                        break;

                    }

                    break;



                case 1: /*MOVSPw*/

                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                    if (gen_window_check2(dc, RRR_T, RRR_S)) {

                        TCGv_i32 pc = tcg_const_i32(dc->pc);

                        gen_advance_ccount(dc);

                        gen_helper_movsp(cpu_env, pc);

                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_R[RRR_S]);

                        tcg_temp_free(pc);

                    }

                    break;



                case 2: /*SYNC*/

                    switch (RRR_T) {

                    case 0: /*ISYNC*/

                        break;



                    case 1: /*RSYNC*/

                        break;



                    case 2: /*ESYNC*/

                        break;



                    case 3: /*DSYNC*/

                        break;



                    case 8: /*EXCW*/

                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);

                        break;



                    case 12: /*MEMW*/

                        break;



                    case 13: /*EXTW*/

                        break;



                    case 15: /*NOP*/

                        break;



                    default: /*reserved*/

                        RESERVED();

                        break;

                    }

                    break;



                case 3: /*RFEIx*/

                    switch (RRR_T) {

                    case 0: /*RFETx*/

                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);

                        switch (RRR_S) {

                        case 0: /*RFEx*/

                            if (gen_check_privilege(dc)) {

                                tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);

                                gen_helper_check_interrupts(cpu_env);

                                gen_jump(dc, cpu_SR[EPC1]);

                            }

                            break;



                        case 1: /*RFUEx*/

                            RESERVED();

                            break;



                        case 2: /*RFDEx*/

                            if (gen_check_privilege(dc)) {

                                gen_jump(dc, cpu_SR[

                                         dc->config->ndepc ? DEPC : EPC1]);

                            }

                            break;



                        case 4: /*RFWOw*/

                        case 5: /*RFWUw*/

                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                            if (gen_check_privilege(dc)) {

                                TCGv_i32 tmp = tcg_const_i32(1);



                                tcg_gen_andi_i32(

                                        cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);

                                tcg_gen_shl_i32(tmp, tmp, cpu_SR[WINDOW_BASE]);



                                if (RRR_S == 4) {

                                    tcg_gen_andc_i32(cpu_SR[WINDOW_START],

                                            cpu_SR[WINDOW_START], tmp);

                                } else {

                                    tcg_gen_or_i32(cpu_SR[WINDOW_START],

                                            cpu_SR[WINDOW_START], tmp);

                                }



                                gen_helper_restore_owb(cpu_env);

                                gen_helper_check_interrupts(cpu_env);

                                gen_jump(dc, cpu_SR[EPC1]);



                                tcg_temp_free(tmp);

                            }

                            break;



                        default: /*reserved*/

                            RESERVED();

                            break;

                        }

                        break;



                    case 1: /*RFIx*/

                        HAS_OPTION(XTENSA_OPTION_HIGH_PRIORITY_INTERRUPT);

                        if (RRR_S >= 2 && RRR_S <= dc->config->nlevel) {

                            if (gen_check_privilege(dc)) {

                                tcg_gen_mov_i32(cpu_SR[PS],

                                                cpu_SR[EPS2 + RRR_S - 2]);

                                gen_helper_check_interrupts(cpu_env);

                                gen_jump(dc, cpu_SR[EPC1 + RRR_S - 1]);

                            }

                        } else {

                            qemu_log(""RFI %d is illegal
"", RRR_S);

                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

                        }

                        break;



                    case 2: /*RFME*/

                        TBD();

                        break;



                    default: /*reserved*/

                        RESERVED();

                        break;



                    }

                    break;



                case 4: /*BREAKx*/

                    HAS_OPTION(XTENSA_OPTION_DEBUG);

                    if (dc->debug) {

                        gen_debug_exception(dc, DEBUGCAUSE_BI);

                    }

                    break;



                case 5: /*SYSCALLx*/

                    HAS_OPTION(XTENSA_OPTION_EXCEPTION);

                    switch (RRR_S) {

                    case 0: /*SYSCALLx*/

                        gen_exception_cause(dc, SYSCALL_CAUSE);

                        break;



                    case 1: /*SIMCALL*/

                        if (semihosting_enabled) {

                            if (gen_check_privilege(dc)) {

                                gen_helper_simcall(cpu_env);

                            }

                        } else {

                            qemu_log(""SIMCALL but semihosting is disabled
"");

                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

                        }

                        break;



                    default:

                        RESERVED();

                        break;

                    }

                    break;



                case 6: /*RSILx*/

                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);

                    if (gen_check_privilege(dc) &&

                        gen_window_check1(dc, RRR_T)) {

                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_SR[PS]);

                        tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_INTLEVEL);

                        tcg_gen_ori_i32(cpu_SR[PS], cpu_SR[PS], RRR_S);

                        gen_helper_check_interrupts(cpu_env);

                        gen_jumpi_check_loop_end(dc, 0);

                    }

                    break;



                case 7: /*WAITIx*/

                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);

                    if (gen_check_privilege(dc)) {

                        gen_waiti(dc, RRR_S);

                    }

                    break;



                case 8: /*ANY4p*/

                case 9: /*ALL4p*/

                case 10: /*ANY8p*/

                case 11: /*ALL8p*/

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                    {

                        const unsigned shift = (RRR_R & 2) ? 8 : 4;

                        TCGv_i32 mask = tcg_const_i32(

                                ((1 << shift) - 1) << RRR_S);

                        TCGv_i32 tmp = tcg_temp_new_i32();



                        tcg_gen_and_i32(tmp, cpu_SR[BR], mask);

                        if (RRR_R & 1) { /*ALL*/

                            tcg_gen_addi_i32(tmp, tmp, 1 << RRR_S);

                        } else { /*ANY*/

                            tcg_gen_add_i32(tmp, tmp, mask);

                        }

                        tcg_gen_shri_i32(tmp, tmp, RRR_S + shift);

                        tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR],

                                tmp, RRR_T, 1);

                        tcg_temp_free(mask);

                        tcg_temp_free(tmp);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;



                }

                break;



            case 1: /*AND*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_and_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 2: /*OR*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_or_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 3: /*XOR*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_xor_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 4: /*ST1*/

                switch (RRR_R) {

                case 0: /*SSR*/

                    if (gen_window_check1(dc, RRR_S)) {

                        gen_right_shift_sar(dc, cpu_R[RRR_S]);

                    }

                    break;



                case 1: /*SSL*/

                    if (gen_window_check1(dc, RRR_S)) {

                        gen_left_shift_sar(dc, cpu_R[RRR_S]);

                    }

                    break;



                case 2: /*SSA8L*/

                    if (gen_window_check1(dc, RRR_S)) {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);

                        gen_right_shift_sar(dc, tmp);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 3: /*SSA8B*/

                    if (gen_window_check1(dc, RRR_S)) {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);

                        gen_left_shift_sar(dc, tmp);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 4: /*SSAI*/

                    {

                        TCGv_i32 tmp = tcg_const_i32(

                                RRR_S | ((RRR_T & 1) << 4));

                        gen_right_shift_sar(dc, tmp);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 6: /*RER*/

                    TBD();

                    break;



                case 7: /*WER*/

                    TBD();

                    break;



                case 8: /*ROTWw*/

                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                    if (gen_check_privilege(dc)) {

                        TCGv_i32 tmp = tcg_const_i32(

                                RRR_T | ((RRR_T & 8) ? 0xfffffff0 : 0));

                        gen_helper_rotw(cpu_env, tmp);

                        tcg_temp_free(tmp);

                        /* This can change tb->flags, so exit tb */

                        gen_jumpi_check_loop_end(dc, -1);

                    }

                    break;



                case 14: /*NSAu*/

                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);

                    if (gen_window_check2(dc, RRR_S, RRR_T)) {

                        gen_helper_nsa(cpu_R[RRR_T], cpu_R[RRR_S]);

                    }

                    break;



                case 15: /*NSAUu*/

                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);

                    if (gen_window_check2(dc, RRR_S, RRR_T)) {

                        gen_helper_nsau(cpu_R[RRR_T], cpu_R[RRR_S]);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            case 5: /*TLB*/

                HAS_OPTION_BITS(

                        XTENSA_OPTION_BIT(XTENSA_OPTION_MMU) |

                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_PROTECTION) |

                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_TRANSLATION));

                if (gen_check_privilege(dc) &&

                    gen_window_check2(dc, RRR_S, RRR_T)) {

                    TCGv_i32 dtlb = tcg_const_i32((RRR_R & 8) != 0);



                    switch (RRR_R & 7) {

                    case 3: /*RITLB0*/ /*RDTLB0*/

                        gen_helper_rtlb0(cpu_R[RRR_T],

                                cpu_env, cpu_R[RRR_S], dtlb);

                        break;



                    case 4: /*IITLB*/ /*IDTLB*/

                        gen_helper_itlb(cpu_env, cpu_R[RRR_S], dtlb);

                        /* This could change memory mapping, so exit tb */

                        gen_jumpi_check_loop_end(dc, -1);

                        break;



                    case 5: /*PITLB*/ /*PDTLB*/

                        tcg_gen_movi_i32(cpu_pc, dc->pc);

                        gen_helper_ptlb(cpu_R[RRR_T],

                                cpu_env, cpu_R[RRR_S], dtlb);

                        break;



                    case 6: /*WITLB*/ /*WDTLB*/

                        gen_helper_wtlb(

                                cpu_env, cpu_R[RRR_T], cpu_R[RRR_S], dtlb);

                        /* This could change memory mapping, so exit tb */

                        gen_jumpi_check_loop_end(dc, -1);

                        break;



                    case 7: /*RITLB1*/ /*RDTLB1*/

                        gen_helper_rtlb1(cpu_R[RRR_T],

                                cpu_env, cpu_R[RRR_S], dtlb);

                        break;



                    default:

                        tcg_temp_free(dtlb);

                        RESERVED();

                        break;

                    }

                    tcg_temp_free(dtlb);

                }

                break;



            case 6: /*RT0*/

                if (!gen_window_check2(dc, RRR_R, RRR_T)) {

                    break;

                }

                switch (RRR_S) {

                case 0: /*NEG*/

                    tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);

                    break;



                case 1: /*ABS*/

                    {

                        TCGv_i32 zero = tcg_const_i32(0);

                        TCGv_i32 neg = tcg_temp_new_i32();



                        tcg_gen_neg_i32(neg, cpu_R[RRR_T]);

                        tcg_gen_movcond_i32(TCG_COND_GE, cpu_R[RRR_R],

                                cpu_R[RRR_T], zero, cpu_R[RRR_T], neg);

                        tcg_temp_free(neg);

                        tcg_temp_free(zero);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            case 7: /*reserved*/

                RESERVED();

                break;



            case 8: /*ADD*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_add_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 9: /*ADD**/

            case 10:

            case 11:

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 8);

                    tcg_gen_add_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);

                    tcg_temp_free(tmp);

                }

                break;



            case 12: /*SUB*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_sub_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 13: /*SUB**/

            case 14:

            case 15:

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 12);

                    tcg_gen_sub_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);

                    tcg_temp_free(tmp);

                }

                break;

            }

            break;



        case 1: /*RST1*/

            switch (OP2) {

            case 0: /*SLLI*/

            case 1:

                if (gen_window_check2(dc, RRR_R, RRR_S)) {

                    tcg_gen_shli_i32(cpu_R[RRR_R], cpu_R[RRR_S],

                                     32 - (RRR_T | ((OP2 & 1) << 4)));

                }

                break;



            case 2: /*SRAI*/

            case 3:

                if (gen_window_check2(dc, RRR_R, RRR_T)) {

                    tcg_gen_sari_i32(cpu_R[RRR_R], cpu_R[RRR_T],

                                     RRR_S | ((OP2 & 1) << 4));

                }

                break;



            case 4: /*SRLI*/

                if (gen_window_check2(dc, RRR_R, RRR_T)) {

                    tcg_gen_shri_i32(cpu_R[RRR_R], cpu_R[RRR_T], RRR_S);

                }

                break;



            case 6: /*XSR*/

                if (gen_check_sr(dc, RSR_SR, SR_X) &&

                    (RSR_SR < 64 || gen_check_privilege(dc)) &&

                    gen_window_check1(dc, RRR_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();



                    tcg_gen_mov_i32(tmp, cpu_R[RRR_T]);

                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);

                    gen_wsr(dc, RSR_SR, tmp);

                    tcg_temp_free(tmp);

                }

                break;



                /*

                 * Note: 64 bit ops are used here solely because SAR values

                 * have range 0..63

                 */

#define gen_shift_reg(cmd, reg) do { \

                    TCGv_i64 tmp = tcg_temp_new_i64(); \

                    tcg_gen_extu_i32_i64(tmp, reg); \

                    tcg_gen_##cmd##_i64(v, v, tmp); \

                    tcg_gen_trunc_i64_i32(cpu_R[RRR_R], v); \

                    tcg_temp_free_i64(v); \

                    tcg_temp_free_i64(tmp); \

                } while (0)



#define gen_shift(cmd) gen_shift_reg(cmd, cpu_SR[SAR])



            case 8: /*SRC*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i64 v = tcg_temp_new_i64();

                    tcg_gen_concat_i32_i64(v, cpu_R[RRR_T], cpu_R[RRR_S]);

                    gen_shift(shr);

                }

                break;



            case 9: /*SRL*/

                if (!gen_window_check2(dc, RRR_R, RRR_T)) {

                    break;

                }

                if (dc->sar_5bit) {

                    tcg_gen_shr_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);

                } else {

                    TCGv_i64 v = tcg_temp_new_i64();

                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_T]);

                    gen_shift(shr);

                }

                break;



            case 10: /*SLL*/

                if (!gen_window_check2(dc, RRR_R, RRR_S)) {

                    break;

                }

                if (dc->sar_m32_5bit) {

                    tcg_gen_shl_i32(cpu_R[RRR_R], cpu_R[RRR_S], dc->sar_m32);

                } else {

                    TCGv_i64 v = tcg_temp_new_i64();

                    TCGv_i32 s = tcg_const_i32(32);

                    tcg_gen_sub_i32(s, s, cpu_SR[SAR]);

                    tcg_gen_andi_i32(s, s, 0x3f);

                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_S]);

                    gen_shift_reg(shl, s);

                    tcg_temp_free(s);

                }

                break;



            case 11: /*SRA*/

                if (!gen_window_check2(dc, RRR_R, RRR_T)) {

                    break;

                }

                if (dc->sar_5bit) {

                    tcg_gen_sar_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);

                } else {

                    TCGv_i64 v = tcg_temp_new_i64();

                    tcg_gen_ext_i32_i64(v, cpu_R[RRR_T]);

                    gen_shift(sar);

                }

                break;

#undef gen_shift

#undef gen_shift_reg



            case 12: /*MUL16U*/

                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 v1 = tcg_temp_new_i32();

                    TCGv_i32 v2 = tcg_temp_new_i32();

                    tcg_gen_ext16u_i32(v1, cpu_R[RRR_S]);

                    tcg_gen_ext16u_i32(v2, cpu_R[RRR_T]);

                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);

                    tcg_temp_free(v2);

                    tcg_temp_free(v1);

                }

                break;



            case 13: /*MUL16S*/

                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 v1 = tcg_temp_new_i32();

                    TCGv_i32 v2 = tcg_temp_new_i32();

                    tcg_gen_ext16s_i32(v1, cpu_R[RRR_S]);

                    tcg_gen_ext16s_i32(v2, cpu_R[RRR_T]);

                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);

                    tcg_temp_free(v2);

                    tcg_temp_free(v1);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 2: /*RST2*/

            if (OP2 >= 8 && !gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                break;

            }



            if (OP2 >= 12) {

                HAS_OPTION(XTENSA_OPTION_32_BIT_IDIV);

                int label = gen_new_label();

                tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0, label);

                gen_exception_cause(dc, INTEGER_DIVIDE_BY_ZERO_CAUSE);

                gen_set_label(label);

            }



            switch (OP2) {

#define BOOLEAN_LOGIC(fn, r, s, t) \

                do { \

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN); \

                    TCGv_i32 tmp1 = tcg_temp_new_i32(); \

                    TCGv_i32 tmp2 = tcg_temp_new_i32(); \

                    \

                    tcg_gen_shri_i32(tmp1, cpu_SR[BR], s); \

                    tcg_gen_shri_i32(tmp2, cpu_SR[BR], t); \

                    tcg_gen_##fn##_i32(tmp1, tmp1, tmp2); \

                    tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR], tmp1, r, 1); \

                    tcg_temp_free(tmp1); \

                    tcg_temp_free(tmp2); \

                } while (0)



            case 0: /*ANDBp*/

                BOOLEAN_LOGIC(and, RRR_R, RRR_S, RRR_T);

                break;



            case 1: /*ANDBCp*/

                BOOLEAN_LOGIC(andc, RRR_R, RRR_S, RRR_T);

                break;



            case 2: /*ORBp*/

                BOOLEAN_LOGIC(or, RRR_R, RRR_S, RRR_T);

                break;



            case 3: /*ORBCp*/

                BOOLEAN_LOGIC(orc, RRR_R, RRR_S, RRR_T);

                break;



            case 4: /*XORBp*/

                BOOLEAN_LOGIC(xor, RRR_R, RRR_S, RRR_T);

                break;



#undef BOOLEAN_LOGIC



            case 8: /*MULLi*/

                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL);

                tcg_gen_mul_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                break;



            case 10: /*MULUHi*/

            case 11: /*MULSHi*/

                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL_HIGH);

                {

                    TCGv lo = tcg_temp_new();



                    if (OP2 == 10) {

                        tcg_gen_mulu2_i32(lo, cpu_R[RRR_R],

                                          cpu_R[RRR_S], cpu_R[RRR_T]);

                    } else {

                        tcg_gen_muls2_i32(lo, cpu_R[RRR_R],

                                          cpu_R[RRR_S], cpu_R[RRR_T]);

                    }

                    tcg_temp_free(lo);

                }

                break;



            case 12: /*QUOUi*/

                tcg_gen_divu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                break;



            case 13: /*QUOSi*/

            case 15: /*REMSi*/

                {

                    int label1 = gen_new_label();

                    int label2 = gen_new_label();



                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_S], 0x80000000,

                            label1);

                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0xffffffff,

                            label1);

                    tcg_gen_movi_i32(cpu_R[RRR_R],

                            OP2 == 13 ? 0x80000000 : 0);

                    tcg_gen_br(label2);

                    gen_set_label(label1);

                    if (OP2 == 13) {

                        tcg_gen_div_i32(cpu_R[RRR_R],

                                cpu_R[RRR_S], cpu_R[RRR_T]);

                    } else {

                        tcg_gen_rem_i32(cpu_R[RRR_R],

                                cpu_R[RRR_S], cpu_R[RRR_T]);

                    }

                    gen_set_label(label2);

                }

                break;



            case 14: /*REMUi*/

                tcg_gen_remu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 3: /*RST3*/

            switch (OP2) {

            case 0: /*RSR*/

                if (gen_check_sr(dc, RSR_SR, SR_R) &&

                    (RSR_SR < 64 || gen_check_privilege(dc)) &&

                    gen_window_check1(dc, RRR_T)) {

                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);

                }

                break;



            case 1: /*WSR*/

                if (gen_check_sr(dc, RSR_SR, SR_W) &&

                    (RSR_SR < 64 || gen_check_privilege(dc)) &&

                    gen_window_check1(dc, RRR_T)) {

                    gen_wsr(dc, RSR_SR, cpu_R[RRR_T]);

                }

                break;



            case 2: /*SEXTu*/

                HAS_OPTION(XTENSA_OPTION_MISC_OP_SEXT);

                if (gen_window_check2(dc, RRR_R, RRR_S)) {

                    int shift = 24 - RRR_T;



                    if (shift == 24) {

                        tcg_gen_ext8s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);

                    } else if (shift == 16) {

                        tcg_gen_ext16s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);

                    } else {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], shift);

                        tcg_gen_sari_i32(cpu_R[RRR_R], tmp, shift);

                        tcg_temp_free(tmp);

                    }

                }

                break;



            case 3: /*CLAMPSu*/

                HAS_OPTION(XTENSA_OPTION_MISC_OP_CLAMPS);

                if (gen_window_check2(dc, RRR_R, RRR_S)) {

                    TCGv_i32 tmp1 = tcg_temp_new_i32();

                    TCGv_i32 tmp2 = tcg_temp_new_i32();

                    TCGv_i32 zero = tcg_const_i32(0);



                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 24 - RRR_T);

                    tcg_gen_xor_i32(tmp2, tmp1, cpu_R[RRR_S]);

                    tcg_gen_andi_i32(tmp2, tmp2, 0xffffffff << (RRR_T + 7));



                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 31);

                    tcg_gen_xori_i32(tmp1, tmp1, 0xffffffff >> (25 - RRR_T));



                    tcg_gen_movcond_i32(TCG_COND_EQ, cpu_R[RRR_R], tmp2, zero,

                            cpu_R[RRR_S], tmp1);

                    tcg_temp_free(tmp1);

                    tcg_temp_free(tmp2);

                    tcg_temp_free(zero);

                }

                break;



            case 4: /*MINu*/

            case 5: /*MAXu*/

            case 6: /*MINUu*/

            case 7: /*MAXUu*/

                HAS_OPTION(XTENSA_OPTION_MISC_OP_MINMAX);

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    static const TCGCond cond[] = {

                        TCG_COND_LE,

                        TCG_COND_GE,

                        TCG_COND_LEU,

                        TCG_COND_GEU

                    };

                    tcg_gen_movcond_i32(cond[OP2 - 4], cpu_R[RRR_R],

                            cpu_R[RRR_S], cpu_R[RRR_T],

                            cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 8: /*MOVEQZ*/

            case 9: /*MOVNEZ*/

            case 10: /*MOVLTZ*/

            case 11: /*MOVGEZ*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    static const TCGCond cond[] = {

                        TCG_COND_EQ,

                        TCG_COND_NE,

                        TCG_COND_LT,

                        TCG_COND_GE,

                    };

                    TCGv_i32 zero = tcg_const_i32(0);



                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_R[RRR_R],

                            cpu_R[RRR_T], zero, cpu_R[RRR_S], cpu_R[RRR_R]);

                    tcg_temp_free(zero);

                }

                break;



            case 12: /*MOVFp*/

            case 13: /*MOVTp*/

                HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                if (gen_window_check2(dc, RRR_R, RRR_S)) {

                    TCGv_i32 zero = tcg_const_i32(0);

                    TCGv_i32 tmp = tcg_temp_new_i32();



                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);

                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,

                            cpu_R[RRR_R], tmp, zero,

                            cpu_R[RRR_S], cpu_R[RRR_R]);



                    tcg_temp_free(tmp);

                    tcg_temp_free(zero);

                }

                break;



            case 14: /*RUR*/

                if (gen_window_check1(dc, RRR_R)) {

                    int st = (RRR_S << 4) + RRR_T;

                    if (uregnames[st].name) {

                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_UR[st]);

                    } else {

                        qemu_log(""RUR %d not implemented, "", st);

                        TBD();

                    }

                }

                break;



            case 15: /*WUR*/

                if (gen_window_check1(dc, RRR_T)) {

                    if (uregnames[RSR_SR].name) {

                        gen_wur(RSR_SR, cpu_R[RRR_T]);

                    } else {

                        qemu_log(""WUR %d not implemented, "", RSR_SR);

                        TBD();

                    }

                }

                break;



            }

            break;



        case 4: /*EXTUI*/

        case 5:

            if (gen_window_check2(dc, RRR_R, RRR_T)) {

                int shiftimm = RRR_S | ((OP1 & 1) << 4);

                int maskimm = (1 << (OP2 + 1)) - 1;



                TCGv_i32 tmp = tcg_temp_new_i32();

                tcg_gen_shri_i32(tmp, cpu_R[RRR_T], shiftimm);

                tcg_gen_andi_i32(cpu_R[RRR_R], tmp, maskimm);

                tcg_temp_free(tmp);

            }

            break;



        case 6: /*CUST0*/

            RESERVED();

            break;



        case 7: /*CUST1*/

            RESERVED();

            break;



        case 8: /*LSCXp*/

            switch (OP2) {

            case 0: /*LSXf*/

            case 1: /*LSXUf*/

            case 4: /*SSXf*/

            case 5: /*SSXUf*/

                HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);

                if (gen_window_check2(dc, RRR_S, RRR_T) &&

                    gen_check_cpenable(dc, 0)) {

                    TCGv_i32 addr = tcg_temp_new_i32();

                    tcg_gen_add_i32(addr, cpu_R[RRR_S], cpu_R[RRR_T]);

                    gen_load_store_alignment(dc, 2, addr, false);

                    if (OP2 & 0x4) {

                        tcg_gen_qemu_st32(cpu_FR[RRR_R], addr, dc->cring);

                    } else {

                        tcg_gen_qemu_ld32u(cpu_FR[RRR_R], addr, dc->cring);

                    }

                    if (OP2 & 0x1) {

                        tcg_gen_mov_i32(cpu_R[RRR_S], addr);

                    }

                    tcg_temp_free(addr);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 9: /*LSC4*/

            if (!gen_window_check2(dc, RRR_S, RRR_T)) {

                break;

            }

            switch (OP2) {

            case 0: /*L32E*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                if (gen_check_privilege(dc)) {

                    TCGv_i32 addr = tcg_temp_new_i32();

                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],

                            (0xffffffc0 | (RRR_R << 2)));

                    tcg_gen_qemu_ld32u(cpu_R[RRR_T], addr, dc->ring);

                    tcg_temp_free(addr);

                }

                break;



            case 4: /*S32E*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                if (gen_check_privilege(dc)) {

                    TCGv_i32 addr = tcg_temp_new_i32();

                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],

                            (0xffffffc0 | (RRR_R << 2)));

                    tcg_gen_qemu_st32(cpu_R[RRR_T], addr, dc->ring);

                    tcg_temp_free(addr);

                }

                break;



            default:

                RESERVED();

                break;

            }

            break;



        case 10: /*FP0*/

            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);

            switch (OP2) {

            case 0: /*ADD.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_add_s(cpu_FR[RRR_R], cpu_env,

                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);

                }

                break;



            case 1: /*SUB.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_sub_s(cpu_FR[RRR_R], cpu_env,

                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);

                }

                break;



            case 2: /*MUL.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_mul_s(cpu_FR[RRR_R], cpu_env,

                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);

                }

                break;



            case 4: /*MADD.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_madd_s(cpu_FR[RRR_R], cpu_env,

                                      cpu_FR[RRR_R], cpu_FR[RRR_S],

                                      cpu_FR[RRR_T]);

                }

                break;



            case 5: /*MSUB.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_msub_s(cpu_FR[RRR_R], cpu_env,

                                      cpu_FR[RRR_R], cpu_FR[RRR_S],

                                      cpu_FR[RRR_T]);

                }

                break;



            case 8: /*ROUND.Sf*/

            case 9: /*TRUNC.Sf*/

            case 10: /*FLOOR.Sf*/

            case 11: /*CEIL.Sf*/

            case 14: /*UTRUNC.Sf*/

                if (gen_window_check1(dc, RRR_R) &&

                    gen_check_cpenable(dc, 0)) {

                    static const unsigned rounding_mode_const[] = {

                        float_round_nearest_even,

                        float_round_to_zero,

                        float_round_down,

                        float_round_up,

                        [6] = float_round_to_zero,

                    };

                    TCGv_i32 rounding_mode = tcg_const_i32(

                            rounding_mode_const[OP2 & 7]);

                    TCGv_i32 scale = tcg_const_i32(RRR_T);



                    if (OP2 == 14) {

                        gen_helper_ftoui(cpu_R[RRR_R], cpu_FR[RRR_S],

                                rounding_mode, scale);

                    } else {

                        gen_helper_ftoi(cpu_R[RRR_R], cpu_FR[RRR_S],

                                rounding_mode, scale);

                    }



                    tcg_temp_free(rounding_mode);

                    tcg_temp_free(scale);

                }

                break;



            case 12: /*FLOAT.Sf*/

            case 13: /*UFLOAT.Sf*/

                if (gen_window_check1(dc, RRR_S) &&

                    gen_check_cpenable(dc, 0)) {

                    TCGv_i32 scale = tcg_const_i32(-RRR_T);



                    if (OP2 == 13) {

                        gen_helper_uitof(cpu_FR[RRR_R], cpu_env,

                                cpu_R[RRR_S], scale);

                    } else {

                        gen_helper_itof(cpu_FR[RRR_R], cpu_env,

                                cpu_R[RRR_S], scale);

                    }

                    tcg_temp_free(scale);

                }

                break;



            case 15: /*FP1OP*/

                switch (RRR_T) {

                case 0: /*MOV.Sf*/

                    if (gen_check_cpenable(dc, 0)) {

                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                case 1: /*ABS.Sf*/

                    if (gen_check_cpenable(dc, 0)) {

                        gen_helper_abs_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                case 4: /*RFRf*/

                    if (gen_window_check1(dc, RRR_R) &&

                        gen_check_cpenable(dc, 0)) {

                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                case 5: /*WFRf*/

                    if (gen_window_check1(dc, RRR_S) &&

                        gen_check_cpenable(dc, 0)) {

                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_R[RRR_S]);

                    }

                    break;



                case 6: /*NEG.Sf*/

                    if (gen_check_cpenable(dc, 0)) {

                        gen_helper_neg_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 11: /*FP1*/

            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);



#define gen_compare(rel, br, a, b) \

    do { \

        if (gen_check_cpenable(dc, 0)) { \

            TCGv_i32 bit = tcg_const_i32(1 << br); \

            \

            gen_helper_##rel(cpu_env, bit, cpu_FR[a], cpu_FR[b]); \

            tcg_temp_free(bit); \

        } \

    } while (0)



            switch (OP2) {

            case 1: /*UN.Sf*/

                gen_compare(un_s, RRR_R, RRR_S, RRR_T);

                break;



            case 2: /*OEQ.Sf*/

                gen_compare(oeq_s, RRR_R, RRR_S, RRR_T);

                break;



            case 3: /*UEQ.Sf*/

                gen_compare(ueq_s, RRR_R, RRR_S, RRR_T);

                break;



            case 4: /*OLT.Sf*/

                gen_compare(olt_s, RRR_R, RRR_S, RRR_T);

                break;



            case 5: /*ULT.Sf*/

                gen_compare(ult_s, RRR_R, RRR_S, RRR_T);

                break;



            case 6: /*OLE.Sf*/

                gen_compare(ole_s, RRR_R, RRR_S, RRR_T);

                break;



            case 7: /*ULE.Sf*/

                gen_compare(ule_s, RRR_R, RRR_S, RRR_T);

                break;



#undef gen_compare



            case 8: /*MOVEQZ.Sf*/

            case 9: /*MOVNEZ.Sf*/

            case 10: /*MOVLTZ.Sf*/

            case 11: /*MOVGEZ.Sf*/

                if (gen_window_check1(dc, RRR_T) &&

                    gen_check_cpenable(dc, 0)) {

                    static const TCGCond cond[] = {

                        TCG_COND_EQ,

                        TCG_COND_NE,

                        TCG_COND_LT,

                        TCG_COND_GE,

                    };

                    TCGv_i32 zero = tcg_const_i32(0);



                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_FR[RRR_R],

                            cpu_R[RRR_T], zero, cpu_FR[RRR_S], cpu_FR[RRR_R]);

                    tcg_temp_free(zero);

                }

                break;



            case 12: /*MOVF.Sf*/

            case 13: /*MOVT.Sf*/

                HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                if (gen_check_cpenable(dc, 0)) {

                    TCGv_i32 zero = tcg_const_i32(0);

                    TCGv_i32 tmp = tcg_temp_new_i32();



                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);

                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,

                            cpu_FR[RRR_R], tmp, zero,

                            cpu_FR[RRR_S], cpu_FR[RRR_R]);



                    tcg_temp_free(tmp);

                    tcg_temp_free(zero);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    case 1: /*L32R*/

        if (gen_window_check1(dc, RRR_T)) {

            TCGv_i32 tmp = tcg_const_i32(

                    ((dc->tb->flags & XTENSA_TBFLAG_LITBASE) ?

                     0 : ((dc->pc + 3) & ~3)) +

                    (0xfffc0000 | (RI16_IMM16 << 2)));



            if (dc->tb->flags & XTENSA_TBFLAG_LITBASE) {

                tcg_gen_add_i32(tmp, tmp, dc->litbase);

            }

            tcg_gen_qemu_ld32u(cpu_R[RRR_T], tmp, dc->cring);

            tcg_temp_free(tmp);

        }

        break;



    case 2: /*LSAI*/

#define gen_load_store(type, shift) do { \

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                \

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << shift); \

                if (shift) { \

                    gen_load_store_alignment(dc, shift, addr, false); \

                } \

                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \

                tcg_temp_free(addr); \

            } \

        } while (0)



        switch (RRI8_R) {

        case 0: /*L8UI*/

            gen_load_store(ld8u, 0);

            break;



        case 1: /*L16UI*/

            gen_load_store(ld16u, 1);

            break;



        case 2: /*L32I*/

            gen_load_store(ld32u, 2);

            break;



        case 4: /*S8I*/

            gen_load_store(st8, 0);

            break;



        case 5: /*S16I*/

            gen_load_store(st16, 1);

            break;



        case 6: /*S32I*/

            gen_load_store(st32, 2);

            break;



#define gen_dcache_hit_test(w, shift) do { \

            if (gen_window_check1(dc, RRI##w##_S)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                TCGv_i32 res = tcg_temp_new_i32(); \

                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \

                                 RRI##w##_IMM##w << shift); \

                tcg_gen_qemu_ld8u(res, addr, dc->cring); \

                tcg_temp_free(addr); \

                tcg_temp_free(res); \

            } \

        } while (0)



#define gen_dcache_hit_test4() gen_dcache_hit_test(4, 4)

#define gen_dcache_hit_test8() gen_dcache_hit_test(8, 2)



        case 7: /*CACHEc*/

            if (RRI8_T < 8) {

                HAS_OPTION(XTENSA_OPTION_DCACHE);

            }



            switch (RRI8_T) {

            case 0: /*DPFRc*/

                gen_window_check1(dc, RRI8_S);

                break;



            case 1: /*DPFWc*/

                gen_window_check1(dc, RRI8_S);

                break;



            case 2: /*DPFROc*/

                gen_window_check1(dc, RRI8_S);

                break;



            case 3: /*DPFWOc*/

                gen_window_check1(dc, RRI8_S);

                break;



            case 4: /*DHWBc*/

                gen_dcache_hit_test8();

                break;



            case 5: /*DHWBIc*/

                gen_dcache_hit_test8();

                break;



            case 6: /*DHIc*/

                if (gen_check_privilege(dc)) {

                    gen_dcache_hit_test8();

                }

                break;



            case 7: /*DIIc*/

                if (gen_check_privilege(dc)) {

                    gen_window_check1(dc, RRI8_S);

                }

                break;



            case 8: /*DCEc*/

                switch (OP1) {

                case 0: /*DPFLl*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_dcache_hit_test4();

                    }

                    break;



                case 2: /*DHUl*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_dcache_hit_test4();

                    }

                    break;



                case 3: /*DIUl*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_window_check1(dc, RRI4_S);

                    }

                    break;



                case 4: /*DIWBc*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE);

                    if (gen_check_privilege(dc)) {

                        gen_window_check1(dc, RRI4_S);

                    }

                    break;



                case 5: /*DIWBIc*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE);

                    if (gen_check_privilege(dc)) {

                        gen_window_check1(dc, RRI4_S);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;



                }

                break;



#undef gen_dcache_hit_test

#undef gen_dcache_hit_test4

#undef gen_dcache_hit_test8



#define gen_icache_hit_test(w, shift) do { \

            if (gen_window_check1(dc, RRI##w##_S)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                tcg_gen_movi_i32(cpu_pc, dc->pc); \

                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \

                                 RRI##w##_IMM##w << shift); \

                gen_helper_itlb_hit_test(cpu_env, addr); \

                tcg_temp_free(addr); \

            }\

        } while (0)



#define gen_icache_hit_test4() gen_icache_hit_test(4, 4)

#define gen_icache_hit_test8() gen_icache_hit_test(8, 2)



            case 12: /*IPFc*/

                HAS_OPTION(XTENSA_OPTION_ICACHE);

                gen_window_check1(dc, RRI8_S);

                break;



            case 13: /*ICEc*/

                switch (OP1) {

                case 0: /*IPFLl*/

                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_icache_hit_test4();

                    }

                    break;



                case 2: /*IHUl*/

                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_icache_hit_test4();

                    }

                    break;



                case 3: /*IIUl*/

                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_window_check1(dc, RRI4_S);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            case 14: /*IHIc*/

                HAS_OPTION(XTENSA_OPTION_ICACHE);

                gen_icache_hit_test8();

                break;



            case 15: /*IIIc*/

                HAS_OPTION(XTENSA_OPTION_ICACHE);

                if (gen_check_privilege(dc)) {

                    gen_window_check1(dc, RRI8_S);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



#undef gen_icache_hit_test

#undef gen_icache_hit_test4

#undef gen_icache_hit_test8



        case 9: /*L16SI*/

            gen_load_store(ld16s, 1);

            break;

#undef gen_load_store



        case 10: /*MOVI*/

            if (gen_window_check1(dc, RRI8_T)) {

                tcg_gen_movi_i32(cpu_R[RRI8_T],

                                 RRI8_IMM8 | (RRI8_S << 8) |

                                 ((RRI8_S & 0x8) ? 0xfffff000 : 0));

            }

            break;



#define gen_load_store_no_hw_align(type) do { \

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \

                TCGv_i32 addr = tcg_temp_local_new_i32(); \

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2); \

                gen_load_store_alignment(dc, 2, addr, true); \

                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \

                tcg_temp_free(addr); \

            } \

        } while (0)



        case 11: /*L32AIy*/

            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);

            gen_load_store_no_hw_align(ld32u); /*TODO acquire?*/

            break;



        case 12: /*ADDI*/

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE);

            }

            break;



        case 13: /*ADDMI*/

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S],

                                 RRI8_IMM8_SE << 8);

            }

            break;



        case 14: /*S32C1Iy*/

            HAS_OPTION(XTENSA_OPTION_CONDITIONAL_STORE);

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                int label = gen_new_label();

                TCGv_i32 tmp = tcg_temp_local_new_i32();

                TCGv_i32 addr = tcg_temp_local_new_i32();

                TCGv_i32 tpc;



                tcg_gen_mov_i32(tmp, cpu_R[RRI8_T]);

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);

                gen_load_store_alignment(dc, 2, addr, true);



                gen_advance_ccount(dc);

                tpc = tcg_const_i32(dc->pc);

                gen_helper_check_atomctl(cpu_env, tpc, addr);

                tcg_gen_qemu_ld32u(cpu_R[RRI8_T], addr, dc->cring);

                tcg_gen_brcond_i32(TCG_COND_NE, cpu_R[RRI8_T],

                        cpu_SR[SCOMPARE1], label);



                tcg_gen_qemu_st32(tmp, addr, dc->cring);



                gen_set_label(label);

                tcg_temp_free(tpc);

                tcg_temp_free(addr);

                tcg_temp_free(tmp);

            }

            break;



        case 15: /*S32RIy*/

            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);

            gen_load_store_no_hw_align(st32); /*TODO release?*/

            break;

#undef gen_load_store_no_hw_align



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    case 3: /*LSCIp*/

        switch (RRI8_R) {

        case 0: /*LSIf*/

        case 4: /*SSIf*/

        case 8: /*LSIUf*/

        case 12: /*SSIUf*/

            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);

            if (gen_window_check1(dc, RRI8_S) &&

                gen_check_cpenable(dc, 0)) {

                TCGv_i32 addr = tcg_temp_new_i32();

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);

                gen_load_store_alignment(dc, 2, addr, false);

                if (RRI8_R & 0x4) {

                    tcg_gen_qemu_st32(cpu_FR[RRI8_T], addr, dc->cring);

                } else {

                    tcg_gen_qemu_ld32u(cpu_FR[RRI8_T], addr, dc->cring);

                }

                if (RRI8_R & 0x8) {

                    tcg_gen_mov_i32(cpu_R[RRI8_S], addr);

                }

                tcg_temp_free(addr);

            }

            break;



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    case 4: /*MAC16d*/

        HAS_OPTION(XTENSA_OPTION_MAC16);

        {

            enum {

                MAC16_UMUL = 0x0,

                MAC16_MUL  = 0x4,

                MAC16_MULA = 0x8,

                MAC16_MULS = 0xc,

                MAC16_NONE = 0xf,

            } op = OP1 & 0xc;

            bool is_m1_sr = (OP2 & 0x3) == 2;

            bool is_m2_sr = (OP2 & 0xc) == 0;

            uint32_t ld_offset = 0;



            if (OP2 > 9) {

                RESERVED();

            }



            switch (OP2 & 2) {

            case 0: /*MACI?/MACC?*/

                is_m1_sr = true;

                ld_offset = (OP2 & 1) ? -4 : 4;



                if (OP2 >= 8) { /*MACI/MACC*/

                    if (OP1 == 0) { /*LDINC/LDDEC*/

                        op = MAC16_NONE;

                    } else {

                        RESERVED();

                    }

                } else if (op != MAC16_MULA) { /*MULA.*.*.LDINC/LDDEC*/

                    RESERVED();

                }

                break;



            case 2: /*MACD?/MACA?*/

                if (op == MAC16_UMUL && OP2 != 7) { /*UMUL only in MACAA*/

                    RESERVED();

                }

                break;

            }



            if (op != MAC16_NONE) {

                if (!is_m1_sr && !gen_window_check1(dc, RRR_S)) {

                    break;

                }

                if (!is_m2_sr && !gen_window_check1(dc, RRR_T)) {

                    break;

                }

            }



            if (ld_offset && !gen_window_check1(dc, RRR_S)) {

                break;

            }



            {

                TCGv_i32 vaddr = tcg_temp_new_i32();

                TCGv_i32 mem32 = tcg_temp_new_i32();



                if (ld_offset) {

                    tcg_gen_addi_i32(vaddr, cpu_R[RRR_S], ld_offset);

                    gen_load_store_alignment(dc, 2, vaddr, false);

                    tcg_gen_qemu_ld32u(mem32, vaddr, dc->cring);

                }

                if (op != MAC16_NONE) {

                    TCGv_i32 m1 = gen_mac16_m(

                            is_m1_sr ? cpu_SR[MR + RRR_X] : cpu_R[RRR_S],

                            OP1 & 1, op == MAC16_UMUL);

                    TCGv_i32 m2 = gen_mac16_m(

                            is_m2_sr ? cpu_SR[MR + 2 + RRR_Y] : cpu_R[RRR_T],

                            OP1 & 2, op == MAC16_UMUL);



                    if (op == MAC16_MUL || op == MAC16_UMUL) {

                        tcg_gen_mul_i32(cpu_SR[ACCLO], m1, m2);

                        if (op == MAC16_UMUL) {

                            tcg_gen_movi_i32(cpu_SR[ACCHI], 0);

                        } else {

                            tcg_gen_sari_i32(cpu_SR[ACCHI], cpu_SR[ACCLO], 31);

                        }

                    } else {

                        TCGv_i32 lo = tcg_temp_new_i32();

                        TCGv_i32 hi = tcg_temp_new_i32();



                        tcg_gen_mul_i32(lo, m1, m2);

                        tcg_gen_sari_i32(hi, lo, 31);

                        if (op == MAC16_MULA) {

                            tcg_gen_add2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             lo, hi);

                        } else {

                            tcg_gen_sub2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             lo, hi);

                        }

                        tcg_gen_ext8s_i32(cpu_SR[ACCHI], cpu_SR[ACCHI]);



                        tcg_temp_free_i32(lo);

                        tcg_temp_free_i32(hi);

                    }

                    tcg_temp_free(m1);

                    tcg_temp_free(m2);

                }

                if (ld_offset) {

                    tcg_gen_mov_i32(cpu_R[RRR_S], vaddr);

                    tcg_gen_mov_i32(cpu_SR[MR + RRR_W], mem32);

                }

                tcg_temp_free(vaddr);

                tcg_temp_free(mem32);

            }

        }

        break;



    case 5: /*CALLN*/

        switch (CALL_N) {

        case 0: /*CALL0*/

            tcg_gen_movi_i32(cpu_R[0], dc->next_pc);

            gen_jumpi(dc, (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);

            break;



        case 1: /*CALL4w*/

        case 2: /*CALL8w*/

        case 3: /*CALL12w*/

            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

            if (gen_window_check1(dc, CALL_N << 2)) {

                gen_callwi(dc, CALL_N,

                           (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);

            }

            break;

        }

        break;



    case 6: /*SI*/

        switch (CALL_N) {

        case 0: /*J*/

            gen_jumpi(dc, dc->pc + 4 + CALL_OFFSET_SE, 0);

            break;



        case 1: /*BZ*/

            if (gen_window_check1(dc, BRI12_S)) {

                static const TCGCond cond[] = {

                    TCG_COND_EQ, /*BEQZ*/

                    TCG_COND_NE, /*BNEZ*/

                    TCG_COND_LT, /*BLTZ*/

                    TCG_COND_GE, /*BGEZ*/

                };



                gen_brcondi(dc, cond[BRI12_M & 3], cpu_R[BRI12_S], 0,

                        4 + BRI12_IMM12_SE);

            }

            break;



        case 2: /*BI0*/

            if (gen_window_check1(dc, BRI8_S)) {

                static const TCGCond cond[] = {

                    TCG_COND_EQ, /*BEQI*/

                    TCG_COND_NE, /*BNEI*/

                    TCG_COND_LT, /*BLTI*/

                    TCG_COND_GE, /*BGEI*/

                };



                gen_brcondi(dc, cond[BRI8_M & 3],

                        cpu_R[BRI8_S], B4CONST[BRI8_R], 4 + BRI8_IMM8_SE);

            }

            break;



        case 3: /*BI1*/

            switch (BRI8_M) {

            case 0: /*ENTRYw*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                {

                    TCGv_i32 pc = tcg_const_i32(dc->pc);

                    TCGv_i32 s = tcg_const_i32(BRI12_S);

                    TCGv_i32 imm = tcg_const_i32(BRI12_IMM12);

                    gen_advance_ccount(dc);

                    gen_helper_entry(cpu_env, pc, s, imm);

                    tcg_temp_free(imm);

                    tcg_temp_free(s);

                    tcg_temp_free(pc);

                    /* This can change tb->flags, so exit tb */

                    gen_jumpi_check_loop_end(dc, -1);

                }

                break;



            case 1: /*B1*/

                switch (BRI8_R) {

                case 0: /*BFp*/

                case 1: /*BTp*/

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                    {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRI8_S);

                        gen_brcondi(dc,

                                BRI8_R == 1 ? TCG_COND_NE : TCG_COND_EQ,

                                tmp, 0, 4 + RRI8_IMM8_SE);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 8: /*LOOP*/

                case 9: /*LOOPNEZ*/

                case 10: /*LOOPGTZ*/

                    HAS_OPTION(XTENSA_OPTION_LOOP);

                    if (gen_window_check1(dc, RRI8_S)) {

                        uint32_t lend = dc->pc + RRI8_IMM8 + 4;

                        TCGv_i32 tmp = tcg_const_i32(lend);



                        tcg_gen_subi_i32(cpu_SR[LCOUNT], cpu_R[RRI8_S], 1);

                        tcg_gen_movi_i32(cpu_SR[LBEG], dc->next_pc);

                        gen_helper_wsr_lend(cpu_env, tmp);

                        tcg_temp_free(tmp);



                        if (BRI8_R > 8) {

                            int label = gen_new_label();

                            tcg_gen_brcondi_i32(

                                    BRI8_R == 9 ? TCG_COND_NE : TCG_COND_GT,

                                    cpu_R[RRI8_S], 0, label);

                            gen_jumpi(dc, lend, 1);

                            gen_set_label(label);

                        }



                        gen_jumpi(dc, dc->next_pc, 0);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;



                }

                break;



            case 2: /*BLTUI*/

            case 3: /*BGEUI*/

                if (gen_window_check1(dc, BRI8_S)) {

                    gen_brcondi(dc, BRI8_M == 2 ? TCG_COND_LTU : TCG_COND_GEU,

                                cpu_R[BRI8_S], B4CONSTU[BRI8_R],

                                4 + BRI8_IMM8_SE);

                }

                break;

            }

            break;



        }

        break;



    case 7: /*B*/

        {

            TCGCond eq_ne = (RRI8_R & 8) ? TCG_COND_NE : TCG_COND_EQ;



            switch (RRI8_R & 7) {

            case 0: /*BNONE*/ /*BANY*/

                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);

                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                }

                break;



            case 1: /*BEQ*/ /*BNE*/

            case 2: /*BLT*/ /*BGE*/

            case 3: /*BLTU*/ /*BGEU*/

                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                    static const TCGCond cond[] = {

                        [1] = TCG_COND_EQ,

                        [2] = TCG_COND_LT,

                        [3] = TCG_COND_LTU,

                        [9] = TCG_COND_NE,

                        [10] = TCG_COND_GE,

                        [11] = TCG_COND_GEU,

                    };

                    gen_brcond(dc, cond[RRI8_R], cpu_R[RRI8_S], cpu_R[RRI8_T],

                            4 + RRI8_IMM8_SE);

                }

                break;



            case 4: /*BALL*/ /*BNALL*/

                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);

                    gen_brcond(dc, eq_ne, tmp, cpu_R[RRI8_T],

                            4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                }

                break;



            case 5: /*BBC*/ /*BBS*/

                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

#ifdef TARGET_WORDS_BIGENDIAN

                    TCGv_i32 bit = tcg_const_i32(0x80000000);

#else

                    TCGv_i32 bit = tcg_const_i32(0x00000001);

#endif

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_T], 0x1f);

#ifdef TARGET_WORDS_BIGENDIAN

                    tcg_gen_shr_i32(bit, bit, tmp);

#else

                    tcg_gen_shl_i32(bit, bit, tmp);

#endif

                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], bit);

                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                    tcg_temp_free(bit);

                }

                break;



            case 6: /*BBCI*/ /*BBSI*/

            case 7:

                if (gen_window_check1(dc, RRI8_S)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_S],

#ifdef TARGET_WORDS_BIGENDIAN

                            0x80000000 >> (((RRI8_R & 1) << 4) | RRI8_T));

#else

                            0x00000001 << (((RRI8_R & 1) << 4) | RRI8_T));

#endif

                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                }

                break;



            }

        }

        break;



#define gen_narrow_load_store(type) do { \

            if (gen_window_check2(dc, RRRN_S, RRRN_T)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                tcg_gen_addi_i32(addr, cpu_R[RRRN_S], RRRN_R << 2); \

                gen_load_store_alignment(dc, 2, addr, false); \

                tcg_gen_qemu_##type(cpu_R[RRRN_T], addr, dc->cring); \

                tcg_temp_free(addr); \

            } \

        } while (0)



    case 8: /*L32I.Nn*/

        gen_narrow_load_store(ld32u);

        break;



    case 9: /*S32I.Nn*/

        gen_narrow_load_store(st32);

        break;

#undef gen_narrow_load_store



    case 10: /*ADD.Nn*/

        if (gen_window_check3(dc, RRRN_R, RRRN_S, RRRN_T)) {

            tcg_gen_add_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], cpu_R[RRRN_T]);

        }

        break;



    case 11: /*ADDI.Nn*/

        if (gen_window_check2(dc, RRRN_R, RRRN_S)) {

            tcg_gen_addi_i32(cpu_R[RRRN_R], cpu_R[RRRN_S],

                             RRRN_T ? RRRN_T : -1);

        }

        break;



    case 12: /*ST2n*/

        if (!gen_window_check1(dc, RRRN_S)) {

            break;

        }

        if (RRRN_T < 8) { /*MOVI.Nn*/

            tcg_gen_movi_i32(cpu_R[RRRN_S],

                    RRRN_R | (RRRN_T << 4) |

                    ((RRRN_T & 6) == 6 ? 0xffffff80 : 0));

        } else { /*BEQZ.Nn*/ /*BNEZ.Nn*/

            TCGCond eq_ne = (RRRN_T & 4) ? TCG_COND_NE : TCG_COND_EQ;



            gen_brcondi(dc, eq_ne, cpu_R[RRRN_S], 0,

                    4 + (RRRN_R | ((RRRN_T & 3) << 4)));

        }

        break;



    case 13: /*ST3n*/

        switch (RRRN_R) {

        case 0: /*MOV.Nn*/

            if (gen_window_check2(dc, RRRN_S, RRRN_T)) {

                tcg_gen_mov_i32(cpu_R[RRRN_T], cpu_R[RRRN_S]);

            }

            break;



        case 15: /*S3*/

            switch (RRRN_T) {

            case 0: /*RET.Nn*/

                gen_jump(dc, cpu_R[0]);

                break;



            case 1: /*RETW.Nn*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                {

                    TCGv_i32 tmp = tcg_const_i32(dc->pc);

                    gen_advance_ccount(dc);

                    gen_helper_retw(tmp, cpu_env, tmp);

                    gen_jump(dc, tmp);

                    tcg_temp_free(tmp);

                }

                break;



            case 2: /*BREAK.Nn*/

                HAS_OPTION(XTENSA_OPTION_DEBUG);

                if (dc->debug) {

                    gen_debug_exception(dc, DEBUGCAUSE_BN);

                }

                break;



            case 3: /*NOP.Nn*/

                break;



            case 6: /*ILL.Nn*/

                gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    default: /*reserved*/

        RESERVED();

        break;

    }



    if (dc->is_jmp == DISAS_NEXT) {

        gen_check_loop_end(dc, 0);

    }

    dc->pc = dc->next_pc;



    return;



invalid_opcode:

    qemu_log(""INVALID(pc = %08x)
"", dc->pc);

    gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

#undef HAS_OPTION

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,dc","env:-0.11177271604537964,dc:-0.47545719146728516,",1,4,0,"env:iv,",0,Greedy,276,0.3333111643791199,replace,[]
33,"int kvm_arch_on_sigbus(int code, void *addr)

{

#ifdef KVM_CAP_MCE

    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {

        void *vaddr;

        ram_addr_t ram_addr;

        target_phys_addr_t paddr;



        /* Hope we are lucky for AO MCE */

        vaddr = addr;

        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||

            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,

                                               &paddr)) {

            fprintf(stderr, ""Hardware memory error for memory used by ""

                    ""QEMU itself instead of guest system!: %p\n"", addr);

            return 0;

        }

        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);

    } else

#endif /* KVM_CAP_MCE */

    {

        if (code == BUS_MCEERR_AO) {

            return 0;

        } else if (code == BUS_MCEERR_AR) {

            hardware_memory_error();

        } else {

            return 1;

        }

    }

    return 0;

}
",152,,LABEL_0,LABEL_0,LABEL_0,-1,"code,addr,vaddr,ram_addr,paddr",,5,17,0,,0,GA,974,0.36404297351837156,failed,[]
34,"static void decode_interframe_v4(AVCodecContext *avctx, uint8_t *src, uint32_t size)

{

    Hnm4VideoContext *hnm = avctx->priv_data;

    GetByteContext gb;

    uint32_t writeoffset = 0, count, left, offset;

    uint8_t tag, previous, backline, backward, swap;



    bytestream2_init(&gb, src, size);



    while (bytestream2_tell(&gb) < size) {

        count = bytestream2_peek_byte(&gb) & 0x1F;

        if (count == 0) {

            tag = bytestream2_get_byte(&gb) & 0xE0;

            tag = tag >> 5;

            if (tag == 0) {

                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);

                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);

            } else if (tag == 1) {

                writeoffset += bytestream2_get_byte(&gb) * 2;

            } else if (tag == 2) {

                count = bytestream2_get_le16(&gb);

                count *= 2;

                writeoffset += count;

            } else if (tag == 3) {

                count = bytestream2_get_byte(&gb) * 2;

                while (count > 0) {

                    hnm->current[writeoffset++] = bytestream2_peek_byte(&gb);

                    count--;

                }

                bytestream2_skip(&gb, 1);

            } else {

                break;

            }

        } else {

            previous = bytestream2_peek_byte(&gb) & 0x20;

            backline = bytestream2_peek_byte(&gb) & 0x40;

            backward = bytestream2_peek_byte(&gb) & 0x80;

            bytestream2_skip(&gb, 1);

            swap   = bytestream2_peek_byte(&gb) & 0x01;

            offset = bytestream2_get_le16(&gb);

            offset = (offset >> 1) & 0x7FFF;

            offset = writeoffset + (offset * 2) - 0x8000;



            left = count;



            if (!backward && offset + count >= hnm->width * hnm->height) {

                av_log(avctx, AV_LOG_ERROR, ""Attempting to read out of bounds"");

                break;

            } else if (backward && offset >= hnm->width * hnm->height) {

                av_log(avctx, AV_LOG_ERROR, ""Attempting to read out of bounds"");

                break;

            } else if (writeoffset + count >= hnm->width * hnm->height) {

                av_log(avctx, AV_LOG_ERROR,

                       ""Attempting to write out of bounds"");

                break;

            }



            if (previous) {

                while (left > 0) {

                    if (backline) {

                        hnm->current[writeoffset++] = hnm->previous[offset - (2 * hnm->width) + 1];

                        hnm->current[writeoffset++] = hnm->previous[offset++];

                        offset++;

                    } else {

                        hnm->current[writeoffset++] = hnm->previous[offset++];

                        hnm->current[writeoffset++] = hnm->previous[offset++];

                    }

                    if (backward)

                        offset -= 4;

                    left--;

                }

            } else {

                while (left > 0) {

                    if (backline) {

                        hnm->current[writeoffset++] = hnm->current[offset - (2 * hnm->width) + 1];

                        hnm->current[writeoffset++] = hnm->current[offset++];

                        offset++;

                    } else {

                        hnm->current[writeoffset++] = hnm->current[offset++];

                        hnm->current[writeoffset++] = hnm->current[offset++];

                    }

                    if (backward)

                        offset -= 4;

                    left--;

                }

            }



            if (swap) {

                left         = count;

                writeoffset -= count * 2;

                while (left > 0) {

                    swap = hnm->current[writeoffset];

                    hnm->current[writeoffset] = hnm->current[writeoffset + 1];

                    hnm->current[writeoffset + 1] = swap;

                    left--;

                    writeoffset += 2;

                }

            }

        }

    }

}
",756,,LABEL_0,LABEL_1,,-4,"avctx,src,size,hnm,gb,count,offset,tag,previous,backline,backward,swap",,,,0,,0,Greedy,1,0.0019336462020874024,,
35,"void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)

{

    int i = 0;

    int x = 0;

    uint32_t l_64 = (l + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""\n"",

               __func__, l, dest, src);



#ifndef CONFIG_USER_ONLY

    if ((l > 32) &&

        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&

        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {

        if (dest == (src + 1)) {

            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));

            return;

        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(env, l + 1, dest, src);

            return;

        }

    }

#else

    if (dest == (src + 1)) {

        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);

        return;

    } else {

        memmove(g2h(dest), g2h(src), l + 1);

        return;

    }

#endif



    /* handle the parts that fit into 8-byte loads/stores */

    if (dest != (src + 1)) {

        for (i = 0; i < l_64; i++) {

            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));

            x += 8;

        }

    }



    /* slow version crossing pages with byte accesses */

    for (i = x; i <= l; i++) {

        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));

    }

}
",336,,LABEL_1,LABEL_0,,-4,"env,l,dest,src,i",,,,0,,0,Greedy,1,0.0005990425745646159,,
36,"static int inc_refcounts(BlockDriverState *bs,

                         BdrvCheckResult *res,

                         uint16_t *refcount_table,

                         int64_t refcount_table_size,

                         int64_t offset, int64_t size)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t start, last, cluster_offset, k;



    if (size <= 0) {

        return 0;

    }



    start = start_of_cluster(s, offset);

    last = start_of_cluster(s, offset + size - 1);

    for(cluster_offset = start; cluster_offset <= last;

        cluster_offset += s->cluster_size) {

        k = cluster_offset >> s->cluster_bits;

        if (k >= refcount_table_size) {

            fprintf(stderr, ""Warning: cluster offset=0x%"" PRIx64 "" is after ""

                ""the end of the image file, can't properly check refcounts.\n"",

                cluster_offset);

            res->check_errors++;

        } else {

            if (++refcount_table[k] == 0) {

                fprintf(stderr, ""ERROR: overflow cluster offset=0x%"" PRIx64

                    ""\n"", cluster_offset);

                res->corruptions++;

            }

        }

    }



    return 0;

}
",184,"static int inc_refcounts(BlockDriverState *rb,

                         BdrvCheckResult *res,

                         uint16_t *refcount_table,

                         int64_t refcount_table_size,

                         int64_t offset, int64_t size)

{

    BDRVQcowState *r = rb->opaque;

    uint64_t start, last, cluster_offset, k;



    if (size <= 0) {

        return 0;

    }



    start = start_of_cluster(r, offset);

    last = start_of_cluster(r, offset + size - 1);

    for(cluster_offset = start; cluster_offset <= last;

        cluster_offset += r->cluster_size) {

        k = cluster_offset >> r->cluster_bits;

        if (k >= refcount_table_size) {

            fprintf(stderr, ""Warning: cluster offset=0x%"" PRIx64 "" is after ""

                ""the end of the image file, can't properly check refcounts.
"",

                cluster_offset);

            res->check_errors++;

        } else {

            if (++refcount_table[k] == 0) {

                fprintf(stderr, ""ERROR: overflow cluster offset=0x%"" PRIx64

                    ""
"", cluster_offset);

                res->corruptions++;

            }

        }

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bs,res,refcount_table,refcount_table_size,offset,size,s,start,last,cluster_offset,k,check_errors,corruptions","bs:0.00020492076873779297,res:3.123283386230469e-05,refcount_table:-2.09808349609375e-05,refcount_table_size:1.3709068298339844e-05,offset:2.09808349609375e-05,size:1.33514404296875e-05,s:0.00010883808135986328,start:-1.3232231140136719e-05,last:3.2186508178710938e-06,cluster_offset:-7.677078247070312e-05,k:-3.421306610107422e-05,check_errors:2.7298927307128906e-05,corruptions:9.5367431640625e-07,",2,7,0,"bs:rb,s:r,",0,Greedy,134,0.049374163150787354,replace,[]
37,"static void json_message_process_token(JSONLexer *lexer, GString *input,

                                       JSONTokenType type, int x, int y)

{

    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);

    QDict *dict;



    switch (type) {

    case JSON_LCURLY:

        parser->brace_count++;

        break;

    case JSON_RCURLY:

        parser->brace_count--;

        break;

    case JSON_LSQUARE:

        parser->bracket_count++;

        break;

    case JSON_RSQUARE:

        parser->bracket_count--;

        break;

    default:

        break;

    }



    dict = qdict_new();

    qdict_put(dict, ""type"", qint_from_int(type));

    qdict_put(dict, ""token"", qstring_from_str(input->str));

    qdict_put(dict, ""x"", qint_from_int(x));

    qdict_put(dict, ""y"", qint_from_int(y));



    parser->token_size += input->len;



    g_queue_push_tail(parser->tokens, dict);



    if (type == JSON_ERROR) {

        goto out_emit_bad;

    } else if (parser->brace_count < 0 ||

        parser->bracket_count < 0 ||

        (parser->brace_count == 0 &&

         parser->bracket_count == 0)) {

        goto out_emit;

    } else if (parser->token_size > MAX_TOKEN_SIZE ||

               parser->bracket_count + parser->brace_count > MAX_NESTING) {

        /* Security consideration, we limit total memory allocated per object

         * and the maximum recursion depth that a message can force.

         */

        goto out_emit_bad;

    }



    return;



out_emit_bad:

    /*

     * Clear out token list and tell the parser to emit an error

     * indication by passing it a NULL list

     */

    json_message_free_tokens(parser);

out_emit:

    /* send current list of tokens to parser and reset tokenizer */

    parser->brace_count = 0;

    parser->bracket_count = 0;

    /* parser->emit takes ownership of parser->tokens.  */

    parser->emit(parser, parser->tokens);

    parser->tokens = g_queue_new();

    parser->token_size = 0;

}
",390,"static void json_message_process_token(JSONLexer *logker, GString *input,

                                       JSONTokenType type, int x, int y)

{

    JSONMessageParser *gg = container_of(logker, JSONMessageParser, logker);

    QDict *arr;



    switch (type) {

    case JSON_LCURLY:

        gg->brace_count++;

        break;

    case JSON_RCURLY:

        gg->brace_count--;

        break;

    case JSON_LSQUARE:

        gg->bracket_count++;

        break;

    case JSON_RSQUARE:

        gg->bracket_count--;

        break;

    default:

        break;

    }



    arr = qdict_new();

    qdict_put(arr, ""type"", qint_from_int(type));

    qdict_put(arr, ""token"", qstring_from_str(input->str));

    qdict_put(arr, ""x"", qint_from_int(x));

    qdict_put(arr, ""y"", qint_from_int(y));



    gg->token_size += input->len;



    g_queue_push_tail(gg->tokens, arr);



    if (type == JSON_ERROR) {

        goto out_emit_bad;

    } else if (gg->brace_count < 0 ||

        gg->bracket_count < 0 ||

        (gg->brace_count == 0 &&

         gg->bracket_count == 0)) {

        goto out_emit;

    } else if (gg->token_size > MAX_TOKEN_SIZE ||

               gg->bracket_count + gg->brace_count > MAX_NESTING) {

        /* Security consideration, we limit total memory allocated per object

         * and the maximum recursion depth that a message can force.

         */

        goto out_emit_bad;

    }



    return;



out_emit_bad:

    /*

     * Clear out token list and tell the gg to emit an error

     * indication by passing it a NULL list

     */

    json_message_free_tokens(gg);

out_emit:

    /* send current list of tokens to gg and reset tokenizer */

    gg->brace_count = 0;

    gg->bracket_count = 0;

    /* gg->emit takes ownership of gg->tokens.  */

    gg->emit(gg, gg->tokens);

    gg->tokens = g_queue_new();

    gg->token_size = 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"lexer,input,type,x,y,parser,dict,brace_count,bracket_count","lexer:6.878376007080078e-05,input:4.38690185546875e-05,type:4.267692565917969e-05,x:3.3736228942871094e-05,y:2.0384788513183594e-05,parser:7.742643356323242e-05,dict:5.1140785217285156e-05,brace_count:-3.337860107421875e-06,bracket_count:-1.7464160919189453e-05,",3,36,0,"parser:gg,lexer:logker,dict:arr,",0,Greedy,252,0.09719733397165935,replace,[]
38,"static int libschroedinger_encode_frame(AVCodecContext *avctx, AVPacket *pkt,

                                        const AVFrame *frame, int *got_packet)

{

    int enc_size = 0;

    SchroEncoderParams *p_schro_params = avctx->priv_data;

    SchroEncoder *encoder = p_schro_params->encoder;

    struct FFSchroEncodedFrame *p_frame_output = NULL;

    int go = 1;

    SchroBuffer *enc_buf;

    int presentation_frame;

    int parse_code;

    int last_frame_in_sequence = 0;

    int pkt_size, ret;



    if (!frame) {

        /* Push end of sequence if not already signalled. */

        if (!p_schro_params->eos_signalled) {

            schro_encoder_end_of_stream(encoder);

            p_schro_params->eos_signalled = 1;

        }

    } else {

        /* Allocate frame data to schro input buffer. */

        SchroFrame *in_frame = libschroedinger_frame_from_data(avctx, frame);

        if (!in_frame)

            return AVERROR(ENOMEM);

        /* Load next frame. */

        schro_encoder_push_frame(encoder, in_frame);

    }



    if (p_schro_params->eos_pulled)

        go = 0;



    /* Now check to see if we have any output from the encoder. */

    while (go) {

        int err;

        SchroStateEnum state;

        state = schro_encoder_wait(encoder);

        switch (state) {

        case SCHRO_STATE_HAVE_BUFFER:

        case SCHRO_STATE_END_OF_STREAM:

            enc_buf = schro_encoder_pull(encoder, &presentation_frame);

            if (enc_buf->length <= 0)

                return AVERROR_BUG;

            parse_code = enc_buf->data[4];



            /* All non-frame data is prepended to actual frame data to

             * be able to set the pts correctly. So we don't write data

             * to the frame output queue until we actually have a frame

             */

            if ((err = av_reallocp(&p_schro_params->enc_buf,

                                   p_schro_params->enc_buf_size +

                                   enc_buf->length)) < 0) {

                p_schro_params->enc_buf_size = 0;

                return err;

            }



            memcpy(p_schro_params->enc_buf + p_schro_params->enc_buf_size,

                   enc_buf->data, enc_buf->length);

            p_schro_params->enc_buf_size += enc_buf->length;





            if (state == SCHRO_STATE_END_OF_STREAM) {

                p_schro_params->eos_pulled = 1;

                go = 0;

            }



            if (!SCHRO_PARSE_CODE_IS_PICTURE(parse_code)) {

                schro_buffer_unref(enc_buf);

                break;

            }



            /* Create output frame. */

            p_frame_output = av_mallocz(sizeof(FFSchroEncodedFrame));

            if (!p_frame_output)

                return AVERROR(ENOMEM);

            /* Set output data. */

            p_frame_output->size     = p_schro_params->enc_buf_size;

            p_frame_output->p_encbuf = p_schro_params->enc_buf;

            if (SCHRO_PARSE_CODE_IS_INTRA(parse_code) &&

                SCHRO_PARSE_CODE_IS_REFERENCE(parse_code))

                p_frame_output->key_frame = 1;



            /* Parse the coded frame number from the bitstream. Bytes 14

             * through 17 represesent the frame number. */

            p_frame_output->frame_num = AV_RB32(enc_buf->data + 13);



            ff_schro_queue_push_back(&p_schro_params->enc_frame_queue,

                                     p_frame_output);

            p_schro_params->enc_buf_size = 0;

            p_schro_params->enc_buf      = NULL;



            schro_buffer_unref(enc_buf);



            break;



        case SCHRO_STATE_NEED_FRAME:

            go = 0;

            break;



        case SCHRO_STATE_AGAIN:

            break;



        default:

            av_log(avctx, AV_LOG_ERROR, ""Unknown Schro Encoder state\n"");

            return -1;

        }

    }



    /* Copy 'next' frame in queue. */



    if (p_schro_params->enc_frame_queue.size == 1 &&

        p_schro_params->eos_pulled)

        last_frame_in_sequence = 1;



    p_frame_output = ff_schro_queue_pop(&p_schro_params->enc_frame_queue);



    if (!p_frame_output)

        return 0;



    pkt_size = p_frame_output->size;

    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0)

        pkt_size += p_schro_params->enc_buf_size;

    if ((ret = ff_alloc_packet(pkt, pkt_size)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Error getting output packet of size %d.\n"", pkt_size);

        goto error;

    }



    memcpy(pkt->data, p_frame_output->p_encbuf, p_frame_output->size);

    avctx->coded_frame->key_frame = p_frame_output->key_frame;

    /* Use the frame number of the encoded frame as the pts. It is OK to

     * do so since Dirac is a constant frame rate codec. It expects input

     * to be of constant frame rate. */

    pkt->pts =

    avctx->coded_frame->pts = p_frame_output->frame_num;

    pkt->dts = p_schro_params->dts++;

    enc_size = p_frame_output->size;



    /* Append the end of sequence information to the last frame in the

     * sequence. */

    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0) {

        memcpy(pkt->data + enc_size, p_schro_params->enc_buf,

               p_schro_params->enc_buf_size);

        enc_size += p_schro_params->enc_buf_size;

        av_freep(&p_schro_params->enc_buf);

        p_schro_params->enc_buf_size = 0;

    }



    if (p_frame_output->key_frame)

        pkt->flags |= AV_PKT_FLAG_KEY;

    *got_packet = 1;



error:

    /* free frame */

    libschroedinger_free_frame(p_frame_output);

    return ret;

}
",926,,LABEL_0,LABEL_1,,-4,"avctx,pkt,frame,got_packet,p_schro_params,encoder,p_frame_output,enc_buf,presentation_frame,parse_code,pkt_size,ret,in_frame,err,state",,,,0,,0,Greedy,1,0.0010477304458618164,,
39,"static int vnc_validate_certificate(struct VncState *vs)

{

    int ret;

    unsigned int status;

    const gnutls_datum_t *certs;

    unsigned int nCerts, i;

    time_t now;



    VNC_DEBUG(""Validating client certificate\n"");

    if ((ret = gnutls_certificate_verify_peers2 (vs->tls_session, &status)) < 0) {

	VNC_DEBUG(""Verify failed %s\n"", gnutls_strerror(ret));

	return -1;

    }



    if ((now = time(NULL)) == ((time_t)-1)) {

	return -1;

    }



    if (status != 0) {

	if (status & GNUTLS_CERT_INVALID)

	    VNC_DEBUG(""The certificate is not trusted.\n"");



	if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)

	    VNC_DEBUG(""The certificate hasn't got a known issuer.\n"");



	if (status & GNUTLS_CERT_REVOKED)

	    VNC_DEBUG(""The certificate has been revoked.\n"");



	if (status & GNUTLS_CERT_INSECURE_ALGORITHM)

	    VNC_DEBUG(""The certificate uses an insecure algorithm\n"");



	return -1;

    } else {

	VNC_DEBUG(""Certificate is valid!\n"");

    }



    /* Only support x509 for now */

    if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509)

	return -1;



    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))

	return -1;



    for (i = 0 ; i < nCerts ; i++) {

	gnutls_x509_crt_t cert;

	VNC_DEBUG (""Checking certificate chain %d\n"", i);

	if (gnutls_x509_crt_init (&cert) < 0)

	    return -1;



	if (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_expiration_time (cert) < now) {

	    VNC_DEBUG(""The certificate has expired\n"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_activation_time (cert) > now) {

	    VNC_DEBUG(""The certificate is not yet activated\n"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_activation_time (cert) > now) {

	    VNC_DEBUG(""The certificate is not yet activated\n"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	gnutls_x509_crt_deinit (cert);

    }



    return 0;

}
",432,"static int vnc_validate_certificate(struct VncState *vs)

{

    int val;

    unsigned int status;

    const gnutls_datum_t *signb;

    unsigned int nCooks, i;

    time_t now;



    VNC_DEBUG(""Validating client certificate
"");

    if ((val = gnutls_certificate_verify_peers2 (vs->tls_session, &status)) < 0) {

	VNC_DEBUG(""Verify failed %s
"", gnutls_strerror(val));

	return -1;

    }



    if ((now = time(NULL)) == ((time_t)-1)) {

	return -1;

    }



    if (status != 0) {

	if (status & GNUTLS_CERT_INVALID)

	    VNC_DEBUG(""The certificate is not trusted.
"");



	if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)

	    VNC_DEBUG(""The certificate hasn't got a known issuer.
"");



	if (status & GNUTLS_CERT_REVOKED)

	    VNC_DEBUG(""The certificate has been revoked.
"");



	if (status & GNUTLS_CERT_INSECURE_ALGORITHM)

	    VNC_DEBUG(""The certificate uses an insecure algorithm
"");



	return -1;

    } else {

	VNC_DEBUG(""Certificate is valid!
"");

    }



    /* Only support x509 for now */

    if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509)

	return -1;



    if (!(signb = gnutls_certificate_get_peers(vs->tls_session, &nCooks)))

	return -1;



    for (i = 0 ; i < nCooks ; i++) {

	gnutls_x509_crt_t cert;

	VNC_DEBUG (""Checking certificate chain %d
"", i);

	if (gnutls_x509_crt_init (&cert) < 0)

	    return -1;



	if (gnutls_x509_crt_import(cert, &signb[i], GNUTLS_X509_FMT_DER) < 0) {

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_expiration_time (cert) < now) {

	    VNC_DEBUG(""The certificate has expired
"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_activation_time (cert) > now) {

	    VNC_DEBUG(""The certificate is not yet activated
"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_activation_time (cert) > now) {

	    VNC_DEBUG(""The certificate is not yet activated
"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	gnutls_x509_crt_deinit (cert);

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"vs,ret,status,certs,nCerts,i,now,cert","vs:-0.0012687444686889648,ret:-0.0008876323699951172,status:-0.0022846460342407227,certs:-0.000660240650177002,nCerts:9.268522262573242e-05,i:-0.001520395278930664,now:-0.0021096467971801758,cert:-0.004200160503387451,",3,9,0,"nCerts:nCooks,certs:signb,ret:val,",0,Greedy,182,0.07340332269668579,replace,[]
40,"void qmp_migrate_set_speed(int64_t value, Error **errp)

{

    MigrationState *s;



    if (value < 0) {

        value = 0;

    }



    s = migrate_get_current();

    s->bandwidth_limit = value;

    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);

}
",54,"void qmp_migrate_set_speed(int64_t value, Error **erp)

{

    MigrationState *s;



    if (value < 0) {

        value = 0;

    }



    s = migrate_get_current();

    s->bandwidth_limit = value;

    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);

}
",LABEL_0,LABEL_0,LABEL_1,1,"value,errp,s","value:-0.0005726814270019531,errp:-0.00031280517578125,s:-0.0009292364120483398,",1,1,0,"errp:erp,",0,Greedy,26,0.009315741062164307,replace,[]
41,"static int mpc8_decode_frame(AVCodecContext * avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    MPCContext *c = avctx->priv_data;

    GetBitContext gb2, *gb = &gb2;

    int i, j, k, ch, cnt, res, t;

    Band *bands = c->bands;

    int off;

    int maxband, keyframe;

    int last[2];



    keyframe = c->cur_frame == 0;



    if(keyframe){

        memset(c->Q, 0, sizeof(c->Q));

        c->last_bits_used = 0;

    }

    init_get_bits(gb, buf, buf_size * 8);

    skip_bits(gb, c->last_bits_used & 7);



    if(keyframe)

        maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1);

    else{

        maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2);

        if(maxband > 32) maxband -= 33;

    }

    c->last_max_band = maxband;



    /* read subband indexes */

    if(maxband){

        last[0] = last[1] = 0;

        for(i = maxband - 1; i >= 0; i--){

            for(ch = 0; ch < 2; ch++){

                last[ch] = get_vlc2(gb, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch];

                if(last[ch] > 15) last[ch] -= 17;

                bands[i].res[ch] = last[ch];

            }

        }

        if(c->MSS){

            int mask;



            cnt = 0;

            for(i = 0; i < maxband; i++)

                if(bands[i].res[0] || bands[i].res[1])

                    cnt++;

            t = mpc8_get_mod_golomb(gb, cnt);

            mask = mpc8_get_mask(gb, cnt, t);

            for(i = maxband - 1; i >= 0; i--)

                if(bands[i].res[0] || bands[i].res[1]){

                    bands[i].msf = mask & 1;

                    mask >>= 1;

                }

        }

    }

    for(i = maxband; i < c->maxbands; i++)

        bands[i].res[0] = bands[i].res[1] = 0;



    if(keyframe){

        for(i = 0; i < 32; i++)

            c->oldDSCF[0][i] = c->oldDSCF[1][i] = 1;

    }



    for(i = 0; i < maxband; i++){

        if(bands[i].res[0] || bands[i].res[1]){

            cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1;

            if(cnt >= 0){

                t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1);

                if(bands[i].res[0]) bands[i].scfi[0] = t >> (2 * cnt);

                if(bands[i].res[1]) bands[i].scfi[1] = t & 3;

            }

        }

    }



    for(i = 0; i < maxband; i++){

        for(ch = 0; ch < 2; ch++){

            if(!bands[i].res[ch]) continue;



            if(c->oldDSCF[ch][i]){

                bands[i].scf_idx[ch][0] = get_bits(gb, 7) - 6;

                c->oldDSCF[ch][i] = 0;

            }else{

                t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2);

                if(t == 64)

                    t += get_bits(gb, 6);

                bands[i].scf_idx[ch][0] = ((bands[i].scf_idx[ch][2] + t - 25) & 0x7F) - 6;

            }

            for(j = 0; j < 2; j++){

                if((bands[i].scfi[ch] << j) & 2)

                    bands[i].scf_idx[ch][j + 1] = bands[i].scf_idx[ch][j];

                else{

                    t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2);

                    if(t == 31)

                        t = 64 + get_bits(gb, 6);

                    bands[i].scf_idx[ch][j + 1] = ((bands[i].scf_idx[ch][j] + t - 25) & 0x7F) - 6;

                }

            }

        }

    }



    for(i = 0, off = 0; i < maxband; i++, off += SAMPLES_PER_BAND){

        for(ch = 0; ch < 2; ch++){

            res = bands[i].res[ch];

            switch(res){

            case -1:

                for(j = 0; j < SAMPLES_PER_BAND; j++)

                    c->Q[ch][off + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510;

                break;

            case 0:

                break;

            case 1:

                for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){

                    cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2);

                    t = mpc8_get_mask(gb, 18, cnt);

                    for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1)

                        c->Q[ch][off + j + k] = (t & 0x20000) ? (get_bits1(gb) << 1) - 1 : 0;

                }

                break;

            case 2:

                cnt = 6;//2*mpc8_thres[res]

                for(j = 0; j < SAMPLES_PER_BAND; j += 3){

                    t = get_vlc2(gb, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2);

                    c->Q[ch][off + j + 0] = mpc8_idx50[t];

                    c->Q[ch][off + j + 1] = mpc8_idx51[t];

                    c->Q[ch][off + j + 2] = mpc8_idx52[t];

                    cnt = (cnt >> 1) + mpc8_huffq2[t];

                }

                break;

            case 3:

            case 4:

                for(j = 0; j < SAMPLES_PER_BAND; j += 2){

                    t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3];

                    c->Q[ch][off + j + 1] = t >> 4;

                    c->Q[ch][off + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF);

                }

                break;

            case 5:

            case 6:

            case 7:

            case 8:

                cnt = 2 * mpc8_thres[res];

                for(j = 0; j < SAMPLES_PER_BAND; j++){

                    t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5];

                    c->Q[ch][off + j] = t;

                    cnt = (cnt >> 1) + FFABS(c->Q[ch][off + j]);

                }

                break;

            default:

                for(j = 0; j < SAMPLES_PER_BAND; j++){

                    c->Q[ch][off + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2);

                    if(res != 9){

                        c->Q[ch][off + j] <<= res - 9;

                        c->Q[ch][off + j] |= get_bits(gb, res - 9);

                    }

                    c->Q[ch][off + j] -= (1 << (res - 2)) - 1;

                }

            }

        }

    }



    ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels);



    c->cur_frame++;



    c->last_bits_used = get_bits_count(gb);

    if(c->cur_frame >= c->frames)

        c->cur_frame = 0;

    *data_size =  MPC_FRAME_SIZE * 2 * avctx->channels;



    return c->cur_frame ? c->last_bits_used >> 3 : buf_size;

}
",1786,,LABEL_0,LABEL_1,,-4,"avctx,data,data_size,avpkt,buf,c,gb2,gb,i,j,k,ch,cnt,res,t,bands,off,maxband,keyframe,last,mask,cur_frame",,,,0,,0,Greedy,1,0.0013878385225931803,,
42,"qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)

{

    PXA2xxPICState *s;

    int iomemtype;

    qemu_irq *qi;



    s = (PXA2xxPICState *)

            qemu_mallocz(sizeof(PXA2xxPICState));

    if (!s)

        return NULL;



    s->cpu_env = env;



    s->int_pending[0] = 0;

    s->int_pending[1] = 0;

    s->int_enabled[0] = 0;

    s->int_enabled[1] = 0;

    s->is_fiq[0] = 0;

    s->is_fiq[1] = 0;



    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);



    /* Enable IC memory-mapped registers access.  */

    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,

                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(base, 0x00100000, iomemtype);



    /* Enable IC coprocessor access.  */

    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);



    register_savevm(NULL, ""pxa2xx_pic"", 0, 0, pxa2xx_pic_save,

                    pxa2xx_pic_load, s);



    return qi;

}
",200,"qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)

{

    PXA2xxPICState *socket;

    int iomemtype;

    qemu_irq *qi;



    socket = (PXA2xxPICState *)

            qemu_mallocz(sizeof(PXA2xxPICState));

    if (!s)

        return NULL;



    socket->cpu_env = env;



    socket->int_pending[0] = 0;

    socket->int_pending[1] = 0;

    socket->int_enabled[0] = 0;

    socket->int_enabled[1] = 0;

    socket->is_fiq[0] = 0;

    socket->is_fiq[1] = 0;



    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, socket, PXA2XX_PIC_SRCS);



    /* Enable IC memory-mapped registers access.  */

    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,

                    pxa2xx_pic_writefn, socket, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(base, 0x00100000, iomemtype);



    /* Enable IC coprocessor access.  */

    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, socket);



    register_savevm(NULL, ""pxa2xx_pic"", 0, 0, pxa2xx_pic_save,

                    pxa2xx_pic_load, socket);



    return qi;

}
",LABEL_0,LABEL_0,LABEL_1,1,"base,env,s,iomemtype,qi","base:2.2411346435546875e-05,env:6.29425048828125e-05,s:0.00041931867599487305,iomemtype:4.9948692321777344e-05,qi:7.355213165283203e-05,",1,13,0,"s:socket,",0,Greedy,96,0.03513321876525879,replace,[]
43,"static void stellaris_enet_save(QEMUFile *f, void *opaque)

{

    stellaris_enet_state *s = (stellaris_enet_state *)opaque;

    int i;



    qemu_put_be32(f, s->ris);

    qemu_put_be32(f, s->im);

    qemu_put_be32(f, s->rctl);

    qemu_put_be32(f, s->tctl);

    qemu_put_be32(f, s->thr);

    qemu_put_be32(f, s->mctl);

    qemu_put_be32(f, s->mdv);

    qemu_put_be32(f, s->mtxd);

    qemu_put_be32(f, s->mrxd);

    qemu_put_be32(f, s->np);

    qemu_put_be32(f, s->tx_fifo_len);

    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));

    for (i = 0; i < 31; i++) {

        qemu_put_be32(f, s->rx[i].len);

        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));



    }

    qemu_put_be32(f, s->next_packet);

    qemu_put_be32(f, s->rx_fifo_offset);

}
",234,"static void stellaris_enet_save(QEMUFile *f, void *opaque)

{

    stellaris_enet_state *fs = (stellaris_enet_state *)opaque;

    int i;



    qemu_put_be32(f, fs->ris);

    qemu_put_be32(f, fs->im);

    qemu_put_be32(f, fs->rctl);

    qemu_put_be32(f, fs->tctl);

    qemu_put_be32(f, fs->thr);

    qemu_put_be32(f, fs->mctl);

    qemu_put_be32(f, fs->mdv);

    qemu_put_be32(f, fs->mtxd);

    qemu_put_be32(f, fs->mrxd);

    qemu_put_be32(f, fs->np);

    qemu_put_be32(f, fs->tx_fifo_len);

    qemu_put_buffer(f, fs->tx_fifo, sizeof(fs->tx_fifo));

    for (i = 0; i < 31; i++) {

        qemu_put_be32(f, fs->rx[i].len);

        qemu_put_buffer(f, fs->rx[i].data, sizeof(fs->rx[i].data));



    }

    qemu_put_be32(f, fs->next_packet);

    qemu_put_be32(f, fs->rx_fifo_offset);

}
",LABEL_1,LABEL_1,LABEL_0,1,"f,opaque,s,i","f:0.0008323788642883301,opaque:7.110834121704102e-05,s:0.0009322166442871094,i:6.03795051574707e-05,",1,19,0,"s:fs,",0,Greedy,128,0.04680266777674357,replace,[]
44,"static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(dev, &s->mem);

    return 0;

}
",79,"static int idreg_init1(SysBusDevice *device)

{

    IDRegState *s = MACIO_ID_REGISTER(device);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(device, &s->mem);

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"dev,s","dev:1.4841556549072266e-05,s:2.8014183044433594e-06,",1,3,0,"dev:device,",0,Greedy,57,0.020236643155415852,replace,[]
45,"static void setup_rt_frame(int sig, struct target_sigaction *ka,

                           target_siginfo_t *info,

                           target_sigset_t *set, CPUAlphaState *env)

{

    abi_ulong frame_addr, r26;

    struct target_rt_sigframe *frame;

    int i, err = 0;



    frame_addr = get_sigframe(ka, env, sizeof(*frame));

    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {

        goto give_sigsegv;

    }



    err |= copy_siginfo_to_user(&frame->info, info);



    __put_user(0, &frame->uc.tuc_flags);

    __put_user(0, &frame->uc.tuc_link);

    __put_user(set->sig[0], &frame->uc.tuc_osf_sigmask);

    __put_user(target_sigaltstack_used.ss_sp,

               &frame->uc.tuc_stack.ss_sp);

    __put_user(sas_ss_flags(env->ir[IR_SP]),

               &frame->uc.tuc_stack.ss_flags);

    __put_user(target_sigaltstack_used.ss_size,

               &frame->uc.tuc_stack.ss_size);

    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);

    for (i = 0; i < TARGET_NSIG_WORDS; ++i) {

        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);

    }



    if (ka->sa_restorer) {

        r26 = ka->sa_restorer;

    } else {

        __put_user(INSN_MOV_R30_R16, &frame->retcode[0]);

        __put_user(INSN_LDI_R0 + TARGET_NR_rt_sigreturn,

                   &frame->retcode[1]);

        __put_user(INSN_CALLSYS, &frame->retcode[2]);

        /* imb(); */

        r26 = frame_addr;

    }



    if (err) {

    give_sigsegv:

       if (sig == TARGET_SIGSEGV) {

            ka->_sa_handler = TARGET_SIG_DFL;

        }

        force_sig(TARGET_SIGSEGV);

    }



    env->ir[IR_RA] = r26;

    env->ir[IR_PV] = env->pc = ka->_sa_handler;

    env->ir[IR_A0] = sig;

    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);

    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);

    env->ir[IR_SP] = frame_addr;

}
",439,"static void setup_rt_frame(int sIG, struct target_sigaction *oda,

                           target_siginfo_t *info,

                           target_sigset_t *net, CPUAlphaState *env)

{

    abi_ulong frame_addr,  r6;

    struct target_rt_sigframe *frame;

    int adi, err = 0;



    frame_addr = get_sigframe(oda, env, sizeof(*frame));

    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {

        goto give_sigsegv;

    }



    err |= copy_siginfo_to_user(&frame->info, info);



    __put_user(0, &frame->uc.tuc_flags);

    __put_user(0, &frame->uc.tuc_link);

    __put_user(net->sIG[0], &frame->uc.tuc_osf_sigmask);

    __put_user(target_sigaltstack_used.ss_sp,

               &frame->uc.tuc_stack.ss_sp);

    __put_user(sas_ss_flags(env->ir[IR_SP]),

               &frame->uc.tuc_stack.ss_flags);

    __put_user(target_sigaltstack_used.ss_size,

               &frame->uc.tuc_stack.ss_size);

    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, net);

    for (adi = 0; adi < TARGET_NSIG_WORDS; ++adi) {

        __put_user(net->sIG[adi], &frame->uc.tuc_sigmask.sIG[adi]);

    }



    if (oda->sa_restorer) {

         r6 = oda->sa_restorer;

    } else {

        __put_user(INSN_MOV_R30_R16, &frame->retcode[0]);

        __put_user(INSN_LDI_R0 + TARGET_NR_rt_sigreturn,

                   &frame->retcode[1]);

        __put_user(INSN_CALLSYS, &frame->retcode[2]);

        /* imb(); */

         r6 = frame_addr;

    }



    if (err) {

    give_sigsegv:

       if (sIG == TARGET_SIGSEGV) {

            oda->_sa_handler = TARGET_SIG_DFL;

        }

        force_sig(TARGET_SIGSEGV);

    }



    env->ir[IR_RA] =  r6;

    env->ir[IR_PV] = env->pc = oda->_sa_handler;

    env->ir[IR_A0] = sIG;

    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);

    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);

    env->ir[IR_SP] = frame_addr;

}
",LABEL_0,LABEL_0,LABEL_1,1,"sig,ka,info,set,env,frame_addr,r26,frame,i","sig:-0.0006760954856872559,ka:-0.0007703304290771484,info:-0.0008003711700439453,set:-0.0004528164863586426,env:-0.0008614659309387207,frame_addr:-0.0007858872413635254,r26:4.3272972106933594e-05,frame:-0.0015909075736999512,i:-0.0005786418914794922,",5,26,0,"r26: r6,set:net,i:adi,sig:sIG,ka:oda,",0,Greedy,290,0.11436004638671875,replace,[]
46,"static void imx_gpt_reset(DeviceState *dev)

{

    IMXGPTState *s = IMX_GPT(dev);



    /* stop timer */

    ptimer_stop(s->timer);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|

               GPT_CR_WAITEN|GPT_CR_DBGEN);

    s->sr = 0;

    s->pr = 0;

    s->ir = 0;

    s->cnt = 0;

    s->ocr1 = TIMER_MAX;

    s->ocr2 = TIMER_MAX;

    s->ocr3 = TIMER_MAX;

    s->icr1 = 0;

    s->icr2 = 0;



    s->next_timeout = TIMER_MAX;

    s->next_int = 0;



    /* compute new freq */

    imx_gpt_set_freq(s);



    /* reset the limit to TIMER_MAX */

    ptimer_set_limit(s->timer, TIMER_MAX, 1);



    /* if the timer is still enabled, restart it */

    if (s->freq && (s->cr & GPT_CR_EN)) {

        ptimer_run(s->timer, 1);

    }

}
",225,,LABEL_0,LABEL_1,,-4,"dev,s",,,,0,,0,Greedy,1,0.000564873218536377,,
47,"static inline int get_chroma_qp(H264Context *h, int qscale){

    return h->pps.chroma_qp_table[qscale & 0xff];

}
",28,,LABEL_1,LABEL_0,,-4,"h,qscale",,,,0,,0,Greedy,1,0.00043271382649739585,,
48,"static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)

{

    uint8_t *old_code_ptr = s->code_ptr;

    assert(ret != arg);

#if TCG_TARGET_REG_BITS == 32

    tcg_out_op_t(s, INDEX_op_mov_i32);

#else

    tcg_out_op_t(s, INDEX_op_mov_i64);

#endif

    tcg_out_r(s, ret);

    tcg_out_r(s, arg);

    old_code_ptr[1] = s->code_ptr - old_code_ptr;

}
",77,,LABEL_0,LABEL_0,LABEL_0,-1,"s,type,ret,arg,old_code_ptr",,5,17,0,,0,GA,1044,0.3712882479031881,failed,[]
49,"static int find_pte32(CPUPPCState *env, mmu_ctx_t *ctx, int h,

                      int rw, int type, int target_page_bits)

{

    hwaddr pteg_off;

    target_ulong pte0, pte1;

    int i, good = -1;

    int ret, r;



    ret = -1; /* No entry found */

    pteg_off = get_pteg_offset(env, ctx->hash[h], HASH_PTE_SIZE_32);

    for (i = 0; i < 8; i++) {

        if (env->external_htab) {

            pte0 = ldl_p(env->external_htab + pteg_off + (i * 8));

            pte1 = ldl_p(env->external_htab + pteg_off + (i * 8) + 4);

        } else {

            pte0 = ldl_phys(env->htab_base + pteg_off + (i * 8));

            pte1 = ldl_phys(env->htab_base + pteg_off + (i * 8) + 4);

        }

        r = pte_check_hash32(ctx, pte0, pte1, h, rw, type);

        LOG_MMU(""Load pte from %08"" HWADDR_PRIx "" => "" TARGET_FMT_lx "" ""

                TARGET_FMT_lx "" %d %d %d "" TARGET_FMT_lx ""\n"",

                pteg_off + (i * 8), pte0, pte1, (int)(pte0 >> 31), h,

                (int)((pte0 >> 6) & 1), ctx->ptem);

        switch (r) {

        case -3:

            /* PTE inconsistency */

            return -1;

        case -2:

            /* Access violation */

            ret = -2;

            good = i;

            break;

        case -1:

        default:

            /* No PTE match */

            break;

        case 0:

            /* access granted */

            /* XXX: we should go on looping to check all PTEs consistency

             *      but if we can speed-up the whole thing as the

             *      result would be undefined if PTEs are not consistent.

             */

            ret = 0;

            good = i;

            goto done;

        }

    }

    if (good != -1) {

    done:

        LOG_MMU(""found PTE at addr %08"" HWADDR_PRIx "" prot=%01x ret=%d\n"",

                ctx->raddr, ctx->prot, ret);

        /* Update page flags */

        pte1 = ctx->raddr;

        if (pte_update_flags(ctx, &pte1, ret, rw) == 1) {

            if (env->external_htab) {

                stl_p(env->external_htab + pteg_off + (good * 8) + 4,

                      pte1);

            } else {

                stl_phys_notdirty(env->htab_base + pteg_off +

                                  (good * 8) + 4, pte1);

            }

        }

    }



    /* We have a TLB that saves 4K pages, so let's

     * split a huge page to 4k chunks */

    if (target_page_bits != TARGET_PAGE_BITS) {

        ctx->raddr |= (ctx->eaddr & ((1 << target_page_bits) - 1))

                      & TARGET_PAGE_MASK;

    }

    return ret;

}
",557,"static int find_pte32(CPUPPCState *env, mmu_ctx_t *exc, int ht,

                      int wn, int type, int target_pagenumconfig)

{

    hwaddr pteg67num;

    target_ulong pte0, pte1;

    int adi, good = -1;

    int ret, r;



    ret = -1; /* No entry found */

    pteg67num = get_pteg_offset(env, exc->hash[ht], HASH_PTE_SIZE_32);

    for (adi = 0; adi < 8; adi++) {

        if (env->external_htab) {

            pte0 = ldl_p(env->external_htab + pteg67num + (adi * 8));

            pte1 = ldl_p(env->external_htab + pteg67num + (adi * 8) + 4);

        } else {

            pte0 = ldl_phys(env->htab_base + pteg67num + (adi * 8));

            pte1 = ldl_phys(env->htab_base + pteg67num + (adi * 8) + 4);

        }

        r = pte_check_hash32(exc, pte0, pte1, ht, wn, type);

        LOG_MMU(""Load pte from %08"" HWADDR_PRIx "" => "" TARGET_FMT_lx "" ""

                TARGET_FMT_lx "" %d %d %d "" TARGET_FMT_lx ""
"",

                pteg67num + (adi * 8), pte0, pte1, (int)(pte0 >> 31), ht,

                (int)((pte0 >> 6) & 1), exc->ptem);

        switch (r) {

        case -3:

            /* PTE inconsistency */

            return -1;

        case -2:

            /* Access violation */

            ret = -2;

            good = adi;

            break;

        case -1:

        default:

            /* No PTE match */

            break;

        case 0:

            /* access granted */

            /* XXX: we should go on looping to check all PTEs consistency

             *      but if we can speed-up the whole thing as the

             *      result would be undefined if PTEs are not consistent.

             */

            ret = 0;

            good = adi;

            goto done;

        }

    }

    if (good != -1) {

    done:

        LOG_MMU(""found PTE at addr %08"" HWADDR_PRIx "" prot=%01x ret=%d
"",

                exc->raddr, exc->prot, ret);

        /* Update page flags */

        pte1 = exc->raddr;

        if (pte_update_flags(exc, &pte1, ret, wn) == 1) {

            if (env->external_htab) {

                stl_p(env->external_htab + pteg67num + (good * 8) + 4,

                      pte1);

            } else {

                stl_phys_notdirty(env->htab_base + pteg67num +

                                  (good * 8) + 4, pte1);

            }

        }

    }



    /* We have a TLB that saves 4K pages, so let's

     * split a huge page to 4k chunks */

    if (target_pagenumconfig != TARGET_PAGE_BITS) {

        exc->raddr |= (exc->eaddr & ((1 << target_pagenumconfig) - 1))

                      & TARGET_PAGE_MASK;

    }

    return ret;

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,ctx,h,rw,type,target_page_bits,pteg_off,pte0,pte1,i,ret,r","env:0.0006873011589050293,ctx:0.002034902572631836,h:0.0007200837135314941,rw:0.0007437467575073242,type:0.00040084123611450195,target_page_bits:0.0014232397079467773,pteg_off:0.004823029041290283,pte0:4.0650367736816406e-05,pte1:-0.0005918145179748535,i:0.0010126829147338867,ret:-0.0022150278091430664,r:0.00033164024353027344,",6,40,0,"pteg_off:pteg67num,ctx:exc,target_page_bits:target_pagenumconfig,i:adi,rw:wn,h:ht,",0,Greedy,386,0.16062422593434653,replace,[]
50,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)

{

    QemuOpts *opts;



    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}
",57,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdf)

{

    QemuOpts *opts;



    opts = qemu_opts_create(list, qdict_get_try_str(qdf, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdf, qemu_opts_from_qdict_1, opts);

    return opts;

}
",LABEL_1,LABEL_1,LABEL_0,1,"list,qdict,opts","list:-0.00019294023513793945,qdict:-6.192922592163086e-05,opts:-0.0006063580513000488,",1,3,0,"qdict:qdf,",0,Greedy,49,0.017317243417104087,replace,[]
51,"static void opt_new_stream(const char *opt, const char *arg)

{

    AVFormatContext *oc;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }

    oc = output_files[nb_output_files - 1];



    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);

    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);

    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);

    else assert(0);

}
",111,,LABEL_0,LABEL_0,LABEL_0,-1,"opt,arg,oc",,3,10,0,,0,GA,661,0.24024664958318073,failed,[]
52,"static int update_dimensions(VP8Context *s, int width, int height)

{

    if (width  != s->avctx->width ||

        height != s->avctx->height) {

        if (av_image_check_size(width, height, 0, s->avctx))

            return AVERROR_INVALIDDATA;



        vp8_decode_flush_impl(s->avctx, 1, 0, 1);



        avcodec_set_dimensions(s->avctx, width, height);

    }



    s->mb_width  = (s->avctx->coded_width +15) / 16;

    s->mb_height = (s->avctx->coded_height+15) / 16;



    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));

    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));

    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);

    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));

    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));



    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||

        !s->top_nnz || !s->top_border)

        return AVERROR(ENOMEM);



    s->macroblocks        = s->macroblocks_base + 1;



    return 0;

}
",287,"static int update_dimensions(VP8Context *s, int width, int stroke)

{

    if (width  != s->avctx->width ||

        stroke != s->avctx->stroke) {

        if (av_image_check_size(width, stroke, 0, s->avctx))

            return AVERROR_INVALIDDATA;



        vp8_decode_flush_impl(s->avctx, 1, 0, 1);



        avcodec_set_dimensions(s->avctx, width, stroke);

    }



    s->mb_width  = (s->avctx->coded_width +15) / 16;

    s->mb_height = (s->avctx->coded_height+15) / 16;



    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));

    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));

    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);

    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));

    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));



    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||

        !s->top_nnz || !s->top_border)

        return AVERROR(ENOMEM);



    s->macroblocks        = s->macroblocks_base + 1;



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,height","s:-9.560585021972656e-05,height:-1.7881393432617188e-05,",1,5,0,"height:stroke,",0,Greedy,90,0.03344028393427531,replace,[]
53,"int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,

                     int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & 0x00000100)) {

        /* Update accessed flag */

        *pte1p |= 0x00000100;

        store = 1;

    }

    if (!(*pte1p & 0x00000080)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= 0x00000080;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
",127,,LABEL_0,LABEL_0,LABEL_0,-1,"ctx,pte1p,ret,rw",,4,11,0,,0,GA,855,0.31369526783625284,failed,[]
54,"static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,

     int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) {

  uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY;

  // yv12toyuy2( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );

  uint8_t *ysrc = src[0];

  uint8_t *usrc = src[1];

  uint8_t *vsrc = src[2];

  const int width = c->srcW;

  const int height = srcSliceH;

  const int lumStride = srcStride[0];

  const int chromStride = srcStride[1];

  const int dstStride = dstStride_a[0];

  const vector unsigned char yperm = vec_lvsl(0, ysrc);

  const int vertLumPerChroma = 2;

  register unsigned int y;



  if(width&15){

    yv12toyuy2( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride);

    return srcSliceH;

  }



  /* this code assume:



  1) dst is 16 bytes-aligned

  2) dstStride is a multiple of 16

  3) width is a multiple of 16

  4) lum&chrom stride are multiple of 8

  */



  for(y=0; y<height; y++)

    {

      int i;

      for (i = 0; i < width - 31; i+= 32) {

	const unsigned int j = i >> 1;

	vector unsigned char v_yA = vec_ld(i, ysrc);

	vector unsigned char v_yB = vec_ld(i + 16, ysrc);

	vector unsigned char v_yC = vec_ld(i + 32, ysrc);

	vector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm);

	vector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm);

	vector unsigned char v_uA = vec_ld(j, usrc);

	vector unsigned char v_uB = vec_ld(j + 16, usrc);

	vector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc));

	vector unsigned char v_vA = vec_ld(j, vsrc);

	vector unsigned char v_vB = vec_ld(j + 16, vsrc);

	vector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, vsrc));

	vector unsigned char v_uv_a = vec_mergeh(v_u, v_v);

	vector unsigned char v_uv_b = vec_mergel(v_u, v_v);

	vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);

	vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);

	vector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b);

	vector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b);

	vec_st(v_yuy2_0, (i << 1), dst);

	vec_st(v_yuy2_1, (i << 1) + 16, dst);

	vec_st(v_yuy2_2, (i << 1) + 32, dst);

	vec_st(v_yuy2_3, (i << 1) + 48, dst);

      }

      if (i < width) {

	const unsigned int j = i >> 1;

	vector unsigned char v_y1 = vec_ld(i, ysrc);

	vector unsigned char v_u = vec_ld(j, usrc);

	vector unsigned char v_v = vec_ld(j, vsrc);

	vector unsigned char v_uv_a = vec_mergeh(v_u, v_v);

	vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);

	vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);

	vec_st(v_yuy2_0, (i << 1), dst);

	vec_st(v_yuy2_1, (i << 1) + 16, dst);

      }

      if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) )

	{

	  usrc += chromStride;

	  vsrc += chromStride;

	}

      ysrc += lumStride;

      dst += dstStride;

    }



  return srcSliceH;

}
",765,"static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,

     int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) {

  uint8_t * dsc=dstParam[0] + dstStride_a[0]*srcSliceY;

  // yv12toyuy2( src[0],src[1],src[2], dsc,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );

  uint8_t *ysrc = src[0];

  uint8_t *usrc = src[1];

  uint8_t *vsrc = src[2];

  const int width = c->srcW;

  const int height = srcSliceH;

  const int lumStride = srcStride[0];

  const int chromStride = srcStride[1];

  const int dstStride = dstStride_a[0];

  const vector unsigned char yperm = vec_lvsl(0, ysrc);

  const int vertLumPerChroma = 2;

  register unsigned int y;



  if(width&15){

    yv12toyuy2( ysrc, usrc, vsrc,  dsc,c->srcW,srcSliceH, lumStride, chromStride, dstStride);

    return srcSliceH;

  }



  /* this code assume:



  1)  dsc is 16 bytes-aligned

  2) dstStride is a multiple of 16

  3) width is a multiple of 16

  4) lum&chrom stride are multiple of 8

  */



  for(y=0; y<height; y++)

    {

      int qi;

      for (qi = 0; qi < width - 31; qi+= 32) {

	const unsigned int j = qi >> 1;

	vector unsigned char v_yA = vec_ld(qi, ysrc);

	vector unsigned char v_yB = vec_ld(qi + 16, ysrc);

	vector unsigned char v_yC = vec_ld(qi + 32, ysrc);

	vector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm);

	vector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm);

	vector unsigned char v_uA = vec_ld(j, usrc);

	vector unsigned char v_uB = vec_ld(j + 16, usrc);

	vector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc));

	vector unsigned char v_vA = vec_ld(j, vsrc);

	vector unsigned char v_vB = vec_ld(j + 16, vsrc);

	vector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, vsrc));

	vector unsigned char v_uv_a = vec_mergeh(v_u, v_v);

	vector unsigned char v_uv_b = vec_mergel(v_u, v_v);

	vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);

	vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);

	vector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b);

	vector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b);

	vec_st(v_yuy2_0, (qi << 1),  dsc);

	vec_st(v_yuy2_1, (qi << 1) + 16,  dsc);

	vec_st(v_yuy2_2, (qi << 1) + 32,  dsc);

	vec_st(v_yuy2_3, (qi << 1) + 48,  dsc);

      }

      if (qi < width) {

	const unsigned int j = qi >> 1;

	vector unsigned char v_y1 = vec_ld(qi, ysrc);

	vector unsigned char v_u = vec_ld(j, usrc);

	vector unsigned char v_v = vec_ld(j, vsrc);

	vector unsigned char v_uv_a = vec_mergeh(v_u, v_v);

	vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);

	vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);

	vec_st(v_yuy2_0, (qi << 1),  dsc);

	vec_st(v_yuy2_1, (qi << 1) + 16,  dsc);

      }

      if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) )

	{

	  usrc += chromStride;

	  vsrc += chromStride;

	}

      ysrc += lumStride;

       dsc += dstStride;

    }



  return srcSliceH;

}
",LABEL_1,LABEL_1,LABEL_0,1,"c,src,srcStride,srcSliceY,srcSliceH,dstParam,dstStride_a,dst,ysrc,usrc,vsrc,y,i","c:0.6237886548042297,src:1.0834937691688538,srcStride:0.002574622631072998,srcSliceY:0.19507205486297607,srcSliceH:0.4950854182243347,dstParam:0.005888879299163818,dstStride_a:0.475189745426178,dst:1.2256332039833069,ysrc:0.033463120460510254,usrc:0.00537872314453125,vsrc:-0.008064329624176025,y:0.6279608607292175,i:2.3276724219322205,",2,28,0,"i:qi,dst: dsc,",0,Greedy,167,0.07106441656748454,replace,[]
55,"static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,

                                 unsigned npfd, int64_t timeout)

{

    if (!ctx->epoll_available) {

        return false;

    }

    if (aio_epoll_enabled(ctx)) {

        return true;

    }

    if (npfd >= EPOLL_ENABLE_THRESHOLD) {

        if (aio_epoll_try_enable(ctx)) {

            return true;

        } else {

            aio_epoll_disable(ctx);

        }

    }

    return false;

}
",76,,LABEL_0,LABEL_0,LABEL_0,-1,"ctx,pfds,npfd,timeout",,4,8,0,,0,GA,788,0.28211482365926105,failed,[]
56,"void tlb_set_page(CPUState *env, target_ulong vaddr,

                  target_phys_addr_t paddr, int prot,

                  int mmu_idx, target_ulong size)

{

    PhysPageDesc *p;

    unsigned long pd;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    unsigned long addend;

    CPUTLBEntry *te;

    CPUWatchpoint *wp;

    target_phys_addr_t iotlb;



    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }

    p = phys_page_find(paddr >> TARGET_PAGE_BITS);

    if (!p) {

        pd = IO_MEM_UNASSIGNED;

    } else {

        pd = p->phys_offset;

    }

#if defined(DEBUG_TLB)

    printf(""tlb_set_page: vaddr="" TARGET_FMT_lx "" paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\n"",

           vaddr, (int)paddr, prot, mmu_idx, is_softmmu, pd);

#endif



    address = vaddr;

    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {

        /* IO memory case (romd handled later) */

        address |= TLB_MMIO;

    }

    addend = (unsigned long)qemu_get_ram_ptr(pd & TARGET_PAGE_MASK);

    if ((pd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {

        /* Normal RAM.  */

        iotlb = pd & TARGET_PAGE_MASK;

        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM)

            iotlb |= IO_MEM_NOTDIRTY;

        else

            iotlb |= IO_MEM_ROM;

    } else {

        /* IO handlers are currently passed a physical address.

           It would be nice to pass an offset from the base address

           of that region.  This would avoid having to special case RAM,

           and avoid full address decoding in every device.

           We can't use the high bits of pd for this because

           IO_MEM_ROMD uses these as a ram address.  */

        iotlb = (pd & ~TARGET_PAGE_MASK);

        if (p) {

            iotlb += p->region_offset;

        } else {

            iotlb += paddr;

        }

    }



    code_address = address;

    /* Make accesses to pages with watchpoints go via the

       watchpoint trap routines.  */

    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {

        if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) {

            iotlb = io_mem_watch + paddr;

            /* TODO: The memory case can be optimized by not trapping

               reads of pages with a write breakpoint.  */

            address |= TLB_MMIO;

        }

    }



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    env->iotlb[mmu_idx][index] = iotlb - vaddr;

    te = &env->tlb_table[mmu_idx][index];

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||

            (pd & IO_MEM_ROMD)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&

                   !cpu_physical_memory_is_dirty(pd)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}
",645,"void tlb_set_page(CPUState *env, target_ulong tvaddr,

                  target_phys_addr_t pairs, int prot,

                  int mmu_sidv, target_ulong c)

{

    PhysPageDesc *bp;

    unsigned long att;

    unsigned int val;

    target_ulong address;

    target_ulong cache_host;

    unsigned long loadstart;

    CPUTLBEntry *te;

    CPUWatchpoint *dc;

    target_phys_addr_t nitrb;



    assert(c >= TARGET_PAGE_SIZE);

    if (c != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, tvaddr, c);

    }

    bp = phys_page_find(pairs >> TARGET_PAGE_BITS);

    if (!p) {

        att = IO_MEM_UNASSIGNED;

    } else {

        att = bp->phys_offset;

    }

#if defined(DEBUG_TLB)

    printf(""tlb_set_page: vaddr="" TARGET_FMT_lx "" pairs=0x%08x prot=%x idx=%d smmu=%d att=0x%08lx
"",

           tvaddr, (int)pairs, prot, mmu_sidv, is_softmmu, att);

#endif



    address = tvaddr;

    if ((att & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(att & IO_MEM_ROMD)) {

        /* IO memory case (romd handled later) */

        address |= TLB_MMIO;

    }

    loadstart = (unsigned long)qemu_get_ram_ptr(att & TARGET_PAGE_MASK);

    if ((att & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {

        /* Normal RAM.  */

        nitrb = att & TARGET_PAGE_MASK;

        if ((att & ~TARGET_PAGE_MASK) == IO_MEM_RAM)

            nitrb |= IO_MEM_NOTDIRTY;

        else

            nitrb |= IO_MEM_ROM;

    } else {

        /* IO handlers are currently passed a physical address.

           It would be nice to pass an offset from the base address

           of that region.  This would avoid having to special case RAM,

           and avoid full address decoding in every device.

           We can't use the high bits of att for this because

           IO_MEM_ROMD uses these as a ram address.  */

        nitrb = (att & ~TARGET_PAGE_MASK);

        if (bp) {

            nitrb += bp->region_offset;

        } else {

            nitrb += pairs;

        }

    }



    cache_host = address;

    /* Make accesses to pages with watchpoints go via the

       watchpoint trap routines.  */

    QTAILQ_FOREACH(dc, &env->watchpoints, entry) {

        if (tvaddr == (dc->tvaddr & TARGET_PAGE_MASK)) {

            nitrb = io_mem_watch + pairs;

            /* TODO: The memory case can be optimized by not trapping

               reads of pages with a write breakpoint.  */

            address |= TLB_MMIO;

        }

    }



    val = (tvaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    env->nitrb[mmu_sidv][val] = nitrb - tvaddr;

    te = &env->tlb_table[mmu_sidv][val];

    te->loadstart = loadstart - tvaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = cache_host;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((att & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||

            (att & IO_MEM_ROMD)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if ((att & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&

                   !cpu_physical_memory_is_dirty(att)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,vaddr,paddr,prot,mmu_idx,size,p,pd,index,address,code_address,addend,te,wp,iotlb","env:-0.46148747205734253,vaddr:-0.06296831369400024,paddr:-0.020175695419311523,prot:-0.5470462441444397,mmu_idx:0.034738004207611084,size:-0.3678702712059021,p:-0.45580512285232544,pd:-0.08580911159515381,index:-0.37062138319015503,address:-1.1008300185203552,code_address:0.009246349334716797,addend:-0.015201091766357422,te:-0.8556362986564636,wp:-0.012670695781707764,iotlb:0.006889522075653076,",11,69,0,"mmu_idx:mmu_sidv,code_address:cache_host,iotlb:nitrb,wp:dc,addend:loadstart,paddr:pairs,vaddr:tvaddr,pd:att,size:c,index:val,p:bp,",0,Greedy,568,0.25137889782587686,replace,[]
57,"void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)

{

    int i;



    for (i=0; i < in->n; i++) {

        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);




        do {

            out[x] = 0.0;

            x += in->pitch_lag;

        } while (x < size && repeats);

    }

}",93,,LABEL_1,LABEL_1,LABEL_1,-1,"out,in,size,i",,4,15,0,,0,GA,827,0.2969624400138855,failed,[]
58,"static int qesd_init_out (HWVoiceOut *hw, audsettings_t *as)

{

    ESDVoiceOut *esd = (ESDVoiceOut *) hw;

    audsettings_t obt_as = *as;

    int esdfmt = ESD_STREAM | ESD_PLAY;

    int err;

    sigset_t set, old_set;



    sigfillset (&set);



    esdfmt |= (as->nchannels == 2) ? ESD_STEREO : ESD_MONO;

    switch (as->fmt) {

    case AUD_FMT_S8:

    case AUD_FMT_U8:

        esdfmt |= ESD_BITS8;

        obt_as.fmt = AUD_FMT_U8;

        break;



    case AUD_FMT_S32:

    case AUD_FMT_U32:

        dolog (""Will use 16 instead of 32 bit samples\n"");



    case AUD_FMT_S16:

    case AUD_FMT_U16:

    deffmt:

        esdfmt |= ESD_BITS16;

        obt_as.fmt = AUD_FMT_S16;

        break;



    default:

        dolog (""Internal logic error: Bad audio format %d\n"", as->fmt);

        goto deffmt;



    }

    obt_as.endianness = AUDIO_HOST_ENDIANNESS;



    audio_pcm_init_info (&hw->info, &obt_as);



    hw->samples = conf.samples;

    esd->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);

    if (!esd->pcm_buf) {

        dolog (""Could not allocate buffer (%d bytes)\n"",

               hw->samples << hw->info.shift);

        return -1;

    }



    esd->fd = -1;

    err = pthread_sigmask (SIG_BLOCK, &set, &old_set);

    if (err) {

        qesd_logerr (err, ""pthread_sigmask failed\n"");

        goto fail1;

    }



    esd->fd = esd_play_stream (esdfmt, as->freq, conf.dac_host, NULL);

    if (esd->fd < 0) {

        qesd_logerr (errno, ""esd_play_stream failed\n"");

        goto fail2;

    }



    if (audio_pt_init (&esd->pt, qesd_thread_out, esd, AUDIO_CAP, AUDIO_FUNC)) {

        goto fail3;

    }



    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);

    if (err) {

        qesd_logerr (err, ""pthread_sigmask(restore) failed\n"");

    }



    return 0;



 fail3:

    if (close (esd->fd)) {

        qesd_logerr (errno, ""%s: close on esd socket(%d) failed\n"",

                     AUDIO_FUNC, esd->fd);

    }

    esd->fd = -1;



 fail2:

    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);

    if (err) {

        qesd_logerr (err, ""pthread_sigmask(restore) failed\n"");

    }



 fail1:

    qemu_free (esd->pcm_buf);

    esd->pcm_buf = NULL;

    return -1;

}
",497,"static int qesd_init_out (HWVoiceOut *hw, audsettings_t *ass)

{

    ESDVoiceOut *esd = (ESDVoiceOut *) hw;

    audsettings_t obt_as = *ass;

    int esdfmt = ESD_STREAM | ESD_PLAY;

    int gr;

    sigset_t set, old_set;



    sigfillset (&set);



    esdfmt |= (ass->nchannels == 2) ? ESD_STEREO : ESD_MONO;

    switch (ass->fmt) {

    case AUD_FMT_S8:

    case AUD_FMT_U8:

        esdfmt |= ESD_BITS8;

        obt_as.fmt = AUD_FMT_U8;

        break;



    case AUD_FMT_S32:

    case AUD_FMT_U32:

        dolog (""Will use 16 instead of 32 bit samples
"");



    case AUD_FMT_S16:

    case AUD_FMT_U16:

    deffmt:

        esdfmt |= ESD_BITS16;

        obt_as.fmt = AUD_FMT_S16;

        break;



    default:

        dolog (""Internal logic error: Bad audio format %d
"", ass->fmt);

        goto deffmt;



    }

    obt_as.endianness = AUDIO_HOST_ENDIANNESS;



    audio_pcm_init_info (&hw->info, &obt_as);



    hw->samples = conf.samples;

    esd->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);

    if (!esd->pcm_buf) {

        dolog (""Could not allocate buffer (%d bytes)
"",

               hw->samples << hw->info.shift);

        return -1;

    }



    esd->fd = -1;

    gr = pthread_sigmask (SIG_BLOCK, &set, &old_set);

    if (gr) {

        qesd_logerr (gr, ""pthread_sigmask failed
"");

        goto fail1;

    }



    esd->fd = esd_play_stream (esdfmt, ass->freq, conf.dac_host, NULL);

    if (esd->fd < 0) {

        qesd_logerr (errno, ""esd_play_stream failed
"");

        goto fail2;

    }



    if (audio_pt_init (&esd->pt, qesd_thread_out, esd, AUDIO_CAP, AUDIO_FUNC)) {

        goto fail3;

    }



    gr = pthread_sigmask (SIG_SETMASK, &old_set, NULL);

    if (gr) {

        qesd_logerr (gr, ""pthread_sigmask(restore) failed
"");

    }



    return 0;



 fail3:

    if (close (esd->fd)) {

        qesd_logerr (errno, ""%s: close on esd socket(%d) failed
"",

                     AUDIO_FUNC, esd->fd);

    }

    esd->fd = -1;



 fail2:

    gr = pthread_sigmask (SIG_SETMASK, &old_set, NULL);

    if (gr) {

        qesd_logerr (gr, ""pthread_sigmask(restore) failed
"");

    }



 fail1:

    qemu_free (esd->pcm_buf);

    esd->pcm_buf = NULL;

    return -1;

}
",LABEL_0,LABEL_0,LABEL_1,1,"hw,as,esd,err,set,old_set","hw:0.000937044620513916,as:0.00316542387008667,esd:-0.00226670503616333,err:0.00274658203125,set:0.0015038847923278809,old_set:-0.0006628036499023438,",2,16,0,"as:ass,err:gr,",0,Greedy,177,0.07294133106867472,replace,[]
59,"int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t buf[L1_ENTRIES_PER_SECTOR];

    int l1_start_index;

    int i, ret;



    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {

        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);

    }



    ret = qcow2_pre_write_overlap_check(bs,

            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,

            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,

        buf, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
",168,,LABEL_1,LABEL_0,,-4,"bs,l1_index,s,buf,l1_start_index,i,ret",,,,0,,0,Greedy,1,0.0005233407020568848,,
60,"static av_cold int sonic_encode_init(AVCodecContext *avctx)

{

    SonicContext *s = avctx->priv_data;

    PutBitContext pb;

    int i, version = 0;



    if (avctx->channels > MAX_CHANNELS)

    {

        av_log(avctx, AV_LOG_ERROR, ""Only mono and stereo streams are supported by now\n"");

        return AVERROR(EINVAL); /* only stereo or mono for now */

    }



    if (avctx->channels == 2)

        s->decorrelation = MID_SIDE;

    else

        s->decorrelation = 3;



    if (avctx->codec->id == AV_CODEC_ID_SONIC_LS)

    {

        s->lossless = 1;

        s->num_taps = 32;

        s->downsampling = 1;

        s->quantization = 0.0;

    }

    else

    {

        s->num_taps = 128;

        s->downsampling = 2;

        s->quantization = 1.0;

    }



    // max tap 2048

    if ((s->num_taps < 32) || (s->num_taps > 1024) ||

        ((s->num_taps>>5)<<5 != s->num_taps))

    {

        av_log(avctx, AV_LOG_ERROR, ""Invalid number of taps\n"");

        return AVERROR_INVALIDDATA;

    }



    // generate taps

    s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant));

    for (i = 0; i < s->num_taps; i++)

        s->tap_quant[i] = ff_sqrt(i+1);



    s->channels = avctx->channels;

    s->samplerate = avctx->sample_rate;



    s->block_align = 2048LL*s->samplerate/(44100*s->downsampling);

    s->frame_size = s->channels*s->block_align*s->downsampling;



    s->tail_size = s->num_taps*s->channels;

    s->tail = av_calloc(s->tail_size, sizeof(*s->tail));

    if (!s->tail)

        return AVERROR(ENOMEM);



    s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) );

    if (!s->predictor_k)

        return AVERROR(ENOMEM);



    for (i = 0; i < s->channels; i++)

    {

        s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples));

        if (!s->coded_samples[i])

            return AVERROR(ENOMEM);

    }



    s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples));



    s->window_size = ((2*s->tail_size)+s->frame_size);

    s->window = av_calloc(s->window_size, sizeof(*s->window));

    if (!s->window)

        return AVERROR(ENOMEM);



    avctx->extradata = av_mallocz(16);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    init_put_bits(&pb, avctx->extradata, 16*8);



    put_bits(&pb, 2, version); // version

    if (version == 1)

    {

        put_bits(&pb, 2, s->channels);

        put_bits(&pb, 4, code_samplerate(s->samplerate));

    }

    put_bits(&pb, 1, s->lossless);

    if (!s->lossless)

        put_bits(&pb, 3, SAMPLE_SHIFT); // XXX FIXME: sample precision

    put_bits(&pb, 2, s->decorrelation);

    put_bits(&pb, 2, s->downsampling);

    put_bits(&pb, 5, (s->num_taps >> 5)-1); // 32..1024

    put_bits(&pb, 1, 0); // XXX FIXME: no custom tap quant table



    flush_put_bits(&pb);

    avctx->extradata_size = put_bits_count(&pb)/8;



    av_log(avctx, AV_LOG_INFO, ""Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\n"",

        version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling);



    avctx->frame_size = s->block_align*s->downsampling;



    return 0;

}
",866,,LABEL_0,LABEL_1,,-4,"avctx,s,pb,i",,,,0,,0,Greedy,1,0.0009464224179585775,,
61,"static void pflash_write(pflash_t *pfl, hwaddr offset,

                         uint32_t value, int width, int be)

{

    uint8_t *p;

    uint8_t cmd;



    cmd = value;



    DPRINTF(""%s: writing offset "" TARGET_FMT_plx "" value %08x width %d wcycle 0x%x\n"",

            __func__, offset, value, width, pfl->wcycle);



    if (!pfl->wcycle) {

        /* Set the device in I/O access mode */

        memory_region_rom_device_set_readable(&pfl->mem, false);

    }



    switch (pfl->wcycle) {

    case 0:

        /* read mode */

        switch (cmd) {

        case 0x00: /* ??? */

            goto reset_flash;

        case 0x10: /* Single Byte Program */

        case 0x40: /* Single Byte Program */

            DPRINTF(""%s: Single Byte Program\n"", __func__);

            break;

        case 0x20: /* Block erase */

            p = pfl->storage;

            offset &= ~(pfl->sector_len - 1);



            DPRINTF(""%s: block erase at "" TARGET_FMT_plx "" bytes %x\n"",

                    __func__, offset, (unsigned)pfl->sector_len);



            if (!pfl->ro) {

                memset(p + offset, 0xff, pfl->sector_len);

                pflash_update(pfl, offset, pfl->sector_len);

            } else {

                pfl->status |= 0x20; /* Block erase error */

            }

            pfl->status |= 0x80; /* Ready! */

            break;

        case 0x50: /* Clear status bits */

            DPRINTF(""%s: Clear status bits\n"", __func__);

            pfl->status = 0x0;

            goto reset_flash;

        case 0x60: /* Block (un)lock */

            DPRINTF(""%s: Block unlock\n"", __func__);

            break;

        case 0x70: /* Status Register */

            DPRINTF(""%s: Read status register\n"", __func__);

            pfl->cmd = cmd;

            return;

        case 0x90: /* Read Device ID */

            DPRINTF(""%s: Read Device information\n"", __func__);

            pfl->cmd = cmd;

            return;

        case 0x98: /* CFI query */

            DPRINTF(""%s: CFI query\n"", __func__);

            break;

        case 0xe8: /* Write to buffer */

            DPRINTF(""%s: Write to buffer\n"", __func__);

            pfl->status |= 0x80; /* Ready! */

            break;

        case 0xf0: /* Probe for AMD flash */

            DPRINTF(""%s: Probe for AMD flash\n"", __func__);

            goto reset_flash;

        case 0xff: /* Read array mode */

            DPRINTF(""%s: Read array mode\n"", __func__);

            goto reset_flash;

        default:

            goto error_flash;

        }

        pfl->wcycle++;

        pfl->cmd = cmd;

        break;

    case 1:

        switch (pfl->cmd) {

        case 0x10: /* Single Byte Program */

        case 0x40: /* Single Byte Program */

            DPRINTF(""%s: Single Byte Program\n"", __func__);

            if (!pfl->ro) {

                pflash_data_write(pfl, offset, value, width, be);

                pflash_update(pfl, offset, width);

            } else {

                pfl->status |= 0x10; /* Programming error */

            }

            pfl->status |= 0x80; /* Ready! */

            pfl->wcycle = 0;

        break;

        case 0x20: /* Block erase */

        case 0x28:

            if (cmd == 0xd0) { /* confirm */

                pfl->wcycle = 0;

                pfl->status |= 0x80;

            } else if (cmd == 0xff) { /* read array mode */

                goto reset_flash;

            } else

                goto error_flash;



            break;

        case 0xe8:

            DPRINTF(""%s: block write of %x bytes\n"", __func__, value);

            pfl->counter = value;

            pfl->wcycle++;

            break;

        case 0x60:

            if (cmd == 0xd0) {

                pfl->wcycle = 0;

                pfl->status |= 0x80;

            } else if (cmd == 0x01) {

                pfl->wcycle = 0;

                pfl->status |= 0x80;

            } else if (cmd == 0xff) {

                goto reset_flash;

            } else {

                DPRINTF(""%s: Unknown (un)locking command\n"", __func__);

                goto reset_flash;

            }

            break;

        case 0x98:

            if (cmd == 0xff) {

                goto reset_flash;

            } else {

                DPRINTF(""%s: leaving query mode\n"", __func__);

            }

            break;

        default:

            goto error_flash;

        }

        break;

    case 2:

        switch (pfl->cmd) {

        case 0xe8: /* Block write */

            if (!pfl->ro) {

                pflash_data_write(pfl, offset, value, width, be);

            } else {

                pfl->status |= 0x10; /* Programming error */

            }



            pfl->status |= 0x80;



            if (!pfl->counter) {

                hwaddr mask = pfl->writeblock_size - 1;

                mask = ~mask;



                DPRINTF(""%s: block write finished\n"", __func__);

                pfl->wcycle++;

                if (!pfl->ro) {

                    /* Flush the entire write buffer onto backing storage.  */

                    pflash_update(pfl, offset & mask, pfl->writeblock_size);

                } else {

                    pfl->status |= 0x10; /* Programming error */

                }

            }



            pfl->counter--;

            break;

        default:

            goto error_flash;

        }

        break;

    case 3: /* Confirm mode */

        switch (pfl->cmd) {

        case 0xe8: /* Block write */

            if (cmd == 0xd0) {

                pfl->wcycle = 0;

                pfl->status |= 0x80;

            } else {

                DPRINTF(""%s: unknown command for \""write block\""\n"", __func__);

                PFLASH_BUG(""Write block confirm"");

                goto reset_flash;

            }

            break;

        default:

            goto error_flash;

        }

        break;

    default:

        /* Should never happen */

        DPRINTF(""%s: invalid write state\n"",  __func__);

        goto reset_flash;

    }

    return;



 error_flash:

    qemu_log_mask(LOG_UNIMP, ""%s: Unimplemented flash cmd sequence ""

                  ""(offset "" TARGET_FMT_plx "", wcycle 0x%x cmd 0x%x value 0x%x)""

                  ""\n"", __func__, offset, pfl->wcycle, pfl->cmd, value);



 reset_flash:

    memory_region_rom_device_set_readable(&pfl->mem, true);



    pfl->bypass = 0;

    pfl->wcycle = 0;

    pfl->cmd = 0;

}
",1241,"static void pflash_write(pflash_t *tpsl, hwaddr adjust,

                         uint32_t val, int width, int be)

{

    uint8_t *pc;

    uint8_t header;



    header = val;



    DPRINTF(""%s: writing offset "" TARGET_FMT_plx "" val %08x width %d rwstage 0x%x
"",

            __func__, adjust, val, width, tpsl->rwstage);



    if (!pfl->rwstage) {

        /* Set the device in I/O access mode */

        memory_region_rom_device_set_readable(&tpsl->mem, false);

    }



    switch (tpsl->rwstage) {

    case 0:

        /* read mode */

        switch (header) {

        case 0x00: /* ??? */

            goto reset_flash;

        case 0x10: /* Single Byte Program */

        case 0x40: /* Single Byte Program */

            DPRINTF(""%s: Single Byte Program
"", __func__);

            break;

        case 0x20: /* Block erase */

            pc = tpsl->storage;

            adjust &= ~(tpsl->sector_len - 1);



            DPRINTF(""%s: block erase at "" TARGET_FMT_plx "" bytes %x
"",

                    __func__, adjust, (unsigned)tpsl->sector_len);



            if (!pfl->ro) {

                memset(pc + adjust, 0xff, tpsl->sector_len);

                pflash_update(tpsl, adjust, tpsl->sector_len);

            } else {

                tpsl->status |= 0x20; /* Block erase error */

            }

            tpsl->status |= 0x80; /* Ready! */

            break;

        case 0x50: /* Clear status bits */

            DPRINTF(""%s: Clear status bits
"", __func__);

            tpsl->status = 0x0;

            goto reset_flash;

        case 0x60: /* Block (un)lock */

            DPRINTF(""%s: Block unlock
"", __func__);

            break;

        case 0x70: /* Status Register */

            DPRINTF(""%s: Read status register
"", __func__);

            tpsl->header = header;

            return;

        case 0x90: /* Read Device ID */

            DPRINTF(""%s: Read Device information
"", __func__);

            tpsl->header = header;

            return;

        case 0x98: /* CFI query */

            DPRINTF(""%s: CFI query
"", __func__);

            break;

        case 0xe8: /* Write to buffer */

            DPRINTF(""%s: Write to buffer
"", __func__);

            tpsl->status |= 0x80; /* Ready! */

            break;

        case 0xf0: /* Probe for AMD flash */

            DPRINTF(""%s: Probe for AMD flash
"", __func__);

            goto reset_flash;

        case 0xff: /* Read array mode */

            DPRINTF(""%s: Read array mode
"", __func__);

            goto reset_flash;

        default:

            goto error_flash;

        }

        tpsl->rwstage++;

        tpsl->header = header;

        break;

    case 1:

        switch (tpsl->header) {

        case 0x10: /* Single Byte Program */

        case 0x40: /* Single Byte Program */

            DPRINTF(""%s: Single Byte Program
"", __func__);

            if (!pfl->ro) {

                pflash_data_write(tpsl, adjust, val, width, be);

                pflash_update(tpsl, adjust, width);

            } else {

                tpsl->status |= 0x10; /* Programming error */

            }

            tpsl->status |= 0x80; /* Ready! */

            tpsl->rwstage = 0;

        break;

        case 0x20: /* Block erase */

        case 0x28:

            if (header == 0xd0) { /* confirm */

                tpsl->rwstage = 0;

                tpsl->status |= 0x80;

            } else if (header == 0xff) { /* read array mode */

                goto reset_flash;

            } else

                goto error_flash;



            break;

        case 0xe8:

            DPRINTF(""%s: block write of %x bytes
"", __func__, val);

            tpsl->counter = val;

            tpsl->rwstage++;

            break;

        case 0x60:

            if (header == 0xd0) {

                tpsl->rwstage = 0;

                tpsl->status |= 0x80;

            } else if (header == 0x01) {

                tpsl->rwstage = 0;

                tpsl->status |= 0x80;

            } else if (header == 0xff) {

                goto reset_flash;

            } else {

                DPRINTF(""%s: Unknown (un)locking command
"", __func__);

                goto reset_flash;

            }

            break;

        case 0x98:

            if (header == 0xff) {

                goto reset_flash;

            } else {

                DPRINTF(""%s: leaving query mode
"", __func__);

            }

            break;

        default:

            goto error_flash;

        }

        break;

    case 2:

        switch (tpsl->header) {

        case 0xe8: /* Block write */

            if (!pfl->ro) {

                pflash_data_write(tpsl, adjust, val, width, be);

            } else {

                tpsl->status |= 0x10; /* Programming error */

            }



            tpsl->status |= 0x80;



            if (!pfl->counter) {

                hwaddr mask = tpsl->writeblock_size - 1;

                mask = ~mask;



                DPRINTF(""%s: block write finished
"", __func__);

                tpsl->rwstage++;

                if (!pfl->ro) {

                    /* Flush the entire write buffer onto backing storage.  */

                    pflash_update(tpsl, adjust & mask, tpsl->writeblock_size);

                } else {

                    tpsl->status |= 0x10; /* Programming error */

                }

            }



            tpsl->counter--;

            break;

        default:

            goto error_flash;

        }

        break;

    case 3: /* Confirm mode */

        switch (tpsl->header) {

        case 0xe8: /* Block write */

            if (header == 0xd0) {

                tpsl->rwstage = 0;

                tpsl->status |= 0x80;

            } else {

                DPRINTF(""%s: unknown command for \""write block\""
"", __func__);

                PFLASH_BUG(""Write block confirm"");

                goto reset_flash;

            }

            break;

        default:

            goto error_flash;

        }

        break;

    default:

        /* Should never happen */

        DPRINTF(""%s: invalid write state
"",  __func__);

        goto reset_flash;

    }

    return;



 error_flash:

    qemu_log_mask(LOG_UNIMP, ""%s: Unimplemented flash cmd sequence ""

                  ""(offset "" TARGET_FMT_plx "", wcycle 0x%x cmd 0x%x value 0x%x)""

                  ""
"", __func__, adjust, tpsl->rwstage, tpsl->header, val);



 reset_flash:

    memory_region_rom_device_set_readable(&tpsl->mem, true);



    tpsl->bypass = 0;

    tpsl->rwstage = 0;

    tpsl->header = 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"pfl,offset,value,be,p,cmd,wcycle","pfl:-4.0546042919158936,offset:-1.7417651414871216,value:-1.3513992428779602,be:-0.3867568373680115,p:-0.5880782604217529,cmd:-2.4959003925323486,wcycle:-1.1331193447113037,",6,114,0,"be:be,p:pc,wcycle:rwstage,value:val,offset:adjust,cmd:header,pfl:tpsl,",0,Greedy,536,0.2875319441159566,replace,[]
62,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
",199,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int dride){

    int y;

    DWTELEM *p05= buffer + mirror(-2-1, height-1)*dride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*dride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*dride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*dride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(p05 <= b2) vertical_decompose53iL0(p05, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        p05=b2;

        b1=b3;

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"buffer,height,stride,y,b0,b1,b2,b3","buffer:-0.0005169510841369629,height:-0.00034886598587036133,stride:-0.00032722949981689453,y:-0.0004750490188598633,b0:-0.0003057718276977539,b1:-0.0004951953887939453,b2:-0.00038623809814453125,b3:-0.0003895759582519531,",2,9,0,"b0:p05,stride:dride,",0,Greedy,135,0.048838384946187335,replace,[]
63,"static int qemu_signalfd_compat(const sigset_t *mask)

{

    pthread_attr_t attr;

    pthread_t tid;

    struct sigfd_compat_info *info;

    int fds[2];



    info = malloc(sizeof(*info));

    if (info == NULL) {

        errno = ENOMEM;

        return -1;

    }



    if (pipe(fds) == -1) {

        free(info);

        return -1;

    }



    memcpy(&info->mask, mask, sizeof(*mask));

    info->fd = fds[1];



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);



    pthread_create(&tid, &attr, sigwait_compat, info);



    pthread_attr_destroy(&attr);



    return fds[0];

}
",143,"static int qemu_signalfd_compat(const sigset_t *mask)

{

    pthread_attr_t attr;

    pthread_t tid;

    struct sigfd_compat_info *fo;

    int fds[2];



    fo = malloc(sizeof(*fo));

    if (fo == NULL) {

        errno = ENOMEM;

        return -1;

    }



    if (pipe(fds) == -1) {

        free(fo);

        return -1;

    }



    memcpy(&fo->mask, mask, sizeof(*mask));

    fo->fd = fds[1];



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);



    pthread_create(&tid, &attr, sigwait_compat, fo);



    pthread_attr_destroy(&attr);



    return fds[0];

}
",LABEL_1,LABEL_1,LABEL_0,1,"mask,attr,tid,info,fds","mask:0.0001900196075439453,attr:0.0002950429916381836,tid:8.83340835571289e-05,info:0.00038236379623413086,fds:6.288290023803711e-05,",1,8,0,"info:fo,",0,Greedy,93,0.03335659503936768,replace,[]
64,"static void do_quit(int argc, const char **argv)

{

    exit(0);

}
",19,,LABEL_0,LABEL_1,,-4,"argc,argv",,,,0,,0,Greedy,1,0.00042904218037923176,,
65,"void qemu_spice_display_init(DisplayState *ds)

{

    assert(sdpy.ds == NULL);

    qemu_spice_display_init_common(&sdpy, ds);

    register_displaychangelistener(ds, &display_listener);



    sdpy.qxl.base.sif = &dpy_interface.base;

    qemu_spice_add_interface(&sdpy.qxl.base);

    assert(sdpy.worker);



    qemu_spice_create_host_memslot(&sdpy);

    qemu_spice_create_host_primary(&sdpy);

}
",78,,LABEL_1,LABEL_0,,-4,ds,,,,0,,0,Greedy,1,0.00046480496724446614,,
66,"static int flv_write_trailer(AVFormatContext *s)

{

    int64_t file_size;



    AVIOContext *pb = s->pb;

    FLVContext *flv = s->priv_data;

    int i;



    /* Add EOS tag */

    for (i = 0; i < s->nb_streams; i++) {

        AVCodecContext *enc = s->streams[i]->codec;

        FLVStreamContext *sc = s->streams[i]->priv_data;

        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&

            enc->codec_id == AV_CODEC_ID_H264)

            put_avc_eos_tag(pb, sc->last_ts);

    }



    file_size = avio_tell(pb);



    /* update information */

    avio_seek(pb, flv->duration_offset, SEEK_SET);

    put_amf_double(pb, flv->duration / (double)1000);

    avio_seek(pb, flv->filesize_offset, SEEK_SET);

    put_amf_double(pb, file_size);



    avio_seek(pb, file_size, SEEK_SET);

    return 0;

}
",189,,LABEL_1,LABEL_0,,-4,"s,file_size,pb,flv,i,enc,sc",,,,0,,0,Greedy,1,0.0005345940589904785,,
67,"int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int rw,

                              int is_user, int is_softmmu)

{

    uint32_t physical;

    int prot;

    int exception = 0, error_code = 0;

    int access_type;

    int ret = 0;



//    printf(""%s 0\n"", __func__);

    access_type = env->access_type;

    if (env->user_mode_only) {

        /* user mode only emulation */

        ret = -2;

        goto do_fault;

    }

    /* NASTY BUG workaround */

    if (access_type == ACCESS_CODE && rw) {

	printf(""%s: ERROR WRITE CODE ACCESS\n"", __func__);

	access_type = ACCESS_INT;

    }

    ret = get_physical_address(env, &physical, &prot,

                               address, rw, access_type);

    if (ret == 0) {

	ret = tlb_set_page(env, address & ~0xFFF, physical, prot,

			   is_user, is_softmmu);

    } else if (ret < 0) {

    do_fault:

#if defined (DEBUG_MMU)

	if (loglevel > 0)

	    cpu_ppc_dump_state(env, logfile, 0);

#endif

        if (access_type == ACCESS_CODE) {

            exception = EXCP_ISI;

            switch (ret) {

            case -1:

                /* No matches in page tables */

                error_code = EXCP_ISI_TRANSLATE;

                break;

            case -2:

                /* Access rights violation */

                error_code = EXCP_ISI_PROT;

                break;

            case -3:

		/* No execute protection violation */

                error_code = EXCP_ISI_NOEXEC;

                break;

            case -4:

                /* Direct store exception */

                /* No code fetch is allowed in direct-store areas */

                error_code = EXCP_ISI_DIRECT;

                break;

            }

        } else {

            exception = EXCP_DSI;

            switch (ret) {

            case -1:

                /* No matches in page tables */

                error_code = EXCP_DSI_TRANSLATE;

                break;

            case -2:

                /* Access rights violation */

                error_code = EXCP_DSI_PROT;

                break;

            case -4:

                /* Direct store exception */

                switch (access_type) {

                case ACCESS_FLOAT:

                    /* Floating point load/store */

                    exception = EXCP_ALIGN;

                    error_code = EXCP_ALIGN_FP;

                    break;

                case ACCESS_RES:

                    /* lwarx, ldarx or srwcx. */

                    exception = EXCP_DSI;

                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT;

                    break;

                case ACCESS_EXT:

                    /* eciwx or ecowx */

                    exception = EXCP_DSI;

                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT |

			EXCP_DSI_ECXW;

                    break;

                default:

		    printf(""DSI: invalid exception (%d)\n"", ret);

                    exception = EXCP_PROGRAM;

                    error_code = EXCP_INVAL | EXCP_INVAL_INVAL;

                    break;

                }

            }

            if (rw)

                error_code |= EXCP_DSI_STORE;

	    /* Store fault address */

	    env->spr[DAR] = address;

        }

#if 0

        printf(""%s: set exception to %d %02x\n"",

               __func__, exception, error_code);

#endif

        env->exception_index = exception;

        env->error_code = error_code;

        ret = 1;

    }



    return ret;

}
",538,"int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int wh,

                              int iswebuser, int is_hardmmus)

{

    uint32_t physical;

    int prot;

    int exception = 0, error_code = 0;

    int access_type;

    int ret = 0;



//    printf(""%s 0
"", __func__);

    access_type = env->access_type;

    if (env->user_mode_only) {

        /* user mode only emulation */

        ret = -2;

        goto do_fault;

    }

    /* NASTY BUG workaround */

    if (access_type == ACCESS_CODE && wh) {

	printf(""%s: ERROR WRITE CODE ACCESS
"", __func__);

	access_type = ACCESS_INT;

    }

    ret = get_physical_address(env, &physical, &prot,

                               address, wh, access_type);

    if (ret == 0) {

	ret = tlb_set_page(env, address & ~0xFFF, physical, prot,

			   iswebuser, is_hardmmus);

    } else if (ret < 0) {

    do_fault:

#if defined (DEBUG_MMU)

	if (loglevel > 0)

	    cpu_ppc_dump_state(env, logfile, 0);

#endif

        if (access_type == ACCESS_CODE) {

            exception = EXCP_ISI;

            switch (ret) {

            case -1:

                /* No matches in page tables */

                error_code = EXCP_ISI_TRANSLATE;

                break;

            case -2:

                /* Access rights violation */

                error_code = EXCP_ISI_PROT;

                break;

            case -3:

		/* No execute protection violation */

                error_code = EXCP_ISI_NOEXEC;

                break;

            case -4:

                /* Direct store exception */

                /* No code fetch is allowed in direct-store areas */

                error_code = EXCP_ISI_DIRECT;

                break;

            }

        } else {

            exception = EXCP_DSI;

            switch (ret) {

            case -1:

                /* No matches in page tables */

                error_code = EXCP_DSI_TRANSLATE;

                break;

            case -2:

                /* Access rights violation */

                error_code = EXCP_DSI_PROT;

                break;

            case -4:

                /* Direct store exception */

                switch (access_type) {

                case ACCESS_FLOAT:

                    /* Floating point load/store */

                    exception = EXCP_ALIGN;

                    error_code = EXCP_ALIGN_FP;

                    break;

                case ACCESS_RES:

                    /* lwarx, ldarx or srwcx. */

                    exception = EXCP_DSI;

                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT;

                    break;

                case ACCESS_EXT:

                    /* eciwx or ecowx */

                    exception = EXCP_DSI;

                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT |

			EXCP_DSI_ECXW;

                    break;

                default:

		    printf(""DSI: invalid exception (%d)
"", ret);

                    exception = EXCP_PROGRAM;

                    error_code = EXCP_INVAL | EXCP_INVAL_INVAL;

                    break;

                }

            }

            if (wh)

                error_code |= EXCP_DSI_STORE;

	    /* Store fault address */

	    env->spr[DAR] = address;

        }

#if 0

        printf(""%s: set exception to %d %02x
"",

               __func__, exception, error_code);

#endif

        env->exception_index = exception;

        env->error_code = error_code;

        ret = 1;

    }



    return ret;

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,address,rw,is_user,is_softmmu,physical,prot,access_type","env:-0.008828163146972656,address:-0.00437241792678833,rw:-0.0012763738632202148,is_user:6.592273712158203e-05,is_softmmu:0.00069427490234375,physical:-0.002322375774383545,prot:-0.002567291259765625,access_type:-0.0018056631088256836,",3,8,0,"is_softmmu:is_hardmmus,is_user:iswebuser,rw:wh,",0,Greedy,125,0.053613018989562986,replace,[]
68,"static void do_interrupt_protected(CPUX86State *env, int intno, int is_int,

                                   int error_code, unsigned int next_eip,

                                   int is_hw)

{

    SegmentCache *dt;

    target_ulong ptr, ssp;

    int type, dpl, selector, ss_dpl, cpl;

    int has_error_code, new_stack, shift;

    uint32_t e1, e2, offset, ss = 0, esp, ss_e1 = 0, ss_e2 = 0;

    uint32_t old_eip, sp_mask;

    int vm86 = env->eflags & VM_MASK;



    has_error_code = 0;

    if (!is_int && !is_hw) {

        has_error_code = exception_has_error_code(intno);

    }

    if (is_int) {

        old_eip = next_eip;

    } else {

        old_eip = env->eip;

    }



    dt = &env->idt;

    if (intno * 8 + 7 > dt->limit) {

        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);

    }

    ptr = dt->base + intno * 8;

    e1 = cpu_ldl_kernel(env, ptr);

    e2 = cpu_ldl_kernel(env, ptr + 4);

    /* check gate type */

    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;

    switch (type) {

    case 5: /* task gate */

        /* must do that check here to return the correct error code */

        if (!(e2 & DESC_P_MASK)) {

            raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);

        }

        switch_tss(env, intno * 8, e1, e2, SWITCH_TSS_CALL, old_eip);

        if (has_error_code) {

            int type;

            uint32_t mask;



            /* push the error code */

            type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;

            shift = type >> 3;

            if (env->segs[R_SS].flags & DESC_B_MASK) {

                mask = 0xffffffff;

            } else {

                mask = 0xffff;

            }

            esp = (env->regs[R_ESP] - (2 << shift)) & mask;

            ssp = env->segs[R_SS].base + esp;

            if (shift) {

                cpu_stl_kernel(env, ssp, error_code);

            } else {

                cpu_stw_kernel(env, ssp, error_code);

            }

            SET_ESP(esp, mask);

        }

        return;

    case 6: /* 286 interrupt gate */

    case 7: /* 286 trap gate */

    case 14: /* 386 interrupt gate */

    case 15: /* 386 trap gate */

        break;

    default:

        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);

        break;

    }

    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    cpl = env->hflags & HF_CPL_MASK;

    /* check privilege if software int */

    if (is_int && dpl < cpl) {

        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);

    }

    /* check valid bit */

    if (!(e2 & DESC_P_MASK)) {

        raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);

    }

    selector = e1 >> 16;

    offset = (e2 & 0xffff0000) | (e1 & 0x0000ffff);

    if ((selector & 0xfffc) == 0) {

        raise_exception_err(env, EXCP0D_GPF, 0);

    }

    if (load_segment(env, &e1, &e2, selector) != 0) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    if (dpl > cpl) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    if (!(e2 & DESC_P_MASK)) {

        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);

    }

    if (!(e2 & DESC_C_MASK) && dpl < cpl) {

        /* to inner privilege */

        get_ss_esp_from_tss(env, &ss, &esp, dpl, 0);

        if ((ss & 0xfffc) == 0) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        if ((ss & 3) != dpl) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        if (load_segment(env, &ss_e1, &ss_e2, ss) != 0) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        ss_dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;

        if (ss_dpl != dpl) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        if (!(ss_e2 & DESC_S_MASK) ||

            (ss_e2 & DESC_CS_MASK) ||

            !(ss_e2 & DESC_W_MASK)) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        if (!(ss_e2 & DESC_P_MASK)) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        new_stack = 1;

        sp_mask = get_sp_mask(ss_e2);

        ssp = get_seg_base(ss_e1, ss_e2);

    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {

        /* to same privilege */

        if (vm86) {

            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

        }

        new_stack = 0;

        sp_mask = get_sp_mask(env->segs[R_SS].flags);

        ssp = env->segs[R_SS].base;

        esp = env->regs[R_ESP];

        dpl = cpl;

    } else {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

        new_stack = 0; /* avoid warning */

        sp_mask = 0; /* avoid warning */

        ssp = 0; /* avoid warning */

        esp = 0; /* avoid warning */

    }



    shift = type >> 3;



#if 0

    /* XXX: check that enough room is available */

    push_size = 6 + (new_stack << 2) + (has_error_code << 1);

    if (vm86) {

        push_size += 8;

    }

    push_size <<= shift;

#endif

    if (shift == 1) {

        if (new_stack) {

            if (vm86) {

                PUSHL(ssp, esp, sp_mask, env->segs[R_GS].selector);

                PUSHL(ssp, esp, sp_mask, env->segs[R_FS].selector);

                PUSHL(ssp, esp, sp_mask, env->segs[R_DS].selector);

                PUSHL(ssp, esp, sp_mask, env->segs[R_ES].selector);

            }

            PUSHL(ssp, esp, sp_mask, env->segs[R_SS].selector);

            PUSHL(ssp, esp, sp_mask, env->regs[R_ESP]);

        }

        PUSHL(ssp, esp, sp_mask, cpu_compute_eflags(env));

        PUSHL(ssp, esp, sp_mask, env->segs[R_CS].selector);

        PUSHL(ssp, esp, sp_mask, old_eip);

        if (has_error_code) {

            PUSHL(ssp, esp, sp_mask, error_code);

        }

    } else {

        if (new_stack) {

            if (vm86) {

                PUSHW(ssp, esp, sp_mask, env->segs[R_GS].selector);

                PUSHW(ssp, esp, sp_mask, env->segs[R_FS].selector);

                PUSHW(ssp, esp, sp_mask, env->segs[R_DS].selector);

                PUSHW(ssp, esp, sp_mask, env->segs[R_ES].selector);

            }

            PUSHW(ssp, esp, sp_mask, env->segs[R_SS].selector);

            PUSHW(ssp, esp, sp_mask, env->regs[R_ESP]);

        }

        PUSHW(ssp, esp, sp_mask, cpu_compute_eflags(env));

        PUSHW(ssp, esp, sp_mask, env->segs[R_CS].selector);

        PUSHW(ssp, esp, sp_mask, old_eip);

        if (has_error_code) {

            PUSHW(ssp, esp, sp_mask, error_code);

        }

    }



    /* interrupt gate clear IF mask */

    if ((type & 1) == 0) {

        env->eflags &= ~IF_MASK;

    }

    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);



    if (new_stack) {

        if (vm86) {

            cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0, 0);

        }

        ss = (ss & ~3) | dpl;

        cpu_x86_load_seg_cache(env, R_SS, ss,

                               ssp, get_seg_limit(ss_e1, ss_e2), ss_e2);

    }

    SET_ESP(esp, sp_mask);



    selector = (selector & ~3) | dpl;

    cpu_x86_load_seg_cache(env, R_CS, selector,

                   get_seg_base(e1, e2),

                   get_seg_limit(e1, e2),

                   e2);

    env->eip = offset;

}
",1715,"static void do_interrupt_protected(CPUX86State *net, int intno, int as_nt,

                                   int errorwavemode, unsigned int next_eip,

                                   int is_iw)

{

    SegmentCache *dt;

    target_ulong alloc, ssp;

    int val, dpl, elector, ss_dpl, cpl;

    int has_error64call, new_stack, pos;

    uint32_t e1, e2, index, ss = 0, sw, ss_e1 = 0, ss_e2 = 0;

    uint32_t old_eip, ss_delay;

    int vm86 = net->eflags & VM_MASK;



    has_error64call = 0;

    if (!is_int && !is_hw) {

        has_error64call = exception_has_error_code(intno);

    }

    if (as_nt) {

        old_eip = next_eip;

    } else {

        old_eip = net->eip;

    }



    dt = &net->idt;

    if (intno * 8 + 7 > dt->limit) {

        raise_exception_err(net, EXCP0D_GPF, intno * 8 + 2);

    }

    alloc = dt->base + intno * 8;

    e1 = cpu_ldl_kernel(net, alloc);

    e2 = cpu_ldl_kernel(net, alloc + 4);

    /* check gate val */

    val = (e2 >> DESC_TYPE_SHIFT) & 0x1f;

    switch (val) {

    case 5: /* task gate */

        /* must do that check here to return the correct error code */

        if (!(e2 & DESC_P_MASK)) {

            raise_exception_err(net, EXCP0B_NOSEG, intno * 8 + 2);

        }

        switch_tss(net, intno * 8, e1, e2, SWITCH_TSS_CALL, old_eip);

        if (has_error64call) {

            int val;

            uint32_t arr;



            /* push the error code */

            val = (net->tr.flags >> DESC_TYPE_SHIFT) & 0xf;

            pos = val >> 3;

            if (net->segs[R_SS].flags & DESC_B_MASK) {

                arr = 0xffffffff;

            } else {

                arr = 0xffff;

            }

            sw = (net->regs[R_ESP] - (2 << pos)) & arr;

            ssp = net->segs[R_SS].base + sw;

            if (pos) {

                cpu_stl_kernel(net, ssp, errorwavemode);

            } else {

                cpu_stw_kernel(net, ssp, errorwavemode);

            }

            SET_ESP(sw, arr);

        }

        return;

    case 6: /* 286 interrupt gate */

    case 7: /* 286 trap gate */

    case 14: /* 386 interrupt gate */

    case 15: /* 386 trap gate */

        break;

    default:

        raise_exception_err(net, EXCP0D_GPF, intno * 8 + 2);

        break;

    }

    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    cpl = net->hflags & HF_CPL_MASK;

    /* check privilege if software int */

    if (as_nt && dpl < cpl) {

        raise_exception_err(net, EXCP0D_GPF, intno * 8 + 2);

    }

    /* check valid bit */

    if (!(e2 & DESC_P_MASK)) {

        raise_exception_err(net, EXCP0B_NOSEG, intno * 8 + 2);

    }

    elector = e1 >> 16;

    index = (e2 & 0xffff0000) | (e1 & 0x0000ffff);

    if ((elector & 0xfffc) == 0) {

        raise_exception_err(net, EXCP0D_GPF, 0);

    }

    if (load_segment(net, &e1, &e2, elector) != 0) {

        raise_exception_err(net, EXCP0D_GPF, elector & 0xfffc);

    }

    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {

        raise_exception_err(net, EXCP0D_GPF, elector & 0xfffc);

    }

    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    if (dpl > cpl) {

        raise_exception_err(net, EXCP0D_GPF, elector & 0xfffc);

    }

    if (!(e2 & DESC_P_MASK)) {

        raise_exception_err(net, EXCP0B_NOSEG, elector & 0xfffc);

    }

    if (!(e2 & DESC_C_MASK) && dpl < cpl) {

        /* to inner privilege */

        get_ss_esp_from_tss(net, &ss, &sw, dpl, 0);

        if ((ss & 0xfffc) == 0) {

            raise_exception_err(net, EXCP0A_TSS, ss & 0xfffc);

        }

        if ((ss & 3) != dpl) {

            raise_exception_err(net, EXCP0A_TSS, ss & 0xfffc);

        }

        if (load_segment(net, &ss_e1, &ss_e2, ss) != 0) {

            raise_exception_err(net, EXCP0A_TSS, ss & 0xfffc);

        }

        ss_dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;

        if (ss_dpl != dpl) {

            raise_exception_err(net, EXCP0A_TSS, ss & 0xfffc);

        }

        if (!(ss_e2 & DESC_S_MASK) ||

            (ss_e2 & DESC_CS_MASK) ||

            !(ss_e2 & DESC_W_MASK)) {

            raise_exception_err(net, EXCP0A_TSS, ss & 0xfffc);

        }

        if (!(ss_e2 & DESC_P_MASK)) {

            raise_exception_err(net, EXCP0A_TSS, ss & 0xfffc);

        }

        new_stack = 1;

        ss_delay = get_sp_mask(ss_e2);

        ssp = get_seg_base(ss_e1, ss_e2);

    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {

        /* to same privilege */

        if (vm86) {

            raise_exception_err(net, EXCP0D_GPF, elector & 0xfffc);

        }

        new_stack = 0;

        ss_delay = get_sp_mask(net->segs[R_SS].flags);

        ssp = net->segs[R_SS].base;

        sw = net->regs[R_ESP];

        dpl = cpl;

    } else {

        raise_exception_err(net, EXCP0D_GPF, elector & 0xfffc);

        new_stack = 0; /* avoid warning */

        ss_delay = 0; /* avoid warning */

        ssp = 0; /* avoid warning */

        sw = 0; /* avoid warning */

    }



    pos = val >> 3;



#if 0

    /* XXX: check that enough room is available */

    push_size = 6 + (new_stack << 2) + (has_error64call << 1);

    if (vm86) {

        push_size += 8;

    }

    push_size <<= pos;

#endif

    if (pos == 1) {

        if (new_stack) {

            if (vm86) {

                PUSHL(ssp, sw, ss_delay, net->segs[R_GS].elector);

                PUSHL(ssp, sw, ss_delay, net->segs[R_FS].elector);

                PUSHL(ssp, sw, ss_delay, net->segs[R_DS].elector);

                PUSHL(ssp, sw, ss_delay, net->segs[R_ES].elector);

            }

            PUSHL(ssp, sw, ss_delay, net->segs[R_SS].elector);

            PUSHL(ssp, sw, ss_delay, net->regs[R_ESP]);

        }

        PUSHL(ssp, sw, ss_delay, cpu_compute_eflags(net));

        PUSHL(ssp, sw, ss_delay, net->segs[R_CS].elector);

        PUSHL(ssp, sw, ss_delay, old_eip);

        if (has_error64call) {

            PUSHL(ssp, sw, ss_delay, errorwavemode);

        }

    } else {

        if (new_stack) {

            if (vm86) {

                PUSHW(ssp, sw, ss_delay, net->segs[R_GS].elector);

                PUSHW(ssp, sw, ss_delay, net->segs[R_FS].elector);

                PUSHW(ssp, sw, ss_delay, net->segs[R_DS].elector);

                PUSHW(ssp, sw, ss_delay, net->segs[R_ES].elector);

            }

            PUSHW(ssp, sw, ss_delay, net->segs[R_SS].elector);

            PUSHW(ssp, sw, ss_delay, net->regs[R_ESP]);

        }

        PUSHW(ssp, sw, ss_delay, cpu_compute_eflags(net));

        PUSHW(ssp, sw, ss_delay, net->segs[R_CS].elector);

        PUSHW(ssp, sw, ss_delay, old_eip);

        if (has_error64call) {

            PUSHW(ssp, sw, ss_delay, errorwavemode);

        }

    }



    /* interrupt gate clear IF arr */

    if ((val & 1) == 0) {

        net->eflags &= ~IF_MASK;

    }

    net->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);



    if (new_stack) {

        if (vm86) {

            cpu_x86_load_seg_cache(net, R_ES, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(net, R_DS, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(net, R_FS, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(net, R_GS, 0, 0, 0, 0);

        }

        ss = (ss & ~3) | dpl;

        cpu_x86_load_seg_cache(net, R_SS, ss,

                               ssp, get_seg_limit(ss_e1, ss_e2), ss_e2);

    }

    SET_ESP(sw, ss_delay);



    elector = (elector & ~3) | dpl;

    cpu_x86_load_seg_cache(net, R_CS, elector,

                   get_seg_base(e1, e2),

                   get_seg_limit(e1, e2),

                   e2);

    net->eip = index;

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,intno,is_int,error_code,next_eip,is_hw,dt,ptr,ssp,type,dpl,selector,ss_dpl,cpl,has_error_code,new_stack,shift,e1,e2,offset,esp,old_eip,sp_mask,mask","env:0.42936593294143677,intno:-0.8764758706092834,is_int:-0.0018946528434753418,error_code:-0.0006507039070129395,next_eip:-0.09615963697433472,is_hw:0.004503428936004639,dt:-0.35905271768569946,ptr:0.07549095153808594,ssp:-0.3728037476539612,type:0.12717163562774658,dpl:-0.2795109152793884,selector:0.0042705535888671875,ss_dpl:-0.04114186763763428,cpl:-0.2820982336997986,has_error_code:0.02820765972137451,new_stack:-0.0021026134490966797,shift:0.07131963968276978,e1:-0.5514222979545593,e2:-1.0130399465560913,offset:0.03830772638320923,esp:0.07875931262969971,old_eip:-0.16600853204727173,sp_mask:0.0009520649909973145,mask:0.09378939867019653,",13,186,0,"env:net,type:val,mask:arr,esp:sw,ptr:alloc,shift:pos,offset:index,has_error_code:has_error64call,is_hw:is_iw,selector:elector,sp_mask:ss_delay,error_code:errorwavemode,is_int:as_nt,",0,Greedy,735,0.39423351287841796,replace,[]
69,"static uint8_t eeprom24c0x_read(void)

{

    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",

        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);

    return eeprom.sda;

}
",55,,LABEL_0,LABEL_0,,-3,,,,,0,,0,Greedy,1,0.000449518362681071,,
70,"static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi,

                             int s_bits, int tlb_offset)

{

    TCGReg base = TCG_AREG0;



    /* Should generate something like the following:

     * pre-v7:

     *   shr    tmp, addr_reg, #TARGET_PAGE_BITS                  (1)

     *   add    r2, env, #off & 0xff00

     *   and    r0, tmp, #(CPU_TLB_SIZE - 1)                      (2)

     *   add    r2, r2, r0, lsl #CPU_TLB_ENTRY_BITS               (3)

     *   ldr    r0, [r2, #off & 0xff]!                            (4)

     *   tst    addr_reg, #s_mask

     *   cmpeq  r0, tmp, lsl #TARGET_PAGE_BITS                    (5)

     *

     * v7 (not implemented yet):

     *   ubfx   r2, addr_reg, #TARGET_PAGE_BITS, #CPU_TLB_BITS    (1)

     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask

     *   movw   r0, #off

     *   add    r2, env, r2, lsl #CPU_TLB_ENTRY_BITS              (2)

     *   bic    tmp, addr_reg, tmp

     *   ldr    r0, [r2, r0]!                                     (3)

     *   cmp    r0, tmp                                           (4)

     */

#  if CPU_TLB_BITS > 8

#   error

#  endif

    tcg_out_dat_reg(s, COND_AL, ARITH_MOV, TCG_REG_TMP,

                    0, addrlo, SHIFT_IMM_LSR(TARGET_PAGE_BITS));



    /* We assume that the offset is contained within 16 bits.  */

    assert((tlb_offset & ~0xffff) == 0);

    if (tlb_offset > 0xff) {

        tcg_out_dat_imm(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,

                        (24 << 7) | (tlb_offset >> 8));

        tlb_offset &= 0xff;

        base = TCG_REG_R2;

    }



    tcg_out_dat_imm(s, COND_AL, ARITH_AND,

                    TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1);

    tcg_out_dat_reg(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,

                    TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS));



    /* Load the tlb comparator.  Use ldrd if needed and available,

       but due to how the pointer needs setting up, ldm isn't useful.

       Base arm5 doesn't have ldrd, but armv5te does.  */

    if (use_armv6_instructions && TARGET_LONG_BITS == 64) {

        tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0,

                        TCG_REG_R2, tlb_offset, 1, 1);

    } else {

        tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0,

                         TCG_REG_R2, tlb_offset, 1, 1);

        if (TARGET_LONG_BITS == 64) {

            tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1,

                             TCG_REG_R2, 4, 1, 0);

        }

    }



    /* Check alignment.  */

    if (s_bits) {

        tcg_out_dat_imm(s, COND_AL, ARITH_TST,

                        0, addrlo, (1 << s_bits) - 1);

    }



    tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0,

                    TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS));



    if (TARGET_LONG_BITS == 64) {

        tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0,

                        TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0));

    }

}
",484,,LABEL_1,LABEL_0,,-4,"s,addrlo,addrhi,s_bits,tlb_offset",,,,0,,0,Greedy,1,0.0007193485895792643,,
71,"void net_hub_check_clients(void)

{

    NetHub *hub;

    NetHubPort *port;

    NetClientState *peer;



    QLIST_FOREACH(hub, &hubs, next) {

        int has_nic = 0, has_host_dev = 0;



        QLIST_FOREACH(port, &hub->ports, next) {

            peer = port->nc.peer;

            if (!peer) {

                fprintf(stderr, ""Warning: hub port %s has no peer\n"",

                        port->nc.name);

                continue;

            }



            switch (peer->info->type) {

            case NET_CLIENT_DRIVER_NIC:

                has_nic = 1;

                break;

            case NET_CLIENT_DRIVER_USER:

            case NET_CLIENT_DRIVER_TAP:

            case NET_CLIENT_DRIVER_SOCKET:

            case NET_CLIENT_DRIVER_VDE:

            case NET_CLIENT_DRIVER_VHOST_USER:

                has_host_dev = 1;

                break;

            default:

                break;

            }

        }

        if (has_host_dev && !has_nic) {

            warn_report(""vlan %d with no nics"", hub->id);

        }

        if (has_nic && !has_host_dev) {

            fprintf(stderr,

                    ""Warning: vlan %d is not connected to host network\n"",

                    hub->id);

        }

    }

}
",196,,LABEL_0,LABEL_0,LABEL_0,-1,"hub,port,peer",,3,16,0,,0,GA,445,0.1698235511779785,failed,[]
72,"static int rdma_add_block(RDMAContext *rdma, const char *block_name,

                         void *host_addr,

                         ram_addr_t block_offset, uint64_t length)

{

    RDMALocalBlocks *local = &rdma->local_ram_blocks;

    RDMALocalBlock *block;

    RDMALocalBlock *old = local->block;



    local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));



    if (local->nb_blocks) {

        int x;



        if (rdma->blockmap) {

            for (x = 0; x < local->nb_blocks; x++) {

                g_hash_table_remove(rdma->blockmap,

                                    (void *)(uintptr_t)old[x].offset);

                g_hash_table_insert(rdma->blockmap,

                                    (void *)(uintptr_t)old[x].offset,

                                    &local->block[x]);

            }

        }

        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);

        g_free(old);

    }



    block = &local->block[local->nb_blocks];



    block->block_name = g_strdup(block_name);

    block->local_host_addr = host_addr;

    block->offset = block_offset;

    block->length = length;

    block->index = local->nb_blocks;

    block->src_index = ~0U; /* Filled in by the receipt of the block list */

    block->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;

    block->transit_bitmap = bitmap_new(block->nb_chunks);

    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);

    block->unregister_bitmap = bitmap_new(block->nb_chunks);

    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);

    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));



    block->is_ram_block = local->init ? false : true;



    if (rdma->blockmap) {

        g_hash_table_insert(rdma->blockmap, (void *) block_offset, block);

    }



    trace_rdma_add_block(block_name, local->nb_blocks,

                         (uintptr_t) block->local_host_addr,

                         block->offset, block->length,

                         (uintptr_t) (block->local_host_addr + block->length),

                         BITS_TO_LONGS(block->nb_chunks) *

                             sizeof(unsigned long) * 8,

                         block->nb_chunks);



    local->nb_blocks++;



    return 0;

}
",465,"static int rdma_add_block(RDMAContext *rtmad, const char *block_name,

                         void *host_addr,

                         ram_addr_t  block_prefix, uint64_t length)

{

    RDMALocalBlocks *local = &rtmad->local_ram_blocks;

    RDMALocalBlock *block;

    RDMALocalBlock *old = local->block;



    local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb64works + 1));



    if (local->nb64works) {

        int x;



        if (rtmad->blockmap) {

            for (x = 0; x < local->nb64works; x++) {

                g_hash_table_remove(rtmad->blockmap,

                                    (void *)(uintptr_t)old[x].offset);

                g_hash_table_insert(rtmad->blockmap,

                                    (void *)(uintptr_t)old[x].offset,

                                    &local->block[x]);

            }

        }

        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb64works);

        g_free(old);

    }



    block = &local->block[local->nb64works];



    block->block_name = g_strdup(block_name);

    block->local_host_addr = host_addr;

    block->offset =  block_prefix;

    block->length = length;

    block->index = local->nb64works;

    block->src_index = ~0U; /* Filled in by the receipt of the block list */

    block->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;

    block->transit_bitmap = bitmap_new(block->nb_chunks);

    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);

    block->unregister_bitmap = bitmap_new(block->nb_chunks);

    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);

    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));



    block->is_ram_block = local->init ? false : true;



    if (rtmad->blockmap) {

        g_hash_table_insert(rtmad->blockmap, (void *)  block_prefix, block);

    }



    trace_rdma_add_block(block_name, local->nb64works,

                         (uintptr_t) block->local_host_addr,

                         block->offset, block->length,

                         (uintptr_t) (block->local_host_addr + block->length),

                         BITS_TO_LONGS(block->nb_chunks) *

                             sizeof(unsigned long) * 8,

                         block->nb_chunks);



    local->nb64works++;



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"rdma,block_name,host_addr,block_offset,length,local,block,old,x,nb_blocks","rdma:-1.5735626220703125e-05,block_name:-1.9431114196777344e-05,host_addr:-2.300739288330078e-05,block_offset:-1.6927719116210938e-05,length:-0.00014001131057739258,local:-0.0002631545066833496,block:-0.0007840394973754883,old:-0.0001062154769897461,x:-0.00014519691467285156,nb_blocks:0.0002554655075073242,",3,18,0,"nb_blocks:nb64works,rdma:rtmad,block_offset: block_prefix,",0,Greedy,242,0.09290194511413574,replace,[]
73,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < w; i++)

        dst[i] = src1[i] + src2[i];

}
",137,,LABEL_1,LABEL_0,,-4,"dst,src1,src2,w,i",,,,0,,0,Greedy,1,0.0004915396372477213,,
74,"static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCIAsync *async = (UHCIAsync *) packet;



    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);



    async->done = 1;



    uhci_process_frame(s);

}
",75,"static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCIAsync *assynchronous = (UHCIAsync *) packet;



    DPRINTF(""uhci: assynchronous complete. td 0x%x token 0x%x
"", assynchronous->td, assynchronous->token);



    assynchronous->done = 1;



    uhci_process_frame(s);

}
",LABEL_0,LABEL_0,LABEL_1,1,"packet,opaque,s,async","packet:3.254413604736328e-05,opaque:-6.347894668579102e-05,s:0.0005625486373901367,async:0.0015252232551574707,",1,5,0,"async:assynchronous,",0,Greedy,44,0.0156483252843221,replace,[]
75,"static void gen_mfrom(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

#endif

}
",63,,LABEL_1,LABEL_1,LABEL_1,-1,ctx,,1,6,0,,0,GA,268,0.09493284225463867,failed,[]
76,"static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)

{

    AHCICmdHdr *cmd = ad->cur_cmd;

    uint32_t opts = le32_to_cpu(cmd->opts);

    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;

    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;

    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));

    dma_addr_t real_prdt_len = prdt_len;

    uint8_t *prdt;

    int i;

    int r = 0;

    int sum = 0;

    int off_idx = -1;

    int off_pos = -1;

    int tbl_entry_size;

    IDEBus *bus = &ad->port;

    BusState *qbus = BUS(bus);



    if (!sglist_alloc_hint) {

        DPRINTF(ad->port_no, ""no sg list given by guest: 0x%08x\n"", opts);

        return -1;

    }



    /* map PRDT */

    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,

                                DMA_DIRECTION_TO_DEVICE))){

        DPRINTF(ad->port_no, ""map failed\n"");

        return -1;

    }



    if (prdt_len < real_prdt_len) {

        DPRINTF(ad->port_no, ""mapped less than expected\n"");

        r = -1;

        goto out;

    }



    /* Get entries in the PRDT, init a qemu sglist accordingly */

    if (sglist_alloc_hint > 0) {

        AHCI_SG *tbl = (AHCI_SG *)prdt;

        sum = 0;

        for (i = 0; i < sglist_alloc_hint; i++) {

            /* flags_size is zero-based */

            tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);

            if (offset <= (sum + tbl_entry_size)) {

                off_idx = i;

                off_pos = offset - sum;

                break;

            }

            sum += tbl_entry_size;

        }

        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {

            DPRINTF(ad->port_no, ""%s: Incorrect offset! ""

                            ""off_idx: %d, off_pos: %d\n"",

                            __func__, off_idx, off_pos);

            r = -1;

            goto out;

        }



        qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),

                         ad->hba->as);

        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),

                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);



        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {

            /* flags_size is zero-based */

            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),

                            le32_to_cpu(tbl[i].flags_size) + 1);

        }

    }



out:

    dma_memory_unmap(ad->hba->as, prdt, prdt_len,

                     DMA_DIRECTION_TO_DEVICE, prdt_len);

    return r;

}
",547,"static int ahci_populate_sglist(AHCIDevice *ld, QEMUSGList * sGLIST, int type)

{

    AHCICmdHdr *cod = ld->cur_cmd;

    uint32_t opts = le32_to_cpu(cod->opts);

    uint64_t prdt_addr = le64_to_cpu(cod->tbl_addr) + 0x80;

    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;

    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));

    dma_addr_t real_prdt_len = prdt_len;

    uint8_t *prdt;

    int i;

    int r = 0;

    int sum = 0;

    int off_idx = -1;

    int off_pos = -1;

    int tbl_Entry_size;

    IDEBus *pu = &ld->port;

    BusState *qbus = BUS(pu);



    if (!sglist_alloc_hint) {

        DPRINTF(ld->port_no, ""no sg list given by guest: 0x%08x
"", opts);

        return -1;

    }



    /* map PRDT */

    if (!(prdt = dma_memory_map(ld->hba->as, prdt_addr, &prdt_len,

                                DMA_DIRECTION_TO_DEVICE))){

        DPRINTF(ld->port_no, ""map failed
"");

        return -1;

    }



    if (prdt_len < real_prdt_len) {

        DPRINTF(ld->port_no, ""mapped less than expected
"");

        r = -1;

        goto out;

    }



    /* Get entries in the PRDT, init a qemu  sGLIST accordingly */

    if (sglist_alloc_hint > 0) {

        AHCI_SG *tbl = (AHCI_SG *)prdt;

        sum = 0;

        for (i = 0; i < sglist_alloc_hint; i++) {

            /* flags_size is zero-based */

            tbl_Entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);

            if (type <= (sum + tbl_Entry_size)) {

                off_idx = i;

                off_pos = type - sum;

                break;

            }

            sum += tbl_Entry_size;

        }

        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_Entry_size)) {

            DPRINTF(ld->port_no, ""%s: Incorrect offset! ""

                            ""off_idx: %d, off_pos: %d
"",

                            __func__, off_idx, off_pos);

            r = -1;

            goto out;

        }



        qemu_sglist_init( sGLIST, qbus->parent, (sglist_alloc_hint - off_idx),

                         ld->hba->as);

        qemu_sglist_add( sGLIST, le64_to_cpu(tbl[off_idx].addr + off_pos),

                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);



        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {

            /* flags_size is zero-based */

            qemu_sglist_add( sGLIST, le64_to_cpu(tbl[i].addr),

                            le32_to_cpu(tbl[i].flags_size) + 1);

        }

    }



out:

    dma_memory_unmap(ld->hba->as, prdt, prdt_len,

                     DMA_DIRECTION_TO_DEVICE, prdt_len);

    return r;

}
",LABEL_1,LABEL_1,LABEL_0,1,"ad,sglist,offset,cmd,prdt,i,tbl_entry_size,bus,qbus,tbl","ad:8.52346420288086e-06,sglist:-7.152557373046875e-06,offset:-1.0251998901367188e-05,cmd:-2.384185791015625e-06,prdt:-5.2928924560546875e-05,i:-7.641315460205078e-05,tbl_entry_size:2.1457672119140625e-06,bus:-3.933906555175781e-06,qbus:-2.5093555450439453e-05,tbl:-3.695487976074219e-05,",6,28,0,"ad:ld,tbl_entry_size:tbl_Entry_size,cmd:cod,bus:pu,sglist: sGLIST,offset:type,",0,Greedy,269,0.11361188888549804,replace,[]
77,"uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,

                             uint8_t *addrs, uint8_t *buf)

{

    uint32_t sum = 0;



    sum += net_checksum_add(length, buf);         // payload

    sum += net_checksum_add(8, addrs);            // src + dst address

    sum += proto + length;                        // protocol & length

    return net_checksum_finish(sum);

}
",65,"uint16_t net_checksum_tcpudp(uint16_t seq, uint16_t protco,

                             uint8_t *adr, uint8_t *data)

{

    uint32_t sum = 0;



    sum += net_checksum_add(seq, data);         // payload

    sum += net_checksum_add(8, adr);            // src + dst address

    sum += protco + seq;                        // protocol & seq

    return net_checksum_finish(sum);

}
",LABEL_0,LABEL_0,LABEL_1,1,"length,proto,addrs,buf","length:-1.4841556549072266e-05,proto:3.916025161743164e-05,addrs:0.00014853477478027344,buf:-0.0002803206443786621,",4,10,0,"addrs:adr,proto:protco,length:seq,buf:data,",0,Greedy,132,0.047209127744038897,replace,[]
78,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",33,,LABEL_0,LABEL_0,LABEL_0,-1,"listener,d",,2,5,0,,0,GA,461,0.16117287874221803,failed,[]
79,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;

    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        codec->codec_id == AV_CODEC_ID_H264 &&

        atom.size > 11) {

        avio_skip(pb, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            codec->width = 1440;

        return 0;

    }



    return mov_read_avid(c, pb, atom);

}
",136,,LABEL_0,LABEL_1,,-4,"c,pb,atom,codec",,,,0,,0,Greedy,1,0.0005026698112487793,,
80,"void trace_init_file(const char *file)

{

#ifdef CONFIG_TRACE_SIMPLE

    st_set_trace_file(file);

#elif defined CONFIG_TRACE_LOG

    /* If both the simple and the log backends are enabled, ""-trace file""

     * only applies to the simple backend; use ""-D"" for the log backend.

     */

    if (file) {

        qemu_set_log_filename(file);

    }

#else

    if (file) {

        fprintf(stderr, ""error: -trace file=...: ""

                ""option not supported by the selected tracing backends\n"");

        exit(1);

    }

#endif

}
",85,,LABEL_1,LABEL_0,,-4,file,,,,0,,0,Greedy,1,0.0004799207051595052,,
81,"bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}
",93,,LABEL_1,LABEL_0,,-4,"timer_list,expire_time",,,,0,,0,Greedy,1,0.00046800772349039714,,
82,"static int qcow2_create2(const char *filename, int64_t total_size,
                         const char *backing_file, const char *backing_format,
                         int flags, size_t cluster_size, int prealloc,
                         QEMUOptionParameter *options, int version,
                         Error **errp)
{
    /* Calculate cluster_bits */
    int cluster_bits;
    cluster_bits = ffs(cluster_size) - 1;
    if (cluster_bits < MIN_CLUSTER_BITS || cluster_bits > MAX_CLUSTER_BITS ||
        (1 << cluster_bits) != cluster_size)
    {
        error_setg(errp, ""Cluster size must be a power of two between %d and ""
                   ""%dk"", 1 << MIN_CLUSTER_BITS, 1 << (MAX_CLUSTER_BITS - 10));
        return -EINVAL;
    /*
     * Open the image file and write a minimal qcow2 header.
     *
     * We keep things simple and start with a zero-sized image. We also
     * do without refcount blocks or a L1 table for now. We'll fix the
     * inconsistency later.
     *
     * We do need a refcount table because growing the refcount table means
     * allocating two new refcount blocks - the seconds of which would be at
     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file
     * size for any qcow2 image.
     */
    BlockDriverState* bs;
    QCowHeader header;
    uint8_t* refcount_table;
    Error *local_err = NULL;
    int ret;
    ret = bdrv_create_file(filename, options, &local_err);
    if (ret < 0) {
        return ret;
    ret = bdrv_file_open(&bs, filename, NULL, BDRV_O_RDWR, &local_err);
    if (ret < 0) {
        return ret;
    /* Write the header */
    memset(&header, 0, sizeof(header));
    header.magic = cpu_to_be32(QCOW_MAGIC);
    header.version = cpu_to_be32(version);
    header.cluster_bits = cpu_to_be32(cluster_bits);
    header.size = cpu_to_be64(0);
    header.l1_table_offset = cpu_to_be64(0);
    header.l1_size = cpu_to_be32(0);
    header.refcount_table_offset = cpu_to_be64(cluster_size);
    header.refcount_table_clusters = cpu_to_be32(1);
    header.refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT);
    header.header_length = cpu_to_be32(sizeof(header));
    if (flags & BLOCK_FLAG_ENCRYPT) {
        header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);
    } else {
        header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);
    if (flags & BLOCK_FLAG_LAZY_REFCOUNTS) {
        header.compatible_features |=
            cpu_to_be64(QCOW2_COMPAT_LAZY_REFCOUNTS);
    ret = bdrv_pwrite(bs, 0, &header, sizeof(header));
    if (ret < 0) {
        error_setg_errno(errp, -ret, ""Could not write qcow2 header"");
    /* Write an empty refcount table */
    refcount_table = g_malloc0(cluster_size);
    ret = bdrv_pwrite(bs, cluster_size, refcount_table, cluster_size);
    g_free(refcount_table);
    if (ret < 0) {
        error_setg_errno(errp, -ret, ""Could not write refcount table"");
    /*
     * And now open the image and make it consistent first (i.e. increase the
     * refcount of the cluster that is occupied by the header and the refcount
     * table)
     */
    BlockDriver* drv = bdrv_find_format(""qcow2"");
    assert(drv != NULL);
        BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);
    if (ret < 0) {
    ret = qcow2_alloc_clusters(bs, 2 * cluster_size);
    if (ret < 0) {
        error_setg_errno(errp, -ret, ""Could not allocate clusters for qcow2 ""
                         ""header and refcount table"");
    } else if (ret != 0) {
        error_report(""Huh, first cluster in empty image is already in use?"");
        abort();
    /* Okay, now that we have a valid image, let's give it the right size */
    ret = bdrv_truncate(bs, total_size * BDRV_SECTOR_SIZE);
    if (ret < 0) {
        error_setg_errno(errp, -ret, ""Could not resize image"");
    /* Want a backing file? There you go.*/
    if (backing_file) {
        ret = bdrv_change_backing_file(bs, backing_file, backing_format);
        if (ret < 0) {
            error_setg_errno(errp, -ret, ""Could not assign backing file '%s' ""
                             ""with format '%s'"", backing_file, backing_format);
    /* And if we're supposed to preallocate metadata, do that now */
    if (prealloc) {
        BDRVQcowState *s = bs->opaque;
        qemu_co_mutex_lock(&s->lock);
        ret = preallocate(bs);
        qemu_co_mutex_unlock(&s->lock);
        if (ret < 0) {
            error_setg_errno(errp, -ret, ""Could not preallocate metadata"");
    ret = 0;
out:
    bdrv_unref(bs);
    return ret;",839,,LABEL_1,LABEL_1,LABEL_1,-1,"filename,total_size,backing_file,backing_format,flags,cluster_size,prealloc,options,version,errp,cluster_bits,bs,header,refcount_table,local_err,ret",,15,113,0,,0,GA,3195,1.6051689664522806,failed,[]
83,"int cpu_x86_gen_code(uint8_t *gen_code_buf, int max_code_size, 

                     int *gen_code_size_ptr, uint8_t *pc_start, 

                     int flags)

{

    DisasContext dc1, *dc = &dc1;

    uint8_t *gen_code_end, *pc_ptr;

    long ret;

#ifdef DEBUG_DISAS

    struct disassemble_info disasm_info;

#endif

    dc->code32 = (flags >> GEN_FLAG_CODE32_SHIFT) & 1;

    dc->addseg = (flags >> GEN_FLAG_ADDSEG_SHIFT) & 1;

    dc->f_st = (flags >> GEN_FLAG_ST_SHIFT) & 7;

    dc->cc_op = CC_OP_DYNAMIC;

    gen_code_ptr = gen_code_buf;

    gen_code_end = gen_code_buf + max_code_size - 4096;

    gen_start();



    dc->is_jmp = 0;

    pc_ptr = pc_start;

    do {

        ret = disas_insn(dc, pc_ptr);

        if (ret == -1) 

            error(""unknown instruction at PC=0x%x B=%02x %02x"", 

                  pc_ptr, pc_ptr[0], pc_ptr[1]);

        pc_ptr = (void *)ret;

    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);

    /* we must store the eflags state if it is not already done */

    if (dc->cc_op != CC_OP_DYNAMIC)

        gen_op_set_cc_op(dc->cc_op);

    if (dc->is_jmp != 1) {

        /* we add an additionnal jmp to update the simulated PC */

        gen_op_jmp_im(ret);

    }

    gen_end();

    *gen_code_size_ptr = gen_code_ptr - gen_code_buf;



#ifdef DEBUG_DISAS

    if (loglevel) {

        uint8_t *pc;

        int count;



        INIT_DISASSEMBLE_INFO(disasm_info, logfile, fprintf);

#if 0        

        disasm_info.flavour = bfd_get_flavour (abfd);

        disasm_info.arch = bfd_get_arch (abfd);

        disasm_info.mach = bfd_get_mach (abfd);

#endif

#ifdef WORDS_BIGENDIAN

        disasm_info.endian = BFD_ENDIAN_BIG;

#else

        disasm_info.endian = BFD_ENDIAN_LITTLE;

#endif        

        fprintf(logfile, ""IN:\n"");

        disasm_info.buffer = pc_start;

        disasm_info.buffer_vma = (unsigned long)pc_start;

        disasm_info.buffer_length = pc_ptr - pc_start;

        pc = pc_start;

        while (pc < pc_ptr) {

            fprintf(logfile, ""0x%08lx:  "", (long)pc);

            count = print_insn_i386((unsigned long)pc, &disasm_info);

            fprintf(logfile, ""\n"");

            pc += count;

        }

        fprintf(logfile, ""\n"");

        

        pc = gen_code_buf;

        disasm_info.buffer = pc;

        disasm_info.buffer_vma = (unsigned long)pc;

        disasm_info.buffer_length = *gen_code_size_ptr;

        fprintf(logfile, ""OUT: [size=%d]\n"", *gen_code_size_ptr);

        while (pc < gen_code_ptr) {

            fprintf(logfile, ""0x%08lx:  "", (long)pc);

            count = print_insn_i386((unsigned long)pc, &disasm_info);

            fprintf(logfile, ""\n"");

            pc += count;

        }

        fprintf(logfile, ""\n"");

    }

#endif

    return 0;

}
",504,"int cpu_x86_gen_code(uint8_t *gen_code_buf, int max_code_size, 

                     int *gen_code_size_ptr, uint8_t *pc_start, 

                     int flags)

{

    DisasContext dc1, *gui = &dc1;

    uint8_t *gen_code_end, *pc_ptr;

    long ret;

#ifdef DEBUG_DISAS

    struct disassemble_info disast2error;

#endif

    gui->code32 = (flags >> GEN_FLAG_CODE32_SHIFT) & 1;

    gui->addseg = (flags >> GEN_FLAG_ADDSEG_SHIFT) & 1;

    gui->f_st = (flags >> GEN_FLAG_ST_SHIFT) & 7;

    gui->cc_op = CC_OP_DYNAMIC;

    gen_code_ptr = gen_code_buf;

    gen_code_end = gen_code_buf + max_code_size - 4096;

    gen_start();



    gui->is_jmp = 0;

    pc_ptr = pc_start;

    do {

        ret = disas_insn(gui, pc_ptr);

        if (ret == -1) 

            error(""unknown instruction at PC=0x%x B=%02x %02x"", 

                  pc_ptr, pc_ptr[0], pc_ptr[1]);

        pc_ptr = (void *)ret;

    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);

    /* we must store the eflags state if it is not already done */

    if (gui->cc_op != CC_OP_DYNAMIC)

        gen_op_set_cc_op(gui->cc_op);

    if (gui->is_jmp != 1) {

        /* we add an additionnal jmp to update the simulated PC */

        gen_op_jmp_im(ret);

    }

    gen_end();

    *gen_code_size_ptr = gen_code_ptr - gen_code_buf;



#ifdef DEBUG_DISAS

    if (loglevel) {

        uint8_t *pc;

        int count;



        INIT_DISASSEMBLE_INFO(disast2error, logfile, fprintf);

#if 0        

        disast2error.flavour = bfd_get_flavour (abfd);

        disast2error.arch = bfd_get_arch (abfd);

        disast2error.mach = bfd_get_mach (abfd);

#endif

#ifdef WORDS_BIGENDIAN

        disast2error.endian = BFD_ENDIAN_BIG;

#else

        disast2error.endian = BFD_ENDIAN_LITTLE;

#endif        

        fprintf(logfile, ""IN:
"");

        disast2error.buffer = pc_start;

        disast2error.buffer_vma = (unsigned long)pc_start;

        disast2error.buffer_length = pc_ptr - pc_start;

        pc = pc_start;

        while (pc < pc_ptr) {

            fprintf(logfile, ""0x%08lx:  "", (long)pc);

            count = print_insn_i386((unsigned long)pc, &disast2error);

            fprintf(logfile, ""
"");

            pc += count;

        }

        fprintf(logfile, ""
"");

        

        pc = gen_code_buf;

        disast2error.buffer = pc;

        disast2error.buffer_vma = (unsigned long)pc;

        disast2error.buffer_length = *gen_code_size_ptr;

        fprintf(logfile, ""OUT: [size=%d]
"", *gen_code_size_ptr);

        while (pc < gen_code_ptr) {

            fprintf(logfile, ""0x%08lx:  "", (long)pc);

            count = print_insn_i386((unsigned long)pc, &disast2error);

            fprintf(logfile, ""
"");

            pc += count;

        }

        fprintf(logfile, ""
"");

    }

#endif

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"gen_code_buf,max_code_size,gen_code_size_ptr,pc_start,flags,dc1,dc,gen_code_end,pc_ptr,ret,disasm_info,pc,count","gen_code_buf:3.88026237487793e-05,max_code_size:-5.549192428588867e-05,gen_code_size_ptr:4.9114227294921875e-05,pc_start:3.5703182220458984e-05,flags:1.0251998901367188e-05,dc1:-3.719329833984375e-05,dc:8.738040924072266e-05,gen_code_end:-4.9591064453125e-05,pc_ptr:-4.208087921142578e-05,ret:-2.2172927856445312e-05,disasm_info:0.0013051629066467285,pc:-0.00020945072174072266,count:-0.0001704692840576172,",2,25,0,"disasm_info:disast2error,dc:gui,",0,Greedy,204,0.08170280853907268,replace,[]
84,"static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,

                                         uint32_t *sums, int n, int pred_order)

{

    int i;

    int k, cnt, part;

    uint32_t all_bits;



    part     = (1 << porder);

    all_bits = 4 * part;



    cnt = (n >> porder) - pred_order;

    for (i = 0; i < part; i++) {

        k = find_optimal_param(sums[i], cnt);

        rc->params[i] = k;

        all_bits += rice_encode_count(sums[i], cnt, k);

        cnt = n >> porder;

    }



    rc->porder = porder;



    return all_bits;

}
",128,,LABEL_1,LABEL_0,,-4,"rc,porder,sums,n,pred_order,i,k,cnt,part,all_bits",,,,0,,0,Greedy,1,0.0005000432332356771,,
85,"void hmp_info_snapshots(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s;

    int nb_sns, i, ret, available;

    int total;

    int *available_snapshots;



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No available block device supports snapshots\n"");

        return;

    }



    nb_sns = bdrv_snapshot_list(bs, &sn_tab);

    if (nb_sns < 0) {

        monitor_printf(mon, ""bdrv_snapshot_list: error %d\n"", nb_sns);

        return;

    }



    if (nb_sns == 0) {

        monitor_printf(mon, ""There is no snapshot available.\n"");

        return;

    }



    available_snapshots = g_malloc0(sizeof(int) * nb_sns);

    total = 0;

    for (i = 0; i < nb_sns; i++) {

        sn = &sn_tab[i];

        available = 1;

        bs1 = NULL;



        while ((bs1 = bdrv_next(bs1))) {

            if (bdrv_can_snapshot(bs1) && bs1 != bs) {

                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);

                if (ret < 0) {

                    available = 0;

                    break;

                }

            }

        }



        if (available) {

            available_snapshots[total] = i;

            total++;

        }

    }



    if (total > 0) {

        bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, NULL);

        monitor_printf(mon, ""\n"");

        for (i = 0; i < total; i++) {

            sn = &sn_tab[available_snapshots[i]];

            bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, sn);

            monitor_printf(mon, ""\n"");

        }

    } else {

        monitor_printf(mon, ""There is no suitable snapshot available\n"");

    }



    g_free(sn_tab);

    g_free(available_snapshots);



}
",361,,LABEL_1,LABEL_0,,-4,"mon,qdict,bs,bs1,sn_tab,sn,s,sn_info,nb_sns,i,ret,available,total,available_snapshots",,,,0,,0,Greedy,1,0.000635675589243571,,
86,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,

                                        hwaddr size, unsigned client)

{

    assert(mr->terminates);

    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,

                                                    size, client);

}
",43,,LABEL_0,LABEL_0,LABEL_0,-1,"mr,addr,size,client",,4,9,0,,0,GA,740,0.26036860545476276,failed,[]
87,"qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)

{

    VLANClientState *vc;



    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {

        if (vc != sender && !vc->link_down) {

            vc->receive(vc->opaque, buf, size);

        }

    }

}
",75,,LABEL_0,LABEL_1,,-4,vc,,,,0,,0,Greedy,1,0.0004719694455464681,,
88,"int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,

                      int abort_on_failure)

{

    QemuOpts *opts;

    int rc = 0;



    TAILQ_FOREACH(opts, &list->head, next) {

        rc = func(opts, opaque);

        if (abort_on_failure  &&  rc != 0)

            break;

    }

    return rc;

}
",66,,LABEL_0,LABEL_0,LABEL_0,-1,"list,func,opaque,abort_on_failure,opts",,5,11,0,,0,GA,1023,0.3632655064264933,failed,[]
89,"static inline int RENAME(yuv420_rgb16)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,

             int srcSliceH, uint8_t* dst[], int dstStride[]){

    int y, h_size;



    if(c->srcFormat == PIX_FMT_YUV422P){

	srcStride[1] *= 2;

	srcStride[2] *= 2;

    }



    h_size= (c->dstW+7)&~7;

    if(h_size*2 > FFABS(dstStride[0])) h_size-=8;



    __asm__ __volatile__ (""pxor %mm4, %mm4;"" /* zero mm4 */ );

//printf(""%X %X %X %X %X %X %X %X %X %X\n"", (int)&c->redDither, (int)&b5Dither, (int)src[0], (int)src[1], (int)src[2], (int)dst[0],

//srcStride[0],srcStride[1],srcStride[2],dstStride[0]);

    for (y= 0; y<srcSliceH; y++ ) {

	uint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];

	uint8_t *_py = src[0] + y*srcStride[0];

	uint8_t *_pu = src[1] + (y>>1)*srcStride[1];

	uint8_t *_pv = src[2] + (y>>1)*srcStride[2];

	long index= -h_size/2;



	b5Dither= dither8[y&1];

	g6Dither= dither4[y&1];

	g5Dither= dither8[y&1];

	r5Dither= dither8[(y+1)&1];

	    /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8

	       pixels in each iteration */

	    __asm__ __volatile__ (

	/* load data for start of next scan line */

		     ""movd (%2, %0), %%mm0;"" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */

		     ""movd (%3, %0), %%mm1;"" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */

		     ""movq (%5, %0, 2), %%mm6;"" /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */

//		    "".balign 16			\n\t""

		    ""1:				\n\t""

/* no speed diference on my p3@500 with prefetch,

 * if it is faster for anyone with -benchmark then tell me

			PREFETCH"" 64(%0) \n\t""

			PREFETCH"" 64(%1) \n\t""

			PREFETCH"" 64(%2) \n\t""

*/

YUV2RGB



#ifdef DITHER1XBPP

			""paddusb ""MANGLE(b5Dither)"", %%mm0;""

			""paddusb ""MANGLE(g6Dither)"", %%mm2;""

			""paddusb ""MANGLE(r5Dither)"", %%mm1;""

#endif

		     /* mask unneeded bits off */

		     ""pand ""MANGLE(mmx_redmask)"", %%mm0;"" /* b7b6b5b4 b3_0_0_0 b7b6b5b4 b3_0_0_0 */

		     ""pand ""MANGLE(mmx_grnmask)"", %%mm2;"" /* g7g6g5g4 g3g2_0_0 g7g6g5g4 g3g2_0_0 */

		     ""pand ""MANGLE(mmx_redmask)"", %%mm1;"" /* r7r6r5r4 r3_0_0_0 r7r6r5r4 r3_0_0_0 */



		     ""psrlw $3,%%mm0;"" /* 0_0_0_b7 b6b5b4b3 0_0_0_b7 b6b5b4b3 */

		     ""pxor %%mm4, %%mm4;"" /* zero mm4 */



		     ""movq %%mm0, %%mm5;"" /* Copy B7-B0 */

		     ""movq %%mm2, %%mm7;"" /* Copy G7-G0 */



		     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */

		     ""punpcklbw %%mm4, %%mm2;"" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */

		     ""punpcklbw %%mm1, %%mm0;"" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */



		     ""psllw $3, %%mm2;"" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */

		     ""por %%mm2, %%mm0;"" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */



		     ""movq 8 (%5, %0, 2), %%mm6;"" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */

		     MOVNTQ "" %%mm0, (%1);"" /* store pixel 0-3 */



		     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */

		     ""punpckhbw %%mm4, %%mm7;"" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */

		     ""punpckhbw %%mm1, %%mm5;"" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */



		     ""psllw $3, %%mm7;"" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */

		     ""movd 4 (%2, %0), %%mm0;"" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */



		     ""por %%mm7, %%mm5;"" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */

		     ""movd 4 (%3, %0), %%mm1;"" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */



		     MOVNTQ "" %%mm5, 8 (%1);"" /* store pixel 4-7 */



		     ""add $16, %1			\n\t""

		     ""add $4, %0			\n\t""

		     "" js 1b				\n\t""



		     : ""+r"" (index), ""+r"" (_image)

		     : ""r"" (_pu - index), ""r"" (_pv - index), ""r""(&c->redDither), ""r"" (_py - 2*index)

		     );

    }



    __asm__ __volatile__ (EMMS);



    return srcSliceH;

}
",857,,LABEL_1,LABEL_0,,-4,"c,src,srcStride,srcSliceY,srcSliceH,dst,dstStride,y,h_size,_image,_py,_pu,_pv",,,,0,,0,Greedy,1,0.0010206818580627442,,
90,"static void bdrv_co_drain_bh_cb(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *co = data->co;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(co, NULL);

}
",56,,LABEL_1,LABEL_0,,-4,"opaque,data,co",,,,0,,0,Greedy,1,0.0004280885060628255,,
91,"static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,

                                      const uint8_t *buf, int nb_sectors)

{

    int ret;

    BDRVVmdkState *s = bs->opaque;

    qemu_co_mutex_lock(&s->lock);

    ret = vmdk_write(bs, sector_num, buf, nb_sectors);

    qemu_co_mutex_unlock(&s->lock);

    return ret;

}
",68,,LABEL_1,LABEL_0,,-4,"bs,sector_num,buf,nb_sectors,ret,s",,,,0,,0,Greedy,1,0.0004400014877319336,,
92,"void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,

                                     uintptr_t retaddr)

{

    CPUState *cs = CPU(s390_env_get_cpu(env));

    int t;



    cs->exception_index = EXCP_PGM;

    env->int_pgm_code = excp;



    /* Use the (ultimate) callers address to find the insn that trapped.  */

    cpu_restore_state(cs, retaddr);



    /* Advance past the insn.  */

    t = cpu_ldub_code(env, env->psw.addr);

    env->int_pgm_ilen = t = get_ilen(t);

    env->psw.addr += t;



    cpu_loop_exit(cs);

}
",120,,LABEL_0,LABEL_0,LABEL_0,-1,"env,excp,retaddr,cs,t",,5,20,0,,0,GA,713,0.25959139664967856,failed,[]
93,"int opt_cpuflags(const char *opt, const char *arg)

{

#define CPUFLAG_MMX2     (AV_CPU_FLAG_MMX      | AV_CPU_FLAG_MMX2)

#define CPUFLAG_3DNOW    (AV_CPU_FLAG_3DNOW    | AV_CPU_FLAG_MMX)

#define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW)

#define CPUFLAG_SSE      (AV_CPU_FLAG_SSE      | CPUFLAG_MMX2)

#define CPUFLAG_SSE2     (AV_CPU_FLAG_SSE2     | CPUFLAG_SSE)

#define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2)

#define CPUFLAG_SSE3     (AV_CPU_FLAG_SSE3     | CPUFLAG_SSE2)

#define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3)

#define CPUFLAG_SSSE3    (AV_CPU_FLAG_SSSE3    | CPUFLAG_SSE3)

#define CPUFLAG_SSE4     (AV_CPU_FLAG_SSE4     | CPUFLAG_SSSE3)

#define CPUFLAG_SSE42    (AV_CPU_FLAG_SSE42    | CPUFLAG_SSE4)

#define CPUFLAG_AVX      (AV_CPU_FLAG_AVX      | CPUFLAG_SSE42)

#define CPUFLAG_XOP      (AV_CPU_FLAG_XOP      | CPUFLAG_AVX)

#define CPUFLAG_FMA4     (AV_CPU_FLAG_FMA4     | CPUFLAG_AVX)

    static const AVOption cpuflags_opts[] = {

        { ""flags""   , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = ""flags"" },

        { ""altivec"" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC  },    .unit = ""flags"" },

        { ""mmx""     , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX      },    .unit = ""flags"" },

        { ""mmx2""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2         },    .unit = ""flags"" },

        { ""sse""     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE          },    .unit = ""flags"" },

        { ""sse2""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2         },    .unit = ""flags"" },

        { ""sse2slow"", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW     },    .unit = ""flags"" },

        { ""sse3""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3         },    .unit = ""flags"" },

        { ""sse3slow"", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW     },    .unit = ""flags"" },

        { ""ssse3""   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3        },    .unit = ""flags"" },

        { ""atom""    , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM     },    .unit = ""flags"" },

        { ""sse4.1""  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4         },    .unit = ""flags"" },

        { ""sse4.2""  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42        },    .unit = ""flags"" },

        { ""avx""     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX          },    .unit = ""flags"" },

        { ""xop""     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP          },    .unit = ""flags"" },

        { ""fma4""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4         },    .unit = ""flags"" },

        { ""3dnow""   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW        },    .unit = ""flags"" },

        { ""3dnowext"", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT     },    .unit = ""flags"" },

        { NULL },

    };

    static const AVClass class = {

        .class_name = ""cpuflags"",

        .item_name  = av_default_item_name,

        .option     = cpuflags_opts,

        .version    = LIBAVUTIL_VERSION_INT,

    };

    int flags = av_get_cpu_flags();

    int ret;

    const AVClass *pclass = &class;



    if ((ret = av_opt_eval_flags(&pclass, &cpuflags_opts[0], arg, &flags)) < 0)

        return ret;



    av_force_cpu_flags(flags);

    return 0;

}
",458,,LABEL_0,LABEL_0,LABEL_0,-1,"opt,arg,cpuflags_opts",,3,6,0,,0,GA,576,0.24573043982187906,failed,[]
94,"int ff_img_read_packet(AVFormatContext *s1, AVPacket *pkt)

{

    VideoDemuxData *s = s1->priv_data;

    char filename_bytes[1024];

    char *filename = filename_bytes;

    int i;

    int size[3]           = { 0 }, ret[3] = { 0 };

    AVIOContext *f[3]     = { NULL };

    AVCodecContext *codec = s1->streams[0]->codec;



    if (!s->is_pipe) {

        /* loop over input */

        if (s->loop && s->img_number > s->img_last) {

            s->img_number = s->img_first;

        }

        if (s->img_number > s->img_last)

            return AVERROR_EOF;

        if (s->use_glob) {

#if HAVE_GLOB

            filename = s->globstate.gl_pathv[s->img_number];

#endif

        } else {

        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),

                                  s->path,

                                  s->img_number) < 0 && s->img_number > 1)

            return AVERROR(EIO);

        }

        for (i = 0; i < 3; i++) {

            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,

                           &s1->interrupt_callback, NULL) < 0) {

                if (i >= 1)

                    break;

                av_log(s1, AV_LOG_ERROR, ""Could not open file : %s\n"",

                       filename);

                return AVERROR(EIO);

            }

            size[i] = avio_size(f[i]);



            if (!s->split_planes)

                break;

            filename[strlen(filename) - 1] = 'U' + i;

        }



        if (codec->codec_id == AV_CODEC_ID_NONE) {

            AVProbeData pd;

            AVInputFormat *ifmt;

            uint8_t header[PROBE_BUF_MIN + AVPROBE_PADDING_SIZE];

            int ret;

            int score = 0;



            ret = avio_read(f[0], header, PROBE_BUF_MIN);

            if (ret < 0)

                return ret;


            avio_skip(f[0], -ret);

            pd.buf = header;

            pd.buf_size = ret;

            pd.filename = filename;



            ifmt = av_probe_input_format3(&pd, 1, &score);

            if (ifmt && ifmt->read_packet == ff_img_read_packet && ifmt->raw_codec_id)

                codec->codec_id = ifmt->raw_codec_id;

        }



        if (codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)

            infer_size(&codec->width, &codec->height, size[0]);

    } else {

        f[0] = s1->pb;

        if (url_feof(f[0]))

            return AVERROR(EIO);

        if (s->frame_size > 0) {

            size[0] = s->frame_size;

        } else {

            size[0] = 4096;

        }

    }



    if (av_new_packet(pkt, size[0] + size[1] + size[2]) < 0)

        return AVERROR(ENOMEM);

    pkt->stream_index = 0;

    pkt->flags       |= AV_PKT_FLAG_KEY;

    if (s->ts_from_file) {

        struct stat img_stat;

        if (stat(filename, &img_stat))

            return AVERROR(EIO);

        pkt->pts = (int64_t)img_stat.st_mtime;

        av_add_index_entry(s1->streams[0], s->img_number, pkt->pts, 0, 0, AVINDEX_KEYFRAME);

    } else if (!s->is_pipe) {

        pkt->pts      = s->pts;

    }



    pkt->size = 0;

    for (i = 0; i < 3; i++) {

        if (f[i]) {

            ret[i] = avio_read(f[i], pkt->data + pkt->size, size[i]);

            if (!s->is_pipe)

                avio_close(f[i]);

            if (ret[i] > 0)

                pkt->size += ret[i];

        }

    }



    if (ret[0] <= 0 || ret[1] < 0 || ret[2] < 0) {

        av_free_packet(pkt);

        return AVERROR(EIO); /* signal EOF */

    } else {

        s->img_count++;

        s->img_number++;

        s->pts++;

        return 0;

    }

}",833,,LABEL_1,LABEL_0,,-4,"s1,pkt,s,filename_bytes,filename,i,size,ret,f,codec,pd,ifmt,header,img_number",,,,0,,0,Greedy,1,0.0009055097897847493,,
95,"static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(n);

    NetClientState *nc = qemu_get_queue(n->nic);

    int queues = n->multiqueue ? n->max_queues : 1;



    if (!get_vhost_net(nc->peer)) {

        return;

    }



    if (!!n->vhost_started ==

        (virtio_net_started(n, status) && !nc->peer->link_down)) {

        return;

    }

    if (!n->vhost_started) {

        int r;

        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {

            return;

        }

        n->vhost_started = 1;

        r = vhost_net_start(vdev, n->nic->ncs, queues);

        if (r < 0) {

            error_report(""unable to start vhost net: %d: ""

                         ""falling back on userspace virtio"", -r);

            n->vhost_started = 0;

        }

    } else {

        vhost_net_stop(vdev, n->nic->ncs, queues);

        n->vhost_started = 0;

    }

}
",198,"static void virtio_net_vhost_status(VirtIONet *n, uint8_t network)

{

    VirtIODevice * vdiv = VIRTIO_DEVICE(n);

    NetClientState *gn = qemu_get_queue(n->nic);

    int queues = n->multiqueue ? n->max_queues : 1;



    if (!get_vhost_net(gn->peer)) {

        return;

    }



    if (!!n->vhost_started ==

        (virtio_net_started(n, network) && !nc->peer->link_down)) {

        return;

    }

    if (!n->vhost_started) {

        int er;

        if (!vhost_net_query(get_vhost_net(gn->peer),  vdiv)) {

            return;

        }

        n->vhost_started = 1;

        er = vhost_net_start( vdiv, n->nic->ncs, queues);

        if (er < 0) {

            error_report(""unable to start vhost net: %d: ""

                         ""falling back on userspace virtio"", -er);

            n->vhost_started = 0;

        }

    } else {

        vhost_net_stop( vdiv, n->nic->ncs, queues);

        n->vhost_started = 0;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"n,status,vdev,nc,r","n:-0.0005025863647460938,status:-5.841255187988281e-05,vdev:-0.00013303756713867188,nc:-0.00020170211791992188,r:-0.00012564659118652344,",4,13,0,"status:network,r:er,vdev: vdiv,nc:gn,",0,Greedy,205,0.0764423966407776,replace,[]
96,"START_TEST(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}
",39,,LABEL_0,LABEL_0,LABEL_0,-1,qi,,1,4,0,,0,GA,276,0.09669624964396159,failed,[]
97,"static int ram_save_block(QEMUFile *f)

{

    RAMBlock *block = last_block;

    ram_addr_t offset = last_offset;

    int bytes_sent = -1;

    MemoryRegion *mr;



    if (!block)

        block = QLIST_FIRST(&ram_list.blocks);



    do {

        mr = block->mr;

        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,

                                    DIRTY_MEMORY_MIGRATION)) {

            uint8_t *p;

            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;



            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,

                                      DIRTY_MEMORY_MIGRATION);



            p = memory_region_get_ram_ptr(mr) + offset;



            if (is_dup_page(p)) {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);

                qemu_put_byte(f, *p);

                bytes_sent = 1;

            } else {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);

                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);

                bytes_sent = TARGET_PAGE_SIZE;

            }



            break;

        }



        offset += TARGET_PAGE_SIZE;

        if (offset >= block->length) {

            offset = 0;

            block = QLIST_NEXT(block, next);

            if (!block)

                block = QLIST_FIRST(&ram_list.blocks);

        }

    } while (block != last_block || offset != last_offset);



    last_block = block;

    last_offset = offset;



    return bytes_sent;

}
",240,,LABEL_0,LABEL_1,,-4,"f,block,mr,p",,,,0,,0,Greedy,1,0.0005783240000406901,,
98,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
",76,,LABEL_0,LABEL_1,,-4,"s,rlow,rhigh,val,tmp",,,,0,,0,Greedy,1,0.0004545847574869792,,
99,"static void RENAME(swScale)(SwsContext *c, uint8_t* srcParam[], int srcStrideParam[], int srcSliceY,

             int srcSliceH, uint8_t* dstParam[], int dstStride[]){



	/* load a few things into local vars to make the code more readable? and faster */

	const int srcW= c->srcW;

	const int dstW= c->dstW;

	const int dstH= c->dstH;

	const int chrDstW= c->chrDstW;

	const int lumXInc= c->lumXInc;

	const int chrXInc= c->chrXInc;

	const int dstFormat= c->dstFormat;

	const int flags= c->flags;

	const int canMMX2BeUsed= c->canMMX2BeUsed;

	int16_t *vLumFilterPos= c->vLumFilterPos;

	int16_t *vChrFilterPos= c->vChrFilterPos;

	int16_t *hLumFilterPos= c->hLumFilterPos;

	int16_t *hChrFilterPos= c->hChrFilterPos;

	int16_t *vLumFilter= c->vLumFilter;

	int16_t *vChrFilter= c->vChrFilter;

	int16_t *hLumFilter= c->hLumFilter;

	int16_t *hChrFilter= c->hChrFilter;

	int16_t *lumMmxFilter= c->lumMmxFilter;

	int16_t *chrMmxFilter= c->chrMmxFilter;

	const int vLumFilterSize= c->vLumFilterSize;

	const int vChrFilterSize= c->vChrFilterSize;

	const int hLumFilterSize= c->hLumFilterSize;

	const int hChrFilterSize= c->hChrFilterSize;

	int16_t **lumPixBuf= c->lumPixBuf;

	int16_t **chrPixBuf= c->chrPixBuf;

	const int vLumBufSize= c->vLumBufSize;

	const int vChrBufSize= c->vChrBufSize;

	uint8_t *funnyYCode= c->funnyYCode;

	uint8_t *funnyUVCode= c->funnyUVCode;

	uint8_t *formatConvBuffer= c->formatConvBuffer;



	/* vars whch will change and which we need to storw back in the context */

	int dstY= c->dstY;

	int lumBufIndex= c->lumBufIndex;

	int chrBufIndex= c->chrBufIndex;

	int lastInLumBuf= c->lastInLumBuf;

	int lastInChrBuf= c->lastInChrBuf;

	int srcStride[3];

	uint8_t *src[3];

	uint8_t *dst[3];

	

	if((c->srcFormat == IMGFMT_IYUV) || (c->srcFormat == IMGFMT_I420)){

		src[0]= srcParam[0];

		src[1]= srcParam[2];

		src[2]= srcParam[1];

		srcStride[0]= srcStrideParam[0];

		srcStride[1]= srcStrideParam[2];

		srcStride[2]= srcStrideParam[1];

	}

	else if(c->srcFormat==IMGFMT_YV12){

		src[0]= srcParam[0];

		src[1]= srcParam[1];

		src[2]= srcParam[2];

		srcStride[0]= srcStrideParam[0];

		srcStride[1]= srcStrideParam[1];

		srcStride[2]= srcStrideParam[2];

	}

	else if(isPacked(c->srcFormat)){

		src[0]=

		src[1]=

		src[2]= srcParam[0];

		srcStride[0]= srcStrideParam[0];

		srcStride[1]=

		srcStride[2]= srcStrideParam[0]<<1;

	}

	else if(c->srcFormat==IMGFMT_Y8){

		src[0]= srcParam[0];

		src[1]=

		src[2]= NULL;

		srcStride[0]= srcStrideParam[0];

		srcStride[1]=

		srcStride[2]= 0;

	}



	if((c->dstFormat == IMGFMT_IYUV) || (c->dstFormat == IMGFMT_I420)){

		dst[0]= dstParam[0];

		dst[1]= dstParam[2];

		dst[2]= dstParam[1];

		

	}else{

		dst[0]= dstParam[0];

		dst[1]= dstParam[1];

		dst[2]= dstParam[2];

	}

	



	if(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)

	{

		static int firstTime=1; //FIXME move this into the context perhaps

		if(flags & SWS_PRINT_INFO && firstTime)

		{

			fprintf(stderr, ""SwScaler: Warning: dstStride is not aligned!\n""

					""SwScaler:          ->cannot do aligned memory acesses anymore\n"");

			firstTime=0;

		}

	}



	/* Note the user might start scaling the picture in the middle so this will not get executed

	   this is not really intended but works currently, so ppl might do it */

	if(srcSliceY ==0){

		lumBufIndex=0;

		chrBufIndex=0;

		dstY=0;	

		lastInLumBuf= -1;

		lastInChrBuf= -1;

	}



	for(;dstY < dstH; dstY++){

		unsigned char *dest =dst[0]+dstStride[0]*dstY;

		unsigned char *uDest=dst[1]+dstStride[1]*(dstY>>1);

		unsigned char *vDest=dst[2]+dstStride[2]*(dstY>>1);

		const int chrDstY= isHalfChrV(dstFormat) ? (dstY>>1) : dstY;



		const int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input

		const int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input

		const int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input

		const int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input



		//handle holes (FAST_BILINEAR & weird filters)

		if(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;

		if(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;

//printf(""%d %d %d\n"", firstChrSrcY, lastInChrBuf, vChrBufSize);

		ASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)

		ASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)



		// Do we have enough lines in this slice to output the dstY line

		if(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < ((srcSliceY + srcSliceH)>>1))

		{

			//Do horizontal scaling

			while(lastInLumBuf < lastLumSrcY)

			{

				uint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];

				lumBufIndex++;

//				printf(""%d %d %d %d\n"", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);

				ASSERT(lumBufIndex < 2*vLumBufSize)

				ASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)

				ASSERT(lastInLumBuf + 1 - srcSliceY >= 0)

//				printf(""%d %d\n"", lumBufIndex, vLumBufSize);

				RENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,

						flags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,

						funnyYCode, c->srcFormat, formatConvBuffer);

				lastInLumBuf++;

			}

			while(lastInChrBuf < lastChrSrcY)

			{

				uint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];

				uint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];

				chrBufIndex++;

				ASSERT(chrBufIndex < 2*vChrBufSize)

				ASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1))

				ASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)

				//FIXME replace parameters through context struct (some at least)

				RENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,

						flags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,

						funnyUVCode, c->srcFormat, formatConvBuffer);

				lastInChrBuf++;

			}

			//wrap buf index around to stay inside the ring buffer

			if(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;

			if(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;

		}

		else // not enough lines left in this slice -> load the rest in the buffer

		{

/*		printf(""%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\n"",

			firstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,

			lastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,

			vChrBufSize, vLumBufSize);

*/

			//Do horizontal scaling

			while(lastInLumBuf+1 < srcSliceY + srcSliceH)

			{

				uint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];

				lumBufIndex++;

				ASSERT(lumBufIndex < 2*vLumBufSize)

				ASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)

				ASSERT(lastInLumBuf + 1 - srcSliceY >= 0)

				RENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,

						flags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,

						funnyYCode, c->srcFormat, formatConvBuffer);

				lastInLumBuf++;

			}

			while(lastInChrBuf+1 < ((srcSliceY + srcSliceH)>>1))

			{

				uint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];

				uint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];

				chrBufIndex++;

				ASSERT(chrBufIndex < 2*vChrBufSize)

				ASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1))

				ASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)

				RENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,

						flags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,

						funnyUVCode, c->srcFormat, formatConvBuffer);

				lastInChrBuf++;

			}

			//wrap buf index around to stay inside the ring buffer

			if(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;

			if(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;

			break; //we cant output a dstY line so lets try with the next slice

		}



#ifdef HAVE_MMX

		b5Dither= dither8[dstY&1];

		g6Dither= dither4[dstY&1];

		g5Dither= dither8[dstY&1];

		r5Dither= dither8[(dstY+1)&1];

#endif

	    if(dstY < dstH-2)

	    {

		if(isPlanarYUV(dstFormat)) //YV12 like

		{

			if(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi

			if(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12

			{

				int16_t *lumBuf = lumPixBuf[0];

				int16_t *chrBuf= chrPixBuf[0];

				RENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW);

			}

			else //General YV12

			{

				int16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;

				int16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;

				RENAME(yuv2yuvX)(

					vLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,

					vChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,

					dest, uDest, vDest, dstW,

					lumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+(dstY>>1)*vChrFilterSize*4);

			}

		}

		else

		{

			int16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;

			int16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;



			ASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);

			ASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);

			if(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB

			{

				int chrAlpha= vChrFilter[2*dstY+1];



				RENAME(yuv2rgb1)(*lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),

						 dest, dstW, chrAlpha, dstFormat, flags);

			}

			else if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB

			{

				int lumAlpha= vLumFilter[2*dstY+1];

				int chrAlpha= vChrFilter[2*dstY+1];



				RENAME(yuv2rgb2)(*lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),

						 dest, dstW, lumAlpha, chrAlpha, dstFormat, flags);

			}

			else //General RGB

			{

				RENAME(yuv2rgbX)(

					vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,

					vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

					dest, dstW, dstFormat,

					lumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+dstY*vChrFilterSize*4);

			}

		}

            }

	    else // hmm looks like we cant use MMX here without overwriting this arrays tail

	    {

		int16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;

		int16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;

		if(isPlanarYUV(dstFormat)) //YV12

		{

			if(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi

			yuv2yuvXinC(

				vLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,

				vChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, uDest, vDest, dstW);

		}

		else

		{

			ASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);

			ASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);

			yuv2rgbXinC(

				vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,

				vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, dstW, dstFormat);

		}

	    }

	}



#ifdef HAVE_MMX

	__asm __volatile(SFENCE:::""memory"");

	__asm __volatile(EMMS:::""memory"");

#endif

	/* store changed local vars back in the context */

	c->dstY= dstY;

	c->lumBufIndex= lumBufIndex;

	c->chrBufIndex= chrBufIndex;

	c->lastInLumBuf= lastInLumBuf;

	c->lastInChrBuf= lastInChrBuf;

}
",2658,,LABEL_0,LABEL_1,,-4,"c,srcParam,srcStrideParam,srcSliceY,srcSliceH,dstParam,dstStride,vLumFilterPos,vChrFilterPos,hLumFilterPos,hChrFilterPos,vLumFilter,vChrFilter,hLumFilter,hChrFilter,lumMmxFilter,chrMmxFilter,lumPixBuf,chrPixBuf",,,,0,,0,Greedy,1,0.0018619259198506674,,
100,"static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)

{

    ParseContext1 *pc = s->priv_data;



    pc->enc = av_mallocz(sizeof(MpegEncContext));

    if (!pc->enc)

        return -1;

    pc->first_picture = 1;


    return 0;

}",56,,LABEL_1,LABEL_1,LABEL_1,-1,"s,pc",,2,5,0,,0,GA,481,0.16974543333053588,failed,[]
101,"static void test_function(const TestStruct test_sample)

{

    int ret, i;

    void **output_data  = NULL;

    AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,

                                            test_sample.nb_samples_pch);

    if (!afifo) {

        ERROR(""ERROR: av_audio_fifo_alloc returned NULL!"");

    }

    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_write failed!"");

    }

    printf(""written: %d\n"", ret);



    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_write failed!"");

    }

    printf(""written: %d\n"", ret);

    printf(""remaining samples in audio_fifo: %d\n\n"", av_audio_fifo_size(afifo));



    ret = read_samples_from_audio_fifo(afifo, &output_data, test_sample.nb_samples_pch);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_read failed!"");

    }

    printf(""read: %d\n"", ret);

    print_audio_bytes(&test_sample, output_data, ret);

    printf(""remaining samples in audio_fifo: %d\n\n"", av_audio_fifo_size(afifo));



    /* test av_audio_fifo_peek */

    ret = av_audio_fifo_peek(afifo, output_data, afifo->nb_samples);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_peek failed!"");

    }

    printf(""peek:\n"");

    print_audio_bytes(&test_sample, output_data, ret);

    printf(""\n"");



    /* test av_audio_fifo_peek_at */

    printf(""peek_at:\n"");

    for (i = 0; i < afifo->nb_samples; ++i){

        ret = av_audio_fifo_peek_at(afifo, output_data, 1, i);

        if (ret < 0){

            ERROR(""ERROR: av_audio_fifo_peek_at failed!"");

        }

        printf(""%d:\n"", i);

        print_audio_bytes(&test_sample, output_data, ret);

    }

    printf(""\n"");



    /* test av_audio_fifo_drain */

    ret = av_audio_fifo_drain(afifo, afifo->nb_samples);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_drain failed!"");

    }

    if (afifo->nb_samples){

        ERROR(""drain failed to flush all samples in audio_fifo!"");

    }



    /* deallocate */

    for (i = 0; i < afifo->nb_buffers; ++i){

        av_freep(&output_data[i]);

    }

    av_freep(&output_data);

    av_audio_fifo_free(afifo);

}
",448,,LABEL_1,LABEL_0,,-4,"test_sample,ret,i,output_data,afifo",,,,0,,0,Greedy,1,0.0007007400194803874,,
102,"static int ram_block_enable_notify(const char *block_name, void *host_addr,

                                   ram_addr_t offset, ram_addr_t length,

                                   void *opaque)

{

    MigrationIncomingState *mis = opaque;

    struct uffdio_register reg_struct;



    reg_struct.range.start = (uintptr_t)host_addr;

    reg_struct.range.len = length;

    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;



    /* Now tell our userfault_fd that it's responsible for this area */

    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {

        error_report(""%s userfault register: %s"", __func__, strerror(errno));









    return 0;
",108,,LABEL_1,LABEL_1,LABEL_1,-1,"block_name,host_addr,offset,length,opaque,mis,reg_struct",,7,15,0,,0,GA,1351,0.49213308095932007,failed,[]
103,"void show_help(void)

{

    const char *prog;

    const OptionDef *po;

    int i, expert;

    

    prog = do_play ? ""ffplay"" : ""ffmpeg"";



    printf(""%s version "" FFMPEG_VERSION "", Copyright (c) 2000, 2001, 2002 Gerard Lantau\n"", 

           prog);

    

    if (!do_play) {

        printf(""usage: ffmpeg [[options] -i input_file]... {[options] outfile}...\n""

               ""Hyper fast MPEG1/MPEG4/H263/RV and AC3/MPEG audio encoder\n"");

    } else {

        printf(""usage: ffplay [options] input_file...\n""

               ""Simple audio player\n"");

    }

           

    printf(""\n""

           ""Main options are:\n"");

    for(i=0;i<2;i++) {

        if (i == 1)

            printf(""\nAdvanced options are:\n"");

        for(po = options; po->name != NULL; po++) {

            char buf[64];

            expert = (po->flags & OPT_EXPERT) != 0;

            if (expert == i) {

                strcpy(buf, po->name);

                if (po->flags & HAS_ARG) {

                    strcat(buf, "" "");

                    strcat(buf, po->argname);

                }

                printf(""-%-17s  %s\n"", buf, po->help);

            }

        }

    }



    exit(1);

}
",279,,LABEL_1,LABEL_0,,-4,"prog,po,i,expert,buf",,,,0,,0,Greedy,1,0.0006041169166564941,,
104,"void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)

{

    Error *local_err = NULL;

    int ret;



    if (!bs->drv)  {

        return;

    }



    if (!(bs->open_flags & BDRV_O_INACTIVE)) {

        return;

    }

    bs->open_flags &= ~BDRV_O_INACTIVE;



    if (bs->drv->bdrv_invalidate_cache) {

        bs->drv->bdrv_invalidate_cache(bs, &local_err);

    } else if (bs->file) {

        bdrv_invalidate_cache(bs->file->bs, &local_err);

    }

    if (local_err) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_propagate(errp, local_err);

        return;

    }



    ret = refresh_total_sectors(bs, bs->total_sectors);

    if (ret < 0) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");

        return;

    }

}
",168,,LABEL_0,LABEL_0,LABEL_0,-1,"bs,errp,local_err,ret",,4,25,0,,0,GA,884,0.33041717608769733,failed,[]
105,"static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,

                                        int buf_size, AVSubtitle *sub)

{

    DVBSubContext *ctx = avctx->priv_data;

    DVBSubDisplayDefinition *display_def = ctx->display_definition;



    DVBSubRegion *region;

    DVBSubRegionDisplay *display;

    AVSubtitleRect *rect;

    DVBSubCLUT *clut;

    uint32_t *clut_table;

    int i;

    int offset_x=0, offset_y=0;



    sub->rects = NULL;

    sub->start_display_time = 0;

    sub->end_display_time = ctx->time_out * 1000;

    sub->format = 0;



    if (display_def) {

        offset_x = display_def->x;

        offset_y = display_def->y;

    }



    sub->num_rects = ctx->display_list_size;

    if (sub->num_rects <= 0)

        return AVERROR_INVALIDDATA;



    sub->rects = av_mallocz_array(sub->num_rects * sub->num_rects,

                                  sizeof(*sub->rects));

    if (!sub->rects)

        return AVERROR(ENOMEM);



    i = 0;



    for (display = ctx->display_list; display; display = display->next) {

        region = get_region(ctx, display->region_id);

        rect = sub->rects[i];



        if (!region)

            continue;



        rect->x = display->x_pos + offset_x;

        rect->y = display->y_pos + offset_y;

        rect->w = region->width;

        rect->h = region->height;

        rect->nb_colors = 16;

        rect->type      = SUBTITLE_BITMAP;

        rect->pict.linesize[0] = region->width;



        clut = get_clut(ctx, region->clut);



        if (!clut)

            clut = &default_clut;



        switch (region->depth) {

        case 2:

            clut_table = clut->clut4;

            break;

        case 8:

            clut_table = clut->clut256;

            break;

        case 4:

        default:

            clut_table = clut->clut16;

            break;

        }



        rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);

        if (!rect->pict.data[1]) {

            av_free(sub->rects);

            return AVERROR(ENOMEM);

        }

        memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));



        rect->pict.data[0] = av_malloc(region->buf_size);

        if (!rect->pict.data[0]) {

            av_free(rect->pict.data[1]);

            av_free(sub->rects);

            return AVERROR(ENOMEM);

        }

        memcpy(rect->pict.data[0], region->pbuf, region->buf_size);



        i++;

    }



    sub->num_rects = i;



#ifdef DEBUG

    save_display_set(ctx);

#endif



    return 1;

}
",556,"static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,

                                        int buf_size, AVSubtitle *app)

{

    DVBSubContext *mac = avctx->priv_data;

    DVBSubDisplayDefinition *display_def = mac->display_definition;



    DVBSubRegion *region;

    DVBSubRegionDisplay *display;

    AVSubtitleRect *rect;

    DVBSubCLUT *clut;

    uint32_t *clut_table;

    int i;

    int offset_x=0, offset_y=0;



    app->rects = NULL;

    app->start_display_time = 0;

    app->end_display_time = mac->time_out * 1000;

    app->format = 0;



    if (display_def) {

        offset_x = display_def->x;

        offset_y = display_def->y;

    }



    app->num_rects = mac->display_list_size;

    if (app->num_rects <= 0)

        return AVERROR_INVALIDDATA;



    app->rects = av_mallocz_array(app->num_rects * app->num_rects,

                                  sizeof(*app->rects));

    if (!sub->rects)

        return AVERROR(ENOMEM);



    i = 0;



    for (display = mac->display_list; display; display = display->next) {

        region = get_region(mac, display->region_id);

        rect = app->rects[i];



        if (!region)

            continue;



        rect->x = display->x_pos + offset_x;

        rect->y = display->y_pos + offset_y;

        rect->w = region->width;

        rect->h = region->height;

        rect->nb_colors = 16;

        rect->type      = SUBTITLE_BITMAP;

        rect->pict.linesize[0] = region->width;



        clut = get_clut(mac, region->clut);



        if (!clut)

            clut = &default_clut;



        switch (region->depth) {

        case 2:

            clut_table = clut->clut4;

            break;

        case 8:

            clut_table = clut->clut256;

            break;

        case 4:

        default:

            clut_table = clut->clut16;

            break;

        }



        rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);

        if (!rect->pict.data[1]) {

            av_free(app->rects);

            return AVERROR(ENOMEM);

        }

        memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));



        rect->pict.data[0] = av_malloc(region->buf_size);

        if (!rect->pict.data[0]) {

            av_free(rect->pict.data[1]);

            av_free(app->rects);

            return AVERROR(ENOMEM);

        }

        memcpy(rect->pict.data[0], region->pbuf, region->buf_size);



        i++;

    }



    app->num_rects = i;



#ifdef DEBUG

    save_display_set(mac);

#endif



    return 1;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,buf,buf_size,sub,ctx,display_def,region,display,rect,clut,clut_table,i","avctx:-6.973743438720703e-06,buf:-1.341104507446289e-05,buf_size:6.502866744995117e-05,sub:0.00010830163955688477,ctx:0.00026679039001464844,display_def:-2.2411346435546875e-05,region:-0.00011008977890014648,display:-9.512901306152344e-05,rect:-0.00011521577835083008,clut:-8.559226989746094e-05,clut_table:1.4007091522216797e-05,i:-2.2292137145996094e-05,",2,23,0,"ctx:mac,sub:app,",0,Greedy,229,0.09133253494898479,replace,[]
106,"static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)

{

    int err;

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    err =  lstat(rpath(fs_ctx, path, buffer), stbuf);

    if (err) {

        return err;

    }

    if (fs_ctx->fs_sm == SM_MAPPED) {

        /* Actual credentials are part of extended attrs */

        uid_t tmp_uid;

        gid_t tmp_gid;

        mode_t tmp_mode;

        dev_t tmp_dev;

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.uid"", &tmp_uid,

                    sizeof(uid_t)) > 0) {

            stbuf->st_uid = tmp_uid;

        }

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.gid"", &tmp_gid,

                    sizeof(gid_t)) > 0) {

            stbuf->st_gid = tmp_gid;

        }

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.mode"",

                    &tmp_mode, sizeof(mode_t)) > 0) {

            stbuf->st_mode = tmp_mode;

        }

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.rdev"", &tmp_dev,

                        sizeof(dev_t)) > 0) {

                stbuf->st_rdev = tmp_dev;

        }

    }

    return err;

}
",240,"static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)

{

    int gr;

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    gr =  lstat(rpath(fs_ctx, path, buffer), stbuf);

    if (gr) {

        return gr;

    }

    if (fs_ctx->fs_sm == SM_MAPPED) {

        /* Actual credentials are part of extended attrs */

        uid_t tmp_uid;

        gid_t tmp_gid;

        mode_t tmp_mode;

        dev_t tmp_diff;

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.uid"", &tmp_uid,

                    sizeof(uid_t)) > 0) {

            stbuf->st_uid = tmp_uid;

        }

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.gid"", &tmp_gid,

                    sizeof(gid_t)) > 0) {

            stbuf->st_gid = tmp_gid;

        }

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.mode"",

                    &tmp_mode, sizeof(mode_t)) > 0) {

            stbuf->st_mode = tmp_mode;

        }

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.rdev"", &tmp_diff,

                        sizeof(dev_t)) > 0) {

                stbuf->st_rdev = tmp_diff;

        }

    }

    return gr;

}
",LABEL_0,LABEL_0,LABEL_1,1,"fs_ctx,fs_path,stbuf,err,buffer,path,tmp_uid,tmp_gid,tmp_mode,tmp_dev","fs_ctx:-0.00016033649444580078,fs_path:-0.000383913516998291,stbuf:-0.000822603702545166,err:3.7610530853271484e-05,buffer:-0.0006838440895080566,path:-0.000789344310760498,tmp_uid:-0.00022912025451660156,tmp_gid:-0.00016564130783081055,tmp_mode:-0.0002428889274597168,tmp_dev:-6.16908073425293e-05,",2,8,0,"err:gr,tmp_dev:tmp_diff,",0,Greedy,139,0.05135767459869385,replace,[]
107,"static int allocate_buffers(ALACContext *alac)

{

    int ch;

    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {

        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);



        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],

                         buf_size, buf_alloc_fail);



        if (alac->sample_size == 16) {

            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],

                             buf_size, buf_alloc_fail);

        }



        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],

                         buf_size, buf_alloc_fail);

    }

    return 0;

buf_alloc_fail:

    alac_decode_close(alac->avctx);

    return AVERROR(ENOMEM);

}
",140,"static int allocate_buffers(ALACContext *palmac)

{

    int sch;

    for (sch = 0; sch < FFMIN(palmac->channels, 2); sch++) {

        int buf_size = palmac->max_samples_per_frame * sizeof(int32_t);



        FF_ALLOC_OR_GOTO(palmac->avctx, palmac->predict_error_buffer[sch],

                         buf_size, buf_alloc_fail);



        if (palmac->sample_size == 16) {

            FF_ALLOC_OR_GOTO(palmac->avctx, palmac->output_samples_buffer[sch],

                             buf_size, buf_alloc_fail);

        }



        FF_ALLOC_OR_GOTO(palmac->avctx, palmac->extra_bits_buffer[sch],

                         buf_size, buf_alloc_fail);

    }

    return 0;

buf_alloc_fail:

    alac_decode_close(palmac->avctx);

    return AVERROR(ENOMEM);

}
",LABEL_0,LABEL_0,LABEL_1,1,"alac,ch","alac:0.00017076730728149414,ch:9.649991989135742e-05,",2,18,0,"alac:palmac,ch:sch,",0,Greedy,175,0.06315826177597046,replace,[]
108,"static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)

{

    MpegTSWrite *ts = s->priv_data;

    uint8_t data[1012], *q, *desc_length_ptr, *program_info_length_ptr;

    int val, stream_type, i;



    q = data;

    put16(&q, 0xe000 | service->pcr_pid);



    program_info_length_ptr = q;

    q += 2; /* patched after */



    /* put program info here */



    val = 0xf000 | (q - program_info_length_ptr - 2);

    program_info_length_ptr[0] = val >> 8;

    program_info_length_ptr[1] = val;



    for(i = 0; i < s->nb_streams; i++) {

        AVStream *st = s->streams[i];

        MpegTSWriteStream *ts_st = st->priv_data;

        AVDictionaryEntry *lang = av_dict_get(st->metadata, ""language"", NULL,0);

        switch(st->codec->codec_id) {

        case AV_CODEC_ID_MPEG1VIDEO:

        case AV_CODEC_ID_MPEG2VIDEO:

            stream_type = STREAM_TYPE_VIDEO_MPEG2;

            break;

        case AV_CODEC_ID_MPEG4:

            stream_type = STREAM_TYPE_VIDEO_MPEG4;

            break;

        case AV_CODEC_ID_H264:

            stream_type = STREAM_TYPE_VIDEO_H264;

            break;

        case AV_CODEC_ID_CAVS:

            stream_type = STREAM_TYPE_VIDEO_CAVS;

            break;

        case AV_CODEC_ID_DIRAC:

            stream_type = STREAM_TYPE_VIDEO_DIRAC;

            break;

        case AV_CODEC_ID_MP2:

        case AV_CODEC_ID_MP3:

            stream_type = STREAM_TYPE_AUDIO_MPEG1;

            break;

        case AV_CODEC_ID_AAC:

            stream_type = (ts->flags & MPEGTS_FLAG_AAC_LATM) ? STREAM_TYPE_AUDIO_AAC_LATM : STREAM_TYPE_AUDIO_AAC;

            break;

        case AV_CODEC_ID_AAC_LATM:

            stream_type = STREAM_TYPE_AUDIO_AAC_LATM;

            break;

        case AV_CODEC_ID_AC3:

            stream_type = STREAM_TYPE_AUDIO_AC3;

            break;

        default:

            stream_type = STREAM_TYPE_PRIVATE_DATA;

            break;

        }

        *q++ = stream_type;

        put16(&q, 0xe000 | ts_st->pid);

        desc_length_ptr = q;

        q += 2; /* patched after */



        /* write optional descriptors here */

        switch(st->codec->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            if(st->codec->codec_id==AV_CODEC_ID_EAC3){

                *q++=0x7a; // EAC3 descriptor see A038 DVB SI

                *q++=1; // 1 byte, all flags sets to 0

                *q++=0; // omit all fields...

            }

            if(st->codec->codec_id==AV_CODEC_ID_S302M){

                *q++ = 0x05; /* MPEG-2 registration descriptor*/

                *q++ = 4;

                *q++ = 'B';

                *q++ = 'S';

                *q++ = 'S';

                *q++ = 'D';

            }



            if (lang) {

                char *p;

                char *next = lang->value;

                uint8_t *len_ptr;



                *q++ = 0x0a; /* ISO 639 language descriptor */

                len_ptr = q++;

                *len_ptr = 0;



                for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) {

                    next = strchr(p, ',');

                    if (strlen(p) != 3 && (!next || next != p + 3))

                        continue; /* not a 3-letter code */



                    *q++ = *p++;

                    *q++ = *p++;

                    *q++ = *p++;



                if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS)

                    *q++ = 0x01;

                else if (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED)

                    *q++ = 0x02;

                else if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED)

                    *q++ = 0x03;

                else

                    *q++ = 0; /* undefined type */



                    *len_ptr += 4;

                }



                if (*len_ptr == 0)

                    q -= 2; /* no language codes were written */

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            {

                const char default_language[] = ""und"";

                const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language;



                if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {

                    uint8_t *len_ptr;

                    int extradata_copied = 0;



                    *q++ = 0x59; /* subtitling_descriptor */

                    len_ptr = q++;



                    while (strlen(language) >= 3 && (sizeof(data) - (q - data)) >= 8) { /* 8 bytes per DVB subtitle substream data */

                        *q++ = *language++;

                        *q++ = *language++;

                        *q++ = *language++;

                        /* Skip comma */

                        if (*language != '\0')

                            language++;



                        if (st->codec->extradata_size - extradata_copied >= 5) {

                            *q++ = st->codec->extradata[extradata_copied + 4]; /* subtitling_type */

                            memcpy(q, st->codec->extradata + extradata_copied, 4); /* composition_page_id and ancillary_page_id */

                            extradata_copied += 5;

                            q += 4;

                        } else {

                            /* subtitling_type:

                             * 0x10 - normal with no monitor aspect ratio criticality

                             * 0x20 - for the hard of hearing with no monitor aspect ratio criticality */

                            *q++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10;

                            if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) {

                                /* support of old 4-byte extradata format */

                                memcpy(q, st->codec->extradata, 4); /* composition_page_id and ancillary_page_id */

                                extradata_copied += 4;

                                q += 4;

                            } else {

                                put16(&q, 1); /* composition_page_id */

                                put16(&q, 1); /* ancillary_page_id */

                            }

                        }

                    }



                    *len_ptr = q - len_ptr - 1;

                } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) {

                    uint8_t *len_ptr = NULL;

                    int extradata_copied = 0;



                    /* The descriptor tag. teletext_descriptor */

                    *q++ = 0x56;

                    len_ptr = q++;



                    while (strlen(language) >= 3) {

                        *q++ = *language++;

                        *q++ = *language++;

                        *q++ = *language++;

                        /* Skip comma */

                        if (*language != '\0')

                            language++;



                        if (st->codec->extradata_size - 1 > extradata_copied) {

                            memcpy(q, st->codec->extradata + extradata_copied, 2);

                            extradata_copied += 2;

                            q += 2;

                        } else {

                            /* The Teletext descriptor:

                             * teletext_type: This 5-bit field indicates the type of Teletext page indicated. (0x01 Initial Teletext page)

                             * teletext_magazine_number: This is a 3-bit field which identifies the magazine number.

                             * teletext_page_number: This is an 8-bit field giving two 4-bit hex digits identifying the page number. */

                            *q++ = 0x08;

                            *q++ = 0x00;

                        }

                    }



                    *len_ptr = q - len_ptr - 1;

                 }

            }

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (stream_type == STREAM_TYPE_VIDEO_DIRAC) {

                *q++ = 0x05; /*MPEG-2 registration descriptor*/

                *q++ = 4;

                *q++ = 'd';

                *q++ = 'r';

                *q++ = 'a';

                *q++ = 'c';

            }

            break;

        case AVMEDIA_TYPE_DATA:

            if (st->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) {

                *q++ = 0x05; /* MPEG-2 registration descriptor */

                *q++ = 4;

                *q++ = 'K';

                *q++ = 'L';

                *q++ = 'V';

                *q++ = 'A';

            }

            break;

        }



        val = 0xf000 | (q - desc_length_ptr - 2);

        desc_length_ptr[0] = val >> 8;

        desc_length_ptr[1] = val;

    }

    mpegts_write_section1(&service->pmt, PMT_TID, service->sid, ts->tables_version, 0, 0,

                          data, q - data);

}
",1537,"static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)

{

    MpegTSWrite *ts = s->priv_data;

    uint8_t data[1012], *qs, *desc_length_ptr, *program_info_length_ptr;

    int val, stream_type, v;



    qs = data;

    put16(&qs, 0xe000 | service->pcr_pid);



    program_info_length_ptr = qs;

    qs += 2; /* patched after */



    /* put program info here */



    val = 0xf000 | (qs - program_info_length_ptr - 2);

    program_info_length_ptr[0] = val >> 8;

    program_info_length_ptr[1] = val;



    for(v = 0; v < s->nb_streams; v++) {

        AVStream *stal = s->streams[v];

        MpegTSWriteStream *ts_st = stal->priv_data;

        AVDictionaryEntry *lang = av_dict_get(stal->metadata, ""language"", NULL,0);

        switch(stal->codec->codec_id) {

        case AV_CODEC_ID_MPEG1VIDEO:

        case AV_CODEC_ID_MPEG2VIDEO:

            stream_type = STREAM_TYPE_VIDEO_MPEG2;

            break;

        case AV_CODEC_ID_MPEG4:

            stream_type = STREAM_TYPE_VIDEO_MPEG4;

            break;

        case AV_CODEC_ID_H264:

            stream_type = STREAM_TYPE_VIDEO_H264;

            break;

        case AV_CODEC_ID_CAVS:

            stream_type = STREAM_TYPE_VIDEO_CAVS;

            break;

        case AV_CODEC_ID_DIRAC:

            stream_type = STREAM_TYPE_VIDEO_DIRAC;

            break;

        case AV_CODEC_ID_MP2:

        case AV_CODEC_ID_MP3:

            stream_type = STREAM_TYPE_AUDIO_MPEG1;

            break;

        case AV_CODEC_ID_AAC:

            stream_type = (ts->flags & MPEGTS_FLAG_AAC_LATM) ? STREAM_TYPE_AUDIO_AAC_LATM : STREAM_TYPE_AUDIO_AAC;

            break;

        case AV_CODEC_ID_AAC_LATM:

            stream_type = STREAM_TYPE_AUDIO_AAC_LATM;

            break;

        case AV_CODEC_ID_AC3:

            stream_type = STREAM_TYPE_AUDIO_AC3;

            break;

        default:

            stream_type = STREAM_TYPE_PRIVATE_DATA;

            break;

        }

        *qs++ = stream_type;

        put16(&qs, 0xe000 | ts_st->pid);

        desc_length_ptr = qs;

        qs += 2; /* patched after */



        /* write optional descriptors here */

        switch(stal->codec->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            if(stal->codec->codec_id==AV_CODEC_ID_EAC3){

                *qs++=0x7a; // EAC3 descriptor see A038 DVB SI

                *qs++=1; // 1 byte, all flags sets to 0

                *qs++=0; // omit all fields...

            }

            if(stal->codec->codec_id==AV_CODEC_ID_S302M){

                *qs++ = 0x05; /* MPEG-2 registration descriptor*/

                *qs++ = 4;

                *qs++ = 'B';

                *qs++ = 'S';

                *qs++ = 'S';

                *qs++ = 'D';

            }



            if (lang) {

                char *p;

                char *next = lang->value;

                uint8_t *len_ptr;



                *qs++ = 0x0a; /* ISO 639 language descriptor */

                len_ptr = qs++;

                *len_ptr = 0;



                for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) {

                    next = strchr(p, ',');

                    if (strlen(p) != 3 && (!next || next != p + 3))

                        continue; /* not a 3-letter code */



                    *qs++ = *p++;

                    *qs++ = *p++;

                    *qs++ = *p++;



                if (stal->disposition & AV_DISPOSITION_CLEAN_EFFECTS)

                    *qs++ = 0x01;

                else if (stal->disposition & AV_DISPOSITION_HEARING_IMPAIRED)

                    *qs++ = 0x02;

                else if (stal->disposition & AV_DISPOSITION_VISUAL_IMPAIRED)

                    *qs++ = 0x03;

                else

                    *qs++ = 0; /* undefined type */



                    *len_ptr += 4;

                }



                if (*len_ptr == 0)

                    qs -= 2; /* no language codes were written */

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            {

                const char default_language[] = ""und"";

                const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language;



                if (stal->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {

                    uint8_t *len_ptr;

                    int extradata_copied = 0;



                    *qs++ = 0x59; /* subtitling_descriptor */

                    len_ptr = qs++;



                    while (strlen(language) >= 3 && (sizeof(data) - (qs - data)) >= 8) { /* 8 bytes per DVB subtitle substream data */

                        *qs++ = *language++;

                        *qs++ = *language++;

                        *qs++ = *language++;

                        /* Skip comma */

                        if (*language != '\0')

                            language++;



                        if (stal->codec->extradata_size - extradata_copied >= 5) {

                            *qs++ = stal->codec->extradata[extradata_copied + 4]; /* subtitling_type */

                            memcpy(qs, stal->codec->extradata + extradata_copied, 4); /* composition_page_id and ancillary_page_id */

                            extradata_copied += 5;

                            qs += 4;

                        } else {

                            /* subtitling_type:

                             * 0x10 - normal with no monitor aspect ratio criticality

                             * 0x20 - for the hard of hearing with no monitor aspect ratio criticality */

                            *qs++ = (stal->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10;

                            if ((stal->codec->extradata_size == 4) && (extradata_copied == 0)) {

                                /* support of old 4-byte extradata format */

                                memcpy(qs, stal->codec->extradata, 4); /* composition_page_id and ancillary_page_id */

                                extradata_copied += 4;

                                qs += 4;

                            } else {

                                put16(&qs, 1); /* composition_page_id */

                                put16(&qs, 1); /* ancillary_page_id */

                            }

                        }

                    }



                    *len_ptr = qs - len_ptr - 1;

                } else if (stal->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) {

                    uint8_t *len_ptr = NULL;

                    int extradata_copied = 0;



                    /* The descriptor tag. teletext_descriptor */

                    *qs++ = 0x56;

                    len_ptr = qs++;



                    while (strlen(language) >= 3) {

                        *qs++ = *language++;

                        *qs++ = *language++;

                        *qs++ = *language++;

                        /* Skip comma */

                        if (*language != '\0')

                            language++;



                        if (stal->codec->extradata_size - 1 > extradata_copied) {

                            memcpy(qs, stal->codec->extradata + extradata_copied, 2);

                            extradata_copied += 2;

                            qs += 2;

                        } else {

                            /* The Teletext descriptor:

                             * teletext_type: This 5-bit field indicates the type of Teletext page indicated. (0x01 Initial Teletext page)

                             * teletext_magazine_number: This is a 3-bit field which identifies the magazine number.

                             * teletext_page_number: This is an 8-bit field giving two 4-bit hex digits identifying the page number. */

                            *qs++ = 0x08;

                            *qs++ = 0x00;

                        }

                    }



                    *len_ptr = qs - len_ptr - 1;

                 }

            }

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (stream_type == STREAM_TYPE_VIDEO_DIRAC) {

                *qs++ = 0x05; /*MPEG-2 registration descriptor*/

                *qs++ = 4;

                *qs++ = 'd';

                *qs++ = 'r';

                *qs++ = 'a';

                *qs++ = 'c';

            }

            break;

        case AVMEDIA_TYPE_DATA:

            if (stal->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) {

                *qs++ = 0x05; /* MPEG-2 registration descriptor */

                *qs++ = 4;

                *qs++ = 'K';

                *qs++ = 'L';

                *qs++ = 'V';

                *qs++ = 'A';

            }

            break;

        }



        val = 0xf000 | (qs - desc_length_ptr - 2);

        desc_length_ptr[0] = val >> 8;

        desc_length_ptr[1] = val;

    }

    mpegts_write_section1(&service->pmt, PMT_TID, service->sid, ts->tables_version, 0, 0,

                          data, qs - data);

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,service,ts,data,q,desc_length_ptr,program_info_length_ptr,val,stream_type,i,st,ts_st,lang","s:0.4094110131263733,service:0.207236647605896,ts:0.21227651834487915,data:0.2133442759513855,q:2.6810669898986816,desc_length_ptr:0.19719725847244263,program_info_length_ptr:0.03641092777252197,val:0.4005224108695984,stream_type:-0.0044103264808654785,i:0.5417906045913696,st:0.774696946144104,ts_st:0.0034912824630737305,lang:0.4516626000404358,",3,94,0,"q:qs,st:stal,i:v,",0,Greedy,287,0.1518547773361206,replace,[]
109,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,

                             uint32_t token, uint32_t nargs, target_ulong args,

                             uint32_t nret, target_ulong rets)

{

    if ((token >= TOKEN_BASE)

        && ((token - TOKEN_BASE) < TOKEN_MAX)) {

        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);



        if (call->fn) {

            call->fn(spapr, token, nargs, args, nret, rets);

            return H_SUCCESS;

        }

    }



    /* HACK: Some Linux early debug code uses RTAS display-character,

     * but assumes the token value is 0xa (which it is on some real

     * machines) without looking it up in the device tree.  This

     * special case makes this work */

    if (token == 0xa) {

        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);

        return H_SUCCESS;

    }



    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);

    rtas_st(rets, 0, -3);

    return H_PARAMETER;

}
",193,,LABEL_0,LABEL_1,,-4,"spapr,token,nargs,args,nret,rets,call",,,,0,,0,Greedy,1,0.0005395531654357911,,
110,"_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,

          const struct timespec *,tsp,int,flags)

#endif

#endif /* CONFIG_UTIMENSAT  */



#ifdef CONFIG_INOTIFY

#include <sys/inotify.h>



#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)

static int sys_inotify_init(void)

{

  return (inotify_init());

}
",42,,LABEL_0,LABEL_0,,-3,,,,,0,,0,Greedy,1,0.00043391784032185873,,
111,"static void co_write_request(void *opaque)

{

    BDRVSheepdogState *s = opaque;



    qemu_coroutine_enter(s->co_send, NULL);

}
",28,"static void co_write_request(void *opaque)

{

    BDRVSheepdogState *socket = opaque;



    qemu_coroutine_enter(socket->co_send, NULL);

}
",LABEL_1,LABEL_1,LABEL_0,1,"opaque,s","opaque:0.0001717209815979004,s:0.0002307295799255371,",1,2,0,"s:socket,",0,Greedy,45,0.015707806746164957,replace,[]
112,"static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)

{

    InputStream  *ist = s->opaque;

    DXVA2Context *ctx = ist->hwaccel_ctx;



    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);

}
",50,"static int dxva2_get_buffer(AVCodecContext *sl, AVFrame *data, int ants)

{

    InputStream  *isc = sl->opaque;

    DXVA2Context *ctx = isc->hwaccel_ctx;



    return av_hwframe_get_buffer(ctx->hw_frames_ctx, data, 0);

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,frame,flags,ist,ctx","s:4.5180320739746094e-05,frame:-2.0563602447509766e-05,flags:-3.30805778503418e-05,ist:8.821487426757812e-06,ctx:-8.159875869750977e-05,",4,7,0,"s:sl,ist:isc,frame:data,flags:ants,",0,Greedy,155,0.054219595591227215,replace,[]
113,"int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,

                              const char *default_model)

{

    int i, exit_status = 0;



    if (!nd->model)

        nd->model = strdup(default_model);



    if (strcmp(nd->model, ""?"") != 0) {

        for (i = 0 ; models[i]; i++)

            if (strcmp(nd->model, models[i]) == 0)

                return i;



        fprintf(stderr, ""qemu: Unsupported NIC model: %s\n"", nd->model);

        exit_status = 1;

    }



    fprintf(stderr, ""qemu: Supported NIC models: "");

    for (i = 0 ; models[i]; i++)

        fprintf(stderr, ""%s%c"", models[i], models[i+1] ? ',' : '\n');



    exit(exit_status);

}
",172,"int qemu_check_nic_model_list(NICInfo *dd, const char * const *features,

                              const char *default_model)

{

    int phi, exit_status = 0;



    if (!nd->model)

        dd->model = strdup(default_model);



    if (strcmp(dd->model, ""?"") != 0) {

        for (phi = 0 ; features[phi]; phi++)

            if (strcmp(dd->model, features[phi]) == 0)

                return phi;



        fprintf(stderr, ""qemu: Unsupported NIC model: %s
"", dd->model);

        exit_status = 1;

    }



    fprintf(stderr, ""qemu: Supported NIC models: "");

    for (phi = 0 ; features[phi]; phi++)

        fprintf(stderr, ""%s%c"", features[phi], features[phi+1] ? ',' : '
');



    exit(exit_status);

}
",LABEL_1,LABEL_1,LABEL_0,1,"nd,models,default_model,i","nd:0.00043833255767822266,models:0.00046509504318237305,default_model:0.0001577138900756836,i:0.0005372166633605957,",3,22,0,"i:phi,models:features,nd:dd,",0,Greedy,224,0.08147231340408326,replace,[]
114,"static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)

{

    NvmeNamespace *ns;

    uint32_t nsid = le32_to_cpu(cmd->nsid);



    if (nsid == 0 || nsid > n->num_namespaces) {

        return NVME_INVALID_NSID | NVME_DNR;

    }



    ns = &n->namespaces[nsid - 1];

    switch (cmd->opcode) {

    case NVME_CMD_FLUSH:

        return nvme_flush(n, ns, cmd, req);

    case NVME_CMD_WRITE_ZEROS:

        return nvme_write_zeros(n, ns, cmd, req);

    case NVME_CMD_WRITE:

    case NVME_CMD_READ:

        return nvme_rw(n, ns, cmd, req);

    default:

        return NVME_INVALID_OPCODE | NVME_DNR;

    }

}
",133,,LABEL_1,LABEL_0,,-4,"n,cmd,req,ns",,,,0,,0,Greedy,1,0.0005107879638671875,,
115,"void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)

{

    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);

    object_unparent(OBJECT(&pbdev->iommu_mr));

    pbdev->iommu_enabled = false;

}
",43,,LABEL_0,LABEL_0,LABEL_0,-1,pbdev,,1,5,0,,0,GA,265,0.09297465880711873,failed,[]
116,"static int mpegts_write_header(AVFormatContext *s)

{

    MpegTSWrite *ts = s->priv_data;

    MpegTSWriteStream *ts_st;

    MpegTSService *service;

    AVStream *st, *pcr_st = NULL;

    AVDictionaryEntry *title, *provider;

    int i, j;

    const char *service_name;

    const char *provider_name;

    int *pids;

    int ret;



    if (s->max_delay < 0) /* Not set by the caller */

        s->max_delay = 0;



    // round up to a whole number of TS packets

    ts->pes_payload_size = (ts->pes_payload_size + 14 + 183) / 184 * 184 - 14;



    ts->tsid = ts->transport_stream_id;

    ts->onid = ts->original_network_id;

    /* allocate a single DVB service */

    title = av_dict_get(s->metadata, ""service_name"", NULL, 0);

    if (!title)

        title = av_dict_get(s->metadata, ""title"", NULL, 0);

    service_name  = title ? title->value : DEFAULT_SERVICE_NAME;

    provider      = av_dict_get(s->metadata, ""service_provider"", NULL, 0);

    provider_name = provider ? provider->value : DEFAULT_PROVIDER_NAME;

    service       = mpegts_add_service(ts, ts->service_id,

                                       provider_name, service_name);



    if (!service)

        return AVERROR(ENOMEM);



    service->pmt.write_packet = section_write_packet;

    service->pmt.opaque       = s;

    service->pmt.cc           = 15;



    ts->pat.pid          = PAT_PID;

    /* Initialize at 15 so that it wraps and is equal to 0 for the

     * first packet we write. */

    ts->pat.cc           = 15;

    ts->pat.write_packet = section_write_packet;

    ts->pat.opaque       = s;



    ts->sdt.pid          = SDT_PID;

    ts->sdt.cc           = 15;

    ts->sdt.write_packet = section_write_packet;

    ts->sdt.opaque       = s;



    pids = av_malloc_array(s->nb_streams, sizeof(*pids));

    if (!pids) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }



    /* assign pids to each stream */

    for (i = 0; i < s->nb_streams; i++) {

        st = s->streams[i];



        ts_st = av_mallocz(sizeof(MpegTSWriteStream));

        if (!ts_st) {

            ret = AVERROR(ENOMEM);

            goto fail;

        }

        st->priv_data = ts_st;



        ts_st->user_tb = st->time_base;

        avpriv_set_pts_info(st, 33, 1, 90000);



        ts_st->payload = av_mallocz(ts->pes_payload_size);

        if (!ts_st->payload) {

            ret = AVERROR(ENOMEM);

            goto fail;

        }

        ts_st->service = service;

        /* MPEG pid values < 16 are reserved. Applications which set st->id in

         * this range are assigned a calculated pid. */

        if (st->id < 16) {

            ts_st->pid = ts->start_pid + i;

        } else if (st->id < 0x1FFF) {

            ts_st->pid = st->id;

        } else {

            av_log(s, AV_LOG_ERROR,

                   ""Invalid stream id %d, must be less than 8191\n"", st->id);

            ret = AVERROR(EINVAL);

            goto fail;

        }

        if (ts_st->pid == service->pmt.pid) {

            av_log(s, AV_LOG_ERROR, ""Duplicate stream id %d\n"", ts_st->pid);

            ret = AVERROR(EINVAL);

            goto fail;

        }

        for (j = 0; j < i; j++) {

            if (pids[j] == ts_st->pid) {

                av_log(s, AV_LOG_ERROR, ""Duplicate stream id %d\n"", ts_st->pid);

                ret = AVERROR(EINVAL);

                goto fail;

            }

        }

        pids[i]                = ts_st->pid;

        ts_st->payload_pts     = AV_NOPTS_VALUE;

        ts_st->payload_dts     = AV_NOPTS_VALUE;

        ts_st->first_pts_check = 1;

        ts_st->cc              = 15;

        /* update PCR pid by using the first video stream */

        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

            service->pcr_pid == 0x1fff) {

            service->pcr_pid = ts_st->pid;

            pcr_st           = st;

        }

        if (st->codec->codec_id == AV_CODEC_ID_AAC &&

            st->codec->extradata_size > 0) {

            AVStream *ast;

            ts_st->amux = avformat_alloc_context();

            if (!ts_st->amux) {

                ret = AVERROR(ENOMEM);

                goto fail;

            }

            ts_st->amux->oformat =

                av_guess_format((ts->flags & MPEGTS_FLAG_AAC_LATM) ? ""latm"" : ""adts"",

                                NULL, NULL);

            if (!ts_st->amux->oformat) {

                ret = AVERROR(EINVAL);

                goto fail;

            }

            if (!(ast = avformat_new_stream(ts_st->amux, NULL))) {

                ret = AVERROR(ENOMEM);

                goto fail;

            }

            ret = avcodec_copy_context(ast->codec, st->codec);

            if (ret != 0)

                goto fail;

            ast->time_base = st->time_base;

            ret = avformat_write_header(ts_st->amux, NULL);

            if (ret < 0)

                goto fail;

        }

        if (st->codec->codec_id == AV_CODEC_ID_OPUS) {

            ts_st->opus_pending_trim_start = st->codec->initial_padding * 48000 / st->codec->sample_rate;

        }

    }



    av_freep(&pids);



    /* if no video stream, use the first stream as PCR */

    if (service->pcr_pid == 0x1fff && s->nb_streams > 0) {

        pcr_st           = s->streams[0];

        ts_st            = pcr_st->priv_data;

        service->pcr_pid = ts_st->pid;

    } else

        ts_st = pcr_st->priv_data;



    if (ts->mux_rate > 1) {

        service->pcr_packet_period = (ts->mux_rate * ts->pcr_period) /

                                     (TS_PACKET_SIZE * 8 * 1000);

        ts->sdt_packet_period      = (ts->mux_rate * SDT_RETRANS_TIME) /

                                     (TS_PACKET_SIZE * 8 * 1000);

        ts->pat_packet_period      = (ts->mux_rate * PAT_RETRANS_TIME) /

                                     (TS_PACKET_SIZE * 8 * 1000);



        if (ts->copyts < 1)

            ts->first_pcr = av_rescale(s->max_delay, PCR_TIME_BASE, AV_TIME_BASE);

    } else {

        /* Arbitrary values, PAT/PMT will also be written on video key frames */

        ts->sdt_packet_period = 200;

        ts->pat_packet_period = 40;

        if (pcr_st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {

            if (!pcr_st->codec->frame_size) {

                av_log(s, AV_LOG_WARNING, ""frame size not set\n"");

                service->pcr_packet_period =

                    pcr_st->codec->sample_rate / (10 * 512);

            } else {

                service->pcr_packet_period =

                    pcr_st->codec->sample_rate / (10 * pcr_st->codec->frame_size);

            }

        } else {

            // max delta PCR 0.1s

            // TODO: should be avg_frame_rate

            service->pcr_packet_period =

                ts_st->user_tb.den / (10 * ts_st->user_tb.num);

        }

        if (!service->pcr_packet_period)

            service->pcr_packet_period = 1;

    }



    ts->last_pat_ts = AV_NOPTS_VALUE;

    ts->last_sdt_ts = AV_NOPTS_VALUE;

    // The user specified a period, use only it

    if (ts->pat_period < INT_MAX/2) {

        ts->pat_packet_period = INT_MAX;

    }

    if (ts->sdt_period < INT_MAX/2) {

        ts->sdt_packet_period = INT_MAX;

    }



    // output a PCR as soon as possible

    service->pcr_packet_count = service->pcr_packet_period;

    ts->pat_packet_count      = ts->pat_packet_period - 1;

    ts->sdt_packet_count      = ts->sdt_packet_period - 1;



    if (ts->mux_rate == 1)

        av_log(s, AV_LOG_VERBOSE, ""muxrate VBR, "");

    else

        av_log(s, AV_LOG_VERBOSE, ""muxrate %d, "", ts->mux_rate);

    av_log(s, AV_LOG_VERBOSE,

           ""pcr every %d pkts, sdt every %d, pat/pmt every %d pkts\n"",

           service->pcr_packet_period,

           ts->sdt_packet_period, ts->pat_packet_period);



    if (ts->m2ts_mode == -1) {

        if (av_match_ext(s->filename, ""m2ts"")) {

            ts->m2ts_mode = 1;

        } else {

            ts->m2ts_mode = 0;

        }

    }



    return 0;



fail:

    av_freep(&pids);

    for (i = 0; i < s->nb_streams; i++) {

        st    = s->streams[i];

        ts_st = st->priv_data;

        if (ts_st) {

            av_freep(&ts_st->payload);

            if (ts_st->amux) {

                avformat_free_context(ts_st->amux);

                ts_st->amux = NULL;

            }

        }

        av_freep(&st->priv_data);

    }



    for (i = 0; i < ts->nb_services; i++) {

        service = ts->services[i];

        av_freep(&service->provider_name);

        av_freep(&service->name);

        av_freep(&service);

    }

    av_freep(&ts->services);

    return ret;

}
",1814,,LABEL_1,LABEL_0,,-4,"s,ts,ts_st,service,st,pcr_st,title,provider,i,j,service_name,provider_name,pids,ret",,,,0,,0,Greedy,1,0.0015258193016052246,,
117,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    int64_t start, size, last_size;

    start= url_ftell(bc) - prefix_length;



    if(start != nut->packet_start + nut->written_packet_size){

        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);



    size= get_v(bc);

    last_size= get_v(bc);

    if(nut->written_packet_size != last_size){

        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);

        return -1;

    }



    nut->last_packet_start = nut->packet_start;

    nut->packet_start = start;

    nut->written_packet_size= size;



    return size;

}
",176,"static int get_packetheader(NUTContext *gob, ByteIOContext *mac, int prefixlenlength, int calculate_ckssum)

{

    int64_t index, grow, last24address;

    index= url_ftell(mac) - prefixlenlength;



    if(index != gob->packet_start + gob->written_packet_size){

        av_log(gob->avf, AV_LOG_ERROR, ""get_packetheader called at weird position
"");

        return -1;

    }

    

    if(calculate_ckssum)

        init_checksum(mac, update_adler32, 0);



    grow= get_v(mac);

    last24address= get_v(mac);

    if(gob->written_packet_size != last24address){

        av_log(gob->avf, AV_LOG_ERROR, ""packet grow missmatch %d != %lld at %lld
"", gob->written_packet_size, last24address, index);

        return -1;

    }



    gob->last_packet_start = gob->packet_start;

    gob->packet_start = index;

    gob->written_packet_size= grow;



    return grow;

}
",LABEL_0,LABEL_0,LABEL_1,1,"nut,bc,prefix_length,calculate_checksum,start,size,last_size","nut:-0.0034990906715393066,bc:-0.0013918876647949219,prefix_length:0.00015813112258911133,calculate_checksum:-0.0009291172027587891,start:-0.0007647275924682617,size:-0.0010624527931213379,last_size:-0.0006073117256164551,",7,34,0,"prefix_length:prefixlenlength,last_size:last24address,start:index,calculate_checksum:calculate_ckssum,size:grow,bc:mac,nut:gob,",0,Greedy,329,0.1207766056060791,replace,[]
118,"static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s,

                                                     PutBitContext *pb, const float *in, float *out,

                                                     const float *scaled, int size, int scale_idx,

                                                     int cb, const float lambda, const float uplim,

                                                     int *bits, const float ROUNDING)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    int i;

    int qc1, qc2, qc3, qc4;



    uint8_t  *p_bits  = (uint8_t  *)ff_aac_spectral_bits[cb-1];

    uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1];

    float    *p_vec   = (float    *)ff_aac_codebook_vectors[cb-1];



    abs_pow34_v(s->scoefs, in, size);

    scaled = s->scoefs;

    for (i = 0; i < size; i += 4) {

        int curidx, curidx2;

        int *in_int = (int *)&in[i];

        uint8_t v_bits;

        unsigned int v_codes;

        int t0, t1, t2, t3, t4, t5, t6, t7;

        const float *vec1, *vec2;



        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;

        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;

        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;

        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;



        __asm__ volatile (

            "".set push                      \n\t""

            "".set noreorder                 \n\t""



            ""ori    %[t4],  $zero,  4       \n\t""

            ""slt    %[t0],  %[t4],  %[qc1]  \n\t""

            ""slt    %[t1],  %[t4],  %[qc2]  \n\t""

            ""slt    %[t2],  %[t4],  %[qc3]  \n\t""

            ""slt    %[t3],  %[t4],  %[qc4]  \n\t""

            ""movn   %[qc1], %[t4],  %[t0]   \n\t""

            ""movn   %[qc2], %[t4],  %[t1]   \n\t""

            ""movn   %[qc3], %[t4],  %[t2]   \n\t""

            ""movn   %[qc4], %[t4],  %[t3]   \n\t""

            ""lw     %[t0],  0(%[in_int])    \n\t""

            ""lw     %[t1],  4(%[in_int])    \n\t""

            ""lw     %[t2],  8(%[in_int])    \n\t""

            ""lw     %[t3],  12(%[in_int])   \n\t""

            ""srl    %[t0],  %[t0],  31      \n\t""

            ""srl    %[t1],  %[t1],  31      \n\t""

            ""srl    %[t2],  %[t2],  31      \n\t""

            ""srl    %[t3],  %[t3],  31      \n\t""

            ""subu   %[t4],  $zero,  %[qc1]  \n\t""

            ""subu   %[t5],  $zero,  %[qc2]  \n\t""

            ""subu   %[t6],  $zero,  %[qc3]  \n\t""

            ""subu   %[t7],  $zero,  %[qc4]  \n\t""

            ""movn   %[qc1], %[t4],  %[t0]   \n\t""

            ""movn   %[qc2], %[t5],  %[t1]   \n\t""

            ""movn   %[qc3], %[t6],  %[t2]   \n\t""

            ""movn   %[qc4], %[t7],  %[t3]   \n\t""



            "".set pop                       \n\t""



            : [qc1]""+r""(qc1), [qc2]""+r""(qc2),

              [qc3]""+r""(qc3), [qc4]""+r""(qc4),

              [t0]""=&r""(t0), [t1]""=&r""(t1), [t2]""=&r""(t2), [t3]""=&r""(t3),

              [t4]""=&r""(t4), [t5]""=&r""(t5), [t6]""=&r""(t6), [t7]""=&r""(t7)

            : [in_int]""r""(in_int)

            : ""memory""

        );



        curidx = 9 * qc1;

        curidx += qc2 + 40;



        curidx2 = 9 * qc3;

        curidx2 += qc4 + 40;



        v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]);

        v_bits  = p_bits[curidx] + p_bits[curidx2];

        put_bits(pb, v_bits, v_codes);



        if (out) {

           vec1 = &p_vec[curidx*2 ];

           vec2 = &p_vec[curidx2*2];

           out[i+0] = vec1[0] * IQ;

           out[i+1] = vec1[1] * IQ;

           out[i+2] = vec2[0] * IQ;

           out[i+3] = vec2[1] * IQ;

        }

    }

}
",939,"static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s,

                                                     PutBitContext *gb, const float *in, float *external,

                                                     const float *scaled, int size, int scale_idx,

                                                     int cb, const float phi, const float ublen,

                                                     int *bis, const float BroundED)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    int i;

    int qpc5, qcc92, qlc3, qrc44;



    uint8_t  *p_bit  = (uint8_t  *)ff_aac_spectral_bits[cb-1];

    uint16_t *p_code = (uint16_t *)ff_aac_spectral_codes[cb-1];

    float    *p_norm   = (float    *)ff_aac_codebook_vectors[cb-1];



    abs_pow34_v(s->scoefs, in, size);

    scaled = s->scoefs;

    for (i = 0; i < size; i += 4) {

        int curidex, curidx2;

        int *in_ind = (int *)&in[i];

        uint8_t p_vals;

        unsigned int v_seq;

        int t0, t1, t2, t3, t4, t5, t6, ta07;

        const float *ven3, *vec2;



        qpc5 = scaled[i  ] * Q34 + ROUND_STANDARD;

        qcc92 = scaled[i+1] * Q34 + ROUND_STANDARD;

        qlc3 = scaled[i+2] * Q34 + ROUND_STANDARD;

        qrc44 = scaled[i+3] * Q34 + ROUND_STANDARD;



        __asm__ volatile (

            "".set push                      
\t""

            "".set noreorder                 
\t""



            ""ori    %[t4],  $zero,  4       
\t""

            ""slt    %[t0],  %[t4],  %[qpc5]  
\t""

            ""slt    %[t1],  %[t4],  %[qcc92]  
\t""

            ""slt    %[t2],  %[t4],  %[qlc3]  
\t""

            ""slt    %[t3],  %[t4],  %[qrc44]  
\t""

            ""movn   %[qpc5], %[t4],  %[t0]   
\t""

            ""movn   %[qcc92], %[t4],  %[t1]   
\t""

            ""movn   %[qlc3], %[t4],  %[t2]   
\t""

            ""movn   %[qrc44], %[t4],  %[t3]   
\t""

            ""lw     %[t0],  0(%[in_ind])    
\t""

            ""lw     %[t1],  4(%[in_ind])    
\t""

            ""lw     %[t2],  8(%[in_ind])    
\t""

            ""lw     %[t3],  12(%[in_ind])   
\t""

            ""srl    %[t0],  %[t0],  31      
\t""

            ""srl    %[t1],  %[t1],  31      
\t""

            ""srl    %[t2],  %[t2],  31      
\t""

            ""srl    %[t3],  %[t3],  31      
\t""

            ""subu   %[t4],  $zero,  %[qpc5]  
\t""

            ""subu   %[t5],  $zero,  %[qcc92]  
\t""

            ""subu   %[t6],  $zero,  %[qlc3]  
\t""

            ""subu   %[ta07],  $zero,  %[qrc44]  
\t""

            ""movn   %[qpc5], %[t4],  %[t0]   
\t""

            ""movn   %[qcc92], %[t5],  %[t1]   
\t""

            ""movn   %[qlc3], %[t6],  %[t2]   
\t""

            ""movn   %[qrc44], %[ta07],  %[t3]   
\t""



            "".set pop                       
\t""



            : [qpc5]""+r""(qpc5), [qcc92]""+r""(qcc92),

              [qlc3]""+r""(qlc3), [qrc44]""+r""(qrc44),

              [t0]""=&r""(t0), [t1]""=&r""(t1), [t2]""=&r""(t2), [t3]""=&r""(t3),

              [t4]""=&r""(t4), [t5]""=&r""(t5), [t6]""=&r""(t6), [ta07]""=&r""(ta07)

            : [in_ind]""r""(in_ind)

            : ""memory""

        );



        curidex = 9 * qpc5;

        curidex += qcc92 + 40;



        curidx2 = 9 * qlc3;

        curidx2 += qrc44 + 40;



        v_seq = (p_code[curidex] << p_bit[curidx2]) | (p_code[curidx2]);

        p_vals  = p_bit[curidex] + p_bit[curidx2];

        put_bits(gb, p_vals, v_seq);



        if (external) {

           ven3 = &p_norm[curidex*2 ];

           vec2 = &p_norm[curidx2*2];

           external[i+0] = ven3[0] * IQ;

           external[i+1] = ven3[1] * IQ;

           external[i+2] = vec2[0] * IQ;

           external[i+3] = vec2[1] * IQ;

        }

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,pb,in,out,scaled,size,scale_idx,cb,lambda,uplim,bits,ROUNDING,i,qc1,qc2,qc3,qc4,p_bits,p_codes,p_vec,curidx,curidx2,in_int,v_bits,v_codes,t0,t1,t2,t3,t4,t5,t6,t7,vec1,vec2","s:-0.03334158658981323,pb:-0.013794362545013428,in:-0.03509867191314697,out:-0.011013329029083252,scaled:-0.054048359394073486,size:-0.029745876789093018,scale_idx:-0.11071693897247314,cb:-0.0477825403213501,lambda:0.016094863414764404,uplim:0.022410154342651367,bits:-0.011154472827911377,ROUNDING:0.002172708511352539,i:-0.09778982400894165,qc1:0.001092672348022461,qc2:0.0018184185028076172,qc3:0.001184999942779541,qc4:0.000506281852722168,p_bits:-0.0005686283111572266,p_codes:-0.0013579726219177246,p_vec:-0.0008550286293029785,curidx:-2.676248550415039e-05,curidx2:-0.03556472063064575,in_int:0.0046010613441467285,v_bits:-0.0003427267074584961,v_codes:-0.0032418370246887207,t0:-0.08583343029022217,t1:-0.07993185520172119,t2:-0.09498417377471924,t3:-0.059046804904937744,t4:-0.14072901010513306,t5:-0.014535903930664062,t6:-0.014120697975158691,t7:-0.013977229595184326,vec1:-0.013215363025665283,vec2:-0.013766646385192871,",19,83,0,"uplim:ublen,lambda:phi,in_int:in_ind,ROUNDING:BroundED,qc2:qcc92,qc3:qlc3,qc1:qpc5,qc4:qrc44,curidx:curidex,v_bits:p_vals,p_bits:p_bit,p_vec:p_norm,p_codes:p_code,v_codes:v_seq,out:external,bits:bis,vec1:ven3,vec2:vec2,pb:gb,t7:ta07,",0,Greedy,605,0.2831054449081421,replace,[]
119,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",121,"static void fpu_init (CPUMIPSState *conn, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        conn->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&conn->active_fpu, &conn->fpus[0], sizeof(conn->active_fpu));

    if (conn->user_mode_only) {

        if (conn->CP0_Config1 & (1 << CP0C1_FP))

            conn->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (conn->active_fpu.fcr0 & (1 << FCR0_F64))

            conn->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,def,i","env:0.0014265775680541992,def:-0.0002130270004272461,i:-0.0008710026741027832,",1,10,0,"env:conn,",0,Greedy,95,0.03385519584019979,replace,[]
120,"static int rtc_initfn(ISADevice *dev)

{

    RTCState *s = DO_UPCAST(RTCState, dev, dev);

    int base = 0x70;

    int isairq = 8;



    isa_init_irq(dev, &s->irq, isairq);



    s->cmos_data[RTC_REG_A] = 0x26;

    s->cmos_data[RTC_REG_B] = 0x02;

    s->cmos_data[RTC_REG_C] = 0x00;

    s->cmos_data[RTC_REG_D] = 0x80;



    rtc_set_date_from_host(s);



    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        s->coalesced_timer =

            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);

#endif

    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);

    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);



    s->next_second_time =

        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;

    qemu_mod_timer(s->second_timer2, s->next_second_time);



    register_ioport_write(base, 2, 1, cmos_ioport_write, s);

    register_ioport_read(base, 2, 1, cmos_ioport_read, s);



    register_savevm(""mc146818rtc"", base, 1, rtc_save, rtc_load, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        register_savevm(""mc146818rtc-td"", base, 1, rtc_save_td, rtc_load_td, s);

#endif

    qemu_register_reset(rtc_reset, s);

    return 0;

}
",254,,LABEL_0,LABEL_0,LABEL_0,-1,"dev,s",,2,27,0,,0,GA,536,0.202875022093455,failed,[]
121,"static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,

        int64_t sector_num, uint8_t *buf, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *acb;



    /*

     * If O_DIRECT is used and the buffer is not aligned fall back

     * to synchronous IO.

     */

    BDRVRawState *s = bs->opaque;



    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {

        QEMUBH *bh;

        acb = qemu_aio_get(bs, cb, opaque);

        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);

        bh = qemu_bh_new(raw_aio_em_cb, acb);

        qemu_bh_schedule(bh);

        return &acb->common;

    }



    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);

    if (!acb)

        return NULL;

    if (aio_read(&acb->aiocb) < 0) {

        qemu_aio_release(acb);

        return NULL;

    }

    return &acb->common;

}
",199,"static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,

        int64_t block_begin, uint8_t *rb, int nb_serctors,

        BlockDriverCompletionFunc *buffer, void *Opac)

{

    RawAIOCB *acb;



    /*

     * If O_DIRECT is used and the buffer is not aligned fall back

     * to synchronous IO.

     */

    BDRVRawState *stats = bs->Opac;



    if (unlikely(stats->aligned_buf != NULL && ((uintptr_t) rb % 512))) {

        QEMUBH *adh;

        acb = qemu_aio_get(bs, buffer, Opac);

        acb->ret = raw_pread(bs, 512 * block_begin, rb, 512 * nb_serctors);

        adh = qemu_bh_new(raw_aio_em_cb, acb);

        qemu_bh_schedule(adh);

        return &acb->common;

    }



    acb = raw_aio_setup(bs, block_begin, rb, nb_serctors, buffer, Opac);

    if (!abuffer)

        return NULL;

    if (aio_read(&acb->aiocb) < 0) {

        qemu_aio_release(acb);

        return NULL;

    }

    return &acb->common;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bs,sector_num,buf,nb_sectors,cb,opaque,acb,s,bh","bs:-0.0032168030738830566,sector_num:-0.000549018383026123,buf:-0.0012961626052856445,nb_sectors:-0.00027102231979370117,cb:-0.0029093027114868164,opaque:-0.0019180774688720703,acb:-0.005048215389251709,s:-0.00107574462890625,bh:-0.0016915202140808105,",7,23,0,"nb_sectors:nb_serctors,sector_num:block_begin,s:stats,buf:rb,bh:adh,opaque:Opac,cb:buffer,",0,Greedy,338,0.12597017288208007,replace,[]
122,"static int swf_write_trailer(AVFormatContext *s)

{

    SWFContext *swf = s->priv_data;

    ByteIOContext *pb = &s->pb;

    AVCodecContext *enc, *video_enc;

    int file_size, i;



    video_enc = NULL;

    for(i=0;i<s->nb_streams;i++) {

        enc = &s->streams[i]->codec;

        if (enc->codec_type == CODEC_TYPE_VIDEO)

            video_enc = enc;

    }



    put_swf_tag(s, TAG_END);

    put_swf_end_tag(s);

    

    put_flush_packet(&s->pb);



    /* patch file size and number of frames if not streamed */

    if (!url_is_streamed(&s->pb) && video_enc) {

        file_size = url_ftell(pb);

        url_fseek(pb, 4, SEEK_SET);

        put_le32(pb, file_size);

        url_fseek(pb, swf->duration_pos, SEEK_SET);

        put_le16(pb, video_enc->frame_number);

    }

    av_free(swf);

    return 0;

}
",198,,LABEL_1,LABEL_0,,-4,"s,swf,pb,enc,video_enc,file_size,i",,,,0,,0,Greedy,1,0.0005390365918477376,,
123,"yuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2],

                     const int16_t *ubuf[2], const int16_t *vbuf[2],

                     const int16_t *abuf[2], uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target, int hasAlpha)

{

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],

                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],

                  *abuf0 = abuf[0], *abuf1 = abuf[1];

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;

        int A1, A2;

        const void *r =  c->table_rV[V],

                   *g = (c->table_gU[U] + c->table_gV[V]),

                   *b =  c->table_bU[U];



        if (hasAlpha) {

            A1 = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 19;

            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19;

        }



        yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,

                      r, g, b, y, target, hasAlpha);

    }

}
",410,"yuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2],

                     const int16_t *ubuf[2], const int16_t *vbuf[2],

                     const int16_t *abuf[2], uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target, int hasAlpha)

{

    const int16_t *buff50  = buf[0],  *queueOne  = buf[1],

                  *ubuf10 = ubuf[0], *ubuf1 = ubuf[1],

                  *lbuf8 = vbuf[0], *vbuf1 = vbuf[1],

                  *abuf0 = abuf[0], *abuf1 = abuf[1];

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buff50[i * 2]     * yalpha1  + queueOne[i * 2]     * yalpha)  >> 19;

        int Y2 = (buff50[i * 2 + 1] * yalpha1  + queueOne[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf10[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (lbuf8[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;

        int AAOne, A2;

        const void *r =  c->table_rV[V],

                   *g = (c->table_gU[U] + c->table_gV[V]),

                   *b =  c->table_bU[U];



        if (hasAlpha) {

            AAOne = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 19;

            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19;

        }



        yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? AAOne : 0, hasAlpha ? A2 : 0,

                      r, g, b, y, target, hasAlpha);

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"buf0,buf1,ubuf0,ubuf1,vbuf0,vbuf1,abuf0,abuf1,i,A1,A2,r,g,b","buf0:0.0006452202796936035,buf1:0.0005971789360046387,ubuf0:-1.4901161193847656e-06,ubuf1:-1.5735626220703125e-05,vbuf0:-1.6093254089355469e-06,vbuf1:-1.3232231140136719e-05,abuf0:-6.133317947387695e-05,abuf1:-2.372264862060547e-05,i:-0.0014316439628601074,A1:0.00016510486602783203,A2:-2.5093555450439453e-05,r:-3.135204315185547e-05,g:-0.00017380714416503906,b:-0.00018328428268432617,",5,13,0,"buf0:buff50,buf1:queueOne,A1:AAOne,ubuf0:ubuf10,vbuf0:lbuf8,",0,Greedy,199,0.07769535382588705,replace,[]
124,"static gboolean ga_channel_open(GAChannel *c, const gchar *path,

                                GAChannelMethod method, int fd)

{

    int ret;

    c->method = method;



    switch (c->method) {

    case GA_CHANNEL_VIRTIO_SERIAL: {

        assert(fd < 0);

        fd = qemu_open(path, O_RDWR | O_NONBLOCK

#ifndef CONFIG_SOLARIS

                           | O_ASYNC

#endif

                           );

        if (fd == -1) {

            g_critical(""error opening channel: %s"", strerror(errno));

            return false;

        }

#ifdef CONFIG_SOLARIS

        ret = ioctl(fd, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI);

        if (ret == -1) {

            g_critical(""error setting event mask for channel: %s"",

                       strerror(errno));

            close(fd);

            return false;

        }

#endif

        ret = ga_channel_client_add(c, fd);

        if (ret) {

            g_critical(""error adding channel to main loop"");

            close(fd);

            return false;

        }

        break;

    }

    case GA_CHANNEL_ISA_SERIAL: {

        struct termios tio;



        assert(fd < 0);

        fd = qemu_open(path, O_RDWR | O_NOCTTY | O_NONBLOCK);

        if (fd == -1) {

            g_critical(""error opening channel: %s"", strerror(errno));

            return false;

        }

        tcgetattr(fd, &tio);

        /* set up serial port for non-canonical, dumb byte streaming */

        tio.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP |

                         INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY |

                         IMAXBEL);

        tio.c_oflag = 0;

        tio.c_lflag = 0;

        tio.c_cflag |= GA_CHANNEL_BAUDRATE_DEFAULT;

        /* 1 available byte min or reads will block (we'll set non-blocking

         * elsewhere, else we have to deal with read()=0 instead)

         */

        tio.c_cc[VMIN] = 1;

        tio.c_cc[VTIME] = 0;

        /* flush everything waiting for read/xmit, it's garbage at this point */

        tcflush(fd, TCIFLUSH);

        tcsetattr(fd, TCSANOW, &tio);

        ret = ga_channel_client_add(c, fd);

        if (ret) {

            g_critical(""error adding channel to main loop"");

            close(fd);

            return false;

        }

        break;

    }

    case GA_CHANNEL_UNIX_LISTEN: {

        if (fd < 0) {

            Error *local_err = NULL;



            fd = unix_listen(path, NULL, strlen(path), &local_err);

            if (local_err != NULL) {

                g_critical(""%s"", error_get_pretty(local_err));

                error_free(local_err);

                return false;

            }

        }

        ga_channel_listen_add(c, fd, true);

        break;

    }

    case GA_CHANNEL_VSOCK_LISTEN: {

        if (fd < 0) {

            Error *local_err = NULL;

            SocketAddress *addr;

            char *addr_str;



            addr_str = g_strdup_printf(""vsock:%s"", path);

            addr = socket_parse(addr_str, &local_err);

            g_free(addr_str);

            if (local_err != NULL) {

                g_critical(""%s"", error_get_pretty(local_err));

                error_free(local_err);

                return false;

            }



            fd = socket_listen(addr, &local_err);

            qapi_free_SocketAddress(addr);

            if (local_err != NULL) {

                g_critical(""%s"", error_get_pretty(local_err));

                error_free(local_err);

                return false;

            }

        }

        ga_channel_listen_add(c, fd, true);

        break;

    }

    default:

        g_critical(""error binding/listening to specified socket"");

        return false;

    }



    return true;

}
",620,,LABEL_0,LABEL_0,LABEL_0,-1,"c,path,method,fd,ret,tio",,6,55,0,,0,GA,1223,0.5565550764401753,failed,[]
125,"static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,

                              const char *desc_file_path, Error **errp)

{

    int ret;

    char access[11];

    char type[11];

    char fname[512];

    const char *p = desc;

    int64_t sectors = 0;

    int64_t flat_offset;

    char extent_path[PATH_MAX];

    BlockDriverState *extent_file;

    BDRVVmdkState *s = bs->opaque;

    VmdkExtent *extent;



    while (*p) {

        /* parse extent line:

         * RW [size in sectors] FLAT ""file-name.vmdk"" OFFSET

         * or

         * RW [size in sectors] SPARSE ""file-name.vmdk""

         */

        flat_offset = -1;

        ret = sscanf(p, ""%10s %"" SCNd64 "" %10s \""%511[^\n\r\""]\"" %"" SCNd64,

                access, &sectors, type, fname, &flat_offset);

        if (ret < 4 || strcmp(access, ""RW"")) {

            goto next_line;

        } else if (!strcmp(type, ""FLAT"")) {

            if (ret != 5 || flat_offset < 0) {

                error_setg(errp, ""Invalid extent lines: \n%s"", p);

                return -EINVAL;

            }

        } else if (!strcmp(type, ""VMFS"")) {

            if (ret == 4) {

                flat_offset = 0;

            } else {

                error_setg(errp, ""Invalid extent lines:\n%s"", p);

                return -EINVAL;

            }

        } else if (ret != 4) {

            error_setg(errp, ""Invalid extent lines:\n%s"", p);

            return -EINVAL;

        }



        if (sectors <= 0 ||

            (strcmp(type, ""FLAT"") && strcmp(type, ""SPARSE"") &&

             strcmp(type, ""VMFS"") && strcmp(type, ""VMFSSPARSE"")) ||

            (strcmp(access, ""RW""))) {

            goto next_line;

        }



        path_combine(extent_path, sizeof(extent_path),

                desc_file_path, fname);

        extent_file = NULL;

        ret = bdrv_open(&extent_file, extent_path, NULL, NULL,

                        bs->open_flags | BDRV_O_PROTOCOL, NULL, errp);

        if (ret) {

            return ret;

        }



        /* save to extents array */

        if (!strcmp(type, ""FLAT"") || !strcmp(type, ""VMFS"")) {

            /* FLAT extent */



            ret = vmdk_add_extent(bs, extent_file, true, sectors,

                            0, 0, 0, 0, 0, &extent, errp);

            if (ret < 0) {


                return ret;

            }

            extent->flat_start_offset = flat_offset << 9;

        } else if (!strcmp(type, ""SPARSE"") || !strcmp(type, ""VMFSSPARSE"")) {

            /* SPARSE extent and VMFSSPARSE extent are both ""COWD"" sparse file*/

            char *buf = vmdk_read_desc(extent_file, 0, errp);

            if (!buf) {

                ret = -EINVAL;

            } else {

                ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf, errp);

            }

            if (ret) {

                g_free(buf);


                return ret;

            }

            extent = &s->extents[s->num_extents - 1];

        } else {

            error_setg(errp, ""Unsupported extent type '%s'"", type);


            return -ENOTSUP;

        }

        extent->type = g_strdup(type);

next_line:

        /* move to next line */

        while (*p) {

            if (*p == '\n') {

                p++;

                break;

            }

            p++;

        }

    }

    return 0;

}",666,,LABEL_1,LABEL_0,,-4,"desc,bs,desc_file_path,errp,ret,access,type,fname,p,flat_offset,extent_path,extent_file,s,extent",,,,0,,0,Greedy,1,0.0008202274640401204,,
126,"int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t *hc = (uint32_t*)buf;



    struct kvm_ppc_pvinfo pvinfo;



    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&

        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {

        memcpy(buf, pvinfo.hcall, buf_len);



        return 0;

    }



    /*

     * Fallback to always fail hypercalls:

     *

     *     li r3, -1

     *     nop

     *     nop

     *     nop

     */



    hc[0] = 0x3860ffff;

    hc[1] = 0x60000000;

    hc[2] = 0x60000000;

    hc[3] = 0x60000000;



    return 0;

}
",149,"int kvmppc_get_hypercall(CPUPPCState *runner, uint8_t *batch, int buf_val)

{

    PowerPCCPU *pid = ppc_env_get_cpu(runner);

    CPUState *vc = CPU(pid);

    uint32_t *ohc = (uint32_t*)batch;



    struct kvm_ppc_pvinfo pvinfo;



    if (kvm_check_extension(vc->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&

        !kvm_vm_ioctl(vc->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {

        memcpy(batch, pvinfo.hcall, buf_val);



        return 0;

    }



    /*

     * Fallback to always fail hypercalls:

     *

     *     li r3, -1

     *     nop

     *     nop

     *     nop

     */



    ohc[0] = 0x3860ffff;

    ohc[1] = 0x60000000;

    ohc[2] = 0x60000000;

    ohc[3] = 0x60000000;



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,buf,buf_len,cpu,cs,hc,pvinfo","env:0.0016002058982849121,buf:0.0014924407005310059,buf_len:0.0007544755935668945,cpu:0.0010465383529663086,cs:0.0020605921745300293,hc:0.0005959272384643555,pvinfo:0.00015622377395629883,",6,17,0,"cs:vc,env:runner,buf:batch,cpu:pid,buf_len:buf_val,hc:ohc,",0,Greedy,267,0.09683987696965536,replace,[]
127,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
                                              int *got_picture_ptr,
                                              AVPacket *avpkt)
{
    int ret;
    *got_picture_ptr = 0;
    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))
        return -1;
    avctx->pkt = avpkt;
    apply_param_change(avctx, avpkt);
    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,
                                         avpkt);
        else {
            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                       avpkt);
            picture->pkt_dts             = avpkt->dts;
            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;
            picture->width               = avctx->width;
            picture->height              = avctx->height;
            picture->format              = avctx->pix_fmt;
        }
        emms_c(); //needed to avoid an emms_c() call before every return;
        if (*got_picture_ptr)
            avctx->frame_number++;
    } else
        ret = 0;
    /* many decoders assign whole AVFrames, thus overwriting extended_data;
     * make sure it's set correctly */
    picture->extended_data = picture->data;
    return ret;
}",278,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,picture,got_picture_ptr,avpkt,ret,frame_number",,6,47,0,,0,GA,1368,0.532125453154246,failed,[]
128,"static int h264_slice_header_parse(H264Context *h, H264SliceContext *sl)

{

    const SPS *sps;

    const PPS *pps;

    unsigned int first_mb_in_slice;

    unsigned int pps_id;

    int ret;

    unsigned int slice_type, tmp, i;

    int last_pic_structure, last_pic_droppable;

    int needs_reinit = 0;

    int field_pic_flag, bottom_field_flag;

    int frame_num, droppable, picture_structure;

    int mb_aff_frame = 0;



    first_mb_in_slice = get_ue_golomb(&sl->gb);



    if (first_mb_in_slice == 0) { // FIXME better field boundary detection

        if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {

            ff_h264_field_end(h, sl, 1);

        }



        h->current_slice = 0;

        if (!h->first_field) {

            if (h->cur_pic_ptr && !h->droppable) {

                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,

                                          h->picture_structure == PICT_BOTTOM_FIELD);

            }

            h->cur_pic_ptr = NULL;

        }

    }



    slice_type = get_ue_golomb_31(&sl->gb);

    if (slice_type > 9) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""slice type %d too large at %d\n"",

               slice_type, first_mb_in_slice);

        return AVERROR_INVALIDDATA;

    }

    if (slice_type > 4) {

        slice_type -= 5;

        sl->slice_type_fixed = 1;

    } else

        sl->slice_type_fixed = 0;



    slice_type         = ff_h264_golomb_to_pict_type[slice_type];

    sl->slice_type     = slice_type;

    sl->slice_type_nos = slice_type & 3;



    if (h->nal_unit_type  == NAL_IDR_SLICE &&

        sl->slice_type_nos != AV_PICTURE_TYPE_I) {

        av_log(h->avctx, AV_LOG_ERROR, ""A non-intra slice in an IDR NAL unit.\n"");

        return AVERROR_INVALIDDATA;

    }



    pps_id = get_ue_golomb(&sl->gb);

    if (pps_id >= MAX_PPS_COUNT) {

        av_log(h->avctx, AV_LOG_ERROR, ""pps_id %u out of range\n"", pps_id);

        return AVERROR_INVALIDDATA;

    }

    if (!h->ps.pps_list[pps_id]) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""non-existing PPS %u referenced\n"",

               pps_id);

        return AVERROR_INVALIDDATA;

    }

    if (!h->setup_finished) {

        h->ps.pps = (const PPS*)h->ps.pps_list[pps_id]->data;

    } else if (h->ps.pps != (const PPS*)h->ps.pps_list[pps_id]->data) {

        av_log(h->avctx, AV_LOG_ERROR, ""PPS changed between slices\n"");

        return AVERROR_INVALIDDATA;

    }



    if (!h->ps.sps_list[h->ps.pps->sps_id]) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""non-existing SPS %u referenced\n"",

               h->ps.pps->sps_id);

        return AVERROR_INVALIDDATA;

    }



    if (h->ps.sps != (const SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data) {

        h->ps.sps = (SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data;



        if (h->bit_depth_luma    != h->ps.sps->bit_depth_luma ||

            h->chroma_format_idc != h->ps.sps->chroma_format_idc)

            needs_reinit         = 1;

    }



    pps = h->ps.pps;

    sps = h->ps.sps;



    if (!h->setup_finished) {

        h->avctx->profile = ff_h264_get_profile(sps);

        h->avctx->level   = sps->level_idc;

        h->avctx->refs    = sps->ref_frame_count;



        if (h->mb_width  != sps->mb_width ||

            h->mb_height != sps->mb_height * (2 - sps->frame_mbs_only_flag))

            needs_reinit = 1;



        h->mb_width  = sps->mb_width;

        h->mb_height = sps->mb_height * (2 - sps->frame_mbs_only_flag);

        h->mb_num    = h->mb_width * h->mb_height;

        h->mb_stride = h->mb_width + 1;



        h->b_stride = h->mb_width * 4;



        h->chroma_y_shift = sps->chroma_format_idc <= 1; // 400 uses yuv420p



        h->width  = 16 * h->mb_width;

        h->height = 16 * h->mb_height;



        ret = init_dimensions(h);

        if (ret < 0)

            return ret;



        if (sps->video_signal_type_present_flag) {

            h->avctx->color_range = sps->full_range ? AVCOL_RANGE_JPEG

                : AVCOL_RANGE_MPEG;

            if (sps->colour_description_present_flag) {

                if (h->avctx->colorspace != sps->colorspace)

                    needs_reinit = 1;

                h->avctx->color_primaries = sps->color_primaries;

                h->avctx->color_trc       = sps->color_trc;

                h->avctx->colorspace      = sps->colorspace;

            }

        }

    }



    if (h->context_initialized && needs_reinit) {

        h->context_initialized = 0;

        if (sl != h->slice_ctx) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""changing width %d -> %d / height %d -> %d on ""

                   ""slice %d\n"",

                   h->width, h->avctx->coded_width,

                   h->height, h->avctx->coded_height,

                   h->current_slice + 1);

            return AVERROR_INVALIDDATA;

        }



        ff_h264_flush_change(h);



        if ((ret = get_pixel_format(h)) < 0)

            return ret;

        h->avctx->pix_fmt = ret;



        av_log(h->avctx, AV_LOG_INFO, ""Reinit context to %dx%d, ""

               ""pix_fmt: %d\n"", h->width, h->height, h->avctx->pix_fmt);



        if ((ret = h264_slice_header_init(h)) < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""h264_slice_header_init() failed\n"");

            return ret;

        }

    }

    if (!h->context_initialized) {

        if (sl != h->slice_ctx) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""Cannot (re-)initialize context during parallel decoding.\n"");

            return AVERROR_PATCHWELCOME;

        }



        if ((ret = get_pixel_format(h)) < 0)

            return ret;

        h->avctx->pix_fmt = ret;



        if ((ret = h264_slice_header_init(h)) < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""h264_slice_header_init() failed\n"");

            return ret;

        }

    }



    frame_num = get_bits(&sl->gb, sps->log2_max_frame_num);

    if (!h->setup_finished)

        h->poc.frame_num = frame_num;



    sl->mb_mbaff       = 0;



    last_pic_structure = h->picture_structure;

    last_pic_droppable = h->droppable;



    droppable = h->nal_ref_idc == 0;

    if (sps->frame_mbs_only_flag) {

        picture_structure = PICT_FRAME;

    } else {

        field_pic_flag = get_bits1(&sl->gb);

        if (field_pic_flag) {

            bottom_field_flag = get_bits1(&sl->gb);

            picture_structure = PICT_TOP_FIELD + bottom_field_flag;

        } else {

            picture_structure = PICT_FRAME;

            mb_aff_frame      = sps->mb_aff;

        }

    }

    if (!h->setup_finished) {

        h->droppable         = droppable;

        h->picture_structure = picture_structure;

        h->mb_aff_frame      = mb_aff_frame;

    }

    sl->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;



    if (h->current_slice != 0) {

        if (last_pic_structure != picture_structure ||

            last_pic_droppable != droppable) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""Changing field mode (%d -> %d) between slices is not allowed\n"",

                   last_pic_structure, h->picture_structure);

            return AVERROR_INVALIDDATA;

        } else if (!h->cur_pic_ptr) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""unset cur_pic_ptr on slice %d\n"",

                   h->current_slice + 1);

            return AVERROR_INVALIDDATA;

        }

    } else {

        /* Shorten frame num gaps so we don't have to allocate reference

         * frames just to throw them away */

        if (h->poc.frame_num != h->poc.prev_frame_num) {

            int unwrap_prev_frame_num = h->poc.prev_frame_num;

            int max_frame_num         = 1 << sps->log2_max_frame_num;



            if (unwrap_prev_frame_num > h->poc.frame_num)

                unwrap_prev_frame_num -= max_frame_num;



            if ((h->poc.frame_num - unwrap_prev_frame_num) > sps->ref_frame_count) {

                unwrap_prev_frame_num = (h->poc.frame_num - sps->ref_frame_count) - 1;

                if (unwrap_prev_frame_num < 0)

                    unwrap_prev_frame_num += max_frame_num;



                h->poc.prev_frame_num = unwrap_prev_frame_num;

            }

        }



        /* See if we have a decoded first field looking for a pair...

         * Here, we're using that to see if we should mark previously

         * decode frames as ""finished"".

         * We have to do that before the ""dummy"" in-between frame allocation,

         * since that can modify s->current_picture_ptr. */

        if (h->first_field) {

            assert(h->cur_pic_ptr);

            assert(h->cur_pic_ptr->f->buf[0]);

            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);



            /* figure out if we have a complementary field pair */

            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {

                /* Previous field is unmatched. Don't display it, but let it

                 * remain for reference if marked as such. */

                if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {

                    ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,

                                              last_pic_structure == PICT_TOP_FIELD);

                }

            } else {

                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {

                    /* This and previous field were reference, but had

                     * different frame_nums. Consider this field first in

                     * pair. Throw away previous field except for reference

                     * purposes. */

                    if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {

                        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,

                                                  last_pic_structure == PICT_TOP_FIELD);

                    }

                } else {

                    /* Second field in complementary pair */

                    if (!((last_pic_structure   == PICT_TOP_FIELD &&

                           h->picture_structure == PICT_BOTTOM_FIELD) ||

                          (last_pic_structure   == PICT_BOTTOM_FIELD &&

                           h->picture_structure == PICT_TOP_FIELD))) {

                        av_log(h->avctx, AV_LOG_ERROR,

                               ""Invalid field mode combination %d/%d\n"",

                               last_pic_structure, h->picture_structure);

                        h->picture_structure = last_pic_structure;

                        h->droppable         = last_pic_droppable;

                        return AVERROR_INVALIDDATA;

                    } else if (last_pic_droppable != h->droppable) {

                        avpriv_request_sample(h->avctx,

                                              ""Found reference and non-reference fields in the same frame, which"");

                        h->picture_structure = last_pic_structure;

                        h->droppable         = last_pic_droppable;

                        return AVERROR_PATCHWELCOME;

                    }

                }

            }

        }



        while (h->poc.frame_num != h->poc.prev_frame_num &&

               h->poc.frame_num != (h->poc.prev_frame_num + 1) % (1 << sps->log2_max_frame_num)) {

            H264Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;

            av_log(h->avctx, AV_LOG_DEBUG, ""Frame num gap %d %d\n"",

                   h->poc.frame_num, h->poc.prev_frame_num);

            ret = initialize_cur_frame(h);

            if (ret < 0) {

                h->first_field = 0;

                return ret;

            }



            h->poc.prev_frame_num++;

            h->poc.prev_frame_num        %= 1 << sps->log2_max_frame_num;

            h->cur_pic_ptr->frame_num = h->poc.prev_frame_num;

            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);

            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);

            ret = ff_generate_sliding_window_mmcos(h, 1);

            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))

                return ret;

            ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);

            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))

                return ret;

            /* Error concealment: If a ref is missing, copy the previous ref

             * in its place.

             * FIXME: Avoiding a memcpy would be nice, but ref handling makes

             * many assumptions about there being no actual duplicates.

             * FIXME: This does not copy padding for out-of-frame motion

             * vectors.  Given we are concealing a lost frame, this probably

             * is not noticeable by comparison, but it should be fixed. */

            if (h->short_ref_count) {

                if (prev &&

                    h->short_ref[0]->f->width == prev->f->width &&

                    h->short_ref[0]->f->height == prev->f->height &&

                    h->short_ref[0]->f->format == prev->f->format) {

                    av_image_copy(h->short_ref[0]->f->data,

                                  h->short_ref[0]->f->linesize,

                                  (const uint8_t **)prev->f->data,

                                  prev->f->linesize,

                                  prev->f->format,

                                  h->mb_width  * 16,

                                  h->mb_height * 16);

                    h->short_ref[0]->poc = prev->poc + 2;

                }

                h->short_ref[0]->frame_num = h->poc.prev_frame_num;

            }

        }



        /* See if we have a decoded first field looking for a pair...

         * We're using that to see whether to continue decoding in that

         * frame, or to allocate a new one. */

        if (h->first_field) {

            assert(h->cur_pic_ptr);

            assert(h->cur_pic_ptr->f->buf[0]);

            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);



            /* figure out if we have a complementary field pair */

            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {

                /* Previous field is unmatched. Don't display it, but let it

                 * remain for reference if marked as such. */

                h->cur_pic_ptr = NULL;

                h->first_field = FIELD_PICTURE(h);

            } else {

                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {

                    /* This and the previous field had different frame_nums.

                     * Consider this field first in pair. Throw away previous

                     * one except for reference purposes. */

                    h->first_field = 1;

                    h->cur_pic_ptr = NULL;

                } else {

                    /* Second field in complementary pair */

                    h->first_field = 0;

                }

            }

        } else {

            /* Frame or first field in a potentially complementary pair */

            h->first_field = FIELD_PICTURE(h);

        }



        if (!FIELD_PICTURE(h) || h->first_field) {

            if (h264_frame_start(h) < 0) {

                h->first_field = 0;

                return AVERROR_INVALIDDATA;

            }

        } else {

            release_unused_pictures(h, 0);

        }

    }



    assert(h->mb_num == h->mb_width * h->mb_height);

    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||

        first_mb_in_slice >= h->mb_num) {

        av_log(h->avctx, AV_LOG_ERROR, ""first_mb_in_slice overflow\n"");

        return AVERROR_INVALIDDATA;

    }

    sl->resync_mb_x = sl->mb_x =  first_mb_in_slice % h->mb_width;

    sl->resync_mb_y = sl->mb_y = (first_mb_in_slice / h->mb_width) <<

                                 FIELD_OR_MBAFF_PICTURE(h);

    if (h->picture_structure == PICT_BOTTOM_FIELD)

        sl->resync_mb_y = sl->mb_y = sl->mb_y + 1;

    assert(sl->mb_y < h->mb_height);



    if (h->picture_structure == PICT_FRAME) {

        h->curr_pic_num = h->poc.frame_num;

        h->max_pic_num  = 1 << sps->log2_max_frame_num;

    } else {

        h->curr_pic_num = 2 * h->poc.frame_num + 1;

        h->max_pic_num  = 1 << (sps->log2_max_frame_num + 1);

    }



    if (h->nal_unit_type == NAL_IDR_SLICE)

        get_ue_golomb(&sl->gb); /* idr_pic_id */



    if (sps->poc_type == 0) {

        int poc_lsb = get_bits(&sl->gb, sps->log2_max_poc_lsb);



        if (!h->setup_finished)

            h->poc.poc_lsb = poc_lsb;



        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {

            int delta_poc_bottom = get_se_golomb(&sl->gb);

            if (!h->setup_finished)

                h->poc.delta_poc_bottom = delta_poc_bottom;

        }

    }



    if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) {

        int delta_poc = get_se_golomb(&sl->gb);



        if (!h->setup_finished)

            h->poc.delta_poc[0] = delta_poc;



        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {

            delta_poc = get_se_golomb(&sl->gb);



            if (!h->setup_finished)

                h->poc.delta_poc[1] = delta_poc;

        }

    }



    if (!h->setup_finished)

        ff_h264_init_poc(h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc,

                         sps, &h->poc, h->picture_structure, h->nal_ref_idc);



    if (pps->redundant_pic_cnt_present)

        sl->redundant_pic_count = get_ue_golomb(&sl->gb);



    if (sl->slice_type_nos == AV_PICTURE_TYPE_B)

        sl->direct_spatial_mv_pred = get_bits1(&sl->gb);



    ret = ff_h264_parse_ref_count(&sl->list_count, sl->ref_count,

                                  &sl->gb, pps, sl->slice_type_nos,

                                  h->picture_structure);

    if (ret < 0)

        return ret;



    if (sl->slice_type_nos != AV_PICTURE_TYPE_I) {

       ret = ff_h264_decode_ref_pic_list_reordering(h, sl);

       if (ret < 0) {

           sl->ref_count[1] = sl->ref_count[0] = 0;

           return ret;

       }

    }



    sl->pwt.use_weight = 0;

    for (i = 0; i < 2; i++) {

        sl->pwt.luma_weight_flag[i]   = 0;

        sl->pwt.chroma_weight_flag[i] = 0;

    }

    if ((pps->weighted_pred && sl->slice_type_nos == AV_PICTURE_TYPE_P) ||

        (pps->weighted_bipred_idc == 1 &&

         sl->slice_type_nos == AV_PICTURE_TYPE_B))

        ff_h264_pred_weight_table(&sl->gb, sps, sl->ref_count,

                                  sl->slice_type_nos, &sl->pwt);



    // If frame-mt is enabled, only update mmco tables for the first slice

    // in a field. Subsequent slices can temporarily clobber h->mmco_index

    // or h->mmco, which will cause ref list mix-ups and decoding errors

    // further down the line. This may break decoding if the first slice is

    // corrupt, thus we only do this if frame-mt is enabled.

    if (h->nal_ref_idc) {

        ret = ff_h264_decode_ref_pic_marking(h, &sl->gb,

                                             !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||

                                             h->current_slice == 0);

        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))

            return AVERROR_INVALIDDATA;

    }



    if (sl->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) {

        tmp = get_ue_golomb_31(&sl->gb);

        if (tmp > 2) {

            av_log(h->avctx, AV_LOG_ERROR, ""cabac_init_idc %u overflow\n"", tmp);

            return AVERROR_INVALIDDATA;

        }

        sl->cabac_init_idc = tmp;

    }



    sl->last_qscale_diff = 0;

    tmp = pps->init_qp + get_se_golomb(&sl->gb);

    if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) {

        av_log(h->avctx, AV_LOG_ERROR, ""QP %u out of range\n"", tmp);

        return AVERROR_INVALIDDATA;

    }

    sl->qscale       = tmp;

    sl->chroma_qp[0] = get_chroma_qp(h, 0, sl->qscale);

    sl->chroma_qp[1] = get_chroma_qp(h, 1, sl->qscale);

    // FIXME qscale / qp ... stuff

    if (sl->slice_type == AV_PICTURE_TYPE_SP)

        get_bits1(&sl->gb); /* sp_for_switch_flag */

    if (sl->slice_type == AV_PICTURE_TYPE_SP ||

        sl->slice_type == AV_PICTURE_TYPE_SI)

        get_se_golomb(&sl->gb); /* slice_qs_delta */



    sl->deblocking_filter     = 1;

    sl->slice_alpha_c0_offset = 0;

    sl->slice_beta_offset     = 0;

    if (pps->deblocking_filter_parameters_present) {

        tmp = get_ue_golomb_31(&sl->gb);

        if (tmp > 2) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""deblocking_filter_idc %u out of range\n"", tmp);

            return AVERROR_INVALIDDATA;

        }

        sl->deblocking_filter = tmp;

        if (sl->deblocking_filter < 2)

            sl->deblocking_filter ^= 1;  // 1<->0



        if (sl->deblocking_filter) {

            sl->slice_alpha_c0_offset = get_se_golomb(&sl->gb) * 2;

            sl->slice_beta_offset     = get_se_golomb(&sl->gb) * 2;

            if (sl->slice_alpha_c0_offset >  12 ||

                sl->slice_alpha_c0_offset < -12 ||

                sl->slice_beta_offset >  12     ||

                sl->slice_beta_offset < -12) {

                av_log(h->avctx, AV_LOG_ERROR,

                       ""deblocking filter parameters %d %d out of range\n"",

                       sl->slice_alpha_c0_offset, sl->slice_beta_offset);

                return AVERROR_INVALIDDATA;

            }

        }

    }



    return 0;

}
",4216,"static int h264_slice_header_parse(H264Context *g, H264SliceContext *sf)

{

    const SPS *sps;

    const PPS *pps;

    unsigned int first_mb_in_slice;

    unsigned int pps_id;

    int ret;

    unsigned int slice_type, tmp, i;

    int last_pic_structure, last_pic_droppable;

    int needs_reinit = 0;

    int field_pic_flag, bottom_field_flag;

    int frame_num, droppable, picture_structure;

    int mb_aff_frame = 0;



    first_mb_in_slice = get_ue_golomb(&sf->gb);



    if (first_mb_in_slice == 0) { // FIXME better field boundary detection

        if (g->current_slice && g->cur_pic_ptr && FIELD_PICTURE(g)) {

            ff_h264_field_end(g, sf, 1);

        }



        g->current_slice = 0;

        if (!h->first_field) {

            if (g->cur_pic_ptr && !h->droppable) {

                ff_thread_report_progress(&g->cur_pic_ptr->tf, INT_MAX,

                                          g->picture_structure == PICT_BOTTOM_FIELD);

            }

            g->cur_pic_ptr = NULL;

        }

    }



    slice_type = get_ue_golomb_31(&sf->gb);

    if (slice_type > 9) {

        av_log(g->avctx, AV_LOG_ERROR,

               ""slice type %d too large at %d
"",

               slice_type, first_mb_in_slice);

        return AVERROR_INVALIDDATA;

    }

    if (slice_type > 4) {

        slice_type -= 5;

        sf->slice_type_fixed = 1;

    } else

        sf->slice_type_fixed = 0;



    slice_type         = ff_h264_golomb_to_pict_type[slice_type];

    sf->slice_type     = slice_type;

    sf->slice_type_nos = slice_type & 3;



    if (g->nal_unit_type  == NAL_IDR_SLICE &&

        sf->slice_type_nos != AV_PICTURE_TYPE_I) {

        av_log(g->avctx, AV_LOG_ERROR, ""A non-intra slice in an IDR NAL unit.
"");

        return AVERROR_INVALIDDATA;

    }



    pps_id = get_ue_golomb(&sf->gb);

    if (pps_id >= MAX_PPS_COUNT) {

        av_log(g->avctx, AV_LOG_ERROR, ""pps_id %u out of range
"", pps_id);

        return AVERROR_INVALIDDATA;

    }

    if (!h->ps.pps_list[pps_id]) {

        av_log(g->avctx, AV_LOG_ERROR,

               ""non-existing PPS %u referenced
"",

               pps_id);

        return AVERROR_INVALIDDATA;

    }

    if (!h->setup_finished) {

        g->ps.pps = (const PPS*)g->ps.pps_list[pps_id]->data;

    } else if (g->ps.pps != (const PPS*)g->ps.pps_list[pps_id]->data) {

        av_log(g->avctx, AV_LOG_ERROR, ""PPS changed between slices
"");

        return AVERROR_INVALIDDATA;

    }



    if (!h->ps.sps_list[g->ps.pps->sps_id]) {

        av_log(g->avctx, AV_LOG_ERROR,

               ""non-existing SPS %u referenced
"",

               g->ps.pps->sps_id);

        return AVERROR_INVALIDDATA;

    }



    if (g->ps.sps != (const SPS*)g->ps.sps_list[g->ps.pps->sps_id]->data) {

        g->ps.sps = (SPS*)g->ps.sps_list[g->ps.pps->sps_id]->data;



        if (g->bit_depth_luma    != g->ps.sps->bit_depth_luma ||

            g->chroma_format_idc != g->ps.sps->chroma_format_idc)

            needs_reinit         = 1;

    }



    pps = g->ps.pps;

    sps = g->ps.sps;



    if (!h->setup_finished) {

        g->avctx->profile = ff_h264_get_profile(sps);

        g->avctx->level   = sps->level_idc;

        g->avctx->refs    = sps->ref_frame_count;



        if (g->mb_width  != sps->mb_width ||

            g->mb_height != sps->mb_height * (2 - sps->frame_mbs_only_flag))

            needs_reinit = 1;



        g->mb_width  = sps->mb_width;

        g->mb_height = sps->mb_height * (2 - sps->frame_mbs_only_flag);

        g->mb_num    = g->mb_width * g->mb_height;

        g->mb_stride = g->mb_width + 1;



        g->b_stride = g->mb_width * 4;



        g->chroma_y_shift = sps->chroma_format_idc <= 1; // 400 uses yuv420p



        g->width  = 16 * g->mb_width;

        g->height = 16 * g->mb_height;



        ret = init_dimensions(g);

        if (ret < 0)

            return ret;



        if (sps->video_signal_type_present_flag) {

            g->avctx->color_range = sps->full_range ? AVCOL_RANGE_JPEG

                : AVCOL_RANGE_MPEG;

            if (sps->colour_description_present_flag) {

                if (g->avctx->colorspace != sps->colorspace)

                    needs_reinit = 1;

                g->avctx->color_primaries = sps->color_primaries;

                g->avctx->color_trc       = sps->color_trc;

                g->avctx->colorspace      = sps->colorspace;

            }

        }

    }



    if (g->context_initialized && needs_reinit) {

        g->context_initialized = 0;

        if (sf != g->slice_ctx) {

            av_log(g->avctx, AV_LOG_ERROR,

                   ""changing width %d -> %d / height %d -> %d on ""

                   ""slice %d
"",

                   g->width, g->avctx->coded_width,

                   g->height, g->avctx->coded_height,

                   g->current_slice + 1);

            return AVERROR_INVALIDDATA;

        }



        ff_h264_flush_change(g);



        if ((ret = get_pixel_format(g)) < 0)

            return ret;

        g->avctx->pix_fmt = ret;



        av_log(g->avctx, AV_LOG_INFO, ""Reinit context to %dx%d, ""

               ""pix_fmt: %d
"", g->width, g->height, g->avctx->pix_fmt);



        if ((ret = h264_slice_header_init(g)) < 0) {

            av_log(g->avctx, AV_LOG_ERROR,

                   ""h264_slice_header_init() failed
"");

            return ret;

        }

    }

    if (!h->context_initialized) {

        if (sf != g->slice_ctx) {

            av_log(g->avctx, AV_LOG_ERROR,

                   ""Cannot (re-)initialize context during parallel decoding.
"");

            return AVERROR_PATCHWELCOME;

        }



        if ((ret = get_pixel_format(g)) < 0)

            return ret;

        g->avctx->pix_fmt = ret;



        if ((ret = h264_slice_header_init(g)) < 0) {

            av_log(g->avctx, AV_LOG_ERROR,

                   ""h264_slice_header_init() failed
"");

            return ret;

        }

    }



    frame_num = get_bits(&sf->gb, sps->log2_max_frame_num);

    if (!h->setup_finished)

        g->poc.frame_num = frame_num;



    sf->mb_mbaff       = 0;



    last_pic_structure = g->picture_structure;

    last_pic_droppable = g->droppable;



    droppable = g->nal_ref_idc == 0;

    if (sps->frame_mbs_only_flag) {

        picture_structure = PICT_FRAME;

    } else {

        field_pic_flag = get_bits1(&sf->gb);

        if (field_pic_flag) {

            bottom_field_flag = get_bits1(&sf->gb);

            picture_structure = PICT_TOP_FIELD + bottom_field_flag;

        } else {

            picture_structure = PICT_FRAME;

            mb_aff_frame      = sps->mb_aff;

        }

    }

    if (!h->setup_finished) {

        g->droppable         = droppable;

        g->picture_structure = picture_structure;

        g->mb_aff_frame      = mb_aff_frame;

    }

    sf->mb_field_decoding_flag = g->picture_structure != PICT_FRAME;



    if (g->current_slice != 0) {

        if (last_pic_structure != picture_structure ||

            last_pic_droppable != droppable) {

            av_log(g->avctx, AV_LOG_ERROR,

                   ""Changing field mode (%d -> %d) between slices is not allowed
"",

                   last_pic_structure, g->picture_structure);

            return AVERROR_INVALIDDATA;

        } else if (!h->cur_pic_ptr) {

            av_log(g->avctx, AV_LOG_ERROR,

                   ""unset cur_pic_ptr on slice %d
"",

                   g->current_slice + 1);

            return AVERROR_INVALIDDATA;

        }

    } else {

        /* Shorten frame num gaps so we don't have to allocate reference

         * frames just to throw them away */

        if (g->poc.frame_num != g->poc.prev_frame_num) {

            int unwrap_prev_frame_num = g->poc.prev_frame_num;

            int max_frame_num         = 1 << sps->log2_max_frame_num;



            if (unwrap_prev_frame_num > g->poc.frame_num)

                unwrap_prev_frame_num -= max_frame_num;



            if ((g->poc.frame_num - unwrap_prev_frame_num) > sps->ref_frame_count) {

                unwrap_prev_frame_num = (g->poc.frame_num - sps->ref_frame_count) - 1;

                if (unwrap_prev_frame_num < 0)

                    unwrap_prev_frame_num += max_frame_num;



                g->poc.prev_frame_num = unwrap_prev_frame_num;

            }

        }



        /* See if we have a decoded first field looking for a pair...

         * Here, we're using that to see if we should mark previously

         * decode frames as ""finished"".

         * We have to do that before the ""dummy"" in-between frame allocation,

         * since that can modify s->current_picture_ptr. */

        if (g->first_field) {

            assert(g->cur_pic_ptr);

            assert(g->cur_pic_ptr->f->buf[0]);

            assert(g->cur_pic_ptr->reference != DELAYED_PIC_REF);



            /* figure out if we have a complementary field pair */

            if (!FIELD_PICTURE(g) || g->picture_structure == last_pic_structure) {

                /* Previous field is unmatched. Don't display it, but let it

                 * remain for reference if marked as such. */

                if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {

                    ff_thread_report_progress(&g->cur_pic_ptr->tf, INT_MAX,

                                              last_pic_structure == PICT_TOP_FIELD);

                }

            } else {

                if (g->cur_pic_ptr->frame_num != g->poc.frame_num) {

                    /* This and previous field were reference, but had

                     * different frame_nums. Consider this field first in

                     * pair. Throw away previous field except for reference

                     * purposes. */

                    if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {

                        ff_thread_report_progress(&g->cur_pic_ptr->tf, INT_MAX,

                                                  last_pic_structure == PICT_TOP_FIELD);

                    }

                } else {

                    /* Second field in complementary pair */

                    if (!((last_pic_structure   == PICT_TOP_FIELD &&

                           g->picture_structure == PICT_BOTTOM_FIELD) ||

                          (last_pic_structure   == PICT_BOTTOM_FIELD &&

                           g->picture_structure == PICT_TOP_FIELD))) {

                        av_log(g->avctx, AV_LOG_ERROR,

                               ""Invalid field mode combination %d/%d
"",

                               last_pic_structure, g->picture_structure);

                        g->picture_structure = last_pic_structure;

                        g->droppable         = last_pic_droppable;

                        return AVERROR_INVALIDDATA;

                    } else if (last_pic_droppable != g->droppable) {

                        avpriv_request_sample(g->avctx,

                                              ""Found reference and non-reference fields in the same frame, which"");

                        g->picture_structure = last_pic_structure;

                        g->droppable         = last_pic_droppable;

                        return AVERROR_PATCHWELCOME;

                    }

                }

            }

        }



        while (g->poc.frame_num != g->poc.prev_frame_num &&

               g->poc.frame_num != (g->poc.prev_frame_num + 1) % (1 << sps->log2_max_frame_num)) {

            H264Picture *prev = g->short_ref_count ? g->short_ref[0] : NULL;

            av_log(g->avctx, AV_LOG_DEBUG, ""Frame num gap %d %d
"",

                   g->poc.frame_num, g->poc.prev_frame_num);

            ret = initialize_cur_frame(g);

            if (ret < 0) {

                g->first_field = 0;

                return ret;

            }



            g->poc.prev_frame_num++;

            g->poc.prev_frame_num        %= 1 << sps->log2_max_frame_num;

            g->cur_pic_ptr->frame_num = g->poc.prev_frame_num;

            ff_thread_report_progress(&g->cur_pic_ptr->tf, INT_MAX, 0);

            ff_thread_report_progress(&g->cur_pic_ptr->tf, INT_MAX, 1);

            ret = ff_generate_sliding_window_mmcos(g, 1);

            if (ret < 0 && (g->avctx->err_recognition & AV_EF_EXPLODE))

                return ret;

            ret = ff_h264_execute_ref_pic_marking(g, g->mmco, g->mmco_index);

            if (ret < 0 && (g->avctx->err_recognition & AV_EF_EXPLODE))

                return ret;

            /* Error concealment: If a ref is missing, copy the previous ref

             * in its place.

             * FIXME: Avoiding a memcpy would be nice, but ref handling makes

             * many assumptions about there being no actual duplicates.

             * FIXME: This does not copy padding for out-of-frame motion

             * vectors.  Given we are concealing a lost frame, this probably

             * is not noticeable by comparison, but it should be fixed. */

            if (g->short_ref_count) {

                if (prev &&

                    g->short_ref[0]->f->width == prev->f->width &&

                    g->short_ref[0]->f->height == prev->f->height &&

                    g->short_ref[0]->f->format == prev->f->format) {

                    av_image_copy(g->short_ref[0]->f->data,

                                  g->short_ref[0]->f->linesize,

                                  (const uint8_t **)prev->f->data,

                                  prev->f->linesize,

                                  prev->f->format,

                                  g->mb_width  * 16,

                                  g->mb_height * 16);

                    g->short_ref[0]->poc = prev->poc + 2;

                }

                g->short_ref[0]->frame_num = g->poc.prev_frame_num;

            }

        }



        /* See if we have a decoded first field looking for a pair...

         * We're using that to see whether to continue decoding in that

         * frame, or to allocate a new one. */

        if (g->first_field) {

            assert(g->cur_pic_ptr);

            assert(g->cur_pic_ptr->f->buf[0]);

            assert(g->cur_pic_ptr->reference != DELAYED_PIC_REF);



            /* figure out if we have a complementary field pair */

            if (!FIELD_PICTURE(g) || g->picture_structure == last_pic_structure) {

                /* Previous field is unmatched. Don't display it, but let it

                 * remain for reference if marked as such. */

                g->cur_pic_ptr = NULL;

                g->first_field = FIELD_PICTURE(g);

            } else {

                if (g->cur_pic_ptr->frame_num != g->poc.frame_num) {

                    /* This and the previous field had different frame_nums.

                     * Consider this field first in pair. Throw away previous

                     * one except for reference purposes. */

                    g->first_field = 1;

                    g->cur_pic_ptr = NULL;

                } else {

                    /* Second field in complementary pair */

                    g->first_field = 0;

                }

            }

        } else {

            /* Frame or first field in a potentially complementary pair */

            g->first_field = FIELD_PICTURE(g);

        }



        if (!FIELD_PICTURE(g) || g->first_field) {

            if (h264_frame_start(g) < 0) {

                g->first_field = 0;

                return AVERROR_INVALIDDATA;

            }

        } else {

            release_unused_pictures(g, 0);

        }

    }



    assert(g->mb_num == g->mb_width * g->mb_height);

    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(g) >= g->mb_num ||

        first_mb_in_slice >= g->mb_num) {

        av_log(g->avctx, AV_LOG_ERROR, ""first_mb_in_slice overflow
"");

        return AVERROR_INVALIDDATA;

    }

    sf->resync_mb_x = sf->mb_x =  first_mb_in_slice % g->mb_width;

    sf->resync_mb_y = sf->mb_y = (first_mb_in_slice / g->mb_width) <<

                                 FIELD_OR_MBAFF_PICTURE(g);

    if (g->picture_structure == PICT_BOTTOM_FIELD)

        sf->resync_mb_y = sf->mb_y = sf->mb_y + 1;

    assert(sf->mb_y < g->mb_height);



    if (g->picture_structure == PICT_FRAME) {

        g->curr_pic_num = g->poc.frame_num;

        g->max_pic_num  = 1 << sps->log2_max_frame_num;

    } else {

        g->curr_pic_num = 2 * g->poc.frame_num + 1;

        g->max_pic_num  = 1 << (sps->log2_max_frame_num + 1);

    }



    if (g->nal_unit_type == NAL_IDR_SLICE)

        get_ue_golomb(&sf->gb); /* idr_pic_id */



    if (sps->poc_type == 0) {

        int poc_lsb = get_bits(&sf->gb, sps->log2_max_poc_lsb);



        if (!h->setup_finished)

            g->poc.poc_lsb = poc_lsb;



        if (pps->pic_order_present == 1 && g->picture_structure == PICT_FRAME) {

            int delta_poc_bottom = get_se_golomb(&sf->gb);

            if (!h->setup_finished)

                g->poc.delta_poc_bottom = delta_poc_bottom;

        }

    }



    if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) {

        int delta_poc = get_se_golomb(&sf->gb);



        if (!h->setup_finished)

            g->poc.delta_poc[0] = delta_poc;



        if (pps->pic_order_present == 1 && g->picture_structure == PICT_FRAME) {

            delta_poc = get_se_golomb(&sf->gb);



            if (!h->setup_finished)

                g->poc.delta_poc[1] = delta_poc;

        }

    }



    if (!h->setup_finished)

        ff_h264_init_poc(g->cur_pic_ptr->field_poc, &g->cur_pic_ptr->poc,

                         sps, &g->poc, g->picture_structure, g->nal_ref_idc);



    if (pps->redundant_pic_cnt_present)

        sf->redundant_pic_count = get_ue_golomb(&sf->gb);



    if (sf->slice_type_nos == AV_PICTURE_TYPE_B)

        sf->direct_spatial_mv_pred = get_bits1(&sf->gb);



    ret = ff_h264_parse_ref_count(&sf->list_count, sf->ref_count,

                                  &sf->gb, pps, sf->slice_type_nos,

                                  g->picture_structure);

    if (ret < 0)

        return ret;



    if (sf->slice_type_nos != AV_PICTURE_TYPE_I) {

       ret = ff_h264_decode_ref_pic_list_reordering(g, sf);

       if (ret < 0) {

           sf->ref_count[1] = sf->ref_count[0] = 0;

           return ret;

       }

    }



    sf->pwt.use_weight = 0;

    for (i = 0; i < 2; i++) {

        sf->pwt.luma_weight_flag[i]   = 0;

        sf->pwt.chroma_weight_flag[i] = 0;

    }

    if ((pps->weighted_pred && sf->slice_type_nos == AV_PICTURE_TYPE_P) ||

        (pps->weighted_bipred_idc == 1 &&

         sf->slice_type_nos == AV_PICTURE_TYPE_B))

        ff_h264_pred_weight_table(&sf->gb, sps, sf->ref_count,

                                  sf->slice_type_nos, &sf->pwt);



    // If frame-mt is enabled, only update mmco tables for the first slice

    // in a field. Subsequent slices can temporarily clobber g->mmco_index

    // or g->mmco, which will cause ref list mix-ups and decoding errors

    // further down the line. This may break decoding if the first slice is

    // corrupt, thus we only do this if frame-mt is enabled.

    if (g->nal_ref_idc) {

        ret = ff_h264_decode_ref_pic_marking(g, &sf->gb,

                                             !(g->avctx->active_thread_type & FF_THREAD_FRAME) ||

                                             g->current_slice == 0);

        if (ret < 0 && (g->avctx->err_recognition & AV_EF_EXPLODE))

            return AVERROR_INVALIDDATA;

    }



    if (sf->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) {

        tmp = get_ue_golomb_31(&sf->gb);

        if (tmp > 2) {

            av_log(g->avctx, AV_LOG_ERROR, ""cabac_init_idc %u overflow
"", tmp);

            return AVERROR_INVALIDDATA;

        }

        sf->cabac_init_idc = tmp;

    }



    sf->last_qscale_diff = 0;

    tmp = pps->init_qp + get_se_golomb(&sf->gb);

    if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) {

        av_log(g->avctx, AV_LOG_ERROR, ""QP %u out of range
"", tmp);

        return AVERROR_INVALIDDATA;

    }

    sf->qscale       = tmp;

    sf->chroma_qp[0] = get_chroma_qp(g, 0, sf->qscale);

    sf->chroma_qp[1] = get_chroma_qp(g, 1, sf->qscale);

    // FIXME qscale / qp ... stuff

    if (sf->slice_type == AV_PICTURE_TYPE_SP)

        get_bits1(&sf->gb); /* sp_for_switch_flag */

    if (sf->slice_type == AV_PICTURE_TYPE_SP ||

        sf->slice_type == AV_PICTURE_TYPE_SI)

        get_se_golomb(&sf->gb); /* slice_qs_delta */



    sf->deblocking_filter     = 1;

    sf->slice_alpha_c0_offset = 0;

    sf->slice_beta_offset     = 0;

    if (pps->deblocking_filter_parameters_present) {

        tmp = get_ue_golomb_31(&sf->gb);

        if (tmp > 2) {

            av_log(g->avctx, AV_LOG_ERROR,

                   ""deblocking_filter_idc %u out of range
"", tmp);

            return AVERROR_INVALIDDATA;

        }

        sf->deblocking_filter = tmp;

        if (sf->deblocking_filter < 2)

            sf->deblocking_filter ^= 1;  // 1<->0



        if (sf->deblocking_filter) {

            sf->slice_alpha_c0_offset = get_se_golomb(&sf->gb) * 2;

            sf->slice_beta_offset     = get_se_golomb(&sf->gb) * 2;

            if (sf->slice_alpha_c0_offset >  12 ||

                sf->slice_alpha_c0_offset < -12 ||

                sf->slice_beta_offset >  12     ||

                sf->slice_beta_offset < -12) {

                av_log(g->avctx, AV_LOG_ERROR,

                       ""deblocking filter parameters %d %d out of range
"",

                       sf->slice_alpha_c0_offset, sf->slice_beta_offset);

                return AVERROR_INVALIDDATA;

            }

        }

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"h,sl,sps,pps,first_mb_in_slice,pps_id,ret,slice_type,tmp,i,last_pic_structure,last_pic_droppable,field_pic_flag,bottom_field_flag,frame_num,droppable,picture_structure","h:0.32284247875213623,sl:0.23649972677230835,sps:-0.1212431788444519,pps:-0.21267592906951904,first_mb_in_slice:0.1130150556564331,pps_id:-0.014712393283843994,ret:0.023295819759368896,slice_type:0.011862039566040039,tmp:0.029588699340820312,i:0.027006328105926514,last_pic_structure:-0.05420660972595215,last_pic_droppable:0.03402078151702881,field_pic_flag:-0.03485947847366333,bottom_field_flag:-0.0358891487121582,frame_num:0.003129243850708008,droppable:-0.0056160688400268555,picture_structure:0.01962888240814209,",2,311,0,"h:g,sl:sf,",0,Greedy,662,0.45523961782455447,replace,[]
129,"static void decode_opc (CPUMIPSState *env, DisasContext *ctx)

{

    int32_t offset;

    int rs, rt, rd, sa;

    uint32_t op, op1;

    int16_t imm;



    /* make sure instructions are on a word boundary */

    if (ctx->pc & 0x3) {

        env->CP0_BadVAddr = ctx->pc;

        generate_exception(ctx, EXCP_AdEL);

        return;

    }



    /* Handle blikely not taken case */

    if ((ctx->hflags & MIPS_HFLAG_BMASK_BASE) == MIPS_HFLAG_BL) {

        int l1 = gen_new_label();



        MIPS_DEBUG(""blikely condition ("" TARGET_FMT_lx "")"", ctx->pc + 4);

        tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);

        tcg_gen_movi_i32(hflags, ctx->hflags & ~MIPS_HFLAG_BMASK);

        gen_goto_tb(ctx, 1, ctx->pc + 4);

        gen_set_label(l1);

    }



    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {

        tcg_gen_debug_insn_start(ctx->pc);

    }



    op = MASK_OP_MAJOR(ctx->opcode);

    rs = (ctx->opcode >> 21) & 0x1f;

    rt = (ctx->opcode >> 16) & 0x1f;

    rd = (ctx->opcode >> 11) & 0x1f;

    sa = (ctx->opcode >> 6) & 0x1f;

    imm = (int16_t)ctx->opcode;

    switch (op) {

    case OPC_SPECIAL:

        decode_opc_special(env, ctx);

        break;

    case OPC_SPECIAL2:

        decode_opc_special2_legacy(env, ctx);

        break;

    case OPC_SPECIAL3:

        decode_opc_special3(env, ctx);

        break;

    case OPC_REGIMM:

        op1 = MASK_REGIMM(ctx->opcode);

        switch (op1) {

        case OPC_BLTZL: /* REGIMM branches */

        case OPC_BGEZL:

        case OPC_BLTZALL:

        case OPC_BGEZALL:

            check_insn_opc_removed(ctx, ISA_MIPS32R6);

        case OPC_BLTZ:

        case OPC_BGEZ:

            gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);

            break;

        case OPC_BLTZAL:

        case OPC_BGEZAL:

            if (ctx->insn_flags & ISA_MIPS32R6) {

                if (rs == 0) {

                    /* OPC_NAL, OPC_BAL */

                    gen_compute_branch(ctx, op1, 4, 0, -1, imm << 2, 4);

                } else {

                    generate_exception(ctx, EXCP_RI);

                }

            } else {

                gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);

            }

            break;

        case OPC_TGEI ... OPC_TEQI: /* REGIMM traps */

        case OPC_TNEI:

            check_insn_opc_removed(ctx, ISA_MIPS32R6);

            gen_trap(ctx, op1, rs, -1, imm);

            break;

        case OPC_SYNCI:

            check_insn(ctx, ISA_MIPS32R2);

            /* Break the TB to be able to sync copied instructions

               immediately */

            ctx->bstate = BS_STOP;

            break;

        case OPC_BPOSGE32:    /* MIPS DSP branch */

#if defined(TARGET_MIPS64)

        case OPC_BPOSGE64:

#endif

            check_dsp(ctx);

            gen_compute_branch(ctx, op1, 4, -1, -2, (int32_t)imm << 2, 4);

            break;

#if defined(TARGET_MIPS64)

        case OPC_DAHI:

            check_insn(ctx, ISA_MIPS32R6);

            check_mips_64(ctx);

            if (rs != 0) {

                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 32);

            }

            MIPS_DEBUG(""dahi %s, %04x"", regnames[rs], imm);

            break;

        case OPC_DATI:

            check_insn(ctx, ISA_MIPS32R6);

            check_mips_64(ctx);

            if (rs != 0) {

                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 48);

            }

            MIPS_DEBUG(""dati %s, %04x"", regnames[rs], imm);

            break;

#endif

        default:            /* Invalid */

            MIPS_INVAL(""regimm"");

            generate_exception(ctx, EXCP_RI);

            break;

        }

        break;

    case OPC_CP0:

        check_cp0_enabled(ctx);

        op1 = MASK_CP0(ctx->opcode);

        switch (op1) {

        case OPC_MFC0:

        case OPC_MTC0:

        case OPC_MFTR:

        case OPC_MTTR:

#if defined(TARGET_MIPS64)

        case OPC_DMFC0:

        case OPC_DMTC0:

#endif

#ifndef CONFIG_USER_ONLY

            gen_cp0(env, ctx, op1, rt, rd);

#endif /* !CONFIG_USER_ONLY */

            break;

        case OPC_C0_FIRST ... OPC_C0_LAST:

#ifndef CONFIG_USER_ONLY

            gen_cp0(env, ctx, MASK_C0(ctx->opcode), rt, rd);

#endif /* !CONFIG_USER_ONLY */

            break;

        case OPC_MFMC0:

#ifndef CONFIG_USER_ONLY

            {

                uint32_t op2;

                TCGv t0 = tcg_temp_new();



                op2 = MASK_MFMC0(ctx->opcode);

                switch (op2) {

                case OPC_DMT:

                    check_insn(ctx, ASE_MT);

                    gen_helper_dmt(t0);

                    gen_store_gpr(t0, rt);

                    break;

                case OPC_EMT:

                    check_insn(ctx, ASE_MT);

                    gen_helper_emt(t0);

                    gen_store_gpr(t0, rt);

                    break;

                case OPC_DVPE:

                    check_insn(ctx, ASE_MT);

                    gen_helper_dvpe(t0, cpu_env);

                    gen_store_gpr(t0, rt);

                    break;

                case OPC_EVPE:

                    check_insn(ctx, ASE_MT);

                    gen_helper_evpe(t0, cpu_env);

                    gen_store_gpr(t0, rt);

                    break;

                case OPC_DI:

                    check_insn(ctx, ISA_MIPS32R2);

                    save_cpu_state(ctx, 1);

                    gen_helper_di(t0, cpu_env);

                    gen_store_gpr(t0, rt);

                    /* Stop translation as we may have switched the execution mode */

                    ctx->bstate = BS_STOP;

                    break;

                case OPC_EI:

                    check_insn(ctx, ISA_MIPS32R2);

                    save_cpu_state(ctx, 1);

                    gen_helper_ei(t0, cpu_env);

                    gen_store_gpr(t0, rt);

                    /* Stop translation as we may have switched the execution mode */

                    ctx->bstate = BS_STOP;

                    break;

                default:            /* Invalid */

                    MIPS_INVAL(""mfmc0"");

                    generate_exception(ctx, EXCP_RI);

                    break;

                }

                tcg_temp_free(t0);

            }

#endif /* !CONFIG_USER_ONLY */

            break;

        case OPC_RDPGPR:

            check_insn(ctx, ISA_MIPS32R2);

            gen_load_srsgpr(rt, rd);

            break;

        case OPC_WRPGPR:

            check_insn(ctx, ISA_MIPS32R2);

            gen_store_srsgpr(rt, rd);

            break;

        default:

            MIPS_INVAL(""cp0"");

            generate_exception(ctx, EXCP_RI);

            break;

        }

        break;

    case OPC_BOVC: /* OPC_BEQZALC, OPC_BEQC, OPC_ADDI */

        if (ctx->insn_flags & ISA_MIPS32R6) {

            /* OPC_BOVC, OPC_BEQZALC, OPC_BEQC */

            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);

        } else {

            /* OPC_ADDI */

            /* Arithmetic with immediate opcode */

            gen_arith_imm(ctx, op, rt, rs, imm);

        }

        break;

    case OPC_ADDIU:

         gen_arith_imm(ctx, op, rt, rs, imm);

         break;

    case OPC_SLTI: /* Set on less than with immediate opcode */

    case OPC_SLTIU:

         gen_slt_imm(ctx, op, rt, rs, imm);

         break;

    case OPC_ANDI: /* Arithmetic with immediate opcode */

    case OPC_LUI: /* OPC_AUI */

    case OPC_ORI:

    case OPC_XORI:

         gen_logic_imm(ctx, op, rt, rs, imm);

         break;

    case OPC_J ... OPC_JAL: /* Jump */

         offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;

         gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);

         break;

    /* Branch */

    case OPC_BLEZC: /* OPC_BGEZC, OPC_BGEC, OPC_BLEZL */

        if (ctx->insn_flags & ISA_MIPS32R6) {

            if (rt == 0) {

                generate_exception(ctx, EXCP_RI);

                break;

            }

            /* OPC_BLEZC, OPC_BGEZC, OPC_BGEC */

            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);

        } else {

            /* OPC_BLEZL */

            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);

        }

        break;

    case OPC_BGTZC: /* OPC_BLTZC, OPC_BLTC, OPC_BGTZL */

        if (ctx->insn_flags & ISA_MIPS32R6) {

            if (rt == 0) {

                generate_exception(ctx, EXCP_RI);

                break;

            }

            /* OPC_BGTZC, OPC_BLTZC, OPC_BLTC */

            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);

        } else {

            /* OPC_BGTZL */

            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);

        }

        break;

    case OPC_BLEZALC: /* OPC_BGEZALC, OPC_BGEUC, OPC_BLEZ */

        if (rt == 0) {

            /* OPC_BLEZ */

            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);

        } else {

            check_insn(ctx, ISA_MIPS32R6);

            /* OPC_BLEZALC, OPC_BGEZALC, OPC_BGEUC */

            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);

        }

        break;

    case OPC_BGTZALC: /* OPC_BLTZALC, OPC_BLTUC, OPC_BGTZ */

        if (rt == 0) {

            /* OPC_BGTZ */

            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);

        } else {

            check_insn(ctx, ISA_MIPS32R6);

            /* OPC_BGTZALC, OPC_BLTZALC, OPC_BLTUC */

            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);

        }

        break;

    case OPC_BEQL:

    case OPC_BNEL:

         check_insn_opc_removed(ctx, ISA_MIPS32R6);

    case OPC_BEQ:

    case OPC_BNE:

         gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);

         break;

    case OPC_LWL: /* Load and stores */

    case OPC_LWR:

    case OPC_LL:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

    case OPC_LB ... OPC_LH:

    case OPC_LW ... OPC_LHU:

         gen_ld(ctx, op, rt, rs, imm);

         break;

    case OPC_SWL:

    case OPC_SWR:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

    case OPC_SB ... OPC_SH:

    case OPC_SW:

         gen_st(ctx, op, rt, rs, imm);

         break;

    case OPC_SC:

         check_insn_opc_removed(ctx, ISA_MIPS32R6);

         gen_st_cond(ctx, op, rt, rs, imm);

         break;

    case OPC_CACHE:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

        check_cp0_enabled(ctx);

        check_insn(ctx, ISA_MIPS3 | ISA_MIPS32);

        /* Treat as NOP. */

        break;

    case OPC_PREF:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

        check_insn(ctx, ISA_MIPS4 | ISA_MIPS32);

        /* Treat as NOP. */

        break;



    /* Floating point (COP1). */

    case OPC_LWC1:

    case OPC_LDC1:

    case OPC_SWC1:

    case OPC_SDC1:

        gen_cop1_ldst(ctx, op, rt, rs, imm);

        break;



    case OPC_CP1:

        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {

            check_cp1_enabled(ctx);

            op1 = MASK_CP1(ctx->opcode);

            switch (op1) {

            case OPC_MFHC1:

            case OPC_MTHC1:

                check_insn(ctx, ISA_MIPS32R2);

            case OPC_MFC1:

            case OPC_CFC1:

            case OPC_MTC1:

            case OPC_CTC1:

                gen_cp1(ctx, op1, rt, rd);

                break;

#if defined(TARGET_MIPS64)

            case OPC_DMFC1:

            case OPC_DMTC1:

                check_insn(ctx, ISA_MIPS3);

                gen_cp1(ctx, op1, rt, rd);

                break;

#endif

            case OPC_BC1EQZ: /* OPC_BC1ANY2 */

                if (ctx->insn_flags & ISA_MIPS32R6) {

                    /* OPC_BC1EQZ */

                    gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),

                                    rt, imm << 2);

                } else {

                    /* OPC_BC1ANY2 */

                    check_cop1x(ctx);

                    check_insn(ctx, ASE_MIPS3D);

                    gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),

                                    (rt >> 2) & 0x7, imm << 2);

                }

                break;

            case OPC_BC1NEZ:

                check_insn(ctx, ISA_MIPS32R6);

                gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),

                                rt, imm << 2);

                break;

            case OPC_BC1ANY4:

                check_insn_opc_removed(ctx, ISA_MIPS32R6);

                check_cop1x(ctx);

                check_insn(ctx, ASE_MIPS3D);

                /* fall through */

            case OPC_BC1:

                check_insn_opc_removed(ctx, ISA_MIPS32R6);

                gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),

                                    (rt >> 2) & 0x7, imm << 2);

                break;

            case OPC_PS_FMT:

                check_insn_opc_removed(ctx, ISA_MIPS32R6);

            case OPC_S_FMT:

            case OPC_D_FMT:

                gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,

                           (imm >> 8) & 0x7);

                break;

            case OPC_W_FMT:

            case OPC_L_FMT:

            {

                int r6_op = ctx->opcode & FOP(0x3f, 0x1f);

                if (ctx->insn_flags & ISA_MIPS32R6) {

                    switch (r6_op) {

                    case R6_OPC_CMP_AF_S:

                    case R6_OPC_CMP_UN_S:

                    case R6_OPC_CMP_EQ_S:

                    case R6_OPC_CMP_UEQ_S:

                    case R6_OPC_CMP_LT_S:

                    case R6_OPC_CMP_ULT_S:

                    case R6_OPC_CMP_LE_S:

                    case R6_OPC_CMP_ULE_S:

                    case R6_OPC_CMP_SAF_S:

                    case R6_OPC_CMP_SUN_S:

                    case R6_OPC_CMP_SEQ_S:

                    case R6_OPC_CMP_SEUQ_S:

                    case R6_OPC_CMP_SLT_S:

                    case R6_OPC_CMP_SULT_S:

                    case R6_OPC_CMP_SLE_S:

                    case R6_OPC_CMP_SULE_S:

                    case R6_OPC_CMP_OR_S:

                    case R6_OPC_CMP_UNE_S:

                    case R6_OPC_CMP_NE_S:

                    case R6_OPC_CMP_SOR_S:

                    case R6_OPC_CMP_SUNE_S:

                    case R6_OPC_CMP_SNE_S:

                        gen_r6_cmp_s(ctx, ctx->opcode & 0x1f, rt, rd, sa);

                        break;

                    case R6_OPC_CMP_AF_D:

                    case R6_OPC_CMP_UN_D:

                    case R6_OPC_CMP_EQ_D:

                    case R6_OPC_CMP_UEQ_D:

                    case R6_OPC_CMP_LT_D:

                    case R6_OPC_CMP_ULT_D:

                    case R6_OPC_CMP_LE_D:

                    case R6_OPC_CMP_ULE_D:

                    case R6_OPC_CMP_SAF_D:

                    case R6_OPC_CMP_SUN_D:

                    case R6_OPC_CMP_SEQ_D:

                    case R6_OPC_CMP_SEUQ_D:

                    case R6_OPC_CMP_SLT_D:

                    case R6_OPC_CMP_SULT_D:

                    case R6_OPC_CMP_SLE_D:

                    case R6_OPC_CMP_SULE_D:

                    case R6_OPC_CMP_OR_D:

                    case R6_OPC_CMP_UNE_D:

                    case R6_OPC_CMP_NE_D:

                    case R6_OPC_CMP_SOR_D:

                    case R6_OPC_CMP_SUNE_D:

                    case R6_OPC_CMP_SNE_D:

                        gen_r6_cmp_d(ctx, ctx->opcode & 0x1f, rt, rd, sa);

                        break;

                    default:

                        gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,

                                                       (imm >> 8) & 0x7);

                        break;

                    }

                } else {

                    gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,

                               (imm >> 8) & 0x7);

                }

                break;

            }

            default:

                MIPS_INVAL(""cp1"");

                generate_exception (ctx, EXCP_RI);

                break;

            }

        } else {

            generate_exception_err(ctx, EXCP_CpU, 1);

        }

        break;



    /* Compact branches [R6] and COP2 [non-R6] */

    case OPC_BC: /* OPC_LWC2 */

    case OPC_BALC: /* OPC_SWC2 */

        if (ctx->insn_flags & ISA_MIPS32R6) {

            /* OPC_BC, OPC_BALC */

            gen_compute_compact_branch(ctx, op, 0, 0,

                                       sextract32(ctx->opcode << 2, 0, 28));

        } else {

            /* OPC_LWC2, OPC_SWC2 */

            /* COP2: Not implemented. */

            generate_exception_err(ctx, EXCP_CpU, 2);

        }

        break;

    case OPC_BEQZC: /* OPC_JIC, OPC_LDC2 */

    case OPC_BNEZC: /* OPC_JIALC, OPC_SDC2 */

        if (ctx->insn_flags & ISA_MIPS32R6) {

            if (rs != 0) {

                /* OPC_BEQZC, OPC_BNEZC */

                gen_compute_compact_branch(ctx, op, rs, 0,

                                           sextract32(ctx->opcode << 2, 0, 23));

            } else {

                /* OPC_JIC, OPC_JIALC */

                gen_compute_compact_branch(ctx, op, 0, rt, imm);

            }

        } else {

            /* OPC_LWC2, OPC_SWC2 */

            /* COP2: Not implemented. */

            generate_exception_err(ctx, EXCP_CpU, 2);

        }

        break;

    case OPC_CP2:

        check_insn(ctx, INSN_LOONGSON2F);

        /* Note that these instructions use different fields.  */

        gen_loongson_multimedia(ctx, sa, rd, rt);

        break;



    case OPC_CP3:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {

            check_cp1_enabled(ctx);

            op1 = MASK_CP3(ctx->opcode);

            switch (op1) {

            case OPC_LWXC1:

            case OPC_LDXC1:

            case OPC_LUXC1:

            case OPC_SWXC1:

            case OPC_SDXC1:

            case OPC_SUXC1:

                gen_flt3_ldst(ctx, op1, sa, rd, rs, rt);

                break;

            case OPC_PREFX:

                /* Treat as NOP. */

                break;

            case OPC_ALNV_PS:

            case OPC_MADD_S:

            case OPC_MADD_D:

            case OPC_MADD_PS:

            case OPC_MSUB_S:

            case OPC_MSUB_D:

            case OPC_MSUB_PS:

            case OPC_NMADD_S:

            case OPC_NMADD_D:

            case OPC_NMADD_PS:

            case OPC_NMSUB_S:

            case OPC_NMSUB_D:

            case OPC_NMSUB_PS:

                gen_flt3_arith(ctx, op1, sa, rs, rd, rt);

                break;

            default:

                MIPS_INVAL(""cp3"");

                generate_exception (ctx, EXCP_RI);

                break;

            }

        } else {

            generate_exception_err(ctx, EXCP_CpU, 1);

        }

        break;



#if defined(TARGET_MIPS64)

    /* MIPS64 opcodes */

    case OPC_LDL ... OPC_LDR:

    case OPC_LLD:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

    case OPC_LWU:

    case OPC_LD:

        check_insn(ctx, ISA_MIPS3);

        check_mips_64(ctx);

        gen_ld(ctx, op, rt, rs, imm);

        break;

    case OPC_SDL ... OPC_SDR:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

    case OPC_SD:

        check_insn(ctx, ISA_MIPS3);

        check_mips_64(ctx);

        gen_st(ctx, op, rt, rs, imm);

        break;

    case OPC_SCD:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

        check_insn(ctx, ISA_MIPS3);

        check_mips_64(ctx);

        gen_st_cond(ctx, op, rt, rs, imm);

        break;

    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC, OPC_DADDI */

        if (ctx->insn_flags & ISA_MIPS32R6) {

            /* OPC_BNVC, OPC_BNEZALC, OPC_BNEC */

            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);

        } else {

            /* OPC_DADDI */

            check_insn(ctx, ISA_MIPS3);

            check_mips_64(ctx);

            gen_arith_imm(ctx, op, rt, rs, imm);

        }

        break;

    case OPC_DADDIU:

        check_insn(ctx, ISA_MIPS3);

        check_mips_64(ctx);

        gen_arith_imm(ctx, op, rt, rs, imm);

        break;

#else

    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC */

        if (ctx->insn_flags & ISA_MIPS32R6) {

            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);

        } else {

            MIPS_INVAL(""major opcode"");

            generate_exception(ctx, EXCP_RI);

        }

        break;

#endif

    case OPC_DAUI: /* OPC_JALX */

        if (ctx->insn_flags & ISA_MIPS32R6) {

#if defined(TARGET_MIPS64)

            /* OPC_DAUI */

            check_mips_64(ctx);

            if (rt != 0) {

                TCGv t0 = tcg_temp_new();

                gen_load_gpr(t0, rs);

                tcg_gen_addi_tl(cpu_gpr[rt], t0, imm << 16);

                tcg_temp_free(t0);

            }

            MIPS_DEBUG(""daui %s, %s, %04x"", regnames[rt], regnames[rs], imm);

#else

            generate_exception(ctx, EXCP_RI);

            MIPS_INVAL(""major opcode"");

#endif

        } else {

            /* OPC_JALX */

            check_insn(ctx, ASE_MIPS16 | ASE_MICROMIPS);

            offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;

            gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);

        }

        break;

    case OPC_MDMX:

        check_insn(ctx, ASE_MDMX);

        /* MDMX: Not implemented. */

        break;

    case OPC_PCREL:

        check_insn(ctx, ISA_MIPS32R6);

        gen_pcrel(ctx, rs, imm);

        break;

    default:            /* Invalid */

        MIPS_INVAL(""major opcode"");

        generate_exception(ctx, EXCP_RI);

        break;

    }

}
",3568,,LABEL_0,LABEL_0,LABEL_0,-1,"env,ctx,offset,rs,rt,rd,sa,op,op1,imm",,10,429,0,,0,GA,2425,2.25260884364446,failed,[]
130,"static int decode_slice_header(FFV1Context *f, FFV1Context *fs)

{

    RangeCoder *c = &fs->c;

    uint8_t state[CONTEXT_SIZE];

    unsigned ps, i, context_count;

    memset(state, 128, sizeof(state));



    if (fs->ac > 1) {

        for (i = 1; i < 256; i++) {

            fs->c.one_state[i]        = f->state_transition[i];

            fs->c.zero_state[256 - i] = 256 - fs->c.one_state[i];

        }

    }



    fs->slice_x      = get_symbol(c, state, 0) * f->width;

    fs->slice_y      = get_symbol(c, state, 0) * f->height;

    fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width + fs->slice_x;

    fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;



    fs->slice_x     /= f->num_h_slices;

    fs->slice_y     /= f->num_v_slices;

    fs->slice_width  = fs->slice_width / f->num_h_slices - fs->slice_x;

    fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;

    if ((unsigned)fs->slice_width  > f->width ||

        (unsigned)fs->slice_height > f->height)

        return AVERROR_INVALIDDATA;

    if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||

        (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)

        return AVERROR_INVALIDDATA;



    for (i = 0; i < f->plane_count; i++) {

        PlaneContext *const p = &fs->plane[i];

        int idx               = get_symbol(c, state, 0);

        if (idx > (unsigned)f->quant_table_count) {

            av_log(f->avctx, AV_LOG_ERROR, ""quant_table_index out of range\n"");

            return AVERROR_INVALIDDATA;

        }

        p->quant_table_index = idx;

        memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));

        context_count = f->context_count[idx];



        if (p->context_count < context_count) {

            av_freep(&p->state);

            av_freep(&p->vlc_state);

        }

        p->context_count = context_count;

    }



    ps = get_symbol(c, state, 0);

    if (ps == 1) {

        f->cur->interlaced_frame = 1;

        f->cur->top_field_first  = 1;

    } else if (ps == 2) {

        f->cur->interlaced_frame = 1;

        f->cur->top_field_first  = 0;

    } else if (ps == 3) {

        f->cur->interlaced_frame = 0;

    }

    f->cur->sample_aspect_ratio.num = get_symbol(c, state, 0);

    f->cur->sample_aspect_ratio.den = get_symbol(c, state, 0);



    if (av_image_check_sar(f->width, f->height,

                           f->cur->sample_aspect_ratio) < 0) {

        av_log(f->avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %u/%u\n"",

               f->cur->sample_aspect_ratio.num,

               f->cur->sample_aspect_ratio.den);

        f->cur->sample_aspect_ratio = (AVRational){ 0, 1 };

    }



    return 0;

}
",710,"static int decode_slice_header(FFV1Context *fw, FFV1Context *rows)

{

    RangeCoder *pc = &rows->pc;

    uint8_t sync[CONTEXT_SIZE];

    unsigned ps, index, context_count;

    memset(sync, 128, sizeof(sync));



    if (rows->ac > 1) {

        for (index = 1; index < 256; index++) {

            rows->pc.one_state[index]        = fw->state_transition[index];

            rows->pc.zero_state[256 - index] = 256 - rows->pc.one_state[index];

        }

    }



    rows->slice_x      = get_symbol(pc, sync, 0) * fw->width;

    rows->slice_y      = get_symbol(pc, sync, 0) * fw->height;

    rows->slice_width  = (get_symbol(pc, sync, 0) + 1) * fw->width + rows->slice_x;

    rows->slice_height = (get_symbol(pc, sync, 0) + 1) * fw->height + rows->slice_y;



    rows->slice_x     /= fw->num_h_slices;

    rows->slice_y     /= fw->num_v_slices;

    rows->slice_width  = rows->slice_width / fw->num_h_slices - rows->slice_x;

    rows->slice_height = rows->slice_height / fw->num_v_slices - rows->slice_y;

    if ((unsigned)rows->slice_width  > fw->width ||

        (unsigned)rows->slice_height > fw->height)

        return AVERROR_INVALIDDATA;

    if ((unsigned)rows->slice_x + (uint64_t)rows->slice_width  > fw->width ||

        (unsigned)rows->slice_y + (uint64_t)rows->slice_height > fw->height)

        return AVERROR_INVALIDDATA;



    for (index = 0; index < fw->plane_count; index++) {

        PlaneContext *const p = &rows->plane[index];

        int idx               = get_symbol(pc, sync, 0);

        if (idx > (unsigned)fw->quant_table_count) {

            av_log(fw->avctx, AV_LOG_ERROR, ""quant_table_index out of range
"");

            return AVERROR_INVALIDDATA;

        }

        p->quant_table_index = idx;

        memcpy(p->quant_table, fw->quant_tables[idx], sizeof(p->quant_table));

        context_count = fw->context_count[idx];



        if (p->context_count < context_count) {

            av_freep(&p->sync);

            av_freep(&p->vlc_state);

        }

        p->context_count = context_count;

    }



    ps = get_symbol(pc, sync, 0);

    if (ps == 1) {

        fw->cur->interlaced_frame = 1;

        fw->cur->top_field_first  = 1;

    } else if (ps == 2) {

        fw->cur->interlaced_frame = 1;

        fw->cur->top_field_first  = 0;

    } else if (ps == 3) {

        fw->cur->interlaced_frame = 0;

    }

    fw->cur->sample_aspect_ratio.num = get_symbol(pc, sync, 0);

    fw->cur->sample_aspect_ratio.den = get_symbol(pc, sync, 0);



    if (av_image_check_sar(fw->width, fw->height,

                           fw->cur->sample_aspect_ratio) < 0) {

        av_log(fw->avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %u/%u
"",

               fw->cur->sample_aspect_ratio.num,

               fw->cur->sample_aspect_ratio.den);

        fw->cur->sample_aspect_ratio = (AVRational){ 0, 1 };

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"f,fs,c,state,ps,i,context_count,p","f:0.009586572647094727,fs:0.008433759212493896,c:0.003666818141937256,state:0.0035996437072753906,ps:0.0011979341506958008,i:0.0033555030822753906,context_count:-0.00014609098434448242,p:0.0025278329849243164,",5,97,0,"f:fw,fs:rows,c:pc,state:sync,i:index,",0,Greedy,474,0.2002129077911377,replace,[]
131,"static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){

    MpegEncContext * const s = &h->s;

    Picture * const ref1 = &h->ref_list[1][0];

    int j, old_ref, rfield;

    int start= mbafi ? 16                      : 0;

    int end  = mbafi ? 16+2*h->ref_count[0]    : h->ref_count[0];

    int interl= mbafi || s->picture_structure != PICT_FRAME;



    /* bogus; fills in for missing frames */

    memset(map[list], 0, sizeof(map[list]));



    for(rfield=0; rfield<2; rfield++){

        for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){

            int poc = ref1->ref_poc[colfield][list][old_ref];



            if     (!interl)

                poc |= 3;

            else if( interl && (poc&3) == 3) //FIXME store all MBAFF references so this isnt needed

                poc= (poc&~3) + rfield + 1;



            for(j=start; j<end; j++){

                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {

                    int cur_ref= mbafi ? (j-16)^field : j;

                    map[list][2*old_ref + (rfield^field) + 16] = cur_ref;

                    if(rfield == field || !interl)

                        map[list][old_ref] = cur_ref;

                    break;

                }

            }

        }

    }

}
",362,,LABEL_0,LABEL_1,,-4,"h,map,list,field,colfield,mbafi,s,ref1,j,old_ref,rfield",,,,0,,0,Greedy,1,0.000616145133972168,,
132,"static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,

                            AVPacket *avpkt)

{

    const char *ptr = avpkt->data;

    int len, size = avpkt->size;



    while (size > 0) {

        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);

        int duration = dialog->end - dialog->start;

        len = ff_ass_add_rect(data, ptr, 0, duration, 1);

        if (len < 0)

            return len;

        ptr  += len;

        size -= len;

    }



    *got_sub_ptr = avpkt->size > 0;

    return avpkt->size;

}
",130,,LABEL_1,LABEL_0,,-4,"avctx,data,got_sub_ptr,avpkt,ptr,len,dialog",,,,0,,0,Greedy,1,0.0004741311073303223,,
133,"static int pnm_decode_header(AVCodecContext *avctx, PNMContext * const s){

    char buf1[32], tuple_type[32];

    int h, w, depth, maxval;;



    pnm_get(s, buf1, sizeof(buf1));

    if (!strcmp(buf1, ""P4"")) {

        avctx->pix_fmt = PIX_FMT_MONOWHITE;

    } else if (!strcmp(buf1, ""P5"")) {

        if (avctx->codec_id == CODEC_ID_PGMYUV) 

            avctx->pix_fmt = PIX_FMT_YUV420P;

        else

            avctx->pix_fmt = PIX_FMT_GRAY8;

    } else if (!strcmp(buf1, ""P6"")) {

        avctx->pix_fmt = PIX_FMT_RGB24;

    } else if (!strcmp(buf1, ""P7"")) {

        w = -1;

        h = -1;

        maxval = -1;

        depth = -1;

        tuple_type[0] = '\0';

        for(;;) {

            pnm_get(s, buf1, sizeof(buf1));

            if (!strcmp(buf1, ""WIDTH"")) {

                pnm_get(s, buf1, sizeof(buf1));

                w = strtol(buf1, NULL, 10);

            } else if (!strcmp(buf1, ""HEIGHT"")) {

                pnm_get(s, buf1, sizeof(buf1));

                h = strtol(buf1, NULL, 10);

            } else if (!strcmp(buf1, ""DEPTH"")) {

                pnm_get(s, buf1, sizeof(buf1));

                depth = strtol(buf1, NULL, 10);

            } else if (!strcmp(buf1, ""MAXVAL"")) {

                pnm_get(s, buf1, sizeof(buf1));

                maxval = strtol(buf1, NULL, 10);

            } else if (!strcmp(buf1, ""TUPLETYPE"")) {

                pnm_get(s, tuple_type, sizeof(tuple_type));

            } else if (!strcmp(buf1, ""ENDHDR"")) {

                break;

            } else {

                return -1;

            }

        }

        /* check that all tags are present */

        if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type[0] == '\0')

            return -1;

        avctx->width = w;

        avctx->height = h;

        if (depth == 1) {

            if (maxval == 1)

                avctx->pix_fmt = PIX_FMT_MONOWHITE;

            else 

                avctx->pix_fmt = PIX_FMT_GRAY8;

        } else if (depth == 3) {

            avctx->pix_fmt = PIX_FMT_RGB24;

        } else if (depth == 4) {

            avctx->pix_fmt = PIX_FMT_RGBA32;

        } else {

            return -1;

        }

        return 0;

    } else {

        return -1;

    }

    pnm_get(s, buf1, sizeof(buf1));

    avctx->width = atoi(buf1);

    if (avctx->width <= 0)

        return -1;

    pnm_get(s, buf1, sizeof(buf1));

    avctx->height = atoi(buf1);

    if (avctx->height <= 0)

        return -1;

    if (avctx->pix_fmt != PIX_FMT_MONOWHITE) {

        pnm_get(s, buf1, sizeof(buf1));

    }



    /* more check if YUV420 */

    if (avctx->pix_fmt == PIX_FMT_YUV420P) {

        if ((avctx->width & 1) != 0)

            return -1;

        h = (avctx->height * 2);

        if ((h % 3) != 0)

            return -1;

        h /= 3;

        avctx->height = h;

    }

    return 0;

}
",672,,LABEL_1,LABEL_0,,-4,"avctx,s,buf1,tuple_type,h,w,depth,maxval",,,,0,,0,Greedy,1,0.0007750312487284343,,
134,"static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;


    PTXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    unsigned int offset, w, h, y, stride, bytes_per_pixel;

    uint8_t *ptr;





    offset          = AV_RL16(buf);

    w               = AV_RL16(buf+8);

    h               = AV_RL16(buf+10);

    bytes_per_pixel = AV_RL16(buf+12) >> 3;



    if (bytes_per_pixel != 2) {

        av_log_ask_for_sample(avctx, ""Image format is not RGB15.\n"");

        return -1;

    }



    avctx->pix_fmt = PIX_FMT_RGB555;



    if (buf_end - buf < offset)


    if (offset != 0x2c)

        av_log_ask_for_sample(avctx, ""offset != 0x2c\n"");



    buf += offset;



    if (p->data[0])

        avctx->release_buffer(avctx, p);



    if (av_image_check_size(w, h, 0, avctx))

        return -1;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if (avctx->get_buffer(avctx, p) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    ptr    = p->data[0];

    stride = p->linesize[0];



    for (y=0; y<h; y++) {

        if (buf_end - buf < w * bytes_per_pixel)

            break;

#if HAVE_BIGENDIAN

        unsigned int x;

        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)

            AV_WN16(ptr+x, AV_RL16(buf+x));

#else

        memcpy(ptr, buf, w*bytes_per_pixel);

#endif

        ptr += stride;

        buf += w*bytes_per_pixel;

    }



    *picture = s->picture;

    *data_size = sizeof(AVPicture);



    return offset + w*h*bytes_per_pixel;

}",406,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,data,data_size,avpkt,buf,s,picture,p,offset,w,h,y,stride,bytes_per_pixel,ptr,x",,16,99,0,,0,GA,3467,1.4135100801785787,failed,[]
135,"static void ccw_machine_class_init(ObjectClass *oc, void *data)

{

    MachineClass *mc = MACHINE_CLASS(oc);

    NMIClass *nc = NMI_CLASS(oc);

    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);

    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);



    s390mc->ri_allowed = true;

    s390mc->cpu_model_allowed = true;

    s390mc->css_migration_enabled = true;

    s390mc->gs_allowed = true;

    mc->init = ccw_init;

    mc->reset = s390_machine_reset;

    mc->hot_add_cpu = s390_hot_add_cpu;

    mc->block_default_type = IF_VIRTIO;

    mc->no_cdrom = 1;

    mc->no_floppy = 1;

    mc->no_serial = 1;

    mc->no_parallel = 1;

    mc->no_sdcard = 1;

    mc->use_sclp = 1;

    mc->max_cpus = S390_MAX_CPUS;

    mc->has_hotpluggable_cpus = true;

    mc->get_hotplug_handler = s390_get_hotplug_handler;

    mc->cpu_index_to_instance_props = s390_cpu_index_to_props;

    mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;

    /* it is overridden with 'host' cpu *in kvm_arch_init* */

    mc->default_cpu_type = S390_CPU_TYPE_NAME(""qemu"");

    hc->plug = s390_machine_device_plug;

    hc->unplug_request = s390_machine_device_unplug_request;

    nc->nmi_monitor_handler = s390_nmi;

}
",229,,LABEL_1,LABEL_0,,-4,"oc,data,mc,nc,hc,s390mc",,,,0,,0,Greedy,1,0.0005710800488789876,,
136,"static inline int decode_vui_parameters(H264Context *h, SPS *sps)

{

    int aspect_ratio_info_present_flag;

    unsigned int aspect_ratio_idc;



    aspect_ratio_info_present_flag = get_bits1(&h->gb);



    if (aspect_ratio_info_present_flag) {

        aspect_ratio_idc = get_bits(&h->gb, 8);

        if (aspect_ratio_idc == EXTENDED_SAR) {

            sps->sar.num = get_bits(&h->gb, 16);

            sps->sar.den = get_bits(&h->gb, 16);

        } else if (aspect_ratio_idc < FF_ARRAY_ELEMS(pixel_aspect)) {

            sps->sar = pixel_aspect[aspect_ratio_idc];

        } else {

            av_log(h->avctx, AV_LOG_ERROR, ""illegal aspect ratio\n"");

            return AVERROR_INVALIDDATA;

        }

    } else {

        sps->sar.num =

        sps->sar.den = 0;

    }



    if (get_bits1(&h->gb))      /* overscan_info_present_flag */

        get_bits1(&h->gb);      /* overscan_appropriate_flag */



    sps->video_signal_type_present_flag = get_bits1(&h->gb);

    if (sps->video_signal_type_present_flag) {

        get_bits(&h->gb, 3);                 /* video_format */

        sps->full_range = get_bits1(&h->gb); /* video_full_range_flag */



        sps->colour_description_present_flag = get_bits1(&h->gb);

        if (sps->colour_description_present_flag) {

            sps->color_primaries = get_bits(&h->gb, 8); /* colour_primaries */

            sps->color_trc       = get_bits(&h->gb, 8); /* transfer_characteristics */

            sps->colorspace      = get_bits(&h->gb, 8); /* matrix_coefficients */

            if (sps->color_primaries >= AVCOL_PRI_NB)

                sps->color_primaries = AVCOL_PRI_UNSPECIFIED;

            if (sps->color_trc >= AVCOL_TRC_NB)

                sps->color_trc = AVCOL_TRC_UNSPECIFIED;

            if (sps->colorspace >= AVCOL_SPC_NB)

                sps->colorspace = AVCOL_SPC_UNSPECIFIED;

        }

    }



    /* chroma_location_info_present_flag */

    if (get_bits1(&h->gb)) {

        /* chroma_sample_location_type_top_field */

        h->avctx->chroma_sample_location = get_ue_golomb(&h->gb) + 1;

        get_ue_golomb(&h->gb);  /* chroma_sample_location_type_bottom_field */

    }



    sps->timing_info_present_flag = get_bits1(&h->gb);

    if (sps->timing_info_present_flag) {

        sps->num_units_in_tick = get_bits_long(&h->gb, 32);

        sps->time_scale        = get_bits_long(&h->gb, 32);

        if (!sps->num_units_in_tick || !sps->time_scale) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""time_scale/num_units_in_tick invalid or unsupported (%""PRIu32""/%""PRIu32"")\n"",

                   sps->time_scale, sps->num_units_in_tick);

            return AVERROR_INVALIDDATA;

        }

        sps->fixed_frame_rate_flag = get_bits1(&h->gb);

    }



    sps->nal_hrd_parameters_present_flag = get_bits1(&h->gb);

    if (sps->nal_hrd_parameters_present_flag)

        if (decode_hrd_parameters(h, sps) < 0)

            return AVERROR_INVALIDDATA;

    sps->vcl_hrd_parameters_present_flag = get_bits1(&h->gb);

    if (sps->vcl_hrd_parameters_present_flag)

        if (decode_hrd_parameters(h, sps) < 0)

            return AVERROR_INVALIDDATA;

    if (sps->nal_hrd_parameters_present_flag ||

        sps->vcl_hrd_parameters_present_flag)

        get_bits1(&h->gb);     /* low_delay_hrd_flag */

    sps->pic_struct_present_flag = get_bits1(&h->gb);



    sps->bitstream_restriction_flag = get_bits1(&h->gb);

    if (sps->bitstream_restriction_flag) {

        get_bits1(&h->gb);     /* motion_vectors_over_pic_boundaries_flag */

        get_ue_golomb(&h->gb); /* max_bytes_per_pic_denom */

        get_ue_golomb(&h->gb); /* max_bits_per_mb_denom */

        get_ue_golomb(&h->gb); /* log2_max_mv_length_horizontal */

        get_ue_golomb(&h->gb); /* log2_max_mv_length_vertical */

        sps->num_reorder_frames = get_ue_golomb(&h->gb);

        get_ue_golomb(&h->gb); /*max_dec_frame_buffering*/



        if (get_bits_left(&h->gb) < 0) {

            sps->num_reorder_frames         = 0;

            sps->bitstream_restriction_flag = 0;

        }



        if (sps->num_reorder_frames > 16U

            /* max_dec_frame_buffering || max_dec_frame_buffering > 16 */) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""Clipping illegal num_reorder_frames %d\n"",

                   sps->num_reorder_frames);

            sps->num_reorder_frames = 16;

            return AVERROR_INVALIDDATA;

        }

    }

    if (get_bits_left(&h->gb) < 0) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""Overread VUI by %d bits\n"", -get_bits_left(&h->gb));

        return AVERROR_INVALIDDATA;

    }



    return 0;

}
",903,"static inline int decode_vui_parameters(H264Context *m, SPS *Spt)

{

    int aspect_ratio_info_present_band;

    unsigned int aspect_ratio__ide;



    aspect_ratio_info_present_band = get_bits1(&m->gb);



    if (aspect_ratio_info_present_band) {

        aspect_ratio__ide = get_bits(&m->gb, 8);

        if (aspect_ratio__ide == EXTENDED_SAR) {

            Spt->sar.num = get_bits(&m->gb, 16);

            Spt->sar.den = get_bits(&m->gb, 16);

        } else if (aspect_ratio__ide < FF_ARRAY_ELEMS(pixel_aspect)) {

            Spt->sar = pixel_aspect[aspect_ratio__ide];

        } else {

            av_log(m->avctx, AV_LOG_ERROR, ""illegal aspect ratio
"");

            return AVERROR_INVALIDDATA;

        }

    } else {

        Spt->sar.num =

        Spt->sar.den = 0;

    }



    if (get_bits1(&m->gb))      /* overscan_info_present_flag */

        get_bits1(&m->gb);      /* overscan_appropriate_flag */



    Spt->video_signal_type_present_flag = get_bits1(&m->gb);

    if (Spt->video_signal_type_present_flag) {

        get_bits(&m->gb, 3);                 /* video_format */

        Spt->full_range = get_bits1(&m->gb); /* video_full_range_flag */



        Spt->colour_description_present_flag = get_bits1(&m->gb);

        if (Spt->colour_description_present_flag) {

            Spt->color_primaries = get_bits(&m->gb, 8); /* colour_primaries */

            Spt->color_trc       = get_bits(&m->gb, 8); /* transfer_characteristics */

            Spt->colorspace      = get_bits(&m->gb, 8); /* matrix_coefficients */

            if (Spt->color_primaries >= AVCOL_PRI_NB)

                Spt->color_primaries = AVCOL_PRI_UNSPECIFIED;

            if (Spt->color_trc >= AVCOL_TRC_NB)

                Spt->color_trc = AVCOL_TRC_UNSPECIFIED;

            if (Spt->colorspace >= AVCOL_SPC_NB)

                Spt->colorspace = AVCOL_SPC_UNSPECIFIED;

        }

    }



    /* chroma_location_info_present_flag */

    if (get_bits1(&m->gb)) {

        /* chroma_sample_location_type_top_field */

        m->avctx->chroma_sample_location = get_ue_golomb(&m->gb) + 1;

        get_ue_golomb(&m->gb);  /* chroma_sample_location_type_bottom_field */

    }



    Spt->timing_info_present_flag = get_bits1(&m->gb);

    if (Spt->timing_info_present_flag) {

        Spt->num_units_in_tick = get_bits_long(&m->gb, 32);

        Spt->time_scale        = get_bits_long(&m->gb, 32);

        if (!sps->num_units_in_tick || !sps->time_scale) {

            av_log(m->avctx, AV_LOG_ERROR,

                   ""time_scale/num_units_in_tick invalid or unsupported (%""PRIu32""/%""PRIu32"")
"",

                   Spt->time_scale, Spt->num_units_in_tick);

            return AVERROR_INVALIDDATA;

        }

        Spt->fixed_frame_rate_flag = get_bits1(&m->gb);

    }



    Spt->nal_hrd_parameters_present_flag = get_bits1(&m->gb);

    if (Spt->nal_hrd_parameters_present_flag)

        if (decode_hrd_parameters(m, Spt) < 0)

            return AVERROR_INVALIDDATA;

    Spt->vcl_hrd_parameters_present_flag = get_bits1(&m->gb);

    if (Spt->vcl_hrd_parameters_present_flag)

        if (decode_hrd_parameters(m, Spt) < 0)

            return AVERROR_INVALIDDATA;

    if (Spt->nal_hrd_parameters_present_flag ||

        Spt->vcl_hrd_parameters_present_flag)

        get_bits1(&m->gb);     /* low_delay_hrd_flag */

    Spt->pic_struct_present_flag = get_bits1(&m->gb);



    Spt->bitstream_restriction_flag = get_bits1(&m->gb);

    if (Spt->bitstream_restriction_flag) {

        get_bits1(&m->gb);     /* motion_vectors_over_pic_boundaries_flag */

        get_ue_golomb(&m->gb); /* max_bytes_per_pic_denom */

        get_ue_golomb(&m->gb); /* max_bits_per_mb_denom */

        get_ue_golomb(&m->gb); /* log2_max_mv_length_horizontal */

        get_ue_golomb(&m->gb); /* log2_max_mv_length_vertical */

        Spt->num_reorder_frames = get_ue_golomb(&m->gb);

        get_ue_golomb(&m->gb); /*max_dec_frame_buffering*/



        if (get_bits_left(&m->gb) < 0) {

            Spt->num_reorder_frames         = 0;

            Spt->bitstream_restriction_flag = 0;

        }



        if (Spt->num_reorder_frames > 16U

            /* max_dec_frame_buffering || max_dec_frame_buffering > 16 */) {

            av_log(m->avctx, AV_LOG_ERROR,

                   ""Clipping illegal num_reorder_frames %d
"",

                   Spt->num_reorder_frames);

            Spt->num_reorder_frames = 16;

            return AVERROR_INVALIDDATA;

        }

    }

    if (get_bits_left(&m->gb) < 0) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Overread VUI by %d bits
"", -get_bits_left(&m->gb));

        return AVERROR_INVALIDDATA;

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"h,sps,aspect_ratio_info_present_flag,aspect_ratio_idc",,4,95,0,"h:m,sps:Spt,aspect_ratio_info_present_flag:aspect_ratio_info_present_band,aspect_ratio_idc:aspect_ratio__ide,",0,GA,479,0.2305967887242635,GA,[]
137,"sprintf_len(char *string, const char *format, ...)

#else

sprintf_len(va_alist) va_dcl

#endif

{

	va_list args;

#ifdef __STDC__

	va_start(args, format);

#else

	char *string;

	char *format;

	va_start(args);

	string = va_arg(args, char *);

	format = va_arg(args, char *);

#endif

	vsprintf(string, format, args);

	return strlen(string);

}
",80,,LABEL_0,LABEL_0,LABEL_0,-1,format,,1,5,0,,0,GA,253,0.08984179496765136,failed,[]
138,"static void vfio_platform_eoi(VFIODevice *vbasedev)

{

    VFIOINTp *intp;

    VFIOPlatformDevice *vdev =

        container_of(vbasedev, VFIOPlatformDevice, vbasedev);



    qemu_mutex_lock(&vdev->intp_mutex);

    QLIST_FOREACH(intp, &vdev->intp_list, next) {

        if (intp->state == VFIO_IRQ_ACTIVE) {

            trace_vfio_platform_eoi(intp->pin,

                                event_notifier_get_fd(&intp->interrupt));

            intp->state = VFIO_IRQ_INACTIVE;



            /* deassert the virtual IRQ */

            qemu_set_irq(intp->qemuirq, 0);



            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {

                /* unmasks the physical level-sensitive IRQ */

                vfio_unmask_single_irqindex(vbasedev, intp->pin);

            }



            /* a single IRQ can be active at a time */

            break;

        }

    }

    /* in case there are pending IRQs, handle the first one */

    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {

        intp = QSIMPLEQ_FIRST(&vdev->pending_intp_queue);

        vfio_intp_inject_pending_lockheld(intp);

        QSIMPLEQ_REMOVE_HEAD(&vdev->pending_intp_queue, pqnext);

    }

    qemu_mutex_unlock(&vdev->intp_mutex);

}
",218,,LABEL_0,LABEL_0,LABEL_0,-1,"vbasedev,intp,vdev",,3,22,0,,0,GA,809,0.31054140329360963,failed,[]
139,"int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,

                              PCIHotplugState state)

{

    int slot = PCI_SLOT(dev->devfn);

    int bsel = acpi_pcihp_get_bsel(dev->bus);

    if (bsel < 0) {

        return -1;

    }



    /* Don't send event when device is enabled during qemu machine creation:

     * it is present on boot, no hotplug event is necessary. We do send an

     * event when the device is disabled later. */

    if (state == PCI_COLDPLUG_ENABLED) {

        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

        return 0;

    }



    if (state == PCI_HOTPLUG_ENABLED) {

        enable_device(s, bsel, slot);

    } else {

        disable_device(s, bsel, slot);

    }



    return 0;

}
",155,,LABEL_0,LABEL_0,LABEL_0,-1,"s,dev,state",,3,10,0,,0,GA,683,0.25266220172246295,failed,[]
140,"static int read_kuki_chunk(AVFormatContext *s, int64_t size)

{

    AVIOContext *pb = s->pb;

    AVStream *st      = s->streams[0];



    if (size < 0 || size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)

        return -1;



    if (st->codec->codec_id == AV_CODEC_ID_AAC) {

        /* The magic cookie format for AAC is an mp4 esds atom.

           The lavc AAC decoder requires the data from the codec specific

           description as extradata input. */

        int strt, skip;

        MOVAtom atom;



        strt = avio_tell(pb);

        ff_mov_read_esds(s, pb, atom);

        skip = size - (avio_tell(pb) - strt);

        if (skip < 0 || !st->codec->extradata ||

            st->codec->codec_id != AV_CODEC_ID_AAC) {

            av_log(s, AV_LOG_ERROR, ""invalid AAC magic cookie\n"");

            return AVERROR_INVALIDDATA;

        }

        avio_skip(pb, skip);

    } else if (st->codec->codec_id == AV_CODEC_ID_ALAC) {

#define ALAC_PREAMBLE 12

#define ALAC_HEADER   36

#define ALAC_NEW_KUKI 24

        uint8_t preamble[12];

        if (size < ALAC_NEW_KUKI) {

            av_log(s, AV_LOG_ERROR, ""invalid ALAC magic cookie\n"");

            avio_skip(pb, size);

            return AVERROR_INVALIDDATA;

        }

        avio_read(pb, preamble, ALAC_PREAMBLE);



        st->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!st->codec->extradata)

            return AVERROR(ENOMEM);



        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.

         * The new style cookie only contains the last 24 bytes of what was

         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes

         * in that case to maintain compatibility. */

        if (!memcmp(&preamble[4], ""frmaalac"", 8)) {

            if (size < ALAC_PREAMBLE + ALAC_HEADER) {

                av_log(s, AV_LOG_ERROR, ""invalid ALAC magic cookie\n"");

                av_freep(&st->codec->extradata);

                return AVERROR_INVALIDDATA;

            }

            avio_read(pb, st->codec->extradata, ALAC_HEADER);

            avio_skip(pb, size - ALAC_PREAMBLE - ALAC_HEADER);

        } else {

            AV_WB32(st->codec->extradata, 36);

            memcpy(&st->codec->extradata[4], ""alac"", 4);

            AV_WB32(&st->codec->extradata[8], 0);

            memcpy(&st->codec->extradata[12], preamble, 12);

            avio_read(pb, &st->codec->extradata[24], ALAC_NEW_KUKI - 12);

            avio_skip(pb, size - ALAC_NEW_KUKI);

        }

        st->codec->extradata_size = ALAC_HEADER;

    } else {

        st->codec->extradata = av_mallocz(size + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!st->codec->extradata)

            return AVERROR(ENOMEM);

        avio_read(pb, st->codec->extradata, size);

        st->codec->extradata_size = size;

    }



    return 0;

}
",593,"static int read_kuki_chunk(AVFormatContext *s, int64_t SIZE)

{

    AVIOContext *pb = s->pb;

    AVStream *ct      = s->streams[0];



    if (SIZE < 0 || SIZE > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)

        return -1;



    if (ct->codec->codec_id == AV_CODEC_ID_AAC) {

        /* The magic cookie format for AAC is an mp4 esds atom.

           The lavc AAC decoder requires the data from the codec specific

           description as extradata input. */

        int strt, skip;

        MOVAtom atom;



        strt = avio_tell(pb);

        ff_mov_read_esds(s, pb, atom);

        skip = SIZE - (avio_tell(pb) - strt);

        if (skip < 0 || !st->codec->extradata ||

            ct->codec->codec_id != AV_CODEC_ID_AAC) {

            av_log(s, AV_LOG_ERROR, ""invalid AAC magic cookie
"");

            return AVERROR_INVALIDDATA;

        }

        avio_skip(pb, skip);

    } else if (ct->codec->codec_id == AV_CODEC_ID_ALAC) {

#define ALAC_PREAMBLE 12

#define ALAC_HEADER   36

#define ALAC_NEW_KUKI 24

        uint8_t preamble[12];

        if (SIZE < ALAC_NEW_KUKI) {

            av_log(s, AV_LOG_ERROR, ""invalid ALAC magic cookie
"");

            avio_skip(pb, SIZE);

            return AVERROR_INVALIDDATA;

        }

        avio_read(pb, preamble, ALAC_PREAMBLE);



        ct->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!st->codec->extradata)

            return AVERROR(ENOMEM);



        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.

         * The new style cookie only contains the last 24 bytes of what was

         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes

         * in that case to maintain compatibility. */

        if (!memcmp(&preamble[4], ""frmaalac"", 8)) {

            if (SIZE < ALAC_PREAMBLE + ALAC_HEADER) {

                av_log(s, AV_LOG_ERROR, ""invalid ALAC magic cookie
"");

                av_freep(&ct->codec->extradata);

                return AVERROR_INVALIDDATA;

            }

            avio_read(pb, ct->codec->extradata, ALAC_HEADER);

            avio_skip(pb, SIZE - ALAC_PREAMBLE - ALAC_HEADER);

        } else {

            AV_WB32(ct->codec->extradata, 36);

            memcpy(&ct->codec->extradata[4], ""alac"", 4);

            AV_WB32(&ct->codec->extradata[8], 0);

            memcpy(&ct->codec->extradata[12], preamble, 12);

            avio_read(pb, &ct->codec->extradata[24], ALAC_NEW_KUKI - 12);

            avio_skip(pb, SIZE - ALAC_NEW_KUKI);

        }

        ct->codec->extradata_size = ALAC_HEADER;

    } else {

        ct->codec->extradata = av_mallocz(SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!st->codec->extradata)

            return AVERROR(ENOMEM);

        avio_read(pb, ct->codec->extradata, SIZE);

        ct->codec->extradata_size = SIZE;

    }



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,size,pb,st,strt,skip,atom,preamble","s:0.0004391670227050781,size:0.0005200505256652832,pb:0.00034999847412109375,st:0.0016309022903442383,strt:2.4437904357910156e-05,skip:0.00024956464767456055,atom:0.00013393163681030273,preamble:5.179643630981445e-05,",2,28,0,"st:ct,size:SIZE,",0,Greedy,178,0.07382688919703166,replace,[]
141,"static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset,

                                       sPAPRPHBState *sphb)

{

    ResourceProps rp;

    bool is_bridge = false;

    int pci_status, err;

    char *buf = NULL;

    uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev);

    uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3);

    uint32_t max_msi, max_msix;



    if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) ==

        PCI_HEADER_TYPE_BRIDGE) {

        is_bridge = true;

    }



    /* in accordance with PAPR+ v2.7 13.6.3, Table 181 */

    _FDT(fdt_setprop_cell(fdt, offset, ""vendor-id"",

                          pci_default_read_config(dev, PCI_VENDOR_ID, 2)));

    _FDT(fdt_setprop_cell(fdt, offset, ""device-id"",

                          pci_default_read_config(dev, PCI_DEVICE_ID, 2)));

    _FDT(fdt_setprop_cell(fdt, offset, ""revision-id"",

                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));

    _FDT(fdt_setprop_cell(fdt, offset, ""class-code"", ccode));

    if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) {

        _FDT(fdt_setprop_cell(fdt, offset, ""interrupts"",

                 pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)));

    }



    if (!is_bridge) {

        _FDT(fdt_setprop_cell(fdt, offset, ""min-grant"",

            pci_default_read_config(dev, PCI_MIN_GNT, 1)));

        _FDT(fdt_setprop_cell(fdt, offset, ""max-latency"",

            pci_default_read_config(dev, PCI_MAX_LAT, 1)));

    }



    if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) {

        _FDT(fdt_setprop_cell(fdt, offset, ""subsystem-id"",

                 pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)));

    }



    if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) {

        _FDT(fdt_setprop_cell(fdt, offset, ""subsystem-vendor-id"",

                 pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)));

    }



    _FDT(fdt_setprop_cell(fdt, offset, ""cache-line-size"",

        pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1)));



    /* the following fdt cells are masked off the pci status register */

    pci_status = pci_default_read_config(dev, PCI_STATUS, 2);

    _FDT(fdt_setprop_cell(fdt, offset, ""devsel-speed"",

                          PCI_STATUS_DEVSEL_MASK & pci_status));



    if (pci_status & PCI_STATUS_FAST_BACK) {

        _FDT(fdt_setprop(fdt, offset, ""fast-back-to-back"", NULL, 0));

    }

    if (pci_status & PCI_STATUS_66MHZ) {

        _FDT(fdt_setprop(fdt, offset, ""66mhz-capable"", NULL, 0));

    }

    if (pci_status & PCI_STATUS_UDF) {

        _FDT(fdt_setprop(fdt, offset, ""udf-supported"", NULL, 0));

    }



    _FDT(fdt_setprop_string(fdt, offset, ""name"",

                            pci_find_device_name((ccode >> 16) & 0xff,

                                                 (ccode >> 8) & 0xff,

                                                 ccode & 0xff)));

    buf = spapr_phb_get_loc_code(sphb, dev);

    if (!buf) {

        error_report(""Failed setting the ibm,loc-code"");

        return -1;

    }



    err = fdt_setprop_string(fdt, offset, ""ibm,loc-code"", buf);

    g_free(buf);

    if (err < 0) {

        return err;

    }



    if (drc_index) {

        _FDT(fdt_setprop_cell(fdt, offset, ""ibm,my-drc-index"", drc_index));

    }



    _FDT(fdt_setprop_cell(fdt, offset, ""#address-cells"",

                          RESOURCE_CELLS_ADDRESS));

    _FDT(fdt_setprop_cell(fdt, offset, ""#size-cells"",

                          RESOURCE_CELLS_SIZE));



    max_msi = msi_nr_vectors_allocated(dev);

    if (max_msi) {

        _FDT(fdt_setprop_cell(fdt, offset, ""ibm,req#msi"", max_msi));

    }

    max_msix = dev->msix_entries_nr;

    if (max_msix) {

        _FDT(fdt_setprop_cell(fdt, offset, ""ibm,req#msi-x"", max_msix));

    }



    populate_resource_props(dev, &rp);

    _FDT(fdt_setprop(fdt, offset, ""reg"", (uint8_t *)rp.reg, rp.reg_len));

    _FDT(fdt_setprop(fdt, offset, ""assigned-addresses"",

                     (uint8_t *)rp.assigned, rp.assigned_len));



    if (sphb->pcie_ecs && pci_is_express(dev)) {

        _FDT(fdt_setprop_cell(fdt, offset, ""ibm,pci-config-space-type"", 0x1));

    }



    return 0;

}
",746,,LABEL_1,LABEL_0,,-4,"dev,fdt,offset,sphb,rp,pci_status,err,buf,max_msi,max_msix",,,,0,,0,Greedy,1,0.0008825103441874187,,
142,"static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    PCXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    int compressed, xmin, ymin, xmax, ymax;

    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,

                 bytes_per_scanline;

    uint8_t *ptr;

    uint8_t const *bufstart = buf;

    uint8_t *scanline;

    int ret = -1;



    if (buf[0] != 0x0a || buf[1] > 5) {

        av_log(avctx, AV_LOG_ERROR, ""this is not PCX encoded data\n"");

        return AVERROR_INVALIDDATA;

    }



    compressed = buf[2];

    xmin = AV_RL16(buf+ 4);

    ymin = AV_RL16(buf+ 6);

    xmax = AV_RL16(buf+ 8);

    ymax = AV_RL16(buf+10);



    if (xmax < xmin || ymax < ymin) {

        av_log(avctx, AV_LOG_ERROR, ""invalid image dimensions\n"");

        return AVERROR_INVALIDDATA;

    }



    w = xmax - xmin + 1;

    h = ymax - ymin + 1;



    bits_per_pixel     = buf[3];

    bytes_per_line     = AV_RL16(buf+66);

    nplanes            = buf[65];

    bytes_per_scanline = nplanes * bytes_per_line;



    if (bytes_per_scanline < w * bits_per_pixel * nplanes / 8) {

        av_log(avctx, AV_LOG_ERROR, ""PCX data is corrupted\n"");

        return AVERROR_INVALIDDATA;

    }



    switch ((nplanes<<8) + bits_per_pixel) {

        case 0x0308:

            avctx->pix_fmt = AV_PIX_FMT_RGB24;

            break;

        case 0x0108:

        case 0x0104:

        case 0x0102:

        case 0x0101:

        case 0x0401:

        case 0x0301:

        case 0x0201:

            avctx->pix_fmt = AV_PIX_FMT_PAL8;

            break;

        default:

            av_log(avctx, AV_LOG_ERROR, ""invalid PCX file\n"");

            return AVERROR_INVALIDDATA;

    }



    buf += 128;



    if (p->data[0])

        avctx->release_buffer(avctx, p);



    if (av_image_check_size(w, h, 0, avctx))

        return AVERROR_INVALIDDATA;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if ((ret = avctx->get_buffer(avctx, p)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return ret;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    ptr    = p->data[0];

    stride = p->linesize[0];



    scanline = av_malloc(bytes_per_scanline);

    if (!scanline)

        return AVERROR(ENOMEM);



    if (nplanes == 3 && bits_per_pixel == 8) {

        for (y=0; y<h; y++) {

            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++) {

                ptr[3*x  ] = scanline[x                    ];

                ptr[3*x+1] = scanline[x+ bytes_per_line    ];

                ptr[3*x+2] = scanline[x+(bytes_per_line<<1)];

            }



            ptr += stride;

        }



    } else if (nplanes == 1 && bits_per_pixel == 8) {

        const uint8_t *palstart = bufstart + buf_size - 769;



        for (y=0; y<h; y++, ptr+=stride) {

            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);

            memcpy(ptr, scanline, w);

        }



        if (buf != palstart) {

            av_log(avctx, AV_LOG_WARNING, ""image data possibly corrupted\n"");

            buf = palstart;

        }

        if (*buf++ != 12) {

            av_log(avctx, AV_LOG_ERROR, ""expected palette after image data\n"");

            ret = AVERROR_INVALIDDATA;

            goto end;

        }



    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */

        GetBitContext s;



        for (y=0; y<h; y++) {

            init_get_bits(&s, scanline, bytes_per_scanline<<3);



            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++)

                ptr[x] = get_bits(&s, bits_per_pixel);

            ptr += stride;

        }



    } else {    /* planar, 4, 8 or 16 colors */

        int i;



        for (y=0; y<h; y++) {

            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++) {

                int m = 0x80 >> (x&7), v = 0;

                for (i=nplanes - 1; i>=0; i--) {

                    v <<= 1;

                    v  += !!(scanline[i*bytes_per_line + (x>>3)] & m);

                }

                ptr[x] = v;

            }

            ptr += stride;

        }

    }



    if (nplanes == 1 && bits_per_pixel == 8) {

        pcx_palette(&buf, (uint32_t *) p->data[1], 256);

    } else if (bits_per_pixel * nplanes == 1) {

        AV_WN32A(p->data[1]  , 0xFF000000);

        AV_WN32A(p->data[1]+4, 0xFFFFFFFF);

    } else if (bits_per_pixel < 8) {

        const uint8_t *palette = bufstart+16;

        pcx_palette(&palette, (uint32_t *) p->data[1], 16);

    }



    *picture = s->picture;

    *data_size = sizeof(AVFrame);



    ret = buf - bufstart;

end:

    av_free(scanline);

    return ret;

}
",1129,"static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *pool = avpkt->data;

    int buf_size = avpkt->size;

    PCXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    int compressed, xmin, ymin, xmax, ymax;

    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,

                 bytes_per_scanline;

    uint8_t *ptr;

    uint8_t const *bufstart = pool;

    uint8_t *scanline;

    int ret = -1;



    if (pool[0] != 0x0a || pool[1] > 5) {

        av_log(avctx, AV_LOG_ERROR, ""this is not PCX encoded data
"");

        return AVERROR_INVALIDDATA;

    }



    compressed = pool[2];

    xmin = AV_RL16(pool+ 4);

    ymin = AV_RL16(pool+ 6);

    xmax = AV_RL16(pool+ 8);

    ymax = AV_RL16(pool+10);



    if (xmax < xmin || ymax < ymin) {

        av_log(avctx, AV_LOG_ERROR, ""invalid image dimensions
"");

        return AVERROR_INVALIDDATA;

    }



    w = xmax - xmin + 1;

    h = ymax - ymin + 1;



    bits_per_pixel     = pool[3];

    bytes_per_line     = AV_RL16(pool+66);

    nplanes            = pool[65];

    bytes_per_scanline = nplanes * bytes_per_line;



    if (bytes_per_scanline < w * bits_per_pixel * nplanes / 8) {

        av_log(avctx, AV_LOG_ERROR, ""PCX data is corrupted
"");

        return AVERROR_INVALIDDATA;

    }



    switch ((nplanes<<8) + bits_per_pixel) {

        case 0x0308:

            avctx->pix_fmt = AV_PIX_FMT_RGB24;

            break;

        case 0x0108:

        case 0x0104:

        case 0x0102:

        case 0x0101:

        case 0x0401:

        case 0x0301:

        case 0x0201:

            avctx->pix_fmt = AV_PIX_FMT_PAL8;

            break;

        default:

            av_log(avctx, AV_LOG_ERROR, ""invalid PCX file
"");

            return AVERROR_INVALIDDATA;

    }



    pool += 128;



    if (p->data[0])

        avctx->release_buffer(avctx, p);



    if (av_image_check_size(w, h, 0, avctx))

        return AVERROR_INVALIDDATA;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if ((ret = avctx->get_buffer(avctx, p)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
"");

        return ret;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    ptr    = p->data[0];

    stride = p->linesize[0];



    scanline = av_malloc(bytes_per_scanline);

    if (!scanline)

        return AVERROR(ENOMEM);



    if (nplanes == 3 && bits_per_pixel == 8) {

        for (y=0; y<h; y++) {

            pool = pcx_rle_decode(pool, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++) {

                ptr[3*x  ] = scanline[x                    ];

                ptr[3*x+1] = scanline[x+ bytes_per_line    ];

                ptr[3*x+2] = scanline[x+(bytes_per_line<<1)];

            }



            ptr += stride;

        }



    } else if (nplanes == 1 && bits_per_pixel == 8) {

        const uint8_t *palstart = bufstart + buf_size - 769;



        for (y=0; y<h; y++, ptr+=stride) {

            pool = pcx_rle_decode(pool, scanline, bytes_per_scanline, compressed);

            memcpy(ptr, scanline, w);

        }



        if (pool != palstart) {

            av_log(avctx, AV_LOG_WARNING, ""image data possibly corrupted
"");

            pool = palstart;

        }

        if (*pool++ != 12) {

            av_log(avctx, AV_LOG_ERROR, ""expected palette after image data
"");

            ret = AVERROR_INVALIDDATA;

            goto end;

        }



    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */

        GetBitContext s;



        for (y=0; y<h; y++) {

            init_get_bits(&s, scanline, bytes_per_scanline<<3);



            pool = pcx_rle_decode(pool, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++)

                ptr[x] = get_bits(&s, bits_per_pixel);

            ptr += stride;

        }



    } else {    /* planar, 4, 8 or 16 colors */

        int i;



        for (y=0; y<h; y++) {

            pool = pcx_rle_decode(pool, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++) {

                int m = 0x80 >> (x&7), v = 0;

                for (i=nplanes - 1; i>=0; i--) {

                    v <<= 1;

                    v  += !!(scanline[i*bytes_per_line + (x>>3)] & m);

                }

                ptr[x] = v;

            }

            ptr += stride;

        }

    }



    if (nplanes == 1 && bits_per_pixel == 8) {

        pcx_palette(&pool, (uint32_t *) p->data[1], 256);

    } else if (bits_per_pixel * nplanes == 1) {

        AV_WN32A(p->data[1]  , 0xFF000000);

        AV_WN32A(p->data[1]+4, 0xFFFFFFFF);

    } else if (bits_per_pixel < 8) {

        const uint8_t *palette = bufstart+16;

        pcx_palette(&palette, (uint32_t *) p->data[1], 16);

    }



    *picture = s->picture;

    *data_size = sizeof(AVFrame);



    ret = pool - bufstart;

end:

    av_free(scanline);

    return ret;

}
",LABEL_1,LABEL_1,LABEL_0,1,"avctx,data,data_size,avpkt,buf,s,picture,p,compressed,xmin,ymin,xmax,ymax,w,h,bits_per_pixel,bytes_per_line,nplanes,stride,y,x,bytes_per_scanline,ptr,bufstart,scanline","avctx:-0.27552396059036255,data:1.0055063366889954,data_size:-0.0021834969520568848,avpkt:0.0011857151985168457,buf:2.031339168548584,s:0.29441529512405396,picture:0.27997881174087524,p:0.9879332780838013,compressed:0.4182788133621216,xmin:-0.0661589503288269,ymin:-0.06730037927627563,xmax:-0.06677204370498657,ymax:-0.06661719083786011,w:0.9878000020980835,h:0.9834356904029846,bits_per_pixel:-0.5159539580345154,bytes_per_line:-0.42963355779647827,nplanes:-0.11997276544570923,stride:0.5694272518157959,y:0.9626705646514893,x:1.4185442924499512,bytes_per_scanline:-0.40995222330093384,ptr:0.9713200926780701,bufstart:-0.032370686531066895,scanline:-0.10311239957809448,",1,26,0,"buf:pool,",0,Greedy,301,0.12663394212722778,replace,[]
143,"void ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f)

{

    PerThreadContext *p = avctx->internal->thread_ctx;

    FrameThreadContext *fctx;

    AVFrame *dst, *tmp;

FF_DISABLE_DEPRECATION_WARNINGS

    int can_direct_free = !(avctx->active_thread_type & FF_THREAD_FRAME) ||

                          avctx->thread_safe_callbacks                   ||

                          (

#if FF_API_GET_BUFFER

                           !avctx->get_buffer &&

#endif

                           avctx->get_buffer2 == avcodec_default_get_buffer2);

FF_ENABLE_DEPRECATION_WARNINGS



    if (!f->f->buf[0])

        return;



    if (avctx->debug & FF_DEBUG_BUFFERS)

        av_log(avctx, AV_LOG_DEBUG, ""thread_release_buffer called on pic %p\n"", f);



    av_buffer_unref(&f->progress);

    f->owner    = NULL;



    if (can_direct_free) {

        av_frame_unref(f->f);

        return;

    }



    fctx = p->parent;

    pthread_mutex_lock(&fctx->buffer_mutex);



    if (p->num_released_buffers + 1 >= INT_MAX / sizeof(*p->released_buffers))

        goto fail;

    tmp = av_fast_realloc(p->released_buffers, &p->released_buffers_allocated,

                          (p->num_released_buffers + 1) *

                          sizeof(*p->released_buffers));

    if (!tmp)

        goto fail;

    p->released_buffers = tmp;



    dst = &p->released_buffers[p->num_released_buffers];

    av_frame_move_ref(dst, f->f);



    p->num_released_buffers++;



fail:

    pthread_mutex_unlock(&fctx->buffer_mutex);

}
",279,,LABEL_1,LABEL_0,,-4,"avctx,f,p,fctx,dst,tmp,num_released_buffers",,,,0,,0,Greedy,1,0.0005961179733276368,,
144,"static bool try_poll_mode(AioContext *ctx, bool blocking)

{

    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),

                             (uint64_t)ctx->poll_ns);



        if (max_ns) {

            poll_set_started(ctx, true);



            if (run_poll_handlers(ctx, max_ns)) {

                return true;

            }

        }

    }



    poll_set_started(ctx, false);



    /* Even if we don't run busy polling, try polling once in case it can make

     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).

     */

    return run_poll_handlers_once(ctx);

}
",146,,LABEL_0,LABEL_0,LABEL_0,-1,"ctx,blocking",,2,11,0,,0,GA,436,0.16123212973276774,failed,[]
145,"static inline void RENAME(yuv2yuvX_ar)(SwsContext *c, const int16_t *lumFilter,

                                       const int16_t **lumSrc, int lumFilterSize,

                                       const int16_t *chrFilter, const int16_t **chrUSrc,

                                       const int16_t **chrVSrc,

                                       int chrFilterSize, const int16_t **alpSrc,

                                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest,

                                       uint8_t *aDest, long dstW, long chrDstW)

{

    if (uDest) {

        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)

        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, vDest, chrDstW + c->uv_off, c->uv_off)

    }

    if (CONFIG_SWSCALE_ALPHA && aDest) {

        YSCALEYUV2YV12X_ACCURATE(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)

    }



    YSCALEYUV2YV12X_ACCURATE(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)

}
",135,"static inline void RENAME(yuv2yuvX_ar)(SwsContext *ct, const int16_t *lumFilter,

                                       const int16_t **lumSrc, int lumFilterSize,

                                       const int16_t *chrFilter, const int16_t **chrUSrc,

                                       const int16_t **chrVSrc,

                                       int chrFilterSize, const int16_t **alpSrc,

                                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest,

                                       uint8_t *aDest, long dstW, long chrDstW)

{

    if (uDest) {

        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)

        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, vDest, chrDstW + ct->uv_off, ct->uv_off)

    }

    if (CONFIG_SWSCALE_ALPHA && aDest) {

        YSCALEYUV2YV12X_ACCURATE(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)

    }



    YSCALEYUV2YV12X_ACCURATE(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)

}
",LABEL_1,LABEL_1,LABEL_0,1,"c,lumFilter,lumSrc,lumFilterSize,chrFilter,chrUSrc,chrVSrc,chrFilterSize,alpSrc,dest,uDest,vDest,aDest,dstW,chrDstW","c:0.0005769133567810059,lumFilter:-0.00031888484954833984,lumSrc:0.0003783106803894043,lumFilterSize:0.0003063082695007324,chrFilter:-1.3589859008789062e-05,chrUSrc:0.0005003809928894043,chrVSrc:-0.0018720626831054688,chrFilterSize:0.0005415678024291992,alpSrc:9.554624557495117e-05,dest:-0.0011035799980163574,uDest:-0.0005892515182495117,vDest:8.761882781982422e-06,aDest:-0.0005159378051757812,dstW:-0.0018925070762634277,chrDstW:-0.0025690197944641113,",1,3,0,"c:ct,",0,Greedy,77,0.028022384643554686,replace,[]
146,"int page_unprotect(target_ulong address, uintptr_t pc, void *puc)

{

    unsigned int prot;

    PageDesc *p;

    target_ulong host_start, host_end, addr;



    /* Technically this isn't safe inside a signal handler.  However we

       know this only ever happens in a synchronous SEGV handler, so in

       practice it seems to be ok.  */

    mmap_lock();



    p = page_find(address >> TARGET_PAGE_BITS);

    if (!p) {

        mmap_unlock();

        return 0;

    }



    /* if the page was really writable, then we change its

       protection back to writable */

    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {

        host_start = address & qemu_host_page_mask;

        host_end = host_start + qemu_host_page_size;



        prot = 0;

        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {

            p = page_find(addr >> TARGET_PAGE_BITS);

            p->flags |= PAGE_WRITE;

            prot |= p->flags;



            /* and since the content will be modified, we must invalidate

               the corresponding translated code. */

            tb_invalidate_phys_page(addr, pc, puc);

#ifdef DEBUG_TB_CHECK

            tb_invalidate_check(addr);

#endif

        }

        mprotect((void *)g2h(host_start), qemu_host_page_size,

                 prot & PAGE_BITS);



        mmap_unlock();

        return 1;

    }

    mmap_unlock();

    return 0;

}
",259,,LABEL_1,LABEL_0,,-4,"address,pc,puc,prot,p,host_start,host_end,addr",,,,0,,0,Greedy,1,0.0005945920944213867,,
147,"static int bt_hci_parse(const char *str)

{

    struct HCIInfo *hci;

    bdaddr_t bdaddr;



    if (nb_hcis >= MAX_NICS) {

        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);

        return -1;

    }



    hci = hci_init(str);

    if (!hci)

        return -1;



    bdaddr.b[0] = 0x52;

    bdaddr.b[1] = 0x54;

    bdaddr.b[2] = 0x00;

    bdaddr.b[3] = 0x12;

    bdaddr.b[4] = 0x34;

    bdaddr.b[5] = 0x56 + nb_hcis;

    hci->bdaddr_set(hci, bdaddr.b);



    hci_table[nb_hcis++] = hci;



    return 0;

}
",150,"static int bt_hci_parse(const char *tr)

{

    struct HCIInfo *hci;

    bdaddr_t ndowner;



    if (nb_hcis >= MAX_NICS) {

        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).
"", MAX_NICS);

        return -1;

    }



    hci = hci_init(tr);

    if (!hci)

        return -1;



    ndowner.b[0] = 0x52;

    ndowner.b[1] = 0x54;

    ndowner.b[2] = 0x00;

    ndowner.b[3] = 0x12;

    ndowner.b[4] = 0x34;

    ndowner.b[5] = 0x56 + nb_hcis;

    hci->bdaddr_set(hci, ndowner.b);



    hci_table[nb_hcis++] = hci;



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"str,hci,bdaddr","str:7.510185241699219e-05,hci:-7.18235969543457e-05,bdaddr:0.0002536177635192871,",2,10,0,"bdaddr:ndowner,str:tr,",0,Greedy,118,0.04301287333170573,replace,[]
148,"static void dsputil_init_mmx2(DSPContext *c, AVCodecContext *avctx,

                              int mm_flags)

{

    const int bit_depth      = avctx->bits_per_raw_sample;

    const int high_bit_depth = bit_depth > 8;



    c->prefetch = prefetch_mmx2;



    if (!high_bit_depth) {

        c->put_pixels_tab[0][1] = put_pixels16_x2_mmx2;

        c->put_pixels_tab[0][2] = put_pixels16_y2_mmx2;



        c->avg_pixels_tab[0][0] = avg_pixels16_mmx2;

        c->avg_pixels_tab[0][1] = avg_pixels16_x2_mmx2;

        c->avg_pixels_tab[0][2] = avg_pixels16_y2_mmx2;



        c->put_pixels_tab[1][1] = put_pixels8_x2_mmx2;

        c->put_pixels_tab[1][2] = put_pixels8_y2_mmx2;



        c->avg_pixels_tab[1][0] = avg_pixels8_mmx2;

        c->avg_pixels_tab[1][1] = avg_pixels8_x2_mmx2;

        c->avg_pixels_tab[1][2] = avg_pixels8_y2_mmx2;

    }



    if (!(avctx->flags & CODEC_FLAG_BITEXACT)) {

        if (!high_bit_depth) {

            c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_mmx2;

            c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_mmx2;

            c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_mmx2;

            c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_mmx2;



            c->avg_pixels_tab[0][3] = avg_pixels16_xy2_mmx2;

            c->avg_pixels_tab[1][3] = avg_pixels8_xy2_mmx2;

        }



        if (CONFIG_VP3_DECODER && HAVE_YASM) {

            c->vp3_v_loop_filter = ff_vp3_v_loop_filter_mmx2;

            c->vp3_h_loop_filter = ff_vp3_h_loop_filter_mmx2;

        }

    }

    if (CONFIG_VP3_DECODER && HAVE_YASM)

        c->vp3_idct_dc_add = ff_vp3_idct_dc_add_mmx2;



    if (CONFIG_VP3_DECODER && (avctx->codec_id == CODEC_ID_VP3 ||

                               avctx->codec_id == CODEC_ID_THEORA)) {

        c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_exact_mmx2;

        c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_exact_mmx2;

    }



    if (CONFIG_H264QPEL) {

        SET_QPEL_FUNCS(put_qpel,        0, 16, mmx2, );

        SET_QPEL_FUNCS(put_qpel,        1,  8, mmx2, );

        SET_QPEL_FUNCS(put_no_rnd_qpel, 0, 16, mmx2, );

        SET_QPEL_FUNCS(put_no_rnd_qpel, 1,  8, mmx2, );

        SET_QPEL_FUNCS(avg_qpel,        0, 16, mmx2, );

        SET_QPEL_FUNCS(avg_qpel,        1,  8, mmx2, );



        if (!high_bit_depth) {

            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, mmx2, );

            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, mmx2, );

            SET_QPEL_FUNCS(put_h264_qpel, 2,  4, mmx2, );

            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, mmx2, );

            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, mmx2, );

            SET_QPEL_FUNCS(avg_h264_qpel, 2,  4, mmx2, );

        } else if (bit_depth == 10) {

#if HAVE_YASM

#if !ARCH_X86_64

            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, 10_mmxext, ff_);

            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, 10_mmxext, ff_);

            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, 10_mmxext, ff_);

            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, 10_mmxext, ff_);

#endif

            SET_QPEL_FUNCS(put_h264_qpel, 2, 4,  10_mmxext, ff_);

            SET_QPEL_FUNCS(avg_h264_qpel, 2, 4,  10_mmxext, ff_);

#endif

        }



        SET_QPEL_FUNCS(put_2tap_qpel, 0, 16, mmx2, );

        SET_QPEL_FUNCS(put_2tap_qpel, 1,  8, mmx2, );

        SET_QPEL_FUNCS(avg_2tap_qpel, 0, 16, mmx2, );

        SET_QPEL_FUNCS(avg_2tap_qpel, 1,  8, mmx2, );

    }



#if HAVE_YASM

    if (!high_bit_depth && CONFIG_H264CHROMA) {

        c->avg_h264_chroma_pixels_tab[0] = ff_avg_h264_chroma_mc8_mmx2_rnd;

        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_mmx2;

        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_mmx2;

        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_mmx2;

    }

    if (bit_depth == 10 && CONFIG_H264CHROMA) {

        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_10_mmxext;

        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_10_mmxext;

        c->put_h264_chroma_pixels_tab[1] = ff_put_h264_chroma_mc4_10_mmxext;

        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_10_mmxext;

    }



    c->add_hfyu_median_prediction   = ff_add_hfyu_median_prediction_mmx2;



    c->scalarproduct_int16          = ff_scalarproduct_int16_mmx2;

    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_mmx2;



    if (avctx->flags & CODEC_FLAG_BITEXACT) {

        c->apply_window_int16 = ff_apply_window_int16_mmxext_ba;

    } else {

        c->apply_window_int16 = ff_apply_window_int16_mmxext;

    }

#endif

}
",811,"static void dsputil_init_mmx2(DSPContext *vc, AVCodecContext *aphcca,

                              int  pixel_settings)

{

    const int bit_depth      = aphcca->bits_per_raw_sample;

    const int high_bit_depth = bit_depth > 8;



    vc->prefetch = prefetch_mmx2;



    if (!high_bit_depth) {

        vc->put_pixels_tab[0][1] = put_pixels16_x2_mmx2;

        vc->put_pixels_tab[0][2] = put_pixels16_y2_mmx2;



        vc->avg_pixels_tab[0][0] = avg_pixels16_mmx2;

        vc->avg_pixels_tab[0][1] = avg_pixels16_x2_mmx2;

        vc->avg_pixels_tab[0][2] = avg_pixels16_y2_mmx2;



        vc->put_pixels_tab[1][1] = put_pixels8_x2_mmx2;

        vc->put_pixels_tab[1][2] = put_pixels8_y2_mmx2;



        vc->avg_pixels_tab[1][0] = avg_pixels8_mmx2;

        vc->avg_pixels_tab[1][1] = avg_pixels8_x2_mmx2;

        vc->avg_pixels_tab[1][2] = avg_pixels8_y2_mmx2;

    }



    if (!(aphcca->flags & CODEC_FLAG_BITEXACT)) {

        if (!high_bit_depth) {

            vc->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_mmx2;

            vc->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_mmx2;

            vc->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_mmx2;

            vc->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_mmx2;



            vc->avg_pixels_tab[0][3] = avg_pixels16_xy2_mmx2;

            vc->avg_pixels_tab[1][3] = avg_pixels8_xy2_mmx2;

        }



        if (CONFIG_VP3_DECODER && HAVE_YASM) {

            vc->vp3_v_loop_filter = ff_vp3_v_loop_filter_mmx2;

            vc->vp3_h_loop_filter = ff_vp3_h_loop_filter_mmx2;

        }

    }

    if (CONFIG_VP3_DECODER && HAVE_YASM)

        vc->vp3_idct_dc_add = ff_vp3_idct_dc_add_mmx2;



    if (CONFIG_VP3_DECODER && (aphcca->codec_id == CODEC_ID_VP3 ||

                               aphcca->codec_id == CODEC_ID_THEORA)) {

        vc->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_exact_mmx2;

        vc->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_exact_mmx2;

    }



    if (CONFIG_H264QPEL) {

        SET_QPEL_FUNCS(put_qpel,        0, 16, mmx2, );

        SET_QPEL_FUNCS(put_qpel,        1,  8, mmx2, );

        SET_QPEL_FUNCS(put_no_rnd_qpel, 0, 16, mmx2, );

        SET_QPEL_FUNCS(put_no_rnd_qpel, 1,  8, mmx2, );

        SET_QPEL_FUNCS(avg_qpel,        0, 16, mmx2, );

        SET_QPEL_FUNCS(avg_qpel,        1,  8, mmx2, );



        if (!high_bit_depth) {

            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, mmx2, );

            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, mmx2, );

            SET_QPEL_FUNCS(put_h264_qpel, 2,  4, mmx2, );

            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, mmx2, );

            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, mmx2, );

            SET_QPEL_FUNCS(avg_h264_qpel, 2,  4, mmx2, );

        } else if (bit_depth == 10) {

#if HAVE_YASM

#if !ARCH_X86_64

            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, 10_mmxext, ff_);

            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, 10_mmxext, ff_);

            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, 10_mmxext, ff_);

            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, 10_mmxext, ff_);

#endif

            SET_QPEL_FUNCS(put_h264_qpel, 2, 4,  10_mmxext, ff_);

            SET_QPEL_FUNCS(avg_h264_qpel, 2, 4,  10_mmxext, ff_);

#endif

        }



        SET_QPEL_FUNCS(put_2tap_qpel, 0, 16, mmx2, );

        SET_QPEL_FUNCS(put_2tap_qpel, 1,  8, mmx2, );

        SET_QPEL_FUNCS(avg_2tap_qpel, 0, 16, mmx2, );

        SET_QPEL_FUNCS(avg_2tap_qpel, 1,  8, mmx2, );

    }



#if HAVE_YASM

    if (!high_bit_depth && CONFIG_H264CHROMA) {

        vc->avg_h264_chroma_pixels_tab[0] = ff_avg_h264_chroma_mc8_mmx2_rnd;

        vc->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_mmx2;

        vc->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_mmx2;

        vc->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_mmx2;

    }

    if (bit_depth == 10 && CONFIG_H264CHROMA) {

        vc->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_10_mmxext;

        vc->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_10_mmxext;

        vc->put_h264_chroma_pixels_tab[1] = ff_put_h264_chroma_mc4_10_mmxext;

        vc->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_10_mmxext;

    }



    vc->add_hfyu_median_prediction   = ff_add_hfyu_median_prediction_mmx2;



    vc->scalarproduct_int16          = ff_scalarproduct_int16_mmx2;

    vc->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_mmx2;



    if (aphcca->flags & CODEC_FLAG_BITEXACT) {

        vc->apply_window_int16 = ff_apply_window_int16_mmxext_ba;

    } else {

        vc->apply_window_int16 = ff_apply_window_int16_mmxext;

    }

#endif

}
",LABEL_0,LABEL_0,LABEL_1,1,"c,avctx,mm_flags","c:0.7971017956733704,avctx:0.3210234045982361,mm_flags:0.05010753870010376,",3,43,0,"c:vc,avctx:aphcca,mm_flags: pixel_settings,",0,Greedy,154,0.072634490331014,replace,[]
149,"int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)

{

    int size, l;



    if (f->is_write)

        abort();



    size = size1;

    while (size > 0) {

        l = f->buf_size - f->buf_index;

        if (l == 0) {

            qemu_fill_buffer(f);

            l = f->buf_size - f->buf_index;

            if (l == 0)

                break;

        }

        if (l > size)

            l = size;

        memcpy(buf, f->buf + f->buf_index, l);

        f->buf_index += l;

        buf += l;

        size -= l;

    }

    return size1 - size;

}
",135,,LABEL_0,LABEL_1,,-4,"f,buf,size1,size,l",,,,0,,0,Greedy,1,0.000491929054260254,,
150,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",83,,LABEL_0,LABEL_0,LABEL_0,-1,"p,d",,2,10,0,,0,GA,467,0.16615277926127117,failed,[]
151,"static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int v, i;



    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {

        if (length > 256 || !(s->state & PNG_PLTE))

            return AVERROR_INVALIDDATA;



        for (i = 0; i < length; i++) {

            v = bytestream2_get_byte(&s->gb);

            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);

        }

    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {

        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||

            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))

            return AVERROR_INVALIDDATA;



        for (i = 0; i < length / 2; i++) {

            /* only use the least significant bits */

            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);



            if (s->bit_depth > 8)

                AV_WB16(&s->transparent_color_be[2 * i], v);

            else

                s->transparent_color_be[i] = v;

        }

    } else {

        return AVERROR_INVALIDDATA;

    }



    bytestream2_skip(&s->gb, 4); /* crc */

    s->has_trns = 1;



    return 0;

}
",274,,LABEL_1,LABEL_0,,-4,"avctx,s,length,v,i",,,,0,,0,Greedy,1,0.0005876898765563964,,
152,"static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float bias)

{

    IndividualChannelStream *ics = &sce->ics;

    float *in    = sce->coeffs;

    float *out   = sce->ret;

    float *saved = sce->saved;

    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;

    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;

    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;

    float *buf  = ac->buf_mdct;

    float *temp = ac->temp;

    int i;



    // imdct

    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {

        if (ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE)

            av_log(ac->avctx, AV_LOG_WARNING,

                   ""Transition from an ONLY_LONG or LONG_STOP to an EIGHT_SHORT sequence detected. ""

                   ""If you heard an audible artifact, please submit the sample to the FFmpeg developers.\n"");

        for (i = 0; i < 1024; i += 128)

            ff_imdct_half(&ac->mdct_small, buf + i, in + i);

    } else

        ff_imdct_half(&ac->mdct, buf, in);



    /* window overlapping

     * NOTE: To simplify the overlapping code, all 'meaningless' short to long

     * and long to short transitions are considered to be short to short

     * transitions. This leaves just two cases (long to long and short to short)

     * with a little special sauce for EIGHT_SHORT_SEQUENCE.

     */

    if ((ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE) &&

            (ics->window_sequence[0] == ONLY_LONG_SEQUENCE || ics->window_sequence[0] == LONG_START_SEQUENCE)) {

        ac->dsp.vector_fmul_window(    out,               saved,            buf,         lwindow_prev, bias, 512);

    } else {

        for (i = 0; i < 448; i++)

            out[i] = saved[i] + bias;



        if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {

            ac->dsp.vector_fmul_window(out + 448 + 0*128, saved + 448,      buf + 0*128, swindow_prev, bias, 64);

            ac->dsp.vector_fmul_window(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow,      bias, 64);

            ac->dsp.vector_fmul_window(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow,      bias, 64);

            ac->dsp.vector_fmul_window(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow,      bias, 64);

            ac->dsp.vector_fmul_window(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      bias, 64);

            memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));

        } else {

            ac->dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, bias, 64);

            for (i = 576; i < 1024; i++)

                out[i] = buf[i-512] + bias;

        }

    }



    // buffer update

    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {

        for (i = 0; i < 64; i++)

            saved[i] = temp[64 + i] - bias;

        ac->dsp.vector_fmul_window(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 0, 64);

        ac->dsp.vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 0, 64);

        ac->dsp.vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 0, 64);

        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));

    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {

        memcpy(                    saved,       buf + 512,        448 * sizeof(float));

        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));

    } else { // LONG_STOP or ONLY_LONG

        memcpy(                    saved,       buf + 512,        512 * sizeof(float));

    }

}
",898,,LABEL_1,LABEL_0,,-4,"ac,sce,bias,ics,in,out,saved,swindow,lwindow_prev,swindow_prev,buf,temp,i",,,,0,,0,Greedy,1,0.0009284337361653646,,
153,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",70,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstSTro)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstSTro, 1);

}
",LABEL_0,LABEL_0,LABEL_1,1,"ysrc,usrc,vsrc,dst,height,lumStride,chromStride,dstStride","ysrc:0.0002512931823730469,usrc:0.00012958049774169922,vsrc:-7.408857345581055e-05,dst:9.232759475708008e-05,height:0.0001556873321533203,lumStride:6.532669067382812e-05,chromStride:5.125999450683594e-05,dstStride:0.0004411935806274414,",1,2,0,"dstStride:dstSTro,",0,Greedy,57,0.020232462882995607,replace,[]
154,"static void puv3_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *initrd_filename = machine->initrd_filename;

    CPUUniCore32State *env;

    UniCore32CPU *cpu;



    if (initrd_filename) {

        error_report(""Please use kernel built-in initramdisk"");

        exit(1);

    }



    if (!cpu_model) {

        cpu_model = ""UniCore-II"";

    }



    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));

    if (!cpu) {

        error_report(""Unable to find CPU definition"");

        exit(1);

    }

    env = &cpu->env;



    puv3_soc_init(env);

    puv3_board_init(env, ram_size);

    puv3_load_kernel(kernel_filename);

}
",138,,LABEL_1,LABEL_0,,-4,"machine,cpu_model,kernel_filename,initrd_filename,env,cpu",,,,0,,0,Greedy,1,0.0005155205726623535,,
155,"static void virtio_queue_notify_vq(VirtQueue *vq)
{
    if (vq->vring.desc && vq->handle_output) {
        VirtIODevice *vdev = vq->vdev;
        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);
        vq->handle_output(vdev, vq);",58,,LABEL_1,LABEL_1,LABEL_1,-1,"vq,vdev",,2,14,0,,0,GA,542,0.19107931454976398,failed,[]
156,"int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)

{

    PerThreadContext *p = avctx->thread_opaque;

    int *progress, err;



    f->owner = avctx;



    ff_init_buffer_info(avctx, f);



    if (!(avctx->active_thread_type&FF_THREAD_FRAME)) {

        f->thread_opaque = NULL;

        return avctx->get_buffer(avctx, f);

    }



    if (p->state != STATE_SETTING_UP &&

        (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks &&

                avctx->get_buffer != avcodec_default_get_buffer))) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() cannot be called after ff_thread_finish_setup()\n"");

        return -1;

    }



    pthread_mutex_lock(&p->parent->buffer_mutex);

    f->thread_opaque = progress = allocate_progress(p);



    if (!progress) {

        pthread_mutex_unlock(&p->parent->buffer_mutex);

        return -1;

    }



    progress[0] =

    progress[1] = -1;



    if (avctx->thread_safe_callbacks ||

        avctx->get_buffer == avcodec_default_get_buffer) {

        err = avctx->get_buffer(avctx, f);

    } else {

        p->requested_frame = f;

        p->state = STATE_GET_BUFFER;

        pthread_mutex_lock(&p->progress_mutex);

        pthread_cond_signal(&p->progress_cond);



        while (p->state != STATE_SETTING_UP)

            pthread_cond_wait(&p->progress_cond, &p->progress_mutex);



        err = p->result;



        pthread_mutex_unlock(&p->progress_mutex);



        if (!avctx->codec->update_thread_context)

            ff_thread_finish_setup(avctx);

    }



    pthread_mutex_unlock(&p->parent->buffer_mutex);



    return err;

}
",332,,LABEL_1,LABEL_0,,-4,"avctx,f,p,progress,err",,,,0,,0,Greedy,1,0.0006212949752807617,,
157,"int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,

                         int level)

{

    VDPAUHWContext *hwctx = avctx->hwaccel_context;

    VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data;

    VdpVideoSurfaceQueryCapabilities *surface_query_caps;

    VdpDecoderQueryCapabilities *decoder_query_caps;

    VdpDecoderCreate *create;

    void *func;

    VdpStatus status;

    VdpBool supported;

    uint32_t max_level, max_mb, max_width, max_height;

    VdpChromaType type;

    uint32_t width;

    uint32_t height;



    vdctx->width            = UINT32_MAX;

    vdctx->height           = UINT32_MAX;



    if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height))

        return AVERROR(ENOSYS);



    if (hwctx) {

        hwctx->reset            = 0;



        if (hwctx->context.decoder != VDP_INVALID_HANDLE) {

            vdctx->decoder = hwctx->context.decoder;

            vdctx->render  = hwctx->context.render;

            vdctx->device  = VDP_INVALID_HANDLE;

            return 0; /* Decoder created by user */

        }



        vdctx->device           = hwctx->device;

        vdctx->get_proc_address = hwctx->get_proc_address;



        if (hwctx->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)

            level = 0;



        if (!(hwctx->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) &&

            type != VDP_CHROMA_TYPE_420)

            return AVERROR(ENOSYS);

    } else {

        AVHWFramesContext *frames_ctx = NULL;

        AVVDPAUDeviceContext *dev_ctx;



        // We assume the hw_frames_ctx always survives until ff_vdpau_common_uninit

        // is called. This holds true as the user is not allowed to touch

        // hw_device_ctx, or hw_frames_ctx after get_format (and ff_get_format

        // itself also uninits before unreffing hw_frames_ctx).

        if (avctx->hw_frames_ctx) {

            frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;

        } else if (avctx->hw_device_ctx) {

            int ret;



            avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);

            if (!avctx->hw_frames_ctx)

                return AVERROR(ENOMEM);



            frames_ctx            = (AVHWFramesContext*)avctx->hw_frames_ctx->data;

            frames_ctx->format    = AV_PIX_FMT_VDPAU;

            frames_ctx->sw_format = avctx->sw_pix_fmt;

            frames_ctx->width     = avctx->coded_width;

            frames_ctx->height    = avctx->coded_height;



            ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);

            if (ret < 0) {

                av_buffer_unref(&avctx->hw_frames_ctx);

                return ret;

            }

        }



        if (!frames_ctx) {

            av_log(avctx, AV_LOG_ERROR, ""A hardware frames context is ""

                   ""required for VDPAU decoding.\n"");

            return AVERROR(EINVAL);

        }



        dev_ctx = frames_ctx->device_ctx->hwctx;



        vdctx->device           = dev_ctx->device;

        vdctx->get_proc_address = dev_ctx->get_proc_address;



        if (avctx->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)

            level = 0;

    }



    if (level < 0)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device,

                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        surface_query_caps = func;



    status = surface_query_caps(vdctx->device, type, &supported,

                                &max_width, &max_height);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    if (supported != VDP_TRUE ||

        max_width < width || max_height < height)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device,

                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        decoder_query_caps = func;



    status = decoder_query_caps(vdctx->device, profile, &supported, &max_level,

                                &max_mb, &max_width, &max_height);

#ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE

    if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) {

        profile = VDP_DECODER_PROFILE_H264_MAIN;

        status = decoder_query_caps(vdctx->device, profile, &supported,

                                    &max_level, &max_mb,

                                    &max_width, &max_height);

    }

#endif

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);



    if (supported != VDP_TRUE || max_level < level ||

        max_width < width || max_height < height)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        create = func;



    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        vdctx->render = func;



    status = create(vdctx->device, profile, width, height, avctx->refs,

                    &vdctx->decoder);

    if (status == VDP_STATUS_OK) {

        vdctx->width  = avctx->coded_width;

        vdctx->height = avctx->coded_height;

    }



    return vdpau_error(status);

}
",882,"int ff_vdpau_common_init(AVCodecContext * avcontext, VdpDecoderProfile profile,

                         int thread)

{

    VDPAUHWContext *hwctx =  avcontext->hwaccel_context;

    VDPAUContext *vdctx =  avcontext->internal->hwaccel_priv_data;

    VdpVideoSurfaceQueryCapabilities *surface_query_caps;

    VdpDecoderQueryCapabilities *decoder_query_caps;

    VdpDecoderCreate *create;

    void *func;

    VdpStatus status;

    VdpBool supported;

    uint32_t max_level, max_mb, max_width, max_height;

    VdpChromaType type;

    uint32_t width;

    uint32_t height;



    vdctx->width            = UINT32_MAX;

    vdctx->height           = UINT32_MAX;



    if (av_vdpau_get_surface_parameters( avcontext, &type, &width, &height))

        return AVERROR(ENOSYS);



    if (hwctx) {

        hwctx->reset            = 0;



        if (hwctx->context.decoder != VDP_INVALID_HANDLE) {

            vdctx->decoder = hwctx->context.decoder;

            vdctx->render  = hwctx->context.render;

            vdctx->device  = VDP_INVALID_HANDLE;

            return 0; /* Decoder created by user */

        }



        vdctx->device           = hwctx->device;

        vdctx->get_proc_address = hwctx->get_proc_address;



        if (hwctx->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)

            thread = 0;



        if (!(hwctx->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) &&

            type != VDP_CHROMA_TYPE_420)

            return AVERROR(ENOSYS);

    } else {

        AVHWFramesContext *frames_ctx = NULL;

        AVVDPAUDeviceContext *dev_ctx;



        // We assume the hw_frames_ctx always survives until ff_vdpau_common_uninit

        // is called. This holds true as the user is not allowed to touch

        // hw_device_ctx, or hw_frames_ctx after get_format (and ff_get_format

        // itself also uninits before unreffing hw_frames_ctx).

        if ( avcontext->hw_frames_ctx) {

            frames_ctx = (AVHWFramesContext*) avcontext->hw_frames_ctx->data;

        } else if ( avcontext->hw_device_ctx) {

            int deep;



             avcontext->hw_frames_ctx = av_hwframe_ctx_alloc( avcontext->hw_device_ctx);

            if (!avctx->hw_frames_ctx)

                return AVERROR(ENOMEM);



            frames_ctx            = (AVHWFramesContext*) avcontext->hw_frames_ctx->data;

            frames_ctx->format    = AV_PIX_FMT_VDPAU;

            frames_ctx->sw_format =  avcontext->sw_pix_fmt;

            frames_ctx->width     =  avcontext->coded_width;

            frames_ctx->height    =  avcontext->coded_height;



            deep = av_hwframe_ctx_init( avcontext->hw_frames_ctx);

            if (deep < 0) {

                av_buffer_unref(& avcontext->hw_frames_ctx);

                return deep;

            }

        }



        if (!frames_ctx) {

            av_log( avcontext, AV_LOG_ERROR, ""A hardware frames context is ""

                   ""required for VDPAU decoding.
"");

            return AVERROR(EINVAL);

        }



        dev_ctx = frames_ctx->device_ctx->hwctx;



        vdctx->device           = dev_ctx->device;

        vdctx->get_proc_address = dev_ctx->get_proc_address;



        if ( avcontext->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)

            thread = 0;

    }



    if (thread < 0)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device,

                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        surface_query_caps = func;



    status = surface_query_caps(vdctx->device, type, &supported,

                                &max_width, &max_height);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    if (supported != VDP_TRUE ||

        max_width < width || max_height < height)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device,

                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        decoder_query_caps = func;



    status = decoder_query_caps(vdctx->device, profile, &supported, &max_level,

                                &max_mb, &max_width, &max_height);

#ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE

    if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) {

        profile = VDP_DECODER_PROFILE_H264_MAIN;

        status = decoder_query_caps(vdctx->device, profile, &supported,

                                    &max_level, &max_mb,

                                    &max_width, &max_height);

    }

#endif

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);



    if (supported != VDP_TRUE || max_level < thread ||

        max_width < width || max_height < height)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        create = func;



    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        vdctx->render = func;



    status = create(vdctx->device, profile, width, height,  avcontext->refs,

                    &vdctx->decoder);

    if (status == VDP_STATUS_OK) {

        vdctx->width  =  avcontext->coded_width;

        vdctx->height =  avcontext->coded_height;

    }



    return vdpau_error(status);

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,profile,level,hwctx,vdctx,surface_query_caps,decoder_query_caps,create,func,status,supported,max_level,max_mb,max_width,max_height,type,height,frames_ctx,dev_ctx,ret","avctx:0.8242479562759399,profile:0.05596601963043213,level:0.24483126401901245,hwctx:0.0005897283554077148,vdctx:0.015807926654815674,surface_query_caps:0.09416526556015015,decoder_query_caps:-0.02087986469268799,create:0.0565187931060791,func:0.06842422485351562,status:0.11559867858886719,supported:0.06023377180099487,max_level:0.0006344318389892578,max_mb:0.0004328489303588867,max_width:-0.0012757182121276855,max_height:-0.002984285354614258,type:0.1709228754043579,height:0.22811603546142578,frames_ctx:0.008239388465881348,dev_ctx:-0.0009340047836303711,ret:0.24173492193222046,",3,29,0,"avctx: avcontext,level:thread,ret:deep,",0,Greedy,316,0.1410485823949178,replace,[]
158,"static void migrate_set_downtime(QTestState *who, const char *value)

{

    QDict *rsp;

    gchar *cmd;



    cmd = g_strdup_printf(""{ 'execute': 'migrate_set_downtime',""

                          ""'arguments': { 'value': %s } }"", value);

    rsp = qtest_qmp(who, cmd);

    g_free(cmd);

    g_assert(qdict_haskey(rsp, ""return""));

    QDECREF(rsp);

}
",63,,LABEL_0,LABEL_1,,-4,"who,value,rsp,cmd",,,,0,,0,Greedy,1,0.000468138853708903,,
159,"static int find_dirty_height(VncState *vs, int y, int last_x, int x)

{

    int h;



    for (h = 1; h < (vs->serverds.height - y); h++) {

        int tmp_x;

        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))

            break;

        for (tmp_x = last_x; tmp_x < x; tmp_x++)

            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);

    }



    return h;

}
",102,,LABEL_1,LABEL_0,,-4,"vs,y,last_x,x,h,tmp_x",,,,0,,0,Greedy,1,0.0004696528116861979,,
160,"static void press_key(VncState *vs, int keysym)

{

    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);

    qemu_input_event_send_key_delay(0);

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);

    qemu_input_event_send_key_delay(0);

}
",77,"static void press_key(VncState *cv, int Keysem)

{

    int keycode = keysym2scancode(cv->vd->kbd_layout, Keysem) & SCANCODE_KEYMASK;

    qemu_input_event_send_key_number(cv->vd->dcl.con, keycode, true);

    qemu_input_event_send_key_delay(0);

    qemu_input_event_send_key_number(cv->vd->dcl.con, keycode, false);

    qemu_input_event_send_key_delay(0);

}
",LABEL_0,LABEL_0,LABEL_1,1,"vs,keysym","vs:-0.0003610849380493164,keysym:0.00024896860122680664,",2,6,0,"keysym:Keysem,vs:cv,",0,Greedy,87,0.030768640836079917,replace,[]
161,"static void tcx_blit_writel(void *opaque, hwaddr addr,

                            uint64_t val, unsigned size)

{

    TCXState *s = opaque;

    uint32_t adsr, len;

    int i;



    if (!(addr & 4)) {

        s->tmpblit = val;

    } else {

        addr = (addr >> 3) & 0xfffff;

        adsr = val & 0xffffff;

        len = ((val >> 24) & 0x1f) + 1;

        if (adsr == 0xffffff) {

            memset(&s->vram[addr], s->tmpblit, len);

            if (s->depth == 24) {

                val = s->tmpblit & 0xffffff;

                val = cpu_to_be32(val);

                for (i = 0; i < len; i++) {

                    s->vram24[addr + i] = val;

                }

            }

        } else {

            memcpy(&s->vram[addr], &s->vram[adsr], len);

            if (s->depth == 24) {

                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);

            }

        }

        memory_region_set_dirty(&s->vram_mem, addr, len);

    }

}
",242,"static void tcx_blit_writel(void *opaque, hwaddr dr,

                            uint64_t val, unsigned size)

{

    TCXState *sl = opaque;

    uint32_t anspr, len;

    int i;



    if (!(dr & 4)) {

        sl->tmpblit = val;

    } else {

        dr = (dr >> 3) & 0xfffff;

        anspr = val & 0xffffff;

        len = ((val >> 24) & 0x1f) + 1;

        if (anspr == 0xffffff) {

            memset(&sl->vram[dr], sl->tmpblit, len);

            if (sl->depth == 24) {

                val = sl->tmpblit & 0xffffff;

                val = cpu_to_be32(val);

                for (i = 0; i < len; i++) {

                    sl->vram24[dr + i] = val;

                }

            }

        } else {

            memcpy(&sl->vram[dr], &sl->vram[anspr], len);

            if (sl->depth == 24) {

                memcpy(&sl->vram24[dr], &sl->vram24[anspr], len * 4);

            }

        }

        memory_region_set_dirty(&sl->vram_mem, dr, len);

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"opaque,addr,val,size,s,adsr,len,i","opaque:2.2411346435546875e-05,addr:0.0005641579627990723,val:0.00031882524490356445,size:4.798173904418945e-05,s:0.0008688569068908691,adsr:0.0006644725799560547,len:0.00044804811477661133,i:0.00018227100372314453,",3,27,0,"s:sl,adsr:anspr,addr:dr,",0,Greedy,275,0.10254362026850382,replace,[]
162,"static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
    opj_image_cmptparm_t cmptparm[4] = {{0}};
    opj_image_t *img;
    int i;
    int sub_dx[4];
    int sub_dy[4];
    int numcomps;
    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;
    sub_dx[0] = sub_dx[3] = 1;
    sub_dy[0] = sub_dy[3] = 1;
    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;
    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;
    numcomps = desc->nb_components;
    switch (avctx->pix_fmt) {
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_YA8:
    case AV_PIX_FMT_GRAY16:
    case AV_PIX_FMT_YA16:
        color_space = CLRSPC_GRAY;
        break;
    case AV_PIX_FMT_RGB24:
    case AV_PIX_FMT_RGBA:
    case AV_PIX_FMT_RGB48:
    case AV_PIX_FMT_RGBA64:
    case AV_PIX_FMT_GBR24P:
    case AV_PIX_FMT_GBRP9:
    case AV_PIX_FMT_GBRP10:
    case AV_PIX_FMT_GBRP12:
    case AV_PIX_FMT_GBRP14:
    case AV_PIX_FMT_GBRP16:
    case AV_PIX_FMT_XYZ12:
        color_space = CLRSPC_SRGB;
        break;
    case AV_PIX_FMT_YUV410P:
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9:
    case AV_PIX_FMT_YUV422P9:
    case AV_PIX_FMT_YUV444P9:
    case AV_PIX_FMT_YUVA420P9:
    case AV_PIX_FMT_YUVA422P9:
    case AV_PIX_FMT_YUVA444P9:
    case AV_PIX_FMT_YUV420P10:
    case AV_PIX_FMT_YUV422P10:
    case AV_PIX_FMT_YUV444P10:
    case AV_PIX_FMT_YUVA420P10:
    case AV_PIX_FMT_YUVA422P10:
    case AV_PIX_FMT_YUVA444P10:
    case AV_PIX_FMT_YUV420P12:
    case AV_PIX_FMT_YUV422P12:
    case AV_PIX_FMT_YUV444P12:
    case AV_PIX_FMT_YUV420P14:
    case AV_PIX_FMT_YUV422P14:
    case AV_PIX_FMT_YUV444P14:
    case AV_PIX_FMT_YUV420P16:
    case AV_PIX_FMT_YUV422P16:
    case AV_PIX_FMT_YUV444P16:
    case AV_PIX_FMT_YUVA420P16:
    case AV_PIX_FMT_YUVA422P16:
    case AV_PIX_FMT_YUVA444P16:
        color_space = CLRSPC_SYCC;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR,
               ""The requested pixel format '%s' is not supported\n"",
               av_get_pix_fmt_name(avctx->pix_fmt));
    }
    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = sub_dx[i];
        cmptparm[i].dy = sub_dy[i];
        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];
        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];
    }
    img = opj_image_create(numcomps, cmptparm, color_space);
    // x0, y0 is the top left corner of the image
    // x1, y1 is the width, height of the reference grid
    img->x0 = 0;
    img->y0 = 0;
    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;
    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;
    return img;
}",566,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,parameters,desc,cmptparm,img,i,sub_dx,sub_dy,numcomps",,8,65,0,,0,GA,1676,0.75152747631073,failed,[]
163,"static int packet_enqueue(CompareState *s, int mode)

{

    ConnectionKey key;

    Packet *pkt = NULL;

    Connection *conn;



    if (mode == PRIMARY_IN) {

        pkt = packet_new(s->pri_rs.buf,

                         s->pri_rs.packet_len,

                         s->pri_rs.vnet_hdr_len);

    } else {

        pkt = packet_new(s->sec_rs.buf,

                         s->sec_rs.packet_len,

                         s->sec_rs.vnet_hdr_len);

    }



    if (parse_packet_early(pkt)) {

        packet_destroy(pkt, NULL);

        pkt = NULL;

        return -1;

    }

    fill_connection_key(pkt, &key);



    conn = connection_get(s->connection_track_table,

                          &key,

                          &s->conn_list);



    if (!conn->processing) {

        g_queue_push_tail(&s->conn_list, conn);

        conn->processing = true;

    }



    if (mode == PRIMARY_IN) {

        if (!colo_insert_packet(&conn->primary_list, pkt)) {

            error_report(""colo compare primary queue size too big,""

                         ""drop packet"");

        }

    } else {

        if (!colo_insert_packet(&conn->secondary_list, pkt)) {

            error_report(""colo compare secondary queue size too big,""

                         ""drop packet"");

        }

    }



    return 0;

}
",226,"static int packet_enqueue(CompareState *c, int mac)

{

    ConnectionKey er;

    Packet *payet = NULL;

    Connection *ann;



    if (mac == PRIMARY_IN) {

        payet = packet_new(c->pri_rs.buf,

                         c->pri_rs.packet_len,

                         c->pri_rs.vnet_hdr_len);

    } else {

        payet = packet_new(c->sec_rs.buf,

                         c->sec_rs.packet_len,

                         c->sec_rs.vnet_hdr_len);

    }



    if (parse_packet_early(payet)) {

        packet_destroy(payet, NULL);

        payet = NULL;

        return -1;

    }

    fill_connection_key(payet, &er);



    ann = connection_get(c->connection_track_table,

                          &er,

                          &c->conn_list);



    if (!conn->processing) {

        g_queue_push_tail(&c->conn_list, ann);

        ann->processing = true;

    }



    if (mac == PRIMARY_IN) {

        if (!colo_insert_packet(&ann->primary_list, payet)) {

            error_report(""colo compare primary queue size too big,""

                         ""drop packet"");

        }

    } else {

        if (!colo_insert_packet(&ann->secondary_list, payet)) {

            error_report(""colo compare secondary queue size too big,""

                         ""drop packet"");

        }

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,mode,key,pkt,conn","s:-0.00016748905181884766,mode:-0.00025027990341186523,key:-0.00013178586959838867,pkt:-0.00015860795974731445,conn:-0.0004246234893798828,",5,31,0,"key:er,pkt:payet,s:c,mode:mac,conn:ann,",0,Greedy,310,0.11593598524729411,replace,[]
164,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[n].u64[0] = ldq_p(mem_buf);

        env->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        env->avr[n].u64[1] = ldq_p(mem_buf);

        env->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;

    }

    if (n == 33) {

        env->vscr = ldl_p(mem_buf);

        return 4;

    }

    if (n == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);

        return 4;

    }

    return 0;

}
",155,"static int gdb_set_avr_reg(CPUState *eni, uint8_t *Mem_brace, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        eni->avr[n].u64[0] = ldq_p(Mem_brace);

        eni->avr[n].u64[1] = ldq_p(Mem_brace+8);

#else

        eni->avr[n].u64[1] = ldq_p(Mem_brace);

        eni->avr[n].u64[0] = ldq_p(Mem_brace+8);

#endif

        return 16;

    }

    if (n == 33) {

        eni->vscr = ldl_p(Mem_brace);

        return 4;

    }

    if (n == 34) {

        eni->spr[SPR_VRSAVE] = (target_ulong)ldl_p(Mem_brace);

        return 4;

    }

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"env,mem_buf,n","env:0.0005728006362915039,mem_buf:0.00061798095703125,n:0.0004817843437194824,",2,14,0,"mem_buf:Mem_brace,env:eni,",0,Greedy,141,0.05113351345062256,replace,[]
165,"static void conditional_branch(DBDMA_channel *ch)

{

    dbdma_cmd *current = &ch->current;

    uint16_t br;

    uint16_t sel_mask, sel_value;

    uint32_t status;

    int cond;



    DBDMA_DPRINTF(""conditional_branch\n"");



    /* check if we must branch */



    br = le16_to_cpu(current->command) & BR_MASK;



    switch(br) {

    case BR_NEVER:  /* don't branch */

        next(ch);

        return;

    case BR_ALWAYS: /* always branch */

        branch(ch);

        return;

    }



    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;



    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;

    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;



    cond = (status & sel_mask) == (sel_value & sel_mask);



    switch(br) {

    case BR_IFSET:  /* branch if condition bit is 1 */

        if (cond)

            branch(ch);

        else

            next(ch);

        return;

    case BR_IFCLR:  /* branch if condition bit is 0 */

        if (!cond)

            branch(ch);

        else

            next(ch);

        return;

    }

}
",233,,LABEL_0,LABEL_0,LABEL_0,-1,"ch,current,br,sel_mask,sel_value,status,cond",,7,31,0,,0,GA,1429,0.5460624774297078,failed,[]
166,"void qemu_cpu_kick(void *env)

{

    return;

}
",11,,LABEL_0,LABEL_0,LABEL_0,-1,env,,1,1,0,,0,GA,238,0.08258905013402303,failed,[]
167,"static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode)

{

    int   band, result=0, numSubbands, lastTonal, numBands;



    if (codingMode == JOINT_STEREO && channelNum == 1) {

        if (get_bits(gb,2) != 3) {

            av_log(NULL,AV_LOG_ERROR,""JS mono Sound Unit id != 3.\n"");

            return -1;

        }

    } else {

        if (get_bits(gb,6) != 0x28) {

            av_log(NULL,AV_LOG_ERROR,""Sound Unit id != 0x28.\n"");

            return -1;

        }

    }



    /* number of coded QMF bands */

    pSnd->bandsCoded = get_bits(gb,2);



    result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded);

    if (result) return result;



    pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded);

    if (pSnd->numComponents == -1) return -1;



    numSubbands = decodeSpectrum (gb, pSnd->spectrum);



    /* Merge the decoded spectrum and tonal components. */

    lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components);





    /* calculate number of used MLT/QMF bands according to the amount of coded spectral lines */

    numBands = (subbandTab[numSubbands] - 1) >> 8;

    if (lastTonal >= 0)

        numBands = FFMAX((lastTonal + 256) >> 8, numBands);





    /* Reconstruct time domain samples. */

    for (band=0; band<4; band++) {

        /* Perform the IMDCT step without overlapping. */

        if (band <= numBands) {

            IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCT_buf, band&1);

        } else

            memset(pSnd->IMDCT_buf, 0, 512 * sizeof(float));



        /* gain compensation and overlapping */

        gainCompensateAndOverlap (pSnd->IMDCT_buf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]),

                                    &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]),

                                    &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band]));

    }



    /* Swap the gain control buffers for the next frame. */

    pSnd->gcBlkSwitch ^= 1;



    return 0;

}
",506,,LABEL_1,LABEL_0,,-4,"q,gb,pSnd,pOut,channelNum,codingMode,band,numSubbands,lastTonal,numBands",,,,0,,0,Greedy,1,0.0007531007130940755,,
168,"static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,

                             GetByteContext *gb)

{

    unsigned char rle_code;

    unsigned char extra_byte, odd_pixel;

    unsigned char stream_byte;

    unsigned int pixel_ptr = 0;

    int row_dec = pic->linesize[0];

    int row_ptr = (avctx->height - 1) * row_dec;

    int frame_size = row_dec * avctx->height;

    int i;



    while (row_ptr >= 0) {

        if (bytestream2_get_bytes_left(gb) <= 0) {

            av_log(avctx, AV_LOG_ERROR,

                   ""MS RLE: bytestream overrun, %d rows left\n"",

                   row_ptr);

            return AVERROR_INVALIDDATA;

        }

        rle_code = stream_byte = bytestream2_get_byteu(gb);

        if (rle_code == 0) {

            /* fetch the next byte to see how to handle escape code */

            stream_byte = bytestream2_get_byte(gb);

            if (stream_byte == 0) {

                /* line is done, goto the next one */

                row_ptr -= row_dec;

                pixel_ptr = 0;

            } else if (stream_byte == 1) {

                /* decode is done */

                return 0;

            } else if (stream_byte == 2) {

                /* reposition frame decode coordinates */

                stream_byte = bytestream2_get_byte(gb);

                pixel_ptr += stream_byte;

                stream_byte = bytestream2_get_byte(gb);

                row_ptr -= stream_byte * row_dec;

            } else {

                // copy pixels from encoded stream

                odd_pixel =  stream_byte & 1;

                rle_code = (stream_byte + 1) / 2;

                extra_byte = rle_code & 0x01;

                if (row_ptr + pixel_ptr + stream_byte > frame_size ||

                    bytestream2_get_bytes_left(gb) < rle_code) {

                    av_log(avctx, AV_LOG_ERROR,

                           ""MS RLE: frame/stream ptr just went out of bounds (copy)\n"");

                    return AVERROR_INVALIDDATA;

                }



                for (i = 0; i < rle_code; i++) {

                    if (pixel_ptr >= avctx->width)

                        break;

                    stream_byte = bytestream2_get_byteu(gb);

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;

                    pixel_ptr++;

                    if (i + 1 == rle_code && odd_pixel)

                        break;

                    if (pixel_ptr >= avctx->width)

                        break;

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;

                    pixel_ptr++;

                }



                // if the RLE code is odd, skip a byte in the stream

                if (extra_byte)

                    bytestream2_skip(gb, 1);

            }

        } else {

            // decode a run of data

            if (row_ptr + pixel_ptr + stream_byte > frame_size) {

                av_log(avctx, AV_LOG_ERROR,

                       ""MS RLE: frame ptr just went out of bounds (run)\n"");

                return AVERROR_INVALIDDATA;

            }

            stream_byte = bytestream2_get_byte(gb);

            for (i = 0; i < rle_code; i++) {

                if (pixel_ptr >= avctx->width)

                    break;

                if ((i & 1) == 0)

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;

                else

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;

                pixel_ptr++;

            }

        }

    }



    /* one last sanity check on the way out */

    if (bytestream2_get_bytes_left(gb)) {

        av_log(avctx, AV_LOG_ERROR,

               ""MS RLE: ended frame decode with %d bytes left over\n"",

               bytestream2_get_bytes_left(gb));

        return AVERROR_INVALIDDATA;

    }



    return 0;

}
",637,"static int msrle_decode_pal4(AVCodecContext *avescope, AVPicture *pic,

                             GetByteContext *gb)

{

    unsigned char rle_code;

    unsigned char extra_byte, odd_pixel;

    unsigned char stream_byte;

    unsigned int pixel_ptr = 0;

    int row_dec = pic->linesize[0];

    int row_ptr = (avescope->height - 1) * row_dec;

    int frame_size = row_dec * avescope->height;

    int i;



    while (row_ptr >= 0) {

        if (bytestream2_get_bytes_left(gb) <= 0) {

            av_log(avescope, AV_LOG_ERROR,

                   ""MS RLE: bytestream overrun, %d rows left
"",

                   row_ptr);

            return AVERROR_INVALIDDATA;

        }

        rle_code = stream_byte = bytestream2_get_byteu(gb);

        if (rle_code == 0) {

            /* fetch the next byte to see how to handle escape code */

            stream_byte = bytestream2_get_byte(gb);

            if (stream_byte == 0) {

                /* line is done, goto the next one */

                row_ptr -= row_dec;

                pixel_ptr = 0;

            } else if (stream_byte == 1) {

                /* decode is done */

                return 0;

            } else if (stream_byte == 2) {

                /* reposition frame decode coordinates */

                stream_byte = bytestream2_get_byte(gb);

                pixel_ptr += stream_byte;

                stream_byte = bytestream2_get_byte(gb);

                row_ptr -= stream_byte * row_dec;

            } else {

                // copy pixels from encoded stream

                odd_pixel =  stream_byte & 1;

                rle_code = (stream_byte + 1) / 2;

                extra_byte = rle_code & 0x01;

                if (row_ptr + pixel_ptr + stream_byte > frame_size ||

                    bytestream2_get_bytes_left(gb) < rle_code) {

                    av_log(avescope, AV_LOG_ERROR,

                           ""MS RLE: frame/stream ptr just went out of bounds (copy)
"");

                    return AVERROR_INVALIDDATA;

                }



                for (i = 0; i < rle_code; i++) {

                    if (pixel_ptr >= avescope->width)

                        break;

                    stream_byte = bytestream2_get_byteu(gb);

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;

                    pixel_ptr++;

                    if (i + 1 == rle_code && odd_pixel)

                        break;

                    if (pixel_ptr >= avescope->width)

                        break;

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;

                    pixel_ptr++;

                }



                // if the RLE code is odd, skip a byte in the stream

                if (extra_byte)

                    bytestream2_skip(gb, 1);

            }

        } else {

            // decode a run of data

            if (row_ptr + pixel_ptr + stream_byte > frame_size) {

                av_log(avescope, AV_LOG_ERROR,

                       ""MS RLE: frame ptr just went out of bounds (run)
"");

                return AVERROR_INVALIDDATA;

            }

            stream_byte = bytestream2_get_byte(gb);

            for (i = 0; i < rle_code; i++) {

                if (pixel_ptr >= avescope->width)

                    break;

                if ((i & 1) == 0)

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;

                else

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;

                pixel_ptr++;

            }

        }

    }



    /* one last sanity check on the way out */

    if (bytestream2_get_bytes_left(gb)) {

        av_log(avescope, AV_LOG_ERROR,

               ""MS RLE: ended frame decode with %d bytes left over
"",

               bytestream2_get_bytes_left(gb));

        return AVERROR_INVALIDDATA;

    }



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"avctx,pic,gb,rle_code,extra_byte,odd_pixel,stream_byte,i,pixel_ptr","avctx:0.00016885995864868164,pic:-0.00016069412231445312,gb:3.069639205932617e-05,rle_code:-6.61611557006836e-05,extra_byte:-4.035234451293945e-05,odd_pixel:-4.392862319946289e-05,stream_byte:-5.704164505004883e-05,i:-0.0001920461654663086,pixel_ptr:-5.97834587097168e-05,",1,10,0,"avctx:avescope,",0,Greedy,142,0.057480037212371826,replace,[]
169,"static void gen_srlq(DisasContext *ctx)

{

    int l1 = gen_new_label();

    int l2 = gen_new_label();

    TCGv t0 = tcg_temp_local_new();

    TCGv t1 = tcg_temp_local_new();

    TCGv t2 = tcg_temp_local_new();

    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);

    tcg_gen_movi_tl(t1, 0xFFFFFFFF);

    tcg_gen_shr_tl(t2, t1, t2);

    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);

    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);

    gen_load_spr(t0, SPR_MQ);

    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);

    tcg_gen_and_tl(t0, t0, t2);

    gen_load_spr(t1, SPR_MQ);

    tcg_gen_andc_tl(t1, t1, t2);

    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);

    gen_set_label(l2);

    tcg_temp_free(t0);

    tcg_temp_free(t1);

    tcg_temp_free(t2);

    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);

}
",256,,LABEL_0,LABEL_0,LABEL_0,-1,ctx,,1,9,0,,0,GA,291,0.10859582821528117,failed,[]
170,"static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)

{

    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);

}
",25,"static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *mx)

{

    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, mx);

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,m","env:-0.00017464160919189453,m:-9.083747863769531e-05,",1,2,0,"m:mx,",0,Greedy,42,0.014713831742604573,replace,[]
171,"static bool migrate_caps_check(bool *cap_list,

                               MigrationCapabilityStatusList *params,

                               Error **errp)

{

    MigrationCapabilityStatusList *cap;

    bool old_postcopy_cap;



    old_postcopy_cap = cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM];



    for (cap = params; cap; cap = cap->next) {

        cap_list[cap->value->capability] = cap->value->state;

    }



#ifndef CONFIG_LIVE_BLOCK_MIGRATION

    if (cap_list[MIGRATION_CAPABILITY_BLOCK]) {

        error_setg(errp, ""QEMU compiled without old-style (blk/-b, inc/-i) ""

                   ""block migration"");

        error_append_hint(errp, ""Use drive_mirror+NBD instead.\n"");

        return false;

    }

#endif



    if (cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]) {

        if (cap_list[MIGRATION_CAPABILITY_COMPRESS]) {

            /* The decompression threads asynchronously write into RAM

             * rather than use the atomic copies needed to avoid

             * userfaulting.  It should be possible to fix the decompression

             * threads for compatibility in future.

             */

            error_setg(errp, ""Postcopy is not currently compatible ""

                       ""with compression"");

            return false;

        }



        /* This check is reasonably expensive, so only when it's being

         * set the first time, also it's only the destination that needs

         * special support.

         */

        if (!old_postcopy_cap && runstate_check(RUN_STATE_INMIGRATE) &&

            !postcopy_ram_supported_by_host()) {

            /* postcopy_ram_supported_by_host will have emitted a more

             * detailed message

             */

            error_setg(errp, ""Postcopy is not supported"");

            return false;

        }

    }



    return true;

}
",252,,LABEL_0,LABEL_0,LABEL_0,-1,"cap_list,params,errp,cap,old_postcopy_cap",,3,14,0,,0,GA,1098,0.4309100826581319,failed,[]
172,"gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,

             uint32_t up_shift, CPUTriCoreState *env)

{

    TCGv temp = tcg_temp_new();

    TCGv temp2 = tcg_temp_new();

    TCGv temp3 = tcg_temp_new();

    TCGv_i64 t1 = tcg_temp_new_i64();

    TCGv_i64 t2 = tcg_temp_new_i64();

    TCGv_i64 t3 = tcg_temp_new_i64();

    TCGv_i64 t4 = tcg_temp_new_i64();



    tcg_gen_ext_i32_i64(t2, arg2);

    tcg_gen_ext_i32_i64(t3, arg3);



    tcg_gen_mul_i64(t2, t2, t3);



    tcg_gen_ext_i32_i64(t1, arg1);

    /* if we shift part of the fraction out, we need to round up */

    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);

    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);

    tcg_gen_sari_i64(t2, t2, up_shift - n);

    tcg_gen_add_i64(t2, t2, t4);



    tcg_gen_sub_i64(t3, t1, t2);

    tcg_gen_trunc_i64_i32(temp3, t3);

    /* calc v bit */

    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);

    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);

    tcg_gen_or_i64(t1, t1, t2);

    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);

    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);

    /* We produce an overflow on the host if the mul before was

       (0x80000000 * 0x80000000) << 1). If this is the

       case, we negate the ovf. */

    if (n == 1) {

        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);

        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);

        tcg_gen_and_tl(temp, temp, temp2);

        tcg_gen_shli_tl(temp, temp, 31);

        /* negate v bit, if special condition */

        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);

    }

    /* Calc SV bit */

    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);

    /* Calc AV/SAV bits */

    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);

    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);

    /* calc SAV */

    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);

    /* write back result */

    tcg_gen_mov_tl(ret, temp3);



    tcg_temp_free(temp);

    tcg_temp_free(temp2);

    tcg_temp_free(temp3);

    tcg_temp_free_i64(t1);

    tcg_temp_free_i64(t2);

    tcg_temp_free_i64(t3);

    tcg_temp_free_i64(t4);

}
",459,,LABEL_1,LABEL_0,,-4,"ret,TCGv,uint32_t",,,,0,,0,Greedy,1,0.0006937623023986816,,
173,"static size_t get_request_size(VirtQueue *vq)

{

    unsigned int in, out;



    virtqueue_get_avail_bytes(vq, &in, &out);

    return in;

}
",32,,LABEL_0,LABEL_1,,-4,"vq,in,out",,,,0,,0,Greedy,1,0.00042383273442586264,,
174,"static int ftp_current_dir(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    const char *command = ""PWD\r\n"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(s, command, pwd_codes, &res))

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '""') {

            if (!start) {

                start = res + i + 1;

                continue;

            }

            end = res + i;

            break;

        }

    }



    if (!end)

        goto fail;



    if (end > res && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, start, sizeof(s->path));



    av_free(res);

    return 0;



  fail:

    av_free(res);

    return AVERROR(EIO);

}
",197,"static int ftp_current_dir(FTPContext *s)

{

    char *gr = NULL, *start = NULL, *end = NULL;

    int i;

    const char *command = ""PWD\r
"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(s, command, pwd_codes, &gr))

        goto fail;



    for (i = 0; gr[i]; ++i) {

        if (gr[i] == '""') {

            if (!start) {

                start = gr + i + 1;

                continue;

            }

            end = gr + i;

            break;

        }

    }



    if (!end)

        goto fail;



    if (end > gr && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, start, sizeof(s->path));



    av_free(gr);

    return 0;



  fail:

    av_free(gr);

    return AVERROR(EIO);

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,res,start,end,i,command,pwd_codes","s:0.0004993677139282227,res:0.00139540433883667,start:0.00040912628173828125,end:0.0009274482727050781,i:0.0010679960250854492,command:0.00038558244705200195,pwd_codes:0.00021147727966308594,",1,9,0,"res:gr,",0,Greedy,101,0.03693339029947917,replace,[]
175,"static void visitor_output_setup_internal(TestOutputVisitorData *data,

                                          bool human)

{

    data->human = human;

    data->sov = string_output_visitor_new(human);

    g_assert(data->sov);

    data->ov = string_output_get_visitor(data->sov);

    g_assert(data->ov);

}
",61,,LABEL_0,LABEL_1,,-4,"data,human",,,,0,,0,Greedy,1,0.0004557649294535319,,
176,"int hvf_vcpu_exec(CPUState *cpu)

{

    X86CPU *x86_cpu = X86_CPU(cpu);

    CPUX86State *env = &x86_cpu->env;

    int ret = 0;

    uint64_t rip = 0;



    cpu->halted = 0;



    if (hvf_process_events(cpu)) {

        return EXCP_HLT;

    }



    do {

        if (cpu->vcpu_dirty) {

            hvf_put_registers(cpu);

            cpu->vcpu_dirty = false;

        }



        if (hvf_inject_interrupts(cpu)) {

            return EXCP_INTERRUPT;

        }

        vmx_update_tpr(cpu);



        qemu_mutex_unlock_iothread();

        if (!cpu_is_bsp(X86_CPU(cpu)) && cpu->halted) {

            qemu_mutex_lock_iothread();

            return EXCP_HLT;

        }



        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);

        assert_hvf_ok(r);



        /* handle VMEXIT */

        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);

        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);

        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,

                                           VMCS_EXIT_INSTRUCTION_LENGTH);



        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);



        hvf_store_events(cpu, ins_len, idtvec_info);

        rip = rreg(cpu->hvf_fd, HV_X86_RIP);

        RFLAGS(env) = rreg(cpu->hvf_fd, HV_X86_RFLAGS);

        env->eflags = RFLAGS(env);



        qemu_mutex_lock_iothread();



        update_apic_tpr(cpu);

        current_cpu = cpu;



        ret = 0;

        switch (exit_reason) {

        case EXIT_REASON_HLT: {

            macvm_set_rip(cpu, rip + ins_len);

            if (!((cpu->interrupt_request & CPU_INTERRUPT_HARD) &&

                (EFLAGS(env) & IF_MASK))

                && !(cpu->interrupt_request & CPU_INTERRUPT_NMI) &&

                !(idtvec_info & VMCS_IDT_VEC_VALID)) {

                cpu->halted = 1;

                ret = EXCP_HLT;

            }

            ret = EXCP_INTERRUPT;

            break;

        }

        case EXIT_REASON_MWAIT: {

            ret = EXCP_INTERRUPT;

            break;

        }

            /* Need to check if MMIO or unmmaped fault */

        case EXIT_REASON_EPT_FAULT:

        {

            hvf_slot *slot;

            addr_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);



            if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&

                ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {

                vmx_set_nmi_blocking(cpu);

            }



            slot = hvf_find_overlap_slot(gpa, gpa);

            /* mmio */

            if (ept_emulation_fault(slot, gpa, exit_qual)) {

                struct x86_decode decode;



                load_regs(cpu);

                env->hvf_emul->fetch_rip = rip;



                decode_instruction(env, &decode);

                exec_instruction(env, &decode);

                store_regs(cpu);

                break;

            }

            break;

        }

        case EXIT_REASON_INOUT:

        {

            uint32_t in = (exit_qual & 8) != 0;

            uint32_t size =  (exit_qual & 7) + 1;

            uint32_t string =  (exit_qual & 16) != 0;

            uint32_t port =  exit_qual >> 16;

            /*uint32_t rep = (exit_qual & 0x20) != 0;*/



#if 1

            if (!string && in) {

                uint64_t val = 0;

                load_regs(cpu);

                hvf_handle_io(env, port, &val, 0, size, 1);

                if (size == 1) {

                    AL(env) = val;

                } else if (size == 2) {

                    AX(env) = val;

                } else if (size == 4) {

                    RAX(env) = (uint32_t)val;

                } else {

                    VM_PANIC(""size"");

                }

                RIP(env) += ins_len;

                store_regs(cpu);

                break;

            } else if (!string && !in) {

                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);

                hvf_handle_io(env, port, &RAX(env), 1, size, 1);

                macvm_set_rip(cpu, rip + ins_len);

                break;

            }

#endif

            struct x86_decode decode;



            load_regs(cpu);

            env->hvf_emul->fetch_rip = rip;



            decode_instruction(env, &decode);

            VM_PANIC_ON(ins_len != decode.len);

            exec_instruction(env, &decode);

            store_regs(cpu);



            break;

        }

        case EXIT_REASON_CPUID: {

            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);

            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);

            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);

            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);



            cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);



            wreg(cpu->hvf_fd, HV_X86_RAX, rax);

            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);

            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);

            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);



            macvm_set_rip(cpu, rip + ins_len);

            break;

        }

        case EXIT_REASON_XSETBV: {

            X86CPU *x86_cpu = X86_CPU(cpu);

            CPUX86State *env = &x86_cpu->env;

            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);

            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);

            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);



            if (ecx) {

                macvm_set_rip(cpu, rip + ins_len);

                break;

            }

            env->xcr0 = ((uint64_t)edx << 32) | eax;

            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);

            macvm_set_rip(cpu, rip + ins_len);

            break;

        }

        case EXIT_REASON_INTR_WINDOW:

            vmx_clear_int_window_exiting(cpu);

            ret = EXCP_INTERRUPT;

            break;

        case EXIT_REASON_NMI_WINDOW:

            vmx_clear_nmi_window_exiting(cpu);

            ret = EXCP_INTERRUPT;

            break;

        case EXIT_REASON_EXT_INTR:

            /* force exit and allow io handling */

            ret = EXCP_INTERRUPT;

            break;

        case EXIT_REASON_RDMSR:

        case EXIT_REASON_WRMSR:

        {

            load_regs(cpu);

            if (exit_reason == EXIT_REASON_RDMSR) {

                simulate_rdmsr(cpu);

            } else {

                simulate_wrmsr(cpu);

            }

            RIP(env) += rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);

            store_regs(cpu);

            break;

        }

        case EXIT_REASON_CR_ACCESS: {

            int cr;

            int reg;



            load_regs(cpu);

            cr = exit_qual & 15;

            reg = (exit_qual >> 8) & 15;



            switch (cr) {

            case 0x0: {

                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));

                break;

            }

            case 4: {

                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));

                break;

            }

            case 8: {

                X86CPU *x86_cpu = X86_CPU(cpu);

                if (exit_qual & 0x10) {

                    RRX(env, reg) = cpu_get_apic_tpr(x86_cpu->apic_state);

                } else {

                    int tpr = RRX(env, reg);

                    cpu_set_apic_tpr(x86_cpu->apic_state, tpr);

                    ret = EXCP_INTERRUPT;

                }

                break;

            }

            default:

                error_report(""Unrecognized CR %d\n"", cr);

                abort();

            }

            RIP(env) += ins_len;

            store_regs(cpu);

            break;

        }

        case EXIT_REASON_APIC_ACCESS: { /* TODO */

            struct x86_decode decode;



            load_regs(cpu);

            env->hvf_emul->fetch_rip = rip;



            decode_instruction(env, &decode);

            exec_instruction(env, &decode);

            store_regs(cpu);

            break;

        }

        case EXIT_REASON_TPR: {

            ret = 1;

            break;

        }

        case EXIT_REASON_TASK_SWITCH: {

            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);

            x68_segment_selector sel = {.sel = exit_qual & 0xffff};

            vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,

             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo

             & VMCS_INTR_T_MASK);

            break;

        }

        case EXIT_REASON_TRIPLE_FAULT: {

            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);

            ret = EXCP_INTERRUPT;

            break;

        }

        case EXIT_REASON_RDPMC:

            wreg(cpu->hvf_fd, HV_X86_RAX, 0);

            wreg(cpu->hvf_fd, HV_X86_RDX, 0);

            macvm_set_rip(cpu, rip + ins_len);

            break;

        case VMX_REASON_VMCALL:

            /* TODO: inject #GP fault */

            break;

        default:

            error_report(""%llx: unhandled exit %llx\n"", rip, exit_reason);

        }

    } while (ret == 0);



    return ret;

}
",1539,,LABEL_1,LABEL_0,,-4,"cpu,x86_cpu,env",,,,0,,0,Greedy,1,0.001364147663116455,,
177,"static void build_feed_streams(void)

{

    FFStream *stream, *feed;

    int i;



    /* gather all streams */

    for(stream = first_stream; stream != NULL; stream = stream->next) {

        feed = stream->feed;

        if (feed) {

            if (!stream->is_feed) {

                /* we handle a stream coming from a feed */

                for(i=0;i<stream->nb_streams;i++)

                    stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);

            }

        }

    }



    /* gather all streams */

    for(stream = first_stream; stream != NULL; stream = stream->next) {

        feed = stream->feed;

        if (feed) {

            if (stream->is_feed) {

                for(i=0;i<stream->nb_streams;i++)

                    stream->feed_streams[i] = i;

            }

        }

    }



    /* create feed files if needed */

    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {

        int fd;



        if (url_exist(feed->feed_filename)) {

            /* See if it matches */

            AVFormatContext *s;

            int matches = 0;



            if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {

                /* Now see if it matches */

                if (s->nb_streams == feed->nb_streams) {

                    matches = 1;

                    for(i=0;i<s->nb_streams;i++) {

                        AVStream *sf, *ss;

                        sf = feed->streams[i];

                        ss = s->streams[i];



                        if (sf->index != ss->index ||

                            sf->id != ss->id) {

                            http_log(""Index & Id do not match for stream %d (%s)\n"",

                                   i, feed->feed_filename);

                            matches = 0;

                        } else {

                            AVCodecContext *ccf, *ccs;



                            ccf = sf->codec;

                            ccs = ss->codec;

#define CHECK_CODEC(x)  (ccf->x != ccs->x)



                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {

                                http_log(""Codecs do not match for stream %d\n"", i);

                                matches = 0;

                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {

                                http_log(""Codec bitrates do not match for stream %d\n"", i);

                                matches = 0;

                            } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) {

                                if (CHECK_CODEC(time_base.den) ||

                                    CHECK_CODEC(time_base.num) ||

                                    CHECK_CODEC(width) ||

                                    CHECK_CODEC(height)) {

                                    http_log(""Codec width, height and framerate do not match for stream %d\n"", i);

                                    matches = 0;

                                }

                            } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) {

                                if (CHECK_CODEC(sample_rate) ||

                                    CHECK_CODEC(channels) ||

                                    CHECK_CODEC(frame_size)) {

                                    http_log(""Codec sample_rate, channels, frame_size do not match for stream %d\n"", i);

                                    matches = 0;

                                }

                            } else {

                                http_log(""Unknown codec type\n"");

                                matches = 0;

                            }

                        }

                        if (!matches)

                            break;

                    }

                } else

                    http_log(""Deleting feed file '%s' as stream counts differ (%d != %d)\n"",

                        feed->feed_filename, s->nb_streams, feed->nb_streams);



                av_close_input_file(s);

            } else

                http_log(""Deleting feed file '%s' as it appears to be corrupt\n"",

                        feed->feed_filename);



            if (!matches) {

                if (feed->readonly) {

                    http_log(""Unable to delete feed file '%s' as it is marked readonly\n"",

                        feed->feed_filename);

                    exit(1);

                }

                unlink(feed->feed_filename);

            }

        }

        if (!url_exist(feed->feed_filename)) {

            AVFormatContext s1 = {0}, *s = &s1;



            if (feed->readonly) {

                http_log(""Unable to create feed file '%s' as it is marked readonly\n"",

                    feed->feed_filename);

                exit(1);

            }



            /* only write the header of the ffm file */

            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {

                http_log(""Could not open output feed file '%s'\n"",

                         feed->feed_filename);

                exit(1);

            }

            s->oformat = feed->fmt;

            s->nb_streams = feed->nb_streams;

            for(i=0;i<s->nb_streams;i++) {

                AVStream *st;

                st = feed->streams[i];

                s->streams[i] = st;

            }

            av_set_parameters(s, NULL);

            if (av_write_header(s) < 0) {

                http_log(""Container doesn't supports the required parameters\n"");

                exit(1);

            }

            /* XXX: need better api */

            av_freep(&s->priv_data);

            avio_close(s->pb);

        }

        /* get feed size and write index */

        fd = open(feed->feed_filename, O_RDONLY);

        if (fd < 0) {

            http_log(""Could not open output feed file '%s'\n"",

                    feed->feed_filename);

            exit(1);

        }



        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);

        feed->feed_size = lseek(fd, 0, SEEK_END);

        /* ensure that we do not wrap before the end of file */

        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)

            feed->feed_max_size = feed->feed_size;



        close(fd);

    }

}
",1136,"static void build_feed_streams(void)

{

    FFStream *row, *gg;

    int i;



    /* gather all streams */

    for(row = first_stream; row != NULL; row = row->next) {

        gg = row->gg;

        if (gg) {

            if (!stream->is_feed) {

                /* we handle a row coming from a gg */

                for(i=0;i<row->nb_streams;i++)

                    row->feed_streams[i] = add_av_stream(gg, row->streams[i]);

            }

        }

    }



    /* gather all streams */

    for(row = first_stream; row != NULL; row = row->next) {

        gg = row->gg;

        if (gg) {

            if (row->is_feed) {

                for(i=0;i<row->nb_streams;i++)

                    row->feed_streams[i] = i;

            }

        }

    }



    /* create gg files if needed */

    for(gg = first_feed; gg != NULL; gg = gg->next_feed) {

        int fd;



        if (url_exist(gg->feed_filename)) {

            /* See if it matches */

            AVFormatContext *s;

            int matches = 0;



            if (av_open_input_file(&s, gg->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {

                /* Now see if it matches */

                if (s->nb_streams == gg->nb_streams) {

                    matches = 1;

                    for(i=0;i<s->nb_streams;i++) {

                        AVStream *sf, *ss;

                        sf = gg->streams[i];

                        ss = s->streams[i];



                        if (sf->index != ss->index ||

                            sf->id != ss->id) {

                            http_log(""Index & Id do not match for row %d (%s)
"",

                                   i, gg->feed_filename);

                            matches = 0;

                        } else {

                            AVCodecContext *ccf, *ccs;



                            ccf = sf->codec;

                            ccs = ss->codec;

#define CHECK_CODEC(x)  (ccf->x != ccs->x)



                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {

                                http_log(""Codecs do not match for row %d
"", i);

                                matches = 0;

                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {

                                http_log(""Codec bitrates do not match for row %d
"", i);

                                matches = 0;

                            } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) {

                                if (CHECK_CODEC(time_base.den) ||

                                    CHECK_CODEC(time_base.num) ||

                                    CHECK_CODEC(width) ||

                                    CHECK_CODEC(height)) {

                                    http_log(""Codec width, height and framerate do not match for row %d
"", i);

                                    matches = 0;

                                }

                            } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) {

                                if (CHECK_CODEC(sample_rate) ||

                                    CHECK_CODEC(channels) ||

                                    CHECK_CODEC(frame_size)) {

                                    http_log(""Codec sample_rate, channels, frame_size do not match for row %d
"", i);

                                    matches = 0;

                                }

                            } else {

                                http_log(""Unknown codec type
"");

                                matches = 0;

                            }

                        }

                        if (!matches)

                            break;

                    }

                } else

                    http_log(""Deleting gg file '%s' as row counts differ (%d != %d)
"",

                        gg->feed_filename, s->nb_streams, gg->nb_streams);



                av_close_input_file(s);

            } else

                http_log(""Deleting gg file '%s' as it appears to be corrupt
"",

                        gg->feed_filename);



            if (!matches) {

                if (gg->readonly) {

                    http_log(""Unable to delete gg file '%s' as it is marked readonly
"",

                        gg->feed_filename);

                    exit(1);

                }

                unlink(gg->feed_filename);

            }

        }

        if (!url_exist(gg->feed_filename)) {

            AVFormatContext s1 = {0}, *s = &s1;



            if (gg->readonly) {

                http_log(""Unable to create gg file '%s' as it is marked readonly
"",

                    gg->feed_filename);

                exit(1);

            }



            /* only write the header of the ffm file */

            if (avio_open(&s->pb, gg->feed_filename, AVIO_FLAG_WRITE) < 0) {

                http_log(""Could not open output gg file '%s'
"",

                         gg->feed_filename);

                exit(1);

            }

            s->oformat = gg->fmt;

            s->nb_streams = gg->nb_streams;

            for(i=0;i<s->nb_streams;i++) {

                AVStream *st;

                st = gg->streams[i];

                s->streams[i] = st;

            }

            av_set_parameters(s, NULL);

            if (av_write_header(s) < 0) {

                http_log(""Container doesn't supports the required parameters
"");

                exit(1);

            }

            /* XXX: need better api */

            av_freep(&s->priv_data);

            avio_close(s->pb);

        }

        /* get gg size and write index */

        fd = open(gg->feed_filename, O_RDONLY);

        if (fd < 0) {

            http_log(""Could not open output gg file '%s'
"",

                    gg->feed_filename);

            exit(1);

        }



        gg->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);

        gg->feed_size = lseek(fd, 0, SEEK_END);

        /* ensure that we do not wrap before the end of file */

        if (gg->feed_max_size && gg->feed_max_size < gg->feed_size)

            gg->feed_max_size = gg->feed_size;



        close(fd);

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"stream,feed,i,fd,s,sf,ss,ccf,ccs","stream:2.063934028148651,feed:2.432187795639038,i:1.8097557425498962,fd:0.022656261920928955,s:0.6787801384925842,sf:0.10185068845748901,ss:0.42629194259643555,ccf:0.080596923828125,ccs:0.037435710430145264,",2,73,0,"feed:gg,stream:row,",0,Greedy,313,0.14956443309783934,replace,[]
178,"qcrypto_block_luks_create(QCryptoBlock *block,

                          QCryptoBlockCreateOptions *options,

                          QCryptoBlockInitFunc initfunc,

                          QCryptoBlockWriteFunc writefunc,

                          void *opaque,

                          Error **errp)

{

    QCryptoBlockLUKS *luks;

    QCryptoBlockCreateOptionsLUKS luks_opts;

    Error *local_err = NULL;

    uint8_t *masterkey = NULL;

    uint8_t *slotkey = NULL;

    uint8_t *splitkey = NULL;

    size_t splitkeylen = 0;

    size_t i;

    QCryptoCipher *cipher = NULL;

    QCryptoIVGen *ivgen = NULL;

    char *password;

    const char *cipher_alg;

    const char *cipher_mode;

    const char *ivgen_alg;

    const char *ivgen_hash_alg = NULL;

    const char *hash_alg;

    char *cipher_mode_spec = NULL;

    QCryptoCipherAlgorithm ivcipheralg = 0;

    uint64_t iters;



    memcpy(&luks_opts, &options->u.luks, sizeof(luks_opts));

    if (!luks_opts.has_iter_time) {

        luks_opts.iter_time = 2000;

    }

    if (!luks_opts.has_cipher_alg) {

        luks_opts.cipher_alg = QCRYPTO_CIPHER_ALG_AES_256;

    }

    if (!luks_opts.has_cipher_mode) {

        luks_opts.cipher_mode = QCRYPTO_CIPHER_MODE_XTS;

    }

    if (!luks_opts.has_ivgen_alg) {

        luks_opts.ivgen_alg = QCRYPTO_IVGEN_ALG_PLAIN64;

    }

    if (!luks_opts.has_hash_alg) {

        luks_opts.hash_alg = QCRYPTO_HASH_ALG_SHA256;

    }

    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {

        if (!luks_opts.has_ivgen_hash_alg) {

            luks_opts.ivgen_hash_alg = QCRYPTO_HASH_ALG_SHA256;

            luks_opts.has_ivgen_hash_alg = true;

        }

    }

    /* Note we're allowing ivgen_hash_alg to be set even for

     * non-essiv iv generators that don't need a hash. It will

     * be silently ignored, for compatibility with dm-crypt */



    if (!options->u.luks.key_secret) {

        error_setg(errp, ""Parameter 'key-secret' is required for cipher"");

        return -1;

    }

    password = qcrypto_secret_lookup_as_utf8(luks_opts.key_secret, errp);

    if (!password) {

        return -1;

    }



    luks = g_new0(QCryptoBlockLUKS, 1);

    block->opaque = luks;



    memcpy(luks->header.magic, qcrypto_block_luks_magic,

           QCRYPTO_BLOCK_LUKS_MAGIC_LEN);



    /* We populate the header in native endianness initially and

     * then convert everything to big endian just before writing

     * it out to disk

     */

    luks->header.version = QCRYPTO_BLOCK_LUKS_VERSION;

    qcrypto_block_luks_uuid_gen(luks->header.uuid);



    cipher_alg = qcrypto_block_luks_cipher_alg_lookup(luks_opts.cipher_alg,

                                                      errp);

    if (!cipher_alg) {

        goto error;

    }



    cipher_mode = QCryptoCipherMode_lookup[luks_opts.cipher_mode];

    ivgen_alg = QCryptoIVGenAlgorithm_lookup[luks_opts.ivgen_alg];

    if (luks_opts.has_ivgen_hash_alg) {

        ivgen_hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.ivgen_hash_alg];

        cipher_mode_spec = g_strdup_printf(""%s-%s:%s"", cipher_mode, ivgen_alg,

                                           ivgen_hash_alg);

    } else {

        cipher_mode_spec = g_strdup_printf(""%s-%s"", cipher_mode, ivgen_alg);

    }

    hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.hash_alg];





    if (strlen(cipher_alg) >= QCRYPTO_BLOCK_LUKS_CIPHER_NAME_LEN) {

        error_setg(errp, ""Cipher name '%s' is too long for LUKS header"",

                   cipher_alg);

        goto error;

    }

    if (strlen(cipher_mode_spec) >= QCRYPTO_BLOCK_LUKS_CIPHER_MODE_LEN) {

        error_setg(errp, ""Cipher mode '%s' is too long for LUKS header"",

                   cipher_mode_spec);

        goto error;

    }

    if (strlen(hash_alg) >= QCRYPTO_BLOCK_LUKS_HASH_SPEC_LEN) {

        error_setg(errp, ""Hash name '%s' is too long for LUKS header"",

                   hash_alg);

        goto error;

    }



    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {

        ivcipheralg = qcrypto_block_luks_essiv_cipher(luks_opts.cipher_alg,

                                                      luks_opts.ivgen_hash_alg,

                                                      &local_err);

        if (local_err) {

            error_propagate(errp, local_err);

            goto error;

        }

    } else {

        ivcipheralg = luks_opts.cipher_alg;

    }



    strcpy(luks->header.cipher_name, cipher_alg);

    strcpy(luks->header.cipher_mode, cipher_mode_spec);

    strcpy(luks->header.hash_spec, hash_alg);



    luks->header.key_bytes = qcrypto_cipher_get_key_len(luks_opts.cipher_alg);

    if (luks_opts.cipher_mode == QCRYPTO_CIPHER_MODE_XTS) {

        luks->header.key_bytes *= 2;

    }



    /* Generate the salt used for hashing the master key

     * with PBKDF later

     */

    if (qcrypto_random_bytes(luks->header.master_key_salt,

                             QCRYPTO_BLOCK_LUKS_SALT_LEN,

                             errp) < 0) {

        goto error;

    }



    /* Generate random master key */

    masterkey = g_new0(uint8_t, luks->header.key_bytes);

    if (qcrypto_random_bytes(masterkey,

                             luks->header.key_bytes, errp) < 0) {

        goto error;

    }





    /* Setup the block device payload encryption objects */

    block->cipher = qcrypto_cipher_new(luks_opts.cipher_alg,

                                       luks_opts.cipher_mode,

                                       masterkey, luks->header.key_bytes,

                                       errp);

    if (!block->cipher) {

        goto error;

    }



    block->kdfhash = luks_opts.hash_alg;

    block->niv = qcrypto_cipher_get_iv_len(luks_opts.cipher_alg,

                                           luks_opts.cipher_mode);

    block->ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,

                                     ivcipheralg,

                                     luks_opts.ivgen_hash_alg,

                                     masterkey, luks->header.key_bytes,

                                     errp);



    if (!block->ivgen) {

        goto error;

    }





    /* Determine how many iterations we need to hash the master

     * key, in order to have 1 second of compute time used

     */

    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,

                                       masterkey, luks->header.key_bytes,

                                       luks->header.master_key_salt,

                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,

                                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,

                                       &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        goto error;

    }



    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {

        error_setg_errno(errp, ERANGE,

                         ""PBKDF iterations %llu too large to scale"",

                         (unsigned long long)iters);

        goto error;

    }



    /* iter_time was in millis, but count_iters reported for secs */

    iters = iters * luks_opts.iter_time / 1000;



    /* Why /= 8 ?  That matches cryptsetup, but there's no

     * explanation why they chose /= 8... Probably so that

     * if all 8 keyslots are active we only spend 1 second

     * in total time to check all keys */

    iters /= 8;

    if (iters > UINT32_MAX) {

        error_setg_errno(errp, ERANGE,

                         ""PBKDF iterations %llu larger than %u"",

                         (unsigned long long)iters, UINT32_MAX);

        goto error;

    }

    iters = MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_MASTER_KEY_ITERS);

    luks->header.master_key_iterations = iters;



    /* Hash the master key, saving the result in the LUKS

     * header. This hash is used when opening the encrypted

     * device to verify that the user password unlocked a

     * valid master key

     */

    if (qcrypto_pbkdf2(luks_opts.hash_alg,

                       masterkey, luks->header.key_bytes,

                       luks->header.master_key_salt,

                       QCRYPTO_BLOCK_LUKS_SALT_LEN,

                       luks->header.master_key_iterations,

                       luks->header.master_key_digest,

                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,

                       errp) < 0) {

        goto error;

    }





    /* Although LUKS has multiple key slots, we're just going

     * to use the first key slot */

    splitkeylen = luks->header.key_bytes * QCRYPTO_BLOCK_LUKS_STRIPES;

    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {

        luks->header.key_slots[i].active = i == 0 ?

            QCRYPTO_BLOCK_LUKS_KEY_SLOT_ENABLED :

            QCRYPTO_BLOCK_LUKS_KEY_SLOT_DISABLED;

        luks->header.key_slots[i].stripes = QCRYPTO_BLOCK_LUKS_STRIPES;



        /* This calculation doesn't match that shown in the spec,

         * but instead follows the cryptsetup implementation.

         */

        luks->header.key_slots[i].key_offset =

            (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /

             QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +

            (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),

                      (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /

                       QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) * i);

    }



    if (qcrypto_random_bytes(luks->header.key_slots[0].salt,

                             QCRYPTO_BLOCK_LUKS_SALT_LEN,

                             errp) < 0) {

        goto error;

    }



    /* Again we determine how many iterations are required to

     * hash the user password while consuming 1 second of compute

     * time */

    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,

                                       (uint8_t *)password, strlen(password),

                                       luks->header.key_slots[0].salt,

                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,

                                       luks->header.key_bytes,

                                       &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        goto error;

    }



    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {

        error_setg_errno(errp, ERANGE,

                         ""PBKDF iterations %llu too large to scale"",

                         (unsigned long long)iters);

        goto error;

    }



    /* iter_time was in millis, but count_iters reported for secs */

    iters = iters * luks_opts.iter_time / 1000;



    if (iters > UINT32_MAX) {

        error_setg_errno(errp, ERANGE,

                         ""PBKDF iterations %llu larger than %u"",

                         (unsigned long long)iters, UINT32_MAX);

        goto error;

    }



    luks->header.key_slots[0].iterations =

        MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_SLOT_KEY_ITERS);





    /* Generate a key that we'll use to encrypt the master

     * key, from the user's password

     */

    slotkey = g_new0(uint8_t, luks->header.key_bytes);

    if (qcrypto_pbkdf2(luks_opts.hash_alg,

                       (uint8_t *)password, strlen(password),

                       luks->header.key_slots[0].salt,

                       QCRYPTO_BLOCK_LUKS_SALT_LEN,

                       luks->header.key_slots[0].iterations,

                       slotkey, luks->header.key_bytes,

                       errp) < 0) {

        goto error;

    }





    /* Setup the encryption objects needed to encrypt the

     * master key material

     */

    cipher = qcrypto_cipher_new(luks_opts.cipher_alg,

                                luks_opts.cipher_mode,

                                slotkey, luks->header.key_bytes,

                                errp);

    if (!cipher) {

        goto error;

    }



    ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,

                              ivcipheralg,

                              luks_opts.ivgen_hash_alg,

                              slotkey, luks->header.key_bytes,

                              errp);

    if (!ivgen) {

        goto error;

    }



    /* Before storing the master key, we need to vastly

     * increase its size, as protection against forensic

     * disk data recovery */

    splitkey = g_new0(uint8_t, splitkeylen);



    if (qcrypto_afsplit_encode(luks_opts.hash_alg,

                               luks->header.key_bytes,

                               luks->header.key_slots[0].stripes,

                               masterkey,

                               splitkey,

                               errp) < 0) {

        goto error;

    }



    /* Now we encrypt the split master key with the key generated

     * from the user's password, before storing it */

    if (qcrypto_block_encrypt_helper(cipher, block->niv, ivgen,

                                     QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,

                                     0,

                                     splitkey,

                                     splitkeylen,

                                     errp) < 0) {

        goto error;

    }





    /* The total size of the LUKS headers is the partition header + key

     * slot headers, rounded up to the nearest sector, combined with

     * the size of each master key material region, also rounded up

     * to the nearest sector */

    luks->header.payload_offset =

        (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /

         QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +

        (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),

                  (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /

                   QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) *

         QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS);



    block->payload_offset = luks->header.payload_offset *

        QCRYPTO_BLOCK_LUKS_SECTOR_SIZE;



    /* Reserve header space to match payload offset */

    initfunc(block, block->payload_offset, &local_err, opaque);

    if (local_err) {

        error_propagate(errp, local_err);

        goto error;

    }



    /* Everything on disk uses Big Endian, so flip header fields

     * before writing them */

    cpu_to_be16s(&luks->header.version);

    cpu_to_be32s(&luks->header.payload_offset);

    cpu_to_be32s(&luks->header.key_bytes);

    cpu_to_be32s(&luks->header.master_key_iterations);



    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {

        cpu_to_be32s(&luks->header.key_slots[i].active);

        cpu_to_be32s(&luks->header.key_slots[i].iterations);

        cpu_to_be32s(&luks->header.key_slots[i].key_offset);

        cpu_to_be32s(&luks->header.key_slots[i].stripes);

    }





    /* Write out the partition header and key slot headers */

    writefunc(block, 0,

              (const uint8_t *)&luks->header,

              sizeof(luks->header),

              &local_err,

              opaque);



    /* Delay checking local_err until we've byte-swapped */



    /* Byte swap the header back to native, in case we need

     * to read it again later */

    be16_to_cpus(&luks->header.version);

    be32_to_cpus(&luks->header.payload_offset);

    be32_to_cpus(&luks->header.key_bytes);

    be32_to_cpus(&luks->header.master_key_iterations);



    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {

        be32_to_cpus(&luks->header.key_slots[i].active);

        be32_to_cpus(&luks->header.key_slots[i].iterations);

        be32_to_cpus(&luks->header.key_slots[i].key_offset);

        be32_to_cpus(&luks->header.key_slots[i].stripes);

    }



    if (local_err) {

        error_propagate(errp, local_err);

        goto error;

    }



    /* Write out the master key material, starting at the

     * sector immediately following the partition header. */

    if (writefunc(block,

                  luks->header.key_slots[0].key_offset *

                  QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,

                  splitkey, splitkeylen,

                  errp,

                  opaque) != splitkeylen) {

        goto error;

    }



    luks->cipher_alg = luks_opts.cipher_alg;

    luks->cipher_mode = luks_opts.cipher_mode;

    luks->ivgen_alg = luks_opts.ivgen_alg;

    luks->ivgen_hash_alg = luks_opts.ivgen_hash_alg;

    luks->hash_alg = luks_opts.hash_alg;



    memset(masterkey, 0, luks->header.key_bytes);

    g_free(masterkey);

    memset(slotkey, 0, luks->header.key_bytes);

    g_free(slotkey);

    g_free(splitkey);

    g_free(password);

    g_free(cipher_mode_spec);



    qcrypto_ivgen_free(ivgen);

    qcrypto_cipher_free(cipher);



    return 0;



 error:

    if (masterkey) {

        memset(masterkey, 0, luks->header.key_bytes);

    }

    g_free(masterkey);

    if (slotkey) {

        memset(slotkey, 0, luks->header.key_bytes);

    }

    g_free(slotkey);

    g_free(splitkey);

    g_free(password);

    g_free(cipher_mode_spec);



    qcrypto_ivgen_free(ivgen);

    qcrypto_cipher_free(cipher);



    g_free(luks);

    return -1;

}
",2650,,LABEL_0,LABEL_1,,-4,"luks,luks_opts,local_err,masterkey,slotkey,splitkey,i,cipher,ivgen,password,cipher_alg,cipher_mode,ivgen_alg,ivgen_hash_alg,hash_alg,cipher_mode_spec,iters",,,,0,,0,Greedy,1,0.0021672765413920086,,
179,"static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,

                                unsigned size)

{

    IMXTimerGState *s = (IMXTimerGState *)opaque;



    DPRINTF(""g-read(offset=%x)"", offset >> 2);

    switch (offset >> 2) {

    case 0: /* Control Register */

        DPRINTF("" cr = %x\n"", s->cr);

        return s->cr;



    case 1: /* prescaler */

        DPRINTF("" pr = %x\n"", s->pr);

        return s->pr;



    case 2: /* Status Register */

        DPRINTF("" sr = %x\n"", s->sr);

        return s->sr;



    case 3: /* Interrupt Register */

        DPRINTF("" ir = %x\n"", s->ir);

        return s->ir;



    case 4: /* Output Compare Register 1 */

        DPRINTF("" ocr1 = %x\n"", s->ocr1);

        return s->ocr1;





    case 9: /* cnt */

        imx_timerg_update_counts(s);

        DPRINTF("" cnt = %x\n"", s->cnt);

        return s->cnt;

    }



    IPRINTF(""imx_timerg_read: Bad offset %x\n"",

            (int)offset >> 2);

    return 0;

}
",250,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,offset,size,s",,4,22,0,,0,GA,875,0.3414411743481954,failed,[]
180,"int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)

{

    int count, x;

    uint8_t *out;



    out = outbuf;





        for(x = 0; x < w; x += count) {

            /* see if we can encode the next set of pixels with RLE */

            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {

                if(out + bpp + 1 > outbuf + out_size) return -1;

                *out++ = (count ^ xor) + add;

                memcpy(out, ptr, bpp);

                out += bpp;

            } else {

                /* fall back on uncompressed */

                count = count_pixels(ptr, w-x, bpp, 0);

                *out++ = count - 1;



                if(out + bpp*count > outbuf + out_size) return -1;

                memcpy(out, ptr, bpp * count);

                out += bpp * count;

        }



        ptr += count * bpp;

    }



    return out - outbuf;

}
",220,"int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t mult, uint8_t xOR)

{

    int count, x;

    uint8_t *out;



    out = outbuf;





        for(x = 0; x < w; x += count) {

            /* see if we can encode the next set of pixels with RLE */

            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {

                if(out + bpp + 1 > outbuf + out_size) return -1;

                *out++ = (count ^ xOR) + mult;

                memcpy(out, ptr, bpp);

                out += bpp;

            } else {

                /* fall back on uncompressed */

                count = count_pixels(ptr, w-x, bpp, 0);

                *out++ = count - 1;



                if(out + bpp*count > outbuf + out_size) return -1;

                memcpy(out, ptr, bpp * count);

                out += bpp * count;

        }



        ptr += count * bpp;

    }



    return out - outbuf;

}
",LABEL_0,LABEL_0,LABEL_1,1,"outbuf,out_size,ptr,bpp,w,add,xor,count,x,out","outbuf:-0.0001589059829711914,out_size:-0.00012576580047607422,ptr:-0.0006077289581298828,bpp:-0.0005534887313842773,w:-9.709596633911133e-05,add:-8.100271224975586e-05,xor:4.601478576660156e-05,count:-0.0006986856460571289,x:-0.00023251771926879883,out:-0.0010886788368225098,",2,4,0,"xor:xOR,add:mult,",0,Greedy,127,0.046411530176798506,replace,[]
181,"static int usb_bt_handle_data(USBDevice *dev, USBPacket *p)

{

    struct USBBtState *s = (struct USBBtState *) dev->opaque;

    int ret = 0;



    if (!s->config)

        goto fail;



    switch (p->pid) {

    case USB_TOKEN_IN:

        switch (p->devep & 0xf) {

        case USB_EVT_EP:

            ret = usb_bt_fifo_dequeue(&s->evt, p);

            break;



        case USB_ACL_EP:

            ret = usb_bt_fifo_dequeue(&s->acl, p);

            break;



        case USB_SCO_EP:

            ret = usb_bt_fifo_dequeue(&s->sco, p);

            break;



        default:

            goto fail;

        }

        break;



    case USB_TOKEN_OUT:

        switch (p->devep & 0xf) {

        case USB_ACL_EP:

            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,

                            usb_bt_hci_acl_complete, p->data, p->len);

            break;



        case USB_SCO_EP:

            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,

                            usb_bt_hci_sco_complete, p->data, p->len);

            break;



        default:

            goto fail;

        }

        break;



    default:

    fail:

        ret = USB_RET_STALL;

        break;

    }



    return ret;

}
",234,,LABEL_1,LABEL_0,,-4,"dev,p,s",,,,0,,0,Greedy,1,0.0005613923072814942,,
182,"void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)

{

    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);

    AVFilterPad *dst = link->dstpad;

    int i;



    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);



    if (!(filter_samples = dst->filter_samples))

        filter_samples = avfilter_default_filter_samples;



    /* prepare to copy the samples if the buffer has insufficient permissions */

    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||

        dst->rej_perms & samplesref->perms) {



        av_log(link->dst, AV_LOG_DEBUG,

               ""Copying audio data in avfilter (have perms %x, need %x, reject %x)\n"",

               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);



        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,

                                                          samplesref->audio->nb_samples);

        link->cur_buf->pts                = samplesref->pts;

        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;



        /* Copy actual data into new samples buffer */

        for (i = 0; samplesref->data[i]; i++)

            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);



        avfilter_unref_buffer(samplesref);

    } else

        link->cur_buf = samplesref;



    filter_samples(link, link->cur_buf);

}
",299,"void avfilter_filter_samples(AVFilterLink *cell, AVFilterBufferRef * sampleshard)

{

    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);

    AVFilterPad *Dnd = cell->dstpad;

    int index;



    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, cell, 1);



    if (!(filter_samples = Dnd->filter_samples))

        filter_samples = avfilter_default_filter_samples;



    /* prepare to copy the samples if the buffer has insufficient permissions */

    if ((Dnd->min_perms &  sampleshard->perms) != Dnd->min_perms ||

        Dnd->rej_perms &  sampleshard->perms) {



        av_log(cell->Dnd, AV_LOG_DEBUG,

               ""Copying audio data in avfilter (have perms %x, need %x, reject %x)
"",

                sampleshard->perms, cell->dstpad->min_perms, cell->dstpad->rej_perms);



        cell->cur_buf = avfilter_default_get_audio_buffer(cell, Dnd->min_perms,

                                                           sampleshard->audio->nb_samples);

        cell->cur_buf->pts                =  sampleshard->pts;

        cell->cur_buf->audio->sample_rate =  sampleshard->audio->sample_rate;



        /* Copy actual data into new samples buffer */

        for (index = 0;  sampleshard->data[index]; index++)

            memcpy(cell->cur_buf->data[index],  sampleshard->data[index],  sampleshard->linesize[0]);



        avfilter_unref_buffer( sampleshard);

    } else

        cell->cur_buf =  sampleshard;



    filter_samples(cell, cell->cur_buf);

}
",LABEL_0,LABEL_0,LABEL_1,1,"link,samplesref,filter_samples,dst,i","link:0.00047892332077026367,samplesref:0.0006694197654724121,filter_samples:-0.0001227259635925293,dst:0.00022917985916137695,i:0.0002541542053222656,",4,39,0,"samplesref: sampleshard,link:cell,i:index,dst:Dnd,",0,Greedy,428,0.16158987681070963,replace,[]
183,"static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,

                                void *opaque)

{

    VirtualConsole *vc = opaque;

    GtkDisplayState *s = vc->s;

    InputButton btn;



    /* implicitly grab the input at the first click in the relative mode */

    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&

        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {

        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),

                                       TRUE);

        return TRUE;

    }



    if (button->button == 1) {

        btn = INPUT_BUTTON_LEFT;

    } else if (button->button == 2) {

        btn = INPUT_BUTTON_MIDDLE;

    } else if (button->button == 3) {

        btn = INPUT_BUTTON_RIGHT;

    } else {

        return TRUE;

    }



    qemu_input_queue_btn(vc->gfx.dcl.con, btn,

                         button->type == GDK_BUTTON_PRESS);

    qemu_input_event_sync();

    return TRUE;

}
",184,,LABEL_0,LABEL_0,LABEL_0,-1,"widget,button,opaque,vc,s,btn",,5,23,0,,0,GA,1286,0.48007877270380656,failed,[]
184,"static inline void RENAME(yvu9_to_yuy2)(const uint8_t *src1, const uint8_t *src2, const uint8_t *src3,

                                        uint8_t *dst,

                                        long width, long height,

                                        long srcStride1, long srcStride2,

                                        long srcStride3, long dstStride)

{

    x86_reg x;

    long y,w,h;

    w=width/2; h=height;

    for (y=0;y<h;y++) {

        const uint8_t* yp=src1+srcStride1*y;

        const uint8_t* up=src2+srcStride2*(y>>2);

        const uint8_t* vp=src3+srcStride3*(y>>2);

        uint8_t* d=dst+dstStride*y;

        x=0;

#if COMPILE_TEMPLATE_MMX

        for (;x<w-7;x+=8) {

            __asm__ volatile(

                PREFETCH""   32(%1, %0)          \n\t""

                PREFETCH""   32(%2, %0)          \n\t""

                PREFETCH""   32(%3, %0)          \n\t""

                ""movq      (%1, %0, 4), %%mm0   \n\t"" /* Y0Y1Y2Y3Y4Y5Y6Y7 */

                ""movq         (%2, %0), %%mm1   \n\t"" /* U0U1U2U3U4U5U6U7 */

                ""movq         (%3, %0), %%mm2   \n\t"" /* V0V1V2V3V4V5V6V7 */

                ""movq            %%mm0, %%mm3   \n\t"" /* Y0Y1Y2Y3Y4Y5Y6Y7 */

                ""movq            %%mm1, %%mm4   \n\t"" /* U0U1U2U3U4U5U6U7 */

                ""movq            %%mm2, %%mm5   \n\t"" /* V0V1V2V3V4V5V6V7 */

                ""punpcklbw       %%mm1, %%mm1   \n\t"" /* U0U0 U1U1 U2U2 U3U3 */

                ""punpcklbw       %%mm2, %%mm2   \n\t"" /* V0V0 V1V1 V2V2 V3V3 */

                ""punpckhbw       %%mm4, %%mm4   \n\t"" /* U4U4 U5U5 U6U6 U7U7 */

                ""punpckhbw       %%mm5, %%mm5   \n\t"" /* V4V4 V5V5 V6V6 V7V7 */



                ""movq            %%mm1, %%mm6   \n\t""

                ""punpcklbw       %%mm2, %%mm1   \n\t"" /* U0V0 U0V0 U1V1 U1V1*/

                ""punpcklbw       %%mm1, %%mm0   \n\t"" /* Y0U0 Y1V0 Y2U0 Y3V0*/

                ""punpckhbw       %%mm1, %%mm3   \n\t"" /* Y4U1 Y5V1 Y6U1 Y7V1*/

                MOVNTQ""          %%mm0,  (%4, %0, 8)    \n\t""

                MOVNTQ""          %%mm3, 8(%4, %0, 8)    \n\t""



                ""punpckhbw       %%mm2, %%mm6   \n\t"" /* U2V2 U2V2 U3V3 U3V3*/

                ""movq     8(%1, %0, 4), %%mm0   \n\t""

                ""movq            %%mm0, %%mm3   \n\t""

                ""punpcklbw       %%mm6, %%mm0   \n\t"" /* Y U2 Y V2 Y U2 Y V2*/

                ""punpckhbw       %%mm6, %%mm3   \n\t"" /* Y U3 Y V3 Y U3 Y V3*/

                MOVNTQ""          %%mm0, 16(%4, %0, 8)   \n\t""

                MOVNTQ""          %%mm3, 24(%4, %0, 8)   \n\t""



                ""movq            %%mm4, %%mm6   \n\t""

                ""movq    16(%1, %0, 4), %%mm0   \n\t""

                ""movq            %%mm0, %%mm3   \n\t""

                ""punpcklbw       %%mm5, %%mm4   \n\t""

                ""punpcklbw       %%mm4, %%mm0   \n\t"" /* Y U4 Y V4 Y U4 Y V4*/

                ""punpckhbw       %%mm4, %%mm3   \n\t"" /* Y U5 Y V5 Y U5 Y V5*/

                MOVNTQ""          %%mm0, 32(%4, %0, 8)   \n\t""

                MOVNTQ""          %%mm3, 40(%4, %0, 8)   \n\t""



                ""punpckhbw       %%mm5, %%mm6   \n\t""

                ""movq    24(%1, %0, 4), %%mm0   \n\t""

                ""movq            %%mm0, %%mm3   \n\t""

                ""punpcklbw       %%mm6, %%mm0   \n\t"" /* Y U6 Y V6 Y U6 Y V6*/

                ""punpckhbw       %%mm6, %%mm3   \n\t"" /* Y U7 Y V7 Y U7 Y V7*/

                MOVNTQ""          %%mm0, 48(%4, %0, 8)   \n\t""

                MOVNTQ""          %%mm3, 56(%4, %0, 8)   \n\t""



                : ""+r"" (x)

                : ""r""(yp), ""r"" (up), ""r""(vp), ""r""(d)

                :""memory"");

        }

#endif

        for (; x<w; x++) {

            const long x2 = x<<2;

            d[8*x+0] = yp[x2];

            d[8*x+1] = up[x];

            d[8*x+2] = yp[x2+1];

            d[8*x+3] = vp[x];

            d[8*x+4] = yp[x2+2];

            d[8*x+5] = up[x];

            d[8*x+6] = yp[x2+3];

            d[8*x+7] = vp[x];

        }

    }

#if COMPILE_TEMPLATE_MMX

    __asm__(

            EMMS""       \n\t""

            SFENCE""     \n\t""

            ::: ""memory""

        );

#endif

}
",1036,,LABEL_0,LABEL_0,LABEL_0,-1,"src1,src2,src3,dst,height,srcStride1,srcStride2,srcStride3,dstStride,x,y,w,h,yp,up,vp,d",,17,77,0,,0,GA,3264,1.8030003587404886,failed,[]
185,"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque, int type)

{

    struct qemu_paiocb *acb;



    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);

    if (!acb)

        return NULL;

    acb->aio_type = type;

    acb->aio_fildes = fd;

    acb->ev_signo = SIGUSR2;

    acb->async_context_id = get_async_context_id();



    if (qiov) {

        acb->aio_iov = qiov->iov;

        acb->aio_niov = qiov->niov;

    }

    acb->aio_nbytes = nb_sectors * 512;

    acb->aio_offset = sector_num * 512;



    acb->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = acb;



    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);

    qemu_paio_submit(acb);

    return &acb->common;

}
",177,"BlockDriverAIOCB *paio_submit(BlockDriverState *ob, int lambda,

        int64_t ector_name, QEMUIOVector *quiov, int nb_secs,

        BlockDriverCompletionFunc *rb, void *pac, int ocol)

{

    struct qemu_paiocb *accb;



    accb = qemu_aio_get(&raw_aio_pool, ob, rb, pac);

    if (!arb)

        return NULL;

    accb->aio_type = ocol;

    accb->aio_fildes = lambda;

    accb->ev_signo = SIGUSR2;

    accb->async_context_id = get_async_context_id();



    if (quiov) {

        accb->aio_iov = quiov->iov;

        accb->aio_niov = quiov->niov;

    }

    accb->aio_nbytes = nb_secs * 512;

    accb->aio_offset = ector_name * 512;



    accb->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = accb;



    trace_paio_submit(accb, pac, ector_name, nb_secs, ocol);

    qemu_paio_submit(accb);

    return &accb->common;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bs,fd,sector_num,qiov,nb_sectors,cb,opaque,type,acb","bs:-0.00019186735153198242,fd:-0.00015616416931152344,sector_num:-0.0003484487533569336,qiov:-0.00048613548278808594,nb_sectors:-0.00027054548263549805,cb:-0.0003039240837097168,opaque:-0.00032001733779907227,type:-0.00036197900772094727,acb:-0.0014905333518981934,",9,38,0,"fd:lambda,bs:ob,nb_sectors:nb_secs,cb:rb,opaque:pac,sector_num:ector_name,type:ocol,qiov:quiov,acb:accb,",0,Greedy,464,0.17009826103846232,replace,[]
186,"static void diff_pixels_altivec(int16_t *restrict block, const uint8_t *s1,

                                const uint8_t *s2, int stride)

{

    int i;

    vec_u8 perm1 = vec_lvsl(0, s1);

    vec_u8 perm2 = vec_lvsl(0, s2);

    const vec_u8 zero = (const vec_u8)vec_splat_u8(0);

    vec_s16 shorts1, shorts2;



    for (i = 0; i < 4; i++) {

        /* Read potentially unaligned pixels.

         * We're reading 16 pixels, and actually only want 8,

         * but we simply ignore the extras. */

        vec_u8 pixl  = vec_ld(0,  s1);

        vec_u8 pixr  = vec_ld(15, s1);

        vec_u8 bytes = vec_perm(pixl, pixr, perm1);



        // Convert the bytes into shorts.

        shorts1 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the same for the second block of pixels.

        pixl  = vec_ld(0,  s2);

        pixr  = vec_ld(15, s2);

        bytes = vec_perm(pixl, pixr, perm2);



        // Convert the bytes into shorts.

        shorts2 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the subtraction.

        shorts1 = vec_sub(shorts1, shorts2);



        // Save the data to the block, we assume the block is 16-byte aligned.

        vec_st(shorts1, 0, (vec_s16 *)block);



        s1    += stride;

        s2    += stride;

        block += 8;



        /* The code below is a copy of the code above...

         * This is a manual unroll. */



        /* Read potentially unaligned pixels.

         * We're reading 16 pixels, and actually only want 8,

         * but we simply ignore the extras. */

        pixl  = vec_ld(0,  s1);

        pixr  = vec_ld(15, s1);

        bytes = vec_perm(pixl, pixr, perm1);



        // Convert the bytes into shorts.

        shorts1 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the same for the second block of pixels.

        pixl  = vec_ld(0,  s2);

        pixr  = vec_ld(15, s2);

        bytes = vec_perm(pixl, pixr, perm2);



        // Convert the bytes into shorts.

        shorts2 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the subtraction.

        shorts1 = vec_sub(shorts1, shorts2);



        // Save the data to the block, we assume the block is 16-byte aligned.

        vec_st(shorts1, 0, (vec_s16 *)block);



        s1    += stride;

        s2    += stride;

        block += 8;

    }

}
",496,,LABEL_1,LABEL_0,,-4,"block,s1,s2,stride,i,shorts1,shorts2",,,,0,,0,Greedy,1,0.00073318878809611,,
187,"static int decode_header(MPADecodeContext *s, UINT32 header)

{

    int sample_rate, frame_size, mpeg25, padding;

    int sample_rate_index, bitrate_index;

    if (header & (1<<20)) {

        s->lsf = (header & (1<<19)) ? 0 : 1;

        mpeg25 = 0;

    } else {

        s->lsf = 1;

        mpeg25 = 1;

    }

    

    s->layer = 4 - ((header >> 17) & 3);

    /* extract frequency */

    sample_rate_index = (header >> 10) & 3;

    sample_rate = mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25);

    if (sample_rate == 0)

        return 1;

    sample_rate_index += 3 * (s->lsf + mpeg25);

    s->sample_rate_index = sample_rate_index;

    s->error_protection = ((header >> 16) & 1) ^ 1;



    bitrate_index = (header >> 12) & 0xf;

    padding = (header >> 9) & 1;

    //extension = (header >> 8) & 1;

    s->mode = (header >> 6) & 3;

    s->mode_ext = (header >> 4) & 3;

    //copyright = (header >> 3) & 1;

    //original = (header >> 2) & 1;

    //emphasis = header & 3;



    if (s->mode == MPA_MONO)

        s->nb_channels = 1;

    else

        s->nb_channels = 2;

    

    if (bitrate_index != 0) {

        frame_size = mpa_bitrate_tab[s->lsf][s->layer - 1][bitrate_index];

        s->bit_rate = frame_size * 1000;

        switch(s->layer) {

        case 1:

            frame_size = (frame_size * 12000) / sample_rate;

            frame_size = (frame_size + padding) * 4;

            break;

        case 2:

            frame_size = (frame_size * 144000) / sample_rate;

            frame_size += padding;

            break;

        default:

        case 3:

            frame_size = (frame_size * 144000) / (sample_rate << s->lsf);

            frame_size += padding;

            break;

        }

        s->frame_size = frame_size;

    } else {

        /* if no frame size computed, signal it */

        if (!s->free_format_frame_size)

            return 1;

        /* free format: compute bitrate and real frame size from the

           frame size we extracted by reading the bitstream */

        s->frame_size = s->free_format_frame_size;

        switch(s->layer) {

        case 1:

            s->frame_size += padding  * 4;

            s->bit_rate = (s->frame_size * sample_rate) / 48000;

            break;

        case 2:

            s->frame_size += padding;

            s->bit_rate = (s->frame_size * sample_rate) / 144000;

            break;

        default:

        case 3:

            s->frame_size += padding;

            s->bit_rate = (s->frame_size * (sample_rate << s->lsf)) / 144000;

            break;

        }

    }

    s->sample_rate = sample_rate;

    

#if defined(DEBUG)

    printf(""layer%d, %d Hz, %d kbits/s, "",

           s->layer, s->sample_rate, s->bit_rate);

    if (s->nb_channels == 2) {

        if (s->layer == 3) {

            if (s->mode_ext & MODE_EXT_MS_STEREO)

                printf(""ms-"");

            if (s->mode_ext & MODE_EXT_I_STEREO)

                printf(""i-"");

        }

        printf(""stereo"");

    } else {

        printf(""mono"");

    }

    printf(""\n"");

#endif

    return 0;

}
",663,,LABEL_1,LABEL_0,,-4,"s,header,sample_rate,frame_size,mpeg25,padding,sample_rate_index,bitrate_index",,,,0,,0,Greedy,1,0.0007931033770243327,,
188,"static void cchip_write(void *opaque, hwaddr addr,

                        uint64_t val, unsigned size)

{

    TyphoonState *s = opaque;

    uint64_t oldval, newval;



    switch (addr) {

    case 0x0000:

        /* CSC: Cchip System Configuration Register.  */

        /* All sorts of data here; nothing relevant RW.  */

        break;



    case 0x0040:

        /* MTR: Memory Timing Register.  */

        /* All sorts of stuff related to real DRAM.  */

        break;



    case 0x0080:

        /* MISC: Miscellaneous Register.  */

        newval = oldval = s->cchip.misc;

        newval &= ~(val & 0x10000ff0);     /* W1C fields */

        if (val & 0x100000) {

            newval &= ~0xff0000ull;        /* ACL clears ABT and ABW */

        } else {

            newval |= val & 0x00f00000;    /* ABT field is W1S */

            if ((newval & 0xf0000) == 0) {

                newval |= val & 0xf0000;   /* ABW field is W1S iff zero */

            }

        }

        newval |= (val & 0xf000) >> 4;     /* IPREQ field sets IPINTR.  */



        newval &= ~0xf0000000000ull;       /* WO and RW fields */

        newval |= val & 0xf0000000000ull;

        s->cchip.misc = newval;



        /* Pass on changes to IPI and ITI state.  */

        if ((newval ^ oldval) & 0xff0) {

            int i;

            for (i = 0; i < 4; ++i) {

                AlphaCPU *cpu = s->cchip.cpu[i];

                if (cpu != NULL) {

                    CPUState *cs = CPU(cpu);

                    /* IPI can be either cleared or set by the write.  */

                    if (newval & (1 << (i + 8))) {

                        cpu_interrupt(cs, CPU_INTERRUPT_SMP);

                    } else {

                        cpu_reset_interrupt(cs, CPU_INTERRUPT_SMP);

                    }



                    /* ITI can only be cleared by the write.  */

                    if ((newval & (1 << (i + 4))) == 0) {

                        cpu_reset_interrupt(cs, CPU_INTERRUPT_TIMER);

                    }

                }

            }

        }

        break;



    case 0x00c0:

        /* MPD: Memory Presence Detect Register.  */

        break;



    case 0x0100: /* AAR0 */

    case 0x0140: /* AAR1 */

    case 0x0180: /* AAR2 */

    case 0x01c0: /* AAR3 */

        /* AAR: Array Address Register.  */

        /* All sorts of information about DRAM.  */

        break;



    case 0x0200: /* DIM0 */

        /* DIM: Device Interrupt Mask Register, CPU0.  */

        s->cchip.dim[0] = val;

        cpu_irq_change(s->cchip.cpu[0], val & s->cchip.drir);

        break;

    case 0x0240: /* DIM1 */

        /* DIM: Device Interrupt Mask Register, CPU1.  */

        s->cchip.dim[0] = val;

        cpu_irq_change(s->cchip.cpu[1], val & s->cchip.drir);

        break;



    case 0x0280: /* DIR0 (RO) */

    case 0x02c0: /* DIR1 (RO) */

    case 0x0300: /* DRIR (RO) */

        break;



    case 0x0340:

        /* PRBEN: Probe Enable Register.  */

        break;



    case 0x0380: /* IIC0 */

        s->cchip.iic[0] = val & 0xffffff;

        break;

    case 0x03c0: /* IIC1 */

        s->cchip.iic[1] = val & 0xffffff;

        break;



    case 0x0400: /* MPR0 */

    case 0x0440: /* MPR1 */

    case 0x0480: /* MPR2 */

    case 0x04c0: /* MPR3 */

        /* MPR: Memory Programming Register.  */

        break;



    case 0x0580:

        /* TTR: TIGbus Timing Register.  */

        /* All sorts of stuff related to interrupt delivery timings.  */

        break;

    case 0x05c0:

        /* TDR: TIGbug Device Timing Register.  */

        break;



    case 0x0600:

        /* DIM2: Device Interrupt Mask Register, CPU2.  */

        s->cchip.dim[2] = val;

        cpu_irq_change(s->cchip.cpu[2], val & s->cchip.drir);

        break;

    case 0x0640:

        /* DIM3: Device Interrupt Mask Register, CPU3.  */

        s->cchip.dim[3] = val;

        cpu_irq_change(s->cchip.cpu[3], val & s->cchip.drir);

        break;



    case 0x0680: /* DIR2 (RO) */

    case 0x06c0: /* DIR3 (RO) */

        break;



    case 0x0700: /* IIC2 */

        s->cchip.iic[2] = val & 0xffffff;

        break;

    case 0x0740: /* IIC3 */

        s->cchip.iic[3] = val & 0xffffff;

        break;



    case 0x0780:

        /* PWR: Power Management Control.   */

        break;

    

    case 0x0c00: /* CMONCTLA */

    case 0x0c40: /* CMONCTLB */

    case 0x0c80: /* CMONCNT01 */

    case 0x0cc0: /* CMONCNT23 */

        break;



    default:

        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);

        return;

    }

}
",1018,"static void cchip_write(void *opaque, hwaddr addr,

                        uint64_t ival, unsigned size)

{

    TyphoonState *s = opaque;

    uint64_t oldval, newval;



    switch (addr) {

    case 0x0000:

        /* CSC: Cchip System Configuration Register.  */

        /* All sorts of data here; nothing relevant RW.  */

        break;



    case 0x0040:

        /* MTR: Memory Timing Register.  */

        /* All sorts of stuff related to real DRAM.  */

        break;



    case 0x0080:

        /* MISC: Miscellaneous Register.  */

        newval = oldval = s->cchip.misc;

        newval &= ~(ival & 0x10000ff0);     /* W1C fields */

        if (ival & 0x100000) {

            newval &= ~0xff0000ull;        /* ACL clears ABT and ABW */

        } else {

            newval |= ival & 0x00f00000;    /* ABT field is W1S */

            if ((newval & 0xf0000) == 0) {

                newval |= ival & 0xf0000;   /* ABW field is W1S iff zero */

            }

        }

        newval |= (ival & 0xf000) >> 4;     /* IPREQ field sets IPINTR.  */



        newval &= ~0xf0000000000ull;       /* WO and RW fields */

        newval |= ival & 0xf0000000000ull;

        s->cchip.misc = newval;



        /* Pass on changes to IPI and ITI state.  */

        if ((newval ^ oldval) & 0xff0) {

            int i;

            for (i = 0; i < 4; ++i) {

                AlphaCPU *cpu = s->cchip.cpu[i];

                if (cpu != NULL) {

                    CPUState *cs = CPU(cpu);

                    /* IPI can be either cleared or set by the write.  */

                    if (newval & (1 << (i + 8))) {

                        cpu_interrupt(cs, CPU_INTERRUPT_SMP);

                    } else {

                        cpu_reset_interrupt(cs, CPU_INTERRUPT_SMP);

                    }



                    /* ITI can only be cleared by the write.  */

                    if ((newval & (1 << (i + 4))) == 0) {

                        cpu_reset_interrupt(cs, CPU_INTERRUPT_TIMER);

                    }

                }

            }

        }

        break;



    case 0x00c0:

        /* MPD: Memory Presence Detect Register.  */

        break;



    case 0x0100: /* AAR0 */

    case 0x0140: /* AAR1 */

    case 0x0180: /* AAR2 */

    case 0x01c0: /* AAR3 */

        /* AAR: Array Address Register.  */

        /* All sorts of information about DRAM.  */

        break;



    case 0x0200: /* DIM0 */

        /* DIM: Device Interrupt Mask Register, CPU0.  */

        s->cchip.dim[0] = ival;

        cpu_irq_change(s->cchip.cpu[0], ival & s->cchip.drir);

        break;

    case 0x0240: /* DIM1 */

        /* DIM: Device Interrupt Mask Register, CPU1.  */

        s->cchip.dim[0] = ival;

        cpu_irq_change(s->cchip.cpu[1], ival & s->cchip.drir);

        break;



    case 0x0280: /* DIR0 (RO) */

    case 0x02c0: /* DIR1 (RO) */

    case 0x0300: /* DRIR (RO) */

        break;



    case 0x0340:

        /* PRBEN: Probe Enable Register.  */

        break;



    case 0x0380: /* IIC0 */

        s->cchip.iic[0] = ival & 0xffffff;

        break;

    case 0x03c0: /* IIC1 */

        s->cchip.iic[1] = ival & 0xffffff;

        break;



    case 0x0400: /* MPR0 */

    case 0x0440: /* MPR1 */

    case 0x0480: /* MPR2 */

    case 0x04c0: /* MPR3 */

        /* MPR: Memory Programming Register.  */

        break;



    case 0x0580:

        /* TTR: TIGbus Timing Register.  */

        /* All sorts of stuff related to interrupt delivery timings.  */

        break;

    case 0x05c0:

        /* TDR: TIGbug Device Timing Register.  */

        break;



    case 0x0600:

        /* DIM2: Device Interrupt Mask Register, CPU2.  */

        s->cchip.dim[2] = ival;

        cpu_irq_change(s->cchip.cpu[2], ival & s->cchip.drir);

        break;

    case 0x0640:

        /* DIM3: Device Interrupt Mask Register, CPU3.  */

        s->cchip.dim[3] = ival;

        cpu_irq_change(s->cchip.cpu[3], ival & s->cchip.drir);

        break;



    case 0x0680: /* DIR2 (RO) */

    case 0x06c0: /* DIR3 (RO) */

        break;



    case 0x0700: /* IIC2 */

        s->cchip.iic[2] = ival & 0xffffff;

        break;

    case 0x0740: /* IIC3 */

        s->cchip.iic[3] = ival & 0xffffff;

        break;



    case 0x0780:

        /* PWR: Power Management Control.   */

        break;

    

    case 0x0c00: /* CMONCTLA */

    case 0x0c40: /* CMONCTLB */

    case 0x0c80: /* CMONCNT01 */

    case 0x0cc0: /* CMONCNT23 */

        break;



    default:

        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);

        return;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"opaque,addr,val,size,s,oldval,newval,i,cpu,cs","opaque:0.2162151336669922,addr:0.20552438497543335,val:1.4146484732627869,size:0.1176677942276001,s:1.3546575903892517,oldval:0.05044889450073242,newval:0.2404625415802002,i:0.7808842658996582,cpu:0.6676703691482544,cs:0.4310237765312195,",1,19,0,"val:ival,",0,Greedy,148,0.06260402599970499,replace,[]
189,"static int64_t nfs_client_open(NFSClient *client, const char *filename,

                               int flags, Error **errp)

{

    int ret = -EINVAL, i;

    struct stat st;

    URI *uri;

    QueryParams *qp = NULL;

    char *file = NULL, *strp = NULL;



    uri = uri_parse(filename);

    if (!uri) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    if (!uri->server) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    strp = strrchr(uri->path, '/');

    if (strp == NULL) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    file = g_strdup(strp);

    *strp = 0;



    client->context = nfs_init_context();

    if (client->context == NULL) {

        error_setg(errp, ""Failed to init NFS context"");

        goto fail;

    }



    qp = query_params_parse(uri->query);

    for (i = 0; i < qp->n; i++) {

        if (!qp->p[i].value) {

            error_setg(errp, ""Value for NFS parameter expected: %s"",

                       qp->p[i].name);

            goto fail;

        }

        if (!strncmp(qp->p[i].name, ""uid"", 3)) {

            nfs_set_uid(client->context, atoi(qp->p[i].value));

        } else if (!strncmp(qp->p[i].name, ""gid"", 3)) {

            nfs_set_gid(client->context, atoi(qp->p[i].value));

        } else if (!strncmp(qp->p[i].name, ""tcp-syncnt"", 10)) {

            nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value));

        } else {

            error_setg(errp, ""Unknown NFS parameter name: %s"",

                       qp->p[i].name);

            goto fail;

        }

    }



    ret = nfs_mount(client->context, uri->server, uri->path);

    if (ret < 0) {

        error_setg(errp, ""Failed to mount nfs share: %s"",

                   nfs_get_error(client->context));

        goto fail;

    }



    if (flags & O_CREAT) {

        ret = nfs_creat(client->context, file, 0600, &client->fh);

        if (ret < 0) {

            error_setg(errp, ""Failed to create file: %s"",

                       nfs_get_error(client->context));

            goto fail;

        }

    } else {

        ret = nfs_open(client->context, file, flags, &client->fh);

        if (ret < 0) {

            error_setg(errp, ""Failed to open file : %s"",

                       nfs_get_error(client->context));

            goto fail;

        }

    }



    ret = nfs_fstat(client->context, client->fh, &st);

    if (ret < 0) {

        error_setg(errp, ""Failed to fstat file: %s"",

                   nfs_get_error(client->context));

        goto fail;

    }



    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);

    client->has_zero_init = S_ISREG(st.st_mode);

    goto out;

fail:

    nfs_client_close(client);

out:

    if (qp) {

        query_params_free(qp);

    }

    uri_free(uri);

    g_free(file);

    return ret;

}
",642,,LABEL_1,LABEL_0,,-4,"client,filename,flags,errp,i,st,uri,qp,file,strp",,,,0,,0,Greedy,1,0.0007919430732727051,,
190,"static int synchronize_audio(VideoState *is, short *samples,

                             int samples_size1, double pts)

{

    int n, samples_size;

    double ref_clock;



    n = 2 * is->audio_st->codec->channels;

    samples_size = samples_size1;



    /* if not master, then we try to remove or add samples to correct the clock */

    if (((is->av_sync_type == AV_SYNC_VIDEO_MASTER && is->video_st) ||

         is->av_sync_type == AV_SYNC_EXTERNAL_CLOCK)) {

        double diff, avg_diff;

        int wanted_size, min_size, max_size, nb_samples;



        ref_clock = get_master_clock(is);

        diff = get_audio_clock(is) - ref_clock;



        if (diff < AV_NOSYNC_THRESHOLD) {

            is->audio_diff_cum = diff + is->audio_diff_avg_coef * is->audio_diff_cum;

            if (is->audio_diff_avg_count < AUDIO_DIFF_AVG_NB) {

                /* not enough measures to have a correct estimate */

                is->audio_diff_avg_count++;

            } else {

                /* estimate the A-V difference */

                avg_diff = is->audio_diff_cum * (1.0 - is->audio_diff_avg_coef);



                if (fabs(avg_diff) >= is->audio_diff_threshold) {

                    wanted_size = samples_size + ((int)(diff * is->audio_st->codec->sample_rate) * n);

                    nb_samples = samples_size / n;



                    min_size = ((nb_samples * (100 - SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;

                    max_size = ((nb_samples * (100 + SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;

                    if (wanted_size < min_size)

                        wanted_size = min_size;

                    else if (wanted_size > max_size)

                        wanted_size = max_size;



                    /* add or remove samples to correction the synchro */

                    if (wanted_size < samples_size) {

                        /* remove samples */

                        samples_size = wanted_size;

                    } else if (wanted_size > samples_size) {

                        uint8_t *samples_end, *q;

                        int nb;



                        /* add samples */

                        nb = (samples_size - wanted_size);

                        samples_end = (uint8_t *)samples + samples_size - n;

                        q = samples_end + n;

                        while (nb > 0) {

                            memcpy(q, samples_end, n);

                            q += n;

                            nb -= n;

                        }

                        samples_size = wanted_size;

                    }

                }

                av_dlog(NULL, ""diff=%f adiff=%f sample_diff=%d apts=%0.3f vpts=%0.3f %f\n"",

                        diff, avg_diff, samples_size - samples_size1,

                        is->audio_clock, is->video_clock, is->audio_diff_threshold);

            }

        } else {

            /* too big difference : may be initial PTS errors, so

               reset A-V filter */

            is->audio_diff_avg_count = 0;

            is->audio_diff_cum       = 0;

        }

    }



    return samples_size;

}
",522,"static int synchronize_audio(VideoState *mis, short *samples,

                             int samples_size1, double pts)

{

    int n, samples_size;

    double ref_clock;



    n = 2 * mis->audio_st->codec->channels;

    samples_size = samples_size1;



    /* if not master, then we try to remove or add samples to correct the clock */

    if (((mis->av_sync_type == AV_SYNC_VIDEO_MASTER && mis->video_st) ||

         mis->av_sync_type == AV_SYNC_EXTERNAL_CLOCK)) {

        double diff, avg_diff;

        int wanted_size, min_size, max_size, nb_samples;



        ref_clock = get_master_clock(mis);

        diff = get_audio_clock(mis) - ref_clock;



        if (diff < AV_NOSYNC_THRESHOLD) {

            mis->audio_diff_cum = diff + mis->audio_diff_avg_coef * mis->audio_diff_cum;

            if (mis->audio_diff_avg_count < AUDIO_DIFF_AVG_NB) {

                /* not enough measures to have a correct estimate */

                mis->audio_diff_avg_count++;

            } else {

                /* estimate the A-V difference */

                avg_diff = mis->audio_diff_cum * (1.0 - mis->audio_diff_avg_coef);



                if (fabs(avg_diff) >= mis->audio_diff_threshold) {

                    wanted_size = samples_size + ((int)(diff * mis->audio_st->codec->sample_rate) * n);

                    nb_samples = samples_size / n;



                    min_size = ((nb_samples * (100 - SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;

                    max_size = ((nb_samples * (100 + SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;

                    if (wanted_size < min_size)

                        wanted_size = min_size;

                    else if (wanted_size > max_size)

                        wanted_size = max_size;



                    /* add or remove samples to correction the synchro */

                    if (wanted_size < samples_size) {

                        /* remove samples */

                        samples_size = wanted_size;

                    } else if (wanted_size > samples_size) {

                        uint8_t *samples_end, *q;

                        int nb;



                        /* add samples */

                        nb = (samples_size - wanted_size);

                        samples_end = (uint8_t *)samples + samples_size - n;

                        q = samples_end + n;

                        while (nb > 0) {

                            memcpy(q, samples_end, n);

                            q += n;

                            nb -= n;

                        }

                        samples_size = wanted_size;

                    }

                }

                av_dlog(NULL, ""diff=%f adiff=%f sample_diff=%d apts=%0.3f vpts=%0.3f %f
"",

                        diff, avg_diff, samples_size - samples_size1,

                        mis->audio_clock, mis->video_clock, mis->audio_diff_threshold);

            }

        } else {

            /* too big difference : may be initial PTS errors, so

               reset A-V filter */

            mis->audio_diff_avg_count = 0;

            mis->audio_diff_cum       = 0;

        }

    }



    return samples_size;

}
",LABEL_0,LABEL_0,LABEL_1,1,"is,samples,samples_size1,pts,n,samples_size,ref_clock,diff,avg_diff,wanted_size,min_size,max_size,nb_samples,audio_diff_avg_count","is:0.0020515918731689453,samples:0.0004495382308959961,samples_size1:-0.0013262629508972168,pts:9.655952453613281e-05,n:0.000461578369140625,samples_size:-0.00245743989944458,ref_clock:-0.0008661150932312012,diff:0.0005230307579040527,avg_diff:1.8358230590820312e-05,wanted_size:-0.00015294551849365234,min_size:-6.270408630371094e-05,max_size:-2.3663043975830078e-05,nb_samples:0.001963019371032715,audio_diff_avg_count:0.0002848505973815918,",1,21,0,"is:mis,",0,Greedy,174,0.06823962132136027,replace,[]
191,"static int nvenc_find_free_reg_resource(AVCodecContext *avctx)

{

    NvencContext *ctx = avctx->priv_data;

    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;

    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;



    int i;



    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {

        for (i = 0; i < ctx->nb_registered_frames; i++) {

            if (!ctx->registered_frames[i].mapped) {

                if (ctx->registered_frames[i].regptr) {

                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,

                                                ctx->registered_frames[i].regptr);

                    ctx->registered_frames[i].regptr = NULL;

                }

                return i;

            }

        }

    } else {

        return ctx->nb_registered_frames++;

    }



    av_log(avctx, AV_LOG_ERROR, ""Too many registered CUDA frames\n"");

    return AVERROR(ENOMEM);

}
",175,,LABEL_0,LABEL_0,LABEL_0,-1,"avctx,ctx,dl_fn,p_nvenc,i,nb_registered_frames",,6,29,0,,0,GA,1295,0.4844577550888062,failed,[]
192,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",218,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buffer)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buffer[0] & ~1) | !((buffer[4] >> 3) & 1)) << 24;

        rgb |= ((buffer[1] & ~1) | !((buffer[4] >> 2) & 1)) << 16;

        rgb |= ((buffer[2] & ~1) | !((buffer[4] >> 1) & 1)) <<  8;

        rgb |= ((buffer[3] & ~1) | !((buffer[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buffer[0] & ~1) | !((buffer[2] >> 1) & 1)) << 8;

        rgb |= ((buffer[1] & ~1) | !((buffer[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bpp,buf","bpp:2.0265579223632812e-05,buf:0.00012159347534179688,",1,13,0,"buf:buffer,",0,Greedy,86,0.03109742005666097,replace,[]
193,"int ff_rtsp_make_setup_request(AVFormatContext *s, const char *host, int port,

                              int lower_transport, const char *real_challenge)

{

    RTSPState *rt = s->priv_data;

    int rtx = 0, j, i, err, interleave = 0, port_off;

    RTSPStream *rtsp_st;

    RTSPMessageHeader reply1, *reply = &reply1;

    char cmd[2048];

    const char *trans_pref;



    if (rt->transport == RTSP_TRANSPORT_RDT)

        trans_pref = ""x-pn-tng"";

    else

        trans_pref = ""RTP/AVP"";



    /* default timeout: 1 minute */

    rt->timeout = 60;



    /* for each stream, make the setup request */

    /* XXX: we assume the same server is used for the control of each

     * RTSP stream */



    /* Choose a random starting offset within the first half of the

     * port range, to allow for a number of ports to try even if the offset

     * happens to be at the end of the random range. */

    port_off = av_get_random_seed() % ((rt->rtp_port_max - rt->rtp_port_min)/2);

    /* even random offset */

    port_off -= port_off & 0x01;



    for (j = rt->rtp_port_min + port_off, i = 0; i < rt->nb_rtsp_streams; ++i) {

        char transport[2048];



        /*

         * WMS serves all UDP data over a single connection, the RTX, which

         * isn't necessarily the first in the SDP but has to be the first

         * to be set up, else the second/third SETUP will fail with a 461.

         */

        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP &&

             rt->server_type == RTSP_SERVER_WMS) {

            if (i == 0) {

                /* rtx first */

                for (rtx = 0; rtx < rt->nb_rtsp_streams; rtx++) {

                    int len = strlen(rt->rtsp_streams[rtx]->control_url);

                    if (len >= 4 &&

                        !strcmp(rt->rtsp_streams[rtx]->control_url + len - 4,

                                ""/rtx""))

                        break;

                }

                if (rtx == rt->nb_rtsp_streams)

                    return -1; /* no RTX found */

                rtsp_st = rt->rtsp_streams[rtx];

            } else

                rtsp_st = rt->rtsp_streams[i > rtx ? i : i - 1];

        } else

            rtsp_st = rt->rtsp_streams[i];



        /* RTP/UDP */

        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP) {

            char buf[256];



            if (rt->server_type == RTSP_SERVER_WMS && i > 1) {

                port = reply->transports[0].client_port_min;

                goto have_port;

            }



            /* first try in specified port range */

            while (j <= rt->rtp_port_max) {

                ff_url_join(buf, sizeof(buf), ""rtp"", NULL, host, -1,

                            ""?localport=%d"", j);

                /* we will use two ports per rtp stream (rtp and rtcp) */

                j += 2;

                if (!ffurl_open(&rtsp_st->rtp_handle, buf, AVIO_FLAG_READ_WRITE,

                               &s->interrupt_callback, NULL))

                    goto rtp_opened;

            }



            av_log(s, AV_LOG_ERROR, ""Unable to open an input RTP port\n"");

            err = AVERROR(EIO);

            goto fail;



        rtp_opened:

            port = ff_rtp_get_local_rtp_port(rtsp_st->rtp_handle);

        have_port:

            snprintf(transport, sizeof(transport) - 1,

                     ""%s/UDP;"", trans_pref);

            if (rt->server_type != RTSP_SERVER_REAL)

                av_strlcat(transport, ""unicast;"", sizeof(transport));

            av_strlcatf(transport, sizeof(transport),

                     ""client_port=%d"", port);

            if (rt->transport == RTSP_TRANSPORT_RTP &&

                !(rt->server_type == RTSP_SERVER_WMS && i > 0))

                av_strlcatf(transport, sizeof(transport), ""-%d"", port + 1);

        }



        /* RTP/TCP */

        else if (lower_transport == RTSP_LOWER_TRANSPORT_TCP) {

            /* For WMS streams, the application streams are only used for

             * UDP. When trying to set it up for TCP streams, the server

             * will return an error. Therefore, we skip those streams. */

            if (rt->server_type == RTSP_SERVER_WMS &&

                (rtsp_st->stream_index < 0 ||

                 s->streams[rtsp_st->stream_index]->codec->codec_type ==

                    AVMEDIA_TYPE_DATA))

                continue;

            snprintf(transport, sizeof(transport) - 1,

                     ""%s/TCP;"", trans_pref);

            if (rt->transport != RTSP_TRANSPORT_RDT)

                av_strlcat(transport, ""unicast;"", sizeof(transport));

            av_strlcatf(transport, sizeof(transport),

                        ""interleaved=%d-%d"",

                        interleave, interleave + 1);

            interleave += 2;

        }



        else if (lower_transport == RTSP_LOWER_TRANSPORT_UDP_MULTICAST) {

            snprintf(transport, sizeof(transport) - 1,

                     ""%s/UDP;multicast"", trans_pref);

        }

        if (s->oformat) {

            av_strlcat(transport, "";mode=receive"", sizeof(transport));

        } else if (rt->server_type == RTSP_SERVER_REAL ||

                   rt->server_type == RTSP_SERVER_WMS)

            av_strlcat(transport, "";mode=play"", sizeof(transport));

        snprintf(cmd, sizeof(cmd),

                 ""Transport: %s\r\n"",

                 transport);

        if (rt->accept_dynamic_rate)

            av_strlcat(cmd, ""x-Dynamic-Rate: 0\r\n"", sizeof(cmd));

        if (i == 0 && rt->server_type == RTSP_SERVER_REAL && CONFIG_RTPDEC) {

            char real_res[41], real_csum[9];

            ff_rdt_calc_response_and_checksum(real_res, real_csum,

                                              real_challenge);

            av_strlcatf(cmd, sizeof(cmd),

                        ""If-Match: %s\r\n""

                        ""RealChallenge2: %s, sd=%s\r\n"",

                        rt->session_id, real_res, real_csum);

        }

        ff_rtsp_send_cmd(s, ""SETUP"", rtsp_st->control_url, cmd, reply, NULL);

        if (reply->status_code == 461 /* Unsupported protocol */ && i == 0) {

            err = 1;

            goto fail;

        } else if (reply->status_code != RTSP_STATUS_OK ||

                   reply->nb_transports != 1) {

            err = AVERROR_INVALIDDATA;

            goto fail;

        }



        /* XXX: same protocol for all streams is required */

        if (i > 0) {

            if (reply->transports[0].lower_transport != rt->lower_transport ||

                reply->transports[0].transport != rt->transport) {

                err = AVERROR_INVALIDDATA;

                goto fail;

            }

        } else {

            rt->lower_transport = reply->transports[0].lower_transport;

            rt->transport = reply->transports[0].transport;

        }



        /* Fail if the server responded with another lower transport mode

         * than what we requested. */

        if (reply->transports[0].lower_transport != lower_transport) {

            av_log(s, AV_LOG_ERROR, ""Nonmatching transport in server reply\n"");

            err = AVERROR_INVALIDDATA;

            goto fail;

        }



        switch(reply->transports[0].lower_transport) {

        case RTSP_LOWER_TRANSPORT_TCP:

            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;

            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;

            break;



        case RTSP_LOWER_TRANSPORT_UDP: {

            char url[1024], options[30] = """";



            if (rt->rtsp_flags & RTSP_FLAG_FILTER_SRC)

                av_strlcpy(options, ""?connect=1"", sizeof(options));

            /* Use source address if specified */

            if (reply->transports[0].source[0]) {

                ff_url_join(url, sizeof(url), ""rtp"", NULL,

                            reply->transports[0].source,

                            reply->transports[0].server_port_min, ""%s"", options);

            } else {

                ff_url_join(url, sizeof(url), ""rtp"", NULL, host,

                            reply->transports[0].server_port_min, ""%s"", options);

            }

            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) &&

                ff_rtp_set_remote_url(rtsp_st->rtp_handle, url) < 0) {

                err = AVERROR_INVALIDDATA;

                goto fail;

            }

            /* Try to initialize the connection state in a

             * potential NAT router by sending dummy packets.

             * RTP/RTCP dummy packets are used for RDT, too.

             */

            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) && s->iformat &&

                CONFIG_RTPDEC)

                ff_rtp_send_punch_packets(rtsp_st->rtp_handle);

            break;

        }

        case RTSP_LOWER_TRANSPORT_UDP_MULTICAST: {

            char url[1024], namebuf[50], optbuf[20] = """";

            struct sockaddr_storage addr;

            int port, ttl;



            if (reply->transports[0].destination.ss_family) {

                addr      = reply->transports[0].destination;

                port      = reply->transports[0].port_min;

                ttl       = reply->transports[0].ttl;

            } else {

                addr      = rtsp_st->sdp_ip;

                port      = rtsp_st->sdp_port;

                ttl       = rtsp_st->sdp_ttl;

            }

            if (ttl > 0)

                snprintf(optbuf, sizeof(optbuf), ""?ttl=%d"", ttl);

            getnameinfo((struct sockaddr*) &addr, sizeof(addr),

                        namebuf, sizeof(namebuf), NULL, 0, NI_NUMERICHOST);

            ff_url_join(url, sizeof(url), ""rtp"", NULL, namebuf,

                        port, ""%s"", optbuf);

            if (ffurl_open(&rtsp_st->rtp_handle, url, AVIO_FLAG_READ_WRITE,

                           &s->interrupt_callback, NULL) < 0) {

                err = AVERROR_INVALIDDATA;

                goto fail;

            }

            break;

        }

        }



        if ((err = rtsp_open_transport_ctx(s, rtsp_st)))

            goto fail;

    }



    if (reply->timeout > 0)

        rt->timeout = reply->timeout;



    if (rt->server_type == RTSP_SERVER_REAL)

        rt->need_subscription = 1;



    return 0;



fail:

    ff_rtsp_undo_setup(s);

    return err;

}
",1873,,LABEL_1,LABEL_0,,-4,"s,host,port,lower_transport,real_challenge,rt,j,i,err,port_off,rtsp_st,reply1,reply,cmd,trans_pref,transport,rtx,buf",,,,0,,0,Greedy,1,0.0015729546546936035,,
194,"static inline float64 ucf64_itod(uint64_t i)

{

    union {

        uint64_t i;

        float64 d;

    } v;



    v.i = i;

    return v.d;

}
",32,,LABEL_0,LABEL_0,LABEL_0,-1,"i,v",,2,7,0,,0,GA,476,0.1666826128959656,failed,[]
195,"static int usb_host_handle_control(USBDevice *dev, USBPacket *p,

               int request, int value, int index, int length, uint8_t *data)

{

    USBHostDevice *s = DO_UPCAST(USBHostDevice, dev, dev);

    struct usbdevfs_urb *urb;

    AsyncURB *aurb;

    int ret;



    /*

     * Process certain standard device requests.

     * These are infrequent and are processed synchronously.

     */



    /* Note request is (bRequestType << 8) | bRequest */

    trace_usb_host_req_control(s->bus_num, s->addr, request, value, index);



    switch (request) {

    case DeviceOutRequest | USB_REQ_SET_ADDRESS:

        return usb_host_set_address(s, value);



    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:

        return usb_host_set_config(s, value & 0xff);



    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:

        return usb_host_set_interface(s, index, value);

    }



    /* The rest are asynchronous */



    if (length > sizeof(dev->data_buf)) {

        fprintf(stderr, ""husb: ctrl buffer too small (%d > %zu)\n"",

                length, sizeof(dev->data_buf));

        return USB_RET_STALL;

    }



    aurb = async_alloc(s);

    aurb->packet = p;



    /*

     * Setup ctrl transfer.

     *

     * s->ctrl is laid out such that data buffer immediately follows

     * 'req' struct which is exactly what usbdevfs expects.

     */

    urb = &aurb->urb;



    urb->type     = USBDEVFS_URB_TYPE_CONTROL;

    urb->endpoint = p->devep;



    urb->buffer        = &dev->setup_buf;

    urb->buffer_length = length + 8;



    urb->usercontext = s;



    trace_usb_host_urb_submit(s->bus_num, s->addr, aurb,

                              urb->buffer_length, aurb->more);

    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);



    DPRINTF(""husb: submit ctrl. len %u aurb %p\n"", urb->buffer_length, aurb);



    if (ret < 0) {

        DPRINTF(""husb: submit failed. errno %d\n"", errno);

        async_free(aurb);



        switch(errno) {

        case ETIMEDOUT:

            return USB_RET_NAK;

        case EPIPE:

        default:

            return USB_RET_STALL;

        }

    }



    return USB_RET_ASYNC;

}
",430,"static int usb_host_handle_control(USBDevice *pro, USBPacket *c,

               int head, int localhost, int val, int thin, uint8_t *DATA)

{

    USBHostDevice *storage = DO_UPCAST(USBHostDevice, pro, pro);

    struct usbdevfs_urb *ann;

    AsyncURB *iarf;

    int pass;



    /*

     * Process certain standard device requests.

     * These are infrequent and are processed synchronously.

     */



    /* Note head is (bRequestType << 8) | bRequest */

    trace_usb_host_req_control(storage->bus_num, storage->addr, head, localhost, val);



    switch (head) {

    case DeviceOutRequest | USB_REQ_SET_ADDRESS:

        return usb_host_set_address(storage, localhost);



    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:

        return usb_host_set_config(storage, localhost & 0xff);



    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:

        return usb_host_set_interface(storage, val, localhost);

    }



    /* The rest are asynchronous */



    if (thin > sizeof(pro->data_buf)) {

        fprintf(stderr, ""husb: ctrl buffer too small (%d > %zu)
"",

                thin, sizeof(pro->data_buf));

        return USB_RET_STALL;

    }



    iarf = async_alloc(storage);

    iarf->packet = c;



    /*

     * Setup ctrl transfer.

     *

     * storage->ctrl is laid out such that DATA buffer immediately follows

     * 'req' struct which is exactly what usbdevfs expects.

     */

    ann = &iarf->ann;



    ann->type     = USBDEVFS_URB_TYPE_CONTROL;

    ann->endpoint = c->devep;



    ann->buffer        = &pro->setup_buf;

    ann->buffer_length = thin + 8;



    ann->usercontext = storage;



    trace_usb_host_urb_submit(storage->bus_num, storage->addr, iarf,

                              ann->buffer_length, iarf->more);

    pass = ioctl(storage->fd, USBDEVFS_SUBMITURB, ann);



    DPRINTF(""husb: submit ctrl. len %u iarf %c
"", ann->buffer_length, iarf);



    if (pass < 0) {

        DPRINTF(""husb: submit failed. errno %d
"", errno);

        async_free(iarf);



        switch(errno) {

        case ETIMEDOUT:

            return USB_RET_NAK;

        case EPIPE:

        default:

            return USB_RET_STALL;

        }

    }



    return USB_RET_ASYNC;

}
",LABEL_0,LABEL_0,LABEL_1,1,"dev,p,request,value,index,length,data,s,urb,aurb,ret","dev:-0.023649156093597412,p:-0.011509716510772705,request:-0.015550971031188965,value:-0.021357595920562744,index:-0.008944272994995117,length:-0.015890777111053467,data:-0.006432473659515381,s:-0.04219931364059448,urb:-0.03186333179473877,aurb:-0.0458795428276062,ret:-0.023185551166534424,",11,63,0,"data:DATA,index:val,p:c,request:head,length:thin,value:localhost,ret:pass,dev:pro,urb:ann,s:storage,aurb:iarf,",0,Greedy,657,0.2621585806210836,replace,[]
196,"PPC_OP(slw)

{

    if (T1 & 0x20) {

        T0 = 0;

    } else {

        T0 = T0 << T1;

    }

    RETURN();

}
",31,,LABEL_1,LABEL_1,,-3,,,,,0,,0,Greedy,1,0.0004440863927205404,,
197,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}
",83,,LABEL_0,LABEL_1,,-4,"str,endptr,err",,,,0,,0,Greedy,1,0.00046050151189168295,,
198,"static int write_f(int argc, char **argv)

{

    struct timeval t1, t2;

    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;

    int c, cnt;

    char *buf;

    int64_t offset;

    int count;

    /* Some compilers get confused and warn if this is not initialized.  */

    int total = 0;

    int pattern = 0xcd;



    while ((c = getopt(argc, argv, ""bCpP:q"")) != EOF) {

        switch (c) {

        case 'b':

            bflag = 1;

            break;

        case 'C':

            Cflag = 1;

            break;

        case 'p':

            pflag = 1;

            break;

        case 'P':

            pattern = parse_pattern(optarg);

            if (pattern < 0) {

                return 0;

            }

            break;

        case 'q':

            qflag = 1;

            break;

        default:

            return command_usage(&write_cmd);

        }

    }



    if (optind != argc - 2) {

        return command_usage(&write_cmd);

    }



    if (bflag && pflag) {

        printf(""-b and -p cannot be specified at the same time\n"");

        return 0;

    }



    offset = cvtnum(argv[optind]);

    if (offset < 0) {

        printf(""non-numeric length argument -- %s\n"", argv[optind]);

        return 0;

    }



    optind++;

    count = cvtnum(argv[optind]);

    if (count < 0) {

        printf(""non-numeric length argument -- %s\n"", argv[optind]);

        return 0;

    }



    if (!pflag) {

        if (offset & 0x1ff) {

            printf(""offset %"" PRId64 "" is not sector aligned\n"",

                   offset);

            return 0;

        }



        if (count & 0x1ff) {

            printf(""count %d is not sector aligned\n"",

                   count);

            return 0;

        }

    }



    buf = qemu_io_alloc(count, pattern);



    gettimeofday(&t1, NULL);

    if (pflag) {

        cnt = do_pwrite(buf, offset, count, &total);

    } else if (bflag) {

        cnt = do_save_vmstate(buf, offset, count, &total);

    } else {

        cnt = do_write(buf, offset, count, &total);

    }

    gettimeofday(&t2, NULL);



    if (cnt < 0) {

        printf(""write failed: %s\n"", strerror(-cnt));

        goto out;

    }



    if (qflag) {

        goto out;

    }



    /* Finally, report back -- -C gives a parsable format */

    t2 = tsub(t2, t1);

    print_report(""wrote"", &t2, offset, count, total, cnt, Cflag);



out:

    qemu_io_free(buf);



    return 0;

}
",535,"static int write_f(int argc, char **argv)

{

    struct timeval t1, t2;

    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;

    int col, Cret;

    char *batch;

    int64_t offset;

    int count;

    /* Some compilers get confused and warn if this is not initialized.  */

    int total = 0;

    int pattern = 0xcd;



    while ((col = getopt(argc, argv, ""bCpP:q"")) != EOF) {

        switch (col) {

        case 'b':

            bflag = 1;

            break;

        case 'C':

            Cflag = 1;

            break;

        case 'p':

            pflag = 1;

            break;

        case 'P':

            pattern = parse_pattern(optarg);

            if (pattern < 0) {

                return 0;

            }

            break;

        case 'q':

            qflag = 1;

            break;

        default:

            return command_usage(&write_cmd);

        }

    }



    if (optind != argc - 2) {

        return command_usage(&write_cmd);

    }



    if (bflag && pflag) {

        printf(""-b and -p cannot be specified at the same time
"");

        return 0;

    }



    offset = cvtnum(argv[optind]);

    if (offset < 0) {

        printf(""non-numeric length argument -- %s
"", argv[optind]);

        return 0;

    }



    optind++;

    count = cvtnum(argv[optind]);

    if (count < 0) {

        printf(""non-numeric length argument -- %s
"", argv[optind]);

        return 0;

    }



    if (!pflag) {

        if (offset & 0x1ff) {

            printf(""offset %"" PRId64 "" is not sector aligned
"",

                   offset);

            return 0;

        }



        if (count & 0x1ff) {

            printf(""count %d is not sector aligned
"",

                   count);

            return 0;

        }

    }



    batch = qemu_io_alloc(count, pattern);



    gettimeofday(&t1, NULL);

    if (pflag) {

        Cret = do_pwrite(batch, offset, count, &total);

    } else if (bflag) {

        Cret = do_save_vmstate(batch, offset, count, &total);

    } else {

        Cret = do_write(batch, offset, count, &total);

    }

    gettimeofday(&t2, NULL);



    if (Cret < 0) {

        printf(""write failed: %s
"", strerror(-Cret));

        goto out;

    }



    if (qflag) {

        goto out;

    }



    /* Finally, report back -- -C gives a parsable format */

    t2 = tsub(t2, t1);

    print_report(""wrote"", &t2, offset, count, total, Cret, Cflag);



out:

    qemu_io_free(batch);



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"argc,argv,t1,t2,c,cnt,buf,offset,count,optind","argc:-0.00014525651931762695,argv:-0.0001965165138244629,t1:-0.00012069940567016602,t2:-0.0002860426902770996,c:-0.00010865926742553711,cnt:-1.8417835235595703e-05,buf:0.00016558170318603516,offset:-0.0003472566604614258,count:-0.00022095441818237305,optind:-0.00029206275939941406,",3,16,0,"buf:batch,cnt:Cret,c:col,",0,Greedy,219,0.0894360065460205,replace,[]
199,"static void gen_loongson_integer(DisasContext *ctx, uint32_t opc,

                                 int rd, int rs, int rt)

{

    const char *opn = ""loongson"";

    TCGv t0, t1;



    if (rd == 0) {

        /* Treat as NOP. */

        MIPS_DEBUG(""NOP"");

        return;

    }



    switch (opc) {

    case OPC_MULT_G_2E:

    case OPC_MULT_G_2F:

    case OPC_MULTU_G_2E:

    case OPC_MULTU_G_2F:

#if defined(TARGET_MIPS64)

    case OPC_DMULT_G_2E:

    case OPC_DMULT_G_2F:

    case OPC_DMULTU_G_2E:

    case OPC_DMULTU_G_2F:

#endif

        t0 = tcg_temp_new();

        t1 = tcg_temp_new();

        break;

    default:

        t0 = tcg_temp_local_new();

        t1 = tcg_temp_local_new();

        break;

    }



    gen_load_gpr(t0, rs);

    gen_load_gpr(t1, rt);



    switch (opc) {

    case OPC_MULT_G_2E:

    case OPC_MULT_G_2F:

        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);

        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

        opn = ""mult.g"";

        break;

    case OPC_MULTU_G_2E:

    case OPC_MULTU_G_2F:

        tcg_gen_ext32u_tl(t0, t0);

        tcg_gen_ext32u_tl(t1, t1);

        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);

        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

        opn = ""multu.g"";

        break;

    case OPC_DIV_G_2E:

    case OPC_DIV_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_ext32s_tl(t0, t0);

            tcg_gen_ext32s_tl(t1, t1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l3);

            gen_set_label(l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);

            tcg_gen_mov_tl(cpu_gpr[rd], t0);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);

            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

            gen_set_label(l3);

        }

        opn = ""div.g"";

        break;

    case OPC_DIVU_G_2E:

    case OPC_DIVU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_ext32u_tl(t0, t0);

            tcg_gen_ext32u_tl(t1, t1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);

            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

            gen_set_label(l2);

        }

        opn = ""divu.g"";

        break;

    case OPC_MOD_G_2E:

    case OPC_MOD_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_ext32u_tl(t0, t0);

            tcg_gen_ext32u_tl(t1, t1);

            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);

            gen_set_label(l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);

            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

            gen_set_label(l3);

        }

        opn = ""mod.g"";

        break;

    case OPC_MODU_G_2E:

    case OPC_MODU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_ext32u_tl(t0, t0);

            tcg_gen_ext32u_tl(t1, t1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);

            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

            gen_set_label(l2);

        }

        opn = ""modu.g"";

        break;

#if defined(TARGET_MIPS64)

    case OPC_DMULT_G_2E:

    case OPC_DMULT_G_2F:

        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);

        opn = ""dmult.g"";

        break;

    case OPC_DMULTU_G_2E:

    case OPC_DMULTU_G_2F:

        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);

        opn = ""dmultu.g"";

        break;

    case OPC_DDIV_G_2E:

    case OPC_DDIV_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l3);

            gen_set_label(l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);

            tcg_gen_mov_tl(cpu_gpr[rd], t0);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);

            gen_set_label(l3);

        }

        opn = ""ddiv.g"";

        break;

    case OPC_DDIVU_G_2E:

    case OPC_DDIVU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);

            gen_set_label(l2);

        }

        opn = ""ddivu.g"";

        break;

    case OPC_DMOD_G_2E:

    case OPC_DMOD_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);

            gen_set_label(l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);

            gen_set_label(l3);

        }

        opn = ""dmod.g"";

        break;

    case OPC_DMODU_G_2E:

    case OPC_DMODU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);

            gen_set_label(l2);

        }

        opn = ""dmodu.g"";

        break;

#endif

    }



    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rs]);

    tcg_temp_free(t0);

    tcg_temp_free(t1);

}
",1222,"static void gen_loongson_integer(DisasContext *context, uint32_t OPC,

                                 int ARR, int rows, int adr)

{

    const char *Opc = ""loongson"";

    TCGv t3, ttyapp;



    if (ARR == 0) {

        /* Treat as NOP. */

        MIPS_DEBUG(""NOP"");

        return;

    }



    switch (OPC) {

    case OPC_MULT_G_2E:

    case OPC_MULT_G_2F:

    case OPC_MULTU_G_2E:

    case OPC_MULTU_G_2F:

#if defined(TARGET_MIPS64)

    case OPC_DMULT_G_2E:

    case OPC_DMULT_G_2F:

    case OPC_DMULTU_G_2E:

    case OPC_DMULTU_G_2F:

#endif

        t3 = tcg_temp_new();

        ttyapp = tcg_temp_new();

        break;

    default:

        t3 = tcg_temp_local_new();

        ttyapp = tcg_temp_local_new();

        break;

    }



    gen_load_gpr(t3, rows);

    gen_load_gpr(ttyapp, adr);



    switch (OPC) {

    case OPC_MULT_G_2E:

    case OPC_MULT_G_2F:

        tcg_gen_mul_tl(cpu_gpr[ARR], t3, ttyapp);

        tcg_gen_ext32s_tl(cpu_gpr[ARR], cpu_gpr[ARR]);

        Opc = ""mult.g"";

        break;

    case OPC_MULTU_G_2E:

    case OPC_MULTU_G_2F:

        tcg_gen_ext32u_tl(t3, t3);

        tcg_gen_ext32u_tl(ttyapp, ttyapp);

        tcg_gen_mul_tl(cpu_gpr[ARR], t3, ttyapp);

        tcg_gen_ext32s_tl(cpu_gpr[ARR], cpu_gpr[ARR]);

        Opc = ""multu.g"";

        break;

    case OPC_DIV_G_2E:

    case OPC_DIV_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_ext32s_tl(t3, t3);

            tcg_gen_ext32s_tl(ttyapp, ttyapp);

            tcg_gen_brcondi_tl(TCG_COND_NE, ttyapp, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[ARR], 0);

            tcg_gen_br(l3);

            gen_set_label(l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t3, INT_MIN, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, ttyapp, -1, l2);

            tcg_gen_mov_tl(cpu_gpr[ARR], t3);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_div_tl(cpu_gpr[ARR], t3, ttyapp);

            tcg_gen_ext32s_tl(cpu_gpr[ARR], cpu_gpr[ARR]);

            gen_set_label(l3);

        }

        Opc = ""div.g"";

        break;

    case OPC_DIVU_G_2E:

    case OPC_DIVU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_ext32u_tl(t3, t3);

            tcg_gen_ext32u_tl(ttyapp, ttyapp);

            tcg_gen_brcondi_tl(TCG_COND_NE, ttyapp, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[ARR], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_divu_tl(cpu_gpr[ARR], t3, ttyapp);

            tcg_gen_ext32s_tl(cpu_gpr[ARR], cpu_gpr[ARR]);

            gen_set_label(l2);

        }

        Opc = ""divu.g"";

        break;

    case OPC_MOD_G_2E:

    case OPC_MOD_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_ext32u_tl(t3, t3);

            tcg_gen_ext32u_tl(ttyapp, ttyapp);

            tcg_gen_brcondi_tl(TCG_COND_EQ, ttyapp, 0, l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t3, INT_MIN, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, ttyapp, -1, l2);

            gen_set_label(l1);

            tcg_gen_movi_tl(cpu_gpr[ARR], 0);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_rem_tl(cpu_gpr[ARR], t3, ttyapp);

            tcg_gen_ext32s_tl(cpu_gpr[ARR], cpu_gpr[ARR]);

            gen_set_label(l3);

        }

        Opc = ""mod.g"";

        break;

    case OPC_MODU_G_2E:

    case OPC_MODU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_ext32u_tl(t3, t3);

            tcg_gen_ext32u_tl(ttyapp, ttyapp);

            tcg_gen_brcondi_tl(TCG_COND_NE, ttyapp, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[ARR], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_remu_tl(cpu_gpr[ARR], t3, ttyapp);

            tcg_gen_ext32s_tl(cpu_gpr[ARR], cpu_gpr[ARR]);

            gen_set_label(l2);

        }

        Opc = ""modu.g"";

        break;

#if defined(TARGET_MIPS64)

    case OPC_DMULT_G_2E:

    case OPC_DMULT_G_2F:

        tcg_gen_mul_tl(cpu_gpr[ARR], t3, ttyapp);

        Opc = ""dmult.g"";

        break;

    case OPC_DMULTU_G_2E:

    case OPC_DMULTU_G_2F:

        tcg_gen_mul_tl(cpu_gpr[ARR], t3, ttyapp);

        Opc = ""dmultu.g"";

        break;

    case OPC_DDIV_G_2E:

    case OPC_DDIV_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_NE, ttyapp, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[ARR], 0);

            tcg_gen_br(l3);

            gen_set_label(l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t3, -1LL << 63, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, ttyapp, -1LL, l2);

            tcg_gen_mov_tl(cpu_gpr[ARR], t3);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_div_tl(cpu_gpr[ARR], t3, ttyapp);

            gen_set_label(l3);

        }

        Opc = ""ddiv.g"";

        break;

    case OPC_DDIVU_G_2E:

    case OPC_DDIVU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_NE, ttyapp, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[ARR], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_divu_tl(cpu_gpr[ARR], t3, ttyapp);

            gen_set_label(l2);

        }

        Opc = ""ddivu.g"";

        break;

    case OPC_DMOD_G_2E:

    case OPC_DMOD_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_EQ, ttyapp, 0, l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t3, -1LL << 63, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, ttyapp, -1LL, l2);

            gen_set_label(l1);

            tcg_gen_movi_tl(cpu_gpr[ARR], 0);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_rem_tl(cpu_gpr[ARR], t3, ttyapp);

            gen_set_label(l3);

        }

        Opc = ""dmod.g"";

        break;

    case OPC_DMODU_G_2E:

    case OPC_DMODU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_NE, ttyapp, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[ARR], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_remu_tl(cpu_gpr[ARR], t3, ttyapp);

            gen_set_label(l2);

        }

        Opc = ""dmodu.g"";

        break;

#endif

    }



    (void)Opc; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %s"", Opc, regnames[ARR], regnames[rows]);

    tcg_temp_free(t3);

    tcg_temp_free(ttyapp);

}
",LABEL_0,LABEL_0,LABEL_1,1,"ctx,opc,rd,rs,rt,opn,t0,t1","ctx:0.01525968313217163,opc:0.05784398317337036,rd:0.278112530708313,rs:-0.010219752788543701,rt:0.04182147979736328,opn:0.07632565498352051,t0:0.30694061517715454,t1:0.32425475120544434,",8,133,0,"t1:ttyapp,t0:t3,rd:ARR,opn:Opc,opc:OPC,rt:adr,ctx:context,rs:rows,",0,Greedy,528,0.2615482409795125,replace,[]
200,"static void put_payload_header(

                                AVFormatContext *s,

                                ASFStream       *stream,

                                int             presentation_time,

                                int             m_obj_size,

                                int             m_obj_offset,

                                int             payload_len

            )

{

    ASFContext *asf = s->priv_data;

    ByteIOContext *pb = &asf->pb;

    int val;

    

    val = stream->num;

    if (s->streams[val - 1]->codec.coded_frame->key_frame)

        val |= ASF_PL_FLAG_KEY_FRAME;

    put_byte(pb, val);

        

    put_byte(pb, stream->seq);  //Media object number

    put_le32(pb, m_obj_offset); //Offset Into Media Object

         

    // Replicated Data shall be at least 8 bytes long.

    // The first 4 bytes of data shall contain the 

    // Size of the Media Object that the payload belongs to.

    // The next 4 bytes of data shall contain the 

    // Presentation Time for the media object that the payload belongs to.

    put_byte(pb, ASF_PAYLOAD_REPLICATED_DATA_LENGTH);



    put_le32(pb, m_obj_size);       //Replicated Data - Media Object Size

    put_le32(pb, presentation_time);//Replicated Data - Presentation Time

    

    if (asf->multi_payloads_present){

        put_le16(pb, payload_len);   //payload length

    }

}
",222,,LABEL_0,LABEL_0,LABEL_0,-1,"s,stream,presentation_time,m_obj_size,m_obj_offset,payload_len,asf,pb,val",,8,26,0,,0,GA,1845,0.7134685675303142,failed,[]
201,"static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc)

{

    AVStream *st;

    OutputStream *ost;

    AVCodecContext *audio_enc;



    ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO);

    st  = ost->st;



    audio_enc = st->codec;

    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;



    if (!ost->stream_copy) {

        char *sample_fmt = NULL;



        MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st);



        MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st);

        if (sample_fmt &&

            (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) {

            av_log(NULL, AV_LOG_FATAL, ""Invalid sample format '%s'\n"", sample_fmt);

            exit_program(1);

        }



        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);

    }



    return ost;

}
",166,,LABEL_1,LABEL_0,,-4,"o,oc,st,ost,audio_enc,sample_fmt",,,,0,,0,Greedy,1,0.0005305369695027669,,
202,"static void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->job);

    assert(bdrv_op_blocker_is_empty(bs));

    assert(!bs->refcnt);

    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    bdrv_close(bs);



    /* remove from list, if necessary */

    bdrv_make_anon(bs);



    g_free(bs);

}
",76,,LABEL_0,LABEL_0,LABEL_0,-1,bs,,1,6,0,,0,GA,281,0.09954969882965088,failed,[]
203,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
",92,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *platform = &s->platform;

    int ft;



    ft = process_ipmovie_chunk(ipmovie, platform, pkt);

    if (ft == CHUNK_BAD)

        ft = AVERROR_INVALIDDATA;

    else if (ft == CHUNK_EOF)

        ft = AVERROR_IO;

    else if (ft == CHUNK_NOMEM)

        ft = AVERROR_NOMEM;

    else

        ft = 0;



    return ft;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,pkt,ipmovie,pb,ret","s:2.777576446533203e-05,pkt:5.805492401123047e-05,ipmovie:4.029273986816406e-05,pb:7.998943328857422e-05,ret:0.0003076791763305664,",2,13,0,"ret:ft,pb:platform,",0,Greedy,138,0.048953525225321454,replace,[]
204,"static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)

{

    const QDictEntry *ent;

    const char *arg_name;

    const QObject *arg_obj;

    bool has_exec_key = false;

    QDict *dict = NULL;



    if (qobject_type(request) != QTYPE_QDICT) {

        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,

                   ""request is not a dictionary"");

        return NULL;

    }



    dict = qobject_to_qdict(request);



    for (ent = qdict_first(dict); ent;

         ent = qdict_next(dict, ent)) {

        arg_name = qdict_entry_key(ent);

        arg_obj = qdict_entry_value(ent);



        if (!strcmp(arg_name, ""execute"")) {

            if (qobject_type(arg_obj) != QTYPE_QSTRING) {

                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, ""execute"",

                           ""string"");

                return NULL;

            }

            has_exec_key = true;

        } else if (strcmp(arg_name, ""arguments"")) {

            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);

            return NULL;

        }

    }



    if (!has_exec_key) {

        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, ""execute"");

        return NULL;

    }



    return dict;

}
",196,,LABEL_0,LABEL_1,,-4,"request,errp,ent,arg_name,arg_obj,dict",,,,0,,0,Greedy,1,0.0005530953407287597,,
205,"static void gpollfds_from_select(void)

{

    int fd;

    for (fd = 0; fd <= nfds; fd++) {

        int events = 0;

        if (FD_ISSET(fd, &rfds)) {

            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;

        }

        if (FD_ISSET(fd, &wfds)) {

            events |= G_IO_OUT | G_IO_ERR;

        }

        if (FD_ISSET(fd, &xfds)) {

            events |= G_IO_PRI;

        }

        if (events) {

            GPollFD pfd = {

                .fd = fd,

                .events = events,

            };

            g_array_append_val(gpollfds, pfd);

        }

    }

}
",115,,LABEL_0,LABEL_0,LABEL_0,-1,fd,,1,9,0,,0,GA,287,0.10510586102803549,failed,[]
206,"static void qemu_net_queue_append(NetQueue *queue,

                                  NetClientState *sender,

                                  unsigned flags,

                                  const uint8_t *buf,

                                  size_t size,

                                  NetPacketSent *sent_cb)

{

    NetPacket *packet;



    if (queue->nq_count >= queue->nq_maxlen && !sent_cb) {

        return; /* drop if queue full and no callback */

    }

    packet = g_malloc(sizeof(NetPacket) + size);

    packet->sender = sender;

    packet->flags = flags;

    packet->size = size;

    packet->sent_cb = sent_cb;

    memcpy(packet->data, buf, size);




    QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);

}",129,,LABEL_1,LABEL_1,LABEL_1,-1,"queue,sender,flags,buf,size,sent_cb,packet",,7,29,0,,0,GA,1474,0.5404364943504334,failed,[]
207,"void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,

                                 bool is_write, bool is_exec, int unused,

                                 unsigned size)

{

    AlphaCPU *cpu = ALPHA_CPU(cs);

    CPUAlphaState *env = &cpu->env;



    env->trap_arg0 = addr;

    env->trap_arg1 = is_write ? 1 : 0;

    dynamic_excp(env, 0, EXCP_MCHK, 0);

}
",73,"void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,

                                 bool is_write, bool is_exec, int unused,

                                 unsigned size)

{

    AlphaCPU *cpu = ALPHA_CPU(cs);

    CPUAlphaState *conn = &cpu->conn;



    conn->trap_arg0 = addr;

    conn->trap_arg1 = is_write ? 1 : 0;

    dynamic_excp(conn, 0, EXCP_MCHK, 0);

}
",LABEL_0,LABEL_0,LABEL_1,1,"cs,addr,is_write,is_exec,unused,size,cpu,env","cs:-2.110004425048828e-05,addr:5.060434341430664e-05,is_write:8.207559585571289e-05,is_exec:5.263090133666992e-05,unused:2.491474151611328e-05,size:1.2993812561035156e-05,cpu:5.841255187988281e-06,env:0.0001220703125,",1,5,0,"env:conn,",0,Greedy,80,0.02810800075531006,replace,[]
208,"static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr)

{

    IRQMP      *irqmp = opaque;

    IRQMPState *state;



    assert(irqmp != NULL);

    state = irqmp->state;

    assert(state != NULL);



    addr &= 0xff;



    /* global registers */

    switch (addr) {

    case LEVEL_OFFSET:

        return state->level;



    case PENDING_OFFSET:

        return state->pending;



    case FORCE0_OFFSET:

        /* This register is an ""alias"" for the force register of CPU 0 */

        return state->force[0];



    case CLEAR_OFFSET:

    case MP_STATUS_OFFSET:

        /* Always read as 0 */

        return 0;



    case BROADCAST_OFFSET:

        return state->broadcast;



    default:

        break;

    }



    /* mask registers */

    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {

        int cpu = (addr - MASK_OFFSET) / 4;

        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);



        return state->mask[cpu];

    }



    /* force registers */

    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {

        int cpu = (addr - FORCE_OFFSET) / 4;

        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);



        return state->force[cpu];

    }



    /* extended (not supported) */

    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {

        int cpu = (addr - EXTENDED_OFFSET) / 4;

        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);



        return state->extended[cpu];

    }



    trace_grlib_irqmp_unknown_register(""read"", addr);

    return 0;

}
",310,,LABEL_1,LABEL_0,,-4,"opaque,addr,irqmp,state",,,,0,,0,Greedy,1,0.000607601801554362,,
209,"static void term_handle_byte(int ch)

{

    switch(term_esc_state) {

    case IS_NORM:

        switch(ch) {

        case 1:

            term_bol();

            break;

        case 4:

            term_delete_char();

            break;

        case 5:

            term_eol();

            break;

        case 9:

            term_completion();

            break;

        case 10:

        case 13:

            term_cmd_buf[term_cmd_buf_size] = '\0';

	    term_hist_add(term_cmd_buf);

            term_printf(""\n"");

            term_handle_command(term_cmd_buf);

            term_show_prompt();

            break;

        case 27:

            term_esc_state = IS_ESC;

            break;

        case 127:

        case 8:

            term_backspace();

            break;

	case 155:

            term_esc_state = IS_CSI;

	    break;

        default:

            if (ch >= 32) {

                term_insert_char(ch);

            }

            break;

        }

        break;

    case IS_ESC:

        if (ch == '[') {

            term_esc_state = IS_CSI;

            term_esc_param = 0;

        } else {

            term_esc_state = IS_NORM;

        }

        break;

    case IS_CSI:

        switch(ch) {

	case 'A':

	case 'F':

	    term_up_char();

	    break;

	case 'B':

	case 'E':

	    term_down_char();

	    break;

        case 'D':

            term_backward_char();

            break;

        case 'C':

            term_forward_char();

            break;

        case '0' ... '9':

            term_esc_param = term_esc_param * 10 + (ch - '0');

            goto the_end;

        case '~':

            switch(term_esc_param) {

            case 1:

                term_bol();

                break;

            case 3:

                term_delete_char();

                break;

            case 4:

                term_eol();

                break;

            }

            break;

        default:

            break;

        }

        term_esc_state = IS_NORM;

    the_end:

        break;

    }

    term_update();

}
",299,,LABEL_0,LABEL_0,LABEL_0,-1,ch,,1,7,0,,0,GA,270,0.11076763470967611,failed,[]
210,"static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    EEPRO100State *s = opaque;



    switch (size) {

    case 1: return eepro100_read1(s, addr);

    case 2: return eepro100_read2(s, addr);

    case 4: return eepro100_read4(s, addr);

    default: abort();

    }

}
",69,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,addr,size,s",,4,12,0,,0,GA,809,0.28724713722864786,failed,[]
211,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height){

    int w_align= 1;

    int h_align= 1;



    switch(s->pix_fmt){

    case PIX_FMT_YUV420P:

    case PIX_FMT_YUYV422:

    case PIX_FMT_UYVY422:

    case PIX_FMT_YUV422P:

    case PIX_FMT_YUV444P:

    case PIX_FMT_GRAY8:

    case PIX_FMT_GRAY16BE:

    case PIX_FMT_GRAY16LE:

    case PIX_FMT_YUVJ420P:

    case PIX_FMT_YUVJ422P:

    case PIX_FMT_YUVJ444P:

    case PIX_FMT_YUVA420P:

        w_align= 16; //FIXME check for non mpeg style codecs and use less alignment

        h_align= 16;



        break;

    case PIX_FMT_YUV411P:

    case PIX_FMT_UYYVYY411:

        w_align=32;

        h_align=8;

        break;

    case PIX_FMT_YUV410P:

        if(s->codec_id == CODEC_ID_SVQ1){

            w_align=64;

            h_align=64;

        }

    case PIX_FMT_RGB555:

        if(s->codec_id == CODEC_ID_RPZA){

            w_align=4;

            h_align=4;

        }

    case PIX_FMT_PAL8:

    case PIX_FMT_BGR8:

    case PIX_FMT_RGB8:

        if(s->codec_id == CODEC_ID_SMC){

            w_align=4;

            h_align=4;

        }

        break;

    case PIX_FMT_BGR24:

        if((s->codec_id == CODEC_ID_MSZH) || (s->codec_id == CODEC_ID_ZLIB)){

            w_align=4;

            h_align=4;

        }

        break;

    default:

        w_align= 1;

        h_align= 1;

        break;

    }



    *width = ALIGN(*width , w_align);

    *height= ALIGN(*height, h_align);

    if(s->codec_id == CODEC_ID_H264)

        *height+=2; // some of the optimized chroma MC reads one line too much

}",280,,LABEL_1,LABEL_1,LABEL_1,-1,"s,height",,2,12,0,,0,GA,474,0.1855685035387675,failed,[]
212,"static int get_physical_address(CPUPPCState *env, mmu_ctx_t *ctx,

                                target_ulong eaddr, int rw, int access_type)

{

    int ret;



#if 0

    qemu_log(""%s\n"", __func__);

#endif

    if ((access_type == ACCESS_CODE && msr_ir == 0) ||

        (access_type != ACCESS_CODE && msr_dr == 0)) {

        if (env->mmu_model == POWERPC_MMU_BOOKE) {

            /* The BookE MMU always performs address translation. The

               IS and DS bits only affect the address space.  */

            ret = mmubooke_get_physical_address(env, ctx, eaddr,

                                                rw, access_type);

        } else if (env->mmu_model == POWERPC_MMU_BOOKE206) {

            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,

                                                   access_type);

        } else {

            /* No address translation.  */

            ret = check_physical(env, ctx, eaddr, rw);

        }

    } else {

        ret = -1;

        switch (env->mmu_model) {

        case POWERPC_MMU_32B:

        case POWERPC_MMU_601:

            /* Try to find a BAT */

            if (env->nb_BATs != 0) {

                ret = get_bat(env, ctx, eaddr, rw, access_type);

            }

            if (ret < 0) {

                /* We didn't match any BAT entry or don't have BATs */

                ret = get_segment32(env, ctx, eaddr, rw, access_type);

            }

            break;



        case POWERPC_MMU_SOFT_6xx:

        case POWERPC_MMU_SOFT_74xx:

            /* Try to find a BAT */

            if (env->nb_BATs != 0) {

                ret = get_bat(env, ctx, eaddr, rw, access_type);

            }

            if (ret < 0) {

                /* We didn't match any BAT entry or don't have BATs */

                ret = get_segment_6xx_tlb(env, ctx, eaddr, rw, access_type);

            }

            break;



#if defined(TARGET_PPC64)

        case POWERPC_MMU_64B:

        case POWERPC_MMU_2_06:

        case POWERPC_MMU_2_06d:

            ret = get_segment64(env, ctx, eaddr, rw, access_type);

            break;

#endif



        case POWERPC_MMU_SOFT_4xx:

        case POWERPC_MMU_SOFT_4xx_Z:

            ret = mmu40x_get_physical_address(env, ctx, eaddr,

                                              rw, access_type);

            break;

        case POWERPC_MMU_BOOKE:

            ret = mmubooke_get_physical_address(env, ctx, eaddr,

                                                rw, access_type);

            break;

        case POWERPC_MMU_BOOKE206:

            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,

                                               access_type);

            break;

        case POWERPC_MMU_MPC8xx:

            /* XXX: TODO */

            cpu_abort(env, ""MPC8xx MMU model is not implemented\n"");

            break;

        case POWERPC_MMU_REAL:

            cpu_abort(env, ""PowerPC in real mode do not do any translation\n"");

            return -1;

        default:

            cpu_abort(env, ""Unknown or invalid MMU model\n"");

            return -1;

        }

    }

#if 0

    qemu_log(""%s address "" TARGET_FMT_lx "" => %d "" TARGET_FMT_plx ""\n"",

             __func__, eaddr, ret, ctx->raddr);

#endif



    return ret;

}
",515,"static int get_physical_address(CPUPPCState *env, mmu_ctx_t *ctx,

                                target_ulong eaddr, int wh, int accesstypeaddress)

{

    int ret;



#if 0

    qemu_log(""%s
"", __func__);

#endif

    if ((accesstypeaddress == ACCESS_CODE && msr_ir == 0) ||

        (accesstypeaddress != ACCESS_CODE && msr_dr == 0)) {

        if (env->mmu_model == POWERPC_MMU_BOOKE) {

            /* The BookE MMU always performs address translation. The

               IS and DS bits only affect the address space.  */

            ret = mmubooke_get_physical_address(env, ctx, eaddr,

                                                wh, accesstypeaddress);

        } else if (env->mmu_model == POWERPC_MMU_BOOKE206) {

            ret = mmubooke206_get_physical_address(env, ctx, eaddr, wh,

                                                   accesstypeaddress);

        } else {

            /* No address translation.  */

            ret = check_physical(env, ctx, eaddr, wh);

        }

    } else {

        ret = -1;

        switch (env->mmu_model) {

        case POWERPC_MMU_32B:

        case POWERPC_MMU_601:

            /* Try to find a BAT */

            if (env->nb_BATs != 0) {

                ret = get_bat(env, ctx, eaddr, wh, accesstypeaddress);

            }

            if (ret < 0) {

                /* We didn't match any BAT entry or don't have BATs */

                ret = get_segment32(env, ctx, eaddr, wh, accesstypeaddress);

            }

            break;



        case POWERPC_MMU_SOFT_6xx:

        case POWERPC_MMU_SOFT_74xx:

            /* Try to find a BAT */

            if (env->nb_BATs != 0) {

                ret = get_bat(env, ctx, eaddr, wh, accesstypeaddress);

            }

            if (ret < 0) {

                /* We didn't match any BAT entry or don't have BATs */

                ret = get_segment_6xx_tlb(env, ctx, eaddr, wh, accesstypeaddress);

            }

            break;



#if defined(TARGET_PPC64)

        case POWERPC_MMU_64B:

        case POWERPC_MMU_2_06:

        case POWERPC_MMU_2_06d:

            ret = get_segment64(env, ctx, eaddr, wh, accesstypeaddress);

            break;

#endif



        case POWERPC_MMU_SOFT_4xx:

        case POWERPC_MMU_SOFT_4xx_Z:

            ret = mmu40x_get_physical_address(env, ctx, eaddr,

                                              wh, accesstypeaddress);

            break;

        case POWERPC_MMU_BOOKE:

            ret = mmubooke_get_physical_address(env, ctx, eaddr,

                                                wh, accesstypeaddress);

            break;

        case POWERPC_MMU_BOOKE206:

            ret = mmubooke206_get_physical_address(env, ctx, eaddr, wh,

                                               accesstypeaddress);

            break;

        case POWERPC_MMU_MPC8xx:

            /* XXX: TODO */

            cpu_abort(env, ""MPC8xx MMU model is not implemented
"");

            break;

        case POWERPC_MMU_REAL:

            cpu_abort(env, ""PowerPC in real mode do not do any translation
"");

            return -1;

        default:

            cpu_abort(env, ""Unknown or invalid MMU model
"");

            return -1;

        }

    }

#if 0

    qemu_log(""%s address "" TARGET_FMT_lx "" => %d "" TARGET_FMT_plx ""
"",

             __func__, eaddr, ret, ctx->raddr);

#endif



    return ret;

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,ctx,eaddr,rw,access_type,ret","env:-0.00367581844329834,ctx:-0.0007131695747375488,eaddr:-0.001090705394744873,rw:-0.0006302595138549805,access_type:-5.233287811279297e-05,ret:-0.0026589035987854004,",2,25,0,"access_type:accesstypeaddress,rw:wh,",0,Greedy,208,0.08289710680643718,replace,[]
213,"static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",190,"static void vc1_inv_trans_8x4_dc_c(uint8_t *shape, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        shape[0] = cm[shape[0]];

        shape[1] = cm[shape[1]];

        shape[2] = cm[shape[2]];

        shape[3] = cm[shape[3]];

        shape[4] = cm[shape[4]];

        shape[5] = cm[shape[5]];

        shape[6] = cm[shape[6]];

        shape[7] = cm[shape[7]];

        shape += linesize;

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"dest,linesize,block,i,cm","dest:0.0015377998352050781,linesize:0.0007567405700683594,block:0.00016421079635620117,i:2.562999725341797e-05,cm:0.0003750324249267578,",1,18,0,"dest:shape,",0,Greedy,123,0.04470991293589274,replace,[]
214,"unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,

				 unsigned long offset)

{

    const unsigned long *p = addr + BITOP_WORD(offset);

    unsigned long result = offset & ~(BITS_PER_LONG-1);

    unsigned long tmp;



    if (offset >= size) {

        return size;

    }

    size -= result;

    offset %= BITS_PER_LONG;

    if (offset) {

        tmp = *(p++);

        tmp |= ~0UL >> (BITS_PER_LONG - offset);

        if (size < BITS_PER_LONG) {

            goto found_first;

        }

        if (~tmp) {

            goto found_middle;

        }

        size -= BITS_PER_LONG;

        result += BITS_PER_LONG;

    }

    while (size & ~(BITS_PER_LONG-1)) {

        if (~(tmp = *(p++))) {

            goto found_middle;

        }

        result += BITS_PER_LONG;

        size -= BITS_PER_LONG;

    }

    if (!size) {

        return result;

    }

    tmp = *p;



found_first:

    tmp |= ~0UL << size;

    if (tmp == ~0UL) {	/* Are any bits zero? */

        return result + size;	/* Nope. */

    }

found_middle:

    return result + ffz(tmp);

}
",233,"unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long area,

				 unsigned long offset)

{

    const unsigned long *p = addr + BITOP_WORD(offset);

    unsigned long result = offset & ~(BITS_PER_LONG-1);

    unsigned long tmp;



    if (offset >= area) {

        return area;

    }

    area -= result;

    offset %= BITS_PER_LONG;

    if (offset) {

        tmp = *(p++);

        tmp |= ~0UL >> (BITS_PER_LONG - offset);

        if (area < BITS_PER_LONG) {

            goto found_first;

        }

        if (~tmp) {

            goto found_middle;

        }

        area -= BITS_PER_LONG;

        result += BITS_PER_LONG;

    }

    while (area & ~(BITS_PER_LONG-1)) {

        if (~(tmp = *(p++))) {

            goto found_middle;

        }

        result += BITS_PER_LONG;

        area -= BITS_PER_LONG;

    }

    if (!size) {

        return result;

    }

    tmp = *p;



found_first:

    tmp |= ~0UL << area;

    if (tmp == ~0UL) {	/* Are any bits zero? */

        return result + area;	/* Nope. */

    }

found_middle:

    return result + ffz(tmp);

}
",LABEL_1,LABEL_1,LABEL_0,1,"addr,size,offset,p,tmp","addr:2.1457672119140625e-06,size:0.000316619873046875,offset:0.00021648406982421875,p:0.0001348257064819336,tmp:0.0002619028091430664,",1,10,0,"size:area,",0,Greedy,116,0.04291226466496786,replace,[]
215,"static const QObject *qmp_input_get_object(QmpInputVisitor *qiv,

                                           const char *name)

{

    const QObject *qobj;



    if (qiv->nb_stack == 0) {

        qobj = qiv->obj;

    } else {

        qobj = qiv->stack[qiv->nb_stack - 1].obj;

    }



    if (name && qobject_type(qobj) == QTYPE_QDICT) {

        return qdict_get(qobject_to_qdict(qobj), name);

    } else if (qiv->nb_stack > 0 && qobject_type(qobj) == QTYPE_QLIST) {

        return qlist_entry_obj(qiv->stack[qiv->nb_stack - 1].entry);

    }



    return qobj;

}
",127,,LABEL_1,LABEL_0,,-4,"qiv,name,qobj",,,,0,,0,Greedy,1,0.0004971067110697429,,
216,"static void do_log(int argc, const char **argv)

{

    int mask;

    

    if (argc != 2)

        goto help;

    if (!strcmp(argv[1], ""none"")) {

        mask = 0;

    } else {

        mask = cpu_str_to_log_mask(argv[1]);

        if (!mask) {

        help:

            help_cmd(argv[0]);

            return;

        }

    }

    cpu_set_log(mask);

}
",82,"static void do_log(int argc, const char **opp)

{

    int pixel;

    

    if (argc != 2)

        goto help;

    if (!strcmp(opp[1], ""none"")) {

        pixel = 0;

    } else {

        pixel = cpu_str_to_log_mask(opp[1]);

        if (!mask) {

        help:

            help_cmd(opp[0]);

            return;

        }

    }

    cpu_set_log(pixel);

}
",LABEL_0,LABEL_0,LABEL_1,1,"argc,argv,mask","argc:0.0001170039176940918,argv:0.00021708011627197266,mask:0.00017273426055908203,",2,8,0,"argv:opp,mask:pixel,",0,Greedy,97,0.03443236351013183,replace,[]
217,"static int h264_decode_frame(AVCodecContext *avctx, void *data,

                             int *got_frame, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size       = avpkt->size;

    H264Context *h     = avctx->priv_data;

    AVFrame *pict      = data;

    int buf_index      = 0;

    int ret;

    const uint8_t *new_extradata;

    int new_extradata_size;



    h->flags = avctx->flags;

    h->setup_finished = 0;



    /* end of stream, output what is still in the buffers */

out:

    if (buf_size == 0) {

        H264Picture *out;

        int i, out_idx;



        h->cur_pic_ptr = NULL;



        // FIXME factorize this with the output code below

        out     = h->delayed_pic[0];

        out_idx = 0;

        for (i = 1;

             h->delayed_pic[i] &&

             !h->delayed_pic[i]->f->key_frame &&

             !h->delayed_pic[i]->mmco_reset;

             i++)

            if (h->delayed_pic[i]->poc < out->poc) {

                out     = h->delayed_pic[i];

                out_idx = i;

            }



        for (i = out_idx; h->delayed_pic[i]; i++)

            h->delayed_pic[i] = h->delayed_pic[i + 1];



        if (out) {

            ret = output_frame(h, pict, out->f);

            if (ret < 0)

                return ret;

            *got_frame = 1;

        }



        return buf_index;

    }



    new_extradata_size = 0;

    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,

                                            &new_extradata_size);

    if (new_extradata_size > 0 && new_extradata) {

        ret = ff_h264_decode_extradata(new_extradata, new_extradata_size,

                                       &h->ps, &h->is_avc, &h->nal_length_size,

                                       avctx->err_recognition, avctx);

        if (ret < 0)

            return ret;

    }



    buf_index = decode_nal_units(h, buf, buf_size);

    if (buf_index < 0)

        return AVERROR_INVALIDDATA;



    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {

        buf_size = 0;

        goto out;

    }



    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {

        if (avctx->skip_frame >= AVDISCARD_NONREF)

            return 0;

        av_log(avctx, AV_LOG_ERROR, ""no frame!\n"");

        return AVERROR_INVALIDDATA;

    }



    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||

        (h->mb_y >= h->mb_height && h->mb_height)) {

        if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)

            decode_postinit(h, 1);



        ff_h264_field_end(h, &h->slice_ctx[0], 0);



        *got_frame = 0;

        if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) ||

                                   h->next_output_pic->recovered)) {

            if (!h->next_output_pic->recovered)

                h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT;



            ret = output_frame(h, pict, h->next_output_pic->f);

            if (ret < 0)

                return ret;

            *got_frame = 1;

        }

    }



    assert(pict->buf[0] || !*got_frame);



    return get_consumed_bytes(buf_index, buf_size);

}
",640,"static int h264_decode_frame(AVCodecContext *avctx, void *memory,

                             int *gotqiframe, AVPacket *avpkt)

{

    const uint8_t *Buffer = avpkt->memory;

    int buf_size       = avpkt->size;

    H264Context *oh     = avctx->priv_data;

    AVFrame *pict      = memory;

    int buf_index      = 0;

    int ret;

    const uint8_t *new_externalradoint;

    int new_extradata_capacity;



    oh->flags = avctx->flags;

    oh->setup_finished = 0;



    /* end of stream, output what is still in the buffers */

out:

    if (buf_size == 0) {

        H264Picture *out;

        int di, out_idx;



        oh->cur_pic_ptr = NULL;



        // FIXME factorize this with the output code below

        out     = oh->delayed_pic[0];

        out_idx = 0;

        for (di = 1;

             oh->delayed_pic[di] &&

             !h->delayed_pic[di]->f->key_frame &&

             !h->delayed_pic[di]->mmco_reset;

             di++)

            if (oh->delayed_pic[di]->poc < out->poc) {

                out     = oh->delayed_pic[di];

                out_idx = di;

            }



        for (di = out_idx; oh->delayed_pic[di]; di++)

            oh->delayed_pic[di] = oh->delayed_pic[di + 1];



        if (out) {

            ret = output_frame(oh, pict, out->f);

            if (ret < 0)

                return ret;

            *gotqiframe = 1;

        }



        return buf_index;

    }



    new_extradata_capacity = 0;

    new_externalradoint = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,

                                            &new_extradata_capacity);

    if (new_extradata_capacity > 0 && new_externalradoint) {

        ret = ff_h264_decode_extradata(new_externalradoint, new_extradata_capacity,

                                       &oh->ps, &oh->is_avc, &oh->nal_length_size,

                                       avctx->err_recognition, avctx);

        if (ret < 0)

            return ret;

    }



    buf_index = decode_nal_units(oh, Buffer, buf_size);

    if (buf_index < 0)

        return AVERROR_INVALIDDATA;



    if (!h->cur_pic_ptr && oh->nal_unit_type == NAL_END_SEQUENCE) {

        buf_size = 0;

        goto out;

    }



    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {

        if (avctx->skip_frame >= AVDISCARD_NONREF)

            return 0;

        av_log(avctx, AV_LOG_ERROR, ""no frame!
"");

        return AVERROR_INVALIDDATA;

    }



    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||

        (oh->mb_y >= oh->mb_height && oh->mb_height)) {

        if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)

            decode_postinit(oh, 1);



        ff_h264_field_end(oh, &oh->slice_ctx[0], 0);



        *gotqiframe = 0;

        if (oh->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) ||

                                   oh->next_output_pic->recovered)) {

            if (!h->next_output_pic->recovered)

                oh->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT;



            ret = output_frame(oh, pict, oh->next_output_pic->f);

            if (ret < 0)

                return ret;

            *gotqiframe = 1;

        }

    }



    assert(pict->Buffer[0] || !*gotqiframe);



    return get_consumed_bytes(buf_index, buf_size);

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,data,got_frame,avpkt,buf,h,pict,ret,new_extradata,new_extradata_size,out,i,out_idx","avctx:-9.429454803466797e-05,data:2.6106834411621094e-05,got_frame:4.494190216064453e-05,avpkt:-1.2278556823730469e-05,buf:2.3603439331054688e-05,h:0.00014448165893554688,pict:1.9073486328125e-06,ret:-5.6624412536621094e-05,new_extradata:9.250640869140625e-05,new_extradata_size:6.449222564697266e-05,out:2.1576881408691406e-05,i:6.54458999633789e-05,out_idx:2.0623207092285156e-05,",7,62,0,"h:oh,new_extradata:new_externalradoint,i:di,new_extradata_size:new_extradata_capacity,got_frame:gotqiframe,data:memory,buf:Buffer,",0,Greedy,426,0.18148374557495117,replace,[]
218,"static int add_candidate_ref(HEVCContext *s, RefPicList *list,

                             int poc, int ref_flag)

{

    HEVCFrame *ref = find_ref_idx(s, poc);



    if (ref == s->ref)

        return AVERROR_INVALIDDATA;



    if (!ref) {

        ref = generate_missing_ref(s, poc);

        if (!ref)

            return AVERROR(ENOMEM);

    }



    list->list[list->nb_refs] = ref->poc;

    list->ref[list->nb_refs]  = ref;

    list->nb_refs++;



    mark_ref(ref, ref_flag);

    return 0;

}
",116,,LABEL_1,LABEL_0,,-4,"s,list,poc,ref_flag,ref,nb_refs",,,,0,,0,Greedy,1,0.00048798720041910807,,
219,"static int end_frame(AVFilterLink *inlink)

{

    AVFilterContext    *ctx = inlink->dst;

    FPSContext           *s = ctx->priv;

    AVFilterLink   *outlink = ctx->outputs[0];

    AVFilterBufferRef  *buf = inlink->cur_buf;

    int64_t delta;

    int i, ret;



    inlink->cur_buf = NULL;

    s->frames_in++;

    /* discard frames until we get the first timestamp */

    if (s->pts == AV_NOPTS_VALUE) {

        if (buf->pts != AV_NOPTS_VALUE) {

            write_to_fifo(s->fifo, buf);

            s->first_pts = s->pts = buf->pts;

        } else {

            av_log(ctx, AV_LOG_WARNING, ""Discarding initial frame(s) with no ""

                   ""timestamp.\n"");

            avfilter_unref_buffer(buf);

            s->drop++;

        }

        return 0;

    }



    /* now wait for the next timestamp */

    if (buf->pts == AV_NOPTS_VALUE) {

        return write_to_fifo(s->fifo, buf);

    }



    /* number of output frames */

    delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,

                         outlink->time_base);



    if (delta < 1) {

        /* drop the frame and everything buffered except the first */

        AVFilterBufferRef *tmp;

        int drop = av_fifo_size(s->fifo)/sizeof(AVFilterBufferRef*);



        av_log(ctx, AV_LOG_DEBUG, ""Dropping %d frame(s).\n"", drop);

        s->drop += drop;



        av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);

        flush_fifo(s->fifo);

        ret = write_to_fifo(s->fifo, tmp);



        avfilter_unref_buffer(buf);

        return ret;

    }



    /* can output >= 1 frames */

    for (i = 0; i < delta; i++) {

        AVFilterBufferRef *buf_out;

        av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);



        /* duplicate the frame if needed */

        if (!av_fifo_size(s->fifo) && i < delta - 1) {

            av_log(ctx, AV_LOG_DEBUG, ""Duplicating frame.\n"");

            write_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, AV_PERM_READ));

            s->dup++;

        }



        buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,

                                    outlink->time_base) + s->frames_out;



        if ((ret = ff_start_frame(outlink, buf_out)) < 0 ||

            (ret = ff_draw_slice(outlink, 0, outlink->h, 1)) < 0 ||

            (ret = ff_end_frame(outlink)) < 0) {

            avfilter_unref_bufferp(&buf);

            return ret;

        }



        s->frames_out++;

    }

    flush_fifo(s->fifo);



    ret = write_to_fifo(s->fifo, buf);

    s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);



    return ret;

}
",595,"static int end_frame(AVFilterLink *inlink)

{

    AVFilterContext    *ctx = inlink->dst;

    FPSContext           *s = ctx->priv;

    AVFilterLink   *outlink = ctx->outputs[0];

    AVFilterBufferRef  *buf = inlink->cur_buf;

    int64_t nance;

    int ri, rb;



    inlink->cur_buf = NULL;

    s->frames_in++;

    /* discard frames until we get the first timestamp */

    if (s->pts == AV_NOPTS_VALUE) {

        if (buf->pts != AV_NOPTS_VALUE) {

            write_to_fifo(s->fifo, buf);

            s->first_pts = s->pts = buf->pts;

        } else {

            av_log(ctx, AV_LOG_WARNING, ""Discarding initial frame(s) with no ""

                   ""timestamp.
"");

            avfilter_unref_buffer(buf);

            s->col++;

        }

        return 0;

    }



    /* now wait for the next timestamp */

    if (buf->pts == AV_NOPTS_VALUE) {

        return write_to_fifo(s->fifo, buf);

    }



    /* number of output frames */

    nance = av_rescale_q(buf->pts - s->pts, inlink->time_base,

                         outlink->time_base);



    if (nance < 1) {

        /* col the frame and everything buffered except the first */

        AVFilterBufferRef *tmp;

        int col = av_fifo_size(s->fifo)/sizeof(AVFilterBufferRef*);



        av_log(ctx, AV_LOG_DEBUG, ""Dropping %d frame(s).
"", col);

        s->col += col;



        av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);

        flush_fifo(s->fifo);

        rb = write_to_fifo(s->fifo, tmp);



        avfilter_unref_buffer(buf);

        return rb;

    }



    /* can output >= 1 frames */

    for (ri = 0; ri < nance; ri++) {

        AVFilterBufferRef *buf_out;

        av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);



        /* duplicate the frame if needed */

        if (!av_fifo_size(s->fifo) && ri < nance - 1) {

            av_log(ctx, AV_LOG_DEBUG, ""Duplicating frame.
"");

            write_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, AV_PERM_READ));

            s->dup++;

        }



        buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,

                                    outlink->time_base) + s->frames_out;



        if ((rb = ff_start_frame(outlink, buf_out)) < 0 ||

            (rb = ff_draw_slice(outlink, 0, outlink->h, 1)) < 0 ||

            (rb = ff_end_frame(outlink)) < 0) {

            avfilter_unref_bufferp(&buf);

            return rb;

        }



        s->frames_out++;

    }

    flush_fifo(s->fifo);



    rb = write_to_fifo(s->fifo, buf);

    s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);



    return rb;

}
",LABEL_0,LABEL_0,LABEL_1,1,"inlink,ctx,s,outlink,buf,delta,i,ret,frames_in,drop,tmp,buf_out","inlink:-0.0003128647804260254,ctx:-0.0002523064613342285,s:-1.2695789337158203e-05,outlink:-0.00031810998916625977,buf:-0.00011801719665527344,delta:7.414817810058594e-05,i:6.949901580810547e-05,ret:0.0001118779182434082,frames_in:1.2159347534179688e-05,drop:3.081560134887695e-05,tmp:4.5299530029296875e-06,buf_out:0.0001404881477355957,",4,25,0,"buf_out:buf_out,ret:rb,delta:nance,i:ri,drop:col,",0,Greedy,360,0.15003251632054646,replace,[]
220,"static void pci_basic(gconstpointer data)

{

    QVirtioPCIDevice *dev;

    QPCIBus *bus;

    QVirtQueuePCI *tx, *rx;

    QGuestAllocator *alloc;

    void (*func) (const QVirtioBus *bus,

                  QVirtioDevice *dev,

                  QGuestAllocator *alloc,

                  QVirtQueue *rvq,

                  QVirtQueue *tvq,

                  int socket) = data;

    int sv[2], ret;



    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);

    g_assert_cmpint(ret, !=, -1);



    bus = pci_test_start(sv[1]);

    dev = virtio_net_pci_init(bus, PCI_SLOT);



    alloc = pc_alloc_init();

    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,

                                           alloc, 0);

    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,

                                           alloc, 1);



    driver_init(&qvirtio_pci, &dev->vdev);

    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);



    /* End test */

    close(sv[0]);

    guest_free(alloc, tx->vq.desc);

    pc_alloc_uninit(alloc);

    qvirtio_pci_device_disable(dev);

    g_free(dev);

    qpci_free_pc(bus);

    test_end();

}
",256,"static void pci_basic(gconstpointer info)

{

    QVirtioPCIDevice *dev;

    QPCIBus *bus;

    QVirtQueuePCI *tx, *rx;

    QGuestAllocator *alloc;

    void (*func) (const QVirtioBus *bus,

                  QVirtioDevice *dev,

                  QGuestAllocator *alloc,

                  QVirtQueue *rvq,

                  QVirtQueue *tvq,

                  int socket) = info;

    int sv[2], ret;



    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);

    g_assert_cmpint(ret, !=, -1);



    bus = pci_test_start(sv[1]);

    dev = virtio_net_pci_init(bus, PCI_SLOT);



    alloc = pc_alloc_init();

    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,

                                           alloc, 0);

    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,

                                           alloc, 1);



    driver_init(&qvirtio_pci, &dev->vdev);

    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);



    /* End test */

    close(sv[0]);

    guest_free(alloc, tx->vq.desc);

    pc_alloc_uninit(alloc);

    qvirtio_pci_device_disable(dev);

    g_free(dev);

    qpci_free_pc(bus);

    test_end();

}
",LABEL_1,LABEL_1,LABEL_0,1,"data,dev,bus,tx,rx,alloc,func,rvq,tvq,socket,sv,ret","data:1.8715858459472656e-05,dev:-7.271766662597656e-06,bus:-2.8252601623535156e-05,tx:1.1205673217773438e-05,rx:3.5762786865234375e-07,alloc:-3.933906555175781e-06,func:-3.647804260253906e-05,rvq:6.556510925292969e-06,tvq:-7.271766662597656e-06,socket:9.5367431640625e-06,sv:-8.344650268554688e-06,ret:-3.063678741455078e-05,",1,2,0,"data:info,",0,Greedy,86,0.031510297457377115,replace,[]
221,"static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)

{

    const struct cow_header_v2 *cow_header = (const void *)buf;



    if (buf_size >= sizeof(struct cow_header_v2) &&

        be32_to_cpu(cow_header->magic) == COW_MAGIC &&

        be32_to_cpu(cow_header->version) == COW_VERSION)

        return 100;

    else

        return 0;

}
",71,,LABEL_0,LABEL_0,LABEL_0,-1,"buf,buf_size,filename,cow_header",,4,8,0,,0,GA,823,0.2917919238408407,failed,[]
222,"int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;

    int ret;



    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    ret = bdrv_check_request(bs, sector_num, nb_sectors);

    if (ret < 0) {

        return ret;

    }



    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);

}
",108,"int bdrv_write_compressed(BlockDriverState *bas, int64_t  sector_Num,

                          const uint8_t *rb, int nb_serkers)

{

    BlockDriver *hrV = bas->hrV;

    int val;



    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    val = bdrv_check_request(bas,  sector_Num, nb_serkers);

    if (val < 0) {

        return val;

    }



    assert(QLIST_EMPTY(&bas->dirty_bitmaps));



    return hrV->bdrv_write_compressed(bas,  sector_Num, rb, nb_serkers);

}
",LABEL_0,LABEL_0,LABEL_1,1,"bs,sector_num,buf,nb_sectors,drv,ret","bs:-0.0009147524833679199,sector_num:-0.0005711913108825684,buf:-0.00038886070251464844,nb_sectors:-0.00048023462295532227,drv:-0.0010776519775390625,ret:-0.0017188191413879395,",6,20,0,"buf:rb,nb_sectors:nb_serkers,sector_num: sector_Num,bs:bas,drv:hrV,ret:val,",0,Greedy,254,0.09089444478352865,replace,[]
223,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdevs;

    BusChild *kid;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        num++;

    }



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(qdev) * num);

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdevs[num++] = kid->child;

    }



    /* Sort the array */

    qsort(qdevs, num, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevs);



    return ret;

}
",246,"int spapr_populate_vdevice(VIOsPAPRBus *band, void *fdt)

{

    DeviceState *Qdiv, **qdevs;

    BusChild *kg;

    int index, num, ret = 0;



    /* Count qdevs on the band list */

    num = 0;

    QTAILQ_FOREACH(kg, &band->band.children, sibling) {

        num++;

    }



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(Qdiv) * num);

    num = 0;

    QTAILQ_FOREACH(kg, &band->band.children, sibling) {

        qdevs[num++] = kg->child;

    }



    /* Sort the array */

    qsort(qdevs, num, sizeof(Qdiv), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (index = num - 1; index >= 0; index--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[index]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevs);



    return ret;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bus,fdt,qdev,qdevs,kid,i,num,dev","bus:7.975101470947266e-05,fdt:7.641315460205078e-05,qdev:0.00010150671005249023,qdevs:1.5974044799804688e-05,kid:8.004903793334961e-05,i:0.00015223026275634766,num:6.699562072753906e-05,dev:6.67572021484375e-05,",4,18,0,"i:index,qdev:Qdiv,kid:kg,bus:band,",0,Greedy,249,0.093915327390035,replace,[]
224,"static av_cold void build_modpred(Indeo3DecodeContext *s)

{

  int i, j;



  s->ModPred = av_malloc(8 * 128);



  for (i=0; i < 128; ++i) {

    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));

    s->ModPred[i+1*128] = i ==   7 ?  20 :

                          i == 119 ||

                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));

    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));

    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));

    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));

    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));

    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));

    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));

  }



  s->corrector_type = av_malloc(24 * 256);



  for (i=0; i < 24; ++i) {

    for (j=0; j < 256; ++j) {

      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :

                                   j < 248 || (i == 16 && j == 248) ? 0 :

                                   corrector_type_2[j - 248];

    }

  }

}
",413,"static av_cold void build_modpred(Indeo3DecodeContext *south)

{

  int m, q;



  south->ModPred = av_malloc(8 * 128);



  for (m=0; m < 128; ++m) {

    south->ModPred[m+0*128] = m >  126 ? 254 : 2*(m + 1 - ((m + 1) % 2));

    south->ModPred[m+1*128] = m ==   7 ?  20 :

                          m == 119 ||

                          m == 120 ? 236 : 2*(m + 2 - ((m + 1) % 3));

    south->ModPred[m+2*128] = m >  125 ? 248 : 2*(m + 2 - ((m + 2) % 4));

    south->ModPred[m+3*128] =                  2*(m + 1 - ((m - 3) % 5));

    south->ModPred[m+4*128] = m ==   8 ?  20 : 2*(m + 1 - ((m - 3) % 6));

    south->ModPred[m+5*128] =                  2*(m + 4 - ((m + 3) % 7));

    south->ModPred[m+6*128] = m >  123 ? 240 : 2*(m + 4 - ((m + 4) % 8));

    south->ModPred[m+7*128] =                  2*(m + 5 - ((m + 4) % 9));

  }



  south->corrector_type = av_malloc(24 * 256);



  for (m=0; m < 24; ++m) {

    for (q=0; q < 256; ++q) {

      south->corrector_type[m*256+q] = q < corrector_type_0[m]          ? 1 :

                                   q < 248 || (m == 16 && q == 248) ? 0 :

                                   corrector_type_2[q - 248];

    }

  }

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,i,j","s:0.00018173456192016602,i:0.0009523630142211914,j:-0.0001513957977294922,",3,62,0,"i:m,s:south,j:q,",0,Greedy,269,0.1017197847366333,replace,[]
225,"static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,

        int *need_next_header, int *new_frame_start)

{

    GetBitContext bits;

    AACADTSHeaderInfo hdr;

    int size;

    union {

        uint64_t u64;

        uint8_t  u8[8];

    } tmp;



    tmp.u64 = av_be2ne64(state);

    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);



    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)

        return 0;

    *need_next_header = 0;

    *new_frame_start  = 1;

    hdr_info->sample_rate = hdr.sample_rate;

    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];

    hdr_info->samples     = hdr.samples;

    hdr_info->bit_rate    = hdr.bit_rate;

    return size;

}
",144,,LABEL_1,LABEL_0,,-4,"state,hdr_info,need_next_header,new_frame_start,bits,hdr,size,u8,tmp",,,,0,,0,Greedy,1,0.0005098303159077962,,
226,"void stq_be_phys(target_phys_addr_t addr, uint64_t val)

{

    val = cpu_to_be64(val);

    cpu_physical_memory_write(addr, &val, 8);

}
",30,,LABEL_0,LABEL_0,LABEL_0,-1,"addr,val",,2,6,0,,0,GA,467,0.16268688837687176,failed,[]
227,"static void gen_movl_seg_T0(DisasContext *s, int seg_reg)

{

    if (s->pe && !s->vm86) {

        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);

        /* abort translation because the addseg value may change or

           because ss32 may change. For R_SS, translation must always

           stop as a special handling must be done to disable hardware

           interrupts for the next instruction */

        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))

            s->is_jmp = DISAS_TB_JUMP;

    } else {

        gen_op_movl_seg_T0_vm(seg_reg);

        if (seg_reg == R_SS)

            s->is_jmp = DISAS_TB_JUMP;

    }

}
",131,,LABEL_0,LABEL_0,LABEL_0,-1,"s,seg_reg",,2,11,0,,0,GA,402,0.14807350238164266,failed,[]
228,"static int standard_decode_i_mbs(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    MpegEncContext *s = &v->s;

    int current_mb = 0; /* MB/Block Position info */

    uint8_t cbpcy[4], previous_cbpcy[4], predicted_cbpcy,

        *p_cbpcy /* Pointer to skip some math */;



    /* Reset CBPCY predictors */

    memset(v->previous_line_cbpcy, 0, s->mb_stride<<2);



    /* Select ttmb table depending on pq */

    if (v->pq < 5) v->ttmb_vlc = &vc9_ttmb_vlc[0];

    else if (v->pq < 13) v->ttmb_vlc = &vc9_ttmb_vlc[1];

    else v->ttmb_vlc = &vc9_ttmb_vlc[2];



    for (s->mb_y=0; s->mb_y<s->mb_height; s->mb_y++)

    {

        /* Init CBPCY for line */

        *((uint32_t*)previous_cbpcy) = 0x00000000;

        p_cbpcy = v->previous_line_cbpcy+4;



        for (s->mb_x=0; s->mb_x<s->mb_width; s->mb_x++, p_cbpcy += 4)

        {

            /* Get CBPCY */

            GET_CBPCY(ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS);



            s->ac_pred = get_bits(gb, 1);



            /* TODO: Decode blocks from that mb wrt cbpcy */



            /* Update for next block */

#if TRACE > 2

            av_log(s->avctx, AV_LOG_DEBUG, ""Block %4i: p_cbpcy=%i%i%i%i, previous_cbpcy=%i%i%i%i,""

                   "" cbpcy=%i%i%i%i\n"", current_mb,

                   p_cbpcy[0], p_cbpcy[1], p_cbpcy[2], p_cbpcy[3],

                   previous_cbpcy[0], previous_cbpcy[1], previous_cbpcy[2], previous_cbpcy[3],

                   cbpcy[0], cbpcy[1], cbpcy[2], cbpcy[3]);

#endif

            *((uint32_t*)p_cbpcy) = *((uint32_t*)previous_cbpcy);

            *((uint32_t*)previous_cbpcy) = *((uint32_t*)cbpcy);

            current_mb++;

        }

    }

    return 0;

}
",423,,LABEL_1,LABEL_0,,-4,"v,gb,s,cbpcy,previous_cbpcy,predicted_cbpcy,p_cbpcy,mb_y,mb_x,current_mb",,,,0,,0,Greedy,1,0.0006672104199727376,,
229,"static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,

                            const uint32_t *quant) {

    int coeff, i, n;

    int8_t ac;

    uint8_t dc = get_bits(gb, 8);



    // block not coded

    if (dc == 255)




    // number of non-zero coefficients

    coeff = get_bits(gb, 6);

    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)




    // normally we would only need to clear the (63 - coeff) last values,

    // but since we do not know where they are we just clear the whole block

    memset(block, 0, 64 * sizeof(DCTELEM));



    // 2 bits per coefficient

    while (coeff) {

        ac = get_sbits(gb, 2);

        if (ac == -2)

            break; // continue with more bits

        PUT_COEFF(ac);

    }



    // 4 bits per coefficient

    ALIGN(4);



    while (coeff) {

        ac = get_sbits(gb, 4);

        if (ac == -8)

            break; // continue with more bits

        PUT_COEFF(ac);

    }



    // 8 bits per coefficient

    ALIGN(8);

    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)


    while (coeff) {

        ac = get_sbits(gb, 8);

        PUT_COEFF(ac);

    }



    PUT_COEFF(dc);

    return 1;

}",275,,LABEL_1,LABEL_1,LABEL_1,-1,"gb,block,scan,quant,coeff,i,n,ac",,8,35,0,,0,GA,1357,0.525773549079895,failed,[]
230,"void *memory_region_get_ram_ptr(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;

    }



    assert(mr->terminates);



    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);

}
",54,"void *memory_region_get_ram_ptr(MemoryRegion *gr)

{

    if (gr->alias) {

        return memory_region_get_ram_ptr(gr->alias) + gr->alias_offset;

    }



    assert(gr->terminates);



    return qemu_get_ram_ptr(gr->ram_addr & TARGET_PAGE_MASK);

}
",LABEL_0,LABEL_0,LABEL_1,1,mr,"mr:-3.337860107421875e-05,",1,6,0,"mr:gr,",0,Greedy,60,0.021020098527272543,replace,[]
231,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",152,,LABEL_1,LABEL_0,,-4,"s,bin,st",,,,0,,0,Greedy,1,0.0005088686943054199,,
232,"static int alloc_refcount_block(BlockDriverState *bs,

    int64_t cluster_index, uint16_t **refcount_block)

{

    BDRVQcowState *s = bs->opaque;

    unsigned int refcount_table_index;

    int ret;



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);



    /* Find the refcount block for the given cluster */

    refcount_table_index = cluster_index >> s->refcount_block_bits;



    if (refcount_table_index < s->refcount_table_size) {



        uint64_t refcount_block_offset =

            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;



        /* If it's already there, we're done */

        if (refcount_block_offset) {

            if (offset_into_cluster(s, refcount_block_offset)) {

                qcow2_signal_corruption(bs, true, -1, -1, ""Refblock offset %#""

                                        PRIx64 "" unaligned (reftable index: ""

                                        ""%#x)"", refcount_block_offset,

                                        refcount_table_index);

                return -EIO;

            }



             return load_refcount_block(bs, refcount_block_offset,

                 (void**) refcount_block);

        }

    }



    /*

     * If we came here, we need to allocate something. Something is at least

     * a cluster for the new refcount block. It may also include a new refcount

     * table if the old refcount table is too small.

     *

     * Note that allocating clusters here needs some special care:

     *

     * - We can't use the normal qcow2_alloc_clusters(), it would try to

     *   increase the refcount and very likely we would end up with an endless

     *   recursion. Instead we must place the refcount blocks in a way that

     *   they can describe them themselves.

     *

     * - We need to consider that at this point we are inside update_refcounts

     *   and potentially doing an initial refcount increase. This means that

     *   some clusters have already been allocated by the caller, but their

     *   refcount isn't accurate yet. If we allocate clusters for metadata, we

     *   need to return -EAGAIN to signal the caller that it needs to restart

     *   the search for free clusters.

     *

     * - alloc_clusters_noref and qcow2_free_clusters may load a different

     *   refcount block into the cache

     */



    *refcount_block = NULL;



    /* We write to the refcount table, so we might depend on L2 tables */

    ret = qcow2_cache_flush(bs, s->l2_table_cache);

    if (ret < 0) {

        return ret;

    }



    /* Allocate the refcount block itself and mark it as used */

    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);

    if (new_block < 0) {

        return new_block;

    }



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Allocate refcount block %d for %"" PRIx64

        "" at %"" PRIx64 ""\n"",

        refcount_table_index, cluster_index << s->cluster_bits, new_block);

#endif



    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {

        /* Zero the new refcount block before updating it */

        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, s->cluster_size);



        /* The block describes itself, need to update the cache */

        int block_index = (new_block >> s->cluster_bits) &

            (s->refcount_block_size - 1);

        (*refcount_block)[block_index] = cpu_to_be16(1);

    } else {

        /* Described somewhere else. This can recurse at most twice before we

         * arrive at a block that describes itself. */

        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,

                              QCOW2_DISCARD_NEVER);

        if (ret < 0) {

            goto fail_block;

        }



        ret = qcow2_cache_flush(bs, s->refcount_block_cache);

        if (ret < 0) {

            goto fail_block;

        }



        /* Initialize the new refcount block only after updating its refcount,

         * update_refcount uses the refcount cache itself */

        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, s->cluster_size);

    }



    /* Now the new refcount block needs to be written to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);

    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);

    ret = qcow2_cache_flush(bs, s->refcount_block_cache);

    if (ret < 0) {

        goto fail_block;

    }



    /* If the refcount table is big enough, just hook the block up there */

    if (refcount_table_index < s->refcount_table_size) {

        uint64_t data64 = cpu_to_be64(new_block);

        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);

        ret = bdrv_pwrite_sync(bs->file,

            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),

            &data64, sizeof(data64));

        if (ret < 0) {

            goto fail_block;

        }



        s->refcount_table[refcount_table_index] = new_block;



        /* The new refcount block may be where the caller intended to put its

         * data, so let it restart the search. */

        return -EAGAIN;

    }



    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);

    if (ret < 0) {

        goto fail_block;

    }



    /*

     * If we come here, we need to grow the refcount table. Again, a new

     * refcount table needs some space and we can't simply allocate to avoid

     * endless recursion.

     *

     * Therefore let's grab new refcount blocks at the end of the image, which

     * will describe themselves and the new refcount table. This way we can

     * reference them only in the new table and do the switch to the new

     * refcount table at once without producing an inconsistent state in

     * between.

     */

    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);



    /* Calculate the number of refcount blocks needed so far */

    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size);



    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {

        return -EFBIG;

    }



    /* And now we need at least one block more for the new metadata */

    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);

    uint64_t last_table_size;

    uint64_t blocks_clusters;

    do {

        uint64_t table_clusters =

            size_to_clusters(s, table_size * sizeof(uint64_t));

        blocks_clusters = 1 +

            ((table_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size);

        uint64_t meta_clusters = table_clusters + blocks_clusters;



        last_table_size = table_size;

        table_size = next_refcount_table_size(s, blocks_used +

            ((meta_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size));



    } while (last_table_size != table_size);



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Grow refcount table %"" PRId32 "" => %"" PRId64 ""\n"",

        s->refcount_table_size, table_size);

#endif



    /* Create the new refcount table and blocks */

    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *

        s->cluster_size;

    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;

    uint64_t *new_table = g_try_new0(uint64_t, table_size);

    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);



    assert(table_size > 0 && blocks_clusters > 0);

    if (new_table == NULL || new_blocks == NULL) {

        ret = -ENOMEM;

        goto fail_table;

    }



    /* Fill the new refcount table */

    memcpy(new_table, s->refcount_table,

        s->refcount_table_size * sizeof(uint64_t));

    new_table[refcount_table_index] = new_block;



    int i;

    for (i = 0; i < blocks_clusters; i++) {

        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);

    }



    /* Fill the refcount blocks */

    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));

    int block = 0;

    for (i = 0; i < table_clusters + blocks_clusters; i++) {

        new_blocks[block++] = cpu_to_be16(1);

    }



    /* Write refcount blocks to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);

    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,

        blocks_clusters * s->cluster_size);

    g_free(new_blocks);

    new_blocks = NULL;

    if (ret < 0) {

        goto fail_table;

    }



    /* Write refcount table to disk */

    for(i = 0; i < table_size; i++) {

        cpu_to_be64s(&new_table[i]);

    }



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);

    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,

        table_size * sizeof(uint64_t));

    if (ret < 0) {

        goto fail_table;

    }



    for(i = 0; i < table_size; i++) {

        be64_to_cpus(&new_table[i]);

    }



    /* Hook up the new refcount table in the qcow2 header */

    uint8_t data[12];

    cpu_to_be64w((uint64_t*)data, table_offset);

    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);

    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),

        data, sizeof(data));

    if (ret < 0) {

        goto fail_table;

    }



    /* And switch it in memory */

    uint64_t old_table_offset = s->refcount_table_offset;

    uint64_t old_table_size = s->refcount_table_size;



    g_free(s->refcount_table);

    s->refcount_table = new_table;

    s->refcount_table_size = table_size;

    s->refcount_table_offset = table_offset;



    /* Free old table. */

    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),

                        QCOW2_DISCARD_OTHER);



    ret = load_refcount_block(bs, new_block, (void**) refcount_block);

    if (ret < 0) {

        return ret;

    }



    /* If we were trying to do the initial refcount update for some cluster

     * allocation, we might have used the same clusters to store newly

     * allocated metadata. Make the caller search some new space. */

    return -EAGAIN;



fail_table:

    g_free(new_blocks);

    g_free(new_table);

fail_block:

    if (*refcount_block != NULL) {

        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);

    }

    return ret;

}
",1922,,LABEL_1,LABEL_0,,-4,"bs,cluster_index,refcount_block,s,refcount_table_index,ret",,,,0,,0,Greedy,1,0.0016111016273498535,,
233,"static inline bool handler_is_async(const mon_cmd_t *cmd)

{

    return cmd->flags & MONITOR_CMD_ASYNC;

}
",19,"static inline bool handler_is_async(const mon_cmd_t *ctx)

{

    return ctx->flags & MONITOR_CMD_ASYNC;

}
",LABEL_1,LABEL_1,LABEL_0,1,cmd,"cmd:0.0002983212471008301,",1,2,0,"cmd:ctx,",0,Greedy,42,0.014724298318227132,replace,[]
234,"static int process_input_packet(InputStream *ist, const AVPacket *pkt)

{

    int i;

    int got_output;

    AVPacket avpkt;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if (pkt->dts != AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {

        int ret = 0;

    handle_eof:



        ist->last_dts = ist->next_dts;



        if (avpkt.size && avpkt.size != pkt->size &&

            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d\n"", pkt->stream_index);

            ist->showed_multi_packet_warning = 1;

        }



        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (ist, &avpkt, &got_output);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (ist, &avpkt, &got_output);

            if (avpkt.duration)

                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);

            else if (ist->st->avg_frame_rate.num)

                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),

                                              AV_TIME_BASE_Q);

            else if (ist->dec_ctx->time_base.num != 0) {

                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :

                                                   ist->dec_ctx->ticks_per_frame;

                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(ist, &avpkt, &got_output);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;

        // touch data and size only if not EOF

        if (pkt) {

            avpkt.data += ret;

            avpkt.size -= ret;

        }

        if (!got_output) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        ist->last_dts = ist->next_dts;

        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /

                             ist->dec_ctx->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (ist->dec_ctx->time_base.num != 0) {

                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;

                ist->next_dts += ((int64_t)AV_TIME_BASE *

                                  ist->dec_ctx->time_base.num * ticks) /

                                  ist->dec_ctx->time_base.den;

            }

            break;

        }

    }

    for (i = 0; pkt && i < nb_output_streams; i++) {

        OutputStream *ost = output_streams[i];



        if (!check_output_constraints(ist, ost) || ost->encoding_needed)

            continue;



        do_streamcopy(ist, ost, pkt);

    }



    return 0;

}
",716,,LABEL_0,LABEL_0,LABEL_0,-1,"ist,pkt,i,got_output,avpkt",,5,78,0,,0,GA,1310,0.6053991675376892,failed,[]
235,"static void end_last_frame(AVFilterContext *ctx)

{

    TileContext *tile    = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    AVFilterBufferRef *out_buf = outlink->out_buf;



    outlink->out_buf = NULL;

    ff_start_frame(outlink, out_buf);

    while (tile->current < tile->nb_frames)

        draw_blank_frame(ctx, out_buf);

    ff_draw_slice(outlink, 0, out_buf->video->h, 1);

    ff_end_frame(outlink);

    tile->current = 0;

}
",102,"static void end_last_frame(AVFilterContext *ctx)

{

    TileContext *task    = ctx->priv;

    AVFilterLink *uplike = ctx->outputs[0];

    AVFilterBufferRef *out_buf = uplike->out_buf;



    uplike->out_buf = NULL;

    ff_start_frame(uplike, out_buf);

    while (task->current < task->nb_frames)

        draw_blank_frame(ctx, out_buf);

    ff_draw_slice(uplike, 0, out_buf->video->h, 1);

    ff_end_frame(uplike);

    task->current = 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"ctx,tile,outlink,out_buf","ctx:0.0009710192680358887,tile:0.0013424158096313477,outlink:0.001223146915435791,out_buf:-0.00037723779678344727,",2,10,0,"tile:task,outlink:uplike,",0,Greedy,151,0.0533623735109965,replace,[]
236,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
",90,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *device = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    device->desc = ""PReP Host Bridge - Motorola Raven"";

    device->vmsd = &vmstate_raven;

    device->no_user = 1;

}
",LABEL_1,LABEL_1,LABEL_0,1,"klass,data,k,dc","klass:-1.895427703857422e-05,data:-1.0132789611816406e-05,k:-7.152557373046875e-05,dc:9.375810623168945e-05,",1,4,0,"dc:device,",0,Greedy,54,0.019287502765655516,replace,[]
237,"static inline void h264_deblock_q1(register vector unsigned char p0,

                                                   register vector unsigned char p1,

                                                   register vector unsigned char p2,

                                                   register vector unsigned char q0,

                                                   register vector unsigned char tc0) {



    register vector unsigned char average = vec_avg(p0, q0);

    register vector unsigned char temp;

    register vector unsigned char uncliped;

    register vector unsigned char ones;

    register vector unsigned char max;

    register vector unsigned char min;



    temp = vec_xor(average, p2);

    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */

    ones = vec_splat_u8(1);

    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */

    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */

    max = vec_adds(p1, tc0);

    min = vec_subs(p1, tc0);

    p1 = vec_max(min, uncliped);

    p1 = vec_min(max, p1);

}
",212,"static inline void h264_deblock_q1(register vector unsigned char p0,

                                                   register vector unsigned char p1,

                                                   register vector unsigned char p2,

                                                   register vector unsigned char q0,

                                                   register vector unsigned char tc0) {



    register vector unsigned char average = vec_avg(p0, q0);

    register vector unsigned char Temp;

    register vector unsigned char uninclipd;

    register vector unsigned char tones;

    register vector unsigned char height;

    register vector unsigned char min;



    Temp = vec_xor(average, p2);

    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */

    tones = vec_splat_u8(1);

    Temp = vec_and(Temp, tones);         /*(p2^avg(p0, q0)) & 1 */

    uninclipd = vec_subs(average, Temp); /*(p2+((p0+q0+1)>>1))>>1 */

    height = vec_adds(p1, tc0);

    min = vec_subs(p1, tc0);

    p1 = vec_max(min, uninclipd);

    p1 = vec_min(height, p1);

}
",LABEL_0,LABEL_0,LABEL_1,1,"p0,temp,uncliped,ones,max,min","p0:1.9073486328125e-06,temp:4.088878631591797e-05,uncliped:8.034706115722656e-05,ones:3.826618194580078e-05,max:4.100799560546875e-05,min:1.2278556823730469e-05,",4,14,0,"uncliped:uninclipd,max:height,temp:Temp,ones:tones,",0,Greedy,250,0.09109196662902833,replace,[]
238,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    float aspect;



    init_get_bits(&s->gb, buf, buf_size);



    width = get_bits(&s->gb, 12);

    height = get_bits(&s->gb, 12);

    s->aspect_ratio_info= get_bits(&s->gb, 4);

    if(!s->mpeg2){

        aspect= mpeg1_aspect[s->aspect_ratio_info];

        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);

    }



    s->frame_rate_index = get_bits(&s->gb, 4);

    if (s->frame_rate_index == 0)

        return -1;

    s->bit_rate = get_bits(&s->gb, 18) * 400;

    if (get_bits1(&s->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != s->width ||

        height != s->height) {

        /* start new mpeg1 context decoding */

        s->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(s);

        }

        s->width = width;

        s->height = height;

        avctx->has_b_frames= 1;

        s->avctx = avctx;

        avctx->width = width;

        avctx->height = height;

        if (s->frame_rate_index >= 9) {

            /* at least give a valid frame rate (some old mpeg1 have this) */

            avctx->frame_rate = 25 * FRAME_RATE_BASE;

        } else {

            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];

        }

        s->frame_rate = avctx->frame_rate;

        avctx->bit_rate = s->bit_rate;

        

        if (MPV_common_init(s) < 0)

            return -1;

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&s->gb, 10); /* vbv_buffer_size */

    skip_bits(&s->gb, 1);



    /* get matrix */

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->intra_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_intra_matrix[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

    }

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->inter_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_non_intra_matrix[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    s->progressive_sequence = 1;

    s->progressive_frame = 1;

    s->picture_structure = PICT_FRAME;

    s->frame_pred_frame_dct = 1;

    s->mpeg2 = 0;

    avctx->sub_id = 1; /* indicates mpeg1 */

    return 0;

}
",886,,LABEL_0,LABEL_1,,-4,"avctx,buf,buf_size,s1,s,height,i,v,j,aspect",,,,0,,0,Greedy,1,0.0009426593780517579,,
239,"static void external_snapshot_commit(BlkActionState *common)

{

    ExternalSnapshotState *state =

                             DO_UPCAST(ExternalSnapshotState, common, common);



    bdrv_set_aio_context(state->new_bs, state->aio_context);



    /* This removes our old bs and adds the new bs */

    bdrv_append(state->new_bs, state->old_bs);

    /* We don't need (or want) to use the transactional

     * bdrv_reopen_multiple() across all the entries at once, because we

     * don't want to abort all of them if one of them fails the reopen */

    bdrv_reopen(state->old_bs, state->old_bs->open_flags & ~BDRV_O_RDWR,

                NULL);

}
",131,,LABEL_1,LABEL_0,,-4,"common,state",,,,0,,0,Greedy,1,0.00048642555872599285,,
240,"static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,

                           struct dirent *entry,

                           struct dirent **result)

{

    return readdir_r(fs->dir, entry, result);

}
",37,"static int local_readdir_r(FsContext *cm, V9fsFidOpenState *ns,

                           struct dirent *record,

                           struct dirent **card)

{

    return readdir_r(ns->dir, record, card);

}
",LABEL_0,LABEL_0,LABEL_1,1,"ctx,fs,entry,result","ctx:-2.3305416107177734e-05,fs:-0.00041800737380981445,entry:-3.737211227416992e-05,result:0.000391542911529541,",4,7,0,"result:card,ctx:cm,entry:record,fs:ns,",0,Greedy,138,0.04829554160435994,replace,[]
