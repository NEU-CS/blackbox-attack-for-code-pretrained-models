Index,Original Code,Program Length,Adversarial Code,True Label,Original Prediction,Adv Prediction,Is Success,Extracted Names,Importance Score,Greedy No. Changed Names,Greedy No. Changed Tokens,Replaced Names,GA No. Changed Names,GA No. Changed Tokens,Attack Type,Query Times,Time Cost,Suc Type,Insert Words
0,"static int check_bind(const char *hostname, bool *has_proto)

{

    int fd = -1;

    struct addrinfo ai, *res = NULL;

    int rc;

    int ret = -1;



    memset(&ai, 0, sizeof(ai));

    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;

    ai.ai_family = AF_UNSPEC;

    ai.ai_socktype = SOCK_STREAM;



    /* lookup */

    rc = getaddrinfo(hostname, NULL, &ai, &res);

    if (rc != 0) {

        if (rc == EAI_ADDRFAMILY ||

            rc == EAI_FAMILY) {

            *has_proto = false;

            goto done;

        }

        goto cleanup;

    }



    fd = qemu_socket(res->ai_family, res->ai_socktype, res->ai_protocol);

    if (fd < 0) {

        goto cleanup;

    }



    if (bind(fd, res->ai_addr, res->ai_addrlen) < 0) {

        if (errno == EADDRNOTAVAIL) {

            *has_proto = false;

            goto done;

        }

        goto cleanup;

    }



    *has_proto = true;

 done:

    ret = 0;



 cleanup:

    if (fd != -1) {

        close(fd);

    }

    if (res) {

        freeaddrinfo(res);

    }

    return ret;

}
",240,,LABEL_1,LABEL_0,,-4,"hostname,has_proto,ai,res,rc",,,,0,,0,Greedy,1,0.008545370896657307,,
1,"static int32_t parse_gain(const char *gain)

{

    char *fraction;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int db;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    db = strtol(gain, &fraction, 0);

    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }



    if (abs(db) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return db * 100000 + sign * mb;

}
",145,"static int32_t parse_gain(const char *align)

{

    char *feractions;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int dd;



    if (!gain)

        return INT32_MIN;



    align += strspn(align, "" \t"");



    if (*align == '-')

        sign = -1;



    db ddstrtol(align, &feractions, 0);

    if (*feractions++ == '.') {

        while (av_isdigit(*feractions) && scale) {

            mb += scale * (*feractions - '0');

            scale /= 10;

            feractions++;

        }

    }



    if (abs(dd) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return dd * 100000 + sign * mb;

}
",LABEL_1,LABEL_1,LABEL_0,1,"gain,fraction,db",,,,0,"gain:align,fraction:feractions,db:dd,",0,GA,195,0.07086217006047567,GA,
2,"static void arm_mptimer_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->realize = arm_mptimer_realize;

    dc->vmsd = &vmstate_arm_mptimer;

    dc->reset = arm_mptimer_reset;

    dc->no_user = 1;

    dc->props = arm_mptimer_properties;

}
",60,"static void arm_mptimer_class_init(ObjectClass *kcl, void *di)

{

    DeviceClassacdc = DEVICE_CLASS(kcl);



    ac->realize = arm_mptimer_realize;

    ac->vmsd = &vmstate_arm_mptimer;

    ac->reset = arm_mptimer_reset;

    ac->no_user = 1;

    ac->props = arm_mptimer_properties;

}
",LABEL_1,LABEL_1,LABEL_0,1,"klass,data,dc",,,,0,"klass:kcl,data:di,dc:ac,",0,GA,123,0.043609551588694256,GA,
3,"void do_load_dcr (void)

{

    target_ulong val;



    if (unlikely(env->dcr_env == NULL)) {

        if (loglevel != 0) {

            fprintf(logfile, ""No DCR environment\n"");

        }

        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_INVAL);

    } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {

        if (loglevel != 0) {

            fprintf(logfile, ""DCR read error %d %03x\n"", (int)T0, (int)T0);

        }

        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_PRIV_REG);

    } else {

        T0 = val;

    }

}
",125,,LABEL_0,LABEL_0,LABEL_0,-1,val,,,,0,,0,GA,246,0.09020964701970419,failed,
4,"static gboolean pty_chr_timer(gpointer opaque)

{

    struct CharDriverState *chr = opaque;

    PtyCharDriver *s = chr->opaque;



    if (s->connected) {

        goto out;

    }



    /* Next poll ... */

    pty_chr_update_read_handler(chr);



out:

    s->timer_tag = 0;

    return FALSE;

}
",62,,LABEL_1,LABEL_0,,-4,"opaque,chr,s",,,,0,,0,Greedy,1,0.0004679560661315918,,
5,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)

{

    uint32_t limit;



    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (s->control & TIMER_CTRL_32BIT)

            limit = 0xffffffff;

        else

            limit = 0xffff;

    } else {

          /* Periodic.  */

          limit = s->limit;

    }

    ptimer_set_limit(s->timer, limit, reload);

}
",84,"static void arm_timer_recalibrate(arm_timer_state *side, int forefill)

{

    uint32_t buffer;



    if ((side->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (side->control & TIMER_CTRL_32BIT)

            buffer = 0xffffffff;

        else

            buffer = 0xffff;

    } else {

          /* Periodic.  */

          limbufferside->buffer;

    }

    ptimer_set_limit(side->timer, libufferforefill);

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,reload,limit",,,,0,"s:side,reload:forefill,limit:buffer,",0,GA,181,0.0643988569577535,GA,
6,"static int do_token_in(USBDevice *s, USBPacket *p)

{

    int request, value, index;

    int ret = 0;



    assert(p->devep == 0);



    request = (s->setup_buf[0] << 8) | s->setup_buf[1];

    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];

    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];

 

    switch(s->setup_state) {

    case SETUP_STATE_ACK:

        if (!(s->setup_buf[0] & USB_DIR_IN)) {

            ret = usb_device_handle_control(s, p, request, value, index,

                                            s->setup_len, s->data_buf);

            if (ret == USB_RET_ASYNC) {

                return USB_RET_ASYNC;

            }

            s->setup_state = SETUP_STATE_IDLE;

            if (ret > 0)

                return 0;

            return ret;

        }



        /* return 0 byte */

        return 0;



    case SETUP_STATE_DATA:

        if (s->setup_buf[0] & USB_DIR_IN) {

            int len = s->setup_len - s->setup_index;

            if (len > p->iov.size) {

                len = p->iov.size;

            }

            usb_packet_copy(p, s->data_buf + s->setup_index, len);

            s->setup_index += len;

            if (s->setup_index >= s->setup_len)

                s->setup_state = SETUP_STATE_ACK;

            return len;

        }



        s->setup_state = SETUP_STATE_IDLE;

        return USB_RET_STALL;



    default:

        return USB_RET_STALL;

    }

}
",310,,LABEL_0,LABEL_0,LABEL_0,-1,"s,p,request,value,index",,,,0,,0,GA,1105,0.43087282180786135,failed,
7,"uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,

                                    uint64_t offset,

                                    int n_start, int n_end,

                                    int *num, QCowL2Meta *m)

{

    BDRVQcowState *s = bs->opaque;

    int l2_index, ret;

    uint64_t l2_offset, *l2_table, cluster_offset;

    int nb_clusters, i = 0;

    QCowL2Meta *old_alloc;



    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);

    if (ret == 0)

        return 0;



    nb_clusters = size_to_clusters(s, n_end << 9);



    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);



    cluster_offset = be64_to_cpu(l2_table[l2_index]);



    /* We keep all QCOW_OFLAG_COPIED clusters */



    if (cluster_offset & QCOW_OFLAG_COPIED) {

        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,

                &l2_table[l2_index], 0, 0);



        cluster_offset &= ~QCOW_OFLAG_COPIED;

        m->nb_clusters = 0;



        goto out;

    }



    /* for the moment, multiple compressed clusters are not managed */



    if (cluster_offset & QCOW_OFLAG_COMPRESSED)

        nb_clusters = 1;



    /* how many available clusters ? */



    while (i < nb_clusters) {

        i += count_contiguous_clusters(nb_clusters - i, s->cluster_size,

                &l2_table[l2_index], i, 0);



        if(be64_to_cpu(l2_table[l2_index + i]))

            break;



        i += count_contiguous_free_clusters(nb_clusters - i,

                &l2_table[l2_index + i]);



        cluster_offset = be64_to_cpu(l2_table[l2_index + i]);



        if ((cluster_offset & QCOW_OFLAG_COPIED) ||

                (cluster_offset & QCOW_OFLAG_COMPRESSED))

            break;

    }

    nb_clusters = i;



    /*

     * Check if there already is an AIO write request in flight which allocates

     * the same cluster. In this case we need to wait until the previous

     * request has completed and updated the L2 table accordingly.

     */

    LIST_FOREACH(old_alloc, &s->cluster_allocs, next_in_flight) {



        uint64_t end_offset = offset + nb_clusters * s->cluster_size;

        uint64_t old_offset = old_alloc->offset;

        uint64_t old_end_offset = old_alloc->offset +

            old_alloc->nb_clusters * s->cluster_size;



        if (end_offset < old_offset || offset > old_end_offset) {

            /* No intersection */

        } else {

            if (offset < old_offset) {

                /* Stop at the start of a running allocation */

                nb_clusters = (old_offset - offset) >> s->cluster_bits;

            } else {

                nb_clusters = 0;

            }



            if (nb_clusters == 0) {

                /* Set dependency and wait for a callback */

                m->depends_on = old_alloc;

                m->nb_clusters = 0;

                *num = 0;

                return 0;

            }

        }

    }



    if (!nb_clusters) {

        abort();

    }



    LIST_INSERT_HEAD(&s->cluster_allocs, m, next_in_flight);



    /* allocate a new cluster */



    cluster_offset = qcow2_alloc_clusters(bs, nb_clusters * s->cluster_size);



    /* save info needed for meta data update */

    m->offset = offset;

    m->n_start = n_start;

    m->nb_clusters = nb_clusters;



out:

    m->nb_available = MIN(nb_clusters << (s->cluster_bits - 9), n_end);



    *num = m->nb_available - n_start;



    return cluster_offset;

}
",620,,LABEL_0,LABEL_0,LABEL_0,-1,"bs,offset,n_start,n_end,num,m,s,l2_index,ret,l2_offset,l2_table,cluster_offset,nb_clusters,old_alloc",,,,0,,0,GA,2826,1.2937627196311952,failed,
8,"static int virtio_9p_device_init(VirtIODevice *vdev)

{

    V9fsState *s = VIRTIO_9P(vdev);

    int i, len;

    struct stat stat;

    FsDriverEntry *fse;

    V9fsPath path;



    virtio_init(VIRTIO_DEVICE(s), ""virtio-9p"", VIRTIO_ID_9P,

                sizeof(struct virtio_9p_config) + MAX_TAG_LEN);



    /* initialize pdu allocator */

    QLIST_INIT(&s->free_list);

    QLIST_INIT(&s->active_list);

    for (i = 0; i < (MAX_REQ - 1); i++) {

        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);

    }



    s->vq = virtio_add_queue(vdev, MAX_REQ, handle_9p_output);



    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);



    if (!fse) {

        /* We don't have a fsdev identified by fsdev_id */

        fprintf(stderr, ""Virtio-9p device couldn't find fsdev with the ""

                ""id = %s\n"",

                s->fsconf.fsdev_id ? s->fsconf.fsdev_id : ""NULL"");

        goto out;

    }



    if (!s->fsconf.tag) {

        /* we haven't specified a mount_tag */

        fprintf(stderr, ""fsdev with id %s needs mount_tag arguments\n"",

                s->fsconf.fsdev_id);

        goto out;

    }



    s->ctx.export_flags = fse->export_flags;

    s->ctx.fs_root = g_strdup(fse->path);

    s->ctx.exops.get_st_gen = NULL;

    len = strlen(s->fsconf.tag);

    if (len > MAX_TAG_LEN - 1) {

        fprintf(stderr, ""mount tag '%s' (%d bytes) is longer than ""

                ""maximum (%d bytes)"", s->fsconf.tag, len, MAX_TAG_LEN - 1);

        goto out;

    }



    s->tag = g_strdup(s->fsconf.tag);

    s->ctx.uid = -1;



    s->ops = fse->ops;

    s->config_size = sizeof(struct virtio_9p_config) + len;

    s->fid_list = NULL;

    qemu_co_rwlock_init(&s->rename_lock);



    if (s->ops->init(&s->ctx) < 0) {

        fprintf(stderr, ""Virtio-9p Failed to initialize fs-driver with id:%s""

                "" and export path:%s\n"", s->fsconf.fsdev_id, s->ctx.fs_root);

        goto out;

    }

    if (v9fs_init_worker_threads() < 0) {

        fprintf(stderr, ""worker thread initialization failed\n"");

        goto out;

    }



    /*

     * Check details of export path, We need to use fs driver

     * call back to do that. Since we are in the init path, we don't

     * use co-routines here.

     */

    v9fs_path_init(&path);

    if (s->ops->name_to_path(&s->ctx, NULL, ""/"", &path) < 0) {

        fprintf(stderr,

                ""error in converting name to path %s"", strerror(errno));

        goto out;

    }

    if (s->ops->lstat(&s->ctx, &path, &stat)) {

        fprintf(stderr, ""share path %s does not exist\n"", fse->path);

        goto out;

    } else if (!S_ISDIR(stat.st_mode)) {

        fprintf(stderr, ""share path %s is not a directory\n"", fse->path);

        goto out;

    }

    v9fs_path_free(&path);



    return 0;

out:

    g_free(s->ctx.fs_root);

    g_free(s->tag);

    virtio_cleanup(vdev);

    v9fs_path_free(&path);



    return -1;



}
",686,,LABEL_1,LABEL_0,,-4,"vdev,s,i,len,stat,fse,path",,,,0,,0,Greedy,1,0.0008662899335225423,,
9,"static void test_qemu_strtoul_decimal(void)

{

    const char *str = ""0123"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 10, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));



    str = ""123"";

    res = 999;

    endptr = &f;

    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));

}
",141,"static void test_qemu_strtoul_decimal(void)

{

    const char *c = ""0123"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int ar;



  arrr = qemu_strtoul(c, &endptr, 10, &res);



    g_assert_cmpint(ar, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assendptrdptr == c + strlen(c));



    c = ""123"";

    res = 999;

    endptr = &f;

  arrr = qemu_strtoul(c, &endptr, 0, &res);



    g_assert_cmpint(ar, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assendptrdptr == c + strlen(c));

}
",LABEL_0,LABEL_0,LABEL_1,1,"str,endptr,err",,,,6,"str:c,endptr:endptr,err:ar,",1,GA,214,0.07677805026372274,GA,
10,"void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {

        QTAILQ_REMOVE(&spapr->pending_events, entry, next);

        g_free(entry->extended_log);

        g_free(entry);

    }

}
",55,,LABEL_0,LABEL_0,LABEL_0,-1,"spapr,entry",,,,0,,0,GA,469,0.1656605839729309,failed,
11,"static void hls_transform_tree(HEVCContext *s, int x0, int y0,

                               int xBase, int yBase, int cb_xBase, int cb_yBase,

                               int log2_cb_size, int log2_trafo_size,

                               int trafo_depth, int blk_idx)

{

    HEVCLocalContext *lc = &s->HEVClc;

    uint8_t split_transform_flag;



    if (trafo_depth > 0 && log2_trafo_size == 2) {

        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =

            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase);

        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =

            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase);

    } else {

        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =

        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) = 0;

    }



    if (lc->cu.intra_split_flag) {

        if (trafo_depth == 1)

            lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[blk_idx];

    } else {

        lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[0];

    }



    lc->tt.cbf_luma = 1;



    lc->tt.inter_split_flag = s->sps->max_transform_hierarchy_depth_inter == 0 &&

                              lc->cu.pred_mode == MODE_INTER &&

                              lc->cu.part_mode != PART_2Nx2N &&

                              trafo_depth == 0;



    if (log2_trafo_size <= s->sps->log2_max_trafo_size &&

        log2_trafo_size >  s->sps->log2_min_tb_size    &&

        trafo_depth     < lc->cu.max_trafo_depth       &&

        !(lc->cu.intra_split_flag && trafo_depth == 0)) {

        split_transform_flag = ff_hevc_split_transform_flag_decode(s, log2_trafo_size);

    } else {

        split_transform_flag = log2_trafo_size > s->sps->log2_max_trafo_size ||

                               (lc->cu.intra_split_flag && trafo_depth == 0) ||

                               lc->tt.inter_split_flag;

    }



    if (log2_trafo_size > 2) {

        if (trafo_depth == 0 ||

            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase)) {

            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =

                ff_hevc_cbf_cb_cr_decode(s, trafo_depth);

        }



        if (trafo_depth == 0 ||

            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase)) {

            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =

                ff_hevc_cbf_cb_cr_decode(s, trafo_depth);

        }

    }



    if (split_transform_flag) {

        int x1 = x0 + ((1 << log2_trafo_size) >> 1);

        int y1 = y0 + ((1 << log2_trafo_size) >> 1);



        hls_transform_tree(s, x0, y0, x0, y0, cb_xBase, cb_yBase, log2_cb_size,

                           log2_trafo_size - 1, trafo_depth + 1, 0);

        hls_transform_tree(s, x1, y0, x0, y0, cb_xBase, cb_yBase, log2_cb_size,

                           log2_trafo_size - 1, trafo_depth + 1, 1);

        hls_transform_tree(s, x0, y1, x0, y0, cb_xBase, cb_yBase, log2_cb_size,

                           log2_trafo_size - 1, trafo_depth + 1, 2);

        hls_transform_tree(s, x1, y1, x0, y0, cb_xBase, cb_yBase, log2_cb_size,

                           log2_trafo_size - 1, trafo_depth + 1, 3);

    } else {

        int min_tu_size      = 1 << s->sps->log2_min_tb_size;

        int log2_min_tu_size = s->sps->log2_min_tb_size;

        int min_tu_width     = s->sps->min_tb_width;



        if (lc->cu.pred_mode == MODE_INTRA || trafo_depth != 0 ||

            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) ||

            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0)) {

            lc->tt.cbf_luma = ff_hevc_cbf_luma_decode(s, trafo_depth);

        }



        hls_transform_unit(s, x0, y0, xBase, yBase, cb_xBase, cb_yBase,

                           log2_cb_size, log2_trafo_size, trafo_depth, blk_idx);



        // TODO: store cbf_luma somewhere else

        if (lc->tt.cbf_luma) {

            int i, j;

            for (i = 0; i < (1 << log2_trafo_size); i += min_tu_size)

                for (j = 0; j < (1 << log2_trafo_size); j += min_tu_size) {

                    int x_tu = (x0 + j) >> log2_min_tu_size;

                    int y_tu = (y0 + i) >> log2_min_tu_size;

                    s->cbf_luma[y_tu * min_tu_width + x_tu] = 1;

                }

        }

        if (!s->sh.disable_deblocking_filter_flag) {

            ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_trafo_size,

                                                  lc->slice_or_tiles_up_boundary,

                                                  lc->slice_or_tiles_left_boundary);

            if (s->pps->transquant_bypass_enable_flag &&

                lc->cu.cu_transquant_bypass_flag)

                set_deblocking_bypass(s, x0, y0, log2_trafo_size);

        }

    }

}
",927,"static void hls_transform_tree(HEVCContext *s, int x0, int ySource,

                               int xBase, int yBase, int cb_yEnd, int cb_yBase,

                               int log2_cb_size, int log2_trafi_go,

                               int traverse_height, int blk_idx)

{

    HEVCLocalContext *lc = &s->HEVClc;

    uint8_t split_transfer_count;



    iftraverse_heightth > 0 && log2_trafi_go == 2) {

        SAMPLE_CBF(lc->tt.cblccb[trafotraverse_height, ySource) =

            SAMPLE_CBF(lc->lc.cbf_cb[traverse_height - 1], xBase, yBase);

        SAMPLE_CBF(lc->tt.cblccr[trafotraverse_height, ySource) =

            SAMPLE_CBF(lc->lc.cbf_cr[traverse_height - 1], xBase, yBase);

    } else {

        SAMPLE_CBF(lc->tt.cblccb[trafotraverse_height, ySource) =

        SAMPLE_CBF(lc->tt.cblccr[trafotraverse_height, ySource) = 0;

    }



    if (lc->cu.intra_split_flag) {

        if (traverse_height == 1)

            lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[blk_idx];

    } else {

        lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[0];

    }



    lc->tt.cbf_luma = 1;



    lc->tt.inter_split_flag = s->sps->max_transform_hierarchy_depth_inter == 0 &&

                              lc->cu.pred_mode == MODE_INTER &&

                              lc->cu.part_mode != PART_2Nx2N &&

                              traverse_height == 0;



    if (log2_trafi_go <= s->sps->log2_max_trafo_size &&

        log2_trafi_go >  s->sps->log2_min_tb_size    &&

        traverse_height     < lc->cu.max_trafo_depth       &&

        !(lc->lc.intra_split_flag && traverse_height == 0)) {

      split_transfer_countag = ff_hevc_split_transform_flag_decode(s, log2_trafi_go);

    } else {

      split_transfer_countag = log2_trafi_go > s->sps->log2_max_trafo_size ||

                               (lc->lc.intra_split_flag && traverse_height == 0) ||

                               lc->tt.inter_split_flag;

    }



    if (log2_trafi_go > 2) {

        if (traverse_height == 0 ||

            SAMPLE_CBF(lc->lc.cbf_cb[traverse_height - 1], xBase, yBase)) {

            SAMPLE_CBF(lc->tt.cblccb[trafotraverse_height, ySource) =

                ff_hevc_cbf_cb_cr_decode(s, traverse_height);

        }



        if (traverse_height == 0 ||

            SAMPLE_CBF(lc->lc.cbf_cr[traverse_height - 1], xBase, yBase)) {

            SAMPLE_CBF(lc->tt.cblccr[trafotraverse_height, ySource) =

                ff_hevc_cbf_cb_cr_decode(s, traverse_height);

        }

    }



    if (split_transfer_count) {

        int x1 = x0 + ((1 << log2_trafi_go) >> 1);

        int y1 = ySource + ((1 << log2_trafi_go) >> 1);



        hls_transform_tree(s, x0, ySource, x0, ySource, cb_yEnd, cb_yBase, log2_cb_size,

                           log2_trafi_go - 1, traverse_height + 1, 0);

        hls_transform_tree(s, x1, ySource, x0, ySource, cb_yEnd, cb_yBase, log2_cb_size,

                           log2_trafi_go - 1, traverse_height + 1, 1);

        hls_transform_tree(s, x0, y1, x0, ySource, cb_yEnd, cb_yBase, log2_cb_size,

                           log2_trafi_go - 1, traverse_height + 1, 2);

        hls_transform_tree(s, x1, y1, x0, ySource, cb_yEnd, cb_yBase, log2_cb_size,

                           log2_trafi_go - 1, traverse_height + 1, 3);

    } else {

        int min_tu_size      = 1 << s->sps->log2_min_tb_size;

        int log2_min_tu_size = s->sps->log2_min_tb_size;

        int min_tu_width     = s->sps->min_tb_width;



        if (lc->lc.pred_mode == MODE_INTRA || traverse_height != 0 ||

            SAMPLE_CBF(lc->tt.cblccb[trafotraverse_height, ySource) ||

            SAMPLE_CBF(lc->tt.cblccr[trafotraverse_height, ySource)) {

            lc->lc.cbf_luma = ff_hevc_cbf_luma_decode(s, traverse_height);

        }



        hls_transform_unit(s, x0, ySource, xBase, yBase, cb_yEnd, cb_yBase,

                           log2_cb_size, log2_trafi_go, traverse_height, blk_idx);



        // TODO: store cbf_luma somewhere else

        if (lc->tt.cbf_luma) {

            int i, j;

            for (i = 0; i < (1 << log2_trafi_go); i += min_tu_size)

                for (j = 0; j < (1 << log2_trafi_go); j += min_tu_size) {

                    int x_tu = (x0 + j) >> log2_min_tu_size;

                    int y_tu = (ySource + i) >> log2_min_tu_size;

                    s->cbf_luma[y_tu * min_tu_width + x_tu] = 1;

                }

        }

        if (!s->sh.disable_deblocking_filter_flag) {

            ff_hevc_deblocking_boundary_strengths(s, x0, ySource, log2_trafi_go,

                                                  lc->slice_or_tiles_up_boundary,

                                                  lc->slice_or_tiles_left_boundary);

            if (s->pps->transquant_bypass_enable_flag &&

                lc->cu.cu_transquant_bypass_flag)

                set_deblocking_bypass(s, x0, ySource, log2_trafi_go);

        }

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,x0,y0,xBase,yBase,cb_xBase,cb_yBase,log2_cb_size,log2_trafo_size,trafo_depth,blk_idx,lc,split_transform_flag",,,,101,"s:s,x0:x0,y0:ySource,xBase:xBase,yBase:yBase,cb_xBase:cb_yEnd,cb_yBase:cb_yBase,log2_cb_size:log2_cb_size,log2_trafo_size:log2_trafi_go,trafo_depth:traverse_height,blk_idx:blk_idx,lc:lc,split_transform_flag:split_transfer_count,",8,GA,502,0.24811756213506062,GA,
12,"static int RENAME(swScale)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,

             int srcSliceH, uint8_t* dst[], int dstStride[]){



	/* load a few things into local vars to make the code more readable? and faster */

	const int srcW= c->srcW;

	const int dstW= c->dstW;

	const int dstH= c->dstH;

	const int chrDstW= c->chrDstW;

	const int chrSrcW= c->chrSrcW;

	const int lumXInc= c->lumXInc;

	const int chrXInc= c->chrXInc;

	const int dstFormat= c->dstFormat;

	const int srcFormat= c->srcFormat;

	const int flags= c->flags;

	const int canMMX2BeUsed= c->canMMX2BeUsed;

	int16_t *vLumFilterPos= c->vLumFilterPos;

	int16_t *vChrFilterPos= c->vChrFilterPos;

	int16_t *hLumFilterPos= c->hLumFilterPos;

	int16_t *hChrFilterPos= c->hChrFilterPos;

	int16_t *vLumFilter= c->vLumFilter;

	int16_t *vChrFilter= c->vChrFilter;

	int16_t *hLumFilter= c->hLumFilter;

	int16_t *hChrFilter= c->hChrFilter;

	int32_t *lumMmxFilter= c->lumMmxFilter;

	int32_t *chrMmxFilter= c->chrMmxFilter;

	const int vLumFilterSize= c->vLumFilterSize;

	const int vChrFilterSize= c->vChrFilterSize;

	const int hLumFilterSize= c->hLumFilterSize;

	const int hChrFilterSize= c->hChrFilterSize;

	int16_t **lumPixBuf= c->lumPixBuf;

	int16_t **chrPixBuf= c->chrPixBuf;

	const int vLumBufSize= c->vLumBufSize;

	const int vChrBufSize= c->vChrBufSize;

	uint8_t *funnyYCode= c->funnyYCode;

	uint8_t *funnyUVCode= c->funnyUVCode;

	uint8_t *formatConvBuffer= c->formatConvBuffer;

	const int chrSrcSliceY= srcSliceY >> c->chrSrcVSubSample;

	const int chrSrcSliceH= -((-srcSliceH) >> c->chrSrcVSubSample);

	int lastDstY;

        uint8_t *pal=NULL;



	/* vars whch will change and which we need to storw back in the context */

	int dstY= c->dstY;

	int lumBufIndex= c->lumBufIndex;

	int chrBufIndex= c->chrBufIndex;

	int lastInLumBuf= c->lastInLumBuf;

	int lastInChrBuf= c->lastInChrBuf;

	

	if(isPacked(c->srcFormat)){

                pal= src[1];

		src[0]=

		src[1]=

		src[2]= src[0];

		srcStride[0]=

		srcStride[1]=

		srcStride[2]= srcStride[0];

	}

	srcStride[1]<<= c->vChrDrop;

	srcStride[2]<<= c->vChrDrop;



//	printf(""swscale %X %X %X -> %X %X %X\n"", (int)src[0], (int)src[1], (int)src[2],

//		(int)dst[0], (int)dst[1], (int)dst[2]);



#if 0 //self test FIXME move to a vfilter or something

{

static volatile int i=0;

i++;

if(srcFormat==PIX_FMT_YUV420P && i==1 && srcSliceH>= c->srcH)

	selfTest(src, srcStride, c->srcW, c->srcH);

i--;

}

#endif



//printf(""sws Strides:%d %d %d -> %d %d %d\n"", srcStride[0],srcStride[1],srcStride[2],

//dstStride[0],dstStride[1],dstStride[2]);



	if(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)

	{

		static int firstTime=1; //FIXME move this into the context perhaps

		if(flags & SWS_PRINT_INFO && firstTime)

		{

			av_log(c, AV_LOG_WARNING, ""SwScaler: Warning: dstStride is not aligned!\n""

					""SwScaler:          ->cannot do aligned memory acesses anymore\n"");

			firstTime=0;

		}

	}



	/* Note the user might start scaling the picture in the middle so this will not get executed

	   this is not really intended but works currently, so ppl might do it */

	if(srcSliceY ==0){

		lumBufIndex=0;

		chrBufIndex=0;

		dstY=0;	

		lastInLumBuf= -1;

		lastInChrBuf= -1;

	}



	lastDstY= dstY;



	for(;dstY < dstH; dstY++){

		unsigned char *dest =dst[0]+dstStride[0]*dstY;

		const int chrDstY= dstY>>c->chrDstVSubSample;

		unsigned char *uDest=dst[1]+dstStride[1]*chrDstY;

		unsigned char *vDest=dst[2]+dstStride[2]*chrDstY;



		const int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input

		const int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input

		const int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input

		const int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input



//printf(""dstY:%d dstH:%d firstLumSrcY:%d lastInLumBuf:%d vLumBufSize: %d vChrBufSize: %d slice: %d %d vLumFilterSize: %d firstChrSrcY: %d vChrFilterSize: %d c->chrSrcVSubSample: %d\n"",

// dstY, dstH, firstLumSrcY, lastInLumBuf, vLumBufSize, vChrBufSize, srcSliceY, srcSliceH, vLumFilterSize, firstChrSrcY, vChrFilterSize,  c->chrSrcVSubSample);

		//handle holes (FAST_BILINEAR & weird filters)

		if(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;

		if(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;

//printf(""%d %d %d\n"", firstChrSrcY, lastInChrBuf, vChrBufSize);

		ASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)

		ASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)



		// Do we have enough lines in this slice to output the dstY line

		if(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample))

		{

			//Do horizontal scaling

			while(lastInLumBuf < lastLumSrcY)

			{

				uint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];

				lumBufIndex++;

//				printf(""%d %d %d %d\n"", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);

				ASSERT(lumBufIndex < 2*vLumBufSize)

				ASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)

				ASSERT(lastInLumBuf + 1 - srcSliceY >= 0)

//				printf(""%d %d\n"", lumBufIndex, vLumBufSize);

				RENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,

						flags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,

						funnyYCode, c->srcFormat, formatConvBuffer, 

						c->lumMmx2Filter, c->lumMmx2FilterPos, pal);

				lastInLumBuf++;

			}

			while(lastInChrBuf < lastChrSrcY)

			{

				uint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];

				uint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];

				chrBufIndex++;

				ASSERT(chrBufIndex < 2*vChrBufSize)

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH))

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)

				//FIXME replace parameters through context struct (some at least)



				if(!(isGray(srcFormat) || isGray(dstFormat)))

					RENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,

						flags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,

						funnyUVCode, c->srcFormat, formatConvBuffer, 

						c->chrMmx2Filter, c->chrMmx2FilterPos, pal);

				lastInChrBuf++;

			}

			//wrap buf index around to stay inside the ring buffer

			if(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;

			if(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;

		}

		else // not enough lines left in this slice -> load the rest in the buffer

		{

/*		printf(""%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\n"",

			firstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,

			lastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,

			vChrBufSize, vLumBufSize);*/



			//Do horizontal scaling

			while(lastInLumBuf+1 < srcSliceY + srcSliceH)

			{

				uint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];

				lumBufIndex++;

				ASSERT(lumBufIndex < 2*vLumBufSize)

				ASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)

				ASSERT(lastInLumBuf + 1 - srcSliceY >= 0)

				RENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,

						flags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,

						funnyYCode, c->srcFormat, formatConvBuffer, 

						c->lumMmx2Filter, c->lumMmx2FilterPos, pal);

				lastInLumBuf++;

			}

			while(lastInChrBuf+1 < (chrSrcSliceY + chrSrcSliceH))

			{

				uint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];

				uint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];

				chrBufIndex++;

				ASSERT(chrBufIndex < 2*vChrBufSize)

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY < chrSrcSliceH)

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)



				if(!(isGray(srcFormat) || isGray(dstFormat)))

					RENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,

						flags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,

						funnyUVCode, c->srcFormat, formatConvBuffer, 

						c->chrMmx2Filter, c->chrMmx2FilterPos, pal);

				lastInChrBuf++;

			}

			//wrap buf index around to stay inside the ring buffer

			if(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;

			if(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;

			break; //we can't output a dstY line so let's try with the next slice

		}



#ifdef HAVE_MMX

		b5Dither= dither8[dstY&1];

		g6Dither= dither4[dstY&1];

		g5Dither= dither8[dstY&1];

		r5Dither= dither8[(dstY+1)&1];

#endif

	    if(dstY < dstH-2)

	    {

		int16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;

		int16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;

#ifdef HAVE_MMX

		int i;

            if(flags & SWS_ACCURATE_RND){

                        for(i=0; i<vLumFilterSize; i+=2){

                                lumMmxFilter[2*i+0]= (int32_t)lumSrcPtr[i  ];

                                lumMmxFilter[2*i+1]= (int32_t)lumSrcPtr[i+(vLumFilterSize>1)];

                                lumMmxFilter[2*i+2]=

                                lumMmxFilter[2*i+3]= vLumFilter[dstY*vLumFilterSize + i    ]

                                                + (vLumFilterSize>1 ? vLumFilter[dstY*vLumFilterSize + i + 1]<<16 : 0);

                        }

                        for(i=0; i<vChrFilterSize; i+=2){

                                chrMmxFilter[2*i+0]= (int32_t)chrSrcPtr[i  ];

                                chrMmxFilter[2*i+1]= (int32_t)chrSrcPtr[i+(vChrFilterSize>1)];

                                chrMmxFilter[2*i+2]=

                                chrMmxFilter[2*i+3]= vChrFilter[chrDstY*vChrFilterSize + i    ]

                                                + (vChrFilterSize>1 ? vChrFilter[chrDstY*vChrFilterSize + i + 1]<<16 : 0);

                        }

            }else{

		for(i=0; i<vLumFilterSize; i++)

		{

			lumMmxFilter[4*i+0]= (int32_t)lumSrcPtr[i];

			lumMmxFilter[4*i+1]= (uint64_t)lumSrcPtr[i] >> 32;

			lumMmxFilter[4*i+2]= 

			lumMmxFilter[4*i+3]= 

				((uint16_t)vLumFilter[dstY*vLumFilterSize + i])*0x10001;

		}

		for(i=0; i<vChrFilterSize; i++)

		{

			chrMmxFilter[4*i+0]= (int32_t)chrSrcPtr[i];


			chrMmxFilter[4*i+2]= 

			chrMmxFilter[4*i+3]= 

				((uint16_t)vChrFilter[chrDstY*vChrFilterSize + i])*0x10001;

		}

            }

#endif

		if(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){

			const int chrSkipMask= (1<<c->chrDstVSubSample)-1;

			if(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi

			RENAME(yuv2nv12X)(c,

				vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

				vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, uDest, dstW, chrDstW, dstFormat);

		}

		else if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12 like

		{

			const int chrSkipMask= (1<<c->chrDstVSubSample)-1;

			if((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi

			if(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12

			{

				int16_t *lumBuf = lumPixBuf[0];

				int16_t *chrBuf= chrPixBuf[0];

				RENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW, chrDstW);

			}

			else //General YV12

			{

				RENAME(yuv2yuvX)(c,

					vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

					vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

					dest, uDest, vDest, dstW, chrDstW);

			}

		}

		else

		{

			ASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);

			ASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);

			if(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB

			{

				int chrAlpha= vChrFilter[2*dstY+1];

				RENAME(yuv2packed1)(c, *lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),

						 dest, dstW, chrAlpha, dstFormat, flags, dstY);

			}

			else if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB

			{

				int lumAlpha= vLumFilter[2*dstY+1];

				int chrAlpha= vChrFilter[2*dstY+1];

                                lumMmxFilter[2]=

                                lumMmxFilter[3]= vLumFilter[2*dstY   ]*0x10001;

                                chrMmxFilter[2]=

                                chrMmxFilter[3]= vChrFilter[2*chrDstY]*0x10001;

				RENAME(yuv2packed2)(c, *lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),

						 dest, dstW, lumAlpha, chrAlpha, dstY);

			}

			else //General RGB

			{

				RENAME(yuv2packedX)(c,

					vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,

					vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

					dest, dstW, dstY);

			}

		}

            }

	    else // hmm looks like we can't use MMX here without overwriting this array's tail

	    {

		int16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;

		int16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;

		if(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){

			const int chrSkipMask= (1<<c->chrDstVSubSample)-1;

			if(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi

			yuv2nv12XinC(

				vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

				vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, uDest, dstW, chrDstW, dstFormat);

		}

		else if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12

		{

			const int chrSkipMask= (1<<c->chrDstVSubSample)-1;

			if((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi

			yuv2yuvXinC(

				vLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

				vChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, uDest, vDest, dstW, chrDstW);

		}

		else

		{

			ASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);

			ASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);

			yuv2packedXinC(c, 

				vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,

				vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, dstW, dstY);

		}

	    }

	}



#ifdef HAVE_MMX

	__asm __volatile(SFENCE:::""memory"");

	__asm __volatile(EMMS:::""memory"");

#endif

	/* store changed local vars back in the context */

	c->dstY= dstY;

	c->lumBufIndex= lumBufIndex;

	c->chrBufIndex= chrBufIndex;

	c->lastInLumBuf= lastInLumBuf;

	c->lastInChrBuf= lastInChrBuf;



	return dstY - lastDstY;

}",3275,"static int RENAME(swScale)(SwsContext *cc, uint8_t* inst[], int rcShause[], int srcSliceD,

             int srcFliceRH, uint8_t* Dst[], int dstShause[]){



	/* load a few things into local vars to make the code more readable? and faster */

	const int srcW= cc->srcW;

	const int dstW= cc->dstW;

	const int dstH= cc->dstH;

	const int chrDstW= cc->chrDstW;

	const int chrSrcW= cc->chrSrcW;

	const int lumXInc= cc->lumXInc;

	const int chrXInc= cc->chrXInc;

	const int dstFormat= cc->dstFormat;

	const int srcFormat= cc->srcFormat;

	const int flags= cc->flags;

	const int canMMX2BeUsed= cc->canMMX2BeUsed;

	int16_t *vvLumMaskPos cc->vLumMaskPos;

	int16_t *vvChrFilterPos cc->vChrFilterPos;

	int16_t *hhLumFilterPos cc->hLumFilterPos;

	int16_t *hhChrtHandlerPos cc->hChrtHandlerPos;

	int16_t *vvLumLimit cc->vLumLimit;

	int16_t *vvPhrRule cc->vPhrRule;

	int16_t *hhLmUrl cc->hLmUrl;

	int16_t *hhChrbFilter cc->hChrbFilter;

	int32_t *llumLmxF cc->lumLmxF;

	int32_t *cchrRmxF cc->chrRmxF;

	const int vLumFilterSize= cc->vLumFilterSize;

	const int vChrFilterSize= cc->vChrFilterSize;

	const int hLumFilterSize= cc->hLumFilterSize;

	const int hChrFilterSize= cc->hChrFilterSize;

	int16_t **llumPixDmp cc->lumPixDmp;

	int16_t **cchrPixBust cc->chrPixBust;

	const int vLumBufSize= cc->vLumBufSize;

	const int vChrBufSize= cc->vChrBufSize;

	uint8_t *funnyYCode= cc->funnyYCode;

	uint8_t *funnyUVCode= cc->funnyUVCode;

	uint8_t *formatConvBuffer= cc->formatConvBuffer;

	const int chrSrcSliceY= ssrcSliceD>> cc->chrSrcVSubSample;

	const int chrSrcSliceH= -((-ssrcFliceRH >> cc->chrSrcVSubSample);

	int lastDstY;

        uint8_t *pal=NULL;



	/* vars whch will change and which we need to storw back in the context */

	int dstY= cc->dstY;

	int lumBufIndex= cc->lumBufIndex;

	int chrBufIndex= cc->chrBufIndex;

	int lastInLumBuf= cc->lastInLumBuf;

	int lastInChrBuf= cc->lastInChrBuf;

	

	if(isPacked(cc->srcFormat)){

                pal= inst[1];

		inst[0]=

		inst[1]=

		inst[2]= inst[0];

		rcShause[0]=

		rcShause[1]=

		rcShause[2]= rcShause[0];

	}

	srcShause1]<<= cc->vChrDrop;

	srcShause2]<<= cc->vChrDrop;



//	printf(""swscale %X %X %X -> %X %X %X
"", (int)inst[0], (int)inst[1], (int)inst[2],

//		(int)Dst[0], (int)Dst[1], (int)Dst[2]);



#if 0 //self test FIXME move to a vfilter or something

{

static volatile int i=0;

i++;

if(srcFormat==PIX_FMT_YUV420P && i==1 && ssrcFliceRH= cc->srcH)

	selfTest(srinstsrrcShausecc->srcW, cc->srcH);

i--;

}

#endif



//printf(""sws Strides:%d %d %d -> %d %d %d
"", rcShause[0],rcShause[1],rcShause[2],

//dstShause[0],dstShause[1],dstShause[2]);



	if(dstShause[0]%8 !=0 || dstShause[1]%8 !=0 || dstShause[2]%8 !=0)

	{

		static int firstTime=1; //FIXME move this into the context perhaps

		if(flags & SWS_PRINT_INFO && firstTime)

		{

			av_log(cc, AV_LOG_WARNING, ""SwScaler: Warning: dstShause is not aligned!
""

					""SwScaler:          ->cannot do aligned memory acesses anymore
"");

			firstTime=0;

		}

	}



	/* Note the user might start scaling the picture in the middle so this will not get executed

	   this is not really intended but works currently, so ppl might do it */

	if(srcSliceD ==0){

		lumBufIndex=0;

		chrBufIndex=0;

		dstY=0;	

		lastInLumBuf= -1;

		lastInChrBuf= -1;

	}



	lastDstY= dstY;



	for(;dstY < dstH; dstY++){

		unsigned char *dest =Dst[0]+dstShause[0]*dstY;

		const int chrDstY= dstY>>cc->chrDstVSubSample;

		unsigned char *uDest=Dst[1]+dstShause[1]*chrDstY;

		unsigned char *vDest=Dst[2]+dstShause[2]*chrDstY;



		const int firstLumSrcY= vLumMaskPos[dstY]; //First line needed as input

		const int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input

		const int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input

		const int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input



//printf(""dstY:%d dstH:%d firstLumSrcY:%d lastInLumBuf:%d vLumBufSize: %d vChrBufSize: %d slice: %d %d vLumFilterSize: %d firstChrSrcY: %d vChrFilterSize: %d cc->chrSrcVSubSample: %d
"",

// dstY, dstH, firstLumSrcY, lastInLumBuf, vLumBufSize, vChrBufSize, ssrcSliceD ssrcFliceRH vLumFilterSize, firstChrSrcY, vChrFilterSize,  cc->chrSrcVSubSample);

		//handle holes (FAST_BILINEAR & weird filters)

		if(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;

		if(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;

//printf(""%d %d %d
"", firstChrSrcY, lastInChrBuf, vChrBufSize);

		ASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)

		ASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)



		// Do we have enough lines in this slice to output the dstY line

		if(lastLumSrcY < ssrcSliceD+ ssrcFliceRH&& lastChrSrcY < -((-ssrcSliceD- ssrcFliceRH>>cc->chrSrcVSubSample))

		{

			//Do horizontal scaling

			while(lastInLumBuf < lastLumSrcY)

			{

				uint8_t *s= inst[0]+(lastInLumBuf + 1 -srcSliceDY)*rcShause[0];

				lumBufIndex++;

//				printf(""%d %d %d %d
"", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);

				ASSERT(lumBufIndex < 2*vLumBufSize)

				ASSERT(lastInLumBuf + 1 - srcSliceD < srcFliceRH)

				ASSERT(lastInLumBuf + 1 - srcSliceD >= 0)

//				printf(""%d %d
"", lumBufIndex, vLumBufSize);

				RENAME(hyscale)(lumPixDmp[ lumBufIndex ], dstW, s, srcW, lumXInc,

						flags, canMMX2BeUsed, hLmUrl, hLumFilterPos, hLumFilterSize,

						funnyYCode, cc->srcFormat, formatConvBuffer, 

						cc->lumMmx2Filter, cc->lumMmx2FilterPos, pal);

				lastInLumBuf++;

			}

			while(lastInChrBuf < lastChrSrcY)

			{

				uint8_t *src1= inst[1]+(lastInChrBuf + 1 - chrSrcSliceY)*rcShause[1];

				uint8_t *src2= inst[2]+(lastInChrBuf + 1 - chrSrcSliceY)*rcShause[2];

				chrBufIndex++;

				ASSERT(chrBufIndex < 2*vChrBufSize)

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH))

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)

				//FIXME replace parameters through context struct (some at least)



				if(!(isGray(srcFormat) || isGray(dstFormat)))

					RENAME(hcscale)(chrPixBust[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,

						flags, canMMX2BeUsed, hChChrbFilterhChrtHandlerPos, hChrFilterSize,

						funnyUVCode, cc->srcFormat, formatConvBuffer, 

						cc->chrMmx2Filter, cc->chrMmx2FilterPos, pal);

				lastInChrBuf++;

			}

			//wrap buf index around to stay inside the ring buffer

			if(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;

			if(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;

		}

		else // not enough lines left in this slice -> load the rest in the buffer

		{

/*		printf(""%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d
"",

			firstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,

			lastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,

			vChrBufSize, vLumBufSize);*/



			//Do horizontal scaling

			while(lastInLumBuf+1 < srcSliceD + srcFliceRH)

			{

				uint8_t *s= inst[0]+(lastInLumBuf + 1 -srcSliceDY)*rcShause[0];

				lumBufIndex++;

				ASSERT(lumBufIndex < 2*vLumBufSize)

				ASSERT(lastInLumBuf + 1 - srcSliceD < srcFliceRH)

				ASSERT(lastInLumBuf + 1 - srcSliceD >= 0)

				RENAME(hyscale)(lumPixDmp[ lumBufIndex ], dstW, s, srcW, lumXInc,

						flags, canMMX2BeUsed, hLmUrl, hLumFilterPos, hLumFilterSize,

						funnyYCode, cc->srcFormat, formatConvBuffer, 

						cc->lumMmx2Filter, cc->lumMmx2FilterPos, pal);

				lastInLumBuf++;

			}

			while(lastInChrBuf+1 < (chrSrcSliceY + chrSrcSliceH))

			{

				uint8_t *src1= inst[1]+(lastInChrBuf + 1 - chrSrcSliceY)*rcShause[1];

				uint8_t *src2= inst[2]+(lastInChrBuf + 1 - chrSrcSliceY)*rcShause[2];

				chrBufIndex++;

				ASSERT(chrBufIndex < 2*vChrBufSize)

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY < chrSrcSliceH)

				ASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)



				if(!(isGray(srcFormat) || isGray(dstFormat)))

					RENAME(hcscale)(chrPixBust[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,

						flags, canMMX2BeUsed, hChChrbFilterhChrtHandlerPos, hChrFilterSize,

						funnyUVCode, cc->srcFormat, formatConvBuffer, 

						cc->chrMmx2Filter, cc->chrMmx2FilterPos, pal);

				lastInChrBuf++;

			}

			//wrap buf index around to stay inside the ring buffer

			if(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;

			if(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;

			break; //we can't output a dstY line so let's try with the next slice

		}



#ifdef HAVE_MMX

		b5Dither= dither8[dstY&1];

		g6Dither= dither4[dstY&1];

		g5Dither= dither8[dstY&1];

		r5Dither= dither8[(dstY+1)&1];

#endif

	    if(dstY < dstH-2)

	    {

		int16_t **lumSrcPtr= lumPixDmp + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;

		int16_t **chrSrcPtr= chrPixBust + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;

#ifdef HAVE_MMX

		int i;

            if(flags & SWS_ACCURATE_RND){

                        for(i=0; i<vLumFilterSize; i+=2){

                                lumLmxF[2*i+0]= (int32_t)lumSrcPtr[i  ];

                                lumLmxF[2*i+1]= (int32_t)lumSrcPtr[i+(vLumFilterSize>1)];

                                lumLmxF[2*i+2]=

                               lumLmxFr[2*i+3]= vLumLimit[dstY*vLumFilterSize + i    ]

                                                + (vLumFilterSize>1 ? vLumLimit[dstY*vLumFilterSize + i + 1]<<16 : 0);

                        }

                        for(i=0; i<vChrFilterSize; i+=2){

                                chrRmxF[2*i+0]= (int32_t)chrSrcPtr[i  ];

                                chrRmxF[2*i+1]= (int32_t)chrSrcPtr[i+(vChrFilterSize>1)];

                                chrRmxF[2*i+2]=

                              chrRmxFer[2*i+3]= vPhrRule[chrDstY*vChrFilterSize + i    ]

                                                + (vChrFilterSize>1 ? vPhrRule[chrDstY*vChrFilterSize + i + 1]<<16 : 0);

                        }

            }else{

		for(i=0; i<vLumFilterSize; i++)

		{

			lumLmxF[4*i+0]= (int32_t)lumSrcPtr[i];

			lumLmxF[4*i+1]= (uint64_t)lumSrcPtr[i] >> 32;

			lumLmxF[4*i+2]= 

			lumLmxF[4*i+3]= 

				((uint16_t)vLumLimit[dstY*vLumFilterSize + i])*0x10001;

		}

		for(i=0; i<vChrFilterSize; i++)

		{

			chrRmxF[4*i+0]= (int32_t)chrSrcPtr[i];


			chrRmxF[4*i+2]= 

			chrRmxF[4*i+3]= 

				((uint16_t)vPhrRule[chrDstY*vChrFilterSize + i])*0x10001;

		}

            }

#endif

		if(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){

			const int chrSkipMask= (1<<cc->chrDstVSubSample)-1;

			if(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi

			RENAME(yuv2nv12X)(cc,

				vLumLimit+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

				vPhrRule+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, uDest, dstW, chrDstW, dstFormat);

		}

		else if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12 like

		{

			const int chrSkipMask= (1<<cc->chrDstVSubSample)-1;

			if((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi

			if(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12

			{

				int16_t *lumBuf = lumPixDmp[0];

				int16_t *chrBuf= chrPixBust[0];

				RENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW, chrDstW);

			}

			else //General YV12

			{

				RENAME(yuv2yuvX)(cc,

					vLumLimit+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

					vPhrRule+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

					dest, uDest, vDest, dstW, chrDstW);

			}

		}

		else

		{

			ASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixDmp + vLumBufSize*2);

			ASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBust + vChrBufSize*2);

			if(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB

			{

				int chrAlpha= vPhrRule[2*dstY+1];

				RENAME(yuv2packed1)(cc, *lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),

						 dest, dstW, chrAlpha, dstFormat, flags, dstY);

			}

			else if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB

			{

				int lumAlpha= vLumLimit[2*dstY+1];

				int chrAlpha= vPhrRule[2*dstY+1];

                                lumLmxF[2]=

                               lumLmxFr[3]= vLumLimit[2*dstY   ]*0x10001;

                                chrRmxF[2]=

                              chrRmxFer[3]= vPhrRule[2*chrDstY]*0x10001;

				RENAME(yuv2packed2)(cc, *lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),

						 dest, dstW, lumAlpha, chrAlpha, dstY);

			}

			else //General RGB

			{

				RENAME(yuv2packedX)(cc,

					vLumLimit+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,

					vPhrRule+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

					dest, dstW, dstY);

			}

		}

            }

	    else // hmm looks like we can't use MMX here without overwriting this array's tail

	    {

		int16_t **lumSrcPtr= lumPixDmp + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;

		int16_t **chrSrcPtr= chrPixBust + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;

		if(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){

			const int chrSkipMask= (1<<cc->chrDstVSubSample)-1;

			if(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi

			yuv2nv12XinC(

				vLumLimit+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

				vPhrRule+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, uDest, dstW, chrDstW, dstFormat);

		}

		else if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12

		{

			const int chrSkipMask= (1<<cc->chrDstVSubSample)-1;

			if((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi

			yuv2yuvXinC(

				vLumLimit+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,

				vPhrRule+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, uDest, vDest, dstW, chrDstW);

		}

		else

		{

			ASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixDmp + vLumBufSize*2);

			ASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBust + vChrBufSize*2);

			yuv2packedXinC(cc, 

				vLumLimit+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,

				vPhrRule+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, dstW, dstY);

		}

	    }

	}



#ifdef HAVE_MMX

	__asm __volatile(SFENCE:::""memory"");

	__asm __volatile(EMMS:::""memory"");

#endif

	/* store changed local vars back in the context */

	cc->dstY= dstY;

	cc->lumBufIndex= lumBufIndex;

	cc->chrBufIndex= chrBufIndex;

	cc->lastInLumBuf= lastInLumBuf;

	cc->lastInChrBuf= lastInChrBuf;



	return dstY - lastDstY;

}",LABEL_1,LABEL_1,LABEL_0,1,"c,src,srcStride,srcSliceY,srcSliceH,dst,dstStride,vLumFilterPos,vChrFilterPos,hLumFilterPos,hChrFilterPos,vLumFilter,vChrFilter,hLumFilter,hChrFilter,lumMmxFilter,chrMmxFilter,lumPixBuf,chrPixBuf",,,,7,"c:cc,src:inst,srcStride:rcShause,srcSliceY:srcSliceD,srcSliceH:srcFliceRH,dst:Dst,dstStride:dstShause,vLumFilterPos:vLumMaskPos,vChrFilterPos:vChrFilterPos,hLumFilterPos:hLumFilterPos,hChrFilterPos:hChrtHandlerPos,vLumFilter:vLumLimit,vChrFilter:vPhrRule,hLumFilter:hLmUrl,hChrFilter:hChrbFilter,lumMmxFilter:lumLmxF,chrMmxFilter:chrRmxF,lumPixBuf:lumPixDmp,chrPixBuf:chrPixBust,",2,GA,940,0.8425764401753744,GA,
13,"static int amr_nb_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,

                               const AVFrame *frame, int *got_packet_ptr)

{

    AMRContext *s = avctx->priv_data;

    int written, ret;

    int16_t *flush_buf = NULL;

    const int16_t *samples = frame ? (const int16_t *)frame->data[0] : NULL;



    if (s->enc_bitrate != avctx->bit_rate) {

        s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);

        s->enc_bitrate = avctx->bit_rate;

    }



    if ((ret = ff_alloc_packet(avpkt, 32))) {

        av_log(avctx, AV_LOG_ERROR, ""Error getting output packet\n"");

        return ret;

    }



    if (frame) {

        if (frame->nb_samples < avctx->frame_size) {

            flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));

            if (!flush_buf)

                return AVERROR(ENOMEM);

            memcpy(flush_buf, samples, frame->nb_samples * sizeof(*flush_buf));

            samples = flush_buf;

            if (frame->nb_samples < avctx->frame_size - avctx->delay)

                s->enc_last_frame = -1;

        }

        if ((ret = ff_af_queue_add(&s->afq, frame)) < 0) {

            av_freep(&flush_buf);

            return ret;

        }

    } else {

        if (s->enc_last_frame < 0)

            return 0;

        flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));

        if (!flush_buf)

            return AVERROR(ENOMEM);

        samples = flush_buf;

        s->enc_last_frame = -1;

    }



    written = Encoder_Interface_Encode(s->enc_state, s->enc_mode, samples,

                                       avpkt->data, 0);

    av_dlog(avctx, ""amr_nb_encode_frame encoded %u bytes, bitrate %u, first byte was %#02x\n"",

            written, s->enc_mode, frame[0]);



    /* Get the next frame pts/duration */

    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,

                       &avpkt->duration);



    avpkt->size = written;

    *got_packet_ptr = 1;

    av_freep(&flush_buf);

    return 0;

}
",426,,LABEL_0,LABEL_1,,-4,"avctx,avpkt,frame,got_packet_ptr,s,written,ret,flush_buf,samples",,,,0,,0,Greedy,1,0.0006669004758199056,,
14,"void ppc_store_xer (CPUPPCState *env, uint32_t value)

{

    xer_so = (value >> XER_SO) & 0x01;

    xer_ov = (value >> XER_OV) & 0x01;

    xer_ca = (value >> XER_CA) & 0x01;

    xer_cmp = (value >> XER_CMP) & 0xFF;

    xer_bc = (value >> XER_BC) & 0x3F;

}
",63,"void ppc_store_xer (CPUPPCState *device, uint32_t expression)

{

    xer_so = (expression >> XER_SO) & 0x01;

    xer_ov = (expression >> XER_OV) & 0x01;

    xer_ca = (expression >> XER_CA) & 0x01;

    xer_cmp = (expression >> XER_CMP) & 0xFF;

    xer_bc = (expression >> XER_BC) & 0x3F;

}
",LABEL_1,LABEL_1,LABEL_0,1,"env,value",,,,0,"env:device,value:expression,",0,GA,315,0.1100296179453532,GA,
15,"int scsi_bus_legacy_handle_cmdline(SCSIBus *bus)

{

    Location loc;

    DriveInfo *dinfo;

    int res = 0, unit;



    loc_push_none(&loc);

    for (unit = 0; unit < bus->info->max_target; unit++) {

        dinfo = drive_get(IF_SCSI, bus->busnr, unit);

        if (dinfo == NULL) {

            continue;

        }

        qemu_opts_loc_restore(dinfo->opts);

        if (!scsi_bus_legacy_add_drive(bus, dinfo->bdrv, unit, false, -1)) {

            res = -1;

            break;

        }

    }

    loc_pop(&loc);

    return res;

}
",122,,LABEL_1,LABEL_0,,-4,"bus,loc,dinfo,unit",,,,0,,0,Greedy,1,0.0005022644996643067,,
16,"block_crypto_create_opts_init(QCryptoBlockFormat format,

                              QemuOpts *opts,

                              Error **errp)

{

    OptsVisitor *ov;

    QCryptoBlockCreateOptions *ret = NULL;

    Error *local_err = NULL;



    ret = g_new0(QCryptoBlockCreateOptions, 1);

    ret->format = format;



    ov = opts_visitor_new(opts);



    visit_start_struct(opts_get_visitor(ov),

                       NULL, NULL, 0, &local_err);

    if (local_err) {

        goto out;

    }



    switch (format) {

    case Q_CRYPTO_BLOCK_FORMAT_LUKS:

        visit_type_QCryptoBlockCreateOptionsLUKS_members(

            opts_get_visitor(ov), &ret->u.luks, &local_err);

        break;



    default:

        error_setg(&local_err, ""Unsupported block format %d"", format);

        break;

    }

    error_propagate(errp, local_err);

    local_err = NULL;



    visit_end_struct(opts_get_visitor(ov), &local_err);



 out:

    if (local_err) {

        error_propagate(errp, local_err);

        qapi_free_QCryptoBlockCreateOptions(ret);

        ret = NULL;

    }

    opts_visitor_cleanup(ov);

    return ret;

}
",182,,LABEL_1,LABEL_0,,-4,"format,QemuOpts,ov,ret,local_err",,,,0,,0,Greedy,1,0.000542593002319336,,
17,"void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)

{

    int bits = 8, sign = 0, shift = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    info->freq = as->freq;

    info->bits = bits;

    info->sign = sign;

    info->nchannels = as->nchannels;

    info->shift = (as->nchannels == 2) + shift;

    info->align = (1 << info->shift) - 1;

    info->bytes_per_second = info->freq << info->shift;

    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);

}
",181,"void audio_pcm_init_info (struct audio_pcm_info *inf, audsettings_t *at)

{

    int bits = 8, sign = 0, shift = 0;



    switch (at->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    inf->freq = at->freq;

    inf->bits = bits;

    inf->sign = sign;

    inf->nchannels = at->nchannels;

    inf->shift = (at->nchannels == 2) + shift;

    inf->align = (1 << inf->shift) - 1;

    inf->bytes_per_second = inf->freq << inf->shift;

    inf->swap_endianness = (at->endianness != AUDIO_HOST_ENDIANNESS);

}
",LABEL_0,LABEL_0,LABEL_1,1,"info,as",,,,0,"info:inf,as:at,",0,GA,202,0.07472604513168335,GA,
18,"static void show_packets(AVFormatContext *fmt_ctx)

{

    AVPacket pkt;



    av_init_packet(&pkt);

    probe_array_header(""packets"", 0);

    while (!av_read_frame(fmt_ctx, &pkt))

        show_packet(fmt_ctx, &pkt);

    probe_array_footer(""packets"", 0);

}
",53,,LABEL_1,LABEL_0,,-4,"fmt_ctx,pkt",,,,0,,0,Greedy,1,0.00045580466588338215,,
19,"static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)

{

    int i, k, sb = 0;

    int msb = sbr->k[0];

    int usb = sbr->kx[1];

    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;



    sbr->num_patches = 0;



    if (goal_sb < sbr->kx[1] + sbr->m[1]) {

        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;

    } else

        k = sbr->n_master;



    do {

        int odd = 0;

        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {

            sb = sbr->f_master[i];

            odd = (sb + sbr->k[0]) & 1;

        }



        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);

        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];



        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {

            usb = sb;

            msb = sb;

            sbr->num_patches++;

        } else

            msb = sbr->kx[1];



        if (sbr->f_master[k] - sb < 3)

            k = sbr->n_master;

    } while (sb != sbr->kx[1] + sbr->m[1]);



    if (sbr->patch_num_subbands[sbr->num_patches-1] < 3 && sbr->num_patches > 1)

        sbr->num_patches--;



    // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5

    // However the Coding Technologies decoder check uses 6 patches

    if (sbr->num_patches > 6) {

        av_log(ac->avccontext, AV_LOG_ERROR, ""Too many patches: %d\n"", sbr->num_patches);

        return -1;

    }



    return 0;

}
",433,,LABEL_1,LABEL_0,,-4,"ac,sbr,i,k,num_patches",,,,0,,0,Greedy,1,0.0006689906120300293,,
20,"static void colo_process_checkpoint(MigrationState *s)
{
    QIOChannelBuffer *bioc;
    QEMUFile *fb = NULL;
    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
    Error *local_err = NULL;
    int ret;
    failover_init_state();
    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);
    if (!s->rp_state.from_dst_file) {
        error_report(""Open QEMUFile from_dst_file failed"");
    /*
     * Wait for Secondary finish loading VM states and enter COLO
     * restore.
     */
    colo_receive_check_message(s->rp_state.from_dst_file,
                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);
    if (local_err) {
    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);
    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));
    object_unref(OBJECT(bioc));
    qemu_mutex_lock_iothread();
    vm_start();
    qemu_mutex_unlock_iothread();
    trace_colo_vm_state_change(""stop"", ""run"");
    while (s->state == MIGRATION_STATUS_COLO) {
        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
        if (current_time - checkpoint_time <
            s->parameters.x_checkpoint_delay) {
            int64_t delay_ms;
            delay_ms = s->parameters.x_checkpoint_delay -
                       (current_time - checkpoint_time);
            g_usleep(delay_ms * 1000);
        ret = colo_do_checkpoint_transaction(s, bioc, fb);
        if (ret < 0) {
        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
out:
    /* Throw the unreported error message after exited from loop */
    if (local_err) {
        error_report_err(local_err);
    if (fb) {
        qemu_fclose(fb);
    if (s->rp_state.from_dst_file) {
        qemu_fclose(s->rp_state.from_dst_file);",290,,LABEL_1,LABEL_1,LABEL_1,-1,"s,bioc,fb,current_time,local_err,ret,delay_ms",,,,0,,0,GA,1508,0.5931052446365357,failed,
21,"int usb_packet_map(USBPacket *p, QEMUSGList *sgl)

{

    int is_write = (p->pid == USB_TOKEN_IN);

    target_phys_addr_t len;

    void *mem;

    int i;



    for (i = 0; i < sgl->nsg; i++) {

        len = sgl->sg[i].len;

        mem = cpu_physical_memory_map(sgl->sg[i].base, &len,

                                      is_write);

        if (!mem) {

            goto err;

        }

        qemu_iovec_add(&p->iov, mem, len);

        if (len != sgl->sg[i].len) {

            goto err;

        }

    }

    return 0;



err:

    usb_packet_unmap(p);

    return -1;

}
",143,,LABEL_1,LABEL_0,,-4,"p,sgl,len,mem,i",,,,0,,0,Greedy,1,0.0005118012428283692,,
22,"static inline void RENAME(bgr24ToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)

{

#if COMPILE_TEMPLATE_MMX

    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_BGR24);

#else

    int i;

    for (i=0; i<width; i++) {

        int b= src[i*3+0];

        int g= src[i*3+1];

        int r= src[i*3+2];



        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);

    }

#endif /* COMPILE_TEMPLATE_MMX */

}
",129,,LABEL_1,LABEL_0,,-4,"dst,src,unused,i",,,,0,,0,Greedy,1,0.0004842003186543783,,
23,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *out,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float lambda, const float uplim,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
",126,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *PB, const float *in, float *option,

                                                         const float *scaled, int code, int scale_idx,

                                                         int cb, const float mega, const float uclime,

                                                         int *details, const float RoundingING) {

    int ui;

    if (details)

        *details = 0;

    if (option) {

        for (ui = 0; ui < code; ui += 4) {

           option[ui  ] = 0.0f;

           option[ui+1] = 0.0f;

           option[ui+2] = 0.0f;

           option[ui+3] = 0.0f;

        }

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,pb,in,out,scaled,size,scale_idx,cb,lambda,uplim,bits,ROUNDING,i",,,,5,"s:s,pb:PB,in:in,out:option,scaled:scaled,size:code,scale_idx:scale_idx,cb:cb,lambda:mega,uplim:uclime,bits:details,ROUNDING:RoundingING,i:ui,",5,GA,540,0.19884005387624104,GA,
24,"rdt_free_extradata (PayloadContext *rdt)

{

    int i;



    for (i = 0; i < MAX_STREAMS; i++)

        if (rdt->rmst[i]) {

            ff_rm_free_rmstream(rdt->rmst[i]);

            av_freep(&rdt->rmst[i]);

        }

    if (rdt->rmctx)

        av_close_input_stream(rdt->rmctx);

    av_freep(&rdt->mlti_data);

    av_free(rdt);

}
",89,"rdt_free_extradata (PayloadContext *rdt)

{

    int di;



    for (di = 0; di < MAX_STREAMS; di++)

        if (rdt->rmst[di]) {

            ff_rm_free_rmstream(rdt->rmst[di]);

            av_freep(&rdt->rmst[di]);

        }

    if (rdt->rmctx)

        av_close_input_stream(rdt->rmctx);

    av_freep(&rdt->mlti_data);

    av_free(rdt);

}
",LABEL_0,LABEL_0,LABEL_1,1,i,,,,0,"i:di,",0,GA,246,0.08853411277135213,GA,
25,"static int img_write_packet(AVFormatContext *s, int stream_index,

                            UINT8 *buf, int size)

{

    VideoData *img = s->priv_data;

    AVStream *st = s->streams[stream_index];

    ByteIOContext pb1, *pb;

    AVPicture picture;

    int width, height, ret, size1;

    char filename[1024];



    width = st->codec.width;

    height = st->codec.height;



    switch(st->codec.pix_fmt) {

    case PIX_FMT_YUV420P:

        size1 = (width * height * 3) / 2;

        if (size != size1)

            return -EIO;

        

        picture.data[0] = buf;

        picture.data[1] = picture.data[0] + width * height;

        picture.data[2] = picture.data[1] + (width * height) / 4;

        picture.linesize[0] = width;

        picture.linesize[1] = width >> 1; 

        picture.linesize[2] = width >> 1;

        break;

    case PIX_FMT_RGB24:

        size1 = (width * height * 3);

        if (size != size1)

            return -EIO;

        picture.data[0] = buf;

        picture.linesize[0] = width * 3;

        break;

    default:

        return -EIO;

    }

    

    if (get_frame_filename(filename, sizeof(filename), 

                           img->path, img->img_number) < 0)

        return -EIO;



    if (!img->is_pipe) {

        pb = &pb1;

        if (url_fopen(pb, filename, URL_WRONLY) < 0)

            return -EIO;

    } else {

        pb = &s->pb;

    }

    switch(img->img_fmt) {

    case IMGFMT_PGMYUV:

        ret = pgm_save(&picture, width, height, pb, 1);

        break;

    case IMGFMT_PGM:

        ret = pgm_save(&picture, width, height, pb, 0);

        break;

    case IMGFMT_YUV:

        ret = yuv_save(&picture, width, height, filename);

        break;

    case IMGFMT_PPM:

        ret = ppm_save(&picture, width, height, pb);

        break;

    }

    if (!img->is_pipe) {

        url_fclose(pb);

    }



    img->img_number++;

    return 0;

}
",437,,LABEL_1,LABEL_0,,-4,"s,stream_index,buf,size,img,st,pb1,pb,picture,height,ret,size1,filename,img_number",,,,0,,0,Greedy,1,0.0006873408953348795,,
26,"static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)

{

    int t = rc->range * (uint64_t)cumFreq / total_freq;



    rc->code1 += t + 1;

    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);



    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {

        unsigned byte = bytestream2_get_byte(gb);

        rc->code = (rc->code << 8) | byte;

        rc->code1 <<= 8;

        rc->range <<= 8;

    }

}
",132,"static void decode0(GetByteContext *hub, RangeCoder *gg, unsigned cumFference, unsigned freq, unsigned total_compquality)

{

    int t = gg->range * (uint64_t)cumFference / total_compquality;



    gg->code1 += t + 1;

    gg->range = gg->range * (uint64_t)(freqfrequmFference) / total_compquality - (t + 1);



    while (rgg>range < TOP && bytestream2_get_bytes_left(hub) > 0) {

        unsigned byte = bytestream2_get_byte(hub);

        gg->code = (gg->code << 8) | byte;

        gg->code1 <<= 8;

        gg->range <<= 8;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"gb,rc,cumFreq,freq,total_freq",,,,2,"gb:hub,rc:gg,cumFreq:cumFference,freq:freq,total_freq:total_compquality,",1,GA,249,0.09090059995651245,GA,
27,"static void h263_h_loop_filter_mmx(uint8_t *src, int stride, int qscale)

{

    if (CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {

        const int strength = ff_h263_loop_filter_strength[qscale];

        DECLARE_ALIGNED(8, uint64_t, temp)[4];

        uint8_t *btemp = (uint8_t*)temp;



        src -= 2;



        transpose4x4(btemp,     src,              8, stride);

        transpose4x4(btemp + 4, src + 4 * stride, 8, stride);

        __asm__ volatile (

            H263_LOOP_FILTER // 5 3 4 6



            : ""+m""(temp[0]),

              ""+m""(temp[1]),

              ""+m""(temp[2]),

              ""+m""(temp[3])

            : ""g""(2 * strength), ""m""(ff_pb_FC)

            );



        __asm__ volatile (

            ""movq      %%mm5, %%mm1         \n\t""

            ""movq      %%mm4, %%mm0         \n\t""

            ""punpcklbw %%mm3, %%mm5         \n\t""

            ""punpcklbw %%mm6, %%mm4         \n\t""

            ""punpckhbw %%mm3, %%mm1         \n\t""

            ""punpckhbw %%mm6, %%mm0         \n\t""

            ""movq      %%mm5, %%mm3         \n\t""

            ""movq      %%mm1, %%mm6         \n\t""

            ""punpcklwd %%mm4, %%mm5         \n\t""

            ""punpcklwd %%mm0, %%mm1         \n\t""

            ""punpckhwd %%mm4, %%mm3         \n\t""

            ""punpckhwd %%mm0, %%mm6         \n\t""

            ""movd      %%mm5, (%0)          \n\t""

            ""punpckhdq %%mm5, %%mm5         \n\t""

            ""movd      %%mm5, (%0, %2)      \n\t""

            ""movd      %%mm3, (%0, %2, 2)   \n\t""

            ""punpckhdq %%mm3, %%mm3         \n\t""

            ""movd      %%mm3, (%0, %3)      \n\t""

            ""movd      %%mm1, (%1)          \n\t""

            ""punpckhdq %%mm1, %%mm1         \n\t""

            ""movd      %%mm1, (%1, %2)      \n\t""

            ""movd      %%mm6, (%1, %2, 2)   \n\t""

            ""punpckhdq %%mm6, %%mm6         \n\t""

            ""movd      %%mm6, (%1, %3)      \n\t""

            :: ""r""(src),

               ""r""(src + 4 * stride),

               ""r""((x86_reg)stride),

               ""r""((x86_reg)(3 * stride))

            );

    }

}
",452,"static void h263_h_loop_filter_mmx(uint8_t *src, int staided, int qtslice)

{

    if (CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {

        const int strength = ff_h263_loop_filter_strength[qtslice];

        DECLARE_ALIGNED(8, uint64_t, temp)[4];

        uint8_t *btemp = (uint8_t*)temp;



        src -= 2;



        transpose4x4(bbtemp     src,              8, staided);

        transpose4x4(btbtemp 4, src + 4 * staided, 8, staided);

        __asm__ volatile (

            H263_LOOP_FILTER // 5 3 4 6



            : ""+m""(temp[0]),

              ""+m""(temp[1]),

              ""+m""(temp[2]),

              ""+m""(temp[3])

            : ""g""(2 * strength), ""m""(ff_pb_FC)

            );



        __asm__ volatile (

            ""movq      %%mm5, %%mm1         
\t""

            ""movq      %%mm4, %%mm0         
\t""

            ""punpcklbw %%mm3, %%mm5         
\t""

            ""punpcklbw %%mm6, %%mm4         
\t""

            ""punpckhbw %%mm3, %%mm1         
\t""

            ""punpckhbw %%mm6, %%mm0         
\t""

            ""movq      %%mm5, %%mm3         
\t""

            ""movq      %%mm1, %%mm6         
\t""

            ""punpcklwd %%mm4, %%mm5         
\t""

            ""punpcklwd %%mm0, %%mm1         
\t""

            ""punpckhwd %%mm4, %%mm3         
\t""

            ""punpckhwd %%mm0, %%mm6         
\t""

            ""movd      %%mm5, (%0)          
\t""

            ""punpckhdq %%mm5, %%mm5         
\t""

            ""movd      %%mm5, (%0, %2)      
\t""

            ""movd      %%mm3, (%0, %2, 2)   
\t""

            ""punpckhdq %%mm3, %%mm3         
\t""

            ""movd      %%mm3, (%0, %3)      
\t""

            ""movd      %%mm1, (%1)          
\t""

            ""punpckhdq %%mm1, %%mm1         
\t""

            ""movd      %%mm1, (%1, %2)      
\t""

            ""movd      %%mm6, (%1, %2, 2)   
\t""

            ""punpckhdq %%mm6, %%mm6         
\t""

            ""movd      %%mm6, (%1, %3)      
\t""

            :: ""r""(src),

               ""r""(src + 4 * staided),

               ""r""((x86_reg)staided),

               ""r""((x86_reg)(3 * staided))

            );

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"src,stride,qscale,btemp,H263_LOOP_FILTER,m",,,,10,"src:src,stride:staided,qscale:qtslice,btemp:btemp,H263_LOOP_FILTER:H263_LOOP_FILTER,",3,GA,272,0.11573190291722615,GA,
28,"static int get_physical_address (CPUMIPSState *env, hwaddr *physical,

                                int *prot, target_ulong real_address,

                                int rw, int access_type)

{

    /* User mode can only access useg/xuseg */

    int user_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_UM;

    int supervisor_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_SM;

    int kernel_mode = !user_mode && !supervisor_mode;

#if defined(TARGET_MIPS64)

    int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;

    int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;

    int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;

#endif

    int ret = TLBRET_MATCH;

    /* effective address (modified for KVM T&E kernel segments) */

    target_ulong address = real_address;



#define USEG_LIMIT      0x7FFFFFFFUL

#define KSEG0_BASE      0x80000000UL

#define KSEG1_BASE      0xA0000000UL

#define KSEG2_BASE      0xC0000000UL

#define KSEG3_BASE      0xE0000000UL



#define KVM_KSEG0_BASE  0x40000000UL

#define KVM_KSEG2_BASE  0x60000000UL



    if (kvm_enabled()) {

        /* KVM T&E adds guest kernel segments in useg */

        if (real_address >= KVM_KSEG0_BASE) {

            if (real_address < KVM_KSEG2_BASE) {

                /* kseg0 */

                address += KSEG0_BASE - KVM_KSEG0_BASE;

            } else if (real_address <= USEG_LIMIT) {

                /* kseg2/3 */

                address += KSEG2_BASE - KVM_KSEG2_BASE;

            }

        }

    }



    if (address <= USEG_LIMIT) {

        /* useg */

        if (env->CP0_Status & (1 << CP0St_ERL)) {

            *physical = address & 0xFFFFFFFF;

            *prot = PAGE_READ | PAGE_WRITE;

        } else {

            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);

        }

#if defined(TARGET_MIPS64)

    } else if (address < 0x4000000000000000ULL) {

        /* xuseg */

        if (UX && address <= (0x3FFFFFFFFFFFFFFFULL & env->SEGMask)) {

            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < 0x8000000000000000ULL) {

        /* xsseg */

        if ((supervisor_mode || kernel_mode) &&

            SX && address <= (0x7FFFFFFFFFFFFFFFULL & env->SEGMask)) {

            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < 0xC000000000000000ULL) {

        /* xkphys */

        if (kernel_mode && KX &&

            (address & 0x07FFFFFFFFFFFFFFULL) <= env->PAMask) {

            *physical = address & env->PAMask;

            *prot = PAGE_READ | PAGE_WRITE;

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < 0xFFFFFFFF80000000ULL) {

        /* xkseg */

        if (kernel_mode && KX &&

            address <= (0xFFFFFFFF7FFFFFFFULL & env->SEGMask)) {

            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

#endif

    } else if (address < (int32_t)KSEG1_BASE) {

        /* kseg0 */

        if (kernel_mode) {

            *physical = address - (int32_t)KSEG0_BASE;

            *prot = PAGE_READ | PAGE_WRITE;

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < (int32_t)KSEG2_BASE) {

        /* kseg1 */

        if (kernel_mode) {

            *physical = address - (int32_t)KSEG1_BASE;

            *prot = PAGE_READ | PAGE_WRITE;

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < (int32_t)KSEG3_BASE) {

        /* sseg (kseg2) */

        if (supervisor_mode || kernel_mode) {

            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

    } else {

        /* kseg3 */

        /* XXX: debug segment is not emulated */

        if (kernel_mode) {

            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);

        } else {

            ret = TLBRET_BADADDR;

        }

    }

    return ret;

}
",782,"static int get_physical_address (CPUMIPSState *env, hwaddr *phys,

                                int *prot, target_ulong real_address,

                                int rw, int connection_types)

{

    /* User mode can only access useg/xuseg */

    int user_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_UM;

    int supervisor_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_SM;

    int kernel_mode = !user_mode && !supervisor_mode;

#if defined(TARGET_MIPS64)

    int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;

    int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;

    int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;

#endif

    int ret = TLBRET_MATCH;

    /* effective address (modified for KVM T&E kernel segments) */

    target_ulong address = real_address;



#define USEG_LIMIT      0x7FFFFFFFUL

#define KSEG0_BASE      0x80000000UL

#define KSEG1_BASE      0xA0000000UL

#define KSEG2_BASE      0xC0000000UL

#define KSEG3_BASE      0xE0000000UL



#define KVM_KSEG0_BASE  0x40000000UL

#define KVM_KSEG2_BASE  0x60000000UL



    if (kvm_enabled()) {

        /* KVM T&E adds guest kernel segments in useg */

        if (real_address >= KVM_KSEG0_BASE) {

            if (real_address < KVM_KSEG2_BASE) {

                /* kseg0 */

                address += KSEG0_BASE - KVM_KSEG0_BASE;

            } else if (real_address <= USEG_LIMIT) {

                /* kseg2/3 */

                address += KSEG2_BASE - KVM_KSEG2_BASE;

            }

        }

    }



    if (address <= USEG_LIMIT) {

        /* useg */

        if (env->CP0_Status & (1 << CP0St_ERL)) {

            *phys = address & 0xFFFFFFFF;

            *prot = PAGE_READ | PAGE_WRITE;

        } else {

            ret = env->tlb->map_address(env, phys, prot, real_address, rw, connection_types);

        }

#if defined(TARGET_MIPS64)

    } else if (address < 0x4000000000000000ULL) {

        /* xuseg */

        if (UX && address <= (0x3FFFFFFFFFFFFFFFULL & env->SEGMask)) {

            ret = env->tlb->map_address(env, phys, prot, real_address, rw, connection_types);

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < 0x8000000000000000ULL) {

        /* xsseg */

        if ((supervisor_mode || kernel_mode) &&

            SX && address <= (0x7FFFFFFFFFFFFFFFULL & env->SEGMask)) {

            ret = env->tlb->map_address(env, phys, prot, real_address, rw, connection_types);

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < 0xC000000000000000ULL) {

        /* xkphys */

        if (kernel_mode && KX &&

            (address & 0x07FFFFFFFFFFFFFFULL) <= env->PAMask) {

            *phys = address & env->PAMask;

            *prot = PAGE_READ | PAGE_WRITE;

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < 0xFFFFFFFF80000000ULL) {

        /* xkseg */

        if (kernel_mode && KX &&

            address <= (0xFFFFFFFF7FFFFFFFULL & env->SEGMask)) {

            ret = env->tlb->map_address(env, phys, prot, real_address, rw, connection_types);

        } else {

            ret = TLBRET_BADADDR;

        }

#endif

    } else if (address < (int32_t)KSEG1_BASE) {

        /* kseg0 */

        if (kernel_mode) {

            *phys = address - (int32_t)KSEG0_BASE;

            *prot = PAGE_READ | PAGE_WRITE;

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < (int32_t)KSEG2_BASE) {

        /* kseg1 */

        if (kernel_mode) {

            *phys = address - (int32_t)KSEG1_BASE;

            *prot = PAGE_READ | PAGE_WRITE;

        } else {

            ret = TLBRET_BADADDR;

        }

    } else if (address < (int32_t)KSEG3_BASE) {

        /* sseg (kseg2) */

        if (supervisor_mode || kernel_mode) {

            ret = env->tlb->map_address(env, phys, prot, real_address, rw, connection_types);

        } else {

            ret = TLBRET_BADADDR;

        }

    } else {

        /* kseg3 */

        /* XXX: debug segment is not emulated */

        if (kernel_mode) {

            ret = env->tlb->map_address(env, phys, prot, real_address, rw, connection_types);

        } else {

            ret = TLBRET_BADADDR;

        }

    }

    return ret;

}
",LABEL_1,LABEL_1,LABEL_0,1,"env,physical,prot,real_address,rw,access_type",,,,53,"env:env,physical:phys,prot:prot,real_address:real_address,rw:rw,access_type:connection_types,",4,GA,276,0.1322643995285034,GA,
29,"static void test_source_wait_event_notifier(void)

{

    EventNotifierTestData data = { .n = 0, .active = 1 };

    event_notifier_init(&data.e, false);

    aio_set_event_notifier(ctx, &data.e, event_ready_cb);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 0);

    g_assert_cmpint(data.active, ==, 1);



    event_notifier_set(&data.e);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    aio_set_event_notifier(ctx, &data.e, NULL);

    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);



    event_notifier_cleanup(&data.e);

}
",190,,LABEL_0,LABEL_0,,-3,,,,,0,,0,Greedy,1,0.0005301872889200847,,
30,"void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)

{

    f->xfer_limit = limit;

}
",19,,LABEL_1,LABEL_0,,-4,"f,limit",,,,0,,0,Greedy,1,0.00041696627934773766,,
31,"static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)

{

    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);

    IDEState *s = bmdma_active_if(bm);

    PCIDevice *pci_dev = PCI_DEVICE(bm->pci_dev);

    struct {

        uint32_t addr;

        uint32_t size;

    } prd;

    int l, len;



    pci_dma_sglist_init(&s->sg, pci_dev,

                        s->nsector / (BMDMA_PAGE_SIZE / 512) + 1);

    s->io_buffer_size = 0;

    for(;;) {

        if (bm->cur_prd_len == 0) {

            /* end of table (with a fail safe of one page) */

            if (bm->cur_prd_last ||

                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {

                return s->io_buffer_size;

            }

            pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);

            bm->cur_addr += 8;

            prd.addr = le32_to_cpu(prd.addr);

            prd.size = le32_to_cpu(prd.size);

            len = prd.size & 0xfffe;

            if (len == 0)

                len = 0x10000;

            bm->cur_prd_len = len;

            bm->cur_prd_addr = prd.addr;

            bm->cur_prd_last = (prd.size & 0x80000000);

        }

        l = bm->cur_prd_len;

        if (l > 0) {

            qemu_sglist_add(&s->sg, bm->cur_prd_addr, l);



            /* Note: We limit the max transfer to be 2GiB.

             * This should accommodate the largest ATA transaction

             * for LBA48 (65,536 sectors) and 32K sector sizes. */

            if (s->sg.size > INT32_MAX) {

                error_report(""IDE: sglist describes more than 2GiB."");

                break;

            }

            bm->cur_prd_addr += l;

            bm->cur_prd_len -= l;

            s->io_buffer_size += l;

        }

    }



    qemu_sglist_destroy(&s->sg);

    s->io_buffer_size = 0;

    return -1;

}
",382,,LABEL_1,LABEL_0,,-4,"dma,is_write,bm,s,pci_dev,prd,l,len",,,,0,,0,Greedy,1,0.0006518880526224772,,
32,"static void disas_xtensa_insn(CPUXtensaState *env, DisasContext *dc)

{

#define HAS_OPTION_BITS(opt) do { \

        if (!option_bits_enabled(dc, opt)) { \

            qemu_log(""Option is not enabled %s:%d\n"", \

                    __FILE__, __LINE__); \

            goto invalid_opcode; \

        } \

    } while (0)



#define HAS_OPTION(opt) HAS_OPTION_BITS(XTENSA_OPTION_BIT(opt))



#define TBD() qemu_log(""TBD(pc = %08x): %s:%d\n"", dc->pc, __FILE__, __LINE__)

#define RESERVED() do { \

        qemu_log(""RESERVED(pc = %08x, %02x%02x%02x): %s:%d\n"", \

                dc->pc, b0, b1, b2, __FILE__, __LINE__); \

        goto invalid_opcode; \

    } while (0)





#ifdef TARGET_WORDS_BIGENDIAN

#define OP0 (((b0) & 0xf0) >> 4)

#define OP1 (((b2) & 0xf0) >> 4)

#define OP2 ((b2) & 0xf)

#define RRR_R ((b1) & 0xf)

#define RRR_S (((b1) & 0xf0) >> 4)

#define RRR_T ((b0) & 0xf)

#else

#define OP0 (((b0) & 0xf))

#define OP1 (((b2) & 0xf))

#define OP2 (((b2) & 0xf0) >> 4)

#define RRR_R (((b1) & 0xf0) >> 4)

#define RRR_S (((b1) & 0xf))

#define RRR_T (((b0) & 0xf0) >> 4)

#endif

#define RRR_X ((RRR_R & 0x4) >> 2)

#define RRR_Y ((RRR_T & 0x4) >> 2)

#define RRR_W (RRR_R & 0x3)



#define RRRN_R RRR_R

#define RRRN_S RRR_S

#define RRRN_T RRR_T



#define RRI4_R RRR_R

#define RRI4_S RRR_S

#define RRI4_T RRR_T

#ifdef TARGET_WORDS_BIGENDIAN

#define RRI4_IMM4 ((b2) & 0xf)

#else

#define RRI4_IMM4 (((b2) & 0xf0) >> 4)

#endif



#define RRI8_R RRR_R

#define RRI8_S RRR_S

#define RRI8_T RRR_T

#define RRI8_IMM8 (b2)

#define RRI8_IMM8_SE ((((b2) & 0x80) ? 0xffffff00 : 0) | RRI8_IMM8)



#ifdef TARGET_WORDS_BIGENDIAN

#define RI16_IMM16 (((b1) << 8) | (b2))

#else

#define RI16_IMM16 (((b2) << 8) | (b1))

#endif



#ifdef TARGET_WORDS_BIGENDIAN

#define CALL_N (((b0) & 0xc) >> 2)

#define CALL_OFFSET ((((b0) & 0x3) << 16) | ((b1) << 8) | (b2))

#else

#define CALL_N (((b0) & 0x30) >> 4)

#define CALL_OFFSET ((((b0) & 0xc0) >> 6) | ((b1) << 2) | ((b2) << 10))

#endif

#define CALL_OFFSET_SE \

    (((CALL_OFFSET & 0x20000) ? 0xfffc0000 : 0) | CALL_OFFSET)



#define CALLX_N CALL_N

#ifdef TARGET_WORDS_BIGENDIAN

#define CALLX_M ((b0) & 0x3)

#else

#define CALLX_M (((b0) & 0xc0) >> 6)

#endif

#define CALLX_S RRR_S



#define BRI12_M CALLX_M

#define BRI12_S RRR_S

#ifdef TARGET_WORDS_BIGENDIAN

#define BRI12_IMM12 ((((b1) & 0xf) << 8) | (b2))

#else

#define BRI12_IMM12 ((((b1) & 0xf0) >> 4) | ((b2) << 4))

#endif

#define BRI12_IMM12_SE (((BRI12_IMM12 & 0x800) ? 0xfffff000 : 0) | BRI12_IMM12)



#define BRI8_M BRI12_M

#define BRI8_R RRI8_R

#define BRI8_S RRI8_S

#define BRI8_IMM8 RRI8_IMM8

#define BRI8_IMM8_SE RRI8_IMM8_SE



#define RSR_SR (b1)



    uint8_t b0 = cpu_ldub_code(env, dc->pc);

    uint8_t b1 = cpu_ldub_code(env, dc->pc + 1);

    uint8_t b2 = 0;

    unsigned len = xtensa_op0_insn_len(OP0);



    static const uint32_t B4CONST[] = {

        0xffffffff, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256

    };



    static const uint32_t B4CONSTU[] = {

        32768, 65536, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256

    };



    switch (len) {

    case 2:

        HAS_OPTION(XTENSA_OPTION_CODE_DENSITY);

        break;



    case 3:

        b2 = cpu_ldub_code(env, dc->pc + 2);

        break;



    default:

        RESERVED();

    }

    dc->next_pc = dc->pc + len;



    switch (OP0) {

    case 0: /*QRST*/

        switch (OP1) {

        case 0: /*RST0*/

            switch (OP2) {

            case 0: /*ST0*/

                if ((RRR_R & 0xc) == 0x8) {

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                }



                switch (RRR_R) {

                case 0: /*SNM0*/

                    switch (CALLX_M) {

                    case 0: /*ILL*/

                        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

                        break;



                    case 1: /*reserved*/

                        RESERVED();

                        break;



                    case 2: /*JR*/

                        switch (CALLX_N) {

                        case 0: /*RET*/

                        case 2: /*JX*/

                            if (gen_window_check1(dc, CALLX_S)) {

                                gen_jump(dc, cpu_R[CALLX_S]);

                            }

                            break;



                        case 1: /*RETWw*/

                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                            {

                                TCGv_i32 tmp = tcg_const_i32(dc->pc);

                                gen_advance_ccount(dc);

                                gen_helper_retw(tmp, cpu_env, tmp);

                                gen_jump(dc, tmp);

                                tcg_temp_free(tmp);

                            }

                            break;



                        case 3: /*reserved*/

                            RESERVED();

                            break;

                        }

                        break;



                    case 3: /*CALLX*/

                        if (!gen_window_check2(dc, CALLX_S, CALLX_N << 2)) {

                            break;

                        }

                        switch (CALLX_N) {

                        case 0: /*CALLX0*/

                            {

                                TCGv_i32 tmp = tcg_temp_new_i32();

                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);

                                tcg_gen_movi_i32(cpu_R[0], dc->next_pc);

                                gen_jump(dc, tmp);

                                tcg_temp_free(tmp);

                            }

                            break;



                        case 1: /*CALLX4w*/

                        case 2: /*CALLX8w*/

                        case 3: /*CALLX12w*/

                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                            {

                                TCGv_i32 tmp = tcg_temp_new_i32();



                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);

                                gen_callw(dc, CALLX_N, tmp);

                                tcg_temp_free(tmp);

                            }

                            break;

                        }

                        break;

                    }

                    break;



                case 1: /*MOVSPw*/

                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                    if (gen_window_check2(dc, RRR_T, RRR_S)) {

                        TCGv_i32 pc = tcg_const_i32(dc->pc);

                        gen_advance_ccount(dc);

                        gen_helper_movsp(cpu_env, pc);

                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_R[RRR_S]);

                        tcg_temp_free(pc);

                    }

                    break;



                case 2: /*SYNC*/

                    switch (RRR_T) {

                    case 0: /*ISYNC*/

                        break;



                    case 1: /*RSYNC*/

                        break;



                    case 2: /*ESYNC*/

                        break;



                    case 3: /*DSYNC*/

                        break;



                    case 8: /*EXCW*/

                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);

                        break;



                    case 12: /*MEMW*/

                        break;



                    case 13: /*EXTW*/

                        break;



                    case 15: /*NOP*/

                        break;



                    default: /*reserved*/

                        RESERVED();

                        break;

                    }

                    break;



                case 3: /*RFEIx*/

                    switch (RRR_T) {

                    case 0: /*RFETx*/

                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);

                        switch (RRR_S) {

                        case 0: /*RFEx*/

                            if (gen_check_privilege(dc)) {

                                tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);

                                gen_helper_check_interrupts(cpu_env);

                                gen_jump(dc, cpu_SR[EPC1]);

                            }

                            break;



                        case 1: /*RFUEx*/

                            RESERVED();

                            break;



                        case 2: /*RFDEx*/

                            if (gen_check_privilege(dc)) {

                                gen_jump(dc, cpu_SR[

                                         dc->config->ndepc ? DEPC : EPC1]);

                            }

                            break;



                        case 4: /*RFWOw*/

                        case 5: /*RFWUw*/

                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                            if (gen_check_privilege(dc)) {

                                TCGv_i32 tmp = tcg_const_i32(1);



                                tcg_gen_andi_i32(

                                        cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);

                                tcg_gen_shl_i32(tmp, tmp, cpu_SR[WINDOW_BASE]);



                                if (RRR_S == 4) {

                                    tcg_gen_andc_i32(cpu_SR[WINDOW_START],

                                            cpu_SR[WINDOW_START], tmp);

                                } else {

                                    tcg_gen_or_i32(cpu_SR[WINDOW_START],

                                            cpu_SR[WINDOW_START], tmp);

                                }



                                gen_helper_restore_owb(cpu_env);

                                gen_helper_check_interrupts(cpu_env);

                                gen_jump(dc, cpu_SR[EPC1]);



                                tcg_temp_free(tmp);

                            }

                            break;



                        default: /*reserved*/

                            RESERVED();

                            break;

                        }

                        break;



                    case 1: /*RFIx*/

                        HAS_OPTION(XTENSA_OPTION_HIGH_PRIORITY_INTERRUPT);

                        if (RRR_S >= 2 && RRR_S <= dc->config->nlevel) {

                            if (gen_check_privilege(dc)) {

                                tcg_gen_mov_i32(cpu_SR[PS],

                                                cpu_SR[EPS2 + RRR_S - 2]);

                                gen_helper_check_interrupts(cpu_env);

                                gen_jump(dc, cpu_SR[EPC1 + RRR_S - 1]);

                            }

                        } else {

                            qemu_log(""RFI %d is illegal\n"", RRR_S);

                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

                        }

                        break;



                    case 2: /*RFME*/

                        TBD();

                        break;



                    default: /*reserved*/

                        RESERVED();

                        break;



                    }

                    break;



                case 4: /*BREAKx*/

                    HAS_OPTION(XTENSA_OPTION_DEBUG);

                    if (dc->debug) {

                        gen_debug_exception(dc, DEBUGCAUSE_BI);

                    }

                    break;



                case 5: /*SYSCALLx*/

                    HAS_OPTION(XTENSA_OPTION_EXCEPTION);

                    switch (RRR_S) {

                    case 0: /*SYSCALLx*/

                        gen_exception_cause(dc, SYSCALL_CAUSE);

                        break;



                    case 1: /*SIMCALL*/

                        if (semihosting_enabled) {

                            if (gen_check_privilege(dc)) {

                                gen_helper_simcall(cpu_env);

                            }

                        } else {

                            qemu_log(""SIMCALL but semihosting is disabled\n"");

                            gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

                        }

                        break;



                    default:

                        RESERVED();

                        break;

                    }

                    break;



                case 6: /*RSILx*/

                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);

                    if (gen_check_privilege(dc) &&

                        gen_window_check1(dc, RRR_T)) {

                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_SR[PS]);

                        tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_INTLEVEL);

                        tcg_gen_ori_i32(cpu_SR[PS], cpu_SR[PS], RRR_S);

                        gen_helper_check_interrupts(cpu_env);

                        gen_jumpi_check_loop_end(dc, 0);

                    }

                    break;



                case 7: /*WAITIx*/

                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);

                    if (gen_check_privilege(dc)) {

                        gen_waiti(dc, RRR_S);

                    }

                    break;



                case 8: /*ANY4p*/

                case 9: /*ALL4p*/

                case 10: /*ANY8p*/

                case 11: /*ALL8p*/

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                    {

                        const unsigned shift = (RRR_R & 2) ? 8 : 4;

                        TCGv_i32 mask = tcg_const_i32(

                                ((1 << shift) - 1) << RRR_S);

                        TCGv_i32 tmp = tcg_temp_new_i32();



                        tcg_gen_and_i32(tmp, cpu_SR[BR], mask);

                        if (RRR_R & 1) { /*ALL*/

                            tcg_gen_addi_i32(tmp, tmp, 1 << RRR_S);

                        } else { /*ANY*/

                            tcg_gen_add_i32(tmp, tmp, mask);

                        }

                        tcg_gen_shri_i32(tmp, tmp, RRR_S + shift);

                        tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR],

                                tmp, RRR_T, 1);

                        tcg_temp_free(mask);

                        tcg_temp_free(tmp);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;



                }

                break;



            case 1: /*AND*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_and_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 2: /*OR*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_or_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 3: /*XOR*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_xor_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 4: /*ST1*/

                switch (RRR_R) {

                case 0: /*SSR*/

                    if (gen_window_check1(dc, RRR_S)) {

                        gen_right_shift_sar(dc, cpu_R[RRR_S]);

                    }

                    break;



                case 1: /*SSL*/

                    if (gen_window_check1(dc, RRR_S)) {

                        gen_left_shift_sar(dc, cpu_R[RRR_S]);

                    }

                    break;



                case 2: /*SSA8L*/

                    if (gen_window_check1(dc, RRR_S)) {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);

                        gen_right_shift_sar(dc, tmp);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 3: /*SSA8B*/

                    if (gen_window_check1(dc, RRR_S)) {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);

                        gen_left_shift_sar(dc, tmp);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 4: /*SSAI*/

                    {

                        TCGv_i32 tmp = tcg_const_i32(

                                RRR_S | ((RRR_T & 1) << 4));

                        gen_right_shift_sar(dc, tmp);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 6: /*RER*/

                    TBD();

                    break;



                case 7: /*WER*/

                    TBD();

                    break;



                case 8: /*ROTWw*/

                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                    if (gen_check_privilege(dc)) {

                        TCGv_i32 tmp = tcg_const_i32(

                                RRR_T | ((RRR_T & 8) ? 0xfffffff0 : 0));

                        gen_helper_rotw(cpu_env, tmp);

                        tcg_temp_free(tmp);

                        /* This can change tb->flags, so exit tb */

                        gen_jumpi_check_loop_end(dc, -1);

                    }

                    break;



                case 14: /*NSAu*/

                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);

                    if (gen_window_check2(dc, RRR_S, RRR_T)) {

                        gen_helper_nsa(cpu_R[RRR_T], cpu_R[RRR_S]);

                    }

                    break;



                case 15: /*NSAUu*/

                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);

                    if (gen_window_check2(dc, RRR_S, RRR_T)) {

                        gen_helper_nsau(cpu_R[RRR_T], cpu_R[RRR_S]);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            case 5: /*TLB*/

                HAS_OPTION_BITS(

                        XTENSA_OPTION_BIT(XTENSA_OPTION_MMU) |

                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_PROTECTION) |

                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_TRANSLATION));

                if (gen_check_privilege(dc) &&

                    gen_window_check2(dc, RRR_S, RRR_T)) {

                    TCGv_i32 dtlb = tcg_const_i32((RRR_R & 8) != 0);



                    switch (RRR_R & 7) {

                    case 3: /*RITLB0*/ /*RDTLB0*/

                        gen_helper_rtlb0(cpu_R[RRR_T],

                                cpu_env, cpu_R[RRR_S], dtlb);

                        break;



                    case 4: /*IITLB*/ /*IDTLB*/

                        gen_helper_itlb(cpu_env, cpu_R[RRR_S], dtlb);

                        /* This could change memory mapping, so exit tb */

                        gen_jumpi_check_loop_end(dc, -1);

                        break;



                    case 5: /*PITLB*/ /*PDTLB*/

                        tcg_gen_movi_i32(cpu_pc, dc->pc);

                        gen_helper_ptlb(cpu_R[RRR_T],

                                cpu_env, cpu_R[RRR_S], dtlb);

                        break;



                    case 6: /*WITLB*/ /*WDTLB*/

                        gen_helper_wtlb(

                                cpu_env, cpu_R[RRR_T], cpu_R[RRR_S], dtlb);

                        /* This could change memory mapping, so exit tb */

                        gen_jumpi_check_loop_end(dc, -1);

                        break;



                    case 7: /*RITLB1*/ /*RDTLB1*/

                        gen_helper_rtlb1(cpu_R[RRR_T],

                                cpu_env, cpu_R[RRR_S], dtlb);

                        break;



                    default:

                        tcg_temp_free(dtlb);

                        RESERVED();

                        break;

                    }

                    tcg_temp_free(dtlb);

                }

                break;



            case 6: /*RT0*/

                if (!gen_window_check2(dc, RRR_R, RRR_T)) {

                    break;

                }

                switch (RRR_S) {

                case 0: /*NEG*/

                    tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);

                    break;



                case 1: /*ABS*/

                    {

                        TCGv_i32 zero = tcg_const_i32(0);

                        TCGv_i32 neg = tcg_temp_new_i32();



                        tcg_gen_neg_i32(neg, cpu_R[RRR_T]);

                        tcg_gen_movcond_i32(TCG_COND_GE, cpu_R[RRR_R],

                                cpu_R[RRR_T], zero, cpu_R[RRR_T], neg);

                        tcg_temp_free(neg);

                        tcg_temp_free(zero);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            case 7: /*reserved*/

                RESERVED();

                break;



            case 8: /*ADD*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_add_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 9: /*ADD**/

            case 10:

            case 11:

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 8);

                    tcg_gen_add_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);

                    tcg_temp_free(tmp);

                }

                break;



            case 12: /*SUB*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_sub_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 13: /*SUB**/

            case 14:

            case 15:

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 12);

                    tcg_gen_sub_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);

                    tcg_temp_free(tmp);

                }

                break;

            }

            break;



        case 1: /*RST1*/

            switch (OP2) {

            case 0: /*SLLI*/

            case 1:

                if (gen_window_check2(dc, RRR_R, RRR_S)) {

                    tcg_gen_shli_i32(cpu_R[RRR_R], cpu_R[RRR_S],

                                     32 - (RRR_T | ((OP2 & 1) << 4)));

                }

                break;



            case 2: /*SRAI*/

            case 3:

                if (gen_window_check2(dc, RRR_R, RRR_T)) {

                    tcg_gen_sari_i32(cpu_R[RRR_R], cpu_R[RRR_T],

                                     RRR_S | ((OP2 & 1) << 4));

                }

                break;



            case 4: /*SRLI*/

                if (gen_window_check2(dc, RRR_R, RRR_T)) {

                    tcg_gen_shri_i32(cpu_R[RRR_R], cpu_R[RRR_T], RRR_S);

                }

                break;



            case 6: /*XSR*/

                if (gen_check_sr(dc, RSR_SR, SR_X) &&

                    (RSR_SR < 64 || gen_check_privilege(dc)) &&

                    gen_window_check1(dc, RRR_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();



                    tcg_gen_mov_i32(tmp, cpu_R[RRR_T]);

                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);

                    gen_wsr(dc, RSR_SR, tmp);

                    tcg_temp_free(tmp);

                }

                break;



                /*

                 * Note: 64 bit ops are used here solely because SAR values

                 * have range 0..63

                 */

#define gen_shift_reg(cmd, reg) do { \

                    TCGv_i64 tmp = tcg_temp_new_i64(); \

                    tcg_gen_extu_i32_i64(tmp, reg); \

                    tcg_gen_##cmd##_i64(v, v, tmp); \

                    tcg_gen_trunc_i64_i32(cpu_R[RRR_R], v); \

                    tcg_temp_free_i64(v); \

                    tcg_temp_free_i64(tmp); \

                } while (0)



#define gen_shift(cmd) gen_shift_reg(cmd, cpu_SR[SAR])



            case 8: /*SRC*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i64 v = tcg_temp_new_i64();

                    tcg_gen_concat_i32_i64(v, cpu_R[RRR_T], cpu_R[RRR_S]);

                    gen_shift(shr);

                }

                break;



            case 9: /*SRL*/

                if (!gen_window_check2(dc, RRR_R, RRR_T)) {

                    break;

                }

                if (dc->sar_5bit) {

                    tcg_gen_shr_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);

                } else {

                    TCGv_i64 v = tcg_temp_new_i64();

                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_T]);

                    gen_shift(shr);

                }

                break;



            case 10: /*SLL*/

                if (!gen_window_check2(dc, RRR_R, RRR_S)) {

                    break;

                }

                if (dc->sar_m32_5bit) {

                    tcg_gen_shl_i32(cpu_R[RRR_R], cpu_R[RRR_S], dc->sar_m32);

                } else {

                    TCGv_i64 v = tcg_temp_new_i64();

                    TCGv_i32 s = tcg_const_i32(32);

                    tcg_gen_sub_i32(s, s, cpu_SR[SAR]);

                    tcg_gen_andi_i32(s, s, 0x3f);

                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_S]);

                    gen_shift_reg(shl, s);

                    tcg_temp_free(s);

                }

                break;



            case 11: /*SRA*/

                if (!gen_window_check2(dc, RRR_R, RRR_T)) {

                    break;

                }

                if (dc->sar_5bit) {

                    tcg_gen_sar_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);

                } else {

                    TCGv_i64 v = tcg_temp_new_i64();

                    tcg_gen_ext_i32_i64(v, cpu_R[RRR_T]);

                    gen_shift(sar);

                }

                break;

#undef gen_shift

#undef gen_shift_reg



            case 12: /*MUL16U*/

                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 v1 = tcg_temp_new_i32();

                    TCGv_i32 v2 = tcg_temp_new_i32();

                    tcg_gen_ext16u_i32(v1, cpu_R[RRR_S]);

                    tcg_gen_ext16u_i32(v2, cpu_R[RRR_T]);

                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);

                    tcg_temp_free(v2);

                    tcg_temp_free(v1);

                }

                break;



            case 13: /*MUL16S*/

                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 v1 = tcg_temp_new_i32();

                    TCGv_i32 v2 = tcg_temp_new_i32();

                    tcg_gen_ext16s_i32(v1, cpu_R[RRR_S]);

                    tcg_gen_ext16s_i32(v2, cpu_R[RRR_T]);

                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);

                    tcg_temp_free(v2);

                    tcg_temp_free(v1);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 2: /*RST2*/

            if (OP2 >= 8 && !gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                break;

            }



            if (OP2 >= 12) {

                HAS_OPTION(XTENSA_OPTION_32_BIT_IDIV);

                int label = gen_new_label();

                tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0, label);

                gen_exception_cause(dc, INTEGER_DIVIDE_BY_ZERO_CAUSE);

                gen_set_label(label);

            }



            switch (OP2) {

#define BOOLEAN_LOGIC(fn, r, s, t) \

                do { \

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN); \

                    TCGv_i32 tmp1 = tcg_temp_new_i32(); \

                    TCGv_i32 tmp2 = tcg_temp_new_i32(); \

                    \

                    tcg_gen_shri_i32(tmp1, cpu_SR[BR], s); \

                    tcg_gen_shri_i32(tmp2, cpu_SR[BR], t); \

                    tcg_gen_##fn##_i32(tmp1, tmp1, tmp2); \

                    tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR], tmp1, r, 1); \

                    tcg_temp_free(tmp1); \

                    tcg_temp_free(tmp2); \

                } while (0)



            case 0: /*ANDBp*/

                BOOLEAN_LOGIC(and, RRR_R, RRR_S, RRR_T);

                break;



            case 1: /*ANDBCp*/

                BOOLEAN_LOGIC(andc, RRR_R, RRR_S, RRR_T);

                break;



            case 2: /*ORBp*/

                BOOLEAN_LOGIC(or, RRR_R, RRR_S, RRR_T);

                break;



            case 3: /*ORBCp*/

                BOOLEAN_LOGIC(orc, RRR_R, RRR_S, RRR_T);

                break;



            case 4: /*XORBp*/

                BOOLEAN_LOGIC(xor, RRR_R, RRR_S, RRR_T);

                break;



#undef BOOLEAN_LOGIC



            case 8: /*MULLi*/

                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL);

                tcg_gen_mul_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                break;



            case 10: /*MULUHi*/

            case 11: /*MULSHi*/

                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL_HIGH);

                {

                    TCGv lo = tcg_temp_new();



                    if (OP2 == 10) {

                        tcg_gen_mulu2_i32(lo, cpu_R[RRR_R],

                                          cpu_R[RRR_S], cpu_R[RRR_T]);

                    } else {

                        tcg_gen_muls2_i32(lo, cpu_R[RRR_R],

                                          cpu_R[RRR_S], cpu_R[RRR_T]);

                    }

                    tcg_temp_free(lo);

                }

                break;



            case 12: /*QUOUi*/

                tcg_gen_divu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                break;



            case 13: /*QUOSi*/

            case 15: /*REMSi*/

                {

                    int label1 = gen_new_label();

                    int label2 = gen_new_label();



                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_S], 0x80000000,

                            label1);

                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0xffffffff,

                            label1);

                    tcg_gen_movi_i32(cpu_R[RRR_R],

                            OP2 == 13 ? 0x80000000 : 0);

                    tcg_gen_br(label2);

                    gen_set_label(label1);

                    if (OP2 == 13) {

                        tcg_gen_div_i32(cpu_R[RRR_R],

                                cpu_R[RRR_S], cpu_R[RRR_T]);

                    } else {

                        tcg_gen_rem_i32(cpu_R[RRR_R],

                                cpu_R[RRR_S], cpu_R[RRR_T]);

                    }

                    gen_set_label(label2);

                }

                break;



            case 14: /*REMUi*/

                tcg_gen_remu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 3: /*RST3*/

            switch (OP2) {

            case 0: /*RSR*/

                if (gen_check_sr(dc, RSR_SR, SR_R) &&

                    (RSR_SR < 64 || gen_check_privilege(dc)) &&

                    gen_window_check1(dc, RRR_T)) {

                    gen_rsr(dc, cpu_R[RRR_T], RSR_SR);

                }

                break;



            case 1: /*WSR*/

                if (gen_check_sr(dc, RSR_SR, SR_W) &&

                    (RSR_SR < 64 || gen_check_privilege(dc)) &&

                    gen_window_check1(dc, RRR_T)) {

                    gen_wsr(dc, RSR_SR, cpu_R[RRR_T]);

                }

                break;



            case 2: /*SEXTu*/

                HAS_OPTION(XTENSA_OPTION_MISC_OP_SEXT);

                if (gen_window_check2(dc, RRR_R, RRR_S)) {

                    int shift = 24 - RRR_T;



                    if (shift == 24) {

                        tcg_gen_ext8s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);

                    } else if (shift == 16) {

                        tcg_gen_ext16s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);

                    } else {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], shift);

                        tcg_gen_sari_i32(cpu_R[RRR_R], tmp, shift);

                        tcg_temp_free(tmp);

                    }

                }

                break;



            case 3: /*CLAMPSu*/

                HAS_OPTION(XTENSA_OPTION_MISC_OP_CLAMPS);

                if (gen_window_check2(dc, RRR_R, RRR_S)) {

                    TCGv_i32 tmp1 = tcg_temp_new_i32();

                    TCGv_i32 tmp2 = tcg_temp_new_i32();

                    TCGv_i32 zero = tcg_const_i32(0);



                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 24 - RRR_T);

                    tcg_gen_xor_i32(tmp2, tmp1, cpu_R[RRR_S]);

                    tcg_gen_andi_i32(tmp2, tmp2, 0xffffffff << (RRR_T + 7));



                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 31);

                    tcg_gen_xori_i32(tmp1, tmp1, 0xffffffff >> (25 - RRR_T));



                    tcg_gen_movcond_i32(TCG_COND_EQ, cpu_R[RRR_R], tmp2, zero,

                            cpu_R[RRR_S], tmp1);

                    tcg_temp_free(tmp1);

                    tcg_temp_free(tmp2);

                    tcg_temp_free(zero);

                }

                break;



            case 4: /*MINu*/

            case 5: /*MAXu*/

            case 6: /*MINUu*/

            case 7: /*MAXUu*/

                HAS_OPTION(XTENSA_OPTION_MISC_OP_MINMAX);

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    static const TCGCond cond[] = {

                        TCG_COND_LE,

                        TCG_COND_GE,

                        TCG_COND_LEU,

                        TCG_COND_GEU

                    };

                    tcg_gen_movcond_i32(cond[OP2 - 4], cpu_R[RRR_R],

                            cpu_R[RRR_S], cpu_R[RRR_T],

                            cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 8: /*MOVEQZ*/

            case 9: /*MOVNEZ*/

            case 10: /*MOVLTZ*/

            case 11: /*MOVGEZ*/

                if (gen_window_check3(dc, RRR_R, RRR_S, RRR_T)) {

                    static const TCGCond cond[] = {

                        TCG_COND_EQ,

                        TCG_COND_NE,

                        TCG_COND_LT,

                        TCG_COND_GE,

                    };

                    TCGv_i32 zero = tcg_const_i32(0);



                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_R[RRR_R],

                            cpu_R[RRR_T], zero, cpu_R[RRR_S], cpu_R[RRR_R]);

                    tcg_temp_free(zero);

                }

                break;



            case 12: /*MOVFp*/

            case 13: /*MOVTp*/

                HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                if (gen_window_check2(dc, RRR_R, RRR_S)) {

                    TCGv_i32 zero = tcg_const_i32(0);

                    TCGv_i32 tmp = tcg_temp_new_i32();



                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);

                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,

                            cpu_R[RRR_R], tmp, zero,

                            cpu_R[RRR_S], cpu_R[RRR_R]);



                    tcg_temp_free(tmp);

                    tcg_temp_free(zero);

                }

                break;



            case 14: /*RUR*/

                if (gen_window_check1(dc, RRR_R)) {

                    int st = (RRR_S << 4) + RRR_T;

                    if (uregnames[st].name) {

                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_UR[st]);

                    } else {

                        qemu_log(""RUR %d not implemented, "", st);

                        TBD();

                    }

                }

                break;



            case 15: /*WUR*/

                if (gen_window_check1(dc, RRR_T)) {

                    if (uregnames[RSR_SR].name) {

                        gen_wur(RSR_SR, cpu_R[RRR_T]);

                    } else {

                        qemu_log(""WUR %d not implemented, "", RSR_SR);

                        TBD();

                    }

                }

                break;



            }

            break;



        case 4: /*EXTUI*/

        case 5:

            if (gen_window_check2(dc, RRR_R, RRR_T)) {

                int shiftimm = RRR_S | ((OP1 & 1) << 4);

                int maskimm = (1 << (OP2 + 1)) - 1;



                TCGv_i32 tmp = tcg_temp_new_i32();

                tcg_gen_shri_i32(tmp, cpu_R[RRR_T], shiftimm);

                tcg_gen_andi_i32(cpu_R[RRR_R], tmp, maskimm);

                tcg_temp_free(tmp);

            }

            break;



        case 6: /*CUST0*/

            RESERVED();

            break;



        case 7: /*CUST1*/

            RESERVED();

            break;



        case 8: /*LSCXp*/

            switch (OP2) {

            case 0: /*LSXf*/

            case 1: /*LSXUf*/

            case 4: /*SSXf*/

            case 5: /*SSXUf*/

                HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);

                if (gen_window_check2(dc, RRR_S, RRR_T) &&

                    gen_check_cpenable(dc, 0)) {

                    TCGv_i32 addr = tcg_temp_new_i32();

                    tcg_gen_add_i32(addr, cpu_R[RRR_S], cpu_R[RRR_T]);

                    gen_load_store_alignment(dc, 2, addr, false);

                    if (OP2 & 0x4) {

                        tcg_gen_qemu_st32(cpu_FR[RRR_R], addr, dc->cring);

                    } else {

                        tcg_gen_qemu_ld32u(cpu_FR[RRR_R], addr, dc->cring);

                    }

                    if (OP2 & 0x1) {

                        tcg_gen_mov_i32(cpu_R[RRR_S], addr);

                    }

                    tcg_temp_free(addr);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 9: /*LSC4*/

            if (!gen_window_check2(dc, RRR_S, RRR_T)) {

                break;

            }

            switch (OP2) {

            case 0: /*L32E*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                if (gen_check_privilege(dc)) {

                    TCGv_i32 addr = tcg_temp_new_i32();

                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],

                            (0xffffffc0 | (RRR_R << 2)));

                    tcg_gen_qemu_ld32u(cpu_R[RRR_T], addr, dc->ring);

                    tcg_temp_free(addr);

                }

                break;



            case 4: /*S32E*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                if (gen_check_privilege(dc)) {

                    TCGv_i32 addr = tcg_temp_new_i32();

                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],

                            (0xffffffc0 | (RRR_R << 2)));

                    tcg_gen_qemu_st32(cpu_R[RRR_T], addr, dc->ring);

                    tcg_temp_free(addr);

                }

                break;



            default:

                RESERVED();

                break;

            }

            break;



        case 10: /*FP0*/

            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);

            switch (OP2) {

            case 0: /*ADD.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_add_s(cpu_FR[RRR_R], cpu_env,

                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);

                }

                break;



            case 1: /*SUB.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_sub_s(cpu_FR[RRR_R], cpu_env,

                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);

                }

                break;



            case 2: /*MUL.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_mul_s(cpu_FR[RRR_R], cpu_env,

                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);

                }

                break;



            case 4: /*MADD.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_madd_s(cpu_FR[RRR_R], cpu_env,

                                      cpu_FR[RRR_R], cpu_FR[RRR_S],

                                      cpu_FR[RRR_T]);

                }

                break;



            case 5: /*MSUB.Sf*/

                if (gen_check_cpenable(dc, 0)) {

                    gen_helper_msub_s(cpu_FR[RRR_R], cpu_env,

                                      cpu_FR[RRR_R], cpu_FR[RRR_S],

                                      cpu_FR[RRR_T]);

                }

                break;



            case 8: /*ROUND.Sf*/

            case 9: /*TRUNC.Sf*/

            case 10: /*FLOOR.Sf*/

            case 11: /*CEIL.Sf*/

            case 14: /*UTRUNC.Sf*/

                if (gen_window_check1(dc, RRR_R) &&

                    gen_check_cpenable(dc, 0)) {

                    static const unsigned rounding_mode_const[] = {

                        float_round_nearest_even,

                        float_round_to_zero,

                        float_round_down,

                        float_round_up,

                        [6] = float_round_to_zero,

                    };

                    TCGv_i32 rounding_mode = tcg_const_i32(

                            rounding_mode_const[OP2 & 7]);

                    TCGv_i32 scale = tcg_const_i32(RRR_T);



                    if (OP2 == 14) {

                        gen_helper_ftoui(cpu_R[RRR_R], cpu_FR[RRR_S],

                                rounding_mode, scale);

                    } else {

                        gen_helper_ftoi(cpu_R[RRR_R], cpu_FR[RRR_S],

                                rounding_mode, scale);

                    }



                    tcg_temp_free(rounding_mode);

                    tcg_temp_free(scale);

                }

                break;



            case 12: /*FLOAT.Sf*/

            case 13: /*UFLOAT.Sf*/

                if (gen_window_check1(dc, RRR_S) &&

                    gen_check_cpenable(dc, 0)) {

                    TCGv_i32 scale = tcg_const_i32(-RRR_T);



                    if (OP2 == 13) {

                        gen_helper_uitof(cpu_FR[RRR_R], cpu_env,

                                cpu_R[RRR_S], scale);

                    } else {

                        gen_helper_itof(cpu_FR[RRR_R], cpu_env,

                                cpu_R[RRR_S], scale);

                    }

                    tcg_temp_free(scale);

                }

                break;



            case 15: /*FP1OP*/

                switch (RRR_T) {

                case 0: /*MOV.Sf*/

                    if (gen_check_cpenable(dc, 0)) {

                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                case 1: /*ABS.Sf*/

                    if (gen_check_cpenable(dc, 0)) {

                        gen_helper_abs_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                case 4: /*RFRf*/

                    if (gen_window_check1(dc, RRR_R) &&

                        gen_check_cpenable(dc, 0)) {

                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                case 5: /*WFRf*/

                    if (gen_window_check1(dc, RRR_S) &&

                        gen_check_cpenable(dc, 0)) {

                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_R[RRR_S]);

                    }

                    break;



                case 6: /*NEG.Sf*/

                    if (gen_check_cpenable(dc, 0)) {

                        gen_helper_neg_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 11: /*FP1*/

            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);



#define gen_compare(rel, br, a, b) \

    do { \

        if (gen_check_cpenable(dc, 0)) { \

            TCGv_i32 bit = tcg_const_i32(1 << br); \

            \

            gen_helper_##rel(cpu_env, bit, cpu_FR[a], cpu_FR[b]); \

            tcg_temp_free(bit); \

        } \

    } while (0)



            switch (OP2) {

            case 1: /*UN.Sf*/

                gen_compare(un_s, RRR_R, RRR_S, RRR_T);

                break;



            case 2: /*OEQ.Sf*/

                gen_compare(oeq_s, RRR_R, RRR_S, RRR_T);

                break;



            case 3: /*UEQ.Sf*/

                gen_compare(ueq_s, RRR_R, RRR_S, RRR_T);

                break;



            case 4: /*OLT.Sf*/

                gen_compare(olt_s, RRR_R, RRR_S, RRR_T);

                break;



            case 5: /*ULT.Sf*/

                gen_compare(ult_s, RRR_R, RRR_S, RRR_T);

                break;



            case 6: /*OLE.Sf*/

                gen_compare(ole_s, RRR_R, RRR_S, RRR_T);

                break;



            case 7: /*ULE.Sf*/

                gen_compare(ule_s, RRR_R, RRR_S, RRR_T);

                break;



#undef gen_compare



            case 8: /*MOVEQZ.Sf*/

            case 9: /*MOVNEZ.Sf*/

            case 10: /*MOVLTZ.Sf*/

            case 11: /*MOVGEZ.Sf*/

                if (gen_window_check1(dc, RRR_T) &&

                    gen_check_cpenable(dc, 0)) {

                    static const TCGCond cond[] = {

                        TCG_COND_EQ,

                        TCG_COND_NE,

                        TCG_COND_LT,

                        TCG_COND_GE,

                    };

                    TCGv_i32 zero = tcg_const_i32(0);



                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_FR[RRR_R],

                            cpu_R[RRR_T], zero, cpu_FR[RRR_S], cpu_FR[RRR_R]);

                    tcg_temp_free(zero);

                }

                break;



            case 12: /*MOVF.Sf*/

            case 13: /*MOVT.Sf*/

                HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                if (gen_check_cpenable(dc, 0)) {

                    TCGv_i32 zero = tcg_const_i32(0);

                    TCGv_i32 tmp = tcg_temp_new_i32();



                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);

                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,

                            cpu_FR[RRR_R], tmp, zero,

                            cpu_FR[RRR_S], cpu_FR[RRR_R]);



                    tcg_temp_free(tmp);

                    tcg_temp_free(zero);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    case 1: /*L32R*/

        if (gen_window_check1(dc, RRR_T)) {

            TCGv_i32 tmp = tcg_const_i32(

                    ((dc->tb->flags & XTENSA_TBFLAG_LITBASE) ?

                     0 : ((dc->pc + 3) & ~3)) +

                    (0xfffc0000 | (RI16_IMM16 << 2)));



            if (dc->tb->flags & XTENSA_TBFLAG_LITBASE) {

                tcg_gen_add_i32(tmp, tmp, dc->litbase);

            }

            tcg_gen_qemu_ld32u(cpu_R[RRR_T], tmp, dc->cring);

            tcg_temp_free(tmp);

        }

        break;



    case 2: /*LSAI*/

#define gen_load_store(type, shift) do { \

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                \

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << shift); \

                if (shift) { \

                    gen_load_store_alignment(dc, shift, addr, false); \

                } \

                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \

                tcg_temp_free(addr); \

            } \

        } while (0)



        switch (RRI8_R) {

        case 0: /*L8UI*/

            gen_load_store(ld8u, 0);

            break;



        case 1: /*L16UI*/

            gen_load_store(ld16u, 1);

            break;



        case 2: /*L32I*/

            gen_load_store(ld32u, 2);

            break;



        case 4: /*S8I*/

            gen_load_store(st8, 0);

            break;



        case 5: /*S16I*/

            gen_load_store(st16, 1);

            break;



        case 6: /*S32I*/

            gen_load_store(st32, 2);

            break;



#define gen_dcache_hit_test(w, shift) do { \

            if (gen_window_check1(dc, RRI##w##_S)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                TCGv_i32 res = tcg_temp_new_i32(); \

                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \

                                 RRI##w##_IMM##w << shift); \

                tcg_gen_qemu_ld8u(res, addr, dc->cring); \

                tcg_temp_free(addr); \

                tcg_temp_free(res); \

            } \

        } while (0)



#define gen_dcache_hit_test4() gen_dcache_hit_test(4, 4)

#define gen_dcache_hit_test8() gen_dcache_hit_test(8, 2)



        case 7: /*CACHEc*/

            if (RRI8_T < 8) {

                HAS_OPTION(XTENSA_OPTION_DCACHE);

            }



            switch (RRI8_T) {

            case 0: /*DPFRc*/

                gen_window_check1(dc, RRI8_S);

                break;



            case 1: /*DPFWc*/

                gen_window_check1(dc, RRI8_S);

                break;



            case 2: /*DPFROc*/

                gen_window_check1(dc, RRI8_S);

                break;



            case 3: /*DPFWOc*/

                gen_window_check1(dc, RRI8_S);

                break;



            case 4: /*DHWBc*/

                gen_dcache_hit_test8();

                break;



            case 5: /*DHWBIc*/

                gen_dcache_hit_test8();

                break;



            case 6: /*DHIc*/

                if (gen_check_privilege(dc)) {

                    gen_dcache_hit_test8();

                }

                break;



            case 7: /*DIIc*/

                if (gen_check_privilege(dc)) {

                    gen_window_check1(dc, RRI8_S);

                }

                break;



            case 8: /*DCEc*/

                switch (OP1) {

                case 0: /*DPFLl*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_dcache_hit_test4();

                    }

                    break;



                case 2: /*DHUl*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_dcache_hit_test4();

                    }

                    break;



                case 3: /*DIUl*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_window_check1(dc, RRI4_S);

                    }

                    break;



                case 4: /*DIWBc*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE);

                    if (gen_check_privilege(dc)) {

                        gen_window_check1(dc, RRI4_S);

                    }

                    break;



                case 5: /*DIWBIc*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE);

                    if (gen_check_privilege(dc)) {

                        gen_window_check1(dc, RRI4_S);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;



                }

                break;



#undef gen_dcache_hit_test

#undef gen_dcache_hit_test4

#undef gen_dcache_hit_test8



#define gen_icache_hit_test(w, shift) do { \

            if (gen_window_check1(dc, RRI##w##_S)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                tcg_gen_movi_i32(cpu_pc, dc->pc); \

                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \

                                 RRI##w##_IMM##w << shift); \

                gen_helper_itlb_hit_test(cpu_env, addr); \

                tcg_temp_free(addr); \

            }\

        } while (0)



#define gen_icache_hit_test4() gen_icache_hit_test(4, 4)

#define gen_icache_hit_test8() gen_icache_hit_test(8, 2)



            case 12: /*IPFc*/

                HAS_OPTION(XTENSA_OPTION_ICACHE);

                gen_window_check1(dc, RRI8_S);

                break;



            case 13: /*ICEc*/

                switch (OP1) {

                case 0: /*IPFLl*/

                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_icache_hit_test4();

                    }

                    break;



                case 2: /*IHUl*/

                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_icache_hit_test4();

                    }

                    break;



                case 3: /*IIUl*/

                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);

                    if (gen_check_privilege(dc)) {

                        gen_window_check1(dc, RRI4_S);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            case 14: /*IHIc*/

                HAS_OPTION(XTENSA_OPTION_ICACHE);

                gen_icache_hit_test8();

                break;



            case 15: /*IIIc*/

                HAS_OPTION(XTENSA_OPTION_ICACHE);

                if (gen_check_privilege(dc)) {

                    gen_window_check1(dc, RRI8_S);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



#undef gen_icache_hit_test

#undef gen_icache_hit_test4

#undef gen_icache_hit_test8



        case 9: /*L16SI*/

            gen_load_store(ld16s, 1);

            break;

#undef gen_load_store



        case 10: /*MOVI*/

            if (gen_window_check1(dc, RRI8_T)) {

                tcg_gen_movi_i32(cpu_R[RRI8_T],

                                 RRI8_IMM8 | (RRI8_S << 8) |

                                 ((RRI8_S & 0x8) ? 0xfffff000 : 0));

            }

            break;



#define gen_load_store_no_hw_align(type) do { \

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) { \

                TCGv_i32 addr = tcg_temp_local_new_i32(); \

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2); \

                gen_load_store_alignment(dc, 2, addr, true); \

                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \

                tcg_temp_free(addr); \

            } \

        } while (0)



        case 11: /*L32AIy*/

            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);

            gen_load_store_no_hw_align(ld32u); /*TODO acquire?*/

            break;



        case 12: /*ADDI*/

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE);

            }

            break;



        case 13: /*ADDMI*/

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S],

                                 RRI8_IMM8_SE << 8);

            }

            break;



        case 14: /*S32C1Iy*/

            HAS_OPTION(XTENSA_OPTION_CONDITIONAL_STORE);

            if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                int label = gen_new_label();

                TCGv_i32 tmp = tcg_temp_local_new_i32();

                TCGv_i32 addr = tcg_temp_local_new_i32();

                TCGv_i32 tpc;



                tcg_gen_mov_i32(tmp, cpu_R[RRI8_T]);

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);

                gen_load_store_alignment(dc, 2, addr, true);



                gen_advance_ccount(dc);

                tpc = tcg_const_i32(dc->pc);

                gen_helper_check_atomctl(cpu_env, tpc, addr);

                tcg_gen_qemu_ld32u(cpu_R[RRI8_T], addr, dc->cring);

                tcg_gen_brcond_i32(TCG_COND_NE, cpu_R[RRI8_T],

                        cpu_SR[SCOMPARE1], label);



                tcg_gen_qemu_st32(tmp, addr, dc->cring);



                gen_set_label(label);

                tcg_temp_free(tpc);

                tcg_temp_free(addr);

                tcg_temp_free(tmp);

            }

            break;



        case 15: /*S32RIy*/

            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);

            gen_load_store_no_hw_align(st32); /*TODO release?*/

            break;

#undef gen_load_store_no_hw_align



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    case 3: /*LSCIp*/

        switch (RRI8_R) {

        case 0: /*LSIf*/

        case 4: /*SSIf*/

        case 8: /*LSIUf*/

        case 12: /*SSIUf*/

            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);

            if (gen_window_check1(dc, RRI8_S) &&

                gen_check_cpenable(dc, 0)) {

                TCGv_i32 addr = tcg_temp_new_i32();

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);

                gen_load_store_alignment(dc, 2, addr, false);

                if (RRI8_R & 0x4) {

                    tcg_gen_qemu_st32(cpu_FR[RRI8_T], addr, dc->cring);

                } else {

                    tcg_gen_qemu_ld32u(cpu_FR[RRI8_T], addr, dc->cring);

                }

                if (RRI8_R & 0x8) {

                    tcg_gen_mov_i32(cpu_R[RRI8_S], addr);

                }

                tcg_temp_free(addr);

            }

            break;



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    case 4: /*MAC16d*/

        HAS_OPTION(XTENSA_OPTION_MAC16);

        {

            enum {

                MAC16_UMUL = 0x0,

                MAC16_MUL  = 0x4,

                MAC16_MULA = 0x8,

                MAC16_MULS = 0xc,

                MAC16_NONE = 0xf,

            } op = OP1 & 0xc;

            bool is_m1_sr = (OP2 & 0x3) == 2;

            bool is_m2_sr = (OP2 & 0xc) == 0;

            uint32_t ld_offset = 0;



            if (OP2 > 9) {

                RESERVED();

            }



            switch (OP2 & 2) {

            case 0: /*MACI?/MACC?*/

                is_m1_sr = true;

                ld_offset = (OP2 & 1) ? -4 : 4;



                if (OP2 >= 8) { /*MACI/MACC*/

                    if (OP1 == 0) { /*LDINC/LDDEC*/

                        op = MAC16_NONE;

                    } else {

                        RESERVED();

                    }

                } else if (op != MAC16_MULA) { /*MULA.*.*.LDINC/LDDEC*/

                    RESERVED();

                }

                break;



            case 2: /*MACD?/MACA?*/

                if (op == MAC16_UMUL && OP2 != 7) { /*UMUL only in MACAA*/

                    RESERVED();

                }

                break;

            }



            if (op != MAC16_NONE) {

                if (!is_m1_sr && !gen_window_check1(dc, RRR_S)) {

                    break;

                }

                if (!is_m2_sr && !gen_window_check1(dc, RRR_T)) {

                    break;

                }

            }



            if (ld_offset && !gen_window_check1(dc, RRR_S)) {

                break;

            }



            {

                TCGv_i32 vaddr = tcg_temp_new_i32();

                TCGv_i32 mem32 = tcg_temp_new_i32();



                if (ld_offset) {

                    tcg_gen_addi_i32(vaddr, cpu_R[RRR_S], ld_offset);

                    gen_load_store_alignment(dc, 2, vaddr, false);

                    tcg_gen_qemu_ld32u(mem32, vaddr, dc->cring);

                }

                if (op != MAC16_NONE) {

                    TCGv_i32 m1 = gen_mac16_m(

                            is_m1_sr ? cpu_SR[MR + RRR_X] : cpu_R[RRR_S],

                            OP1 & 1, op == MAC16_UMUL);

                    TCGv_i32 m2 = gen_mac16_m(

                            is_m2_sr ? cpu_SR[MR + 2 + RRR_Y] : cpu_R[RRR_T],

                            OP1 & 2, op == MAC16_UMUL);



                    if (op == MAC16_MUL || op == MAC16_UMUL) {

                        tcg_gen_mul_i32(cpu_SR[ACCLO], m1, m2);

                        if (op == MAC16_UMUL) {

                            tcg_gen_movi_i32(cpu_SR[ACCHI], 0);

                        } else {

                            tcg_gen_sari_i32(cpu_SR[ACCHI], cpu_SR[ACCLO], 31);

                        }

                    } else {

                        TCGv_i32 lo = tcg_temp_new_i32();

                        TCGv_i32 hi = tcg_temp_new_i32();



                        tcg_gen_mul_i32(lo, m1, m2);

                        tcg_gen_sari_i32(hi, lo, 31);

                        if (op == MAC16_MULA) {

                            tcg_gen_add2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             lo, hi);

                        } else {

                            tcg_gen_sub2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             lo, hi);

                        }

                        tcg_gen_ext8s_i32(cpu_SR[ACCHI], cpu_SR[ACCHI]);



                        tcg_temp_free_i32(lo);

                        tcg_temp_free_i32(hi);

                    }

                    tcg_temp_free(m1);

                    tcg_temp_free(m2);

                }

                if (ld_offset) {

                    tcg_gen_mov_i32(cpu_R[RRR_S], vaddr);

                    tcg_gen_mov_i32(cpu_SR[MR + RRR_W], mem32);

                }

                tcg_temp_free(vaddr);

                tcg_temp_free(mem32);

            }

        }

        break;



    case 5: /*CALLN*/

        switch (CALL_N) {

        case 0: /*CALL0*/

            tcg_gen_movi_i32(cpu_R[0], dc->next_pc);

            gen_jumpi(dc, (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);

            break;



        case 1: /*CALL4w*/

        case 2: /*CALL8w*/

        case 3: /*CALL12w*/

            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

            if (gen_window_check1(dc, CALL_N << 2)) {

                gen_callwi(dc, CALL_N,

                           (dc->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);

            }

            break;

        }

        break;



    case 6: /*SI*/

        switch (CALL_N) {

        case 0: /*J*/

            gen_jumpi(dc, dc->pc + 4 + CALL_OFFSET_SE, 0);

            break;



        case 1: /*BZ*/

            if (gen_window_check1(dc, BRI12_S)) {

                static const TCGCond cond[] = {

                    TCG_COND_EQ, /*BEQZ*/

                    TCG_COND_NE, /*BNEZ*/

                    TCG_COND_LT, /*BLTZ*/

                    TCG_COND_GE, /*BGEZ*/

                };



                gen_brcondi(dc, cond[BRI12_M & 3], cpu_R[BRI12_S], 0,

                        4 + BRI12_IMM12_SE);

            }

            break;



        case 2: /*BI0*/

            if (gen_window_check1(dc, BRI8_S)) {

                static const TCGCond cond[] = {

                    TCG_COND_EQ, /*BEQI*/

                    TCG_COND_NE, /*BNEI*/

                    TCG_COND_LT, /*BLTI*/

                    TCG_COND_GE, /*BGEI*/

                };



                gen_brcondi(dc, cond[BRI8_M & 3],

                        cpu_R[BRI8_S], B4CONST[BRI8_R], 4 + BRI8_IMM8_SE);

            }

            break;



        case 3: /*BI1*/

            switch (BRI8_M) {

            case 0: /*ENTRYw*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                {

                    TCGv_i32 pc = tcg_const_i32(dc->pc);

                    TCGv_i32 s = tcg_const_i32(BRI12_S);

                    TCGv_i32 imm = tcg_const_i32(BRI12_IMM12);

                    gen_advance_ccount(dc);

                    gen_helper_entry(cpu_env, pc, s, imm);

                    tcg_temp_free(imm);

                    tcg_temp_free(s);

                    tcg_temp_free(pc);

                    /* This can change tb->flags, so exit tb */

                    gen_jumpi_check_loop_end(dc, -1);

                }

                break;



            case 1: /*B1*/

                switch (BRI8_R) {

                case 0: /*BFp*/

                case 1: /*BTp*/

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                    {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRI8_S);

                        gen_brcondi(dc,

                                BRI8_R == 1 ? TCG_COND_NE : TCG_COND_EQ,

                                tmp, 0, 4 + RRI8_IMM8_SE);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 8: /*LOOP*/

                case 9: /*LOOPNEZ*/

                case 10: /*LOOPGTZ*/

                    HAS_OPTION(XTENSA_OPTION_LOOP);

                    if (gen_window_check1(dc, RRI8_S)) {

                        uint32_t lend = dc->pc + RRI8_IMM8 + 4;

                        TCGv_i32 tmp = tcg_const_i32(lend);



                        tcg_gen_subi_i32(cpu_SR[LCOUNT], cpu_R[RRI8_S], 1);

                        tcg_gen_movi_i32(cpu_SR[LBEG], dc->next_pc);

                        gen_helper_wsr_lend(cpu_env, tmp);

                        tcg_temp_free(tmp);



                        if (BRI8_R > 8) {

                            int label = gen_new_label();

                            tcg_gen_brcondi_i32(

                                    BRI8_R == 9 ? TCG_COND_NE : TCG_COND_GT,

                                    cpu_R[RRI8_S], 0, label);

                            gen_jumpi(dc, lend, 1);

                            gen_set_label(label);

                        }



                        gen_jumpi(dc, dc->next_pc, 0);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;



                }

                break;



            case 2: /*BLTUI*/

            case 3: /*BGEUI*/

                if (gen_window_check1(dc, BRI8_S)) {

                    gen_brcondi(dc, BRI8_M == 2 ? TCG_COND_LTU : TCG_COND_GEU,

                                cpu_R[BRI8_S], B4CONSTU[BRI8_R],

                                4 + BRI8_IMM8_SE);

                }

                break;

            }

            break;



        }

        break;



    case 7: /*B*/

        {

            TCGCond eq_ne = (RRI8_R & 8) ? TCG_COND_NE : TCG_COND_EQ;



            switch (RRI8_R & 7) {

            case 0: /*BNONE*/ /*BANY*/

                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);

                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                }

                break;



            case 1: /*BEQ*/ /*BNE*/

            case 2: /*BLT*/ /*BGE*/

            case 3: /*BLTU*/ /*BGEU*/

                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                    static const TCGCond cond[] = {

                        [1] = TCG_COND_EQ,

                        [2] = TCG_COND_LT,

                        [3] = TCG_COND_LTU,

                        [9] = TCG_COND_NE,

                        [10] = TCG_COND_GE,

                        [11] = TCG_COND_GEU,

                    };

                    gen_brcond(dc, cond[RRI8_R], cpu_R[RRI8_S], cpu_R[RRI8_T],

                            4 + RRI8_IMM8_SE);

                }

                break;



            case 4: /*BALL*/ /*BNALL*/

                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);

                    gen_brcond(dc, eq_ne, tmp, cpu_R[RRI8_T],

                            4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                }

                break;



            case 5: /*BBC*/ /*BBS*/

                if (gen_window_check2(dc, RRI8_S, RRI8_T)) {

#ifdef TARGET_WORDS_BIGENDIAN

                    TCGv_i32 bit = tcg_const_i32(0x80000000);

#else

                    TCGv_i32 bit = tcg_const_i32(0x00000001);

#endif

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_T], 0x1f);

#ifdef TARGET_WORDS_BIGENDIAN

                    tcg_gen_shr_i32(bit, bit, tmp);

#else

                    tcg_gen_shl_i32(bit, bit, tmp);

#endif

                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], bit);

                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                    tcg_temp_free(bit);

                }

                break;



            case 6: /*BBCI*/ /*BBSI*/

            case 7:

                if (gen_window_check1(dc, RRI8_S)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_S],

#ifdef TARGET_WORDS_BIGENDIAN

                            0x80000000 >> (((RRI8_R & 1) << 4) | RRI8_T));

#else

                            0x00000001 << (((RRI8_R & 1) << 4) | RRI8_T));

#endif

                    gen_brcondi(dc, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                }

                break;



            }

        }

        break;



#define gen_narrow_load_store(type) do { \

            if (gen_window_check2(dc, RRRN_S, RRRN_T)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                tcg_gen_addi_i32(addr, cpu_R[RRRN_S], RRRN_R << 2); \

                gen_load_store_alignment(dc, 2, addr, false); \

                tcg_gen_qemu_##type(cpu_R[RRRN_T], addr, dc->cring); \

                tcg_temp_free(addr); \

            } \

        } while (0)



    case 8: /*L32I.Nn*/

        gen_narrow_load_store(ld32u);

        break;



    case 9: /*S32I.Nn*/

        gen_narrow_load_store(st32);

        break;

#undef gen_narrow_load_store



    case 10: /*ADD.Nn*/

        if (gen_window_check3(dc, RRRN_R, RRRN_S, RRRN_T)) {

            tcg_gen_add_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], cpu_R[RRRN_T]);

        }

        break;



    case 11: /*ADDI.Nn*/

        if (gen_window_check2(dc, RRRN_R, RRRN_S)) {

            tcg_gen_addi_i32(cpu_R[RRRN_R], cpu_R[RRRN_S],

                             RRRN_T ? RRRN_T : -1);

        }

        break;



    case 12: /*ST2n*/

        if (!gen_window_check1(dc, RRRN_S)) {

            break;

        }

        if (RRRN_T < 8) { /*MOVI.Nn*/

            tcg_gen_movi_i32(cpu_R[RRRN_S],

                    RRRN_R | (RRRN_T << 4) |

                    ((RRRN_T & 6) == 6 ? 0xffffff80 : 0));

        } else { /*BEQZ.Nn*/ /*BNEZ.Nn*/

            TCGCond eq_ne = (RRRN_T & 4) ? TCG_COND_NE : TCG_COND_EQ;



            gen_brcondi(dc, eq_ne, cpu_R[RRRN_S], 0,

                    4 + (RRRN_R | ((RRRN_T & 3) << 4)));

        }

        break;



    case 13: /*ST3n*/

        switch (RRRN_R) {

        case 0: /*MOV.Nn*/

            if (gen_window_check2(dc, RRRN_S, RRRN_T)) {

                tcg_gen_mov_i32(cpu_R[RRRN_T], cpu_R[RRRN_S]);

            }

            break;



        case 15: /*S3*/

            switch (RRRN_T) {

            case 0: /*RET.Nn*/

                gen_jump(dc, cpu_R[0]);

                break;



            case 1: /*RETW.Nn*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                {

                    TCGv_i32 tmp = tcg_const_i32(dc->pc);

                    gen_advance_ccount(dc);

                    gen_helper_retw(tmp, cpu_env, tmp);

                    gen_jump(dc, tmp);

                    tcg_temp_free(tmp);

                }

                break;



            case 2: /*BREAK.Nn*/

                HAS_OPTION(XTENSA_OPTION_DEBUG);

                if (dc->debug) {

                    gen_debug_exception(dc, DEBUGCAUSE_BN);

                }

                break;



            case 3: /*NOP.Nn*/

                break;



            case 6: /*ILL.Nn*/

                gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    default: /*reserved*/

        RESERVED();

        break;

    }



    if (dc->is_jmp == DISAS_NEXT) {

        gen_check_loop_end(dc, 0);

    }

    dc->pc = dc->next_pc;



    return;



invalid_opcode:

    qemu_log(""INVALID(pc = %08x)\n"", dc->pc);

    gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

#undef HAS_OPTION

}
",11140,"static void disas_xtensa_insn(CPUXtensaState *rc, DisasContext *di)

{

#define HAS_OPTION_BITS(opt) do { \

        if (!option_bits_enabled(di, opt)) { \

            qemu_log(""Option is not enabled %s:%d
"", \

                    __FILE__, __LINE__); \

            goto invalid_opcode; \

        } \

    } while (0)



#define HAS_OPTION(opt) HAS_OPTION_BITS(XTENSA_OPTION_BIT(opt))



#define TBD() qemu_log(""TBD(pc = %08x): %s:%d
"", di->pc, __FILE__, __LINE__)

#define RESERVED() do { \

        qemu_log(""RESERVED(pc = %08x, %02x%02x%02x): %s:%d
"", \

                dc->pc, b0, b1, b2, __FILE__, __LINE__); \

        goto invalid_opcode; \

    } while (0)





#ifdef TARGET_WORDS_BIGENDIAN

#define OP0 (((b0) & 0xf0) >> 4)

#define OP1 (((b2) & 0xf0) >> 4)

#define OP2 ((b2) & 0xf)

#define RRR_R ((b1) & 0xf)

#define RRR_S (((b1) & 0xf0) >> 4)

#define RRR_T ((b0) & 0xf)

#else

#define OP0 (((b0) & 0xf))

#define OP1 (((b2) & 0xf))

#define OP2 (((b2) & 0xf0) >> 4)

#define RRR_R (((b1) & 0xf0) >> 4)

#define RRR_S (((b1) & 0xf))

#define RRR_T (((b0) & 0xf0) >> 4)

#endif

#define RRR_X ((RRR_R & 0x4) >> 2)

#define RRR_Y ((RRR_T & 0x4) >> 2)

#define RRR_W (RRR_R & 0x3)



#define RRRN_R RRR_R

#define RRRN_S RRR_S

#define RRRN_T RRR_T



#define RRI4_R RRR_R

#define RRI4_S RRR_S

#define RRI4_T RRR_T

#ifdef TARGET_WORDS_BIGENDIAN

#define RRI4_IMM4 ((b2) & 0xf)

#else

#define RRI4_IMM4 (((b2) & 0xf0) >> 4)

#endif



#define RRI8_R RRR_R

#define RRI8_S RRR_S

#define RRI8_T RRR_T

#define RRI8_IMM8 (b2)

#define RRI8_IMM8_SE ((((b2) & 0x80) ? 0xffffff00 : 0) | RRI8_IMM8)



#ifdef TARGET_WORDS_BIGENDIAN

#define RI16_IMM16 (((b1) << 8) | (b2))

#else

#define RI16_IMM16 (((b2) << 8) | (b1))

#endif



#ifdef TARGET_WORDS_BIGENDIAN

#define CALL_N (((b0) & 0xc) >> 2)

#define CALL_OFFSET ((((b0) & 0x3) << 16) | ((b1) << 8) | (b2))

#else

#define CALL_N (((b0) & 0x30) >> 4)

#define CALL_OFFSET ((((b0) & 0xc0) >> 6) | ((b1) << 2) | ((b2) << 10))

#endif

#define CALL_OFFSET_SE \

    (((CALL_OFFSET & 0x20000) ? 0xfffc0000 : 0) | CALL_OFFSET)



#define CALLX_N CALL_N

#ifdef TARGET_WORDS_BIGENDIAN

#define CALLX_M ((b0) & 0x3)

#else

#define CALLX_M (((b0) & 0xc0) >> 6)

#endif

#define CALLX_S RRR_S



#define BRI12_M CALLX_M

#define BRI12_S RRR_S

#ifdef TARGET_WORDS_BIGENDIAN

#define BRI12_IMM12 ((((b1) & 0xf) << 8) | (b2))

#else

#define BRI12_IMM12 ((((b1) & 0xf0) >> 4) | ((b2) << 4))

#endif

#define BRI12_IMM12_SE (((BRI12_IMM12 & 0x800) ? 0xfffff000 : 0) | BRI12_IMM12)



#define BRI8_M BRI12_M

#define BRI8_R RRI8_R

#define BRI8_S RRI8_S

#define BRI8_IMM8 RRI8_IMM8

#define BRI8_IMM8_SE RRI8_IMM8_SE



#define RSR_SR (b1)



    uint8_t b0 = cpu_ldub_code(rc, di->pc);

    uint8_t b1 = cpu_ldub_code(rc, di->pc + 1);

    uint8_t b2 = 0;

    unsigned len = xtensa_op0_insn_len(OP0);



    static const uint32_t B4CONST[] = {

        0xffffffff, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256

    };



    static const uint32_t B4CONSTU[] = {

        32768, 65536, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256

    };



    switch (len) {

    case 2:

        HAS_OPTION(XTENSA_OPTION_CODE_DENSITY);

        break;



    case 3:

        b2 = cpu_ldub_code(rc, di->pc + 2);

        break;



    default:

        RESERVED();

    }

    di->next_pc = di->pc + len;



    switch (OP0) {

    case 0: /*QRST*/

        switch (OP1) {

        case 0: /*RST0*/

            switch (OP2) {

            case 0: /*ST0*/

                if ((RRR_R & 0xc) == 0x8) {

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                }



                switch (RRR_R) {

                case 0: /*SNM0*/

                    switch (CALLX_M) {

                    case 0: /*ILL*/

                        gen_exception_cause(di, ILLEGAL_INSTRUCTION_CAUSE);

                        break;



                    case 1: /*reserved*/

                        RESERVED();

                        break;



                    case 2: /*JR*/

                        switch (CALLX_N) {

                        case 0: /*RET*/

                        case 2: /*JX*/

                            if (gen_window_check1(di, CALLX_S)) {

                                gen_jump(di, cpu_R[CALLX_S]);

                            }

                            break;



                        case 1: /*RETWw*/

                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                            {

                                TCGv_i32 tmp = tcg_const_i32(di->pc);

                                gen_advance_ccount(di);

                                gen_helper_retw(tmp, cpu_env, tmp);

                                gen_jump(di, tmp);

                                tcg_temp_free(tmp);

                            }

                            break;



                        case 3: /*reserved*/

                            RESERVED();

                            break;

                        }

                        break;



                    case 3: /*CALLX*/

                        if (!gen_window_check2(di, CALLX_S, CALLX_N << 2)) {

                            break;

                        }

                        switch (CALLX_N) {

                        case 0: /*CALLX0*/

                            {

                                TCGv_i32 tmp = tcg_temp_new_i32();

                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);

                                tcg_gen_movi_i32(cpu_R[0], di->next_pc);

                                gen_jump(di, tmp);

                                tcg_temp_free(tmp);

                            }

                            break;



                        case 1: /*CALLX4w*/

                        case 2: /*CALLX8w*/

                        case 3: /*CALLX12w*/

                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                            {

                                TCGv_i32 tmp = tcg_temp_new_i32();



                                tcg_gen_mov_i32(tmp, cpu_R[CALLX_S]);

                                gen_callw(di, CALLX_N, tmp);

                                tcg_temp_free(tmp);

                            }

                            break;

                        }

                        break;

                    }

                    break;



                case 1: /*MOVSPw*/

                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                    if (gen_window_check2(di, RRR_T, RRR_S)) {

                        TCGv_i32 pc = tcg_const_i32(di->pc);

                        gen_advance_ccount(di);

                        gen_helper_movsp(cpu_env, pc);

                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_R[RRR_S]);

                        tcg_temp_free(pc);

                    }

                    break;



                case 2: /*SYNC*/

                    switch (RRR_T) {

                    case 0: /*ISYNC*/

                        break;



                    case 1: /*RSYNC*/

                        break;



                    case 2: /*ESYNC*/

                        break;



                    case 3: /*DSYNC*/

                        break;



                    case 8: /*EXCW*/

                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);

                        break;



                    case 12: /*MEMW*/

                        break;



                    case 13: /*EXTW*/

                        break;



                    case 15: /*NOP*/

                        break;



                    default: /*reserved*/

                        RESERVED();

                        break;

                    }

                    break;



                case 3: /*RFEIx*/

                    switch (RRR_T) {

                    case 0: /*RFETx*/

                        HAS_OPTION(XTENSA_OPTION_EXCEPTION);

                        switch (RRR_S) {

                        case 0: /*RFEx*/

                            if (gen_check_privilege(di)) {

                                tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);

                                gen_helper_check_interrupts(cpu_env);

                                gen_jump(di, cpu_SR[EPC1]);

                            }

                            break;



                        case 1: /*RFUEx*/

                            RESERVED();

                            break;



                        case 2: /*RFDEx*/

                            if (gen_check_privilege(di)) {

                                gen_jump(di, cpu_SR[

                                         di->config->ndepc ? DEPC : EPC1]);

                            }

                            break;



                        case 4: /*RFWOw*/

                        case 5: /*RFWUw*/

                            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                            if (gen_check_privilege(di)) {

                                TCGv_i32 tmp = tcg_const_i32(1);



                                tcg_gen_andi_i32(

                                        cpu_SR[PS], cpu_SR[PS], ~PS_EXCM);

                                tcg_gen_shl_i32(tmp, tmp, cpu_SR[WINDOW_BASE]);



                                if (RRR_S == 4) {

                                    tcg_gen_andc_i32(cpu_SR[WINDOW_START],

                                            cpu_SR[WINDOW_START], tmp);

                                } else {

                                    tcg_gen_or_i32(cpu_SR[WINDOW_START],

                                            cpu_SR[WINDOW_START], tmp);

                                }



                                gen_helper_restore_owb(cpu_env);

                                gen_helper_check_interrupts(cpu_env);

                                gen_jump(di, cpu_SR[EPC1]);



                                tcg_temp_free(tmp);

                            }

                            break;



                        default: /*reserved*/

                            RESERVED();

                            break;

                        }

                        break;



                    case 1: /*RFIx*/

                        HAS_OPTION(XTENSA_OPTION_HIGH_PRIORITY_INTERRUPT);

                        if (RRR_S >= 2 && RRR_S <= di->config->nlevel) {

                            if (gen_check_privilege(di)) {

                                tcg_gen_mov_i32(cpu_SR[PS],

                                                cpu_SR[EPS2 + RRR_S - 2]);

                                gen_helper_check_interrupts(cpu_env);

                                gen_jump(di, cpu_SR[EPC1 + RRR_S - 1]);

                            }

                        } else {

                            qemu_log(""RFI %d is illegal
"", RRR_S);

                            gen_exception_cause(di, ILLEGAL_INSTRUCTION_CAUSE);

                        }

                        break;



                    case 2: /*RFME*/

                        TBD();

                        break;



                    default: /*reserved*/

                        RESERVED();

                        break;



                    }

                    break;



                case 4: /*BREAKx*/

                    HAS_OPTION(XTENSA_OPTION_DEBUG);

                    if (di->debug) {

                        gen_debug_exception(di, DEBUGCAUSE_BI);

                    }

                    break;



                case 5: /*SYSCALLx*/

                    HAS_OPTION(XTENSA_OPTION_EXCEPTION);

                    switch (RRR_S) {

                    case 0: /*SYSCALLx*/

                        gen_exception_cause(di, SYSCALL_CAUSE);

                        break;



                    case 1: /*SIMCALL*/

                        if (semihosting_enabled) {

                            if (gen_check_privilege(di)) {

                                gen_helper_simcall(cpu_env);

                            }

                        } else {

                            qemu_log(""SIMCALL but semihosting is disabled
"");

                            gen_exception_cause(di, ILLEGAL_INSTRUCTION_CAUSE);

                        }

                        break;



                    default:

                        RESERVED();

                        break;

                    }

                    break;



                case 6: /*RSILx*/

                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);

                    if (gen_check_privilege(di) &&

                        gen_window_check1(di, RRR_T)) {

                        tcg_gen_mov_i32(cpu_R[RRR_T], cpu_SR[PS]);

                        tcg_gen_andi_i32(cpu_SR[PS], cpu_SR[PS], ~PS_INTLEVEL);

                        tcg_gen_ori_i32(cpu_SR[PS], cpu_SR[PS], RRR_S);

                        gen_helper_check_interrupts(cpu_env);

                        gen_jumpi_check_loop_end(di, 0);

                    }

                    break;



                case 7: /*WAITIx*/

                    HAS_OPTION(XTENSA_OPTION_INTERRUPT);

                    if (gen_check_privilege(di)) {

                        gen_waiti(di, RRR_S);

                    }

                    break;



                case 8: /*ANY4p*/

                case 9: /*ALL4p*/

                case 10: /*ANY8p*/

                case 11: /*ALL8p*/

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                    {

                        const unsigned shift = (RRR_R & 2) ? 8 : 4;

                        TCGv_i32 mask = tcg_const_i32(

                                ((1 << shift) - 1) << RRR_S);

                        TCGv_i32 tmp = tcg_temp_new_i32();



                        tcg_gen_and_i32(tmp, cpu_SR[BR], mask);

                        if (RRR_R & 1) { /*ALL*/

                            tcg_gen_addi_i32(tmp, tmp, 1 << RRR_S);

                        } else { /*ANY*/

                            tcg_gen_add_i32(tmp, tmp, mask);

                        }

                        tcg_gen_shri_i32(tmp, tmp, RRR_S + shift);

                        tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR],

                                tmp, RRR_T, 1);

                        tcg_temp_free(mask);

                        tcg_temp_free(tmp);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;



                }

                break;



            case 1: /*AND*/

                if (gen_window_check3(di, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_and_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 2: /*OR*/

                if (gen_window_check3(di, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_or_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 3: /*XOR*/

                if (gen_window_check3(di, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_xor_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 4: /*ST1*/

                switch (RRR_R) {

                case 0: /*SSR*/

                    if (gen_window_check1(di, RRR_S)) {

                        gen_right_shift_sar(di, cpu_R[RRR_S]);

                    }

                    break;



                case 1: /*SSL*/

                    if (gen_window_check1(di, RRR_S)) {

                        gen_left_shift_sar(di, cpu_R[RRR_S]);

                    }

                    break;



                case 2: /*SSA8L*/

                    if (gen_window_check1(di, RRR_S)) {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);

                        gen_right_shift_sar(di, tmp);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 3: /*SSA8B*/

                    if (gen_window_check1(di, RRR_S)) {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], 3);

                        gen_left_shift_sar(di, tmp);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 4: /*SSAI*/

                    {

                        TCGv_i32 tmp = tcg_const_i32(

                                RRR_S | ((RRR_T & 1) << 4));

                        gen_right_shift_sar(di, tmp);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 6: /*RER*/

                    TBD();

                    break;



                case 7: /*WER*/

                    TBD();

                    break;



                case 8: /*ROTWw*/

                    HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                    if (gen_check_privilege(di)) {

                        TCGv_i32 tmp = tcg_const_i32(

                                RRR_T | ((RRR_T & 8) ? 0xfffffff0 : 0));

                        gen_helper_rotw(cpu_env, tmp);

                        tcg_temp_free(tmp);

                        /* This can change tb->flags, so exit tb */

                        gen_jumpi_check_loop_end(di, -1);

                    }

                    break;



                case 14: /*NSAu*/

                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);

                    if (gen_window_check2(di, RRR_S, RRR_T)) {

                        gen_helper_nsa(cpu_R[RRR_T], cpu_R[RRR_S]);

                    }

                    break;



                case 15: /*NSAUu*/

                    HAS_OPTION(XTENSA_OPTION_MISC_OP_NSA);

                    if (gen_window_check2(di, RRR_S, RRR_T)) {

                        gen_helper_nsau(cpu_R[RRR_T], cpu_R[RRR_S]);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            case 5: /*TLB*/

                HAS_OPTION_BITS(

                        XTENSA_OPTION_BIT(XTENSA_OPTION_MMU) |

                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_PROTECTION) |

                        XTENSA_OPTION_BIT(XTENSA_OPTION_REGION_TRANSLATION));

                if (gen_check_privilege(di) &&

                    gen_window_check2(di, RRR_S, RRR_T)) {

                    TCGv_i32 dtlb = tcg_const_i32((RRR_R & 8) != 0);



                    switch (RRR_R & 7) {

                    case 3: /*RITLB0*/ /*RDTLB0*/

                        gen_helper_rtlb0(cpu_R[RRR_T],

                                cpu_env, cpu_R[RRR_S], dtlb);

                        break;



                    case 4: /*IITLB*/ /*IDTLB*/

                        gen_helper_itlb(cpu_env, cpu_R[RRR_S], dtlb);

                        /* This could change memory mapping, so exit tb */

                        gen_jumpi_check_loop_end(di, -1);

                        break;



                    case 5: /*PITLB*/ /*PDTLB*/

                        tcg_gen_movi_i32(cpu_pc, di->pc);

                        gen_helper_ptlb(cpu_R[RRR_T],

                                cpu_env, cpu_R[RRR_S], dtlb);

                        break;



                    case 6: /*WITLB*/ /*WDTLB*/

                        gen_helper_wtlb(

                                cpu_env, cpu_R[RRR_T], cpu_R[RRR_S], dtlb);

                        /* This could change memory mapping, so exit tb */

                        gen_jumpi_check_loop_end(di, -1);

                        break;



                    case 7: /*RITLB1*/ /*RDTLB1*/

                        gen_helper_rtlb1(cpu_R[RRR_T],

                                cpu_env, cpu_R[RRR_S], dtlb);

                        break;



                    default:

                        tcg_temp_free(dtlb);

                        RESERVED();

                        break;

                    }

                    tcg_temp_free(dtlb);

                }

                break;



            case 6: /*RT0*/

                if (!gen_window_check2(di, RRR_R, RRR_T)) {

                    break;

                }

                switch (RRR_S) {

                case 0: /*NEG*/

                    tcg_gen_neg_i32(cpu_R[RRR_R], cpu_R[RRR_T]);

                    break;



                case 1: /*ABS*/

                    {

                        TCGv_i32 zero = tcg_const_i32(0);

                        TCGv_i32 neg = tcg_temp_new_i32();



                        tcg_gen_neg_i32(neg, cpu_R[RRR_T]);

                        tcg_gen_movcond_i32(TCG_COND_GE, cpu_R[RRR_R],

                                cpu_R[RRR_T], zero, cpu_R[RRR_T], neg);

                        tcg_temp_free(neg);

                        tcg_temp_free(zero);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            case 7: /*reserved*/

                RESERVED();

                break;



            case 8: /*ADD*/

                if (gen_window_check3(di, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_add_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 9: /*ADD**/

            case 10:

            case 11:

                if (gen_window_check3(di, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 8);

                    tcg_gen_add_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);

                    tcg_temp_free(tmp);

                }

                break;



            case 12: /*SUB*/

                if (gen_window_check3(di, RRR_R, RRR_S, RRR_T)) {

                    tcg_gen_sub_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 13: /*SUB**/

            case 14:

            case 15:

                if (gen_window_check3(di, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_shli_i32(tmp, cpu_R[RRR_S], OP2 - 12);

                    tcg_gen_sub_i32(cpu_R[RRR_R], tmp, cpu_R[RRR_T]);

                    tcg_temp_free(tmp);

                }

                break;

            }

            break;



        case 1: /*RST1*/

            switch (OP2) {

            case 0: /*SLLI*/

            case 1:

                if (gen_window_check2(di, RRR_R, RRR_S)) {

                    tcg_gen_shli_i32(cpu_R[RRR_R], cpu_R[RRR_S],

                                     32 - (RRR_T | ((OP2 & 1) << 4)));

                }

                break;



            case 2: /*SRAI*/

            case 3:

                if (gen_window_check2(di, RRR_R, RRR_T)) {

                    tcg_gen_sari_i32(cpu_R[RRR_R], cpu_R[RRR_T],

                                     RRR_S | ((OP2 & 1) << 4));

                }

                break;



            case 4: /*SRLI*/

                if (gen_window_check2(di, RRR_R, RRR_T)) {

                    tcg_gen_shri_i32(cpu_R[RRR_R], cpu_R[RRR_T], RRR_S);

                }

                break;



            case 6: /*XSR*/

                if (gen_check_sr(di, RSR_SR, SR_X) &&

                    (RSR_SR < 64 || gen_check_privilege(di)) &&

                    gen_window_check1(di, RRR_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();



                    tcg_gen_mov_i32(tmp, cpu_R[RRR_T]);

                    gen_rsr(di, cpu_R[RRR_T], RSR_SR);

                    gen_wsr(di, RSR_SR, tmp);

                    tcg_temp_free(tmp);

                }

                break;



                /*

                 * Note: 64 bit ops are used here solely because SAR values

                 * have range 0..63

                 */

#define gen_shift_reg(cmd, reg) do { \

                    TCGv_i64 tmp = tcg_temp_new_i64(); \

                    tcg_gen_extu_i32_i64(tmp, reg); \

                    tcg_gen_##cmd##_i64(v, v, tmp); \

                    tcg_gen_trunc_i64_i32(cpu_R[RRR_R], v); \

                    tcg_temp_free_i64(v); \

                    tcg_temp_free_i64(tmp); \

                } while (0)



#define gen_shift(cmd) gen_shift_reg(cmd, cpu_SR[SAR])



            case 8: /*SRC*/

                if (gen_window_check3(di, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i64 v = tcg_temp_new_i64();

                    tcg_gen_concat_i32_i64(v, cpu_R[RRR_T], cpu_R[RRR_S]);

                    gen_shift(shr);

                }

                break;



            case 9: /*SRL*/

                if (!gen_window_check2(di, RRR_R, RRR_T)) {

                    break;

                }

                if (di->sar_5bit) {

                    tcg_gen_shr_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);

                } else {

                    TCGv_i64 v = tcg_temp_new_i64();

                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_T]);

                    gen_shift(shr);

                }

                break;



            case 10: /*SLL*/

                if (!gen_window_check2(di, RRR_R, RRR_S)) {

                    break;

                }

                if (di->sar_m32_5bit) {

                    tcg_gen_shl_i32(cpu_R[RRR_R], cpu_R[RRR_S], di->sar_m32);

                } else {

                    TCGv_i64 v = tcg_temp_new_i64();

                    TCGv_i32 s = tcg_const_i32(32);

                    tcg_gen_sub_i32(s, s, cpu_SR[SAR]);

                    tcg_gen_andi_i32(s, s, 0x3f);

                    tcg_gen_extu_i32_i64(v, cpu_R[RRR_S]);

                    gen_shift_reg(shl, s);

                    tcg_temp_free(s);

                }

                break;



            case 11: /*SRA*/

                if (!gen_window_check2(di, RRR_R, RRR_T)) {

                    break;

                }

                if (di->sar_5bit) {

                    tcg_gen_sar_i32(cpu_R[RRR_R], cpu_R[RRR_T], cpu_SR[SAR]);

                } else {

                    TCGv_i64 v = tcg_temp_new_i64();

                    tcg_gen_ext_i32_i64(v, cpu_R[RRR_T]);

                    gen_shift(sar);

                }

                break;

#undef gen_shift

#undef gen_shift_reg



            case 12: /*MUL16U*/

                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);

                if (gen_window_check3(di, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 v1 = tcg_temp_new_i32();

                    TCGv_i32 v2 = tcg_temp_new_i32();

                    tcg_gen_ext16u_i32(v1, cpu_R[RRR_S]);

                    tcg_gen_ext16u_i32(v2, cpu_R[RRR_T]);

                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);

                    tcg_temp_free(v2);

                    tcg_temp_free(v1);

                }

                break;



            case 13: /*MUL16S*/

                HAS_OPTION(XTENSA_OPTION_16_BIT_IMUL);

                if (gen_window_check3(di, RRR_R, RRR_S, RRR_T)) {

                    TCGv_i32 v1 = tcg_temp_new_i32();

                    TCGv_i32 v2 = tcg_temp_new_i32();

                    tcg_gen_ext16s_i32(v1, cpu_R[RRR_S]);

                    tcg_gen_ext16s_i32(v2, cpu_R[RRR_T]);

                    tcg_gen_mul_i32(cpu_R[RRR_R], v1, v2);

                    tcg_temp_free(v2);

                    tcg_temp_free(v1);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 2: /*RST2*/

            if (OP2 >= 8 && !gen_window_check3(di, RRR_R, RRR_S, RRR_T)) {

                break;

            }



            if (OP2 >= 12) {

                HAS_OPTION(XTENSA_OPTION_32_BIT_IDIV);

                int label = gen_new_label();

                tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0, label);

                gen_exception_cause(di, INTEGER_DIVIDE_BY_ZERO_CAUSE);

                gen_set_label(label);

            }



            switch (OP2) {

#define BOOLEAN_LOGIC(fn, r, s, t) \

                do { \

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN); \

                    TCGv_i32 tmp1 = tcg_temp_new_i32(); \

                    TCGv_i32 tmp2 = tcg_temp_new_i32(); \

                    \

                    tcg_gen_shri_i32(tmp1, cpu_SR[BR], s); \

                    tcg_gen_shri_i32(tmp2, cpu_SR[BR], t); \

                    tcg_gen_##fn##_i32(tmp1, tmp1, tmp2); \

                    tcg_gen_deposit_i32(cpu_SR[BR], cpu_SR[BR], tmp1, r, 1); \

                    tcg_temp_free(tmp1); \

                    tcg_temp_free(tmp2); \

                } while (0)



            case 0: /*ANDBp*/

                BOOLEAN_LOGIC(and, RRR_R, RRR_S, RRR_T);

                break;



            case 1: /*ANDBCp*/

                BOOLEAN_LOGIC(andc, RRR_R, RRR_S, RRR_T);

                break;



            case 2: /*ORBp*/

                BOOLEAN_LOGIC(or, RRR_R, RRR_S, RRR_T);

                break;



            case 3: /*ORBCp*/

                BOOLEAN_LOGIC(orc, RRR_R, RRR_S, RRR_T);

                break;



            case 4: /*XORBp*/

                BOOLEAN_LOGIC(xor, RRR_R, RRR_S, RRR_T);

                break;



#undef BOOLEAN_LOGIC



            case 8: /*MULLi*/

                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL);

                tcg_gen_mul_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                break;



            case 10: /*MULUHi*/

            case 11: /*MULSHi*/

                HAS_OPTION(XTENSA_OPTION_32_BIT_IMUL_HIGH);

                {

                    TCGv lo = tcg_temp_new();



                    if (OP2 == 10) {

                        tcg_gen_mulu2_i32(lo, cpu_R[RRR_R],

                                          cpu_R[RRR_S], cpu_R[RRR_T]);

                    } else {

                        tcg_gen_muls2_i32(lo, cpu_R[RRR_R],

                                          cpu_R[RRR_S], cpu_R[RRR_T]);

                    }

                    tcg_temp_free(lo);

                }

                break;



            case 12: /*QUOUi*/

                tcg_gen_divu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                break;



            case 13: /*QUOSi*/

            case 15: /*REMSi*/

                {

                    int label1 = gen_new_label();

                    int label2 = gen_new_label();



                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_S], 0x80000000,

                            label1);

                    tcg_gen_brcondi_i32(TCG_COND_NE, cpu_R[RRR_T], 0xffffffff,

                            label1);

                    tcg_gen_movi_i32(cpu_R[RRR_R],

                            OP2 == 13 ? 0x80000000 : 0);

                    tcg_gen_br(label2);

                    gen_set_label(label1);

                    if (OP2 == 13) {

                        tcg_gen_div_i32(cpu_R[RRR_R],

                                cpu_R[RRR_S], cpu_R[RRR_T]);

                    } else {

                        tcg_gen_rem_i32(cpu_R[RRR_R],

                                cpu_R[RRR_S], cpu_R[RRR_T]);

                    }

                    gen_set_label(label2);

                }

                break;



            case 14: /*REMUi*/

                tcg_gen_remu_i32(cpu_R[RRR_R], cpu_R[RRR_S], cpu_R[RRR_T]);

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 3: /*RST3*/

            switch (OP2) {

            case 0: /*RSR*/

                if (gen_check_sr(di, RSR_SR, SR_R) &&

                    (RSR_SR < 64 || gen_check_privilege(di)) &&

                    gen_window_check1(di, RRR_T)) {

                    gen_rsr(di, cpu_R[RRR_T], RSR_SR);

                }

                break;



            case 1: /*WSR*/

                if (gen_check_sr(di, RSR_SR, SR_W) &&

                    (RSR_SR < 64 || gen_check_privilege(di)) &&

                    gen_window_check1(di, RRR_T)) {

                    gen_wsr(di, RSR_SR, cpu_R[RRR_T]);

                }

                break;



            case 2: /*SEXTu*/

                HAS_OPTION(XTENSA_OPTION_MISC_OP_SEXT);

                if (gen_window_check2(di, RRR_R, RRR_S)) {

                    int shift = 24 - RRR_T;



                    if (shift == 24) {

                        tcg_gen_ext8s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);

                    } else if (shift == 16) {

                        tcg_gen_ext16s_i32(cpu_R[RRR_R], cpu_R[RRR_S]);

                    } else {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_shli_i32(tmp, cpu_R[RRR_S], shift);

                        tcg_gen_sari_i32(cpu_R[RRR_R], tmp, shift);

                        tcg_temp_free(tmp);

                    }

                }

                break;



            case 3: /*CLAMPSu*/

                HAS_OPTION(XTENSA_OPTION_MISC_OP_CLAMPS);

                if (gen_window_check2(di, RRR_R, RRR_S)) {

                    TCGv_i32 tmp1 = tcg_temp_new_i32();

                    TCGv_i32 tmp2 = tcg_temp_new_i32();

                    TCGv_i32 zero = tcg_const_i32(0);



                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 24 - RRR_T);

                    tcg_gen_xor_i32(tmp2, tmp1, cpu_R[RRR_S]);

                    tcg_gen_andi_i32(tmp2, tmp2, 0xffffffff << (RRR_T + 7));



                    tcg_gen_sari_i32(tmp1, cpu_R[RRR_S], 31);

                    tcg_gen_xori_i32(tmp1, tmp1, 0xffffffff >> (25 - RRR_T));



                    tcg_gen_movcond_i32(TCG_COND_EQ, cpu_R[RRR_R], tmp2, zero,

                            cpu_R[RRR_S], tmp1);

                    tcg_temp_free(tmp1);

                    tcg_temp_free(tmp2);

                    tcg_temp_free(zero);

                }

                break;



            case 4: /*MINu*/

            case 5: /*MAXu*/

            case 6: /*MINUu*/

            case 7: /*MAXUu*/

                HAS_OPTION(XTENSA_OPTION_MISC_OP_MINMAX);

                if (gen_window_check3(di, RRR_R, RRR_S, RRR_T)) {

                    static const TCGCond cond[] = {

                        TCG_COND_LE,

                        TCG_COND_GE,

                        TCG_COND_LEU,

                        TCG_COND_GEU

                    };

                    tcg_gen_movcond_i32(cond[OP2 - 4], cpu_R[RRR_R],

                            cpu_R[RRR_S], cpu_R[RRR_T],

                            cpu_R[RRR_S], cpu_R[RRR_T]);

                }

                break;



            case 8: /*MOVEQZ*/

            case 9: /*MOVNEZ*/

            case 10: /*MOVLTZ*/

            case 11: /*MOVGEZ*/

                if (gen_window_check3(di, RRR_R, RRR_S, RRR_T)) {

                    static const TCGCond cond[] = {

                        TCG_COND_EQ,

                        TCG_COND_NE,

                        TCG_COND_LT,

                        TCG_COND_GE,

                    };

                    TCGv_i32 zero = tcg_const_i32(0);



                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_R[RRR_R],

                            cpu_R[RRR_T], zero, cpu_R[RRR_S], cpu_R[RRR_R]);

                    tcg_temp_free(zero);

                }

                break;



            case 12: /*MOVFp*/

            case 13: /*MOVTp*/

                HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                if (gen_window_check2(di, RRR_R, RRR_S)) {

                    TCGv_i32 zero = tcg_const_i32(0);

                    TCGv_i32 tmp = tcg_temp_new_i32();



                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);

                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,

                            cpu_R[RRR_R], tmp, zero,

                            cpu_R[RRR_S], cpu_R[RRR_R]);



                    tcg_temp_free(tmp);

                    tcg_temp_free(zero);

                }

                break;



            case 14: /*RUR*/

                if (gen_window_check1(di, RRR_R)) {

                    int st = (RRR_S << 4) + RRR_T;

                    if (uregnames[st].name) {

                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_UR[st]);

                    } else {

                        qemu_log(""RUR %d not implemented, "", st);

                        TBD();

                    }

                }

                break;



            case 15: /*WUR*/

                if (gen_window_check1(di, RRR_T)) {

                    if (uregnames[RSR_SR].name) {

                        gen_wur(RSR_SR, cpu_R[RRR_T]);

                    } else {

                        qemu_log(""WUR %d not implemented, "", RSR_SR);

                        TBD();

                    }

                }

                break;



            }

            break;



        case 4: /*EXTUI*/

        case 5:

            if (gen_window_check2(di, RRR_R, RRR_T)) {

                int shiftimm = RRR_S | ((OP1 & 1) << 4);

                int maskimm = (1 << (OP2 + 1)) - 1;



                TCGv_i32 tmp = tcg_temp_new_i32();

                tcg_gen_shri_i32(tmp, cpu_R[RRR_T], shiftimm);

                tcg_gen_andi_i32(cpu_R[RRR_R], tmp, maskimm);

                tcg_temp_free(tmp);

            }

            break;



        case 6: /*CUST0*/

            RESERVED();

            break;



        case 7: /*CUST1*/

            RESERVED();

            break;



        case 8: /*LSCXp*/

            switch (OP2) {

            case 0: /*LSXf*/

            case 1: /*LSXUf*/

            case 4: /*SSXf*/

            case 5: /*SSXUf*/

                HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);

                if (gen_window_check2(di, RRR_S, RRR_T) &&

                    gen_check_cpenable(di, 0)) {

                    TCGv_i32 addr = tcg_temp_new_i32();

                    tcg_gen_add_i32(addr, cpu_R[RRR_S], cpu_R[RRR_T]);

                    gen_load_store_alignment(di, 2, addr, false);

                    if (OP2 & 0x4) {

                        tcg_gen_qemu_st32(cpu_FR[RRR_R], addr, di->cring);

                    } else {

                        tcg_gen_qemu_ld32u(cpu_FR[RRR_R], addr, di->cring);

                    }

                    if (OP2 & 0x1) {

                        tcg_gen_mov_i32(cpu_R[RRR_S], addr);

                    }

                    tcg_temp_free(addr);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 9: /*LSC4*/

            if (!gen_window_check2(di, RRR_S, RRR_T)) {

                break;

            }

            switch (OP2) {

            case 0: /*L32E*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                if (gen_check_privilege(di)) {

                    TCGv_i32 addr = tcg_temp_new_i32();

                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],

                            (0xffffffc0 | (RRR_R << 2)));

                    tcg_gen_qemu_ld32u(cpu_R[RRR_T], addr, di->ring);

                    tcg_temp_free(addr);

                }

                break;



            case 4: /*S32E*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                if (gen_check_privilege(di)) {

                    TCGv_i32 addr = tcg_temp_new_i32();

                    tcg_gen_addi_i32(addr, cpu_R[RRR_S],

                            (0xffffffc0 | (RRR_R << 2)));

                    tcg_gen_qemu_st32(cpu_R[RRR_T], addr, di->ring);

                    tcg_temp_free(addr);

                }

                break;



            default:

                RESERVED();

                break;

            }

            break;



        case 10: /*FP0*/

            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);

            switch (OP2) {

            case 0: /*ADD.Sf*/

                if (gen_check_cpenable(di, 0)) {

                    gen_helper_add_s(cpu_FR[RRR_R], cpu_env,

                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);

                }

                break;



            case 1: /*SUB.Sf*/

                if (gen_check_cpenable(di, 0)) {

                    gen_helper_sub_s(cpu_FR[RRR_R], cpu_env,

                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);

                }

                break;



            case 2: /*MUL.Sf*/

                if (gen_check_cpenable(di, 0)) {

                    gen_helper_mul_s(cpu_FR[RRR_R], cpu_env,

                                     cpu_FR[RRR_S], cpu_FR[RRR_T]);

                }

                break;



            case 4: /*MADD.Sf*/

                if (gen_check_cpenable(di, 0)) {

                    gen_helper_madd_s(cpu_FR[RRR_R], cpu_env,

                                      cpu_FR[RRR_R], cpu_FR[RRR_S],

                                      cpu_FR[RRR_T]);

                }

                break;



            case 5: /*MSUB.Sf*/

                if (gen_check_cpenable(di, 0)) {

                    gen_helper_msub_s(cpu_FR[RRR_R], cpu_env,

                                      cpu_FR[RRR_R], cpu_FR[RRR_S],

                                      cpu_FR[RRR_T]);

                }

                break;



            case 8: /*ROUND.Sf*/

            case 9: /*TRUNC.Sf*/

            case 10: /*FLOOR.Sf*/

            case 11: /*CEIL.Sf*/

            case 14: /*UTRUNC.Sf*/

                if (gen_window_check1(di, RRR_R) &&

                    gen_check_cpenable(di, 0)) {

                    static const unsigned rounding_mode_const[] = {

                        float_round_nearest_even,

                        float_round_to_zero,

                        float_round_down,

                        float_round_up,

                        [6] = float_round_to_zero,

                    };

                    TCGv_i32 rounding_mode = tcg_const_i32(

                            rounding_mode_const[OP2 & 7]);

                    TCGv_i32 scale = tcg_const_i32(RRR_T);



                    if (OP2 == 14) {

                        gen_helper_ftoui(cpu_R[RRR_R], cpu_FR[RRR_S],

                                rounding_mode, scale);

                    } else {

                        gen_helper_ftoi(cpu_R[RRR_R], cpu_FR[RRR_S],

                                rounding_mode, scale);

                    }



                    tcg_temp_free(rounding_mode);

                    tcg_temp_free(scale);

                }

                break;



            case 12: /*FLOAT.Sf*/

            case 13: /*UFLOAT.Sf*/

                if (gen_window_check1(di, RRR_S) &&

                    gen_check_cpenable(di, 0)) {

                    TCGv_i32 scale = tcg_const_i32(-RRR_T);



                    if (OP2 == 13) {

                        gen_helper_uitof(cpu_FR[RRR_R], cpu_env,

                                cpu_R[RRR_S], scale);

                    } else {

                        gen_helper_itof(cpu_FR[RRR_R], cpu_env,

                                cpu_R[RRR_S], scale);

                    }

                    tcg_temp_free(scale);

                }

                break;



            case 15: /*FP1OP*/

                switch (RRR_T) {

                case 0: /*MOV.Sf*/

                    if (gen_check_cpenable(di, 0)) {

                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                case 1: /*ABS.Sf*/

                    if (gen_check_cpenable(di, 0)) {

                        gen_helper_abs_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                case 4: /*RFRf*/

                    if (gen_window_check1(di, RRR_R) &&

                        gen_check_cpenable(di, 0)) {

                        tcg_gen_mov_i32(cpu_R[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                case 5: /*WFRf*/

                    if (gen_window_check1(di, RRR_S) &&

                        gen_check_cpenable(di, 0)) {

                        tcg_gen_mov_i32(cpu_FR[RRR_R], cpu_R[RRR_S]);

                    }

                    break;



                case 6: /*NEG.Sf*/

                    if (gen_check_cpenable(di, 0)) {

                        gen_helper_neg_s(cpu_FR[RRR_R], cpu_FR[RRR_S]);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        case 11: /*FP1*/

            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);



#define gen_compare(rel, br, a, b) \

    do { \

        if (gen_check_cpenable(di, 0)) { \

            TCGv_i32 bit = tcg_const_i32(1 << br); \

            \

            gen_helper_##rel(cpu_env, bit, cpu_FR[a], cpu_FR[b]); \

            tcg_temp_free(bit); \

        } \

    } while (0)



            switch (OP2) {

            case 1: /*UN.Sf*/

                gen_compare(un_s, RRR_R, RRR_S, RRR_T);

                break;



            case 2: /*OEQ.Sf*/

                gen_compare(oeq_s, RRR_R, RRR_S, RRR_T);

                break;



            case 3: /*UEQ.Sf*/

                gen_compare(ueq_s, RRR_R, RRR_S, RRR_T);

                break;



            case 4: /*OLT.Sf*/

                gen_compare(olt_s, RRR_R, RRR_S, RRR_T);

                break;



            case 5: /*ULT.Sf*/

                gen_compare(ult_s, RRR_R, RRR_S, RRR_T);

                break;



            case 6: /*OLE.Sf*/

                gen_compare(ole_s, RRR_R, RRR_S, RRR_T);

                break;



            case 7: /*ULE.Sf*/

                gen_compare(ule_s, RRR_R, RRR_S, RRR_T);

                break;



#undef gen_compare



            case 8: /*MOVEQZ.Sf*/

            case 9: /*MOVNEZ.Sf*/

            case 10: /*MOVLTZ.Sf*/

            case 11: /*MOVGEZ.Sf*/

                if (gen_window_check1(di, RRR_T) &&

                    gen_check_cpenable(di, 0)) {

                    static const TCGCond cond[] = {

                        TCG_COND_EQ,

                        TCG_COND_NE,

                        TCG_COND_LT,

                        TCG_COND_GE,

                    };

                    TCGv_i32 zero = tcg_const_i32(0);



                    tcg_gen_movcond_i32(cond[OP2 - 8], cpu_FR[RRR_R],

                            cpu_R[RRR_T], zero, cpu_FR[RRR_S], cpu_FR[RRR_R]);

                    tcg_temp_free(zero);

                }

                break;



            case 12: /*MOVF.Sf*/

            case 13: /*MOVT.Sf*/

                HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                if (gen_check_cpenable(di, 0)) {

                    TCGv_i32 zero = tcg_const_i32(0);

                    TCGv_i32 tmp = tcg_temp_new_i32();



                    tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRR_T);

                    tcg_gen_movcond_i32(OP2 & 1 ? TCG_COND_NE : TCG_COND_EQ,

                            cpu_FR[RRR_R], tmp, zero,

                            cpu_FR[RRR_S], cpu_FR[RRR_R]);



                    tcg_temp_free(tmp);

                    tcg_temp_free(zero);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    case 1: /*L32R*/

        if (gen_window_check1(di, RRR_T)) {

            TCGv_i32 tmp = tcg_const_i32(

                    ((di->tb->flags & XTENSA_TBFLAG_LITBASE) ?

                     0 : ((di->pc + 3) & ~3)) +

                    (0xfffc0000 | (RI16_IMM16 << 2)));



            if (di->tb->flags & XTENSA_TBFLAG_LITBASE) {

                tcg_gen_add_i32(tmp, tmp, di->litbase);

            }

            tcg_gen_qemu_ld32u(cpu_R[RRR_T], tmp, di->cring);

            tcg_temp_free(tmp);

        }

        break;



    case 2: /*LSAI*/

#define gen_load_store(type, shift) do { \

            if (gen_window_check2(di, RRI8_S, RRI8_T)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                \

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << shift); \

                if (shift) { \

                    gen_load_store_alignment(di, shift, addr, false); \

                } \

                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \

                tcg_temp_free(addr); \

            } \

        } while (0)



        switch (RRI8_R) {

        case 0: /*L8UI*/

            gen_load_store(ld8u, 0);

            break;



        case 1: /*L16UI*/

            gen_load_store(ld16u, 1);

            break;



        case 2: /*L32I*/

            gen_load_store(ld32u, 2);

            break;



        case 4: /*S8I*/

            gen_load_store(st8, 0);

            break;



        case 5: /*S16I*/

            gen_load_store(st16, 1);

            break;



        case 6: /*S32I*/

            gen_load_store(st32, 2);

            break;



#define gen_dcache_hit_test(w, shift) do { \

            if (gen_window_check1(di, RRI##w##_S)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                TCGv_i32 res = tcg_temp_new_i32(); \

                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \

                                 RRI##w##_IMM##w << shift); \

                tcg_gen_qemu_ld8u(res, addr, di->cring); \

                tcg_temp_free(addr); \

                tcg_temp_free(res); \

            } \

        } while (0)



#define gen_dcache_hit_test4() gen_dcache_hit_test(4, 4)

#define gen_dcache_hit_test8() gen_dcache_hit_test(8, 2)



        case 7: /*CACHEc*/

            if (RRI8_T < 8) {

                HAS_OPTION(XTENSA_OPTION_DCACHE);

            }



            switch (RRI8_T) {

            case 0: /*DPFRc*/

                gen_window_check1(di, RRI8_S);

                break;



            case 1: /*DPFWc*/

                gen_window_check1(di, RRI8_S);

                break;



            case 2: /*DPFROc*/

                gen_window_check1(di, RRI8_S);

                break;



            case 3: /*DPFWOc*/

                gen_window_check1(di, RRI8_S);

                break;



            case 4: /*DHWBc*/

                gen_dcache_hit_test8();

                break;



            case 5: /*DHWBIc*/

                gen_dcache_hit_test8();

                break;



            case 6: /*DHIc*/

                if (gen_check_privilege(di)) {

                    gen_dcache_hit_test8();

                }

                break;



            case 7: /*DIIc*/

                if (gen_check_privilege(di)) {

                    gen_window_check1(di, RRI8_S);

                }

                break;



            case 8: /*DCEc*/

                switch (OP1) {

                case 0: /*DPFLl*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);

                    if (gen_check_privilege(di)) {

                        gen_dcache_hit_test4();

                    }

                    break;



                case 2: /*DHUl*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);

                    if (gen_check_privilege(di)) {

                        gen_dcache_hit_test4();

                    }

                    break;



                case 3: /*DIUl*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE_INDEX_LOCK);

                    if (gen_check_privilege(di)) {

                        gen_window_check1(di, RRI4_S);

                    }

                    break;



                case 4: /*DIWBc*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE);

                    if (gen_check_privilege(di)) {

                        gen_window_check1(di, RRI4_S);

                    }

                    break;



                case 5: /*DIWBIc*/

                    HAS_OPTION(XTENSA_OPTION_DCACHE);

                    if (gen_check_privilege(di)) {

                        gen_window_check1(di, RRI4_S);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;



                }

                break;



#undef gen_dcache_hit_test

#undef gen_dcache_hit_test4

#undef gen_dcache_hit_test8



#define gen_icache_hit_test(w, shift) do { \

            if (gen_window_check1(di, RRI##w##_S)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                tcg_gen_movi_i32(cpu_pc, di->pc); \

                tcg_gen_addi_i32(addr, cpu_R[RRI##w##_S], \

                                 RRI##w##_IMM##w << shift); \

                gen_helper_itlb_hit_test(cpu_env, addr); \

                tcg_temp_free(addr); \

            }\

        } while (0)



#define gen_icache_hit_test4() gen_icache_hit_test(4, 4)

#define gen_icache_hit_test8() gen_icache_hit_test(8, 2)



            case 12: /*IPFc*/

                HAS_OPTION(XTENSA_OPTION_ICACHE);

                gen_window_check1(di, RRI8_S);

                break;



            case 13: /*ICEc*/

                switch (OP1) {

                case 0: /*IPFLl*/

                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);

                    if (gen_check_privilege(di)) {

                        gen_icache_hit_test4();

                    }

                    break;



                case 2: /*IHUl*/

                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);

                    if (gen_check_privilege(di)) {

                        gen_icache_hit_test4();

                    }

                    break;



                case 3: /*IIUl*/

                    HAS_OPTION(XTENSA_OPTION_ICACHE_INDEX_LOCK);

                    if (gen_check_privilege(di)) {

                        gen_window_check1(di, RRI4_S);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;

                }

                break;



            case 14: /*IHIc*/

                HAS_OPTION(XTENSA_OPTION_ICACHE);

                gen_icache_hit_test8();

                break;



            case 15: /*IIIc*/

                HAS_OPTION(XTENSA_OPTION_ICACHE);

                if (gen_check_privilege(di)) {

                    gen_window_check1(di, RRI8_S);

                }

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



#undef gen_icache_hit_test

#undef gen_icache_hit_test4

#undef gen_icache_hit_test8



        case 9: /*L16SI*/

            gen_load_store(ld16s, 1);

            break;

#undef gen_load_store



        case 10: /*MOVI*/

            if (gen_window_check1(di, RRI8_T)) {

                tcg_gen_movi_i32(cpu_R[RRI8_T],

                                 RRI8_IMM8 | (RRI8_S << 8) |

                                 ((RRI8_S & 0x8) ? 0xfffff000 : 0));

            }

            break;



#define gen_load_store_no_hw_align(type) do { \

            if (gen_window_check2(di, RRI8_S, RRI8_T)) { \

                TCGv_i32 addr = tcg_temp_local_new_i32(); \

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2); \

                gen_load_store_alignment(di, 2, addr, true); \

                tcg_gen_qemu_##type(cpu_R[RRI8_T], addr, dc->cring); \

                tcg_temp_free(addr); \

            } \

        } while (0)



        case 11: /*L32AIy*/

            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);

            gen_load_store_no_hw_align(ld32u); /*TODO acquire?*/

            break;



        case 12: /*ADDI*/

            if (gen_window_check2(di, RRI8_S, RRI8_T)) {

                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S], RRI8_IMM8_SE);

            }

            break;



        case 13: /*ADDMI*/

            if (gen_window_check2(di, RRI8_S, RRI8_T)) {

                tcg_gen_addi_i32(cpu_R[RRI8_T], cpu_R[RRI8_S],

                                 RRI8_IMM8_SE << 8);

            }

            break;



        case 14: /*S32C1Iy*/

            HAS_OPTION(XTENSA_OPTION_CONDITIONAL_STORE);

            if (gen_window_check2(di, RRI8_S, RRI8_T)) {

                int label = gen_new_label();

                TCGv_i32 tmp = tcg_temp_local_new_i32();

                TCGv_i32 addr = tcg_temp_local_new_i32();

                TCGv_i32 tpc;



                tcg_gen_mov_i32(tmp, cpu_R[RRI8_T]);

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);

                gen_load_store_alignment(di, 2, addr, true);



                gen_advance_ccount(di);

                tpc = tcg_const_i32(di->pc);

                gen_helper_check_atomctl(cpu_env, tpc, addr);

                tcg_gen_qemu_ld32u(cpu_R[RRI8_T], addr, di->cring);

                tcg_gen_brcond_i32(TCG_COND_NE, cpu_R[RRI8_T],

                        cpu_SR[SCOMPARE1], label);



                tcg_gen_qemu_st32(tmp, addr, di->cring);



                gen_set_label(label);

                tcg_temp_free(tpc);

                tcg_temp_free(addr);

                tcg_temp_free(tmp);

            }

            break;



        case 15: /*S32RIy*/

            HAS_OPTION(XTENSA_OPTION_MP_SYNCHRO);

            gen_load_store_no_hw_align(st32); /*TODO release?*/

            break;

#undef gen_load_store_no_hw_align



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    case 3: /*LSCIp*/

        switch (RRI8_R) {

        case 0: /*LSIf*/

        case 4: /*SSIf*/

        case 8: /*LSIUf*/

        case 12: /*SSIUf*/

            HAS_OPTION(XTENSA_OPTION_FP_COPROCESSOR);

            if (gen_window_check1(di, RRI8_S) &&

                gen_check_cpenable(di, 0)) {

                TCGv_i32 addr = tcg_temp_new_i32();

                tcg_gen_addi_i32(addr, cpu_R[RRI8_S], RRI8_IMM8 << 2);

                gen_load_store_alignment(di, 2, addr, false);

                if (RRI8_R & 0x4) {

                    tcg_gen_qemu_st32(cpu_FR[RRI8_T], addr, di->cring);

                } else {

                    tcg_gen_qemu_ld32u(cpu_FR[RRI8_T], addr, di->cring);

                }

                if (RRI8_R & 0x8) {

                    tcg_gen_mov_i32(cpu_R[RRI8_S], addr);

                }

                tcg_temp_free(addr);

            }

            break;



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    case 4: /*MAC16d*/

        HAS_OPTION(XTENSA_OPTION_MAC16);

        {

            enum {

                MAC16_UMUL = 0x0,

                MAC16_MUL  = 0x4,

                MAC16_MULA = 0x8,

                MAC16_MULS = 0xc,

                MAC16_NONE = 0xf,

            } op = OP1 & 0xc;

            bool is_m1_sr = (OP2 & 0x3) == 2;

            bool is_m2_sr = (OP2 & 0xc) == 0;

            uint32_t ld_offset = 0;



            if (OP2 > 9) {

                RESERVED();

            }



            switch (OP2 & 2) {

            case 0: /*MACI?/MACC?*/

                is_m1_sr = true;

                ld_offset = (OP2 & 1) ? -4 : 4;



                if (OP2 >= 8) { /*MACI/MACC*/

                    if (OP1 == 0) { /*LDINC/LDDEC*/

                        op = MAC16_NONE;

                    } else {

                        RESERVED();

                    }

                } else if (op != MAC16_MULA) { /*MULA.*.*.LDINC/LDDEC*/

                    RESERVED();

                }

                break;



            case 2: /*MACD?/MACA?*/

                if (op == MAC16_UMUL && OP2 != 7) { /*UMUL only in MACAA*/

                    RESERVED();

                }

                break;

            }



            if (op != MAC16_NONE) {

                if (!is_m1_sr && !gen_window_check1(di, RRR_S)) {

                    break;

                }

                if (!is_m2_sr && !gen_window_check1(di, RRR_T)) {

                    break;

                }

            }



            if (ld_offset && !gen_window_check1(di, RRR_S)) {

                break;

            }



            {

                TCGv_i32 vaddr = tcg_temp_new_i32();

                TCGv_i32 mem32 = tcg_temp_new_i32();



                if (ld_offset) {

                    tcg_gen_addi_i32(vaddr, cpu_R[RRR_S], ld_offset);

                    gen_load_store_alignment(di, 2, vaddr, false);

                    tcg_gen_qemu_ld32u(mem32, vaddr, di->cring);

                }

                if (op != MAC16_NONE) {

                    TCGv_i32 m1 = gen_mac16_m(

                            is_m1_sr ? cpu_SR[MR + RRR_X] : cpu_R[RRR_S],

                            OP1 & 1, op == MAC16_UMUL);

                    TCGv_i32 m2 = gen_mac16_m(

                            is_m2_sr ? cpu_SR[MR + 2 + RRR_Y] : cpu_R[RRR_T],

                            OP1 & 2, op == MAC16_UMUL);



                    if (op == MAC16_MUL || op == MAC16_UMUL) {

                        tcg_gen_mul_i32(cpu_SR[ACCLO], m1, m2);

                        if (op == MAC16_UMUL) {

                            tcg_gen_movi_i32(cpu_SR[ACCHI], 0);

                        } else {

                            tcg_gen_sari_i32(cpu_SR[ACCHI], cpu_SR[ACCLO], 31);

                        }

                    } else {

                        TCGv_i32 lo = tcg_temp_new_i32();

                        TCGv_i32 hi = tcg_temp_new_i32();



                        tcg_gen_mul_i32(lo, m1, m2);

                        tcg_gen_sari_i32(hi, lo, 31);

                        if (op == MAC16_MULA) {

                            tcg_gen_add2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             lo, hi);

                        } else {

                            tcg_gen_sub2_i32(cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             cpu_SR[ACCLO], cpu_SR[ACCHI],

                                             lo, hi);

                        }

                        tcg_gen_ext8s_i32(cpu_SR[ACCHI], cpu_SR[ACCHI]);



                        tcg_temp_free_i32(lo);

                        tcg_temp_free_i32(hi);

                    }

                    tcg_temp_free(m1);

                    tcg_temp_free(m2);

                }

                if (ld_offset) {

                    tcg_gen_mov_i32(cpu_R[RRR_S], vaddr);

                    tcg_gen_mov_i32(cpu_SR[MR + RRR_W], mem32);

                }

                tcg_temp_free(vaddr);

                tcg_temp_free(mem32);

            }

        }

        break;



    case 5: /*CALLN*/

        switch (CALL_N) {

        case 0: /*CALL0*/

            tcg_gen_movi_i32(cpu_R[0], di->next_pc);

            gen_jumpi(di, (di->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);

            break;



        case 1: /*CALL4w*/

        case 2: /*CALL8w*/

        case 3: /*CALL12w*/

            HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

            if (gen_window_check1(di, CALL_N << 2)) {

                gen_callwi(di, CALL_N,

                           (di->pc & ~3) + (CALL_OFFSET_SE << 2) + 4, 0);

            }

            break;

        }

        break;



    case 6: /*SI*/

        switch (CALL_N) {

        case 0: /*J*/

            gen_jumpi(di, di->pc + 4 + CALL_OFFSET_SE, 0);

            break;



        case 1: /*BZ*/

            if (gen_window_check1(di, BRI12_S)) {

                static const TCGCond cond[] = {

                    TCG_COND_EQ, /*BEQZ*/

                    TCG_COND_NE, /*BNEZ*/

                    TCG_COND_LT, /*BLTZ*/

                    TCG_COND_GE, /*BGEZ*/

                };



                gen_brcondi(di, cond[BRI12_M & 3], cpu_R[BRI12_S], 0,

                        4 + BRI12_IMM12_SE);

            }

            break;



        case 2: /*BI0*/

            if (gen_window_check1(di, BRI8_S)) {

                static const TCGCond cond[] = {

                    TCG_COND_EQ, /*BEQI*/

                    TCG_COND_NE, /*BNEI*/

                    TCG_COND_LT, /*BLTI*/

                    TCG_COND_GE, /*BGEI*/

                };



                gen_brcondi(di, cond[BRI8_M & 3],

                        cpu_R[BRI8_S], B4CONST[BRI8_R], 4 + BRI8_IMM8_SE);

            }

            break;



        case 3: /*BI1*/

            switch (BRI8_M) {

            case 0: /*ENTRYw*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                {

                    TCGv_i32 pc = tcg_const_i32(di->pc);

                    TCGv_i32 s = tcg_const_i32(BRI12_S);

                    TCGv_i32 imm = tcg_const_i32(BRI12_IMM12);

                    gen_advance_ccount(di);

                    gen_helper_entry(cpu_env, pc, s, imm);

                    tcg_temp_free(imm);

                    tcg_temp_free(s);

                    tcg_temp_free(pc);

                    /* This can change tb->flags, so exit tb */

                    gen_jumpi_check_loop_end(di, -1);

                }

                break;



            case 1: /*B1*/

                switch (BRI8_R) {

                case 0: /*BFp*/

                case 1: /*BTp*/

                    HAS_OPTION(XTENSA_OPTION_BOOLEAN);

                    {

                        TCGv_i32 tmp = tcg_temp_new_i32();

                        tcg_gen_andi_i32(tmp, cpu_SR[BR], 1 << RRI8_S);

                        gen_brcondi(di,

                                BRI8_R == 1 ? TCG_COND_NE : TCG_COND_EQ,

                                tmp, 0, 4 + RRI8_IMM8_SE);

                        tcg_temp_free(tmp);

                    }

                    break;



                case 8: /*LOOP*/

                case 9: /*LOOPNEZ*/

                case 10: /*LOOPGTZ*/

                    HAS_OPTION(XTENSA_OPTION_LOOP);

                    if (gen_window_check1(di, RRI8_S)) {

                        uint32_t lend = di->pc + RRI8_IMM8 + 4;

                        TCGv_i32 tmp = tcg_const_i32(lend);



                        tcg_gen_subi_i32(cpu_SR[LCOUNT], cpu_R[RRI8_S], 1);

                        tcg_gen_movi_i32(cpu_SR[LBEG], di->next_pc);

                        gen_helper_wsr_lend(cpu_env, tmp);

                        tcg_temp_free(tmp);



                        if (BRI8_R > 8) {

                            int label = gen_new_label();

                            tcg_gen_brcondi_i32(

                                    BRI8_R == 9 ? TCG_COND_NE : TCG_COND_GT,

                                    cpu_R[RRI8_S], 0, label);

                            gen_jumpi(di, lend, 1);

                            gen_set_label(label);

                        }



                        gen_jumpi(di, di->next_pc, 0);

                    }

                    break;



                default: /*reserved*/

                    RESERVED();

                    break;



                }

                break;



            case 2: /*BLTUI*/

            case 3: /*BGEUI*/

                if (gen_window_check1(di, BRI8_S)) {

                    gen_brcondi(di, BRI8_M == 2 ? TCG_COND_LTU : TCG_COND_GEU,

                                cpu_R[BRI8_S], B4CONSTU[BRI8_R],

                                4 + BRI8_IMM8_SE);

                }

                break;

            }

            break;



        }

        break;



    case 7: /*B*/

        {

            TCGCond eq_ne = (RRI8_R & 8) ? TCG_COND_NE : TCG_COND_EQ;



            switch (RRI8_R & 7) {

            case 0: /*BNONE*/ /*BANY*/

                if (gen_window_check2(di, RRI8_S, RRI8_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);

                    gen_brcondi(di, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                }

                break;



            case 1: /*BEQ*/ /*BNE*/

            case 2: /*BLT*/ /*BGE*/

            case 3: /*BLTU*/ /*BGEU*/

                if (gen_window_check2(di, RRI8_S, RRI8_T)) {

                    static const TCGCond cond[] = {

                        [1] = TCG_COND_EQ,

                        [2] = TCG_COND_LT,

                        [3] = TCG_COND_LTU,

                        [9] = TCG_COND_NE,

                        [10] = TCG_COND_GE,

                        [11] = TCG_COND_GEU,

                    };

                    gen_brcond(di, cond[RRI8_R], cpu_R[RRI8_S], cpu_R[RRI8_T],

                            4 + RRI8_IMM8_SE);

                }

                break;



            case 4: /*BALL*/ /*BNALL*/

                if (gen_window_check2(di, RRI8_S, RRI8_T)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], cpu_R[RRI8_T]);

                    gen_brcond(di, eq_ne, tmp, cpu_R[RRI8_T],

                            4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                }

                break;



            case 5: /*BBC*/ /*BBS*/

                if (gen_window_check2(di, RRI8_S, RRI8_T)) {

#ifdef TARGET_WORDS_BIGENDIAN

                    TCGv_i32 bit = tcg_const_i32(0x80000000);

#else

                    TCGv_i32 bit = tcg_const_i32(0x00000001);

#endif

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_T], 0x1f);

#ifdef TARGET_WORDS_BIGENDIAN

                    tcg_gen_shr_i32(bit, bit, tmp);

#else

                    tcg_gen_shl_i32(bit, bit, tmp);

#endif

                    tcg_gen_and_i32(tmp, cpu_R[RRI8_S], bit);

                    gen_brcondi(di, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                    tcg_temp_free(bit);

                }

                break;



            case 6: /*BBCI*/ /*BBSI*/

            case 7:

                if (gen_window_check1(di, RRI8_S)) {

                    TCGv_i32 tmp = tcg_temp_new_i32();

                    tcg_gen_andi_i32(tmp, cpu_R[RRI8_S],

#ifdef TARGET_WORDS_BIGENDIAN

                            0x80000000 >> (((RRI8_R & 1) << 4) | RRI8_T));

#else

                            0x00000001 << (((RRI8_R & 1) << 4) | RRI8_T));

#endif

                    gen_brcondi(di, eq_ne, tmp, 0, 4 + RRI8_IMM8_SE);

                    tcg_temp_free(tmp);

                }

                break;



            }

        }

        break;



#define gen_narrow_load_store(type) do { \

            if (gen_window_check2(di, RRRN_S, RRRN_T)) { \

                TCGv_i32 addr = tcg_temp_new_i32(); \

                tcg_gen_addi_i32(addr, cpu_R[RRRN_S], RRRN_R << 2); \

                gen_load_store_alignment(di, 2, addr, false); \

                tcg_gen_qemu_##type(cpu_R[RRRN_T], addr, dc->cring); \

                tcg_temp_free(addr); \

            } \

        } while (0)



    case 8: /*L32I.Nn*/

        gen_narrow_load_store(ld32u);

        break;



    case 9: /*S32I.Nn*/

        gen_narrow_load_store(st32);

        break;

#undef gen_narrow_load_store



    case 10: /*ADD.Nn*/

        if (gen_window_check3(di, RRRN_R, RRRN_S, RRRN_T)) {

            tcg_gen_add_i32(cpu_R[RRRN_R], cpu_R[RRRN_S], cpu_R[RRRN_T]);

        }

        break;



    case 11: /*ADDI.Nn*/

        if (gen_window_check2(di, RRRN_R, RRRN_S)) {

            tcg_gen_addi_i32(cpu_R[RRRN_R], cpu_R[RRRN_S],

                             RRRN_T ? RRRN_T : -1);

        }

        break;



    case 12: /*ST2n*/

        if (!gen_window_check1(di, RRRN_S)) {

            break;

        }

        if (RRRN_T < 8) { /*MOVI.Nn*/

            tcg_gen_movi_i32(cpu_R[RRRN_S],

                    RRRN_R | (RRRN_T << 4) |

                    ((RRRN_T & 6) == 6 ? 0xffffff80 : 0));

        } else { /*BEQZ.Nn*/ /*BNEZ.Nn*/

            TCGCond eq_ne = (RRRN_T & 4) ? TCG_COND_NE : TCG_COND_EQ;



            gen_brcondi(di, eq_ne, cpu_R[RRRN_S], 0,

                    4 + (RRRN_R | ((RRRN_T & 3) << 4)));

        }

        break;



    case 13: /*ST3n*/

        switch (RRRN_R) {

        case 0: /*MOV.Nn*/

            if (gen_window_check2(di, RRRN_S, RRRN_T)) {

                tcg_gen_mov_i32(cpu_R[RRRN_T], cpu_R[RRRN_S]);

            }

            break;



        case 15: /*S3*/

            switch (RRRN_T) {

            case 0: /*RET.Nn*/

                gen_jump(di, cpu_R[0]);

                break;



            case 1: /*RETW.Nn*/

                HAS_OPTION(XTENSA_OPTION_WINDOWED_REGISTER);

                {

                    TCGv_i32 tmp = tcg_const_i32(di->pc);

                    gen_advance_ccount(di);

                    gen_helper_retw(tmp, cpu_env, tmp);

                    gen_jump(di, tmp);

                    tcg_temp_free(tmp);

                }

                break;



            case 2: /*BREAK.Nn*/

                HAS_OPTION(XTENSA_OPTION_DEBUG);

                if (di->debug) {

                    gen_debug_exception(di, DEBUGCAUSE_BN);

                }

                break;



            case 3: /*NOP.Nn*/

                break;



            case 6: /*ILL.Nn*/

                gen_exception_cause(di, ILLEGAL_INSTRUCTION_CAUSE);

                break;



            default: /*reserved*/

                RESERVED();

                break;

            }

            break;



        default: /*reserved*/

            RESERVED();

            break;

        }

        break;



    default: /*reserved*/

        RESERVED();

        break;

    }



    if (di->is_jmp == DISAS_NEXT) {

        gen_check_loop_end(di, 0);

    }

    di->pc = di->next_pc;



    return;



invalid_opcode:

    qemu_log(""INVALID(pc = %08x)
"", di->pc);

    gen_exception_cause(di, ILLEGAL_INSTRUCTION_CAUSE);

#undef HAS_OPTION

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,dc",,,,0,"env:rc,dc:di,",0,GA,134,0.3713355620702108,GA,
33,"int kvm_arch_on_sigbus(int code, void *addr)

{

#ifdef KVM_CAP_MCE

    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {

        void *vaddr;

        ram_addr_t ram_addr;

        target_phys_addr_t paddr;



        /* Hope we are lucky for AO MCE */

        vaddr = addr;

        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||

            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,

                                               &paddr)) {

            fprintf(stderr, ""Hardware memory error for memory used by ""

                    ""QEMU itself instead of guest system!: %p\n"", addr);

            return 0;

        }

        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);

    } else

#endif /* KVM_CAP_MCE */

    {

        if (code == BUS_MCEERR_AO) {

            return 0;

        } else if (code == BUS_MCEERR_AR) {

            hardware_memory_error();

        } else {

            return 1;

        }

    }

    return 0;

}
",152,,LABEL_0,LABEL_0,LABEL_0,-1,"code,addr,vaddr,ram_addr,paddr",,,,0,,0,GA,819,0.3064594546953837,failed,
34,"static void decode_interframe_v4(AVCodecContext *avctx, uint8_t *src, uint32_t size)

{

    Hnm4VideoContext *hnm = avctx->priv_data;

    GetByteContext gb;

    uint32_t writeoffset = 0, count, left, offset;

    uint8_t tag, previous, backline, backward, swap;



    bytestream2_init(&gb, src, size);



    while (bytestream2_tell(&gb) < size) {

        count = bytestream2_peek_byte(&gb) & 0x1F;

        if (count == 0) {

            tag = bytestream2_get_byte(&gb) & 0xE0;

            tag = tag >> 5;

            if (tag == 0) {

                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);

                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);

            } else if (tag == 1) {

                writeoffset += bytestream2_get_byte(&gb) * 2;

            } else if (tag == 2) {

                count = bytestream2_get_le16(&gb);

                count *= 2;

                writeoffset += count;

            } else if (tag == 3) {

                count = bytestream2_get_byte(&gb) * 2;

                while (count > 0) {

                    hnm->current[writeoffset++] = bytestream2_peek_byte(&gb);

                    count--;

                }

                bytestream2_skip(&gb, 1);

            } else {

                break;

            }

        } else {

            previous = bytestream2_peek_byte(&gb) & 0x20;

            backline = bytestream2_peek_byte(&gb) & 0x40;

            backward = bytestream2_peek_byte(&gb) & 0x80;

            bytestream2_skip(&gb, 1);

            swap   = bytestream2_peek_byte(&gb) & 0x01;

            offset = bytestream2_get_le16(&gb);

            offset = (offset >> 1) & 0x7FFF;

            offset = writeoffset + (offset * 2) - 0x8000;



            left = count;



            if (!backward && offset + count >= hnm->width * hnm->height) {

                av_log(avctx, AV_LOG_ERROR, ""Attempting to read out of bounds"");

                break;

            } else if (backward && offset >= hnm->width * hnm->height) {

                av_log(avctx, AV_LOG_ERROR, ""Attempting to read out of bounds"");

                break;

            } else if (writeoffset + count >= hnm->width * hnm->height) {

                av_log(avctx, AV_LOG_ERROR,

                       ""Attempting to write out of bounds"");

                break;

            }



            if (previous) {

                while (left > 0) {

                    if (backline) {

                        hnm->current[writeoffset++] = hnm->previous[offset - (2 * hnm->width) + 1];

                        hnm->current[writeoffset++] = hnm->previous[offset++];

                        offset++;

                    } else {

                        hnm->current[writeoffset++] = hnm->previous[offset++];

                        hnm->current[writeoffset++] = hnm->previous[offset++];

                    }

                    if (backward)

                        offset -= 4;

                    left--;

                }

            } else {

                while (left > 0) {

                    if (backline) {

                        hnm->current[writeoffset++] = hnm->current[offset - (2 * hnm->width) + 1];

                        hnm->current[writeoffset++] = hnm->current[offset++];

                        offset++;

                    } else {

                        hnm->current[writeoffset++] = hnm->current[offset++];

                        hnm->current[writeoffset++] = hnm->current[offset++];

                    }

                    if (backward)

                        offset -= 4;

                    left--;

                }

            }



            if (swap) {

                left         = count;

                writeoffset -= count * 2;

                while (left > 0) {

                    swap = hnm->current[writeoffset];

                    hnm->current[writeoffset] = hnm->current[writeoffset + 1];

                    hnm->current[writeoffset + 1] = swap;

                    left--;

                    writeoffset += 2;

                }

            }

        }

    }

}
",756,,LABEL_0,LABEL_1,,-4,"avctx,src,size,hnm,gb,count,offset,tag,previous,backline,backward,swap",,,,0,,0,Greedy,1,0.0008807142575581868,,
35,"void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)

{

    int i = 0;

    int x = 0;

    uint32_t l_64 = (l + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""\n"",

               __func__, l, dest, src);



#ifndef CONFIG_USER_ONLY

    if ((l > 32) &&

        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&

        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {

        if (dest == (src + 1)) {

            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));

            return;

        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(env, l + 1, dest, src);

            return;

        }

    }

#else

    if (dest == (src + 1)) {

        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);

        return;

    } else {

        memmove(g2h(dest), g2h(src), l + 1);

        return;

    }

#endif



    /* handle the parts that fit into 8-byte loads/stores */

    if (dest != (src + 1)) {

        for (i = 0; i < l_64; i++) {

            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));

            x += 8;

        }

    }



    /* slow version crossing pages with byte accesses */

    for (i = x; i <= l; i++) {

        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));

    }

}
",336,,LABEL_1,LABEL_0,,-4,"env,l,dest,src,i",,,,0,,0,Greedy,1,0.000594945748647054,,
36,"static int inc_refcounts(BlockDriverState *bs,

                         BdrvCheckResult *res,

                         uint16_t *refcount_table,

                         int64_t refcount_table_size,

                         int64_t offset, int64_t size)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t start, last, cluster_offset, k;



    if (size <= 0) {

        return 0;

    }



    start = start_of_cluster(s, offset);

    last = start_of_cluster(s, offset + size - 1);

    for(cluster_offset = start; cluster_offset <= last;

        cluster_offset += s->cluster_size) {

        k = cluster_offset >> s->cluster_bits;

        if (k >= refcount_table_size) {

            fprintf(stderr, ""Warning: cluster offset=0x%"" PRIx64 "" is after ""

                ""the end of the image file, can't properly check refcounts.\n"",

                cluster_offset);

            res->check_errors++;

        } else {

            if (++refcount_table[k] == 0) {

                fprintf(stderr, ""ERROR: overflow cluster offset=0x%"" PRIx64

                    ""\n"", cluster_offset);

                res->corruptions++;

            }

        }

    }



    return 0;

}
",184,"static int inc_refcounts(BlockDriverState *bs,

                         BdrvCheckResult *res,

                         uint16_t *refcount_table,

                         int64_t refcount_table_size,

                         int64_t slice, int64_t size)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t ind, last, cluster_offset, k;



    if (size <= 0) {

        return 0;

    }



   indt = start_of_clusterss, slice);

   lastt = start_of_clusterss, slice + size - 1);

    focluster_offsetet = ind; cluster_offset <= last;

        cluster_offset += s->cluster_size) {

        k = cluster_offset >> s->cluster_bits;

        if (k >= refcount_table_size) {

            fprintf(stderr, ""Warning: cluster offset=0x%"" PRIx64 "" is after ""

                ""the end of the image file, can't properly check refcounts.
"",

                cluster_offset);

            res->check_errors++;

        } else {

            if (++refcount_table[k] == 0) {

                fprintf(stderr, ""ERROR: overflow cluster offset=0x%"" PRIx64

                    ""
"", cluster_offset);

                res->corruptions++;

            }

        }

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bs,res,refcount_table,refcount_table_size,offset,size,s,start,last,cluster_offset,k,check_errors,corruptions",,,,33,"bs:bs,res:res,refcount_table:refcount_table,refcount_table_size:refcount_table_size,offset:slice,size:size,s:s,start:ind,last:last,cluster_offset:cluster_offset,k:k,check_errors:check_errors,corruptions:corruptions,",11,GA,556,0.2088085651397705,GA,
37,"static void json_message_process_token(JSONLexer *lexer, GString *input,

                                       JSONTokenType type, int x, int y)

{

    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);

    QDict *dict;



    switch (type) {

    case JSON_LCURLY:

        parser->brace_count++;

        break;

    case JSON_RCURLY:

        parser->brace_count--;

        break;

    case JSON_LSQUARE:

        parser->bracket_count++;

        break;

    case JSON_RSQUARE:

        parser->bracket_count--;

        break;

    default:

        break;

    }



    dict = qdict_new();

    qdict_put(dict, ""type"", qint_from_int(type));

    qdict_put(dict, ""token"", qstring_from_str(input->str));

    qdict_put(dict, ""x"", qint_from_int(x));

    qdict_put(dict, ""y"", qint_from_int(y));



    parser->token_size += input->len;



    g_queue_push_tail(parser->tokens, dict);



    if (type == JSON_ERROR) {

        goto out_emit_bad;

    } else if (parser->brace_count < 0 ||

        parser->bracket_count < 0 ||

        (parser->brace_count == 0 &&

         parser->bracket_count == 0)) {

        goto out_emit;

    } else if (parser->token_size > MAX_TOKEN_SIZE ||

               parser->bracket_count + parser->brace_count > MAX_NESTING) {

        /* Security consideration, we limit total memory allocated per object

         * and the maximum recursion depth that a message can force.

         */

        goto out_emit_bad;

    }



    return;



out_emit_bad:

    /*

     * Clear out token list and tell the parser to emit an error

     * indication by passing it a NULL list

     */

    json_message_free_tokens(parser);

out_emit:

    /* send current list of tokens to parser and reset tokenizer */

    parser->brace_count = 0;

    parser->bracket_count = 0;

    /* parser->emit takes ownership of parser->tokens.  */

    parser->emit(parser, parser->tokens);

    parser->tokens = g_queue_new();

    parser->token_size = 0;

}
",390,"static void json_message_process_token(JSONLexer *lexer, GString *input,

                                       JSONTokenType sort, int x, int y)

{

    JSONMessageParser *gg = container_of(lexer, JSONMessageParser, lexer);

    QDict *arr;



    switch (sort) {

    case JSON_LCURLY:

        gg->brace_left++;

        break;

    case JSON_RCURLY:

        gg->brace_left--;

        break;

    case JSON_LSQUARE:

        gg->bracketersize++;

        break;

    case JSON_RSQUARE:

        gg->bracketersize--;

        break;

    default:

        break;

    }



    arr = qdict_new();

    qdict_put(arr, ""type"", qint_from_int(sort));

    qdict_put(arr, ""token"", qstring_from_str(input->str));

    qdict_put(arr, ""x"", qint_from_int(x));

    qdict_put(arr, ""y"", qint_from_int(y));



    gg->token_size += input->len;



    g_queue_push_tail(gg->tokens, arr);



    if (sort == JSON_ERROR) {

        goto out_emit_bad;

    } else if (gg->brace_left < 0 ||

        gg->bracketersize < 0 ||

        (gg->brace_left == 0 &&

         gg->bracketersize == 0)) {

        goto out_emit;

    } else if (gg->token_size > MAX_TOKEN_SIZE ||

              bracketersizecount + gg->brace_left > MAX_NESTING) {

        /* Security consideration, we limit total memory allocated per object

         * and the maximum recursion depth that a message can force.

         */

        goto out_emit_bad;

    }



    return;



out_emit_bad:

    /*

     * Clear out token list and tell the gg to emit an error

     * indication by passing it a NULL list

     */

    json_message_free_tokens(gg);

out_emit:

    /* send current list of tokens to gg and reset tokenizer */

    gg->brace_left = 0;

    gg->bracketersize = 0;

    /* gg->emit takes ownership of gg->tokens.  */

    gg->emit(gg, gg->tokens);

    gg->tokens = g_queue_new();

    gg->token_size = 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"lexer,input,type,x,y,parser,dict,brace_count,bracket_count",,,,10,"lexer:lexer,input:input,type:sort,x:x,y:y,parser:gg,dict:arr,brace_count:brace_left,bracket_count:bracketersize,",4,GA,537,0.21517768303553264,GA,
38,"static int libschroedinger_encode_frame(AVCodecContext *avctx, AVPacket *pkt,

                                        const AVFrame *frame, int *got_packet)

{

    int enc_size = 0;

    SchroEncoderParams *p_schro_params = avctx->priv_data;

    SchroEncoder *encoder = p_schro_params->encoder;

    struct FFSchroEncodedFrame *p_frame_output = NULL;

    int go = 1;

    SchroBuffer *enc_buf;

    int presentation_frame;

    int parse_code;

    int last_frame_in_sequence = 0;

    int pkt_size, ret;



    if (!frame) {

        /* Push end of sequence if not already signalled. */

        if (!p_schro_params->eos_signalled) {

            schro_encoder_end_of_stream(encoder);

            p_schro_params->eos_signalled = 1;

        }

    } else {

        /* Allocate frame data to schro input buffer. */

        SchroFrame *in_frame = libschroedinger_frame_from_data(avctx, frame);

        if (!in_frame)

            return AVERROR(ENOMEM);

        /* Load next frame. */

        schro_encoder_push_frame(encoder, in_frame);

    }



    if (p_schro_params->eos_pulled)

        go = 0;



    /* Now check to see if we have any output from the encoder. */

    while (go) {

        int err;

        SchroStateEnum state;

        state = schro_encoder_wait(encoder);

        switch (state) {

        case SCHRO_STATE_HAVE_BUFFER:

        case SCHRO_STATE_END_OF_STREAM:

            enc_buf = schro_encoder_pull(encoder, &presentation_frame);

            if (enc_buf->length <= 0)

                return AVERROR_BUG;

            parse_code = enc_buf->data[4];



            /* All non-frame data is prepended to actual frame data to

             * be able to set the pts correctly. So we don't write data

             * to the frame output queue until we actually have a frame

             */

            if ((err = av_reallocp(&p_schro_params->enc_buf,

                                   p_schro_params->enc_buf_size +

                                   enc_buf->length)) < 0) {

                p_schro_params->enc_buf_size = 0;

                return err;

            }



            memcpy(p_schro_params->enc_buf + p_schro_params->enc_buf_size,

                   enc_buf->data, enc_buf->length);

            p_schro_params->enc_buf_size += enc_buf->length;





            if (state == SCHRO_STATE_END_OF_STREAM) {

                p_schro_params->eos_pulled = 1;

                go = 0;

            }



            if (!SCHRO_PARSE_CODE_IS_PICTURE(parse_code)) {

                schro_buffer_unref(enc_buf);

                break;

            }



            /* Create output frame. */

            p_frame_output = av_mallocz(sizeof(FFSchroEncodedFrame));

            if (!p_frame_output)

                return AVERROR(ENOMEM);

            /* Set output data. */

            p_frame_output->size     = p_schro_params->enc_buf_size;

            p_frame_output->p_encbuf = p_schro_params->enc_buf;

            if (SCHRO_PARSE_CODE_IS_INTRA(parse_code) &&

                SCHRO_PARSE_CODE_IS_REFERENCE(parse_code))

                p_frame_output->key_frame = 1;



            /* Parse the coded frame number from the bitstream. Bytes 14

             * through 17 represesent the frame number. */

            p_frame_output->frame_num = AV_RB32(enc_buf->data + 13);



            ff_schro_queue_push_back(&p_schro_params->enc_frame_queue,

                                     p_frame_output);

            p_schro_params->enc_buf_size = 0;

            p_schro_params->enc_buf      = NULL;



            schro_buffer_unref(enc_buf);



            break;



        case SCHRO_STATE_NEED_FRAME:

            go = 0;

            break;



        case SCHRO_STATE_AGAIN:

            break;



        default:

            av_log(avctx, AV_LOG_ERROR, ""Unknown Schro Encoder state\n"");

            return -1;

        }

    }



    /* Copy 'next' frame in queue. */



    if (p_schro_params->enc_frame_queue.size == 1 &&

        p_schro_params->eos_pulled)

        last_frame_in_sequence = 1;



    p_frame_output = ff_schro_queue_pop(&p_schro_params->enc_frame_queue);



    if (!p_frame_output)

        return 0;



    pkt_size = p_frame_output->size;

    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0)

        pkt_size += p_schro_params->enc_buf_size;

    if ((ret = ff_alloc_packet(pkt, pkt_size)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Error getting output packet of size %d.\n"", pkt_size);

        goto error;

    }



    memcpy(pkt->data, p_frame_output->p_encbuf, p_frame_output->size);

    avctx->coded_frame->key_frame = p_frame_output->key_frame;

    /* Use the frame number of the encoded frame as the pts. It is OK to

     * do so since Dirac is a constant frame rate codec. It expects input

     * to be of constant frame rate. */

    pkt->pts =

    avctx->coded_frame->pts = p_frame_output->frame_num;

    pkt->dts = p_schro_params->dts++;

    enc_size = p_frame_output->size;



    /* Append the end of sequence information to the last frame in the

     * sequence. */

    if (last_frame_in_sequence && p_schro_params->enc_buf_size > 0) {

        memcpy(pkt->data + enc_size, p_schro_params->enc_buf,

               p_schro_params->enc_buf_size);

        enc_size += p_schro_params->enc_buf_size;

        av_freep(&p_schro_params->enc_buf);

        p_schro_params->enc_buf_size = 0;

    }



    if (p_frame_output->key_frame)

        pkt->flags |= AV_PKT_FLAG_KEY;

    *got_packet = 1;



error:

    /* free frame */

    libschroedinger_free_frame(p_frame_output);

    return ret;

}
",926,,LABEL_0,LABEL_1,,-4,"avctx,pkt,frame,got_packet,p_schro_params,encoder,p_frame_output,enc_buf,presentation_frame,parse_code,pkt_size,ret,in_frame,err,state",,,,0,,0,Greedy,1,0.0010522206624348958,,
39,"static int vnc_validate_certificate(struct VncState *vs)

{

    int ret;

    unsigned int status;

    const gnutls_datum_t *certs;

    unsigned int nCerts, i;

    time_t now;



    VNC_DEBUG(""Validating client certificate\n"");

    if ((ret = gnutls_certificate_verify_peers2 (vs->tls_session, &status)) < 0) {

	VNC_DEBUG(""Verify failed %s\n"", gnutls_strerror(ret));

	return -1;

    }



    if ((now = time(NULL)) == ((time_t)-1)) {

	return -1;

    }



    if (status != 0) {

	if (status & GNUTLS_CERT_INVALID)

	    VNC_DEBUG(""The certificate is not trusted.\n"");



	if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)

	    VNC_DEBUG(""The certificate hasn't got a known issuer.\n"");



	if (status & GNUTLS_CERT_REVOKED)

	    VNC_DEBUG(""The certificate has been revoked.\n"");



	if (status & GNUTLS_CERT_INSECURE_ALGORITHM)

	    VNC_DEBUG(""The certificate uses an insecure algorithm\n"");



	return -1;

    } else {

	VNC_DEBUG(""Certificate is valid!\n"");

    }



    /* Only support x509 for now */

    if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509)

	return -1;



    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))

	return -1;



    for (i = 0 ; i < nCerts ; i++) {

	gnutls_x509_crt_t cert;

	VNC_DEBUG (""Checking certificate chain %d\n"", i);

	if (gnutls_x509_crt_init (&cert) < 0)

	    return -1;



	if (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_expiration_time (cert) < now) {

	    VNC_DEBUG(""The certificate has expired\n"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_activation_time (cert) > now) {

	    VNC_DEBUG(""The certificate is not yet activated\n"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	if (gnutls_x509_crt_get_activation_time (cert) > now) {

	    VNC_DEBUG(""The certificate is not yet activated\n"");

	    gnutls_x509_crt_deinit (cert);

	    return -1;

	}



	gnutls_x509_crt_deinit (cert);

    }



    return 0;

}
",432,"static int vnc_validate_certificate(struct VncState *vs)

{

    int ret;

    unsigned int sys;

    const gnutls_datum_t *certs;

    unsigned int nCerts, i;

    time_t now;



    VNC_DEBUG(""Validating client certificate
"");

    if ((ret = gnutls_certificate_verify_peers2 (vs->tls_session, &sys)) < 0) {

	VNC_DEBUG(""Verify failed %s
"", gnutls_strerror(ret));

	return -1;

    }



    if ((now = time(NULL)) == ((time_t)-1)) {

	return -1;

    }



    if (sys != 0) {

	if (sys & GNUTLS_CERT_INVALID)

	    VNC_DEBUG(""The certificate is not trusted.
"");



	if (sys & GNUTLS_CERT_SIGNER_NOT_FOUND)

	    VNC_DEBUG(""The certificate hasn't got a known issuer.
"");



	if (sys & GNUTLS_CERT_REVOKED)

	    VNC_DEBUG(""The certificate has been revoked.
"");



	if (sys & GNUTLS_CERT_INSECURE_ALGORITHM)

	    VNC_DEBUG(""The certificate uses an insecure algorithm
"");



	return -1;

    } else {

	VNC_DEBUG(""Certificate is valid!
"");

    }



    /* Only support x509 for now */

    if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509)

	return -1;



    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))

	return -1;



    for (i = 0 ; i < nCerts ; i++) {

	gnutls_x509_crt_t user;

	VNC_DEBUG (""Checking certificate chain %d
"", i);

	if (gnutls_x509_crt_init (&user) < 0)

	    return -1;



	if (gnutls_x509_crt_import(user, &certs[i], GNUTLS_X509_FMT_DER) < 0) {

	    gnutls_x509_crt_deinit (user);

	    return -1;

	}



	if (gnutls_x509_crt_get_expiration_time (user) < now) {

	    VNC_DEBUG(""The certificate has expired
"");

	    gnutls_x509_crt_deinit (user);

	    return -1;

	}



	if (gnutls_x509_crt_get_activation_time (user) > now) {

	    VNC_DEBUG(""The certificate is not yet activated
"");

	    gnutls_x509_crt_deinit (user);

	    return -1;

	}



	if (gnutls_x509_crt_get_activation_time (user) > now) {

	    VNC_DEBUG(""The certificate is not yet activated
"");

	    gnutls_x509_crt_deinit (user);

	    return -1;

	}



	gnutls_x509_crt_deinit (user);

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"vs,ret,status,certs,nCerts,i,now,cert",,,,25,"vs:vs,ret:ret,status:sys,certs:certs,nCerts:nCerts,i:i,now:now,cert:user,",6,GA,461,0.19158936738967897,GA,
40,"void qmp_migrate_set_speed(int64_t value, Error **errp)

{

    MigrationState *s;



    if (value < 0) {

        value = 0;

    }



    s = migrate_get_current();

    s->bandwidth_limit = value;

    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);

}
",54,"void qmp_migrate_set_speed(int64_t score, Error **errr)

{

    MigrationState *cs;



    if (score < 0) {

        score = 0;

    }



    cs = migrate_get_current();

    cs->bandwidth_limit = score;

    qemu_file_set_rate_limit(cs->file, cs->bandwidth_limit);

}
",LABEL_0,LABEL_0,LABEL_1,1,"value,errp,s",,,,0,"value:score,errp:errr,s:cs,",0,GA,147,0.05194909969965617,GA,
41,"static int mpc8_decode_frame(AVCodecContext * avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    MPCContext *c = avctx->priv_data;

    GetBitContext gb2, *gb = &gb2;

    int i, j, k, ch, cnt, res, t;

    Band *bands = c->bands;

    int off;

    int maxband, keyframe;

    int last[2];



    keyframe = c->cur_frame == 0;



    if(keyframe){

        memset(c->Q, 0, sizeof(c->Q));

        c->last_bits_used = 0;

    }

    init_get_bits(gb, buf, buf_size * 8);

    skip_bits(gb, c->last_bits_used & 7);



    if(keyframe)

        maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1);

    else{

        maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2);

        if(maxband > 32) maxband -= 33;

    }

    c->last_max_band = maxband;



    /* read subband indexes */

    if(maxband){

        last[0] = last[1] = 0;

        for(i = maxband - 1; i >= 0; i--){

            for(ch = 0; ch < 2; ch++){

                last[ch] = get_vlc2(gb, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch];

                if(last[ch] > 15) last[ch] -= 17;

                bands[i].res[ch] = last[ch];

            }

        }

        if(c->MSS){

            int mask;



            cnt = 0;

            for(i = 0; i < maxband; i++)

                if(bands[i].res[0] || bands[i].res[1])

                    cnt++;

            t = mpc8_get_mod_golomb(gb, cnt);

            mask = mpc8_get_mask(gb, cnt, t);

            for(i = maxband - 1; i >= 0; i--)

                if(bands[i].res[0] || bands[i].res[1]){

                    bands[i].msf = mask & 1;

                    mask >>= 1;

                }

        }

    }

    for(i = maxband; i < c->maxbands; i++)

        bands[i].res[0] = bands[i].res[1] = 0;



    if(keyframe){

        for(i = 0; i < 32; i++)

            c->oldDSCF[0][i] = c->oldDSCF[1][i] = 1;

    }



    for(i = 0; i < maxband; i++){

        if(bands[i].res[0] || bands[i].res[1]){

            cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1;

            if(cnt >= 0){

                t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1);

                if(bands[i].res[0]) bands[i].scfi[0] = t >> (2 * cnt);

                if(bands[i].res[1]) bands[i].scfi[1] = t & 3;

            }

        }

    }



    for(i = 0; i < maxband; i++){

        for(ch = 0; ch < 2; ch++){

            if(!bands[i].res[ch]) continue;



            if(c->oldDSCF[ch][i]){

                bands[i].scf_idx[ch][0] = get_bits(gb, 7) - 6;

                c->oldDSCF[ch][i] = 0;

            }else{

                t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2);

                if(t == 64)

                    t += get_bits(gb, 6);

                bands[i].scf_idx[ch][0] = ((bands[i].scf_idx[ch][2] + t - 25) & 0x7F) - 6;

            }

            for(j = 0; j < 2; j++){

                if((bands[i].scfi[ch] << j) & 2)

                    bands[i].scf_idx[ch][j + 1] = bands[i].scf_idx[ch][j];

                else{

                    t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2);

                    if(t == 31)

                        t = 64 + get_bits(gb, 6);

                    bands[i].scf_idx[ch][j + 1] = ((bands[i].scf_idx[ch][j] + t - 25) & 0x7F) - 6;

                }

            }

        }

    }



    for(i = 0, off = 0; i < maxband; i++, off += SAMPLES_PER_BAND){

        for(ch = 0; ch < 2; ch++){

            res = bands[i].res[ch];

            switch(res){

            case -1:

                for(j = 0; j < SAMPLES_PER_BAND; j++)

                    c->Q[ch][off + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510;

                break;

            case 0:

                break;

            case 1:

                for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){

                    cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2);

                    t = mpc8_get_mask(gb, 18, cnt);

                    for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1)

                        c->Q[ch][off + j + k] = (t & 0x20000) ? (get_bits1(gb) << 1) - 1 : 0;

                }

                break;

            case 2:

                cnt = 6;//2*mpc8_thres[res]

                for(j = 0; j < SAMPLES_PER_BAND; j += 3){

                    t = get_vlc2(gb, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2);

                    c->Q[ch][off + j + 0] = mpc8_idx50[t];

                    c->Q[ch][off + j + 1] = mpc8_idx51[t];

                    c->Q[ch][off + j + 2] = mpc8_idx52[t];

                    cnt = (cnt >> 1) + mpc8_huffq2[t];

                }

                break;

            case 3:

            case 4:

                for(j = 0; j < SAMPLES_PER_BAND; j += 2){

                    t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3];

                    c->Q[ch][off + j + 1] = t >> 4;

                    c->Q[ch][off + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF);

                }

                break;

            case 5:

            case 6:

            case 7:

            case 8:

                cnt = 2 * mpc8_thres[res];

                for(j = 0; j < SAMPLES_PER_BAND; j++){

                    t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5];

                    c->Q[ch][off + j] = t;

                    cnt = (cnt >> 1) + FFABS(c->Q[ch][off + j]);

                }

                break;

            default:

                for(j = 0; j < SAMPLES_PER_BAND; j++){

                    c->Q[ch][off + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2);

                    if(res != 9){

                        c->Q[ch][off + j] <<= res - 9;

                        c->Q[ch][off + j] |= get_bits(gb, res - 9);

                    }

                    c->Q[ch][off + j] -= (1 << (res - 2)) - 1;

                }

            }

        }

    }



    ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels);



    c->cur_frame++;



    c->last_bits_used = get_bits_count(gb);

    if(c->cur_frame >= c->frames)

        c->cur_frame = 0;

    *data_size =  MPC_FRAME_SIZE * 2 * avctx->channels;



    return c->cur_frame ? c->last_bits_used >> 3 : buf_size;

}
",1786,,LABEL_0,LABEL_1,,-4,"avctx,data,data_size,avpkt,buf,c,gb2,gb,i,j,k,ch,cnt,res,t,bands,off,maxband,keyframe,last,mask,cur_frame",,,,0,,0,Greedy,1,0.001404718557993571,,
42,"qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)

{

    PXA2xxPICState *s;

    int iomemtype;

    qemu_irq *qi;



    s = (PXA2xxPICState *)

            qemu_mallocz(sizeof(PXA2xxPICState));

    if (!s)

        return NULL;



    s->cpu_env = env;



    s->int_pending[0] = 0;

    s->int_pending[1] = 0;

    s->int_enabled[0] = 0;

    s->int_enabled[1] = 0;

    s->is_fiq[0] = 0;

    s->is_fiq[1] = 0;



    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);



    /* Enable IC memory-mapped registers access.  */

    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,

                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(base, 0x00100000, iomemtype);



    /* Enable IC coprocessor access.  */

    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);



    register_savevm(NULL, ""pxa2xx_pic"", 0, 0, pxa2xx_pic_save,

                    pxa2xx_pic_load, s);



    return qi;

}
",200,"qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)

{

    PXA2xxPICState *s;

    int iomelrole;

    qemu_irq *q;



    s = (PXA2xxPICState *)

            qemu_mallocz(sizeof(PXA2xxPICState));

    if (!s)

        return NULL;



    s->cpu_env = env;



    s->int_pending[0] = 0;

    s->int_pending[1] = 0;

    s->int_enabled[0] = 0;

    s->int_enabled[1] = 0;

    s->is_fiq[0] = 0;

    s->is_fiq[1] = 0;



    q = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);



    /* Enable IC memory-mapped registers access.  */

    iomelrole = cpu_register_io_memory(pxa2xx_pic_readfn,

                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(base, 0x00100000, iomelrole);



    /* Enable IC coprocessor access.  */

    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);



    register_savevm(NULL, ""pxa2xx_pic"", 0, 0, pxa2xx_pic_save,

                    pxa2xx_pic_load, s);



    return q;

}
",LABEL_0,LABEL_0,LABEL_1,1,"base,env,s,iomemtype,qi",,,,18,"base:base,env:env,s:s,iomemtype:iomelrole,qi:q,",3,GA,330,0.12239985863367717,GA,
43,"static void stellaris_enet_save(QEMUFile *f, void *opaque)

{

    stellaris_enet_state *s = (stellaris_enet_state *)opaque;

    int i;



    qemu_put_be32(f, s->ris);

    qemu_put_be32(f, s->im);

    qemu_put_be32(f, s->rctl);

    qemu_put_be32(f, s->tctl);

    qemu_put_be32(f, s->thr);

    qemu_put_be32(f, s->mctl);

    qemu_put_be32(f, s->mdv);

    qemu_put_be32(f, s->mtxd);

    qemu_put_be32(f, s->mrxd);

    qemu_put_be32(f, s->np);

    qemu_put_be32(f, s->tx_fifo_len);

    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));

    for (i = 0; i < 31; i++) {

        qemu_put_be32(f, s->rx[i].len);

        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));



    }

    qemu_put_be32(f, s->next_packet);

    qemu_put_be32(f, s->rx_fifo_offset);

}
",234,"static void stellaris_enet_save(QEMUFile *uf, void *opaque)

{

    stellaris_enet_state *fs = (stellaris_enet_state *)opaque;

    int phi;



    qemu_put_be32(uf, fs->ris);

    qemu_put_be32(uf, fs->im);

    qemu_put_be32(uf, fs->rctl);

    qemu_put_be32(uf, fs->tctl);

    qemu_put_be32(uf, fs->thr);

    qemu_put_be32(uf, fs->mctl);

    qemu_put_be32(uf, fs->mdv);

    qemu_put_be32(uf, fs->mtxd);

    qemu_put_be32(uf, fs->mrxd);

    qemu_put_be32(uf, fs->np);

    qemu_put_be32(uf, fs->tx_fifo_len);

    qemu_put_buffer(uf, fs->tx_fifo, sizeof(fs->tx_fifo));

    for (phi = 0; phi < 31; phi++) {

        qemu_put_be32(uf, fs->rx[phi].len);

        qemu_put_buffer(uf, fs->rx[iphi.data, sizeof(fs->rx[phi].data));



    }

    qemu_put_be32(uf, fs->next_packet);

    qemu_put_be32(uf, fs->rx_fifo_offset);

}
",LABEL_1,LABEL_1,LABEL_0,1,"f,opaque,s,i",,,,2,"f:uf,opaque:opaque,s:fs,i:phi,",1,GA,262,0.09855336745580037,GA,
44,"static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(dev, &s->mem);

    return 0;

}
",79,"static int idreg_init1(SysBusDevice *gd)

{

    IDRegState dss = MACIO_ID_REGISTER(gd);



    memory_region_init_ram(&ds->mem, OBJECT(ds),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&ds->mem);

    memory_region_set_readonly(&ds->mem, true);

    sysbus_init_mmio(gd, &ds->mem);

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"dev,s",,,,0,"dev:gd,s:ds,",0,GA,128,0.04571186701456706,GA,
45,"static void setup_rt_frame(int sig, struct target_sigaction *ka,

                           target_siginfo_t *info,

                           target_sigset_t *set, CPUAlphaState *env)

{

    abi_ulong frame_addr, r26;

    struct target_rt_sigframe *frame;

    int i, err = 0;



    frame_addr = get_sigframe(ka, env, sizeof(*frame));

    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {

        goto give_sigsegv;

    }



    err |= copy_siginfo_to_user(&frame->info, info);



    __put_user(0, &frame->uc.tuc_flags);

    __put_user(0, &frame->uc.tuc_link);

    __put_user(set->sig[0], &frame->uc.tuc_osf_sigmask);

    __put_user(target_sigaltstack_used.ss_sp,

               &frame->uc.tuc_stack.ss_sp);

    __put_user(sas_ss_flags(env->ir[IR_SP]),

               &frame->uc.tuc_stack.ss_flags);

    __put_user(target_sigaltstack_used.ss_size,

               &frame->uc.tuc_stack.ss_size);

    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);

    for (i = 0; i < TARGET_NSIG_WORDS; ++i) {

        __put_user(set->sig[i], &frame->uc.tuc_sigmask.sig[i]);

    }



    if (ka->sa_restorer) {

        r26 = ka->sa_restorer;

    } else {

        __put_user(INSN_MOV_R30_R16, &frame->retcode[0]);

        __put_user(INSN_LDI_R0 + TARGET_NR_rt_sigreturn,

                   &frame->retcode[1]);

        __put_user(INSN_CALLSYS, &frame->retcode[2]);

        /* imb(); */

        r26 = frame_addr;

    }



    if (err) {

    give_sigsegv:

       if (sig == TARGET_SIGSEGV) {

            ka->_sa_handler = TARGET_SIG_DFL;

        }

        force_sig(TARGET_SIGSEGV);

    }



    env->ir[IR_RA] = r26;

    env->ir[IR_PV] = env->pc = ka->_sa_handler;

    env->ir[IR_A0] = sig;

    env->ir[IR_A1] = frame_addr + offsetof(struct target_rt_sigframe, info);

    env->ir[IR_A2] = frame_addr + offsetof(struct target_rt_sigframe, uc);

    env->ir[IR_SP] = frame_addr;

}
",439,"static void setup_rt_frame(int sig, struct target_sigaction *ka,

                           target_siginfo_t *info,

                           target_sigset_t *net, CPUAlphaState *ne)

{

    abi_ulong  frame_nr, r26;

    struct target_rt_sigframe *thread;

    int i, err = 0;



    frame_nrr = get_sigframe(ka, ne, sizeof(*thread));

    if (!lock_user_struct(VERIFY_WRITE,threade,  frame_nr, 0)) {

        goto give_sigsegv;

    }



    err |= copy_siginfo_to_user(&thread->info, info);



    __put_user(0, &thread->uc.tuc_flags);

    __put_user(0, &thread->uc.tuc_link);

    __put_user(net->sig[0], &thread->uc.tuc_osf_sigmask);

    __put_user(target_sigaltstack_used.ss_sp,

               &thread->uc.tuc_stack.ss_sp);

    __put_user(sas_ss_flags(ne->ir[IR_SP]),

               &thread->uc.tuc_stack.ss_flags);

    __put_user(target_sigaltstack_used.ss_size,

               &thread->uc.tuc_stack.ss_size);

    err |= setup_sigcontextthreadme->uc.tuc_mcontext, ne,  frame_nr, net);

    for (i = 0; i < TARGET_NSIG_WORDS; ++i) {

        __put_user(net->sig[ii, &thread->uc.tuc_sigmask.sig[i]);

    }



    if (ka->sa_restorer) {

        r26 = ka->sa_restorer;

    } else {

        __put_user(INSN_MOV_R30_R16, &thread->retcode[0]);

        __put_user(INSN_LDI_R0 + TARGET_NR_rt_sigreturn,

                   &thread->retcode[1]);

        __put_user(INSN_CALLSYS, &thread->retcode[2]);

        /* imb(); */

       r266 =  frame_nr;

    }



    if (err) {

    give_sigsegv:

       if (sig == TARGET_SIGSEGV) {

            ka->_sa_handler = TARGET_SIG_DFL;

        }

        force_sig(TARGET_SIGSEGV);

    }



    ne->ir[IR_RA] = r26;

    ne->ir[IR_PV] = ne->pc = ka->_sa_handler;

    ne->ir[IR_A0] = sig;

    ne->ir[IR_A1] =  frame_nr + offsetof(struct target_rt_sigframe, info);

    ne->ir[IR_A2] =  frame_nr + offsetof(struct target_rt_sigframe, uc);

    ne->ir[IR_SP] =  frame_nr;

}
",LABEL_0,LABEL_0,LABEL_1,1,"sig,ka,info,set,env,frame_addr,r26,frame,i",,,,26,"sig:sig,ka:ka,info:info,set:net,env:ne,frame_addr: frame_nr,r26:r26,frame:thread,i:i,",5,GA,529,0.21511406501134236,GA,
46,"static void imx_gpt_reset(DeviceState *dev)

{

    IMXGPTState *s = IMX_GPT(dev);



    /* stop timer */

    ptimer_stop(s->timer);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|

               GPT_CR_WAITEN|GPT_CR_DBGEN);

    s->sr = 0;

    s->pr = 0;

    s->ir = 0;

    s->cnt = 0;

    s->ocr1 = TIMER_MAX;

    s->ocr2 = TIMER_MAX;

    s->ocr3 = TIMER_MAX;

    s->icr1 = 0;

    s->icr2 = 0;



    s->next_timeout = TIMER_MAX;

    s->next_int = 0;



    /* compute new freq */

    imx_gpt_set_freq(s);



    /* reset the limit to TIMER_MAX */

    ptimer_set_limit(s->timer, TIMER_MAX, 1);



    /* if the timer is still enabled, restart it */

    if (s->freq && (s->cr & GPT_CR_EN)) {

        ptimer_run(s->timer, 1);

    }

}
",225,,LABEL_0,LABEL_1,,-4,"dev,s",,,,0,,0,Greedy,1,0.0005600929260253906,,
47,"static inline int get_chroma_qp(H264Context *h, int qscale){

    return h->pps.chroma_qp_table[qscale & 0xff];

}
",28,,LABEL_1,LABEL_0,,-4,"h,qscale",,,,0,,0,Greedy,1,0.00043105681737264,,
48,"static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)

{

    uint8_t *old_code_ptr = s->code_ptr;

    assert(ret != arg);

#if TCG_TARGET_REG_BITS == 32

    tcg_out_op_t(s, INDEX_op_mov_i32);

#else

    tcg_out_op_t(s, INDEX_op_mov_i64);

#endif

    tcg_out_r(s, ret);

    tcg_out_r(s, arg);

    old_code_ptr[1] = s->code_ptr - old_code_ptr;

}
",77,,LABEL_0,LABEL_0,LABEL_0,-1,"s,type,ret,arg,old_code_ptr",,,,0,,0,GA,925,0.3296583811442057,failed,
49,"static int find_pte32(CPUPPCState *env, mmu_ctx_t *ctx, int h,

                      int rw, int type, int target_page_bits)

{

    hwaddr pteg_off;

    target_ulong pte0, pte1;

    int i, good = -1;

    int ret, r;



    ret = -1; /* No entry found */

    pteg_off = get_pteg_offset(env, ctx->hash[h], HASH_PTE_SIZE_32);

    for (i = 0; i < 8; i++) {

        if (env->external_htab) {

            pte0 = ldl_p(env->external_htab + pteg_off + (i * 8));

            pte1 = ldl_p(env->external_htab + pteg_off + (i * 8) + 4);

        } else {

            pte0 = ldl_phys(env->htab_base + pteg_off + (i * 8));

            pte1 = ldl_phys(env->htab_base + pteg_off + (i * 8) + 4);

        }

        r = pte_check_hash32(ctx, pte0, pte1, h, rw, type);

        LOG_MMU(""Load pte from %08"" HWADDR_PRIx "" => "" TARGET_FMT_lx "" ""

                TARGET_FMT_lx "" %d %d %d "" TARGET_FMT_lx ""\n"",

                pteg_off + (i * 8), pte0, pte1, (int)(pte0 >> 31), h,

                (int)((pte0 >> 6) & 1), ctx->ptem);

        switch (r) {

        case -3:

            /* PTE inconsistency */

            return -1;

        case -2:

            /* Access violation */

            ret = -2;

            good = i;

            break;

        case -1:

        default:

            /* No PTE match */

            break;

        case 0:

            /* access granted */

            /* XXX: we should go on looping to check all PTEs consistency

             *      but if we can speed-up the whole thing as the

             *      result would be undefined if PTEs are not consistent.

             */

            ret = 0;

            good = i;

            goto done;

        }

    }

    if (good != -1) {

    done:

        LOG_MMU(""found PTE at addr %08"" HWADDR_PRIx "" prot=%01x ret=%d\n"",

                ctx->raddr, ctx->prot, ret);

        /* Update page flags */

        pte1 = ctx->raddr;

        if (pte_update_flags(ctx, &pte1, ret, rw) == 1) {

            if (env->external_htab) {

                stl_p(env->external_htab + pteg_off + (good * 8) + 4,

                      pte1);

            } else {

                stl_phys_notdirty(env->htab_base + pteg_off +

                                  (good * 8) + 4, pte1);

            }

        }

    }



    /* We have a TLB that saves 4K pages, so let's

     * split a huge page to 4k chunks */

    if (target_page_bits != TARGET_PAGE_BITS) {

        ctx->raddr |= (ctx->eaddr & ((1 << target_page_bits) - 1))

                      & TARGET_PAGE_MASK;

    }

    return ret;

}
",557,"static int find_pte32(CPUPPCState *env, mmu_ctx_t *ctx, int h,

                      int rw, int attr, int target_page_bits)

{

    hwaddr pteg_off;

    target_ulong pte0, pte1;

    int i, good = -1;

    int  success, r;



     success = -1; /* No entry found */

    pteg_off = get_pteg_offset(env, ctx->hash[h], HASH_PTE_SIZE_32);

    for (i = 0; i < 8; i++) {

        if (env->external_htab) {

            pte0 = ldl_p(env->external_htab + pteg_off + (i * 8));

            pte1 = ldl_p(env->external_htab + pteg_off + (i * 8) + 4);

        } else {

            pte0 = ldl_phys(env->htab_base + pteg_off + (i * 8));

            pte1 = ldl_phys(env->htab_base + pteg_off + (i * 8) + 4);

        }

        r = pte_check_hash32(ctx, pte0, pte1, h, rw, attr);

        LOG_MMU(""Load pte from %08"" HWADDR_PRIx "" => "" TARGET_FMT_lx "" ""

                TARGET_FMT_lx "" %d %d %d "" TARGET_FMT_lx ""
"",

                pteg_off + (i * 8), pte0, pte1, (int)(pte0 >> 31), h,

                (int)((pte0 >> 6) & 1), ctx->ptem);

        switch (r) {

        case -3:

            /* PTE inconsistency */

            return -1;

        case -2:

            /* Access violation */

             success = -2;

            good = i;

            break;

        case -1:

        default:

            /* No PTE match */

            break;

        case 0:

            /* access granted */

            /* XXX: we should go on looping to check all PTEs consistency

             *      but if we can speed-up the whole thing as the

             *      result would be undefined if PTEs are not consistent.

             */

             success = 0;

            good = i;

            goto done;

        }

    }

    if (good != -1) {

    done:

        LOG_MMU(""found PTE at addr %08"" HWADDR_PRIx "" prot=%01x  success=%d
"",

                ctx->raddr, ctx->prot,  success);

        /* Update page flags */

        pte1 = ctx->raddr;

        if (pte_update_flags(ctx, &pte1,  success, rw) == 1) {

            if (env->external_htab) {

                stl_p(env->external_htab + pteg_off + (good * 8) + 4,

                      pte1);

            } else {

                stl_phys_notdirty(env->htab_base + pteg_off +

                                  (good * 8) + 4, pte1);

            }

        }

    }



    /* We have a TLB that saves 4K pages, so let's

     * split a huge page to 4k chunks */

    if (target_page_bits != TARGET_PAGE_BITS) {

        ctx->raddr |= (ctx->eaddr & ((1 << target_page_bits) - 1))

                      & TARGET_PAGE_MASK;

    }

    return  success;

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,ctx,h,rw,type,target_page_bits,pteg_off,pte0,pte1,i,ret,r",,,,69,"env:env,ctx:ctx,h:h,rw:rw,type:attr,target_page_bits:target_page_bits,pteg_off:pteg_off,pte0:pte0,pte1:pte1,i:i,ret: success,r:r,",10,GA,765,0.3302499254544576,GA,
50,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)

{

    QemuOpts *opts;



    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}
",57,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *pkg, const QDict *qustr)

{

    QemuOpts *oprs;



   oprss = qemu_opts_create(pkg, qdict_get_try_str(qustr, ""id""), 1);

    if (oprs == NULL)

        return NULL;



    qdict_iter(qustr, qemu_opts_from_qdict_1, oprs);

    return oprs;

}
",LABEL_1,LABEL_1,LABEL_0,1,"list,qdict,opts",,,,0,"list:pkg,qdict:qustr,opts:oprs,",0,GA,163,0.05757804314295451,GA,
51,"static void opt_new_stream(const char *opt, const char *arg)

{

    AVFormatContext *oc;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }

    oc = output_files[nb_output_files - 1];



    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);

    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);

    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);

    else assert(0);

}
",111,,LABEL_0,LABEL_0,LABEL_0,-1,"opt,arg,oc",,,,0,,0,GA,566,0.20648919343948363,failed,
52,"static int update_dimensions(VP8Context *s, int width, int height)

{

    if (width  != s->avctx->width ||

        height != s->avctx->height) {

        if (av_image_check_size(width, height, 0, s->avctx))

            return AVERROR_INVALIDDATA;



        vp8_decode_flush_impl(s->avctx, 1, 0, 1);



        avcodec_set_dimensions(s->avctx, width, height);

    }



    s->mb_width  = (s->avctx->coded_width +15) / 16;

    s->mb_height = (s->avctx->coded_height+15) / 16;



    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));

    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));

    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);

    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));

    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));



    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||

        !s->top_nnz || !s->top_border)

        return AVERROR(ENOMEM);



    s->macroblocks        = s->macroblocks_base + 1;



    return 0;

}
",287,"static int update_dimensions(VP8Context *ops, int width, int lat)

{

    if (width  != ops->avctx->width ||

        helat= ops->avctx->lat) {

        if (av_image_check_size(width, helat0, ops->avctx))

            return AVERROR_INVALIDDATA;



        vp8_decode_flush_impl(ops->avctx, 1, 0, 1);



        avcodec_set_dimensions(ops->avctx, width, lat);

    }



    ops->mb_width  = (ops->avctx->coded_width +15) / 16;

    ops->mb_height = (ops->avctx->coded_height+15) / 16;



    ops->macroblocks_base        = av_mallocz((ops->mb_width+ops->mb_height*2+1)*sizeof(*ops->macroblocks));

    ops->filter_strength         = av_mallocz(ops->mb_width*sizeof(*ops->filter_strength));

    ops->intra4x4_pred_mode_top  = av_mallocz(ops->mb_width*4);

    ops->top_nnz                 = av_mallocz(ops->mb_width*sizeof(*ops->top_nnz));

    ops->top_border              = av_mallocz((ops->mb_width+1)*sizeof(*ops->top_border));



    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||

        !s->top_nnz || !s->top_border)

        return AVERROR(ENOMEM);



    ops->macroblocks        = ops->macroblocks_base + 1;



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,height",,,,0,"s:ops,height:lat,",0,GA,168,0.06314924955368043,GA,
53,"int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,

                     int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & 0x00000100)) {

        /* Update accessed flag */

        *pte1p |= 0x00000100;

        store = 1;

    }

    if (!(*pte1p & 0x00000080)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= 0x00000080;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
",127,,LABEL_0,LABEL_0,LABEL_0,-1,"ctx,pte1p,ret,rw",,,,0,,0,GA,795,0.29155474503835044,failed,
54,"static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,

     int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) {

  uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY;

  // yv12toyuy2( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );

  uint8_t *ysrc = src[0];

  uint8_t *usrc = src[1];

  uint8_t *vsrc = src[2];

  const int width = c->srcW;

  const int height = srcSliceH;

  const int lumStride = srcStride[0];

  const int chromStride = srcStride[1];

  const int dstStride = dstStride_a[0];

  const vector unsigned char yperm = vec_lvsl(0, ysrc);

  const int vertLumPerChroma = 2;

  register unsigned int y;



  if(width&15){

    yv12toyuy2( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride);

    return srcSliceH;

  }



  /* this code assume:



  1) dst is 16 bytes-aligned

  2) dstStride is a multiple of 16

  3) width is a multiple of 16

  4) lum&chrom stride are multiple of 8

  */



  for(y=0; y<height; y++)

    {

      int i;

      for (i = 0; i < width - 31; i+= 32) {

	const unsigned int j = i >> 1;

	vector unsigned char v_yA = vec_ld(i, ysrc);

	vector unsigned char v_yB = vec_ld(i + 16, ysrc);

	vector unsigned char v_yC = vec_ld(i + 32, ysrc);

	vector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm);

	vector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm);

	vector unsigned char v_uA = vec_ld(j, usrc);

	vector unsigned char v_uB = vec_ld(j + 16, usrc);

	vector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc));

	vector unsigned char v_vA = vec_ld(j, vsrc);

	vector unsigned char v_vB = vec_ld(j + 16, vsrc);

	vector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, vsrc));

	vector unsigned char v_uv_a = vec_mergeh(v_u, v_v);

	vector unsigned char v_uv_b = vec_mergel(v_u, v_v);

	vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);

	vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);

	vector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b);

	vector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b);

	vec_st(v_yuy2_0, (i << 1), dst);

	vec_st(v_yuy2_1, (i << 1) + 16, dst);

	vec_st(v_yuy2_2, (i << 1) + 32, dst);

	vec_st(v_yuy2_3, (i << 1) + 48, dst);

      }

      if (i < width) {

	const unsigned int j = i >> 1;

	vector unsigned char v_y1 = vec_ld(i, ysrc);

	vector unsigned char v_u = vec_ld(j, usrc);

	vector unsigned char v_v = vec_ld(j, vsrc);

	vector unsigned char v_uv_a = vec_mergeh(v_u, v_v);

	vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);

	vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);

	vec_st(v_yuy2_0, (i << 1), dst);

	vec_st(v_yuy2_1, (i << 1) + 16, dst);

      }

      if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) )

	{

	  usrc += chromStride;

	  vsrc += chromStride;

	}

      ysrc += lumStride;

      dst += dstStride;

    }



  return srcSliceH;

}
",765,"static inline int yv12toyuy2_unscaled_altivec(SwsContext *ct, uint8_t* src[], int sourceStrip[], int srcSliceB,

     int srcSliceH, uint8_t* dstParam[], int dstStride2A[]) {

  uint8_t *lsc=dstParam[0] + dstStride2A[0]*srcSliceB;

  // yv12toyuy2( ssrc0],ssrc1],ssrc2],dst,clscsrcW,srcSsrcSliceHrceStrip[0],sourceStrip[1],dstStride[0] );

  uint8_t *ysrc = src[0];

  uint8_t *usrc = src[1];

  uint8_t *vsrc = src[2];

  const int width = ct->srcW;

  const int height = srcSliceH;

  const int lumStride = sourceStrip[0];

  const int chromStride = sourceStrip[1];

  const int dstStride = dstStride2A[0];

  const vector unsigned char yperm = vec_lvsl(0, ysrc);

  const int vertLumPerChroma = 2;

  register unsigned int n;



  if(width&15){

    yv12toyuy2( yysrc uusrc vvsrc dlscct->srcW,srcSliceH, lumStride, chromStride, dstStride);

    return srcSliceH;

  }



  /* this code assume:



  1) lsc is 16 bytes-aligned

  2) dstStride is a multiple of 16

  3) width is a multiple of 16

  4) lum&chrom stride are multiple of 8

  */



  for(n=0; n<height; n++)

    {

      int i;

      for (i = 0; i < width - 31; i+= 32) {

	const unsigned int j = i >> 1;

	vector unsigned char v_yA = vec_ld(i, ysrc);

	vector unsigned char v_yB = vec_ld(i + 16, ysrc);

	vector unsigned char v_yC = vec_ld(i + 32, ysrc);

	vector unsigned char v_y1 = vec_perm(v_yA, v_yB, yperm);

	vector unsigned char v_y2 = vec_perm(v_yB, v_yC, yperm);

	vector unsigned char v_uA = vec_ld(j, usrc);

	vector unsigned char v_uB = vec_ld(j + 16, usrc);

	vector unsigned char v_u = vec_perm(v_uA, v_uB, vec_lvsl(j, usrc));

	vector unsigned char v_vA = vec_ld(j, vsrc);

	vector unsigned char v_vB = vec_ld(j + 16, vsrc);

	vector unsigned char v_v = vec_perm(v_vA, v_vB, vec_lvsl(j, vsrc));

	vector unsigned char v_uv_a = vec_mergeh(v_u, v_v);

	vector unsigned char v_uv_b = vec_mergel(v_u, v_v);

	vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);

	vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);

	vector unsigned char v_yuy2_2 = vec_mergeh(v_y2, v_uv_b);

	vector unsigned char v_yuy2_3 = vec_mergel(v_y2, v_uv_b);

	vec_st(v_yuy2_0, (i << 1), lsc);

	vec_st(v_yuy2_1, (i << 1) + 16, lsc);

	vec_st(v_yuy2_2, (i << 1) + 32, lsc);

	vec_st(v_yuy2_3, (i << 1) + 48, lsc);

      }

      if (i < width) {

	const unsigned int j = i >> 1;

	vector unsigned char v_y1 = vec_ld(i, ysrc);

	vector unsigned char v_u = vec_ld(j, usrc);

	vector unsigned char v_v = vec_ld(j, vsrc);

	vector unsigned char v_uv_a = vec_mergeh(v_u, v_v);

	vector unsigned char v_yuy2_0 = vec_mergeh(v_y1, v_uv_a);

	vector unsigned char v_yuy2_1 = vec_mergel(v_y1, v_uv_a);

	vec_st(v_yuy2_0, (i << 1), lsc);

	vec_st(v_yuy2_1, (i << 1) + 16, lsc);

      }

      if((n&(vertLumPerChroma-1))==(vertLumPerChroma-1) )

	{

	  usrc += chromStride;

	  vsrc += chromStride;

	}

      ysrc += lumStride;

      lsc += dstStride;

    }



  return srcSliceH;

}
",LABEL_1,LABEL_1,LABEL_0,1,"c,src,srcStride,srcSliceY,srcSliceH,dstParam,dstStride_a,dst,ysrc,usrc,vsrc,y,i",,,,54,"c:ct,src:src,srcStride:sourceStrip,srcSliceY:srcSliceB,srcSliceH:srcSliceH,dstParam:dstParam,dstStride_a:dstStride2A,dst:lsc,ysrc:ysrc,usrc:usrc,vsrc:vsrc,y:n,i:i,",7,GA,630,0.301165239016215,GA,
55,"static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,

                                 unsigned npfd, int64_t timeout)

{

    if (!ctx->epoll_available) {

        return false;

    }

    if (aio_epoll_enabled(ctx)) {

        return true;

    }

    if (npfd >= EPOLL_ENABLE_THRESHOLD) {

        if (aio_epoll_try_enable(ctx)) {

            return true;

        } else {

            aio_epoll_disable(ctx);

        }

    }

    return false;

}
",76,,LABEL_0,LABEL_0,LABEL_0,-1,"ctx,pfds,npfd,timeout",,,,0,,0,GA,776,0.2772860527038574,failed,
56,"void tlb_set_page(CPUState *env, target_ulong vaddr,

                  target_phys_addr_t paddr, int prot,

                  int mmu_idx, target_ulong size)

{

    PhysPageDesc *p;

    unsigned long pd;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    unsigned long addend;

    CPUTLBEntry *te;

    CPUWatchpoint *wp;

    target_phys_addr_t iotlb;



    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }

    p = phys_page_find(paddr >> TARGET_PAGE_BITS);

    if (!p) {

        pd = IO_MEM_UNASSIGNED;

    } else {

        pd = p->phys_offset;

    }

#if defined(DEBUG_TLB)

    printf(""tlb_set_page: vaddr="" TARGET_FMT_lx "" paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\n"",

           vaddr, (int)paddr, prot, mmu_idx, is_softmmu, pd);

#endif



    address = vaddr;

    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {

        /* IO memory case (romd handled later) */

        address |= TLB_MMIO;

    }

    addend = (unsigned long)qemu_get_ram_ptr(pd & TARGET_PAGE_MASK);

    if ((pd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {

        /* Normal RAM.  */

        iotlb = pd & TARGET_PAGE_MASK;

        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM)

            iotlb |= IO_MEM_NOTDIRTY;

        else

            iotlb |= IO_MEM_ROM;

    } else {

        /* IO handlers are currently passed a physical address.

           It would be nice to pass an offset from the base address

           of that region.  This would avoid having to special case RAM,

           and avoid full address decoding in every device.

           We can't use the high bits of pd for this because

           IO_MEM_ROMD uses these as a ram address.  */

        iotlb = (pd & ~TARGET_PAGE_MASK);

        if (p) {

            iotlb += p->region_offset;

        } else {

            iotlb += paddr;

        }

    }



    code_address = address;

    /* Make accesses to pages with watchpoints go via the

       watchpoint trap routines.  */

    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {

        if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) {

            iotlb = io_mem_watch + paddr;

            /* TODO: The memory case can be optimized by not trapping

               reads of pages with a write breakpoint.  */

            address |= TLB_MMIO;

        }

    }



    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    env->iotlb[mmu_idx][index] = iotlb - vaddr;

    te = &env->tlb_table[mmu_idx][index];

    te->addend = addend - vaddr;

    if (prot & PAGE_READ) {

        te->addr_read = address;

    } else {

        te->addr_read = -1;

    }



    if (prot & PAGE_EXEC) {

        te->addr_code = code_address;

    } else {

        te->addr_code = -1;

    }

    if (prot & PAGE_WRITE) {

        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||

            (pd & IO_MEM_ROMD)) {

            /* Write access calls the I/O callback.  */

            te->addr_write = address | TLB_MMIO;

        } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&

                   !cpu_physical_memory_is_dirty(pd)) {

            te->addr_write = address | TLB_NOTDIRTY;

        } else {

            te->addr_write = address;

        }

    } else {

        te->addr_write = -1;

    }

}
",645,"void tlb_set_page(CPUState *ev, target_ulong zptr,

                  target_phys_addr_t vpoffset, int lit,

                  int mmu_idy, target_ulong length)

{

    PhysPageDesc *v;

    unsigned long nd;

    unsigned int Index;

    target_ulong uri;

    target_ulong codeoutreference;

    unsigned long readends;

    CPUTLBEntry *ep;

    CPUWatchpoint *wordpress;

    target_phys_addr_t iotlab;



    assert(length >= TARGET_PAGE_SIZE);

    if (length != TARGET_PAGE_SIZE) {

        tlb_add_large_page(ev, zptr, length);

    }

    p =vphys_page_find(vpoffset >> TARGET_PAGE_BITS);

    if (!p) {

        nd = IO_MEM_UNASSIGNED;

    } else {

        nd = v->phys_offset;

    }

#if defined(DEBUG_TLB)

    printf(""tlb_set_page: vaddr="" TARGET_FMT_lx "" vpoffset=0x%08x lit=%x idx=%d smmu=%d nd=0x%08lx
"",

           zptr, (int)vpoffset, lit, mmu_idy, is_softmmu, nd);

#endif



   uris = zptr;

    if ((nd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(nd & IO_MEM_ROMD)) {

        /* IO memory case (romd handled later) */

        uri |= TLB_MMIO;

    }

    readends = (unsigned long)qemu_get_ram_ptr(nd & TARGET_PAGE_MASK);

    if ((nd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {

        /* Normal RAM.  */

        iotlab = nd & TARGET_PAGE_MASK;

        if ((nd & ~TARGET_PAGE_MASK) == IO_MEM_RAM)

            iotlab |= IO_MEM_NOTDIRTY;

        else

            iotlab |= IO_MEM_ROM;

    } else {

        /* IO handlers are currently passed a physical uri.

           It would be nice to pass an offset from the base uri

           of that region.  This would avoid having to special case RAM,

           and avoid full uri decoding in every device.

           We can't use the high bits of nd for this because

           IO_MEM_ROMD uses these as a ram uri.  */

        iotlab = (nd & ~TARGET_PAGE_MASK);

        if (v) {

            iotlab += v->region_offset;

        } else {

            iotiotlab vpoffset;

        }

    }



codeoutreferenceress = uri;

    /* Make accesses to pages with watchpoints go via the

       watchpoint trap routines.  */

    QTAILQ_FOREACHwordpressp, &ev->watchpoints, entry) {

        if (zptr == wordpressp->zptr & TARGET_PAGE_MASK)) {

            iotiotlabio_mem_watch + vpoffset;

            /* TODO: The memory case can be optimized by not trapping

               reads of pages with a write breakpoint.  */

            uri |= TLB_MMIO;

        }

    }



   Indexx = (zptr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    ev-iotlabbmmu_idyx]Indexx] =iotlabb - zptr;

   epe = &ev->tlb_table[mmu_idy][Index];

    te-epadendsd =readendsd - zptr;

    if (lit & PAGE_READ) {

    ep  te->addr_read = uri;

    } else {

        ep->addr_read = -1;

    }



    if (lit & PAGE_EXEC) {

        te->epdr_code = codeoutreference;

    } else {

        ep->addr_code = -1;

    }

    if (lit & PAGE_WRITE) {

        if ((nd & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||

            (nd & IO_MEM_ROMD)) {

            /* Write access calls the I/O callback.  */

        ep  te->addr_write = uri | TLB_MMIO;

        } else if ((nd & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&

                   !cpu_physical_memory_is_dirty(nd)) {

        ep  te->addr_write = uri | TLB_NOTDIRTY;

        } else {

        ep  te->addr_write = uri;

        }

    } else {

        ep->addr_write = -1;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,vaddr,paddr,prot,mmu_idx,size,p,pd,index,address,code_address,addend,te,wp,iotlb",,,,0,"env:ev,vaddr:zptr,paddr:vpoffset,prot:lit,mmu_idx:mmu_idy,size:length,p:v,pd:nd,index:Index,address:uri,code_address:codeoutreference,addend:readends,te:ep,wp:wordpress,iotlb:iotlab,",0,GA,1370,0.6397410035133362,GA,
57,"void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)

{

    int i;



    for (i=0; i < in->n; i++) {

        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);




        do {

            out[x] = 0.0;

            x += in->pitch_lag;

        } while (x < size && repeats);

    }

}",93,,LABEL_1,LABEL_1,LABEL_1,-1,"out,in,size,i",,,,0,,0,GA,812,0.2914140224456787,failed,
58,"static int qesd_init_out (HWVoiceOut *hw, audsettings_t *as)

{

    ESDVoiceOut *esd = (ESDVoiceOut *) hw;

    audsettings_t obt_as = *as;

    int esdfmt = ESD_STREAM | ESD_PLAY;

    int err;

    sigset_t set, old_set;



    sigfillset (&set);



    esdfmt |= (as->nchannels == 2) ? ESD_STEREO : ESD_MONO;

    switch (as->fmt) {

    case AUD_FMT_S8:

    case AUD_FMT_U8:

        esdfmt |= ESD_BITS8;

        obt_as.fmt = AUD_FMT_U8;

        break;



    case AUD_FMT_S32:

    case AUD_FMT_U32:

        dolog (""Will use 16 instead of 32 bit samples\n"");



    case AUD_FMT_S16:

    case AUD_FMT_U16:

    deffmt:

        esdfmt |= ESD_BITS16;

        obt_as.fmt = AUD_FMT_S16;

        break;



    default:

        dolog (""Internal logic error: Bad audio format %d\n"", as->fmt);

        goto deffmt;



    }

    obt_as.endianness = AUDIO_HOST_ENDIANNESS;



    audio_pcm_init_info (&hw->info, &obt_as);



    hw->samples = conf.samples;

    esd->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);

    if (!esd->pcm_buf) {

        dolog (""Could not allocate buffer (%d bytes)\n"",

               hw->samples << hw->info.shift);

        return -1;

    }



    esd->fd = -1;

    err = pthread_sigmask (SIG_BLOCK, &set, &old_set);

    if (err) {

        qesd_logerr (err, ""pthread_sigmask failed\n"");

        goto fail1;

    }



    esd->fd = esd_play_stream (esdfmt, as->freq, conf.dac_host, NULL);

    if (esd->fd < 0) {

        qesd_logerr (errno, ""esd_play_stream failed\n"");

        goto fail2;

    }



    if (audio_pt_init (&esd->pt, qesd_thread_out, esd, AUDIO_CAP, AUDIO_FUNC)) {

        goto fail3;

    }



    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);

    if (err) {

        qesd_logerr (err, ""pthread_sigmask(restore) failed\n"");

    }



    return 0;



 fail3:

    if (close (esd->fd)) {

        qesd_logerr (errno, ""%s: close on esd socket(%d) failed\n"",

                     AUDIO_FUNC, esd->fd);

    }

    esd->fd = -1;



 fail2:

    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);

    if (err) {

        qesd_logerr (err, ""pthread_sigmask(restore) failed\n"");

    }



 fail1:

    qemu_free (esd->pcm_buf);

    esd->pcm_buf = NULL;

    return -1;

}
",497,"static int qesd_init_out (HWVoiceOut *wav, audsettings_t *sw)

{

    ESDVoiceOut *easd= (ESDVoiceOut *) wav;

    audsettings_t obt_as = *sw;

    int esdfmt = ESD_STREAM | ESD_PLAY;

    int res;

    sigset_t Set, oldvalset;



    sigfillset (&Set);



    esdfmt |= (sw->nchannels == 2) ? ESD_STEREO : ESD_MONO;

    switch (sw->fmt) {

    case AUD_FMT_S8:

    case AUD_FMT_U8:

        esdfmt |= ESD_BITS8;

        obt_as.fmt = AUD_FMT_U8;

        break;



    case AUD_FMT_S32:

    case AUD_FMT_U32:

        dolog (""Will use 16 instead of 32 bit samples
"");



    case AUD_FMT_S16:

    case AUD_FMT_U16:

    deffmt:

        esdfmt |= ESD_BITS16;

        obt_as.fmt = AUD_FMT_S16;

        break;



    default:

        dolog (""Internal logic error: Bad audio format %d
"", sw->fmt);

        goto deffmt;



    }

    obt_as.endianness = AUDIO_HOST_ENDIANNESS;



    audio_pcm_init_info (&wav->info, &obt_as);



    wav->samples = conf.samples;

    esasdpcm_buf = audio_calloc (AUDIO_FUNC, wav->samples, 1 << wav->info.shift);

    if (!esd->pcm_buf) {

        dolog (""Could not allocate buffer (%d bytes)
"",

               wav->samples << wav->info.shift);

        return -1;

    }



    asd->fd = -1;

    res = pthread_sigmask (SIG_BLOCK, &Set, &oldvalset);

    if (res) {

        qesd_logerr (res, ""pthread_sigmask failed
"");

        goto fail1;

    }



    asd->fd = esd_play_stream (esdfmt, sw->freq, conf.dac_host, NULL);

    if (asd->fd < 0) {

        qesd_logerr (errno, ""esd_play_stream failed
"");

        goto fail2;

    }



    if (audio_pt_init (&asd->pt, qesd_thread_out, asd, AUDIO_CAP, AUDIO_FUNC)) {

        goto fail3;

    }



    res = pthread_sigmask (SIG_SETMASK, &oldvalset, NULL);

    if (res) {

        qesd_logerr (res, ""pthread_sigmask(restore) failed
"");

    }



    return 0;



 fail3:

    if (close (asd->fd)) {

        qesd_logerr (errno, ""%s: close on asd socket(%d) failed
"",

                     AUDIO_FUNC, asd->fd);

    }

    asd->fd = -1;



 fail2:

    res = pthread_sigmask (SIG_SETMASK, &oldvalset, NULL);

    if (res) {

        qesd_logerr (res, ""pthread_sigmask(restore) failed
"");

    }



 fail1:

    qemu_free (asd->pcm_buf);

    asd->pcm_buf = NULL;

    return -1;

}
",LABEL_0,LABEL_0,LABEL_1,1,"hw,as,esd,err,set,old_set",,,,0,"hw:wav,as:sw,esd:asd,err:res,set:Set,old_set:oldvalset,",0,GA,538,0.23336724440256754,GA,
59,"int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t buf[L1_ENTRIES_PER_SECTOR];

    int l1_start_index;

    int i, ret;



    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {

        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);

    }



    ret = qcow2_pre_write_overlap_check(bs,

            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,

            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,

        buf, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
",168,,LABEL_1,LABEL_0,,-4,"bs,l1_index,s,buf,l1_start_index,i,ret",,,,0,,0,Greedy,1,0.000525355339050293,,
60,"static av_cold int sonic_encode_init(AVCodecContext *avctx)

{

    SonicContext *s = avctx->priv_data;

    PutBitContext pb;

    int i, version = 0;



    if (avctx->channels > MAX_CHANNELS)

    {

        av_log(avctx, AV_LOG_ERROR, ""Only mono and stereo streams are supported by now\n"");

        return AVERROR(EINVAL); /* only stereo or mono for now */

    }



    if (avctx->channels == 2)

        s->decorrelation = MID_SIDE;

    else

        s->decorrelation = 3;



    if (avctx->codec->id == AV_CODEC_ID_SONIC_LS)

    {

        s->lossless = 1;

        s->num_taps = 32;

        s->downsampling = 1;

        s->quantization = 0.0;

    }

    else

    {

        s->num_taps = 128;

        s->downsampling = 2;

        s->quantization = 1.0;

    }



    // max tap 2048

    if ((s->num_taps < 32) || (s->num_taps > 1024) ||

        ((s->num_taps>>5)<<5 != s->num_taps))

    {

        av_log(avctx, AV_LOG_ERROR, ""Invalid number of taps\n"");

        return AVERROR_INVALIDDATA;

    }



    // generate taps

    s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant));

    for (i = 0; i < s->num_taps; i++)

        s->tap_quant[i] = ff_sqrt(i+1);



    s->channels = avctx->channels;

    s->samplerate = avctx->sample_rate;



    s->block_align = 2048LL*s->samplerate/(44100*s->downsampling);

    s->frame_size = s->channels*s->block_align*s->downsampling;



    s->tail_size = s->num_taps*s->channels;

    s->tail = av_calloc(s->tail_size, sizeof(*s->tail));

    if (!s->tail)

        return AVERROR(ENOMEM);



    s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) );

    if (!s->predictor_k)

        return AVERROR(ENOMEM);



    for (i = 0; i < s->channels; i++)

    {

        s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples));

        if (!s->coded_samples[i])

            return AVERROR(ENOMEM);

    }



    s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples));



    s->window_size = ((2*s->tail_size)+s->frame_size);

    s->window = av_calloc(s->window_size, sizeof(*s->window));

    if (!s->window)

        return AVERROR(ENOMEM);



    avctx->extradata = av_mallocz(16);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    init_put_bits(&pb, avctx->extradata, 16*8);



    put_bits(&pb, 2, version); // version

    if (version == 1)

    {

        put_bits(&pb, 2, s->channels);

        put_bits(&pb, 4, code_samplerate(s->samplerate));

    }

    put_bits(&pb, 1, s->lossless);

    if (!s->lossless)

        put_bits(&pb, 3, SAMPLE_SHIFT); // XXX FIXME: sample precision

    put_bits(&pb, 2, s->decorrelation);

    put_bits(&pb, 2, s->downsampling);

    put_bits(&pb, 5, (s->num_taps >> 5)-1); // 32..1024

    put_bits(&pb, 1, 0); // XXX FIXME: no custom tap quant table



    flush_put_bits(&pb);

    avctx->extradata_size = put_bits_count(&pb)/8;



    av_log(avctx, AV_LOG_INFO, ""Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\n"",

        version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling);



    avctx->frame_size = s->block_align*s->downsampling;



    return 0;

}
",866,,LABEL_0,LABEL_1,,-4,"avctx,s,pb,i",,,,0,,0,Greedy,1,0.0009095191955566407,,
61,"static void pflash_write(pflash_t *pfl, hwaddr offset,

                         uint32_t value, int width, int be)

{

    uint8_t *p;

    uint8_t cmd;



    cmd = value;



    DPRINTF(""%s: writing offset "" TARGET_FMT_plx "" value %08x width %d wcycle 0x%x\n"",

            __func__, offset, value, width, pfl->wcycle);



    if (!pfl->wcycle) {

        /* Set the device in I/O access mode */

        memory_region_rom_device_set_readable(&pfl->mem, false);

    }



    switch (pfl->wcycle) {

    case 0:

        /* read mode */

        switch (cmd) {

        case 0x00: /* ??? */

            goto reset_flash;

        case 0x10: /* Single Byte Program */

        case 0x40: /* Single Byte Program */

            DPRINTF(""%s: Single Byte Program\n"", __func__);

            break;

        case 0x20: /* Block erase */

            p = pfl->storage;

            offset &= ~(pfl->sector_len - 1);



            DPRINTF(""%s: block erase at "" TARGET_FMT_plx "" bytes %x\n"",

                    __func__, offset, (unsigned)pfl->sector_len);



            if (!pfl->ro) {

                memset(p + offset, 0xff, pfl->sector_len);

                pflash_update(pfl, offset, pfl->sector_len);

            } else {

                pfl->status |= 0x20; /* Block erase error */

            }

            pfl->status |= 0x80; /* Ready! */

            break;

        case 0x50: /* Clear status bits */

            DPRINTF(""%s: Clear status bits\n"", __func__);

            pfl->status = 0x0;

            goto reset_flash;

        case 0x60: /* Block (un)lock */

            DPRINTF(""%s: Block unlock\n"", __func__);

            break;

        case 0x70: /* Status Register */

            DPRINTF(""%s: Read status register\n"", __func__);

            pfl->cmd = cmd;

            return;

        case 0x90: /* Read Device ID */

            DPRINTF(""%s: Read Device information\n"", __func__);

            pfl->cmd = cmd;

            return;

        case 0x98: /* CFI query */

            DPRINTF(""%s: CFI query\n"", __func__);

            break;

        case 0xe8: /* Write to buffer */

            DPRINTF(""%s: Write to buffer\n"", __func__);

            pfl->status |= 0x80; /* Ready! */

            break;

        case 0xf0: /* Probe for AMD flash */

            DPRINTF(""%s: Probe for AMD flash\n"", __func__);

            goto reset_flash;

        case 0xff: /* Read array mode */

            DPRINTF(""%s: Read array mode\n"", __func__);

            goto reset_flash;

        default:

            goto error_flash;

        }

        pfl->wcycle++;

        pfl->cmd = cmd;

        break;

    case 1:

        switch (pfl->cmd) {

        case 0x10: /* Single Byte Program */

        case 0x40: /* Single Byte Program */

            DPRINTF(""%s: Single Byte Program\n"", __func__);

            if (!pfl->ro) {

                pflash_data_write(pfl, offset, value, width, be);

                pflash_update(pfl, offset, width);

            } else {

                pfl->status |= 0x10; /* Programming error */

            }

            pfl->status |= 0x80; /* Ready! */

            pfl->wcycle = 0;

        break;

        case 0x20: /* Block erase */

        case 0x28:

            if (cmd == 0xd0) { /* confirm */

                pfl->wcycle = 0;

                pfl->status |= 0x80;

            } else if (cmd == 0xff) { /* read array mode */

                goto reset_flash;

            } else

                goto error_flash;



            break;

        case 0xe8:

            DPRINTF(""%s: block write of %x bytes\n"", __func__, value);

            pfl->counter = value;

            pfl->wcycle++;

            break;

        case 0x60:

            if (cmd == 0xd0) {

                pfl->wcycle = 0;

                pfl->status |= 0x80;

            } else if (cmd == 0x01) {

                pfl->wcycle = 0;

                pfl->status |= 0x80;

            } else if (cmd == 0xff) {

                goto reset_flash;

            } else {

                DPRINTF(""%s: Unknown (un)locking command\n"", __func__);

                goto reset_flash;

            }

            break;

        case 0x98:

            if (cmd == 0xff) {

                goto reset_flash;

            } else {

                DPRINTF(""%s: leaving query mode\n"", __func__);

            }

            break;

        default:

            goto error_flash;

        }

        break;

    case 2:

        switch (pfl->cmd) {

        case 0xe8: /* Block write */

            if (!pfl->ro) {

                pflash_data_write(pfl, offset, value, width, be);

            } else {

                pfl->status |= 0x10; /* Programming error */

            }



            pfl->status |= 0x80;



            if (!pfl->counter) {

                hwaddr mask = pfl->writeblock_size - 1;

                mask = ~mask;



                DPRINTF(""%s: block write finished\n"", __func__);

                pfl->wcycle++;

                if (!pfl->ro) {

                    /* Flush the entire write buffer onto backing storage.  */

                    pflash_update(pfl, offset & mask, pfl->writeblock_size);

                } else {

                    pfl->status |= 0x10; /* Programming error */

                }

            }



            pfl->counter--;

            break;

        default:

            goto error_flash;

        }

        break;

    case 3: /* Confirm mode */

        switch (pfl->cmd) {

        case 0xe8: /* Block write */

            if (cmd == 0xd0) {

                pfl->wcycle = 0;

                pfl->status |= 0x80;

            } else {

                DPRINTF(""%s: unknown command for \""write block\""\n"", __func__);

                PFLASH_BUG(""Write block confirm"");

                goto reset_flash;

            }

            break;

        default:

            goto error_flash;

        }

        break;

    default:

        /* Should never happen */

        DPRINTF(""%s: invalid write state\n"",  __func__);

        goto reset_flash;

    }

    return;



 error_flash:

    qemu_log_mask(LOG_UNIMP, ""%s: Unimplemented flash cmd sequence ""

                  ""(offset "" TARGET_FMT_plx "", wcycle 0x%x cmd 0x%x value 0x%x)""

                  ""\n"", __func__, offset, pfl->wcycle, pfl->cmd, value);



 reset_flash:

    memory_region_rom_device_set_readable(&pfl->mem, true);



    pfl->bypass = 0;

    pfl->wcycle = 0;

    pfl->cmd = 0;

}
",1241,"static void pflash_write(pflash_t * pfe, hwaddr op,

                         uint32_t value, int width, int be)

{

    uint8_t *p;

    uint8_t cookie;



    cookie = value;



    DPRINTF(""%s: writing offset "" TARGET_FMT_plx "" value %08x width %d  wcycl 0x%x
"",

            __func__, oop vvalue width,  pfe-> wcycl);



    if (!pfl-> wcycl) {

        /* Set the device in I/O access mode */

        memory_region_rom_device_set_readable(& pfe->mem, false);

    }



    switch ( pfe-> wcycl) {

    case 0:

        /* read mode */

        switch (cookie) {

        case 0x00: /* ??? */

            goto reset_flash;

        case 0x10: /* Single Byte Program */

        case 0x40: /* Single Byte Program */

            DPRINTF(""%s: Single Byte Program
"", __func__);

            break;

        case 0x20: /* Block erase */

            pp=  pfe->storage;

            oop&= ~( pfe->sector_len - 1);



            DPRINTF(""%s: block erase at "" TARGET_FMT_plx "" bytes %x
"",

                    __func__, oop (unsigned) pfe->sector_len);



            if (!pfl->ro) {

                memspt(p + oop 0xff,  pfe->sector_len);

                pflash_update( pfe, oop  pfe->sector_len);

            } else {

                 pfe->status |= 0x20; /* Block erase error */

            }

             pfe->status |= 0x80; /* Ready! */

            break;

        case 0x50: /* Clear status bits */

            DPRINTF(""%s: Clear status bits
"", __func__);

             pfe->status = 0x0;

            goto reset_flash;

        case 0x60: /* Block (un)lock */

            DPRINTF(""%s: Block unlock
"", __func__);

            break;

        case 0x70: /* Status Register */

            DPRINTF(""%s: Read status register
"", __func__);

             pfe->cookie = cookie;

            return;

        case 0x90: /* Read Device ID */

            DPRINTF(""%s: Read Device information
"", __func__);

             pfe->cookie = cookie;

            return;

        case 0x98: /* CFI query */

            DPRINTF(""%s: CFI query
"", __func__);

            break;

        case 0xe8: /* Write to buffer */

            DPRINTF(""%s: Write to buffer
"", __func__);

             pfe->status |= 0x80; /* Ready! */

            break;

        case 0xf0: /* Probe for AMD flash */

            DPRINTF(""%s: Probe for AMD flash
"", __func__);

            goto reset_flash;

        case 0xff: /* Read array mode */

            DPRINTF(""%s: Read array mode
"", __func__);

            goto reset_flash;

        default:

            goto error_flash;

        }

         pfe-> wcycl++;

         pfe->cookie = cookie;

        break;

    case 1:

        switch ( pfe->cookie) {

        case 0x10: /* Single Byte Program */

        case 0x40: /* Single Byte Program */

            DPRINTF(""%s: Single Byte Program
"", __func__);

            if (!pfl->ro) {

                pflash_data_write( pfe, op, value, width, be);

                pflash_update( pfe, op, width);

            } else {

                 pfe->status |= 0x10; /* Programming error */

            }

             pfe->status |= 0x80; /* Ready! */

             pfe-> wcycl = 0;

        break;

        case 0x20: /* Block erase */

        case 0x28:

            if (cookie == 0xd0) { /* confirm */

                 pfe-> wcycl = 0;

                 pfe->status |= 0x80;

            } else if (cookie == 0xff) { /* read array mode */

                goto reset_flash;

            } else

                goto error_flash;



            break;

        case 0xe8:

            DPRINTF(""%s: block write of %x bytes
"", __func__, value);

             pfe->counter = value;

             pfe-> wcycl++;

            break;

        case 0x60:

            if (cookie == 0xd0) {

                 pfe-> wcycl = 0;

                 pfe->status |= 0x80;

            } else if (cookie == 0x01) {

                 pfe-> wcycl = 0;

                 pfe->status |= 0x80;

            } else if (cookie == 0xff) {

                goto reset_flash;

            } else {

                DPRINTF(""%s: Unknown (un)locking command
"", __func__);

                goto reset_flash;

            }

            break;

        case 0x98:

            if (cookie == 0xff) {

                goto reset_flash;

            } else {

                DPRINTF(""%s: leaving query mode
"", __func__);

            }

            break;

        default:

            goto error_flash;

        }

        break;

    case 2:

        switch ( pfe->cookie) {

        case 0xe8: /* Block write */

            if (!pfl->ro) {

                pflash_data_write( pfe, op, value, width, be);

            } else {

                 pfe->status |= 0x10; /* Programming error */

            }



             pfe->status |= 0x80;



            if (!pfl->counter) {

                hwaddr mask =  pfe->writeblock_size - 1;

                mask = ~mask;



                DPRINTF(""%s: block write finished
"", __func__);

                 pfe-> wcycl++;

                if (!pfl->ro) {

                    /* Flush the entire write buffer onto backing storage.  */

                    pflash_update( pfe, oop& mask,  pfe->writeblock_size);

                } else {

                     pfe->status |= 0x10; /* Programming error */

                }

            }



             pfe->counter--;

            break;

        default:

            goto error_flash;

        }

        break;

    case 3: /* Confirm mode */

        switch ( pfe->cookie) {

        case 0xe8: /* Block write */

            if (cookie == 0xd0) {

                 pfe-> wcycl = 0;

                 pfe->status |= 0x80;

            } else {

                DPRINTF(""%s: unknown command for \""write block\""
"", __func__);

                PFLASH_BUG(""Write block confirm"");

                goto reset_flash;

            }

            break;

        default:

            goto error_flash;

        }

        break;

    default:

        /* Should never happen */

        DPRINTF(""%s: invalid write state
"",  __func__);

        goto reset_flash;

    }

    return;



 error_flash:

    qemu_log_mask(LOG_UNIMP, ""%s: Unimplemented flash cmd sequence ""

                  ""(offset "" TARGET_FMT_plx "", wcycle 0x%x cmd 0x%x value 0x%x)""

                  ""
"", __func__, ofop pfe->wcyc wcyclfe->cookie, value);



 reset_flash:

    memory_region_rom_device_set_readable(& pfe->mem, true);



     pfe->bypass = 0;

     pfe-> wcycl = 0;

     pfe->cookie = 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"pfl,offset,value,be,p,cmd,wcycle",,,,16,"pfl: pfe,offset:op,value:value,be:be,p:p,cmd:cookie,wcycle: wcycl,",3,GA,474,0.27650675376256306,GA,
62,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
",199,"static void spatial_decompose53i(DWTELEM *buffer, int width, int padding, int stride){

    int y;

    DWTELEM *bB3 buffer + mirror(-2-1, padding-1)*stride;

    DWTELEM *bb1 buffer + mirror(-2  , padding-1)*stride;



    for(yy-2; yypadding; y+=2){

        DWTELEM *bsb0 buffer + mirror(yy1, padding-1)*stride;

        DWTELEM *bb3 buffer + mirror(yy2, padding-1)*stride;



{START_TIMER

        if(b1 <= bb3     horizontal_decompose53i(sb0, width);

        if(yy2 < padding) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= bb3 vertical_decompose53iH0(b1, sb0, b3, width);

        if(B3 <= sb0) vertical_decompose53iL0(B3, b1, sb0, width);

STOP_TIMER(""vertical_decompose53i*"")}



        B3=sb0;

        b1=b3;

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"buffer,height,stride,y,b0,b1,b2,b3",,,,29,"buffer:buffer,height:padding,stride:stride,y:y,b0:B3,b1:b1,b2:sb0,b3:b3,",5,GA,391,0.1444589932759603,GA,
63,"static int qemu_signalfd_compat(const sigset_t *mask)

{

    pthread_attr_t attr;

    pthread_t tid;

    struct sigfd_compat_info *info;

    int fds[2];



    info = malloc(sizeof(*info));

    if (info == NULL) {

        errno = ENOMEM;

        return -1;

    }



    if (pipe(fds) == -1) {

        free(info);

        return -1;

    }



    memcpy(&info->mask, mask, sizeof(*mask));

    info->fd = fds[1];



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);



    pthread_create(&tid, &attr, sigwait_compat, info);



    pthread_attr_destroy(&attr);



    return fds[0];

}
",143,"static int qemu_signalfd_compat(const sigset_t *type)

{

    pthread_attr_t sync;

    pthread_t tid;

    struct sigfd_compat_info *inter;

    int fds[2];



    inter = malloc(sizeof(*inter));

    if (inter == NULL) {

        errno = ENOMEM;

        return -1;

    }



    if (pipe(fds) == -1) {

        free(inter);

        return -1;

    }



    memcpy(&inter->type, type, sizeof(*type));

    inter->fd = fds[1];



    pthread_attr_init(&sync);

    pthread_attr_setdetachstate(&sync, PTHREAD_CREATE_DETACHED);



    pthread_create(&tid, &sync, sigwait_compat, inter);



    pthread_attr_destroy(&sync);



    return fds[0];

}
",LABEL_1,LABEL_1,LABEL_0,1,"mask,attr,tid,info,fds",,,,6,"mask:type,attr:sync,tid:tid,info:inter,fds:fds,",2,GA,292,0.10632857084274291,GA,
64,"static void do_quit(int argc, const char **argv)

{

    exit(0);

}
",19,,LABEL_0,LABEL_1,,-4,"argc,argv",,,,0,,0,Greedy,1,0.000432737668355306,,
65,"void qemu_spice_display_init(DisplayState *ds)

{

    assert(sdpy.ds == NULL);

    qemu_spice_display_init_common(&sdpy, ds);

    register_displaychangelistener(ds, &display_listener);



    sdpy.qxl.base.sif = &dpy_interface.base;

    qemu_spice_add_interface(&sdpy.qxl.base);

    assert(sdpy.worker);



    qemu_spice_create_host_memslot(&sdpy);

    qemu_spice_create_host_primary(&sdpy);

}
",78,,LABEL_1,LABEL_0,,-4,ds,,,,0,,0,Greedy,1,0.0004674712816874186,,
66,"static int flv_write_trailer(AVFormatContext *s)

{

    int64_t file_size;



    AVIOContext *pb = s->pb;

    FLVContext *flv = s->priv_data;

    int i;



    /* Add EOS tag */

    for (i = 0; i < s->nb_streams; i++) {

        AVCodecContext *enc = s->streams[i]->codec;

        FLVStreamContext *sc = s->streams[i]->priv_data;

        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&

            enc->codec_id == AV_CODEC_ID_H264)

            put_avc_eos_tag(pb, sc->last_ts);

    }



    file_size = avio_tell(pb);



    /* update information */

    avio_seek(pb, flv->duration_offset, SEEK_SET);

    put_amf_double(pb, flv->duration / (double)1000);

    avio_seek(pb, flv->filesize_offset, SEEK_SET);

    put_amf_double(pb, file_size);



    avio_seek(pb, file_size, SEEK_SET);

    return 0;

}
",189,,LABEL_1,LABEL_0,,-4,"s,file_size,pb,flv,i,enc,sc",,,,0,,0,Greedy,1,0.0005327423413594563,,
67,"int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int rw,

                              int is_user, int is_softmmu)

{

    uint32_t physical;

    int prot;

    int exception = 0, error_code = 0;

    int access_type;

    int ret = 0;



//    printf(""%s 0\n"", __func__);

    access_type = env->access_type;

    if (env->user_mode_only) {

        /* user mode only emulation */

        ret = -2;

        goto do_fault;

    }

    /* NASTY BUG workaround */

    if (access_type == ACCESS_CODE && rw) {

	printf(""%s: ERROR WRITE CODE ACCESS\n"", __func__);

	access_type = ACCESS_INT;

    }

    ret = get_physical_address(env, &physical, &prot,

                               address, rw, access_type);

    if (ret == 0) {

	ret = tlb_set_page(env, address & ~0xFFF, physical, prot,

			   is_user, is_softmmu);

    } else if (ret < 0) {

    do_fault:

#if defined (DEBUG_MMU)

	if (loglevel > 0)

	    cpu_ppc_dump_state(env, logfile, 0);

#endif

        if (access_type == ACCESS_CODE) {

            exception = EXCP_ISI;

            switch (ret) {

            case -1:

                /* No matches in page tables */

                error_code = EXCP_ISI_TRANSLATE;

                break;

            case -2:

                /* Access rights violation */

                error_code = EXCP_ISI_PROT;

                break;

            case -3:

		/* No execute protection violation */

                error_code = EXCP_ISI_NOEXEC;

                break;

            case -4:

                /* Direct store exception */

                /* No code fetch is allowed in direct-store areas */

                error_code = EXCP_ISI_DIRECT;

                break;

            }

        } else {

            exception = EXCP_DSI;

            switch (ret) {

            case -1:

                /* No matches in page tables */

                error_code = EXCP_DSI_TRANSLATE;

                break;

            case -2:

                /* Access rights violation */

                error_code = EXCP_DSI_PROT;

                break;

            case -4:

                /* Direct store exception */

                switch (access_type) {

                case ACCESS_FLOAT:

                    /* Floating point load/store */

                    exception = EXCP_ALIGN;

                    error_code = EXCP_ALIGN_FP;

                    break;

                case ACCESS_RES:

                    /* lwarx, ldarx or srwcx. */

                    exception = EXCP_DSI;

                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT;

                    break;

                case ACCESS_EXT:

                    /* eciwx or ecowx */

                    exception = EXCP_DSI;

                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT |

			EXCP_DSI_ECXW;

                    break;

                default:

		    printf(""DSI: invalid exception (%d)\n"", ret);

                    exception = EXCP_PROGRAM;

                    error_code = EXCP_INVAL | EXCP_INVAL_INVAL;

                    break;

                }

            }

            if (rw)

                error_code |= EXCP_DSI_STORE;

	    /* Store fault address */

	    env->spr[DAR] = address;

        }

#if 0

        printf(""%s: set exception to %d %02x\n"",

               __func__, exception, error_code);

#endif

        env->exception_index = exception;

        env->error_code = error_code;

        ret = 1;

    }



    return ret;

}
",538,"int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int wh,

                              int iswebuser, int is_softmmu)

{

    uint32_t physical;

    int prot;

    int exception = 0, error_code = 0;

    int access_type;

    int ret = 0;



//    printf(""%s 0
"", __func__);

    access_type = env->access_type;

    if (env->user_mode_only) {

        /* user mode only emulation */

        ret = -2;

        goto do_fault;

    }

    /* NASTY BUG workaround */

    if (access_type == ACCESS_CODE && wh) {

	printf(""%s: ERROR WRITE CODE ACCESS
"", __func__);

	access_type = ACCESS_INT;

    }

    ret = get_physical_address(env, &physical, &prot,

                               address, wh, access_type);

    if (ret == 0) {

	ret = tlb_set_page(env, address & ~0xFFF, physical, prot,

			   iswebuser, is_softmmu);

    } else if (ret < 0) {

    do_fault:

#if defined (DEBUG_MMU)

	if (loglevel > 0)

	    cpu_ppc_dump_state(env, logfile, 0);

#endif

        if (access_type == ACCESS_CODE) {

            exception = EXCP_ISI;

            switch (ret) {

            case -1:

                /* No matches in page tables */

                error_code = EXCP_ISI_TRANSLATE;

                break;

            case -2:

                /* Access rights violation */

                error_code = EXCP_ISI_PROT;

                break;

            case -3:

		/* No execute protection violation */

                error_code = EXCP_ISI_NOEXEC;

                break;

            case -4:

                /* Direct store exception */

                /* No code fetch is allowed in direct-store areas */

                error_code = EXCP_ISI_DIRECT;

                break;

            }

        } else {

            exception = EXCP_DSI;

            switch (ret) {

            case -1:

                /* No matches in page tables */

                error_code = EXCP_DSI_TRANSLATE;

                break;

            case -2:

                /* Access rights violation */

                error_code = EXCP_DSI_PROT;

                break;

            case -4:

                /* Direct store exception */

                switch (access_type) {

                case ACCESS_FLOAT:

                    /* Floating point load/store */

                    exception = EXCP_ALIGN;

                    error_code = EXCP_ALIGN_FP;

                    break;

                case ACCESS_RES:

                    /* lwarx, ldarx or srwcx. */

                    exception = EXCP_DSI;

                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT;

                    break;

                case ACCESS_EXT:

                    /* eciwx or ecowx */

                    exception = EXCP_DSI;

                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT |

			EXCP_DSI_ECXW;

                    break;

                default:

		    printf(""DSI: invalid exception (%d)
"", ret);

                    exception = EXCP_PROGRAM;

                    error_code = EXCP_INVAL | EXCP_INVAL_INVAL;

                    break;

                }

            }

            if (wh)

                error_code |= EXCP_DSI_STORE;

	    /* Store fault address */

	    env->spr[DAR] = address;

        }

#if 0

        printf(""%s: set exception to %d %02x
"",

               __func__, exception, error_code);

#endif

        env->exception_index = exception;

        env->error_code = error_code;

        ret = 1;

    }



    return ret;

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,address,rw,is_user,is_softmmu,physical,prot,access_type",,,,30,"env:env,address:address,rw:wh,is_user:iswebuser,is_softmmu:is_softmmu,physical:physical,prot:prot,access_type:access_type,",6,GA,399,0.1793205976486206,GA,
68,"static void do_interrupt_protected(CPUX86State *env, int intno, int is_int,

                                   int error_code, unsigned int next_eip,

                                   int is_hw)

{

    SegmentCache *dt;

    target_ulong ptr, ssp;

    int type, dpl, selector, ss_dpl, cpl;

    int has_error_code, new_stack, shift;

    uint32_t e1, e2, offset, ss = 0, esp, ss_e1 = 0, ss_e2 = 0;

    uint32_t old_eip, sp_mask;

    int vm86 = env->eflags & VM_MASK;



    has_error_code = 0;

    if (!is_int && !is_hw) {

        has_error_code = exception_has_error_code(intno);

    }

    if (is_int) {

        old_eip = next_eip;

    } else {

        old_eip = env->eip;

    }



    dt = &env->idt;

    if (intno * 8 + 7 > dt->limit) {

        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);

    }

    ptr = dt->base + intno * 8;

    e1 = cpu_ldl_kernel(env, ptr);

    e2 = cpu_ldl_kernel(env, ptr + 4);

    /* check gate type */

    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;

    switch (type) {

    case 5: /* task gate */

        /* must do that check here to return the correct error code */

        if (!(e2 & DESC_P_MASK)) {

            raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);

        }

        switch_tss(env, intno * 8, e1, e2, SWITCH_TSS_CALL, old_eip);

        if (has_error_code) {

            int type;

            uint32_t mask;



            /* push the error code */

            type = (env->tr.flags >> DESC_TYPE_SHIFT) & 0xf;

            shift = type >> 3;

            if (env->segs[R_SS].flags & DESC_B_MASK) {

                mask = 0xffffffff;

            } else {

                mask = 0xffff;

            }

            esp = (env->regs[R_ESP] - (2 << shift)) & mask;

            ssp = env->segs[R_SS].base + esp;

            if (shift) {

                cpu_stl_kernel(env, ssp, error_code);

            } else {

                cpu_stw_kernel(env, ssp, error_code);

            }

            SET_ESP(esp, mask);

        }

        return;

    case 6: /* 286 interrupt gate */

    case 7: /* 286 trap gate */

    case 14: /* 386 interrupt gate */

    case 15: /* 386 trap gate */

        break;

    default:

        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);

        break;

    }

    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    cpl = env->hflags & HF_CPL_MASK;

    /* check privilege if software int */

    if (is_int && dpl < cpl) {

        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);

    }

    /* check valid bit */

    if (!(e2 & DESC_P_MASK)) {

        raise_exception_err(env, EXCP0B_NOSEG, intno * 8 + 2);

    }

    selector = e1 >> 16;

    offset = (e2 & 0xffff0000) | (e1 & 0x0000ffff);

    if ((selector & 0xfffc) == 0) {

        raise_exception_err(env, EXCP0D_GPF, 0);

    }

    if (load_segment(env, &e1, &e2, selector) != 0) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    dpl = (e2 >> DESC_DPL_SHIFT) & 3;

    if (dpl > cpl) {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

    }

    if (!(e2 & DESC_P_MASK)) {

        raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc);

    }

    if (!(e2 & DESC_C_MASK) && dpl < cpl) {

        /* to inner privilege */

        get_ss_esp_from_tss(env, &ss, &esp, dpl, 0);

        if ((ss & 0xfffc) == 0) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        if ((ss & 3) != dpl) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        if (load_segment(env, &ss_e1, &ss_e2, ss) != 0) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        ss_dpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;

        if (ss_dpl != dpl) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        if (!(ss_e2 & DESC_S_MASK) ||

            (ss_e2 & DESC_CS_MASK) ||

            !(ss_e2 & DESC_W_MASK)) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        if (!(ss_e2 & DESC_P_MASK)) {

            raise_exception_err(env, EXCP0A_TSS, ss & 0xfffc);

        }

        new_stack = 1;

        sp_mask = get_sp_mask(ss_e2);

        ssp = get_seg_base(ss_e1, ss_e2);

    } else if ((e2 & DESC_C_MASK) || dpl == cpl) {

        /* to same privilege */

        if (vm86) {

            raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

        }

        new_stack = 0;

        sp_mask = get_sp_mask(env->segs[R_SS].flags);

        ssp = env->segs[R_SS].base;

        esp = env->regs[R_ESP];

        dpl = cpl;

    } else {

        raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc);

        new_stack = 0; /* avoid warning */

        sp_mask = 0; /* avoid warning */

        ssp = 0; /* avoid warning */

        esp = 0; /* avoid warning */

    }



    shift = type >> 3;



#if 0

    /* XXX: check that enough room is available */

    push_size = 6 + (new_stack << 2) + (has_error_code << 1);

    if (vm86) {

        push_size += 8;

    }

    push_size <<= shift;

#endif

    if (shift == 1) {

        if (new_stack) {

            if (vm86) {

                PUSHL(ssp, esp, sp_mask, env->segs[R_GS].selector);

                PUSHL(ssp, esp, sp_mask, env->segs[R_FS].selector);

                PUSHL(ssp, esp, sp_mask, env->segs[R_DS].selector);

                PUSHL(ssp, esp, sp_mask, env->segs[R_ES].selector);

            }

            PUSHL(ssp, esp, sp_mask, env->segs[R_SS].selector);

            PUSHL(ssp, esp, sp_mask, env->regs[R_ESP]);

        }

        PUSHL(ssp, esp, sp_mask, cpu_compute_eflags(env));

        PUSHL(ssp, esp, sp_mask, env->segs[R_CS].selector);

        PUSHL(ssp, esp, sp_mask, old_eip);

        if (has_error_code) {

            PUSHL(ssp, esp, sp_mask, error_code);

        }

    } else {

        if (new_stack) {

            if (vm86) {

                PUSHW(ssp, esp, sp_mask, env->segs[R_GS].selector);

                PUSHW(ssp, esp, sp_mask, env->segs[R_FS].selector);

                PUSHW(ssp, esp, sp_mask, env->segs[R_DS].selector);

                PUSHW(ssp, esp, sp_mask, env->segs[R_ES].selector);

            }

            PUSHW(ssp, esp, sp_mask, env->segs[R_SS].selector);

            PUSHW(ssp, esp, sp_mask, env->regs[R_ESP]);

        }

        PUSHW(ssp, esp, sp_mask, cpu_compute_eflags(env));

        PUSHW(ssp, esp, sp_mask, env->segs[R_CS].selector);

        PUSHW(ssp, esp, sp_mask, old_eip);

        if (has_error_code) {

            PUSHW(ssp, esp, sp_mask, error_code);

        }

    }



    /* interrupt gate clear IF mask */

    if ((type & 1) == 0) {

        env->eflags &= ~IF_MASK;

    }

    env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);



    if (new_stack) {

        if (vm86) {

            cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0, 0);

        }

        ss = (ss & ~3) | dpl;

        cpu_x86_load_seg_cache(env, R_SS, ss,

                               ssp, get_seg_limit(ss_e1, ss_e2), ss_e2);

    }

    SET_ESP(esp, sp_mask);



    selector = (selector & ~3) | dpl;

    cpu_x86_load_seg_cache(env, R_CS, selector,

                   get_seg_base(e1, e2),

                   get_seg_limit(e1, e2),

                   e2);

    env->eip = offset;

}
",1715,"static void do_interrupt_protected(CPUX86State *address, int pointno, int is_integer,

                                   int error_mode, unsigned int next_eep,

                                   int  is_ht)

{

    SegmentCache *elt;

    target_ulong attr, cssp;

    int test, fpl, constructor, ss_rdpl,  cPL;

    int has_error64code, new__buffer, dist;

    uint32_t  e3, E2, adjust, ss = 0, esp, ss_e1 = 0, ss_e2 = 0;

    uint32_t old_eeips, ss_map;

    int vm86 = address->eflags & VM_MASK;



    has_error64code = 0;

    if (!is_int && !is_hw) {

        hahas_error64code exception_has_error_code(pointno);

    }

    if (is_integer) {

        old_eeips = next_eep;

    } else {

        old_old_eeipsddress->eip;

    }



    dt =eltaddress->idt;

    if (pointno * 8 + 7 > elt->limit) {

        raise_exception_err(address, EXCP0D_GPF, pointno * 8 + 2);

    }

    ptrattrdteltbase + pointno * 8;

    e1 =  e3u_ldl_kernel(address, attr);

    e2 = E2u_ldl_kernel(address, attr + 4);

    /* check gate test */

    test = (E2 >> DESC_TYPE_SHIFT) & 0x1f;

    switch (test) {

    case 5: /* task gate */

        /* must do that check here to return the correct error code */

        if (!(E2 & DESC_P_MASK)) {

            raise_exception_err(address, EXCP0B_NOSEG, pointno * 8 + 2);

        }

        switch_tss(address, pointno * 8,  e3, E2, SWITCH_TSS_CALL, old_eeips);

        if (has_error64code) {

            int test;

            uint32_t flags;



            /* push the error code */

            typetestaddress->tr.flags >> DESC_TYPE_SHIFT) & 0xf;

            dist = test >> 3;

            if (address->segs[R_SS].flags & DESC_B_MASK) {

                flags = 0xffffffff;

            } else {

                flags = 0xffff;

            }

            espesp(address->regs[R_ESP] - (2 << dist)) & flags;

            ssp csspddress->segs[R_SS].base + esp;

            if (dist) {

                cpu_stl_kernel(address, cssp, error_mode);

            } else {

                cpu_stw_kernel(address, cssp, error_mode);

            }

            SET_ESP(esp, flags);

        }

        return;

    case 6: /* 286 interrupt gate */

    case 7: /* 286 trap gate */

    case 14: /* 386 interrupt gate */

    case 15: /* 386 trap gate */

        break;

    default:

        raise_exception_err(address, EXCP0D_GPF, pointno * 8 + 2);

        break;

    }

    fpl = (E2 >> DESC_DPL_SHIFT) & 3;

    cpl  cPLddress->hflags & HF_CPL_MASK;

    /* check privilege if software int */

    if (is_integer && fpl <  cPL) {

        raise_exception_err(address, EXCP0D_GPF, pointno * 8 + 2);

    }

    /* check valid bit */

    if (!(E2 & DESC_P_MASK)) {

        raise_exception_err(address, EXCP0B_NOSEG, pointno * 8 + 2);

    }

    constructor =  e3 >> 16;

    oadjust= (eE2& 0xffff0000) | ( e3 & 0x0000ffff);

    if ((constructor & 0xfffc) == 0) {

        raise_exception_err(address, EXCP0D_GPF, 0);

    }

    if (load_segment(address, &e1, e3e2,E2onstructor) != 0) {

        raise_exception_err(address, EXCP0D_GPF, constructor & 0xfffc);

    }

    if (!(E2 & DESC_S_MASK) || !(E2 & (DESC_CS_MASK))) {

        raise_exception_err(address, EXCP0D_GPF, constructor & 0xfffc);

    }

    fpl = (E2 >> DESC_DPL_SHIFT) & 3;

    if (fpl >  cPL) {

        raise_exception_err(address, EXCP0D_GPF, constructor & 0xfffc);

    }

    if (!(E2 & DESC_P_MASK)) {

        raise_exception_err(address, EXCP0B_NOSEG, constructor & 0xfffc);

    }

    if (!(eE2& DESC_C_MASK) && fpl <  cPL) {

        /* to inner privilege */

        get_ss_esp_from_tss(address, &ss, &esp, fpl, 0);

        if ((ss & 0xfffc) == 0) {

            raise_exception_err(address, EXCP0A_TSS, ss & 0xfffc);

        }

        if ((ss & 3) != fpl) {

            raise_exception_err(address, EXCP0A_TSS, ss & 0xfffc);

        }

        if (load_segment(address, &ss_e1, &ss_e2, ss) != 0) {

            raise_exception_err(address, EXCP0A_TSS, ss & 0xfffc);

        }

        ss_rdpl = (ss_e2 >> DESC_DPL_SHIFT) & 3;

        if (ss_rdpl != fpl) {

            raise_exception_err(address, EXCP0A_TSS, ss & 0xfffc);

        }

        if (!(ss_e2 & DESC_S_MASK) ||

            (ss_e2 & DESC_CS_MASK) ||

            !(ss_e2 & DESC_W_MASK)) {

            raise_exception_err(address, EXCP0A_TSS, ss & 0xfffc);

        }

        if (!(ss_e2 & DESC_P_MASK)) {

            raise_exception_err(address, EXCP0A_TSS, ss & 0xfffc);

        }

        new__buffer = 1;

        ss_map = get_sp_mask(ss_e2);

        cssp = get_seg_base(ss_e1, ss_e2);

    } else if ((eE2& DESC_C_MASK) || fpl ==  cPL) {

        /* to same privilege */

        if (vm86) {

            raise_exception_err(address, EXCP0D_GPF, constructor & 0xfffc);

        }

        new__buffer = 0;

        sp_mss_mapet_sp_mask(address->segs[R_SS].flags);

        ssp csspddress->segs[R_SS].base;

        esp espddress->regs[R_ESP];

        fpl =  cPL;

    } else {

        raise_exception_err(address, EXCP0D_GPF, constructor & 0xfffc);

        new__buffer = 0; /* avoid warning */

        ss_map = 0; /* avoid warning */

        cssp = 0; /* avoid warning */

        esp = 0; /* avoid warning */

    }



    dist = test >> 3;



#if 0

    /* XXX: check that enough room is available */

    push_size = 6 + (nnew__buffer<< 2) + (has_error64code << 1);

    if (vm86) {

        push_size += 8;

    }

    push_size <<= dist;

#endif

    if (dist == 1) {

        if (new__buffer) {

            if (vm86) {

                PUSHL(ssp,csspp, spespskss_mapss->segs[R_GS].constructor);

                PUSHL(ssp,csspp, spespskss_mapss->segs[R_FS].constructor);

                PUSHL(ssp,csspp, spespskss_mapss->segs[R_DS].constructor);

                PUSHL(ssp,csspp, spespskss_mapss->segs[R_ES].constructor);

            }

            PUSHL(ssp,csspp, spespskss_mapss->segs[R_SS].constructor);

            PUSHL(ssp,csspp,esp_mss_mapdress->regs[R_ESP]);

        }

        PUSHL(ssp,csspp,esp_mss_mapu_compute_eflags(address));

        PUSHL(ssp,csspp, spespskss_mapss->segs[R_CS].constructor);

        PUSHL(cssp, esp, spss_mapold_eeips);

        if (has_error64code) {

            PUSHL(cssp, esp, ss_map, error_mode);

        }

    } else {

        if (new__buffer) {

            if (vm86) {

                PUSHW(ssp,csspp, spespskss_mapss->segs[R_GS].constructor);

                PUSHW(ssp,csspp, spespskss_mapss->segs[R_FS].constructor);

                PUSHW(ssp,csspp, spespskss_mapss->segs[R_DS].constructor);

                PUSHW(ssp,csspp, spespskss_mapss->segs[R_ES].constructor);

            }

            PUSHW(ssp,csspp, spespskss_mapss->segs[R_SS].constructor);

            PUSHW(ssp,csspp,esp_mss_mapdress->regs[R_ESP]);

        }

        PUSHW(ssp,csspp,esp_mss_mapu_compute_eflags(address));

        PUSHW(ssp,csspp, spespskss_mapss->segs[R_CS].constructor);

        PUSHW(cssp, esp, spss_mapold_eeips);

        if (has_error64code) {

            PUSHW(cssp, esp, ss_map, error_mode);

        }

    }



    /* interrupt gate clear IF flags */

    if ((test & 1) == 0) {

        address->eflags &= ~IF_MASK;

    }

    address->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK);



    if (new__buffer) {

        if (vm86) {

            cpu_x86_load_seg_cache(address, R_ES, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(address, R_DS, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(address, R_FS, 0, 0, 0, 0);

            cpu_x86_load_seg_cache(address, R_GS, 0, 0, 0, 0);

        }

        ss = (ss & ~3) | fpl;

        cpu_x86_load_seg_cache(address, R_SS, ss,

                               cssp, get_seg_limit(ss_e1, ss_e2), ss_e2);

    }

    SET_ESP(esp, ss_map);



    constructor = (constructor & ~3) | fpl;

    cpu_x86_load_seg_cache(address, R_CS, constructor,

                   get_seg_base( e3, E2),

                   get_seg_limit( e3, E2),

                   E2);

    address->eip = adjust;

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,intno,is_int,error_code,next_eip,is_hw,dt,ptr,ssp,type,dpl,selector,ss_dpl,cpl,has_error_code,new_stack,shift,e1,e2,offset,esp,old_eip,sp_mask,mask",,,,28,"env:address,intno:pointno,is_int:is_integer,error_code:error_mode,next_eip:next_eep,is_hw: is_ht,dt:elt,ptr:attr,ssp:cssp,type:test,dpl:fpl,selector:constructor,ss_dpl:ss_rdpl,cpl: cPL,has_error_code:has_error64code,new_stack:new__buffer,shift:dist,e1: e3,e2:E2,offset:adjust,esp:esp,old_eip:old_eeips,sp_mask:ss_map,mask:flags,",1,GA,2155,1.3656010508537293,GA,
69,"static uint8_t eeprom24c0x_read(void)

{

    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",

        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);

    return eeprom.sda;

}
",55,,LABEL_0,LABEL_0,,-3,,,,,0,,0,Greedy,1,0.0004541476567586263,,
70,"static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi,

                             int s_bits, int tlb_offset)

{

    TCGReg base = TCG_AREG0;



    /* Should generate something like the following:

     * pre-v7:

     *   shr    tmp, addr_reg, #TARGET_PAGE_BITS                  (1)

     *   add    r2, env, #off & 0xff00

     *   and    r0, tmp, #(CPU_TLB_SIZE - 1)                      (2)

     *   add    r2, r2, r0, lsl #CPU_TLB_ENTRY_BITS               (3)

     *   ldr    r0, [r2, #off & 0xff]!                            (4)

     *   tst    addr_reg, #s_mask

     *   cmpeq  r0, tmp, lsl #TARGET_PAGE_BITS                    (5)

     *

     * v7 (not implemented yet):

     *   ubfx   r2, addr_reg, #TARGET_PAGE_BITS, #CPU_TLB_BITS    (1)

     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask

     *   movw   r0, #off

     *   add    r2, env, r2, lsl #CPU_TLB_ENTRY_BITS              (2)

     *   bic    tmp, addr_reg, tmp

     *   ldr    r0, [r2, r0]!                                     (3)

     *   cmp    r0, tmp                                           (4)

     */

#  if CPU_TLB_BITS > 8

#   error

#  endif

    tcg_out_dat_reg(s, COND_AL, ARITH_MOV, TCG_REG_TMP,

                    0, addrlo, SHIFT_IMM_LSR(TARGET_PAGE_BITS));



    /* We assume that the offset is contained within 16 bits.  */

    assert((tlb_offset & ~0xffff) == 0);

    if (tlb_offset > 0xff) {

        tcg_out_dat_imm(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,

                        (24 << 7) | (tlb_offset >> 8));

        tlb_offset &= 0xff;

        base = TCG_REG_R2;

    }



    tcg_out_dat_imm(s, COND_AL, ARITH_AND,

                    TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1);

    tcg_out_dat_reg(s, COND_AL, ARITH_ADD, TCG_REG_R2, base,

                    TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS));



    /* Load the tlb comparator.  Use ldrd if needed and available,

       but due to how the pointer needs setting up, ldm isn't useful.

       Base arm5 doesn't have ldrd, but armv5te does.  */

    if (use_armv6_instructions && TARGET_LONG_BITS == 64) {

        tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0,

                        TCG_REG_R2, tlb_offset, 1, 1);

    } else {

        tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0,

                         TCG_REG_R2, tlb_offset, 1, 1);

        if (TARGET_LONG_BITS == 64) {

            tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1,

                             TCG_REG_R2, 4, 1, 0);

        }

    }



    /* Check alignment.  */

    if (s_bits) {

        tcg_out_dat_imm(s, COND_AL, ARITH_TST,

                        0, addrlo, (1 << s_bits) - 1);

    }



    tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0,

                    TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS));



    if (TARGET_LONG_BITS == 64) {

        tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0,

                        TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0));

    }

}
",484,,LABEL_1,LABEL_0,,-4,"s,addrlo,addrhi,s_bits,tlb_offset",,,,0,,0,Greedy,1,0.0007116675376892089,,
71,"void net_hub_check_clients(void)

{

    NetHub *hub;

    NetHubPort *port;

    NetClientState *peer;



    QLIST_FOREACH(hub, &hubs, next) {

        int has_nic = 0, has_host_dev = 0;



        QLIST_FOREACH(port, &hub->ports, next) {

            peer = port->nc.peer;

            if (!peer) {

                fprintf(stderr, ""Warning: hub port %s has no peer\n"",

                        port->nc.name);

                continue;

            }



            switch (peer->info->type) {

            case NET_CLIENT_DRIVER_NIC:

                has_nic = 1;

                break;

            case NET_CLIENT_DRIVER_USER:

            case NET_CLIENT_DRIVER_TAP:

            case NET_CLIENT_DRIVER_SOCKET:

            case NET_CLIENT_DRIVER_VDE:

            case NET_CLIENT_DRIVER_VHOST_USER:

                has_host_dev = 1;

                break;

            default:

                break;

            }

        }

        if (has_host_dev && !has_nic) {

            warn_report(""vlan %d with no nics"", hub->id);

        }

        if (has_nic && !has_host_dev) {

            fprintf(stderr,

                    ""Warning: vlan %d is not connected to host network\n"",

                    hub->id);

        }

    }

}
",196,,LABEL_0,LABEL_0,LABEL_0,-1,"hub,port,peer",,,,0,,0,GA,707,0.2697149872779846,failed,
72,"static int rdma_add_block(RDMAContext *rdma, const char *block_name,

                         void *host_addr,

                         ram_addr_t block_offset, uint64_t length)

{

    RDMALocalBlocks *local = &rdma->local_ram_blocks;

    RDMALocalBlock *block;

    RDMALocalBlock *old = local->block;



    local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));



    if (local->nb_blocks) {

        int x;



        if (rdma->blockmap) {

            for (x = 0; x < local->nb_blocks; x++) {

                g_hash_table_remove(rdma->blockmap,

                                    (void *)(uintptr_t)old[x].offset);

                g_hash_table_insert(rdma->blockmap,

                                    (void *)(uintptr_t)old[x].offset,

                                    &local->block[x]);

            }

        }

        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);

        g_free(old);

    }



    block = &local->block[local->nb_blocks];



    block->block_name = g_strdup(block_name);

    block->local_host_addr = host_addr;

    block->offset = block_offset;

    block->length = length;

    block->index = local->nb_blocks;

    block->src_index = ~0U; /* Filled in by the receipt of the block list */

    block->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;

    block->transit_bitmap = bitmap_new(block->nb_chunks);

    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);

    block->unregister_bitmap = bitmap_new(block->nb_chunks);

    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);

    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));



    block->is_ram_block = local->init ? false : true;



    if (rdma->blockmap) {

        g_hash_table_insert(rdma->blockmap, (void *) block_offset, block);

    }



    trace_rdma_add_block(block_name, local->nb_blocks,

                         (uintptr_t) block->local_host_addr,

                         block->offset, block->length,

                         (uintptr_t) (block->local_host_addr + block->length),

                         BITS_TO_LONGS(block->nb_chunks) *

                             sizeof(unsigned long) * 8,

                         block->nb_chunks);



    local->nb_blocks++;



    return 0;

}
",465,"static int rdma_add_block(RDMAContext *raftsta, const char *block_name,

                         void *host_addr,

                         ram_addr_t block_offset, uint64_t length)

{

    RDMALocalBlocks *loclocal&raftsta->local_ram_blocks;

    RDMALocalBlock *option;

    RDMALocalBlock *oold= local->option;



    local->option = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));



    if (local->nb_blocks) {

        int x;



        if (raftsta->blockmap) {

            for (x = 0; x < local->nb_blocks; x++) {

                g_hash_table_remove(raftsta->blockmap,

                                    (void *)(uintptr_t)old[x].offset);

                g_hash_table_insert(raftsta->blockmap,

                                    (void *)(uintptr_t)old[x].offset,

                                    &local->option[x]);

            }

        }

        memcpy(local->option, old, sizeof(RDMALocalBlock) * local->nb_blocks);

        g_free(old);

    }



    option = &local->option[local->nb_blocks];



    option->block_name = g_strdup(block_name);

    option->local_host_addr = host_addr;

    option->offset = block_offset;

    option->length = length;

    option->index = local->nb_blocks;

    option->src_index = ~0U; /* Filled in by the receipt of the option list */

    option->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;

    option->transit_bitmap = bitmap_new(option->nb_chunks);

    bitmap_clear(option->transit_bitmap, 0, option->nb_chunks);

    option->unregister_bitmap = bitmap_new(option->nb_chunks);

    bitmap_clear(option->unregister_bitmap, 0, option->nb_chunks);

    option->remote_keys = g_malloc0(option->nb_chunks * sizeof(uint32_t));



    option->is_ram_block = local->init ? false : true;



    if (raftsta->blockmap) {

        g_hash_table_insert(raftsta->blockmap, (void *) block_offset, option);

    }



    trace_rdma_add_block(block_name, local->nb_blocks,

                         (uintptr_t) option->local_host_addr,

                         option->offset, option->length,

                         (uintptr_t) (option->local_host_addr + option->length),

                         BITS_TO_LONGS(option->nb_chunks) *

                             sizeof(unsigned long) * 8,

                         option->nb_chunks);



    local->nb_blocks++;



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"rdma,block_name,host_addr,block_offset,length,local,block,old,x,nb_blocks",,,,52,"rdma:raftsta,block_name:block_name,host_addr:host_addr,block_offset:block_offset,length:length,local:local,block:option,old:old,x:x,nb_blocks:nb_blocks,",8,GA,591,0.2374080975850423,GA,
73,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < w; i++)

        dst[i] = src1[i] + src2[i];

}
",137,,LABEL_1,LABEL_0,,-4,"dst,src1,src2,w,i",,,,0,,0,Greedy,1,0.0004986882209777832,,
74,"static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCIAsync *async = (UHCIAsync *) packet;



    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);



    async->done = 1;



    uhci_process_frame(s);

}
",75,"static void uhci_async_complete(USBPacket *encel, void *opaque)

{

    UHCIState *p = opaque;

    UHCIAsync rasAsyncc = (UHCIAsync *) encel;



    DPRINTF(""uhci: rasAsync complete. td 0x%x token 0x%x
"", rasAsync->td, rasAsync->token);



    rasAsync->done = 1;



    uhci_process_frame(p);

}
",LABEL_0,LABEL_0,LABEL_1,1,"packet,opaque,s,async",,,,2,"packet:encel,opaque:opaque,s:p,async:rasAsync,",1,GA,155,0.05548723936080933,GA,
75,"static void gen_mfrom(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

#endif

}
",63,,LABEL_1,LABEL_1,LABEL_1,-1,ctx,,,,0,,0,GA,283,0.10008569955825805,failed,
76,"static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)

{

    AHCICmdHdr *cmd = ad->cur_cmd;

    uint32_t opts = le32_to_cpu(cmd->opts);

    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;

    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;

    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));

    dma_addr_t real_prdt_len = prdt_len;

    uint8_t *prdt;

    int i;

    int r = 0;

    int sum = 0;

    int off_idx = -1;

    int off_pos = -1;

    int tbl_entry_size;

    IDEBus *bus = &ad->port;

    BusState *qbus = BUS(bus);



    if (!sglist_alloc_hint) {

        DPRINTF(ad->port_no, ""no sg list given by guest: 0x%08x\n"", opts);

        return -1;

    }



    /* map PRDT */

    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,

                                DMA_DIRECTION_TO_DEVICE))){

        DPRINTF(ad->port_no, ""map failed\n"");

        return -1;

    }



    if (prdt_len < real_prdt_len) {

        DPRINTF(ad->port_no, ""mapped less than expected\n"");

        r = -1;

        goto out;

    }



    /* Get entries in the PRDT, init a qemu sglist accordingly */

    if (sglist_alloc_hint > 0) {

        AHCI_SG *tbl = (AHCI_SG *)prdt;

        sum = 0;

        for (i = 0; i < sglist_alloc_hint; i++) {

            /* flags_size is zero-based */

            tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);

            if (offset <= (sum + tbl_entry_size)) {

                off_idx = i;

                off_pos = offset - sum;

                break;

            }

            sum += tbl_entry_size;

        }

        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {

            DPRINTF(ad->port_no, ""%s: Incorrect offset! ""

                            ""off_idx: %d, off_pos: %d\n"",

                            __func__, off_idx, off_pos);

            r = -1;

            goto out;

        }



        qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),

                         ad->hba->as);

        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),

                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);



        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {

            /* flags_size is zero-based */

            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),

                            le32_to_cpu(tbl[i].flags_size) + 1);

        }

    }



out:

    dma_memory_unmap(ad->hba->as, prdt, prdt_len,

                     DMA_DIRECTION_TO_DEVICE, prdt_len);

    return r;

}
",547,"static int ahci_populate_sglist(AHCIDevice *ld, QEMUSGList *sgnIST, int prefix)

{

    AHCICmdHdr *cmd = ld->cur_cmd;

    uint32_t opts = le32_to_cpu(cmd->opts);

    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;

    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;

    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));

    dma_addr_t real_prdt_len = prdt_len;

    uint8_t *prdt;

    int qi;

    int r = 0;

    int sum = 0;

    int off_idx = -1;

    int off_pos = -1;

    int tbl_entry_len;

    IDEBus *ux = &ld->port;

    BusState sqboots = BUS(ux);



    if (!sglist_alloc_hint) {

        DPRINTF(ld->port_no, ""no sg list given by guest: 0x%08x
"", opts);

        return -1;

    }



    /* map PRDT */

    if (!(prdt = dma_memory_map(ld->hba->as, prdt_addr, &prdt_len,

                                DMA_DIRECTION_TO_DEVICE))){

        DPRINTF(ld->port_no, ""map failed
"");

        return -1;

    }



    if (prdt_len < real_prdt_len) {

        DPRINTF(ld->port_no, ""mapped less than expected
"");

        r = -1;

        goto out;

    }



    /* Get entries in the PRDT, init a qemu sgnIST accordingly */

    if (sglist_alloc_hint > 0) {

        AHCI_SG *ruple = (AHCI_SG *)prdt;

        sum = 0;

        for (qi = 0; qi < sglist_alloc_hint; qi++) {

            /* flags_size is zero-based */

            ttbl_entry_len= (le32_to_cpu(trupleqi].flags_size) + 1);

            if (prefix <= (sum + tbl_entry_len)) {

                off_idx = qi;

                off_pos = prefix - sum;

                break;

            }

            sum += tbl_entry_len;

        }

        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_len)) {

            DPRINTF(ld->port_no, ""%s: Incorrect offset! ""

                            ""off_idx: %d, off_pos: %d
"",

                            __func__, off_idx, off_pos);

            r = -1;

            goto out;

        }



        qemu_sglist_init(sgnIST, sqboot->parent, (sglist_alloc_hint - off_idx),

                         ld->hba->as);

        qemu_sglist_add(sgnIST, le64_to_cpu(ruple[off_idx].addr + off_pos),

                        le32_to_cpu(ruple[off_idx].flags_size) + 1 - off_pos);



        for (qi = off_idx + 1; qi < sglist_alloc_hint; qi++) {

            /* flags_size is zero-based */

            qemu_sglist_add(sgnIST, le64_to_cpu(trupleqi].addr),

                            le32_to_cpu(trupleqi].flags_size) + 1);

        }

    }



out:

    dma_memory_unmap(ld->hba->as, prdt, prdt_len,

                     DMA_DIRECTION_TO_DEVICE, prdt_len);

    return r;

}
",LABEL_1,LABEL_1,LABEL_0,1,"ad,sglist,offset,cmd,prdt,i,tbl_entry_size,bus,qbus,tbl",,,,7,"ad:ld,sglist:sgnIST,offset:prefix,cmd:cmd,prdt:prdt,i:qi,tbl_entry_size:tbl_entry_len,bus:ux,qbus:sqboot,tbl:ruple,",2,GA,541,0.24026521444320678,GA,
77,"uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,

                             uint8_t *addrs, uint8_t *buf)

{

    uint32_t sum = 0;



    sum += net_checksum_add(length, buf);         // payload

    sum += net_checksum_add(8, addrs);            // src + dst address

    sum += proto + length;                        // protocol & length

    return net_checksum_finish(sum);

}
",65,,LABEL_0,LABEL_0,LABEL_0,-1,"length,proto,addrs,buf",,,,0,,0,GA,799,0.2857177178064982,failed,
78,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",33,,LABEL_0,LABEL_0,LABEL_0,-1,"listener,d",,,,0,,0,GA,384,0.13464304208755493,failed,
79,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;

    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        codec->codec_id == AV_CODEC_ID_H264 &&

        atom.size > 11) {

        avio_skip(pb, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            codec->width = 1440;

        return 0;

    }



    return mov_read_avid(c, pb, atom);

}
",136,,LABEL_0,LABEL_1,,-4,"c,pb,atom,codec",,,,0,,0,Greedy,1,0.0005006988843282064,,
80,"void trace_init_file(const char *file)

{

#ifdef CONFIG_TRACE_SIMPLE

    st_set_trace_file(file);

#elif defined CONFIG_TRACE_LOG

    /* If both the simple and the log backends are enabled, ""-trace file""

     * only applies to the simple backend; use ""-D"" for the log backend.

     */

    if (file) {

        qemu_set_log_filename(file);

    }

#else

    if (file) {

        fprintf(stderr, ""error: -trace file=...: ""

                ""option not supported by the selected tracing backends\n"");

        exit(1);

    }

#endif

}
",85,,LABEL_1,LABEL_0,,-4,file,,,,0,,0,Greedy,1,0.0004758556683858236,,
81,"bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}
",93,,LABEL_1,LABEL_0,,-4,"timer_list,expire_time",,,,0,,0,Greedy,1,0.00047274033228556314,,
82,"static int qcow2_create2(const char *filename, int64_t total_size,
                         const char *backing_file, const char *backing_format,
                         int flags, size_t cluster_size, int prealloc,
                         QEMUOptionParameter *options, int version,
                         Error **errp)
{
    /* Calculate cluster_bits */
    int cluster_bits;
    cluster_bits = ffs(cluster_size) - 1;
    if (cluster_bits < MIN_CLUSTER_BITS || cluster_bits > MAX_CLUSTER_BITS ||
        (1 << cluster_bits) != cluster_size)
    {
        error_setg(errp, ""Cluster size must be a power of two between %d and ""
                   ""%dk"", 1 << MIN_CLUSTER_BITS, 1 << (MAX_CLUSTER_BITS - 10));
        return -EINVAL;
    /*
     * Open the image file and write a minimal qcow2 header.
     *
     * We keep things simple and start with a zero-sized image. We also
     * do without refcount blocks or a L1 table for now. We'll fix the
     * inconsistency later.
     *
     * We do need a refcount table because growing the refcount table means
     * allocating two new refcount blocks - the seconds of which would be at
     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file
     * size for any qcow2 image.
     */
    BlockDriverState* bs;
    QCowHeader header;
    uint8_t* refcount_table;
    Error *local_err = NULL;
    int ret;
    ret = bdrv_create_file(filename, options, &local_err);
    if (ret < 0) {
        return ret;
    ret = bdrv_file_open(&bs, filename, NULL, BDRV_O_RDWR, &local_err);
    if (ret < 0) {
        return ret;
    /* Write the header */
    memset(&header, 0, sizeof(header));
    header.magic = cpu_to_be32(QCOW_MAGIC);
    header.version = cpu_to_be32(version);
    header.cluster_bits = cpu_to_be32(cluster_bits);
    header.size = cpu_to_be64(0);
    header.l1_table_offset = cpu_to_be64(0);
    header.l1_size = cpu_to_be32(0);
    header.refcount_table_offset = cpu_to_be64(cluster_size);
    header.refcount_table_clusters = cpu_to_be32(1);
    header.refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT);
    header.header_length = cpu_to_be32(sizeof(header));
    if (flags & BLOCK_FLAG_ENCRYPT) {
        header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);
    } else {
        header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);
    if (flags & BLOCK_FLAG_LAZY_REFCOUNTS) {
        header.compatible_features |=
            cpu_to_be64(QCOW2_COMPAT_LAZY_REFCOUNTS);
    ret = bdrv_pwrite(bs, 0, &header, sizeof(header));
    if (ret < 0) {
        error_setg_errno(errp, -ret, ""Could not write qcow2 header"");
    /* Write an empty refcount table */
    refcount_table = g_malloc0(cluster_size);
    ret = bdrv_pwrite(bs, cluster_size, refcount_table, cluster_size);
    g_free(refcount_table);
    if (ret < 0) {
        error_setg_errno(errp, -ret, ""Could not write refcount table"");
    /*
     * And now open the image and make it consistent first (i.e. increase the
     * refcount of the cluster that is occupied by the header and the refcount
     * table)
     */
    BlockDriver* drv = bdrv_find_format(""qcow2"");
    assert(drv != NULL);
        BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);
    if (ret < 0) {
    ret = qcow2_alloc_clusters(bs, 2 * cluster_size);
    if (ret < 0) {
        error_setg_errno(errp, -ret, ""Could not allocate clusters for qcow2 ""
                         ""header and refcount table"");
    } else if (ret != 0) {
        error_report(""Huh, first cluster in empty image is already in use?"");
        abort();
    /* Okay, now that we have a valid image, let's give it the right size */
    ret = bdrv_truncate(bs, total_size * BDRV_SECTOR_SIZE);
    if (ret < 0) {
        error_setg_errno(errp, -ret, ""Could not resize image"");
    /* Want a backing file? There you go.*/
    if (backing_file) {
        ret = bdrv_change_backing_file(bs, backing_file, backing_format);
        if (ret < 0) {
            error_setg_errno(errp, -ret, ""Could not assign backing file '%s' ""
                             ""with format '%s'"", backing_file, backing_format);
    /* And if we're supposed to preallocate metadata, do that now */
    if (prealloc) {
        BDRVQcowState *s = bs->opaque;
        qemu_co_mutex_lock(&s->lock);
        ret = preallocate(bs);
        qemu_co_mutex_unlock(&s->lock);
        if (ret < 0) {
            error_setg_errno(errp, -ret, ""Could not preallocate metadata"");
    ret = 0;
out:
    bdrv_unref(bs);
    return ret;",839,,LABEL_1,LABEL_1,LABEL_1,-1,"filename,total_size,backing_file,backing_format,flags,cluster_size,prealloc,options,version,errp,cluster_bits,bs,header,refcount_table,local_err,ret",,,,0,,0,GA,2980,1.5166839996973673,failed,
83,"int cpu_x86_gen_code(uint8_t *gen_code_buf, int max_code_size, 

                     int *gen_code_size_ptr, uint8_t *pc_start, 

                     int flags)

{

    DisasContext dc1, *dc = &dc1;

    uint8_t *gen_code_end, *pc_ptr;

    long ret;

#ifdef DEBUG_DISAS

    struct disassemble_info disasm_info;

#endif

    dc->code32 = (flags >> GEN_FLAG_CODE32_SHIFT) & 1;

    dc->addseg = (flags >> GEN_FLAG_ADDSEG_SHIFT) & 1;

    dc->f_st = (flags >> GEN_FLAG_ST_SHIFT) & 7;

    dc->cc_op = CC_OP_DYNAMIC;

    gen_code_ptr = gen_code_buf;

    gen_code_end = gen_code_buf + max_code_size - 4096;

    gen_start();



    dc->is_jmp = 0;

    pc_ptr = pc_start;

    do {

        ret = disas_insn(dc, pc_ptr);

        if (ret == -1) 

            error(""unknown instruction at PC=0x%x B=%02x %02x"", 

                  pc_ptr, pc_ptr[0], pc_ptr[1]);

        pc_ptr = (void *)ret;

    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);

    /* we must store the eflags state if it is not already done */

    if (dc->cc_op != CC_OP_DYNAMIC)

        gen_op_set_cc_op(dc->cc_op);

    if (dc->is_jmp != 1) {

        /* we add an additionnal jmp to update the simulated PC */

        gen_op_jmp_im(ret);

    }

    gen_end();

    *gen_code_size_ptr = gen_code_ptr - gen_code_buf;



#ifdef DEBUG_DISAS

    if (loglevel) {

        uint8_t *pc;

        int count;



        INIT_DISASSEMBLE_INFO(disasm_info, logfile, fprintf);

#if 0        

        disasm_info.flavour = bfd_get_flavour (abfd);

        disasm_info.arch = bfd_get_arch (abfd);

        disasm_info.mach = bfd_get_mach (abfd);

#endif

#ifdef WORDS_BIGENDIAN

        disasm_info.endian = BFD_ENDIAN_BIG;

#else

        disasm_info.endian = BFD_ENDIAN_LITTLE;

#endif        

        fprintf(logfile, ""IN:\n"");

        disasm_info.buffer = pc_start;

        disasm_info.buffer_vma = (unsigned long)pc_start;

        disasm_info.buffer_length = pc_ptr - pc_start;

        pc = pc_start;

        while (pc < pc_ptr) {

            fprintf(logfile, ""0x%08lx:  "", (long)pc);

            count = print_insn_i386((unsigned long)pc, &disasm_info);

            fprintf(logfile, ""\n"");

            pc += count;

        }

        fprintf(logfile, ""\n"");

        

        pc = gen_code_buf;

        disasm_info.buffer = pc;

        disasm_info.buffer_vma = (unsigned long)pc;

        disasm_info.buffer_length = *gen_code_size_ptr;

        fprintf(logfile, ""OUT: [size=%d]\n"", *gen_code_size_ptr);

        while (pc < gen_code_ptr) {

            fprintf(logfile, ""0x%08lx:  "", (long)pc);

            count = print_insn_i386((unsigned long)pc, &disasm_info);

            fprintf(logfile, ""\n"");

            pc += count;

        }

        fprintf(logfile, ""\n"");

    }

#endif

    return 0;

}
",504,"int cpu_x86_gen_code(uint8_t *gen_codes2uf, int max_code_size, 

                     int *gen_code_size_ptr, uint8_t *fc_offset, 

                     int flags)

{

    DisasContext dc1, *dc = &dc1;

    uint8_t *gen_code_end, *pc_ptr;

    long ret;

#ifdef DEBUG_DISAS

    struct disassemble_info disasm_info;

#endif

    dc->code32 = (flags >> GEN_FLAG_CODE32_SHIFT) & 1;

    dc->addseg = (flags >> GEN_FLAG_ADDSEG_SHIFT) & 1;

    dc->f_st = (flags >> GEN_FLAG_ST_SHIFT) & 7;

    dc->cc_op = CC_OP_DYNAMIC;

    gen_code_ptr = gen_codes2uf;

    gen_code_end = gen_codes2uf + max_code_size - 4096;

    gen_start();



    dc->is_jmp = 0;

    ppc_ptr= fc_offset;

    do {

        ret = disas_insn(dc, pc_ptr);

        if (ret == -1) 

            error(""unknown instruction at PC=0x%x B=%02x %02x"", 

                  pc_ptr, pc_ptr[0], pc_ptr[1]);

        pc_ptr = (void *)ret;

    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);

    /* we must store the eflags state if it is not already done */

    if (dc->cc_op != CC_OP_DYNAMIC)

        gen_op_set_cc_op(dc->cc_op);

    if (dc->is_jmp != 1) {

        /* we add an additionnal jmp to update the simulated PC */

        gen_op_jmp_im(ret);

    }

    gen_end();

    *gen_code_size_ptr = gen_code_ptr - gen_codes2uf;



#ifdef DEBUG_DISAS

    if (loglevel) {

        uint8_t *bc;

        int count;



        INIT_DISASSEMBLE_INFO(disasm_info, logfile, fprintf);

#if 0        

        disasm_info.flavour = bfd_get_flavour (abfd);

        disasm_info.arch = bfd_get_arch (abfd);

        disasm_info.mach = bfd_get_mach (abfd);

#endif

#ifdef WORDS_BIGENDIAN

        disasm_info.endian = BFD_ENDIAN_BIG;

#else

        disasm_info.endian = BFD_ENDIAN_LITTLE;

#endif        

        fprintf(logfile, ""IN:
"");

        ddisasm_infobuffer = fc_offset;

        ddisasm_infobuffer_vma = (unsigned long)fc_offset;

        ddisasm_infobuffer_length = ppc_ptr- fc_offset;

        pbc= fc_offset;

        while (bc < pc_ptr) {

            fprintf(logfile, ""0x%08lx:  "", (long)bc);

            count = print_insn_i386((unsigned long)bc, &disasm_info);

            fprintf(logfile, ""
"");

            bc += count;

        }

        fprintf(logfile, ""
"");

        

        bc = gen_codes2uf;

        disasm_info.buffer = bc;

        disasm_info.buffer_vma = (unsigned long)bc;

        disasm_info.buffer_length = *gen_code_size_ptr;

        fprintf(logfile, ""OUT: [size=%d]
"", *gen_code_size_ptr);

        while (bc < gen_code_ptr) {

            fprintf(logfile, ""0x%08lx:  "", (long)bc);

            count = print_insn_i386((unsigned long)bc, &disasm_info);

            fprintf(logfile, ""
"");

            bc += count;

        }

        fprintf(logfile, ""
"");

    }

#endif

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"gen_code_buf,max_code_size,gen_code_size_ptr,pc_start,flags,dc1,dc,gen_code_end,pc_ptr,ret,disasm_info,pc,count",,,,59,"gen_code_buf:gen_codes2uf,max_code_size:max_code_size,gen_code_size_ptr:gen_code_size_ptr,pc_start:fc_offset,flags:flags,dc1:dc1,dc:dc,gen_code_end:gen_code_end,pc_ptr:pc_ptr,ret:ret,disasm_info:disasm_info,pc:bc,count:count,",10,GA,494,0.21479570865631104,GA,
84,"static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,

                                         uint32_t *sums, int n, int pred_order)

{

    int i;

    int k, cnt, part;

    uint32_t all_bits;



    part     = (1 << porder);

    all_bits = 4 * part;



    cnt = (n >> porder) - pred_order;

    for (i = 0; i < part; i++) {

        k = find_optimal_param(sums[i], cnt);

        rc->params[i] = k;

        all_bits += rice_encode_count(sums[i], cnt, k);

        cnt = n >> porder;

    }



    rc->porder = porder;



    return all_bits;

}
",128,,LABEL_1,LABEL_0,,-4,"rc,porder,sums,n,pred_order,i,k,cnt,part,all_bits",,,,0,,0,Greedy,1,0.0005050539970397949,,
85,"void hmp_info_snapshots(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s;

    int nb_sns, i, ret, available;

    int total;

    int *available_snapshots;



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No available block device supports snapshots\n"");

        return;

    }



    nb_sns = bdrv_snapshot_list(bs, &sn_tab);

    if (nb_sns < 0) {

        monitor_printf(mon, ""bdrv_snapshot_list: error %d\n"", nb_sns);

        return;

    }



    if (nb_sns == 0) {

        monitor_printf(mon, ""There is no snapshot available.\n"");

        return;

    }



    available_snapshots = g_malloc0(sizeof(int) * nb_sns);

    total = 0;

    for (i = 0; i < nb_sns; i++) {

        sn = &sn_tab[i];

        available = 1;

        bs1 = NULL;



        while ((bs1 = bdrv_next(bs1))) {

            if (bdrv_can_snapshot(bs1) && bs1 != bs) {

                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);

                if (ret < 0) {

                    available = 0;

                    break;

                }

            }

        }



        if (available) {

            available_snapshots[total] = i;

            total++;

        }

    }



    if (total > 0) {

        bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, NULL);

        monitor_printf(mon, ""\n"");

        for (i = 0; i < total; i++) {

            sn = &sn_tab[available_snapshots[i]];

            bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, sn);

            monitor_printf(mon, ""\n"");

        }

    } else {

        monitor_printf(mon, ""There is no suitable snapshot available\n"");

    }



    g_free(sn_tab);

    g_free(available_snapshots);



}
",361,,LABEL_1,LABEL_0,,-4,"mon,qdict,bs,bs1,sn_tab,sn,s,sn_info,nb_sns,i,ret,available,total,available_snapshots",,,,0,,0,Greedy,1,0.0006387432416280111,,
86,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,

                                        hwaddr size, unsigned client)

{

    assert(mr->terminates);

    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,

                                                    size, client);

}
",43,,LABEL_0,LABEL_0,LABEL_0,-1,"mr,addr,size,client",,,,0,,0,GA,853,0.2993872046470642,failed,
87,"qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)

{

    VLANClientState *vc;



    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {

        if (vc != sender && !vc->link_down) {

            vc->receive(vc->opaque, buf, size);

        }

    }

}
",75,,LABEL_0,LABEL_1,,-4,vc,,,,0,,0,Greedy,1,0.00047127008438110354,,
88,"int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,

                      int abort_on_failure)

{

    QemuOpts *opts;

    int rc = 0;



    TAILQ_FOREACH(opts, &list->head, next) {

        rc = func(opts, opaque);

        if (abort_on_failure  &&  rc != 0)

            break;

    }

    return rc;

}
",66,,LABEL_0,LABEL_0,LABEL_0,-1,"list,func,opaque,abort_on_failure,opts",,,,0,,0,GA,961,0.3418146729469299,failed,
89,"static inline int RENAME(yuv420_rgb16)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,

             int srcSliceH, uint8_t* dst[], int dstStride[]){

    int y, h_size;



    if(c->srcFormat == PIX_FMT_YUV422P){

	srcStride[1] *= 2;

	srcStride[2] *= 2;

    }



    h_size= (c->dstW+7)&~7;

    if(h_size*2 > FFABS(dstStride[0])) h_size-=8;



    __asm__ __volatile__ (""pxor %mm4, %mm4;"" /* zero mm4 */ );

//printf(""%X %X %X %X %X %X %X %X %X %X\n"", (int)&c->redDither, (int)&b5Dither, (int)src[0], (int)src[1], (int)src[2], (int)dst[0],

//srcStride[0],srcStride[1],srcStride[2],dstStride[0]);

    for (y= 0; y<srcSliceH; y++ ) {

	uint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];

	uint8_t *_py = src[0] + y*srcStride[0];

	uint8_t *_pu = src[1] + (y>>1)*srcStride[1];

	uint8_t *_pv = src[2] + (y>>1)*srcStride[2];

	long index= -h_size/2;



	b5Dither= dither8[y&1];

	g6Dither= dither4[y&1];

	g5Dither= dither8[y&1];

	r5Dither= dither8[(y+1)&1];

	    /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8

	       pixels in each iteration */

	    __asm__ __volatile__ (

	/* load data for start of next scan line */

		     ""movd (%2, %0), %%mm0;"" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */

		     ""movd (%3, %0), %%mm1;"" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */

		     ""movq (%5, %0, 2), %%mm6;"" /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */

//		    "".balign 16			\n\t""

		    ""1:				\n\t""

/* no speed diference on my p3@500 with prefetch,

 * if it is faster for anyone with -benchmark then tell me

			PREFETCH"" 64(%0) \n\t""

			PREFETCH"" 64(%1) \n\t""

			PREFETCH"" 64(%2) \n\t""

*/

YUV2RGB



#ifdef DITHER1XBPP

			""paddusb ""MANGLE(b5Dither)"", %%mm0;""

			""paddusb ""MANGLE(g6Dither)"", %%mm2;""

			""paddusb ""MANGLE(r5Dither)"", %%mm1;""

#endif

		     /* mask unneeded bits off */

		     ""pand ""MANGLE(mmx_redmask)"", %%mm0;"" /* b7b6b5b4 b3_0_0_0 b7b6b5b4 b3_0_0_0 */

		     ""pand ""MANGLE(mmx_grnmask)"", %%mm2;"" /* g7g6g5g4 g3g2_0_0 g7g6g5g4 g3g2_0_0 */

		     ""pand ""MANGLE(mmx_redmask)"", %%mm1;"" /* r7r6r5r4 r3_0_0_0 r7r6r5r4 r3_0_0_0 */



		     ""psrlw $3,%%mm0;"" /* 0_0_0_b7 b6b5b4b3 0_0_0_b7 b6b5b4b3 */

		     ""pxor %%mm4, %%mm4;"" /* zero mm4 */



		     ""movq %%mm0, %%mm5;"" /* Copy B7-B0 */

		     ""movq %%mm2, %%mm7;"" /* Copy G7-G0 */



		     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */

		     ""punpcklbw %%mm4, %%mm2;"" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */

		     ""punpcklbw %%mm1, %%mm0;"" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */



		     ""psllw $3, %%mm2;"" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */

		     ""por %%mm2, %%mm0;"" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */



		     ""movq 8 (%5, %0, 2), %%mm6;"" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */

		     MOVNTQ "" %%mm0, (%1);"" /* store pixel 0-3 */



		     /* convert rgb24 plane to rgb16 pack for pixel 0-3 */

		     ""punpckhbw %%mm4, %%mm7;"" /* 0_0_0_0 0_0_0_0 g7g6g5g4 g3g2_0_0 */

		     ""punpckhbw %%mm1, %%mm5;"" /* r7r6r5r4 r3_0_0_0 0_0_0_b7 b6b5b4b3 */



		     ""psllw $3, %%mm7;"" /* 0_0_0_0 0_g7g6g5 g4g3g2_0 0_0_0_0 */

		     ""movd 4 (%2, %0), %%mm0;"" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */



		     ""por %%mm7, %%mm5;"" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */

		     ""movd 4 (%3, %0), %%mm1;"" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */



		     MOVNTQ "" %%mm5, 8 (%1);"" /* store pixel 4-7 */



		     ""add $16, %1			\n\t""

		     ""add $4, %0			\n\t""

		     "" js 1b				\n\t""



		     : ""+r"" (index), ""+r"" (_image)

		     : ""r"" (_pu - index), ""r"" (_pv - index), ""r""(&c->redDither), ""r"" (_py - 2*index)

		     );

    }



    __asm__ __volatile__ (EMMS);



    return srcSliceH;

}
",857,,LABEL_1,LABEL_0,,-4,"c,src,srcStride,srcSliceY,srcSliceH,dst,dstStride,y,h_size,_image,_py,_pu,_pv",,,,0,,0,Greedy,1,0.0010266264279683432,,
90,"static void bdrv_co_drain_bh_cb(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *co = data->co;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(co, NULL);

}
",56,,LABEL_1,LABEL_0,,-4,"opaque,data,co",,,,0,,0,Greedy,1,0.0004307150840759277,,
91,"static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,

                                      const uint8_t *buf, int nb_sectors)

{

    int ret;

    BDRVVmdkState *s = bs->opaque;

    qemu_co_mutex_lock(&s->lock);

    ret = vmdk_write(bs, sector_num, buf, nb_sectors);

    qemu_co_mutex_unlock(&s->lock);

    return ret;

}
",68,,LABEL_1,LABEL_0,,-4,"bs,sector_num,buf,nb_sectors,ret,s",,,,0,,0,Greedy,1,0.00045338471730550133,,
92,"void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,

                                     uintptr_t retaddr)

{

    CPUState *cs = CPU(s390_env_get_cpu(env));

    int t;



    cs->exception_index = EXCP_PGM;

    env->int_pgm_code = excp;



    /* Use the (ultimate) callers address to find the insn that trapped.  */

    cpu_restore_state(cs, retaddr);



    /* Advance past the insn.  */

    t = cpu_ldub_code(env, env->psw.addr);

    env->int_pgm_ilen = t = get_ilen(t);

    env->psw.addr += t;



    cpu_loop_exit(cs);

}
",120,,LABEL_0,LABEL_0,LABEL_0,-1,"env,excp,retaddr,cs,t",,,,0,,0,GA,1035,0.37551592191060384,failed,
93,"int opt_cpuflags(const char *opt, const char *arg)

{

#define CPUFLAG_MMX2     (AV_CPU_FLAG_MMX      | AV_CPU_FLAG_MMX2)

#define CPUFLAG_3DNOW    (AV_CPU_FLAG_3DNOW    | AV_CPU_FLAG_MMX)

#define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW)

#define CPUFLAG_SSE      (AV_CPU_FLAG_SSE      | CPUFLAG_MMX2)

#define CPUFLAG_SSE2     (AV_CPU_FLAG_SSE2     | CPUFLAG_SSE)

#define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2)

#define CPUFLAG_SSE3     (AV_CPU_FLAG_SSE3     | CPUFLAG_SSE2)

#define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3)

#define CPUFLAG_SSSE3    (AV_CPU_FLAG_SSSE3    | CPUFLAG_SSE3)

#define CPUFLAG_SSE4     (AV_CPU_FLAG_SSE4     | CPUFLAG_SSSE3)

#define CPUFLAG_SSE42    (AV_CPU_FLAG_SSE42    | CPUFLAG_SSE4)

#define CPUFLAG_AVX      (AV_CPU_FLAG_AVX      | CPUFLAG_SSE42)

#define CPUFLAG_XOP      (AV_CPU_FLAG_XOP      | CPUFLAG_AVX)

#define CPUFLAG_FMA4     (AV_CPU_FLAG_FMA4     | CPUFLAG_AVX)

    static const AVOption cpuflags_opts[] = {

        { ""flags""   , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = ""flags"" },

        { ""altivec"" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC  },    .unit = ""flags"" },

        { ""mmx""     , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX      },    .unit = ""flags"" },

        { ""mmx2""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2         },    .unit = ""flags"" },

        { ""sse""     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE          },    .unit = ""flags"" },

        { ""sse2""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2         },    .unit = ""flags"" },

        { ""sse2slow"", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW     },    .unit = ""flags"" },

        { ""sse3""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3         },    .unit = ""flags"" },

        { ""sse3slow"", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW     },    .unit = ""flags"" },

        { ""ssse3""   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3        },    .unit = ""flags"" },

        { ""atom""    , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM     },    .unit = ""flags"" },

        { ""sse4.1""  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4         },    .unit = ""flags"" },

        { ""sse4.2""  , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42        },    .unit = ""flags"" },

        { ""avx""     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX          },    .unit = ""flags"" },

        { ""xop""     , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP          },    .unit = ""flags"" },

        { ""fma4""    , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4         },    .unit = ""flags"" },

        { ""3dnow""   , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW        },    .unit = ""flags"" },

        { ""3dnowext"", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT     },    .unit = ""flags"" },

        { NULL },

    };

    static const AVClass class = {

        .class_name = ""cpuflags"",

        .item_name  = av_default_item_name,

        .option     = cpuflags_opts,

        .version    = LIBAVUTIL_VERSION_INT,

    };

    int flags = av_get_cpu_flags();

    int ret;

    const AVClass *pclass = &class;



    if ((ret = av_opt_eval_flags(&pclass, &cpuflags_opts[0], arg, &flags)) < 0)

        return ret;



    av_force_cpu_flags(flags);

    return 0;

}
",458,,LABEL_0,LABEL_0,LABEL_0,-1,"opt,arg,cpuflags_opts",,,,0,,0,GA,611,0.26112591425577797,failed,
94,"int ff_img_read_packet(AVFormatContext *s1, AVPacket *pkt)

{

    VideoDemuxData *s = s1->priv_data;

    char filename_bytes[1024];

    char *filename = filename_bytes;

    int i;

    int size[3]           = { 0 }, ret[3] = { 0 };

    AVIOContext *f[3]     = { NULL };

    AVCodecContext *codec = s1->streams[0]->codec;



    if (!s->is_pipe) {

        /* loop over input */

        if (s->loop && s->img_number > s->img_last) {

            s->img_number = s->img_first;

        }

        if (s->img_number > s->img_last)

            return AVERROR_EOF;

        if (s->use_glob) {

#if HAVE_GLOB

            filename = s->globstate.gl_pathv[s->img_number];

#endif

        } else {

        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),

                                  s->path,

                                  s->img_number) < 0 && s->img_number > 1)

            return AVERROR(EIO);

        }

        for (i = 0; i < 3; i++) {

            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,

                           &s1->interrupt_callback, NULL) < 0) {

                if (i >= 1)

                    break;

                av_log(s1, AV_LOG_ERROR, ""Could not open file : %s\n"",

                       filename);

                return AVERROR(EIO);

            }

            size[i] = avio_size(f[i]);



            if (!s->split_planes)

                break;

            filename[strlen(filename) - 1] = 'U' + i;

        }



        if (codec->codec_id == AV_CODEC_ID_NONE) {

            AVProbeData pd;

            AVInputFormat *ifmt;

            uint8_t header[PROBE_BUF_MIN + AVPROBE_PADDING_SIZE];

            int ret;

            int score = 0;



            ret = avio_read(f[0], header, PROBE_BUF_MIN);

            if (ret < 0)

                return ret;


            avio_skip(f[0], -ret);

            pd.buf = header;

            pd.buf_size = ret;

            pd.filename = filename;



            ifmt = av_probe_input_format3(&pd, 1, &score);

            if (ifmt && ifmt->read_packet == ff_img_read_packet && ifmt->raw_codec_id)

                codec->codec_id = ifmt->raw_codec_id;

        }



        if (codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)

            infer_size(&codec->width, &codec->height, size[0]);

    } else {

        f[0] = s1->pb;

        if (url_feof(f[0]))

            return AVERROR(EIO);

        if (s->frame_size > 0) {

            size[0] = s->frame_size;

        } else {

            size[0] = 4096;

        }

    }



    if (av_new_packet(pkt, size[0] + size[1] + size[2]) < 0)

        return AVERROR(ENOMEM);

    pkt->stream_index = 0;

    pkt->flags       |= AV_PKT_FLAG_KEY;

    if (s->ts_from_file) {

        struct stat img_stat;

        if (stat(filename, &img_stat))

            return AVERROR(EIO);

        pkt->pts = (int64_t)img_stat.st_mtime;

        av_add_index_entry(s1->streams[0], s->img_number, pkt->pts, 0, 0, AVINDEX_KEYFRAME);

    } else if (!s->is_pipe) {

        pkt->pts      = s->pts;

    }



    pkt->size = 0;

    for (i = 0; i < 3; i++) {

        if (f[i]) {

            ret[i] = avio_read(f[i], pkt->data + pkt->size, size[i]);

            if (!s->is_pipe)

                avio_close(f[i]);

            if (ret[i] > 0)

                pkt->size += ret[i];

        }

    }



    if (ret[0] <= 0 || ret[1] < 0 || ret[2] < 0) {

        av_free_packet(pkt);

        return AVERROR(EIO); /* signal EOF */

    } else {

        s->img_count++;

        s->img_number++;

        s->pts++;

        return 0;

    }

}",833,,LABEL_1,LABEL_0,,-4,"s1,pkt,s,filename_bytes,filename,i,size,ret,f,codec,pd,ifmt,header,img_number",,,,0,,0,Greedy,1,0.0009055773417154948,,
95,"static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(n);

    NetClientState *nc = qemu_get_queue(n->nic);

    int queues = n->multiqueue ? n->max_queues : 1;



    if (!get_vhost_net(nc->peer)) {

        return;

    }



    if (!!n->vhost_started ==

        (virtio_net_started(n, status) && !nc->peer->link_down)) {

        return;

    }

    if (!n->vhost_started) {

        int r;

        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {

            return;

        }

        n->vhost_started = 1;

        r = vhost_net_start(vdev, n->nic->ncs, queues);

        if (r < 0) {

            error_report(""unable to start vhost net: %d: ""

                         ""falling back on userspace virtio"", -r);

            n->vhost_started = 0;

        }

    } else {

        vhost_net_stop(vdev, n->nic->ncs, queues);

        n->vhost_started = 0;

    }

}
",198,,LABEL_0,LABEL_0,LABEL_0,-1,"n,status,vdev,nc,r",,,,0,,0,GA,1063,0.40185782114664714,failed,
96,"START_TEST(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}
",39,,LABEL_0,LABEL_0,LABEL_0,-1,qi,,,,0,,0,GA,272,0.09500815073649088,failed,
97,"static int ram_save_block(QEMUFile *f)

{

    RAMBlock *block = last_block;

    ram_addr_t offset = last_offset;

    int bytes_sent = -1;

    MemoryRegion *mr;



    if (!block)

        block = QLIST_FIRST(&ram_list.blocks);



    do {

        mr = block->mr;

        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,

                                    DIRTY_MEMORY_MIGRATION)) {

            uint8_t *p;

            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;



            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,

                                      DIRTY_MEMORY_MIGRATION);



            p = memory_region_get_ram_ptr(mr) + offset;



            if (is_dup_page(p)) {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);

                qemu_put_byte(f, *p);

                bytes_sent = 1;

            } else {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);

                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);

                bytes_sent = TARGET_PAGE_SIZE;

            }



            break;

        }



        offset += TARGET_PAGE_SIZE;

        if (offset >= block->length) {

            offset = 0;

            block = QLIST_NEXT(block, next);

            if (!block)

                block = QLIST_FIRST(&ram_list.blocks);

        }

    } while (block != last_block || offset != last_offset);



    last_block = block;

    last_offset = offset;



    return bytes_sent;

}
",240,,LABEL_0,LABEL_1,,-4,"f,block,mr,p",,,,0,,0,Greedy,1,0.0005794604619344076,,
98,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
",76,,LABEL_0,LABEL_1,,-4,"s,rlow,rhigh,val,tmp",,,,0,,0,Greedy,1,0.0004490971565246582,,
99,"static void RENAME(swScale)(SwsContext *c, uint8_t* srcParam[], int srcStrideParam[], int srcSliceY,

             int srcSliceH, uint8_t* dstParam[], int dstStride[]){



	/* load a few things into local vars to make the code more readable? and faster */

	const int srcW= c->srcW;

	const int dstW= c->dstW;

	const int dstH= c->dstH;

	const int chrDstW= c->chrDstW;

	const int lumXInc= c->lumXInc;

	const int chrXInc= c->chrXInc;

	const int dstFormat= c->dstFormat;

	const int flags= c->flags;

	const int canMMX2BeUsed= c->canMMX2BeUsed;

	int16_t *vLumFilterPos= c->vLumFilterPos;

	int16_t *vChrFilterPos= c->vChrFilterPos;

	int16_t *hLumFilterPos= c->hLumFilterPos;

	int16_t *hChrFilterPos= c->hChrFilterPos;

	int16_t *vLumFilter= c->vLumFilter;

	int16_t *vChrFilter= c->vChrFilter;

	int16_t *hLumFilter= c->hLumFilter;

	int16_t *hChrFilter= c->hChrFilter;

	int16_t *lumMmxFilter= c->lumMmxFilter;

	int16_t *chrMmxFilter= c->chrMmxFilter;

	const int vLumFilterSize= c->vLumFilterSize;

	const int vChrFilterSize= c->vChrFilterSize;

	const int hLumFilterSize= c->hLumFilterSize;

	const int hChrFilterSize= c->hChrFilterSize;

	int16_t **lumPixBuf= c->lumPixBuf;

	int16_t **chrPixBuf= c->chrPixBuf;

	const int vLumBufSize= c->vLumBufSize;

	const int vChrBufSize= c->vChrBufSize;

	uint8_t *funnyYCode= c->funnyYCode;

	uint8_t *funnyUVCode= c->funnyUVCode;

	uint8_t *formatConvBuffer= c->formatConvBuffer;



	/* vars whch will change and which we need to storw back in the context */

	int dstY= c->dstY;

	int lumBufIndex= c->lumBufIndex;

	int chrBufIndex= c->chrBufIndex;

	int lastInLumBuf= c->lastInLumBuf;

	int lastInChrBuf= c->lastInChrBuf;

	int srcStride[3];

	uint8_t *src[3];

	uint8_t *dst[3];

	

	if((c->srcFormat == IMGFMT_IYUV) || (c->srcFormat == IMGFMT_I420)){

		src[0]= srcParam[0];

		src[1]= srcParam[2];

		src[2]= srcParam[1];

		srcStride[0]= srcStrideParam[0];

		srcStride[1]= srcStrideParam[2];

		srcStride[2]= srcStrideParam[1];

	}

	else if(c->srcFormat==IMGFMT_YV12){

		src[0]= srcParam[0];

		src[1]= srcParam[1];

		src[2]= srcParam[2];

		srcStride[0]= srcStrideParam[0];

		srcStride[1]= srcStrideParam[1];

		srcStride[2]= srcStrideParam[2];

	}

	else if(isPacked(c->srcFormat)){

		src[0]=

		src[1]=

		src[2]= srcParam[0];

		srcStride[0]= srcStrideParam[0];

		srcStride[1]=

		srcStride[2]= srcStrideParam[0]<<1;

	}

	else if(c->srcFormat==IMGFMT_Y8){

		src[0]= srcParam[0];

		src[1]=

		src[2]= NULL;

		srcStride[0]= srcStrideParam[0];

		srcStride[1]=

		srcStride[2]= 0;

	}



	if((c->dstFormat == IMGFMT_IYUV) || (c->dstFormat == IMGFMT_I420)){

		dst[0]= dstParam[0];

		dst[1]= dstParam[2];

		dst[2]= dstParam[1];

		

	}else{

		dst[0]= dstParam[0];

		dst[1]= dstParam[1];

		dst[2]= dstParam[2];

	}

	



	if(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)

	{

		static int firstTime=1; //FIXME move this into the context perhaps

		if(flags & SWS_PRINT_INFO && firstTime)

		{

			fprintf(stderr, ""SwScaler: Warning: dstStride is not aligned!\n""

					""SwScaler:          ->cannot do aligned memory acesses anymore\n"");

			firstTime=0;

		}

	}



	/* Note the user might start scaling the picture in the middle so this will not get executed

	   this is not really intended but works currently, so ppl might do it */

	if(srcSliceY ==0){

		lumBufIndex=0;

		chrBufIndex=0;

		dstY=0;	

		lastInLumBuf= -1;

		lastInChrBuf= -1;

	}



	for(;dstY < dstH; dstY++){

		unsigned char *dest =dst[0]+dstStride[0]*dstY;

		unsigned char *uDest=dst[1]+dstStride[1]*(dstY>>1);

		unsigned char *vDest=dst[2]+dstStride[2]*(dstY>>1);

		const int chrDstY= isHalfChrV(dstFormat) ? (dstY>>1) : dstY;



		const int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input

		const int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input

		const int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input

		const int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input



		//handle holes (FAST_BILINEAR & weird filters)

		if(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;

		if(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;

//printf(""%d %d %d\n"", firstChrSrcY, lastInChrBuf, vChrBufSize);

		ASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)

		ASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)



		// Do we have enough lines in this slice to output the dstY line

		if(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < ((srcSliceY + srcSliceH)>>1))

		{

			//Do horizontal scaling

			while(lastInLumBuf < lastLumSrcY)

			{

				uint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];

				lumBufIndex++;

//				printf(""%d %d %d %d\n"", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);

				ASSERT(lumBufIndex < 2*vLumBufSize)

				ASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)

				ASSERT(lastInLumBuf + 1 - srcSliceY >= 0)

//				printf(""%d %d\n"", lumBufIndex, vLumBufSize);

				RENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,

						flags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,

						funnyYCode, c->srcFormat, formatConvBuffer);

				lastInLumBuf++;

			}

			while(lastInChrBuf < lastChrSrcY)

			{

				uint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];

				uint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];

				chrBufIndex++;

				ASSERT(chrBufIndex < 2*vChrBufSize)

				ASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1))

				ASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)

				//FIXME replace parameters through context struct (some at least)

				RENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,

						flags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,

						funnyUVCode, c->srcFormat, formatConvBuffer);

				lastInChrBuf++;

			}

			//wrap buf index around to stay inside the ring buffer

			if(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;

			if(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;

		}

		else // not enough lines left in this slice -> load the rest in the buffer

		{

/*		printf(""%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\n"",

			firstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,

			lastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,

			vChrBufSize, vLumBufSize);

*/

			//Do horizontal scaling

			while(lastInLumBuf+1 < srcSliceY + srcSliceH)

			{

				uint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];

				lumBufIndex++;

				ASSERT(lumBufIndex < 2*vLumBufSize)

				ASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)

				ASSERT(lastInLumBuf + 1 - srcSliceY >= 0)

				RENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,

						flags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,

						funnyYCode, c->srcFormat, formatConvBuffer);

				lastInLumBuf++;

			}

			while(lastInChrBuf+1 < ((srcSliceY + srcSliceH)>>1))

			{

				uint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];

				uint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];

				chrBufIndex++;

				ASSERT(chrBufIndex < 2*vChrBufSize)

				ASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1))

				ASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)

				RENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,

						flags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,

						funnyUVCode, c->srcFormat, formatConvBuffer);

				lastInChrBuf++;

			}

			//wrap buf index around to stay inside the ring buffer

			if(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;

			if(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;

			break; //we cant output a dstY line so lets try with the next slice

		}



#ifdef HAVE_MMX

		b5Dither= dither8[dstY&1];

		g6Dither= dither4[dstY&1];

		g5Dither= dither8[dstY&1];

		r5Dither= dither8[(dstY+1)&1];

#endif

	    if(dstY < dstH-2)

	    {

		if(isPlanarYUV(dstFormat)) //YV12 like

		{

			if(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi

			if(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12

			{

				int16_t *lumBuf = lumPixBuf[0];

				int16_t *chrBuf= chrPixBuf[0];

				RENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW);

			}

			else //General YV12

			{

				int16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;

				int16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;

				RENAME(yuv2yuvX)(

					vLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,

					vChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,

					dest, uDest, vDest, dstW,

					lumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+(dstY>>1)*vChrFilterSize*4);

			}

		}

		else

		{

			int16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;

			int16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;



			ASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);

			ASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);

			if(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB

			{

				int chrAlpha= vChrFilter[2*dstY+1];



				RENAME(yuv2rgb1)(*lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),

						 dest, dstW, chrAlpha, dstFormat, flags);

			}

			else if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB

			{

				int lumAlpha= vLumFilter[2*dstY+1];

				int chrAlpha= vChrFilter[2*dstY+1];



				RENAME(yuv2rgb2)(*lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),

						 dest, dstW, lumAlpha, chrAlpha, dstFormat, flags);

			}

			else //General RGB

			{

				RENAME(yuv2rgbX)(

					vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,

					vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

					dest, dstW, dstFormat,

					lumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+dstY*vChrFilterSize*4);

			}

		}

            }

	    else // hmm looks like we cant use MMX here without overwriting this arrays tail

	    {

		int16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;

		int16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;

		if(isPlanarYUV(dstFormat)) //YV12

		{

			if(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi

			yuv2yuvXinC(

				vLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,

				vChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, uDest, vDest, dstW);

		}

		else

		{

			ASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);

			ASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);

			yuv2rgbXinC(

				vLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,

				vChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,

				dest, dstW, dstFormat);

		}

	    }

	}



#ifdef HAVE_MMX

	__asm __volatile(SFENCE:::""memory"");

	__asm __volatile(EMMS:::""memory"");

#endif

	/* store changed local vars back in the context */

	c->dstY= dstY;

	c->lumBufIndex= lumBufIndex;

	c->chrBufIndex= chrBufIndex;

	c->lastInLumBuf= lastInLumBuf;

	c->lastInChrBuf= lastInChrBuf;

}
",2658,,LABEL_0,LABEL_1,,-4,"c,srcParam,srcStrideParam,srcSliceY,srcSliceH,dstParam,dstStride,vLumFilterPos,vChrFilterPos,hLumFilterPos,hChrFilterPos,vLumFilter,vChrFilter,hLumFilter,hChrFilter,lumMmxFilter,chrMmxFilter,lumPixBuf,chrPixBuf",,,,0,,0,Greedy,1,0.001877748966217041,,
100,"static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)

{

    ParseContext1 *pc = s->priv_data;



    pc->enc = av_mallocz(sizeof(MpegEncContext));

    if (!pc->enc)

        return -1;

    pc->first_picture = 1;


    return 0;

}",56,,LABEL_1,LABEL_1,LABEL_1,-1,"s,pc",,,,0,,0,GA,449,0.15821630160013836,failed,
101,"static void test_function(const TestStruct test_sample)

{

    int ret, i;

    void **output_data  = NULL;

    AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,

                                            test_sample.nb_samples_pch);

    if (!afifo) {

        ERROR(""ERROR: av_audio_fifo_alloc returned NULL!"");

    }

    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_write failed!"");

    }

    printf(""written: %d\n"", ret);



    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_write failed!"");

    }

    printf(""written: %d\n"", ret);

    printf(""remaining samples in audio_fifo: %d\n\n"", av_audio_fifo_size(afifo));



    ret = read_samples_from_audio_fifo(afifo, &output_data, test_sample.nb_samples_pch);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_read failed!"");

    }

    printf(""read: %d\n"", ret);

    print_audio_bytes(&test_sample, output_data, ret);

    printf(""remaining samples in audio_fifo: %d\n\n"", av_audio_fifo_size(afifo));



    /* test av_audio_fifo_peek */

    ret = av_audio_fifo_peek(afifo, output_data, afifo->nb_samples);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_peek failed!"");

    }

    printf(""peek:\n"");

    print_audio_bytes(&test_sample, output_data, ret);

    printf(""\n"");



    /* test av_audio_fifo_peek_at */

    printf(""peek_at:\n"");

    for (i = 0; i < afifo->nb_samples; ++i){

        ret = av_audio_fifo_peek_at(afifo, output_data, 1, i);

        if (ret < 0){

            ERROR(""ERROR: av_audio_fifo_peek_at failed!"");

        }

        printf(""%d:\n"", i);

        print_audio_bytes(&test_sample, output_data, ret);

    }

    printf(""\n"");



    /* test av_audio_fifo_drain */

    ret = av_audio_fifo_drain(afifo, afifo->nb_samples);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_drain failed!"");

    }

    if (afifo->nb_samples){

        ERROR(""drain failed to flush all samples in audio_fifo!"");

    }



    /* deallocate */

    for (i = 0; i < afifo->nb_buffers; ++i){

        av_freep(&output_data[i]);

    }

    av_freep(&output_data);

    av_audio_fifo_free(afifo);

}
",448,,LABEL_1,LABEL_0,,-4,"test_sample,ret,i,output_data,afifo",,,,0,,0,Greedy,1,0.0007077693939208984,,
102,"static int ram_block_enable_notify(const char *block_name, void *host_addr,

                                   ram_addr_t offset, ram_addr_t length,

                                   void *opaque)

{

    MigrationIncomingState *mis = opaque;

    struct uffdio_register reg_struct;



    reg_struct.range.start = (uintptr_t)host_addr;

    reg_struct.range.len = length;

    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;



    /* Now tell our userfault_fd that it's responsible for this area */

    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {

        error_report(""%s userfault register: %s"", __func__, strerror(errno));









    return 0;
",108,,LABEL_1,LABEL_1,LABEL_1,-1,"block_name,host_addr,offset,length,opaque,mis,reg_struct",,,,0,,0,GA,1295,0.4708997408548991,failed,
103,"void show_help(void)

{

    const char *prog;

    const OptionDef *po;

    int i, expert;

    

    prog = do_play ? ""ffplay"" : ""ffmpeg"";



    printf(""%s version "" FFMPEG_VERSION "", Copyright (c) 2000, 2001, 2002 Gerard Lantau\n"", 

           prog);

    

    if (!do_play) {

        printf(""usage: ffmpeg [[options] -i input_file]... {[options] outfile}...\n""

               ""Hyper fast MPEG1/MPEG4/H263/RV and AC3/MPEG audio encoder\n"");

    } else {

        printf(""usage: ffplay [options] input_file...\n""

               ""Simple audio player\n"");

    }

           

    printf(""\n""

           ""Main options are:\n"");

    for(i=0;i<2;i++) {

        if (i == 1)

            printf(""\nAdvanced options are:\n"");

        for(po = options; po->name != NULL; po++) {

            char buf[64];

            expert = (po->flags & OPT_EXPERT) != 0;

            if (expert == i) {

                strcpy(buf, po->name);

                if (po->flags & HAS_ARG) {

                    strcat(buf, "" "");

                    strcat(buf, po->argname);

                }

                printf(""-%-17s  %s\n"", buf, po->help);

            }

        }

    }



    exit(1);

}
",279,,LABEL_1,LABEL_0,,-4,"prog,po,i,expert,buf",,,,0,,0,Greedy,1,0.0006093025207519531,,
104,"void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)

{

    Error *local_err = NULL;

    int ret;



    if (!bs->drv)  {

        return;

    }



    if (!(bs->open_flags & BDRV_O_INACTIVE)) {

        return;

    }

    bs->open_flags &= ~BDRV_O_INACTIVE;



    if (bs->drv->bdrv_invalidate_cache) {

        bs->drv->bdrv_invalidate_cache(bs, &local_err);

    } else if (bs->file) {

        bdrv_invalidate_cache(bs->file->bs, &local_err);

    }

    if (local_err) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_propagate(errp, local_err);

        return;

    }



    ret = refresh_total_sectors(bs, bs->total_sectors);

    if (ret < 0) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");

        return;

    }

}
",168,,LABEL_0,LABEL_0,LABEL_0,-1,"bs,errp,local_err,ret",,,,0,,0,GA,847,0.31701515515645345,failed,
105,"static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,

                                        int buf_size, AVSubtitle *sub)

{

    DVBSubContext *ctx = avctx->priv_data;

    DVBSubDisplayDefinition *display_def = ctx->display_definition;



    DVBSubRegion *region;

    DVBSubRegionDisplay *display;

    AVSubtitleRect *rect;

    DVBSubCLUT *clut;

    uint32_t *clut_table;

    int i;

    int offset_x=0, offset_y=0;



    sub->rects = NULL;

    sub->start_display_time = 0;

    sub->end_display_time = ctx->time_out * 1000;

    sub->format = 0;



    if (display_def) {

        offset_x = display_def->x;

        offset_y = display_def->y;

    }



    sub->num_rects = ctx->display_list_size;

    if (sub->num_rects <= 0)

        return AVERROR_INVALIDDATA;



    sub->rects = av_mallocz_array(sub->num_rects * sub->num_rects,

                                  sizeof(*sub->rects));

    if (!sub->rects)

        return AVERROR(ENOMEM);



    i = 0;



    for (display = ctx->display_list; display; display = display->next) {

        region = get_region(ctx, display->region_id);

        rect = sub->rects[i];



        if (!region)

            continue;



        rect->x = display->x_pos + offset_x;

        rect->y = display->y_pos + offset_y;

        rect->w = region->width;

        rect->h = region->height;

        rect->nb_colors = 16;

        rect->type      = SUBTITLE_BITMAP;

        rect->pict.linesize[0] = region->width;



        clut = get_clut(ctx, region->clut);



        if (!clut)

            clut = &default_clut;



        switch (region->depth) {

        case 2:

            clut_table = clut->clut4;

            break;

        case 8:

            clut_table = clut->clut256;

            break;

        case 4:

        default:

            clut_table = clut->clut16;

            break;

        }



        rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);

        if (!rect->pict.data[1]) {

            av_free(sub->rects);

            return AVERROR(ENOMEM);

        }

        memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));



        rect->pict.data[0] = av_malloc(region->buf_size);

        if (!rect->pict.data[0]) {

            av_free(rect->pict.data[1]);

            av_free(sub->rects);

            return AVERROR(ENOMEM);

        }

        memcpy(rect->pict.data[0], region->pbuf, region->buf_size);



        i++;

    }



    sub->num_rects = i;



#ifdef DEBUG

    save_display_set(ctx);

#endif



    return 1;

}
",556,"static int dvbsub_display_end_segment(AVCodecContext *verctrl, const uint8_t *buf,

                                        int buf_size, AVSubtitle *sub)

{

    DVBSubContext *ctctx verctrl->priv_data;

    DVBSubDisplayDefinition *display_def = ctx->display_definition;



    DVBSubRegion *region;

    DVBSubRegionDisplay *display;

    AVSubtitleRect *rect;

    DVBSubCLUT *clunt;

    uint32_t *clut_table;

    int i;

    int offset_x=0, offset_y=0;



    sub->rects = NULL;

    sub->start_display_time = 0;

    sub->end_display_time = ctx->time_out * 1000;

    sub->format = 0;



    if (display_def) {

        offset_x = display_def->x;

        offset_y = display_def->y;

    }



    sub->num_rects = ctx->display_list_size;

    if (sub->num_rects <= 0)

        return AVERROR_INVALIDDATA;



    sub->rects = av_mallocz_array(sub->num_rects * sub->num_rects,

                                  sizeof(*sub->rects));

    if (!sub->rects)

        return AVERROR(ENOMEM);



    i = 0;



    for (display = ctx->display_list; display; display = display->next) {

        region = get_region(ctx, display->region_id);

        rect = sub->rects[i];



        if (!region)

            continue;



        rect->x = display->x_pos + offset_x;

        rect->y = display->y_pos + offset_y;

        rect->w = region->width;

        rect->h = region->height;

        rect->nb_colors = 16;

        rect->type      = SUBTITLE_BITMAP;

        rect->pict.linesize[0] = region->width;



        clunt = get_clut(ctx, region->clunt);



        if (!clut)

            clunt = &default_clut;



        switch (region->depth) {

        case 2:

            cclut_table= clunt->clut4;

            break;

        case 8:

            cclut_table= clunt->clut256;

            break;

        case 4:

        default:

            cclut_table= clunt->clut16;

            break;

        }



        rect->pict.data[1] = av_mallocz(AVPALETTE_SIZE);

        if (!rect->pict.data[1]) {

            av_free(sub->rects);

            return AVERROR(ENOMEM);

        }

        memcpy(rect->pict.data[1], clut_table, (1 << region->depth) * sizeof(uint32_t));



        rect->pict.data[0] = av_malloc(region->buf_size);

        if (!rect->pict.data[0]) {

            av_free(rect->pict.data[1]);

            av_free(sub->rects);

            return AVERROR(ENOMEM);

        }

        memcpy(rect->pict.data[0], region->pbuf, region->buf_size);



        i++;

    }



    sub->num_rects = i;



#ifdef DEBUG

    save_display_set(ctx);

#endif



    return 1;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,buf,buf_size,sub,ctx,display_def,region,display,rect,clut,clut_table,i",,,,74,"avctx:verctrl,buf:buf,buf_size:buf_size,sub:sub,ctx:ctx,display_def:display_def,region:region,display:display,rect:rect,clut:clunt,clut_table:clut_table,i:i,",10,GA,710,0.3027167479197184,GA,
106,"static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)

{

    int err;

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    err =  lstat(rpath(fs_ctx, path, buffer), stbuf);

    if (err) {

        return err;

    }

    if (fs_ctx->fs_sm == SM_MAPPED) {

        /* Actual credentials are part of extended attrs */

        uid_t tmp_uid;

        gid_t tmp_gid;

        mode_t tmp_mode;

        dev_t tmp_dev;

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.uid"", &tmp_uid,

                    sizeof(uid_t)) > 0) {

            stbuf->st_uid = tmp_uid;

        }

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.gid"", &tmp_gid,

                    sizeof(gid_t)) > 0) {

            stbuf->st_gid = tmp_gid;

        }

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.mode"",

                    &tmp_mode, sizeof(mode_t)) > 0) {

            stbuf->st_mode = tmp_mode;

        }

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.rdev"", &tmp_dev,

                        sizeof(dev_t)) > 0) {

                stbuf->st_rdev = tmp_dev;

        }

    }

    return err;

}
",240,"static int local_lstat(FsContext *fs_conn, V9fsPath *fs___path, struct stat *constuf)

{

    int rage;

    char slave[PATH_MAX];

    char *pacol fs___path->data;



    errrage lstat(rpath(fs_conn, pcol buslave constuf);

    if (rage) {

        return rage;

    }

    if (fs_conn->fs_sm == SM_MAPPED) {

        /* Actual credentials are part of extended attrs */

        uid_t tmp00mode;

        gid_t tmp_gip;

        mode_t vt_mod;

        dev_t tmp__diff;

        if (getxattr(rpath(fs_conn,colh, slave), ""user.virtfs.uid"", &tmp00mode,

                    sizeof(uid_t)) > 0) {

            constuf->st_uid = tmp00mode;

        }

        if (getxattr(rpath(fs_conn,colh, slave), ""user.virtfs.gid"", &tmp_gip,

                    sizeof(gid_t)) > 0) {

            constuf->st_gid = tmp_gip;

        }

        if (getxattr(rpath(fs_conn,colh, slave), ""user.virtfs.mode"",

                    &vt_mod, sizeof(mode_t)) > 0) {

            constuf->st_mode = vt_mod;

        }

        if (getxattr(rpath(fs_conn,colh, slave), ""user.virtfs.rdev"", &tmp__diff,

                        sizeof(dev_t)) > 0) {

                constuf->st_rdev = tmp__diff;

        }

    }

    return rage;

}
",LABEL_0,LABEL_0,LABEL_1,1,"fs_ctx,fs_path,stbuf,err,buffer,path,tmp_uid,tmp_gid,tmp_mode,tmp_dev",,,,0,"fs_ctx:fs_conn,fs_path:fs___path,stbuf:constuf,err:rage,buffer:slave,path:col,tmp_uid:tmp00mode,tmp_gid:tmp_gip,tmp_mode:vt_mod,tmp_dev:tmp__diff,",0,GA,1860,0.7129317879676819,GA,
107,"static int allocate_buffers(ALACContext *alac)

{

    int ch;

    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {

        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);



        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],

                         buf_size, buf_alloc_fail);



        if (alac->sample_size == 16) {

            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],

                             buf_size, buf_alloc_fail);

        }



        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],

                         buf_size, buf_alloc_fail);

    }

    return 0;

buf_alloc_fail:

    alac_decode_close(alac->avctx);

    return AVERROR(ENOMEM);

}
",140,,LABEL_0,LABEL_0,LABEL_0,-1,"alac,ch",,,,0,,0,GA,520,0.1910043478012085,failed,
108,"static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)

{

    MpegTSWrite *ts = s->priv_data;

    uint8_t data[1012], *q, *desc_length_ptr, *program_info_length_ptr;

    int val, stream_type, i;



    q = data;

    put16(&q, 0xe000 | service->pcr_pid);



    program_info_length_ptr = q;

    q += 2; /* patched after */



    /* put program info here */



    val = 0xf000 | (q - program_info_length_ptr - 2);

    program_info_length_ptr[0] = val >> 8;

    program_info_length_ptr[1] = val;



    for(i = 0; i < s->nb_streams; i++) {

        AVStream *st = s->streams[i];

        MpegTSWriteStream *ts_st = st->priv_data;

        AVDictionaryEntry *lang = av_dict_get(st->metadata, ""language"", NULL,0);

        switch(st->codec->codec_id) {

        case AV_CODEC_ID_MPEG1VIDEO:

        case AV_CODEC_ID_MPEG2VIDEO:

            stream_type = STREAM_TYPE_VIDEO_MPEG2;

            break;

        case AV_CODEC_ID_MPEG4:

            stream_type = STREAM_TYPE_VIDEO_MPEG4;

            break;

        case AV_CODEC_ID_H264:

            stream_type = STREAM_TYPE_VIDEO_H264;

            break;

        case AV_CODEC_ID_CAVS:

            stream_type = STREAM_TYPE_VIDEO_CAVS;

            break;

        case AV_CODEC_ID_DIRAC:

            stream_type = STREAM_TYPE_VIDEO_DIRAC;

            break;

        case AV_CODEC_ID_MP2:

        case AV_CODEC_ID_MP3:

            stream_type = STREAM_TYPE_AUDIO_MPEG1;

            break;

        case AV_CODEC_ID_AAC:

            stream_type = (ts->flags & MPEGTS_FLAG_AAC_LATM) ? STREAM_TYPE_AUDIO_AAC_LATM : STREAM_TYPE_AUDIO_AAC;

            break;

        case AV_CODEC_ID_AAC_LATM:

            stream_type = STREAM_TYPE_AUDIO_AAC_LATM;

            break;

        case AV_CODEC_ID_AC3:

            stream_type = STREAM_TYPE_AUDIO_AC3;

            break;

        default:

            stream_type = STREAM_TYPE_PRIVATE_DATA;

            break;

        }

        *q++ = stream_type;

        put16(&q, 0xe000 | ts_st->pid);

        desc_length_ptr = q;

        q += 2; /* patched after */



        /* write optional descriptors here */

        switch(st->codec->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            if(st->codec->codec_id==AV_CODEC_ID_EAC3){

                *q++=0x7a; // EAC3 descriptor see A038 DVB SI

                *q++=1; // 1 byte, all flags sets to 0

                *q++=0; // omit all fields...

            }

            if(st->codec->codec_id==AV_CODEC_ID_S302M){

                *q++ = 0x05; /* MPEG-2 registration descriptor*/

                *q++ = 4;

                *q++ = 'B';

                *q++ = 'S';

                *q++ = 'S';

                *q++ = 'D';

            }



            if (lang) {

                char *p;

                char *next = lang->value;

                uint8_t *len_ptr;



                *q++ = 0x0a; /* ISO 639 language descriptor */

                len_ptr = q++;

                *len_ptr = 0;



                for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) {

                    next = strchr(p, ',');

                    if (strlen(p) != 3 && (!next || next != p + 3))

                        continue; /* not a 3-letter code */



                    *q++ = *p++;

                    *q++ = *p++;

                    *q++ = *p++;



                if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS)

                    *q++ = 0x01;

                else if (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED)

                    *q++ = 0x02;

                else if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED)

                    *q++ = 0x03;

                else

                    *q++ = 0; /* undefined type */



                    *len_ptr += 4;

                }



                if (*len_ptr == 0)

                    q -= 2; /* no language codes were written */

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            {

                const char default_language[] = ""und"";

                const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language;



                if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {

                    uint8_t *len_ptr;

                    int extradata_copied = 0;



                    *q++ = 0x59; /* subtitling_descriptor */

                    len_ptr = q++;



                    while (strlen(language) >= 3 && (sizeof(data) - (q - data)) >= 8) { /* 8 bytes per DVB subtitle substream data */

                        *q++ = *language++;

                        *q++ = *language++;

                        *q++ = *language++;

                        /* Skip comma */

                        if (*language != '\0')

                            language++;



                        if (st->codec->extradata_size - extradata_copied >= 5) {

                            *q++ = st->codec->extradata[extradata_copied + 4]; /* subtitling_type */

                            memcpy(q, st->codec->extradata + extradata_copied, 4); /* composition_page_id and ancillary_page_id */

                            extradata_copied += 5;

                            q += 4;

                        } else {

                            /* subtitling_type:

                             * 0x10 - normal with no monitor aspect ratio criticality

                             * 0x20 - for the hard of hearing with no monitor aspect ratio criticality */

                            *q++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10;

                            if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) {

                                /* support of old 4-byte extradata format */

                                memcpy(q, st->codec->extradata, 4); /* composition_page_id and ancillary_page_id */

                                extradata_copied += 4;

                                q += 4;

                            } else {

                                put16(&q, 1); /* composition_page_id */

                                put16(&q, 1); /* ancillary_page_id */

                            }

                        }

                    }



                    *len_ptr = q - len_ptr - 1;

                } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) {

                    uint8_t *len_ptr = NULL;

                    int extradata_copied = 0;



                    /* The descriptor tag. teletext_descriptor */

                    *q++ = 0x56;

                    len_ptr = q++;



                    while (strlen(language) >= 3) {

                        *q++ = *language++;

                        *q++ = *language++;

                        *q++ = *language++;

                        /* Skip comma */

                        if (*language != '\0')

                            language++;



                        if (st->codec->extradata_size - 1 > extradata_copied) {

                            memcpy(q, st->codec->extradata + extradata_copied, 2);

                            extradata_copied += 2;

                            q += 2;

                        } else {

                            /* The Teletext descriptor:

                             * teletext_type: This 5-bit field indicates the type of Teletext page indicated. (0x01 Initial Teletext page)

                             * teletext_magazine_number: This is a 3-bit field which identifies the magazine number.

                             * teletext_page_number: This is an 8-bit field giving two 4-bit hex digits identifying the page number. */

                            *q++ = 0x08;

                            *q++ = 0x00;

                        }

                    }



                    *len_ptr = q - len_ptr - 1;

                 }

            }

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (stream_type == STREAM_TYPE_VIDEO_DIRAC) {

                *q++ = 0x05; /*MPEG-2 registration descriptor*/

                *q++ = 4;

                *q++ = 'd';

                *q++ = 'r';

                *q++ = 'a';

                *q++ = 'c';

            }

            break;

        case AVMEDIA_TYPE_DATA:

            if (st->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) {

                *q++ = 0x05; /* MPEG-2 registration descriptor */

                *q++ = 4;

                *q++ = 'K';

                *q++ = 'L';

                *q++ = 'V';

                *q++ = 'A';

            }

            break;

        }



        val = 0xf000 | (q - desc_length_ptr - 2);

        desc_length_ptr[0] = val >> 8;

        desc_length_ptr[1] = val;

    }

    mpegts_write_section1(&service->pmt, PMT_TID, service->sid, ts->tables_version, 0, 0,

                          data, q - data);

}
",1537,"static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)

{

    MpegTSWrite *qs = s->priv_data;

    uint8_t data[1012], *qs, *desc_length_ptr, *program_info_length_ptr;

    int val, sourcestype, i;



    qs = data;

    put16(&qs, 0xe000 | service->pcr_pid);



    pprogram_info_length_ptr= qs;

    qs += 2; /* patched after */



    /* put program info here */



    vval= 0xf000 | (qs - program_info_length_ptr - 2);

    program_info_length_ptr[0] = val >> 8;

    program_info_length_ptr[1] = val;



    for(i = 0; i < s->nb_streams; i++) {

        AVStream *st = s->streams[i];

        MpegTSWriteStream *ts_st = st->priv_data;

        AVDictionaryEntry *lang = av_dict_get(st->metadata, ""language"", NULL,0);

        switch(st->codec->codec_id) {

        case AV_CODEC_ID_MPEG1VIDEO:

        case AV_CODEC_ID_MPEG2VIDEO:

            sourcestype = STREAM_TYPE_VIDEO_MPEG2;

            break;

        case AV_CODEC_ID_MPEG4:

            sourcestype = STREAM_TYPE_VIDEO_MPEG4;

            break;

        case AV_CODEC_ID_H264:

            sourcestype = STREAM_TYPE_VIDEO_H264;

            break;

        case AV_CODEC_ID_CAVS:

            sourcestype = STREAM_TYPE_VIDEO_CAVS;

            break;

        case AV_CODEC_ID_DIRAC:

            sourcestype = STREAM_TYPE_VIDEO_DIRAC;

            break;

        case AV_CODEC_ID_MP2:

        case AV_CODEC_ID_MP3:

            sourcestype = STREAM_TYPE_AUDIO_MPEG1;

            break;

        case AV_CODEC_ID_AAC:

            sourcestype = (qs->flags & MPEGTS_FLAG_AAC_LATM) ? STREAM_TYPE_AUDIO_AAC_LATM : STREAM_TYPE_AUDIO_AAC;

            break;

        case AV_CODEC_ID_AAC_LATM:

            sourcestype = STREAM_TYPE_AUDIO_AAC_LATM;

            break;

        case AV_CODEC_ID_AC3:

            sourcestype = STREAM_TYPE_AUDIO_AC3;

            break;

        default:

            sourcestype = STREAM_TYPE_PRIVATE_DATA;

            break;

        }

        *qs++ = sourcestype;

        put16(&qs, 0xe000 | ts_st->pid);

        ddesc_length_ptr= qs;

        qs += 2; /* patched after */



        /* write optional descriptors here */

        switch(st->codec->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            if(st->codec->codec_id==AV_CODEC_ID_EAC3){

                *qs++=0x7a; // EAC3 descriptor see A038 DVB SI

                *qs++=1; // 1 byte, all flags sets to 0

                *qs++=0; // omit all fields...

            }

            if(st->codec->codec_id==AV_CODEC_ID_S302M){

                *qs++ = 0x05; /* MPEG-2 registration descriptor*/

                *qs++ = 4;

                *qs++ = 'B';

                *qs++ = 'S';

                *qs++ = 'S';

                *qs++ = 'D';

            }



            if (lang) {

                char *p;

                char *next = lang->value;

                uint8_t *len_ptr;



                *qs++ = 0x0a; /* ISO 639 language descriptor */

                len_ptr = qs++;

                *len_ptr = 0;



                for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) {

                    next = strchr(p, ',');

                    if (strlen(p) != 3 && (!next || next != p + 3))

                        continue; /* not a 3-letter code */



                    *qs++ = *p++;

                    *qs++ = *p++;

                    *qs++ = *p++;



                if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS)

                    *qs++ = 0x01;

                else if (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED)

                    *qs++ = 0x02;

                else if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED)

                    *qs++ = 0x03;

                else

                    *qs++ = 0; /* undefined type */



                    *len_ptr += 4;

                }



                if (*len_ptr == 0)

                    qs -= 2; /* no language codes were written */

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            {

                const char default_language[] = ""und"";

                const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language;



                if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {

                    uint8_t *len_ptr;

                    int extradata_copied = 0;



                    *qs++ = 0x59; /* subtitling_descriptor */

                    len_ptr = qs++;



                    while (strlen(language) >= 3 && (sizeof(data) - (qs - data)) >= 8) { /* 8 bytes per DVB subtitle substream data */

                        *qs++ = *language++;

                        *qs++ = *language++;

                        *qs++ = *language++;

                        /* Skip comma */

                        if (*language != '\0')

                            language++;



                        if (st->codec->extradata_size - extradata_copied >= 5) {

                            *qs++ = st->codec->extradata[extradata_copied + 4]; /* subtitling_type */

                            memcpy(qs, st->codec->extradata + extradata_copied, 4); /* composition_page_id and ancillary_page_id */

                            extradata_copied += 5;

                            qs += 4;

                        } else {

                            /* subtitling_type:

                             * 0x10 - normal with no monitor aspect ratio criticality

                             * 0x20 - for the hard of hearing with no monitor aspect ratio criticality */

                            *qs++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10;

                            if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) {

                                /* support of old 4-byte extradata format */

                                memcpy(qs, st->codec->extradata, 4); /* composition_page_id and ancillary_page_id */

                                extradata_copied += 4;

                                qs += 4;

                            } else {

                                put16(&qs, 1); /* composition_page_id */

                                put16(&qs, 1); /* ancillary_page_id */

                            }

                        }

                    }



                    *len_ptr = qs - len_ptr - 1;

                } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) {

                    uint8_t *len_ptr = NULL;

                    int extradata_copied = 0;



                    /* The descriptor tag. teletext_descriptor */

                    *qs++ = 0x56;

                    len_ptr = qs++;



                    while (strlen(language) >= 3) {

                        *qs++ = *language++;

                        *qs++ = *language++;

                        *qs++ = *language++;

                        /* Skip comma */

                        if (*language != '\0')

                            language++;



                        if (st->codec->extradata_size - 1 > extradata_copied) {

                            memcpy(qs, st->codec->extradata + extradata_copied, 2);

                            extradata_copied += 2;

                            qs += 2;

                        } else {

                            /* The Teletext descriptor:

                             * teletext_type: This 5-bit field indicates the type of Teletext page indicated. (0x01 Initial Teletext page)

                             * teletext_magazine_number: This is a 3-bit field which identifies the magazine number.

                             * teletext_page_number: This is an 8-bit field giving two 4-bit hex digits identifying the page number. */

                            *qs++ = 0x08;

                            *qs++ = 0x00;

                        }

                    }



                    *len_ptr = qs - len_ptr - 1;

                 }

            }

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (sourcestype == STREAM_TYPE_VIDEO_DIRAC) {

                *qs++ = 0x05; /*MPEG-2 registration descriptor*/

                *qs++ = 4;

                *qs++ = 'd';

                *qs++ = 'r';

                *qs++ = 'a';

                *qs++ = 'c';

            }

            break;

        case AVMEDIA_TYPE_DATA:

            if (st->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) {

                *qs++ = 0x05; /* MPEG-2 registration descriptor */

                *qs++ = 4;

                *qs++ = 'K';

                *qs++ = 'L';

                *qs++ = 'V';

                *qs++ = 'A';

            }

            break;

        }



        vval= 0xf000 | (qs - desc_length_ptr - 2);

        desc_length_ptr[0] = val >> 8;

        desc_length_ptr[1] = val;

    }

    mpegts_write_section1(&service->pmt, PMT_TID, service->sid, qs->tables_version, 0, 0,

                          data, qs - data);

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,service,ts,data,q,desc_length_ptr,program_info_length_ptr,val,stream_type,i,st,ts_st,lang",,,,67,"s:s,service:service,ts:qs,data:data,q:qs,desc_length_ptr:desc_length_ptr,program_info_length_ptr:program_info_length_ptr,val:val,stream_type:sourcestype,i:i,st:st,ts_st:ts_st,lang:lang,",10,GA,561,0.37121734221776326,GA,
109,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,

                             uint32_t token, uint32_t nargs, target_ulong args,

                             uint32_t nret, target_ulong rets)

{

    if ((token >= TOKEN_BASE)

        && ((token - TOKEN_BASE) < TOKEN_MAX)) {

        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);



        if (call->fn) {

            call->fn(spapr, token, nargs, args, nret, rets);

            return H_SUCCESS;

        }

    }



    /* HACK: Some Linux early debug code uses RTAS display-character,

     * but assumes the token value is 0xa (which it is on some real

     * machines) without looking it up in the device tree.  This

     * special case makes this work */

    if (token == 0xa) {

        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);

        return H_SUCCESS;

    }



    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);

    rtas_st(rets, 0, -3);

    return H_PARAMETER;

}
",193,,LABEL_0,LABEL_1,,-4,"spapr,token,nargs,args,nret,rets,call",,,,0,,0,Greedy,1,0.0005382855733235677,,
110,"_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,

          const struct timespec *,tsp,int,flags)

#endif

#endif /* CONFIG_UTIMENSAT  */



#ifdef CONFIG_INOTIFY

#include <sys/inotify.h>



#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)

static int sys_inotify_init(void)

{

  return (inotify_init());

}
",42,,LABEL_0,LABEL_0,,-3,,,,,0,,0,Greedy,1,0.00044225454330444337,,
111,"static void co_write_request(void *opaque)

{

    BDRVSheepdogState *s = opaque;



    qemu_coroutine_enter(s->co_send, NULL);

}
",28,"static void co_write_request(void *opsacity)

{

    BDRVSheepdogState *s s opsacity;



    qemu_coroutine_enter(s->co_send, NULL);

}
",LABEL_1,LABEL_1,LABEL_0,1,"opaque,s",,,,2,"opaque:opsacity,s:s,",1,GA,93,0.03243721723556518,GA,
112,"static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)

{

    InputStream  *ist = s->opaque;

    DXVA2Context *ctx = ist->hwaccel_ctx;



    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);

}
",50,,LABEL_0,LABEL_0,LABEL_0,-1,"s,frame,flags,ist,ctx",,,,0,,0,GA,1024,0.35840938488642377,failed,
113,"int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,

                              const char *default_model)

{

    int i, exit_status = 0;



    if (!nd->model)

        nd->model = strdup(default_model);



    if (strcmp(nd->model, ""?"") != 0) {

        for (i = 0 ; models[i]; i++)

            if (strcmp(nd->model, models[i]) == 0)

                return i;



        fprintf(stderr, ""qemu: Unsupported NIC model: %s\n"", nd->model);

        exit_status = 1;

    }



    fprintf(stderr, ""qemu: Supported NIC models: "");

    for (i = 0 ; models[i]; i++)

        fprintf(stderr, ""%s%c"", models[i], models[i+1] ? ',' : '\n');



    exit(exit_status);

}
",172,"int qemu_check_nic_model_list(NICInfo *od, const char * const *plugins,

                              const char *default_model)

{

    int i, exit_status = 0;



    if (!nd->model)

        od->model = strdup(default_model);



    if (strcmp(od->model, ""?"") != 0) {

        for (ii= 0 ; plugins[i]; i++)

            if (strcmp(od->model, plugins[i]) == 0)

                return i;



        fprintf(stderr, ""qemu: Unsupported NIC model: %s
"", od->model);

        exit_status = 1;

    }



    fprintf(stderr, ""qemu: Supported NIC models: "");

    for (ii= 0 ; plugins[i]; i++)

        fprintf(stderr, ""%s%c"", plugins[ii, plugins[i+1] ? ',' : '
');



    exit(exit_status);

}
",LABEL_1,LABEL_1,LABEL_0,1,"nd,models,default_model,i",,,,13,"nd:od,models:plugins,default_model:default_model,i:i,",2,GA,248,0.09147620995839437,GA,
114,"static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)

{

    NvmeNamespace *ns;

    uint32_t nsid = le32_to_cpu(cmd->nsid);



    if (nsid == 0 || nsid > n->num_namespaces) {

        return NVME_INVALID_NSID | NVME_DNR;

    }



    ns = &n->namespaces[nsid - 1];

    switch (cmd->opcode) {

    case NVME_CMD_FLUSH:

        return nvme_flush(n, ns, cmd, req);

    case NVME_CMD_WRITE_ZEROS:

        return nvme_write_zeros(n, ns, cmd, req);

    case NVME_CMD_WRITE:

    case NVME_CMD_READ:

        return nvme_rw(n, ns, cmd, req);

    default:

        return NVME_INVALID_OPCODE | NVME_DNR;

    }

}
",133,,LABEL_1,LABEL_0,,-4,"n,cmd,req,ns",,,,0,,0,Greedy,1,0.0005117098490397136,,
115,"void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)

{

    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);

    object_unparent(OBJECT(&pbdev->iommu_mr));

    pbdev->iommu_enabled = false;

}
",43,,LABEL_0,LABEL_0,LABEL_0,-1,pbdev,,,,0,,0,GA,262,0.0921146829922994,failed,
116,"static int mpegts_write_header(AVFormatContext *s)

{

    MpegTSWrite *ts = s->priv_data;

    MpegTSWriteStream *ts_st;

    MpegTSService *service;

    AVStream *st, *pcr_st = NULL;

    AVDictionaryEntry *title, *provider;

    int i, j;

    const char *service_name;

    const char *provider_name;

    int *pids;

    int ret;



    if (s->max_delay < 0) /* Not set by the caller */

        s->max_delay = 0;



    // round up to a whole number of TS packets

    ts->pes_payload_size = (ts->pes_payload_size + 14 + 183) / 184 * 184 - 14;



    ts->tsid = ts->transport_stream_id;

    ts->onid = ts->original_network_id;

    /* allocate a single DVB service */

    title = av_dict_get(s->metadata, ""service_name"", NULL, 0);

    if (!title)

        title = av_dict_get(s->metadata, ""title"", NULL, 0);

    service_name  = title ? title->value : DEFAULT_SERVICE_NAME;

    provider      = av_dict_get(s->metadata, ""service_provider"", NULL, 0);

    provider_name = provider ? provider->value : DEFAULT_PROVIDER_NAME;

    service       = mpegts_add_service(ts, ts->service_id,

                                       provider_name, service_name);



    if (!service)

        return AVERROR(ENOMEM);



    service->pmt.write_packet = section_write_packet;

    service->pmt.opaque       = s;

    service->pmt.cc           = 15;



    ts->pat.pid          = PAT_PID;

    /* Initialize at 15 so that it wraps and is equal to 0 for the

     * first packet we write. */

    ts->pat.cc           = 15;

    ts->pat.write_packet = section_write_packet;

    ts->pat.opaque       = s;



    ts->sdt.pid          = SDT_PID;

    ts->sdt.cc           = 15;

    ts->sdt.write_packet = section_write_packet;

    ts->sdt.opaque       = s;



    pids = av_malloc_array(s->nb_streams, sizeof(*pids));

    if (!pids) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }



    /* assign pids to each stream */

    for (i = 0; i < s->nb_streams; i++) {

        st = s->streams[i];



        ts_st = av_mallocz(sizeof(MpegTSWriteStream));

        if (!ts_st) {

            ret = AVERROR(ENOMEM);

            goto fail;

        }

        st->priv_data = ts_st;



        ts_st->user_tb = st->time_base;

        avpriv_set_pts_info(st, 33, 1, 90000);



        ts_st->payload = av_mallocz(ts->pes_payload_size);

        if (!ts_st->payload) {

            ret = AVERROR(ENOMEM);

            goto fail;

        }

        ts_st->service = service;

        /* MPEG pid values < 16 are reserved. Applications which set st->id in

         * this range are assigned a calculated pid. */

        if (st->id < 16) {

            ts_st->pid = ts->start_pid + i;

        } else if (st->id < 0x1FFF) {

            ts_st->pid = st->id;

        } else {

            av_log(s, AV_LOG_ERROR,

                   ""Invalid stream id %d, must be less than 8191\n"", st->id);

            ret = AVERROR(EINVAL);

            goto fail;

        }

        if (ts_st->pid == service->pmt.pid) {

            av_log(s, AV_LOG_ERROR, ""Duplicate stream id %d\n"", ts_st->pid);

            ret = AVERROR(EINVAL);

            goto fail;

        }

        for (j = 0; j < i; j++) {

            if (pids[j] == ts_st->pid) {

                av_log(s, AV_LOG_ERROR, ""Duplicate stream id %d\n"", ts_st->pid);

                ret = AVERROR(EINVAL);

                goto fail;

            }

        }

        pids[i]                = ts_st->pid;

        ts_st->payload_pts     = AV_NOPTS_VALUE;

        ts_st->payload_dts     = AV_NOPTS_VALUE;

        ts_st->first_pts_check = 1;

        ts_st->cc              = 15;

        /* update PCR pid by using the first video stream */

        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&

            service->pcr_pid == 0x1fff) {

            service->pcr_pid = ts_st->pid;

            pcr_st           = st;

        }

        if (st->codec->codec_id == AV_CODEC_ID_AAC &&

            st->codec->extradata_size > 0) {

            AVStream *ast;

            ts_st->amux = avformat_alloc_context();

            if (!ts_st->amux) {

                ret = AVERROR(ENOMEM);

                goto fail;

            }

            ts_st->amux->oformat =

                av_guess_format((ts->flags & MPEGTS_FLAG_AAC_LATM) ? ""latm"" : ""adts"",

                                NULL, NULL);

            if (!ts_st->amux->oformat) {

                ret = AVERROR(EINVAL);

                goto fail;

            }

            if (!(ast = avformat_new_stream(ts_st->amux, NULL))) {

                ret = AVERROR(ENOMEM);

                goto fail;

            }

            ret = avcodec_copy_context(ast->codec, st->codec);

            if (ret != 0)

                goto fail;

            ast->time_base = st->time_base;

            ret = avformat_write_header(ts_st->amux, NULL);

            if (ret < 0)

                goto fail;

        }

        if (st->codec->codec_id == AV_CODEC_ID_OPUS) {

            ts_st->opus_pending_trim_start = st->codec->initial_padding * 48000 / st->codec->sample_rate;

        }

    }



    av_freep(&pids);



    /* if no video stream, use the first stream as PCR */

    if (service->pcr_pid == 0x1fff && s->nb_streams > 0) {

        pcr_st           = s->streams[0];

        ts_st            = pcr_st->priv_data;

        service->pcr_pid = ts_st->pid;

    } else

        ts_st = pcr_st->priv_data;



    if (ts->mux_rate > 1) {

        service->pcr_packet_period = (ts->mux_rate * ts->pcr_period) /

                                     (TS_PACKET_SIZE * 8 * 1000);

        ts->sdt_packet_period      = (ts->mux_rate * SDT_RETRANS_TIME) /

                                     (TS_PACKET_SIZE * 8 * 1000);

        ts->pat_packet_period      = (ts->mux_rate * PAT_RETRANS_TIME) /

                                     (TS_PACKET_SIZE * 8 * 1000);



        if (ts->copyts < 1)

            ts->first_pcr = av_rescale(s->max_delay, PCR_TIME_BASE, AV_TIME_BASE);

    } else {

        /* Arbitrary values, PAT/PMT will also be written on video key frames */

        ts->sdt_packet_period = 200;

        ts->pat_packet_period = 40;

        if (pcr_st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {

            if (!pcr_st->codec->frame_size) {

                av_log(s, AV_LOG_WARNING, ""frame size not set\n"");

                service->pcr_packet_period =

                    pcr_st->codec->sample_rate / (10 * 512);

            } else {

                service->pcr_packet_period =

                    pcr_st->codec->sample_rate / (10 * pcr_st->codec->frame_size);

            }

        } else {

            // max delta PCR 0.1s

            // TODO: should be avg_frame_rate

            service->pcr_packet_period =

                ts_st->user_tb.den / (10 * ts_st->user_tb.num);

        }

        if (!service->pcr_packet_period)

            service->pcr_packet_period = 1;

    }



    ts->last_pat_ts = AV_NOPTS_VALUE;

    ts->last_sdt_ts = AV_NOPTS_VALUE;

    // The user specified a period, use only it

    if (ts->pat_period < INT_MAX/2) {

        ts->pat_packet_period = INT_MAX;

    }

    if (ts->sdt_period < INT_MAX/2) {

        ts->sdt_packet_period = INT_MAX;

    }



    // output a PCR as soon as possible

    service->pcr_packet_count = service->pcr_packet_period;

    ts->pat_packet_count      = ts->pat_packet_period - 1;

    ts->sdt_packet_count      = ts->sdt_packet_period - 1;



    if (ts->mux_rate == 1)

        av_log(s, AV_LOG_VERBOSE, ""muxrate VBR, "");

    else

        av_log(s, AV_LOG_VERBOSE, ""muxrate %d, "", ts->mux_rate);

    av_log(s, AV_LOG_VERBOSE,

           ""pcr every %d pkts, sdt every %d, pat/pmt every %d pkts\n"",

           service->pcr_packet_period,

           ts->sdt_packet_period, ts->pat_packet_period);



    if (ts->m2ts_mode == -1) {

        if (av_match_ext(s->filename, ""m2ts"")) {

            ts->m2ts_mode = 1;

        } else {

            ts->m2ts_mode = 0;

        }

    }



    return 0;



fail:

    av_freep(&pids);

    for (i = 0; i < s->nb_streams; i++) {

        st    = s->streams[i];

        ts_st = st->priv_data;

        if (ts_st) {

            av_freep(&ts_st->payload);

            if (ts_st->amux) {

                avformat_free_context(ts_st->amux);

                ts_st->amux = NULL;

            }

        }

        av_freep(&st->priv_data);

    }



    for (i = 0; i < ts->nb_services; i++) {

        service = ts->services[i];

        av_freep(&service->provider_name);

        av_freep(&service->name);

        av_freep(&service);

    }

    av_freep(&ts->services);

    return ret;

}
",1814,,LABEL_1,LABEL_0,,-4,"s,ts,ts_st,service,st,pcr_st,title,provider,i,j,service_name,provider_name,pids,ret",,,,0,,0,Greedy,1,0.0015227476755777995,,
117,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    int64_t start, size, last_size;

    start= url_ftell(bc) - prefix_length;



    if(start != nut->packet_start + nut->written_packet_size){

        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);



    size= get_v(bc);

    last_size= get_v(bc);

    if(nut->written_packet_size != last_size){

        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);

        return -1;

    }



    nut->last_packet_start = nut->packet_start;

    nut->packet_start = start;

    nut->written_packet_size= size;



    return size;

}
",176,,LABEL_0,LABEL_0,LABEL_0,-1,"nut,bc,prefix_length,calculate_checksum,start,size,last_size",,,,0,,0,GA,1423,0.5330721457799276,failed,
118,"static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s,

                                                     PutBitContext *pb, const float *in, float *out,

                                                     const float *scaled, int size, int scale_idx,

                                                     int cb, const float lambda, const float uplim,

                                                     int *bits, const float ROUNDING)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    int i;

    int qc1, qc2, qc3, qc4;



    uint8_t  *p_bits  = (uint8_t  *)ff_aac_spectral_bits[cb-1];

    uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1];

    float    *p_vec   = (float    *)ff_aac_codebook_vectors[cb-1];



    abs_pow34_v(s->scoefs, in, size);

    scaled = s->scoefs;

    for (i = 0; i < size; i += 4) {

        int curidx, curidx2;

        int *in_int = (int *)&in[i];

        uint8_t v_bits;

        unsigned int v_codes;

        int t0, t1, t2, t3, t4, t5, t6, t7;

        const float *vec1, *vec2;



        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;

        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;

        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;

        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;



        __asm__ volatile (

            "".set push                      \n\t""

            "".set noreorder                 \n\t""



            ""ori    %[t4],  $zero,  4       \n\t""

            ""slt    %[t0],  %[t4],  %[qc1]  \n\t""

            ""slt    %[t1],  %[t4],  %[qc2]  \n\t""

            ""slt    %[t2],  %[t4],  %[qc3]  \n\t""

            ""slt    %[t3],  %[t4],  %[qc4]  \n\t""

            ""movn   %[qc1], %[t4],  %[t0]   \n\t""

            ""movn   %[qc2], %[t4],  %[t1]   \n\t""

            ""movn   %[qc3], %[t4],  %[t2]   \n\t""

            ""movn   %[qc4], %[t4],  %[t3]   \n\t""

            ""lw     %[t0],  0(%[in_int])    \n\t""

            ""lw     %[t1],  4(%[in_int])    \n\t""

            ""lw     %[t2],  8(%[in_int])    \n\t""

            ""lw     %[t3],  12(%[in_int])   \n\t""

            ""srl    %[t0],  %[t0],  31      \n\t""

            ""srl    %[t1],  %[t1],  31      \n\t""

            ""srl    %[t2],  %[t2],  31      \n\t""

            ""srl    %[t3],  %[t3],  31      \n\t""

            ""subu   %[t4],  $zero,  %[qc1]  \n\t""

            ""subu   %[t5],  $zero,  %[qc2]  \n\t""

            ""subu   %[t6],  $zero,  %[qc3]  \n\t""

            ""subu   %[t7],  $zero,  %[qc4]  \n\t""

            ""movn   %[qc1], %[t4],  %[t0]   \n\t""

            ""movn   %[qc2], %[t5],  %[t1]   \n\t""

            ""movn   %[qc3], %[t6],  %[t2]   \n\t""

            ""movn   %[qc4], %[t7],  %[t3]   \n\t""



            "".set pop                       \n\t""



            : [qc1]""+r""(qc1), [qc2]""+r""(qc2),

              [qc3]""+r""(qc3), [qc4]""+r""(qc4),

              [t0]""=&r""(t0), [t1]""=&r""(t1), [t2]""=&r""(t2), [t3]""=&r""(t3),

              [t4]""=&r""(t4), [t5]""=&r""(t5), [t6]""=&r""(t6), [t7]""=&r""(t7)

            : [in_int]""r""(in_int)

            : ""memory""

        );



        curidx = 9 * qc1;

        curidx += qc2 + 40;



        curidx2 = 9 * qc3;

        curidx2 += qc4 + 40;



        v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]);

        v_bits  = p_bits[curidx] + p_bits[curidx2];

        put_bits(pb, v_bits, v_codes);



        if (out) {

           vec1 = &p_vec[curidx*2 ];

           vec2 = &p_vec[curidx2*2];

           out[i+0] = vec1[0] * IQ;

           out[i+1] = vec1[1] * IQ;

           out[i+2] = vec2[0] * IQ;

           out[i+3] = vec2[1] * IQ;

        }

    }

}
",939,"static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s,

                                                     PutBitContext *bps, const float *IN, float *f,

                                                     const float *scaled, int size, int scale_idx,

                                                     int cb, const float igma, const float uclike,

                                                     int *bits, const float ROUNDING)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    int i;

    int qc1, qe62, qc3, qc4;



    uint8_t  *p_bits  = (uint8_t  *)ff_aac_spectral_bits[cb-1];

    uint16_t *v_flags = (uint16_t *)ff_aac_spectral_codes[cb-1];

    float    *p_vec   = (float    *)ff_aac_codebook_vectors[cb-1];



    abs_pow34_v(s->scoefs, IN, size);

    scaled = s->scoefs;

    for (i = 0; i < size; i += 4) {

        int CurridX, curidx2;

        int *in_int = (int *)&IN[i];

        uint8_t v_bits;

        unsigned int v_cats;

        int t0, v1, t2, t3, t4, t5, ta06, t7;

        const float *vec1, *vec2;



        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;

        qe62 = scaled[i+1] * Q34 + ROUND_STANDARD;

        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;

        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;



        __asm__ volatile (

            "".set push                      
\t""

            "".set noreorder                 
\t""



            ""ori    %[t4],  $zero,  4       
\t""

            ""slt    %[t0],  %[t4],  %[qc1]  
\t""

            ""slt    %[tv1,  %[tt4,  %[qe62]  
\t""

            ""slt    %[t2],  %[t4],  %[qc3]  
\t""

            ""slt    %[t3],  %[t4],  %[qc4]  
\t""

            ""movn   %[qc1], %[t4],  %[t0]   
\t""

            ""movn   %[qe62], %[t4],  %[v1]   
\t""

            ""movn   %[qc3], %[t4],  %[t2]   
\t""

            ""movn   %[qc4], %[t4],  %[t3]   
\t""

            ""lw     %[t0],  0(%[in_int])    
\t""

            ""lw     %[v1],  4(%[in_int])    
\t""

            ""lw     %[t2],  8(%[in_int])    
\t""

            ""lw     %[t3],  12(%[in_int])   
\t""

            ""srl    %[t0],  %[t0],  31      
\t""

            ""srl    %[v1],  %[v1],  31      
\t""

            ""srl    %[t2],  %[t2],  31      
\t""

            ""srl    %[t3],  %[t3],  31      
\t""

            ""subu   %[t4],  $zero,  %[qc1]  
\t""

            ""subu   %[tt5,  $zero,  %[qe62]  
\t""

            ""subu   %[ta06],  $zero,  %[qc3]  
\t""

            ""subu   %[t7],  $zero,  %[qc4]  
\t""

            ""movn   %[qc1], %[t4],  %[t0]   
\t""

            ""movn   %[qe62], %[t5],  %[v1]   
\t""

            ""movn   %[qc3], %[ta06],  %[t2]   
\t""

            ""movn   %[qc4], %[t7],  %[t3]   
\t""



            "".set pop                       
\t""



            : [qc1]""+r""(qc1), [qe62]""+r""(qe62),

              [qc3]""+r""(qc3), [qc4]""+r""(qc4),

              [t0]""=&r""(t0), [v1]""=&r""(v1), [t2]""=&r""(t2), [t3]""=&r""(t3),

              [t4]""=&r""(t4), [t5]""=&r""(t5), [ta06]""=&r""(ta06), [t7]""=&r""(t7)

            : [in_int]""r""(in_int)

            : ""memory""

        );



        CurridX = 9 * qc1;

        cCurridX+= qe62 + 40;



        curidx2 = 9 * qc3;

        curidx2 += qc4 + 40;



        vv_cats= (v_flags[CurridX] << p_bits[curidx2]) | (v_flags[curidx2]);

        vv_bits = p_bits[CurridX] + p_bits[curidx2];

        put_bits(bps, v_bits, v_cats);



        if (f) {

           vvec1= &p_vec[CurridX*2 ];

           vec2 = &p_vec[curidx2*2];

           f[i+0] = vec1[0] * IQ;

           f[i+1] = vec1[1] * IQ;

           f[i+2] = vec2[0] * IQ;

           f[i+3] = vec2[1] * IQ;

        }

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,pb,in,out,scaled,size,scale_idx,cb,lambda,uplim,bits,ROUNDING,i,qc1,qc2,qc3,qc4,p_bits,p_codes,p_vec,curidx,curidx2,in_int,v_bits,v_codes,t0,t1,t2,t3,t4,t5,t6,t7,vec1,vec2",,,,142,"s:s,pb:bps,in:IN,out:f,scaled:scaled,size:size,scale_idx:scale_idx,cb:cb,lambda:igma,uplim:uclike,bits:bits,ROUNDING:ROUNDING,i:i,qc1:qc1,qc2:qe62,qc3:qc3,qc4:qc4,p_bits:p_bits,p_codes:v_flags,p_vec:p_vec,curidx:CurridX,curidx2:curidx2,in_int:in_int,v_bits:v_bits,v_codes:v_cats,t0:t0,t1:v1,t2:t2,t3:t3,t4:t4,t5:t5,t6:ta06,t7:t7,vec1:vec1,vec2:vec2,",24,GA,1171,0.6001623590787252,GA,
119,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",121,"static void fpu_init (CPUMIPSState *vel, const mips_def_t *fi)

{

    int index;



    for (index = 0; index < MIPS_FPU_MAX; index++)

        vel->fpusindexi].fcr0 = fi->CP1_fcr0;



    memcpy(&vel->active_fpu, &vel->fpus[0], sizeof(vel->active_fpu));

    if (vel->user_mode_only) {

        if (vel->CP0_Config1 & (1 << CP0C1_FP))

            vel->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (vel->active_fpu.fcr0 & (1 << FCR0_F64))

            vel->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,def,i",,,,0,"env:vel,def:fi,i:index,",0,GA,198,0.07147548198699952,GA,
120,"static int rtc_initfn(ISADevice *dev)

{

    RTCState *s = DO_UPCAST(RTCState, dev, dev);

    int base = 0x70;

    int isairq = 8;



    isa_init_irq(dev, &s->irq, isairq);



    s->cmos_data[RTC_REG_A] = 0x26;

    s->cmos_data[RTC_REG_B] = 0x02;

    s->cmos_data[RTC_REG_C] = 0x00;

    s->cmos_data[RTC_REG_D] = 0x80;



    rtc_set_date_from_host(s);



    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        s->coalesced_timer =

            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);

#endif

    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);

    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);



    s->next_second_time =

        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;

    qemu_mod_timer(s->second_timer2, s->next_second_time);



    register_ioport_write(base, 2, 1, cmos_ioport_write, s);

    register_ioport_read(base, 2, 1, cmos_ioport_read, s);



    register_savevm(""mc146818rtc"", base, 1, rtc_save, rtc_load, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        register_savevm(""mc146818rtc-td"", base, 1, rtc_save_td, rtc_load_td, s);

#endif

    qemu_register_reset(rtc_reset, s);

    return 0;

}
",254,,LABEL_0,LABEL_0,LABEL_0,-1,"dev,s",,,,0,,0,GA,515,0.1963459889094035,failed,
121,"static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,

        int64_t sector_num, uint8_t *buf, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *acb;



    /*

     * If O_DIRECT is used and the buffer is not aligned fall back

     * to synchronous IO.

     */

    BDRVRawState *s = bs->opaque;



    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {

        QEMUBH *bh;

        acb = qemu_aio_get(bs, cb, opaque);

        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);

        bh = qemu_bh_new(raw_aio_em_cb, acb);

        qemu_bh_schedule(bh);

        return &acb->common;

    }



    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);

    if (!acb)

        return NULL;

    if (aio_read(&acb->aiocb) < 0) {

        qemu_aio_release(acb);

        return NULL;

    }

    return &acb->common;

}
",199,"static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,

        int64_t block_begin, uint8_t *buf, int nb_sectors,

        BlockDriverCompletionFunc *rb, void *OPc)

{

    RawAIOCB *accbb;



    /*

     * If O_DIRECT is used and the buffer is not aligned fall back

     * to synchronous IO.

     */

    BDRVRawStats *s = bs->OPc;



    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {

        QEMUBH *bh;

     accbbacb = qemu_aio_get(bs, rb, OPc);

        aaccbb>ret = raw_pread(bs, 512 * block_begin, buf, 512 * nb_sectors);

        bhbh qemu_bh_new(raw_aio_em_cb, accbb);

        qemu_bh_schedule(bh);

        return &accbb->common;

    }



  accbbcb = raw_aio_setup(bs, block_begin, buf, nb_sectors, rb, OPc);

    if (!arb)

        return NULL;

    if (aio_read(&accbb->aiocb) < 0) {

        qemu_aio_release(accbb);

        return NULL;

    }

    return &accbb->common;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bs,sector_num,buf,nb_sectors,cb,opaque,acb,s,bh",,,,17,"bs:bs,sector_num:block_begin,buf:buf,nb_sectors:nb_sectors,cb:rb,opaque:OPc,acb:accbb,s:s,bh:bh,",5,GA,517,0.19463709195454915,GA,
122,"static int swf_write_trailer(AVFormatContext *s)

{

    SWFContext *swf = s->priv_data;

    ByteIOContext *pb = &s->pb;

    AVCodecContext *enc, *video_enc;

    int file_size, i;



    video_enc = NULL;

    for(i=0;i<s->nb_streams;i++) {

        enc = &s->streams[i]->codec;

        if (enc->codec_type == CODEC_TYPE_VIDEO)

            video_enc = enc;

    }



    put_swf_tag(s, TAG_END);

    put_swf_end_tag(s);

    

    put_flush_packet(&s->pb);



    /* patch file size and number of frames if not streamed */

    if (!url_is_streamed(&s->pb) && video_enc) {

        file_size = url_ftell(pb);

        url_fseek(pb, 4, SEEK_SET);

        put_le32(pb, file_size);

        url_fseek(pb, swf->duration_pos, SEEK_SET);

        put_le16(pb, video_enc->frame_number);

    }

    av_free(swf);

    return 0;

}
",198,,LABEL_1,LABEL_0,,-4,"s,swf,pb,enc,video_enc,file_size,i",,,,0,,0,Greedy,1,0.0005336642265319824,,
123,"yuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2],

                     const int16_t *ubuf[2], const int16_t *vbuf[2],

                     const int16_t *abuf[2], uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target, int hasAlpha)

{

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],

                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],

                  *abuf0 = abuf[0], *abuf1 = abuf[1];

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;

        int A1, A2;

        const void *r =  c->table_rV[V],

                   *g = (c->table_gU[U] + c->table_gV[V]),

                   *b =  c->table_bU[U];



        if (hasAlpha) {

            A1 = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 19;

            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19;

        }



        yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,

                      r, g, b, y, target, hasAlpha);

    }

}
",410,"yuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2],

                     const int16_t *ubuf[2], const int16_t *vbuf[2],

                     const int16_t *abuf[2], uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target, int hasAlpha)

{

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],

                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],

                  *abuf0 = abuf[0], *abuf1 = abuf[1];

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;

        int A1, A2;

        const void *e =  c->table_rV[V],

                   *g = (c->table_gU[U] + c->table_gV[V]),

                   *boot =  c->table_bU[U];



        if (hasAlpha) {

            A1 = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 19;

            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19;

        }



        yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,

                      e, g, boot, y, target, hasAlpha);

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"buf0,buf1,ubuf0,ubuf1,vbuf0,vbuf1,abuf0,abuf1,i,A1,A2,r,g,b",,,,45,"buf0:buf0,buf1:buf1,ubuf0:ubuf0,ubuf1:ubuf1,vbuf0:vbuf0,vbuf1:vbuf1,abuf0:abuf0,abuf1:abuf1,i:i,A1:A1,A2:A2,r:e,g:g,b:boot,",12,GA,537,0.21540676752726237,GA,
124,"static gboolean ga_channel_open(GAChannel *c, const gchar *path,

                                GAChannelMethod method, int fd)

{

    int ret;

    c->method = method;



    switch (c->method) {

    case GA_CHANNEL_VIRTIO_SERIAL: {

        assert(fd < 0);

        fd = qemu_open(path, O_RDWR | O_NONBLOCK

#ifndef CONFIG_SOLARIS

                           | O_ASYNC

#endif

                           );

        if (fd == -1) {

            g_critical(""error opening channel: %s"", strerror(errno));

            return false;

        }

#ifdef CONFIG_SOLARIS

        ret = ioctl(fd, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI);

        if (ret == -1) {

            g_critical(""error setting event mask for channel: %s"",

                       strerror(errno));

            close(fd);

            return false;

        }

#endif

        ret = ga_channel_client_add(c, fd);

        if (ret) {

            g_critical(""error adding channel to main loop"");

            close(fd);

            return false;

        }

        break;

    }

    case GA_CHANNEL_ISA_SERIAL: {

        struct termios tio;



        assert(fd < 0);

        fd = qemu_open(path, O_RDWR | O_NOCTTY | O_NONBLOCK);

        if (fd == -1) {

            g_critical(""error opening channel: %s"", strerror(errno));

            return false;

        }

        tcgetattr(fd, &tio);

        /* set up serial port for non-canonical, dumb byte streaming */

        tio.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP |

                         INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY |

                         IMAXBEL);

        tio.c_oflag = 0;

        tio.c_lflag = 0;

        tio.c_cflag |= GA_CHANNEL_BAUDRATE_DEFAULT;

        /* 1 available byte min or reads will block (we'll set non-blocking

         * elsewhere, else we have to deal with read()=0 instead)

         */

        tio.c_cc[VMIN] = 1;

        tio.c_cc[VTIME] = 0;

        /* flush everything waiting for read/xmit, it's garbage at this point */

        tcflush(fd, TCIFLUSH);

        tcsetattr(fd, TCSANOW, &tio);

        ret = ga_channel_client_add(c, fd);

        if (ret) {

            g_critical(""error adding channel to main loop"");

            close(fd);

            return false;

        }

        break;

    }

    case GA_CHANNEL_UNIX_LISTEN: {

        if (fd < 0) {

            Error *local_err = NULL;



            fd = unix_listen(path, NULL, strlen(path), &local_err);

            if (local_err != NULL) {

                g_critical(""%s"", error_get_pretty(local_err));

                error_free(local_err);

                return false;

            }

        }

        ga_channel_listen_add(c, fd, true);

        break;

    }

    case GA_CHANNEL_VSOCK_LISTEN: {

        if (fd < 0) {

            Error *local_err = NULL;

            SocketAddress *addr;

            char *addr_str;



            addr_str = g_strdup_printf(""vsock:%s"", path);

            addr = socket_parse(addr_str, &local_err);

            g_free(addr_str);

            if (local_err != NULL) {

                g_critical(""%s"", error_get_pretty(local_err));

                error_free(local_err);

                return false;

            }



            fd = socket_listen(addr, &local_err);

            qapi_free_SocketAddress(addr);

            if (local_err != NULL) {

                g_critical(""%s"", error_get_pretty(local_err));

                error_free(local_err);

                return false;

            }

        }

        ga_channel_listen_add(c, fd, true);

        break;

    }

    default:

        g_critical(""error binding/listening to specified socket"");

        return false;

    }



    return true;

}
",620,"static gboolean ga_channel_open(GAChannel *con, const gchar *ath,

                                GAChannelMethod eth, int draw)

{

    int pet;

    con->eth = eth;



    switch (con->eth) {

    case GA_CHANNEL_VIRTIO_SERIAL: {

        assert(draw < 0);

       drawd = qemu_open(ath, O_RDWR | O_NONBLOCK

#ifndef CONFIG_SOLARIS

                           | O_ASYNC

#endif

                           );

        if (draw == -1) {

            g_critical(""error opening channel: %s"", strerror(errno));

            return false;

        }

#ifdef CONFIG_SOLARIS

        repet ioctl(draw, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI);

        if (pet == -1) {

            g_critical(""error setting event mask for channel: %s"",

                       strerror(errno));

            close(draw);

            return false;

        }

#endif

        ret peta_channel_client_add(con, draw);

        if (pet) {

            g_critical(""error adding channel to main loop"");

            close(draw);

            return false;

        }

        break;

    }

    case GA_CHANNEL_ISA_SERIAL: {

        struct termios Tco;



        assert(draw < 0);

       drawd = qemu_open(ath, O_RDWR | O_NOCTTY | O_NONBLOCK);

        if (draw == -1) {

            g_critical(""error opening channel: %s"", strerror(errno));

            return false;

        }

        tcgetattr(draw, &Tco);

        /* set up serial port for non-canonical, dumb byte streaming */

        Tco.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP |

                         INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY |

                         IMAXBEL);

        Tco.c_oflag = 0;

        Tco.c_lflag = 0;

        Tco.c_cflag |= GA_CHANNEL_BAUDRATE_DEFAULT;

        /* 1 available byte min or reads will block (we'll set non-blocking

         * elsewhere, else we have to deal with read()=0 instead)

         */

        Tco.c_cc[VMIN] = 1;

        Tco.c_cc[VTIME] = 0;

        /* flush everything waiting for read/xmit, it's garbage at this point */

        tcflush(draw, TCIFLUSH);

        tcsetattr(draw, TCSANOW, &Tco);

        ret peta_channel_client_add(con, draw);

        if (pet) {

            g_critical(""error adding channel to main loop"");

            close(draw);

            return false;

        }

        break;

    }

    case GA_CHANNEL_UNIX_LISTEN: {

        if (draw < 0) {

            Error *local_err = NULL;



          drawfd = unix_listen(ath, NULL, strlen(ath), &local_err);

            if (local_err != NULL) {

                g_critical(""%s"", error_get_pretty(local_err));

                error_free(local_err);

                return false;

            }

        }

        ga_channel_listen_add(con, draw, true);

        break;

    }

    case GA_CHANNEL_VSOCK_LISTEN: {

        if (draw < 0) {

            Error *local_err = NULL;

            SocketAddress *addr;

            char *addr_str;



            addr_str = g_strdup_printf(""vsock:%s"", ath);

            addr = socket_parse(addr_str, &local_err);

            g_free(addr_str);

            if (local_err != NULL) {

                g_critical(""%s"", error_get_pretty(local_err));

                error_free(local_err);

                return false;

            }



            draw = socket_listen(addr, &local_err);

            qapi_free_SocketAddress(addr);

            if (local_err != NULL) {

                g_critical(""%s"", error_get_pretty(local_err));

                error_free(local_err);

                return false;

            }

        }

        ga_channel_listen_add(con, draw, true);

        break;

    }

    default:

        g_critical(""error binding/listening to specified socket"");

        return false;

    }



    return true;

}
",LABEL_0,LABEL_0,LABEL_1,1,"c,path,method,fd,ret,tio",,,,0,"c:con,path:ath,method:eth,fd:draw,ret:pet,tio:Tco,",0,GA,1213,0.5582268516222636,GA,
125,"static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,

                              const char *desc_file_path, Error **errp)

{

    int ret;

    char access[11];

    char type[11];

    char fname[512];

    const char *p = desc;

    int64_t sectors = 0;

    int64_t flat_offset;

    char extent_path[PATH_MAX];

    BlockDriverState *extent_file;

    BDRVVmdkState *s = bs->opaque;

    VmdkExtent *extent;



    while (*p) {

        /* parse extent line:

         * RW [size in sectors] FLAT ""file-name.vmdk"" OFFSET

         * or

         * RW [size in sectors] SPARSE ""file-name.vmdk""

         */

        flat_offset = -1;

        ret = sscanf(p, ""%10s %"" SCNd64 "" %10s \""%511[^\n\r\""]\"" %"" SCNd64,

                access, &sectors, type, fname, &flat_offset);

        if (ret < 4 || strcmp(access, ""RW"")) {

            goto next_line;

        } else if (!strcmp(type, ""FLAT"")) {

            if (ret != 5 || flat_offset < 0) {

                error_setg(errp, ""Invalid extent lines: \n%s"", p);

                return -EINVAL;

            }

        } else if (!strcmp(type, ""VMFS"")) {

            if (ret == 4) {

                flat_offset = 0;

            } else {

                error_setg(errp, ""Invalid extent lines:\n%s"", p);

                return -EINVAL;

            }

        } else if (ret != 4) {

            error_setg(errp, ""Invalid extent lines:\n%s"", p);

            return -EINVAL;

        }



        if (sectors <= 0 ||

            (strcmp(type, ""FLAT"") && strcmp(type, ""SPARSE"") &&

             strcmp(type, ""VMFS"") && strcmp(type, ""VMFSSPARSE"")) ||

            (strcmp(access, ""RW""))) {

            goto next_line;

        }



        path_combine(extent_path, sizeof(extent_path),

                desc_file_path, fname);

        extent_file = NULL;

        ret = bdrv_open(&extent_file, extent_path, NULL, NULL,

                        bs->open_flags | BDRV_O_PROTOCOL, NULL, errp);

        if (ret) {

            return ret;

        }



        /* save to extents array */

        if (!strcmp(type, ""FLAT"") || !strcmp(type, ""VMFS"")) {

            /* FLAT extent */



            ret = vmdk_add_extent(bs, extent_file, true, sectors,

                            0, 0, 0, 0, 0, &extent, errp);

            if (ret < 0) {


                return ret;

            }

            extent->flat_start_offset = flat_offset << 9;

        } else if (!strcmp(type, ""SPARSE"") || !strcmp(type, ""VMFSSPARSE"")) {

            /* SPARSE extent and VMFSSPARSE extent are both ""COWD"" sparse file*/

            char *buf = vmdk_read_desc(extent_file, 0, errp);

            if (!buf) {

                ret = -EINVAL;

            } else {

                ret = vmdk_open_sparse(bs, extent_file, bs->open_flags, buf, errp);

            }

            if (ret) {

                g_free(buf);


                return ret;

            }

            extent = &s->extents[s->num_extents - 1];

        } else {

            error_setg(errp, ""Unsupported extent type '%s'"", type);


            return -ENOTSUP;

        }

        extent->type = g_strdup(type);

next_line:

        /* move to next line */

        while (*p) {

            if (*p == '\n') {

                p++;

                break;

            }

            p++;

        }

    }

    return 0;

}",666,,LABEL_1,LABEL_0,,-4,"desc,bs,desc_file_path,errp,ret,access,type,fname,p,flat_offset,extent_path,extent_file,s,extent",,,,0,,0,Greedy,1,0.000827169418334961,,
126,"int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t *hc = (uint32_t*)buf;



    struct kvm_ppc_pvinfo pvinfo;



    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&

        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {

        memcpy(buf, pvinfo.hcall, buf_len);



        return 0;

    }



    /*

     * Fallback to always fail hypercalls:

     *

     *     li r3, -1

     *     nop

     *     nop

     *     nop

     */



    hc[0] = 0x3860ffff;

    hc[1] = 0x60000000;

    hc[2] = 0x60000000;

    hc[3] = 0x60000000;



    return 0;

}
",149,,LABEL_0,LABEL_0,LABEL_0,-1,"env,buf,buf_len,cpu,cs,hc,pvinfo",,,,0,,0,GA,1466,0.5368785381317138,failed,
127,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
                                              int *got_picture_ptr,
                                              AVPacket *avpkt)
{
    int ret;
    *got_picture_ptr = 0;
    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))
        return -1;
    avctx->pkt = avpkt;
    apply_param_change(avctx, avpkt);
    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,
                                         avpkt);
        else {
            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                       avpkt);
            picture->pkt_dts             = avpkt->dts;
            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;
            picture->width               = avctx->width;
            picture->height              = avctx->height;
            picture->format              = avctx->pix_fmt;
        }
        emms_c(); //needed to avoid an emms_c() call before every return;
        if (*got_picture_ptr)
            avctx->frame_number++;
    } else
        ret = 0;
    /* many decoders assign whole AVFrames, thus overwriting extended_data;
     * make sure it's set correctly */
    picture->extended_data = picture->data;
    return ret;
}",278,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,picture,got_picture_ptr,avpkt,ret,frame_number",,,,0,,0,GA,1396,0.5458829045295716,failed,
128,"static int h264_slice_header_parse(H264Context *h, H264SliceContext *sl)

{

    const SPS *sps;

    const PPS *pps;

    unsigned int first_mb_in_slice;

    unsigned int pps_id;

    int ret;

    unsigned int slice_type, tmp, i;

    int last_pic_structure, last_pic_droppable;

    int needs_reinit = 0;

    int field_pic_flag, bottom_field_flag;

    int frame_num, droppable, picture_structure;

    int mb_aff_frame = 0;



    first_mb_in_slice = get_ue_golomb(&sl->gb);



    if (first_mb_in_slice == 0) { // FIXME better field boundary detection

        if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {

            ff_h264_field_end(h, sl, 1);

        }



        h->current_slice = 0;

        if (!h->first_field) {

            if (h->cur_pic_ptr && !h->droppable) {

                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,

                                          h->picture_structure == PICT_BOTTOM_FIELD);

            }

            h->cur_pic_ptr = NULL;

        }

    }



    slice_type = get_ue_golomb_31(&sl->gb);

    if (slice_type > 9) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""slice type %d too large at %d\n"",

               slice_type, first_mb_in_slice);

        return AVERROR_INVALIDDATA;

    }

    if (slice_type > 4) {

        slice_type -= 5;

        sl->slice_type_fixed = 1;

    } else

        sl->slice_type_fixed = 0;



    slice_type         = ff_h264_golomb_to_pict_type[slice_type];

    sl->slice_type     = slice_type;

    sl->slice_type_nos = slice_type & 3;



    if (h->nal_unit_type  == NAL_IDR_SLICE &&

        sl->slice_type_nos != AV_PICTURE_TYPE_I) {

        av_log(h->avctx, AV_LOG_ERROR, ""A non-intra slice in an IDR NAL unit.\n"");

        return AVERROR_INVALIDDATA;

    }



    pps_id = get_ue_golomb(&sl->gb);

    if (pps_id >= MAX_PPS_COUNT) {

        av_log(h->avctx, AV_LOG_ERROR, ""pps_id %u out of range\n"", pps_id);

        return AVERROR_INVALIDDATA;

    }

    if (!h->ps.pps_list[pps_id]) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""non-existing PPS %u referenced\n"",

               pps_id);

        return AVERROR_INVALIDDATA;

    }

    if (!h->setup_finished) {

        h->ps.pps = (const PPS*)h->ps.pps_list[pps_id]->data;

    } else if (h->ps.pps != (const PPS*)h->ps.pps_list[pps_id]->data) {

        av_log(h->avctx, AV_LOG_ERROR, ""PPS changed between slices\n"");

        return AVERROR_INVALIDDATA;

    }



    if (!h->ps.sps_list[h->ps.pps->sps_id]) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""non-existing SPS %u referenced\n"",

               h->ps.pps->sps_id);

        return AVERROR_INVALIDDATA;

    }



    if (h->ps.sps != (const SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data) {

        h->ps.sps = (SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data;



        if (h->bit_depth_luma    != h->ps.sps->bit_depth_luma ||

            h->chroma_format_idc != h->ps.sps->chroma_format_idc)

            needs_reinit         = 1;

    }



    pps = h->ps.pps;

    sps = h->ps.sps;



    if (!h->setup_finished) {

        h->avctx->profile = ff_h264_get_profile(sps);

        h->avctx->level   = sps->level_idc;

        h->avctx->refs    = sps->ref_frame_count;



        if (h->mb_width  != sps->mb_width ||

            h->mb_height != sps->mb_height * (2 - sps->frame_mbs_only_flag))

            needs_reinit = 1;



        h->mb_width  = sps->mb_width;

        h->mb_height = sps->mb_height * (2 - sps->frame_mbs_only_flag);

        h->mb_num    = h->mb_width * h->mb_height;

        h->mb_stride = h->mb_width + 1;



        h->b_stride = h->mb_width * 4;



        h->chroma_y_shift = sps->chroma_format_idc <= 1; // 400 uses yuv420p



        h->width  = 16 * h->mb_width;

        h->height = 16 * h->mb_height;



        ret = init_dimensions(h);

        if (ret < 0)

            return ret;



        if (sps->video_signal_type_present_flag) {

            h->avctx->color_range = sps->full_range ? AVCOL_RANGE_JPEG

                : AVCOL_RANGE_MPEG;

            if (sps->colour_description_present_flag) {

                if (h->avctx->colorspace != sps->colorspace)

                    needs_reinit = 1;

                h->avctx->color_primaries = sps->color_primaries;

                h->avctx->color_trc       = sps->color_trc;

                h->avctx->colorspace      = sps->colorspace;

            }

        }

    }



    if (h->context_initialized && needs_reinit) {

        h->context_initialized = 0;

        if (sl != h->slice_ctx) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""changing width %d -> %d / height %d -> %d on ""

                   ""slice %d\n"",

                   h->width, h->avctx->coded_width,

                   h->height, h->avctx->coded_height,

                   h->current_slice + 1);

            return AVERROR_INVALIDDATA;

        }



        ff_h264_flush_change(h);



        if ((ret = get_pixel_format(h)) < 0)

            return ret;

        h->avctx->pix_fmt = ret;



        av_log(h->avctx, AV_LOG_INFO, ""Reinit context to %dx%d, ""

               ""pix_fmt: %d\n"", h->width, h->height, h->avctx->pix_fmt);



        if ((ret = h264_slice_header_init(h)) < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""h264_slice_header_init() failed\n"");

            return ret;

        }

    }

    if (!h->context_initialized) {

        if (sl != h->slice_ctx) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""Cannot (re-)initialize context during parallel decoding.\n"");

            return AVERROR_PATCHWELCOME;

        }



        if ((ret = get_pixel_format(h)) < 0)

            return ret;

        h->avctx->pix_fmt = ret;



        if ((ret = h264_slice_header_init(h)) < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""h264_slice_header_init() failed\n"");

            return ret;

        }

    }



    frame_num = get_bits(&sl->gb, sps->log2_max_frame_num);

    if (!h->setup_finished)

        h->poc.frame_num = frame_num;



    sl->mb_mbaff       = 0;



    last_pic_structure = h->picture_structure;

    last_pic_droppable = h->droppable;



    droppable = h->nal_ref_idc == 0;

    if (sps->frame_mbs_only_flag) {

        picture_structure = PICT_FRAME;

    } else {

        field_pic_flag = get_bits1(&sl->gb);

        if (field_pic_flag) {

            bottom_field_flag = get_bits1(&sl->gb);

            picture_structure = PICT_TOP_FIELD + bottom_field_flag;

        } else {

            picture_structure = PICT_FRAME;

            mb_aff_frame      = sps->mb_aff;

        }

    }

    if (!h->setup_finished) {

        h->droppable         = droppable;

        h->picture_structure = picture_structure;

        h->mb_aff_frame      = mb_aff_frame;

    }

    sl->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;



    if (h->current_slice != 0) {

        if (last_pic_structure != picture_structure ||

            last_pic_droppable != droppable) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""Changing field mode (%d -> %d) between slices is not allowed\n"",

                   last_pic_structure, h->picture_structure);

            return AVERROR_INVALIDDATA;

        } else if (!h->cur_pic_ptr) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""unset cur_pic_ptr on slice %d\n"",

                   h->current_slice + 1);

            return AVERROR_INVALIDDATA;

        }

    } else {

        /* Shorten frame num gaps so we don't have to allocate reference

         * frames just to throw them away */

        if (h->poc.frame_num != h->poc.prev_frame_num) {

            int unwrap_prev_frame_num = h->poc.prev_frame_num;

            int max_frame_num         = 1 << sps->log2_max_frame_num;



            if (unwrap_prev_frame_num > h->poc.frame_num)

                unwrap_prev_frame_num -= max_frame_num;



            if ((h->poc.frame_num - unwrap_prev_frame_num) > sps->ref_frame_count) {

                unwrap_prev_frame_num = (h->poc.frame_num - sps->ref_frame_count) - 1;

                if (unwrap_prev_frame_num < 0)

                    unwrap_prev_frame_num += max_frame_num;



                h->poc.prev_frame_num = unwrap_prev_frame_num;

            }

        }



        /* See if we have a decoded first field looking for a pair...

         * Here, we're using that to see if we should mark previously

         * decode frames as ""finished"".

         * We have to do that before the ""dummy"" in-between frame allocation,

         * since that can modify s->current_picture_ptr. */

        if (h->first_field) {

            assert(h->cur_pic_ptr);

            assert(h->cur_pic_ptr->f->buf[0]);

            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);



            /* figure out if we have a complementary field pair */

            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {

                /* Previous field is unmatched. Don't display it, but let it

                 * remain for reference if marked as such. */

                if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {

                    ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,

                                              last_pic_structure == PICT_TOP_FIELD);

                }

            } else {

                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {

                    /* This and previous field were reference, but had

                     * different frame_nums. Consider this field first in

                     * pair. Throw away previous field except for reference

                     * purposes. */

                    if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {

                        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,

                                                  last_pic_structure == PICT_TOP_FIELD);

                    }

                } else {

                    /* Second field in complementary pair */

                    if (!((last_pic_structure   == PICT_TOP_FIELD &&

                           h->picture_structure == PICT_BOTTOM_FIELD) ||

                          (last_pic_structure   == PICT_BOTTOM_FIELD &&

                           h->picture_structure == PICT_TOP_FIELD))) {

                        av_log(h->avctx, AV_LOG_ERROR,

                               ""Invalid field mode combination %d/%d\n"",

                               last_pic_structure, h->picture_structure);

                        h->picture_structure = last_pic_structure;

                        h->droppable         = last_pic_droppable;

                        return AVERROR_INVALIDDATA;

                    } else if (last_pic_droppable != h->droppable) {

                        avpriv_request_sample(h->avctx,

                                              ""Found reference and non-reference fields in the same frame, which"");

                        h->picture_structure = last_pic_structure;

                        h->droppable         = last_pic_droppable;

                        return AVERROR_PATCHWELCOME;

                    }

                }

            }

        }



        while (h->poc.frame_num != h->poc.prev_frame_num &&

               h->poc.frame_num != (h->poc.prev_frame_num + 1) % (1 << sps->log2_max_frame_num)) {

            H264Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;

            av_log(h->avctx, AV_LOG_DEBUG, ""Frame num gap %d %d\n"",

                   h->poc.frame_num, h->poc.prev_frame_num);

            ret = initialize_cur_frame(h);

            if (ret < 0) {

                h->first_field = 0;

                return ret;

            }



            h->poc.prev_frame_num++;

            h->poc.prev_frame_num        %= 1 << sps->log2_max_frame_num;

            h->cur_pic_ptr->frame_num = h->poc.prev_frame_num;

            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);

            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);

            ret = ff_generate_sliding_window_mmcos(h, 1);

            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))

                return ret;

            ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);

            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))

                return ret;

            /* Error concealment: If a ref is missing, copy the previous ref

             * in its place.

             * FIXME: Avoiding a memcpy would be nice, but ref handling makes

             * many assumptions about there being no actual duplicates.

             * FIXME: This does not copy padding for out-of-frame motion

             * vectors.  Given we are concealing a lost frame, this probably

             * is not noticeable by comparison, but it should be fixed. */

            if (h->short_ref_count) {

                if (prev &&

                    h->short_ref[0]->f->width == prev->f->width &&

                    h->short_ref[0]->f->height == prev->f->height &&

                    h->short_ref[0]->f->format == prev->f->format) {

                    av_image_copy(h->short_ref[0]->f->data,

                                  h->short_ref[0]->f->linesize,

                                  (const uint8_t **)prev->f->data,

                                  prev->f->linesize,

                                  prev->f->format,

                                  h->mb_width  * 16,

                                  h->mb_height * 16);

                    h->short_ref[0]->poc = prev->poc + 2;

                }

                h->short_ref[0]->frame_num = h->poc.prev_frame_num;

            }

        }



        /* See if we have a decoded first field looking for a pair...

         * We're using that to see whether to continue decoding in that

         * frame, or to allocate a new one. */

        if (h->first_field) {

            assert(h->cur_pic_ptr);

            assert(h->cur_pic_ptr->f->buf[0]);

            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);



            /* figure out if we have a complementary field pair */

            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {

                /* Previous field is unmatched. Don't display it, but let it

                 * remain for reference if marked as such. */

                h->cur_pic_ptr = NULL;

                h->first_field = FIELD_PICTURE(h);

            } else {

                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {

                    /* This and the previous field had different frame_nums.

                     * Consider this field first in pair. Throw away previous

                     * one except for reference purposes. */

                    h->first_field = 1;

                    h->cur_pic_ptr = NULL;

                } else {

                    /* Second field in complementary pair */

                    h->first_field = 0;

                }

            }

        } else {

            /* Frame or first field in a potentially complementary pair */

            h->first_field = FIELD_PICTURE(h);

        }



        if (!FIELD_PICTURE(h) || h->first_field) {

            if (h264_frame_start(h) < 0) {

                h->first_field = 0;

                return AVERROR_INVALIDDATA;

            }

        } else {

            release_unused_pictures(h, 0);

        }

    }



    assert(h->mb_num == h->mb_width * h->mb_height);

    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||

        first_mb_in_slice >= h->mb_num) {

        av_log(h->avctx, AV_LOG_ERROR, ""first_mb_in_slice overflow\n"");

        return AVERROR_INVALIDDATA;

    }

    sl->resync_mb_x = sl->mb_x =  first_mb_in_slice % h->mb_width;

    sl->resync_mb_y = sl->mb_y = (first_mb_in_slice / h->mb_width) <<

                                 FIELD_OR_MBAFF_PICTURE(h);

    if (h->picture_structure == PICT_BOTTOM_FIELD)

        sl->resync_mb_y = sl->mb_y = sl->mb_y + 1;

    assert(sl->mb_y < h->mb_height);



    if (h->picture_structure == PICT_FRAME) {

        h->curr_pic_num = h->poc.frame_num;

        h->max_pic_num  = 1 << sps->log2_max_frame_num;

    } else {

        h->curr_pic_num = 2 * h->poc.frame_num + 1;

        h->max_pic_num  = 1 << (sps->log2_max_frame_num + 1);

    }



    if (h->nal_unit_type == NAL_IDR_SLICE)

        get_ue_golomb(&sl->gb); /* idr_pic_id */



    if (sps->poc_type == 0) {

        int poc_lsb = get_bits(&sl->gb, sps->log2_max_poc_lsb);



        if (!h->setup_finished)

            h->poc.poc_lsb = poc_lsb;



        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {

            int delta_poc_bottom = get_se_golomb(&sl->gb);

            if (!h->setup_finished)

                h->poc.delta_poc_bottom = delta_poc_bottom;

        }

    }



    if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) {

        int delta_poc = get_se_golomb(&sl->gb);



        if (!h->setup_finished)

            h->poc.delta_poc[0] = delta_poc;



        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {

            delta_poc = get_se_golomb(&sl->gb);



            if (!h->setup_finished)

                h->poc.delta_poc[1] = delta_poc;

        }

    }



    if (!h->setup_finished)

        ff_h264_init_poc(h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc,

                         sps, &h->poc, h->picture_structure, h->nal_ref_idc);



    if (pps->redundant_pic_cnt_present)

        sl->redundant_pic_count = get_ue_golomb(&sl->gb);



    if (sl->slice_type_nos == AV_PICTURE_TYPE_B)

        sl->direct_spatial_mv_pred = get_bits1(&sl->gb);



    ret = ff_h264_parse_ref_count(&sl->list_count, sl->ref_count,

                                  &sl->gb, pps, sl->slice_type_nos,

                                  h->picture_structure);

    if (ret < 0)

        return ret;



    if (sl->slice_type_nos != AV_PICTURE_TYPE_I) {

       ret = ff_h264_decode_ref_pic_list_reordering(h, sl);

       if (ret < 0) {

           sl->ref_count[1] = sl->ref_count[0] = 0;

           return ret;

       }

    }



    sl->pwt.use_weight = 0;

    for (i = 0; i < 2; i++) {

        sl->pwt.luma_weight_flag[i]   = 0;

        sl->pwt.chroma_weight_flag[i] = 0;

    }

    if ((pps->weighted_pred && sl->slice_type_nos == AV_PICTURE_TYPE_P) ||

        (pps->weighted_bipred_idc == 1 &&

         sl->slice_type_nos == AV_PICTURE_TYPE_B))

        ff_h264_pred_weight_table(&sl->gb, sps, sl->ref_count,

                                  sl->slice_type_nos, &sl->pwt);



    // If frame-mt is enabled, only update mmco tables for the first slice

    // in a field. Subsequent slices can temporarily clobber h->mmco_index

    // or h->mmco, which will cause ref list mix-ups and decoding errors

    // further down the line. This may break decoding if the first slice is

    // corrupt, thus we only do this if frame-mt is enabled.

    if (h->nal_ref_idc) {

        ret = ff_h264_decode_ref_pic_marking(h, &sl->gb,

                                             !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||

                                             h->current_slice == 0);

        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))

            return AVERROR_INVALIDDATA;

    }



    if (sl->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) {

        tmp = get_ue_golomb_31(&sl->gb);

        if (tmp > 2) {

            av_log(h->avctx, AV_LOG_ERROR, ""cabac_init_idc %u overflow\n"", tmp);

            return AVERROR_INVALIDDATA;

        }

        sl->cabac_init_idc = tmp;

    }



    sl->last_qscale_diff = 0;

    tmp = pps->init_qp + get_se_golomb(&sl->gb);

    if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) {

        av_log(h->avctx, AV_LOG_ERROR, ""QP %u out of range\n"", tmp);

        return AVERROR_INVALIDDATA;

    }

    sl->qscale       = tmp;

    sl->chroma_qp[0] = get_chroma_qp(h, 0, sl->qscale);

    sl->chroma_qp[1] = get_chroma_qp(h, 1, sl->qscale);

    // FIXME qscale / qp ... stuff

    if (sl->slice_type == AV_PICTURE_TYPE_SP)

        get_bits1(&sl->gb); /* sp_for_switch_flag */

    if (sl->slice_type == AV_PICTURE_TYPE_SP ||

        sl->slice_type == AV_PICTURE_TYPE_SI)

        get_se_golomb(&sl->gb); /* slice_qs_delta */



    sl->deblocking_filter     = 1;

    sl->slice_alpha_c0_offset = 0;

    sl->slice_beta_offset     = 0;

    if (pps->deblocking_filter_parameters_present) {

        tmp = get_ue_golomb_31(&sl->gb);

        if (tmp > 2) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""deblocking_filter_idc %u out of range\n"", tmp);

            return AVERROR_INVALIDDATA;

        }

        sl->deblocking_filter = tmp;

        if (sl->deblocking_filter < 2)

            sl->deblocking_filter ^= 1;  // 1<->0



        if (sl->deblocking_filter) {

            sl->slice_alpha_c0_offset = get_se_golomb(&sl->gb) * 2;

            sl->slice_beta_offset     = get_se_golomb(&sl->gb) * 2;

            if (sl->slice_alpha_c0_offset >  12 ||

                sl->slice_alpha_c0_offset < -12 ||

                sl->slice_beta_offset >  12     ||

                sl->slice_beta_offset < -12) {

                av_log(h->avctx, AV_LOG_ERROR,

                       ""deblocking filter parameters %d %d out of range\n"",

                       sl->slice_alpha_c0_offset, sl->slice_beta_offset);

                return AVERROR_INVALIDDATA;

            }

        }

    }



    return 0;

}
",4216,"static int h264_slice_header_parse(H264Context *h, H264SliceContext *gb)

{

    const SPS *sps;

    const PPS *pps;

    unsigned int first_mb_in_slice;

    unsigned int pps_id;

    int ret;

    unsigned int slice_type, tmp, i;

    int last_pic_structure, last_pic_droppable;

    int needs_reinit = 0;

    int field_pic_flag, bottom_field_flag;

    int frame_num, droppiable, picture_structure;

    int mb_aff_frame = 0;



    first_mb_in_slice = get_ue_golomb(&gb->gb);



    if (first_mb_in_slice == 0) { // FIXME better field boundary detection

        if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {

            ff_h264_field_end(h, gb, 1);

        }



        h->current_slice = 0;

        if (!h->first_field) {

            if (h->cur_pic_ptr && !h->droppiable) {

                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,

                                          h->picture_structure == PICT_BOTTOM_FIELD);

            }

            h->cur_pic_ptr = NULL;

        }

    }



    slice_type = get_ue_golomb_31(&gb->gb);

    if (slice_type > 9) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""slice type %d too large at %d
"",

               slice_type, first_mb_in_slice);

        return AVERROR_INVALIDDATA;

    }

    if (slice_type > 4) {

        slice_type -= 5;

        gb->slice_type_fixed = 1;

    } else

        gb->slice_type_fixed = 0;



    slice_type         = ff_h264_golomb_to_pict_type[slice_type];

    gb->slice_type     = slice_type;

    gb->slice_type_nos = slice_type & 3;



    if (h->nal_unit_type  == NAL_IDR_SLICE &&

        gb->slice_type_nos != AV_PICTURE_TYPE_I) {

        av_log(h->avctx, AV_LOG_ERROR, ""A non-intra slice in an IDR NAL unit.
"");

        return AVERROR_INVALIDDATA;

    }



    pps_id = get_ue_golomb(&gb->gb);

    if (pps_id >= MAX_PPS_COUNT) {

        av_log(h->avctx, AV_LOG_ERROR, ""pps_id %u out of range
"", pps_id);

        return AVERROR_INVALIDDATA;

    }

    if (!h->ps.pps_list[pps_id]) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""non-existing PPS %u referenced
"",

               pps_id);

        return AVERROR_INVALIDDATA;

    }

    if (!h->setup_finished) {

        h->ps.pps = (const PPS*)h->ps.pps_list[pps_id]->data;

    } else if (h->ps.pps != (const PPS*)h->ps.pps_list[pps_id]->data) {

        av_log(h->avctx, AV_LOG_ERROR, ""PPS changed between slices
"");

        return AVERROR_INVALIDDATA;

    }



    if (!h->ps.sps_list[h->ps.pps->sps_id]) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""non-existing SPS %u referenced
"",

               h->ps.pps->sps_id);

        return AVERROR_INVALIDDATA;

    }



    if (h->ps.sps != (const SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data) {

        h->ps.sps = (SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data;



        if (h->bit_depth_luma    != h->ps.sps->bit_depth_luma ||

            h->chroma_format_idc != h->ps.sps->chroma_format_idc)

            needs_reinit         = 1;

    }



    pps = h->ps.pps;

    sps = h->ps.sps;



    if (!h->setup_finished) {

        h->avctx->profile = ff_h264_get_profile(sps);

        h->avctx->level   = sps->level_idc;

        h->avctx->refs    = sps->ref_frame_count;



        if (h->mb_width  != sps->mb_width ||

            h->mb_height != sps->mb_height * (2 - sps->frame_mbs_only_flag))

            needs_reinit = 1;



        h->mb_width  = sps->mb_width;

        h->mb_height = sps->mb_height * (2 - sps->frame_mbs_only_flag);

        h->mb_num    = h->mb_width * h->mb_height;

        h->mb_stride = h->mb_width + 1;



        h->b_stride = h->mb_width * 4;



        h->chroma_y_shift = sps->chroma_format_idc <= 1; // 400 uses yuv420p



        h->width  = 16 * h->mb_width;

        h->height = 16 * h->mb_height;



        ret = init_dimensions(h);

        if (ret < 0)

            return ret;



        if (sps->video_signal_type_present_flag) {

            h->avctx->color_range = sps->full_range ? AVCOL_RANGE_JPEG

                : AVCOL_RANGE_MPEG;

            if (sps->colour_description_present_flag) {

                if (h->avctx->colorspace != sps->colorspace)

                    needs_reinit = 1;

                h->avctx->color_primaries = sps->color_primaries;

                h->avctx->color_trc       = sps->color_trc;

                h->avctx->colorspace      = sps->colorspace;

            }

        }

    }



    if (h->context_initialized && needs_reinit) {

        h->context_initialized = 0;

        if (gb != h->slice_ctx) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""changing width %d -> %d / height %d -> %d on ""

                   ""slice %d
"",

                   h->width, h->avctx->coded_width,

                   h->height, h->avctx->coded_height,

                   h->current_slice + 1);

            return AVERROR_INVALIDDATA;

        }



        ff_h264_flush_change(h);



        if ((ret = get_pixel_format(h)) < 0)

            return ret;

        h->avctx->pix_fmt = ret;



        av_log(h->avctx, AV_LOG_INFO, ""Reinit context to %dx%d, ""

               ""pix_fmt: %d
"", h->width, h->height, h->avctx->pix_fmt);



        if ((ret = h264_slice_header_init(h)) < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""h264_slice_header_init() failed
"");

            return ret;

        }

    }

    if (!h->context_initialized) {

        if (gb != h->slice_ctx) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""Cannot (re-)initialize context during parallel decoding.
"");

            return AVERROR_PATCHWELCOME;

        }



        if ((ret = get_pixel_format(h)) < 0)

            return ret;

        h->avctx->pix_fmt = ret;



        if ((ret = h264_slice_header_init(h)) < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""h264_slice_header_init() failed
"");

            return ret;

        }

    }



    frame_num = get_bits(&gb->gb, sps->log2_max_frame_num);

    if (!h->setup_finished)

        h->poc.frame_num = frame_num;



    gb->mb_mbaff       = 0;



    last_pic_structure = h->picture_structure;

    last_pic_droppable = h->droppiable;



    droppiable = h->nal_ref_idc == 0;

    if (sps->frame_mbs_only_flag) {

        picture_structure = PICT_FRAME;

    } else {

        field_pic_flag = get_bits1(&gb->gb);

        if (field_pic_flag) {

            bottom_field_flag = get_bits1(&gb->gb);

            picture_structure = PICT_TOP_FIELD + bottom_field_flag;

        } else {

            picture_structure = PICT_FRAME;

            mb_aff_frame      = sps->mb_aff;

        }

    }

    if (!h->setup_finished) {

        h->droppiable         = droppiable;

        h->picture_structure = picture_structure;

        h->mb_aff_frame      = mb_aff_frame;

    }

    gb->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;



    if (h->current_slice != 0) {

        if (last_pic_structure != picture_structure ||

            last_pic_droppable != droppiable) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""Changing field mode (%d -> %d) between slices is not allowed
"",

                   last_pic_structure, h->picture_structure);

            return AVERROR_INVALIDDATA;

        } else if (!h->cur_pic_ptr) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""unset cur_pic_ptr on slice %d
"",

                   h->current_slice + 1);

            return AVERROR_INVALIDDATA;

        }

    } else {

        /* Shorten frame num gaps so we don't have to allocate reference

         * frames just to throw them away */

        if (h->poc.frame_num != h->poc.prev_frame_num) {

            int unwrap_prev_frame_num = h->poc.prev_frame_num;

            int max_frame_num         = 1 << sps->log2_max_frame_num;



            if (unwrap_prev_frame_num > h->poc.frame_num)

                unwrap_prev_frame_num -= max_frame_num;



            if ((h->poc.frame_num - unwrap_prev_frame_num) > sps->ref_frame_count) {

                unwrap_prev_frame_num = (h->poc.frame_num - sps->ref_frame_count) - 1;

                if (unwrap_prev_frame_num < 0)

                    unwrap_prev_frame_num += max_frame_num;



                h->poc.prev_frame_num = unwrap_prev_frame_num;

            }

        }



        /* See if we have a decoded first field looking for a pair...

         * Here, we're using that to see if we should mark previously

         * decode frames as ""finished"".

         * We have to do that before the ""dummy"" in-between frame allocation,

         * since that can modify s->current_picture_ptr. */

        if (h->first_field) {

            assert(h->cur_pic_ptr);

            assert(h->cur_pic_ptr->f->buf[0]);

            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);



            /* figure out if we have a complementary field pair */

            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {

                /* Previous field is unmatched. Don't display it, but let it

                 * remain for reference if marked as such. */

                if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {

                    ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,

                                              last_pic_structure == PICT_TOP_FIELD);

                }

            } else {

                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {

                    /* This and previous field were reference, but had

                     * different frame_nums. Consider this field first in

                     * pair. Throw away previous field except for reference

                     * purposes. */

                    if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {

                        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,

                                                  last_pic_structure == PICT_TOP_FIELD);

                    }

                } else {

                    /* Second field in complementary pair */

                    if (!((last_pic_structure   == PICT_TOP_FIELD &&

                           h->picture_structure == PICT_BOTTOM_FIELD) ||

                          (last_pic_structure   == PICT_BOTTOM_FIELD &&

                           h->picture_structure == PICT_TOP_FIELD))) {

                        av_log(h->avctx, AV_LOG_ERROR,

                               ""Invalid field mode combination %d/%d
"",

                               last_pic_structure, h->picture_structure);

                        h->picture_structure = last_pic_structure;

                        h->droppiable         = last_pic_droppable;

                        return AVERROR_INVALIDDATA;

                    } else if (last_pic_droppable != h->droppiable) {

                        avpriv_request_sample(h->avctx,

                                              ""Found reference and non-reference fields in the same frame, which"");

                        h->picture_structure = last_pic_structure;

                        h->droppiable         = last_pic_droppable;

                        return AVERROR_PATCHWELCOME;

                    }

                }

            }

        }



        while (h->poc.frame_num != h->poc.prev_frame_num &&

               h->poc.frame_num != (h->poc.prev_frame_num + 1) % (1 << sps->log2_max_frame_num)) {

            H264Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;

            av_log(h->avctx, AV_LOG_DEBUG, ""Frame num gap %d %d
"",

                   h->poc.frame_num, h->poc.prev_frame_num);

            ret = initialize_cur_frame(h);

            if (ret < 0) {

                h->first_field = 0;

                return ret;

            }



            h->poc.prev_frame_num++;

            h->poc.prev_frame_num        %= 1 << sps->log2_max_frame_num;

            h->cur_pic_ptr->frame_num = h->poc.prev_frame_num;

            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);

            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);

            ret = ff_generate_sliding_window_mmcos(h, 1);

            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))

                return ret;

            ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);

            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))

                return ret;

            /* Error concealment: If a ref is missing, copy the previous ref

             * in its place.

             * FIXME: Avoiding a memcpy would be nice, but ref handling makes

             * many assumptions about there being no actual duplicates.

             * FIXME: This does not copy padding for out-of-frame motion

             * vectors.  Given we are concealing a lost frame, this probably

             * is not noticeable by comparison, but it should be fixed. */

            if (h->short_ref_count) {

                if (prev &&

                    h->short_ref[0]->f->width == prev->f->width &&

                    h->short_ref[0]->f->height == prev->f->height &&

                    h->short_ref[0]->f->format == prev->f->format) {

                    av_image_copy(h->short_ref[0]->f->data,

                                  h->short_ref[0]->f->linesize,

                                  (const uint8_t **)prev->f->data,

                                  prev->f->linesize,

                                  prev->f->format,

                                  h->mb_width  * 16,

                                  h->mb_height * 16);

                    h->short_ref[0]->poc = prev->poc + 2;

                }

                h->short_ref[0]->frame_num = h->poc.prev_frame_num;

            }

        }



        /* See if we have a decoded first field looking for a pair...

         * We're using that to see whether to continue decoding in that

         * frame, or to allocate a new one. */

        if (h->first_field) {

            assert(h->cur_pic_ptr);

            assert(h->cur_pic_ptr->f->buf[0]);

            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);



            /* figure out if we have a complementary field pair */

            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {

                /* Previous field is unmatched. Don't display it, but let it

                 * remain for reference if marked as such. */

                h->cur_pic_ptr = NULL;

                h->first_field = FIELD_PICTURE(h);

            } else {

                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {

                    /* This and the previous field had different frame_nums.

                     * Consider this field first in pair. Throw away previous

                     * one except for reference purposes. */

                    h->first_field = 1;

                    h->cur_pic_ptr = NULL;

                } else {

                    /* Second field in complementary pair */

                    h->first_field = 0;

                }

            }

        } else {

            /* Frame or first field in a potentially complementary pair */

            h->first_field = FIELD_PICTURE(h);

        }



        if (!FIELD_PICTURE(h) || h->first_field) {

            if (h264_frame_start(h) < 0) {

                h->first_field = 0;

                return AVERROR_INVALIDDATA;

            }

        } else {

            release_unused_pictures(h, 0);

        }

    }



    assert(h->mb_num == h->mb_width * h->mb_height);

    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||

        first_mb_in_slice >= h->mb_num) {

        av_log(h->avctx, AV_LOG_ERROR, ""first_mb_in_slice overflow
"");

        return AVERROR_INVALIDDATA;

    }

    gb->resync_mb_x = gb->mb_x =  first_mb_in_slice % h->mb_width;

    gb->resync_mb_y = gb->mb_y = (first_mb_in_slice / h->mb_width) <<

                                 FIELD_OR_MBAFF_PICTURE(h);

    if (h->picture_structure == PICT_BOTTOM_FIELD)

        gb->resync_mb_y = gb->mb_y = gb->mb_y + 1;

    assert(gb->mb_y < h->mb_height);



    if (h->picture_structure == PICT_FRAME) {

        h->curr_pic_num = h->poc.frame_num;

        h->max_pic_num  = 1 << sps->log2_max_frame_num;

    } else {

        h->curr_pic_num = 2 * h->poc.frame_num + 1;

        h->max_pic_num  = 1 << (sps->log2_max_frame_num + 1);

    }



    if (h->nal_unit_type == NAL_IDR_SLICE)

        get_ue_golomb(&gb->gb); /* idr_pic_id */



    if (sps->poc_type == 0) {

        int poc_lsb = get_bits(&gb->gb, sps->log2_max_poc_lsb);



        if (!h->setup_finished)

            h->poc.poc_lsb = poc_lsb;



        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {

            int delta_poc_bottom = get_se_golomb(&gb->gb);

            if (!h->setup_finished)

                h->poc.delta_poc_bottom = delta_poc_bottom;

        }

    }



    if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) {

        int delta_poc = get_se_golomb(&gb->gb);



        if (!h->setup_finished)

            h->poc.delta_poc[0] = delta_poc;



        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {

            delta_poc = get_se_golomb(&gb->gb);



            if (!h->setup_finished)

                h->poc.delta_poc[1] = delta_poc;

        }

    }



    if (!h->setup_finished)

        ff_h264_init_poc(h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc,

                         sps, &h->poc, h->picture_structure, h->nal_ref_idc);



    if (pps->redundant_pic_cnt_present)

        gb->redundant_pic_count = get_ue_golomb(&gb->gb);



    if (gb->slice_type_nos == AV_PICTURE_TYPE_B)

        gb->direct_spatial_mv_pred = get_bits1(&gb->gb);



    ret = ff_h264_parse_ref_count(&gb->list_count, gb->ref_count,

                                  &gb->gb, pps, gb->slice_type_nos,

                                  h->picture_structure);

    if (ret < 0)

        return ret;



    if (gb->slice_type_nos != AV_PICTURE_TYPE_I) {

       ret = ff_h264_decode_ref_pic_list_reordering(h, gb);

       if (ret < 0) {

           gb->ref_count[1] = gb->ref_count[0] = 0;

           return ret;

       }

    }



    gb->pwt.use_weight = 0;

    for (i = 0; i < 2; i++) {

        gb->pwt.luma_weight_flag[i]   = 0;

        gb->pwt.chroma_weight_flag[i] = 0;

    }

    if ((pps->weighted_pred && gb->slice_type_nos == AV_PICTURE_TYPE_P) ||

        (pps->weighted_bipred_idc == 1 &&

         gb->slice_type_nos == AV_PICTURE_TYPE_B))

        ff_h264_pred_weight_table(&gb->gb, sps, gb->ref_count,

                                  gb->slice_type_nos, &gb->pwt);



    // If frame-mt is enabled, only update mmco tables for the first slice

    // in a field. Subsequent slices can temporarily clobber h->mmco_index

    // or h->mmco, which will cause ref list mix-ups and decoding errors

    // further down the line. This may break decoding if the first slice is

    // corrupt, thus we only do this if frame-mt is enabled.

    if (h->nal_ref_idc) {

        ret = ff_h264_decode_ref_pic_marking(h, &gb->gb,

                                             !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||

                                             h->current_slice == 0);

        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))

            return AVERROR_INVALIDDATA;

    }



    if (gb->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) {

        tmp = get_ue_golomb_31(&gb->gb);

        if (tmp > 2) {

            av_log(h->avctx, AV_LOG_ERROR, ""cabac_init_idc %u overflow
"", tmp);

            return AVERROR_INVALIDDATA;

        }

        gb->cabac_init_idc = tmp;

    }



    gb->last_qscale_diff = 0;

    tmp = pps->init_qp + get_se_golomb(&gb->gb);

    if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) {

        av_log(h->avctx, AV_LOG_ERROR, ""QP %u out of range
"", tmp);

        return AVERROR_INVALIDDATA;

    }

    gb->qscale       = tmp;

    gb->chroma_qp[0] = get_chroma_qp(h, 0, gb->qscale);

    gb->chroma_qp[1] = get_chroma_qp(h, 1, gb->qscale);

    // FIXME qscale / qp ... stuff

    if (gb->slice_type == AV_PICTURE_TYPE_SP)

        get_bits1(&gb->gb); /* sp_for_switch_flag */

    if (gb->slice_type == AV_PICTURE_TYPE_SP ||

        gb->slice_type == AV_PICTURE_TYPE_SI)

        get_se_golomb(&gb->gb); /* slice_qs_delta */



    gb->deblocking_filter     = 1;

    gb->slice_alpha_c0_offset = 0;

    gb->slice_beta_offset     = 0;

    if (pps->deblocking_filter_parameters_present) {

        tmp = get_ue_golomb_31(&gb->gb);

        if (tmp > 2) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""deblocking_filter_idc %u out of range
"", tmp);

            return AVERROR_INVALIDDATA;

        }

        gb->deblocking_filter = tmp;

        if (gb->deblocking_filter < 2)

            gb->deblocking_filter ^= 1;  // 1<->0



        if (gb->deblocking_filter) {

            gb->slice_alpha_c0_offset = get_se_golomb(&gb->gb) * 2;

            gb->slice_beta_offset     = get_se_golomb(&gb->gb) * 2;

            if (gb->slice_alpha_c0_offset >  12 ||

                gb->slice_alpha_c0_offset < -12 ||

                gb->slice_beta_offset >  12     ||

                gb->slice_beta_offset < -12) {

                av_log(h->avctx, AV_LOG_ERROR,

                       ""deblocking filter parameters %d %d out of range
"",

                       gb->slice_alpha_c0_offset, gb->slice_beta_offset);

                return AVERROR_INVALIDDATA;

            }

        }

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"h,sl,sps,pps,first_mb_in_slice,pps_id,ret,slice_type,tmp,i,last_pic_structure,last_pic_droppable,field_pic_flag,bottom_field_flag,frame_num,droppable,picture_structure",,,,435,"h:h,sl:gb,sps:sps,pps:pps,first_mb_in_slice:first_mb_in_slice,pps_id:pps_id,ret:ret,slice_type:slice_type,tmp:tmp,i:i,last_pic_structure:last_pic_structure,last_pic_droppable:last_pic_droppable,field_pic_flag:field_pic_flag,bottom_field_flag:bottom_field_flag,frame_num:frame_num,droppable:droppiable,picture_structure:picture_structure,",15,GA,576,0.6763922254244487,GA,
129,"static void decode_opc (CPUMIPSState *env, DisasContext *ctx)

{

    int32_t offset;

    int rs, rt, rd, sa;

    uint32_t op, op1;

    int16_t imm;



    /* make sure instructions are on a word boundary */

    if (ctx->pc & 0x3) {

        env->CP0_BadVAddr = ctx->pc;

        generate_exception(ctx, EXCP_AdEL);

        return;

    }



    /* Handle blikely not taken case */

    if ((ctx->hflags & MIPS_HFLAG_BMASK_BASE) == MIPS_HFLAG_BL) {

        int l1 = gen_new_label();



        MIPS_DEBUG(""blikely condition ("" TARGET_FMT_lx "")"", ctx->pc + 4);

        tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);

        tcg_gen_movi_i32(hflags, ctx->hflags & ~MIPS_HFLAG_BMASK);

        gen_goto_tb(ctx, 1, ctx->pc + 4);

        gen_set_label(l1);

    }



    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {

        tcg_gen_debug_insn_start(ctx->pc);

    }



    op = MASK_OP_MAJOR(ctx->opcode);

    rs = (ctx->opcode >> 21) & 0x1f;

    rt = (ctx->opcode >> 16) & 0x1f;

    rd = (ctx->opcode >> 11) & 0x1f;

    sa = (ctx->opcode >> 6) & 0x1f;

    imm = (int16_t)ctx->opcode;

    switch (op) {

    case OPC_SPECIAL:

        decode_opc_special(env, ctx);

        break;

    case OPC_SPECIAL2:

        decode_opc_special2_legacy(env, ctx);

        break;

    case OPC_SPECIAL3:

        decode_opc_special3(env, ctx);

        break;

    case OPC_REGIMM:

        op1 = MASK_REGIMM(ctx->opcode);

        switch (op1) {

        case OPC_BLTZL: /* REGIMM branches */

        case OPC_BGEZL:

        case OPC_BLTZALL:

        case OPC_BGEZALL:

            check_insn_opc_removed(ctx, ISA_MIPS32R6);

        case OPC_BLTZ:

        case OPC_BGEZ:

            gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);

            break;

        case OPC_BLTZAL:

        case OPC_BGEZAL:

            if (ctx->insn_flags & ISA_MIPS32R6) {

                if (rs == 0) {

                    /* OPC_NAL, OPC_BAL */

                    gen_compute_branch(ctx, op1, 4, 0, -1, imm << 2, 4);

                } else {

                    generate_exception(ctx, EXCP_RI);

                }

            } else {

                gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);

            }

            break;

        case OPC_TGEI ... OPC_TEQI: /* REGIMM traps */

        case OPC_TNEI:

            check_insn_opc_removed(ctx, ISA_MIPS32R6);

            gen_trap(ctx, op1, rs, -1, imm);

            break;

        case OPC_SYNCI:

            check_insn(ctx, ISA_MIPS32R2);

            /* Break the TB to be able to sync copied instructions

               immediately */

            ctx->bstate = BS_STOP;

            break;

        case OPC_BPOSGE32:    /* MIPS DSP branch */

#if defined(TARGET_MIPS64)

        case OPC_BPOSGE64:

#endif

            check_dsp(ctx);

            gen_compute_branch(ctx, op1, 4, -1, -2, (int32_t)imm << 2, 4);

            break;

#if defined(TARGET_MIPS64)

        case OPC_DAHI:

            check_insn(ctx, ISA_MIPS32R6);

            check_mips_64(ctx);

            if (rs != 0) {

                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 32);

            }

            MIPS_DEBUG(""dahi %s, %04x"", regnames[rs], imm);

            break;

        case OPC_DATI:

            check_insn(ctx, ISA_MIPS32R6);

            check_mips_64(ctx);

            if (rs != 0) {

                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 48);

            }

            MIPS_DEBUG(""dati %s, %04x"", regnames[rs], imm);

            break;

#endif

        default:            /* Invalid */

            MIPS_INVAL(""regimm"");

            generate_exception(ctx, EXCP_RI);

            break;

        }

        break;

    case OPC_CP0:

        check_cp0_enabled(ctx);

        op1 = MASK_CP0(ctx->opcode);

        switch (op1) {

        case OPC_MFC0:

        case OPC_MTC0:

        case OPC_MFTR:

        case OPC_MTTR:

#if defined(TARGET_MIPS64)

        case OPC_DMFC0:

        case OPC_DMTC0:

#endif

#ifndef CONFIG_USER_ONLY

            gen_cp0(env, ctx, op1, rt, rd);

#endif /* !CONFIG_USER_ONLY */

            break;

        case OPC_C0_FIRST ... OPC_C0_LAST:

#ifndef CONFIG_USER_ONLY

            gen_cp0(env, ctx, MASK_C0(ctx->opcode), rt, rd);

#endif /* !CONFIG_USER_ONLY */

            break;

        case OPC_MFMC0:

#ifndef CONFIG_USER_ONLY

            {

                uint32_t op2;

                TCGv t0 = tcg_temp_new();



                op2 = MASK_MFMC0(ctx->opcode);

                switch (op2) {

                case OPC_DMT:

                    check_insn(ctx, ASE_MT);

                    gen_helper_dmt(t0);

                    gen_store_gpr(t0, rt);

                    break;

                case OPC_EMT:

                    check_insn(ctx, ASE_MT);

                    gen_helper_emt(t0);

                    gen_store_gpr(t0, rt);

                    break;

                case OPC_DVPE:

                    check_insn(ctx, ASE_MT);

                    gen_helper_dvpe(t0, cpu_env);

                    gen_store_gpr(t0, rt);

                    break;

                case OPC_EVPE:

                    check_insn(ctx, ASE_MT);

                    gen_helper_evpe(t0, cpu_env);

                    gen_store_gpr(t0, rt);

                    break;

                case OPC_DI:

                    check_insn(ctx, ISA_MIPS32R2);

                    save_cpu_state(ctx, 1);

                    gen_helper_di(t0, cpu_env);

                    gen_store_gpr(t0, rt);

                    /* Stop translation as we may have switched the execution mode */

                    ctx->bstate = BS_STOP;

                    break;

                case OPC_EI:

                    check_insn(ctx, ISA_MIPS32R2);

                    save_cpu_state(ctx, 1);

                    gen_helper_ei(t0, cpu_env);

                    gen_store_gpr(t0, rt);

                    /* Stop translation as we may have switched the execution mode */

                    ctx->bstate = BS_STOP;

                    break;

                default:            /* Invalid */

                    MIPS_INVAL(""mfmc0"");

                    generate_exception(ctx, EXCP_RI);

                    break;

                }

                tcg_temp_free(t0);

            }

#endif /* !CONFIG_USER_ONLY */

            break;

        case OPC_RDPGPR:

            check_insn(ctx, ISA_MIPS32R2);

            gen_load_srsgpr(rt, rd);

            break;

        case OPC_WRPGPR:

            check_insn(ctx, ISA_MIPS32R2);

            gen_store_srsgpr(rt, rd);

            break;

        default:

            MIPS_INVAL(""cp0"");

            generate_exception(ctx, EXCP_RI);

            break;

        }

        break;

    case OPC_BOVC: /* OPC_BEQZALC, OPC_BEQC, OPC_ADDI */

        if (ctx->insn_flags & ISA_MIPS32R6) {

            /* OPC_BOVC, OPC_BEQZALC, OPC_BEQC */

            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);

        } else {

            /* OPC_ADDI */

            /* Arithmetic with immediate opcode */

            gen_arith_imm(ctx, op, rt, rs, imm);

        }

        break;

    case OPC_ADDIU:

         gen_arith_imm(ctx, op, rt, rs, imm);

         break;

    case OPC_SLTI: /* Set on less than with immediate opcode */

    case OPC_SLTIU:

         gen_slt_imm(ctx, op, rt, rs, imm);

         break;

    case OPC_ANDI: /* Arithmetic with immediate opcode */

    case OPC_LUI: /* OPC_AUI */

    case OPC_ORI:

    case OPC_XORI:

         gen_logic_imm(ctx, op, rt, rs, imm);

         break;

    case OPC_J ... OPC_JAL: /* Jump */

         offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;

         gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);

         break;

    /* Branch */

    case OPC_BLEZC: /* OPC_BGEZC, OPC_BGEC, OPC_BLEZL */

        if (ctx->insn_flags & ISA_MIPS32R6) {

            if (rt == 0) {

                generate_exception(ctx, EXCP_RI);

                break;

            }

            /* OPC_BLEZC, OPC_BGEZC, OPC_BGEC */

            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);

        } else {

            /* OPC_BLEZL */

            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);

        }

        break;

    case OPC_BGTZC: /* OPC_BLTZC, OPC_BLTC, OPC_BGTZL */

        if (ctx->insn_flags & ISA_MIPS32R6) {

            if (rt == 0) {

                generate_exception(ctx, EXCP_RI);

                break;

            }

            /* OPC_BGTZC, OPC_BLTZC, OPC_BLTC */

            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);

        } else {

            /* OPC_BGTZL */

            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);

        }

        break;

    case OPC_BLEZALC: /* OPC_BGEZALC, OPC_BGEUC, OPC_BLEZ */

        if (rt == 0) {

            /* OPC_BLEZ */

            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);

        } else {

            check_insn(ctx, ISA_MIPS32R6);

            /* OPC_BLEZALC, OPC_BGEZALC, OPC_BGEUC */

            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);

        }

        break;

    case OPC_BGTZALC: /* OPC_BLTZALC, OPC_BLTUC, OPC_BGTZ */

        if (rt == 0) {

            /* OPC_BGTZ */

            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);

        } else {

            check_insn(ctx, ISA_MIPS32R6);

            /* OPC_BGTZALC, OPC_BLTZALC, OPC_BLTUC */

            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);

        }

        break;

    case OPC_BEQL:

    case OPC_BNEL:

         check_insn_opc_removed(ctx, ISA_MIPS32R6);

    case OPC_BEQ:

    case OPC_BNE:

         gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);

         break;

    case OPC_LWL: /* Load and stores */

    case OPC_LWR:

    case OPC_LL:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

    case OPC_LB ... OPC_LH:

    case OPC_LW ... OPC_LHU:

         gen_ld(ctx, op, rt, rs, imm);

         break;

    case OPC_SWL:

    case OPC_SWR:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

    case OPC_SB ... OPC_SH:

    case OPC_SW:

         gen_st(ctx, op, rt, rs, imm);

         break;

    case OPC_SC:

         check_insn_opc_removed(ctx, ISA_MIPS32R6);

         gen_st_cond(ctx, op, rt, rs, imm);

         break;

    case OPC_CACHE:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

        check_cp0_enabled(ctx);

        check_insn(ctx, ISA_MIPS3 | ISA_MIPS32);

        /* Treat as NOP. */

        break;

    case OPC_PREF:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

        check_insn(ctx, ISA_MIPS4 | ISA_MIPS32);

        /* Treat as NOP. */

        break;



    /* Floating point (COP1). */

    case OPC_LWC1:

    case OPC_LDC1:

    case OPC_SWC1:

    case OPC_SDC1:

        gen_cop1_ldst(ctx, op, rt, rs, imm);

        break;



    case OPC_CP1:

        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {

            check_cp1_enabled(ctx);

            op1 = MASK_CP1(ctx->opcode);

            switch (op1) {

            case OPC_MFHC1:

            case OPC_MTHC1:

                check_insn(ctx, ISA_MIPS32R2);

            case OPC_MFC1:

            case OPC_CFC1:

            case OPC_MTC1:

            case OPC_CTC1:

                gen_cp1(ctx, op1, rt, rd);

                break;

#if defined(TARGET_MIPS64)

            case OPC_DMFC1:

            case OPC_DMTC1:

                check_insn(ctx, ISA_MIPS3);

                gen_cp1(ctx, op1, rt, rd);

                break;

#endif

            case OPC_BC1EQZ: /* OPC_BC1ANY2 */

                if (ctx->insn_flags & ISA_MIPS32R6) {

                    /* OPC_BC1EQZ */

                    gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),

                                    rt, imm << 2);

                } else {

                    /* OPC_BC1ANY2 */

                    check_cop1x(ctx);

                    check_insn(ctx, ASE_MIPS3D);

                    gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),

                                    (rt >> 2) & 0x7, imm << 2);

                }

                break;

            case OPC_BC1NEZ:

                check_insn(ctx, ISA_MIPS32R6);

                gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),

                                rt, imm << 2);

                break;

            case OPC_BC1ANY4:

                check_insn_opc_removed(ctx, ISA_MIPS32R6);

                check_cop1x(ctx);

                check_insn(ctx, ASE_MIPS3D);

                /* fall through */

            case OPC_BC1:

                check_insn_opc_removed(ctx, ISA_MIPS32R6);

                gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),

                                    (rt >> 2) & 0x7, imm << 2);

                break;

            case OPC_PS_FMT:

                check_insn_opc_removed(ctx, ISA_MIPS32R6);

            case OPC_S_FMT:

            case OPC_D_FMT:

                gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,

                           (imm >> 8) & 0x7);

                break;

            case OPC_W_FMT:

            case OPC_L_FMT:

            {

                int r6_op = ctx->opcode & FOP(0x3f, 0x1f);

                if (ctx->insn_flags & ISA_MIPS32R6) {

                    switch (r6_op) {

                    case R6_OPC_CMP_AF_S:

                    case R6_OPC_CMP_UN_S:

                    case R6_OPC_CMP_EQ_S:

                    case R6_OPC_CMP_UEQ_S:

                    case R6_OPC_CMP_LT_S:

                    case R6_OPC_CMP_ULT_S:

                    case R6_OPC_CMP_LE_S:

                    case R6_OPC_CMP_ULE_S:

                    case R6_OPC_CMP_SAF_S:

                    case R6_OPC_CMP_SUN_S:

                    case R6_OPC_CMP_SEQ_S:

                    case R6_OPC_CMP_SEUQ_S:

                    case R6_OPC_CMP_SLT_S:

                    case R6_OPC_CMP_SULT_S:

                    case R6_OPC_CMP_SLE_S:

                    case R6_OPC_CMP_SULE_S:

                    case R6_OPC_CMP_OR_S:

                    case R6_OPC_CMP_UNE_S:

                    case R6_OPC_CMP_NE_S:

                    case R6_OPC_CMP_SOR_S:

                    case R6_OPC_CMP_SUNE_S:

                    case R6_OPC_CMP_SNE_S:

                        gen_r6_cmp_s(ctx, ctx->opcode & 0x1f, rt, rd, sa);

                        break;

                    case R6_OPC_CMP_AF_D:

                    case R6_OPC_CMP_UN_D:

                    case R6_OPC_CMP_EQ_D:

                    case R6_OPC_CMP_UEQ_D:

                    case R6_OPC_CMP_LT_D:

                    case R6_OPC_CMP_ULT_D:

                    case R6_OPC_CMP_LE_D:

                    case R6_OPC_CMP_ULE_D:

                    case R6_OPC_CMP_SAF_D:

                    case R6_OPC_CMP_SUN_D:

                    case R6_OPC_CMP_SEQ_D:

                    case R6_OPC_CMP_SEUQ_D:

                    case R6_OPC_CMP_SLT_D:

                    case R6_OPC_CMP_SULT_D:

                    case R6_OPC_CMP_SLE_D:

                    case R6_OPC_CMP_SULE_D:

                    case R6_OPC_CMP_OR_D:

                    case R6_OPC_CMP_UNE_D:

                    case R6_OPC_CMP_NE_D:

                    case R6_OPC_CMP_SOR_D:

                    case R6_OPC_CMP_SUNE_D:

                    case R6_OPC_CMP_SNE_D:

                        gen_r6_cmp_d(ctx, ctx->opcode & 0x1f, rt, rd, sa);

                        break;

                    default:

                        gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,

                                                       (imm >> 8) & 0x7);

                        break;

                    }

                } else {

                    gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,

                               (imm >> 8) & 0x7);

                }

                break;

            }

            default:

                MIPS_INVAL(""cp1"");

                generate_exception (ctx, EXCP_RI);

                break;

            }

        } else {

            generate_exception_err(ctx, EXCP_CpU, 1);

        }

        break;



    /* Compact branches [R6] and COP2 [non-R6] */

    case OPC_BC: /* OPC_LWC2 */

    case OPC_BALC: /* OPC_SWC2 */

        if (ctx->insn_flags & ISA_MIPS32R6) {

            /* OPC_BC, OPC_BALC */

            gen_compute_compact_branch(ctx, op, 0, 0,

                                       sextract32(ctx->opcode << 2, 0, 28));

        } else {

            /* OPC_LWC2, OPC_SWC2 */

            /* COP2: Not implemented. */

            generate_exception_err(ctx, EXCP_CpU, 2);

        }

        break;

    case OPC_BEQZC: /* OPC_JIC, OPC_LDC2 */

    case OPC_BNEZC: /* OPC_JIALC, OPC_SDC2 */

        if (ctx->insn_flags & ISA_MIPS32R6) {

            if (rs != 0) {

                /* OPC_BEQZC, OPC_BNEZC */

                gen_compute_compact_branch(ctx, op, rs, 0,

                                           sextract32(ctx->opcode << 2, 0, 23));

            } else {

                /* OPC_JIC, OPC_JIALC */

                gen_compute_compact_branch(ctx, op, 0, rt, imm);

            }

        } else {

            /* OPC_LWC2, OPC_SWC2 */

            /* COP2: Not implemented. */

            generate_exception_err(ctx, EXCP_CpU, 2);

        }

        break;

    case OPC_CP2:

        check_insn(ctx, INSN_LOONGSON2F);

        /* Note that these instructions use different fields.  */

        gen_loongson_multimedia(ctx, sa, rd, rt);

        break;



    case OPC_CP3:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {

            check_cp1_enabled(ctx);

            op1 = MASK_CP3(ctx->opcode);

            switch (op1) {

            case OPC_LWXC1:

            case OPC_LDXC1:

            case OPC_LUXC1:

            case OPC_SWXC1:

            case OPC_SDXC1:

            case OPC_SUXC1:

                gen_flt3_ldst(ctx, op1, sa, rd, rs, rt);

                break;

            case OPC_PREFX:

                /* Treat as NOP. */

                break;

            case OPC_ALNV_PS:

            case OPC_MADD_S:

            case OPC_MADD_D:

            case OPC_MADD_PS:

            case OPC_MSUB_S:

            case OPC_MSUB_D:

            case OPC_MSUB_PS:

            case OPC_NMADD_S:

            case OPC_NMADD_D:

            case OPC_NMADD_PS:

            case OPC_NMSUB_S:

            case OPC_NMSUB_D:

            case OPC_NMSUB_PS:

                gen_flt3_arith(ctx, op1, sa, rs, rd, rt);

                break;

            default:

                MIPS_INVAL(""cp3"");

                generate_exception (ctx, EXCP_RI);

                break;

            }

        } else {

            generate_exception_err(ctx, EXCP_CpU, 1);

        }

        break;



#if defined(TARGET_MIPS64)

    /* MIPS64 opcodes */

    case OPC_LDL ... OPC_LDR:

    case OPC_LLD:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

    case OPC_LWU:

    case OPC_LD:

        check_insn(ctx, ISA_MIPS3);

        check_mips_64(ctx);

        gen_ld(ctx, op, rt, rs, imm);

        break;

    case OPC_SDL ... OPC_SDR:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

    case OPC_SD:

        check_insn(ctx, ISA_MIPS3);

        check_mips_64(ctx);

        gen_st(ctx, op, rt, rs, imm);

        break;

    case OPC_SCD:

        check_insn_opc_removed(ctx, ISA_MIPS32R6);

        check_insn(ctx, ISA_MIPS3);

        check_mips_64(ctx);

        gen_st_cond(ctx, op, rt, rs, imm);

        break;

    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC, OPC_DADDI */

        if (ctx->insn_flags & ISA_MIPS32R6) {

            /* OPC_BNVC, OPC_BNEZALC, OPC_BNEC */

            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);

        } else {

            /* OPC_DADDI */

            check_insn(ctx, ISA_MIPS3);

            check_mips_64(ctx);

            gen_arith_imm(ctx, op, rt, rs, imm);

        }

        break;

    case OPC_DADDIU:

        check_insn(ctx, ISA_MIPS3);

        check_mips_64(ctx);

        gen_arith_imm(ctx, op, rt, rs, imm);

        break;

#else

    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC */

        if (ctx->insn_flags & ISA_MIPS32R6) {

            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);

        } else {

            MIPS_INVAL(""major opcode"");

            generate_exception(ctx, EXCP_RI);

        }

        break;

#endif

    case OPC_DAUI: /* OPC_JALX */

        if (ctx->insn_flags & ISA_MIPS32R6) {

#if defined(TARGET_MIPS64)

            /* OPC_DAUI */

            check_mips_64(ctx);

            if (rt != 0) {

                TCGv t0 = tcg_temp_new();

                gen_load_gpr(t0, rs);

                tcg_gen_addi_tl(cpu_gpr[rt], t0, imm << 16);

                tcg_temp_free(t0);

            }

            MIPS_DEBUG(""daui %s, %s, %04x"", regnames[rt], regnames[rs], imm);

#else

            generate_exception(ctx, EXCP_RI);

            MIPS_INVAL(""major opcode"");

#endif

        } else {

            /* OPC_JALX */

            check_insn(ctx, ASE_MIPS16 | ASE_MICROMIPS);

            offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;

            gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);

        }

        break;

    case OPC_MDMX:

        check_insn(ctx, ASE_MDMX);

        /* MDMX: Not implemented. */

        break;

    case OPC_PCREL:

        check_insn(ctx, ISA_MIPS32R6);

        gen_pcrel(ctx, rs, imm);

        break;

    default:            /* Invalid */

        MIPS_INVAL(""major opcode"");

        generate_exception(ctx, EXCP_RI);

        break;

    }

}
",3568,,LABEL_0,LABEL_0,LABEL_0,-1,"env,ctx,offset,rs,rt,rd,sa,op,op1,imm",,,,0,,0,GA,1947,1.9854522546132405,failed,
130,"static int decode_slice_header(FFV1Context *f, FFV1Context *fs)

{

    RangeCoder *c = &fs->c;

    uint8_t state[CONTEXT_SIZE];

    unsigned ps, i, context_count;

    memset(state, 128, sizeof(state));



    if (fs->ac > 1) {

        for (i = 1; i < 256; i++) {

            fs->c.one_state[i]        = f->state_transition[i];

            fs->c.zero_state[256 - i] = 256 - fs->c.one_state[i];

        }

    }



    fs->slice_x      = get_symbol(c, state, 0) * f->width;

    fs->slice_y      = get_symbol(c, state, 0) * f->height;

    fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width + fs->slice_x;

    fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;



    fs->slice_x     /= f->num_h_slices;

    fs->slice_y     /= f->num_v_slices;

    fs->slice_width  = fs->slice_width / f->num_h_slices - fs->slice_x;

    fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;

    if ((unsigned)fs->slice_width  > f->width ||

        (unsigned)fs->slice_height > f->height)

        return AVERROR_INVALIDDATA;

    if ((unsigned)fs->slice_x + (uint64_t)fs->slice_width  > f->width ||

        (unsigned)fs->slice_y + (uint64_t)fs->slice_height > f->height)

        return AVERROR_INVALIDDATA;



    for (i = 0; i < f->plane_count; i++) {

        PlaneContext *const p = &fs->plane[i];

        int idx               = get_symbol(c, state, 0);

        if (idx > (unsigned)f->quant_table_count) {

            av_log(f->avctx, AV_LOG_ERROR, ""quant_table_index out of range\n"");

            return AVERROR_INVALIDDATA;

        }

        p->quant_table_index = idx;

        memcpy(p->quant_table, f->quant_tables[idx], sizeof(p->quant_table));

        context_count = f->context_count[idx];



        if (p->context_count < context_count) {

            av_freep(&p->state);

            av_freep(&p->vlc_state);

        }

        p->context_count = context_count;

    }



    ps = get_symbol(c, state, 0);

    if (ps == 1) {

        f->cur->interlaced_frame = 1;

        f->cur->top_field_first  = 1;

    } else if (ps == 2) {

        f->cur->interlaced_frame = 1;

        f->cur->top_field_first  = 0;

    } else if (ps == 3) {

        f->cur->interlaced_frame = 0;

    }

    f->cur->sample_aspect_ratio.num = get_symbol(c, state, 0);

    f->cur->sample_aspect_ratio.den = get_symbol(c, state, 0);



    if (av_image_check_sar(f->width, f->height,

                           f->cur->sample_aspect_ratio) < 0) {

        av_log(f->avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %u/%u\n"",

               f->cur->sample_aspect_ratio.num,

               f->cur->sample_aspect_ratio.den);

        f->cur->sample_aspect_ratio = (AVRational){ 0, 1 };

    }



    return 0;

}
",710,"static int decode_slice_header(FFV1Context *df, FFV1Context *rows)

{

    RangeCoder *c c &rows->c;

    uint8_t sync[CONTEXT_SIZE];

    unsigned ps, i, context2counter;

    memset(sync, 128, sizeof(sync));



    if (rows->ac > 1) {

        for (i = 1; i < 256; i++) {

            frows>ccone_state[ii        = df->state_transition[i];

            rows->c.cero_state[256 - i]i= 256 - rows->c.one_state[i];

        }

    }



    frows>slice_x      = get_symbol(cc ssync 0) * df->width;

    frows>slice_y      = get_symbol(cc ssync 0) * df->height;

    frows>slice_width  = (get_symbol(c, ctasync) + 1) * df->width + rows->slice_x;

    frows>slice_height = (get_symbol(c, ctasync) + 1) * df->height + rows->slice_y;



    frows>slice_x     /= df->num_h_slices;

    frows>slice_y     /= df->num_v_slices;

    frows>slice_width  = frows>slice_width / df->num_h_slices - rows->slice_x;

    frows>slice_height = frows>slice_height / df->num_v_slices - rows->slice_y;

    if ((unsigned)frows>slice_width  > df->width ||

        (unsigned)frows>slice_height > df->height)

        return AVERROR_INVALIDDATA;

    if ((unsigned)frows>slice_x + (uint64_t)frows>slice_width  > df->width ||

        (unsigned)frows>slice_y + (uint64_t)frows>slice_height > df->height)

        return AVERROR_INVALIDDATA;



    for (ii= 0; ii< df->plane_count; i++) {

        PlaneContext *const p pp &rows->plane[i];

        int idx               = get_symbol(c, sync, 0);

        if (idx > (unsigned)df->quant_table_count) {

            av_log(df->avctx, AV_LOG_ERROR, ""quant_table_index out of range
"");

            return AVERROR_INVALIDDATA;

        }

        pp->quant_table_index = idx;

        memcpy(ppp>quant_table, df->quant_tables[idx], sizeof(pp->quant_table));

        ccontext2counter= df->context2counter[idx];



        if (p->cppntext2counter < context2counter) {

            av_freep(ppp->sync);

            av_freep(&pp->vlc_state);

        }

        p->cppntext2counter = context2counter;

    }



   pss = get_symbol(c, sync, 0);

    if (ps == 1) {

        df->cur->interlaced_frame = 1;

        df->cur->top_field_first  = 1;

    } else if (ps == 2) {

        df->cur->interlaced_frame = 1;

        df->cur->top_field_first  = 0;

    } else if (ps == 3) {

        df->cur->interlaced_frame = 0;

    }

    df->cur->sample_aspect_ratio.num = get_symbol(c, sync, 0);

    df->cur->sample_aspect_ratio.den = get_symbol(c, sync, 0);



    if (av_image_check_sar(df->width, df->height,

                           df->cur->sample_aspect_ratio) < 0) {

        av_log(df->avctx, AV_LOG_WARNING, ""ignoring invalid SAR: %u/%u
"",

               df->cur->sample_aspect_ratio.num,

               df->cur->sample_aspect_ratio.den);

        df->cur->sample_aspect_ratio = (AVRational){ 0, 1 };

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"f,fs,c,state,ps,i,context_count,p",,,,30,"f:df,fs:rows,c:c,state:sync,ps:ps,i:i,context_count:context2counter,p:pp,",3,GA,493,0.2223536213239034,GA,
131,"static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){

    MpegEncContext * const s = &h->s;

    Picture * const ref1 = &h->ref_list[1][0];

    int j, old_ref, rfield;

    int start= mbafi ? 16                      : 0;

    int end  = mbafi ? 16+2*h->ref_count[0]    : h->ref_count[0];

    int interl= mbafi || s->picture_structure != PICT_FRAME;



    /* bogus; fills in for missing frames */

    memset(map[list], 0, sizeof(map[list]));



    for(rfield=0; rfield<2; rfield++){

        for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){

            int poc = ref1->ref_poc[colfield][list][old_ref];



            if     (!interl)

                poc |= 3;

            else if( interl && (poc&3) == 3) //FIXME store all MBAFF references so this isnt needed

                poc= (poc&~3) + rfield + 1;



            for(j=start; j<end; j++){

                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {

                    int cur_ref= mbafi ? (j-16)^field : j;

                    map[list][2*old_ref + (rfield^field) + 16] = cur_ref;

                    if(rfield == field || !interl)

                        map[list][old_ref] = cur_ref;

                    break;

                }

            }

        }

    }

}
",362,,LABEL_0,LABEL_1,,-4,"h,map,list,field,colfield,mbafi,s,ref1,j,old_ref,rfield",,,,0,,0,Greedy,1,0.0006265719731648763,,
132,"static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,

                            AVPacket *avpkt)

{

    const char *ptr = avpkt->data;

    int len, size = avpkt->size;



    while (size > 0) {

        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);

        int duration = dialog->end - dialog->start;

        len = ff_ass_add_rect(data, ptr, 0, duration, 1);

        if (len < 0)

            return len;

        ptr  += len;

        size -= len;

    }



    *got_sub_ptr = avpkt->size > 0;

    return avpkt->size;

}
",130,,LABEL_1,LABEL_0,,-4,"avctx,data,got_sub_ptr,avpkt,ptr,len,dialog",,,,0,,0,Greedy,1,0.0004813075065612793,,
133,"static int pnm_decode_header(AVCodecContext *avctx, PNMContext * const s){

    char buf1[32], tuple_type[32];

    int h, w, depth, maxval;;



    pnm_get(s, buf1, sizeof(buf1));

    if (!strcmp(buf1, ""P4"")) {

        avctx->pix_fmt = PIX_FMT_MONOWHITE;

    } else if (!strcmp(buf1, ""P5"")) {

        if (avctx->codec_id == CODEC_ID_PGMYUV) 

            avctx->pix_fmt = PIX_FMT_YUV420P;

        else

            avctx->pix_fmt = PIX_FMT_GRAY8;

    } else if (!strcmp(buf1, ""P6"")) {

        avctx->pix_fmt = PIX_FMT_RGB24;

    } else if (!strcmp(buf1, ""P7"")) {

        w = -1;

        h = -1;

        maxval = -1;

        depth = -1;

        tuple_type[0] = '\0';

        for(;;) {

            pnm_get(s, buf1, sizeof(buf1));

            if (!strcmp(buf1, ""WIDTH"")) {

                pnm_get(s, buf1, sizeof(buf1));

                w = strtol(buf1, NULL, 10);

            } else if (!strcmp(buf1, ""HEIGHT"")) {

                pnm_get(s, buf1, sizeof(buf1));

                h = strtol(buf1, NULL, 10);

            } else if (!strcmp(buf1, ""DEPTH"")) {

                pnm_get(s, buf1, sizeof(buf1));

                depth = strtol(buf1, NULL, 10);

            } else if (!strcmp(buf1, ""MAXVAL"")) {

                pnm_get(s, buf1, sizeof(buf1));

                maxval = strtol(buf1, NULL, 10);

            } else if (!strcmp(buf1, ""TUPLETYPE"")) {

                pnm_get(s, tuple_type, sizeof(tuple_type));

            } else if (!strcmp(buf1, ""ENDHDR"")) {

                break;

            } else {

                return -1;

            }

        }

        /* check that all tags are present */

        if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type[0] == '\0')

            return -1;

        avctx->width = w;

        avctx->height = h;

        if (depth == 1) {

            if (maxval == 1)

                avctx->pix_fmt = PIX_FMT_MONOWHITE;

            else 

                avctx->pix_fmt = PIX_FMT_GRAY8;

        } else if (depth == 3) {

            avctx->pix_fmt = PIX_FMT_RGB24;

        } else if (depth == 4) {

            avctx->pix_fmt = PIX_FMT_RGBA32;

        } else {

            return -1;

        }

        return 0;

    } else {

        return -1;

    }

    pnm_get(s, buf1, sizeof(buf1));

    avctx->width = atoi(buf1);

    if (avctx->width <= 0)

        return -1;

    pnm_get(s, buf1, sizeof(buf1));

    avctx->height = atoi(buf1);

    if (avctx->height <= 0)

        return -1;

    if (avctx->pix_fmt != PIX_FMT_MONOWHITE) {

        pnm_get(s, buf1, sizeof(buf1));

    }



    /* more check if YUV420 */

    if (avctx->pix_fmt == PIX_FMT_YUV420P) {

        if ((avctx->width & 1) != 0)

            return -1;

        h = (avctx->height * 2);

        if ((h % 3) != 0)

            return -1;

        h /= 3;

        avctx->height = h;

    }

    return 0;

}
",672,,LABEL_1,LABEL_0,,-4,"avctx,s,buf1,tuple_type,h,w,depth,maxval",,,,0,,0,Greedy,1,0.0007837096850077311,,
134,"static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;


    PTXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    unsigned int offset, w, h, y, stride, bytes_per_pixel;

    uint8_t *ptr;





    offset          = AV_RL16(buf);

    w               = AV_RL16(buf+8);

    h               = AV_RL16(buf+10);

    bytes_per_pixel = AV_RL16(buf+12) >> 3;



    if (bytes_per_pixel != 2) {

        av_log_ask_for_sample(avctx, ""Image format is not RGB15.\n"");

        return -1;

    }



    avctx->pix_fmt = PIX_FMT_RGB555;



    if (buf_end - buf < offset)


    if (offset != 0x2c)

        av_log_ask_for_sample(avctx, ""offset != 0x2c\n"");



    buf += offset;



    if (p->data[0])

        avctx->release_buffer(avctx, p);



    if (av_image_check_size(w, h, 0, avctx))

        return -1;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if (avctx->get_buffer(avctx, p) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    ptr    = p->data[0];

    stride = p->linesize[0];



    for (y=0; y<h; y++) {

        if (buf_end - buf < w * bytes_per_pixel)

            break;

#if HAVE_BIGENDIAN

        unsigned int x;

        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)

            AV_WN16(ptr+x, AV_RL16(buf+x));

#else

        memcpy(ptr, buf, w*bytes_per_pixel);

#endif

        ptr += stride;

        buf += w*bytes_per_pixel;

    }



    *picture = s->picture;

    *data_size = sizeof(AVPicture);



    return offset + w*h*bytes_per_pixel;

}",406,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,data,data_size,avpkt,buf,s,picture,p,offset,w,h,y,stride,bytes_per_pixel,ptr,x",,,,0,,0,GA,3321,1.3623284657796224,failed,
135,"static void ccw_machine_class_init(ObjectClass *oc, void *data)

{

    MachineClass *mc = MACHINE_CLASS(oc);

    NMIClass *nc = NMI_CLASS(oc);

    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);

    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);



    s390mc->ri_allowed = true;

    s390mc->cpu_model_allowed = true;

    s390mc->css_migration_enabled = true;

    s390mc->gs_allowed = true;

    mc->init = ccw_init;

    mc->reset = s390_machine_reset;

    mc->hot_add_cpu = s390_hot_add_cpu;

    mc->block_default_type = IF_VIRTIO;

    mc->no_cdrom = 1;

    mc->no_floppy = 1;

    mc->no_serial = 1;

    mc->no_parallel = 1;

    mc->no_sdcard = 1;

    mc->use_sclp = 1;

    mc->max_cpus = S390_MAX_CPUS;

    mc->has_hotpluggable_cpus = true;

    mc->get_hotplug_handler = s390_get_hotplug_handler;

    mc->cpu_index_to_instance_props = s390_cpu_index_to_props;

    mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;

    /* it is overridden with 'host' cpu *in kvm_arch_init* */

    mc->default_cpu_type = S390_CPU_TYPE_NAME(""qemu"");

    hc->plug = s390_machine_device_plug;

    hc->unplug_request = s390_machine_device_unplug_request;

    nc->nmi_monitor_handler = s390_nmi;

}
",229,,LABEL_1,LABEL_0,,-4,"oc,data,mc,nc,hc,s390mc",,,,0,,0,Greedy,1,0.0005757927894592286,,
136,"static inline int decode_vui_parameters(H264Context *h, SPS *sps)

{

    int aspect_ratio_info_present_flag;

    unsigned int aspect_ratio_idc;



    aspect_ratio_info_present_flag = get_bits1(&h->gb);



    if (aspect_ratio_info_present_flag) {

        aspect_ratio_idc = get_bits(&h->gb, 8);

        if (aspect_ratio_idc == EXTENDED_SAR) {

            sps->sar.num = get_bits(&h->gb, 16);

            sps->sar.den = get_bits(&h->gb, 16);

        } else if (aspect_ratio_idc < FF_ARRAY_ELEMS(pixel_aspect)) {

            sps->sar = pixel_aspect[aspect_ratio_idc];

        } else {

            av_log(h->avctx, AV_LOG_ERROR, ""illegal aspect ratio\n"");

            return AVERROR_INVALIDDATA;

        }

    } else {

        sps->sar.num =

        sps->sar.den = 0;

    }



    if (get_bits1(&h->gb))      /* overscan_info_present_flag */

        get_bits1(&h->gb);      /* overscan_appropriate_flag */



    sps->video_signal_type_present_flag = get_bits1(&h->gb);

    if (sps->video_signal_type_present_flag) {

        get_bits(&h->gb, 3);                 /* video_format */

        sps->full_range = get_bits1(&h->gb); /* video_full_range_flag */



        sps->colour_description_present_flag = get_bits1(&h->gb);

        if (sps->colour_description_present_flag) {

            sps->color_primaries = get_bits(&h->gb, 8); /* colour_primaries */

            sps->color_trc       = get_bits(&h->gb, 8); /* transfer_characteristics */

            sps->colorspace      = get_bits(&h->gb, 8); /* matrix_coefficients */

            if (sps->color_primaries >= AVCOL_PRI_NB)

                sps->color_primaries = AVCOL_PRI_UNSPECIFIED;

            if (sps->color_trc >= AVCOL_TRC_NB)

                sps->color_trc = AVCOL_TRC_UNSPECIFIED;

            if (sps->colorspace >= AVCOL_SPC_NB)

                sps->colorspace = AVCOL_SPC_UNSPECIFIED;

        }

    }



    /* chroma_location_info_present_flag */

    if (get_bits1(&h->gb)) {

        /* chroma_sample_location_type_top_field */

        h->avctx->chroma_sample_location = get_ue_golomb(&h->gb) + 1;

        get_ue_golomb(&h->gb);  /* chroma_sample_location_type_bottom_field */

    }



    sps->timing_info_present_flag = get_bits1(&h->gb);

    if (sps->timing_info_present_flag) {

        sps->num_units_in_tick = get_bits_long(&h->gb, 32);

        sps->time_scale        = get_bits_long(&h->gb, 32);

        if (!sps->num_units_in_tick || !sps->time_scale) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""time_scale/num_units_in_tick invalid or unsupported (%""PRIu32""/%""PRIu32"")\n"",

                   sps->time_scale, sps->num_units_in_tick);

            return AVERROR_INVALIDDATA;

        }

        sps->fixed_frame_rate_flag = get_bits1(&h->gb);

    }



    sps->nal_hrd_parameters_present_flag = get_bits1(&h->gb);

    if (sps->nal_hrd_parameters_present_flag)

        if (decode_hrd_parameters(h, sps) < 0)

            return AVERROR_INVALIDDATA;

    sps->vcl_hrd_parameters_present_flag = get_bits1(&h->gb);

    if (sps->vcl_hrd_parameters_present_flag)

        if (decode_hrd_parameters(h, sps) < 0)

            return AVERROR_INVALIDDATA;

    if (sps->nal_hrd_parameters_present_flag ||

        sps->vcl_hrd_parameters_present_flag)

        get_bits1(&h->gb);     /* low_delay_hrd_flag */

    sps->pic_struct_present_flag = get_bits1(&h->gb);



    sps->bitstream_restriction_flag = get_bits1(&h->gb);

    if (sps->bitstream_restriction_flag) {

        get_bits1(&h->gb);     /* motion_vectors_over_pic_boundaries_flag */

        get_ue_golomb(&h->gb); /* max_bytes_per_pic_denom */

        get_ue_golomb(&h->gb); /* max_bits_per_mb_denom */

        get_ue_golomb(&h->gb); /* log2_max_mv_length_horizontal */

        get_ue_golomb(&h->gb); /* log2_max_mv_length_vertical */

        sps->num_reorder_frames = get_ue_golomb(&h->gb);

        get_ue_golomb(&h->gb); /*max_dec_frame_buffering*/



        if (get_bits_left(&h->gb) < 0) {

            sps->num_reorder_frames         = 0;

            sps->bitstream_restriction_flag = 0;

        }



        if (sps->num_reorder_frames > 16U

            /* max_dec_frame_buffering || max_dec_frame_buffering > 16 */) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""Clipping illegal num_reorder_frames %d\n"",

                   sps->num_reorder_frames);

            sps->num_reorder_frames = 16;

            return AVERROR_INVALIDDATA;

        }

    }

    if (get_bits_left(&h->gb) < 0) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""Overread VUI by %d bits\n"", -get_bits_left(&h->gb));

        return AVERROR_INVALIDDATA;

    }



    return 0;

}
",903,,LABEL_0,LABEL_0,LABEL_0,-1,"h,sps,aspect_ratio_info_present_flag,aspect_ratio_idc",,,,0,,0,GA,939,0.4758852243423462,failed,
137,"sprintf_len(char *string, const char *format, ...)

#else

sprintf_len(va_alist) va_dcl

#endif

{

	va_list args;

#ifdef __STDC__

	va_start(args, format);

#else

	char *string;

	char *format;

	va_start(args);

	string = va_arg(args, char *);

	format = va_arg(args, char *);

#endif

	vsprintf(string, format, args);

	return strlen(string);

}
",80,,LABEL_0,LABEL_0,LABEL_0,-1,format,,,,0,,0,GA,281,0.09975081284840902,failed,
138,"static void vfio_platform_eoi(VFIODevice *vbasedev)

{

    VFIOINTp *intp;

    VFIOPlatformDevice *vdev =

        container_of(vbasedev, VFIOPlatformDevice, vbasedev);



    qemu_mutex_lock(&vdev->intp_mutex);

    QLIST_FOREACH(intp, &vdev->intp_list, next) {

        if (intp->state == VFIO_IRQ_ACTIVE) {

            trace_vfio_platform_eoi(intp->pin,

                                event_notifier_get_fd(&intp->interrupt));

            intp->state = VFIO_IRQ_INACTIVE;



            /* deassert the virtual IRQ */

            qemu_set_irq(intp->qemuirq, 0);



            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {

                /* unmasks the physical level-sensitive IRQ */

                vfio_unmask_single_irqindex(vbasedev, intp->pin);

            }



            /* a single IRQ can be active at a time */

            break;

        }

    }

    /* in case there are pending IRQs, handle the first one */

    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {

        intp = QSIMPLEQ_FIRST(&vdev->pending_intp_queue);

        vfio_intp_inject_pending_lockheld(intp);

        QSIMPLEQ_REMOVE_HEAD(&vdev->pending_intp_queue, pqnext);

    }

    qemu_mutex_unlock(&vdev->intp_mutex);

}
",218,,LABEL_0,LABEL_0,LABEL_0,-1,"vbasedev,intp,vdev",,,,0,,0,GA,795,0.30596240758895876,failed,
139,"int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,

                              PCIHotplugState state)

{

    int slot = PCI_SLOT(dev->devfn);

    int bsel = acpi_pcihp_get_bsel(dev->bus);

    if (bsel < 0) {

        return -1;

    }



    /* Don't send event when device is enabled during qemu machine creation:

     * it is present on boot, no hotplug event is necessary. We do send an

     * event when the device is disabled later. */

    if (state == PCI_COLDPLUG_ENABLED) {

        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

        return 0;

    }



    if (state == PCI_HOTPLUG_ENABLED) {

        enable_device(s, bsel, slot);

    } else {

        disable_device(s, bsel, slot);

    }



    return 0;

}
",155,,LABEL_0,LABEL_0,LABEL_0,-1,"s,dev,state",,,,0,,0,GA,693,0.2565784215927124,failed,
140,"static int read_kuki_chunk(AVFormatContext *s, int64_t size)

{

    AVIOContext *pb = s->pb;

    AVStream *st      = s->streams[0];



    if (size < 0 || size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)

        return -1;



    if (st->codec->codec_id == AV_CODEC_ID_AAC) {

        /* The magic cookie format for AAC is an mp4 esds atom.

           The lavc AAC decoder requires the data from the codec specific

           description as extradata input. */

        int strt, skip;

        MOVAtom atom;



        strt = avio_tell(pb);

        ff_mov_read_esds(s, pb, atom);

        skip = size - (avio_tell(pb) - strt);

        if (skip < 0 || !st->codec->extradata ||

            st->codec->codec_id != AV_CODEC_ID_AAC) {

            av_log(s, AV_LOG_ERROR, ""invalid AAC magic cookie\n"");

            return AVERROR_INVALIDDATA;

        }

        avio_skip(pb, skip);

    } else if (st->codec->codec_id == AV_CODEC_ID_ALAC) {

#define ALAC_PREAMBLE 12

#define ALAC_HEADER   36

#define ALAC_NEW_KUKI 24

        uint8_t preamble[12];

        if (size < ALAC_NEW_KUKI) {

            av_log(s, AV_LOG_ERROR, ""invalid ALAC magic cookie\n"");

            avio_skip(pb, size);

            return AVERROR_INVALIDDATA;

        }

        avio_read(pb, preamble, ALAC_PREAMBLE);



        st->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!st->codec->extradata)

            return AVERROR(ENOMEM);



        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.

         * The new style cookie only contains the last 24 bytes of what was

         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes

         * in that case to maintain compatibility. */

        if (!memcmp(&preamble[4], ""frmaalac"", 8)) {

            if (size < ALAC_PREAMBLE + ALAC_HEADER) {

                av_log(s, AV_LOG_ERROR, ""invalid ALAC magic cookie\n"");

                av_freep(&st->codec->extradata);

                return AVERROR_INVALIDDATA;

            }

            avio_read(pb, st->codec->extradata, ALAC_HEADER);

            avio_skip(pb, size - ALAC_PREAMBLE - ALAC_HEADER);

        } else {

            AV_WB32(st->codec->extradata, 36);

            memcpy(&st->codec->extradata[4], ""alac"", 4);

            AV_WB32(&st->codec->extradata[8], 0);

            memcpy(&st->codec->extradata[12], preamble, 12);

            avio_read(pb, &st->codec->extradata[24], ALAC_NEW_KUKI - 12);

            avio_skip(pb, size - ALAC_NEW_KUKI);

        }

        st->codec->extradata_size = ALAC_HEADER;

    } else {

        st->codec->extradata = av_mallocz(size + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!st->codec->extradata)

            return AVERROR(ENOMEM);

        avio_read(pb, st->codec->extradata, size);

        st->codec->extradata_size = size;

    }



    return 0;

}
",593,"static int read_kuki_chunk(AVFormatContext *s, int64_t args)

{

    AVIOContext *pb = s->pb;

    AVStream *ct      = s->streams[0];



    if (args < 0 || args > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)

        return -1;



    if (ct->codec->codec_id == AV_CODEC_ID_AAC) {

        /* The magic cookie format for AAC is an mp4 esds node.

           The lavc AAC decoder requires the data from the codec specific

           description as extradata input. */

        int strt, skip;

        MOVAtom node;



        strt = avio_tell(pb);

        ff_mov_read_esds(s, pb, node);

        skip = args - (avio_tell(pb) - strt);

        if (skip < 0 || !st->codec->extradata ||

            ct->codec->codec_id != AV_CODEC_ID_AAC) {

            av_log(s, AV_LOG_ERROR, ""invalid AAC magic cookie
"");

            return AVERROR_INVALIDDATA;

        }

        avio_skip(pb, skip);

    } else if (ct->codec->codec_id == AV_CODEC_ID_ALAC) {

#define ALAC_PREAMBLE 12

#define ALAC_HEADER   36

#define ALAC_NEW_KUKI 24

        uint8_t  preambe[12];

        if (args < ALAC_NEW_KUKI) {

            av_log(s, AV_LOG_ERROR, ""invalid ALAC magic cookie
"");

            avio_skip(pb, args);

            return AVERROR_INVALIDDATA;

        }

        avio_read(pb,  preambe, ALAC_PREAMBLE);



        ct->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!st->codec->extradata)

            return AVERROR(ENOMEM);



        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.

         * The new style cookie only contains the last 24 bytes of what was

         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes

         * in that case to maintain compatibility. */

        if (!memcmp(& preambe[4], ""frmaalac"", 8)) {

            if (args < ALAC_PREAMBLE + ALAC_HEADER) {

                av_log(s, AV_LOG_ERROR, ""invalid ALAC magic cookie
"");

                av_freep(&ct->codec->extradata);

                return AVERROR_INVALIDDATA;

            }

            avio_read(pb, ct->codec->extradata, ALAC_HEADER);

            avio_skip(pb, args - ALAC_PREAMBLE - ALAC_HEADER);

        } else {

            AV_WB32(ct->codec->extradata, 36);

            memcpy(&ct->codec->extradata[4], ""alac"", 4);

            AV_WB32(&ct->codec->extradata[8], 0);

            memcpy(&ct->codec->extradata[12],  preambe, 12);

            avio_read(pb, &ct->codec->extradata[24], ALAC_NEW_KUKI - 12);

            avio_skip(pb, args - ALAC_NEW_KUKI);

        }

        ct->codec->extradata_size = ALAC_HEADER;

    } else {

        ct->codec->extradata = av_mallocz(args + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!st->codec->extradata)

            return AVERROR(ENOMEM);

        avio_read(pb, ct->codec->extradata, args);

        ct->codec->extradata_size = args;

    }



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,size,pb,st,strt,skip,atom,preamble",,,,28,"s:s,size:args,pb:pb,st:ct,strt:strt,skip:skip,atom:node,preamble: preambe,",4,GA,480,0.2138801137606303,GA,
141,"static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset,

                                       sPAPRPHBState *sphb)

{

    ResourceProps rp;

    bool is_bridge = false;

    int pci_status, err;

    char *buf = NULL;

    uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev);

    uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3);

    uint32_t max_msi, max_msix;



    if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) ==

        PCI_HEADER_TYPE_BRIDGE) {

        is_bridge = true;

    }



    /* in accordance with PAPR+ v2.7 13.6.3, Table 181 */

    _FDT(fdt_setprop_cell(fdt, offset, ""vendor-id"",

                          pci_default_read_config(dev, PCI_VENDOR_ID, 2)));

    _FDT(fdt_setprop_cell(fdt, offset, ""device-id"",

                          pci_default_read_config(dev, PCI_DEVICE_ID, 2)));

    _FDT(fdt_setprop_cell(fdt, offset, ""revision-id"",

                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));

    _FDT(fdt_setprop_cell(fdt, offset, ""class-code"", ccode));

    if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) {

        _FDT(fdt_setprop_cell(fdt, offset, ""interrupts"",

                 pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)));

    }



    if (!is_bridge) {

        _FDT(fdt_setprop_cell(fdt, offset, ""min-grant"",

            pci_default_read_config(dev, PCI_MIN_GNT, 1)));

        _FDT(fdt_setprop_cell(fdt, offset, ""max-latency"",

            pci_default_read_config(dev, PCI_MAX_LAT, 1)));

    }



    if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) {

        _FDT(fdt_setprop_cell(fdt, offset, ""subsystem-id"",

                 pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)));

    }



    if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) {

        _FDT(fdt_setprop_cell(fdt, offset, ""subsystem-vendor-id"",

                 pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)));

    }



    _FDT(fdt_setprop_cell(fdt, offset, ""cache-line-size"",

        pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1)));



    /* the following fdt cells are masked off the pci status register */

    pci_status = pci_default_read_config(dev, PCI_STATUS, 2);

    _FDT(fdt_setprop_cell(fdt, offset, ""devsel-speed"",

                          PCI_STATUS_DEVSEL_MASK & pci_status));



    if (pci_status & PCI_STATUS_FAST_BACK) {

        _FDT(fdt_setprop(fdt, offset, ""fast-back-to-back"", NULL, 0));

    }

    if (pci_status & PCI_STATUS_66MHZ) {

        _FDT(fdt_setprop(fdt, offset, ""66mhz-capable"", NULL, 0));

    }

    if (pci_status & PCI_STATUS_UDF) {

        _FDT(fdt_setprop(fdt, offset, ""udf-supported"", NULL, 0));

    }



    _FDT(fdt_setprop_string(fdt, offset, ""name"",

                            pci_find_device_name((ccode >> 16) & 0xff,

                                                 (ccode >> 8) & 0xff,

                                                 ccode & 0xff)));

    buf = spapr_phb_get_loc_code(sphb, dev);

    if (!buf) {

        error_report(""Failed setting the ibm,loc-code"");

        return -1;

    }



    err = fdt_setprop_string(fdt, offset, ""ibm,loc-code"", buf);

    g_free(buf);

    if (err < 0) {

        return err;

    }



    if (drc_index) {

        _FDT(fdt_setprop_cell(fdt, offset, ""ibm,my-drc-index"", drc_index));

    }



    _FDT(fdt_setprop_cell(fdt, offset, ""#address-cells"",

                          RESOURCE_CELLS_ADDRESS));

    _FDT(fdt_setprop_cell(fdt, offset, ""#size-cells"",

                          RESOURCE_CELLS_SIZE));



    max_msi = msi_nr_vectors_allocated(dev);

    if (max_msi) {

        _FDT(fdt_setprop_cell(fdt, offset, ""ibm,req#msi"", max_msi));

    }

    max_msix = dev->msix_entries_nr;

    if (max_msix) {

        _FDT(fdt_setprop_cell(fdt, offset, ""ibm,req#msi-x"", max_msix));

    }



    populate_resource_props(dev, &rp);

    _FDT(fdt_setprop(fdt, offset, ""reg"", (uint8_t *)rp.reg, rp.reg_len));

    _FDT(fdt_setprop(fdt, offset, ""assigned-addresses"",

                     (uint8_t *)rp.assigned, rp.assigned_len));



    if (sphb->pcie_ecs && pci_is_express(dev)) {

        _FDT(fdt_setprop_cell(fdt, offset, ""ibm,pci-config-space-type"", 0x1));

    }



    return 0;

}
",746,,LABEL_1,LABEL_0,,-4,"dev,fdt,offset,sphb,rp,pci_status,err,buf,max_msi,max_msix",,,,0,,0,Greedy,1,0.0008834640185038249,,
142,"static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    PCXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    int compressed, xmin, ymin, xmax, ymax;

    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,

                 bytes_per_scanline;

    uint8_t *ptr;

    uint8_t const *bufstart = buf;

    uint8_t *scanline;

    int ret = -1;



    if (buf[0] != 0x0a || buf[1] > 5) {

        av_log(avctx, AV_LOG_ERROR, ""this is not PCX encoded data\n"");

        return AVERROR_INVALIDDATA;

    }



    compressed = buf[2];

    xmin = AV_RL16(buf+ 4);

    ymin = AV_RL16(buf+ 6);

    xmax = AV_RL16(buf+ 8);

    ymax = AV_RL16(buf+10);



    if (xmax < xmin || ymax < ymin) {

        av_log(avctx, AV_LOG_ERROR, ""invalid image dimensions\n"");

        return AVERROR_INVALIDDATA;

    }



    w = xmax - xmin + 1;

    h = ymax - ymin + 1;



    bits_per_pixel     = buf[3];

    bytes_per_line     = AV_RL16(buf+66);

    nplanes            = buf[65];

    bytes_per_scanline = nplanes * bytes_per_line;



    if (bytes_per_scanline < w * bits_per_pixel * nplanes / 8) {

        av_log(avctx, AV_LOG_ERROR, ""PCX data is corrupted\n"");

        return AVERROR_INVALIDDATA;

    }



    switch ((nplanes<<8) + bits_per_pixel) {

        case 0x0308:

            avctx->pix_fmt = AV_PIX_FMT_RGB24;

            break;

        case 0x0108:

        case 0x0104:

        case 0x0102:

        case 0x0101:

        case 0x0401:

        case 0x0301:

        case 0x0201:

            avctx->pix_fmt = AV_PIX_FMT_PAL8;

            break;

        default:

            av_log(avctx, AV_LOG_ERROR, ""invalid PCX file\n"");

            return AVERROR_INVALIDDATA;

    }



    buf += 128;



    if (p->data[0])

        avctx->release_buffer(avctx, p);



    if (av_image_check_size(w, h, 0, avctx))

        return AVERROR_INVALIDDATA;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if ((ret = avctx->get_buffer(avctx, p)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return ret;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    ptr    = p->data[0];

    stride = p->linesize[0];



    scanline = av_malloc(bytes_per_scanline);

    if (!scanline)

        return AVERROR(ENOMEM);



    if (nplanes == 3 && bits_per_pixel == 8) {

        for (y=0; y<h; y++) {

            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++) {

                ptr[3*x  ] = scanline[x                    ];

                ptr[3*x+1] = scanline[x+ bytes_per_line    ];

                ptr[3*x+2] = scanline[x+(bytes_per_line<<1)];

            }



            ptr += stride;

        }



    } else if (nplanes == 1 && bits_per_pixel == 8) {

        const uint8_t *palstart = bufstart + buf_size - 769;



        for (y=0; y<h; y++, ptr+=stride) {

            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);

            memcpy(ptr, scanline, w);

        }



        if (buf != palstart) {

            av_log(avctx, AV_LOG_WARNING, ""image data possibly corrupted\n"");

            buf = palstart;

        }

        if (*buf++ != 12) {

            av_log(avctx, AV_LOG_ERROR, ""expected palette after image data\n"");

            ret = AVERROR_INVALIDDATA;

            goto end;

        }



    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */

        GetBitContext s;



        for (y=0; y<h; y++) {

            init_get_bits(&s, scanline, bytes_per_scanline<<3);



            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++)

                ptr[x] = get_bits(&s, bits_per_pixel);

            ptr += stride;

        }



    } else {    /* planar, 4, 8 or 16 colors */

        int i;



        for (y=0; y<h; y++) {

            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++) {

                int m = 0x80 >> (x&7), v = 0;

                for (i=nplanes - 1; i>=0; i--) {

                    v <<= 1;

                    v  += !!(scanline[i*bytes_per_line + (x>>3)] & m);

                }

                ptr[x] = v;

            }

            ptr += stride;

        }

    }



    if (nplanes == 1 && bits_per_pixel == 8) {

        pcx_palette(&buf, (uint32_t *) p->data[1], 256);

    } else if (bits_per_pixel * nplanes == 1) {

        AV_WN32A(p->data[1]  , 0xFF000000);

        AV_WN32A(p->data[1]+4, 0xFFFFFFFF);

    } else if (bits_per_pixel < 8) {

        const uint8_t *palette = bufstart+16;

        pcx_palette(&palette, (uint32_t *) p->data[1], 16);

    }



    *picture = s->picture;

    *data_size = sizeof(AVFrame);



    ret = buf - bufstart;

end:

    av_free(scanline);

    return ret;

}
",1129,"static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *feat = avpkt->data;

    int buf_size = avpkt->size;

    PCXContext * const cs = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const pl= &cs->picture;

    int compressed, xmin, ymin, xmax, ymax;

    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,

                 bytes_per_scanline;

    uint8_t *ptr;

    uint8_t const *bbufstart= feat;

    uint8_t *scanline;

    int ret = -1;



    if (feat[0] != 0x0a || feat[1] > 5) {

        av_log(avctx, AV_LOG_ERROR, ""this is not PCX encoded data
"");

        return AVERROR_INVALIDDATA;

    }



    ccompressed= feat[2];

    xxmin= AV_RL16(feat+ 4);

    yymin= AV_RL16(feat+ 6);

    xxmax= AV_RL16(feat+ 8);

    yymax= AV_RL16(feat+10);



    if (xmax < xmin || ymax < ymin) {

        av_log(avctx, AV_LOG_ERROR, ""invalid image dimensions
"");

        return AVERROR_INVALIDDATA;

    }



    w = xmax - xmin + 1;

    h = ymax - ymin + 1;



    bbits_per_pixel    = feat[3];

    bbytes_per_line    = AV_RL16(feat+66);

    nnplanes           = feat[65];

    bytes_per_scanline = nplanes * bytes_per_line;



    if (bytes_per_scanline < w * bits_per_pixel * nplanes / 8) {

        av_log(avctx, AV_LOG_ERROR, ""PCX data is corrupted
"");

        return AVERROR_INVALIDDATA;

    }



    switch ((nplanes<<8) + bits_per_pixel) {

        case 0x0308:

            avctx->pix_fmt = AV_PIX_FMT_RGB24;

            break;

        case 0x0108:

        case 0x0104:

        case 0x0102:

        case 0x0101:

        case 0x0401:

        case 0x0301:

        case 0x0201:

            avctx->pix_fmt = AV_PIX_FMT_PAL8;

            break;

        default:

            av_log(avctx, AV_LOG_ERROR, ""invalid PCX file
"");

            return AVERROR_INVALIDDATA;

    }



    feat += 128;



    if (l->data[0])

        avctx->release_buffer(avctx, l);



    if (av_image_check_size(w, h, 0, avctx))

        return AVERROR_INVALIDDATA;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if ((ret = avctx->get_buffer(avctx, l)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
"");

        return ret;

    }



    l->pict_type = AV_PICTURE_TYPE_I;



    ptr    = l->data[0];

    stride = l->linesize[0];



    scanline = av_malloc(bytes_per_scanline);

    if (!scanline)

        return AVERROR(ENOMEM);



    if (nplanes == 3 && bits_per_pixel == 8) {

        for (y=0; y<h; y++) {

            feat = pcx_rle_decode(feat, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++) {

                ptr[3*x  ] = scanline[x                    ];

                ptr[3*x+1] = scanline[x+ bytes_per_line    ];

                ptr[3*x+2] = scanline[x+(bytes_per_line<<1)];

            }



            ptr += stride;

        }



    } else if (nplanes == 1 && bits_per_pixel == 8) {

        const uint8_t *palstart = bufstart + buf_size - 769;



        for (y=0; y<h; y++, ptr+=stride) {

            feat = pcx_rle_decode(feat, scanline, bytes_per_scanline, compressed);

            memcpy(ptr, scanline, w);

        }



        if (feat != palstart) {

            av_log(avctx, AV_LOG_WARNING, ""image data possibly corrupted
"");

            feat = palstart;

        }

        if (*feat++ != 12) {

            av_log(avctx, AV_LOG_ERROR, ""expected palette after image data
"");

            ret = AVERROR_INVALIDDATA;

            goto end;

        }



    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */

        GetBitContext cs;



        for (y=0; y<h; y++) {

            init_get_bits(&cs, scanline, bytes_per_scanline<<3);



            feat = pcx_rle_decode(feat, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++)

                pptrxx = get_bits(&cs, bits_per_pixel);

            ptr += stride;

        }



    } else {    /* planar, 4, 8 or 16 colors */

        int i;



        for (y=0; y<h; y++) {

            feat = pcx_rle_decode(feat, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++) {

                int m = 0x80 >> (x&7), v = 0;

                for (i=nplanes - 1; i>=0; i--) {

                    v <<= 1;

                    v  += !!(scanline[i*bytes_per_line + (x>>3)] & m);

                }

                ptr[x] = v;

            }

            ptr += stride;

        }

    }



    if (nplanes == 1 && bits_per_pixel == 8) {

        pcx_palette(&feat, (uint32_t *) l->data[1], 256);

    } else if (bits_per_pixel * nplanes == 1) {

        AV_WN32A(l->data[1]  , 0xFF000000);

        AV_WN32A(l->data[1]+4, 0xFFFFFFFF);

    } else if (bits_per_pixel < 8) {

        const uint8_t *palette = bufstart+16;

        pcx_palette(&palette, (uint32_t *) l->data[1], 16);

    }



    *ppicture= cs->picture;

    *data_size = sizeof(AVFrame);



    ret = feat - bufstart;

end:

    av_free(scanline);

    return ret;

}
",LABEL_1,LABEL_1,LABEL_0,1,"avctx,data,data_size,avpkt,buf,s,picture,p,compressed,xmin,ymin,xmax,ymax,w,h,bits_per_pixel,bytes_per_line,nplanes,stride,y,x,bytes_per_scanline,ptr,bufstart,scanline",,,,186,"avctx:avctx,data:data,data_size:data_size,avpkt:avpkt,buf:feat,s:cs,picture:picture,p:l,compressed:compressed,xmin:xmin,ymin:ymin,xmax:xmax,ymax:ymax,w:w,h:h,bits_per_pixel:bits_per_pixel,bytes_per_line:bytes_per_line,nplanes:nplanes,stride:stride,y:y,x:x,bytes_per_scanline:bytes_per_scanline,ptr:ptr,bufstart:bufstart,scanline:scanline,",22,GA,874,0.47536611557006836,GA,
143,"void ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f)

{

    PerThreadContext *p = avctx->internal->thread_ctx;

    FrameThreadContext *fctx;

    AVFrame *dst, *tmp;

FF_DISABLE_DEPRECATION_WARNINGS

    int can_direct_free = !(avctx->active_thread_type & FF_THREAD_FRAME) ||

                          avctx->thread_safe_callbacks                   ||

                          (

#if FF_API_GET_BUFFER

                           !avctx->get_buffer &&

#endif

                           avctx->get_buffer2 == avcodec_default_get_buffer2);

FF_ENABLE_DEPRECATION_WARNINGS



    if (!f->f->buf[0])

        return;



    if (avctx->debug & FF_DEBUG_BUFFERS)

        av_log(avctx, AV_LOG_DEBUG, ""thread_release_buffer called on pic %p\n"", f);



    av_buffer_unref(&f->progress);

    f->owner    = NULL;



    if (can_direct_free) {

        av_frame_unref(f->f);

        return;

    }



    fctx = p->parent;

    pthread_mutex_lock(&fctx->buffer_mutex);



    if (p->num_released_buffers + 1 >= INT_MAX / sizeof(*p->released_buffers))

        goto fail;

    tmp = av_fast_realloc(p->released_buffers, &p->released_buffers_allocated,

                          (p->num_released_buffers + 1) *

                          sizeof(*p->released_buffers));

    if (!tmp)

        goto fail;

    p->released_buffers = tmp;



    dst = &p->released_buffers[p->num_released_buffers];

    av_frame_move_ref(dst, f->f);



    p->num_released_buffers++;



fail:

    pthread_mutex_unlock(&fctx->buffer_mutex);

}
",279,,LABEL_1,LABEL_0,,-4,"avctx,f,p,fctx,dst,tmp,num_released_buffers",,,,0,,0,Greedy,1,0.0006003777186075846,,
144,"static bool try_poll_mode(AioContext *ctx, bool blocking)

{

    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),

                             (uint64_t)ctx->poll_ns);



        if (max_ns) {

            poll_set_started(ctx, true);



            if (run_poll_handlers(ctx, max_ns)) {

                return true;

            }

        }

    }



    poll_set_started(ctx, false);



    /* Even if we don't run busy polling, try polling once in case it can make

     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).

     */

    return run_poll_handlers_once(ctx);

}
",146,,LABEL_0,LABEL_0,LABEL_0,-1,"ctx,blocking",,,,0,,0,GA,488,0.17995100021362304,failed,
145,"static inline void RENAME(yuv2yuvX_ar)(SwsContext *c, const int16_t *lumFilter,

                                       const int16_t **lumSrc, int lumFilterSize,

                                       const int16_t *chrFilter, const int16_t **chrUSrc,

                                       const int16_t **chrVSrc,

                                       int chrFilterSize, const int16_t **alpSrc,

                                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest,

                                       uint8_t *aDest, long dstW, long chrDstW)

{

    if (uDest) {

        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)

        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, vDest, chrDstW + c->uv_off, c->uv_off)

    }

    if (CONFIG_SWSCALE_ALPHA && aDest) {

        YSCALEYUV2YV12X_ACCURATE(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)

    }



    YSCALEYUV2YV12X_ACCURATE(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)

}
",135,"static inline void RENAME(yuv2yuvX_ar)(SwsContext *cache, const int16_t *lumFilter,

                                       const int16_t **lumVSRC, int lumFilterSize,

                                       const int16_t *chrFilter, const int16_t **chrUSrc,

                                       const int16_t **chrVSrc,

                                       int chrbSortLength, const int16_t **alpSrc,

                                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest,

                                       uint8_t *aDest, long drcWS, long chrDstW)

{

    if (uDest) {

        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)

        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, vDest, cvDestW chrDstW->uv_off, cache->uv_off)

    }

    if (CONFIG_SWSCALE_ALPHA && aDest) {

        YSCALEYUV2YV12X_ACCURATE(ALP_MMX_FILTER_OFFSET, aDest, drcWS, 0)

    }



    YSCALEYUV2YV12X_ACCURATE(LUM_MMX_FILTER_OFFSET, dest, drcWS, 0)

}
",LABEL_1,LABEL_1,LABEL_0,1,"c,lumFilter,lumSrc,lumFilterSize,chrFilter,chrUSrc,chrVSrc,chrFilterSize,alpSrc,dest,uDest,vDest,aDest,dstW,chrDstW",,,,19,"c:cache,lumFilter:lumFilter,lumSrc:lumVSRC,lumFilterSize:lumFilterSize,chrFilter:chrFilter,chrUSrc:chrUSrc,chrVSrc:chrVSrc,chrFilterSize:chrbSortLength,alpSrc:alpSrc,dest:dest,uDest:uDest,vDest:vDest,aDest:aDest,dstW:drcWS,chrDstW:chrDstW,",11,GA,518,0.19212405681610106,GA,
146,"int page_unprotect(target_ulong address, uintptr_t pc, void *puc)

{

    unsigned int prot;

    PageDesc *p;

    target_ulong host_start, host_end, addr;



    /* Technically this isn't safe inside a signal handler.  However we

       know this only ever happens in a synchronous SEGV handler, so in

       practice it seems to be ok.  */

    mmap_lock();



    p = page_find(address >> TARGET_PAGE_BITS);

    if (!p) {

        mmap_unlock();

        return 0;

    }



    /* if the page was really writable, then we change its

       protection back to writable */

    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {

        host_start = address & qemu_host_page_mask;

        host_end = host_start + qemu_host_page_size;



        prot = 0;

        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {

            p = page_find(addr >> TARGET_PAGE_BITS);

            p->flags |= PAGE_WRITE;

            prot |= p->flags;



            /* and since the content will be modified, we must invalidate

               the corresponding translated code. */

            tb_invalidate_phys_page(addr, pc, puc);

#ifdef DEBUG_TB_CHECK

            tb_invalidate_check(addr);

#endif

        }

        mprotect((void *)g2h(host_start), qemu_host_page_size,

                 prot & PAGE_BITS);



        mmap_unlock();

        return 1;

    }

    mmap_unlock();

    return 0;

}
",259,,LABEL_1,LABEL_0,,-4,"address,pc,puc,prot,p,host_start,host_end,addr",,,,0,,0,Greedy,1,0.000591433048248291,,
147,"static int bt_hci_parse(const char *str)

{

    struct HCIInfo *hci;

    bdaddr_t bdaddr;



    if (nb_hcis >= MAX_NICS) {

        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);

        return -1;

    }



    hci = hci_init(str);

    if (!hci)

        return -1;



    bdaddr.b[0] = 0x52;

    bdaddr.b[1] = 0x54;

    bdaddr.b[2] = 0x00;

    bdaddr.b[3] = 0x12;

    bdaddr.b[4] = 0x34;

    bdaddr.b[5] = 0x56 + nb_hcis;

    hci->bdaddr_set(hci, bdaddr.b);



    hci_table[nb_hcis++] = hci;



    return 0;

}
",150,"static int bt_hci_parse(const char *text)

{

    struct HCIInfo *hhoci;

    bdaddr_t ndowner;



    if (nb_hcis >= MAX_NICS) {

        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).
"", MAX_NICS);

        return -1;

    }



    hhhoci= hci_init(text);

    if (!hci)

        return -1;



    ndowner.b[0] = 0x52;

    ndowner.b[1] = 0x54;

    ndowner.b[2] = 0x00;

    ndowner.b[3] = 0x12;

    ndowner.b[4] = 0x34;

    ndowner.b[5] = 0x56 + nb_hcis;

    hhoci->bdaddr_set(hhoci, ndowner.b);



    hci_table[nb_hcis++] = hhoci;



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"str,hci,bdaddr",,,,0,"str:text,hci:hhoci,bdaddr:ndowner,",0,GA,226,0.08282920122146606,GA,
148,"static void dsputil_init_mmx2(DSPContext *c, AVCodecContext *avctx,

                              int mm_flags)

{

    const int bit_depth      = avctx->bits_per_raw_sample;

    const int high_bit_depth = bit_depth > 8;



    c->prefetch = prefetch_mmx2;



    if (!high_bit_depth) {

        c->put_pixels_tab[0][1] = put_pixels16_x2_mmx2;

        c->put_pixels_tab[0][2] = put_pixels16_y2_mmx2;



        c->avg_pixels_tab[0][0] = avg_pixels16_mmx2;

        c->avg_pixels_tab[0][1] = avg_pixels16_x2_mmx2;

        c->avg_pixels_tab[0][2] = avg_pixels16_y2_mmx2;



        c->put_pixels_tab[1][1] = put_pixels8_x2_mmx2;

        c->put_pixels_tab[1][2] = put_pixels8_y2_mmx2;



        c->avg_pixels_tab[1][0] = avg_pixels8_mmx2;

        c->avg_pixels_tab[1][1] = avg_pixels8_x2_mmx2;

        c->avg_pixels_tab[1][2] = avg_pixels8_y2_mmx2;

    }



    if (!(avctx->flags & CODEC_FLAG_BITEXACT)) {

        if (!high_bit_depth) {

            c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_mmx2;

            c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_mmx2;

            c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_mmx2;

            c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_mmx2;



            c->avg_pixels_tab[0][3] = avg_pixels16_xy2_mmx2;

            c->avg_pixels_tab[1][3] = avg_pixels8_xy2_mmx2;

        }



        if (CONFIG_VP3_DECODER && HAVE_YASM) {

            c->vp3_v_loop_filter = ff_vp3_v_loop_filter_mmx2;

            c->vp3_h_loop_filter = ff_vp3_h_loop_filter_mmx2;

        }

    }

    if (CONFIG_VP3_DECODER && HAVE_YASM)

        c->vp3_idct_dc_add = ff_vp3_idct_dc_add_mmx2;



    if (CONFIG_VP3_DECODER && (avctx->codec_id == CODEC_ID_VP3 ||

                               avctx->codec_id == CODEC_ID_THEORA)) {

        c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_exact_mmx2;

        c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_exact_mmx2;

    }



    if (CONFIG_H264QPEL) {

        SET_QPEL_FUNCS(put_qpel,        0, 16, mmx2, );

        SET_QPEL_FUNCS(put_qpel,        1,  8, mmx2, );

        SET_QPEL_FUNCS(put_no_rnd_qpel, 0, 16, mmx2, );

        SET_QPEL_FUNCS(put_no_rnd_qpel, 1,  8, mmx2, );

        SET_QPEL_FUNCS(avg_qpel,        0, 16, mmx2, );

        SET_QPEL_FUNCS(avg_qpel,        1,  8, mmx2, );



        if (!high_bit_depth) {

            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, mmx2, );

            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, mmx2, );

            SET_QPEL_FUNCS(put_h264_qpel, 2,  4, mmx2, );

            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, mmx2, );

            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, mmx2, );

            SET_QPEL_FUNCS(avg_h264_qpel, 2,  4, mmx2, );

        } else if (bit_depth == 10) {

#if HAVE_YASM

#if !ARCH_X86_64

            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, 10_mmxext, ff_);

            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, 10_mmxext, ff_);

            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, 10_mmxext, ff_);

            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, 10_mmxext, ff_);

#endif

            SET_QPEL_FUNCS(put_h264_qpel, 2, 4,  10_mmxext, ff_);

            SET_QPEL_FUNCS(avg_h264_qpel, 2, 4,  10_mmxext, ff_);

#endif

        }



        SET_QPEL_FUNCS(put_2tap_qpel, 0, 16, mmx2, );

        SET_QPEL_FUNCS(put_2tap_qpel, 1,  8, mmx2, );

        SET_QPEL_FUNCS(avg_2tap_qpel, 0, 16, mmx2, );

        SET_QPEL_FUNCS(avg_2tap_qpel, 1,  8, mmx2, );

    }



#if HAVE_YASM

    if (!high_bit_depth && CONFIG_H264CHROMA) {

        c->avg_h264_chroma_pixels_tab[0] = ff_avg_h264_chroma_mc8_mmx2_rnd;

        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_mmx2;

        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_mmx2;

        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_mmx2;

    }

    if (bit_depth == 10 && CONFIG_H264CHROMA) {

        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_10_mmxext;

        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_10_mmxext;

        c->put_h264_chroma_pixels_tab[1] = ff_put_h264_chroma_mc4_10_mmxext;

        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_10_mmxext;

    }



    c->add_hfyu_median_prediction   = ff_add_hfyu_median_prediction_mmx2;



    c->scalarproduct_int16          = ff_scalarproduct_int16_mmx2;

    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_mmx2;



    if (avctx->flags & CODEC_FLAG_BITEXACT) {

        c->apply_window_int16 = ff_apply_window_int16_mmxext_ba;

    } else {

        c->apply_window_int16 = ff_apply_window_int16_mmxext;

    }

#endif

}
",811,,LABEL_0,LABEL_0,LABEL_0,-1,"c,avctx,mm_flags",,,,0,,0,GA,638,0.32414196729660033,failed,
149,"int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)

{

    int size, l;



    if (f->is_write)

        abort();



    size = size1;

    while (size > 0) {

        l = f->buf_size - f->buf_index;

        if (l == 0) {

            qemu_fill_buffer(f);

            l = f->buf_size - f->buf_index;

            if (l == 0)

                break;

        }

        if (l > size)

            l = size;

        memcpy(buf, f->buf + f->buf_index, l);

        f->buf_index += l;

        buf += l;

        size -= l;

    }

    return size1 - size;

}
",135,,LABEL_0,LABEL_1,,-4,"f,buf,size1,size,l",,,,0,,0,Greedy,1,0.0004993796348571778,,
150,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",83,,LABEL_0,LABEL_0,LABEL_0,-1,"p,d",,,,0,,0,GA,441,0.15685037771860758,failed,
151,"static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int v, i;



    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {

        if (length > 256 || !(s->state & PNG_PLTE))

            return AVERROR_INVALIDDATA;



        for (i = 0; i < length; i++) {

            v = bytestream2_get_byte(&s->gb);

            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);

        }

    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {

        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||

            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))

            return AVERROR_INVALIDDATA;



        for (i = 0; i < length / 2; i++) {

            /* only use the least significant bits */

            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);



            if (s->bit_depth > 8)

                AV_WB16(&s->transparent_color_be[2 * i], v);

            else

                s->transparent_color_be[i] = v;

        }

    } else {

        return AVERROR_INVALIDDATA;

    }



    bytestream2_skip(&s->gb, 4); /* crc */

    s->has_trns = 1;



    return 0;

}
",274,,LABEL_1,LABEL_0,,-4,"avctx,s,length,v,i",,,,0,,0,Greedy,1,0.0005822261174519857,,
152,"static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float bias)

{

    IndividualChannelStream *ics = &sce->ics;

    float *in    = sce->coeffs;

    float *out   = sce->ret;

    float *saved = sce->saved;

    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;

    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;

    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;

    float *buf  = ac->buf_mdct;

    float *temp = ac->temp;

    int i;



    // imdct

    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {

        if (ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE)

            av_log(ac->avctx, AV_LOG_WARNING,

                   ""Transition from an ONLY_LONG or LONG_STOP to an EIGHT_SHORT sequence detected. ""

                   ""If you heard an audible artifact, please submit the sample to the FFmpeg developers.\n"");

        for (i = 0; i < 1024; i += 128)

            ff_imdct_half(&ac->mdct_small, buf + i, in + i);

    } else

        ff_imdct_half(&ac->mdct, buf, in);



    /* window overlapping

     * NOTE: To simplify the overlapping code, all 'meaningless' short to long

     * and long to short transitions are considered to be short to short

     * transitions. This leaves just two cases (long to long and short to short)

     * with a little special sauce for EIGHT_SHORT_SEQUENCE.

     */

    if ((ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE) &&

            (ics->window_sequence[0] == ONLY_LONG_SEQUENCE || ics->window_sequence[0] == LONG_START_SEQUENCE)) {

        ac->dsp.vector_fmul_window(    out,               saved,            buf,         lwindow_prev, bias, 512);

    } else {

        for (i = 0; i < 448; i++)

            out[i] = saved[i] + bias;



        if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {

            ac->dsp.vector_fmul_window(out + 448 + 0*128, saved + 448,      buf + 0*128, swindow_prev, bias, 64);

            ac->dsp.vector_fmul_window(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow,      bias, 64);

            ac->dsp.vector_fmul_window(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow,      bias, 64);

            ac->dsp.vector_fmul_window(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow,      bias, 64);

            ac->dsp.vector_fmul_window(temp,              buf + 3*128 + 64, buf + 4*128, swindow,      bias, 64);

            memcpy(                    out + 448 + 4*128, temp, 64 * sizeof(float));

        } else {

            ac->dsp.vector_fmul_window(out + 448,         saved + 448,      buf,         swindow_prev, bias, 64);

            for (i = 576; i < 1024; i++)

                out[i] = buf[i-512] + bias;

        }

    }



    // buffer update

    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {

        for (i = 0; i < 64; i++)

            saved[i] = temp[64 + i] - bias;

        ac->dsp.vector_fmul_window(saved + 64,  buf + 4*128 + 64, buf + 5*128, swindow, 0, 64);

        ac->dsp.vector_fmul_window(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 0, 64);

        ac->dsp.vector_fmul_window(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 0, 64);

        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));

    } else if (ics->window_sequence[0] == LONG_START_SEQUENCE) {

        memcpy(                    saved,       buf + 512,        448 * sizeof(float));

        memcpy(                    saved + 448, buf + 7*128 + 64,  64 * sizeof(float));

    } else { // LONG_STOP or ONLY_LONG

        memcpy(                    saved,       buf + 512,        512 * sizeof(float));

    }

}
",898,,LABEL_1,LABEL_0,,-4,"ac,sce,bias,ics,in,out,saved,swindow,lwindow_prev,swindow_prev,buf,temp,i",,,,0,,0,Greedy,1,0.0009304682413736979,,
153,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",70,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *yssrc, const uint8_t *USrid, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(yssrc, USrid, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",LABEL_0,LABEL_0,LABEL_1,1,"ysrc,usrc,vsrc,dst,height,lumStride,chromStride,dstStride",,,,12,"ysrc:yssrc,usrc:USrid,vsrc:vsrc,dst:dst,height:height,lumStride:lumStride,chromStride:chromStride,dstStride:dstStride,",6,GA,294,0.10526055892308553,GA,
154,"static void puv3_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *initrd_filename = machine->initrd_filename;

    CPUUniCore32State *env;

    UniCore32CPU *cpu;



    if (initrd_filename) {

        error_report(""Please use kernel built-in initramdisk"");

        exit(1);

    }



    if (!cpu_model) {

        cpu_model = ""UniCore-II"";

    }



    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));

    if (!cpu) {

        error_report(""Unable to find CPU definition"");

        exit(1);

    }

    env = &cpu->env;



    puv3_soc_init(env);

    puv3_board_init(env, ram_size);

    puv3_load_kernel(kernel_filename);

}
",138,,LABEL_1,LABEL_0,,-4,"machine,cpu_model,kernel_filename,initrd_filename,env,cpu",,,,0,,0,Greedy,1,0.00052337646484375,,
155,"static void virtio_queue_notify_vq(VirtQueue *vq)
{
    if (vq->vring.desc && vq->handle_output) {
        VirtIODevice *vdev = vq->vdev;
        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);
        vq->handle_output(vdev, vq);",58,,LABEL_1,LABEL_1,LABEL_1,-1,"vq,vdev",,,,0,,0,GA,532,0.18764007488886517,failed,
156,"int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)

{

    PerThreadContext *p = avctx->thread_opaque;

    int *progress, err;



    f->owner = avctx;



    ff_init_buffer_info(avctx, f);



    if (!(avctx->active_thread_type&FF_THREAD_FRAME)) {

        f->thread_opaque = NULL;

        return avctx->get_buffer(avctx, f);

    }



    if (p->state != STATE_SETTING_UP &&

        (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks &&

                avctx->get_buffer != avcodec_default_get_buffer))) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() cannot be called after ff_thread_finish_setup()\n"");

        return -1;

    }



    pthread_mutex_lock(&p->parent->buffer_mutex);

    f->thread_opaque = progress = allocate_progress(p);



    if (!progress) {

        pthread_mutex_unlock(&p->parent->buffer_mutex);

        return -1;

    }



    progress[0] =

    progress[1] = -1;



    if (avctx->thread_safe_callbacks ||

        avctx->get_buffer == avcodec_default_get_buffer) {

        err = avctx->get_buffer(avctx, f);

    } else {

        p->requested_frame = f;

        p->state = STATE_GET_BUFFER;

        pthread_mutex_lock(&p->progress_mutex);

        pthread_cond_signal(&p->progress_cond);



        while (p->state != STATE_SETTING_UP)

            pthread_cond_wait(&p->progress_cond, &p->progress_mutex);



        err = p->result;



        pthread_mutex_unlock(&p->progress_mutex);



        if (!avctx->codec->update_thread_context)

            ff_thread_finish_setup(avctx);

    }



    pthread_mutex_unlock(&p->parent->buffer_mutex);



    return err;

}
",332,,LABEL_1,LABEL_0,,-4,"avctx,f,p,progress,err",,,,0,,0,Greedy,1,0.0006255825360616048,,
157,"int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,

                         int level)

{

    VDPAUHWContext *hwctx = avctx->hwaccel_context;

    VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data;

    VdpVideoSurfaceQueryCapabilities *surface_query_caps;

    VdpDecoderQueryCapabilities *decoder_query_caps;

    VdpDecoderCreate *create;

    void *func;

    VdpStatus status;

    VdpBool supported;

    uint32_t max_level, max_mb, max_width, max_height;

    VdpChromaType type;

    uint32_t width;

    uint32_t height;



    vdctx->width            = UINT32_MAX;

    vdctx->height           = UINT32_MAX;



    if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height))

        return AVERROR(ENOSYS);



    if (hwctx) {

        hwctx->reset            = 0;



        if (hwctx->context.decoder != VDP_INVALID_HANDLE) {

            vdctx->decoder = hwctx->context.decoder;

            vdctx->render  = hwctx->context.render;

            vdctx->device  = VDP_INVALID_HANDLE;

            return 0; /* Decoder created by user */

        }



        vdctx->device           = hwctx->device;

        vdctx->get_proc_address = hwctx->get_proc_address;



        if (hwctx->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)

            level = 0;



        if (!(hwctx->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) &&

            type != VDP_CHROMA_TYPE_420)

            return AVERROR(ENOSYS);

    } else {

        AVHWFramesContext *frames_ctx = NULL;

        AVVDPAUDeviceContext *dev_ctx;



        // We assume the hw_frames_ctx always survives until ff_vdpau_common_uninit

        // is called. This holds true as the user is not allowed to touch

        // hw_device_ctx, or hw_frames_ctx after get_format (and ff_get_format

        // itself also uninits before unreffing hw_frames_ctx).

        if (avctx->hw_frames_ctx) {

            frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;

        } else if (avctx->hw_device_ctx) {

            int ret;



            avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);

            if (!avctx->hw_frames_ctx)

                return AVERROR(ENOMEM);



            frames_ctx            = (AVHWFramesContext*)avctx->hw_frames_ctx->data;

            frames_ctx->format    = AV_PIX_FMT_VDPAU;

            frames_ctx->sw_format = avctx->sw_pix_fmt;

            frames_ctx->width     = avctx->coded_width;

            frames_ctx->height    = avctx->coded_height;



            ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);

            if (ret < 0) {

                av_buffer_unref(&avctx->hw_frames_ctx);

                return ret;

            }

        }



        if (!frames_ctx) {

            av_log(avctx, AV_LOG_ERROR, ""A hardware frames context is ""

                   ""required for VDPAU decoding.\n"");

            return AVERROR(EINVAL);

        }



        dev_ctx = frames_ctx->device_ctx->hwctx;



        vdctx->device           = dev_ctx->device;

        vdctx->get_proc_address = dev_ctx->get_proc_address;



        if (avctx->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)

            level = 0;

    }



    if (level < 0)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device,

                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        surface_query_caps = func;



    status = surface_query_caps(vdctx->device, type, &supported,

                                &max_width, &max_height);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    if (supported != VDP_TRUE ||

        max_width < width || max_height < height)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device,

                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        decoder_query_caps = func;



    status = decoder_query_caps(vdctx->device, profile, &supported, &max_level,

                                &max_mb, &max_width, &max_height);

#ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE

    if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) {

        profile = VDP_DECODER_PROFILE_H264_MAIN;

        status = decoder_query_caps(vdctx->device, profile, &supported,

                                    &max_level, &max_mb,

                                    &max_width, &max_height);

    }

#endif

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);



    if (supported != VDP_TRUE || max_level < level ||

        max_width < width || max_height < height)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        create = func;



    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        vdctx->render = func;



    status = create(vdctx->device, profile, width, height, avctx->refs,

                    &vdctx->decoder);

    if (status == VDP_STATUS_OK) {

        vdctx->width  = avctx->coded_width;

        vdctx->height = avctx->coded_height;

    }



    return vdpau_error(status);

}
",882,"int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,

                         int level)

{

    VDPAUHWContext *rwsci = avctx->hwaccel_context;

    VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data;

    VdpVideoSurfaceQueryCapabilities *surface_query_caps;

    VdpDecoderQueryCapabilities *decoder_query_caps;

    VdpDecoderCreate *create;

    void *func;

    VdpStatus status;

    VdpBool  support;

    uint32_t max_level, min_lvl, max_width, max_height;

    VdpChromaType type;

    uint32_t width;

    uint32_t height;



    vdctx->width            = UINT32_MAX;

    vdctx->height           = UINT32_MAX;



    if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height))

        return AVERROR(ENOSYS);



    if (rwsci) {

        rwsci->reset            = 0;



        if (rwsci->context.decoder != VDP_INVALID_HANDLE) {

            vdctx->decoder = rwsci->context.decoder;

            vdctx->render  = rwsci->context.render;

            vdctx->device  = VDP_INVALID_HANDLE;

            return 0; /* Decoder created by user */

        }



        vdctx->device           = rwsci->device;

        vdctx->get_proc_address = rwsci->get_proc_address;



        if (rwsci->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)

            level = 0;



        if (!(rwsci->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) &&

            type != VDP_CHROMA_TYPE_420)

            return AVERROR(ENOSYS);

    } else {

        AVHWFramesContext *frames_ctx = NULL;

        AVVDPAUDeviceContext *dev_ctx;



        // We assume the hw_frames_ctx always survives until ff_vdpau_common_uninit

        // is called. This holds true as the user is not allowed to touch

        // hw_device_ctx, or hw_frames_ctx after get_format (and ff_get_format

        // itself also uninits before unreffing hw_frames_ctx).

        if (avctx->hw_frames_ctx) {

            frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;

        } else if (avctx->hw_device_ctx) {

            int ret;



            avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);

            if (!avctx->hw_frames_ctx)

                return AVERROR(ENOMEM);



            frames_ctx            = (AVHWFramesContext*)avctx->hw_frames_ctx->data;

            frames_ctx->format    = AV_PIX_FMT_VDPAU;

            frames_ctx->sw_format = avctx->sw_pix_fmt;

            frames_ctx->width     = avctx->coded_width;

            frames_ctx->height    = avctx->coded_height;



            ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);

            if (ret < 0) {

                av_buffer_unref(&avctx->hw_frames_ctx);

                return ret;

            }

        }



        if (!frames_ctx) {

            av_log(avctx, AV_LOG_ERROR, ""A hardware frames context is ""

                   ""required for VDPAU decoding.
"");

            return AVERROR(EINVAL);

        }



        dev_ctx = frames_ctx->device_ctx->rwsci;



        vdctx->device           = dev_ctx->device;

        vdctx->get_proc_address = dev_ctx->get_proc_address;



        if (avctx->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)

            level = 0;

    }



    if (level < 0)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device,

                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        surface_query_caps = func;



    status = surface_query_caps(vdctx->device,typee, & support,

                                &max_width, &max_height);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    if ( support != VDP_TRUE ||

        max_width < width || max_height < height)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device,

                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        decoder_query_caps = func;



    status = decoder_query_caps(vdctx->device, profile, & support, &max_level,

                                &min_lvl, &max_width, &max_height);

#ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE

    if ((status != VDP_STATUS_OK ||  support != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) {

        profile = VDP_DECODER_PROFILE_H264_MAIN;

        status = decoder_query_caps(vdctx->device, profile, & support,

                                    &max_level, &min_lvl,

                                    &max_width, &max_height);

    }

#endif

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);



    if ( support != VDP_TRUE || max_level < level ||

        max_width < width || max_height < height)

        return AVERROR(ENOTSUP);



    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        create = func;



    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER,

                                     &func);

    if (status != VDP_STATUS_OK)

        return vdpau_error(status);

    else

        vdctx->render = func;



    status = create(vdctx->device, profile, width, height, avctx->refs,

                    &vdctx->decoder);

    if (status == VDP_STATUS_OK) {

        vdctx->width  = avctx->coded_width;

        vdctx->height = avctx->coded_height;

    }



    return vdpau_error(status);

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,profile,level,hwctx,vdctx,surface_query_caps,decoder_query_caps,create,func,status,supported,max_level,max_mb,max_width,max_height,type,height,frames_ctx,dev_ctx,ret",,,,144,"avctx:avctx,profile:profile,level:level,hwctx:rwsci,vdctx:vdctx,surface_query_caps:surface_query_caps,decoder_query_caps:decoder_query_caps,create:create,func:func,status:status,supported: support,max_level:max_level,max_mb:min_lvl,max_width:max_width,max_height:max_height,type:type,height:height,frames_ctx:frames_ctx,dev_ctx:dev_ctx,ret:ret,",17,GA,674,0.345839524269104,GA,
158,"static void migrate_set_downtime(QTestState *who, const char *value)

{

    QDict *rsp;

    gchar *cmd;



    cmd = g_strdup_printf(""{ 'execute': 'migrate_set_downtime',""

                          ""'arguments': { 'value': %s } }"", value);

    rsp = qtest_qmp(who, cmd);

    g_free(cmd);

    g_assert(qdict_haskey(rsp, ""return""));

    QDECREF(rsp);

}
",63,,LABEL_0,LABEL_1,,-4,"who,value,rsp,cmd",,,,0,,0,Greedy,1,0.0004664460817972819,,
159,"static int find_dirty_height(VncState *vs, int y, int last_x, int x)

{

    int h;



    for (h = 1; h < (vs->serverds.height - y); h++) {

        int tmp_x;

        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))

            break;

        for (tmp_x = last_x; tmp_x < x; tmp_x++)

            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);

    }



    return h;

}
",102,,LABEL_1,LABEL_0,,-4,"vs,y,last_x,x,h,tmp_x",,,,0,,0,Greedy,1,0.0004661917686462402,,
160,"static void press_key(VncState *vs, int keysym)

{

    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);

    qemu_input_event_send_key_delay(0);

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);

    qemu_input_event_send_key_delay(0);

}
",77,,LABEL_0,LABEL_0,LABEL_0,-1,"vs,keysym",,,,0,,0,GA,441,0.15621418555577596,failed,
161,"static void tcx_blit_writel(void *opaque, hwaddr addr,

                            uint64_t val, unsigned size)

{

    TCXState *s = opaque;

    uint32_t adsr, len;

    int i;



    if (!(addr & 4)) {

        s->tmpblit = val;

    } else {

        addr = (addr >> 3) & 0xfffff;

        adsr = val & 0xffffff;

        len = ((val >> 24) & 0x1f) + 1;

        if (adsr == 0xffffff) {

            memset(&s->vram[addr], s->tmpblit, len);

            if (s->depth == 24) {

                val = s->tmpblit & 0xffffff;

                val = cpu_to_be32(val);

                for (i = 0; i < len; i++) {

                    s->vram24[addr + i] = val;

                }

            }

        } else {

            memcpy(&s->vram[addr], &s->vram[adsr], len);

            if (s->depth == 24) {

                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);

            }

        }

        memory_region_set_dirty(&s->vram_mem, addr, len);

    }

}
",242,"static void tcx_blit_writel(void *opaque, hwaddr conn,

                            uint64_t val, unsigned VAL)

{

    TCXState *g = opaque;

    uint32_t ansr, fin;

    int ti;



    if (!(conn & 4)) {

        g->tmpblit = val;

    } else {

        conn = (conn >> 3) & 0xfffff;

        ansr = val & 0xffffff;

        fin = ((val >> 24) & 0x1f) + 1;

        if (ansr == 0xffffff) {

            memset(&g->vram[conn], g->tmpblit, fin);

            if (g->depth == 24) {

                val = g->tmpblit & 0xffffff;

                val = cpu_to_be32(val);

                for (ti = 0; ti < fin; ti++) {

                    g->vram24[conn + ti] = val;

                }

            }

        } else {

            memcpy(&g->vram[conn], &g->vram[ansr], fin);

            if (g->depth == 24) {

                memcpy(&g->vram24[conn], &g->vram24[ansr], fin * 4);

            }

        }

        memory_region_set_dirty(&g->vram_mem, conn, fin);

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"opaque,addr,val,size,s,adsr,len,i",,,,10,"opaque:opaque,addr:conn,val:val,size:VAL,s:g,adsr:ansr,len:fin,i:ti,",2,GA,549,0.2097092827161153,GA,
162,"static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
    opj_image_cmptparm_t cmptparm[4] = {{0}};
    opj_image_t *img;
    int i;
    int sub_dx[4];
    int sub_dy[4];
    int numcomps;
    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;
    sub_dx[0] = sub_dx[3] = 1;
    sub_dy[0] = sub_dy[3] = 1;
    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;
    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;
    numcomps = desc->nb_components;
    switch (avctx->pix_fmt) {
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_YA8:
    case AV_PIX_FMT_GRAY16:
    case AV_PIX_FMT_YA16:
        color_space = CLRSPC_GRAY;
        break;
    case AV_PIX_FMT_RGB24:
    case AV_PIX_FMT_RGBA:
    case AV_PIX_FMT_RGB48:
    case AV_PIX_FMT_RGBA64:
    case AV_PIX_FMT_GBR24P:
    case AV_PIX_FMT_GBRP9:
    case AV_PIX_FMT_GBRP10:
    case AV_PIX_FMT_GBRP12:
    case AV_PIX_FMT_GBRP14:
    case AV_PIX_FMT_GBRP16:
    case AV_PIX_FMT_XYZ12:
        color_space = CLRSPC_SRGB;
        break;
    case AV_PIX_FMT_YUV410P:
    case AV_PIX_FMT_YUV411P:
    case AV_PIX_FMT_YUV420P:
    case AV_PIX_FMT_YUV422P:
    case AV_PIX_FMT_YUV440P:
    case AV_PIX_FMT_YUV444P:
    case AV_PIX_FMT_YUVA420P:
    case AV_PIX_FMT_YUVA422P:
    case AV_PIX_FMT_YUVA444P:
    case AV_PIX_FMT_YUV420P9:
    case AV_PIX_FMT_YUV422P9:
    case AV_PIX_FMT_YUV444P9:
    case AV_PIX_FMT_YUVA420P9:
    case AV_PIX_FMT_YUVA422P9:
    case AV_PIX_FMT_YUVA444P9:
    case AV_PIX_FMT_YUV420P10:
    case AV_PIX_FMT_YUV422P10:
    case AV_PIX_FMT_YUV444P10:
    case AV_PIX_FMT_YUVA420P10:
    case AV_PIX_FMT_YUVA422P10:
    case AV_PIX_FMT_YUVA444P10:
    case AV_PIX_FMT_YUV420P12:
    case AV_PIX_FMT_YUV422P12:
    case AV_PIX_FMT_YUV444P12:
    case AV_PIX_FMT_YUV420P14:
    case AV_PIX_FMT_YUV422P14:
    case AV_PIX_FMT_YUV444P14:
    case AV_PIX_FMT_YUV420P16:
    case AV_PIX_FMT_YUV422P16:
    case AV_PIX_FMT_YUV444P16:
    case AV_PIX_FMT_YUVA420P16:
    case AV_PIX_FMT_YUVA422P16:
    case AV_PIX_FMT_YUVA444P16:
        color_space = CLRSPC_SYCC;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR,
               ""The requested pixel format '%s' is not supported\n"",
               av_get_pix_fmt_name(avctx->pix_fmt));
    }
    for (i = 0; i < numcomps; i++) {
        cmptparm[i].prec = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].bpp  = desc->comp[i].depth_minus1 + 1;
        cmptparm[i].sgnd = 0;
        cmptparm[i].dx = sub_dx[i];
        cmptparm[i].dy = sub_dy[i];
        cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i];
        cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i];
    }
    img = opj_image_create(numcomps, cmptparm, color_space);
    // x0, y0 is the top left corner of the image
    // x1, y1 is the width, height of the reference grid
    img->x0 = 0;
    img->y0 = 0;
    img->x1 = (avctx->width  - 1) * parameters->subsampling_dx + 1;
    img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1;
    return img;
}",566,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,parameters,desc,cmptparm,img,i,sub_dx,sub_dy,numcomps",,,,0,,0,GA,1618,0.7344502806663513,failed,
163,"static int packet_enqueue(CompareState *s, int mode)

{

    ConnectionKey key;

    Packet *pkt = NULL;

    Connection *conn;



    if (mode == PRIMARY_IN) {

        pkt = packet_new(s->pri_rs.buf,

                         s->pri_rs.packet_len,

                         s->pri_rs.vnet_hdr_len);

    } else {

        pkt = packet_new(s->sec_rs.buf,

                         s->sec_rs.packet_len,

                         s->sec_rs.vnet_hdr_len);

    }



    if (parse_packet_early(pkt)) {

        packet_destroy(pkt, NULL);

        pkt = NULL;

        return -1;

    }

    fill_connection_key(pkt, &key);



    conn = connection_get(s->connection_track_table,

                          &key,

                          &s->conn_list);



    if (!conn->processing) {

        g_queue_push_tail(&s->conn_list, conn);

        conn->processing = true;

    }



    if (mode == PRIMARY_IN) {

        if (!colo_insert_packet(&conn->primary_list, pkt)) {

            error_report(""colo compare primary queue size too big,""

                         ""drop packet"");

        }

    } else {

        if (!colo_insert_packet(&conn->secondary_list, pkt)) {

            error_report(""colo compare secondary queue size too big,""

                         ""drop packet"");

        }

    }



    return 0;

}
",226,,LABEL_0,LABEL_0,LABEL_0,-1,"s,mode,key,pkt,conn",,,,0,,0,GA,1132,0.4352855006853739,failed,
164,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[n].u64[0] = ldq_p(mem_buf);

        env->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        env->avr[n].u64[1] = ldq_p(mem_buf);

        env->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;

    }

    if (n == 33) {

        env->vscr = ldl_p(mem_buf);

        return 4;

    }

    if (n == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);

        return 4;

    }

    return 0;

}
",155,"static int gdb_set_avr_reg(CPUState *err, uint8_t *Mem_brace, int un)

{

    if (un < 32) {

#ifdef WORDS_BIGENDIAN

        err->avr[n]unu64[0] = ldq_p(Mem_brace);

        err->avr[n]unu64[1] = ldq_p(Mem_brace+8);

#else

        err->avr[n]unu64[1] = ldq_p(Mem_brace);

        err->avr[n]unu64[0] = ldq_p(Mem_brace+8);

#endif

        return 16;

    }

    if (un == 33) {

        err->vscr = ldl_p(Mem_brace);

        return 4;

    }

    if (un == 34) {

        err->spr[SPR_VRSAVE] = (target_ulong)ldl_p(Mem_brace);

        return 4;

    }

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"env,mem_buf,n",,,,0,"env:err,mem_buf:Mem_brace,n:un,",0,GA,208,0.0766367793083191,GA,
165,"static void conditional_branch(DBDMA_channel *ch)

{

    dbdma_cmd *current = &ch->current;

    uint16_t br;

    uint16_t sel_mask, sel_value;

    uint32_t status;

    int cond;



    DBDMA_DPRINTF(""conditional_branch\n"");



    /* check if we must branch */



    br = le16_to_cpu(current->command) & BR_MASK;



    switch(br) {

    case BR_NEVER:  /* don't branch */

        next(ch);

        return;

    case BR_ALWAYS: /* always branch */

        branch(ch);

        return;

    }



    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;



    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;

    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;



    cond = (status & sel_mask) == (sel_value & sel_mask);



    switch(br) {

    case BR_IFSET:  /* branch if condition bit is 1 */

        if (cond)

            branch(ch);

        else

            next(ch);

        return;

    case BR_IFCLR:  /* branch if condition bit is 0 */

        if (!cond)

            branch(ch);

        else

            next(ch);

        return;

    }

}
",233,,LABEL_0,LABEL_0,LABEL_0,-1,"ch,current,br,sel_mask,sel_value,status,cond",,,,0,,0,GA,1438,0.5523553093274435,failed,
166,"void qemu_cpu_kick(void *env)

{

    return;

}
",11,,LABEL_0,LABEL_0,LABEL_0,-1,env,,,,0,,0,GA,238,0.08266934156417846,failed,
167,"static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode)

{

    int   band, result=0, numSubbands, lastTonal, numBands;



    if (codingMode == JOINT_STEREO && channelNum == 1) {

        if (get_bits(gb,2) != 3) {

            av_log(NULL,AV_LOG_ERROR,""JS mono Sound Unit id != 3.\n"");

            return -1;

        }

    } else {

        if (get_bits(gb,6) != 0x28) {

            av_log(NULL,AV_LOG_ERROR,""Sound Unit id != 0x28.\n"");

            return -1;

        }

    }



    /* number of coded QMF bands */

    pSnd->bandsCoded = get_bits(gb,2);



    result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded);

    if (result) return result;



    pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded);

    if (pSnd->numComponents == -1) return -1;



    numSubbands = decodeSpectrum (gb, pSnd->spectrum);



    /* Merge the decoded spectrum and tonal components. */

    lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components);





    /* calculate number of used MLT/QMF bands according to the amount of coded spectral lines */

    numBands = (subbandTab[numSubbands] - 1) >> 8;

    if (lastTonal >= 0)

        numBands = FFMAX((lastTonal + 256) >> 8, numBands);





    /* Reconstruct time domain samples. */

    for (band=0; band<4; band++) {

        /* Perform the IMDCT step without overlapping. */

        if (band <= numBands) {

            IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCT_buf, band&1);

        } else

            memset(pSnd->IMDCT_buf, 0, 512 * sizeof(float));



        /* gain compensation and overlapping */

        gainCompensateAndOverlap (pSnd->IMDCT_buf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]),

                                    &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]),

                                    &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band]));

    }



    /* Swap the gain control buffers for the next frame. */

    pSnd->gcBlkSwitch ^= 1;



    return 0;

}
",506,,LABEL_1,LABEL_0,,-4,"q,gb,pSnd,pOut,channelNum,codingMode,band,numSubbands,lastTonal,numBands",,,,0,,0,Greedy,1,0.0007569392522176107,,
168,"static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,

                             GetByteContext *gb)

{

    unsigned char rle_code;

    unsigned char extra_byte, odd_pixel;

    unsigned char stream_byte;

    unsigned int pixel_ptr = 0;

    int row_dec = pic->linesize[0];

    int row_ptr = (avctx->height - 1) * row_dec;

    int frame_size = row_dec * avctx->height;

    int i;



    while (row_ptr >= 0) {

        if (bytestream2_get_bytes_left(gb) <= 0) {

            av_log(avctx, AV_LOG_ERROR,

                   ""MS RLE: bytestream overrun, %d rows left\n"",

                   row_ptr);

            return AVERROR_INVALIDDATA;

        }

        rle_code = stream_byte = bytestream2_get_byteu(gb);

        if (rle_code == 0) {

            /* fetch the next byte to see how to handle escape code */

            stream_byte = bytestream2_get_byte(gb);

            if (stream_byte == 0) {

                /* line is done, goto the next one */

                row_ptr -= row_dec;

                pixel_ptr = 0;

            } else if (stream_byte == 1) {

                /* decode is done */

                return 0;

            } else if (stream_byte == 2) {

                /* reposition frame decode coordinates */

                stream_byte = bytestream2_get_byte(gb);

                pixel_ptr += stream_byte;

                stream_byte = bytestream2_get_byte(gb);

                row_ptr -= stream_byte * row_dec;

            } else {

                // copy pixels from encoded stream

                odd_pixel =  stream_byte & 1;

                rle_code = (stream_byte + 1) / 2;

                extra_byte = rle_code & 0x01;

                if (row_ptr + pixel_ptr + stream_byte > frame_size ||

                    bytestream2_get_bytes_left(gb) < rle_code) {

                    av_log(avctx, AV_LOG_ERROR,

                           ""MS RLE: frame/stream ptr just went out of bounds (copy)\n"");

                    return AVERROR_INVALIDDATA;

                }



                for (i = 0; i < rle_code; i++) {

                    if (pixel_ptr >= avctx->width)

                        break;

                    stream_byte = bytestream2_get_byteu(gb);

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;

                    pixel_ptr++;

                    if (i + 1 == rle_code && odd_pixel)

                        break;

                    if (pixel_ptr >= avctx->width)

                        break;

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;

                    pixel_ptr++;

                }



                // if the RLE code is odd, skip a byte in the stream

                if (extra_byte)

                    bytestream2_skip(gb, 1);

            }

        } else {

            // decode a run of data

            if (row_ptr + pixel_ptr + stream_byte > frame_size) {

                av_log(avctx, AV_LOG_ERROR,

                       ""MS RLE: frame ptr just went out of bounds (run)\n"");

                return AVERROR_INVALIDDATA;

            }

            stream_byte = bytestream2_get_byte(gb);

            for (i = 0; i < rle_code; i++) {

                if (pixel_ptr >= avctx->width)

                    break;

                if ((i & 1) == 0)

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;

                else

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;

                pixel_ptr++;

            }

        }

    }



    /* one last sanity check on the way out */

    if (bytestream2_get_bytes_left(gb)) {

        av_log(avctx, AV_LOG_ERROR,

               ""MS RLE: ended frame decode with %d bytes left over\n"",

               bytestream2_get_bytes_left(gb));

        return AVERROR_INVALIDDATA;

    }



    return 0;

}
",637,"static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,

                             GetByteContext *gb)

{

    unsigned char rle_code;

    unsigned char extra67byte, odd_pixel;

    unsigned char stream___block;

    unsigned int pixel_ptr = 0;

    int row_dec = pic->linesize[0];

    int row_ptr = (avctx->height - 1) * row_dec;

    int frame_size = row_dec * avctx->height;

    int id;



    while (row_ptr >= 0) {

        if (bytestream2_get_bytes_left(gb) <= 0) {

            av_log(avctx, AV_LOG_ERROR,

                   ""MS RLE: bytestream overrun, %d rows left
"",

                   row_ptr);

            return AVERROR_INVALIDDATA;

        }

        rle_code = stream___block = bytestream2_get_byteu(gb);

        if (rle_code == 0) {

            /* fetch the next byte to see how to handle escape code */

            stream___block = bytestream2_get_byte(gb);

            if (stream___block == 0) {

                /* line is done, goto the next one */

                row_ptr -= row_dec;

                pixel_ptr = 0;

            } else if (stream___block == 1) {

                /* decode is done */

                return 0;

            } else if (stream___block == 2) {

                /* reposition frame decode coordinates */

                stream___block = bytestream2_get_byte(gb);

                pixpixel_ptr stream___block;

                stream___block = bytestream2_get_byte(gb);

                row_ptr -= stream___block * row_dec;

            } else {

                // copy pixels from encoded stream

                odd_pixel =  stream___block & 1;

                rle_code = (stream___block + 1) / 2;

                extra67byte = rle_code & 0x01;

                if (row_ptr + pixpixel_ptrstream___block > frame_size ||

                    bytestream2_get_bytes_left(gb) < rle_code) {

                    av_log(avctx, AV_LOG_ERROR,

                           ""MS RLE: frame/stream ptr just went out of bounds (copy)
"");

                    return AVERROR_INVALIDDATA;

                }



                for (id = 0; id < rle_code; id++) {

                    if (pixel_ptr >= avctx->width)

                        break;

                    stream___block = bytestream2_get_byteu(gb);

                    pic->data[0][row_ptr + pixpixel_ptr stream___block >> 4;

                    pixel_ptr++;

                    if (id + 1 == rle_code && odd_pixel)

                        break;

                    if (pixel_ptr >= avctx->width)

                        break;

                    pic->data[0][row_ptr + pixpixel_ptr stream___block & 0x0F;

                    pixel_ptr++;

                }



                // if the RLE code is odd, skip a byte in the stream

                if (extra67byte)

                    bytestream2_skip(gb, 1);

            }

        } else {

            // decode a run of data

            if (row_ptr + pixpixel_ptrstream___block > frame_size) {

                av_log(avctx, AV_LOG_ERROR,

                       ""MS RLE: frame ptr just went out of bounds (run)
"");

                return AVERROR_INVALIDDATA;

            }

            stream___block = bytestream2_get_byte(gb);

            for (id = 0; id < rle_code; id++) {

                if (pixel_ptr >= avctx->width)

                    break;

                if ((id & 1) == 0)

                    pic->data[0][row_ptr + pixpixel_ptr stream___block >> 4;

                else

                    pic->data[0][row_ptr + pixpixel_ptr stream___block & 0x0F;

                pixel_ptr++;

            }

        }

    }



    /* one last sanity check on the way out */

    if (bytestream2_get_bytes_left(gb)) {

        av_log(avctx, AV_LOG_ERROR,

               ""MS RLE: ended frame decode with %d bytes left over
"",

               bytestream2_get_bytes_left(gb));

        return AVERROR_INVALIDDATA;

    }



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"avctx,pic,gb,rle_code,extra_byte,odd_pixel,stream_byte,i,pixel_ptr",,,,55,"avctx:avctx,pic:pic,gb:gb,rle_code:rle_code,extra_byte:extra67byte,odd_pixel:odd_pixel,stream_byte:stream___block,i:id,pixel_ptr:pixel_ptr,",6,GA,625,0.29101933240890504,GA,
169,"static void gen_srlq(DisasContext *ctx)

{

    int l1 = gen_new_label();

    int l2 = gen_new_label();

    TCGv t0 = tcg_temp_local_new();

    TCGv t1 = tcg_temp_local_new();

    TCGv t2 = tcg_temp_local_new();

    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);

    tcg_gen_movi_tl(t1, 0xFFFFFFFF);

    tcg_gen_shr_tl(t2, t1, t2);

    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);

    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);

    gen_load_spr(t0, SPR_MQ);

    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);

    tcg_gen_and_tl(t0, t0, t2);

    gen_load_spr(t1, SPR_MQ);

    tcg_gen_andc_tl(t1, t1, t2);

    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);

    gen_set_label(l2);

    tcg_temp_free(t0);

    tcg_temp_free(t1);

    tcg_temp_free(t2);

    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);

}
",256,,LABEL_0,LABEL_0,LABEL_0,-1,ctx,,,,0,,0,GA,285,0.10678138335545857,failed,
170,"static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)

{

    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);

}
",25,"static int kvm_set_mce(CPUState *iv, struct kvm_x86_mce *mx)

{

    return kvm_vcpu_ioctl(iv, KVM_X86_SET_MCE, mx);

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,m",,,,0,"env:iv,m:mx,",0,GA,108,0.03784655729929606,GA,
171,"static bool migrate_caps_check(bool *cap_list,

                               MigrationCapabilityStatusList *params,

                               Error **errp)

{

    MigrationCapabilityStatusList *cap;

    bool old_postcopy_cap;



    old_postcopy_cap = cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM];



    for (cap = params; cap; cap = cap->next) {

        cap_list[cap->value->capability] = cap->value->state;

    }



#ifndef CONFIG_LIVE_BLOCK_MIGRATION

    if (cap_list[MIGRATION_CAPABILITY_BLOCK]) {

        error_setg(errp, ""QEMU compiled without old-style (blk/-b, inc/-i) ""

                   ""block migration"");

        error_append_hint(errp, ""Use drive_mirror+NBD instead.\n"");

        return false;

    }

#endif



    if (cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]) {

        if (cap_list[MIGRATION_CAPABILITY_COMPRESS]) {

            /* The decompression threads asynchronously write into RAM

             * rather than use the atomic copies needed to avoid

             * userfaulting.  It should be possible to fix the decompression

             * threads for compatibility in future.

             */

            error_setg(errp, ""Postcopy is not currently compatible ""

                       ""with compression"");

            return false;

        }



        /* This check is reasonably expensive, so only when it's being

         * set the first time, also it's only the destination that needs

         * special support.

         */

        if (!old_postcopy_cap && runstate_check(RUN_STATE_INMIGRATE) &&

            !postcopy_ram_supported_by_host()) {

            /* postcopy_ram_supported_by_host will have emitted a more

             * detailed message

             */

            error_setg(errp, ""Postcopy is not supported"");

            return false;

        }

    }



    return true;

}
",252,,LABEL_0,LABEL_0,LABEL_0,-1,"cap_list,params,errp,cap,old_postcopy_cap",,,,0,,0,GA,1024,0.40352702935536705,failed,
172,"gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,

             uint32_t up_shift, CPUTriCoreState *env)

{

    TCGv temp = tcg_temp_new();

    TCGv temp2 = tcg_temp_new();

    TCGv temp3 = tcg_temp_new();

    TCGv_i64 t1 = tcg_temp_new_i64();

    TCGv_i64 t2 = tcg_temp_new_i64();

    TCGv_i64 t3 = tcg_temp_new_i64();

    TCGv_i64 t4 = tcg_temp_new_i64();



    tcg_gen_ext_i32_i64(t2, arg2);

    tcg_gen_ext_i32_i64(t3, arg3);



    tcg_gen_mul_i64(t2, t2, t3);



    tcg_gen_ext_i32_i64(t1, arg1);

    /* if we shift part of the fraction out, we need to round up */

    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);

    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);

    tcg_gen_sari_i64(t2, t2, up_shift - n);

    tcg_gen_add_i64(t2, t2, t4);



    tcg_gen_sub_i64(t3, t1, t2);

    tcg_gen_trunc_i64_i32(temp3, t3);

    /* calc v bit */

    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);

    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);

    tcg_gen_or_i64(t1, t1, t2);

    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);

    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);

    /* We produce an overflow on the host if the mul before was

       (0x80000000 * 0x80000000) << 1). If this is the

       case, we negate the ovf. */

    if (n == 1) {

        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);

        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);

        tcg_gen_and_tl(temp, temp, temp2);

        tcg_gen_shli_tl(temp, temp, 31);

        /* negate v bit, if special condition */

        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);

    }

    /* Calc SV bit */

    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);

    /* Calc AV/SAV bits */

    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);

    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);

    /* calc SAV */

    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);

    /* write back result */

    tcg_gen_mov_tl(ret, temp3);



    tcg_temp_free(temp);

    tcg_temp_free(temp2);

    tcg_temp_free(temp3);

    tcg_temp_free_i64(t1);

    tcg_temp_free_i64(t2);

    tcg_temp_free_i64(t3);

    tcg_temp_free_i64(t4);

}
",459,,LABEL_1,LABEL_0,,-4,"ret,TCGv,uint32_t",,,,0,,0,Greedy,1,0.0006992499033610026,,
173,"static size_t get_request_size(VirtQueue *vq)

{

    unsigned int in, out;



    virtqueue_get_avail_bytes(vq, &in, &out);

    return in;

}
",32,,LABEL_0,LABEL_1,,-4,"vq,in,out",,,,0,,0,Greedy,1,0.0004220406214396159,,
174,"static int ftp_current_dir(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    const char *command = ""PWD\r\n"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(s, command, pwd_codes, &res))

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '""') {

            if (!start) {

                start = res + i + 1;

                continue;

            }

            end = res + i;

            break;

        }

    }



    if (!end)

        goto fail;



    if (end > res && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, start, sizeof(s->path));



    av_free(res);

    return 0;



  fail:

    av_free(res);

    return AVERROR(EIO);

}
",197,"static int ftp_current_dir(FTPContext *s)

{

    char *gr = NULL, *start = NULL, *end = NULL;

    int i;

    const char *command = ""PWD\r
"";

    const int pwdpcode[] = {257, 0};



    if (!ftp_send_command(s,commandd,pwdpcodes, &gr))

        goto fail;



    for ii = 0; gr[i]; ++i) {

        if (gr[i] == '""') {

            if (!start) {

               startt = gr + i + 1;

                continue;

            }

           endd = gr + i;

            break;

        }

    }



    if (!end)

        goto fail;



    if endd > gr && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, start, sizeof(s->path));



    av_free(gr);

    return 0;



  fail:

    av_free(gr);

    return AVERROR(EIO);

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,res,start,end,i,command,pwd_codes",,,,22,"s:s,res:gr,start:start,end:end,i:i,command:command,pwd_codes:pwdpcode,",5,GA,387,0.14418816963831585,GA,
175,"static void visitor_output_setup_internal(TestOutputVisitorData *data,

                                          bool human)

{

    data->human = human;

    data->sov = string_output_visitor_new(human);

    g_assert(data->sov);

    data->ov = string_output_get_visitor(data->sov);

    g_assert(data->ov);

}
",61,,LABEL_0,LABEL_1,,-4,"data,human",,,,0,,0,Greedy,1,0.00046171347300211587,,
176,"int hvf_vcpu_exec(CPUState *cpu)

{

    X86CPU *x86_cpu = X86_CPU(cpu);

    CPUX86State *env = &x86_cpu->env;

    int ret = 0;

    uint64_t rip = 0;



    cpu->halted = 0;



    if (hvf_process_events(cpu)) {

        return EXCP_HLT;

    }



    do {

        if (cpu->vcpu_dirty) {

            hvf_put_registers(cpu);

            cpu->vcpu_dirty = false;

        }



        if (hvf_inject_interrupts(cpu)) {

            return EXCP_INTERRUPT;

        }

        vmx_update_tpr(cpu);



        qemu_mutex_unlock_iothread();

        if (!cpu_is_bsp(X86_CPU(cpu)) && cpu->halted) {

            qemu_mutex_lock_iothread();

            return EXCP_HLT;

        }



        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);

        assert_hvf_ok(r);



        /* handle VMEXIT */

        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);

        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);

        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,

                                           VMCS_EXIT_INSTRUCTION_LENGTH);



        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);



        hvf_store_events(cpu, ins_len, idtvec_info);

        rip = rreg(cpu->hvf_fd, HV_X86_RIP);

        RFLAGS(env) = rreg(cpu->hvf_fd, HV_X86_RFLAGS);

        env->eflags = RFLAGS(env);



        qemu_mutex_lock_iothread();



        update_apic_tpr(cpu);

        current_cpu = cpu;



        ret = 0;

        switch (exit_reason) {

        case EXIT_REASON_HLT: {

            macvm_set_rip(cpu, rip + ins_len);

            if (!((cpu->interrupt_request & CPU_INTERRUPT_HARD) &&

                (EFLAGS(env) & IF_MASK))

                && !(cpu->interrupt_request & CPU_INTERRUPT_NMI) &&

                !(idtvec_info & VMCS_IDT_VEC_VALID)) {

                cpu->halted = 1;

                ret = EXCP_HLT;

            }

            ret = EXCP_INTERRUPT;

            break;

        }

        case EXIT_REASON_MWAIT: {

            ret = EXCP_INTERRUPT;

            break;

        }

            /* Need to check if MMIO or unmmaped fault */

        case EXIT_REASON_EPT_FAULT:

        {

            hvf_slot *slot;

            addr_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);



            if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&

                ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {

                vmx_set_nmi_blocking(cpu);

            }



            slot = hvf_find_overlap_slot(gpa, gpa);

            /* mmio */

            if (ept_emulation_fault(slot, gpa, exit_qual)) {

                struct x86_decode decode;



                load_regs(cpu);

                env->hvf_emul->fetch_rip = rip;



                decode_instruction(env, &decode);

                exec_instruction(env, &decode);

                store_regs(cpu);

                break;

            }

            break;

        }

        case EXIT_REASON_INOUT:

        {

            uint32_t in = (exit_qual & 8) != 0;

            uint32_t size =  (exit_qual & 7) + 1;

            uint32_t string =  (exit_qual & 16) != 0;

            uint32_t port =  exit_qual >> 16;

            /*uint32_t rep = (exit_qual & 0x20) != 0;*/



#if 1

            if (!string && in) {

                uint64_t val = 0;

                load_regs(cpu);

                hvf_handle_io(env, port, &val, 0, size, 1);

                if (size == 1) {

                    AL(env) = val;

                } else if (size == 2) {

                    AX(env) = val;

                } else if (size == 4) {

                    RAX(env) = (uint32_t)val;

                } else {

                    VM_PANIC(""size"");

                }

                RIP(env) += ins_len;

                store_regs(cpu);

                break;

            } else if (!string && !in) {

                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);

                hvf_handle_io(env, port, &RAX(env), 1, size, 1);

                macvm_set_rip(cpu, rip + ins_len);

                break;

            }

#endif

            struct x86_decode decode;



            load_regs(cpu);

            env->hvf_emul->fetch_rip = rip;



            decode_instruction(env, &decode);

            VM_PANIC_ON(ins_len != decode.len);

            exec_instruction(env, &decode);

            store_regs(cpu);



            break;

        }

        case EXIT_REASON_CPUID: {

            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);

            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);

            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);

            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);



            cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);



            wreg(cpu->hvf_fd, HV_X86_RAX, rax);

            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);

            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);

            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);



            macvm_set_rip(cpu, rip + ins_len);

            break;

        }

        case EXIT_REASON_XSETBV: {

            X86CPU *x86_cpu = X86_CPU(cpu);

            CPUX86State *env = &x86_cpu->env;

            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);

            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);

            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);



            if (ecx) {

                macvm_set_rip(cpu, rip + ins_len);

                break;

            }

            env->xcr0 = ((uint64_t)edx << 32) | eax;

            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);

            macvm_set_rip(cpu, rip + ins_len);

            break;

        }

        case EXIT_REASON_INTR_WINDOW:

            vmx_clear_int_window_exiting(cpu);

            ret = EXCP_INTERRUPT;

            break;

        case EXIT_REASON_NMI_WINDOW:

            vmx_clear_nmi_window_exiting(cpu);

            ret = EXCP_INTERRUPT;

            break;

        case EXIT_REASON_EXT_INTR:

            /* force exit and allow io handling */

            ret = EXCP_INTERRUPT;

            break;

        case EXIT_REASON_RDMSR:

        case EXIT_REASON_WRMSR:

        {

            load_regs(cpu);

            if (exit_reason == EXIT_REASON_RDMSR) {

                simulate_rdmsr(cpu);

            } else {

                simulate_wrmsr(cpu);

            }

            RIP(env) += rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);

            store_regs(cpu);

            break;

        }

        case EXIT_REASON_CR_ACCESS: {

            int cr;

            int reg;



            load_regs(cpu);

            cr = exit_qual & 15;

            reg = (exit_qual >> 8) & 15;



            switch (cr) {

            case 0x0: {

                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));

                break;

            }

            case 4: {

                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));

                break;

            }

            case 8: {

                X86CPU *x86_cpu = X86_CPU(cpu);

                if (exit_qual & 0x10) {

                    RRX(env, reg) = cpu_get_apic_tpr(x86_cpu->apic_state);

                } else {

                    int tpr = RRX(env, reg);

                    cpu_set_apic_tpr(x86_cpu->apic_state, tpr);

                    ret = EXCP_INTERRUPT;

                }

                break;

            }

            default:

                error_report(""Unrecognized CR %d\n"", cr);

                abort();

            }

            RIP(env) += ins_len;

            store_regs(cpu);

            break;

        }

        case EXIT_REASON_APIC_ACCESS: { /* TODO */

            struct x86_decode decode;



            load_regs(cpu);

            env->hvf_emul->fetch_rip = rip;



            decode_instruction(env, &decode);

            exec_instruction(env, &decode);

            store_regs(cpu);

            break;

        }

        case EXIT_REASON_TPR: {

            ret = 1;

            break;

        }

        case EXIT_REASON_TASK_SWITCH: {

            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);

            x68_segment_selector sel = {.sel = exit_qual & 0xffff};

            vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,

             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo

             & VMCS_INTR_T_MASK);

            break;

        }

        case EXIT_REASON_TRIPLE_FAULT: {

            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);

            ret = EXCP_INTERRUPT;

            break;

        }

        case EXIT_REASON_RDPMC:

            wreg(cpu->hvf_fd, HV_X86_RAX, 0);

            wreg(cpu->hvf_fd, HV_X86_RDX, 0);

            macvm_set_rip(cpu, rip + ins_len);

            break;

        case VMX_REASON_VMCALL:

            /* TODO: inject #GP fault */

            break;

        default:

            error_report(""%llx: unhandled exit %llx\n"", rip, exit_reason);

        }

    } while (ret == 0);



    return ret;

}
",1539,,LABEL_1,LABEL_0,,-4,"cpu,x86_cpu,env",,,,0,,0,Greedy,1,0.0013564109802246093,,
177,"static void build_feed_streams(void)

{

    FFStream *stream, *feed;

    int i;



    /* gather all streams */

    for(stream = first_stream; stream != NULL; stream = stream->next) {

        feed = stream->feed;

        if (feed) {

            if (!stream->is_feed) {

                /* we handle a stream coming from a feed */

                for(i=0;i<stream->nb_streams;i++)

                    stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);

            }

        }

    }



    /* gather all streams */

    for(stream = first_stream; stream != NULL; stream = stream->next) {

        feed = stream->feed;

        if (feed) {

            if (stream->is_feed) {

                for(i=0;i<stream->nb_streams;i++)

                    stream->feed_streams[i] = i;

            }

        }

    }



    /* create feed files if needed */

    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {

        int fd;



        if (url_exist(feed->feed_filename)) {

            /* See if it matches */

            AVFormatContext *s;

            int matches = 0;



            if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {

                /* Now see if it matches */

                if (s->nb_streams == feed->nb_streams) {

                    matches = 1;

                    for(i=0;i<s->nb_streams;i++) {

                        AVStream *sf, *ss;

                        sf = feed->streams[i];

                        ss = s->streams[i];



                        if (sf->index != ss->index ||

                            sf->id != ss->id) {

                            http_log(""Index & Id do not match for stream %d (%s)\n"",

                                   i, feed->feed_filename);

                            matches = 0;

                        } else {

                            AVCodecContext *ccf, *ccs;



                            ccf = sf->codec;

                            ccs = ss->codec;

#define CHECK_CODEC(x)  (ccf->x != ccs->x)



                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {

                                http_log(""Codecs do not match for stream %d\n"", i);

                                matches = 0;

                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {

                                http_log(""Codec bitrates do not match for stream %d\n"", i);

                                matches = 0;

                            } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) {

                                if (CHECK_CODEC(time_base.den) ||

                                    CHECK_CODEC(time_base.num) ||

                                    CHECK_CODEC(width) ||

                                    CHECK_CODEC(height)) {

                                    http_log(""Codec width, height and framerate do not match for stream %d\n"", i);

                                    matches = 0;

                                }

                            } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) {

                                if (CHECK_CODEC(sample_rate) ||

                                    CHECK_CODEC(channels) ||

                                    CHECK_CODEC(frame_size)) {

                                    http_log(""Codec sample_rate, channels, frame_size do not match for stream %d\n"", i);

                                    matches = 0;

                                }

                            } else {

                                http_log(""Unknown codec type\n"");

                                matches = 0;

                            }

                        }

                        if (!matches)

                            break;

                    }

                } else

                    http_log(""Deleting feed file '%s' as stream counts differ (%d != %d)\n"",

                        feed->feed_filename, s->nb_streams, feed->nb_streams);



                av_close_input_file(s);

            } else

                http_log(""Deleting feed file '%s' as it appears to be corrupt\n"",

                        feed->feed_filename);



            if (!matches) {

                if (feed->readonly) {

                    http_log(""Unable to delete feed file '%s' as it is marked readonly\n"",

                        feed->feed_filename);

                    exit(1);

                }

                unlink(feed->feed_filename);

            }

        }

        if (!url_exist(feed->feed_filename)) {

            AVFormatContext s1 = {0}, *s = &s1;



            if (feed->readonly) {

                http_log(""Unable to create feed file '%s' as it is marked readonly\n"",

                    feed->feed_filename);

                exit(1);

            }



            /* only write the header of the ffm file */

            if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) {

                http_log(""Could not open output feed file '%s'\n"",

                         feed->feed_filename);

                exit(1);

            }

            s->oformat = feed->fmt;

            s->nb_streams = feed->nb_streams;

            for(i=0;i<s->nb_streams;i++) {

                AVStream *st;

                st = feed->streams[i];

                s->streams[i] = st;

            }

            av_set_parameters(s, NULL);

            if (av_write_header(s) < 0) {

                http_log(""Container doesn't supports the required parameters\n"");

                exit(1);

            }

            /* XXX: need better api */

            av_freep(&s->priv_data);

            avio_close(s->pb);

        }

        /* get feed size and write index */

        fd = open(feed->feed_filename, O_RDONLY);

        if (fd < 0) {

            http_log(""Could not open output feed file '%s'\n"",

                    feed->feed_filename);

            exit(1);

        }



        feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);

        feed->feed_size = lseek(fd, 0, SEEK_END);

        /* ensure that we do not wrap before the end of file */

        if (feed->feed_max_size && feed->feed_max_size < feed->feed_size)

            feed->feed_max_size = feed->feed_size;



        close(fd);

    }

}
",1136,"static void build_feed_streams(void)

{

    FFStream *output, *gg;

    int ti;



    /* gather all streams */

    for(output = first_stream; output != NULL; output = output->next) {

        gg = output->gg;

        if (gg) {

            if (!stream->is_feed) {

                /* we handle a output coming from a gg */

                for(ti=0;ti<output->nb_streams;ti++)

                    output->feed_streamti[i] = add_av_stream(gg, output->streams[ti]);

            }

        }

    }



    /* gather all streams */

    for(output = first_stream; output != NULL; output = output->next) {

        gg = output->gg;

        if (gg) {

            if (output->is_feed) {

                for(ti=0;ti<output->nb_streams;ti++)

                    output->feed_streams[ti] = ti;

            }

        }

    }



    /* create gg files if needed */

    for(gg = first_feed; gg != NULL; gg = gg->next_feed) {

        int ct;



        if (url_exist(gg->feed_filename)) {

            /* See if it matches */

            AVFormatContext *sq;

            int matches = 0;



            if (av_open_input_filesq&s, gg->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) {

                /* Now see if it matches */

                ifsq(s->nb_streams == gg->nb_streams) {

                    matches = 1;

                    for(ti=0;ti<ssq>nb_streams;ti++) {

                        AVStream *sf, *ss;

                       sff = gg->streams[ti];

                        ssss ssq>streams[ti];



                        if (sf->index != ss->index ||

                            sf->id != ss->id) {

                            http_log(""Index & Id do not match for output %d (%sq)
"",

                                 ti i, gg->feed_filename);

                            matches = 0;

                        } else {

                            AVCodecContext *cff, *ucl;



                            cff = sf->codec;

                            ucl = ss->codec;

#define CHECK_CODEC(x)  (ccf->x != ccs->x)



                            if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) {

                                http_log(""Codecs do not match for output %d
"", ti);

                                matches = 0;

                            } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) {

                                http_log(""Codec bitrates do not match for output %d
"", ti);

                                matches = 0;

                            } else if (cff->codec_type == AVMEDIA_TYPE_VIDEO) {

                                if (CHECK_CODEC(time_base.den) ||

                                    CHECK_CODEC(time_base.num) ||

                                    CHECK_CODEC(width) ||

                                    CHECK_CODEC(height)) {

                                    http_log(""Codec width, height and framerate do not match for output %d
"", ti);

                                    matches = 0;

                                }

                            } else if (cff->codec_type == AVMEDIA_TYPE_AUDIO) {

                                if (CHECK_CODEC(sample_rate) ||

                                    CHECK_CODEC(channels) ||

                                    CHECK_CODEC(frame_size)) {

                                    http_log(""Codec sample_rate, channels, frame_size do not match for output %d
"", ti);

                                    matches = 0;

                                }

                            } else {

                                http_log(""Unknown codec type
"");

                                matches = 0;

                            }

                        }

                        if (!matches)

                            break;

                    }

                } else

                    http_log(""Deleting gg file '%s' as output counts differ (%d != %d)
"",

                        gg->feed_filenamesq s->nb_streams, gg->nb_streams);



                av_close_input_file(sq);

            } else

                http_log(""Deleting gg file '%s' as it appears to be corrupt
"",

                        gg->feed_filename);



            if (!matches) {

                if (gg->readonly) {

                    http_log(""Unable to delete gg file '%s' as it is marked readonly
"",

                        gg->feed_filename);

                    exit(1);

                }

                unlink(gg->feed_filename);

            }

        }

        if (!url_exist(gg->feed_filename)) {

            AVFormatContext s1 = {0}, *sq = &s1;



            if (gg->readonly) {

                http_log(""Unable to create gg file '%s' as it is marked readonly
"",

                    gg->feed_filename);

                exit(1);

            }



            /* only write the header of the ffm file */

            if (avio_opensq&s->pb, gg->feed_filename, AVIO_FLAG_WRITE) < 0) {

                http_log(""Could not open output gg file '%s'
"",

                         gg->feed_filename);

                exit(1);

            }

          sq s->oformat = gg->fmt;

          sq s->nb_streams = gg->nb_streams;

            for(ti=0;ti<ssq>nb_streams;ti++) {

                AVStream *st;

                st = gg->streams[ti];

                ssq>streams[ti] = st;

            }

            av_set_parameters(sq, NULL);

            if (av_write_header(sq) < 0) {

                http_log(""Container doesn't supports the required parameters
"");

                exit(1);

            }

            /* XXX: need better api */

            av_freep(&sq->priv_data);

            avio_close(sq->pb);

        }

        /* get gg size and write index */

      ctfd = open(gg->feed_filename, O_RDONLY);

        if (ct < 0) {

            http_log(""Could not open output gg file '%s'
"",

                    gg->feed_filename);

            exit(1);

        }



        gg->feed_write_index = FFMAX(ffm_read_write_index(ct), FFM_PACKET_SIZE);

        gg->feed_size = lseek(ct, 0, SEEK_END);

        /* ensure that we do not wrap before the end of file */

        if (gg->feed_max_size && gg->feed_max_size < gg->feed_size)

            gg->feed_max_size = gg->feed_size;



        close(ct);

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"stream,feed,i,fd,s,sf,ss,ccf,ccs",,,,10,"stream:output,feed:gg,i:ti,fd:ct,s:sq,sf:sf,ss:ss,ccf:cff,ccs:ucl,",2,GA,613,0.3431322455406189,GA,
178,"qcrypto_block_luks_create(QCryptoBlock *block,

                          QCryptoBlockCreateOptions *options,

                          QCryptoBlockInitFunc initfunc,

                          QCryptoBlockWriteFunc writefunc,

                          void *opaque,

                          Error **errp)

{

    QCryptoBlockLUKS *luks;

    QCryptoBlockCreateOptionsLUKS luks_opts;

    Error *local_err = NULL;

    uint8_t *masterkey = NULL;

    uint8_t *slotkey = NULL;

    uint8_t *splitkey = NULL;

    size_t splitkeylen = 0;

    size_t i;

    QCryptoCipher *cipher = NULL;

    QCryptoIVGen *ivgen = NULL;

    char *password;

    const char *cipher_alg;

    const char *cipher_mode;

    const char *ivgen_alg;

    const char *ivgen_hash_alg = NULL;

    const char *hash_alg;

    char *cipher_mode_spec = NULL;

    QCryptoCipherAlgorithm ivcipheralg = 0;

    uint64_t iters;



    memcpy(&luks_opts, &options->u.luks, sizeof(luks_opts));

    if (!luks_opts.has_iter_time) {

        luks_opts.iter_time = 2000;

    }

    if (!luks_opts.has_cipher_alg) {

        luks_opts.cipher_alg = QCRYPTO_CIPHER_ALG_AES_256;

    }

    if (!luks_opts.has_cipher_mode) {

        luks_opts.cipher_mode = QCRYPTO_CIPHER_MODE_XTS;

    }

    if (!luks_opts.has_ivgen_alg) {

        luks_opts.ivgen_alg = QCRYPTO_IVGEN_ALG_PLAIN64;

    }

    if (!luks_opts.has_hash_alg) {

        luks_opts.hash_alg = QCRYPTO_HASH_ALG_SHA256;

    }

    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {

        if (!luks_opts.has_ivgen_hash_alg) {

            luks_opts.ivgen_hash_alg = QCRYPTO_HASH_ALG_SHA256;

            luks_opts.has_ivgen_hash_alg = true;

        }

    }

    /* Note we're allowing ivgen_hash_alg to be set even for

     * non-essiv iv generators that don't need a hash. It will

     * be silently ignored, for compatibility with dm-crypt */



    if (!options->u.luks.key_secret) {

        error_setg(errp, ""Parameter 'key-secret' is required for cipher"");

        return -1;

    }

    password = qcrypto_secret_lookup_as_utf8(luks_opts.key_secret, errp);

    if (!password) {

        return -1;

    }



    luks = g_new0(QCryptoBlockLUKS, 1);

    block->opaque = luks;



    memcpy(luks->header.magic, qcrypto_block_luks_magic,

           QCRYPTO_BLOCK_LUKS_MAGIC_LEN);



    /* We populate the header in native endianness initially and

     * then convert everything to big endian just before writing

     * it out to disk

     */

    luks->header.version = QCRYPTO_BLOCK_LUKS_VERSION;

    qcrypto_block_luks_uuid_gen(luks->header.uuid);



    cipher_alg = qcrypto_block_luks_cipher_alg_lookup(luks_opts.cipher_alg,

                                                      errp);

    if (!cipher_alg) {

        goto error;

    }



    cipher_mode = QCryptoCipherMode_lookup[luks_opts.cipher_mode];

    ivgen_alg = QCryptoIVGenAlgorithm_lookup[luks_opts.ivgen_alg];

    if (luks_opts.has_ivgen_hash_alg) {

        ivgen_hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.ivgen_hash_alg];

        cipher_mode_spec = g_strdup_printf(""%s-%s:%s"", cipher_mode, ivgen_alg,

                                           ivgen_hash_alg);

    } else {

        cipher_mode_spec = g_strdup_printf(""%s-%s"", cipher_mode, ivgen_alg);

    }

    hash_alg = QCryptoHashAlgorithm_lookup[luks_opts.hash_alg];





    if (strlen(cipher_alg) >= QCRYPTO_BLOCK_LUKS_CIPHER_NAME_LEN) {

        error_setg(errp, ""Cipher name '%s' is too long for LUKS header"",

                   cipher_alg);

        goto error;

    }

    if (strlen(cipher_mode_spec) >= QCRYPTO_BLOCK_LUKS_CIPHER_MODE_LEN) {

        error_setg(errp, ""Cipher mode '%s' is too long for LUKS header"",

                   cipher_mode_spec);

        goto error;

    }

    if (strlen(hash_alg) >= QCRYPTO_BLOCK_LUKS_HASH_SPEC_LEN) {

        error_setg(errp, ""Hash name '%s' is too long for LUKS header"",

                   hash_alg);

        goto error;

    }



    if (luks_opts.ivgen_alg == QCRYPTO_IVGEN_ALG_ESSIV) {

        ivcipheralg = qcrypto_block_luks_essiv_cipher(luks_opts.cipher_alg,

                                                      luks_opts.ivgen_hash_alg,

                                                      &local_err);

        if (local_err) {

            error_propagate(errp, local_err);

            goto error;

        }

    } else {

        ivcipheralg = luks_opts.cipher_alg;

    }



    strcpy(luks->header.cipher_name, cipher_alg);

    strcpy(luks->header.cipher_mode, cipher_mode_spec);

    strcpy(luks->header.hash_spec, hash_alg);



    luks->header.key_bytes = qcrypto_cipher_get_key_len(luks_opts.cipher_alg);

    if (luks_opts.cipher_mode == QCRYPTO_CIPHER_MODE_XTS) {

        luks->header.key_bytes *= 2;

    }



    /* Generate the salt used for hashing the master key

     * with PBKDF later

     */

    if (qcrypto_random_bytes(luks->header.master_key_salt,

                             QCRYPTO_BLOCK_LUKS_SALT_LEN,

                             errp) < 0) {

        goto error;

    }



    /* Generate random master key */

    masterkey = g_new0(uint8_t, luks->header.key_bytes);

    if (qcrypto_random_bytes(masterkey,

                             luks->header.key_bytes, errp) < 0) {

        goto error;

    }





    /* Setup the block device payload encryption objects */

    block->cipher = qcrypto_cipher_new(luks_opts.cipher_alg,

                                       luks_opts.cipher_mode,

                                       masterkey, luks->header.key_bytes,

                                       errp);

    if (!block->cipher) {

        goto error;

    }



    block->kdfhash = luks_opts.hash_alg;

    block->niv = qcrypto_cipher_get_iv_len(luks_opts.cipher_alg,

                                           luks_opts.cipher_mode);

    block->ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,

                                     ivcipheralg,

                                     luks_opts.ivgen_hash_alg,

                                     masterkey, luks->header.key_bytes,

                                     errp);



    if (!block->ivgen) {

        goto error;

    }





    /* Determine how many iterations we need to hash the master

     * key, in order to have 1 second of compute time used

     */

    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,

                                       masterkey, luks->header.key_bytes,

                                       luks->header.master_key_salt,

                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,

                                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,

                                       &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        goto error;

    }



    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {

        error_setg_errno(errp, ERANGE,

                         ""PBKDF iterations %llu too large to scale"",

                         (unsigned long long)iters);

        goto error;

    }



    /* iter_time was in millis, but count_iters reported for secs */

    iters = iters * luks_opts.iter_time / 1000;



    /* Why /= 8 ?  That matches cryptsetup, but there's no

     * explanation why they chose /= 8... Probably so that

     * if all 8 keyslots are active we only spend 1 second

     * in total time to check all keys */

    iters /= 8;

    if (iters > UINT32_MAX) {

        error_setg_errno(errp, ERANGE,

                         ""PBKDF iterations %llu larger than %u"",

                         (unsigned long long)iters, UINT32_MAX);

        goto error;

    }

    iters = MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_MASTER_KEY_ITERS);

    luks->header.master_key_iterations = iters;



    /* Hash the master key, saving the result in the LUKS

     * header. This hash is used when opening the encrypted

     * device to verify that the user password unlocked a

     * valid master key

     */

    if (qcrypto_pbkdf2(luks_opts.hash_alg,

                       masterkey, luks->header.key_bytes,

                       luks->header.master_key_salt,

                       QCRYPTO_BLOCK_LUKS_SALT_LEN,

                       luks->header.master_key_iterations,

                       luks->header.master_key_digest,

                       QCRYPTO_BLOCK_LUKS_DIGEST_LEN,

                       errp) < 0) {

        goto error;

    }





    /* Although LUKS has multiple key slots, we're just going

     * to use the first key slot */

    splitkeylen = luks->header.key_bytes * QCRYPTO_BLOCK_LUKS_STRIPES;

    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {

        luks->header.key_slots[i].active = i == 0 ?

            QCRYPTO_BLOCK_LUKS_KEY_SLOT_ENABLED :

            QCRYPTO_BLOCK_LUKS_KEY_SLOT_DISABLED;

        luks->header.key_slots[i].stripes = QCRYPTO_BLOCK_LUKS_STRIPES;



        /* This calculation doesn't match that shown in the spec,

         * but instead follows the cryptsetup implementation.

         */

        luks->header.key_slots[i].key_offset =

            (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /

             QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +

            (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),

                      (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /

                       QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) * i);

    }



    if (qcrypto_random_bytes(luks->header.key_slots[0].salt,

                             QCRYPTO_BLOCK_LUKS_SALT_LEN,

                             errp) < 0) {

        goto error;

    }



    /* Again we determine how many iterations are required to

     * hash the user password while consuming 1 second of compute

     * time */

    iters = qcrypto_pbkdf2_count_iters(luks_opts.hash_alg,

                                       (uint8_t *)password, strlen(password),

                                       luks->header.key_slots[0].salt,

                                       QCRYPTO_BLOCK_LUKS_SALT_LEN,

                                       luks->header.key_bytes,

                                       &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        goto error;

    }



    if (iters > (ULLONG_MAX / luks_opts.iter_time)) {

        error_setg_errno(errp, ERANGE,

                         ""PBKDF iterations %llu too large to scale"",

                         (unsigned long long)iters);

        goto error;

    }



    /* iter_time was in millis, but count_iters reported for secs */

    iters = iters * luks_opts.iter_time / 1000;



    if (iters > UINT32_MAX) {

        error_setg_errno(errp, ERANGE,

                         ""PBKDF iterations %llu larger than %u"",

                         (unsigned long long)iters, UINT32_MAX);

        goto error;

    }



    luks->header.key_slots[0].iterations =

        MAX(iters, QCRYPTO_BLOCK_LUKS_MIN_SLOT_KEY_ITERS);





    /* Generate a key that we'll use to encrypt the master

     * key, from the user's password

     */

    slotkey = g_new0(uint8_t, luks->header.key_bytes);

    if (qcrypto_pbkdf2(luks_opts.hash_alg,

                       (uint8_t *)password, strlen(password),

                       luks->header.key_slots[0].salt,

                       QCRYPTO_BLOCK_LUKS_SALT_LEN,

                       luks->header.key_slots[0].iterations,

                       slotkey, luks->header.key_bytes,

                       errp) < 0) {

        goto error;

    }





    /* Setup the encryption objects needed to encrypt the

     * master key material

     */

    cipher = qcrypto_cipher_new(luks_opts.cipher_alg,

                                luks_opts.cipher_mode,

                                slotkey, luks->header.key_bytes,

                                errp);

    if (!cipher) {

        goto error;

    }



    ivgen = qcrypto_ivgen_new(luks_opts.ivgen_alg,

                              ivcipheralg,

                              luks_opts.ivgen_hash_alg,

                              slotkey, luks->header.key_bytes,

                              errp);

    if (!ivgen) {

        goto error;

    }



    /* Before storing the master key, we need to vastly

     * increase its size, as protection against forensic

     * disk data recovery */

    splitkey = g_new0(uint8_t, splitkeylen);



    if (qcrypto_afsplit_encode(luks_opts.hash_alg,

                               luks->header.key_bytes,

                               luks->header.key_slots[0].stripes,

                               masterkey,

                               splitkey,

                               errp) < 0) {

        goto error;

    }



    /* Now we encrypt the split master key with the key generated

     * from the user's password, before storing it */

    if (qcrypto_block_encrypt_helper(cipher, block->niv, ivgen,

                                     QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,

                                     0,

                                     splitkey,

                                     splitkeylen,

                                     errp) < 0) {

        goto error;

    }





    /* The total size of the LUKS headers is the partition header + key

     * slot headers, rounded up to the nearest sector, combined with

     * the size of each master key material region, also rounded up

     * to the nearest sector */

    luks->header.payload_offset =

        (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /

         QCRYPTO_BLOCK_LUKS_SECTOR_SIZE) +

        (ROUND_UP(DIV_ROUND_UP(splitkeylen, QCRYPTO_BLOCK_LUKS_SECTOR_SIZE),

                  (QCRYPTO_BLOCK_LUKS_KEY_SLOT_OFFSET /

                   QCRYPTO_BLOCK_LUKS_SECTOR_SIZE)) *

         QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS);



    block->payload_offset = luks->header.payload_offset *

        QCRYPTO_BLOCK_LUKS_SECTOR_SIZE;



    /* Reserve header space to match payload offset */

    initfunc(block, block->payload_offset, &local_err, opaque);

    if (local_err) {

        error_propagate(errp, local_err);

        goto error;

    }



    /* Everything on disk uses Big Endian, so flip header fields

     * before writing them */

    cpu_to_be16s(&luks->header.version);

    cpu_to_be32s(&luks->header.payload_offset);

    cpu_to_be32s(&luks->header.key_bytes);

    cpu_to_be32s(&luks->header.master_key_iterations);



    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {

        cpu_to_be32s(&luks->header.key_slots[i].active);

        cpu_to_be32s(&luks->header.key_slots[i].iterations);

        cpu_to_be32s(&luks->header.key_slots[i].key_offset);

        cpu_to_be32s(&luks->header.key_slots[i].stripes);

    }





    /* Write out the partition header and key slot headers */

    writefunc(block, 0,

              (const uint8_t *)&luks->header,

              sizeof(luks->header),

              &local_err,

              opaque);



    /* Delay checking local_err until we've byte-swapped */



    /* Byte swap the header back to native, in case we need

     * to read it again later */

    be16_to_cpus(&luks->header.version);

    be32_to_cpus(&luks->header.payload_offset);

    be32_to_cpus(&luks->header.key_bytes);

    be32_to_cpus(&luks->header.master_key_iterations);



    for (i = 0; i < QCRYPTO_BLOCK_LUKS_NUM_KEY_SLOTS; i++) {

        be32_to_cpus(&luks->header.key_slots[i].active);

        be32_to_cpus(&luks->header.key_slots[i].iterations);

        be32_to_cpus(&luks->header.key_slots[i].key_offset);

        be32_to_cpus(&luks->header.key_slots[i].stripes);

    }



    if (local_err) {

        error_propagate(errp, local_err);

        goto error;

    }



    /* Write out the master key material, starting at the

     * sector immediately following the partition header. */

    if (writefunc(block,

                  luks->header.key_slots[0].key_offset *

                  QCRYPTO_BLOCK_LUKS_SECTOR_SIZE,

                  splitkey, splitkeylen,

                  errp,

                  opaque) != splitkeylen) {

        goto error;

    }



    luks->cipher_alg = luks_opts.cipher_alg;

    luks->cipher_mode = luks_opts.cipher_mode;

    luks->ivgen_alg = luks_opts.ivgen_alg;

    luks->ivgen_hash_alg = luks_opts.ivgen_hash_alg;

    luks->hash_alg = luks_opts.hash_alg;



    memset(masterkey, 0, luks->header.key_bytes);

    g_free(masterkey);

    memset(slotkey, 0, luks->header.key_bytes);

    g_free(slotkey);

    g_free(splitkey);

    g_free(password);

    g_free(cipher_mode_spec);



    qcrypto_ivgen_free(ivgen);

    qcrypto_cipher_free(cipher);



    return 0;



 error:

    if (masterkey) {

        memset(masterkey, 0, luks->header.key_bytes);

    }

    g_free(masterkey);

    if (slotkey) {

        memset(slotkey, 0, luks->header.key_bytes);

    }

    g_free(slotkey);

    g_free(splitkey);

    g_free(password);

    g_free(cipher_mode_spec);



    qcrypto_ivgen_free(ivgen);

    qcrypto_cipher_free(cipher);



    g_free(luks);

    return -1;

}
",2650,,LABEL_0,LABEL_1,,-4,"luks,luks_opts,local_err,masterkey,slotkey,splitkey,i,cipher,ivgen,password,cipher_alg,cipher_mode,ivgen_alg,ivgen_hash_alg,hash_alg,cipher_mode_spec,iters",,,,0,,0,Greedy,1,0.0021790623664855956,,
179,"static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,

                                unsigned size)

{

    IMXTimerGState *s = (IMXTimerGState *)opaque;



    DPRINTF(""g-read(offset=%x)"", offset >> 2);

    switch (offset >> 2) {

    case 0: /* Control Register */

        DPRINTF("" cr = %x\n"", s->cr);

        return s->cr;



    case 1: /* prescaler */

        DPRINTF("" pr = %x\n"", s->pr);

        return s->pr;



    case 2: /* Status Register */

        DPRINTF("" sr = %x\n"", s->sr);

        return s->sr;



    case 3: /* Interrupt Register */

        DPRINTF("" ir = %x\n"", s->ir);

        return s->ir;



    case 4: /* Output Compare Register 1 */

        DPRINTF("" ocr1 = %x\n"", s->ocr1);

        return s->ocr1;





    case 9: /* cnt */

        imx_timerg_update_counts(s);

        DPRINTF("" cnt = %x\n"", s->cnt);

        return s->cnt;

    }



    IPRINTF(""imx_timerg_read: Bad offset %x\n"",

            (int)offset >> 2);

    return 0;

}
",250,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,offset,size,s",,,,0,,0,GA,891,0.3473381280899048,failed,
180,"int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)

{

    int count, x;

    uint8_t *out;



    out = outbuf;





        for(x = 0; x < w; x += count) {

            /* see if we can encode the next set of pixels with RLE */

            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {

                if(out + bpp + 1 > outbuf + out_size) return -1;

                *out++ = (count ^ xor) + add;

                memcpy(out, ptr, bpp);

                out += bpp;

            } else {

                /* fall back on uncompressed */

                count = count_pixels(ptr, w-x, bpp, 0);

                *out++ = count - 1;



                if(out + bpp*count > outbuf + out_size) return -1;

                memcpy(out, ptr, bpp * count);

                out += bpp * count;

        }



        ptr += count * bpp;

    }



    return out - outbuf;

}
",220,"int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int sw, int8_t add, uint8_t xor)

{

    int index, x;

    uint8_t *out;



    out = outbuf;





        for(xx= 0; xx< sw; x += index) {

            /* see if we can encode the next set of pixels with RLE */

            if((cindex= count_pixels(ptr, sw-x, bpp, 1)) > 1) {

                if(out + bpp + 1 > outbuf + out_size) return -1;

                *out++ = (index ^ xor) + add;

                memcpy(out, ptr, bpp);

                out += bpp;

            } else {

                /* fall back on uncompressed */

                cindex= count_pixels(ptr, sw-x, bpp, 0);

                *out++ = index - 1;



                if(out + bpp*index > outbuf + out_size) return -1;

                memcpy(out, ptr, bpp * index);

                out += bpp * index;

        }



        ptr += index * bpp;

    }



    return out - outbuf;

}
",LABEL_0,LABEL_0,LABEL_1,1,"outbuf,out_size,ptr,bpp,w,add,xor,count,x,out",,,,45,"outbuf:outbuf,out_size:out_size,ptr:ptr,bpp:bpp,w:sw,add:add,xor:xor,count:index,x:x,out:out,",8,GA,588,0.2201319138209025,GA,
181,"static int usb_bt_handle_data(USBDevice *dev, USBPacket *p)

{

    struct USBBtState *s = (struct USBBtState *) dev->opaque;

    int ret = 0;



    if (!s->config)

        goto fail;



    switch (p->pid) {

    case USB_TOKEN_IN:

        switch (p->devep & 0xf) {

        case USB_EVT_EP:

            ret = usb_bt_fifo_dequeue(&s->evt, p);

            break;



        case USB_ACL_EP:

            ret = usb_bt_fifo_dequeue(&s->acl, p);

            break;



        case USB_SCO_EP:

            ret = usb_bt_fifo_dequeue(&s->sco, p);

            break;



        default:

            goto fail;

        }

        break;



    case USB_TOKEN_OUT:

        switch (p->devep & 0xf) {

        case USB_ACL_EP:

            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,

                            usb_bt_hci_acl_complete, p->data, p->len);

            break;



        case USB_SCO_EP:

            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,

                            usb_bt_hci_sco_complete, p->data, p->len);

            break;



        default:

            goto fail;

        }

        break;



    default:

    fail:

        ret = USB_RET_STALL;

        break;

    }



    return ret;

}
",234,,LABEL_1,LABEL_0,,-4,"dev,p,s",,,,0,,0,Greedy,1,0.0005695263544718425,,
182,"void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)

{

    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);

    AVFilterPad *dst = link->dstpad;

    int i;



    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);



    if (!(filter_samples = dst->filter_samples))

        filter_samples = avfilter_default_filter_samples;



    /* prepare to copy the samples if the buffer has insufficient permissions */

    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||

        dst->rej_perms & samplesref->perms) {



        av_log(link->dst, AV_LOG_DEBUG,

               ""Copying audio data in avfilter (have perms %x, need %x, reject %x)\n"",

               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);



        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,

                                                          samplesref->audio->nb_samples);

        link->cur_buf->pts                = samplesref->pts;

        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;



        /* Copy actual data into new samples buffer */

        for (i = 0; samplesref->data[i]; i++)

            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);



        avfilter_unref_buffer(samplesref);

    } else

        link->cur_buf = samplesref;



    filter_samples(link, link->cur_buf);

}
",299,,LABEL_0,LABEL_0,LABEL_0,-1,"link,samplesref,filter_samples,dst,i",,,,0,,0,GA,1242,0.48408960501352943,failed,
183,"static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,

                                void *opaque)

{

    VirtualConsole *vc = opaque;

    GtkDisplayState *s = vc->s;

    InputButton btn;



    /* implicitly grab the input at the first click in the relative mode */

    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&

        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {

        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),

                                       TRUE);

        return TRUE;

    }



    if (button->button == 1) {

        btn = INPUT_BUTTON_LEFT;

    } else if (button->button == 2) {

        btn = INPUT_BUTTON_MIDDLE;

    } else if (button->button == 3) {

        btn = INPUT_BUTTON_RIGHT;

    } else {

        return TRUE;

    }



    qemu_input_queue_btn(vc->gfx.dcl.con, btn,

                         button->type == GDK_BUTTON_PRESS);

    qemu_input_event_sync();

    return TRUE;

}
",184,,LABEL_0,LABEL_0,LABEL_0,-1,"widget,button,opaque,vc,s,btn",,,,0,,0,GA,1318,0.4924567222595215,failed,
184,"static inline void RENAME(yvu9_to_yuy2)(const uint8_t *src1, const uint8_t *src2, const uint8_t *src3,

                                        uint8_t *dst,

                                        long width, long height,

                                        long srcStride1, long srcStride2,

                                        long srcStride3, long dstStride)

{

    x86_reg x;

    long y,w,h;

    w=width/2; h=height;

    for (y=0;y<h;y++) {

        const uint8_t* yp=src1+srcStride1*y;

        const uint8_t* up=src2+srcStride2*(y>>2);

        const uint8_t* vp=src3+srcStride3*(y>>2);

        uint8_t* d=dst+dstStride*y;

        x=0;

#if COMPILE_TEMPLATE_MMX

        for (;x<w-7;x+=8) {

            __asm__ volatile(

                PREFETCH""   32(%1, %0)          \n\t""

                PREFETCH""   32(%2, %0)          \n\t""

                PREFETCH""   32(%3, %0)          \n\t""

                ""movq      (%1, %0, 4), %%mm0   \n\t"" /* Y0Y1Y2Y3Y4Y5Y6Y7 */

                ""movq         (%2, %0), %%mm1   \n\t"" /* U0U1U2U3U4U5U6U7 */

                ""movq         (%3, %0), %%mm2   \n\t"" /* V0V1V2V3V4V5V6V7 */

                ""movq            %%mm0, %%mm3   \n\t"" /* Y0Y1Y2Y3Y4Y5Y6Y7 */

                ""movq            %%mm1, %%mm4   \n\t"" /* U0U1U2U3U4U5U6U7 */

                ""movq            %%mm2, %%mm5   \n\t"" /* V0V1V2V3V4V5V6V7 */

                ""punpcklbw       %%mm1, %%mm1   \n\t"" /* U0U0 U1U1 U2U2 U3U3 */

                ""punpcklbw       %%mm2, %%mm2   \n\t"" /* V0V0 V1V1 V2V2 V3V3 */

                ""punpckhbw       %%mm4, %%mm4   \n\t"" /* U4U4 U5U5 U6U6 U7U7 */

                ""punpckhbw       %%mm5, %%mm5   \n\t"" /* V4V4 V5V5 V6V6 V7V7 */



                ""movq            %%mm1, %%mm6   \n\t""

                ""punpcklbw       %%mm2, %%mm1   \n\t"" /* U0V0 U0V0 U1V1 U1V1*/

                ""punpcklbw       %%mm1, %%mm0   \n\t"" /* Y0U0 Y1V0 Y2U0 Y3V0*/

                ""punpckhbw       %%mm1, %%mm3   \n\t"" /* Y4U1 Y5V1 Y6U1 Y7V1*/

                MOVNTQ""          %%mm0,  (%4, %0, 8)    \n\t""

                MOVNTQ""          %%mm3, 8(%4, %0, 8)    \n\t""



                ""punpckhbw       %%mm2, %%mm6   \n\t"" /* U2V2 U2V2 U3V3 U3V3*/

                ""movq     8(%1, %0, 4), %%mm0   \n\t""

                ""movq            %%mm0, %%mm3   \n\t""

                ""punpcklbw       %%mm6, %%mm0   \n\t"" /* Y U2 Y V2 Y U2 Y V2*/

                ""punpckhbw       %%mm6, %%mm3   \n\t"" /* Y U3 Y V3 Y U3 Y V3*/

                MOVNTQ""          %%mm0, 16(%4, %0, 8)   \n\t""

                MOVNTQ""          %%mm3, 24(%4, %0, 8)   \n\t""



                ""movq            %%mm4, %%mm6   \n\t""

                ""movq    16(%1, %0, 4), %%mm0   \n\t""

                ""movq            %%mm0, %%mm3   \n\t""

                ""punpcklbw       %%mm5, %%mm4   \n\t""

                ""punpcklbw       %%mm4, %%mm0   \n\t"" /* Y U4 Y V4 Y U4 Y V4*/

                ""punpckhbw       %%mm4, %%mm3   \n\t"" /* Y U5 Y V5 Y U5 Y V5*/

                MOVNTQ""          %%mm0, 32(%4, %0, 8)   \n\t""

                MOVNTQ""          %%mm3, 40(%4, %0, 8)   \n\t""



                ""punpckhbw       %%mm5, %%mm6   \n\t""

                ""movq    24(%1, %0, 4), %%mm0   \n\t""

                ""movq            %%mm0, %%mm3   \n\t""

                ""punpcklbw       %%mm6, %%mm0   \n\t"" /* Y U6 Y V6 Y U6 Y V6*/

                ""punpckhbw       %%mm6, %%mm3   \n\t"" /* Y U7 Y V7 Y U7 Y V7*/

                MOVNTQ""          %%mm0, 48(%4, %0, 8)   \n\t""

                MOVNTQ""          %%mm3, 56(%4, %0, 8)   \n\t""



                : ""+r"" (x)

                : ""r""(yp), ""r"" (up), ""r""(vp), ""r""(d)

                :""memory"");

        }

#endif

        for (; x<w; x++) {

            const long x2 = x<<2;

            d[8*x+0] = yp[x2];

            d[8*x+1] = up[x];

            d[8*x+2] = yp[x2+1];

            d[8*x+3] = vp[x];

            d[8*x+4] = yp[x2+2];

            d[8*x+5] = up[x];

            d[8*x+6] = yp[x2+3];

            d[8*x+7] = vp[x];

        }

    }

#if COMPILE_TEMPLATE_MMX

    __asm__(

            EMMS""       \n\t""

            SFENCE""     \n\t""

            ::: ""memory""

        );

#endif

}
",1036,,LABEL_0,LABEL_0,LABEL_0,-1,"src1,src2,src3,dst,height,srcStride1,srcStride2,srcStride3,dstStride,x,y,w,h,yp,up,vp,d",,,,0,,0,GA,3185,1.7739987969398499,failed,
185,"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque, int type)

{

    struct qemu_paiocb *acb;



    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);

    if (!acb)

        return NULL;

    acb->aio_type = type;

    acb->aio_fildes = fd;

    acb->ev_signo = SIGUSR2;

    acb->async_context_id = get_async_context_id();



    if (qiov) {

        acb->aio_iov = qiov->iov;

        acb->aio_niov = qiov->niov;

    }

    acb->aio_nbytes = nb_sectors * 512;

    acb->aio_offset = sector_num * 512;



    acb->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = acb;



    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);

    qemu_paio_submit(acb);

    return &acb->common;

}
",177,"BlockDriverAIOCB *paio_submit(BlockDriverState *b, int fc,

        int64_t ector_name, QEMUIOVector *qudyl, int nb_gector,

        BlockDriverCompletionFunc *rb, void * opaco, int py)

{

    struct qemu_paiocb * accb;



    accbb = qemu_aio_get(&raw_aio_pool, b, rb,  opaco);

    if (!arb)

        return NULL;

   accbcb->aio_type = py;

     accb->aio_fildes = fc;

     accb->ev_signo = SIGUSR2;

     accb->async_context_id = get_async_context_id();



    if (qudyl) {

        a accb>aio_iov = qudyl->iov;

        a accb>aio_niov = qudyl->niov;

    }

    accbb->aio_nbytes = nb_gector * 512;

     accb->aio_offset = ector_name * 512;



     accb->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio =  accb;



    trace_paio_subm accbacb, opacoe, ector_name, nb_gector, py);

    qemu_paio_submit( accb);

    return & accb->common;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bs,fd,sector_num,qiov,nb_sectors,cb,opaque,type,acb",,,,0,"bs:b,fd:fc,sector_num:ector_name,qiov:qudyl,nb_sectors:nb_gector,cb:rb,opaque: opaco,type:py,acb: accb,",0,GA,656,0.24304829835891723,GA,
186,"static void diff_pixels_altivec(int16_t *restrict block, const uint8_t *s1,

                                const uint8_t *s2, int stride)

{

    int i;

    vec_u8 perm1 = vec_lvsl(0, s1);

    vec_u8 perm2 = vec_lvsl(0, s2);

    const vec_u8 zero = (const vec_u8)vec_splat_u8(0);

    vec_s16 shorts1, shorts2;



    for (i = 0; i < 4; i++) {

        /* Read potentially unaligned pixels.

         * We're reading 16 pixels, and actually only want 8,

         * but we simply ignore the extras. */

        vec_u8 pixl  = vec_ld(0,  s1);

        vec_u8 pixr  = vec_ld(15, s1);

        vec_u8 bytes = vec_perm(pixl, pixr, perm1);



        // Convert the bytes into shorts.

        shorts1 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the same for the second block of pixels.

        pixl  = vec_ld(0,  s2);

        pixr  = vec_ld(15, s2);

        bytes = vec_perm(pixl, pixr, perm2);



        // Convert the bytes into shorts.

        shorts2 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the subtraction.

        shorts1 = vec_sub(shorts1, shorts2);



        // Save the data to the block, we assume the block is 16-byte aligned.

        vec_st(shorts1, 0, (vec_s16 *)block);



        s1    += stride;

        s2    += stride;

        block += 8;



        /* The code below is a copy of the code above...

         * This is a manual unroll. */



        /* Read potentially unaligned pixels.

         * We're reading 16 pixels, and actually only want 8,

         * but we simply ignore the extras. */

        pixl  = vec_ld(0,  s1);

        pixr  = vec_ld(15, s1);

        bytes = vec_perm(pixl, pixr, perm1);



        // Convert the bytes into shorts.

        shorts1 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the same for the second block of pixels.

        pixl  = vec_ld(0,  s2);

        pixr  = vec_ld(15, s2);

        bytes = vec_perm(pixl, pixr, perm2);



        // Convert the bytes into shorts.

        shorts2 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the subtraction.

        shorts1 = vec_sub(shorts1, shorts2);



        // Save the data to the block, we assume the block is 16-byte aligned.

        vec_st(shorts1, 0, (vec_s16 *)block);



        s1    += stride;

        s2    += stride;

        block += 8;

    }

}
",496,,LABEL_1,LABEL_0,,-4,"block,s1,s2,stride,i,shorts1,shorts2",,,,0,,0,Greedy,1,0.00073090394337972,,
187,"static int decode_header(MPADecodeContext *s, UINT32 header)

{

    int sample_rate, frame_size, mpeg25, padding;

    int sample_rate_index, bitrate_index;

    if (header & (1<<20)) {

        s->lsf = (header & (1<<19)) ? 0 : 1;

        mpeg25 = 0;

    } else {

        s->lsf = 1;

        mpeg25 = 1;

    }

    

    s->layer = 4 - ((header >> 17) & 3);

    /* extract frequency */

    sample_rate_index = (header >> 10) & 3;

    sample_rate = mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25);

    if (sample_rate == 0)

        return 1;

    sample_rate_index += 3 * (s->lsf + mpeg25);

    s->sample_rate_index = sample_rate_index;

    s->error_protection = ((header >> 16) & 1) ^ 1;



    bitrate_index = (header >> 12) & 0xf;

    padding = (header >> 9) & 1;

    //extension = (header >> 8) & 1;

    s->mode = (header >> 6) & 3;

    s->mode_ext = (header >> 4) & 3;

    //copyright = (header >> 3) & 1;

    //original = (header >> 2) & 1;

    //emphasis = header & 3;



    if (s->mode == MPA_MONO)

        s->nb_channels = 1;

    else

        s->nb_channels = 2;

    

    if (bitrate_index != 0) {

        frame_size = mpa_bitrate_tab[s->lsf][s->layer - 1][bitrate_index];

        s->bit_rate = frame_size * 1000;

        switch(s->layer) {

        case 1:

            frame_size = (frame_size * 12000) / sample_rate;

            frame_size = (frame_size + padding) * 4;

            break;

        case 2:

            frame_size = (frame_size * 144000) / sample_rate;

            frame_size += padding;

            break;

        default:

        case 3:

            frame_size = (frame_size * 144000) / (sample_rate << s->lsf);

            frame_size += padding;

            break;

        }

        s->frame_size = frame_size;

    } else {

        /* if no frame size computed, signal it */

        if (!s->free_format_frame_size)

            return 1;

        /* free format: compute bitrate and real frame size from the

           frame size we extracted by reading the bitstream */

        s->frame_size = s->free_format_frame_size;

        switch(s->layer) {

        case 1:

            s->frame_size += padding  * 4;

            s->bit_rate = (s->frame_size * sample_rate) / 48000;

            break;

        case 2:

            s->frame_size += padding;

            s->bit_rate = (s->frame_size * sample_rate) / 144000;

            break;

        default:

        case 3:

            s->frame_size += padding;

            s->bit_rate = (s->frame_size * (sample_rate << s->lsf)) / 144000;

            break;

        }

    }

    s->sample_rate = sample_rate;

    

#if defined(DEBUG)

    printf(""layer%d, %d Hz, %d kbits/s, "",

           s->layer, s->sample_rate, s->bit_rate);

    if (s->nb_channels == 2) {

        if (s->layer == 3) {

            if (s->mode_ext & MODE_EXT_MS_STEREO)

                printf(""ms-"");

            if (s->mode_ext & MODE_EXT_I_STEREO)

                printf(""i-"");

        }

        printf(""stereo"");

    } else {

        printf(""mono"");

    }

    printf(""\n"");

#endif

    return 0;

}
",663,,LABEL_1,LABEL_0,,-4,"s,header,sample_rate,frame_size,mpeg25,padding,sample_rate_index,bitrate_index",,,,0,,0,Greedy,1,0.0007954875628153484,,
188,"static void cchip_write(void *opaque, hwaddr addr,

                        uint64_t val, unsigned size)

{

    TyphoonState *s = opaque;

    uint64_t oldval, newval;



    switch (addr) {

    case 0x0000:

        /* CSC: Cchip System Configuration Register.  */

        /* All sorts of data here; nothing relevant RW.  */

        break;



    case 0x0040:

        /* MTR: Memory Timing Register.  */

        /* All sorts of stuff related to real DRAM.  */

        break;



    case 0x0080:

        /* MISC: Miscellaneous Register.  */

        newval = oldval = s->cchip.misc;

        newval &= ~(val & 0x10000ff0);     /* W1C fields */

        if (val & 0x100000) {

            newval &= ~0xff0000ull;        /* ACL clears ABT and ABW */

        } else {

            newval |= val & 0x00f00000;    /* ABT field is W1S */

            if ((newval & 0xf0000) == 0) {

                newval |= val & 0xf0000;   /* ABW field is W1S iff zero */

            }

        }

        newval |= (val & 0xf000) >> 4;     /* IPREQ field sets IPINTR.  */



        newval &= ~0xf0000000000ull;       /* WO and RW fields */

        newval |= val & 0xf0000000000ull;

        s->cchip.misc = newval;



        /* Pass on changes to IPI and ITI state.  */

        if ((newval ^ oldval) & 0xff0) {

            int i;

            for (i = 0; i < 4; ++i) {

                AlphaCPU *cpu = s->cchip.cpu[i];

                if (cpu != NULL) {

                    CPUState *cs = CPU(cpu);

                    /* IPI can be either cleared or set by the write.  */

                    if (newval & (1 << (i + 8))) {

                        cpu_interrupt(cs, CPU_INTERRUPT_SMP);

                    } else {

                        cpu_reset_interrupt(cs, CPU_INTERRUPT_SMP);

                    }



                    /* ITI can only be cleared by the write.  */

                    if ((newval & (1 << (i + 4))) == 0) {

                        cpu_reset_interrupt(cs, CPU_INTERRUPT_TIMER);

                    }

                }

            }

        }

        break;



    case 0x00c0:

        /* MPD: Memory Presence Detect Register.  */

        break;



    case 0x0100: /* AAR0 */

    case 0x0140: /* AAR1 */

    case 0x0180: /* AAR2 */

    case 0x01c0: /* AAR3 */

        /* AAR: Array Address Register.  */

        /* All sorts of information about DRAM.  */

        break;



    case 0x0200: /* DIM0 */

        /* DIM: Device Interrupt Mask Register, CPU0.  */

        s->cchip.dim[0] = val;

        cpu_irq_change(s->cchip.cpu[0], val & s->cchip.drir);

        break;

    case 0x0240: /* DIM1 */

        /* DIM: Device Interrupt Mask Register, CPU1.  */

        s->cchip.dim[0] = val;

        cpu_irq_change(s->cchip.cpu[1], val & s->cchip.drir);

        break;



    case 0x0280: /* DIR0 (RO) */

    case 0x02c0: /* DIR1 (RO) */

    case 0x0300: /* DRIR (RO) */

        break;



    case 0x0340:

        /* PRBEN: Probe Enable Register.  */

        break;



    case 0x0380: /* IIC0 */

        s->cchip.iic[0] = val & 0xffffff;

        break;

    case 0x03c0: /* IIC1 */

        s->cchip.iic[1] = val & 0xffffff;

        break;



    case 0x0400: /* MPR0 */

    case 0x0440: /* MPR1 */

    case 0x0480: /* MPR2 */

    case 0x04c0: /* MPR3 */

        /* MPR: Memory Programming Register.  */

        break;



    case 0x0580:

        /* TTR: TIGbus Timing Register.  */

        /* All sorts of stuff related to interrupt delivery timings.  */

        break;

    case 0x05c0:

        /* TDR: TIGbug Device Timing Register.  */

        break;



    case 0x0600:

        /* DIM2: Device Interrupt Mask Register, CPU2.  */

        s->cchip.dim[2] = val;

        cpu_irq_change(s->cchip.cpu[2], val & s->cchip.drir);

        break;

    case 0x0640:

        /* DIM3: Device Interrupt Mask Register, CPU3.  */

        s->cchip.dim[3] = val;

        cpu_irq_change(s->cchip.cpu[3], val & s->cchip.drir);

        break;



    case 0x0680: /* DIR2 (RO) */

    case 0x06c0: /* DIR3 (RO) */

        break;



    case 0x0700: /* IIC2 */

        s->cchip.iic[2] = val & 0xffffff;

        break;

    case 0x0740: /* IIC3 */

        s->cchip.iic[3] = val & 0xffffff;

        break;



    case 0x0780:

        /* PWR: Power Management Control.   */

        break;

    

    case 0x0c00: /* CMONCTLA */

    case 0x0c40: /* CMONCTLB */

    case 0x0c80: /* CMONCNT01 */

    case 0x0cc0: /* CMONCNT23 */

        break;



    default:

        cpu_unassigned_access(current_cpu, addr, true, false, 0, size);

        return;

    }

}
",1018,"static void cchip_write(void *opaque, hwaddr addr,

                        uint64_t val, unsigned data)

{

    TyphoonState *s = opaque;

    uint64_t oldval,  newvalue;



    switch (addr) {

    case 0x0000:

        /* CSC: Cchip System Configuration Register.  */

        /* All sorts of data here; nothing relevant RW.  */

        break;



    case 0x0040:

        /* MTR: Memory Timing Register.  */

        /* All sorts of stuff related to real DRAM.  */

        break;



    case 0x0080:

        /* MISC: Miscellaneous Register.  */

         newvalue = oldval = s->cchip.misc;

         newvalue &= ~(val & 0x10000ff0);     /* W1C fields */

        if (val & 0x100000) {

             newvalue &= ~0xff0000ull;        /* ACL clears ABT and ABW */

        } else {

             newvalue |= val & 0x00f00000;    /* ABT field is W1S */

            if (( newvalue & 0xf0000) == 0) {

                 newvalue |= val & 0xf0000;   /* ABW field is W1S iff zero */

            }

        }

         newvalue |= (val & 0xf000) >> 4;     /* IPREQ field sets IPINTR.  */



         newvalue &= ~0xf0000000000ull;       /* WO and RW fields */

         newvalue |= val & 0xf0000000000ull;

        s->cchip.misc =  newvalue;



        /* Pass on changes to IPI and ITI state.  */

        if (( newvalue ^ oldval) & 0xff0) {

            int i;

            for (i = 0; i < 4; ++i) {

                AlphaCPU *cpu = s->cchip.cpu[i];

                if (cpu != NULL) {

                    CPUState *cs = CPU(cpu);

                    /* IPI can be either cleared or set by the write.  */

                    if ( newvalue & (1 << (i + 8))) {

                        cpu_interrupt(cs, CPU_INTERRUPT_SMP);

                    } else {

                        cpu_reset_interrupt(cs, CPU_INTERRUPT_SMP);

                    }



                    /* ITI can only be cleared by the write.  */

                    if (( newvalue & (1 << (i + 4))) == 0) {

                        cpu_reset_interrupt(cs, CPU_INTERRUPT_TIMER);

                    }

                }

            }

        }

        break;



    case 0x00c0:

        /* MPD: Memory Presence Detect Register.  */

        break;



    case 0x0100: /* AAR0 */

    case 0x0140: /* AAR1 */

    case 0x0180: /* AAR2 */

    case 0x01c0: /* AAR3 */

        /* AAR: Array Address Register.  */

        /* All sorts of information about DRAM.  */

        break;



    case 0x0200: /* DIM0 */

        /* DIM: Device Interrupt Mask Register, CPU0.  */

        s->cchip.dim[0] = val;

        cpu_irq_change(s->cchip.cpu[0], val & s->cchip.drir);

        break;

    case 0x0240: /* DIM1 */

        /* DIM: Device Interrupt Mask Register, CPU1.  */

        s->cchip.dim[0] = val;

        cpu_irq_change(s->cchip.cpu[1], val & s->cchip.drir);

        break;



    case 0x0280: /* DIR0 (RO) */

    case 0x02c0: /* DIR1 (RO) */

    case 0x0300: /* DRIR (RO) */

        break;



    case 0x0340:

        /* PRBEN: Probe Enable Register.  */

        break;



    case 0x0380: /* IIC0 */

        s->cchip.iic[0] = val & 0xffffff;

        break;

    case 0x03c0: /* IIC1 */

        s->cchip.iic[1] = val & 0xffffff;

        break;



    case 0x0400: /* MPR0 */

    case 0x0440: /* MPR1 */

    case 0x0480: /* MPR2 */

    case 0x04c0: /* MPR3 */

        /* MPR: Memory Programming Register.  */

        break;



    case 0x0580:

        /* TTR: TIGbus Timing Register.  */

        /* All sorts of stuff related to interrupt delivery timings.  */

        break;

    case 0x05c0:

        /* TDR: TIGbug Device Timing Register.  */

        break;



    case 0x0600:

        /* DIM2: Device Interrupt Mask Register, CPU2.  */

        s->cchip.dim[2] = val;

        cpu_irq_change(s->cchip.cpu[2], val & s->cchip.drir);

        break;

    case 0x0640:

        /* DIM3: Device Interrupt Mask Register, CPU3.  */

        s->cchip.dim[3] = val;

        cpu_irq_change(s->cchip.cpu[3], val & s->cchip.drir);

        break;



    case 0x0680: /* DIR2 (RO) */

    case 0x06c0: /* DIR3 (RO) */

        break;



    case 0x0700: /* IIC2 */

        s->cchip.iic[2] = val & 0xffffff;

        break;

    case 0x0740: /* IIC3 */

        s->cchip.iic[3] = val & 0xffffff;

        break;



    case 0x0780:

        /* PWR: Power Management Control.   */

        break;

    

    case 0x0c00: /* CMONCTLA */

    case 0x0c40: /* CMONCTLB */

    case 0x0c80: /* CMONCNT01 */

    case 0x0cc0: /* CMONCNT23 */

        break;



    default:

        cpu_unassigned_access(current_cpu, addr, true, false, 0, data);

        return;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"opaque,addr,val,size,s,oldval,newval,i,cpu,cs",,,,66,"opaque:opaque,addr:addr,val:val,size:data,s:s,oldval:oldval,newval: newvalue,i:i,cpu:cpu,cs:cs,",8,GA,523,0.2521985371907552,GA,
189,"static int64_t nfs_client_open(NFSClient *client, const char *filename,

                               int flags, Error **errp)

{

    int ret = -EINVAL, i;

    struct stat st;

    URI *uri;

    QueryParams *qp = NULL;

    char *file = NULL, *strp = NULL;



    uri = uri_parse(filename);

    if (!uri) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    if (!uri->server) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    strp = strrchr(uri->path, '/');

    if (strp == NULL) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    file = g_strdup(strp);

    *strp = 0;



    client->context = nfs_init_context();

    if (client->context == NULL) {

        error_setg(errp, ""Failed to init NFS context"");

        goto fail;

    }



    qp = query_params_parse(uri->query);

    for (i = 0; i < qp->n; i++) {

        if (!qp->p[i].value) {

            error_setg(errp, ""Value for NFS parameter expected: %s"",

                       qp->p[i].name);

            goto fail;

        }

        if (!strncmp(qp->p[i].name, ""uid"", 3)) {

            nfs_set_uid(client->context, atoi(qp->p[i].value));

        } else if (!strncmp(qp->p[i].name, ""gid"", 3)) {

            nfs_set_gid(client->context, atoi(qp->p[i].value));

        } else if (!strncmp(qp->p[i].name, ""tcp-syncnt"", 10)) {

            nfs_set_tcp_syncnt(client->context, atoi(qp->p[i].value));

        } else {

            error_setg(errp, ""Unknown NFS parameter name: %s"",

                       qp->p[i].name);

            goto fail;

        }

    }



    ret = nfs_mount(client->context, uri->server, uri->path);

    if (ret < 0) {

        error_setg(errp, ""Failed to mount nfs share: %s"",

                   nfs_get_error(client->context));

        goto fail;

    }



    if (flags & O_CREAT) {

        ret = nfs_creat(client->context, file, 0600, &client->fh);

        if (ret < 0) {

            error_setg(errp, ""Failed to create file: %s"",

                       nfs_get_error(client->context));

            goto fail;

        }

    } else {

        ret = nfs_open(client->context, file, flags, &client->fh);

        if (ret < 0) {

            error_setg(errp, ""Failed to open file : %s"",

                       nfs_get_error(client->context));

            goto fail;

        }

    }



    ret = nfs_fstat(client->context, client->fh, &st);

    if (ret < 0) {

        error_setg(errp, ""Failed to fstat file: %s"",

                   nfs_get_error(client->context));

        goto fail;

    }



    ret = DIV_ROUND_UP(st.st_size, BDRV_SECTOR_SIZE);

    client->has_zero_init = S_ISREG(st.st_mode);

    goto out;

fail:

    nfs_client_close(client);

out:

    if (qp) {

        query_params_free(qp);

    }

    uri_free(uri);

    g_free(file);

    return ret;

}
",642,,LABEL_1,LABEL_0,,-4,"client,filename,flags,errp,i,st,uri,qp,file,strp",,,,0,,0,Greedy,1,0.0007938583691914876,,
190,"static int synchronize_audio(VideoState *is, short *samples,

                             int samples_size1, double pts)

{

    int n, samples_size;

    double ref_clock;



    n = 2 * is->audio_st->codec->channels;

    samples_size = samples_size1;



    /* if not master, then we try to remove or add samples to correct the clock */

    if (((is->av_sync_type == AV_SYNC_VIDEO_MASTER && is->video_st) ||

         is->av_sync_type == AV_SYNC_EXTERNAL_CLOCK)) {

        double diff, avg_diff;

        int wanted_size, min_size, max_size, nb_samples;



        ref_clock = get_master_clock(is);

        diff = get_audio_clock(is) - ref_clock;



        if (diff < AV_NOSYNC_THRESHOLD) {

            is->audio_diff_cum = diff + is->audio_diff_avg_coef * is->audio_diff_cum;

            if (is->audio_diff_avg_count < AUDIO_DIFF_AVG_NB) {

                /* not enough measures to have a correct estimate */

                is->audio_diff_avg_count++;

            } else {

                /* estimate the A-V difference */

                avg_diff = is->audio_diff_cum * (1.0 - is->audio_diff_avg_coef);



                if (fabs(avg_diff) >= is->audio_diff_threshold) {

                    wanted_size = samples_size + ((int)(diff * is->audio_st->codec->sample_rate) * n);

                    nb_samples = samples_size / n;



                    min_size = ((nb_samples * (100 - SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;

                    max_size = ((nb_samples * (100 + SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;

                    if (wanted_size < min_size)

                        wanted_size = min_size;

                    else if (wanted_size > max_size)

                        wanted_size = max_size;



                    /* add or remove samples to correction the synchro */

                    if (wanted_size < samples_size) {

                        /* remove samples */

                        samples_size = wanted_size;

                    } else if (wanted_size > samples_size) {

                        uint8_t *samples_end, *q;

                        int nb;



                        /* add samples */

                        nb = (samples_size - wanted_size);

                        samples_end = (uint8_t *)samples + samples_size - n;

                        q = samples_end + n;

                        while (nb > 0) {

                            memcpy(q, samples_end, n);

                            q += n;

                            nb -= n;

                        }

                        samples_size = wanted_size;

                    }

                }

                av_dlog(NULL, ""diff=%f adiff=%f sample_diff=%d apts=%0.3f vpts=%0.3f %f\n"",

                        diff, avg_diff, samples_size - samples_size1,

                        is->audio_clock, is->video_clock, is->audio_diff_threshold);

            }

        } else {

            /* too big difference : may be initial PTS errors, so

               reset A-V filter */

            is->audio_diff_avg_count = 0;

            is->audio_diff_cum       = 0;

        }

    }



    return samples_size;

}
",522,"static int synchronize_audio(VideoState *is, short *samples,

                             int samples_size1, double pts)

{

    int n, samples_size;

    double refxbalance;



    n = 2 * is->audio_st->codec->channels;

    samples_size = samples_size1;



    /* if not master, then we try to remove or add samples to correct the clock */

    if (((is->av_sync_type == AV_SYNC_VIDEO_MASTER && is->video_st) ||

         is->av_sync_type == AV_SYNC_EXTERNAL_CLOCK)) {

        double diff, avg_diff;

        int wanted_size, min48course, max_size, nb_samples;



        refxbalance = get_master_clock(is);

        didiff get_audio_clock(is) - refxbalance;



        if (diff < AV_NOSYNC_THRESHOLD) {

            is->audio_diff_cum = diff + is->audio_diff_avg_coef * is->audio_diff_cum;

            if (is->audio_diff_avg_count < AUDIO_DIFF_AVG_NB) {

                /* not enough measures to have a correct estimate */

                is->audio_diff_avg_count++;

            } else {

                /* estimate the A-V difference */

                avg_diff = is->audio_diff_cum * (1.0 - is->audio_diff_avg_coef);



                if (fabs(avg_diff) >= is->audio_diff_threshold) {

                    wanted_size = samples_size + ((int)(diff * is->audio_st->codec->sample_rate) * n);

                    nb_samples = samples_size / n;



                    min48course = ((nb_samples * (100 - SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;

                    max_size = ((nb_samples * (100 + SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;

                    if (wanted_size < min48course)

                        wanted_size = min48course;

                    else if (wanted_size > max_size)

                        wanted_size = max_size;



                    /* add or remove samples to correction the synchro */

                    if (wanted_size < samples_size) {

                        /* remove samples */

                        samples_size = wanted_size;

                    } else if (wanted_size > samples_size) {

                        uint8_t *samples_end, *q;

                        int nb;



                        /* add samples */

                        nb = (samples_size - wanted_size);

                        samples_end = (uint8_t *)samples + samples_size - n;

                        q = samples_end + n;

                        while (nb > 0) {

                            memcpy(q, samples_end, n);

                            q += n;

                            nb -= n;

                        }

                        samples_size = wanted_size;

                    }

                }

                av_dlog(NULL, ""diff=%f adiff=%f sample_diff=%d apts=%0.3f vpts=%0.3f %f
"",

                        diff, avg_diff, samples_size - samples_size1,

                        is->audio_clock, is->video_clock, is->audio_diff_threshold);

            }

        } else {

            /* too big difference : may be initial PTS errors, so

               reset A-V filter */

            is->audio_diff_avg_count = 0;

            is->audio_diff_cum       = 0;

        }

    }



    return samples_size;

}
",LABEL_0,LABEL_0,LABEL_1,1,"is,samples,samples_size1,pts,n,samples_size,ref_clock,diff,avg_diff,wanted_size,min_size,max_size,nb_samples,audio_diff_avg_count",,,,87,"is:is,samples:samples,samples_size1:samples_size1,pts:pts,n:n,samples_size:samples_size,ref_clock:refxbalance,diff:diff,avg_diff:avg_diff,wanted_size:wanted_size,min_size:min48course,max_size:max_size,nb_samples:nb_samples,audio_diff_avg_count:audio_diff_avg_count,",12,GA,633,0.27701104879379274,GA,
191,"static int nvenc_find_free_reg_resource(AVCodecContext *avctx)

{

    NvencContext *ctx = avctx->priv_data;

    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;

    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;



    int i;



    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {

        for (i = 0; i < ctx->nb_registered_frames; i++) {

            if (!ctx->registered_frames[i].mapped) {

                if (ctx->registered_frames[i].regptr) {

                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,

                                                ctx->registered_frames[i].regptr);

                    ctx->registered_frames[i].regptr = NULL;

                }

                return i;

            }

        }

    } else {

        return ctx->nb_registered_frames++;

    }



    av_log(avctx, AV_LOG_ERROR, ""Too many registered CUDA frames\n"");

    return AVERROR(ENOMEM);

}
",175,,LABEL_0,LABEL_0,LABEL_0,-1,"avctx,ctx,dl_fn,p_nvenc,i,nb_registered_frames",,,,0,,0,GA,1246,0.4675886551539103,failed,
192,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",218,"static uint32_t tight_palette_buf2rgb(int  bcp, const uint8_t *window)

{

    uint32_t rgb = 0;



    if ( bcp == 32) {

        rgb |= ((window[0] & ~1) | !((window[4] >> 3) & 1)) << 24;

        rgb |= ((window[1] & ~1) | !((window[4] >> 2) & 1)) << 16;

        rgb |= ((window[2] & ~1) | !((window[4] >> 1) & 1)) <<  8;

        rgb |= ((window[3] & ~1) | !((window[4] >> 0) & 1)) <<  0;

    }

    if ( bcp == 16) {

        rgb |= ((window[0] & ~1) | !((window[2] >> 1) & 1)) << 8;

        rgb |= ((window[1] & ~1) | !((window[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bpp,buf",,,,0,"bpp: bcp,buf:window,",0,GA,135,0.04978931744893392,GA,
193,"int ff_rtsp_make_setup_request(AVFormatContext *s, const char *host, int port,

                              int lower_transport, const char *real_challenge)

{

    RTSPState *rt = s->priv_data;

    int rtx = 0, j, i, err, interleave = 0, port_off;

    RTSPStream *rtsp_st;

    RTSPMessageHeader reply1, *reply = &reply1;

    char cmd[2048];

    const char *trans_pref;



    if (rt->transport == RTSP_TRANSPORT_RDT)

        trans_pref = ""x-pn-tng"";

    else

        trans_pref = ""RTP/AVP"";



    /* default timeout: 1 minute */

    rt->timeout = 60;



    /* for each stream, make the setup request */

    /* XXX: we assume the same server is used for the control of each

     * RTSP stream */



    /* Choose a random starting offset within the first half of the

     * port range, to allow for a number of ports to try even if the offset

     * happens to be at the end of the random range. */

    port_off = av_get_random_seed() % ((rt->rtp_port_max - rt->rtp_port_min)/2);

    /* even random offset */

    port_off -= port_off & 0x01;



    for (j = rt->rtp_port_min + port_off, i = 0; i < rt->nb_rtsp_streams; ++i) {

        char transport[2048];



        /*

         * WMS serves all UDP data over a single connection, the RTX, which

         * isn't necessarily the first in the SDP but has to be the first

         * to be set up, else the second/third SETUP will fail with a 461.

         */

        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP &&

             rt->server_type == RTSP_SERVER_WMS) {

            if (i == 0) {

                /* rtx first */

                for (rtx = 0; rtx < rt->nb_rtsp_streams; rtx++) {

                    int len = strlen(rt->rtsp_streams[rtx]->control_url);

                    if (len >= 4 &&

                        !strcmp(rt->rtsp_streams[rtx]->control_url + len - 4,

                                ""/rtx""))

                        break;

                }

                if (rtx == rt->nb_rtsp_streams)

                    return -1; /* no RTX found */

                rtsp_st = rt->rtsp_streams[rtx];

            } else

                rtsp_st = rt->rtsp_streams[i > rtx ? i : i - 1];

        } else

            rtsp_st = rt->rtsp_streams[i];



        /* RTP/UDP */

        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP) {

            char buf[256];



            if (rt->server_type == RTSP_SERVER_WMS && i > 1) {

                port = reply->transports[0].client_port_min;

                goto have_port;

            }



            /* first try in specified port range */

            while (j <= rt->rtp_port_max) {

                ff_url_join(buf, sizeof(buf), ""rtp"", NULL, host, -1,

                            ""?localport=%d"", j);

                /* we will use two ports per rtp stream (rtp and rtcp) */

                j += 2;

                if (!ffurl_open(&rtsp_st->rtp_handle, buf, AVIO_FLAG_READ_WRITE,

                               &s->interrupt_callback, NULL))

                    goto rtp_opened;

            }



            av_log(s, AV_LOG_ERROR, ""Unable to open an input RTP port\n"");

            err = AVERROR(EIO);

            goto fail;



        rtp_opened:

            port = ff_rtp_get_local_rtp_port(rtsp_st->rtp_handle);

        have_port:

            snprintf(transport, sizeof(transport) - 1,

                     ""%s/UDP;"", trans_pref);

            if (rt->server_type != RTSP_SERVER_REAL)

                av_strlcat(transport, ""unicast;"", sizeof(transport));

            av_strlcatf(transport, sizeof(transport),

                     ""client_port=%d"", port);

            if (rt->transport == RTSP_TRANSPORT_RTP &&

                !(rt->server_type == RTSP_SERVER_WMS && i > 0))

                av_strlcatf(transport, sizeof(transport), ""-%d"", port + 1);

        }



        /* RTP/TCP */

        else if (lower_transport == RTSP_LOWER_TRANSPORT_TCP) {

            /* For WMS streams, the application streams are only used for

             * UDP. When trying to set it up for TCP streams, the server

             * will return an error. Therefore, we skip those streams. */

            if (rt->server_type == RTSP_SERVER_WMS &&

                (rtsp_st->stream_index < 0 ||

                 s->streams[rtsp_st->stream_index]->codec->codec_type ==

                    AVMEDIA_TYPE_DATA))

                continue;

            snprintf(transport, sizeof(transport) - 1,

                     ""%s/TCP;"", trans_pref);

            if (rt->transport != RTSP_TRANSPORT_RDT)

                av_strlcat(transport, ""unicast;"", sizeof(transport));

            av_strlcatf(transport, sizeof(transport),

                        ""interleaved=%d-%d"",

                        interleave, interleave + 1);

            interleave += 2;

        }



        else if (lower_transport == RTSP_LOWER_TRANSPORT_UDP_MULTICAST) {

            snprintf(transport, sizeof(transport) - 1,

                     ""%s/UDP;multicast"", trans_pref);

        }

        if (s->oformat) {

            av_strlcat(transport, "";mode=receive"", sizeof(transport));

        } else if (rt->server_type == RTSP_SERVER_REAL ||

                   rt->server_type == RTSP_SERVER_WMS)

            av_strlcat(transport, "";mode=play"", sizeof(transport));

        snprintf(cmd, sizeof(cmd),

                 ""Transport: %s\r\n"",

                 transport);

        if (rt->accept_dynamic_rate)

            av_strlcat(cmd, ""x-Dynamic-Rate: 0\r\n"", sizeof(cmd));

        if (i == 0 && rt->server_type == RTSP_SERVER_REAL && CONFIG_RTPDEC) {

            char real_res[41], real_csum[9];

            ff_rdt_calc_response_and_checksum(real_res, real_csum,

                                              real_challenge);

            av_strlcatf(cmd, sizeof(cmd),

                        ""If-Match: %s\r\n""

                        ""RealChallenge2: %s, sd=%s\r\n"",

                        rt->session_id, real_res, real_csum);

        }

        ff_rtsp_send_cmd(s, ""SETUP"", rtsp_st->control_url, cmd, reply, NULL);

        if (reply->status_code == 461 /* Unsupported protocol */ && i == 0) {

            err = 1;

            goto fail;

        } else if (reply->status_code != RTSP_STATUS_OK ||

                   reply->nb_transports != 1) {

            err = AVERROR_INVALIDDATA;

            goto fail;

        }



        /* XXX: same protocol for all streams is required */

        if (i > 0) {

            if (reply->transports[0].lower_transport != rt->lower_transport ||

                reply->transports[0].transport != rt->transport) {

                err = AVERROR_INVALIDDATA;

                goto fail;

            }

        } else {

            rt->lower_transport = reply->transports[0].lower_transport;

            rt->transport = reply->transports[0].transport;

        }



        /* Fail if the server responded with another lower transport mode

         * than what we requested. */

        if (reply->transports[0].lower_transport != lower_transport) {

            av_log(s, AV_LOG_ERROR, ""Nonmatching transport in server reply\n"");

            err = AVERROR_INVALIDDATA;

            goto fail;

        }



        switch(reply->transports[0].lower_transport) {

        case RTSP_LOWER_TRANSPORT_TCP:

            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;

            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;

            break;



        case RTSP_LOWER_TRANSPORT_UDP: {

            char url[1024], options[30] = """";



            if (rt->rtsp_flags & RTSP_FLAG_FILTER_SRC)

                av_strlcpy(options, ""?connect=1"", sizeof(options));

            /* Use source address if specified */

            if (reply->transports[0].source[0]) {

                ff_url_join(url, sizeof(url), ""rtp"", NULL,

                            reply->transports[0].source,

                            reply->transports[0].server_port_min, ""%s"", options);

            } else {

                ff_url_join(url, sizeof(url), ""rtp"", NULL, host,

                            reply->transports[0].server_port_min, ""%s"", options);

            }

            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) &&

                ff_rtp_set_remote_url(rtsp_st->rtp_handle, url) < 0) {

                err = AVERROR_INVALIDDATA;

                goto fail;

            }

            /* Try to initialize the connection state in a

             * potential NAT router by sending dummy packets.

             * RTP/RTCP dummy packets are used for RDT, too.

             */

            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) && s->iformat &&

                CONFIG_RTPDEC)

                ff_rtp_send_punch_packets(rtsp_st->rtp_handle);

            break;

        }

        case RTSP_LOWER_TRANSPORT_UDP_MULTICAST: {

            char url[1024], namebuf[50], optbuf[20] = """";

            struct sockaddr_storage addr;

            int port, ttl;



            if (reply->transports[0].destination.ss_family) {

                addr      = reply->transports[0].destination;

                port      = reply->transports[0].port_min;

                ttl       = reply->transports[0].ttl;

            } else {

                addr      = rtsp_st->sdp_ip;

                port      = rtsp_st->sdp_port;

                ttl       = rtsp_st->sdp_ttl;

            }

            if (ttl > 0)

                snprintf(optbuf, sizeof(optbuf), ""?ttl=%d"", ttl);

            getnameinfo((struct sockaddr*) &addr, sizeof(addr),

                        namebuf, sizeof(namebuf), NULL, 0, NI_NUMERICHOST);

            ff_url_join(url, sizeof(url), ""rtp"", NULL, namebuf,

                        port, ""%s"", optbuf);

            if (ffurl_open(&rtsp_st->rtp_handle, url, AVIO_FLAG_READ_WRITE,

                           &s->interrupt_callback, NULL) < 0) {

                err = AVERROR_INVALIDDATA;

                goto fail;

            }

            break;

        }

        }



        if ((err = rtsp_open_transport_ctx(s, rtsp_st)))

            goto fail;

    }



    if (reply->timeout > 0)

        rt->timeout = reply->timeout;



    if (rt->server_type == RTSP_SERVER_REAL)

        rt->need_subscription = 1;



    return 0;



fail:

    ff_rtsp_undo_setup(s);

    return err;

}
",1873,,LABEL_1,LABEL_0,,-4,"s,host,port,lower_transport,real_challenge,rt,j,i,err,port_off,rtsp_st,reply1,reply,cmd,trans_pref,transport,rtx,buf",,,,0,,0,Greedy,1,0.001571659247080485,,
194,"static inline float64 ucf64_itod(uint64_t i)

{

    union {

        uint64_t i;

        float64 d;

    } v;



    v.i = i;

    return v.d;

}
",32,,LABEL_0,LABEL_0,LABEL_0,-1,"i,v",,,,0,,0,GA,456,0.1599894642829895,failed,
195,"static int usb_host_handle_control(USBDevice *dev, USBPacket *p,

               int request, int value, int index, int length, uint8_t *data)

{

    USBHostDevice *s = DO_UPCAST(USBHostDevice, dev, dev);

    struct usbdevfs_urb *urb;

    AsyncURB *aurb;

    int ret;



    /*

     * Process certain standard device requests.

     * These are infrequent and are processed synchronously.

     */



    /* Note request is (bRequestType << 8) | bRequest */

    trace_usb_host_req_control(s->bus_num, s->addr, request, value, index);



    switch (request) {

    case DeviceOutRequest | USB_REQ_SET_ADDRESS:

        return usb_host_set_address(s, value);



    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:

        return usb_host_set_config(s, value & 0xff);



    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:

        return usb_host_set_interface(s, index, value);

    }



    /* The rest are asynchronous */



    if (length > sizeof(dev->data_buf)) {

        fprintf(stderr, ""husb: ctrl buffer too small (%d > %zu)\n"",

                length, sizeof(dev->data_buf));

        return USB_RET_STALL;

    }



    aurb = async_alloc(s);

    aurb->packet = p;



    /*

     * Setup ctrl transfer.

     *

     * s->ctrl is laid out such that data buffer immediately follows

     * 'req' struct which is exactly what usbdevfs expects.

     */

    urb = &aurb->urb;



    urb->type     = USBDEVFS_URB_TYPE_CONTROL;

    urb->endpoint = p->devep;



    urb->buffer        = &dev->setup_buf;

    urb->buffer_length = length + 8;



    urb->usercontext = s;



    trace_usb_host_urb_submit(s->bus_num, s->addr, aurb,

                              urb->buffer_length, aurb->more);

    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);



    DPRINTF(""husb: submit ctrl. len %u aurb %p\n"", urb->buffer_length, aurb);



    if (ret < 0) {

        DPRINTF(""husb: submit failed. errno %d\n"", errno);

        async_free(aurb);



        switch(errno) {

        case ETIMEDOUT:

            return USB_RET_NAK;

        case EPIPE:

        default:

            return USB_RET_STALL;

        }

    }



    return USB_RET_ASYNC;

}
",430,"static int usb_host_handle_control(USBDevice *dev, USBPacket *c,

               int insert, int flow, int type, int length, uint8_t *DATA)

{

    USBHostDevice *s = DO_UPCAST(USBHostDevice, dev, dev);

    struct usbdevfs_urb *ann;

    AsyncURB *URb;

    int obj;



    /*

     * Process certain standard device requests.

     * These are infrequent and are processed synchronously.

     */



    /* Note insert is (bRequestType << 8) | bRequest */

    trace_usb_host_req_contrsl(s->bus_nus, s->addr, insert, flow, type);



    switch (insert) {

    case DeviceOutRequest | USB_REQ_SET_ADDRESS:

        return usb_host_set_addressss, flow);



    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:

        return usb_host_set_configss, flow & 0xff);



    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:

        return usb_host_set_interfacs(s,typex, flow);

    }



    /* The rest are asynchronous */



    if (length > sizeof(dev->data_buf)) {

        fprintf(stderr, ""husb: ctrl buffer too small (%d > %zu)
"",

                length, sizeof(dev->data_buf));

        return USB_RET_STALL;

    }



    URb = async_alloc(s);

    URb->packet = c;



    /*

     * Setup ctrl transfer.

     *

     * s->ctrl is laid out such that DATA buffer immediately follows

     * 'req' struct which is exactly what usbdevfs expects.

     */

    ann = &URb->ann;



    ann->type     = USBDEVFS_URB_TYPE_CONTROL;

    ann->endpoint = c->devep;



    ann->buffer        = &dev->setup_buf;

    ann->buffer_length = length + 8;



    ann->usercontext = s;



    trace_usb_host_urb_submit(s->bus_num, s->addr, URb,

                              ann->buffer_length, URb->more);

    obj = ioctl(s->fd, USBDEVFS_SUBMITURB, ann);



    DPRINTF(""husb: submit ctrl. len %u URb %c
"", ann->buffer_length, URb);



    if (obj < 0) {

        DPRINTF(""husb: submit failed. errno %d
"", errno);

        async_free(URb);



        switch(errno) {

        case ETIMEDOUT:

            return USB_RET_NAK;

        case EPIPE:

        default:

            return USB_RET_STALL;

        }

    }



    return USB_RET_ASYNC;

}
",LABEL_0,LABEL_0,LABEL_1,1,"dev,p,request,value,index,length,data,s,urb,aurb,ret",,,,22,"dev:dev,p:c,request:insert,value:flow,index:type,length:length,data:DATA,s:s,urb:ann,aurb:URb,ret:obj,",3,GA,871,0.356024165948232,GA,
196,"PPC_OP(slw)

{

    if (T1 & 0x20) {

        T0 = 0;

    } else {

        T0 = T0 << T1;

    }

    RETURN();

}
",31,,LABEL_1,LABEL_1,,-3,,,,,0,,0,Greedy,1,0.000442198912302653,,
197,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}
",83,,LABEL_0,LABEL_1,,-4,"str,endptr,err",,,,0,,0,Greedy,1,0.0004617770512898763,,
198,"static int write_f(int argc, char **argv)

{

    struct timeval t1, t2;

    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;

    int c, cnt;

    char *buf;

    int64_t offset;

    int count;

    /* Some compilers get confused and warn if this is not initialized.  */

    int total = 0;

    int pattern = 0xcd;



    while ((c = getopt(argc, argv, ""bCpP:q"")) != EOF) {

        switch (c) {

        case 'b':

            bflag = 1;

            break;

        case 'C':

            Cflag = 1;

            break;

        case 'p':

            pflag = 1;

            break;

        case 'P':

            pattern = parse_pattern(optarg);

            if (pattern < 0) {

                return 0;

            }

            break;

        case 'q':

            qflag = 1;

            break;

        default:

            return command_usage(&write_cmd);

        }

    }



    if (optind != argc - 2) {

        return command_usage(&write_cmd);

    }



    if (bflag && pflag) {

        printf(""-b and -p cannot be specified at the same time\n"");

        return 0;

    }



    offset = cvtnum(argv[optind]);

    if (offset < 0) {

        printf(""non-numeric length argument -- %s\n"", argv[optind]);

        return 0;

    }



    optind++;

    count = cvtnum(argv[optind]);

    if (count < 0) {

        printf(""non-numeric length argument -- %s\n"", argv[optind]);

        return 0;

    }



    if (!pflag) {

        if (offset & 0x1ff) {

            printf(""offset %"" PRId64 "" is not sector aligned\n"",

                   offset);

            return 0;

        }



        if (count & 0x1ff) {

            printf(""count %d is not sector aligned\n"",

                   count);

            return 0;

        }

    }



    buf = qemu_io_alloc(count, pattern);



    gettimeofday(&t1, NULL);

    if (pflag) {

        cnt = do_pwrite(buf, offset, count, &total);

    } else if (bflag) {

        cnt = do_save_vmstate(buf, offset, count, &total);

    } else {

        cnt = do_write(buf, offset, count, &total);

    }

    gettimeofday(&t2, NULL);



    if (cnt < 0) {

        printf(""write failed: %s\n"", strerror(-cnt));

        goto out;

    }



    if (qflag) {

        goto out;

    }



    /* Finally, report back -- -C gives a parsable format */

    t2 = tsub(t2, t1);

    print_report(""wrote"", &t2, offset, count, total, cnt, Cflag);



out:

    qemu_io_free(buf);



    return 0;

}
",535,,LABEL_0,LABEL_0,LABEL_0,-1,"argc,argv,t1,t2,c,cnt,buf,offset,count,optind",,,,0,,0,GA,2000,0.8705864667892456,failed,
199,"static void gen_loongson_integer(DisasContext *ctx, uint32_t opc,

                                 int rd, int rs, int rt)

{

    const char *opn = ""loongson"";

    TCGv t0, t1;



    if (rd == 0) {

        /* Treat as NOP. */

        MIPS_DEBUG(""NOP"");

        return;

    }



    switch (opc) {

    case OPC_MULT_G_2E:

    case OPC_MULT_G_2F:

    case OPC_MULTU_G_2E:

    case OPC_MULTU_G_2F:

#if defined(TARGET_MIPS64)

    case OPC_DMULT_G_2E:

    case OPC_DMULT_G_2F:

    case OPC_DMULTU_G_2E:

    case OPC_DMULTU_G_2F:

#endif

        t0 = tcg_temp_new();

        t1 = tcg_temp_new();

        break;

    default:

        t0 = tcg_temp_local_new();

        t1 = tcg_temp_local_new();

        break;

    }



    gen_load_gpr(t0, rs);

    gen_load_gpr(t1, rt);



    switch (opc) {

    case OPC_MULT_G_2E:

    case OPC_MULT_G_2F:

        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);

        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

        opn = ""mult.g"";

        break;

    case OPC_MULTU_G_2E:

    case OPC_MULTU_G_2F:

        tcg_gen_ext32u_tl(t0, t0);

        tcg_gen_ext32u_tl(t1, t1);

        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);

        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

        opn = ""multu.g"";

        break;

    case OPC_DIV_G_2E:

    case OPC_DIV_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_ext32s_tl(t0, t0);

            tcg_gen_ext32s_tl(t1, t1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l3);

            gen_set_label(l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);

            tcg_gen_mov_tl(cpu_gpr[rd], t0);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);

            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

            gen_set_label(l3);

        }

        opn = ""div.g"";

        break;

    case OPC_DIVU_G_2E:

    case OPC_DIVU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_ext32u_tl(t0, t0);

            tcg_gen_ext32u_tl(t1, t1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);

            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

            gen_set_label(l2);

        }

        opn = ""divu.g"";

        break;

    case OPC_MOD_G_2E:

    case OPC_MOD_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_ext32u_tl(t0, t0);

            tcg_gen_ext32u_tl(t1, t1);

            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);

            gen_set_label(l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);

            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

            gen_set_label(l3);

        }

        opn = ""mod.g"";

        break;

    case OPC_MODU_G_2E:

    case OPC_MODU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_ext32u_tl(t0, t0);

            tcg_gen_ext32u_tl(t1, t1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);

            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

            gen_set_label(l2);

        }

        opn = ""modu.g"";

        break;

#if defined(TARGET_MIPS64)

    case OPC_DMULT_G_2E:

    case OPC_DMULT_G_2F:

        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);

        opn = ""dmult.g"";

        break;

    case OPC_DMULTU_G_2E:

    case OPC_DMULTU_G_2F:

        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);

        opn = ""dmultu.g"";

        break;

    case OPC_DDIV_G_2E:

    case OPC_DDIV_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l3);

            gen_set_label(l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);

            tcg_gen_mov_tl(cpu_gpr[rd], t0);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);

            gen_set_label(l3);

        }

        opn = ""ddiv.g"";

        break;

    case OPC_DDIVU_G_2E:

    case OPC_DDIVU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);

            gen_set_label(l2);

        }

        opn = ""ddivu.g"";

        break;

    case OPC_DMOD_G_2E:

    case OPC_DMOD_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            int l3 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);

            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);

            gen_set_label(l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l3);

            gen_set_label(l2);

            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);

            gen_set_label(l3);

        }

        opn = ""dmod.g"";

        break;

    case OPC_DMODU_G_2E:

    case OPC_DMODU_G_2F:

        {

            int l1 = gen_new_label();

            int l2 = gen_new_label();

            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

            tcg_gen_movi_tl(cpu_gpr[rd], 0);

            tcg_gen_br(l2);

            gen_set_label(l1);

            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);

            gen_set_label(l2);

        }

        opn = ""dmodu.g"";

        break;

#endif

    }



    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %s"", opn, regnames[rd], regnames[rs]);

    tcg_temp_free(t0);

    tcg_temp_free(t1);

}
",1222,,LABEL_0,LABEL_0,LABEL_0,-1,"ctx,opc,rd,rs,rt,opn,t0,t1",,,,0,,0,GA,1587,0.8459930658340454,failed,
200,"static void put_payload_header(

                                AVFormatContext *s,

                                ASFStream       *stream,

                                int             presentation_time,

                                int             m_obj_size,

                                int             m_obj_offset,

                                int             payload_len

            )

{

    ASFContext *asf = s->priv_data;

    ByteIOContext *pb = &asf->pb;

    int val;

    

    val = stream->num;

    if (s->streams[val - 1]->codec.coded_frame->key_frame)

        val |= ASF_PL_FLAG_KEY_FRAME;

    put_byte(pb, val);

        

    put_byte(pb, stream->seq);  //Media object number

    put_le32(pb, m_obj_offset); //Offset Into Media Object

         

    // Replicated Data shall be at least 8 bytes long.

    // The first 4 bytes of data shall contain the 

    // Size of the Media Object that the payload belongs to.

    // The next 4 bytes of data shall contain the 

    // Presentation Time for the media object that the payload belongs to.

    put_byte(pb, ASF_PAYLOAD_REPLICATED_DATA_LENGTH);



    put_le32(pb, m_obj_size);       //Replicated Data - Media Object Size

    put_le32(pb, presentation_time);//Replicated Data - Presentation Time

    

    if (asf->multi_payloads_present){

        put_le16(pb, payload_len);   //payload length

    }

}
",222,,LABEL_0,LABEL_0,LABEL_0,-1,"s,stream,presentation_time,m_obj_size,m_obj_offset,payload_len,asf,pb,val",,,,0,,0,GA,1791,0.6924400011698405,failed,
201,"static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc)

{

    AVStream *st;

    OutputStream *ost;

    AVCodecContext *audio_enc;



    ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO);

    st  = ost->st;



    audio_enc = st->codec;

    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;



    if (!ost->stream_copy) {

        char *sample_fmt = NULL;



        MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st);



        MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st);

        if (sample_fmt &&

            (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) {

            av_log(NULL, AV_LOG_FATAL, ""Invalid sample format '%s'\n"", sample_fmt);

            exit_program(1);

        }



        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);

    }



    return ost;

}
",166,,LABEL_1,LABEL_0,,-4,"o,oc,st,ost,audio_enc,sample_fmt",,,,0,,0,Greedy,1,0.0005213777224222819,,
202,"static void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->job);

    assert(bdrv_op_blocker_is_empty(bs));

    assert(!bs->refcnt);

    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    bdrv_close(bs);



    /* remove from list, if necessary */

    bdrv_make_anon(bs);



    g_free(bs);

}
",76,,LABEL_0,LABEL_0,LABEL_0,-1,bs,,,,0,,0,GA,267,0.0946215550104777,failed,
203,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
",92,,LABEL_1,LABEL_1,LABEL_1,-1,"s,pkt,ipmovie,pb,ret",,,,0,,0,GA,1047,0.3746934096018473,failed,
204,"static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)

{

    const QDictEntry *ent;

    const char *arg_name;

    const QObject *arg_obj;

    bool has_exec_key = false;

    QDict *dict = NULL;



    if (qobject_type(request) != QTYPE_QDICT) {

        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,

                   ""request is not a dictionary"");

        return NULL;

    }



    dict = qobject_to_qdict(request);



    for (ent = qdict_first(dict); ent;

         ent = qdict_next(dict, ent)) {

        arg_name = qdict_entry_key(ent);

        arg_obj = qdict_entry_value(ent);



        if (!strcmp(arg_name, ""execute"")) {

            if (qobject_type(arg_obj) != QTYPE_QSTRING) {

                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, ""execute"",

                           ""string"");

                return NULL;

            }

            has_exec_key = true;

        } else if (strcmp(arg_name, ""arguments"")) {

            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);

            return NULL;

        }

    }



    if (!has_exec_key) {

        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, ""execute"");

        return NULL;

    }



    return dict;

}
",196,,LABEL_0,LABEL_1,,-4,"request,errp,ent,arg_name,arg_obj,dict",,,,0,,0,Greedy,1,0.0005510648091634115,,
205,"static void gpollfds_from_select(void)

{

    int fd;

    for (fd = 0; fd <= nfds; fd++) {

        int events = 0;

        if (FD_ISSET(fd, &rfds)) {

            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;

        }

        if (FD_ISSET(fd, &wfds)) {

            events |= G_IO_OUT | G_IO_ERR;

        }

        if (FD_ISSET(fd, &xfds)) {

            events |= G_IO_PRI;

        }

        if (events) {

            GPollFD pfd = {

                .fd = fd,

                .events = events,

            };

            g_array_append_val(gpollfds, pfd);

        }

    }

}
",115,,LABEL_0,LABEL_0,LABEL_0,-1,fd,,,,0,,0,GA,289,0.10591475168863933,failed,
206,"static void qemu_net_queue_append(NetQueue *queue,

                                  NetClientState *sender,

                                  unsigned flags,

                                  const uint8_t *buf,

                                  size_t size,

                                  NetPacketSent *sent_cb)

{

    NetPacket *packet;



    if (queue->nq_count >= queue->nq_maxlen && !sent_cb) {

        return; /* drop if queue full and no callback */

    }

    packet = g_malloc(sizeof(NetPacket) + size);

    packet->sender = sender;

    packet->flags = flags;

    packet->size = size;

    packet->sent_cb = sent_cb;

    memcpy(packet->data, buf, size);




    QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);

}",129,,LABEL_1,LABEL_1,LABEL_1,-1,"queue,sender,flags,buf,size,sent_cb,packet",,,,0,,0,GA,1504,0.5516405900319418,failed,
207,"void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,

                                 bool is_write, bool is_exec, int unused,

                                 unsigned size)

{

    AlphaCPU *cpu = ALPHA_CPU(cs);

    CPUAlphaState *env = &cpu->env;



    env->trap_arg0 = addr;

    env->trap_arg1 = is_write ? 1 : 0;

    dynamic_excp(env, 0, EXCP_MCHK, 0);

}
",73,"void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,

                                 bool is_write, bool is_exec, int unusable,

                                 unsigned size)

{

    AlphaCPU *cpp = ALPHA_CPU(cs);

    CPUAlphaState *env = &cpp->env;



    env->trap_arg0 = addr;

    env->trap_arg1 = is_write ? 1 : 0;

    dynamic_excp(env, 0, EXCP_MCHK, 0);

}
",LABEL_0,LABEL_0,LABEL_1,1,"cs,addr,is_write,is_exec,unused,size,cpu,env",,,,13,"cs:cs,addr:addr,is_write:is_write,is_exec:is_exec,unused:unusable,size:size,cpu:cpp,env:env,",6,GA,292,0.10437163511912027,GA,
208,"static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr)

{

    IRQMP      *irqmp = opaque;

    IRQMPState *state;



    assert(irqmp != NULL);

    state = irqmp->state;

    assert(state != NULL);



    addr &= 0xff;



    /* global registers */

    switch (addr) {

    case LEVEL_OFFSET:

        return state->level;



    case PENDING_OFFSET:

        return state->pending;



    case FORCE0_OFFSET:

        /* This register is an ""alias"" for the force register of CPU 0 */

        return state->force[0];



    case CLEAR_OFFSET:

    case MP_STATUS_OFFSET:

        /* Always read as 0 */

        return 0;



    case BROADCAST_OFFSET:

        return state->broadcast;



    default:

        break;

    }



    /* mask registers */

    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {

        int cpu = (addr - MASK_OFFSET) / 4;

        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);



        return state->mask[cpu];

    }



    /* force registers */

    if (addr >= FORCE_OFFSET && addr < EXTENDED_OFFSET) {

        int cpu = (addr - FORCE_OFFSET) / 4;

        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);



        return state->force[cpu];

    }



    /* extended (not supported) */

    if (addr >= EXTENDED_OFFSET && addr < IRQMP_REG_SIZE) {

        int cpu = (addr - EXTENDED_OFFSET) / 4;

        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);



        return state->extended[cpu];

    }



    trace_grlib_irqmp_unknown_register(""read"", addr);

    return 0;

}
",310,,LABEL_1,LABEL_0,,-4,"opaque,addr,irqmp,state",,,,0,,0,Greedy,1,0.0005999366442362467,,
209,"static void term_handle_byte(int ch)

{

    switch(term_esc_state) {

    case IS_NORM:

        switch(ch) {

        case 1:

            term_bol();

            break;

        case 4:

            term_delete_char();

            break;

        case 5:

            term_eol();

            break;

        case 9:

            term_completion();

            break;

        case 10:

        case 13:

            term_cmd_buf[term_cmd_buf_size] = '\0';

	    term_hist_add(term_cmd_buf);

            term_printf(""\n"");

            term_handle_command(term_cmd_buf);

            term_show_prompt();

            break;

        case 27:

            term_esc_state = IS_ESC;

            break;

        case 127:

        case 8:

            term_backspace();

            break;

	case 155:

            term_esc_state = IS_CSI;

	    break;

        default:

            if (ch >= 32) {

                term_insert_char(ch);

            }

            break;

        }

        break;

    case IS_ESC:

        if (ch == '[') {

            term_esc_state = IS_CSI;

            term_esc_param = 0;

        } else {

            term_esc_state = IS_NORM;

        }

        break;

    case IS_CSI:

        switch(ch) {

	case 'A':

	case 'F':

	    term_up_char();

	    break;

	case 'B':

	case 'E':

	    term_down_char();

	    break;

        case 'D':

            term_backward_char();

            break;

        case 'C':

            term_forward_char();

            break;

        case '0' ... '9':

            term_esc_param = term_esc_param * 10 + (ch - '0');

            goto the_end;

        case '~':

            switch(term_esc_param) {

            case 1:

                term_bol();

                break;

            case 3:

                term_delete_char();

                break;

            case 4:

                term_eol();

                break;

            }

            break;

        default:

            break;

        }

        term_esc_state = IS_NORM;

    the_end:

        break;

    }

    term_update();

}
",299,,LABEL_0,LABEL_0,LABEL_0,-1,ch,,,,0,,0,GA,273,0.1122081200281779,failed,
210,"static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    EEPRO100State *s = opaque;



    switch (size) {

    case 1: return eepro100_read1(s, addr);

    case 2: return eepro100_read2(s, addr);

    case 4: return eepro100_read4(s, addr);

    default: abort();

    }

}
",69,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,addr,size,s",,,,0,,0,GA,845,0.3003600756327311,failed,
211,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height){

    int w_align= 1;

    int h_align= 1;



    switch(s->pix_fmt){

    case PIX_FMT_YUV420P:

    case PIX_FMT_YUYV422:

    case PIX_FMT_UYVY422:

    case PIX_FMT_YUV422P:

    case PIX_FMT_YUV444P:

    case PIX_FMT_GRAY8:

    case PIX_FMT_GRAY16BE:

    case PIX_FMT_GRAY16LE:

    case PIX_FMT_YUVJ420P:

    case PIX_FMT_YUVJ422P:

    case PIX_FMT_YUVJ444P:

    case PIX_FMT_YUVA420P:

        w_align= 16; //FIXME check for non mpeg style codecs and use less alignment

        h_align= 16;



        break;

    case PIX_FMT_YUV411P:

    case PIX_FMT_UYYVYY411:

        w_align=32;

        h_align=8;

        break;

    case PIX_FMT_YUV410P:

        if(s->codec_id == CODEC_ID_SVQ1){

            w_align=64;

            h_align=64;

        }

    case PIX_FMT_RGB555:

        if(s->codec_id == CODEC_ID_RPZA){

            w_align=4;

            h_align=4;

        }

    case PIX_FMT_PAL8:

    case PIX_FMT_BGR8:

    case PIX_FMT_RGB8:

        if(s->codec_id == CODEC_ID_SMC){

            w_align=4;

            h_align=4;

        }

        break;

    case PIX_FMT_BGR24:

        if((s->codec_id == CODEC_ID_MSZH) || (s->codec_id == CODEC_ID_ZLIB)){

            w_align=4;

            h_align=4;

        }

        break;

    default:

        w_align= 1;

        h_align= 1;

        break;

    }



    *width = ALIGN(*width , w_align);

    *height= ALIGN(*height, h_align);

    if(s->codec_id == CODEC_ID_H264)

        *height+=2; // some of the optimized chroma MC reads one line too much

}",280,,LABEL_1,LABEL_1,LABEL_1,-1,"s,height",,,,0,,0,GA,392,0.15418018500010172,failed,
212,"static int get_physical_address(CPUPPCState *env, mmu_ctx_t *ctx,

                                target_ulong eaddr, int rw, int access_type)

{

    int ret;



#if 0

    qemu_log(""%s\n"", __func__);

#endif

    if ((access_type == ACCESS_CODE && msr_ir == 0) ||

        (access_type != ACCESS_CODE && msr_dr == 0)) {

        if (env->mmu_model == POWERPC_MMU_BOOKE) {

            /* The BookE MMU always performs address translation. The

               IS and DS bits only affect the address space.  */

            ret = mmubooke_get_physical_address(env, ctx, eaddr,

                                                rw, access_type);

        } else if (env->mmu_model == POWERPC_MMU_BOOKE206) {

            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,

                                                   access_type);

        } else {

            /* No address translation.  */

            ret = check_physical(env, ctx, eaddr, rw);

        }

    } else {

        ret = -1;

        switch (env->mmu_model) {

        case POWERPC_MMU_32B:

        case POWERPC_MMU_601:

            /* Try to find a BAT */

            if (env->nb_BATs != 0) {

                ret = get_bat(env, ctx, eaddr, rw, access_type);

            }

            if (ret < 0) {

                /* We didn't match any BAT entry or don't have BATs */

                ret = get_segment32(env, ctx, eaddr, rw, access_type);

            }

            break;



        case POWERPC_MMU_SOFT_6xx:

        case POWERPC_MMU_SOFT_74xx:

            /* Try to find a BAT */

            if (env->nb_BATs != 0) {

                ret = get_bat(env, ctx, eaddr, rw, access_type);

            }

            if (ret < 0) {

                /* We didn't match any BAT entry or don't have BATs */

                ret = get_segment_6xx_tlb(env, ctx, eaddr, rw, access_type);

            }

            break;



#if defined(TARGET_PPC64)

        case POWERPC_MMU_64B:

        case POWERPC_MMU_2_06:

        case POWERPC_MMU_2_06d:

            ret = get_segment64(env, ctx, eaddr, rw, access_type);

            break;

#endif



        case POWERPC_MMU_SOFT_4xx:

        case POWERPC_MMU_SOFT_4xx_Z:

            ret = mmu40x_get_physical_address(env, ctx, eaddr,

                                              rw, access_type);

            break;

        case POWERPC_MMU_BOOKE:

            ret = mmubooke_get_physical_address(env, ctx, eaddr,

                                                rw, access_type);

            break;

        case POWERPC_MMU_BOOKE206:

            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,

                                               access_type);

            break;

        case POWERPC_MMU_MPC8xx:

            /* XXX: TODO */

            cpu_abort(env, ""MPC8xx MMU model is not implemented\n"");

            break;

        case POWERPC_MMU_REAL:

            cpu_abort(env, ""PowerPC in real mode do not do any translation\n"");

            return -1;

        default:

            cpu_abort(env, ""Unknown or invalid MMU model\n"");

            return -1;

        }

    }

#if 0

    qemu_log(""%s address "" TARGET_FMT_lx "" => %d "" TARGET_FMT_plx ""\n"",

             __func__, eaddr, ret, ctx->raddr);

#endif



    return ret;

}
",515,"static int get_physical_address(CPUPPCState *env, mmu_ctx_t *sem,

                                target_ulong eaddr, int row, int access_type)

{

    int arr;



#if 0

    qemu_log(""%s
"", __func__);

#endif

    if ((access_type == ACCESS_CODE && msr_ir == 0) ||

        (access_type != ACCESS_CODE && msr_dr == 0)) {

        if (env->mmu_model == POWERPC_MMU_BOOKE) {

            /* The BookE MMU always performs address translation. The

               IS and DS bits only affect the address space.  */

            arr = mmubooke_get_physical_address(env, sem, eaddr,

                                                row, access_type);

        } else if (env->mmu_model == POWERPC_MMU_BOOKE206) {

            rarr= mmubooke206_get_physical_address(env, sem, eaddr, row,

                                                   access_type);

        } else {

            /* No address translation.  */

            rarr= check_physical(env, sem, eaddr, row);

        }

    } else {

        arr = -1;

        switch (env->mmu_model) {

        case POWERPC_MMU_32B:

        case POWERPC_MMU_601:

            /* Try to find a BAT */

            if (env->nb_BATs != 0) {

                rarr= get_bat(env, sem, eaddr, row, access_type);

            }

            if (arr < 0) {

                /* We didn't match any BAT entry or don't have BATs */

                rarr= get_segment32(env, sem, eaddr, row, access_type);

            }

            break;



        case POWERPC_MMU_SOFT_6xx:

        case POWERPC_MMU_SOFT_74xx:

            /* Try to find a BAT */

            if (env->nb_BATs != 0) {

                rarr= get_bat(env, sem, eaddr, row, access_type);

            }

            if (arr < 0) {

                /* We didn't match any BAT entry or don't have BATs */

                rarr= get_segment_6xx_tlb(env, sem, eaddr, row, access_type);

            }

            break;



#if defined(TARGET_PPC64)

        case POWERPC_MMU_64B:

        case POWERPC_MMU_2_06:

        case POWERPC_MMU_2_06d:

            rarr= get_segment64(env, sem, eaddr, row, access_type);

            break;

#endif



        case POWERPC_MMU_SOFT_4xx:

        case POWERPC_MMU_SOFT_4xx_Z:

            arr = mmu40x_get_physical_address(env, sem, eaddr,

                                              row, access_type);

            break;

        case POWERPC_MMU_BOOKE:

            arr = mmubooke_get_physical_address(env, sem, eaddr,

                                                row, access_type);

            break;

        case POWERPC_MMU_BOOKE206:

            rarr= mmubooke206_get_physical_address(env, sem, eaddr, row,

                                               access_type);

            break;

        case POWERPC_MMU_MPC8xx:

            /* XXX: TODO */

            cpu_abort(env, ""MPC8xx MMU model is not implemented
"");

            break;

        case POWERPC_MMU_REAL:

            cpu_abort(env, ""PowerPC in real mode do not do any translation
"");

            return -1;

        default:

            cpu_abort(env, ""Unknown or invalid MMU model
"");

            return -1;

        }

    }

#if 0

    qemu_log(""%s address "" TARGET_FMT_lx "" => %d "" TARGET_FMT_plx ""
"",

             __func__, eaddr, arr, sem->raddr);

#endif



    return arr;

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,ctx,eaddr,rw,access_type,ret",,,,46,"env:env,ctx:sem,eaddr:eaddr,rw:row,access_type:access_type,ret:arr,",3,GA,454,0.1936226487159729,GA,
213,"static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",190,"static void vc1_inv_trans_8x4_dc_c(uint8_t *sort, int linesize, DCTELEM *bc)

{

    int ie;

    int dc = bc[0];

    const uint8_t *cont;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cont = ff_cropTbl + MAX_NEG_CROP + dc;

    for(ie = 0; ie < 4; ie++){

        sort[0] = cont[sort[0]];

        sort[1] = cont[sort[1]];

        sort[2] = cont[sort[2]];

        sort[3] = cont[sort[3]];

        sort[4] = cont[sort[4]];

        sort[5] = cont[sort[5]];

        sort[6] = cont[sort[6]];

        sort[7] = cont[sort[7]];

        sort += linesize;

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"dest,linesize,block,i,cm",,,,2,"dest:sort,linesize:linesize,block:bc,i:ie,cm:cont,",1,GA,301,0.11228154102961223,GA,
214,"unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,

				 unsigned long offset)

{

    const unsigned long *p = addr + BITOP_WORD(offset);

    unsigned long result = offset & ~(BITS_PER_LONG-1);

    unsigned long tmp;



    if (offset >= size) {

        return size;

    }

    size -= result;

    offset %= BITS_PER_LONG;

    if (offset) {

        tmp = *(p++);

        tmp |= ~0UL >> (BITS_PER_LONG - offset);

        if (size < BITS_PER_LONG) {

            goto found_first;

        }

        if (~tmp) {

            goto found_middle;

        }

        size -= BITS_PER_LONG;

        result += BITS_PER_LONG;

    }

    while (size & ~(BITS_PER_LONG-1)) {

        if (~(tmp = *(p++))) {

            goto found_middle;

        }

        result += BITS_PER_LONG;

        size -= BITS_PER_LONG;

    }

    if (!size) {

        return result;

    }

    tmp = *p;



found_first:

    tmp |= ~0UL << size;

    if (tmp == ~0UL) {	/* Are any bits zero? */

        return result + size;	/* Nope. */

    }

found_middle:

    return result + ffz(tmp);

}
",233,"unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long capacity,

				 unsigned long offset)

{

    const unsigned long *sp = addr + BITOP_WORD(offset);

    unsigned long result = offset & ~(BITS_PER_LONG-1);

    unsigned long now;



    if (offsoffsetcapacity) {

        return capacity;

    }

    capacity -= result;

    offset %= BITS_PER_LONG;

    if (offset) {

        tnow= *(sp++);

        now |= ~0UL >> (BITS_PER_LONG - offset);

        if (capacity < BITS_PER_LONG) {

            goto found_first;

        }

        if (~now) {

            goto found_middle;

        }

        capacity -= BITS_PER_LONG;

        result += BITS_PER_LONG;

    }

    while (capacity & ~(BITS_PER_LONG-1)) {

        if (~(tnow= *(sp++))) {

            goto found_middle;

        }

        result += BITS_PER_LONG;

        capacity -= BITS_PER_LONG;

    }

    if (!size) {

        return result;

    }

    tnow= *sp;



found_first:

    tmp now~0UL << capacity;

    if (now == ~0UL) {	/* Are any bits zero? */

        return result + capacity;	/* Nope. */

    }

found_middle:

    return result + ffz(now);

}
",LABEL_1,LABEL_1,LABEL_0,1,"addr,size,offset,p,tmp",,,,9,"addr:addr,size:capacity,offset:offset,p:sp,tmp:now,",2,GA,347,0.13130120833714803,GA,
215,"static const QObject *qmp_input_get_object(QmpInputVisitor *qiv,

                                           const char *name)

{

    const QObject *qobj;



    if (qiv->nb_stack == 0) {

        qobj = qiv->obj;

    } else {

        qobj = qiv->stack[qiv->nb_stack - 1].obj;

    }



    if (name && qobject_type(qobj) == QTYPE_QDICT) {

        return qdict_get(qobject_to_qdict(qobj), name);

    } else if (qiv->nb_stack > 0 && qobject_type(qobj) == QTYPE_QLIST) {

        return qlist_entry_obj(qiv->stack[qiv->nb_stack - 1].entry);

    }



    return qobj;

}
",127,,LABEL_1,LABEL_0,,-4,"qiv,name,qobj",,,,0,,0,Greedy,1,0.0005073785781860351,,
216,"static void do_log(int argc, const char **argv)

{

    int mask;

    

    if (argc != 2)

        goto help;

    if (!strcmp(argv[1], ""none"")) {

        mask = 0;

    } else {

        mask = cpu_str_to_log_mask(argv[1]);

        if (!mask) {

        help:

            help_cmd(argv[0]);

            return;

        }

    }

    cpu_set_log(mask);

}
",82,"static void do_log(int Argsc, const char **argsf)

{

    int pixel;

    

    if (Argsc != 2)

        goto help;

    if (!strcmp(argsf[1], ""none"")) {

        pixel = 0;

    } else {

        mpixel= cpu_str_to_log_mask(argsf[1]);

        if (!mask) {

        help:

            help_cmd(argsf[0]);

            return;

        }

    }

    cpu_set_log(pixel);

}
",LABEL_0,LABEL_0,LABEL_1,1,"argc,argv,mask",,,,0,"argc:Argsc,argv:argsf,mask:pixel,",0,GA,149,0.05350190003712972,GA,
217,"static int h264_decode_frame(AVCodecContext *avctx, void *data,

                             int *got_frame, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size       = avpkt->size;

    H264Context *h     = avctx->priv_data;

    AVFrame *pict      = data;

    int buf_index      = 0;

    int ret;

    const uint8_t *new_extradata;

    int new_extradata_size;



    h->flags = avctx->flags;

    h->setup_finished = 0;



    /* end of stream, output what is still in the buffers */

out:

    if (buf_size == 0) {

        H264Picture *out;

        int i, out_idx;



        h->cur_pic_ptr = NULL;



        // FIXME factorize this with the output code below

        out     = h->delayed_pic[0];

        out_idx = 0;

        for (i = 1;

             h->delayed_pic[i] &&

             !h->delayed_pic[i]->f->key_frame &&

             !h->delayed_pic[i]->mmco_reset;

             i++)

            if (h->delayed_pic[i]->poc < out->poc) {

                out     = h->delayed_pic[i];

                out_idx = i;

            }



        for (i = out_idx; h->delayed_pic[i]; i++)

            h->delayed_pic[i] = h->delayed_pic[i + 1];



        if (out) {

            ret = output_frame(h, pict, out->f);

            if (ret < 0)

                return ret;

            *got_frame = 1;

        }



        return buf_index;

    }



    new_extradata_size = 0;

    new_extradata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,

                                            &new_extradata_size);

    if (new_extradata_size > 0 && new_extradata) {

        ret = ff_h264_decode_extradata(new_extradata, new_extradata_size,

                                       &h->ps, &h->is_avc, &h->nal_length_size,

                                       avctx->err_recognition, avctx);

        if (ret < 0)

            return ret;

    }



    buf_index = decode_nal_units(h, buf, buf_size);

    if (buf_index < 0)

        return AVERROR_INVALIDDATA;



    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {

        buf_size = 0;

        goto out;

    }



    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {

        if (avctx->skip_frame >= AVDISCARD_NONREF)

            return 0;

        av_log(avctx, AV_LOG_ERROR, ""no frame!\n"");

        return AVERROR_INVALIDDATA;

    }



    if (!(avctx->flags2 & AV_CODEC_FLAG2_CHUNKS) ||

        (h->mb_y >= h->mb_height && h->mb_height)) {

        if (avctx->flags2 & AV_CODEC_FLAG2_CHUNKS)

            decode_postinit(h, 1);



        ff_h264_field_end(h, &h->slice_ctx[0], 0);



        *got_frame = 0;

        if (h->next_output_pic && ((avctx->flags & AV_CODEC_FLAG_OUTPUT_CORRUPT) ||

                                   h->next_output_pic->recovered)) {

            if (!h->next_output_pic->recovered)

                h->next_output_pic->f->flags |= AV_FRAME_FLAG_CORRUPT;



            ret = output_frame(h, pict, h->next_output_pic->f);

            if (ret < 0)

                return ret;

            *got_frame = 1;

        }

    }



    assert(pict->buf[0] || !*got_frame);



    return get_consumed_bytes(buf_index, buf_size);

}
",640,,LABEL_0,LABEL_0,LABEL_0,-1,"avctx,data,got_frame,avpkt,buf,h,pict,ret,new_extradata,new_extradata_size,out,i,out_idx",,,,0,,0,GA,2782,1.2648862918217978,failed,
218,"static int add_candidate_ref(HEVCContext *s, RefPicList *list,

                             int poc, int ref_flag)

{

    HEVCFrame *ref = find_ref_idx(s, poc);



    if (ref == s->ref)

        return AVERROR_INVALIDDATA;



    if (!ref) {

        ref = generate_missing_ref(s, poc);

        if (!ref)

            return AVERROR(ENOMEM);

    }



    list->list[list->nb_refs] = ref->poc;

    list->ref[list->nb_refs]  = ref;

    list->nb_refs++;



    mark_ref(ref, ref_flag);

    return 0;

}
",116,,LABEL_1,LABEL_0,,-4,"s,list,poc,ref_flag,ref,nb_refs",,,,0,,0,Greedy,1,0.0004987875620524088,,
219,"static int end_frame(AVFilterLink *inlink)

{

    AVFilterContext    *ctx = inlink->dst;

    FPSContext           *s = ctx->priv;

    AVFilterLink   *outlink = ctx->outputs[0];

    AVFilterBufferRef  *buf = inlink->cur_buf;

    int64_t delta;

    int i, ret;



    inlink->cur_buf = NULL;

    s->frames_in++;

    /* discard frames until we get the first timestamp */

    if (s->pts == AV_NOPTS_VALUE) {

        if (buf->pts != AV_NOPTS_VALUE) {

            write_to_fifo(s->fifo, buf);

            s->first_pts = s->pts = buf->pts;

        } else {

            av_log(ctx, AV_LOG_WARNING, ""Discarding initial frame(s) with no ""

                   ""timestamp.\n"");

            avfilter_unref_buffer(buf);

            s->drop++;

        }

        return 0;

    }



    /* now wait for the next timestamp */

    if (buf->pts == AV_NOPTS_VALUE) {

        return write_to_fifo(s->fifo, buf);

    }



    /* number of output frames */

    delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,

                         outlink->time_base);



    if (delta < 1) {

        /* drop the frame and everything buffered except the first */

        AVFilterBufferRef *tmp;

        int drop = av_fifo_size(s->fifo)/sizeof(AVFilterBufferRef*);



        av_log(ctx, AV_LOG_DEBUG, ""Dropping %d frame(s).\n"", drop);

        s->drop += drop;



        av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);

        flush_fifo(s->fifo);

        ret = write_to_fifo(s->fifo, tmp);



        avfilter_unref_buffer(buf);

        return ret;

    }



    /* can output >= 1 frames */

    for (i = 0; i < delta; i++) {

        AVFilterBufferRef *buf_out;

        av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);



        /* duplicate the frame if needed */

        if (!av_fifo_size(s->fifo) && i < delta - 1) {

            av_log(ctx, AV_LOG_DEBUG, ""Duplicating frame.\n"");

            write_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, AV_PERM_READ));

            s->dup++;

        }



        buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,

                                    outlink->time_base) + s->frames_out;



        if ((ret = ff_start_frame(outlink, buf_out)) < 0 ||

            (ret = ff_draw_slice(outlink, 0, outlink->h, 1)) < 0 ||

            (ret = ff_end_frame(outlink)) < 0) {

            avfilter_unref_bufferp(&buf);

            return ret;

        }



        s->frames_out++;

    }

    flush_fifo(s->fifo);



    ret = write_to_fifo(s->fifo, buf);

    s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);



    return ret;

}
",595,"static int end_frame(AVFilterLink *inlink)

{

    AVFilterContext    *ctx = inlink->dst;

    FPSContext           *s = ctx->priv;

    AVFilterLink   *upline = ctx->outputs[0];

    AVFilterBufferRef  *buf = inlink->cur_buf;

    int64_t delta;

    int i, fi;



    inlink->cur_buf = NULL;

    s->frames_in++;

    /* discard frames until we get the first timestamp */

    if (s->pts == AV_NOPTS_VALUE) {

        if (buf->pts != AV_NOPTS_VALUE) {

            write_to_fifo(s->fifo, buf);

            s->first_pts = s->pts = buf->pts;

        } else {

            av_log(ctx, AV_LOG_WARNING, ""Discarding initial frame(s) with no ""

                   ""timestamp.
"");

            avfilter_unref_buffer(buf);

            s->size++;

        }

        return 0;

    }



    /* now wait for the next timestamp */

    if (buf->pts == AV_NOPTS_VALUE) {

        return write_to_fifo(s->fifo, buf);

    }



    /* number of output frames */

    delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,

                         upline->time_base);



    if (delta < 1) {

        /* size the frame and everything buffered except the first */

        AVFilterBufferRef *tmp;

        int size = av_fifo_size(s->fifo)/sizeof(AVFilterBufferRef*);



        av_log(ctx, AV_LOG_DEBUG, ""Dropping %d frame(s).
"", size);

        s->size += size;



        av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);

        flush_fifo(s->fifo);

        fi = write_to_fifo(s->fifo, tmp);



        avfilter_unref_buffer(buf);

        return fi;

    }



    /* can output >= 1 frames */

    for (i = 0; i < delta; i++) {

        AVFilterBufferRef *buf_out;

        av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);



        /* duplicate the frame if needed */

        if (!av_fifo_size(s->fifo) && i < delta - 1) {

            av_log(ctx, AV_LOG_DEBUG, ""Duplicating frame.
"");

            write_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, AV_PERM_READ));

            s->dup++;

        }



        buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,

                                    upline->time_base) + s->frames_out;



        if (fit = ff_start_frame(upline, buf_out)) < 0 ||

           fiet = ff_draw_slice(upline, 0, upline->h, 1)) < 0 ||

            fit = ff_end_frame(upline)) < 0) {

            avfilter_unref_bufferp(&buf);

            return fi;

        }



        s->frames_out++;

    }

    flush_fifo(s->fifo);



    fi = write_to_fifo(s->fifo, buf);

    s->pts = s->first_pts + av_rescale_q(s->frames_out, upline->time_base, inlink->time_base);



    return fi;

}
",LABEL_0,LABEL_0,LABEL_1,1,"inlink,ctx,s,outlink,buf,delta,i,ret,frames_in,drop,tmp,buf_out",,,,72,"inlink:inlink,ctx:ctx,s:s,outlink:upline,buf:buf,delta:delta,i:i,ret:fi,frames_in:frames_in,drop:size,tmp:tmp,buf_out:buf_out,",9,GA,644,0.2811466693878174,GA,
220,"static void pci_basic(gconstpointer data)

{

    QVirtioPCIDevice *dev;

    QPCIBus *bus;

    QVirtQueuePCI *tx, *rx;

    QGuestAllocator *alloc;

    void (*func) (const QVirtioBus *bus,

                  QVirtioDevice *dev,

                  QGuestAllocator *alloc,

                  QVirtQueue *rvq,

                  QVirtQueue *tvq,

                  int socket) = data;

    int sv[2], ret;



    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);

    g_assert_cmpint(ret, !=, -1);



    bus = pci_test_start(sv[1]);

    dev = virtio_net_pci_init(bus, PCI_SLOT);



    alloc = pc_alloc_init();

    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,

                                           alloc, 0);

    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,

                                           alloc, 1);



    driver_init(&qvirtio_pci, &dev->vdev);

    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);



    /* End test */

    close(sv[0]);

    guest_free(alloc, tx->vq.desc);

    pc_alloc_uninit(alloc);

    qvirtio_pci_device_disable(dev);

    g_free(dev);

    qpci_free_pc(bus);

    test_end();

}
",256,"static void pci_basic(gconstpointer data)

{

    QVirtioPCIDevice *driver;

    QPCIBus *pass;

    QVirtQueuePCI *ta, *rx;

    QGuestAllocator *alloc;

    void (*ffunc (const QVirtioBus *pass,

                  QVirtioDevice *driver,

                  QGuestAllocator *alloc,

                  QVirtQueue *rvq,

                  QVirtQueue *tvq,

                  int src) = data;

    int sv[2], ret;



    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);

    g_assert_cmpint(ret, !=, -1);



    pass = pci_test_start(sv[1]);

    driver = virtio_net_pci_init(pass, PCI_SLOT);



    alloc = pc_alloc_init();

    rx rx(QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &driver->vdev,

                                           alloc, 0);

    tx ta(QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &driver->vdev,

                                           alloc, 1);



    driver_init(&qvirtio_pci, &driver->vdev);

    funfuncvirtio_pci, &driver->vdev, alloc, &rx->vq, &ta->vq, sv[0]);



    /* End test */

    close(sv[0]);

    guest_free(alloc, ta->vq.desc);

    pc_alloc_uninit(alloc);

    qvirtio_pci_device_disable(driver);

    g_free(driver);

    qpci_free_pc(pass);

    test_end();

}
",LABEL_1,LABEL_1,LABEL_0,1,"data,dev,bus,tx,rx,alloc,func,rvq,tvq,socket,sv,ret",,,,25,"data:data,dev:driver,bus:pass,tx:ta,rx:rx,alloc:alloc,func:func,rvq:rvq,tvq:tvq,socket:src,sv:sv,ret:ret,",8,GA,557,0.20910650491714478,GA,
221,"static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)

{

    const struct cow_header_v2 *cow_header = (const void *)buf;



    if (buf_size >= sizeof(struct cow_header_v2) &&

        be32_to_cpu(cow_header->magic) == COW_MAGIC &&

        be32_to_cpu(cow_header->version) == COW_VERSION)

        return 100;

    else

        return 0;

}
",71,,LABEL_0,LABEL_0,LABEL_0,-1,"buf,buf_size,filename,cow_header",,,,0,,0,GA,603,0.21563424269358317,failed,
222,"int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;

    int ret;



    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    ret = bdrv_check_request(bs, sector_num, nb_sectors);

    if (ret < 0) {

        return ret;

    }



    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);

}
",108,,LABEL_0,LABEL_0,LABEL_0,-1,"bs,sector_num,buf,nb_sectors,drv,ret",,,,0,,0,GA,1162,0.4202364762624105,failed,
223,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdevs;

    BusChild *kid;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        num++;

    }



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(qdev) * num);

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdevs[num++] = kid->child;

    }



    /* Sort the array */

    qsort(qdevs, num, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevs);



    return ret;

}
",246,,LABEL_0,LABEL_0,LABEL_0,-1,"bus,fdt,qdev,qdevs,kid,i,num,dev",,,,0,,0,GA,1736,0.6720417499542236,failed,
224,"static av_cold void build_modpred(Indeo3DecodeContext *s)

{

  int i, j;



  s->ModPred = av_malloc(8 * 128);



  for (i=0; i < 128; ++i) {

    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));

    s->ModPred[i+1*128] = i ==   7 ?  20 :

                          i == 119 ||

                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));

    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));

    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));

    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));

    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));

    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));

    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));

  }



  s->corrector_type = av_malloc(24 * 256);



  for (i=0; i < 24; ++i) {

    for (j=0; j < 256; ++j) {

      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :

                                   j < 248 || (i == 16 && j == 248) ? 0 :

                                   corrector_type_2[j - 248];

    }

  }

}
",413,,LABEL_0,LABEL_0,LABEL_0,-1,"s,i,j",,,,0,,0,GA,734,0.29031641880671183,failed,
225,"static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,

        int *need_next_header, int *new_frame_start)

{

    GetBitContext bits;

    AACADTSHeaderInfo hdr;

    int size;

    union {

        uint64_t u64;

        uint8_t  u8[8];

    } tmp;



    tmp.u64 = av_be2ne64(state);

    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);



    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)

        return 0;

    *need_next_header = 0;

    *new_frame_start  = 1;

    hdr_info->sample_rate = hdr.sample_rate;

    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];

    hdr_info->samples     = hdr.samples;

    hdr_info->bit_rate    = hdr.bit_rate;

    return size;

}
",144,,LABEL_1,LABEL_0,,-4,"state,hdr_info,need_next_header,new_frame_start,bits,hdr,size,u8,tmp",,,,0,,0,Greedy,1,0.0005149602890014649,,
226,"void stq_be_phys(target_phys_addr_t addr, uint64_t val)

{

    val = cpu_to_be64(val);

    cpu_physical_memory_write(addr, &val, 8);

}
",30,,LABEL_0,LABEL_0,LABEL_0,-1,"addr,val",,,,0,,0,GA,470,0.16435718139012653,failed,
227,"static void gen_movl_seg_T0(DisasContext *s, int seg_reg)

{

    if (s->pe && !s->vm86) {

        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);

        /* abort translation because the addseg value may change or

           because ss32 may change. For R_SS, translation must always

           stop as a special handling must be done to disable hardware

           interrupts for the next instruction */

        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))

            s->is_jmp = DISAS_TB_JUMP;

    } else {

        gen_op_movl_seg_T0_vm(seg_reg);

        if (seg_reg == R_SS)

            s->is_jmp = DISAS_TB_JUMP;

    }

}
",131,,LABEL_0,LABEL_0,LABEL_0,-1,"s,seg_reg",,,,0,,0,GA,472,0.17363982597986857,failed,
228,"static int standard_decode_i_mbs(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    MpegEncContext *s = &v->s;

    int current_mb = 0; /* MB/Block Position info */

    uint8_t cbpcy[4], previous_cbpcy[4], predicted_cbpcy,

        *p_cbpcy /* Pointer to skip some math */;



    /* Reset CBPCY predictors */

    memset(v->previous_line_cbpcy, 0, s->mb_stride<<2);



    /* Select ttmb table depending on pq */

    if (v->pq < 5) v->ttmb_vlc = &vc9_ttmb_vlc[0];

    else if (v->pq < 13) v->ttmb_vlc = &vc9_ttmb_vlc[1];

    else v->ttmb_vlc = &vc9_ttmb_vlc[2];



    for (s->mb_y=0; s->mb_y<s->mb_height; s->mb_y++)

    {

        /* Init CBPCY for line */

        *((uint32_t*)previous_cbpcy) = 0x00000000;

        p_cbpcy = v->previous_line_cbpcy+4;



        for (s->mb_x=0; s->mb_x<s->mb_width; s->mb_x++, p_cbpcy += 4)

        {

            /* Get CBPCY */

            GET_CBPCY(ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS);



            s->ac_pred = get_bits(gb, 1);



            /* TODO: Decode blocks from that mb wrt cbpcy */



            /* Update for next block */

#if TRACE > 2

            av_log(s->avctx, AV_LOG_DEBUG, ""Block %4i: p_cbpcy=%i%i%i%i, previous_cbpcy=%i%i%i%i,""

                   "" cbpcy=%i%i%i%i\n"", current_mb,

                   p_cbpcy[0], p_cbpcy[1], p_cbpcy[2], p_cbpcy[3],

                   previous_cbpcy[0], previous_cbpcy[1], previous_cbpcy[2], previous_cbpcy[3],

                   cbpcy[0], cbpcy[1], cbpcy[2], cbpcy[3]);

#endif

            *((uint32_t*)p_cbpcy) = *((uint32_t*)previous_cbpcy);

            *((uint32_t*)previous_cbpcy) = *((uint32_t*)cbpcy);

            current_mb++;

        }

    }

    return 0;

}
",423,,LABEL_1,LABEL_0,,-4,"v,gb,s,cbpcy,previous_cbpcy,predicted_cbpcy,p_cbpcy,mb_y,mb_x,current_mb",,,,0,,0,Greedy,1,0.0006703694661458333,,
229,"static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,

                            const uint32_t *quant) {

    int coeff, i, n;

    int8_t ac;

    uint8_t dc = get_bits(gb, 8);



    // block not coded

    if (dc == 255)




    // number of non-zero coefficients

    coeff = get_bits(gb, 6);

    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)




    // normally we would only need to clear the (63 - coeff) last values,

    // but since we do not know where they are we just clear the whole block

    memset(block, 0, 64 * sizeof(DCTELEM));



    // 2 bits per coefficient

    while (coeff) {

        ac = get_sbits(gb, 2);

        if (ac == -2)

            break; // continue with more bits

        PUT_COEFF(ac);

    }



    // 4 bits per coefficient

    ALIGN(4);



    while (coeff) {

        ac = get_sbits(gb, 4);

        if (ac == -8)

            break; // continue with more bits

        PUT_COEFF(ac);

    }



    // 8 bits per coefficient

    ALIGN(8);

    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)


    while (coeff) {

        ac = get_sbits(gb, 8);

        PUT_COEFF(ac);

    }



    PUT_COEFF(dc);

    return 1;

}",275,,LABEL_1,LABEL_1,LABEL_1,-1,"gb,block,scan,quant,coeff,i,n,ac",,,,0,,0,GA,1593,0.6171654621760051,failed,
230,"void *memory_region_get_ram_ptr(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;

    }



    assert(mr->terminates);



    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);

}
",54,"void *memory_region_get_ram_ptr(MemoryRegion *mn)

{

    if (mn->alias) {

        return memory_region_get_ram_ptr(mn->alias) + mn->alias_offset;

    }



    assert(mn->terminates);



    return qemu_get_ram_ptr(mn->ram_addr & TARGET_PAGE_MASK);

}
",LABEL_0,LABEL_0,LABEL_1,1,mr,,,,0,"mr:mn,",0,GA,159,0.05603819290796916,GA,
231,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",152,,LABEL_1,LABEL_0,,-4,"s,bin,st",,,,0,,0,Greedy,1,0.0005111853281656901,,
232,"static int alloc_refcount_block(BlockDriverState *bs,

    int64_t cluster_index, uint16_t **refcount_block)

{

    BDRVQcowState *s = bs->opaque;

    unsigned int refcount_table_index;

    int ret;



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);



    /* Find the refcount block for the given cluster */

    refcount_table_index = cluster_index >> s->refcount_block_bits;



    if (refcount_table_index < s->refcount_table_size) {



        uint64_t refcount_block_offset =

            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;



        /* If it's already there, we're done */

        if (refcount_block_offset) {

            if (offset_into_cluster(s, refcount_block_offset)) {

                qcow2_signal_corruption(bs, true, -1, -1, ""Refblock offset %#""

                                        PRIx64 "" unaligned (reftable index: ""

                                        ""%#x)"", refcount_block_offset,

                                        refcount_table_index);

                return -EIO;

            }



             return load_refcount_block(bs, refcount_block_offset,

                 (void**) refcount_block);

        }

    }



    /*

     * If we came here, we need to allocate something. Something is at least

     * a cluster for the new refcount block. It may also include a new refcount

     * table if the old refcount table is too small.

     *

     * Note that allocating clusters here needs some special care:

     *

     * - We can't use the normal qcow2_alloc_clusters(), it would try to

     *   increase the refcount and very likely we would end up with an endless

     *   recursion. Instead we must place the refcount blocks in a way that

     *   they can describe them themselves.

     *

     * - We need to consider that at this point we are inside update_refcounts

     *   and potentially doing an initial refcount increase. This means that

     *   some clusters have already been allocated by the caller, but their

     *   refcount isn't accurate yet. If we allocate clusters for metadata, we

     *   need to return -EAGAIN to signal the caller that it needs to restart

     *   the search for free clusters.

     *

     * - alloc_clusters_noref and qcow2_free_clusters may load a different

     *   refcount block into the cache

     */



    *refcount_block = NULL;



    /* We write to the refcount table, so we might depend on L2 tables */

    ret = qcow2_cache_flush(bs, s->l2_table_cache);

    if (ret < 0) {

        return ret;

    }



    /* Allocate the refcount block itself and mark it as used */

    int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);

    if (new_block < 0) {

        return new_block;

    }



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Allocate refcount block %d for %"" PRIx64

        "" at %"" PRIx64 ""\n"",

        refcount_table_index, cluster_index << s->cluster_bits, new_block);

#endif



    if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) {

        /* Zero the new refcount block before updating it */

        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, s->cluster_size);



        /* The block describes itself, need to update the cache */

        int block_index = (new_block >> s->cluster_bits) &

            (s->refcount_block_size - 1);

        (*refcount_block)[block_index] = cpu_to_be16(1);

    } else {

        /* Described somewhere else. This can recurse at most twice before we

         * arrive at a block that describes itself. */

        ret = update_refcount(bs, new_block, s->cluster_size, 1, false,

                              QCOW2_DISCARD_NEVER);

        if (ret < 0) {

            goto fail_block;

        }



        ret = qcow2_cache_flush(bs, s->refcount_block_cache);

        if (ret < 0) {

            goto fail_block;

        }



        /* Initialize the new refcount block only after updating its refcount,

         * update_refcount uses the refcount cache itself */

        ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block,

            (void**) refcount_block);

        if (ret < 0) {

            goto fail_block;

        }



        memset(*refcount_block, 0, s->cluster_size);

    }



    /* Now the new refcount block needs to be written to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE);

    qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block);

    ret = qcow2_cache_flush(bs, s->refcount_block_cache);

    if (ret < 0) {

        goto fail_block;

    }



    /* If the refcount table is big enough, just hook the block up there */

    if (refcount_table_index < s->refcount_table_size) {

        uint64_t data64 = cpu_to_be64(new_block);

        BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP);

        ret = bdrv_pwrite_sync(bs->file,

            s->refcount_table_offset + refcount_table_index * sizeof(uint64_t),

            &data64, sizeof(data64));

        if (ret < 0) {

            goto fail_block;

        }



        s->refcount_table[refcount_table_index] = new_block;



        /* The new refcount block may be where the caller intended to put its

         * data, so let it restart the search. */

        return -EAGAIN;

    }



    ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);

    if (ret < 0) {

        goto fail_block;

    }



    /*

     * If we come here, we need to grow the refcount table. Again, a new

     * refcount table needs some space and we can't simply allocate to avoid

     * endless recursion.

     *

     * Therefore let's grab new refcount blocks at the end of the image, which

     * will describe themselves and the new refcount table. This way we can

     * reference them only in the new table and do the switch to the new

     * refcount table at once without producing an inconsistent state in

     * between.

     */

    BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW);



    /* Calculate the number of refcount blocks needed so far */

    uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size);



    if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) {

        return -EFBIG;

    }



    /* And now we need at least one block more for the new metadata */

    uint64_t table_size = next_refcount_table_size(s, blocks_used + 1);

    uint64_t last_table_size;

    uint64_t blocks_clusters;

    do {

        uint64_t table_clusters =

            size_to_clusters(s, table_size * sizeof(uint64_t));

        blocks_clusters = 1 +

            ((table_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size);

        uint64_t meta_clusters = table_clusters + blocks_clusters;



        last_table_size = table_size;

        table_size = next_refcount_table_size(s, blocks_used +

            ((meta_clusters + s->refcount_block_size - 1)

            / s->refcount_block_size));



    } while (last_table_size != table_size);



#ifdef DEBUG_ALLOC2

    fprintf(stderr, ""qcow2: Grow refcount table %"" PRId32 "" => %"" PRId64 ""\n"",

        s->refcount_table_size, table_size);

#endif



    /* Create the new refcount table and blocks */

    uint64_t meta_offset = (blocks_used * s->refcount_block_size) *

        s->cluster_size;

    uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size;

    uint64_t *new_table = g_try_new0(uint64_t, table_size);

    uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size);



    assert(table_size > 0 && blocks_clusters > 0);

    if (new_table == NULL || new_blocks == NULL) {

        ret = -ENOMEM;

        goto fail_table;

    }



    /* Fill the new refcount table */

    memcpy(new_table, s->refcount_table,

        s->refcount_table_size * sizeof(uint64_t));

    new_table[refcount_table_index] = new_block;



    int i;

    for (i = 0; i < blocks_clusters; i++) {

        new_table[blocks_used + i] = meta_offset + (i * s->cluster_size);

    }



    /* Fill the refcount blocks */

    uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t));

    int block = 0;

    for (i = 0; i < table_clusters + blocks_clusters; i++) {

        new_blocks[block++] = cpu_to_be16(1);

    }



    /* Write refcount blocks to disk */

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS);

    ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks,

        blocks_clusters * s->cluster_size);

    g_free(new_blocks);

    new_blocks = NULL;

    if (ret < 0) {

        goto fail_table;

    }



    /* Write refcount table to disk */

    for(i = 0; i < table_size; i++) {

        cpu_to_be64s(&new_table[i]);

    }



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE);

    ret = bdrv_pwrite_sync(bs->file, table_offset, new_table,

        table_size * sizeof(uint64_t));

    if (ret < 0) {

        goto fail_table;

    }



    for(i = 0; i < table_size; i++) {

        be64_to_cpus(&new_table[i]);

    }



    /* Hook up the new refcount table in the qcow2 header */

    uint8_t data[12];

    cpu_to_be64w((uint64_t*)data, table_offset);

    cpu_to_be32w((uint32_t*)(data + 8), table_clusters);

    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);

    ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),

        data, sizeof(data));

    if (ret < 0) {

        goto fail_table;

    }



    /* And switch it in memory */

    uint64_t old_table_offset = s->refcount_table_offset;

    uint64_t old_table_size = s->refcount_table_size;



    g_free(s->refcount_table);

    s->refcount_table = new_table;

    s->refcount_table_size = table_size;

    s->refcount_table_offset = table_offset;



    /* Free old table. */

    qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),

                        QCOW2_DISCARD_OTHER);



    ret = load_refcount_block(bs, new_block, (void**) refcount_block);

    if (ret < 0) {

        return ret;

    }



    /* If we were trying to do the initial refcount update for some cluster

     * allocation, we might have used the same clusters to store newly

     * allocated metadata. Make the caller search some new space. */

    return -EAGAIN;



fail_table:

    g_free(new_blocks);

    g_free(new_table);

fail_block:

    if (*refcount_block != NULL) {

        qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block);

    }

    return ret;

}
",1922,,LABEL_1,LABEL_0,,-4,"bs,cluster_index,refcount_block,s,refcount_table_index,ret",,,,0,,0,Greedy,1,0.001613306999206543,,
233,"static inline bool handler_is_async(const mon_cmd_t *cmd)

{

    return cmd->flags & MONITOR_CMD_ASYNC;

}
",19,"static inline bool handler_is_async(const mon_cmd_t *cp)

{

    return cp->flags & MONITOR_CMD_ASYNC;

}
",LABEL_1,LABEL_1,LABEL_0,1,cmd,,,,0,"cmd:cp,",0,GA,72,0.025235235691070557,GA,
234,"static int process_input_packet(InputStream *ist, const AVPacket *pkt)

{

    int i;

    int got_output;

    AVPacket avpkt;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if (pkt->dts != AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {

        int ret = 0;

    handle_eof:



        ist->last_dts = ist->next_dts;



        if (avpkt.size && avpkt.size != pkt->size &&

            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,

                   ""Multiple frames in a packet from stream %d\n"", pkt->stream_index);

            ist->showed_multi_packet_warning = 1;

        }



        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ret = decode_audio    (ist, &avpkt, &got_output);

            break;

        case AVMEDIA_TYPE_VIDEO:

            ret = decode_video    (ist, &avpkt, &got_output);

            if (avpkt.duration)

                ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);

            else if (ist->st->avg_frame_rate.num)

                ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate),

                                              AV_TIME_BASE_Q);

            else if (ist->dec_ctx->time_base.num != 0) {

                int ticks      = ist->st->parser ? ist->st->parser->repeat_pict + 1 :

                                                   ist->dec_ctx->ticks_per_frame;

                ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q);

            }

            break;

        case AVMEDIA_TYPE_SUBTITLE:

            ret = transcode_subtitles(ist, &avpkt, &got_output);

            break;

        default:

            return -1;

        }



        if (ret < 0)

            return ret;

        // touch data and size only if not EOF

        if (pkt) {

            avpkt.data += ret;

            avpkt.size -= ret;

        }

        if (!got_output) {

            continue;

        }

    }



    /* handle stream copy */

    if (!ist->decoding_needed) {

        ist->last_dts = ist->next_dts;

        switch (ist->dec_ctx->codec_type) {

        case AVMEDIA_TYPE_AUDIO:

            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /

                             ist->dec_ctx->sample_rate;

            break;

        case AVMEDIA_TYPE_VIDEO:

            if (ist->dec_ctx->time_base.num != 0) {

                int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame;

                ist->next_dts += ((int64_t)AV_TIME_BASE *

                                  ist->dec_ctx->time_base.num * ticks) /

                                  ist->dec_ctx->time_base.den;

            }

            break;

        }

    }

    for (i = 0; pkt && i < nb_output_streams; i++) {

        OutputStream *ost = output_streams[i];



        if (!check_output_constraints(ist, ost) || ost->encoding_needed)

            continue;



        do_streamcopy(ist, ost, pkt);

    }



    return 0;

}
",716,,LABEL_0,LABEL_0,LABEL_0,-1,"ist,pkt,i,got_output,avpkt",,,,0,,0,GA,1220,0.5708410302797954,failed,
235,"static void end_last_frame(AVFilterContext *ctx)

{

    TileContext *tile    = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    AVFilterBufferRef *out_buf = outlink->out_buf;



    outlink->out_buf = NULL;

    ff_start_frame(outlink, out_buf);

    while (tile->current < tile->nb_frames)

        draw_blank_frame(ctx, out_buf);

    ff_draw_slice(outlink, 0, out_buf->video->h, 1);

    ff_end_frame(outlink);

    tile->current = 0;

}
",102,"static void end_last_frame(AVFilterContext *c)

{

    TileContexttaskle    = c->priv;

    AVFilterLinkoutlinknk = c->outputs[0];

    AVFilterBufferRef *out_queue = outlink->out_queue;



    outlink->out_queue = NULL;

    ff_start_frame(outlink, out_queue);

    while (task->current < task->nb_frames)

        draw_blank_frame(c, out_queue);

    ff_draw_slice(outlink, 0, out_queue->video->h, 1);

    ff_end_frame(outlink);

    task->current = 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"ctx,tile,outlink,out_buf",,,,6,"ctx:c,tile:task,outlink:outlink,out_buf:out_queue,",1,GA,305,0.10817771355311076,GA,
236,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
",90,"static void raven_class_init(ObjectClass * kcl, void *i)

{

    PCIDeviceClass kik = PCI_DEVICE_CLASS( kcl);

    DeviceClass dcc = DEVICE_CLASS( kcl);



    ki->init = raven_init;

    ki->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    ki->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    ki->revision = 0x00;

    ki->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
",LABEL_1,LABEL_1,LABEL_0,1,"klass,data,k,dc",,,,4,"klass: kcl,data:i,k:ki,dc:dc,",1,GA,167,0.05994896491368611,GA,
237,"static inline void h264_deblock_q1(register vector unsigned char p0,

                                                   register vector unsigned char p1,

                                                   register vector unsigned char p2,

                                                   register vector unsigned char q0,

                                                   register vector unsigned char tc0) {



    register vector unsigned char average = vec_avg(p0, q0);

    register vector unsigned char temp;

    register vector unsigned char uncliped;

    register vector unsigned char ones;

    register vector unsigned char max;

    register vector unsigned char min;



    temp = vec_xor(average, p2);

    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */

    ones = vec_splat_u8(1);

    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */

    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */

    max = vec_adds(p1, tc0);

    min = vec_subs(p1, tc0);

    p1 = vec_max(min, uncliped);

    p1 = vec_min(max, p1);

}
",212,"static inline void h264_deblock_q1(register vector unsigned char c0,

                                                   register vector unsigned char p1,

                                                   register vector unsigned char p2,

                                                   register vector unsigned char q0,

                                                   register vector unsigned char tc0) {



    register vector unsigned char average = vec_avg(c0, q0);

    register vector unsigned char test;

    register vector unsigned char unincliped;

    register vector unsigned char blocks;

    register vector unsigned char w;

    register vector unsigned char ps;



    test = vec_xor(average, p2);

    average = vec_avg(average, p2);     /*avg(p2, avg(c0, q0)) */

    blocks = vec_splat_u8(1);

    test = vec_and(test, blocks);         /*(p2^avg(c0, q0)) & 1 */

    unincliped = vec_subs(average, test); /*(p2+((c0+q0+1)>>1))>>1 */

    w = vec_adds(p1, tc0);

    ps = vec_subs(p1, tc0);

    p1 = vec_max(mipsunincliped);

    p1 = vec_min(w, p1);

}
",LABEL_0,LABEL_0,LABEL_1,1,"p0,temp,uncliped,ones,max,min",,,,0,"p0:c0,temp:test,uncliped:unincliped,ones:blocks,max:w,min:ps,",0,GA,537,0.1993608792622884,GA,
238,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    float aspect;



    init_get_bits(&s->gb, buf, buf_size);



    width = get_bits(&s->gb, 12);

    height = get_bits(&s->gb, 12);

    s->aspect_ratio_info= get_bits(&s->gb, 4);

    if(!s->mpeg2){

        aspect= mpeg1_aspect[s->aspect_ratio_info];

        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);

    }



    s->frame_rate_index = get_bits(&s->gb, 4);

    if (s->frame_rate_index == 0)

        return -1;

    s->bit_rate = get_bits(&s->gb, 18) * 400;

    if (get_bits1(&s->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != s->width ||

        height != s->height) {

        /* start new mpeg1 context decoding */

        s->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(s);

        }

        s->width = width;

        s->height = height;

        avctx->has_b_frames= 1;

        s->avctx = avctx;

        avctx->width = width;

        avctx->height = height;

        if (s->frame_rate_index >= 9) {

            /* at least give a valid frame rate (some old mpeg1 have this) */

            avctx->frame_rate = 25 * FRAME_RATE_BASE;

        } else {

            avctx->frame_rate = frame_rate_tab[s->frame_rate_index];

        }

        s->frame_rate = avctx->frame_rate;

        avctx->bit_rate = s->bit_rate;

        

        if (MPV_common_init(s) < 0)

            return -1;

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&s->gb, 10); /* vbv_buffer_size */

    skip_bits(&s->gb, 1);



    /* get matrix */

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->intra_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_intra_matrix[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

    }

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = s->intra_scantable.permutated[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->inter_matrix[s->intra_scantable.permutated[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            int j= s->idct_permutation[i];

            v = ff_mpeg1_default_non_intra_matrix[i];

            s->inter_matrix[j] = v;

            s->chroma_inter_matrix[j] = v;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    s->progressive_sequence = 1;

    s->progressive_frame = 1;

    s->picture_structure = PICT_FRAME;

    s->frame_pred_frame_dct = 1;

    s->mpeg2 = 0;

    avctx->sub_id = 1; /* indicates mpeg1 */

    return 0;

}
",886,,LABEL_0,LABEL_1,,-4,"avctx,buf,buf_size,s1,s,height,i,v,j,aspect",,,,0,,0,Greedy,1,0.0009402712186177572,,
239,"static void external_snapshot_commit(BlkActionState *common)

{

    ExternalSnapshotState *state =

                             DO_UPCAST(ExternalSnapshotState, common, common);



    bdrv_set_aio_context(state->new_bs, state->aio_context);



    /* This removes our old bs and adds the new bs */

    bdrv_append(state->new_bs, state->old_bs);

    /* We don't need (or want) to use the transactional

     * bdrv_reopen_multiple() across all the entries at once, because we

     * don't want to abort all of them if one of them fails the reopen */

    bdrv_reopen(state->old_bs, state->old_bs->open_flags & ~BDRV_O_RDWR,

                NULL);

}
",131,,LABEL_1,LABEL_0,,-4,"common,state",,,,0,,0,Greedy,1,0.0004895289738972981,,
240,"static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,

                           struct dirent *entry,

                           struct dirent **result)

{

    return readdir_r(fs->dir, entry, result);

}
",37,"static int local_readdir_r(FsContext *cm, V9fsFidOpenState *rs,

                           struct dirent *row,

                           struct dirent **result)

{

    return readdir_r(rs->dir, row, result);

}
",LABEL_0,LABEL_0,LABEL_1,1,"ctx,fs,entry,result",,,,2,"ctx:cm,fs:rs,entry:row,result:result,",1,GA,164,0.05764470895131429,GA,
241,"static int aiff_read_packet(AVFormatContext *s,
                            AVPacket *pkt)
{
    AVStream *st = s->streams[0];
    AIFFInputContext *aiff = s->priv_data;
    int64_t max_size;
    int res, size;
    /* calculate size of remaining data */
    max_size = aiff->data_end - avio_tell(s->pb);
    if (max_size <= 0)
        return AVERROR_EOF;
    /* Now for that packet */
    switch (st->codecpar->codec_id) {
    case AV_CODEC_ID_ADPCM_IMA_QT:
    case AV_CODEC_ID_GSM:
    case AV_CODEC_ID_QDM2:
    case AV_CODEC_ID_QCELP:
        size = st->codecpar->block_align;
        break;
    default:
        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;
    size = FFMIN(max_size, size);
    res = av_get_packet(s->pb, pkt, size);
    if (res < 0)
        return res;
    if (size >= st->codecpar->block_align)
        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;
    /* Only one stream in an AIFF file */
    pkt->stream_index = 0;
    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;
    return 0;",249,,LABEL_1,LABEL_1,LABEL_1,-1,"s,pkt,st,aiff,max_size,res,size",,,,0,,0,GA,1495,0.5721419175465902,failed,
242,"static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm)

{

    fadt->model = 1;

    fadt->reserved1 = 0;

    fadt->sci_int = cpu_to_le16(pm->sci_int);

    fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);

    fadt->acpi_enable = pm->acpi_enable_cmd;

    fadt->acpi_disable = pm->acpi_disable_cmd;

    /* EVT, CNT, TMR offset matches hw/acpi/core.c */

    fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);

    fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);

    fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);

    fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);

    /* EVT, CNT, TMR length matches hw/acpi/core.c */

    fadt->pm1_evt_len = 4;

    fadt->pm1_cnt_len = 2;

    fadt->pm_tmr_len = 4;

    fadt->gpe0_blk_len = pm->gpe0_blk_len;

    fadt->plvl2_lat = cpu_to_le16(0xfff); /* C2 state not supported */

    fadt->plvl3_lat = cpu_to_le16(0xfff); /* C3 state not supported */

    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |

                              (1 << ACPI_FADT_F_PROC_C1) |

                              (1 << ACPI_FADT_F_SLP_BUTTON) |

                              (1 << ACPI_FADT_F_RTC_S4));

    fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_USE_PLATFORM_CLOCK);

    /* APIC destination mode (""Flat Logical"") has an upper limit of 8 CPUs

     * For more than 8 CPUs, ""Clustered Logical"" mode has to be used

     */

    if (max_cpus > 8) {

        fadt->flags |= cpu_to_le32(1 << ACPI_FADT_F_FORCE_APIC_CLUSTER_MODEL);

    }

    fadt->century = RTC_CENTURY;

}
",333,,LABEL_0,LABEL_0,LABEL_0,-1,"fadt,pm",,,,0,,0,GA,760,0.2937431891759237,failed,
243,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)

{

    *q_ptr = num / den;

    return num % den;

}
",28,"uint32_t div32(uint32_t *p_pointer, uint64_t num, uint32_t su)

{

    *p_pointer = num / su;

    return num % su;

}
",LABEL_1,LABEL_1,LABEL_0,1,"q_ptr,num,den",,,,3,"q_ptr:p_pointer,num:num,den:su,",1,GA,140,0.049141077200571696,GA,
244,"static int mch_init(PCIDevice *d)

{

    int i;

    MCHPCIState *mch = MCH_PCI_DEVICE(d);



    /* setup pci memory regions */

    memory_region_init_alias(&mch->pci_hole, OBJECT(mch), ""pci-hole"",

                             mch->pci_address_space,

                             mch->below_4g_mem_size,

                             0x100000000ULL - mch->below_4g_mem_size);

    memory_region_add_subregion(mch->system_memory, mch->below_4g_mem_size,

                                &mch->pci_hole);



    pc_init_pci64_hole(&mch->pci_info, 0x100000000ULL + mch->above_4g_mem_size,

                       mch->pci_hole64_size);

    memory_region_init_alias(&mch->pci_hole_64bit, OBJECT(mch), ""pci-hole64"",

                             mch->pci_address_space,

                             mch->pci_info.w64.begin,

                             mch->pci_hole64_size);

    if (mch->pci_hole64_size) {

        memory_region_add_subregion(mch->system_memory,

                                    mch->pci_info.w64.begin,

                                    &mch->pci_hole_64bit);

    }

    /* smram */

    cpu_smm_register(&mch_set_smm, mch);

    memory_region_init_alias(&mch->smram_region, OBJECT(mch), ""smram-region"",

                             mch->pci_address_space, 0xa0000, 0x20000);

    memory_region_add_subregion_overlap(mch->system_memory, 0xa0000,

                                        &mch->smram_region, 1);

    memory_region_set_enabled(&mch->smram_region, false);

    init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,

             &mch->pam_regions[0], PAM_BIOS_BASE, PAM_BIOS_SIZE);

    for (i = 0; i < 12; ++i) {

        init_pam(DEVICE(mch), mch->ram_memory, mch->system_memory, mch->pci_address_space,

                 &mch->pam_regions[i+1], PAM_EXPAN_BASE + i * PAM_EXPAN_SIZE,

                 PAM_EXPAN_SIZE);

    }

    return 0;

}
",337,,LABEL_0,LABEL_1,,-4,"d,i,mch",,,,0,,0,Greedy,1,0.0006239414215087891,,
245,"static void simple_number(void)

{

    int i;

    struct {

        const char *encoded;

        int64_t decoded;

        int skip;

    } test_cases[] = {

        { ""0"", 0 },

        { ""1234"", 1234 },

        { ""1"", 1 },

        { ""-32"", -32 },

        { ""-0"", 0, .skip = 1 },

        { },

    };



    for (i = 0; test_cases[i].encoded; i++) {

        QInt *qint;



        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));

        g_assert(qint);

        g_assert(qint_get_int(qint) == test_cases[i].decoded);

        if (test_cases[i].skip == 0) {

            QString *str;



            str = qobject_to_json(QOBJECT(qint));

            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);

            QDECREF(str);

        }



        QDECREF(qint);

    }

}
",188,"static void simple_number(void)

{

    int i;

    struct {

        const char *decoded;

        int64_t decoded;

        int skip;

    } testingstimes[] = {

        { ""0"", 0 },

        { ""1234"", 1234 },

        { ""1"", 1 },

        { ""-32"", -32 },

        { ""-0"", 0, .skip = 1 },

        { },

    };



    for (i = 0; testingstimes[i].decoded; i++) {

        QInt *qqx;



        qinqqxqobject_to_qint(qobject_from_json(testingstimes[i].decoded, NULL));

        g_assert(qqx);

        g_assert(qint_get_int(qinqqx= testingstimes[i].decoded);

        if (testingstimes[i].skip == 0) {

            QString *str;



           strr = qobject_to_json(QOBJECT(qqx));

            g_assert(strcmp(qstring_get_str(strstrtestingstimes[i].decoded) == 0);

            QDECREF(str);

        }



        QDECREF(qqx);

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"i,encoded,test_cases,qint,str",,,,12,"i:i,encoded:decoded,test_cases:testingstimes,qint:qqx,str:str,",2,GA,318,0.11836512088775634,GA,
246,"static void init_virtio_dev(TestServer *s)

{

    QPCIBus *bus;

    QVirtioPCIDevice *dev;

    uint32_t features;



    bus = qpci_init_pc(NULL);

    g_assert_nonnull(bus);



    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);

    g_assert_nonnull(dev);



    qvirtio_pci_device_enable(dev);

    qvirtio_reset(&dev->vdev);

    qvirtio_set_acknowledge(&dev->vdev);

    qvirtio_set_driver(&dev->vdev);



    features = qvirtio_get_features(&dev->vdev);

    features = features & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&dev->vdev, features);



    qvirtio_set_driver_ok(&dev->vdev);

}
",117,"static void init_virtio_dev(TestServer *src)

{

    QPCIBus *Bus;

    QVirtioPCIDevice *serv;

    uint32_t features;



    Bus = qpci_init_pc(NULL);

    g_assert_nonnull(Bus);



    serv = qvirtio_pci_device_find(Bus, VIRTIO_ID_NET);

    g_assert_nonnull(serv);



    qvirtio_pci_device_enable(serv);

    qvirtio_reset(&serv->vdev);

    qvirtio_set_acknowledge(&serv->vdev);

    qvirtio_set_driver(&serv->vdev);



    ffeatures= qvirtio_get_features(&serv->vdev);

    features = features & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&serv->vdev, features);



    qvirtio_set_driver_ok(&serv->vdev);

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,bus,dev,features",,,,5,"s:src,bus:Bus,dev:serv,features:features,",1,GA,230,0.08313769102096558,GA,
247,"static bool do_modify_softint(CPUSPARCState *env, uint32_t value)

{

    if (env->softint != value) {

        env->softint = value;

#if !defined(CONFIG_USER_ONLY)

        if (cpu_interrupts_enabled(env)) {


            cpu_check_irqs(env);


        }

#endif

        return true;

    }

    return false;

}",51,,LABEL_1,LABEL_1,LABEL_1,-1,"env,value",,,,0,,0,GA,464,0.16488253275553386,failed,
248,"void qemu_file_set_error(QEMUFile *f, int ret)

{

    if (f->last_error == 0) {

        f->last_error = ret;

    }

}
",30,,LABEL_1,LABEL_0,,-4,"f,ret",,,,0,,0,Greedy,1,0.00043925046920776365,,
249,"AVStream *add_audio_stream(AVFormatContext *oc, int codec_id)

{

    AVCodec *codec;

    AVCodecContext *c;

    AVStream *st;



    st = av_new_stream(oc, 1);

    if (!st) {

        fprintf(stderr, ""Could not alloc stream\n"");

        exit(1);

    }



    /* find the MP2 encoder */

    codec = avcodec_find_encoder(codec_id);

    if (!codec) {

        fprintf(stderr, ""codec not found\n"");

        exit(1);

    }

    c = &st->codec;

    c->codec_type = CODEC_TYPE_AUDIO;



    /* put sample parameters */

    c->bit_rate = 64000;

    c->sample_rate = 44100;

    c->channels = 2;



    /* open it */

    if (avcodec_open(c, codec) < 0) {

        fprintf(stderr, ""could not open codec\n"");

        exit(1);

    }



    /* init signal generator */

    t = 0;

    tincr = 2 * M_PI * 440.0 / c->sample_rate;



    audio_outbuf_size = 10000;

    audio_outbuf = malloc(audio_outbuf_size);



    /* ugly hack for PCM codecs (will be removed ASAP with new PCM

       support to compute the input frame size in samples */

    if (c->frame_size <= 1) {

        audio_input_frame_size = audio_outbuf_size / c->channels;

        switch(st->codec.codec_id) {

        case CODEC_ID_PCM_S16LE:

        case CODEC_ID_PCM_S16BE:

        case CODEC_ID_PCM_U16LE:

        case CODEC_ID_PCM_U16BE:

            audio_input_frame_size >>= 1;

            break;

        default:

            break;

        }

    } else {

        audio_input_frame_size = c->frame_size;

    }

    samples = malloc(audio_input_frame_size * 2 * c->channels);



    return st;

}
",319,,LABEL_1,LABEL_0,,-4,"oc,codec_id,codec,c,st",,,,0,,0,Greedy,1,0.0006082892417907715,,
250,"static int mov_write_hdlr_tag(AVIOContext *pb, MOVTrack *track)

{

    const char *hdlr, *descr = NULL, *hdlr_type = NULL;

    int64_t pos = avio_tell(pb);



    if (!track) { /* no media --> data handler */

        hdlr      = ""dhlr"";

        hdlr_type = ""url "";

        descr     = ""DataHandler"";

    } else {

        hdlr = (track->mode == MODE_MOV) ? ""mhlr"" : ""\0\0\0\0"";

        if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            hdlr_type = ""vide"";

            descr     = ""VideoHandler"";

        } else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO) {

            hdlr_type = ""soun"";

            descr     = ""SoundHandler"";

        } else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {

            if (track->tag == MKTAG('t','x','3','g')) hdlr_type = ""sbtl"";

            else                                      hdlr_type = ""text"";

            descr = ""SubtitleHandler"";

        } else if (track->enc->codec_tag == MKTAG('r','t','p',' ')) {

            hdlr_type = ""hint"";

            descr     = ""HintHandler"";

        }

    }



    avio_wb32(pb, 0); /* size */

    ffio_wfourcc(pb, ""hdlr"");

    avio_wb32(pb, 0); /* Version & flags */

    avio_write(pb, hdlr, 4); /* handler */

    ffio_wfourcc(pb, hdlr_type); /* handler type */

    avio_wb32(pb, 0); /* reserved */

    avio_wb32(pb, 0); /* reserved */

    avio_wb32(pb, 0); /* reserved */

    if (!track || track->mode == MODE_MOV)

        avio_w8(pb, strlen(descr)); /* pascal string */

    avio_write(pb, descr, strlen(descr)); /* handler description */

    if (track && track->mode != MODE_MOV)

        avio_w8(pb, 0); /* c string */

    return update_size(pb, pos);

}
",387,,LABEL_0,LABEL_0,LABEL_0,-1,"pb,track,hdlr,descr,hdlr_type",,,,0,,0,GA,1078,0.4428837458292643,failed,
251,"static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,

                int x, int y, int w, int h)

{

    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];

    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;

    rect->x = x;

    rect->y = y;

    rect->w = w;

    rect->h = h;

}
",80,,LABEL_0,LABEL_1,,-4,"s,x,y,w,h,rect,redraw_fifo_last",,,,0,,0,Greedy,1,0.00047143300374348957,,
252,"e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)

{

    E1000State *s = opaque;

    unsigned int index = (addr & 0x1ffff) >> 2;



    if (index < NREADOPS && macreg_readops[index])

    {

        return macreg_readops[index](s, index);

    }

    DBGOUT(UNKNOWN, ""MMIO unknown read addr=0x%08x\n"", index<<2);

    return 0;

}
",83,,LABEL_0,LABEL_0,LABEL_0,-1,s,,,,0,,0,GA,240,0.08603169520696004,failed,
253,"static float64 roundAndPackFloat64( flag zSign, int16 zExp, uint64_t zSig STATUS_PARAM)

{

    int8 roundingMode;

    flag roundNearestEven;

    int16 roundIncrement, roundBits;

    flag isTiny;



    roundingMode = STATUS(float_rounding_mode);

    roundNearestEven = ( roundingMode == float_round_nearest_even );

    roundIncrement = 0x200;

    if ( ! roundNearestEven ) {

        if ( roundingMode == float_round_to_zero ) {

            roundIncrement = 0;

        }

        else {

            roundIncrement = 0x3FF;

            if ( zSign ) {

                if ( roundingMode == float_round_up ) roundIncrement = 0;

            }

            else {

                if ( roundingMode == float_round_down ) roundIncrement = 0;

            }

        }

    }

    roundBits = zSig & 0x3FF;

    if ( 0x7FD <= (uint16_t) zExp ) {

        if (    ( 0x7FD < zExp )

             || (    ( zExp == 0x7FD )

                  && ( (int64_t) ( zSig + roundIncrement ) < 0 ) )

           ) {

            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);

            return packFloat64( zSign, 0x7FF, - ( roundIncrement == 0 ));

        }

        if ( zExp < 0 ) {

            if ( STATUS(flush_to_zero) ) return packFloat64( zSign, 0, 0 );

            isTiny =

                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )

                || ( zExp < -1 )

                || ( zSig + roundIncrement < LIT64( 0x8000000000000000 ) );

            shift64RightJamming( zSig, - zExp, &zSig );

            zExp = 0;

            roundBits = zSig & 0x3FF;

            if ( isTiny && roundBits ) float_raise( float_flag_underflow STATUS_VAR);

        }

    }

    if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;

    zSig = ( zSig + roundIncrement )>>10;

    zSig &= ~ ( ( ( roundBits ^ 0x200 ) == 0 ) & roundNearestEven );

    if ( zSig == 0 ) zExp = 0;

    return packFloat64( zSign, zExp, zSig );



}
",326,,LABEL_1,LABEL_0,,-4,"zSign,zExp,STATUS_PARAM,roundingMode,roundNearestEven,roundIncrement,roundBits,isTiny",,,,0,,0,Greedy,1,0.0006232619285583496,,
254,"static void test_qemu_strtol_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    long res = 999;

    int err;



    err = qemu_strtol(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",77,"static void test_qemu_strtol_invalid(void)

{

    const char *nc = ""   xxxx  \t abc"";

    char f = 'X';

    const char * endctr = &f;

    long res = 999;

    int err;



    err = qemu_strtol(nc, & endctr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert endctrr == nc);

}
",LABEL_1,LABEL_1,LABEL_0,1,"str,endptr,err",,,,3,"str:nc,endptr: endctr,err:err,",1,GA,145,0.051742064952850345,GA,
255,"static int ftp_passive_mode_epsv(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    static const char d = '|';

    static const char *command = ""EPSV\r\n"";

    static const int epsv_codes[] = {229, 0};



    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '(') {

            start = res + i + 1;

        } else if (res[i] == ')') {

            end = res + i;

            break;

        }

    }

    if (!start || !end)

        goto fail;



    *end = '\0';

    if (strlen(start) < 5)

        goto fail;

    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)

        goto fail;

    start += 3;

    end[-1] = '\0';



    s->server_data_port = atoi(start);

    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);



    av_free(res);

    return 0;



  fail:

    av_free(res);

    s->server_data_port = -1;

    return AVERROR(ENOSYS);

}
",272,"static int ftp_passive_mode_epsv(FTPContext *s)

{

    char *gr = NULL, *start = NULL, *end = NULL;

    int index;

    static const char d = '|';

    static const char *command = ""EPSV\r
"";

    static const int epsv_codes[] = {229, 0};



    if (ftp_send_command(s,commandd,epsv_codess, &gr) != 229 || !res)

        goto fail;



    for indexi = 0; gr[index]; ++index) {

        if (gr[index] == '(') {

           startt = gr + index + 1;

        } else if (gr[index] == ')') {

           endd = gr + index;

            break;

        }

    }

    if (!start || !end)

        goto fail;



    *end = '\0';

    if (strlen(start) < 5)

        goto fail;

    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)

        goto fail;

    start += 3;

    end[-1] = '\0';



    s->server_data_port = atoi(start);

    av_dlog(s, ""Server data port: %d
"", s->server_data_port);



    av_free(gr);

    return 0;



  fail:

    av_free(gr);

    s->server_data_port = -1;

    return AVERROR(ENOSYS);

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,res,start,end,i,command,epsv_codes",,,,23,"s:s,res:gr,start:start,end:end,i:index,command:command,epsv_codes:epsv_codes,",5,GA,394,0.15018212000528972,GA,
256,"static int hevc_frame_start(HEVCContext *s)

{

    HEVCLocalContext *lc = &s->HEVClc;

    int ret;



    memset(s->horizontal_bs, 0, 2 * s->bs_width * (s->bs_height + 1));

    memset(s->vertical_bs,   0, 2 * s->bs_width * (s->bs_height + 1));

    memset(s->cbf_luma,      0, s->sps->min_tb_width * s->sps->min_tb_height);

    memset(s->is_pcm,        0, s->sps->min_pu_width * s->sps->min_pu_height);



    lc->start_of_tiles_x = 0;

    s->is_decoded        = 0;




    if (s->pps->tiles_enabled_flag)

        lc->end_of_tiles_x = s->pps->column_width[0] << s->sps->log2_ctb_size;



    ret = ff_hevc_set_new_ref(s, s->sps->sao_enabled ? &s->sao_frame : &s->frame,

                              s->poc);

    if (ret < 0)

        goto fail;



    ret = ff_hevc_frame_rps(s);

    if (ret < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""Error constructing the frame RPS.\n"");

        goto fail;

    }



    ret = set_side_data(s);

    if (ret < 0)

        goto fail;



    av_frame_unref(s->output_frame);

    ret = ff_hevc_output_frame(s, s->output_frame, 0);

    if (ret < 0)

        goto fail;



    ff_thread_finish_setup(s->avctx);



    return 0;



fail:

    if (s->ref)

        ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);

    s->ref = NULL;

    return ret;

}",346,,LABEL_1,LABEL_1,LABEL_1,-1,"s,lc,ret",,,,0,,0,GA,716,0.27999321222305296,failed,
257,"static int mkv_write_ass_blocks(AVFormatContext *s, AVIOContext *pb,

                                AVPacket *pkt)

{

    MatroskaMuxContext *mkv = s->priv_data;

    int i, layer = 0, max_duration = 0, size, line_size, data_size = pkt->size;

    uint8_t *start, *end, *data = pkt->data;

    ebml_master blockgroup;

    char buffer[2048];



    while (data_size) {

        int duration = ass_get_duration(data);

        max_duration = FFMAX(duration, max_duration);

        end          = memchr(data, '\n', data_size);

        size         = line_size = end ? end - data + 1 : data_size;

        size        -= end ? (end[-1] == '\r') + 1 : 0;

        start        = data;

        for (i = 0; i < 3; i++, start++)

            if (!(start = memchr(start, ',', size - (start - data))))

                return max_duration;

        size -= start - data;

        sscanf(data, ""Dialogue: %d,"", &layer);

        i = snprintf(buffer, sizeof(buffer), ""%"" PRId64 "",%d,"",

                     s->streams[pkt->stream_index]->nb_frames, layer);

        size = FFMIN(i + size, sizeof(buffer));

        memcpy(buffer + i, start, size - i);



        av_log(s, AV_LOG_DEBUG,

               ""Writing block at offset %"" PRIu64 "", size %d, ""

               ""pts %"" PRId64 "", duration %d\n"",

               avio_tell(pb), size, pkt->pts, duration);

        blockgroup = start_ebml_master(pb, MATROSKA_ID_BLOCKGROUP,

                                       mkv_blockgroup_size(size));

        put_ebml_id(pb, MATROSKA_ID_BLOCK);

        put_ebml_num(pb, size + 4, 0);

        // this assumes stream_index is less than 126

        avio_w8(pb, 0x80 | (pkt->stream_index + 1));

        avio_wb16(pb, pkt->pts - mkv->cluster_pts);

        avio_w8(pb, 0);

        avio_write(pb, buffer, size);

        put_ebml_uint(pb, MATROSKA_ID_BLOCKDURATION, duration);

        end_ebml_master(pb, blockgroup);



        data      += line_size;

        data_size -= line_size;

    }



    return max_duration;

}
",410,,LABEL_0,LABEL_1,,-4,"s,pb,pkt,mkv,i,size,line_size,start,end,data,blockgroup,buffer",,,,0,,0,Greedy,1,0.0006699085235595704,,
258,"static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,

                                        unsigned int queue_no,

                                        unsigned int vector,

                                        MSIMessage msg)

{

    VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no);

    EventNotifier *n = virtio_queue_get_guest_notifier(vq);

    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];

    int ret;



    if (irqfd->users == 0) {

        ret = kvm_irqchip_add_msi_route(kvm_state, msg);

        if (ret < 0) {

            return ret;

        }

        irqfd->virq = ret;

    }

    irqfd->users++;



    ret = kvm_irqchip_add_irq_notifier(kvm_state, n, irqfd->virq);

    if (ret < 0) {

        if (--irqfd->users == 0) {

            kvm_irqchip_release_virq(kvm_state, irqfd->virq);

        }

        return ret;

    }



    virtio_queue_set_guest_notifier_fd_handler(vq, true, true);

    return 0;

}
",164,"static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *model,

                                        unsigned int queue_no,

                                        unsigned int prefix,

                                        MSIMessage msg)

{

    VirtQueue *vque = virtio_get_queue(model->vdev, queue_no);

    EventNotifier *n n virtio_queue_get_guest_notifier(vque);

    VirtIOIRQFD *yrarchcdn = &model->vector_irqfd[prefix];

    int val;



    if (yrarchcdn->users == 0) {

        val = kvm_irqchip_add_msi_route(kvm_state, msg);

        if (val < 0) {

            return val;

        }

        yrarchcdn->virq = val;

    }

    yrarchcdn->users++;



    ret valvm_irqchip_add_irq_notifier(kvm_state, n, yrarchcdn->virq);

    if (val < 0) {

        if (--yrarchcdn->users == 0) {

            kvm_irqchip_release_virq(kvm_state, yrarchcdn->virq);

        }

        return val;

    }



    virtio_queue_set_guest_notifier_fd_handler(vque, true, true);

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"proxy,queue_no,vector,msg,vq,n,irqfd,ret,users",,,,9,"proxy:model,queue_no:queue_no,vector:prefix,msg:msg,vq:vque,n:n,irqfd:yrarchcdn,ret:val,users:users,",4,GA,568,0.20952492554982502,GA,
259,"static void bdrv_qed_drain(BlockDriverState *bs)

{

    BDRVQEDState *s = bs->opaque;



    /* Cancel timer and start doing I/O that were meant to happen as if it

     * fired, that way we get bdrv_drain() taking care of the ongoing requests

     * correctly. */

    qed_cancel_need_check_timer(s);

    qed_plug_allocating_write_reqs(s);

    bdrv_aio_flush(s->bs, qed_clear_need_check, s);

}
",82,,LABEL_1,LABEL_0,,-4,"bs,s",,,,0,,0,Greedy,1,0.00048595269521077474,,
260,"static uint64_t omap_ulpd_pm_read(void *opaque, target_phys_addr_t addr,

                                  unsigned size)

{

    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;

    uint16_t ret;



    if (size != 2) {

        return omap_badwidth_read16(opaque, addr);

    }



    switch (addr) {

    case 0x14:	/* IT_STATUS */

        ret = s->ulpd_pm_regs[addr >> 2];

        s->ulpd_pm_regs[addr >> 2] = 0;

        qemu_irq_lower(s->irq[1][OMAP_INT_GAUGE_32K]);

        return ret;



    case 0x18:	/* Reserved */

    case 0x1c:	/* Reserved */

    case 0x20:	/* Reserved */

    case 0x28:	/* Reserved */

    case 0x2c:	/* Reserved */

        OMAP_BAD_REG(addr);

    case 0x00:	/* COUNTER_32_LSB */

    case 0x04:	/* COUNTER_32_MSB */

    case 0x08:	/* COUNTER_HIGH_FREQ_LSB */

    case 0x0c:	/* COUNTER_HIGH_FREQ_MSB */

    case 0x10:	/* GAUGING_CTRL */

    case 0x24:	/* SETUP_ANALOG_CELL3_ULPD1 */

    case 0x30:	/* CLOCK_CTRL */

    case 0x34:	/* SOFT_REQ */

    case 0x38:	/* COUNTER_32_FIQ */

    case 0x3c:	/* DPLL_CTRL */

    case 0x40:	/* STATUS_REQ */

        /* XXX: check clk::usecount state for every clock */

    case 0x48:	/* LOCL_TIME */

    case 0x4c:	/* APLL_CTRL */

    case 0x50:	/* POWER_CTRL */

        return s->ulpd_pm_regs[addr >> 2];

    }



    OMAP_BAD_REG(addr);

    return 0;

}
",306,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,addr,size,s,ret",,,,0,,0,GA,1095,0.43354174693425496,failed,
261,"static int vhost_virtqueue_init(struct vhost_dev *dev,

                                struct vhost_virtqueue *vq, int n)

{

    struct vhost_vring_file file = {

        .index = n,

    };

    int r = event_notifier_init(&vq->masked_notifier, 0);

    if (r < 0) {

        return r;

    }



    file.fd = event_notifier_get_fd(&vq->masked_notifier);

    r = dev->vhost_ops->vhost_call(dev, VHOST_SET_VRING_CALL, &file);

    if (r) {

        r = -errno;

        goto fail_call;

    }

    return 0;

fail_call:

    event_notifier_cleanup(&vq->masked_notifier);

    return r;

}
",118,"static int vhost_virtqueue_init(struct vhost_dev *rad,

                                struct vhost_virtqueue *vQ, int nm)

{

    struct vhost_vring_file file = {

        .index = nm,

    };

    int r = event_notifier_init(&vQ->masked_notifier, 0);

    if (r < 0) {

        return r;

    }



    file.fd = event_notifier_get_fd(&vQ->masked_notifier);

    r = rad->vhost_ops->vhost_call(rad, VHOST_SET_VRING_CALL, &file);

    if (r) {

        r = -errno;

        goto fail_call;

    }

    return 0;

fail_call:

    event_notifier_cleanup(&vQ->masked_notifier);

    return r;

}
",LABEL_0,LABEL_0,LABEL_1,1,"dev,vq,n",,,,0,"dev:rad,vq:vQ,n:nm,",0,GA,300,0.10943025747934977,GA,
262,"yuv2rgba64_full_X_c_template(SwsContext *c, const int16_t *lumFilter,

                       const int32_t **lumSrc, int lumFilterSize,

                       const int16_t *chrFilter, const int32_t **chrUSrc,

                       const int32_t **chrVSrc, int chrFilterSize,

                       const int32_t **alpSrc, uint16_t *dest, int dstW,

                       int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)

{

    int i;

    int A = 0xffff<<14;



    for (i = 0; i < dstW; i++) {

        int j;

        int Y  = -0x40000000;

        int U  = -128 << 23; // 19

        int V  = -128 << 23;

        int R, G, B;



        for (j = 0; j < lumFilterSize; j++) {

            Y += lumSrc[j][i]  * (unsigned)lumFilter[j];

        }

        for (j = 0; j < chrFilterSize; j++) {;

            U += chrUSrc[j][i] * (unsigned)chrFilter[j];

            V += chrVSrc[j][i] * (unsigned)chrFilter[j];

        }



        if (hasAlpha) {

            A = -0x40000000;

            for (j = 0; j < lumFilterSize; j++) {

                A += alpSrc[j][i] * (unsigned)lumFilter[j];

            }

            A >>= 1;

            A += 0x20002000;

        }



        // 8bit: 12+15=27; 16-bit: 12+19=31

        Y  >>= 14; // 10

        Y += 0x10000;

        U  >>= 14;

        V  >>= 14;



        // 8bit: 27 -> 17bit, 16bit: 31 - 14 = 17bit

        Y -= c->yuv2rgb_y_offset;

        Y *= c->yuv2rgb_y_coeff;

        Y += 1 << 13; // 21

        // 8bit: 17 + 13bit = 30bit, 16bit: 17 + 13bit = 30bit



        R = V * c->yuv2rgb_v2r_coeff;

        G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;

        B =                            U * c->yuv2rgb_u2b_coeff;



        // 8bit: 30 - 22 = 8bit, 16bit: 30bit - 14 = 16bit

        output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);

        output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);

        output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);

        if (eightbytes) {

            output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);

            dest += 4;

        } else {

            dest += 3;

        }

    }

}
",514,"yuv2rgba64_full_X_c_template(SwsContext *c, const int16_t *lumFilter,

                       const int32_t **lumSrc, int lumFilterSize,

                       const int16_t *chrFilter, const int32_t **chrUSrc,

                       const int32_t **chrVSrc, int chrFilterSize,

                       const int32_t **alpSrc, uint16_t *dest, int dstW,

                       int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)

{

    int b;

    int A = 0xffff<<14;



    for (b = 0; b < dstW; b++) {

        int qi;

        int Y  = -0x40000000;

        int U  = -128 << 23; // 19

        int V  = -128 << 23;

        int GR, D, B;



        for (qi = 0; qi < lumFilterSize; qi++) {

            Y += lumSrc[qi][b]  * (unsigned)lumFilter[qi];

        }

        for (qi = 0; qi < chrFilterSize; qi++) {;

            U += chrUSrc[qi][b] * (unsigned)chrFilter[qi];

            V += chrVSrc[qi][b] * (unsigned)chrFilter[qi];

        }



        if (hasAlpha) {

            A = -0x40000000;

            for (qi = 0; qi < lumFilterSize; qi++) {

                A += alpSrc[qi][b] * (unsigned)lumFilter[qi];

            }

            A >>= 1;

            A += 0x20002000;

        }



        // 8bit: 12+15=27; 16-bit: 12+19=31

        Y  >>= 14; // 10

        Y += 0x10000;

        U  >>= 14;

        V  >>= 14;



        // 8bit: 27 -> 17bit, 16bit: 31 - 14 = 17bit

        Y -= c->yuv2rgb_y_offset;

        Y *= c->yuv2rgb_y_coeff;

        Y += 1 << 13; // 21

        // 8bit: 17 + 13bit = 30bit, 16bit: 17 + 13bit = 30bit



        GR = V * c->yuv2rgb_v2r_coeff;

        D = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;

        B =                            U * c->yuv2rgb_u2b_coeff;



        // 8bit: 30 - 22 = 8bit, 16bit: 30bit - 14 = 16bit

        output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);

        output_pixel(&dest[1], av_clip_uintp2(  D + Y, 30) >> 14);

        output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);

        if (eightbytes) {

            output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);

            dest += 4;

        } else {

            dest += 3;

        }

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"i,j,R,G,B",,,,2,"i:b,j:qi,R:GR,G:D,B:B,",1,GA,267,0.11843014160792033,GA,
263,"static int decode_band(IVI45DecContext *ctx, int plane_num,

                       IVIBandDesc *band, AVCodecContext *avctx)

{

    int         result, i, t, idx1, idx2, pos;

    IVITile     *tile;



    band->buf     = band->bufs[ctx->dst_buf];

    if (!band->buf) {

        av_log(avctx, AV_LOG_ERROR, ""Band buffer points to no data!\n"");

        return AVERROR_INVALIDDATA;

    }

    band->ref_buf = band->bufs[ctx->ref_buf];

    band->data_ptr = ctx->frame_data + (get_bits_count(&ctx->gb) >> 3);



    result = ctx->decode_band_hdr(ctx, band, avctx);

    if (result) {

        av_log(avctx, AV_LOG_ERROR, ""Error while decoding band header: %d\n"",

               result);

        return result;

    }



    if (band->is_empty) {

        av_log(avctx, AV_LOG_ERROR, ""Empty band encountered!\n"");

        return AVERROR_INVALIDDATA;

    }



    band->rv_map = &ctx->rvmap_tabs[band->rvmap_sel];



    /* apply corrections to the selected rvmap table if present */

    for (i = 0; i < band->num_corr; i++) {

        idx1 = band->corr[i * 2];

        idx2 = band->corr[i * 2 + 1];

        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);

        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);

    }



    pos = get_bits_count(&ctx->gb);



    for (t = 0; t < band->num_tiles; t++) {

        tile = &band->tiles[t];



        if (tile->mb_size != band->mb_size) {

            av_log(avctx, AV_LOG_ERROR, ""MB sizes mismatch: %d vs. %d\n"",

                   band->mb_size, tile->mb_size);

            return AVERROR_INVALIDDATA;

        }

        tile->is_empty = get_bits1(&ctx->gb);

        if (tile->is_empty) {

            ivi_process_empty_tile(avctx, band, tile,

                                      (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3));

            av_dlog(avctx, ""Empty tile encountered!\n"");

        } else {

            tile->data_size = ff_ivi_dec_tile_data_size(&ctx->gb);

            if (!tile->data_size) {

                av_log(avctx, AV_LOG_ERROR, ""Tile data size is zero!\n"");

                return AVERROR_INVALIDDATA;

            }



            result = ctx->decode_mb_info(ctx, band, tile, avctx);

            if (result < 0)

                break;



            result = ff_ivi_decode_blocks(&ctx->gb, band, tile);

            if (result < 0 || ((get_bits_count(&ctx->gb) - pos) >> 3) != tile->data_size) {

                av_log(avctx, AV_LOG_ERROR, ""Corrupted tile data encountered!\n"");

                break;

            }



            pos += tile->data_size << 3; // skip to next tile

        }

    }



    /* restore the selected rvmap table by applying its corrections in reverse order */

    for (i = band->num_corr-1; i >= 0; i--) {

        idx1 = band->corr[i*2];

        idx2 = band->corr[i*2+1];

        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);

        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);

    }



#ifdef DEBUG

    if (band->checksum_present) {

        uint16_t chksum = ivi_calc_band_checksum(band);

        if (chksum != band->checksum) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Band checksum mismatch! Plane %d, band %d, received: %x, calculated: %x\n"",

                   band->plane, band->band_num, band->checksum, chksum);

        }

    }

#endif



    align_get_bits(&ctx->gb);



    return result;

}
",834,"static int decode_band(IVI45DecContext *gpu, int plane_num,

                       IVIBandDesc *device, AVCodecContext *avctx)

{

    int         result, i, t, idx1, idx2, type;

    IVITile     *coll;



    device->buf     = device->bufs[gpu->dst_buf];

    if (!band->buf) {

        av_log(avctx, AV_LOG_ERROR, ""Band buffer points to no data!
"");

        return AVERROR_INVALIDDATA;

    }

    device->ref_buf = device->bufs[gpu->ref_buf];

    device->data_ptr = gpu->frame_data + (get_bits_count(&gpu->gb) >> 3);



    reresult gpu->decode_band_hdr(gpu, device, avctx);

    if (result) {

        av_log(avavctxAV_LOG_ERROR, ""Error while decoding device header: %d
"",

               result);

        return result;

    }



    if (device->is_empty) {

        av_log(avavctxAV_LOG_ERROR, ""Empty device encountered!
"");

        return AVERROR_INVALIDDATA;

    }



    device->rv_map = &gpu->rvmap_tabs[device->rvmap_sel];



    /* apply corrections to the selected rvmap table if present */

    for (i i 0; i i device->num_corr; i++) {

        ididx1 device->corr[i * 2];

        ididx2 device->corr[i * 2 + 1];

        FFSWAP(uint8_t, device->rv_map->runtab[ididx1 device->rv_map->runtab[idx2]);

        FFSWAP(int16_t, device->rv_map->valtab[ididx1 device->rv_map->valtab[idx2]);

    }



    type = get_bits_count(&gpu->gb);



    for (t t 0; t t device->num_tiles; t++) {

        ticoll &device->tiles[t];



        if (ticollmb_size != device->mb_size) {

            av_log(avctx, AV_LOG_ERROR, ""MB sizes mismatch: %d vs. %d
"",

                   device->mb_size, coll->mb_size);

            return AVERROR_INVALIDDATA;

        }

        coll->is_empty = get_bits1(&gpu->gb);

        if (coll->is_empty) {

            ivi_process_empty_tile(avavctxdevice, coll,

                                      (gpu->planes[0].bands[0].mb_size >> 3) - (device->mb_size >> 3));

            av_dlog(avctx, ""Empty coll encountered!
"");

        } else {

            coll->data_size = ff_ivi_dec_tile_data_size(&gpu->gb);

            if (!tile->data_size) {

                av_log(avctx, AV_LOG_ERROR, ""Tile data size is zero!
"");

                return AVERROR_INVALIDDATA;

            }



            reresult gpu->decode_mb_info(gpu, device, coll, avctx);

            if (result < 0)

                break;



            reresult ff_ivi_decode_blocks(&gpu->gb, device, coll);

            if (result < 0 || ((get_bits_count(&gpu->gb) - type) >> 3) != coll->data_size) {

                av_log(avctx, AV_LOG_ERROR, ""Corrupted coll data encountered!
"");

                break;

            }



            type += coll->data_size << 3; // skip to next coll

        }

    }



    /* restore the selected rvmap table by applying its corrections in reverse order */

    for (i i device->num_corr-1; i >= 0; i--) {

        ididx1 device->corr[i*2];

        ididx2 device->corr[i*2+1];

        FFSWAP(uint8_t, device->rv_map->runtab[ididx1 device->rv_map->runtab[idx2]);

        FFSWAP(int16_t, device->rv_map->valtab[ididx1 device->rv_map->valtab[idx2]);

    }



#ifdef DEBUG

    if (device->checksum_present) {

        uint16_t chksum = ivi_calc_band_checksum(device);

        if (chksum != device->checksum) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Band checksum mismatch! Plane %d, device %d, received: %x, calculated: %x
"",

                   device->plane, device->band_num, device->checksum, chksum);

        }

    }

#endif



    align_get_bits(&gpu->gb);



    return result;

}
",LABEL_1,LABEL_1,LABEL_0,1,"ctx,plane_num,band,avctx,result,i,t,idx1,idx2,pos,tile",,,,53,"ctx:gpu,plane_num:plane_num,band:device,avctx:avctx,result:result,i:i,t:t,idx1:idx1,idx2:idx2,pos:type,tile:coll,",7,GA,718,0.34475617011388143,GA,
264,"static int piix4_initfn(PCIDevice *dev)

{

    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);

    uint8_t *pci_conf;



    isa_bus_new(&d->dev.qdev);



    pci_conf = d->dev.config;

    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge

    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);



    piix4_dev = &d->dev;

    qemu_register_reset(piix4_reset, d);

    return 0;

}
",102,,LABEL_0,LABEL_0,LABEL_0,-1,"dev,d,pci_conf",,,,0,,0,GA,399,0.1443708380063375,failed,
265,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
",137,"static av_cold int init_bundles(BinkContext *e)

{

    int bbw, bh, breaks;

    int ni;



    bbw = (e->avctx->width  + 7) >> 3;

    bh = (e->avctx->height + 7) >> 3;

    bbreaks= bbw * bh;



    for (ni = 0; ni < BINKB_NB_SRC; ni++) {

        e->bundle[ni].data = av_malloc(breaks * 64);

        if (!c->bundle[ni].data)

            return AVERROR(ENOMEM);

        e->bundle[ni].data_end = e->bundle[ni].data + breaks * 64;

    }



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"c,bw,bh,blocks,i",,,,3,"c:e,bw:bbw,bh:bh,blocks:breaks,i:ni,",1,GA,286,0.10340841611226399,GA,
266,"DeviceState *qdev_device_add(QemuOpts *opts)

{

    ObjectClass *oc;

    DeviceClass *dc;

    const char *driver, *path, *id;

    DeviceState *dev;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        qerror_report(QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    oc = object_class_by_name(driver);

    if (!oc) {

        const char *typename = find_typename_by_alias(driver);



        if (typename) {

            driver = typename;

            oc = object_class_by_name(driver);

        }

    }



    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {

        qerror_report(ERROR_CLASS_GENERIC_ERROR,

                      ""'%s' is not a valid device model name"", driver);

        return NULL;

    }



    if (object_class_is_abstract(oc)) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""non-abstract device type"");

        return NULL;

    }



    dc = DEVICE_CLASS(oc);

    if (dc->cannot_instantiate_with_device_add_yet) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""pluggable device type"");

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {

            qerror_report(QERR_BAD_BUS_FOR_DEVICE,

                          driver, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!bus) {

            qerror_report(QERR_NO_BUS_FOR_DEVICE,

                          dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && bus && !bus->allow_hotplug) {

        qerror_report(QERR_BUS_NO_HOTPLUG, bus->name);

        return NULL;

    }



    /* create device, set properties */

    dev = DEVICE(object_new(driver));



    if (bus) {

        qdev_set_parent_bus(dev, bus);

    }



    id = qemu_opts_id(opts);

    if (id) {

        dev->id = id;

    }

    if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) {

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        return NULL;

    }

    if (dev->id) {

        object_property_add_child(qdev_get_peripheral(), dev->id,

                                  OBJECT(dev), NULL);

    } else {

        static int anon_count;

        gchar *name = g_strdup_printf(""device[%d]"", anon_count++);

        object_property_add_child(qdev_get_peripheral_anon(), name,

                                  OBJECT(dev), NULL);

        g_free(name);

    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        qerror_report_err(err);

        error_free(err);

        dev->opts = NULL;

        object_unparent(OBJECT(dev));

        object_unref(OBJECT(dev));

        qerror_report(QERR_DEVICE_INIT_FAILED, driver);

        return NULL;

    }

    return dev;

}
",580,,LABEL_1,LABEL_0,,-4,"opts,oc,dc,driver,path,id,dev,bus,err,typename",,,,0,,0,Greedy,1,0.0007803877194722494,,
267,"static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)

{

    gen_read_xer(cpu_gpr[gprn]);

}
",24,,LABEL_1,LABEL_0,,-4,"ctx,gprn,sprn",,,,0,,0,Greedy,1,0.0004194299379984538,,
268,"int ram_load(QEMUFile *f, void *opaque, int version_id)

{

    ram_addr_t addr;

    int flags;



    if (version_id < 3 || version_id > 4) {

        return -EINVAL;

    }



    do {

        addr = qemu_get_be64(f);



        flags = addr & ~TARGET_PAGE_MASK;

        addr &= TARGET_PAGE_MASK;



        if (flags & RAM_SAVE_FLAG_MEM_SIZE) {

            if (version_id == 3) {

                if (addr != ram_bytes_total()) {

                    return -EINVAL;

                }

            } else {

                /* Synchronize RAM block list */

                char id[256];

                ram_addr_t length;

                ram_addr_t total_ram_bytes = addr;



                while (total_ram_bytes) {

                    RAMBlock *block;

                    uint8_t len;



                    len = qemu_get_byte(f);

                    qemu_get_buffer(f, (uint8_t *)id, len);

                    id[len] = 0;

                    length = qemu_get_be64(f);



                    QLIST_FOREACH(block, &ram_list.blocks, next) {

                        if (!strncmp(id, block->idstr, sizeof(id))) {

                            if (block->length != length)

                                return -EINVAL;

                            break;

                        }

                    }



                    if (!block) {

                        fprintf(stderr, ""Unknown ramblock \""%s\"", cannot ""

                                ""accept migration\n"", id);

                        return -EINVAL;

                    }



                    total_ram_bytes -= length;

                }

            }

        }



        if (flags & RAM_SAVE_FLAG_COMPRESS) {

            void *host;

            uint8_t ch;



            if (version_id == 3)

                host = qemu_get_ram_ptr(addr);

            else

                host = host_from_stream_offset(f, addr, flags);



            ch = qemu_get_byte(f);

            memset(host, ch, TARGET_PAGE_SIZE);

#ifndef _WIN32

            if (ch == 0 &&

                (!kvm_enabled() || kvm_has_sync_mmu())) {

                madvise(host, TARGET_PAGE_SIZE, MADV_DONTNEED);

            }

#endif

        } else if (flags & RAM_SAVE_FLAG_PAGE) {

            void *host;



            if (version_id == 3)

                host = qemu_get_ram_ptr(addr);

            else

                host = host_from_stream_offset(f, addr, flags);



            qemu_get_buffer(f, host, TARGET_PAGE_SIZE);

        }

        if (qemu_file_has_error(f)) {

            return -EIO;

        }

    } while (!(flags & RAM_SAVE_FLAG_EOS));



    return 0;

}
",398,,LABEL_1,LABEL_0,,-4,"f,opaque,version_id,addr,flags,id,length,block,len,host,ch",,,,0,,0,Greedy,1,0.0006701270739237468,,
269,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
",61,,LABEL_0,LABEL_0,LABEL_0,-1,"errp,fid",,,,0,,0,GA,455,0.1617047349611918,failed,
270,"static void flatview_ref(FlatView *view)

{

    atomic_inc(&view->ref);

}
",19,,LABEL_1,LABEL_0,,-4,view,,,,0,,0,Greedy,1,0.0004387378692626953,,
271,"static void mmap_release_buffer(AVPacket *pkt)

{

    struct v4l2_buffer buf;

    int res, fd;

    struct buff_data *buf_descriptor = pkt->priv;



    if (pkt->data == NULL)

        return;



    memset(&buf, 0, sizeof(struct v4l2_buffer));

    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    buf.memory = V4L2_MEMORY_MMAP;

    buf.index = buf_descriptor->index;

    fd = buf_descriptor->fd;

    av_free(buf_descriptor);



    res = ioctl(fd, VIDIOC_QBUF, &buf);

    if (res < 0)

        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",

               strerror(errno));



    pkt->data = NULL;

    pkt->size = 0;

}
",139,,LABEL_0,LABEL_0,LABEL_0,-1,"pkt,buf,res,fd,buf_descriptor",,,,0,,0,GA,795,0.2917661786079407,failed,
272,"static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd,

                            abi_long cmd, abi_long arg)

{

    void *argptr;

    struct dm_ioctl *host_dm;

    abi_long guest_data;

    uint32_t guest_data_size;

    int target_size;

    const argtype *arg_type = ie->arg_type;

    abi_long ret;

    void *big_buf = NULL;

    char *host_data;



    arg_type++;

    target_size = thunk_type_size(arg_type, 0);

    argptr = lock_user(VERIFY_READ, arg, target_size, 1);

    if (!argptr) {

        ret = -TARGET_EFAULT;

        goto out;

    }

    thunk_convert(buf_temp, argptr, arg_type, THUNK_HOST);

    unlock_user(argptr, arg, 0);



    /* buf_temp is too small, so fetch things into a bigger buffer */

    big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2);

    memcpy(big_buf, buf_temp, target_size);

    buf_temp = big_buf;

    host_dm = big_buf;



    guest_data = arg + host_dm->data_start;

    if ((guest_data - arg) < 0) {

        ret = -EINVAL;

        goto out;

    }

    guest_data_size = host_dm->data_size - host_dm->data_start;

    host_data = (char*)host_dm + host_dm->data_start;



    argptr = lock_user(VERIFY_READ, guest_data, guest_data_size, 1);

    switch (ie->host_cmd) {

    case DM_REMOVE_ALL:

    case DM_LIST_DEVICES:

    case DM_DEV_CREATE:

    case DM_DEV_REMOVE:

    case DM_DEV_SUSPEND:

    case DM_DEV_STATUS:

    case DM_DEV_WAIT:

    case DM_TABLE_STATUS:

    case DM_TABLE_CLEAR:

    case DM_TABLE_DEPS:

    case DM_LIST_VERSIONS:

        /* no input data */

        break;

    case DM_DEV_RENAME:

    case DM_DEV_SET_GEOMETRY:

        /* data contains only strings */

        memcpy(host_data, argptr, guest_data_size);

        break;

    case DM_TARGET_MSG:

        memcpy(host_data, argptr, guest_data_size);

        *(uint64_t*)host_data = tswap64(*(uint64_t*)argptr);

        break;

    case DM_TABLE_LOAD:

    {

        void *gspec = argptr;

        void *cur_data = host_data;

        const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };

        int spec_size = thunk_type_size(arg_type, 0);

        int i;



        for (i = 0; i < host_dm->target_count; i++) {

            struct dm_target_spec *spec = cur_data;

            uint32_t next;

            int slen;



            thunk_convert(spec, gspec, arg_type, THUNK_HOST);

            slen = strlen((char*)gspec + spec_size) + 1;

            next = spec->next;

            spec->next = sizeof(*spec) + slen;

            strcpy((char*)&spec[1], gspec + spec_size);

            gspec += next;

            cur_data += spec->next;

        }

        break;

    }

    default:

        ret = -TARGET_EINVAL;

        goto out;

    }

    unlock_user(argptr, guest_data, 0);



    ret = get_errno(ioctl(fd, ie->host_cmd, buf_temp));

    if (!is_error(ret)) {

        guest_data = arg + host_dm->data_start;

        guest_data_size = host_dm->data_size - host_dm->data_start;

        argptr = lock_user(VERIFY_WRITE, guest_data, guest_data_size, 0);

        switch (ie->host_cmd) {

        case DM_REMOVE_ALL:

        case DM_DEV_CREATE:

        case DM_DEV_REMOVE:

        case DM_DEV_RENAME:

        case DM_DEV_SUSPEND:

        case DM_DEV_STATUS:

        case DM_TABLE_LOAD:

        case DM_TABLE_CLEAR:

        case DM_TARGET_MSG:

        case DM_DEV_SET_GEOMETRY:

            /* no return data */

            break;

        case DM_LIST_DEVICES:

        {

            struct dm_name_list *nl = (void*)host_dm + host_dm->data_start;

            uint32_t remaining_data = guest_data_size;

            void *cur_data = argptr;

            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_name_list) };

            int nl_size = 12; /* can't use thunk_size due to alignment */



            while (1) {

                uint32_t next = nl->next;

                if (next) {

                    nl->next = nl_size + (strlen(nl->name) + 1);

                }

                if (remaining_data < nl->next) {

                    host_dm->flags |= DM_BUFFER_FULL_FLAG;

                    break;

                }

                thunk_convert(cur_data, nl, arg_type, THUNK_TARGET);

                strcpy(cur_data + nl_size, nl->name);

                cur_data += nl->next;

                remaining_data -= nl->next;

                if (!next) {

                    break;

                }

                nl = (void*)nl + next;

            }

            break;

        }

        case DM_DEV_WAIT:

        case DM_TABLE_STATUS:

        {

            struct dm_target_spec *spec = (void*)host_dm + host_dm->data_start;

            void *cur_data = argptr;

            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_spec) };

            int spec_size = thunk_type_size(arg_type, 0);

            int i;



            for (i = 0; i < host_dm->target_count; i++) {

                uint32_t next = spec->next;

                int slen = strlen((char*)&spec[1]) + 1;

                spec->next = (cur_data - argptr) + spec_size + slen;

                if (guest_data_size < spec->next) {

                    host_dm->flags |= DM_BUFFER_FULL_FLAG;

                    break;

                }

                thunk_convert(cur_data, spec, arg_type, THUNK_TARGET);

                strcpy(cur_data + spec_size, (char*)&spec[1]);

                cur_data = argptr + spec->next;

                spec = (void*)host_dm + host_dm->data_start + next;

            }

            break;

        }

        case DM_TABLE_DEPS:

        {

            void *hdata = (void*)host_dm + host_dm->data_start;

            int count = *(uint32_t*)hdata;

            uint64_t *hdev = hdata + 8;

            uint64_t *gdev = argptr + 8;

            int i;



            *(uint32_t*)argptr = tswap32(count);

            for (i = 0; i < count; i++) {

                *gdev = tswap64(*hdev);

                gdev++;

                hdev++;

            }

            break;

        }

        case DM_LIST_VERSIONS:

        {

            struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start;

            uint32_t remaining_data = guest_data_size;

            void *cur_data = argptr;

            const argtype arg_type[] = { MK_STRUCT(STRUCT_dm_target_versions) };

            int vers_size = thunk_type_size(arg_type, 0);



            while (1) {

                uint32_t next = vers->next;

                if (next) {

                    vers->next = vers_size + (strlen(vers->name) + 1);

                }

                if (remaining_data < vers->next) {

                    host_dm->flags |= DM_BUFFER_FULL_FLAG;

                    break;

                }

                thunk_convert(cur_data, vers, arg_type, THUNK_TARGET);

                strcpy(cur_data + vers_size, vers->name);

                cur_data += vers->next;

                remaining_data -= vers->next;

                if (!next) {

                    break;

                }

                vers = (void*)vers + next;

            }

            break;

        }

        default:

            ret = -TARGET_EINVAL;

            goto out;

        }

        unlock_user(argptr, guest_data, guest_data_size);



        argptr = lock_user(VERIFY_WRITE, arg, target_size, 0);

        if (!argptr) {

            ret = -TARGET_EFAULT;

            goto out;

        }

        thunk_convert(argptr, buf_temp, arg_type, THUNK_TARGET);

        unlock_user(argptr, arg, target_size);

    }

out:

    if (big_buf) {

        free(big_buf);

    }

    return ret;

}
",1358,"static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd,

                            abi_long method, abi_long arg)

{

    void *argptr;

    struct dm_ioctl *host_dm;

    abi_long guest_data;

    uint32_t guest_Data_size;

    int arget_len;

    const argtype *int_order = ie->int_order;

    abi_long ret;

    void *big_buf = NULL;

    char *host_data;



    int_order++;

    arget_len = thunk_type_size(int_order, 0);

    argptr = lock_user(VERIFY_READ, arg, arget_len, 1);

    if (!argptr) {

        ret = -TARGET_EFAULT;

        goto out;

    }

    thunk_convert(buf_temp, argptr, int_order, THUNK_HOST);

    unlock_user(argptr, arg, 0);



    /* buf_temp is too small, so fetch things into a bigger buffer */

    big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2);

    memcpbig_bufuf, buf_temp, arget_len);

    buf_temp = big_buf;

    host_dm = big_buf;



    guest_data = arg + host_dm->data_start;

    if ((guest_data - arg) < 0) {

        ret = -EINVAL;

        goto out;

    }

    guest_Data_size = host_dm->data_size - host_dm->data_start;

    host_data = (char*)host_dm + host_dm->data_start;



    argptr = lock_user(VERIFY_READ, guest_data, guest_Data_size, 1);

    switch (ie->host_cmd) {

    case DM_REMOVE_ALL:

    case DM_LIST_DEVICES:

    case DM_DEV_CREATE:

    case DM_DEV_REMOVE:

    case DM_DEV_SUSPEND:

    case DM_DEV_STATUS:

    case DM_DEV_WAIT:

    case DM_TABLE_STATUS:

    case DM_TABLE_CLEAR:

    case DM_TABLE_DEPS:

    case DM_LIST_VERSIONS:

        /* no input data */

        break;

    case DM_DEV_RENAME:

    case DM_DEV_SET_GEOMETRY:

        /* data contains only strings */

        memcpy(host_data, argptr, guest_Data_size);

        break;

    case DM_TARGET_MSG:

        memcpy(host_data, argptr, guest_Data_size);

        *(uint64_t*)host_data = tswap64(*(uint64_t*)argptr);

        break;

    case DM_TABLE_LOAD:

    {

        void *gspec = argptr;

        void *cur_data = host_data;

        const argtype int_order[] = { MK_STRUCT(STRUCT_dm_target_spec) };

        int spec_size = thunk_type_size(int_order, 0);

        int i;



        for (i = 0; i < host_dm->target_count; i++) {

            struct dm_target_spec *spec = cur_data;

            uint32_t next;

            int slen;



            thunk_convert(spec, gspec, int_order, THUNK_HOST);

            slen = strlen((char*)gspec + spec_size) + 1;

            next = spec->next;

            spec->next = sizeof(*spec) + slen;

            strcpy((char*)&spec[1], gspec + spec_size);

            gspec += next;

            cur_data += spec->next;

        }

        break;

    }

    default:

        ret = -TARGET_EINVAL;

        goto out;

    }

    unlock_user(argptr, guest_data, 0);



    ret = get_errno(ioctl(fd, ie->host_cmd, buf_temp));

    if (!is_error(ret)) {

        guest_data = arg + host_dm->data_start;

        guest_Data_size = host_dm->data_size - host_dm->data_start;

        argptr = lock_user(VERIFY_WRITE, guest_data, guest_Data_size, 0);

        switch (ie->host_cmd) {

        case DM_REMOVE_ALL:

        case DM_DEV_CREATE:

        case DM_DEV_REMOVE:

        case DM_DEV_RENAME:

        case DM_DEV_SUSPEND:

        case DM_DEV_STATUS:

        case DM_TABLE_LOAD:

        case DM_TABLE_CLEAR:

        case DM_TARGET_MSG:

        case DM_DEV_SET_GEOMETRY:

            /* no return data */

            break;

        case DM_LIST_DEVICES:

        {

            struct dm_name_list *nl = (void*)host_dm + host_dm->data_start;

            uint32_t remaining_data = guest_Data_size;

            void *cur_data = argptr;

            const argtype int_order[] = { MK_STRUCT(STRUCT_dm_name_list) };

            int nl_size = 12; /* can't use thunk_size due to alignment */



            while (1) {

                uint32_t next = nl->next;

                if (next) {

                    nl->next = nl_size + (strlen(nl->name) + 1);

                }

                if (remaining_data < nl->next) {

                    host_dm->flags |= DM_BUFFER_FULL_FLAG;

                    break;

                }

                thunk_convert(cur_data, nl, int_order, THUNK_TARGET);

                strcpy(cur_data + nl_size, nl->name);

                cur_data += nl->next;

                remaining_data -= nl->next;

                if (!next) {

                    break;

                }

                nl = (void*)nl + next;

            }

            break;

        }

        case DM_DEV_WAIT:

        case DM_TABLE_STATUS:

        {

            struct dm_target_spec *spec = (void*)host_dm + host_dm->data_start;

            void *cur_data = argptr;

            const argtype int_order[] = { MK_STRUCT(STRUCT_dm_target_spec) };

            int spec_size = thunk_type_size(int_order, 0);

            int i;



            for (i = 0; i < host_dm->target_count; i++) {

                uint32_t next = spec->next;

                int slen = strlen((char*)&spec[1]) + 1;

                spec->next = (cur_data - argptr) + spec_size + slen;

                if (guest_Data_size < spec->next) {

                    host_dm->flags |= DM_BUFFER_FULL_FLAG;

                    break;

                }

                thunk_convert(cur_data, spec, int_order, THUNK_TARGET);

                strcpy(cur_data + spec_size, (char*)&spec[1]);

                cur_data = argptr + spec->next;

                spec = (void*)host_dm + host_dm->data_start + next;

            }

            break;

        }

        case DM_TABLE_DEPS:

        {

            void *hdata = (void*)host_dm + host_dm->data_start;

            int count = *(uint32_t*)hdata;

            uint64_t *hdev = hdata + 8;

            uint64_t *gdev = argptr + 8;

            int i;



            *(uint32_t*)argptr = tswap32(count);

            for (i = 0; i < count; i++) {

                *gdev = tswap64(*hdev);

                gdev++;

                hdev++;

            }

            break;

        }

        case DM_LIST_VERSIONS:

        {

            struct dm_target_versions *vers = (void*)host_dm + host_dm->data_start;

            uint32_t remaining_data = guest_Data_size;

            void *cur_data = argptr;

            const argtype int_order[] = { MK_STRUCT(STRUCT_dm_target_versions) };

            int vers_size = thunk_type_size(int_order, 0);



            while (1) {

                uint32_t next = vers->next;

                if (next) {

                    vers->next = vers_size + (strlen(vers->name) + 1);

                }

                if (remaining_data < vers->next) {

                    host_dm->flags |= DM_BUFFER_FULL_FLAG;

                    break;

                }

                thunk_convert(cur_data, vers, int_order, THUNK_TARGET);

                strcpy(cur_data + vers_size, vers->name);

                cur_data += vers->next;

                remaining_data -= vers->next;

                if (!next) {

                    break;

                }

                vers = (void*)vers + next;

            }

            break;

        }

        default:

            ret = -TARGET_EINVAL;

            goto out;

        }

        unlock_user(argptr, guest_data, guest_Data_size);



        argptr = lock_user(VERIFY_WRITE, arg, arget_len, 0);

        if (!argptr) {

            ret = -TARGET_EFAULT;

            goto out;

        }

        thunk_convert(argptr, buf_temp, int_order, THUNK_TARGET);

        unlock_user(argptr, arg, arget_len);

    }

out:

    if (big_buf) {

        free(big_buf);

    }

    return ret;

}
",LABEL_0,LABEL_0,LABEL_1,1,"ie,buf_temp,fd,cmd,arg,argptr,host_dm,guest_data,guest_data_size,target_size,arg_type,ret,big_buf,host_data",,,,100,"ie:ie,buf_temp:buf_temp,fd:fd,cmd:method,arg:arg,argptr:argptr,host_dm:host_dm,guest_data:guest_data,guest_data_size:guest_Data_size,target_size:arget_len,arg_type:int_order,ret:ret,big_buf:big_buf,host_data:host_data,",10,GA,628,0.38668115933736164,GA,
273,"static bool qht_insert__locked(struct qht *ht, struct qht_map *map,

                               struct qht_bucket *head, void *p, uint32_t hash,

                               bool *needs_resize)

{

    struct qht_bucket *b = head;

    struct qht_bucket *prev = NULL;

    struct qht_bucket *new = NULL;

    int i;



    do {

        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {

            if (b->pointers[i]) {

                if (unlikely(b->pointers[i] == p)) {

                    return false;

                }

            } else {

                goto found;

            }

        }

        prev = b;

        b = b->next;

    } while (b);



    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));

    memset(b, 0, sizeof(*b));

    new = b;

    i = 0;

    atomic_inc(&map->n_added_buckets);

    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {

        *needs_resize = true;

    }



 found:

    /* found an empty key: acquire the seqlock and write */

    seqlock_write_begin(&head->sequence);

    if (new) {

        atomic_rcu_set(&prev->next, b);

    }

    b->hashes[i] = hash;

    /* smp_wmb() implicit in seqlock_write_begin.  */

    atomic_set(&b->pointers[i], p);

    seqlock_write_end(&head->sequence);

    return true;

}
",281,,LABEL_1,LABEL_0,,-4,"ht,map,head,p,hash,needs_resize,b,prev,new,i",,,,0,,0,Greedy,1,0.0005839268366495768,,
274,"int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)

{

    cl_int status;

    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,

                                      CL_TRUE,CL_MAP_READ, 0, buf_size,

                                      0, NULL, NULL, &status);



    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not map OpenCL buffer: %s\n"", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }

    memcpy(dst_buf, mapped, buf_size);



    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);

    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not unmap OpenCL buffer: %s\n"", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }

    return 0;

}
",149,,LABEL_0,LABEL_0,LABEL_0,-1,"dst_buf,src_cl_buf,buf_size,status,mapped",,,,0,,0,GA,1015,0.3749588886896769,failed,
275,"static int srt_decode_frame(AVCodecContext *avctx,

                            void *data, int *got_sub_ptr, AVPacket *avpkt)

{

    AVSubtitle *sub = data;

    AVBPrint buffer;

    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

    int size, ret;

    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);

    FFASSDecoderContext *s = avctx->priv_data;



    if (p && size == 16) {

        x1 = AV_RL32(p     );

        y1 = AV_RL32(p +  4);

        x2 = AV_RL32(p +  8);

        y2 = AV_RL32(p + 12);

    }



    if (avpkt->size <= 0)

        return avpkt->size;



    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);



    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);

    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);

    av_bprint_finalize(&buffer, NULL);

    if (ret < 0)

        return ret;



    *got_sub_ptr = sub->num_rects > 0;

    return avpkt->size;

}
",229,,LABEL_0,LABEL_1,,-4,"avctx,data,got_sub_ptr,avpkt,sub,buffer,size,ret,p,s",,,,0,,0,Greedy,1,0.0005589405695597331,,
276,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)

{

    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));



    re->func = func;

    re->opaque = opaque;

    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);

}
",51,,LABEL_0,LABEL_0,LABEL_0,-1,"func,opaque,re",,,,0,,0,GA,602,0.2118260065714518,failed,
277,"void helper_frndint(void)

{

    ST0 = rint(ST0);

}
",14,,LABEL_1,LABEL_1,,-3,,,,,0,,0,Greedy,1,0.0004297693570454915,,
278,"static void stellaris_init(const char *kernel_filename, const char *cpu_model,

                           stellaris_board_info *board)

{

    static const int uart_irq[] = {5, 6, 33, 34};

    static const int timer_irq[] = {19, 21, 23, 35};

    static const uint32_t gpio_addr[7] =

      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,

        0x40024000, 0x40025000, 0x40026000};

    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};



    qemu_irq *pic;

    DeviceState *gpio_dev[7];

    qemu_irq gpio_in[7][8];

    qemu_irq gpio_out[7][8];

    qemu_irq adc;

    int sram_size;

    int flash_size;

    I2CBus *i2c;

    DeviceState *dev;

    int i;

    int j;



    MemoryRegion *sram = g_new(MemoryRegion, 1);

    MemoryRegion *flash = g_new(MemoryRegion, 1);

    MemoryRegion *system_memory = get_system_memory();



    flash_size = (((board->dc0 & 0xffff) + 1) << 1) * 1024;

    sram_size = ((board->dc0 >> 18) + 1) * 1024;



    /* Flash programming is done via the SCU, so pretend it is ROM.  */

    memory_region_init_ram(flash, NULL, ""stellaris.flash"", flash_size,

                           &error_abort);

    vmstate_register_ram_global(flash);

    memory_region_set_readonly(flash, true);

    memory_region_add_subregion(system_memory, 0, flash);



    memory_region_init_ram(sram, NULL, ""stellaris.sram"", sram_size,

                           &error_abort);

    vmstate_register_ram_global(sram);

    memory_region_add_subregion(system_memory, 0x20000000, sram);



    pic = armv7m_init(system_memory, flash_size, NUM_IRQ_LINES,

                      kernel_filename, cpu_model);



    if (board->dc1 & (1 << 16)) {

        dev = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000,

                                    pic[14], pic[15], pic[16], pic[17], NULL);

        adc = qdev_get_gpio_in(dev, 0);

    } else {

        adc = NULL;

    }

    for (i = 0; i < 4; i++) {

        if (board->dc2 & (0x10000 << i)) {

            dev = sysbus_create_simple(TYPE_STELLARIS_GPTM,

                                       0x40030000 + i * 0x1000,

                                       pic[timer_irq[i]]);

            /* TODO: This is incorrect, but we get away with it because

               the ADC output is only ever pulsed.  */

            qdev_connect_gpio_out(dev, 0, adc);

        }

    }



    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr.a);



    for (i = 0; i < 7; i++) {

        if (board->dc4 & (1 << i)) {

            gpio_dev[i] = sysbus_create_simple(""pl061_luminary"", gpio_addr[i],

                                               pic[gpio_irq[i]]);

            for (j = 0; j < 8; j++) {

                gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j);

                gpio_out[i][j] = NULL;

            }

        }

    }



    if (board->dc2 & (1 << 12)) {

        dev = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]);

        i2c = (I2CBus *)qdev_get_child_bus(dev, ""i2c"");

        if (board->peripherals & BP_OLED_I2C) {

            i2c_create_slave(i2c, ""ssd0303"", 0x3d);

        }

    }



    for (i = 0; i < 4; i++) {

        if (board->dc2 & (1 << i)) {

            sysbus_create_simple(""pl011_luminary"", 0x4000c000 + i * 0x1000,

                                 pic[uart_irq[i]]);

        }

    }

    if (board->dc2 & (1 << 4)) {

        dev = sysbus_create_simple(""pl022"", 0x40008000, pic[7]);

        if (board->peripherals & BP_OLED_SSI) {

            void *bus;

            DeviceState *sddev;

            DeviceState *ssddev;



            /* Some boards have both an OLED controller and SD card connected to

             * the same SSI port, with the SD card chip select connected to a

             * GPIO pin.  Technically the OLED chip select is connected to the

             * SSI Fss pin.  We do not bother emulating that as both devices

             * should never be selected simultaneously, and our OLED controller

             * ignores stray 0xff commands that occur when deselecting the SD

             * card.

             */

            bus = qdev_get_child_bus(dev, ""ssi"");



            sddev = ssi_create_slave(bus, ""ssi-sd"");

            ssddev = ssi_create_slave(bus, ""ssd0323"");

            gpio_out[GPIO_D][0] = qemu_irq_split(

                    qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0),

                    qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0));

            gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0);



            /* Make sure the select pin is high.  */

            qemu_irq_raise(gpio_out[GPIO_D][0]);

        }

    }

    if (board->dc4 & (1 << 28)) {

        DeviceState *enet;



        qemu_check_nic_model(&nd_table[0], ""stellaris"");



        enet = qdev_create(NULL, ""stellaris_enet"");

        qdev_set_nic_properties(enet, &nd_table[0]);

        qdev_init_nofail(enet);

        sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000);

        sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]);

    }

    if (board->peripherals & BP_GAMEPAD) {

        qemu_irq gpad_irq[5];

        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };



        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */

        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */

        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */

        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */

        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */



        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);

    }

    for (i = 0; i < 7; i++) {

        if (board->dc4 & (1 << i)) {

            for (j = 0; j < 8; j++) {

                if (gpio_out[i][j]) {

                    qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]);

                }

            }

        }

    }

}
",1237,,LABEL_1,LABEL_0,,-4,"kernel_filename,cpu_model,board,uart_irq,timer_irq,gpio_addr,gpio_irq,pic,gpio_dev,gpio_in,gpio_out,adc,sram_size,flash_size,i2c,dev,i,j,sram,flash,system_memory",,,,0,,0,Greedy,1,0.0011612375577290852,,
279,"POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(oc);

    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);

    CPUClass *cc = CPU_CLASS(oc);



    dc->fw_name = ""PowerPC,POWER9"";

    dc->desc = ""POWER9"";

    dc->props = powerpc_servercpu_properties;

    pcc->pvr_match = ppc_pvr_match_power9;

    pcc->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07;

    pcc->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 |

                         PCR_COMPAT_2_05;

    pcc->init_proc = init_proc_POWER9;

    pcc->check_pow = check_pow_nocheck;

    cc->has_work = cpu_has_work_POWER9;

    pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |

                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |

                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |

                       PPC_FLOAT_FRSQRTES |

                       PPC_FLOAT_STFIWX |

                       PPC_FLOAT_EXT |

                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |

                       PPC_MEM_SYNC | PPC_MEM_EIEIO |

                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |

                       PPC_64B | PPC_64BX | PPC_ALTIVEC |

                       PPC_SEGMENT_64B | PPC_SLBI |

                       PPC_POPCNTB | PPC_POPCNTWD |

                       PPC_CILDST;

    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |

                        PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |

                        PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |

                        PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |

                        PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |

                        PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |

                        PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;

    pcc->msr_mask = (1ull << MSR_SF) |

                    (1ull << MSR_TM) |

                    (1ull << MSR_VR) |

                    (1ull << MSR_VSX) |

                    (1ull << MSR_EE) |

                    (1ull << MSR_PR) |

                    (1ull << MSR_FP) |

                    (1ull << MSR_ME) |

                    (1ull << MSR_FE0) |

                    (1ull << MSR_SE) |

                    (1ull << MSR_DE) |

                    (1ull << MSR_FE1) |

                    (1ull << MSR_IR) |

                    (1ull << MSR_DR) |

                    (1ull << MSR_PMM) |

                    (1ull << MSR_RI) |

                    (1ull << MSR_LE);

    pcc->mmu_model = POWERPC_MMU_3_00;

#if defined(CONFIG_SOFTMMU)

    pcc->handle_mmu_fault = ppc64_v3_handle_mmu_fault;

    /* segment page size remain the same */

    pcc->sps = &POWER7_POWER8_sps;

    pcc->radix_page_info = &POWER9_radix_page_info;

#endif

    pcc->excp_model = POWERPC_EXCP_POWER8;

    pcc->bus_model = PPC_FLAGS_INPUT_POWER7;

    pcc->bfd_mach = bfd_mach_ppc64;

    pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE |

                 POWERPC_FLAG_BE | POWERPC_FLAG_PMM |

                 POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR |

                 POWERPC_FLAG_VSX | POWERPC_FLAG_TM;

    pcc->l1_dcache_size = 0x8000;

    pcc->l1_icache_size = 0x8000;

    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr;

}
",443,,LABEL_1,LABEL_0,,-4,"oc,data,dc,pcc,cc",,,,0,,0,Greedy,1,0.0006884177525838216,,
280,"void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,

                          int is_asi, int size)

{

    CPUState *saved_env;

    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;

    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",

             addr, is_write, is_exec);

    if (!(env->sregs[SR_MSR] & MSR_EE)) {

        return;

    }



    if (is_exec) {

        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    } else {

        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    }

}
",171,,LABEL_0,LABEL_0,LABEL_0,-1,"addr,is_write,is_exec,is_asi,size,saved_env",,,,0,,0,GA,894,0.3397701462109884,failed,
281,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);

    }

    pc_alloc_uninit(vs->alloc);

    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));

    g_free(vs->dev);

    qpci_free_pc(vs->bus);

    g_free(vs);

}
",102,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *obs)

{

    int index;



    for (iindex= 0; iindex< obs->num_queues + 2; index++) {

        qvirtqueue_cleanup(obs->dev->bus, obs->vq[iindex, obs->alloc);

    }

    pc_alloc_uninit(obs->alloc);

    qvirtio_pci_device_disable(container_of(obs->dev, QVirtioPCIDevice, vdev));

    g_free(obs->dev);

    qpci_free_pc(obs->bus);

    g_free(obs);

}
",LABEL_0,LABEL_0,LABEL_1,1,"vs,i",,,,0,"vs:obs,i:index,",0,GA,137,0.049917864799499514,GA,
282,"static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)

{

    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

}
",33,,LABEL_0,LABEL_0,LABEL_0,-1,"s,bsel,slot",,,,0,,0,GA,641,0.22439463138580323,failed,
283,"static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param)

{

    int prefix = 0;

    int suffix = 0;

    int last_coeff_abs_level_remaining;

    int i;



    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc))

        prefix++;



    if (prefix < 3) {

        for (i = 0; i < rc_rice_param; i++)

            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);

        last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;

    } else {

        int prefix_minus3 = prefix - 3;



        if (prefix == CABAC_MAX_BIN) {

            av_log(s->avctx, AV_LOG_ERROR, ""CABAC_MAX_BIN : %d\n"", prefix);

            return 0;

        }



        for (i = 0; i < prefix_minus3 + rc_rice_param; i++)

            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);

        last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)

                                              << rc_rice_param) + suffix;

    }

    return last_coeff_abs_level_remaining;

}
",204,,LABEL_1,LABEL_0,,-4,"s,rc_rice_param,last_coeff_abs_level_remaining,i,prefix",,,,0,,0,Greedy,1,0.0005466183026631673,,
284,"static int vfio_start_eventfd_injection(VFIOINTp *intp)

{

    int ret;



    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);

    if (ret) {

        error_report(""vfio: Error: Failed to pass IRQ fd to the driver: %m"");

    }

    return ret;

}
",36,,LABEL_1,LABEL_0,,-4,"intp,ret",,,,0,,0,Greedy,1,0.0004416863123575846,,
285,"static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,

                                       int *mb_type)

{

    int b8_stride = 2;

    int b4_stride = h->b_stride;

    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;

    int mb_type_col[2];

    const int16_t (*l1mv0)[2], (*l1mv1)[2];

    const int8_t *l1ref0, *l1ref1;

    const int is_b8x8 = IS_8X8(*mb_type);

    unsigned int sub_mb_type = MB_TYPE_L0L1;

    int i8, i4;

    int ref[2];

    int mv[2];

    int list;



    assert(sl->ref_list[1][0].reference & 3);



    await_reference_mb_row(h, sl->ref_list[1][0].parent,

                           sl->mb_y + !!IS_INTERLACED(*mb_type));



#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \

                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)



    /* ref = min(neighbors) */

    for (list = 0; list < 2; list++) {

        int left_ref     = sl->ref_cache[list][scan8[0] - 1];

        int top_ref      = sl->ref_cache[list][scan8[0] - 8];

        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];

        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];

        if (refc == PART_NOT_AVAILABLE) {

            refc = sl->ref_cache[list][scan8[0] - 8 - 1];

            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];

        }

        ref[list] = FFMIN3((unsigned)left_ref,

                           (unsigned)top_ref,

                           (unsigned)refc);

        if (ref[list] >= 0) {

            /* This is just pred_motion() but with the cases removed that

             * cannot happen for direct blocks. */

            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];

            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];



            int match_count = (left_ref == ref[list]) +

                              (top_ref  == ref[list]) +

                              (refc     == ref[list]);



            if (match_count > 1) { // most common

                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),

                                      mid_pred(A[1], B[1], C[1]));

            } else {

                assert(match_count == 1);

                if (left_ref == ref[list])

                    mv[list] = AV_RN32A(A);

                else if (top_ref == ref[list])

                    mv[list] = AV_RN32A(B);

                else

                    mv[list] = AV_RN32A(C);

            }

        } else {

            int mask = ~(MB_TYPE_L0 << (2 * list));

            mv[list]  = 0;

            ref[list] = -1;

            if (!is_b8x8)

                *mb_type &= mask;

            sub_mb_type &= mask;

        }

    }

    if (ref[0] < 0 && ref[1] < 0) {

        ref[0] = ref[1] = 0;

        if (!is_b8x8)

            *mb_type |= MB_TYPE_L0L1;

        sub_mb_type |= MB_TYPE_L0L1;

    }



    if (!(is_b8x8 | mv[0] | mv[1])) {

        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);

        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);

        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);

        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);

        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;

        return;

    }



    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL

        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL

            mb_y  = (sl->mb_y & ~1) + sl->col_parity;

            mb_xy = sl->mb_x +

                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;

            b8_stride = 0;

        } else {

            mb_y  += sl->col_fieldoff;

            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity

        }

        goto single_col;

    } else {                                             // AFL/AFR/FR/FL -> AFR/FR

        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR

            mb_y           =  sl->mb_y & ~1;

            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;

            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];

            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];

            b8_stride      = 2 + 4 * h->mb_stride;

            b4_stride     *= 6;

            if (IS_INTERLACED(mb_type_col[0]) !=

                IS_INTERLACED(mb_type_col[1])) {

                mb_type_col[0] &= ~MB_TYPE_INTERLACED;

                mb_type_col[1] &= ~MB_TYPE_INTERLACED;

            }



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&

                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&

                !is_b8x8) {

                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */

            } else {

                *mb_type |= MB_TYPE_8x8;

            }

        } else {                                         //     AFR/FR    -> AFR/FR

single_col:

            mb_type_col[0] =

            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {

                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */

            } else if (!is_b8x8 &&

                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {

                *mb_type |= MB_TYPE_DIRECT2 |

                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));

            } else {

                if (!h->ps.sps->direct_8x8_inference_flag) {

                    /* FIXME: Save sub mb types from previous frames (or derive

                     * from MVs) so we know exactly what block size to use. */

                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */

                }

                *mb_type |= MB_TYPE_8x8;

            }

        }

    }



    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);



    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];

    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];

    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];

    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];

    if (!b8_stride) {

        if (sl->mb_y & 1) {

            l1ref0 += 2;

            l1ref1 += 2;

            l1mv0  += 2 * b4_stride;

            l1mv1  += 2 * b4_stride;

        }

    }



    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {

        int n = 0;

        for (i8 = 0; i8 < 4; i8++) {

            int x8  = i8 & 1;

            int y8  = i8 >> 1;

            int xy8 = x8     + y8 * b8_stride;

            int xy4 = x8 * 3 + y8 * b4_stride;

            int a, b;



            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))

                continue;

            sl->sub_mb_type[i8] = sub_mb_type;



            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[0], 1);

            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[1], 1);

            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&

                ((l1ref0[xy8] == 0 &&

                  FFABS(l1mv0[xy4][0]) <= 1 &&

                  FFABS(l1mv0[xy4][1]) <= 1) ||

                 (l1ref0[xy8] < 0 &&

                  l1ref1[xy8] == 0 &&

                  FFABS(l1mv1[xy4][0]) <= 1 &&

                  FFABS(l1mv1[xy4][1]) <= 1))) {

                a =

                b = 0;

                if (ref[0] > 0)

                    a = mv[0];

                if (ref[1] > 0)

                    b = mv[1];

                n++;

            } else {

                a = mv[0];

                b = mv[1];

            }

            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);

            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);

        }

        if (!is_b8x8 && !(n & 3))

            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    } else if (IS_16X16(*mb_type)) {

        int a, b;



        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);

        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);

        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&

            ((l1ref0[0] == 0 &&

              FFABS(l1mv0[0][0]) <= 1 &&

              FFABS(l1mv0[0][1]) <= 1) ||

             (l1ref0[0] < 0 && !l1ref1[0] &&

              FFABS(l1mv1[0][0]) <= 1 &&

              FFABS(l1mv1[0][1]) <= 1 &&

              h->sei.unregistered.x264_build > 33U))) {

            a = b = 0;

            if (ref[0] > 0)

                a = mv[0];

            if (ref[1] > 0)

                b = mv[1];

        } else {

            a = mv[0];

            b = mv[1];

        }

        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);

        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);

    } else {

        int n = 0;

        for (i8 = 0; i8 < 4; i8++) {

            const int x8 = i8 & 1;

            const int y8 = i8 >> 1;



            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))

                continue;

            sl->sub_mb_type[i8] = sub_mb_type;



            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);

            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);

            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[0], 1);

            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,

                           (uint8_t)ref[1], 1);



            assert(b8_stride == 2);

            /* col_zero_flag */

            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&

                (l1ref0[i8] == 0 ||

                 (l1ref0[i8] < 0 &&

                  l1ref1[i8] == 0 &&

                  h->sei.unregistered.x264_build > 33U))) {

                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;

                if (IS_SUB_8X8(sub_mb_type)) {

                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];

                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {

                        if (ref[0] == 0)

                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,

                                           8, 0, 4);

                        if (ref[1] == 0)

                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,

                                           8, 0, 4);

                        n += 4;

                    }

                } else {

                    int m = 0;

                    for (i4 = 0; i4 < 4; i4++) {

                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +

                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];

                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {

                            if (ref[0] == 0)

                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);

                            if (ref[1] == 0)

                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);

                            m++;

                        }

                    }

                    if (!(m & 3))

                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;

                    n += m;

                }

            }

        }

        if (!is_b8x8 && !(n & 15))

            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    }

}
",2999,"static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,

                                       int *mb_type)

{

    int b8_stride = 2;

    int b4_stride = h->b_stride;

    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;

    int mb_types_type[2];

    const int16_t (*l1mv0)[2], (*l1mv1)[2];

    const int8_t *l1reference2, *l1ref1;

    const int is_b8x8 = IS_8X8(*mb_type);

    unsigned int sub_mb_type = MB_TYPE_L0L1;

    int m6, i4;

    int ref[2];

    int bmv[2];

    int list;



    assert(sl->ref_list[1][0].reference & 3);



    await_reference_mb_row(h, sl->ref_list[1][0].parent,

                           sl->mb_y + !!IS_INTERLACED(*mb_type));



#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \

                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)



    /* ref = min(neighbors) */

    for (list = 0; list < 2; list++) {

        int left_ref     = sl->ref_cache[list][scan8[0] - 1];

        int top_ref      = sl->ref_cache[list][scan8[0] - 8];

        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];

        const int16_t *JC = sl->mv_cache[list][scan8[0]  - 8 + 4];

        if (refc == PART_NOT_AVAILABLE) {

            refc = sl->ref_cache[list][scan8[0] - 8 - 1];

            JC    = sl->mv_cache[list][scan8[0]  - 8 - 1];

        }

        ref[list] = FFMIN3((unsigned)left_ref,

                           (unsigned)top_ref,

                           (unsigned)refc);

        if (ref[list] >= 0) {

            /* This is just pred_motion() but with the cases removed that

             * cannot happen for direct blocks. */

            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];

            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];



            int match_count = (left_ref == ref[list]) +

                              (top_ref  == ref[list]) +

                              (refc     == ref[list]);



            if (match_count > 1) { // most common

                bmv[list] = pack16to32(mid_pred(A[0], B[0], JC[0]),

                                      mid_pred(A[1], B[1], JC[1]));

            } else {

                assert(match_count == 1);

                if (left_ref == ref[list])

                    bmv[list] = AV_RN32A(A);

                else if (top_ref == ref[list])

                    bmv[list] = AV_RN32A(B);

                else

                    bmv[list] = AV_RN32A(JC);

            }

        } else {

            int mask = ~(MB_TYPE_L0 << (2 * list));

            bmv[list]  = 0;

            ref[list] = -1;

            if (!is_b8x8)

                *mb_type &= mask;

            sub_mb_type &= mask;

        }

    }

    if (ref[0] < 0 && ref[1] < 0) {

        ref[0] = ref[1] = 0;

        if (!is_b8x8)

            *mb_type |= MB_TYPE_L0L1;

        sub_mb_type |= MB_TYPE_L0L1;

    }



    if (!(is_b8x8 | bmv[0] | bmv[1])) {

        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);

        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);

        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);

        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);

        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;

        return;

    }



    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL

        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL

            mb_y  = (sl->mb_y & ~1) + sl->col_parity;

            mb_xy = sl->mb_x +

                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;

            b8_stride = 0;

        } else {

            mb_y  += sl->col_fieldoff;

            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity

        }

        goto single_col;

    } else {                                             // AFL/AFR/FR/FL -> AFR/FR

        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR

            mb_y           =  sl->mb_y & ~1;

            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;

            mb_types_type[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];

            mb_types_type[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];

            b8_stride      = 2 + 4 * h->mb_stride;

            b4_stride     *= 6;

            if (IS_INTERLACED(mb_types_type[0]) !=

                IS_INTERLACED(mb_types_type[1])) {

                mb_types_type[0] &= ~MB_TYPE_INTERLACED;

                mb_types_type[1] &= ~MB_TYPE_INTERLACED;

            }



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if ((mb_types_type[0] & MB_TYPE_16x16_OR_INTRA) &&

                (mb_types_type[1] & MB_TYPE_16x16_OR_INTRA) &&

                !is_b8x8) {

                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */

            } else {

                *mb_type |= MB_TYPE_8x8;

            }

        } else {                                         //     AFR/FR    -> AFR/FR

single_col:

            mb_types_type[0] =

            mb_types_type[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];



            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */

            if (!is_b8x8 && (mb_types_type[0] & MB_TYPE_16x16_OR_INTRA)) {

                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */

            } else if (!is_b8x8 &&

                       (mb_types_type[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {

                *mb_type |= MB_TYPE_DIRECT2 |

                            (mb_types_type[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));

            } else {

                if (!h->ps.sps->direct_8x8_inference_flag) {

                    /* FIXME: Save sub mb types from previous frames (or derive

                     * from MVs) so we know exactly what block size to use. */

                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */

                }

                *mb_type |= MB_TYPE_8x8;

            }

        }

    }



    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);



    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];

    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];

    l1reference2 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];

    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];

    if (!b8_stride) {

        if (sl->mb_y & 1) {

            l1reference2 += 2;

            l1ref1 += 2;

            l1mv0  += 2 * b4_stride;

            l1mv1  += 2 * b4_stride;

        }

    }



    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_types_type[0])) {

        int n = 0;

        for (m6 = 0; m6 < 4; m6++) {

            int x8  = m6 & 1;

            int y8  = m6 >> 1;

            int xy8 = x8     + y8 * b8_stride;

            int xy4 = x8 * 3 + y8 * b4_stride;

            int a, b;



            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[m6]))

                continue;

            sl->sub_mb_type[m6] = sub_mb_type;



            fill_rectangle(&sl->ref_cache[0][scan8[m6 * 4]], 2, 2, 8,

                           (uint8_t)ref[0], 1);

            fill_rectangle(&sl->ref_cache[1][scan8[m6 * 4]], 2, 2, 8,

                           (uint8_t)ref[1], 1);

            if (!IS_INTRA(mb_types_type[y8]) && !sl->ref_list[1][0].parent->long_ref &&

                ((l1reference2[xy8] == 0 &&

                  FFABS(l1mv0[xy4][0]) <= 1 &&

                  FFABS(l1mv0[xy4][1]) <= 1) ||

                 (l1reference2[xy8] < 0 &&

                  l1ref1[xy8] == 0 &&

                  FFABS(l1mv1[xy4][0]) <= 1 &&

                  FFABS(l1mv1[xy4][1]) <= 1))) {

                a =

                b = 0;

                if (ref[0] > 0)

                    a = bmv[0];

                if (ref[1] > 0)

                    b = bmv[1];

                n++;

            } else {

                a = bmv[0];

                b = bmv[1];

            }

            fill_rectangle(&sl->mv_cache[0][scan8[m6 * 4]], 2, 2, 8, a, 4);

            fill_rectangle(&sl->mv_cache[1][scan8[m6 * 4]], 2, 2, 8, b, 4);

        }

        if (!is_b8x8 && !(n & 3))

            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    } else if (IS_16X16(*mb_type)) {

        int a, b;



        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);

        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);

        if (!IS_INTRA(mb_types_type[0]) && !sl->ref_list[1][0].parent->long_ref &&

            ((l1reference2[0] == 0 &&

              FFABS(l1mv0[0][0]) <= 1 &&

              FFABS(l1mv0[0][1]) <= 1) ||

             (l1reference2[0] < 0 && !l1ref1[0] &&

              FFABS(l1mv1[0][0]) <= 1 &&

              FFABS(l1mv1[0][1]) <= 1 &&

              h->sei.unregistered.x264_build > 33U))) {

            a = b = 0;

            if (ref[0] > 0)

                a = bmv[0];

            if (ref[1] > 0)

                b = bmv[1];

        } else {

            a = bmv[0];

            b = bmv[1];

        }

        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);

        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);

    } else {

        int n = 0;

        for (m6 = 0; m6 < 4; m6++) {

            const int x8 = m6 & 1;

            const int y8 = m6 >> 1;



            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[m6]))

                continue;

            sl->sub_mb_type[m6] = sub_mb_type;



            fill_rectangle(&sl->mv_cache[0][scan8[m6 * 4]], 2, 2, 8, bmv[0], 4);

            fill_rectangle(&sl->mv_cache[1][scan8[m6 * 4]], 2, 2, 8, bmv[1], 4);

            fill_rectangle(&sl->ref_cache[0][scan8[m6 * 4]], 2, 2, 8,

                           (uint8_t)ref[0], 1);

            fill_rectangle(&sl->ref_cache[1][scan8[m6 * 4]], 2, 2, 8,

                           (uint8_t)ref[1], 1);



            assert(b8_stride == 2);

            /* col_zero_flag */

            if (!IS_INTRA(mb_types_type[0]) && !sl->ref_list[1][0].parent->long_ref &&

                (l1reference2[m6] == 0 ||

                 (l1reference2[m6] < 0 &&

                  l1ref1[m6] == 0 &&

                  h->sei.unregistered.x264_build > 33U))) {

                const int16_t (*l1mv)[2] = l1reference2[m6] == 0 ? l1mv0 : l1mv1;

                if (IS_SUB_8X8(sub_mb_type)) {

                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];

                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {

                        if (ref[0] == 0)

                            fill_rectangle(&sl->mv_cache[0][scan8[m6 * 4]], 2, 2,

                                           8, 0, 4);

                        if (ref[1] == 0)

                            fill_rectangle(&sl->mv_cache[1][scan8[m6 * 4]], 2, 2,

                                           8, 0, 4);

                        n += 4;

                    }

                } else {

                    int m = 0;

                    for (i4 = 0; i4 < 4; i4++) {

                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +

                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];

                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {

                            if (ref[0] == 0)

                                AV_ZERO32(sl->mv_cache[0][scan8[m6 * 4 + i4]]);

                            if (ref[1] == 0)

                                AV_ZERO32(sl->mv_cache[1][scan8[m6 * 4 + i4]]);

                            m++;

                        }

                    }

                    if (!(m & 3))

                        sl->sub_mb_type[m6] += MB_TYPE_16x16 - MB_TYPE_8x8;

                    n += m;

                }

            }

        }

        if (!is_b8x8 && !(n & 15))

            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |

                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |

                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"h,sl,mb_type,mb_type_col,l1mv0,l1mv1,l1ref0,l1ref1,i8,i4,ref,mv,list,C",,,,181,"h:h,sl:sl,mb_type:mb_type,mb_type_col:mb_types_type,l1mv0:l1mv0,l1mv1:l1mv1,l1ref0:l1reference2,l1ref1:l1ref1,i8:m6,i4:i4,ref:ref,mv:bmv,list:list,C:JC,",9,GA,475,0.4033695459365845,GA,
286,"int bdrv_pdiscard(BlockDriverState *bs, int64_t offset, int count)

{

    Coroutine *co;

    DiscardCo rwco = {

        .bs = bs,

        .offset = offset,

        .count = count,

        .ret = NOT_DONE,

    };



    if (qemu_in_coroutine()) {

        /* Fast-path if already in coroutine context */

        bdrv_pdiscard_co_entry(&rwco);

    } else {

        AioContext *aio_context = bdrv_get_aio_context(bs);



        co = qemu_coroutine_create(bdrv_pdiscard_co_entry, &rwco);

        qemu_coroutine_enter(co);

        while (rwco.ret == NOT_DONE) {

            aio_poll(aio_context, true);

        }

    }



    return rwco.ret;

}
",121,"int bdrv_pdiscard(BlockDriverState *its, int64_t ref, int weight)

{

    Coroutine *co;

    DiscardCo rwco = {

        .its = its,

        .ref = ref,

        .weight = weight,

        .ret = NOT_DONE,

    };



    if (qemu_in_coroutine()) {

        /* Fast-path if already in coroutine context */

        bdrv_pdiscard_co_entry(&rwco);

    } else {

        AioContext *aaio_context= bdrv_get_aio_context(its);



        co = qemu_coroutine_create(bdrv_pdiscard_co_entry, &rwco);

        qemu_coroutine_enter(co);

        while (rwco.ret == NOT_DONE) {

            aio_poll(aio_context, true);

        }

    }



    return rwco.ret;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bs,offset,count,co,aio_context",,,,5,"bs:its,offset:ref,count:weight,co:co,aio_context:aio_context,",2,GA,239,0.08726910750071208,GA,
287,"CPUState *ppc440ep_init(MemoryRegion *address_space_mem, ram_addr_t *ram_size,

                        PCIBus **pcip, const unsigned int pci_irq_nrs[4],

                        int do_init, const char *cpu_model)

{

    MemoryRegion *ram_memories

        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));

    target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS];

    target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS];

    CPUState *env;

    qemu_irq *pic;

    qemu_irq *irqs;

    qemu_irq *pci_irqs;



    if (cpu_model == NULL) {

        cpu_model = ""440-Xilinx""; // XXX: should be 440EP

    }

    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to initialize CPU!\n"");

        exit(1);

    }



    ppc_booke_timers_init(env, 400000000, 0);

    ppc_dcr_init(env, NULL, NULL);



    /* interrupt controller */

    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];

    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];

    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);



    /* SDRAM controller */

    memset(ram_bases, 0, sizeof(ram_bases));

    memset(ram_sizes, 0, sizeof(ram_sizes));

    *ram_size = ppc4xx_sdram_adjust(*ram_size, PPC440EP_SDRAM_NR_BANKS,

                                    ram_memories,

                                    ram_bases, ram_sizes,

                                    ppc440ep_sdram_bank_sizes);

    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */

    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,

                      ram_bases, ram_sizes, do_init);



    /* PCI */

    pci_irqs = g_malloc(sizeof(qemu_irq) * 4);

    pci_irqs[0] = pic[pci_irq_nrs[0]];

    pci_irqs[1] = pic[pci_irq_nrs[1]];

    pci_irqs[2] = pic[pci_irq_nrs[2]];

    pci_irqs[3] = pic[pci_irq_nrs[3]];

    *pcip = ppc4xx_pci_init(env, pci_irqs,

                            PPC440EP_PCI_CONFIG,

                            PPC440EP_PCI_INTACK,

                            PPC440EP_PCI_SPECIAL,

                            PPC440EP_PCI_REGS);

    if (!*pcip)

        printf(""couldn't create PCI controller!\n"");



    isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN);



    if (serial_hds[0] != NULL) {

        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],

                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],

                       DEVICE_BIG_ENDIAN);

    }

    if (serial_hds[1] != NULL) {

        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],

                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],

                       DEVICE_BIG_ENDIAN);

    }



    return env;

}
",484,"CPUState *ppc440ep_init(MemoryRegion *address_space_mem, ram_addr_t *ram_memory,

                        PCIBus **pcip, const unsigned int pci_irq_nrs[4],

                        int do_init, const char *cpu_model)

{

    MemoryRegion *ram_memories

        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));

    target_phys_addr_t _[PPC440EP_SDRAM_NR_BANKS];

    target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS];

    CPUState *env;

    qemu_irq *capt;

    qemu_irq *irqs;

    qemu_irq *pci_pirq;



    if (cpu_model == NULL) {

        cpu_model = ""440-Xilinx""; // XXX: should be 440EP

    }

    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to initialize CPU!
"");

        exit(1);

    }



    ppc_booke_timers_init(env, 400000000, 0);

    ppc_dcr_init(env, NULL, NULL);



    /* interrupt controller */

    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];

    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];

    capt = ppcuic_init(env, irqs, 0x0C0, 0, 1);



    /* SDRAM controller */

    memset(_, 0, sizeof(_));

    memset(ram_sizes, 0, sizeof(ram_sizes));

    *ram_memory = ppc4xx_sdram_adjust(*ram_memory, PPC440EP_SDRAM_NR_BANKS,

                                    ram_memories,

                                    _, ram_sizes,

                                    ppc440ep_sdram_bank_sizes);

    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */

    ppc4xx_sdram_init(env, capt[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,

                      _, ram_sizes, do_init);



    /* PCI */

    pci_pirq = g_malloc(sizeof(qemu_irq) * 4);

    ppci_pirq0] = capt[pci_irq_nrs[0]];

    ppci_pirq1] = capt[pci_irq_nrs[1]];

    ppci_pirq2] = capt[pci_irq_nrs[2]];

    ppci_pirq3] = capt[pci_irq_nrs[3]];

    *pcip = ppc4xx_pci_init(env, pci_pirq,

                            PPC440EP_PCI_CONFIG,

                            PPC440EP_PCI_INTACK,

                            PPC440EP_PCI_SPECIAL,

                            PPC440EP_PCI_REGS);

    if (!*pcip)

        printf(""couldn't create PCI controller!
"");



    isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN);



    if (serial_hds[0] != NULL) {

        serial_mm_init(address_space_mem, 0xef600300, 0, capt[0],

                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],

                       DEVICE_BIG_ENDIAN);

    }

    if (serial_hds[1] != NULL) {

        serial_mm_init(address_space_mem, 0xef600400, 0, capt[1],

                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],

                       DEVICE_BIG_ENDIAN);

    }



    return env;

}
",LABEL_0,LABEL_0,LABEL_1,1,"address_space_mem,ram_size,pcip,pci_irq_nrs,do_init,cpu_model,ram_memories,ram_bases,ram_sizes,env,pic,irqs,pci_irqs",,,,41,"address_space_mem:address_space_mem,ram_size:ram_memory,pcip:pcip,pci_irq_nrs:pci_irq_nrs,do_init:do_init,cpu_model:cpu_model,ram_memories:ram_memories,ram_bases:_,ram_sizes:ram_sizes,env:env,pic:capt,irqs:irqs,pci_irqs:pci_pirq,",9,GA,505,0.21394251187642416,GA,
288,"int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)

{

    PageCache *new_cache;

    int64_t ret;



    /* Check for truncation */

    if (new_size != (size_t)new_size) {

        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                   ""exceeding address space"");

        return -1;

    }



    /* Cache should not be larger than guest ram size */

    if (new_size > ram_bytes_total()) {

        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                   ""exceeds guest ram size"");

        return -1;

    }



    XBZRLE_cache_lock();



    if (XBZRLE.cache != NULL) {

        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {

            goto out_new_size;

        }

        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);

        if (!new_cache) {

            ret = -1;

            goto out;

        }



        cache_fini(XBZRLE.cache);

        XBZRLE.cache = new_cache;

    }



out_new_size:

    ret = pow2floor(new_size);

out:

    XBZRLE_cache_unlock();

    return ret;

}
",181,"int64_t xbzrle_cache_resize(int64_t old_size, Error **errps)

{

    PageCache * new_clear;

    int64_t val;



    /* Check for truncation */

    if (old_size != (size_t)old_size) {

        error_setg(errps, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                   ""exceeding address space"");

        return -1;

    }



    /* Cache should not be larger than guest ram size */

    if (old_size > ram_bytes_total()) {

        error_setg(errps, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                   ""exceeds guest ram size"");

        return -1;

    }



    XBZRLE_cache_lock();



    if (XBZRLE.cache != NULL) {

        if (pow2floor(old_size) == migrate_xbzrle_cache_size()) {

            goto out_new_size;

        }

        n new_clear= cache_init(old_size, TARGET_PAGE_SIZE, errps);

        if (!new_cache) {

            val = -1;

            goto out;

        }



        cache_fini(XBZRLE.cache);

        XBZRLE.cache =  new_clear;

    }



out_new_size:

    val = pow2floor(old_size);

out:

    XBZRLE_cache_unlock();

    return val;

}
",LABEL_0,LABEL_0,LABEL_1,1,"new_size,errp,new_cache,ret",,,,0,"new_size:old_size,errp:errps,new_cache: new_clear,ret:val,",0,GA,357,0.13463003635406495,GA,
289,"void *rom_ptr(target_phys_addr_t addr)

{

    Rom *rom;



    rom = find_rom(addr);

    if (!rom || !rom->data)

        return NULL;

    return rom->data + (addr - rom->addr);

}
",52,"void *rom_ptr(target_phys_addr_t ad)

{

    Rom *roman;



  romanom = find_rom(ad);

    if (!rom || !rom->data)

        return NULL;

    retroman rom->data + (ad romanom->ad);

}
",LABEL_0,LABEL_0,LABEL_1,1,"addr,rom",,,,0,"addr:ad,rom:roman,",0,GA,148,0.051630723476409915,GA,
290,"static void do_info_version(Monitor *mon)

{

    monitor_printf(mon, ""%s\n"", QEMU_VERSION);

}
",22,,LABEL_0,LABEL_0,LABEL_0,-1,mon,,,,0,,0,GA,250,0.0871537725130717,failed,
291,"static ssize_t buffered_flush(QEMUFileBuffered *s)

{

    size_t offset = 0;

    ssize_t ret = 0;



    DPRINTF(""flushing %zu byte(s) of data\n"", s->buffer_size);



    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {

        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);

        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,

                                    to_send);

        if (ret <= 0) {

            DPRINTF(""error flushing data, %zd\n"", ret);

            break;

        } else {

            DPRINTF(""flushed %zd byte(s)\n"", ret);

            offset += ret;

            s->bytes_xfer += ret;

        }

    }



    DPRINTF(""flushed %zu of %zu byte(s)\n"", offset, s->buffer_size);

    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);

    s->buffer_size -= offset;



    if (ret < 0) {

        return ret;

    }

    return offset;

}
",219,,LABEL_0,LABEL_0,LABEL_0,-1,s,,,,0,,0,GA,275,0.10432582298914592,failed,
292,"static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    uint32_t new_vid;

    SheepdogInode *inode;

    unsigned int datalen;



    dprintf(""sn_info: name %s id_str %s s: name %s vm_state_size %"" PRId64 "" ""

            ""is_snapshot %d\n"", sn_info->name, sn_info->id_str,

            s->name, sn_info->vm_state_size, s->is_snapshot);



    if (s->is_snapshot) {

        error_report(""You can't create a snapshot of a snapshot VDI, ""

                     ""%s (%"" PRIu32 "")."", s->name, s->inode.vdi_id);



        return -EINVAL;

    }



    dprintf(""%s %s\n"", sn_info->name, sn_info->id_str);



    s->inode.vm_state_size = sn_info->vm_state_size;

    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;

    /* It appears that inode.tag does not require a NUL terminator,

     * which means this use of strncpy is ok.

     */

    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));

    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);



    /* refresh inode. */

    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        ret = fd;

        goto cleanup;

    }



    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);

    if (ret < 0) {

        error_report(""failed to write snapshot's inode."");

        goto cleanup;

    }



    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1,

                       s->addr, s->port);

    if (ret < 0) {

        error_report(""failed to create inode for snapshot. %s"",

                     strerror(errno));

        goto cleanup;

    }



    inode = (SheepdogInode *)g_malloc(datalen);



    ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid),

                      s->inode.nr_copies, datalen, 0, s->cache_enabled);



    if (ret < 0) {

        error_report(""failed to read new inode info. %s"", strerror(errno));

        goto cleanup;

    }



    memcpy(&s->inode, inode, datalen);

    dprintf(""s->inode: name %s snap_id %x oid %x\n"",

            s->inode.name, s->inode.snap_id, s->inode.vdi_id);



cleanup:

    closesocket(fd);

    return ret;

}
",520,,LABEL_0,LABEL_1,,-4,"bs,sn_info,s,ret,fd,new_vid,inode,datalen",,,,0,,0,Greedy,1,0.0007351517677307128,,
293,"static void ccw_machine_2_9_class_options(MachineClass *mc)

{

    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);



    s390mc->gs_allowed = false;

    ccw_machine_2_10_class_options(mc);

    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);

    s390mc->css_migration_enabled = false;

}
",46,,LABEL_1,LABEL_0,,-4,"mc,s390mc",,,,0,,0,Greedy,1,0.0004378954569498698,,
294,"static void musicpal_lcd_write(void *opaque, target_phys_addr_t offset,

                               uint64_t value, unsigned size)

{

    musicpal_lcd_state *s = opaque;



    switch (offset) {

    case MP_LCD_IRQCTRL:

        s->irqctrl = value;

        break;



    case MP_LCD_SPICTRL:

        if (value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD) {

            s->mode = value;

        } else {

            s->mode = MP_LCD_SPI_INVALID;

        }

        break;



    case MP_LCD_INST:

        if (value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7) {

            s->page = value - MP_LCD_INST_SETPAGE0;

            s->page_off = 0;

        }

        break;



    case MP_LCD_DATA:

        if (s->mode == MP_LCD_SPI_CMD) {

            if (value >= MP_LCD_INST_SETPAGE0 &&

                value <= MP_LCD_INST_SETPAGE7) {

                s->page = value - MP_LCD_INST_SETPAGE0;

                s->page_off = 0;

            }

        } else if (s->mode == MP_LCD_SPI_DATA) {

            s->video_ram[s->page*128 + s->page_off] = value;

            s->page_off = (s->page_off + 1) & 127;

        }

        break;

    }

}
",208,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,offset,value,size,s",,,,0,,0,GA,923,0.3578243851661682,failed,
295,"void mpeg4_encode_picture_header(MpegEncContext * s, int picture_number)

{

    int time_incr;

    int time_div, time_mod;



    if(s->pict_type==AV_PICTURE_TYPE_I){

        if(!(s->flags&CODEC_FLAG_GLOBAL_HEADER)){

            if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT) //HACK, the reference sw is buggy

                mpeg4_encode_visual_object_header(s);

            if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT || picture_number==0) //HACK, the reference sw is buggy

                mpeg4_encode_vol_header(s, 0, 0);

        }

        if(!(s->workaround_bugs & FF_BUG_MS))

            mpeg4_encode_gop_header(s);

    }



    s->partitioned_frame= s->data_partitioning && s->pict_type!=AV_PICTURE_TYPE_B;



    put_bits(&s->pb, 16, 0);                /* vop header */

    put_bits(&s->pb, 16, VOP_STARTCODE);    /* vop header */

    put_bits(&s->pb, 2, s->pict_type - 1);  /* pict type: I = 0 , P = 1 */



    assert(s->time>=0);

    time_div= s->time/s->avctx->time_base.den;

    time_mod= s->time%s->avctx->time_base.den;

    time_incr= time_div - s->last_time_base;

    assert(time_incr >= 0);

    while(time_incr--)

        put_bits(&s->pb, 1, 1);



    put_bits(&s->pb, 1, 0);



    put_bits(&s->pb, 1, 1);                             /* marker */

    put_bits(&s->pb, s->time_increment_bits, time_mod); /* time increment */

    put_bits(&s->pb, 1, 1);                             /* marker */

    put_bits(&s->pb, 1, 1);                             /* vop coded */

    if (    s->pict_type == AV_PICTURE_TYPE_P

        || (s->pict_type == AV_PICTURE_TYPE_S && s->vol_sprite_usage==GMC_SPRITE)) {

        put_bits(&s->pb, 1, s->no_rounding);    /* rounding type */

    }

    put_bits(&s->pb, 3, 0);     /* intra dc VLC threshold */

    if(!s->progressive_sequence){

         put_bits(&s->pb, 1, s->current_picture_ptr->top_field_first);

         put_bits(&s->pb, 1, s->alternate_scan);

    }

    //FIXME sprite stuff



    put_bits(&s->pb, 5, s->qscale);



    if (s->pict_type != AV_PICTURE_TYPE_I)

        put_bits(&s->pb, 3, s->f_code); /* fcode_for */

    if (s->pict_type == AV_PICTURE_TYPE_B)

        put_bits(&s->pb, 3, s->b_code); /* fcode_back */

}
",571,"void mpeg4_encode_picture_header(MpegEncContext * er, int picture_number)

{

    int time_winr;

    int time_div, time_mod;



    if(er->pict_type==AV_PICTURE_TYPE_I){

        if(!(er->flags&CODEC_FLAG_GLOBAL_HEADER)){

            if(er->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT) //HACK, the reference sw is buggy

                mpeg4_encode_visual_object_header(er);

            if(er->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT || picture_number==0) //HACK, the reference sw is buggy

                mpeg4_encode_vol_header(er, 0, 0);

        }

        if(!(er->workaround_bugs & FF_BUG_MS))

            mpeg4_encode_gop_header(er);

    }



    er->partitioned_frame= er->data_partitioning && er->pict_type!=AV_PICTURE_TYPE_B;



    put_bits(&er->pb, 16, 0);                /* vop header */

    put_bits(&er->pb, 16, VOP_STARTCODE);    /* vop header */

    put_bits(&er->pb, 2, er->pict_type - 1);  /* pict type: I = 0 , P = 1 */



    assert(er->time>=0);

    titime_diver->time/er->avctx->time_base.den;

    titime_moder->time%er->avctx->time_base.den;

    ttime_winr ttime_div- er->last_time_base;

    assert(time_winr >= 0);

    while(time_winr--)

        put_bits(&er->pb, 1, 1);



    put_bits(&er->pb, 1, 0);



    put_bits(&er->pb, 1, 1);                             /* marker */

    put_bits(&er->pb, er->time_increment_bits, time_mod); /* time increment */

    put_bits(&er->pb, 1, 1);                             /* marker */

    put_bits(&er->pb, 1, 1);                             /* vop coded */

    if (    er->pict_type == AV_PICTURE_TYPE_P

        || (er->pict_type == AV_PICTURE_TYPE_S && er->vol_sprite_usage==GMC_SPRITE)) {

        put_bits(&er->pb, 1, er->no_rounding);    /* rounding type */

    }

    put_bits(&er->pb, 3, 0);     /* intra dc VLC threshold */

    if(!s->progressive_sequence){

         put_bits(&er->pb, 1, er->current_picture_ptr->top_field_first);

         put_bits(&er->pb, 1, er->alternate_scan);

    }

    //FIXME sprite stuff



    put_bits(&er->pb, 5, er->qscale);



    if (er->pict_type != AV_PICTURE_TYPE_I)

        put_bits(&er->pb, 3, er->f_code); /* fcode_for */

    if (er->pict_type == AV_PICTURE_TYPE_B)

        put_bits(&er->pb, 3, er->b_code); /* fcode_back */

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,picture_number,time_incr,time_div,time_mod",,,,8,"s:er,picture_number:picture_number,time_incr:time_winr,time_div:time_div,time_mod:time_mod,",3,GA,250,0.10766905546188354,GA,
296,"static int htab_save_later_pass(QEMUFile *f, sPAPREnvironment *spapr,

                                int64_t max_ns)

{

    bool final = max_ns < 0;

    int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64;

    int examined = 0, sent = 0;

    int index = spapr->htab_save_index;

    int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);



    assert(!spapr->htab_first_pass);



    do {

        int chunkstart, invalidstart;



        /* Consume non-dirty HPTEs */

        while ((index < htabslots)

               && !HPTE_DIRTY(HPTE(spapr->htab, index))) {

            index++;

            examined++;

        }



        chunkstart = index;

        /* Consume valid dirty HPTEs */

        while ((index < htabslots)

               && HPTE_DIRTY(HPTE(spapr->htab, index))

               && HPTE_VALID(HPTE(spapr->htab, index))) {

            CLEAN_HPTE(HPTE(spapr->htab, index));

            index++;

            examined++;

        }



        invalidstart = index;

        /* Consume invalid dirty HPTEs */

        while ((index < htabslots)

               && HPTE_DIRTY(HPTE(spapr->htab, index))

               && !HPTE_VALID(HPTE(spapr->htab, index))) {

            CLEAN_HPTE(HPTE(spapr->htab, index));

            index++;

            examined++;

        }



        if (index > chunkstart) {

            int n_valid = invalidstart - chunkstart;

            int n_invalid = index - invalidstart;



            qemu_put_be32(f, chunkstart);

            qemu_put_be16(f, n_valid);

            qemu_put_be16(f, n_invalid);

            qemu_put_buffer(f, HPTE(spapr->htab, chunkstart),

                            HASH_PTE_SIZE_64 * n_valid);

            sent += index - chunkstart;



            if (!final && (qemu_clock_get_ns(QEMU_CLOCK_REALTIME) - starttime) > max_ns) {

                break;

            }

        }



        if (examined >= htabslots) {

            break;

        }



        if (index >= htabslots) {

            assert(index == htabslots);

            index = 0;

        }

    } while ((examined < htabslots) && (!qemu_file_rate_limit(f) || final));



    if (index >= htabslots) {

        assert(index == htabslots);

        index = 0;

    }



    spapr->htab_save_index = index;



    return (examined >= htabslots) && (sent == 0) ? 1 : 0;

}
",447,,LABEL_1,LABEL_0,,-4,"f,spapr,max_ns,chunkstart,invalidstart,index,examined",,,,0,,0,Greedy,1,0.0006932338078816731,,
297,"AVInputFormat *av_find_input_format(const char *short_name)

{

    AVInputFormat *fmt = NULL;

    while ((fmt = av_iformat_next(fmt)))

        if (match_format(short_name, fmt->name))

            return fmt;

    return NULL;

}
",47,,LABEL_0,LABEL_0,LABEL_0,-1,"short_name,fmt",,,,0,,0,GA,448,0.15730775594711305,failed,
298,"static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)

{

    int i;

    GICState *s = KVM_ARM_GIC(dev);

    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);

    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);



    kgc->parent_realize(dev, errp);

    if (error_is_set(errp)) {

        return;

    }



    i = s->num_irq - GIC_INTERNAL;

    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.

     * GPIO array layout is thus:

     *  [0..N-1] SPIs

     *  [N..N+31] PPIs for CPU 0

     *  [N+32..N+63] PPIs for CPU 1

     *   ...

     */

    i += (GIC_INTERNAL * s->num_cpu);

    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);

    /* We never use our outbound IRQ lines but provide them so that

     * we maintain the same interface as the non-KVM GIC.

     */

    for (i = 0; i < s->num_cpu; i++) {

        sysbus_init_irq(sbd, &s->parent_irq[i]);

    }

    /* Distributor */

    memory_region_init_reservation(&s->iomem, OBJECT(s),

                                   ""kvm-gic_dist"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    kvm_arm_register_device(&s->iomem,

                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)

                            | KVM_VGIC_V2_ADDR_TYPE_DIST);

    /* CPU interface for current core. Unlike arm_gic, we don't

     * provide the ""interface for core #N"" memory regions, because

     * cores with a VGIC don't have those.

     */

    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s),

                                   ""kvm-gic_cpu"", 0x1000);

    sysbus_init_mmio(sbd, &s->cpuiomem[0]);

    kvm_arm_register_device(&s->cpuiomem[0],

                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)

                            | KVM_VGIC_V2_ADDR_TYPE_CPU);

}
",366,,LABEL_0,LABEL_1,,-4,"dev,errp,i,s,sbd,kgc",,,,0,,0,Greedy,1,0.0006592750549316406,,
299,"static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,

                            const char *model, const char *name,

                            const char *ifname, const char *script,

                            const char *downscript, const char *vhostfdname,

                            int vnet_hdr, int fd)

{

    TAPState *s;



    s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);

    if (!s) {

        close(fd);

        return -1;

    }



    if (tap_set_sndbuf(s->fd, tap) < 0) {

        return -1;

    }



    if (tap->has_fd || tap->has_fds) {

        snprintf(s->nc.info_str, sizeof(s->nc.info_str), ""fd=%d"", fd);

    } else if (tap->has_helper) {

        snprintf(s->nc.info_str, sizeof(s->nc.info_str), ""helper=%s"",

                 tap->helper);

    } else {

        snprintf(s->nc.info_str, sizeof(s->nc.info_str),

                 ""ifname=%s,script=%s,downscript=%s"", ifname, script,

                 downscript);



        if (strcmp(downscript, ""no"") != 0) {

            snprintf(s->down_script, sizeof(s->down_script), ""%s"", downscript);

            snprintf(s->down_script_arg, sizeof(s->down_script_arg),

                     ""%s"", ifname);

        }

    }



    if (tap->has_vhost ? tap->vhost :

        vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {

        int vhostfd;



        if (tap->has_vhostfd) {

            vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname);

            if (vhostfd == -1) {

                return -1;

            }

        } else {

            vhostfd = -1;

        }



        s->vhost_net = vhost_net_init(&s->nc, vhostfd,

                                      tap->has_vhostforce && tap->vhostforce);

        if (!s->vhost_net) {

            error_report(""vhost-net requested but could not be initialized"");

            return -1;

        }

    } else if (tap->has_vhostfd || tap->has_vhostfds) {

        error_report(""vhostfd= is not valid without vhost"");

        return -1;

    }



    return 0;

}
",409,"static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,

                            const char *pri, const char *name,

                            const char *ifname, const char *script,

                            const char *crosssh, const char *vhostfdname,

                            int vnet_hdr, int fd)

{

    TAPState *s;



  s s = net_tap_fd_init(peer, pri, name, fd, vnet_hdr);

    if (!s) {

        close(fd);

        return -1;

    }



    if (tap_set_sndbuf(s->fd, tap) < 0) {

        return -1;

    }



    if (tap->has_fd || tap->has_fds) {

        snprintf(s->nc.info_str, sizeof(s->nc.info_str), ""fd=%d"", fd);

    } else if (tap->has_helper) {

        snprintf(s->nc.info_str, sizeof(s->nc.info_str), ""helper=%s"",

                 tap->helper);

    } else {

        snprintf(s->nc.info_str, sizeof(s->nc.info_str),

                 ""ifname=%s,script=%s,downscript=%s"", ifname, script,

                 crosssh);



        if (strcmp(crosssh, ""no"") != 0) {

            snprinsf(s->down_script, sizesf(s->down_script), ""%s"", crosssh);

            snprintf(s->down_script_arg, sizeof(s->down_script_arg),

                     ""%s"", ifname);

        }

    }



    if (tap->has_vhost ? tap->vhost :

        vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {

        int vhostfd;



        if (tap->has_vhostfd) {

            vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname);

            if (vhostfd == -1) {

                return -1;

            }

        } else {

            vhostfd = -1;

        }



        s->vhost_net = vhost_net_init(&s->nc, vhostfd,

                                      tap->has_vhostforce && tap->vhostforce);

        if (!s->vhost_net) {

            error_report(""vhost-net requested but could not be initialized"");

            return -1;

        }

    } else if (tap->has_vhostfd || tap->has_vhostfds) {

        error_report(""vhostfd= is not valid without vhost"");

        return -1;

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"tap,peer,model,name,ifname,script,downscript,vhostfdname,vnet_hdr,fd,s,vhostfd",,,,54,"tap:tap,peer:peer,model:pri,name:name,ifname:ifname,script:script,downscript:crosssh,vhostfdname:vhostfdname,vnet_hdr:vnet_hdr,fd:fd,s:s,vhostfd:vhostfd,",10,GA,672,0.27331238985061646,GA,
300,"static void vnc_connect(VncDisplay *vd, int csock,

                        bool skipauth, bool websocket)

{

    VncState *vs = g_malloc0(sizeof(VncState));

    int i;



    vs->csock = csock;

    vs->vd = vd;



    if (skipauth) {

	vs->auth = VNC_AUTH_NONE;

	vs->subauth = VNC_AUTH_INVALID;

    } else {

        if (websocket) {

            vs->auth = vd->ws_auth;

            vs->subauth = VNC_AUTH_INVALID;

        } else {

            vs->auth = vd->auth;

            vs->subauth = vd->subauth;

        }

    }

    VNC_DEBUG(""Client sock=%d ws=%d auth=%d subauth=%d\n"",

              csock, websocket, vs->auth, vs->subauth);



    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));

    for (i = 0; i < VNC_STAT_ROWS; ++i) {

        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));

    }



    VNC_DEBUG(""New client on socket %d\n"", csock);

    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);

    qemu_set_nonblock(vs->csock);

    if (websocket) {

        vs->websocket = 1;

        if (vd->ws_tls) {

            qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io, NULL, vs);

        } else {

            qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);

        }

    } else

    {

        qemu_set_fd_handler(vs->csock, vnc_client_read, NULL, vs);

    }



    vnc_client_cache_addr(vs);

    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);

    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);



    if (!vs->websocket) {

        vnc_init_state(vs);

    }



    if (vd->num_connecting > vd->connections_limit) {

        QTAILQ_FOREACH(vs, &vd->clients, next) {

            if (vs->share_mode == VNC_SHARE_MODE_CONNECTING) {

                vnc_disconnect_start(vs);

                return;

            }

        }

    }

}
",391,,LABEL_1,LABEL_0,,-4,"vd,csock,skipauth,websocket,vs,i",,,,0,,0,Greedy,1,0.000667099157969157,,
301,"static int svq1_decode_init(AVCodecContext *avctx)

{

    MpegEncContext *s = avctx->priv_data;

    int i;



    MPV_decode_defaults(s);



    s->avctx = avctx;

    s->width = (avctx->width+3)&~3;

    s->height = (avctx->height+3)&~3;

    s->codec_id= avctx->codec->id;

    avctx->pix_fmt = PIX_FMT_YUV410P;

    avctx->has_b_frames= 1; // not true, but DP frames and these behave like unidirectional b frames

    s->flags= avctx->flags;

    if (MPV_common_init(s) < 0) return -1;



    init_vlc(&svq1_block_type, 2, 4,

        &svq1_block_type_vlc[0][1], 2, 1,

        &svq1_block_type_vlc[0][0], 2, 1);



    init_vlc(&svq1_motion_component, 7, 33,

        &mvtab[0][1], 2, 1,

        &mvtab[0][0], 2, 1);



    for (i = 0; i < 6; i++) {

        init_vlc(&svq1_intra_multistage[i], 3, 8,

            &svq1_intra_multistage_vlc[i][0][1], 2, 1,

            &svq1_intra_multistage_vlc[i][0][0], 2, 1);

        init_vlc(&svq1_inter_multistage[i], 3, 8,

            &svq1_inter_multistage_vlc[i][0][1], 2, 1,

            &svq1_inter_multistage_vlc[i][0][0], 2, 1);

    }



    init_vlc(&svq1_intra_mean, 8, 256,

        &svq1_intra_mean_vlc[0][1], 4, 2,

        &svq1_intra_mean_vlc[0][0], 4, 2);



    init_vlc(&svq1_inter_mean, 9, 512,

        &svq1_inter_mean_vlc[0][1], 4, 2,

        &svq1_inter_mean_vlc[0][0], 4, 2);



    return 0;

}
",386,,LABEL_1,LABEL_0,,-4,"avctx,s,i",,,,0,,0,Greedy,1,0.0006160298983256022,,
302,"static void v9fs_stat(void *opaque)

{

    int32_t fid;

    V9fsStat v9stat;

    ssize_t err = 0;

    size_t offset = 7;

    struct stat stbuf;

    V9fsFidState *fidp;

    V9fsPDU *pdu = opaque;

    V9fsState *s = pdu->s;



    pdu_unmarshal(pdu, offset, ""d"", &fid);

    trace_v9fs_stat(pdu->tag, pdu->id, fid);



    fidp = get_fid(pdu, fid);

    if (fidp == NULL) {

        err = -ENOENT;

        goto out_nofid;

    }

    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);

    if (err < 0) {

        goto out;

    }

    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);

    if (err < 0) {

        goto out;

    }

    offset += pdu_marshal(pdu, offset, ""wS"", 0, &v9stat);

    err = offset;

    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,

                           v9stat.atime, v9stat.mtime, v9stat.length);

    v9fs_stat_free(&v9stat);

out:

    put_fid(pdu, fidp);

out_nofid:

    complete_pdu(s, pdu, err);

}
",234,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,fid,v9stat,stbuf,fidp,pdu,s",,,,0,,0,GA,1412,0.5340028285980225,failed,
303,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));


    return chr;

}",24,,LABEL_1,LABEL_1,LABEL_1,-1,chr,,,,0,,0,GA,241,0.08427078326543172,failed,
304,"av_cold void ff_sws_init_swScale_mmx(SwsContext *c)

{

    int cpu_flags = av_get_cpu_flags();



#if HAVE_INLINE_ASM

    if (cpu_flags & AV_CPU_FLAG_MMX)

        sws_init_swScale_MMX(c);

#if HAVE_MMXEXT_INLINE

    if (cpu_flags & AV_CPU_FLAG_MMXEXT)

        sws_init_swScale_MMX2(c);

#endif

#endif /* HAVE_INLINE_ASM */



#if HAVE_YASM

#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \

    if (c->srcBpc == 8) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \

    } else if (c->srcBpc == 9) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \

    } else if (c->srcBpc == 10) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \

    } else /* c->srcBpc == 16 */ { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \

    } \

} while (0)

#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \

    }

#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \

switch(c->dstBpc){ \

    case 16:                          do_16_case;                          break; \

    case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \

    case 9:  if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \

    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \

    }

#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \

    switch(c->dstBpc){ \

    case 16: if (!isBE(c->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \

    case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \

    case 9:  if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \

    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \

    }

#define case_rgb(x, X, opt) \

        case PIX_FMT_ ## X: \

            c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \

            if (!c->chrSrcHSubSample) \

                c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \

            break

#if ARCH_X86_32

    if (cpu_flags & AV_CPU_FLAG_MMX) {

        ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx);

        ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);



        switch (c->srcFormat) {

        case PIX_FMT_Y400A:

            c->lumToYV12 = ff_yuyvToY_mmx;

            if (c->alpPixBuf)

                c->alpToYV12 = ff_uyvyToY_mmx;

            break;

        case PIX_FMT_YUYV422:

            c->lumToYV12 = ff_yuyvToY_mmx;

            c->chrToYV12 = ff_yuyvToUV_mmx;

            break;

        case PIX_FMT_UYVY422:

            c->lumToYV12 = ff_uyvyToY_mmx;

            c->chrToYV12 = ff_uyvyToUV_mmx;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_mmx;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_mmx;

            break;

        case_rgb(rgb24, RGB24, mmx);

        case_rgb(bgr24, BGR24, mmx);

        case_rgb(bgra,  BGRA,  mmx);

        case_rgb(rgba,  RGBA,  mmx);

        case_rgb(abgr,  ABGR,  mmx);

        case_rgb(argb,  ARGB,  mmx);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1);

    }

#endif /* ARCH_X86_32 */

#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \

             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \

             break; \

    }

    if (cpu_flags & AV_CPU_FLAG_SSE2) {

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1);



        switch (c->srcFormat) {

        case PIX_FMT_Y400A:

            c->lumToYV12 = ff_yuyvToY_sse2;

            if (c->alpPixBuf)

                c->alpToYV12 = ff_uyvyToY_sse2;

            break;

        case PIX_FMT_YUYV422:

            c->lumToYV12 = ff_yuyvToY_sse2;

            c->chrToYV12 = ff_yuyvToUV_sse2;

            break;

        case PIX_FMT_UYVY422:

            c->lumToYV12 = ff_uyvyToY_sse2;

            c->chrToYV12 = ff_uyvyToUV_sse2;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_sse2;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_sse2;

            break;

        case_rgb(rgb24, RGB24, sse2);

        case_rgb(bgr24, BGR24, sse2);

        case_rgb(bgra,  BGRA,  sse2);

        case_rgb(rgba,  RGBA,  sse2);

        case_rgb(abgr,  ABGR,  sse2);

        case_rgb(argb,  ARGB,  sse2);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSSE3) {

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3);

        switch (c->srcFormat) {

        case_rgb(rgb24, RGB24, ssse3);

        case_rgb(bgr24, BGR24, ssse3);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSE4) {

        /* Xto15 don't need special sse4 functions */

        ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3);

        ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3);

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,

                            if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        if (c->dstBpc == 16 && !isBE(c->dstFormat))

            c->yuv2plane1 = ff_yuv2plane1_16_sse4;

    }



    if (cpu_flags & AV_CPU_FLAG_AVX) {

        ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1);



        switch (c->srcFormat) {

        case PIX_FMT_YUYV422:

            c->chrToYV12 = ff_yuyvToUV_avx;

            break;

        case PIX_FMT_UYVY422:

            c->chrToYV12 = ff_uyvyToUV_avx;

            break;

        case PIX_FMT_NV12:

            c->chrToYV12 = ff_nv12ToUV_avx;

            break;

        case PIX_FMT_NV21:

            c->chrToYV12 = ff_nv21ToUV_avx;

            break;

        case_rgb(rgb24, RGB24, avx);

        case_rgb(bgr24, BGR24, avx);

        case_rgb(bgra,  BGRA,  avx);

        case_rgb(rgba,  RGBA,  avx);

        case_rgb(abgr,  ABGR,  avx);

        case_rgb(argb,  ARGB,  avx);

        default:

            break;

        }

    }

#endif

}
",1189,"av_cold void ff_sws_init_swScale_mmx(SwsContext *cv)

{

    int cpu_flags = av_get_cpu_flags();



#if HAVE_INLINE_ASM

    if (cpu_flags & AV_CPU_FLAG_MMX)

        sws_init_swScale_MMX(cv);

#if HAVE_MMXEXT_INLINE

    if (cpu_flags & AV_CPU_FLAG_MMXEXT)

        sws_init_swScale_MMX2(cv);

#endif

#endif /* HAVE_INLINE_ASM */



#if HAVE_YASM

#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \

    if (cv->srcBpc == 8) { \

        hscalefn = cv->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \

    } else if (cv->srcBpc == 9) { \

        hscalefn = cv->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \

    } else if (cv->srcBpc == 10) { \

        hscalefn = cv->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \

    } else /* cv->srcBpc == 16 */ { \

        hscalefn = cv->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale16to19_ ## filtersize ## _ ## opt1; \

    } \

} while (0)

#define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \

    }

#define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \

switch(cv->dstBpc){ \

    case 16:                          do_16_case;                          break; \

    case 10: if (!isBE(cv->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \

    case 9:  if (!isBE(cv->dstFormat)) vscalefn = ff_yuv2planeX_9_  ## opt; break; \

    default: if (condition_8bit)      vscalefn = ff_yuv2planeX_8_  ## opt; break; \

    }

#define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \

    switch(cv->dstBpc){ \

    case 16: if (!isBE(cv->dstFormat))            vscalefn = ff_yuv2plane1_16_ ## opt1; break; \

    case 10: if (!isBE(cv->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \

    case 9:  if (!isBE(cv->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_  ## opt2;  break; \

    default:                                     vscalefn = ff_yuv2plane1_8_  ## opt1;  break; \

    }

#define case_rgb(x, X, opt) \

        case PIX_FMT_ ## X: \

            cv->lumToYV12 = ff_ ## x ## ToY_ ## opt; \

            if (!c->chrSrcHSubSample) \

                cv->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \

            break

#if ARCH_X86_32

    if (cpu_flags & AV_CPU_FLAG_MMX) {

        ASSIGN_MMX_SCALE_FUNC(cv->hyScale, cv->hLumFilterSize, mmx, mmx);

        ASSIGN_MMX_SCALE_FUNC(cv->hcScale, cv->hChrFilterSize, mmx, mmx);

        ASSIGN_VSCALE_FUNC(cv->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT);



        switch (cv->srcFormat) {

        case PIX_FMT_Y400A:

            cv->lumToYV12 = ff_yuyvToY_mmx;

            if (cv->alpPixBuf)

                cv->alpToYV12 = ff_uyvyToY_mmx;

            break;

        case PIX_FMT_YUYV422:

            cv->lumToYV12 = ff_yuyvToY_mmx;

            cv->chrToYV12 = ff_yuyvToUV_mmx;

            break;

        case PIX_FMT_UYVY422:

            cv->lumToYV12 = ff_uyvyToY_mmx;

            cv->chrToYV12 = ff_uyvyToUV_mmx;

            break;

        case PIX_FMT_NV12:

            cv->chrToYV12 = ff_nv12ToUV_mmx;

            break;

        case PIX_FMT_NV21:

            cv->chrToYV12 = ff_nv21ToUV_mmx;

            break;

        case_rgb(rgb24, RGB24, mmx);

        case_rgb(bgr24, BGR24, mmx);

        case_rgb(bgra,  BGRA,  mmx);

        case_rgb(rgba,  RGBA,  mmx);

        case_rgb(abgr,  ABGR,  mmx);

        case_rgb(argb,  ARGB,  mmx);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_MMXEXT) {

        ASSIGN_VSCALEX_FUNC(cv->yuv2planeX, mmx2, , 1);

    }

#endif /* ARCH_X86_32 */

#define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \

    switch (filtersize) { \

    case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \

    case 8:  ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \

    default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \

             else                ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \

             break; \

    }

    if (cpu_flags & AV_CPU_FLAG_SSE2) {

        ASSIGN_SSE_SCALE_FUNC(cv->hyScale, cv->hLumFilterSize, sse2, sse2);

        ASSIGN_SSE_SCALE_FUNC(cv->hcScale, cv->hChrFilterSize, sse2, sse2);

        ASSIGN_VSCALEX_FUNC(cv->yuv2planeX, sse2, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(cv->yuv2plane1, sse2, sse2, 1);



        switch (cv->srcFormat) {

        case PIX_FMT_Y400A:

            cv->lumToYV12 = ff_yuyvToY_sse2;

            if (cv->alpPixBuf)

                cv->alpToYV12 = ff_uyvyToY_sse2;

            break;

        case PIX_FMT_YUYV422:

            cv->lumToYV12 = ff_yuyvToY_sse2;

            cv->chrToYV12 = ff_yuyvToUV_sse2;

            break;

        case PIX_FMT_UYVY422:

            cv->lumToYV12 = ff_uyvyToY_sse2;

            cv->chrToYV12 = ff_uyvyToUV_sse2;

            break;

        case PIX_FMT_NV12:

            cv->chrToYV12 = ff_nv12ToUV_sse2;

            break;

        case PIX_FMT_NV21:

            cv->chrToYV12 = ff_nv21ToUV_sse2;

            break;

        case_rgb(rgb24, RGB24, sse2);

        case_rgb(bgr24, BGR24, sse2);

        case_rgb(bgra,  BGRA,  sse2);

        case_rgb(rgba,  RGBA,  sse2);

        case_rgb(abgr,  ABGR,  sse2);

        case_rgb(argb,  ARGB,  sse2);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSSE3) {

        ASSIGN_SSE_SCALE_FUNC(cv->hyScale, cv->hLumFilterSize, ssse3, ssse3);

        ASSIGN_SSE_SCALE_FUNC(cv->hcScale, cv->hChrFilterSize, ssse3, ssse3);

        switch (cv->srcFormat) {

        case_rgb(rgb24, RGB24, ssse3);

        case_rgb(bgr24, BGR24, ssse3);

        default:

            break;

        }

    }

    if (cpu_flags & AV_CPU_FLAG_SSE4) {

        /* Xto15 don't need special sse4 functions */

        ASSIGN_SSE_SCALE_FUNC(cv->hyScale, cv->hLumFilterSize, sse4, ssse3);

        ASSIGN_SSE_SCALE_FUNC(cv->hcScale, cv->hChrFilterSize, sse4, ssse3);

        ASSIGN_VSCALEX_FUNC(cv->yuv2planeX, sse4,

                            if (!isBE(cv->dstFormat)) cv->yuv2planeX = ff_yuv2planeX_16_sse4,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        if (cv->dstBpc == 16 && !isBE(cv->dstFormat))

            cv->yuv2plane1 = ff_yuv2plane1_16_sse4;

    }



    if (cpu_flags & AV_CPU_FLAG_AVX) {

        ASSIGN_VSCALEX_FUNC(cv->yuv2planeX, avx, ,

                            HAVE_ALIGNED_STACK || ARCH_X86_64);

        ASSIGN_VSCALE_FUNC(cv->yuv2plane1, avx, avx, 1);



        switch (cv->srcFormat) {

        case PIX_FMT_YUYV422:

            cv->chrToYV12 = ff_yuyvToUV_avx;

            break;

        case PIX_FMT_UYVY422:

            cv->chrToYV12 = ff_uyvyToUV_avx;

            break;

        case PIX_FMT_NV12:

            cv->chrToYV12 = ff_nv12ToUV_avx;

            break;

        case PIX_FMT_NV21:

            cv->chrToYV12 = ff_nv21ToUV_avx;

            break;

        case_rgb(rgb24, RGB24, avx);

        case_rgb(bgr24, BGR24, avx);

        case_rgb(bgra,  BGRA,  avx);

        case_rgb(rgba,  RGBA,  avx);

        case_rgb(abgr,  ABGR,  avx);

        case_rgb(argb,  ARGB,  avx);

        default:

            break;

        }

    }

#endif

}
",LABEL_0,LABEL_0,LABEL_1,1,c,,,,0,"c:cv,",0,GA,147,0.08475434382756551,GA,
305,"uint8_t sd_read_data(SDState *sd)

{

    /* TODO: Append CRCs */

    uint8_t ret;

    int io_len;



    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable)

        return 0x00;



    if (sd->state != sd_sendingdata_state) {

        fprintf(stderr, ""sd_read_data: not in Sending-Data state\n"");

        return 0x00;

    }



    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION))

        return 0x00;



    io_len = (sd->ocr & (1 << 30)) ? 512 : sd->blk_len;



    switch (sd->current_cmd) {

    case 6:	/* CMD6:   SWITCH_FUNCTION */

        ret = sd->data[sd->data_offset ++];



        if (sd->data_offset >= 64)

            sd->state = sd_transfer_state;

        break;



    case 9:	/* CMD9:   SEND_CSD */

    case 10:	/* CMD10:  SEND_CID */

        ret = sd->data[sd->data_offset ++];



        if (sd->data_offset >= 16)

            sd->state = sd_transfer_state;

        break;



    case 11:	/* CMD11:  READ_DAT_UNTIL_STOP */

        if (sd->data_offset == 0)

            BLK_READ_BLOCK(sd->data_start, io_len);

        ret = sd->data[sd->data_offset ++];



        if (sd->data_offset >= io_len) {

            sd->data_start += io_len;

            sd->data_offset = 0;

            if (sd->data_start + io_len > sd->size) {

                sd->card_status |= ADDRESS_ERROR;

                break;

            }

        }

        break;



    case 13:	/* ACMD13: SD_STATUS */

        ret = sd->sd_status[sd->data_offset ++];



        if (sd->data_offset >= sizeof(sd->sd_status))

            sd->state = sd_transfer_state;

        break;



    case 17:	/* CMD17:  READ_SINGLE_BLOCK */

        if (sd->data_offset == 0)

            BLK_READ_BLOCK(sd->data_start, io_len);

        ret = sd->data[sd->data_offset ++];



        if (sd->data_offset >= io_len)

            sd->state = sd_transfer_state;

        break;



    case 18:	/* CMD18:  READ_MULTIPLE_BLOCK */

        if (sd->data_offset == 0)

            BLK_READ_BLOCK(sd->data_start, io_len);

        ret = sd->data[sd->data_offset ++];



        if (sd->data_offset >= io_len) {

            sd->data_start += io_len;

            sd->data_offset = 0;

            if (sd->data_start + io_len > sd->size) {

                sd->card_status |= ADDRESS_ERROR;

                break;

            }

        }

        break;



    case 22:	/* ACMD22: SEND_NUM_WR_BLOCKS */

        ret = sd->data[sd->data_offset ++];



        if (sd->data_offset >= 4)

            sd->state = sd_transfer_state;

        break;



    case 30:	/* CMD30:  SEND_WRITE_PROT */

        ret = sd->data[sd->data_offset ++];



        if (sd->data_offset >= 4)

            sd->state = sd_transfer_state;

        break;



    case 51:	/* ACMD51: SEND_SCR */

        ret = sd->scr[sd->data_offset ++];



        if (sd->data_offset >= sizeof(sd->scr))

            sd->state = sd_transfer_state;

        break;



    case 56:	/* CMD56:  GEN_CMD */

        if (sd->data_offset == 0)

            APP_READ_BLOCK(sd->data_start, sd->blk_len);

        ret = sd->data[sd->data_offset ++];



        if (sd->data_offset >= sd->blk_len)

            sd->state = sd_transfer_state;

        break;



    default:

        fprintf(stderr, ""sd_read_data: unknown command\n"");

        return 0x00;

    }



    return ret;

}
",747,"uint8_t sd_read_data(SDState *sth)

{

    /* TODO: Append CRCs */

    uint8_t gt;

    int iokcount;



    if (!sd->bdrv || !bdrv_is_inserted(sth->bdrv) || !sd->enable)

        return 0x00;



    if (sth->state != sd_sendingdata_state) {

        fprintf(stderr, ""sd_read_data: not in Sending-Data state
"");

        return 0x00;

    }



    if (sth->card_status & (ADDRESS_ERROR | WP_VIOLATION))

        return 0x00;



    ioiokcount (sth->ocr & (1 << 30)) ? 512 : sth->blk_len;



    switch (sth->current_cmd) {

    case 6:	/* CMD6:   SWITCH_FUNCTION */

        regt sth->data[sth->data_offset ++];



        if (sth->data_offset >= 64)

            sth->state = sd_transfer_state;

        break;



    case 9:	/* CMD9:   SEND_CSD */

    case 10:	/* CMD10:  SEND_CID */

        regt sth->data[sth->data_offset ++];



        if (sth->data_offset >= 16)

            sth->state = sd_transfer_state;

        break;



    case 11:	/* CMD11:  READ_DAT_UNTIL_STOP */

        if (sth->data_offset == 0)

            BLK_READ_BLOCK(sth->data_start, iokcount);

        regt sth->data[sth->data_offset ++];



        if (sth->data_offset >= iokcount) {

            sth->data_start += iokcount;

            sth->data_offset = 0;

            if (sth->data_start + iiokcount> sth->size) {

                sth->card_status |= ADDRESS_ERROR;

                break;

            }

        }

        break;



    case 13:	/* ACMD13: SD_STATUS */

        regt sth->sd_status[sth->data_offset ++];



        if (sth->data_offset >= sizeof(sth->sd_status))

            sth->state = sd_transfer_state;

        break;



    case 17:	/* CMD17:  READ_SINGLE_BLOCK */

        if (sth->data_offset == 0)

            BLK_READ_BLOCK(sth->data_start, iokcount);

        regt sth->data[sth->data_offset ++];



        if (sth->data_offset >= iokcount)

            sth->state = sd_transfer_state;

        break;



    case 18:	/* CMD18:  READ_MULTIPLE_BLOCK */

        if (sth->data_offset == 0)

            BLK_READ_BLOCK(sth->data_start, iokcount);

        regt sth->data[sth->data_offset ++];



        if (sth->data_offset >= iokcount) {

            sth->data_start += iokcount;

            sth->data_offset = 0;

            if (sth->data_start + iiokcount> sth->size) {

                sth->card_status |= ADDRESS_ERROR;

                break;

            }

        }

        break;



    case 22:	/* ACMD22: SEND_NUM_WR_BLOCKS */

        regt sth->data[sth->data_offset ++];



        if (sth->data_offset >= 4)

            sth->state = sd_transfer_state;

        break;



    case 30:	/* CMD30:  SEND_WRITE_PROT */

        regt sth->data[sth->data_offset ++];



        if (sth->data_offset >= 4)

            sth->state = sd_transfer_state;

        break;



    case 51:	/* ACMD51: SEND_SCR */

        regt sth->scr[sth->data_offset ++];



        if (sth->data_offset >= sizeof(sth->scr))

            sth->state = sd_transfer_state;

        break;



    case 56:	/* CMD56:  GEN_CMD */

        if (sth->data_offset == 0)

            APP_READ_BLOCK(sth->data_start, sth->blk_len);

        regt sth->data[sth->data_offset ++];



        if (sth->data_offset >= sth->blk_len)

            sth->state = sd_transfer_state;

        break;



    default:

        fprintf(stderr, ""sd_read_data: unknown command
"");

        return 0x00;

    }



    return gt;

}
",LABEL_0,LABEL_0,LABEL_1,1,"sd,ret,io_len",,,,0,"sd:sth,ret:gt,io_len:iokcount,",0,GA,257,0.11493866046269735,GA,
306,"int ff_dxva2_commit_buffer(AVCodecContext *avctx,

                           AVDXVAContext *ctx,

                           DECODER_BUFFER_DESC *dsc,

                           unsigned type, const void *data, unsigned size,

                           unsigned mb_count)

{

    void     *dxva_data;

    unsigned dxva_size;

    int      result;

    HRESULT hr;



#if CONFIG_D3D11VA

    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)

        hr = ID3D11VideoContext_GetDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context,

                                                 D3D11VA_CONTEXT(ctx)->decoder,

                                                 type,

                                                 &dxva_size, &dxva_data);

#endif

#if CONFIG_DXVA2

    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)

        hr = IDirectXVideoDecoder_GetBuffer(DXVA2_CONTEXT(ctx)->decoder, type,

                                            &dxva_data, &dxva_size);

#endif

    if (FAILED(hr)) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to get a buffer for %u: 0x%x\n"",

               type, hr);

        return -1;

    }

    if (size <= dxva_size) {

        memcpy(dxva_data, data, size);



#if CONFIG_D3D11VA

        if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD) {

            D3D11_VIDEO_DECODER_BUFFER_DESC *dsc11 = dsc;

            memset(dsc11, 0, sizeof(*dsc11));

            dsc11->BufferType           = type;

            dsc11->DataSize             = size;

            dsc11->NumMBsInBuffer       = mb_count;

        }

#endif

#if CONFIG_DXVA2

        if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD) {

            DXVA2_DecodeBufferDesc *dsc2 = dsc;

            memset(dsc2, 0, sizeof(*dsc2));

            dsc2->CompressedBufferType = type;

            dsc2->DataSize             = size;

            dsc2->NumMBsInBuffer       = mb_count;

        }

#endif



        result = 0;

    } else {

        av_log(avctx, AV_LOG_ERROR, ""Buffer for type %u was too small\n"", type);

        result = -1;

    }



#if CONFIG_D3D11VA

    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)

        hr = ID3D11VideoContext_ReleaseDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context, D3D11VA_CONTEXT(ctx)->decoder, type);

#endif

#if CONFIG_DXVA2

    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)

        hr = IDirectXVideoDecoder_ReleaseBuffer(DXVA2_CONTEXT(ctx)->decoder, type);

#endif

    if (FAILED(hr)) {

        av_log(avctx, AV_LOG_ERROR,

               ""Failed to release buffer type %u: 0x%x\n"",

               type, hr);

        result = -1;

    }

    return result;

}
",405,,LABEL_0,LABEL_1,,-4,"avctx,ctx,dsc,type,data,size,mb_count,dxva_data,dxva_size,result,hr,dsc11,dsc2",,,,0,,0,Greedy,1,0.0006952285766601562,,
307,"int vm_stop(RunState state)

{

    if (qemu_in_vcpu_thread()) {


        qemu_system_vmstop_request(state);

        /*

         * FIXME: should not return to device code in case

         * vm_stop() has been requested.

         */

        cpu_stop_current();

        return 0;

    }



    return do_vm_stop(state);

}",57,,LABEL_1,LABEL_1,LABEL_1,-1,state,,,,0,,0,GA,253,0.09015225966771444,failed,
308,"static void ac97_map (PCIDevice *pci_dev, int region_num,

                      uint32_t addr, uint32_t size, int type)

{

    PCIAC97LinkState *d = (PCIAC97LinkState *) pci_dev;

    AC97LinkState *s = &d->ac97;



    if (!region_num) {

        s->base[0] = addr;

        register_ioport_read (addr, 256 * 1, 1, nam_readb, d);

        register_ioport_read (addr, 256 * 2, 2, nam_readw, d);

        register_ioport_read (addr, 256 * 4, 4, nam_readl, d);

        register_ioport_write (addr, 256 * 1, 1, nam_writeb, d);

        register_ioport_write (addr, 256 * 2, 2, nam_writew, d);

        register_ioport_write (addr, 256 * 4, 4, nam_writel, d);

    }

    else {

        s->base[1] = addr;

        register_ioport_read (addr, 64 * 1, 1, nabm_readb, d);

        register_ioport_read (addr, 64 * 2, 2, nabm_readw, d);

        register_ioport_read (addr, 64 * 4, 4, nabm_readl, d);

        register_ioport_write (addr, 64 * 1, 1, nabm_writeb, d);

        register_ioport_write (addr, 64 * 2, 2, nabm_writew, d);

        register_ioport_write (addr, 64 * 4, 4, nabm_writel, d);

    }

}
",252,,LABEL_0,LABEL_0,LABEL_0,-1,"pci_dev,region_num,addr,size,type,d,s",,,,0,,0,GA,1315,0.5029296120007832,failed,
309,"static int atrim_filter_frame(AVFilterLink *inlink, AVFrame *frame)

{

    AVFilterContext *ctx = inlink->dst;

    TrimContext       *s = ctx->priv;

    int64_t start_sample, end_sample = frame->nb_samples;

    int64_t pts;

    int drop;



    /* drop everything if EOF has already been returned */

    if (s->eof) {

        av_frame_free(&frame);

        return 0;

    }



    if (frame->pts != AV_NOPTS_VALUE)

        pts = av_rescale_q(frame->pts, inlink->time_base,

                           (AVRational){ 1, inlink->sample_rate });

    else

        pts = s->next_pts;

    s->next_pts = pts + frame->nb_samples;



    /* check if at least a part of the frame is after the start time */

    if (s->start_sample < 0 && s->start_pts == AV_NOPTS_VALUE) {

        start_sample = 0;

    } else {

        drop = 1;

        start_sample = frame->nb_samples;



        if (s->start_sample >= 0 &&

            s->nb_samples + frame->nb_samples > s->start_sample) {

            drop         = 0;

            start_sample = FFMIN(start_sample, s->start_sample - s->nb_samples);

        }



        if (s->start_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&

            pts + frame->nb_samples > s->start_pts) {

            drop = 0;

            start_sample = FFMIN(start_sample, s->start_pts - pts);

        }



        if (drop)

            goto drop;

    }



    if (s->first_pts == AV_NOPTS_VALUE)

        s->first_pts = pts + start_sample;



    /* check if at least a part of the frame is before the end time */

    if (s->end_sample == INT64_MAX && s->end_pts == AV_NOPTS_VALUE && !s->duration_tb) {

        end_sample = frame->nb_samples;

    } else {

        drop       = 1;

        end_sample = 0;



        if (s->end_sample != INT64_MAX &&

            s->nb_samples < s->end_sample) {

            drop       = 0;

            end_sample = FFMAX(end_sample, s->end_sample - s->nb_samples);

        }



        if (s->end_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&

            pts < s->end_pts) {

            drop       = 0;

            end_sample = FFMAX(end_sample, s->end_pts - pts);

        }



        if (s->duration_tb && pts - s->first_pts < s->duration_tb) {

            drop       = 0;

            end_sample = FFMAX(end_sample, s->first_pts + s->duration_tb - pts);

        }



        if (drop) {

            s->eof = 1;

            goto drop;

        }

    }



    s->nb_samples += frame->nb_samples;

    start_sample   = FFMAX(0, start_sample);

    end_sample     = FFMIN(frame->nb_samples, end_sample);

    av_assert0(start_sample < end_sample);



    if (start_sample) {

        AVFrame *out = ff_get_audio_buffer(ctx->outputs[0], end_sample - start_sample);

        if (!out) {

            av_frame_free(&frame);

            return AVERROR(ENOMEM);

        }



        av_frame_copy_props(out, frame);

        av_samples_copy(out->extended_data, frame->extended_data, 0, start_sample,

                        out->nb_samples, av_get_channel_layout_nb_channels(frame->channel_layout),

                        frame->format);

        if (out->pts != AV_NOPTS_VALUE)

            out->pts += av_rescale_q(start_sample, (AVRational){ 1, out->sample_rate },

                                     inlink->time_base);



        av_frame_free(&frame);

        frame = out;

    } else

        frame->nb_samples = end_sample;



    s->got_output = 1;

    return ff_filter_frame(ctx->outputs[0], frame);



drop:

    s->nb_samples += frame->nb_samples;

    av_frame_free(&frame);

    return 0;

}
",734,"static int atrim_filter_frame(AVFilterLink *outload, AVFrame *fram)

{

    AVFilterContext *cctx= outload->dst;

    TrimContext       *s = ctx->priv;

    int64_tstart_samplee, end_sample = fram->nb_samples;

    int64_t pts;

    int drop;



    /* drop everything if EOF has already been returned */

    if (s->eof) {

        av_frame_free(&fram);

        return 0;

    }



    if (fram->pts != AV_NOPTS_VALUE)

        pts = av_rescale_q(ffram>ppts outload->time_base,

                           (AVRational){ 1, outload->sample_rate });

    else

        pts = s->next_pts;

   ss->next_pts =ptss + fram->nb_samples;



    /* check if at least a part of the fram is after the start time */

    if (s->start_sample < 0 && s->start_pts == AV_NOPTS_VALUE) {

        start_sample = 0;

    } else {

        drop = 1;

       start_samplee = fram->nb_samples;



        if (s->start_sample >= 0 &&

           ss->nb_samples + fram->nb_samples > s->start_sample) {

            drop         = 0;

            start_sample = FFMIN(start_sample, s->start_sample - s->nb_samples);

        }



        if (s->start_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&

           ptss + fram->nb_samples > s->start_pts) {

            drop = 0;

            start_sample = FFMIN(start_sample, s->start_pts - pts);

        }



        if (drop)

            goto drop;

    }



    if (s->first_pts == AV_NOPTS_VALUE)

        s->first_pts = pts + start_sample;



    /* check if at least a part of the fram is before the end time */

    if (s->end_sample == INT64_MAX && s->end_pts == AV_NOPTS_VALUE && !s->duration_tb) {

        end_sample = fram->nb_samples;

    } else {

        drop       = 1;

        end_sample = 0;



        if (s->end_sample != INT64_MAX &&

            s->nb_samples < s->end_sample) {

            drop       = 0;

            end_sample = FFMAX(end_sample, s->end_sample - s->nb_samples);

        }



        if (s->end_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE &&

            pts < s->end_pts) {

            drop       = 0;

            end_sample = FFMAX(end_sample, s->end_pts - pts);

        }



        if (s->duration_tb && pts - s->first_pts < s->duration_tb) {

            drop       = 0;

            end_sample = FFMAX(end_sample, s->first_pts + s->duration_tb - pts);

        }



        if (drop) {

            s->eof = 1;

            goto drop;

        }

    }



   ss->nb_samples += fram->nb_samples;

    start_sample   = FFMAX(0, start_sample);

    end_sample     = FFMIN(fram->nb_samples, end_sample);

    av_assert0(start_sample < end_sample);



    if (start_sample) {

        AVFrame *out = ff_get_audio_buffer(ctx->outputs[0], end_sample - start_sample);

        if (!out) {

            av_frame_free(&fram);

            return AVERROR(ENOMEM);

        }



        av_frame_copy_props(out, fram);

        av_samples_copy(out->extended_data, fram->extended_data, 0, start_sample,

                        out->nb_samples, av_get_channel_layout_nb_channels(fram->channel_layout),

                        fram->format);

        if (out->pts != AV_NOPTS_VALUE)

            out->pts += av_rescale_q(start_sample, (AVRational){ 1, out->sample_rate },

                                     outload->time_base);



        av_frame_free(&fram);

        fram = out;

    } else

        fram->nb_samples = end_sample;



    s->got_output = 1;

    return ff_filter_framectxx->outputs[0], fram);



drop:

   ss->nb_samples += fram->nb_samples;

    av_frame_free(&fram);

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"inlink,frame,ctx,s,start_sample,pts,drop",,,,89,"inlink:outload,frame:fram,ctx:ctx,s:s,start_sample:start_sample,pts:pts,drop:drop,",5,GA,533,0.24043159087498983,GA,
310,"static void gem_write(void *opaque, target_phys_addr_t offset, uint64_t val,

        unsigned size)

{

    GemState *s = (GemState *)opaque;

    uint32_t readonly;



    DB_PRINT(""offset: 0x%04x write: 0x%08x "", offset, (unsigned)val);

    offset >>= 2;



    /* Squash bits which are read only in write value */

    val &= ~(s->regs_ro[offset]);

    /* Preserve (only) bits which are read only in register */

    readonly = s->regs[offset];

    readonly &= s->regs_ro[offset];



    /* Squash bits which are write 1 to clear */

    val &= ~(s->regs_w1c[offset] & val);



    /* Copy register write to backing store */

    s->regs[offset] = val | readonly;



    /* Handle register write side effects */

    switch (offset) {

    case GEM_NWCTRL:

        if (val & GEM_NWCTRL_TXSTART) {

            gem_transmit(s);

        }

        if (!(val & GEM_NWCTRL_TXENA)) {

            /* Reset to start of Q when transmit disabled. */

            s->tx_desc_addr = s->regs[GEM_TXQBASE];

        }

        if (!(val & GEM_NWCTRL_RXENA)) {

            /* Reset to start of Q when receive disabled. */

            s->rx_desc_addr = s->regs[GEM_RXQBASE];

        }

        break;



    case GEM_TXSTATUS:

        gem_update_int_status(s);

        break;

    case GEM_RXQBASE:

        s->rx_desc_addr = val;

        break;

    case GEM_TXQBASE:

        s->tx_desc_addr = val;

        break;

    case GEM_RXSTATUS:

        gem_update_int_status(s);

        break;

    case GEM_IER:

        s->regs[GEM_IMR] &= ~val;

        gem_update_int_status(s);

        break;

    case GEM_IDR:

        s->regs[GEM_IMR] |= val;

        gem_update_int_status(s);

        break;

    case GEM_PHYMNTNC:

        if (val & GEM_PHYMNTNC_OP_W) {

            uint32_t phy_addr, reg_num;



            phy_addr = (val & GEM_PHYMNTNC_ADDR) >> GEM_PHYMNTNC_ADDR_SHFT;

            if (phy_addr == BOARD_PHY_ADDRESS) {

                reg_num = (val & GEM_PHYMNTNC_REG) >> GEM_PHYMNTNC_REG_SHIFT;

                gem_phy_write(s, reg_num, val);

            }

        }

        break;

    }



    DB_PRINT(""newval: 0x%08x\n"", s->regs[offset]);

}
",424,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,offset,val,size,s,readonly,phy_addr,reg_num",,,,0,,0,GA,1630,0.7031507372856141,failed,
311,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&

        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)

            return timestamp + (1ULL<<st->pts_wrap_bits);

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= st->pts_wrap_reference)

            return timestamp - (1ULL<<st->pts_wrap_bits);

    }

    return timestamp;

}
",109,"static int64_t wrap_timestamp(AVStream *sign, int64_t tmest)

{

    if (sign->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && sign->pts_wrap_bits < 64 &&

        sign->pts_wrap_reference != AV_NOPTS_VALUE && tmest != AV_NOPTS_VALUE) {

        if (sign->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            titmest sign->pts_wrap_reference)

            return titmest (1ULL<<sign->pts_wrap_bits);

        else if (sign->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            titmest= sign->pts_wrap_reference)

            return titmest (1ULL<<sign->pts_wrap_bits);

    }

    return tmest;

}
",LABEL_0,LABEL_0,LABEL_1,1,"st,timestamp",,,,0,"st:sign,timestamp:tmest,",0,GA,255,0.09190386533737183,GA,
312,"bool aio_poll(AioContext *ctx, bool blocking)

{

    AioHandler *node;

    int i, ret;

    bool progress;

    int64_t timeout;



    aio_context_acquire(ctx);

    progress = false;



    /* aio_notify can avoid the expensive event_notifier_set if

     * everything (file descriptors, bottom halves, timers) will

     * be re-evaluated before the next blocking poll().  This is

     * already true when aio_poll is called with blocking == false;

     * if blocking == true, it is only true after poll() returns,

     * so disable the optimization now.

     */

    if (blocking) {

        atomic_add(&ctx->notify_me, 2);

    }



    ctx->walking_handlers++;



    assert(npfd == 0);



    /* fill pollfds */



    if (!aio_epoll_enabled(ctx)) {

        QLIST_FOREACH(node, &ctx->aio_handlers, node) {

            if (!node->deleted && node->pfd.events

                && aio_node_check(ctx, node->is_external)) {

                add_pollfd(node);

            }

        }

    }



    timeout = blocking ? aio_compute_timeout(ctx) : 0;



    /* wait until next event */

    if (timeout) {

        aio_context_release(ctx);

    }

    if (aio_epoll_check_poll(ctx, pollfds, npfd, timeout)) {

        AioHandler epoll_handler;



        epoll_handler.pfd.fd = ctx->epollfd;

        epoll_handler.pfd.events = G_IO_IN | G_IO_OUT | G_IO_HUP | G_IO_ERR;

        npfd = 0;

        add_pollfd(&epoll_handler);

        ret = aio_epoll(ctx, pollfds, npfd, timeout);

    } else  {

        ret = qemu_poll_ns(pollfds, npfd, timeout);

    }

    if (blocking) {

        atomic_sub(&ctx->notify_me, 2);

    }

    if (timeout) {

        aio_context_acquire(ctx);

    }



    aio_notify_accept(ctx);



    /* if we have any readable fds, dispatch event */

    if (ret > 0) {

        for (i = 0; i < npfd; i++) {

            nodes[i]->pfd.revents = pollfds[i].revents;

        }

    }



    npfd = 0;

    ctx->walking_handlers--;



    /* Run dispatch even if there were no readable fds to run timers */

    if (aio_dispatch(ctx, ret > 0)) {

        progress = true;

    }



    aio_context_release(ctx);



    return progress;

}
",457,,LABEL_1,LABEL_0,,-4,"ctx,blocking,node,i,ret,progress,timeout,walking_handlers,epoll_handler",,,,0,,0,Greedy,1,0.0006987690925598144,,
313,"static int read_gab2_sub(AVStream *st, AVPacket *pkt)

{

    if (pkt->size >= 7 &&

        !strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data + 5) == 2) {

        uint8_t desc[256];

        int score      = AVPROBE_SCORE_EXTENSION, ret;

        AVIStream *ast = st->priv_data;

        AVInputFormat *sub_demuxer;

        AVRational time_base;

        AVIOContext *pb = avio_alloc_context(pkt->data + 7,

                                             pkt->size - 7,

                                             0, NULL, NULL, NULL, NULL);

        AVProbeData pd;

        unsigned int desc_len = avio_rl32(pb);



        if (desc_len > pb->buf_end - pb->buf_ptr)

            goto error;



        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));

        avio_skip(pb, desc_len - ret);

        if (*desc)

            av_dict_set(&st->metadata, ""title"", desc, 0);



        avio_rl16(pb);   /* flags? */

        avio_rl32(pb);   /* data size */



        pd = (AVProbeData) { .buf      = pb->buf_ptr,

                             .buf_size = pb->buf_end - pb->buf_ptr };

        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))

            goto error;



        if (!(ast->sub_ctx = avformat_alloc_context()))

            goto error;



        ast->sub_ctx->pb = pb;

        if (!avformat_open_input(&ast->sub_ctx, """", sub_demuxer, NULL)) {

            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);

            *st->codec = *ast->sub_ctx->streams[0]->codec;

            ast->sub_ctx->streams[0]->codec->extradata = NULL;

            time_base = ast->sub_ctx->streams[0]->time_base;

            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);

        }

        ast->sub_buffer = pkt->data;

        memset(pkt, 0, sizeof(*pkt));

        return 1;



error:

        av_freep(&pb);

    }

    return 0;

}
",423,,LABEL_0,LABEL_1,,-4,"st,pkt,desc,ret,ast,sub_demuxer,time_base,pb,pd",,,,0,,0,Greedy,1,0.000638739267985026,,
314,"static int get_bat (CPUState *env, mmu_ctx_t *ctx,

                    target_ulong virtual, int rw, int type)

{

    target_ulong *BATlt, *BATut, *BATu, *BATl;

    target_ulong base, BEPIl, BEPIu, bl;

    int i;

    int ret = -1;



#if defined (DEBUG_BATS)

    if (loglevel != 0) {

        fprintf(logfile, ""%s: %cBAT v 0x"" ADDRX ""\n"", __func__,

                type == ACCESS_CODE ? 'I' : 'D', virtual);

    }

#endif

    switch (type) {

    case ACCESS_CODE:

        BATlt = env->IBAT[1];

        BATut = env->IBAT[0];

        break;

    default:

        BATlt = env->DBAT[1];

        BATut = env->DBAT[0];

        break;

    }

#if defined (DEBUG_BATS)

    if (loglevel != 0) {

        fprintf(logfile, ""%s...: %cBAT v 0x"" ADDRX ""\n"", __func__,

                type == ACCESS_CODE ? 'I' : 'D', virtual);

    }

#endif

    base = virtual & 0xFFFC0000;

    for (i = 0; i < 4; i++) {

        BATu = &BATut[i];

        BATl = &BATlt[i];

        BEPIu = *BATu & 0xF0000000;

        BEPIl = *BATu & 0x0FFE0000;

        bl = (*BATu & 0x00001FFC) << 15;

#if defined (DEBUG_BATS)

        if (loglevel != 0) {

            fprintf(logfile, ""%s: %cBAT%d v 0x"" ADDRX "" BATu 0x"" ADDRX

                    "" BATl 0x"" ADDRX ""\n"",

                    __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,

                    *BATu, *BATl);

        }

#endif

        if ((virtual & 0xF0000000) == BEPIu &&

            ((virtual & 0x0FFE0000) & ~bl) == BEPIl) {

            /* BAT matches */

            if ((msr_pr == 0 && (*BATu & 0x00000002)) ||

                (msr_pr == 1 && (*BATu & 0x00000001))) {

                /* Get physical address */

                ctx->raddr = (*BATl & 0xF0000000) |

                    ((virtual & 0x0FFE0000 & bl) | (*BATl & 0x0FFE0000)) |

                    (virtual & 0x0001F000);

                if (*BATl & 0x00000001)

                    ctx->prot = PAGE_READ;

                if (*BATl & 0x00000002)

                    ctx->prot = PAGE_WRITE | PAGE_READ;

#if defined (DEBUG_BATS)

                if (loglevel != 0) {

                    fprintf(logfile, ""BAT %d match: r 0x"" PADDRX

                            "" prot=%c%c\n"",

                            i, ctx->raddr, ctx->prot & PAGE_READ ? 'R' : '-',

                            ctx->prot & PAGE_WRITE ? 'W' : '-');

                }

#endif

                ret = 0;

                break;

            }

        }

    }

    if (ret < 0) {

#if defined (DEBUG_BATS)

        if (loglevel != 0) {

            fprintf(logfile, ""no BAT match for 0x"" ADDRX "":\n"", virtual);

            for (i = 0; i < 4; i++) {

                BATu = &BATut[i];

                BATl = &BATlt[i];

                BEPIu = *BATu & 0xF0000000;

                BEPIl = *BATu & 0x0FFE0000;

                bl = (*BATu & 0x00001FFC) << 15;

                fprintf(logfile, ""%s: %cBAT%d v 0x"" ADDRX "" BATu 0x"" ADDRX

                        "" BATl 0x"" ADDRX "" \n\t""

                        ""0x"" ADDRX "" 0x"" ADDRX "" 0x"" ADDRX ""\n"",

                        __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,

                        *BATu, *BATl, BEPIu, BEPIl, bl);

            }

        }

#endif

    }

    /* No hit */

    return ret;

}
",613,"static int get_bat (CPUState *env, mmu_ctx_t *ctx,

                    target_ulong initial, int rw, int type)

{

    target_ulong *BATlt, *BATut, *BATu, *BATl;

    target_ulong core, BEPIl, BEPIu, bl;

    int i;

    int ret = -1;



#if defined (DEBUG_BATS)

    if (loglevel != 0) {

        fprintf(logfile, ""%s: %cBAT v 0x"" ADDRX ""
"", __func__,

                type == ACCESS_CODE ? 'I' : 'D', initial);

    }

#endif

    switch (type) {

    case ACCESS_CODE:

        BATlt = env->IBAT[1];

        BATut = env->IBAT[0];

        break;

    default:

        BATlt = env->DBAT[1];

        BATut = env->DBAT[0];

        break;

    }

#if defined (DEBUG_BATS)

    if (loglevel != 0) {

        fprintf(logfile, ""%s...: %cBAT v 0x"" ADDRX ""
"", __func__,

                type == ACCESS_CODE ? 'I' : 'D', initial);

    }

#endif

    core = initial & 0xFFFC0000;

    for (i = 0; i < 4; i++) {

        BATu = &BATut[i];

        BATl = &BATlt[i];

        BEPIu = *BATu & 0xF0000000;

        BEPIl = *BATu & 0x0FFE0000;

        bl = (*BATu & 0x00001FFC) << 15;

#if defined (DEBUG_BATS)

        if (loglevel != 0) {

            fprintf(logfile, ""%s: %cBAT%d v 0x"" ADDRX "" BATu 0x"" ADDRX

                    "" BATl 0x"" ADDRX ""
"",

                    __func__, type == ACCESS_CODE ? 'I' : 'D', i, initial,

                    *BATu, *BATl);

        }

#endif

        if ((initial & 0xF0000000) == BEPIu &&

            ((initial & 0x0FFE0000) & ~bl) == BEPIl) {

            /* BAT matches */

            if ((msr_pr == 0 && (*BATu & 0x00000002)) ||

                (msr_pr == 1 && (*BATu & 0x00000001))) {

                /* Get physical address */

                ctx->raddr = (*BATl & 0xF0000000) |

                    ((initial & 0x0FFE0000 & bl) | (*BATl & 0x0FFE0000)) |

                    (initial & 0x0001F000);

                if (*BATl & 0x00000001)

                    ctx->prot = PAGE_READ;

                if (*BATl & 0x00000002)

                    ctx->prot = PAGE_WRITE | PAGE_READ;

#if defined (DEBUG_BATS)

                if (loglevel != 0) {

                    fprintf(logfile, ""BAT %d match: r 0x"" PADDRX

                            "" prot=%c%c
"",

                            i, ctx->raddr, ctx->prot & PAGE_READ ? 'R' : '-',

                            ctx->prot & PAGE_WRITE ? 'W' : '-');

                }

#endif

                ret = 0;

                break;

            }

        }

    }

    if (ret < 0) {

#if defined (DEBUG_BATS)

        if (loglevel != 0) {

            fprintf(logfile, ""no BAT match for 0x"" ADDRX "":
"", initial);

            for (i = 0; i < 4; i++) {

                BATu = &BATut[i];

                BATl = &BATlt[i];

                BEPIu = *BATu & 0xF0000000;

                BEPIl = *BATu & 0x0FFE0000;

                bl = (*BATu & 0x00001FFC) << 15;

                fprintf(logfile, ""%s: %cBAT%d v 0x"" ADDRX "" BATu 0x"" ADDRX

                        "" BATl 0x"" ADDRX "" 
\t""

                        ""0x"" ADDRX "" 0x"" ADDRX "" 0x"" ADDRX ""
"",

                        __func__, type == ACCESS_CODE ? 'I' : 'D', i, initial,

                        *BATu, *BATl, BEPIu, BEPIl, bl);

            }

        }

#endif

    }

    /* No hit */

    return ret;

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,ctx,virtual,rw,type,BATlt,BATut,BATu,BATl,base,BEPIl,BEPIu,bl,i",,,,85,"env:env,ctx:ctx,virtual:initial,rw:rw,type:type,BATlt:BATlt,BATut:BATut,BATu:BATu,BATl:BATl,base:core,BEPIl:BEPIl,BEPIu:BEPIu,bl:bl,i:i,",12,GA,784,0.36050034364064537,GA,
315,"void dct32(INTFLOAT *out, const INTFLOAT *tab)

{

    INTFLOAT tmp0, tmp1;



    INTFLOAT val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 ,

             val8 , val9 , val10, val11, val12, val13, val14, val15,

             val16, val17, val18, val19, val20, val21, val22, val23,

             val24, val25, val26, val27, val28, val29, val30, val31;



    /* pass 1 */

    BF0( 0, 31, COS0_0 , 1);

    BF0(15, 16, COS0_15, 5);

    /* pass 2 */

    BF( 0, 15, COS1_0 , 1);

    BF(16, 31,-COS1_0 , 1);

    /* pass 1 */

    BF0( 7, 24, COS0_7 , 1);

    BF0( 8, 23, COS0_8 , 1);

    /* pass 2 */

    BF( 7,  8, COS1_7 , 4);

    BF(23, 24,-COS1_7 , 4);

    /* pass 3 */

    BF( 0,  7, COS2_0 , 1);

    BF( 8, 15,-COS2_0 , 1);

    BF(16, 23, COS2_0 , 1);

    BF(24, 31,-COS2_0 , 1);

    /* pass 1 */

    BF0( 3, 28, COS0_3 , 1);

    BF0(12, 19, COS0_12, 2);

    /* pass 2 */

    BF( 3, 12, COS1_3 , 1);

    BF(19, 28,-COS1_3 , 1);

    /* pass 1 */

    BF0( 4, 27, COS0_4 , 1);

    BF0(11, 20, COS0_11, 2);

    /* pass 2 */

    BF( 4, 11, COS1_4 , 1);

    BF(20, 27,-COS1_4 , 1);

    /* pass 3 */

    BF( 3,  4, COS2_3 , 3);

    BF(11, 12,-COS2_3 , 3);

    BF(19, 20, COS2_3 , 3);

    BF(27, 28,-COS2_3 , 3);

    /* pass 4 */

    BF( 0,  3, COS3_0 , 1);

    BF( 4,  7,-COS3_0 , 1);

    BF( 8, 11, COS3_0 , 1);

    BF(12, 15,-COS3_0 , 1);

    BF(16, 19, COS3_0 , 1);

    BF(20, 23,-COS3_0 , 1);

    BF(24, 27, COS3_0 , 1);

    BF(28, 31,-COS3_0 , 1);







    /* pass 1 */

    BF0( 1, 30, COS0_1 , 1);

    BF0(14, 17, COS0_14, 3);

    /* pass 2 */

    BF( 1, 14, COS1_1 , 1);

    BF(17, 30,-COS1_1 , 1);

    /* pass 1 */

    BF0( 6, 25, COS0_6 , 1);

    BF0( 9, 22, COS0_9 , 1);

    /* pass 2 */

    BF( 6,  9, COS1_6 , 2);

    BF(22, 25,-COS1_6 , 2);

    /* pass 3 */

    BF( 1,  6, COS2_1 , 1);

    BF( 9, 14,-COS2_1 , 1);

    BF(17, 22, COS2_1 , 1);

    BF(25, 30,-COS2_1 , 1);



    /* pass 1 */

    BF0( 2, 29, COS0_2 , 1);

    BF0(13, 18, COS0_13, 3);

    /* pass 2 */

    BF( 2, 13, COS1_2 , 1);

    BF(18, 29,-COS1_2 , 1);

    /* pass 1 */

    BF0( 5, 26, COS0_5 , 1);

    BF0(10, 21, COS0_10, 1);

    /* pass 2 */

    BF( 5, 10, COS1_5 , 2);

    BF(21, 26,-COS1_5 , 2);

    /* pass 3 */

    BF( 2,  5, COS2_2 , 1);

    BF(10, 13,-COS2_2 , 1);

    BF(18, 21, COS2_2 , 1);

    BF(26, 29,-COS2_2 , 1);

    /* pass 4 */

    BF( 1,  2, COS3_1 , 2);

    BF( 5,  6,-COS3_1 , 2);

    BF( 9, 10, COS3_1 , 2);

    BF(13, 14,-COS3_1 , 2);

    BF(17, 18, COS3_1 , 2);

    BF(21, 22,-COS3_1 , 2);

    BF(25, 26, COS3_1 , 2);

    BF(29, 30,-COS3_1 , 2);



    /* pass 5 */

    BF1( 0,  1,  2,  3);

    BF2( 4,  5,  6,  7);

    BF1( 8,  9, 10, 11);

    BF2(12, 13, 14, 15);

    BF1(16, 17, 18, 19);

    BF2(20, 21, 22, 23);

    BF1(24, 25, 26, 27);

    BF2(28, 29, 30, 31);



    /* pass 6 */



    ADD( 8, 12);

    ADD(12, 10);

    ADD(10, 14);

    ADD(14,  9);

    ADD( 9, 13);

    ADD(13, 11);

    ADD(11, 15);



    out[ 0] = val0;

    out[16] = val1;

    out[ 8] = val2;

    out[24] = val3;

    out[ 4] = val4;

    out[20] = val5;

    out[12] = val6;

    out[28] = val7;

    out[ 2] = val8;

    out[18] = val9;

    out[10] = val10;

    out[26] = val11;

    out[ 6] = val12;

    out[22] = val13;

    out[14] = val14;

    out[30] = val15;



    ADD(24, 28);

    ADD(28, 26);

    ADD(26, 30);

    ADD(30, 25);

    ADD(25, 29);

    ADD(29, 27);

    ADD(27, 31);



    out[ 1] = val16 + val24;

    out[17] = val17 + val25;

    out[ 9] = val18 + val26;

    out[25] = val19 + val27;

    out[ 5] = val20 + val28;

    out[21] = val21 + val29;

    out[13] = val22 + val30;

    out[29] = val23 + val31;

    out[ 3] = val24 + val20;

    out[19] = val25 + val21;

    out[11] = val26 + val22;

    out[27] = val27 + val23;

    out[ 7] = val28 + val18;

    out[23] = val29 + val19;

    out[15] = val30 + val17;

    out[31] = val31;

}
",1421,,LABEL_1,LABEL_0,,-4,"out,tab,tmp0,tmp1,val0,val1,val2,val3,val4,val5,val6,val7,val8,val9,val10,val11,val12,val13,val14,val15,val16,val17,val18,val19,val20,val21,val22,val23,val24,val25,val26,val27,val28,val29,val30,val31",,,,0,,0,Greedy,1,0.0011308868726094565,,
316,"void slirp_cleanup(Slirp *slirp)

{

    TAILQ_REMOVE(&slirp_instances, slirp, entry);



    unregister_savevm(""slirp"", slirp);



    qemu_free(slirp->tftp_prefix);

    qemu_free(slirp->bootp_filename);

    qemu_free(slirp);

}
",49,,LABEL_0,LABEL_0,LABEL_0,-1,slirp,,,,0,,0,GA,328,0.11474462747573852,failed,
317,"void cpu_exec_init(CPUState *env)

{

    CPUState **penv;

    int cpu_index;



    if (!code_gen_ptr) {

        code_gen_ptr = code_gen_buffer;

        page_init();

        io_mem_init();

    }

    env->next_cpu = NULL;

    penv = &first_cpu;

    cpu_index = 0;

    while (*penv != NULL) {

        penv = (CPUState **)&(*penv)->next_cpu;

        cpu_index++;

    }

    env->cpu_index = cpu_index;


    *penv = env;

}",91,,LABEL_1,LABEL_1,LABEL_1,-1,"env,penv,cpu_index",,,,0,,0,GA,699,0.251453705628713,failed,
318,"static int decode_init_mp3on4(AVCodecContext * avctx)

{

    MP3On4DecodeContext *s = avctx->priv_data;

    int i;



    if ((avctx->extradata_size < 2) || (avctx->extradata == NULL)) {

        av_log(avctx, AV_LOG_ERROR, ""Codec extradata missing or too short.\n"");

        return -1;

    }



    s->chan_cfg = (((unsigned char *)avctx->extradata)[1] >> 3) & 0x0f;

    s->frames = mp3Frames[s->chan_cfg];

    if(!s->frames) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid channel config number.\n"");

        return -1;

    }

    avctx->channels = mp3Channels[s->chan_cfg];



    /* Init the first mp3 decoder in standard way, so that all tables get builded

     * We replace avctx->priv_data with the context of the first decoder so that

     * decode_init() does not have to be changed.

     * Other decoders will be inited here copying data from the first context

     */

    // Allocate zeroed memory for the first decoder context

    s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext));

    // Put decoder context in place to make init_decode() happy

    avctx->priv_data = s->mp3decctx[0];

    decode_init(avctx);

    // Restore mp3on4 context pointer

    avctx->priv_data = s;

    s->mp3decctx[0]->adu_mode = 1; // Set adu mode



    /* Create a separate codec/context for each frame (first is already ok).

     * Each frame is 1 or 2 channels - up to 5 frames allowed

     */

    for (i = 1; i < s->frames; i++) {

        s->mp3decctx[i] = av_mallocz(sizeof(MPADecodeContext));

        s->mp3decctx[i]->compute_antialias = s->mp3decctx[0]->compute_antialias;

        s->mp3decctx[i]->adu_mode = 1;

        s->mp3decctx[i]->avctx = avctx;

    }



    return 0;

}
",410,,LABEL_0,LABEL_0,LABEL_0,-1,"avctx,s,i",,,,0,,0,GA,753,0.31340461572011313,failed,
319,"static void test_qemu_strtosz_metric(void)

{

    const char *str = ""12345k"";

    char *endptr = NULL;

    int64_t res;



    res = qemu_strtosz_metric(str, &endptr);

    g_assert_cmpint(res, ==, 12345000);

    g_assert(endptr == str + 6);

}
",53,"static void test_qemu_strtosz_metric(void)

{

    const char *tr = ""12345k"";

    char *endPtr = NULL;

    int64_t pres;



   press = qemu_strtosz_metric(tr, &endPtr);

    g_assert_cmpint(pres, ==, 12345000);

    g_assertendPtrr == tr + 6);

}
",LABEL_0,LABEL_0,LABEL_1,1,"str,endptr,res",,,,0,"str:tr,endptr:endPtr,res:pres,",0,GA,294,0.10347850322723388,GA,
320,"static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)

{

    /* We don't actually refresh here, but just return data queried in

     * iscsi_open(): iscsi targets don't change their limits. */



    IscsiLun *iscsilun = bs->opaque;

    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;



    bs->request_alignment = iscsilun->block_size;



    if (iscsilun->bl.max_xfer_len) {

        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);

    }



    if (max_xfer_len * iscsilun->block_size < INT_MAX) {

        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;

    }



    if (iscsilun->lbp.lbpu) {

        if (iscsilun->bl.max_unmap < 0xffffffff) {

            bs->bl.max_discard =

                sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun);

        }

        bs->bl.discard_alignment =

            sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun);

    } else {

        bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS;

    }



    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {

        bs->bl.max_pwrite_zeroes =

            iscsilun->bl.max_ws_len * iscsilun->block_size;

    }

    if (iscsilun->lbp.lbpws) {

        bs->bl.pwrite_zeroes_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;

    }

    if (iscsilun->bl.opt_xfer_len &&

        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {

        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *

                                        iscsilun->block_size);

    }

}
",337,,LABEL_0,LABEL_0,LABEL_0,-1,"bs,errp,iscsilun",,,,0,,0,GA,879,0.3482210119565328,failed,
321,"static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *track = tracks->tracks[i];

        const char *type    = track->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, type, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    return 0;

}
",179,"static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char directoryName[100], filename[500];

    int is, j;



    for (is = start_index; is < tracks->nb_tracks; is++) {

        struct Track *ttrack= tracks->tracks[is];

        const char *y    = track->is_video ? ""video"" : ""audio"";

        snprintf(directoryName, sizeof(directoryName), ""QualityLevels(%d)"", track->bitrate);

        mkdir(directoryName, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     directoryName, y, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"tracks,start_index,in,dirname,filename,i,j,track,type",,,,25,"tracks:tracks,start_index:start_index,in:in,dirname:directoryName,filename:filename,i:is,j:j,track:track,type:y,",6,GA,459,0.17140363454818724,GA,
322,"static int block_save_iterate(QEMUFile *f, void *opaque)

{

    int ret;

    int64_t last_ftell = qemu_ftell(f);



    DPRINTF(""Enter save live iterate submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    blk_mig_reset_dirty_cursor();



    /* control the rate of transfer */

    blk_mig_lock();

    while ((block_mig_state.submitted +

            block_mig_state.read_done) * BLOCK_SIZE <

           qemu_file_get_rate_limit(f)) {

        blk_mig_unlock();

        if (block_mig_state.bulk_completed == 0) {

            /* first finish the bulk phase */

            if (blk_mig_save_bulked_block(f) == 0) {

                /* finished saving bulk on all devices */

                block_mig_state.bulk_completed = 1;

            }

            ret = 0;

        } else {

            /* Always called with iothread lock taken for

             * simplicity, block_save_complete also calls it.

             */

            qemu_mutex_lock_iothread();

            ret = blk_mig_save_dirty_block(f, 1);

            qemu_mutex_unlock_iothread();

        }

        if (ret < 0) {

            return ret;

        }

        blk_mig_lock();

        if (ret != 0) {

            /* no more dirty blocks */

            break;

        }

    }

    blk_mig_unlock();



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    qemu_put_be64(f, BLK_MIG_FLAG_EOS);

    return qemu_ftell(f) - last_ftell;

}
",267,,LABEL_1,LABEL_0,,-4,"f,opaque,ret",,,,0,,0,Greedy,1,0.0005961338678995769,,
323,"static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,

                         const char *filt_name, const char *args, AVClass *log_ctx)

{

    AVFilter *filt;

    char inst_name[30];

    char tmp_args[256];

    int ret;



    snprintf(inst_name, sizeof(inst_name), ""Parsed filter %d %s"", index, filt_name);



    filt = avfilter_get_by_name(filt_name);



    if (!filt) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""No such filter: '%s'\n"", filt_name);

        return AVERROR(EINVAL);

    }



    ret = avfilter_open(filt_ctx, filt, inst_name);

    if (!*filt_ctx) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Error creating filter '%s'\n"", filt_name);

        return ret;

    }



    if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) {

        avfilter_free(*filt_ctx);

        return ret;

    }



    if (!strcmp(filt_name, ""scale"") && !strstr(args, ""flags"")) {

        snprintf(tmp_args, sizeof(tmp_args), ""%s:%s"",

                 args, ctx->scale_sws_opts);

        args = tmp_args;

    }



    if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Error initializing filter '%s' with args '%s'\n"", filt_name, args);

        return ret;

    }



    return 0;

}
",260,,LABEL_1,LABEL_0,,-4,"filt_ctx,ctx,index,filt_name,args,log_ctx,filt,inst_name,tmp_args,ret",,,,0,,0,Greedy,1,0.0005720218022664388,,
324,"void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))

{

    while (queue->p_head)

        free_func(ff_schro_queue_pop(queue));

}
",34,"void ff_schro_queue_free(FFSchroQueue *queue, void (*freefuncfunction)(void *))

{

    while (queue->p_head)

        freefuncfunction(ff_schro_queue_pop(queue));

}
",LABEL_1,LABEL_1,LABEL_0,1,"queue,free_func",,,,3,"queue:queue,free_func:freefuncfunction,",1,GA,99,0.034789129098256426,GA,
325,"envlist_free(envlist_t *envlist)

{

	struct envlist_entry *entry;



	assert(envlist != NULL);



	while (envlist->el_entries.lh_first != NULL) {

		entry = envlist->el_entries.lh_first;

		LIST_REMOVE(entry, ev_link);



		free((char *)entry->ev_var);

		free(entry);

	}

	free(envlist);

}
",72,,LABEL_0,LABEL_1,,-4,entry,,,,0,,0,Greedy,1,0.0004685322443644206,,
326,"static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)

{

    static uint32_t bmap[INPUT_BUTTON__MAX] = {

        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),

        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),

        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),

        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),

        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),

    };

    static uint32_t prev_state;



    if (prev_state != state) {

        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);

        prev_state = state;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,

                             real_screen->w);

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,

                             real_screen->h);

    } else {

        if (guest_cursor) {

            x -= guest_x;

            y -= guest_y;

            guest_x += x;

            guest_y += y;

            dx = x;

            dy = y;

        }

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx);

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, dy);

    }

    qemu_input_event_sync();

}
",209,"static void sdl_send_mouse_event(int dc, int yer, int x, int y, int state)

{

    static uint32_t cMap[INPUT_BUTTON__MAX] = {

        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),

        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),

        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),

        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),

        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),

    };

    static uint32_t prev_State;



    if (prev_State != state) {

        qemu_input_update_buttons(dcl->con, cMap, prev_State, state);

        prev_State = state;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,

                             real_screen->w);

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,

                             real_screen->h);

    } else {

        if (guest_cursor) {

            x -= guest_x;

            y -= guest_y;

            guest_x += x;

            guest_y += y;

            dc = x;

            yer = y;

        }

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dc);

        qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, yer);

    }

    qemu_input_event_sync();

}
",LABEL_0,LABEL_0,LABEL_1,1,"dx,dy,x,y,state,bmap,prev_state",,,,14,"dx:dc,dy:yer,x:x,y:y,state:state,bmap:cMap,prev_state:prev_State,",3,GA,336,0.1280941883722941,GA,
327,"static FWCfgState *bochs_bios_init(void)

{

    FWCfgState *fw_cfg;

    uint8_t *smbios_tables, *smbios_anchor;

    size_t smbios_tables_len, smbios_anchor_len;

    uint64_t *numa_fw_cfg;

    int i, j;

    unsigned int apic_id_limit = pc_apic_id_limit(max_cpus);



    fw_cfg = fw_cfg_init_io(BIOS_CFG_IOPORT);

    /* FW_CFG_MAX_CPUS is a bit confusing/problematic on x86:

     *

     * SeaBIOS needs FW_CFG_MAX_CPUS for CPU hotplug, but the CPU hotplug

     * QEMU<->SeaBIOS interface is not based on the ""CPU index"", but on the APIC

     * ID of hotplugged CPUs[1]. This means that FW_CFG_MAX_CPUS is not the

     * ""maximum number of CPUs"", but the ""limit to the APIC ID values SeaBIOS

     * may see"".

     *

     * So, this means we must not use max_cpus, here, but the maximum possible

     * APIC ID value, plus one.

     *

     * [1] The only kind of ""CPU identifier"" used between SeaBIOS and QEMU is

     *     the APIC ID, not the ""CPU index""

     */

    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPUS, (uint16_t)apic_id_limit);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_bytes(fw_cfg, FW_CFG_ACPI_TABLES,

                     acpi_tables, acpi_tables_len);

    fw_cfg_add_i32(fw_cfg, FW_CFG_IRQ0_OVERRIDE, kvm_allows_irq0_override());



    smbios_tables = smbios_get_table_legacy(&smbios_tables_len);

    if (smbios_tables) {

        fw_cfg_add_bytes(fw_cfg, FW_CFG_SMBIOS_ENTRIES,

                         smbios_tables, smbios_tables_len);

    }



    smbios_get_tables(&smbios_tables, &smbios_tables_len,

                      &smbios_anchor, &smbios_anchor_len);

    if (smbios_anchor) {

        fw_cfg_add_file(fw_cfg, ""etc/smbios/smbios-tables"",

                        smbios_tables, smbios_tables_len);

        fw_cfg_add_file(fw_cfg, ""etc/smbios/smbios-anchor"",

                        smbios_anchor, smbios_anchor_len);

    }



    fw_cfg_add_bytes(fw_cfg, FW_CFG_E820_TABLE,

                     &e820_reserve, sizeof(e820_reserve));

    fw_cfg_add_file(fw_cfg, ""etc/e820"", e820_table,

                    sizeof(struct e820_entry) * e820_entries);



    fw_cfg_add_bytes(fw_cfg, FW_CFG_HPET, &hpet_cfg, sizeof(hpet_cfg));

    /* allocate memory for the NUMA channel: one (64bit) word for the number

     * of nodes, one word for each VCPU->node and one word for each node to

     * hold the amount of memory.

     */

    numa_fw_cfg = g_new0(uint64_t, 1 + apic_id_limit + nb_numa_nodes);

    numa_fw_cfg[0] = cpu_to_le64(nb_numa_nodes);

    for (i = 0; i < max_cpus; i++) {

        unsigned int apic_id = x86_cpu_apic_id_from_index(i);

        assert(apic_id < apic_id_limit);

        for (j = 0; j < nb_numa_nodes; j++) {

            if (test_bit(i, numa_info[j].node_cpu)) {

                numa_fw_cfg[apic_id + 1] = cpu_to_le64(j);

                break;

            }

        }

    }

    for (i = 0; i < nb_numa_nodes; i++) {

        numa_fw_cfg[apic_id_limit + 1 + i] = cpu_to_le64(numa_info[i].node_mem);

    }

    fw_cfg_add_bytes(fw_cfg, FW_CFG_NUMA, numa_fw_cfg,

                     (1 + apic_id_limit + nb_numa_nodes) *

                     sizeof(*numa_fw_cfg));



    return fw_cfg;

}
",556,,LABEL_0,LABEL_0,LABEL_0,-1,"fw_cfg,smbios_tables,smbios_anchor,smbios_tables_len,smbios_anchor_len,numa_fw_cfg,i,j",,,,0,,0,GA,1639,0.7275311311086019,failed,
328,"void do_smm_enter(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    CPUState *cs = CPU(cpu);

    target_ulong sm_state;

    SegmentCache *dt;

    int i, offset;



    qemu_log_mask(CPU_LOG_INT, ""SMM: enter\n"");

    log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP);



    env->hflags |= HF_SMM_MASK;

    if (env->hflags2 & HF2_NMI_MASK) {

        env->hflags2 |= HF2_SMM_INSIDE_NMI_MASK;

    } else {

        env->hflags2 |= HF2_NMI_MASK;

    }

    cpu_smm_update(env);



    sm_state = env->smbase + 0x8000;



#ifdef TARGET_X86_64

    for (i = 0; i < 6; i++) {

        dt = &env->segs[i];

        offset = 0x7e00 + i * 16;

        x86_stw_phys(cs, sm_state + offset, dt->selector);

        x86_stw_phys(cs, sm_state + offset + 2, (dt->flags >> 8) & 0xf0ff);

        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);

        x86_stq_phys(cs, sm_state + offset + 8, dt->base);

    }



    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);

    x86_stl_phys(cs, sm_state + 0x7e64, env->gdt.limit);



    x86_stw_phys(cs, sm_state + 0x7e70, env->ldt.selector);

    x86_stq_phys(cs, sm_state + 0x7e78, env->ldt.base);

    x86_stl_phys(cs, sm_state + 0x7e74, env->ldt.limit);

    x86_stw_phys(cs, sm_state + 0x7e72, (env->ldt.flags >> 8) & 0xf0ff);



    x86_stq_phys(cs, sm_state + 0x7e88, env->idt.base);

    x86_stl_phys(cs, sm_state + 0x7e84, env->idt.limit);



    x86_stw_phys(cs, sm_state + 0x7e90, env->tr.selector);

    x86_stq_phys(cs, sm_state + 0x7e98, env->tr.base);

    x86_stl_phys(cs, sm_state + 0x7e94, env->tr.limit);

    x86_stw_phys(cs, sm_state + 0x7e92, (env->tr.flags >> 8) & 0xf0ff);



    x86_stq_phys(cs, sm_state + 0x7ed0, env->efer);



    x86_stq_phys(cs, sm_state + 0x7ff8, env->regs[R_EAX]);

    x86_stq_phys(cs, sm_state + 0x7ff0, env->regs[R_ECX]);

    x86_stq_phys(cs, sm_state + 0x7fe8, env->regs[R_EDX]);

    x86_stq_phys(cs, sm_state + 0x7fe0, env->regs[R_EBX]);

    x86_stq_phys(cs, sm_state + 0x7fd8, env->regs[R_ESP]);

    x86_stq_phys(cs, sm_state + 0x7fd0, env->regs[R_EBP]);

    x86_stq_phys(cs, sm_state + 0x7fc8, env->regs[R_ESI]);

    x86_stq_phys(cs, sm_state + 0x7fc0, env->regs[R_EDI]);

    for (i = 8; i < 16; i++) {

        x86_stq_phys(cs, sm_state + 0x7ff8 - i * 8, env->regs[i]);

    }

    x86_stq_phys(cs, sm_state + 0x7f78, env->eip);

    x86_stl_phys(cs, sm_state + 0x7f70, cpu_compute_eflags(env));

    x86_stl_phys(cs, sm_state + 0x7f68, env->dr[6]);

    x86_stl_phys(cs, sm_state + 0x7f60, env->dr[7]);



    x86_stl_phys(cs, sm_state + 0x7f48, env->cr[4]);

    x86_stq_phys(cs, sm_state + 0x7f50, env->cr[3]);

    x86_stl_phys(cs, sm_state + 0x7f58, env->cr[0]);



    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);

    x86_stl_phys(cs, sm_state + 0x7f00, env->smbase);

#else

    x86_stl_phys(cs, sm_state + 0x7ffc, env->cr[0]);

    x86_stl_phys(cs, sm_state + 0x7ff8, env->cr[3]);

    x86_stl_phys(cs, sm_state + 0x7ff4, cpu_compute_eflags(env));

    x86_stl_phys(cs, sm_state + 0x7ff0, env->eip);

    x86_stl_phys(cs, sm_state + 0x7fec, env->regs[R_EDI]);

    x86_stl_phys(cs, sm_state + 0x7fe8, env->regs[R_ESI]);

    x86_stl_phys(cs, sm_state + 0x7fe4, env->regs[R_EBP]);

    x86_stl_phys(cs, sm_state + 0x7fe0, env->regs[R_ESP]);

    x86_stl_phys(cs, sm_state + 0x7fdc, env->regs[R_EBX]);

    x86_stl_phys(cs, sm_state + 0x7fd8, env->regs[R_EDX]);

    x86_stl_phys(cs, sm_state + 0x7fd4, env->regs[R_ECX]);

    x86_stl_phys(cs, sm_state + 0x7fd0, env->regs[R_EAX]);

    x86_stl_phys(cs, sm_state + 0x7fcc, env->dr[6]);

    x86_stl_phys(cs, sm_state + 0x7fc8, env->dr[7]);



    x86_stl_phys(cs, sm_state + 0x7fc4, env->tr.selector);

    x86_stl_phys(cs, sm_state + 0x7f64, env->tr.base);

    x86_stl_phys(cs, sm_state + 0x7f60, env->tr.limit);

    x86_stl_phys(cs, sm_state + 0x7f5c, (env->tr.flags >> 8) & 0xf0ff);



    x86_stl_phys(cs, sm_state + 0x7fc0, env->ldt.selector);

    x86_stl_phys(cs, sm_state + 0x7f80, env->ldt.base);

    x86_stl_phys(cs, sm_state + 0x7f7c, env->ldt.limit);

    x86_stl_phys(cs, sm_state + 0x7f78, (env->ldt.flags >> 8) & 0xf0ff);



    x86_stl_phys(cs, sm_state + 0x7f74, env->gdt.base);

    x86_stl_phys(cs, sm_state + 0x7f70, env->gdt.limit);



    x86_stl_phys(cs, sm_state + 0x7f58, env->idt.base);

    x86_stl_phys(cs, sm_state + 0x7f54, env->idt.limit);



    for (i = 0; i < 6; i++) {

        dt = &env->segs[i];

        if (i < 3) {

            offset = 0x7f84 + i * 12;

        } else {

            offset = 0x7f2c + (i - 3) * 12;

        }

        x86_stl_phys(cs, sm_state + 0x7fa8 + i * 4, dt->selector);

        x86_stl_phys(cs, sm_state + offset + 8, dt->base);

        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);

        x86_stl_phys(cs, sm_state + offset, (dt->flags >> 8) & 0xf0ff);

    }

    x86_stl_phys(cs, sm_state + 0x7f14, env->cr[4]);



    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);

    x86_stl_phys(cs, sm_state + 0x7ef8, env->smbase);

#endif

    /* init SMM cpu state */



#ifdef TARGET_X86_64

    cpu_load_efer(env, 0);

#endif

    cpu_load_eflags(env, 0, ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C |

                              DF_MASK));

    env->eip = 0x00008000;

    cpu_x86_update_cr0(env,

                       env->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK |

                                      CR0_PG_MASK));

    cpu_x86_update_cr4(env, 0);

    env->dr[7] = 0x00000400;



    cpu_x86_load_seg_cache(env, R_CS, (env->smbase >> 4) & 0xffff, env->smbase,

                           0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

}
",1575,"void do_smm_enter(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    CPUState *sk = CPU(cpu);

    target_ulong sm_state;

    SegmentCache *tf;

    int i, offset;



    qemu_log_mask(CPU_LOG_INT, ""SMM: enter
"");

    log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP);



    env->hflags |= HF_SMM_MASK;

    if (env->hflags2 & HF2_NMI_MASK) {

        env->hflags2 |= HF2_SMM_INSIDE_NMI_MASK;

    } else {

        env->hflags2 |= HF2_NMI_MASK;

    }

    cpu_smm_update(env);



    sm_state = env->smbase + 0x8000;



#ifdef TARGET_X86_64

    for (i = 0; i < 6; i++) {

        tf = &env->segs[i];

        offset = 0x7e00 + i * 16;

        x86_stw_phys(sk, sm_state + offset, tf->selector);

        x86_stw_phys(sk, sm_state + offset + 2, (tf->flags >> 8) & 0xf0ff);

        x86_stl_phys(sk, sm_state + offset + 4, tf->limit);

        x86_stq_phys(sk, sm_state + offset + 8, tf->base);

    }



    x86_stq_phys(sk, sm_state + 0x7e68, env->gdt.base);

    x86_stl_phys(sk, sm_state + 0x7e64, env->gdt.limit);



    x86_stw_phys(sk, sm_state + 0x7e70, env->ldt.selector);

    x86_stq_phys(sk, sm_state + 0x7e78, env->ldt.base);

    x86_stl_phys(sk, sm_state + 0x7e74, env->ldt.limit);

    x86_stw_phys(sk, sm_state + 0x7e72, (env->ldt.flags >> 8) & 0xf0ff);



    x86_stq_phys(sk, sm_state + 0x7e88, env->idt.base);

    x86_stl_phys(sk, sm_state + 0x7e84, env->idt.limit);



    x86_stw_phys(sk, sm_state + 0x7e90, env->tr.selector);

    x86_stq_phys(sk, sm_state + 0x7e98, env->tr.base);

    x86_stl_phys(sk, sm_state + 0x7e94, env->tr.limit);

    x86_stw_phys(sk, sm_state + 0x7e92, (env->tr.flags >> 8) & 0xf0ff);



    x86_stq_phys(sk, sm_state + 0x7ed0, env->efer);



    x86_stq_phys(sk, sm_state + 0x7ff8, env->regs[R_EAX]);

    x86_stq_phys(sk, sm_state + 0x7ff0, env->regs[R_ECX]);

    x86_stq_phys(sk, sm_state + 0x7fe8, env->regs[R_EDX]);

    x86_stq_phys(sk, sm_state + 0x7fe0, env->regs[R_EBX]);

    x86_stq_phys(sk, sm_state + 0x7fd8, env->regs[R_ESP]);

    x86_stq_phys(sk, sm_state + 0x7fd0, env->regs[R_EBP]);

    x86_stq_phys(sk, sm_state + 0x7fc8, env->regs[R_ESI]);

    x86_stq_phys(sk, sm_state + 0x7fc0, env->regs[R_EDI]);

    for (i = 8; i < 16; i++) {

        x86_stq_phys(sk, sm_state + 0x7ff8 - i * 8, env->regs[i]);

    }

    x86_stq_phys(sk, sm_state + 0x7f78, env->eip);

    x86_stl_phys(sk, sm_state + 0x7f70, cpu_compute_eflags(env));

    x86_stl_phys(sk, sm_state + 0x7f68, env->dr[6]);

    x86_stl_phys(sk, sm_state + 0x7f60, env->dr[7]);



    x86_stl_phys(sk, sm_state + 0x7f48, env->cr[4]);

    x86_stq_phys(sk, sm_state + 0x7f50, env->cr[3]);

    x86_stl_phys(sk, sm_state + 0x7f58, env->cr[0]);



    x86_stl_phys(sk, sm_state + 0x7efc, SMM_REVISION_ID);

    x86_stl_phys(sk, sm_state + 0x7f00, env->smbase);

#else

    x86_stl_phys(sk, sm_state + 0x7ffc, env->cr[0]);

    x86_stl_phys(sk, sm_state + 0x7ff8, env->cr[3]);

    x86_stl_phys(sk, sm_state + 0x7ff4, cpu_compute_eflags(env));

    x86_stl_phys(sk, sm_state + 0x7ff0, env->eip);

    x86_stl_phys(sk, sm_state + 0x7fec, env->regs[R_EDI]);

    x86_stl_phys(sk, sm_state + 0x7fe8, env->regs[R_ESI]);

    x86_stl_phys(sk, sm_state + 0x7fe4, env->regs[R_EBP]);

    x86_stl_phys(sk, sm_state + 0x7fe0, env->regs[R_ESP]);

    x86_stl_phys(sk, sm_state + 0x7fdc, env->regs[R_EBX]);

    x86_stl_phys(sk, sm_state + 0x7fd8, env->regs[R_EDX]);

    x86_stl_phys(sk, sm_state + 0x7fd4, env->regs[R_ECX]);

    x86_stl_phys(sk, sm_state + 0x7fd0, env->regs[R_EAX]);

    x86_stl_phys(sk, sm_state + 0x7fcc, env->dr[6]);

    x86_stl_phys(sk, sm_state + 0x7fc8, env->dr[7]);



    x86_stl_phys(sk, sm_state + 0x7fc4, env->tr.selector);

    x86_stl_phys(sk, sm_state + 0x7f64, env->tr.base);

    x86_stl_phys(sk, sm_state + 0x7f60, env->tr.limit);

    x86_stl_phys(sk, sm_state + 0x7f5c, (env->tr.flags >> 8) & 0xf0ff);



    x86_stl_phys(sk, sm_state + 0x7fc0, env->ldt.selector);

    x86_stl_phys(sk, sm_state + 0x7f80, env->ldt.base);

    x86_stl_phys(sk, sm_state + 0x7f7c, env->ldt.limit);

    x86_stl_phys(sk, sm_state + 0x7f78, (env->ldt.flags >> 8) & 0xf0ff);



    x86_stl_phys(sk, sm_state + 0x7f74, env->gdt.base);

    x86_stl_phys(sk, sm_state + 0x7f70, env->gdt.limit);



    x86_stl_phys(sk, sm_state + 0x7f58, env->idt.base);

    x86_stl_phys(sk, sm_state + 0x7f54, env->idt.limit);



    for (i = 0; i < 6; i++) {

        tf = &env->segs[i];

        if (i < 3) {

            offset = 0x7f84 + i * 12;

        } else {

            offset = 0x7f2c + (i - 3) * 12;

        }

        x86_stl_phys(sk, sm_state + 0x7fa8 + i * 4, tf->selector);

        x86_stl_phys(sk, sm_state + offset + 8, tf->base);

        x86_stl_phys(sk, sm_state + offset + 4, tf->limit);

        x86_stl_phys(sk, sm_state + offset, (tf->flags >> 8) & 0xf0ff);

    }

    x86_stl_phys(sk, sm_state + 0x7f14, env->cr[4]);



    x86_stl_phys(sk, sm_state + 0x7efc, SMM_REVISION_ID);

    x86_stl_phys(sk, sm_state + 0x7ef8, env->smbase);

#endif

    /* init SMM cpu state */



#ifdef TARGET_X86_64

    cpu_load_efer(env, 0);

#endif

    cpu_load_eflags(env, 0, ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C |

                              DF_MASK));

    env->eip = 0x00008000;

    cpu_x86_update_cr0(env,

                       env->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK |

                                      CR0_PG_MASK));

    cpu_x86_update_cr4(env, 0);

    env->dr[7] = 0x00000400;



    cpu_x86_load_seg_cache(env, R_CS, (env->smbase >> 4) & 0xffff, env->smbase,

                           0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

    cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffffffff,

                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |

                           DESC_A_MASK);

}
",LABEL_0,LABEL_0,LABEL_1,1,"cpu,env,cs,sm_state,dt,i,offset",,,,188,"cpu:cpu,env:env,cs:sk,sm_state:sm_state,dt:tf,i:i,offset:offset,",5,GA,513,0.31153088013331093,GA,
329,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",84,"static int parse_uint8(DeviceState *grad, Property *prop, const char *test)

{

    uint8_t *poffset= qdev_get_prop_ptr(grad, prop);

    const char *cfmt;



    /* accept both hex and decimal */

    fcfmt= strncasecmp(test, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(test, fmtcfmtffset) != 1)

        return -EINVAL;

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"dev,prop,str,ptr,fmt",,,,2,"dev:grad,prop:prop,str:test,ptr:offset,fmt:cfmt,",1,GA,216,0.07733719348907471,GA,
330,"static int assigned_initfn(struct PCIDevice *pci_dev)

{

    AssignedDevice *dev = DO_UPCAST(AssignedDevice, dev, pci_dev);

    uint8_t e_intx;

    int r;

    Error *local_err = NULL;



    if (!kvm_enabled()) {

        error_report(""pci-assign: error: requires KVM support"");

        return -1;

    }



    if (!dev->host.domain && !dev->host.bus && !dev->host.slot &&

        !dev->host.function) {

        error_report(""pci-assign: error: no host device specified"");

        return -1;

    }



    /*

     * Set up basic config space access control. Will be further refined during

     * device initialization.

     */

    assigned_dev_emulate_config_read(dev, 0, PCI_CONFIG_SPACE_SIZE);

    assigned_dev_direct_config_read(dev, PCI_STATUS, 2);

    assigned_dev_direct_config_read(dev, PCI_REVISION_ID, 1);

    assigned_dev_direct_config_read(dev, PCI_CLASS_PROG, 3);

    assigned_dev_direct_config_read(dev, PCI_CACHE_LINE_SIZE, 1);

    assigned_dev_direct_config_read(dev, PCI_LATENCY_TIMER, 1);

    assigned_dev_direct_config_read(dev, PCI_BIST, 1);

    assigned_dev_direct_config_read(dev, PCI_CARDBUS_CIS, 4);

    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_VENDOR_ID, 2);

    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_ID, 2);

    assigned_dev_direct_config_read(dev, PCI_CAPABILITY_LIST + 1, 7);

    assigned_dev_direct_config_read(dev, PCI_MIN_GNT, 1);

    assigned_dev_direct_config_read(dev, PCI_MAX_LAT, 1);

    memcpy(dev->emulate_config_write, dev->emulate_config_read,

           sizeof(dev->emulate_config_read));



    get_real_device(dev, &local_err);

    if (local_err) {

        qerror_report_err(local_err);

        error_free(local_err);

        goto out;

    }



    if (assigned_device_pci_cap_init(pci_dev, &local_err) < 0) {

        qerror_report_err(local_err);

        error_free(local_err);

        goto out;

    }



    /* intercept MSI-X entry page in the MMIO */

    if (dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {

        assigned_dev_register_msix_mmio(dev, &local_err);

        if (local_err) {

            qerror_report_err(local_err);

            error_free(local_err);

            goto out;

        }

    }



    /* handle real device's MMIO/PIO BARs */

    assigned_dev_register_regions(dev->real_device.regions,

                                  dev->real_device.region_number, dev,

                                  &local_err);

    if (local_err) {

        qerror_report_err(local_err);

        error_free(local_err);

        goto out;

    }



    /* handle interrupt routing */

    e_intx = dev->dev.config[PCI_INTERRUPT_PIN] - 1;

    dev->intpin = e_intx;

    dev->intx_route.mode = PCI_INTX_DISABLED;

    dev->intx_route.irq = -1;



    /* assign device to guest */

    r = assign_device(dev);

    if (r < 0) {

        goto out;

    }



    /* assign legacy INTx to the device */

    r = assign_intx(dev);

    if (r < 0) {

        goto assigned_out;

    }



    assigned_dev_load_option_rom(dev);



    add_boot_device_path(dev->bootindex, &pci_dev->qdev, NULL);



    return 0;



assigned_out:

    deassign_device(dev);

out:

    free_assigned_device(dev);

    return -1;

}
",570,,LABEL_0,LABEL_0,LABEL_0,-1,"pci_dev,dev,e_intx,r,local_err",,,,0,,0,GA,1003,0.45226091146469116,failed,
331,"envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *tmpenv, *envvar;

	char *envsave = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((tmpenv = strdup(env)) == NULL)

		return (errno);



	envvar = strtok_r(tmpenv, "","", &envsave);

	while (envvar != NULL) {

		if ((*callback)(envlist, envvar) != 0) {

			free(tmpenv);

			return (errno);

		}

		envvar = strtok_r(NULL, "","", &envsave);

	}



	free(tmpenv);

	return (0);

}
",180,"envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *fakeenv, *environmentstack;

	char *enversaves = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((fakeenv = strdup(env)) == NULL)

		return (errno);



	eenvironmentstack= strtok_r(fakeenv, "","", &enversaves);

	while (environmentstack != NULL) {

		if ((*callback)(envlist, environmentstack) != 0) {

			free(fakeenv);

			return (errno);

		}

		environmentstack = strtok_r(NULL, "","", &enversaves);

	}



	free(fakeenv);

	return (0);

}
",LABEL_1,LABEL_1,LABEL_0,1,"tmpenv,envvar,envsave",,,,0,"tmpenv:fakeenv,envvar:environmentstack,envsave:enversaves,",0,GA,166,0.061691149075826006,GA,
332,"static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus,

                                   uint8_t devfn, hwaddr addr, bool is_write,

                                   IOMMUTLBEntry *entry)

{

    IntelIOMMUState *s = vtd_as->iommu_state;

    VTDContextEntry ce;

    uint8_t bus_num = pci_bus_num(bus);

    VTDContextCacheEntry *cc_entry = &vtd_as->context_cache_entry;

    uint64_t slpte, page_mask;

    uint32_t level;

    uint16_t source_id = vtd_make_source_id(bus_num, devfn);

    int ret_fr;

    bool is_fpd_set = false;

    bool reads = true;

    bool writes = true;

    uint8_t access_flags;

    VTDIOTLBEntry *iotlb_entry;



    /*

     * We have standalone memory region for interrupt addresses, we

     * should never receive translation requests in this region.

     */

    assert(!vtd_is_interrupt_addr(addr));



    /* Try to fetch slpte form IOTLB */

    iotlb_entry = vtd_lookup_iotlb(s, source_id, addr);

    if (iotlb_entry) {

        trace_vtd_iotlb_page_hit(source_id, addr, iotlb_entry->slpte,

                                 iotlb_entry->domain_id);

        slpte = iotlb_entry->slpte;

        access_flags = iotlb_entry->access_flags;

        page_mask = iotlb_entry->mask;

        goto out;

    }



    /* Try to fetch context-entry from cache first */

    if (cc_entry->context_cache_gen == s->context_cache_gen) {

        trace_vtd_iotlb_cc_hit(bus_num, devfn, cc_entry->context_entry.hi,

                               cc_entry->context_entry.lo,

                               cc_entry->context_cache_gen);

        ce = cc_entry->context_entry;

        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;

    } else {

        ret_fr = vtd_dev_to_context_entry(s, bus_num, devfn, &ce);

        is_fpd_set = ce.lo & VTD_CONTEXT_ENTRY_FPD;

        if (ret_fr) {

            ret_fr = -ret_fr;

            if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {

                trace_vtd_fault_disabled();

            } else {

                vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);

            }

            goto error;

        }

        /* Update context-cache */

        trace_vtd_iotlb_cc_update(bus_num, devfn, ce.hi, ce.lo,

                                  cc_entry->context_cache_gen,

                                  s->context_cache_gen);

        cc_entry->context_entry = ce;

        cc_entry->context_cache_gen = s->context_cache_gen;

    }



    /*

     * We don't need to translate for pass-through context entries.

     * Also, let's ignore IOTLB caching as well for PT devices.

     */

    if (vtd_ce_get_type(&ce) == VTD_CONTEXT_TT_PASS_THROUGH) {

        entry->iova = addr & VTD_PAGE_MASK_4K;

        entry->translated_addr = entry->iova;

        entry->addr_mask = ~VTD_PAGE_MASK_4K;

        entry->perm = IOMMU_RW;

        trace_vtd_translate_pt(source_id, entry->iova);



        /*

         * When this happens, it means firstly caching-mode is not

         * enabled, and this is the first passthrough translation for

         * the device. Let's enable the fast path for passthrough.

         *

         * When passthrough is disabled again for the device, we can

         * capture it via the context entry invalidation, then the

         * IOMMU region can be swapped back.

         */

        vtd_pt_enable_fast_path(s, source_id);



        return true;

    }



    ret_fr = vtd_iova_to_slpte(&ce, addr, is_write, &slpte, &level,

                               &reads, &writes);

    if (ret_fr) {

        ret_fr = -ret_fr;

        if (is_fpd_set && vtd_is_qualified_fault(ret_fr)) {

            trace_vtd_fault_disabled();

        } else {

            vtd_report_dmar_fault(s, source_id, addr, ret_fr, is_write);

        }

        goto error;

    }



    page_mask = vtd_slpt_level_page_mask(level);

    access_flags = IOMMU_ACCESS_FLAG(reads, writes);

    vtd_update_iotlb(s, source_id, VTD_CONTEXT_ENTRY_DID(ce.hi), addr, slpte,

                     access_flags, level);

out:

    entry->iova = addr & page_mask;

    entry->translated_addr = vtd_get_slpte_addr(slpte) & page_mask;

    entry->addr_mask = ~page_mask;

    entry->perm = access_flags;

    return true;



error:

    entry->iova = 0;

    entry->translated_addr = 0;

    entry->addr_mask = 0;

    entry->perm = IOMMU_NONE;

    return false;

}
",740,,LABEL_0,LABEL_0,LABEL_0,-1,"vtd_as,bus,devfn,addr,is_write,entry,s,ce,cc_entry,slpte,page_mask,level,ret_fr,access_flags,iotlb_entry",,,,0,,0,GA,3072,1.4847546736399333,failed,
333,"static void unterminated_array_comma(void)

{

    QObject *obj = qobject_from_json(""[32,"", NULL);

    g_assert(obj == NULL);

}
",27,,LABEL_1,LABEL_1,LABEL_1,-1,obj,,,,0,,0,GA,251,0.08745404084523518,failed,
334,"static void format_line(void *ptr, int level, const char *fmt, va_list vl,

                        AVBPrint part[3], int *print_prefix, int type[2])

{

    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;

    av_bprint_init(part+0, 0, 1);

    av_bprint_init(part+1, 0, 1);

    av_bprint_init(part+2, 0, 65536);



    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;

    if (*print_prefix && avc) {

        if (avc->parent_log_context_offset) {

            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +

                                   avc->parent_log_context_offset);

            if (parent && *parent) {

                av_bprintf(part+0, ""[%s @ %p] "",

                         (*parent)->item_name(parent), parent);

                if(type) type[0] = get_category(parent);

            }

        }

        av_bprintf(part+1, ""[%s @ %p] "",

                 avc->item_name(ptr), ptr);

        if(type) type[1] = get_category(ptr);

    }



    av_vbprintf(part+2, fmt, vl);



    if(*part[0].str || *part[1].str || *part[2].str) {

        char lastc = part[2].len ? part[2].str[part[2].len - 1] : 0;

        *print_prefix = lastc == '\n' || lastc == '\r';

    }

}
",302,,LABEL_0,LABEL_1,,-4,"ptr,level,fmt,vl,part,print_prefix,type,avc,parent",,,,0,,0,Greedy,1,0.0005920926729838053,,
335,"static void arm_cpu_do_interrupt_aarch64(CPUState *cs)

{

    ARMCPU *cpu = ARM_CPU(cs);

    CPUARMState *env = &cpu->env;

    unsigned int new_el = env->exception.target_el;

    target_ulong addr = env->cp15.vbar_el[new_el];

    unsigned int new_mode = aarch64_pstate_mode(new_el, true);



    if (arm_current_el(env) < new_el) {

        if (env->aarch64) {

            addr += 0x400;

        } else {

            addr += 0x600;

        }

    } else if (pstate_read(env) & PSTATE_SP) {

        addr += 0x200;

    }



    switch (cs->exception_index) {

    case EXCP_PREFETCH_ABORT:

    case EXCP_DATA_ABORT:

        env->cp15.far_el[new_el] = env->exception.vaddress;

        qemu_log_mask(CPU_LOG_INT, ""...with FAR 0x%"" PRIx64 ""\n"",

                      env->cp15.far_el[new_el]);

        /* fall through */

    case EXCP_BKPT:

    case EXCP_UDEF:

    case EXCP_SWI:

    case EXCP_HVC:

    case EXCP_HYP_TRAP:

    case EXCP_SMC:

        env->cp15.esr_el[new_el] = env->exception.syndrome;

        break;

    case EXCP_IRQ:

    case EXCP_VIRQ:

        addr += 0x80;

        break;

    case EXCP_FIQ:

    case EXCP_VFIQ:

        addr += 0x100;

        break;

    case EXCP_SEMIHOST:

        qemu_log_mask(CPU_LOG_INT,

                      ""...handling as semihosting call 0x%"" PRIx64 ""\n"",

                      env->xregs[0]);

        env->xregs[0] = do_arm_semihosting(env);

        return;

    default:

        cpu_abort(cs, ""Unhandled exception 0x%x\n"", cs->exception_index);

    }



    if (is_a64(env)) {

        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = pstate_read(env);

        aarch64_save_sp(env, arm_current_el(env));

        env->elr_el[new_el] = env->pc;

    } else {

        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = cpsr_read(env);

        if (!env->thumb) {

            env->cp15.esr_el[new_el] |= 1 << 25;

        }

        env->elr_el[new_el] = env->regs[15];



        aarch64_sync_32_to_64(env);



        env->condexec_bits = 0;

    }

    qemu_log_mask(CPU_LOG_INT, ""...with ELR 0x%"" PRIx64 ""\n"",

                  env->elr_el[new_el]);



    pstate_write(env, PSTATE_DAIF | new_mode);

    env->aarch64 = 1;

    aarch64_restore_sp(env, new_el);



    env->pc = addr;



    qemu_log_mask(CPU_LOG_INT, ""...to EL%d PC 0x%"" PRIx64 "" PSTATE 0x%x\n"",

                  new_el, env->pc, pstate_read(env));

}
",476,"static void arm_cpu_do_interrupt_aarch64(CPUState *s)

{

    ARMCPU cu = ARM_CPU(s);

    CPUARMStateexenv = &c->exe;

    unsigned int new_el = exe->exception.target_el;

    target_ulong addr = exe->cp15.vbar_el[new_el];

    unsigned int new_mode = aarch64_pstate_mode(new_el, true);



    if (arm_current_el(exe) < new_el) {

        if (exe->aarch64) {

            addr += 0x400;

        } else {

            addr += 0x600;

        }

    } else if (pstate_read(exe) & PSTATE_SP) {

        addr += 0x200;

    }



    switch (s->exception_index) {

    case EXCP_PREFETCH_ABORT:

    case EXCP_DATA_ABORT:

        exe->cp15.far_el[new_el] = exe->exception.vaddress;

        qemu_log_mask(CPU_LOG_INT, ""...with FAR 0x%"" PRIx64 ""
"",

                      exe->cp15.far_el[new_el]);

        /* fall through */

    case EXCP_BKPT:

    case EXCP_UDEF:

    case EXCP_SWI:

    case EXCP_HVC:

    case EXCP_HYP_TRAP:

    case EXCP_SMC:

        exe->cp15.esr_el[new_el] = exe->exception.syndrome;

        break;

    case EXCP_IRQ:

    case EXCP_VIRQ:

        addr += 0x80;

        break;

    case EXCP_FIQ:

    case EXCP_VFIQ:

        addr += 0x100;

        break;

    case EXCP_SEMIHOST:

        qemu_log_mask(CPU_LOG_INT,

                      ""...handling as semihosting call 0x%"" PRIx64 ""
"",

                      exe->xregs[0]);

        exe->xregs[0] = do_arm_semihosting(exe);

        return;

    default:

        cpu_abort(s, ""Unhandled exception 0x%x
"", s->exception_index);

    }



    if (is_a64(exe)) {

        exe->banked_spsr[aarch64_banked_spsr_index(new_el)] = pstate_read(exe);

        aarch64_save_sp(exe, arm_current_el(exe));

        exe->elr_el[new_el] = exe->pc;

    } else {

        exe->banked_spsr[aarch64_banked_spsr_index(new_el)] = cpsr_read(exe);

        if (!env->thumb) {

            exe->cp15.esr_el[new_el] |= 1 << 25;

        }

        exe->elr_el[new_el] = exe->regs[15];



        aarch64_sync_32_to_64(exe);



        exe->condexec_bits = 0;

    }

    qemu_log_mask(CPU_LOG_INT, ""...with ELR 0x%"" PRIx64 ""
"",

                  exe->elr_el[new_el]);



    pstate_write(exe, PSTATE_DAIF | new_mode);

    exe->aarch64 = 1;

    aarch64_restore_sp(exe, new_el);



    exe->pc = addr;



    qemu_log_mask(CPU_LOG_INT, ""...to EL%d PC 0x%"" PRIx64 "" PSTATE 0x%x
"",

                  new_el, exe->pc, pstate_read(exe));

}
",LABEL_0,LABEL_0,LABEL_1,1,"cs,cpu,env",,,,0,"cs:s,cpu:c,env:exe,",0,GA,399,0.17001701990763346,GA,
336,"e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,

                             const E1000E_RxRing *rxr,

                             const E1000E_RSSInfo *rss_info)

{

    PCIDevice *d = core->owner;

    dma_addr_t base;

    uint8_t desc[E1000_MAX_RX_DESC_LEN];

    size_t desc_size;

    size_t desc_offset = 0;

    size_t iov_ofs = 0;



    struct iovec *iov = net_rx_pkt_get_iovec(pkt);

    size_t size = net_rx_pkt_get_total_len(pkt);

    size_t total_size = size + e1000x_fcs_len(core->mac);

    const E1000E_RingInfo *rxi;

    size_t ps_hdr_len = 0;

    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);



    rxi = rxr->i;



    do {

        hwaddr ba[MAX_PS_BUFFERS];

        e1000e_ba_state bastate = { { 0 } };

        bool is_last = false;

        bool is_first = true;



        desc_size = total_size - desc_offset;



        if (desc_size > core->rx_desc_buf_size) {

            desc_size = core->rx_desc_buf_size;

        }



        base = e1000e_ring_head_descr(core, rxi);



        pci_dma_read(d, base, &desc, core->rx_desc_len);



        trace_e1000e_rx_descr(rxi->idx, base, core->rx_desc_len);



        e1000e_read_rx_descr(core, desc, &ba);



        if (ba[0]) {

            if (desc_offset < size) {

                static const uint32_t fcs_pad;

                size_t iov_copy;

                size_t copy_size = size - desc_offset;

                if (copy_size > core->rx_desc_buf_size) {

                    copy_size = core->rx_desc_buf_size;

                }



                /* For PS mode copy the packet header first */

                if (do_ps) {

                    if (is_first) {

                        size_t ps_hdr_copied = 0;

                        do {

                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,

                                           iov->iov_len - iov_ofs);



                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,

                                                      iov->iov_base, iov_copy);



                            copy_size -= iov_copy;

                            ps_hdr_copied += iov_copy;



                            iov_ofs += iov_copy;

                            if (iov_ofs == iov->iov_len) {

                                iov++;

                                iov_ofs = 0;

                            }

                        } while (ps_hdr_copied < ps_hdr_len);



                        is_first = false;

                    } else {

                        /* Leave buffer 0 of each descriptor except first */

                        /* empty as per spec 7.1.5.1                      */

                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,

                                                       NULL, 0);

                    }

                }



                /* Copy packet payload */

                while (copy_size) {

                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);



                    e1000e_write_to_rx_buffers(core, &ba, &bastate,

                                            iov->iov_base + iov_ofs, iov_copy);



                    copy_size -= iov_copy;

                    iov_ofs += iov_copy;

                    if (iov_ofs == iov->iov_len) {

                        iov++;

                        iov_ofs = 0;

                    }

                }



                if (desc_offset + desc_size >= total_size) {

                    /* Simulate FCS checksum presence in the last descriptor */

                    e1000e_write_to_rx_buffers(core, &ba, &bastate,

                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));

                }

            }

            desc_offset += desc_size;

            if (desc_offset >= total_size) {

                is_last = true;

            }

        } else { /* as per intel docs; skip descriptors with null buf addr */

            trace_e1000e_rx_null_descriptor();

        }



        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,

                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);

        pci_dma_write(d, base, &desc, core->rx_desc_len);



        e1000e_ring_advance(core, rxi,

                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);



    } while (desc_offset < total_size);



    e1000e_update_rx_stats(core, size, total_size);

}
",655,"e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,

                             const E1000E_RxRing *rxr,

                             const E1000E_RSSInfo *rss_info)

{

    PCIDevice *d = core->owner;

    dma_addr_t base;

    uint8_t desc[E1000_MAX_RX_DESC_LEN];

    size_t  desc_offset;

    size_t desc_offset = 0;

    size_t iov_ofs = 0;



    struct iovec *iov = net_rx_pkt_get_iovec(pkt);

    size_t size = net_rx_pkt_get_total_len(pkt);

    size_t total_size = size + e1000x_fcs_len(core->mac);

    const E1000E_RingInfo *rxi;

    size_t ps_hdr_len = 0;

    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);



    rxi = rxr->i;



    do {

        hwaddr ba[MAX_PS_BUFFERS];

        e1000e_ba_state bastate = { { 0 } };

        bool is_last = false;

        bool is_first = true;



         desc_offset = total_size - desc_offset;



        if ( desc_offset > core->rx_desc_buf_size) {

             desc_offset = core->rx_desc_buf_size;

        }



        base = e1000e_ring_head_descr(core, rxi);



        pci_dma_read(d, base, &desc, core->rx_desc_len);



        trace_e1000e_rx_descr(rxi->idx, base, core->rx_desc_len);



        e1000e_read_rx_descr(core, desc, &ba);



        if (ba[0]) {

            if (desc_offset < size) {

                static const uint32_t fcs_pad;

                size_t oren_copy;

                size_t copy_size = size - desc_offset;

                if (copy_size > core->rx_desc_buf_size) {

                    copy_size = core->rx_desc_buf_size;

                }



                /* For PS mode copy the packet header first */

                if (do_ps) {

                    if (is_first) {

                        size_t ps_hdr_copied = 0;

                        do {

                            oren_copy = MIN(ps_hdr_len - ps_hdr_copied,

                                           iov->iov_len - iov_ofs);



                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,

                                                      iov->iov_base, oren_copy);



                            copy_size -= oren_copy;

                            ps_hdr_copied += oren_copy;



                            iov_ofs += oren_copy;

                            if (iov_ofs == iov->iov_len) {

                                iov++;

                                iov_ofs = 0;

                            }

                        } while (ps_hdr_copied < ps_hdr_len);



                        is_first = false;

                    } else {

                        /* Leave buffer 0 of each descriptor except first */

                        /* empty as per spec 7.1.5.1                      */

                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,

                                                       NULL, 0);

                    }

                }



                /* Copy packet payload */

                while (copy_size) {

                    oren_copy = MIN(copy_size, iov->iov_len - iov_ofs);



                    e1000e_write_to_rx_buffers(core, &ba, &bastate,

                                            iov->iov_base + iov_ofs, oren_copy);



                    copy_size -= oren_copy;

                    iov_ofs += oren_copy;

                    if (iov_ofs == iov->iov_len) {

                        iov++;

                        iov_ofs = 0;

                    }

                }



                if (desc_offset +  desc_offset >= total_size) {

                    /* Simulate FCS checksum presence in the last descriptor */

                    e1000e_write_to_rx_buffers(core, &ba, &bastate,

                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));

                }

            }

            desc_offset +=  desc_offset;

            if (desc_offset >= total_size) {

                is_last = true;

            }

        } else { /* as per intel docs; skip descriptors with null buf addr */

            trace_e1000e_rx_null_descriptor();

        }



        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,

                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);

        pci_dma_write(d, base, &desc, core->rx_desc_len);



        e1000e_ring_advance(core, rxi,

                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);



    } while (desc_offset < total_size);



    e1000e_update_rx_stats(core, size, total_size);

}
",LABEL_0,LABEL_0,LABEL_1,1,"d,base,desc,desc_size,iov,rxi,ba,fcs_pad,iov_copy",,,,36,"d:d,base:base,desc:desc,desc_size: desc_offset,iov:iov,rxi:rxi,ba:ba,fcs_pad:fcs_pad,iov_copy:oren_copy,",7,GA,354,0.17003769874572755,GA,
337,"static void test_bmdma_simple_rw(void)

{

    QPCIDevice *dev;

    void *bmdma_base, *ide_base;

    uint8_t status;

    uint8_t *buf;

    uint8_t *cmpbuf;

    size_t len = 512;

    uintptr_t guest_buf = guest_alloc(guest_malloc, len);



    PrdtEntry prdt[] = {

        {

            .addr = cpu_to_le32(guest_buf),

            .size = cpu_to_le32(len | PRDT_EOT),

        },

    };



    dev = get_pci_device(&bmdma_base, &ide_base);



    buf = g_malloc(len);

    cmpbuf = g_malloc(len);



    /* Write 0x55 pattern to sector 0 */

    memset(buf, 0x55, len);

    memwrite(guest_buf, buf, len);



    status = send_dma_request(CMD_WRITE_DMA, 0, 1, prdt,

                              ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    /* Write 0xaa pattern to sector 1 */

    memset(buf, 0xaa, len);

    memwrite(guest_buf, buf, len);



    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,

                              ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    /* Read and verify 0x55 pattern in sector 0 */

    memset(cmpbuf, 0x55, len);



    status = send_dma_request(CMD_READ_DMA, 0, 1, prdt, ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    memread(guest_buf, buf, len);

    g_assert(memcmp(buf, cmpbuf, len) == 0);



    /* Read and verify 0xaa pattern in sector 1 */

    memset(cmpbuf, 0xaa, len);



    status = send_dma_request(CMD_READ_DMA, 1, 1, prdt, ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    memread(guest_buf, buf, len);

    g_assert(memcmp(buf, cmpbuf, len) == 0);





    g_free(buf);

    g_free(cmpbuf);

}
",435,"static void test_bmdma_simple_rw(void)

{

    QPCIDevice *dev;

    void *bmdma_base, *ide_base;

    uint8_t Status;

    uint8_t *pool;

    uint8_t *cmpbuf;

    size_t len = 512;

    uintptr_t guest_buf = guest_alloc(guest_malloc, len);



    PrdtEntry frrt[] = {

        {

            .addr = cpu_to_le32(guest_buf),

            .size = cpu_to_le32(len | PRDT_EOT),

        },

    };



    dev = get_pci_device(&bmdma_base, &ide_base);



    pool = g_malloc(len);

    cmpbuf = g_malloc(len);



    /* Write 0x55 pattern to sector 0 */

    memset(pool, 0x55, len);

    memwrite(guest_buf, pool, len);



    Status = send_dma_request(CMD_WRITE_DMA, 0, 1, frrt,

                              ARRAY_SIZE(frrt), NULL);

    g_assert_cmphex(Status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    /* Write 0xaa pattern to sector 1 */

    memset(pool, 0xaa, len);

    memwrite(guest_buf, pool, len);



    Status = send_dma_request(CMD_WRITE_DMA, 1, 1, frrt,

                              ARRAY_SIZE(frrt), NULL);

    g_assert_cmphex(Status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    /* Read and verify 0x55 pattern in sector 0 */

    memset(cmpbuf, 0x55, len);



    Status = send_dma_request(CMD_READ_DMA, 0, 1, frrt, ARRAY_SIZE(frrt), NULL);

    g_assert_cmphex(Status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    memread(guest_buf, pool, len);

    g_assert(memcmp(pool, cmpbuf, len) == 0);



    /* Read and verify 0xaa pattern in sector 1 */

    memset(cmpbuf, 0xaa, len);



    Status = send_dma_request(CMD_READ_DMA, 1, 1, frrt, ARRAY_SIZE(frrt), NULL);

    g_assert_cmphex(Status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    memread(guest_buf, pool, len);

    g_assert(memcmp(pool, cmpbuf, len) == 0);





    g_free(pool);

    g_free(cmpbuf);

}
",LABEL_1,LABEL_1,LABEL_0,1,"dev,bmdma_base,ide_base,status,buf,cmpbuf,prdt",,,,21,"dev:dev,bmdma_base:bmdma_base,ide_base:ide_base,status:Status,buf:pool,cmpbuf:cmpbuf,prdt:frrt,",4,GA,476,0.1861105481783549,GA,
338,"static void bt_submit_hci(struct HCIInfo *info,

                const uint8_t *data, int length)

{

    struct bt_hci_s *hci = hci_from_info(info);

    uint16_t cmd;

    int paramlen, i;



    if (length < HCI_COMMAND_HDR_SIZE)

        goto short_hci;



    memcpy(&hci->last_cmd, data, 2);



    cmd = (data[1] << 8) | data[0];

    paramlen = data[2];

    if (cmd_opcode_ogf(cmd) == 0 || cmd_opcode_ocf(cmd) == 0)	/* NOP */

        return;



    data += HCI_COMMAND_HDR_SIZE;

    length -= HCI_COMMAND_HDR_SIZE;



    if (paramlen > length)

        return;



#define PARAM(cmd, param)	(((cmd##_cp *) data)->param)

#define PARAM16(cmd, param)	le16_to_cpup(&PARAM(cmd, param))

#define PARAMHANDLE(cmd)	HNDL(PARAM(cmd, handle))

#define LENGTH_CHECK(cmd)	if (length < sizeof(cmd##_cp)) goto short_hci

    /* Note: the supported commands bitmask in bt_hci_read_local_commands_rp

     * needs to be updated every time a command is implemented here!  */

    switch (cmd) {

    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY):

        LENGTH_CHECK(inquiry);



        if (PARAM(inquiry, length) < 1) {

            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);

            break;

        }



        hci->lm.inquire = 1;

        hci->lm.periodic = 0;

        hci->lm.responses_left = PARAM(inquiry, num_rsp) ?: INT_MAX;

        hci->lm.responses = 0;

        bt_hci_event_status(hci, HCI_SUCCESS);

        bt_hci_inquiry_start(hci, PARAM(inquiry, length));

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY_CANCEL):

        if (!hci->lm.inquire || hci->lm.periodic) {

            fprintf(stderr, ""%s: Inquiry Cancel should only be issued after ""

                            ""the Inquiry command has been issued, a Command ""

                            ""Status event has been received for the Inquiry ""

                            ""command, and before the Inquiry Complete event ""

                            ""occurs"", __FUNCTION__);

            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);

            break;

        }



        hci->lm.inquire = 0;

        qemu_del_timer(hci->lm.inquiry_done);

        bt_hci_event_complete_status(hci, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_PERIODIC_INQUIRY):

        LENGTH_CHECK(periodic_inquiry);



        if (!(PARAM(periodic_inquiry, length) <

                                PARAM16(periodic_inquiry, min_period) &&

                                PARAM16(periodic_inquiry, min_period) <

                                PARAM16(periodic_inquiry, max_period)) ||

                        PARAM(periodic_inquiry, length) < 1 ||

                        PARAM16(periodic_inquiry, min_period) < 2 ||

                        PARAM16(periodic_inquiry, max_period) < 3) {

            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);

            break;

        }



        hci->lm.inquire = 1;

        hci->lm.periodic = 1;

        hci->lm.responses_left = PARAM(periodic_inquiry, num_rsp);

        hci->lm.responses = 0;

        hci->lm.inquiry_period = PARAM16(periodic_inquiry, max_period);

        bt_hci_event_complete_status(hci, HCI_SUCCESS);

        bt_hci_inquiry_start(hci, PARAM(periodic_inquiry, length));

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_EXIT_PERIODIC_INQUIRY):

        if (!hci->lm.inquire || !hci->lm.periodic) {

            fprintf(stderr, ""%s: Inquiry Cancel should only be issued after ""

                            ""the Inquiry command has been issued, a Command ""

                            ""Status event has been received for the Inquiry ""

                            ""command, and before the Inquiry Complete event ""

                            ""occurs"", __FUNCTION__);

            bt_hci_event_complete_status(hci, HCI_COMMAND_DISALLOWED);

            break;

        }

        hci->lm.inquire = 0;

        qemu_del_timer(hci->lm.inquiry_done);

        qemu_del_timer(hci->lm.inquiry_next);

        bt_hci_event_complete_status(hci, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN):

        LENGTH_CHECK(create_conn);



        if (hci->lm.connecting >= HCI_HANDLES_MAX) {

            bt_hci_event_status(hci, HCI_REJECTED_LIMITED_RESOURCES);

            break;

        }

        bt_hci_event_status(hci, HCI_SUCCESS);



        if (bt_hci_connect(hci, &PARAM(create_conn, bdaddr)))

            bt_hci_connection_reject_event(hci, &PARAM(create_conn, bdaddr));

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_DISCONNECT):

        LENGTH_CHECK(disconnect);



        if (bt_hci_handle_bad(hci, PARAMHANDLE(disconnect))) {

            bt_hci_event_status(hci, HCI_NO_CONNECTION);

            break;

        }



        bt_hci_event_status(hci, HCI_SUCCESS);

        bt_hci_disconnect(hci, PARAMHANDLE(disconnect),

                        PARAM(disconnect, reason));

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN_CANCEL):

        LENGTH_CHECK(create_conn_cancel);



        if (bt_hci_lmp_connection_ready(hci,

                                &PARAM(create_conn_cancel, bdaddr))) {

            for (i = 0; i < HCI_HANDLES_MAX; i ++)

                if (bt_hci_role_master(hci, i) && hci->lm.handle[i].link &&

                                !bacmp(&hci->lm.handle[i].link->slave->bd_addr,

                                        &PARAM(create_conn_cancel, bdaddr)))

                   break;



            bt_hci_event_complete_conn_cancel(hci, i < HCI_HANDLES_MAX ?

                            HCI_ACL_CONNECTION_EXISTS : HCI_NO_CONNECTION,

                            &PARAM(create_conn_cancel, bdaddr));

        } else

            bt_hci_event_complete_conn_cancel(hci, HCI_SUCCESS,

                            &PARAM(create_conn_cancel, bdaddr));

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_ACCEPT_CONN_REQ):

        LENGTH_CHECK(accept_conn_req);



        if (!hci->conn_req_host ||

                        bacmp(&PARAM(accept_conn_req, bdaddr),

                                &hci->conn_req_host->bd_addr)) {

            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);

            break;

        }



        bt_hci_event_status(hci, HCI_SUCCESS);

        bt_hci_connection_accept(hci, hci->conn_req_host);

        hci->conn_req_host = 0;

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REJECT_CONN_REQ):

        LENGTH_CHECK(reject_conn_req);



        if (!hci->conn_req_host ||

                        bacmp(&PARAM(reject_conn_req, bdaddr),

                                &hci->conn_req_host->bd_addr)) {

            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);

            break;

        }



        bt_hci_event_status(hci, HCI_SUCCESS);

        bt_hci_connection_reject(hci, hci->conn_req_host,

                        PARAM(reject_conn_req, reason));

        bt_hci_connection_reject_event(hci, &hci->conn_req_host->bd_addr);

        hci->conn_req_host = 0;

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_AUTH_REQUESTED):

        LENGTH_CHECK(auth_requested);



        if (bt_hci_handle_bad(hci, PARAMHANDLE(auth_requested)))

            bt_hci_event_status(hci, HCI_NO_CONNECTION);

        else {

            bt_hci_event_status(hci, HCI_SUCCESS);

            bt_hci_event_auth_complete(hci, PARAMHANDLE(auth_requested));

        }

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_SET_CONN_ENCRYPT):

        LENGTH_CHECK(set_conn_encrypt);



        if (bt_hci_handle_bad(hci, PARAMHANDLE(set_conn_encrypt)))

            bt_hci_event_status(hci, HCI_NO_CONNECTION);

        else {

            bt_hci_event_status(hci, HCI_SUCCESS);

            bt_hci_event_encrypt_change(hci,

                            PARAMHANDLE(set_conn_encrypt),

                            PARAM(set_conn_encrypt, encrypt));

        }

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ):

        LENGTH_CHECK(remote_name_req);



        if (bt_hci_name_req(hci, &PARAM(remote_name_req, bdaddr)))

            bt_hci_event_status(hci, HCI_NO_CONNECTION);

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ_CANCEL):

        LENGTH_CHECK(remote_name_req_cancel);



        bt_hci_event_complete_name_cancel(hci,

                        &PARAM(remote_name_req_cancel, bdaddr));

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_FEATURES):

        LENGTH_CHECK(read_remote_features);



        if (bt_hci_features_req(hci, PARAMHANDLE(read_remote_features)))

            bt_hci_event_status(hci, HCI_NO_CONNECTION);

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_EXT_FEATURES):

        LENGTH_CHECK(read_remote_ext_features);



        if (bt_hci_handle_bad(hci, PARAMHANDLE(read_remote_ext_features)))

            bt_hci_event_status(hci, HCI_NO_CONNECTION);

        else {

            bt_hci_event_status(hci, HCI_SUCCESS);

            bt_hci_event_read_remote_ext_features(hci,

                            PARAMHANDLE(read_remote_ext_features));

        }

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_VERSION):

        LENGTH_CHECK(read_remote_version);



        if (bt_hci_version_req(hci, PARAMHANDLE(read_remote_version)))

            bt_hci_event_status(hci, HCI_NO_CONNECTION);

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_CLOCK_OFFSET):

        LENGTH_CHECK(read_clock_offset);



        if (bt_hci_clkoffset_req(hci, PARAMHANDLE(read_clock_offset)))

            bt_hci_event_status(hci, HCI_NO_CONNECTION);

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_LMP_HANDLE):

        LENGTH_CHECK(read_lmp_handle);



        /* TODO: */

        bt_hci_event_complete_lmp_handle(hci, PARAMHANDLE(read_lmp_handle));

        break;



    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_HOLD_MODE):

        LENGTH_CHECK(hold_mode);



        if (PARAM16(hold_mode, min_interval) >

                        PARAM16(hold_mode, max_interval) ||

                        PARAM16(hold_mode, min_interval) < 0x0002 ||

                        PARAM16(hold_mode, max_interval) > 0xff00 ||

                        (PARAM16(hold_mode, min_interval) & 1) ||

                        (PARAM16(hold_mode, max_interval) & 1)) {

            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);

            break;

        }



        if (bt_hci_mode_change(hci, PARAMHANDLE(hold_mode),

                                PARAM16(hold_mode, max_interval),

                                acl_hold))

            bt_hci_event_status(hci, HCI_NO_CONNECTION);

        break;



    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_PARK_MODE):

        LENGTH_CHECK(park_mode);



        if (PARAM16(park_mode, min_interval) >

                        PARAM16(park_mode, max_interval) ||

                        PARAM16(park_mode, min_interval) < 0x000e ||

                        (PARAM16(park_mode, min_interval) & 1) ||

                        (PARAM16(park_mode, max_interval) & 1)) {

            bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);

            break;

        }



        if (bt_hci_mode_change(hci, PARAMHANDLE(park_mode),

                                PARAM16(park_mode, max_interval),

                                acl_parked))

            bt_hci_event_status(hci, HCI_NO_CONNECTION);

        break;



    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_EXIT_PARK_MODE):

        LENGTH_CHECK(exit_park_mode);



        if (bt_hci_mode_cancel(hci, PARAMHANDLE(exit_park_mode),

                                acl_parked))

            bt_hci_event_status(hci, HCI_NO_CONNECTION);

        break;



    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_ROLE_DISCOVERY):

        LENGTH_CHECK(role_discovery);



        if (bt_hci_handle_bad(hci, PARAMHANDLE(role_discovery)))

            bt_hci_event_complete_role_discovery(hci,

                            HCI_NO_CONNECTION, PARAMHANDLE(role_discovery), 0);

        else

            bt_hci_event_complete_role_discovery(hci,

                            HCI_SUCCESS, PARAMHANDLE(role_discovery),

                            bt_hci_role_master(hci,

                                    PARAMHANDLE(role_discovery)));

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_MASK):

        LENGTH_CHECK(set_event_mask);



        memcpy(hci->event_mask, PARAM(set_event_mask, mask), 8);

        bt_hci_event_complete_status(hci, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_RESET):

        bt_hci_reset(hci);

        bt_hci_event_status(hci, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_FLT):

        if (length >= 1 && PARAM(set_event_flt, flt_type) == FLT_CLEAR_ALL)

            /* No length check */;

        else

            LENGTH_CHECK(set_event_flt);



        /* Filters are not implemented */

        bt_hci_event_complete_status(hci, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_FLUSH):

        LENGTH_CHECK(flush);



        if (bt_hci_handle_bad(hci, PARAMHANDLE(flush)))

            bt_hci_event_complete_flush(hci,

                            HCI_NO_CONNECTION, PARAMHANDLE(flush));

        else {

            /* TODO: ordering? */

            bt_hci_event(hci, EVT_FLUSH_OCCURRED,

                            &PARAM(flush, handle),

                            EVT_FLUSH_OCCURRED_SIZE);

            bt_hci_event_complete_flush(hci,

                            HCI_SUCCESS, PARAMHANDLE(flush));

        }

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_CHANGE_LOCAL_NAME):

        LENGTH_CHECK(change_local_name);



        if (hci->device.lmp_name)

            free((void *) hci->device.lmp_name);

        hci->device.lmp_name = strndup(PARAM(change_local_name, name),

                        sizeof(PARAM(change_local_name, name)));

        bt_hci_event_complete_status(hci, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_LOCAL_NAME):

        bt_hci_event_complete_read_local_name(hci);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CONN_ACCEPT_TIMEOUT):

        bt_hci_event_complete_read_conn_accept_timeout(hci);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CONN_ACCEPT_TIMEOUT):

        /* TODO */

        LENGTH_CHECK(write_conn_accept_timeout);



        if (PARAM16(write_conn_accept_timeout, timeout) < 0x0001 ||

                        PARAM16(write_conn_accept_timeout, timeout) > 0xb540) {

            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);

            break;

        }



        hci->conn_accept_tout = PARAM16(write_conn_accept_timeout, timeout);

        bt_hci_event_complete_status(hci, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_SCAN_ENABLE):

        bt_hci_event_complete_read_scan_enable(hci);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_SCAN_ENABLE):

        LENGTH_CHECK(write_scan_enable);



        /* TODO: check that the remaining bits are all 0 */

        hci->device.inquiry_scan =

                !!(PARAM(write_scan_enable, scan_enable) & SCAN_INQUIRY);

        hci->device.page_scan =

                !!(PARAM(write_scan_enable, scan_enable) & SCAN_PAGE);

        bt_hci_event_complete_status(hci, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CLASS_OF_DEV):

        bt_hci_event_complete_read_local_class(hci);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CLASS_OF_DEV):

        LENGTH_CHECK(write_class_of_dev);



        memcpy(hci->device.class, PARAM(write_class_of_dev, dev_class),

                        sizeof(PARAM(write_class_of_dev, dev_class)));

        bt_hci_event_complete_status(hci, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_VOICE_SETTING):

        bt_hci_event_complete_voice_setting(hci);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_VOICE_SETTING):

        LENGTH_CHECK(write_voice_setting);



        hci->voice_setting = PARAM(write_voice_setting, voice_setting);

        bt_hci_event_complete_status(hci, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_HOST_NUMBER_OF_COMPLETED_PACKETS):

        if (length < data[0] * 2 + 1)

            goto short_hci;



        for (i = 0; i < data[0]; i ++)

            if (bt_hci_handle_bad(hci,

                                    data[i * 2 + 1] | (data[i * 2 + 2] << 8)))

                bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_INQUIRY_MODE):

        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x40)

         * else

         *     goto unknown_command */

        bt_hci_event_complete_read_inquiry_mode(hci);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_INQUIRY_MODE):

        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x80)

         * else

         *     goto unknown_command */

        LENGTH_CHECK(write_inquiry_mode);



        if (PARAM(write_inquiry_mode, mode) > 0x01) {

            bt_hci_event_complete_status(hci, HCI_INVALID_PARAMETERS);

            break;

        }



        hci->lm.inquiry_mode = PARAM(write_inquiry_mode, mode);

        bt_hci_event_complete_status(hci, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_VERSION):

        bt_hci_read_local_version_rp(hci);

        break;



    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_COMMANDS):

        bt_hci_read_local_commands_rp(hci);

        break;



    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_FEATURES):

        bt_hci_read_local_features_rp(hci);

        break;



    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_EXT_FEATURES):

        LENGTH_CHECK(read_local_ext_features);



        bt_hci_read_local_ext_features_rp(hci,

                        PARAM(read_local_ext_features, page_num));

        break;



    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BUFFER_SIZE):

        bt_hci_read_buffer_size_rp(hci);

        break;



    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_COUNTRY_CODE):

        bt_hci_read_country_code_rp(hci);

        break;



    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BD_ADDR):

        bt_hci_read_bd_addr_rp(hci);

        break;



    case cmd_opcode_pack(OGF_STATUS_PARAM, OCF_READ_LINK_QUALITY):

        LENGTH_CHECK(read_link_quality);



        bt_hci_link_quality_rp(hci, PARAMHANDLE(read_link_quality));

        break;



    default:

        bt_hci_event_status(hci, HCI_UNKNOWN_COMMAND);

        break;



    short_hci:

        fprintf(stderr, ""%s: HCI packet too short (%iB)\n"",

                        __FUNCTION__, length);

        bt_hci_event_status(hci, HCI_INVALID_PARAMETERS);

        break;

    }

}
",2680,"static void bt_submit_hci(struct HCIInfo *info,

                const uint8_t *data, int length)

{

    struct bt_hci_s *hldi = hci_from_info(info);

    uint16_t kind;

    int paramsid, a;



    if (length < HCI_COMMAND_HDR_SIZE)

        goto short_hci;



    memcpy(&hldi->last_cmd, data, 2);



    kind = (data[1] << 8) | data[0];

    paramsid = data[2];

    if (cmd_opcode_ogf(kind) == 0 || cmd_opcode_ocf(kind) == 0)	/* NOP */

        return;



    data += HCI_COMMAND_HDR_SIZE;

    length -= HCI_COMMAND_HDR_SIZE;



    if (paramsid > length)

        return;



#define PARAM(cmd, param)	(((cmd##_cp *) data)->param)

#define PARAM16(cmd, param)	le16_to_cpup(&PARAM(cmd, param))

#define PARAMHANDLE(cmd)	HNDL(PARAM(cmd, handle))

#define LENGTH_CHECK(cmd)	if (length < sizeof(cmd##_cp)) goto short_hci

    /* Note: the supported commands bitmask in bt_hci_read_local_commands_rp

     * needs to be updated every time a command is implemented here!  */

    switch (kind) {

    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY):

        LENGTH_CHECK(inquiry);



        if (PARAM(inquiry, length) < 1) {

            bt_hci_event_complete_status(hldi, HCI_INVALID_PARAMETERS);

            break;

        }



        hldi->lm.inquire = 1;

        hldi->lm.periodic = 0;

        hldi->lm.responses_left = PARAM(inquiry, num_rsp) ?: INT_MAX;

        hldi->lm.responses = 0;

        bt_hci_event_status(hldi, HCI_SUCCESS);

        bt_hci_inquiry_start(hldi, PARAM(inquiry, length));

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_INQUIRY_CANCEL):

        if (!hci->lm.inquire || hldi->lm.periodic) {

            fprintf(stderr, ""%s: Inquiry Cancel should only be issued after ""

                            ""the Inquiry command has been issued, a Command ""

                            ""Status event has been received for the Inquiry ""

                            ""command, and before the Inquiry Complete event ""

                            ""occurs"", __FUNCTION__);

            bt_hci_event_complete_status(hldi, HCI_COMMAND_DISALLOWED);

            break;

        }



        hldi->lm.inquire = 0;

        qemu_del_timer(hldi->lm.inquiry_done);

        bt_hci_event_complete_status(hldi, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_PERIODIC_INQUIRY):

        LENGTH_CHECK(periodic_inquiry);



        if (!(PARAM(periodic_inquiry, length) <

                                PARAM16(periodic_inquiry, min_period) &&

                                PARAM16(periodic_inquiry, min_period) <

                                PARAM16(periodic_inquiry, max_period)) ||

                        PARAM(periodic_inquiry, length) < 1 ||

                        PARAM16(periodic_inquiry, min_period) < 2 ||

                        PARAM16(periodic_inquiry, max_period) < 3) {

            bt_hci_event_complete_status(hldi, HCI_INVALID_PARAMETERS);

            break;

        }



        hldi->lm.inquire = 1;

        hldi->lm.periodic = 1;

        hldi->lm.responses_left = PARAM(periodic_inquiry, num_rsp);

        hldi->lm.responses = 0;

        hldi->lm.inquiry_period = PARAM16(periodic_inquiry, max_period);

        bt_hci_event_complete_status(hldi, HCI_SUCCESS);

        bt_hci_inquiry_start(hldi, PARAM(periodic_inquiry, length));

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_EXIT_PERIODIC_INQUIRY):

        if (!hci->lm.inquire || !hci->lm.periodic) {

            fprintf(stderr, ""%s: Inquiry Cancel should only be issued after ""

                            ""the Inquiry command has been issued, a Command ""

                            ""Status event has been received for the Inquiry ""

                            ""command, and before the Inquiry Complete event ""

                            ""occurs"", __FUNCTION__);

            bt_hci_event_complete_status(hldi, HCI_COMMAND_DISALLOWED);

            break;

        }

        hldi->lm.inquire = 0;

        qemu_del_timer(hldi->lm.inquiry_done);

        qemu_del_timer(hldi->lm.inquiry_next);

        bt_hci_event_complete_status(hldi, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN):

        LENGTH_CHECK(create_conn);



        if (hldi->lm.connecting >= HCI_HANDLES_MAX) {

            bt_hci_event_status(hldi, HCI_REJECTED_LIMITED_RESOURCES);

            break;

        }

        bt_hci_event_status(hldi, HCI_SUCCESS);



        if (bt_hci_connect(hldi, &PARAM(create_conn, bdaddr)))

            bt_hci_connection_reject_event(hldi, &PARAM(create_conn, bdaddr));

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_DISCONNECT):

        LENGTH_CHECK(disconnect);



        if (bt_hci_handle_bad(hldi, PARAMHANDLE(disconnect))) {

            bt_hci_event_status(hldi, HCI_NO_CONNECTION);

            break;

        }



        bt_hci_event_status(hldi, HCI_SUCCESS);

        bt_hci_disconnect(hldi, PARAMHANDLE(disconnect),

                        PARAM(disconnect, reason));

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_CREATE_CONN_CANCEL):

        LENGTH_CHECK(create_conn_cancel);



        if (bt_hci_lmp_connection_ready(hldi,

                                &PARAM(create_conn_cancel, bdaddr))) {

            for (a = 0; a < HCI_HANDLES_MAX; a ++)

                if (bt_hci_role_master(hldi, ia && hldi->lm.handle[a].link &&

                                !bacmp(&hldi->lm.handle[a].link->slave->bd_addr,

                                        &PARAM(create_conn_cancel, bdaddr)))

                   break;



            bt_hci_event_complete_conn_cancel(hldi, a < HCI_HANDLES_MAX ?

                            HCI_ACL_CONNECTION_EXISTS : HCI_NO_CONNECTION,

                            &PARAM(create_conn_cancel, bdaddr));

        } else

            bt_hci_event_complete_conn_cancel(hldi, HCI_SUCCESS,

                            &PARAM(create_conn_cancel, bdaddr));

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_ACCEPT_CONN_REQ):

        LENGTH_CHECK(accept_conn_req);



        if (!hci->conn_req_host ||

                        bacmp(&PARAM(accept_conn_req, bdaddr),

                                &hldi->conn_req_host->bd_addr)) {

            bt_hci_event_status(hldi, HCI_INVALID_PARAMETERS);

            break;

        }



        bt_hci_event_status(hldi, HCI_SUCCESS);

        bt_hci_connection_accept(hldi, hldi->conn_req_host);

        hldi->conn_req_host = 0;

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REJECT_CONN_REQ):

        LENGTH_CHECK(reject_conn_req);



        if (!hci->conn_req_host ||

                        bacmp(&PARAM(reject_conn_req, bdaddr),

                                &hldi->conn_req_host->bd_addr)) {

            bt_hci_event_status(hldi, HCI_INVALID_PARAMETERS);

            break;

        }



        bt_hci_event_status(hldi, HCI_SUCCESS);

        bt_hci_connection_reject(hldi, hldi->conn_req_host,

                        PARAM(reject_conn_req, reason));

        bt_hci_connection_reject_event(hldi, &hldi->conn_req_host->bd_addr);

        hldi->conn_req_host = 0;

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_AUTH_REQUESTED):

        LENGTH_CHECK(auth_requested);



        if (bt_hci_handle_bad(hldi, PARAMHANDLE(auth_requested)))

            bt_hci_event_status(hldi, HCI_NO_CONNECTION);

        else {

            bt_hci_event_status(hldi, HCI_SUCCESS);

            bt_hci_event_auth_complete(hldi, PARAMHANDLE(auth_requested));

        }

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_SET_CONN_ENCRYPT):

        LENGTH_CHECK(set_conn_encrypt);



        if (bt_hci_handle_bad(hldi, PARAMHANDLE(set_conn_encrypt)))

            bt_hci_event_status(hldi, HCI_NO_CONNECTION);

        else {

            bt_hci_event_status(hldi, HCI_SUCCESS);

            bt_hci_event_encrypt_change(hldi,

                            PARAMHANDLE(set_conn_encrypt),

                            PARAM(set_conn_encrypt, encrypt));

        }

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ):

        LENGTH_CHECK(remote_name_req);



        if (bt_hci_name_req(hldi, &PARAM(remote_name_req, bdaddr)))

            bt_hci_event_status(hldi, HCI_NO_CONNECTION);

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_REMOTE_NAME_REQ_CANCEL):

        LENGTH_CHECK(remote_name_req_cancel);



        bt_hci_event_complete_name_cancel(hldi,

                        &PARAM(remote_name_req_cancel, bdaddr));

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_FEATURES):

        LENGTH_CHECK(read_remote_features);



        if (bt_hci_features_req(hldi, PARAMHANDLE(read_remote_features)))

            bt_hci_event_status(hldi, HCI_NO_CONNECTION);

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_EXT_FEATURES):

        LENGTH_CHECK(read_remote_ext_features);



        if (bt_hci_handle_bad(hldi, PARAMHANDLE(read_remote_ext_features)))

            bt_hci_event_status(hldi, HCI_NO_CONNECTION);

        else {

            bt_hci_event_status(hldi, HCI_SUCCESS);

            bt_hci_event_read_remote_ext_features(hldi,

                            PARAMHANDLE(read_remote_ext_features));

        }

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_REMOTE_VERSION):

        LENGTH_CHECK(read_remote_version);



        if (bt_hci_version_req(hldi, PARAMHANDLE(read_remote_version)))

            bt_hci_event_status(hldi, HCI_NO_CONNECTION);

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_CLOCK_OFFSET):

        LENGTH_CHECK(read_clock_offset);



        if (bt_hci_clkoffset_req(hldi, PARAMHANDLE(read_clock_offset)))

            bt_hci_event_status(hldi, HCI_NO_CONNECTION);

        break;



    case cmd_opcode_pack(OGF_LINK_CTL, OCF_READ_LMP_HANDLE):

        LENGTH_CHECK(read_lmp_handle);



        /* TODO: */

        bt_hci_event_complete_lmp_handle(hldi, PARAMHANDLE(read_lmp_handle));

        break;



    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_HOLD_MODE):

        LENGTH_CHECK(hold_mode);



        if (PARAM16(hold_mode, min_interval) >

                        PARAM16(hold_mode, max_interval) ||

                        PARAM16(hold_mode, min_interval) < 0x0002 ||

                        PARAM16(hold_mode, max_interval) > 0xff00 ||

                        (PARAM16(hold_mode, min_interval) & 1) ||

                        (PARAM16(hold_mode, max_interval) & 1)) {

            bt_hci_event_status(hldi, HCI_INVALID_PARAMETERS);

            break;

        }



        if (bt_hci_mode_change(hldi, PARAMHANDLE(hold_mode),

                                PARAM16(hold_mode, max_interval),

                                acl_hold))

            bt_hci_event_status(hldi, HCI_NO_CONNECTION);

        break;



    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_PARK_MODE):

        LENGTH_CHECK(park_mode);



        if (PARAM16(park_mode, min_interval) >

                        PARAM16(park_mode, max_interval) ||

                        PARAM16(park_mode, min_interval) < 0x000e ||

                        (PARAM16(park_mode, min_interval) & 1) ||

                        (PARAM16(park_mode, max_interval) & 1)) {

            bt_hci_event_status(hldi, HCI_INVALID_PARAMETERS);

            break;

        }



        if (bt_hci_mode_change(hldi, PARAMHANDLE(park_mode),

                                PARAM16(park_mode, max_interval),

                                acl_parked))

            bt_hci_event_status(hldi, HCI_NO_CONNECTION);

        break;



    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_EXIT_PARK_MODE):

        LENGTH_CHECK(exit_park_mode);



        if (bt_hci_mode_cancel(hldi, PARAMHANDLE(exit_park_mode),

                                acl_parked))

            bt_hci_event_status(hldi, HCI_NO_CONNECTION);

        break;



    case cmd_opcode_pack(OGF_LINK_POLICY, OCF_ROLE_DISCOVERY):

        LENGTH_CHECK(role_discovery);



        if (bt_hci_handle_bad(hldi, PARAMHANDLE(role_discovery)))

            bt_hci_event_complete_role_discovery(hldi,

                            HCI_NO_CONNECTION, PARAMHANDLE(role_discovery), 0);

        else

            bt_hci_event_complete_role_discovery(hldi,

                            HCI_SUCCESS, PARAMHANDLE(role_discovery),

                            bt_hci_role_master(hldi,

                                    PARAMHANDLE(role_discovery)));

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_MASK):

        LENGTH_CHECK(set_event_mask);



        memcpy(hldi->event_mask, PARAM(set_event_mask, mask), 8);

        bt_hci_event_complete_status(hldi, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_RESET):

        bt_hci_reset(hldi);

        bt_hci_event_status(hldi, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_SET_EVENT_FLT):

        if (length >= 1 && PARAM(set_event_flt, flt_type) == FLT_CLEAR_ALL)

            /* No length check */;

        else

            LENGTH_CHECK(set_event_flt);



        /* Filters are not implemented */

        bt_hci_event_complete_status(hldi, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_FLUSH):

        LENGTH_CHECK(flush);



        if (bt_hci_handle_bad(hldi, PARAMHANDLE(flush)))

            bt_hci_event_complete_flush(hldi,

                            HCI_NO_CONNECTION, PARAMHANDLE(flush));

        else {

            /* TODO: ordering? */

            bt_hci_event(hldi, EVT_FLUSH_OCCURRED,

                            &PARAM(flush, handle),

                            EVT_FLUSH_OCCURRED_SIZE);

            bt_hci_event_complete_flush(hldi,

                            HCI_SUCCESS, PARAMHANDLE(flush));

        }

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_CHANGE_LOCAL_NAME):

        LENGTH_CHECK(change_local_name);



        if (hldi->device.lmp_name)

            free((void *) hldi->device.lmp_name);

        hldi->device.lmp_name = strndup(PARAM(change_local_name, name),

                        sizeof(PARAM(change_local_name, name)));

        bt_hci_event_complete_status(hldi, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_LOCAL_NAME):

        bt_hci_event_complete_read_local_name(hldi);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CONN_ACCEPT_TIMEOUT):

        bt_hci_event_complete_read_conn_accept_timeout(hldi);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CONN_ACCEPT_TIMEOUT):

        /* TODO */

        LENGTH_CHECK(write_conn_accept_timeout);



        if (PARAM16(write_conn_accept_timeout, timeout) < 0x0001 ||

                        PARAM16(write_conn_accept_timeout, timeout) > 0xb540) {

            bt_hci_event_complete_status(hldi, HCI_INVALID_PARAMETERS);

            break;

        }



        hldi->conn_accept_tout = PARAM16(write_conn_accept_timeout, timeout);

        bt_hci_event_complete_status(hldi, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_SCAN_ENABLE):

        bt_hci_event_complete_read_scan_enable(hldi);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_SCAN_ENABLE):

        LENGTH_CHECK(write_scan_enable);



        /* TODO: check that the remaining bits are all 0 */

        hldi->device.inquiry_scan =

                !!(PARAM(write_scan_enable, scan_enable) & SCAN_INQUIRY);

        hldi->device.page_scan =

                !!(PARAM(write_scan_enable, scan_enable) & SCAN_PAGE);

        bt_hci_event_complete_status(hldi, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_CLASS_OF_DEV):

        bt_hci_event_complete_read_local_class(hldi);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_CLASS_OF_DEV):

        LENGTH_CHECK(write_class_of_dev);



        memcpy(hldi->device.class, PARAM(write_class_of_dev, dev_class),

                        sizeof(PARAM(write_class_of_dev, dev_class)));

        bt_hci_event_complete_status(hldi, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_VOICE_SETTING):

        bt_hci_event_complete_voice_setting(hldi);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_VOICE_SETTING):

        LENGTH_CHECK(write_voice_setting);



        hldi->voice_setting = PARAM(write_voice_setting, voice_setting);

        bt_hci_event_complete_status(hldi, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_HOST_NUMBER_OF_COMPLETED_PACKETS):

        if (length < data[0] * 2 + 1)

            goto short_hci;



        for (a = 0; a < data[0]; a ++)

            if (bt_hci_handle_bad(hldi,

                                    data[a * 2 + 1] | (data[a * 2 + 2] << 8)))

                bt_hci_event_complete_status(hldi, HCI_INVALID_PARAMETERS);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_READ_INQUIRY_MODE):

        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x40)

         * else

         *     goto unknown_command */

        bt_hci_event_complete_read_inquiry_mode(hldi);

        break;



    case cmd_opcode_pack(OGF_HOST_CTL, OCF_WRITE_INQUIRY_MODE):

        /* Only if (local_features[3] & 0x40) && (local_commands[12] & 0x80)

         * else

         *     goto unknown_command */

        LENGTH_CHECK(write_inquiry_mode);



        if (PARAM(write_inquiry_mode, mode) > 0x01) {

            bt_hci_event_complete_status(hldi, HCI_INVALID_PARAMETERS);

            break;

        }



        hldi->lm.inquiry_mode = PARAM(write_inquiry_mode, mode);

        bt_hci_event_complete_status(hldi, HCI_SUCCESS);

        break;



    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_VERSION):

        bt_hci_read_local_version_rp(hldi);

        break;



    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_COMMANDS):

        bt_hci_read_local_commands_rp(hldi);

        break;



    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_FEATURES):

        bt_hci_read_local_features_rp(hldi);

        break;



    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_LOCAL_EXT_FEATURES):

        LENGTH_CHECK(read_local_ext_features);



        bt_hci_read_local_ext_features_rp(hldi,

                        PARAM(read_local_ext_features, page_num));

        break;



    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BUFFER_SIZE):

        bt_hci_read_buffer_size_rp(hldi);

        break;



    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_COUNTRY_CODE):

        bt_hci_read_country_code_rp(hldi);

        break;



    case cmd_opcode_pack(OGF_INFO_PARAM, OCF_READ_BD_ADDR):

        bt_hci_read_bd_addr_rp(hldi);

        break;



    case cmd_opcode_pack(OGF_STATUS_PARAM, OCF_READ_LINK_QUALITY):

        LENGTH_CHECK(read_link_quality);



        bt_hci_link_quality_rp(hldi, PARAMHANDLE(read_link_quality));

        break;



    default:

        bt_hci_event_status(hldi, HCI_UNKNOWN_COMMAND);

        break;



    short_hci:

        fprintf(stderr, ""%s: HCI packet too short (%iB)
"",

                        __FUNCTION__, length);

        bt_hci_event_status(hldi, HCI_INVALID_PARAMETERS);

        break;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"info,data,length,hci,cmd,paramlen,i",,,,25,"info:info,data:data,length:length,hci:hldi,cmd:kind,paramlen:paramsid,i:a,",3,GA,380,0.31931370894114175,GA,
339,"int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)

{

    /* On non-x86 we don't do PCI hotplug */

    monitor_printf(mon, ""Can't hot-add drive to type %d\n"", dinfo->type);

    return -1;

}
",62,,LABEL_1,LABEL_0,,-4,"mon,qdict,dinfo",,,,0,,0,Greedy,1,0.0004433910051981608,,
340,"static int qcow2_co_flush(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    int ret;



    qemu_co_mutex_lock(&s->lock);

    ret = qcow2_cache_flush(bs, s->l2_table_cache);

    if (ret < 0) {


        return ret;

    }



    ret = qcow2_cache_flush(bs, s->refcount_block_cache);

    if (ret < 0) {


        return ret;

    }




    return bdrv_co_flush(bs->file);

}",88,,LABEL_1,LABEL_1,LABEL_1,-1,"bs,s,ret",,,,0,,0,GA,699,0.2485847552617391,failed,
341,"static void control_to_network(RDMAControlHeader *control)

{

    control->type = htonl(control->type);

    control->len = htonl(control->len);

    control->repeat = htonl(control->repeat);

}
",51,"static void control_to_network(RDMAControlHeader *build)

{

    build->type = htonl(build->type);

    build->len = htonl(build->len);

    build->repeat = htonl(build->repeat);

}
",LABEL_1,LABEL_1,LABEL_0,1,control,,,,0,"control:build,",0,GA,165,0.05787277619043986,GA,
342,"static int validate_guest_space(unsigned long guest_base,

                                unsigned long guest_size)

{

    unsigned long real_start, test_page_addr;



    /* We need to check that we can force a fault on access to the

     * commpage at 0xffff0fxx

     */

    test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask);



    /* If the commpage lies within the already allocated guest space,

     * then there is no way we can allocate it.

     */

    if (test_page_addr >= guest_base

        && test_page_addr <= (guest_base + guest_size)) {

        return -1;

    }



    /* Note it needs to be writeable to let us initialise it */

    real_start = (unsigned long)

                 mmap((void *)test_page_addr, qemu_host_page_size,

                     PROT_READ | PROT_WRITE,

                     MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);



    /* If we can't map it then try another address */

    if (real_start == -1ul) {

        return 0;

    }



    if (real_start != test_page_addr) {

        /* OS didn't put the page where we asked - unmap and reject */

        munmap((void *)real_start, qemu_host_page_size);

        return 0;

    }



    /* Leave the page mapped

     * Populate it (mmap should have left it all 0'd)

     */



    /* Kernel helper versions */

    __put_user(5, (uint32_t *)g2h(0xffff0ffcul));



    /* Now it's populated make it RO */

    if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) {

        perror(""Protecting guest commpage"");

        exit(-1);

    }



    return 1; /* All good */

}
",310,,LABEL_0,LABEL_0,LABEL_0,-1,"guest_base,guest_size,real_start,test_page_addr",,,,0,,0,GA,797,0.3254107077916463,failed,
343,"static void *migration_thread(void *opaque)

{

    MigrationState *s = opaque;

    /* Used by the bandwidth calcs, updated later */

    int64_t initial_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);

    int64_t setup_start = qemu_clock_get_ms(QEMU_CLOCK_HOST);

    int64_t initial_bytes = 0;

    int64_t max_size = 0;

    int64_t start_time = initial_time;

    int64_t end_time;

    bool old_vm_running = false;

    bool entered_postcopy = false;

    /* The active state we expect to be in; ACTIVE or POSTCOPY_ACTIVE */

    enum MigrationStatus current_active_state = MIGRATION_STATUS_ACTIVE;



    rcu_register_thread();



    qemu_savevm_state_header(s->to_dst_file);



    if (migrate_postcopy_ram()) {

        /* Now tell the dest that it should open its end so it can reply */

        qemu_savevm_send_open_return_path(s->to_dst_file);



        /* And do a ping that will make stuff easier to debug */

        qemu_savevm_send_ping(s->to_dst_file, 1);



        /*

         * Tell the destination that we *might* want to do postcopy later;

         * if the other end can't do postcopy it should fail now, nice and

         * early.

         */

        qemu_savevm_send_postcopy_advise(s->to_dst_file);

    }



    qemu_savevm_state_begin(s->to_dst_file, &s->params);



    s->setup_time = qemu_clock_get_ms(QEMU_CLOCK_HOST) - setup_start;

    current_active_state = MIGRATION_STATUS_ACTIVE;

    migrate_set_state(&s->state, MIGRATION_STATUS_SETUP,

                      MIGRATION_STATUS_ACTIVE);



    trace_migration_thread_setup_complete();



    while (s->state == MIGRATION_STATUS_ACTIVE ||

           s->state == MIGRATION_STATUS_POSTCOPY_ACTIVE) {

        int64_t current_time;

        uint64_t pending_size;



        if (!qemu_file_rate_limit(s->to_dst_file)) {

            uint64_t pend_post, pend_nonpost;



            qemu_savevm_state_pending(s->to_dst_file, max_size, &pend_nonpost,

                                      &pend_post);

            pending_size = pend_nonpost + pend_post;

            trace_migrate_pending(pending_size, max_size,

                                  pend_post, pend_nonpost);

            if (pending_size && pending_size >= max_size) {

                /* Still a significant amount to transfer */



                if (migrate_postcopy_ram() &&

                    s->state != MIGRATION_STATUS_POSTCOPY_ACTIVE &&

                    pend_nonpost <= max_size &&

                    atomic_read(&s->start_postcopy)) {



                    if (!postcopy_start(s, &old_vm_running)) {

                        current_active_state = MIGRATION_STATUS_POSTCOPY_ACTIVE;

                        entered_postcopy = true;

                    }



                    continue;

                }

                /* Just another iteration step */

                qemu_savevm_state_iterate(s->to_dst_file, entered_postcopy);

            } else {

                trace_migration_thread_low_pending(pending_size);

                migration_completion(s, current_active_state,

                                     &old_vm_running, &start_time);

                break;

            }

        }



        if (qemu_file_get_error(s->to_dst_file)) {

            migrate_set_state(&s->state, current_active_state,

                              MIGRATION_STATUS_FAILED);

            trace_migration_thread_file_err();

            break;

        }

        current_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);

        if (current_time >= initial_time + BUFFER_DELAY) {

            uint64_t transferred_bytes = qemu_ftell(s->to_dst_file) -

                                         initial_bytes;

            uint64_t time_spent = current_time - initial_time;

            double bandwidth = (double)transferred_bytes / time_spent;

            max_size = bandwidth * migrate_max_downtime() / 1000000;



            s->mbps = (((double) transferred_bytes * 8.0) /

                    ((double) time_spent / 1000.0)) / 1000.0 / 1000.0;



            trace_migrate_transferred(transferred_bytes, time_spent,

                                      bandwidth, max_size);

            /* if we haven't sent anything, we don't want to recalculate

               10000 is a small enough number for our purposes */

            if (s->dirty_bytes_rate && transferred_bytes > 10000) {

                s->expected_downtime = s->dirty_bytes_rate / bandwidth;

            }



            qemu_file_reset_rate_limit(s->to_dst_file);

            initial_time = current_time;

            initial_bytes = qemu_ftell(s->to_dst_file);

        }

        if (qemu_file_rate_limit(s->to_dst_file)) {

            /* usleep expects microseconds */

            g_usleep((initial_time + BUFFER_DELAY - current_time)*1000);

        }

    }



    trace_migration_thread_after_loop();

    /* If we enabled cpu throttling for auto-converge, turn it off. */

    cpu_throttle_stop();

    end_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);



    qemu_mutex_lock_iothread();

    qemu_savevm_state_cleanup();

    if (s->state == MIGRATION_STATUS_COMPLETED) {

        uint64_t transferred_bytes = qemu_ftell(s->to_dst_file);

        s->total_time = end_time - s->total_time;

        if (!entered_postcopy) {

            s->downtime = end_time - start_time;

        }

        if (s->total_time) {

            s->mbps = (((double) transferred_bytes * 8.0) /

                       ((double) s->total_time)) / 1000;

        }

        runstate_set(RUN_STATE_POSTMIGRATE);

    } else {

        if (old_vm_running && !entered_postcopy) {

            vm_start();

        } else {

            if (runstate_check(RUN_STATE_FINISH_MIGRATE)) {

                runstate_set(RUN_STATE_POSTMIGRATE);

            }

        }

    }

    qemu_bh_schedule(s->cleanup_bh);

    qemu_mutex_unlock_iothread();



    rcu_unregister_thread();

    return NULL;

}
",863,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,s,end_time,current_time,pending_size,pend_post,pend_nonpost",,,,0,,0,GA,1211,0.6472761670748393,failed,
344,"void qmp_blockdev_add(BlockdevOptions *options, Error **errp)

{

    QmpOutputVisitor *ov = qmp_output_visitor_new();

    QObject *obj;

    QDict *qdict;

    Error *local_err = NULL;



    /* Require an ID in the top level */

    if (!options->has_id) {

        error_setg(errp, ""Block device needs an ID"");

        goto fail;

    }



    /* TODO Sort it out in raw-posix and drive_init: Reject aio=native with

     * cache.direct=false instead of silently switching to aio=threads, except

     * if called from drive_init.

     *

     * For now, simply forbidding the combination for all drivers will do. */

    if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) {

        bool direct = options->cache->has_direct && options->cache->direct;

        if (!options->has_cache && !direct) {

            error_setg(errp, ""aio=native requires cache.direct=true"");

            goto fail;

        }

    }



    visit_type_BlockdevOptions(qmp_output_get_visitor(ov),

                               &options, NULL, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        goto fail;

    }



    obj = qmp_output_get_qobject(ov);

    qdict = qobject_to_qdict(obj);



    qdict_flatten(qdict);



    blockdev_init(NULL, qdict, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        goto fail;

    }



fail:

    qmp_output_visitor_cleanup(ov);

}
",271,,LABEL_1,LABEL_0,,-4,"options,errp,ov,obj,qdict,local_err",,,,0,,0,Greedy,1,0.000591591993967692,,
345,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    if (duration < 0) {





        sc->dts_shift = FFMAX(sc->dts_shift, -duration);

",35,,LABEL_1,LABEL_1,LABEL_1,-1,"sc,duration",,,,0,,0,GA,341,0.11970792611440023,failed,
346,"static int virtcon_parse(const char *devname)

{

    QemuOptsList *device = qemu_find_opts(""device"");

    static int index = 0;

    char label[32];

    QemuOpts *bus_opts, *dev_opts;



    if (strcmp(devname, ""none"") == 0)

        return 0;

    if (index == MAX_VIRTIO_CONSOLES) {

        fprintf(stderr, ""qemu: too many virtio consoles\n"");

        exit(1);

    }



    bus_opts = qemu_opts_create(device, NULL, 0);

    if (arch_type == QEMU_ARCH_S390X) {

        qemu_opt_set(bus_opts, ""driver"", ""virtio-serial-s390"");

    } else {

        qemu_opt_set(bus_opts, ""driver"", ""virtio-serial-pci"");

    } 



    dev_opts = qemu_opts_create(device, NULL, 0);

    qemu_opt_set(dev_opts, ""driver"", ""virtconsole"");



    snprintf(label, sizeof(label), ""virtcon%d"", index);

    virtcon_hds[index] = qemu_chr_new(label, devname, NULL);

    if (!virtcon_hds[index]) {

        fprintf(stderr, ""qemu: could not open virtio console '%s': %s\n"",

                devname, strerror(errno));

        return -1;

    }

    qemu_opt_set(dev_opts, ""chardev"", label);



    index++;

    return 0;

}
",225,,LABEL_1,LABEL_0,,-4,"devname,device,label,bus_opts,dev_opts,index",,,,0,,0,Greedy,1,0.0005568106969197591,,
347,"static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)

{

    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);

    VirtQueueElement elem;

    MemoryRegionSection section;



    while (virtqueue_pop(vq, &elem)) {

        size_t offset = 0;

        uint32_t pfn;



        while (iov_to_buf(elem.out_sg, elem.out_num, offset, &pfn, 4) == 4) {

            ram_addr_t pa;

            ram_addr_t addr;

            int p = virtio_ldl_p(vdev, &pfn);



            pa = (ram_addr_t) p << VIRTIO_BALLOON_PFN_SHIFT;

            offset += 4;



            /* FIXME: remove get_system_memory(), but how? */

            section = memory_region_find(get_system_memory(), pa, 1);

            if (!int128_nz(section.size) || !memory_region_is_ram(section.mr))

                continue;



            trace_virtio_balloon_handle_output(memory_region_name(section.mr),

                                               pa);

            /* Using memory_region_get_ram_ptr is bending the rules a bit, but

               should be OK because we only want a single page.  */

            addr = section.offset_within_region;

            balloon_page(memory_region_get_ram_ptr(section.mr) + addr,

                         !!(vq == s->dvq));

            memory_region_unref(section.mr);

        }



        virtqueue_push(vq, &elem, offset);

        virtio_notify(vdev, vq);

    }

}
",241,,LABEL_0,LABEL_0,LABEL_0,-1,"vdev,vq,s,elem,section,pfn,pa,addr",,,,0,,0,GA,1565,0.6048324465751648,failed,
348,"static void *ff_avio_child_next(void *obj, void *prev)

{

    AVIOContext *s = obj;

    AVIOInternal *internal = s->opaque;

    return prev ? NULL : internal->h;

}
",42,,LABEL_1,LABEL_0,,-4,"obj,prev,s",,,,0,,0,Greedy,1,0.0004474083582560221,,
349,"static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt)

{

    const char *opn = ""loongson_cp2"";

    uint32_t opc, shift_max;

    TCGv_i64 t0, t1;



    opc = MASK_LMI(ctx->opcode);

    switch (opc) {

    case OPC_ADD_CP2:

    case OPC_SUB_CP2:

    case OPC_DADD_CP2:

    case OPC_DSUB_CP2:

        t0 = tcg_temp_local_new_i64();

        t1 = tcg_temp_local_new_i64();

        break;

    default:

        t0 = tcg_temp_new_i64();

        t1 = tcg_temp_new_i64();

        break;

    }



    gen_load_fpr64(ctx, t0, rs);

    gen_load_fpr64(ctx, t1, rt);



#define LMI_HELPER(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break

#define LMI_HELPER_1(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break

#define LMI_DIRECT(UP, LO, OP) \

    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break



    switch (opc) {

    LMI_HELPER(PADDSH, paddsh);

    LMI_HELPER(PADDUSH, paddush);

    LMI_HELPER(PADDH, paddh);

    LMI_HELPER(PADDW, paddw);

    LMI_HELPER(PADDSB, paddsb);

    LMI_HELPER(PADDUSB, paddusb);

    LMI_HELPER(PADDB, paddb);



    LMI_HELPER(PSUBSH, psubsh);

    LMI_HELPER(PSUBUSH, psubush);

    LMI_HELPER(PSUBH, psubh);

    LMI_HELPER(PSUBW, psubw);

    LMI_HELPER(PSUBSB, psubsb);

    LMI_HELPER(PSUBUSB, psubusb);

    LMI_HELPER(PSUBB, psubb);



    LMI_HELPER(PSHUFH, pshufh);

    LMI_HELPER(PACKSSWH, packsswh);

    LMI_HELPER(PACKSSHB, packsshb);

    LMI_HELPER(PACKUSHB, packushb);



    LMI_HELPER(PUNPCKLHW, punpcklhw);

    LMI_HELPER(PUNPCKHHW, punpckhhw);

    LMI_HELPER(PUNPCKLBH, punpcklbh);

    LMI_HELPER(PUNPCKHBH, punpckhbh);

    LMI_HELPER(PUNPCKLWD, punpcklwd);

    LMI_HELPER(PUNPCKHWD, punpckhwd);



    LMI_HELPER(PAVGH, pavgh);

    LMI_HELPER(PAVGB, pavgb);

    LMI_HELPER(PMAXSH, pmaxsh);

    LMI_HELPER(PMINSH, pminsh);

    LMI_HELPER(PMAXUB, pmaxub);

    LMI_HELPER(PMINUB, pminub);



    LMI_HELPER(PCMPEQW, pcmpeqw);

    LMI_HELPER(PCMPGTW, pcmpgtw);

    LMI_HELPER(PCMPEQH, pcmpeqh);

    LMI_HELPER(PCMPGTH, pcmpgth);

    LMI_HELPER(PCMPEQB, pcmpeqb);

    LMI_HELPER(PCMPGTB, pcmpgtb);



    LMI_HELPER(PSLLW, psllw);

    LMI_HELPER(PSLLH, psllh);

    LMI_HELPER(PSRLW, psrlw);

    LMI_HELPER(PSRLH, psrlh);

    LMI_HELPER(PSRAW, psraw);

    LMI_HELPER(PSRAH, psrah);



    LMI_HELPER(PMULLH, pmullh);

    LMI_HELPER(PMULHH, pmulhh);

    LMI_HELPER(PMULHUH, pmulhuh);

    LMI_HELPER(PMADDHW, pmaddhw);



    LMI_HELPER(PASUBUB, pasubub);

    LMI_HELPER_1(BIADD, biadd);

    LMI_HELPER_1(PMOVMSKB, pmovmskb);



    LMI_DIRECT(PADDD, paddd, add);

    LMI_DIRECT(PSUBD, psubd, sub);

    LMI_DIRECT(XOR_CP2, xor, xor);

    LMI_DIRECT(NOR_CP2, nor, nor);

    LMI_DIRECT(AND_CP2, and, and);

    LMI_DIRECT(PANDN, pandn, andc);

    LMI_DIRECT(OR, or, or);



    case OPC_PINSRH_0:

        tcg_gen_deposit_i64(t0, t0, t1, 0, 16);

        opn = ""pinsrh_0"";

        break;

    case OPC_PINSRH_1:

        tcg_gen_deposit_i64(t0, t0, t1, 16, 16);

        opn = ""pinsrh_1"";

        break;

    case OPC_PINSRH_2:

        tcg_gen_deposit_i64(t0, t0, t1, 32, 16);

        opn = ""pinsrh_2"";

        break;

    case OPC_PINSRH_3:

        tcg_gen_deposit_i64(t0, t0, t1, 48, 16);

        opn = ""pinsrh_3"";

        break;



    case OPC_PEXTRH:

        tcg_gen_andi_i64(t1, t1, 3);

        tcg_gen_shli_i64(t1, t1, 4);

        tcg_gen_shr_i64(t0, t0, t1);

        tcg_gen_ext16u_i64(t0, t0);

        opn = ""pextrh"";

        break;



    case OPC_ADDU_CP2:

        tcg_gen_add_i64(t0, t0, t1);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;

    case OPC_SUBU_CP2:

        tcg_gen_sub_i64(t0, t0, t1);

        tcg_gen_ext32s_i64(t0, t0);

        opn = ""addu"";

        break;



    case OPC_SLL_CP2:

        opn = ""sll"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRL_CP2:

        opn = ""srl"";

        shift_max = 32;

        goto do_shift;

    case OPC_SRA_CP2:

        opn = ""sra"";

        shift_max = 32;

        goto do_shift;

    case OPC_DSLL_CP2:

        opn = ""dsll"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRL_CP2:

        opn = ""dsrl"";

        shift_max = 64;

        goto do_shift;

    case OPC_DSRA_CP2:

        opn = ""dsra"";

        shift_max = 64;

        goto do_shift;

    do_shift:

        /* Make sure shift count isn't TCG undefined behaviour.  */

        tcg_gen_andi_i64(t1, t1, shift_max - 1);



        switch (opc) {

        case OPC_SLL_CP2:

        case OPC_DSLL_CP2:

            tcg_gen_shl_i64(t0, t0, t1);

            break;

        case OPC_SRA_CP2:

        case OPC_DSRA_CP2:

            /* Since SRA is UndefinedResult without sign-extended inputs,

               we can treat SRA and DSRA the same.  */

            tcg_gen_sar_i64(t0, t0, t1);

            break;

        case OPC_SRL_CP2:

            /* We want to shift in zeros for SRL; zero-extend first.  */

            tcg_gen_ext32u_i64(t0, t0);

            /* FALLTHRU */

        case OPC_DSRL_CP2:

            tcg_gen_shr_i64(t0, t0, t1);

            break;

        }



        if (shift_max == 32) {

            tcg_gen_ext32s_i64(t0, t0);

        }



        /* Shifts larger than MAX produce zero.  */

        tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max);

        tcg_gen_neg_i64(t1, t1);

        tcg_gen_and_i64(t0, t0, t1);

        break;



    case OPC_ADD_CP2:

    case OPC_DADD_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_add_i64(t0, t1, t2);

            if (opc == OPC_ADD_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(t1, t1, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_andc_i64(t1, t2, t1);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_ADD_CP2 ? ""add"" : ""dadd"");

            break;

        }



    case OPC_SUB_CP2:

    case OPC_DSUB_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, t0);

            tcg_gen_sub_i64(t0, t1, t2);

            if (opc == OPC_SUB_CP2) {

                tcg_gen_ext32s_i64(t0, t0);

            }

            tcg_gen_xor_i64(t1, t1, t2);

            tcg_gen_xor_i64(t2, t2, t0);

            tcg_gen_and_i64(t1, t1, t2);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab);

            generate_exception(ctx, EXCP_OVERFLOW);

            gen_set_label(lab);



            opn = (opc == OPC_SUB_CP2 ? ""sub"" : ""dsub"");

            break;

        }



    case OPC_PMULUW:

        tcg_gen_ext32u_i64(t0, t0);

        tcg_gen_ext32u_i64(t1, t1);

        tcg_gen_mul_i64(t0, t0, t1);

        opn = ""pmuluw"";

        break;



    case OPC_SEQU_CP2:

    case OPC_SEQ_CP2:

    case OPC_SLTU_CP2:

    case OPC_SLT_CP2:

    case OPC_SLEU_CP2:

    case OPC_SLE_CP2:

        /* ??? Document is unclear: Set FCC[CC].  Does that mean the

           FD field is the CC field?  */

    default:

        MIPS_INVAL(opn);

        generate_exception(ctx, EXCP_RI);

        return;

    }



#undef LMI_HELPER

#undef LMI_DIRECT



    gen_store_fpr64(ctx, t0, rd);



    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %s, %s"", opn,

               fregnames[rd], fregnames[rs], fregnames[rt]);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i64(t1);

}
",1387,"static void gen_loongson_multimedia(DisasContext *ck, int rf, int sw, int rc)

{

    const char *Opc = ""loongson_cp2"";

    uint32_t copcode, push_min;

    TCGv_i64 ty00, ty1;



   copcodec = MASK_LMI(ck->opcode);

    switch (copcode) {

    case OPC_ADD_CP2:

    case OPC_SUB_CP2:

    case OPC_DADD_CP2:

    case OPC_DSUB_CP2:

        ty00 = tcg_temp_local_new_i64();

        ty1 = tcg_temp_local_new_i64();

        break;

    default:

        ty00 = tcg_temp_new_i64();

        ty1 = tcg_temp_new_i64();

        break;

    }



    gen_load_fpr64(ck, ty00, sw);

    gen_load_fpr64(ck, ty1, rc);



#define LMI_HELPER(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break

#define LMI_HELPER_1(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break

#define LMI_DIRECT(UP, LO, OP) \

    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break



    switch (copcode) {

    LMI_HELPER(PADDSH, paddsh);

    LMI_HELPER(PADDUSH, paddush);

    LMI_HELPER(PADDH, paddh);

    LMI_HELPER(PADDW, paddw);

    LMI_HELPER(PADDSB, paddsb);

    LMI_HELPER(PADDUSB, paddusb);

    LMI_HELPER(PADDB, paddb);



    LMI_HELPER(PSUBSH, psubsh);

    LMI_HELPER(PSUBUSH, psubush);

    LMI_HELPER(PSUBH, psubh);

    LMI_HELPER(PSUBW, psubw);

    LMI_HELPER(PSUBSB, psubsb);

    LMI_HELPER(PSUBUSB, psubusb);

    LMI_HELPER(PSUBB, psubb);



    LMI_HELPER(PSHUFH, pshufh);

    LMI_HELPER(PACKSSWH, packsswh);

    LMI_HELPER(PACKSSHB, packsshb);

    LMI_HELPER(PACKUSHB, packushb);



    LMI_HELPER(PUNPCKLHW, punpcklhw);

    LMI_HELPER(PUNPCKHHW, punpckhhw);

    LMI_HELPER(PUNPCKLBH, punpcklbh);

    LMI_HELPER(PUNPCKHBH, punpckhbh);

    LMI_HELPER(PUNPCKLWD, punpcklwd);

    LMI_HELPER(PUNPCKHWD, punpckhwd);



    LMI_HELPER(PAVGH, pavgh);

    LMI_HELPER(PAVGB, pavgb);

    LMI_HELPER(PMAXSH, pmaxsh);

    LMI_HELPER(PMINSH, pminsh);

    LMI_HELPER(PMAXUB, pmaxub);

    LMI_HELPER(PMINUB, pminub);



    LMI_HELPER(PCMPEQW, pcmpeqw);

    LMI_HELPER(PCMPGTW, pcmpgtw);

    LMI_HELPER(PCMPEQH, pcmpeqh);

    LMI_HELPER(PCMPGTH, pcmpgth);

    LMI_HELPER(PCMPEQB, pcmpeqb);

    LMI_HELPER(PCMPGTB, pcmpgtb);



    LMI_HELPER(PSLLW, psllw);

    LMI_HELPER(PSLLH, psllh);

    LMI_HELPER(PSRLW, psrlw);

    LMI_HELPER(PSRLH, psrlh);

    LMI_HELPER(PSRAW, psraw);

    LMI_HELPER(PSRAH, psrah);



    LMI_HELPER(PMULLH, pmullh);

    LMI_HELPER(PMULHH, pmulhh);

    LMI_HELPER(PMULHUH, pmulhuh);

    LMI_HELPER(PMADDHW, pmaddhw);



    LMI_HELPER(PASUBUB, pasubub);

    LMI_HELPER_1(BIADD, biadd);

    LMI_HELPER_1(PMOVMSKB, pmovmskb);



    LMI_DIRECT(PADDD, paddd, add);

    LMI_DIRECT(PSUBD, psubd, sub);

    LMI_DIRECT(XOR_CP2, xor, xor);

    LMI_DIRECT(NOR_CP2, nor, nor);

    LMI_DIRECT(AND_CP2, and, and);

    LMI_DIRECT(PANDN, pandn, andc);

    LMI_DIRECT(OR, or, or);



    case OPC_PINSRH_0:

        tcg_gen_deposit_i64(ty00, ty00, ty1, 0, 16);

        Opc = ""pinsrh_0"";

        break;

    case OPC_PINSRH_1:

        tcg_gen_deposit_i64(ty00, ty00, ty1, 16, 16);

        Opc = ""pinsrh_1"";

        break;

    case OPC_PINSRH_2:

        tcg_gen_deposit_i64(ty00, ty00, ty1, 32, 16);

        Opc = ""pinsrh_2"";

        break;

    case OPC_PINSRH_3:

        tcg_gen_deposit_i64(ty00, ty00, ty1, 48, 16);

        Opc = ""pinsrh_3"";

        break;



    case OPC_PEXTRH:

        tcg_gen_andi_i64(ty1, ty1, 3);

        tcg_gen_shli_i64(ty1, ty1, 4);

        tcg_gen_shr_i64(ty00, ty00, ty1);

        tcg_gen_ext16u_i64(ty00, ty00);

        Opc = ""pextrh"";

        break;



    case OPC_ADDU_CP2:

        tcg_gen_add_i64(ty00, ty00, ty1);

        tcg_gen_ext32s_i64(ty00, ty00);

        Opc = ""addu"";

        break;

    case OPC_SUBU_CP2:

        tcg_gen_sub_i64(ty00, ty00, ty1);

        tcg_gen_ext32s_i64(ty00, ty00);

        Opc = ""addu"";

        break;



    case OPC_SLL_CP2:

        Opc = ""sll"";

        push_min = 32;

        goto do_shift;

    case OPC_SRL_CP2:

        Opc = ""srl"";

        push_min = 32;

        goto do_shift;

    case OPC_SRA_CP2:

        Opc = ""sra"";

        push_min = 32;

        goto do_shift;

    case OPC_DSLL_CP2:

        Opc = ""dsll"";

        push_min = 64;

        goto do_shift;

    case OPC_DSRL_CP2:

        Opc = ""dsrl"";

        push_min = 64;

        goto do_shift;

    case OPC_DSRA_CP2:

        Opc = ""dsra"";

        push_min = 64;

        goto do_shift;

    do_shift:

        /* Make sure shift count isn't TCG undefined behaviour.  */

        tcg_gen_andi_i64ty11,ty11, push_min - 1);



        switch (copcode) {

        case OPC_SLL_CP2:

        case OPC_DSLL_CP2:

            tcg_gen_shl_i64(ty00, ty00, ty1);

            break;

        case OPC_SRA_CP2:

        case OPC_DSRA_CP2:

            /* Since SRA is UndefinedResult without sign-extended inputs,

               we can treat SRA and DSRA the same.  */

            tcg_gen_sar_i64(ty00, ty00, ty1);

            break;

        case OPC_SRL_CP2:

            /* We want to shift in zeros for SRL; zero-extend first.  */

            tcg_gen_ext32u_i64(ty00, ty00);

            /* FALLTHRU */

        case OPC_DSRL_CP2:

            tcg_gen_shr_i64(ty00, ty00, ty1);

            break;

        }



        if (push_min == 32) {

            tcg_gen_ext32s_i64(ty00, ty00);

        }



        /* Shifts larger than MAX produce zero.  */

        tcg_gen_setcondi_i64(TCG_COND_LTU,ty11,ty11, push_min);

        tcg_gen_neg_i64(ty1, ty1);

        tcg_gen_and_i64(ty00, ty00, ty1);

        break;



    case OPC_ADD_CP2:

    case OPC_DADD_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, ty00);

            tcg_gen_add_i64(ty00, ty1, t2);

            if (copcode == OPC_ADD_CP2) {

                tcg_gen_ext32s_i64(ty00, ty00);

            }

            tcg_gen_xor_i64(ty1, ty1, t2);

            tcg_gen_xor_i64(t2, t2, ty00);

            tcg_gen_andc_i64(ty1, t2, ty1);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, ty1, 0, lab);

            generate_exception(ck, EXCP_OVERFLOW);

            gen_set_label(lab);



            Opc = (copcode == OPC_ADD_CP2 ? ""add"" : ""dadd"");

            break;

        }



    case OPC_SUB_CP2:

    case OPC_DSUB_CP2:

        {

            TCGv_i64 t2 = tcg_temp_new_i64();

            int lab = gen_new_label();



            tcg_gen_mov_i64(t2, ty00);

            tcg_gen_sub_i64(ty00, ty1, t2);

            if (copcode == OPC_SUB_CP2) {

                tcg_gen_ext32s_i64(ty00, ty00);

            }

            tcg_gen_xor_i64(ty1, ty1, t2);

            tcg_gen_xor_i64(t2, t2, ty00);

            tcg_gen_and_i64(ty1, ty1, t2);

            tcg_temp_free_i64(t2);

            tcg_gen_brcondi_i64(TCG_COND_GE, ty1, 0, lab);

            generate_exception(ck, EXCP_OVERFLOW);

            gen_set_label(lab);



            Opc = (copcode == OPC_SUB_CP2 ? ""sub"" : ""dsub"");

            break;

        }



    case OPC_PMULUW:

        tcg_gen_ext32u_i64(ty00, ty00);

        tcg_gen_ext32u_i64(ty1, ty1);

        tcg_gen_mul_i64(ty00, ty00, ty1);

        Opc = ""pmuluw"";

        break;



    case OPC_SEQU_CP2:

    case OPC_SEQ_CP2:

    case OPC_SLTU_CP2:

    case OPC_SLT_CP2:

    case OPC_SLEU_CP2:

    case OPC_SLE_CP2:

        /* ??? Document is unclear: Set FCC[CC].  Does that mean the

           FD field is the CC field?  */

    default:

        MIPS_INVAL(Opc);

        generate_exception(ck, EXCP_RI);

        return;

    }



#undef LMI_HELPER

#undef LMI_DIRECT



    gen_store_fpr64(ck, ty00, rf);



    (void)Opc; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %s, %s"", Opc,

               fregnames[rf], fregnames[sw], fregnames[rc]);

    tcg_temp_free_i64(ty00);

    tcg_temp_free_i64(ty1);

}
",LABEL_0,LABEL_0,LABEL_1,1,"ctx,rd,rs,rt,opn,opc,shift_max,t0,t1",,,,0,"ctx:ck,rd:rf,rs:sw,rt:rc,opn:Opc,opc:copcode,shift_max:push_min,t0:ty00,t1:ty1,",0,GA,789,0.44894384940465293,GA,
350,"aio_compute_timeout(AioContext *ctx)

{

    int64_t deadline;

    int timeout = -1;

    QEMUBH *bh;



    for (bh = atomic_rcu_read(&ctx->first_bh); bh;

         bh = atomic_rcu_read(&bh->next)) {

        if (bh->scheduled) {

            if (bh->idle) {

                /* idle bottom halves will be polled at least

                 * every 10ms */

                timeout = 10000000;

            } else {

                /* non-idle bottom halves will be executed

                 * immediately */

                return 0;

            }

        }

    }



    deadline = timerlistgroup_deadline_ns(&ctx->tlg);

    if (deadline == 0) {

        return 0;

    } else {

        return qemu_soonest_timeout(timeout, deadline);

    }

}
",142,"aio_compute_timeout(AioContext *ctx)

{

    int64_t goldlining;

    int timeout = -1;

    QEMUBH *hm;



    for (hm = atomic_rcu_read(&ctx->first_bh); hm;

         hm = atomic_rcu_read(&hm->next)) {

        if (hm->scheduled) {

            if (hm->idle) {

                /* idle bottom halves will be polled at least

                 * every 10ms */

                timeout = 10000000;

            } else {

                /* non-idle bottom halves will be executed

                 * immediately */

                return 0;

            }

        }

    }



    goldlining = timerlistgroup_deadline_ns(&ctx->tlg);

    if (goldlining == 0) {

        return 0;

    } else {

        return qemu_soonest_timeout(timeout, goldlining);

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"deadline,bh",,,,0,"deadline:goldlining,bh:hm,",0,GA,144,0.05291866461435954,GA,
351,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}
",132,"static ExitStatus trans_log(DisasContext *loc, uint32_t insn,

                            const DisasInsn *gi)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_g2, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(loc);

    }

    tcg_g2 = load_gpr(loc, r1);

    tcg_r2 = load_gpr(loc, r2);

    ret = do_log(loc, rt, tcg_g2, tcg_r2, cf, gi->f_ttt);

    return nullify_end(loc, ret);

}
",LABEL_1,LABEL_1,LABEL_0,1,"ctx,insn,di,tcg_r1,tcg_r2,ret",,,,11,"ctx:loc,insn:insn,di:gi,tcg_r1:tcg_g2,tcg_r2:tcg_r2,ret:ret,",3,GA,292,0.10554507573445639,GA,
352,"uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)

{

    uint8_t ret;



    OMAP_8B_REG(addr);

    cpu_physical_memory_read(addr, (void *) &ret, 1);

    return ret;

}
",38,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,addr,ret",,,,0,,0,GA,318,0.11273641188939412,failed,
353,"int ff_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt)

{

    int i;



    for (i = 0; i < 256; i++) {

        int r, g, b;



        switch (pix_fmt) {

        case AV_PIX_FMT_RGB8:

            r = (i>>5    )*36;

            g = ((i>>2)&7)*36;

            b = (i&3     )*85;

            break;

        case AV_PIX_FMT_BGR8:

            b = (i>>6    )*85;

            g = ((i>>3)&7)*36;

            r = (i&7     )*36;

            break;

        case AV_PIX_FMT_RGB4_BYTE:

            r = (i>>3    )*255;

            g = ((i>>1)&3)*85;

            b = (i&1     )*255;

            break;

        case AV_PIX_FMT_BGR4_BYTE:

            b = (i>>3    )*255;

            g = ((i>>1)&3)*85;

            r = (i&1     )*255;

            break;

        case AV_PIX_FMT_GRAY8:

            r = b = g = i;

            break;

        default:

            return AVERROR(EINVAL);

        }

        pal[i] = b + (g<<8) + (r<<16) + (0xFF<<24);

    }



    return 0;

}
",252,,LABEL_1,LABEL_0,,-4,"pal,pix_fmt,i,r,g,b",,,,0,,0,Greedy,1,0.0005687991778055827,,
354,"static int kvm_get_msrs(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;

    int ret, i;

    uint64_t mtrr_top_bits;



    kvm_msr_buf_reset(cpu);



    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);

    kvm_msr_entry_add(cpu, MSR_PAT, 0);

    if (has_msr_star) {

        kvm_msr_entry_add(cpu, MSR_STAR, 0);

    }

    if (has_msr_hsave_pa) {

        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);

    }

    if (has_msr_tsc_aux) {

        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);

    }

    if (has_msr_tsc_adjust) {

        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);

    }

    if (has_msr_tsc_deadline) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);

    }

    if (has_msr_misc_enable) {

        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);

    }

    if (has_msr_smbase) {

        kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0);

    }

    if (has_msr_feature_control) {

        kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0);

    }

    if (has_msr_bndcfgs) {

        kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0);

    }

    if (has_msr_xss) {

        kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0);

    }





    if (!env->tsc_valid) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0);

        env->tsc_valid = !runstate_is_running();

    }



#ifdef TARGET_X86_64

    if (lm_capable_kernel) {

        kvm_msr_entry_add(cpu, MSR_CSTAR, 0);

        kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0);

        kvm_msr_entry_add(cpu, MSR_FMASK, 0);

        kvm_msr_entry_add(cpu, MSR_LSTAR, 0);

    }

#endif

    kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0);

    kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0);

    if (has_msr_async_pf_en) {

        kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0);

    }

    if (has_msr_pv_eoi_en) {

        kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0);

    }

    if (has_msr_kvm_steal_time) {

        kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0);

    }

    if (has_msr_architectural_pmu) {

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0);

        for (i = 0; i < MAX_FIXED_COUNTERS; i++) {

            kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0);

        }

        for (i = 0; i < num_architectural_pmu_counters; i++) {

            kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0);

            kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0);

        }

    }



    if (env->mcg_cap) {

        kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0);

        kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0);

        if (has_msr_mcg_ext_ctl) {

            kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0);

        }

        for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) {

            kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0);

        }

    }



    if (has_msr_hv_hypercall) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0);

    }

    if (has_msr_hv_vapic) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0);

    }

    if (has_msr_hv_tsc) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0);

    }

    if (has_msr_hv_crash) {

        int j;



        for (j = 0; j < HV_X64_MSR_CRASH_PARAMS; j++) {

            kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + j, 0);

        }

    }

    if (has_msr_hv_runtime) {

        kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0);

    }

    if (cpu->hyperv_synic) {

        uint32_t msr;



        kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0);

        kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0);

        for (msr = HV_X64_MSR_SINT0; msr <= HV_X64_MSR_SINT15; msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_hv_stimer) {

        uint32_t msr;



        for (msr = HV_X64_MSR_STIMER0_CONFIG; msr <= HV_X64_MSR_STIMER3_COUNT;

             msr++) {

            kvm_msr_entry_add(cpu, msr, 0);

        }

    }

    if (has_msr_mtrr) {

        kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0);

        kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0);

        for (i = 0; i < MSR_MTRRcap_VCNT; i++) {

            kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0);

            kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0);

        }

    }



    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf);

    if (ret < 0) {

        return ret;

    }



    assert(ret == cpu->kvm_msr_buf->nmsrs);

    /*

     * MTRR masks: Each mask consists of 5 parts

     * a  10..0: must be zero

     * b  11   : valid bit

     * c n-1.12: actual mask bits

     * d  51..n: reserved must be zero

     * e  63.52: reserved must be zero

     *

     * 'n' is the number of physical bits supported by the CPU and is

     * apparently always <= 52.   We know our 'n' but don't know what

     * the destinations 'n' is; it might be smaller, in which case

     * it masks (c) on loading. It might be larger, in which case

     * we fill 'd' so that d..c is consistent irrespetive of the 'n'

     * we're migrating to.

     */



    if (cpu->fill_mtrr_mask) {

        QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52);

        assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS);

        mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits);

    } else {

        mtrr_top_bits = 0;

    }



    for (i = 0; i < ret; i++) {

        uint32_t index = msrs[i].index;

        switch (index) {

        case MSR_IA32_SYSENTER_CS:

            env->sysenter_cs = msrs[i].data;

            break;

        case MSR_IA32_SYSENTER_ESP:

            env->sysenter_esp = msrs[i].data;

            break;

        case MSR_IA32_SYSENTER_EIP:

            env->sysenter_eip = msrs[i].data;

            break;

        case MSR_PAT:

            env->pat = msrs[i].data;

            break;

        case MSR_STAR:

            env->star = msrs[i].data;

            break;

#ifdef TARGET_X86_64

        case MSR_CSTAR:

            env->cstar = msrs[i].data;

            break;

        case MSR_KERNELGSBASE:

            env->kernelgsbase = msrs[i].data;

            break;

        case MSR_FMASK:

            env->fmask = msrs[i].data;

            break;

        case MSR_LSTAR:

            env->lstar = msrs[i].data;

            break;

#endif

        case MSR_IA32_TSC:

            env->tsc = msrs[i].data;

            break;

        case MSR_TSC_AUX:

            env->tsc_aux = msrs[i].data;

            break;

        case MSR_TSC_ADJUST:

            env->tsc_adjust = msrs[i].data;

            break;

        case MSR_IA32_TSCDEADLINE:

            env->tsc_deadline = msrs[i].data;

            break;

        case MSR_VM_HSAVE_PA:

            env->vm_hsave = msrs[i].data;

            break;

        case MSR_KVM_SYSTEM_TIME:

            env->system_time_msr = msrs[i].data;

            break;

        case MSR_KVM_WALL_CLOCK:

            env->wall_clock_msr = msrs[i].data;

            break;

        case MSR_MCG_STATUS:

            env->mcg_status = msrs[i].data;

            break;

        case MSR_MCG_CTL:

            env->mcg_ctl = msrs[i].data;

            break;

        case MSR_MCG_EXT_CTL:

            env->mcg_ext_ctl = msrs[i].data;

            break;

        case MSR_IA32_MISC_ENABLE:

            env->msr_ia32_misc_enable = msrs[i].data;

            break;

        case MSR_IA32_SMBASE:

            env->smbase = msrs[i].data;

            break;

        case MSR_IA32_FEATURE_CONTROL:

            env->msr_ia32_feature_control = msrs[i].data;

            break;

        case MSR_IA32_BNDCFGS:

            env->msr_bndcfgs = msrs[i].data;

            break;

        case MSR_IA32_XSS:

            env->xss = msrs[i].data;

            break;

        default:

            if (msrs[i].index >= MSR_MC0_CTL &&

                msrs[i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) {

                env->mce_banks[msrs[i].index - MSR_MC0_CTL] = msrs[i].data;

            }

            break;

        case MSR_KVM_ASYNC_PF_EN:

            env->async_pf_en_msr = msrs[i].data;

            break;

        case MSR_KVM_PV_EOI_EN:

            env->pv_eoi_en_msr = msrs[i].data;

            break;

        case MSR_KVM_STEAL_TIME:

            env->steal_time_msr = msrs[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR_CTRL:

            env->msr_fixed_ctr_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_CTRL:

            env->msr_global_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_STATUS:

            env->msr_global_status = msrs[i].data;

            break;

        case MSR_CORE_PERF_GLOBAL_OVF_CTRL:

            env->msr_global_ovf_ctrl = msrs[i].data;

            break;

        case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1:

            env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = msrs[i].data;

            break;

        case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_counters[index - MSR_P6_PERFCTR0] = msrs[i].data;

            break;

        case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1:

            env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = msrs[i].data;

            break;

        case HV_X64_MSR_HYPERCALL:

            env->msr_hv_hypercall = msrs[i].data;

            break;

        case HV_X64_MSR_GUEST_OS_ID:

            env->msr_hv_guest_os_id = msrs[i].data;

            break;

        case HV_X64_MSR_APIC_ASSIST_PAGE:

            env->msr_hv_vapic = msrs[i].data;

            break;

        case HV_X64_MSR_REFERENCE_TSC:

            env->msr_hv_tsc = msrs[i].data;

            break;

        case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:

            env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = msrs[i].data;

            break;

        case HV_X64_MSR_VP_RUNTIME:

            env->msr_hv_runtime = msrs[i].data;

            break;

        case HV_X64_MSR_SCONTROL:

            env->msr_hv_synic_control = msrs[i].data;

            break;

        case HV_X64_MSR_SVERSION:

            env->msr_hv_synic_version = msrs[i].data;

            break;

        case HV_X64_MSR_SIEFP:

            env->msr_hv_synic_evt_page = msrs[i].data;

            break;

        case HV_X64_MSR_SIMP:

            env->msr_hv_synic_msg_page = msrs[i].data;

            break;

        case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:

            env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = msrs[i].data;

            break;

        case HV_X64_MSR_STIMER0_CONFIG:

        case HV_X64_MSR_STIMER1_CONFIG:

        case HV_X64_MSR_STIMER2_CONFIG:

        case HV_X64_MSR_STIMER3_CONFIG:

            env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] =

                                msrs[i].data;

            break;

        case HV_X64_MSR_STIMER0_COUNT:

        case HV_X64_MSR_STIMER1_COUNT:

        case HV_X64_MSR_STIMER2_COUNT:

        case HV_X64_MSR_STIMER3_COUNT:

            env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] =

                                msrs[i].data;

            break;

        case MSR_MTRRdefType:

            env->mtrr_deftype = msrs[i].data;

            break;

        case MSR_MTRRfix64K_00000:

            env->mtrr_fixed[0] = msrs[i].data;

            break;

        case MSR_MTRRfix16K_80000:

            env->mtrr_fixed[1] = msrs[i].data;

            break;

        case MSR_MTRRfix16K_A0000:

            env->mtrr_fixed[2] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_C0000:

            env->mtrr_fixed[3] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_C8000:

            env->mtrr_fixed[4] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_D0000:

            env->mtrr_fixed[5] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_D8000:

            env->mtrr_fixed[6] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_E0000:

            env->mtrr_fixed[7] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_E8000:

            env->mtrr_fixed[8] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_F0000:

            env->mtrr_fixed[9] = msrs[i].data;

            break;

        case MSR_MTRRfix4K_F8000:

            env->mtrr_fixed[10] = msrs[i].data;

            break;

        case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1):

            if (index & 1) {

                env->mtrr_var[MSR_MTRRphysIndex(index)].mask = msrs[i].data |

                                                               mtrr_top_bits;

            } else {

                env->mtrr_var[MSR_MTRRphysIndex(index)].base = msrs[i].data;

            }

            break;

        }

    }



    return 0;

}
",2443,,LABEL_0,LABEL_1,,-4,"cpu,env,msrs,ret,i,mtrr_top_bits",,,,0,,0,Greedy,1,0.0019273559252421062,,
355,"static void free_geotags(TiffContext *const s)

{

    int i;

    for (i = 0; i < s->geotag_count; i++) {

        if (s->geotags[i].val)

            av_freep(&s->geotags[i].val);

    }

    av_freep(&s->geotags);


}",68,,LABEL_1,LABEL_1,LABEL_1,-1,"s,i",,,,0,,0,GA,491,0.17484842936197917,failed,
356,"int ff_ass_split_override_codes(const ASSCodesCallbacks *callbacks, void *priv,

                                const char *buf)

{

    const char *text = NULL;

    char new_line[2];

    int text_len = 0;



    while (*buf) {

        if (text && callbacks->text &&

            (sscanf(buf, ""\\%1[nN]"", new_line) == 1 ||

             !strncmp(buf, ""{\\"", 2))) {

            callbacks->text(priv, text, text_len);

            text = NULL;

        }

        if (sscanf(buf, ""\\%1[nN]"", new_line) == 1) {

            if (callbacks->new_line)

                callbacks->new_line(priv, new_line[0] == 'N');

            buf += 2;

        } else if (!strncmp(buf, ""{\\"", 2)) {

            buf++;

            while (*buf == '\\') {

                char style[2], c[2], sep[2], c_num[2] = ""0"", tmp[128] = {0};

                unsigned int color = 0xFFFFFFFF;

                int len, size = -1, an = -1, alpha = -1;

                int x1, y1, x2, y2, t1 = -1, t2 = -1;

                if (sscanf(buf, ""\\%1[bisu]%1[01\\}]%n"", style, c, &len) > 1) {

                    int close = c[0] == '0' ? 1 : c[0] == '1' ? 0 : -1;

                    len += close != -1;

                    if (callbacks->style)

                        callbacks->style(priv, style[0], close);

                } else if (sscanf(buf, ""\\c%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(buf, ""\\c&H%X&%1[\\}]%n"", &color, sep, &len) > 1 ||

                           sscanf(buf, ""\\%1[1234]c%1[\\}]%n"", c_num, sep, &len) > 1 ||

                           sscanf(buf, ""\\%1[1234]c&H%X&%1[\\}]%n"", c_num, &color, sep, &len) > 2) {

                    if (callbacks->color)

                        callbacks->color(priv, color, c_num[0] - '0');

                } else if (sscanf(buf, ""\\alpha%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(buf, ""\\alpha&H%2X&%1[\\}]%n"", &alpha, sep, &len) > 1 ||

                           sscanf(buf, ""\\%1[1234]a%1[\\}]%n"", c_num, sep, &len) > 1 ||

                           sscanf(buf, ""\\%1[1234]a&H%2X&%1[\\}]%n"", c_num, &alpha, sep, &len) > 2) {

                    if (callbacks->alpha)

                        callbacks->alpha(priv, alpha, c_num[0] - '0');

                } else if (sscanf(buf, ""\\fn%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(buf, ""\\fn%127[^\\}]%1[\\}]%n"", tmp, sep, &len) > 1) {

                    if (callbacks->font_name)

                        callbacks->font_name(priv, tmp[0] ? tmp : NULL);

                } else if (sscanf(buf, ""\\fs%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(buf, ""\\fs%u%1[\\}]%n"", &size, sep, &len) > 1) {

                    if (callbacks->font_size)

                        callbacks->font_size(priv, size);

                } else if (sscanf(buf, ""\\a%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(buf, ""\\a%2u%1[\\}]%n"", &an, sep, &len) > 1 ||

                           sscanf(buf, ""\\an%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(buf, ""\\an%1u%1[\\}]%n"", &an, sep, &len) > 1) {

                    if (an != -1 && buf[2] != 'n')

                        an = (an&3) + (an&4 ? 6 : an&8 ? 3 : 0);

                    if (callbacks->alignment)

                        callbacks->alignment(priv, an);

                } else if (sscanf(buf, ""\\r%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(buf, ""\\r%127[^\\}]%1[\\}]%n"", tmp, sep, &len) > 1) {

                    if (callbacks->cancel_overrides)

                        callbacks->cancel_overrides(priv, tmp);

                } else if (sscanf(buf, ""\\move(%d,%d,%d,%d)%1[\\}]%n"", &x1, &y1, &x2, &y2, sep, &len) > 4 ||

                           sscanf(buf, ""\\move(%d,%d,%d,%d,%d,%d)%1[\\}]%n"", &x1, &y1, &x2, &y2, &t1, &t2, sep, &len) > 6) {

                    if (callbacks->move)

                        callbacks->move(priv, x1, y1, x2, y2, t1, t2);

                } else if (sscanf(buf, ""\\pos(%d,%d)%1[\\}]%n"", &x1, &y1, sep, &len) > 2) {

                    if (callbacks->move)

                        callbacks->move(priv, x1, y1, x1, y1, -1, -1);

                } else if (sscanf(buf, ""\\org(%d,%d)%1[\\}]%n"", &x1, &y1, sep, &len) > 2) {

                    if (callbacks->origin)

                        callbacks->origin(priv, x1, y1);

                } else {

                    len = strcspn(buf+1, ""\\}"") + 2;  /* skip unknown code */

                }

                buf += len - 1;

            }

            if (*buf++ != '}')

                return AVERROR_INVALIDDATA;

        } else {

            if (!text) {

                text = buf;

                text_len = 1;

            } else

                text_len++;

            buf++;

        }

    }

    if (text && callbacks->text)

        callbacks->text(priv, text, text_len);

    if (callbacks->end)

        callbacks->end(priv);

    return 0;

}
",1088,,LABEL_1,LABEL_0,,-4,"callbacks,priv,buf,text,new_line,text_len,style,c,sep,c_num,tmp,len,x1,y1,x2,y2",,,,0,,0,Greedy,1,0.0010337114334106445,,
357,"int net_init_tap(const Netdev *netdev, const char *name,

                 NetClientState *peer, Error **errp)

{

    const NetdevTapOptions *tap;

    int fd, vnet_hdr = 0, i = 0, queues;

    /* for the no-fd, no-helper case */

    const char *script = NULL; /* suppress wrong ""uninit'd use"" gcc warning */

    const char *downscript = NULL;

    Error *err = NULL;

    const char *vhostfdname;

    char ifname[128];



    assert(netdev->type == NET_CLIENT_DRIVER_TAP);

    tap = &netdev->u.tap;

    queues = tap->has_queues ? tap->queues : 1;

    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;



    /* QEMU vlans does not support multiqueue tap, in this case peer is set.

     * For -netdev, peer is always NULL. */

    if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) {

        error_setg(errp, ""Multiqueue tap cannot be used with QEMU vlans"");

        return -1;

    }



    if (tap->has_fd) {

        if (tap->has_ifname || tap->has_script || tap->has_downscript ||

            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||

            tap->has_fds || tap->has_vhostfds) {

            error_setg(errp, ""ifname=, script=, downscript=, vnet_hdr=, ""

                       ""helper=, queues=, fds=, and vhostfds= ""

                       ""are invalid with fd="");

            return -1;

        }



        fd = monitor_fd_param(cur_mon, tap->fd, &err);

        if (fd == -1) {

            error_propagate(errp, err);

            return -1;

        }



        fcntl(fd, F_SETFL, O_NONBLOCK);



        vnet_hdr = tap_probe_vnet_hdr(fd);



        net_init_tap_one(tap, peer, ""tap"", name, NULL,

                         script, downscript,

                         vhostfdname, vnet_hdr, fd, &err);

        if (err) {

            error_propagate(errp, err);

            return -1;

        }

    } else if (tap->has_fds) {

        char **fds = g_new0(char *, MAX_TAP_QUEUES);

        char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES);

        int nfds, nvhosts;



        if (tap->has_ifname || tap->has_script || tap->has_downscript ||

            tap->has_vnet_hdr || tap->has_helper || tap->has_queues ||

            tap->has_vhostfd) {

            error_setg(errp, ""ifname=, script=, downscript=, vnet_hdr=, ""

                       ""helper=, queues=, and vhostfd= ""

                       ""are invalid with fds="");

            return -1;

        }



        nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES);

        if (tap->has_vhostfds) {

            nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES);

            if (nfds != nvhosts) {

                error_setg(errp, ""The number of fds passed does not match ""

                           ""the number of vhostfds passed"");

                goto free_fail;

            }

        }



        for (i = 0; i < nfds; i++) {

            fd = monitor_fd_param(cur_mon, fds[i], &err);

            if (fd == -1) {

                error_propagate(errp, err);

                goto free_fail;

            }



            fcntl(fd, F_SETFL, O_NONBLOCK);



            if (i == 0) {

                vnet_hdr = tap_probe_vnet_hdr(fd);

            } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) {

                error_setg(errp,

                           ""vnet_hdr not consistent across given tap fds"");

                goto free_fail;

            }



            net_init_tap_one(tap, peer, ""tap"", name, ifname,

                             script, downscript,

                             tap->has_vhostfds ? vhost_fds[i] : NULL,

                             vnet_hdr, fd, &err);

            if (err) {

                error_propagate(errp, err);

                goto free_fail;

            }

        }

        g_free(fds);

        g_free(vhost_fds);

        return 0;



free_fail:

        for (i = 0; i < nfds; i++) {

            g_free(fds[i]);

            g_free(vhost_fds[i]);

        }

        g_free(fds);

        g_free(vhost_fds);

        return -1;

    } else if (tap->has_helper) {

        if (tap->has_ifname || tap->has_script || tap->has_downscript ||

            tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) {

            error_setg(errp, ""ifname=, script=, downscript=, vnet_hdr=, ""

                       ""queues=, and vhostfds= are invalid with helper="");

            return -1;

        }



        fd = net_bridge_run_helper(tap->helper,

                                   tap->has_br ?

                                   tap->br : DEFAULT_BRIDGE_INTERFACE,

                                   errp);

        if (fd == -1) {

            return -1;

        }



        fcntl(fd, F_SETFL, O_NONBLOCK);

        vnet_hdr = tap_probe_vnet_hdr(fd);



        net_init_tap_one(tap, peer, ""bridge"", name, ifname,

                         script, downscript, vhostfdname,

                         vnet_hdr, fd, &err);

        if (err) {

            error_propagate(errp, err);

            close(fd);

            return -1;

        }

    } else {

        if (tap->has_vhostfds) {

            error_setg(errp, ""vhostfds= is invalid if fds= wasn't specified"");

            return -1;

        }

        script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT;

        downscript = tap->has_downscript ? tap->downscript :

            DEFAULT_NETWORK_DOWN_SCRIPT;



        if (tap->has_ifname) {

            pstrcpy(ifname, sizeof ifname, tap->ifname);

        } else {

            ifname[0] = '\0';

        }



        for (i = 0; i < queues; i++) {

            fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? ""no"" : script,

                              ifname, sizeof ifname, queues > 1, errp);

            if (fd == -1) {

                return -1;

            }



            if (queues > 1 && i == 0 && !tap->has_ifname) {

                if (tap_fd_get_ifname(fd, ifname)) {

                    error_setg(errp, ""Fail to get ifname"");

                    close(fd);

                    return -1;

                }

            }



            net_init_tap_one(tap, peer, ""tap"", name, ifname,

                             i >= 1 ? ""no"" : script,

                             i >= 1 ? ""no"" : downscript,

                             vhostfdname, vnet_hdr, fd, &err);

            if (err) {

                error_propagate(errp, err);

                close(fd);

                return -1;

            }

        }

    }



    return 0;

}
",1148,,LABEL_1,LABEL_0,,-4,"netdev,name,peer,errp,tap,fd,queues,script,downscript,err,vhostfdname,ifname,fds,vhost_fds,nfds,i",,,,0,,0,Greedy,1,0.0011111060778299967,,
358,"int cpu_exec(CPUState *env1)

{

#define DECLARE_HOST_REGS 1

#include ""hostregs_helper.h""

    int ret, interrupt_request;

    TranslationBlock *tb;

    uint8_t *tc_ptr;

    unsigned long next_tb;



    if (cpu_halted(env1) == EXCP_HALTED)

        return EXCP_HALTED;



    cpu_single_env = env1;



    /* first we save global registers */

#define SAVE_HOST_REGS 1

#include ""hostregs_helper.h""

    env = env1;



#if defined(TARGET_I386)

    /* put eflags in CPU temporary format */

    CC_SRC = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);

    DF = 1 - (2 * ((env->eflags >> 10) & 1));

    CC_OP = CC_OP_EFLAGS;

    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);

#elif defined(TARGET_SPARC)

#elif defined(TARGET_M68K)

    env->cc_op = CC_OP_FLAGS;

    env->cc_dest = env->sr & 0xf;

    env->cc_x = (env->sr >> 4) & 1;

#elif defined(TARGET_ALPHA)

#elif defined(TARGET_ARM)

#elif defined(TARGET_PPC)

#elif defined(TARGET_MICROBLAZE)

#elif defined(TARGET_MIPS)

#elif defined(TARGET_SH4)

#elif defined(TARGET_CRIS)

#elif defined(TARGET_S390X)

    /* XXXXX */

#else

#error unsupported target CPU

#endif

    env->exception_index = -1;



    /* prepare setjmp context for exception handling */

    for(;;) {

        if (setjmp(env->jmp_env) == 0) {

#if defined(__sparc__) && !defined(CONFIG_SOLARIS)

#undef env

                    env = cpu_single_env;

#define env cpu_single_env

#endif

            /* if an exception is pending, we execute it here */

            if (env->exception_index >= 0) {

                if (env->exception_index >= EXCP_INTERRUPT) {

                    /* exit request from the cpu execution loop */

                    ret = env->exception_index;

                    if (ret == EXCP_DEBUG)

                        cpu_handle_debug_exception(env);

                    break;

                } else {

#if defined(CONFIG_USER_ONLY)

                    /* if user mode only, we simulate a fake exception

                       which will be handled outside the cpu execution

                       loop */

#if defined(TARGET_I386)

                    do_interrupt_user(env->exception_index,

                                      env->exception_is_int,

                                      env->error_code,

                                      env->exception_next_eip);

                    /* successfully delivered */

                    env->old_exception = -1;

#endif

                    ret = env->exception_index;

                    break;

#else

#if defined(TARGET_I386)

                    /* simulate a real cpu exception. On i386, it can

                       trigger new exceptions, but we do not handle

                       double or triple faults yet. */

                    do_interrupt(env->exception_index,

                                 env->exception_is_int,

                                 env->error_code,

                                 env->exception_next_eip, 0);

                    /* successfully delivered */

                    env->old_exception = -1;

#elif defined(TARGET_PPC)

                    do_interrupt(env);

#elif defined(TARGET_MICROBLAZE)

                    do_interrupt(env);

#elif defined(TARGET_MIPS)

                    do_interrupt(env);

#elif defined(TARGET_SPARC)

                    do_interrupt(env);

#elif defined(TARGET_ARM)

                    do_interrupt(env);

#elif defined(TARGET_SH4)

		    do_interrupt(env);

#elif defined(TARGET_ALPHA)

                    do_interrupt(env);

#elif defined(TARGET_CRIS)

                    do_interrupt(env);

#elif defined(TARGET_M68K)

                    do_interrupt(0);

#endif

                    env->exception_index = -1;

#endif

                }

            }



            if (kvm_enabled()) {

                kvm_cpu_exec(env);

                longjmp(env->jmp_env, 1);

            }



            next_tb = 0; /* force lookup of first TB */

            for(;;) {

                interrupt_request = env->interrupt_request;

                if (unlikely(interrupt_request)) {

                    if (unlikely(env->singlestep_enabled & SSTEP_NOIRQ)) {

                        /* Mask out external interrupts for this step. */

                        interrupt_request &= ~(CPU_INTERRUPT_HARD |

                                               CPU_INTERRUPT_FIQ |

                                               CPU_INTERRUPT_SMI |

                                               CPU_INTERRUPT_NMI);

                    }

                    if (interrupt_request & CPU_INTERRUPT_DEBUG) {

                        env->interrupt_request &= ~CPU_INTERRUPT_DEBUG;

                        env->exception_index = EXCP_DEBUG;

                        cpu_loop_exit();

                    }

#if defined(TARGET_ARM) || defined(TARGET_SPARC) || defined(TARGET_MIPS) || \

    defined(TARGET_PPC) || defined(TARGET_ALPHA) || defined(TARGET_CRIS) || \

    defined(TARGET_MICROBLAZE)

                    if (interrupt_request & CPU_INTERRUPT_HALT) {

                        env->interrupt_request &= ~CPU_INTERRUPT_HALT;

                        env->halted = 1;

                        env->exception_index = EXCP_HLT;

                        cpu_loop_exit();

                    }

#endif

#if defined(TARGET_I386)

                    if (interrupt_request & CPU_INTERRUPT_INIT) {

                            svm_check_intercept(SVM_EXIT_INIT);

                            do_cpu_init(env);

                            env->exception_index = EXCP_HALTED;

                            cpu_loop_exit();

                    } else if (interrupt_request & CPU_INTERRUPT_SIPI) {

                            do_cpu_sipi(env);

                    } else if (env->hflags2 & HF2_GIF_MASK) {

                        if ((interrupt_request & CPU_INTERRUPT_SMI) &&

                            !(env->hflags & HF_SMM_MASK)) {

                            svm_check_intercept(SVM_EXIT_SMI);

                            env->interrupt_request &= ~CPU_INTERRUPT_SMI;

                            do_smm_enter();

                            next_tb = 0;

                        } else if ((interrupt_request & CPU_INTERRUPT_NMI) &&

                                   !(env->hflags2 & HF2_NMI_MASK)) {

                            env->interrupt_request &= ~CPU_INTERRUPT_NMI;

                            env->hflags2 |= HF2_NMI_MASK;

                            do_interrupt(EXCP02_NMI, 0, 0, 0, 1);

                            next_tb = 0;

			} else if (interrupt_request & CPU_INTERRUPT_MCE) {

                            env->interrupt_request &= ~CPU_INTERRUPT_MCE;

                            do_interrupt(EXCP12_MCHK, 0, 0, 0, 0);

                            next_tb = 0;

                        } else if ((interrupt_request & CPU_INTERRUPT_HARD) &&

                                   (((env->hflags2 & HF2_VINTR_MASK) && 

                                     (env->hflags2 & HF2_HIF_MASK)) ||

                                    (!(env->hflags2 & HF2_VINTR_MASK) && 

                                     (env->eflags & IF_MASK && 

                                      !(env->hflags & HF_INHIBIT_IRQ_MASK))))) {

                            int intno;

                            svm_check_intercept(SVM_EXIT_INTR);

                            env->interrupt_request &= ~(CPU_INTERRUPT_HARD | CPU_INTERRUPT_VIRQ);

                            intno = cpu_get_pic_interrupt(env);

                            qemu_log_mask(CPU_LOG_TB_IN_ASM, ""Servicing hardware INT=0x%02x\n"", intno);

#if defined(__sparc__) && !defined(CONFIG_SOLARIS)

#undef env

                    env = cpu_single_env;

#define env cpu_single_env

#endif

                            do_interrupt(intno, 0, 0, 0, 1);

                            /* ensure that no TB jump will be modified as

                               the program flow was changed */

                            next_tb = 0;

#if !defined(CONFIG_USER_ONLY)

                        } else if ((interrupt_request & CPU_INTERRUPT_VIRQ) &&

                                   (env->eflags & IF_MASK) && 

                                   !(env->hflags & HF_INHIBIT_IRQ_MASK)) {

                            int intno;

                            /* FIXME: this should respect TPR */

                            svm_check_intercept(SVM_EXIT_VINTR);

                            intno = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_vector));

                            qemu_log_mask(CPU_LOG_TB_IN_ASM, ""Servicing virtual hardware INT=0x%02x\n"", intno);

                            do_interrupt(intno, 0, 0, 0, 1);

                            env->interrupt_request &= ~CPU_INTERRUPT_VIRQ;

                            next_tb = 0;

#endif

                        }

                    }

#elif defined(TARGET_PPC)

#if 0

                    if ((interrupt_request & CPU_INTERRUPT_RESET)) {

                        cpu_reset(env);

                    }

#endif

                    if (interrupt_request & CPU_INTERRUPT_HARD) {

                        ppc_hw_interrupt(env);

                        if (env->pending_interrupts == 0)

                            env->interrupt_request &= ~CPU_INTERRUPT_HARD;

                        next_tb = 0;

                    }

#elif defined(TARGET_MICROBLAZE)

                    if ((interrupt_request & CPU_INTERRUPT_HARD)

                        && (env->sregs[SR_MSR] & MSR_IE)

                        && !(env->sregs[SR_MSR] & (MSR_EIP | MSR_BIP))

                        && !(env->iflags & (D_FLAG | IMM_FLAG))) {

                        env->exception_index = EXCP_IRQ;

                        do_interrupt(env);

                        next_tb = 0;

                    }

#elif defined(TARGET_MIPS)

                    if ((interrupt_request & CPU_INTERRUPT_HARD) &&

                        (env->CP0_Status & env->CP0_Cause & CP0Ca_IP_mask) &&

                        (env->CP0_Status & (1 << CP0St_IE)) &&

                        !(env->CP0_Status & (1 << CP0St_EXL)) &&

                        !(env->CP0_Status & (1 << CP0St_ERL)) &&

                        !(env->hflags & MIPS_HFLAG_DM)) {

                        /* Raise it */

                        env->exception_index = EXCP_EXT_INTERRUPT;

                        env->error_code = 0;

                        do_interrupt(env);

                        next_tb = 0;

                    }

#elif defined(TARGET_SPARC)

                    if (interrupt_request & CPU_INTERRUPT_HARD) {

                        if (cpu_interrupts_enabled(env) &&

                            env->interrupt_index > 0) {

                            int pil = env->interrupt_index & 0xf;

                            int type = env->interrupt_index & 0xf0;



                            if (((type == TT_EXTINT) &&

                                  cpu_pil_allowed(env, pil)) ||

                                  type != TT_EXTINT) {

                                env->exception_index = env->interrupt_index;

                                do_interrupt(env);

                                next_tb = 0;

                            }

                        }

		    } else if (interrupt_request & CPU_INTERRUPT_TIMER) {

			//do_interrupt(0, 0, 0, 0, 0);

			env->interrupt_request &= ~CPU_INTERRUPT_TIMER;

		    }

#elif defined(TARGET_ARM)

                    if (interrupt_request & CPU_INTERRUPT_FIQ

                        && !(env->uncached_cpsr & CPSR_F)) {

                        env->exception_index = EXCP_FIQ;

                        do_interrupt(env);

                        next_tb = 0;

                    }

                    /* ARMv7-M interrupt return works by loading a magic value

                       into the PC.  On real hardware the load causes the

                       return to occur.  The qemu implementation performs the

                       jump normally, then does the exception return when the

                       CPU tries to execute code at the magic address.

                       This will cause the magic PC value to be pushed to

                       the stack if an interrupt occured at the wrong time.

                       We avoid this by disabling interrupts when

                       pc contains a magic address.  */

                    if (interrupt_request & CPU_INTERRUPT_HARD

                        && ((IS_M(env) && env->regs[15] < 0xfffffff0)

                            || !(env->uncached_cpsr & CPSR_I))) {

                        env->exception_index = EXCP_IRQ;

                        do_interrupt(env);

                        next_tb = 0;

                    }

#elif defined(TARGET_SH4)

                    if (interrupt_request & CPU_INTERRUPT_HARD) {

                        do_interrupt(env);

                        next_tb = 0;

                    }

#elif defined(TARGET_ALPHA)

                    if (interrupt_request & CPU_INTERRUPT_HARD) {

                        do_interrupt(env);

                        next_tb = 0;

                    }

#elif defined(TARGET_CRIS)

                    if (interrupt_request & CPU_INTERRUPT_HARD

                        && (env->pregs[PR_CCS] & I_FLAG)) {

                        env->exception_index = EXCP_IRQ;

                        do_interrupt(env);

                        next_tb = 0;

                    }

                    if (interrupt_request & CPU_INTERRUPT_NMI

                        && (env->pregs[PR_CCS] & M_FLAG)) {

                        env->exception_index = EXCP_NMI;

                        do_interrupt(env);

                        next_tb = 0;

                    }

#elif defined(TARGET_M68K)

                    if (interrupt_request & CPU_INTERRUPT_HARD

                        && ((env->sr & SR_I) >> SR_I_SHIFT)

                            < env->pending_level) {

                        /* Real hardware gets the interrupt vector via an

                           IACK cycle at this point.  Current emulated

                           hardware doesn't rely on this, so we

                           provide/save the vector when the interrupt is

                           first signalled.  */

                        env->exception_index = env->pending_vector;

                        do_interrupt(1);

                        next_tb = 0;

                    }

#endif

                   /* Don't use the cached interupt_request value,

                      do_interrupt may have updated the EXITTB flag. */

                    if (env->interrupt_request & CPU_INTERRUPT_EXITTB) {

                        env->interrupt_request &= ~CPU_INTERRUPT_EXITTB;

                        /* ensure that no TB jump will be modified as

                           the program flow was changed */

                        next_tb = 0;

                    }

                }

                if (unlikely(env->exit_request)) {

                    env->exit_request = 0;

                    env->exception_index = EXCP_INTERRUPT;

                    cpu_loop_exit();

                }

#ifdef CONFIG_DEBUG_EXEC

                if (qemu_loglevel_mask(CPU_LOG_TB_CPU)) {

                    /* restore flags in standard format */

#if defined(TARGET_I386)

                    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);

                    log_cpu_state(env, X86_DUMP_CCOP);

                    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);

#elif defined(TARGET_ARM)

                    log_cpu_state(env, 0);

#elif defined(TARGET_SPARC)

                    log_cpu_state(env, 0);

#elif defined(TARGET_PPC)

                    log_cpu_state(env, 0);

#elif defined(TARGET_M68K)

                    cpu_m68k_flush_flags(env, env->cc_op);

                    env->cc_op = CC_OP_FLAGS;

                    env->sr = (env->sr & 0xffe0)

                              | env->cc_dest | (env->cc_x << 4);

                    log_cpu_state(env, 0);

#elif defined(TARGET_MICROBLAZE)

                    log_cpu_state(env, 0);

#elif defined(TARGET_MIPS)

                    log_cpu_state(env, 0);

#elif defined(TARGET_SH4)

		    log_cpu_state(env, 0);

#elif defined(TARGET_ALPHA)

                    log_cpu_state(env, 0);

#elif defined(TARGET_CRIS)

                    log_cpu_state(env, 0);

#else

#error unsupported target CPU

#endif

                }

#endif

                spin_lock(&tb_lock);

                tb = tb_find_fast();

                /* Note: we do it here to avoid a gcc bug on Mac OS X when

                   doing it in tb_find_slow */

                if (tb_invalidated_flag) {

                    /* as some TB could have been invalidated because

                       of memory exceptions while generating the code, we

                       must recompute the hash index here */

                    next_tb = 0;

                    tb_invalidated_flag = 0;

                }

#ifdef CONFIG_DEBUG_EXEC

                qemu_log_mask(CPU_LOG_EXEC, ""Trace 0x%08lx ["" TARGET_FMT_lx ""] %s\n"",

                             (long)tb->tc_ptr, tb->pc,

                             lookup_symbol(tb->pc));

#endif

                /* see if we can patch the calling TB. When the TB

                   spans two pages, we cannot safely do a direct

                   jump. */

                if (next_tb != 0 && tb->page_addr[1] == -1) {

                    tb_add_jump((TranslationBlock *)(next_tb & ~3), next_tb & 3, tb);

                }

                spin_unlock(&tb_lock);



                /* cpu_interrupt might be called while translating the

                   TB, but before it is linked into a potentially

                   infinite loop and becomes env->current_tb. Avoid

                   starting execution if there is a pending interrupt. */

                if (!unlikely (env->exit_request)) {

                    env->current_tb = tb;

                    tc_ptr = tb->tc_ptr;

                /* execute the generated code */

#if defined(__sparc__) && !defined(CONFIG_SOLARIS)

#undef env

                    env = cpu_single_env;

#define env cpu_single_env

#endif

                    next_tb = tcg_qemu_tb_exec(tc_ptr);

                    env->current_tb = NULL;

                    if ((next_tb & 3) == 2) {

                        /* Instruction counter expired.  */

                        int insns_left;

                        tb = (TranslationBlock *)(long)(next_tb & ~3);

                        /* Restore PC.  */

                        cpu_pc_from_tb(env, tb);

                        insns_left = env->icount_decr.u32;

                        if (env->icount_extra && insns_left >= 0) {

                            /* Refill decrementer and continue execution.  */

                            env->icount_extra += insns_left;

                            if (env->icount_extra > 0xffff) {

                                insns_left = 0xffff;

                            } else {

                                insns_left = env->icount_extra;

                            }

                            env->icount_extra -= insns_left;

                            env->icount_decr.u16.low = insns_left;

                        } else {

                            if (insns_left > 0) {

                                /* Execute remaining instructions.  */

                                cpu_exec_nocache(insns_left, tb);

                            }

                            env->exception_index = EXCP_INTERRUPT;

                            next_tb = 0;

                            cpu_loop_exit();

                        }

                    }

                }

                /* reset soft MMU for next block (it can currently

                   only be set by a memory fault) */

            } /* for(;;) */

        }

    } /* for(;;) */





#if defined(TARGET_I386)

    /* restore flags in standard format */

    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);

#elif defined(TARGET_ARM)

    /* XXX: Save/restore host fpu exception state?.  */

#elif defined(TARGET_SPARC)

#elif defined(TARGET_PPC)

#elif defined(TARGET_M68K)

    cpu_m68k_flush_flags(env, env->cc_op);

    env->cc_op = CC_OP_FLAGS;

    env->sr = (env->sr & 0xffe0)

              | env->cc_dest | (env->cc_x << 4);

#elif defined(TARGET_MICROBLAZE)

#elif defined(TARGET_MIPS)

#elif defined(TARGET_SH4)

#elif defined(TARGET_ALPHA)

#elif defined(TARGET_CRIS)

#elif defined(TARGET_S390X)

    /* XXXXX */

#else

#error unsupported target CPU

#endif



    /* restore global registers */

#include ""hostregs_helper.h""



    /* fail safe : never use cpu_single_env outside cpu_exec() */

    cpu_single_env = NULL;

    return ret;

}
",2705,,LABEL_0,LABEL_1,,-4,"env1,ret,interrupt_request,tb,tc_ptr,next_tb",,,,0,,0,Greedy,1,0.0021766543388366697,,
359,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)

{

    if (memory_region_is_ram(mr)) {

        return !(is_write && mr->readonly);

    }

    if (memory_region_is_romd(mr)) {

        return !is_write;

    }



    return false;

}
",51,"static inline bool memory_access_is_direct(MemoryRegion *er, bool is_left)

{

    if (memory_region_is_ram(er)) {

        return !(is_left && er->readonly);

    }

    if (memory_region_is_romd(er)) {

        return !is_write;

    }



    return false;

}
",LABEL_0,LABEL_0,LABEL_1,1,"mr,is_write",,,,0,"mr:er,is_write:is_left,",0,GA,119,0.04220154285430908,GA,
360,"static void fill_coding_method_array (sb_int8_array tone_level_idx, sb_int8_array tone_level_idx_temp,

                sb_int8_array coding_method, int nb_channels,

                int c, int superblocktype_2_3, int cm_table_select)

{

    int ch, sb, j;

    int tmp, acc, esp_40, comp;

    int add1, add2, add3, add4;

    int64_t multres;



    // This should never happen

    if (nb_channels <= 0)

        return;



    if (!superblocktype_2_3) {

        /* This case is untested, no samples available */

        SAMPLES_NEEDED

        for (ch = 0; ch < nb_channels; ch++)

            for (sb = 0; sb < 30; sb++) {

                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer

                    add1 = tone_level_idx[ch][sb][j] - 10;

                    if (add1 < 0)

                        add1 = 0;

                    add2 = add3 = add4 = 0;

                    if (sb > 1) {

                        add2 = tone_level_idx[ch][sb - 2][j] + tone_level_idx_offset_table[sb][0] - 6;

                        if (add2 < 0)

                            add2 = 0;

                    }

                    if (sb > 0) {

                        add3 = tone_level_idx[ch][sb - 1][j] + tone_level_idx_offset_table[sb][1] - 6;

                        if (add3 < 0)

                            add3 = 0;

                    }

                    if (sb < 29) {

                        add4 = tone_level_idx[ch][sb + 1][j] + tone_level_idx_offset_table[sb][3] - 6;

                        if (add4 < 0)

                            add4 = 0;

                    }

                    tmp = tone_level_idx[ch][sb][j + 1] * 2 - add4 - add3 - add2 - add1;

                    if (tmp < 0)

                        tmp = 0;

                    tone_level_idx_temp[ch][sb][j + 1] = tmp & 0xff;

                }

                tone_level_idx_temp[ch][sb][0] = tone_level_idx_temp[ch][sb][1];

            }

            acc = 0;

            for (ch = 0; ch < nb_channels; ch++)

                for (sb = 0; sb < 30; sb++)

                    for (j = 0; j < 64; j++)

                        acc += tone_level_idx_temp[ch][sb][j];



            multres = 0x66666667 * (acc * 10);

            esp_40 = (multres >> 32) / 8 + ((multres & 0xffffffff) >> 31);

            for (ch = 0;  ch < nb_channels; ch++)

                for (sb = 0; sb < 30; sb++)

                    for (j = 0; j < 64; j++) {

                        comp = tone_level_idx_temp[ch][sb][j]* esp_40 * 10;

                        if (comp < 0)

                            comp += 0xff;

                        comp /= 256; // signed shift

                        switch(sb) {

                            case 0:

                                if (comp < 30)

                                    comp = 30;

                                comp += 15;

                                break;

                            case 1:

                                if (comp < 24)

                                    comp = 24;

                                comp += 10;

                                break;

                            case 2:

                            case 3:

                            case 4:

                                if (comp < 16)

                                    comp = 16;

                        }

                        if (comp <= 5)

                            tmp = 0;

                        else if (comp <= 10)

                            tmp = 10;

                        else if (comp <= 16)

                            tmp = 16;

                        else if (comp <= 24)

                            tmp = -1;

                        else

                            tmp = 0;

                        coding_method[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff;

                    }

            for (sb = 0; sb < 30; sb++)

                fix_coding_method_array(sb, nb_channels, coding_method);

            for (ch = 0; ch < nb_channels; ch++)

                for (sb = 0; sb < 30; sb++)

                    for (j = 0; j < 64; j++)

                        if (sb >= 10) {

                            if (coding_method[ch][sb][j] < 10)

                                coding_method[ch][sb][j] = 10;

                        } else {

                            if (sb >= 2) {

                                if (coding_method[ch][sb][j] < 16)

                                    coding_method[ch][sb][j] = 16;

                            } else {

                                if (coding_method[ch][sb][j] < 30)

                                    coding_method[ch][sb][j] = 30;

                            }

                        }

    } else { // superblocktype_2_3 != 0

        for (ch = 0; ch < nb_channels; ch++)

            for (sb = 0; sb < 30; sb++)

                for (j = 0; j < 64; j++)

                    coding_method[ch][sb][j] = coding_method_table[cm_table_select][sb];

    }



    return;

}
",930,,LABEL_0,LABEL_1,,-4,"tone_level_idx,tone_level_idx_temp,coding_method,nb_channels,c,superblocktype_2_3,cm_table_select,ch,sb,j,tmp,acc,esp_40,comp,add1,add2,add3,add4,multres",,,,0,,0,Greedy,1,0.0009740153948465983,,
361,"void qemu_savevm_state_complete(QEMUFile *f)

{

    QJSON *vmdesc;

    int vmdesc_len;

    SaveStateEntry *se;

    int ret;



    trace_savevm_state_complete();



    cpu_synchronize_all_states();



    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {

        if (!se->ops || !se->ops->save_live_complete) {

            continue;

        }

        if (se->ops && se->ops->is_active) {

            if (!se->ops->is_active(se->opaque)) {

                continue;

            }

        }

        trace_savevm_section_start(se->idstr, se->section_id);



        save_section_header(f, se, QEMU_VM_SECTION_END);



        ret = se->ops->save_live_complete(f, se->opaque);

        trace_savevm_section_end(se->idstr, se->section_id, ret);


        if (ret < 0) {

            qemu_file_set_error(f, ret);

            return;

        }

    }



    vmdesc = qjson_new();

    json_prop_int(vmdesc, ""page_size"", TARGET_PAGE_SIZE);

    json_start_array(vmdesc, ""devices"");

    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {



        if ((!se->ops || !se->ops->save_state) && !se->vmsd) {

            continue;

        }

        trace_savevm_section_start(se->idstr, se->section_id);



        json_start_object(vmdesc, NULL);

        json_prop_str(vmdesc, ""name"", se->idstr);

        json_prop_int(vmdesc, ""instance_id"", se->instance_id);



        save_section_header(f, se, QEMU_VM_SECTION_FULL);



        vmstate_save(f, se, vmdesc);



        json_end_object(vmdesc);

        trace_savevm_section_end(se->idstr, se->section_id, 0);


    }



    qemu_put_byte(f, QEMU_VM_EOF);



    json_end_array(vmdesc);

    qjson_finish(vmdesc);

    vmdesc_len = strlen(qjson_get_str(vmdesc));



    if (should_send_vmdesc()) {

        qemu_put_byte(f, QEMU_VM_VMDESCRIPTION);

        qemu_put_be32(f, vmdesc_len);

        qemu_put_buffer(f, (uint8_t *)qjson_get_str(vmdesc), vmdesc_len);

    }

    object_unref(OBJECT(vmdesc));



    qemu_fflush(f);

}",404,"void qemu_savevm_state_complete(QEMUFile *feed)

{

    QJSON *vmnesc;

    int vmdesc_len;

    SaveStateEntry *sche;

    int status;



    trace_savevm_state_complete();



    cpu_synchronize_all_states();



    QTAILQ_FOREACH(sche, &savevm_state.handlers, entry) {

        if (!se->ops || !se->ops->save_live_complete) {

            continue;

        }

        if (sche->ops && sche->ops->is_active) {

            if (!se->ops->is_active(sche->opaque)) {

                continue;

            }

        }

        trace_savevm_section_start(sche->idstr, sche->section_id);



        save_section_header(feed, sche, QEMU_VM_SECTION_END);



        ret = sstatuscheps->save_live_complete(feed, sche->opaque);

        trace_savevm_section_end(sche->idstr, sche->section_id, status);


        if (status < 0) {

            qemu_file_set_error(feed, status);

            return;

        }

    }



    vmnesc = qjson_new();

    json_prop_int(vmnesc, ""page_size"", TARGET_PAGE_SIZE);

    json_start_array(vmnesc, ""devices"");

    QTAILQ_FOREACH(sche, &savevm_state.handlers, entry) {



        if ((!se->ops || !se->ops->save_state) && !se->vmsd) {

            continue;

        }

        trace_savevm_section_start(sche->idstr, sche->section_id);



        json_start_object(vmnesc, NULL);

        json_prop_str(vmnesc, ""name"", sche->idstr);

        json_prop_int(vmnesc, ""instance_id"", sche->instance_id);



        save_section_header(feed, sche, QEMU_VM_SECTION_FULL);



        vmstate_save(feed, sche, vmnesc);



        json_end_object(vmnesc);

        trace_savevm_section_end(sche->idstr, sche->section_id, 0);


    }



    qemu_put_byte(feed, QEMU_VM_EOF);



    json_end_array(vmnesc);

    qjson_finish(vmnesc);

    vmdesc_len = strlen(qjson_get_str(vmnesc));



    if (should_send_vmdesc()) {

        qemu_put_byte(feed, QEMU_VM_VMDESCRIPTION);

        qemu_put_be32(feed, vmdesc_len);

        qemu_put_buffer(feed, (uint8_t *)qjson_get_str(vmnesc), vmdesc_len);

    }

    object_unref(OBJECT(vmnesc));



    qemu_fflush(feed);

}",LABEL_1,LABEL_1,LABEL_0,1,"f,vmdesc,vmdesc_len,se,ret",,,,4,"f:feed,vmdesc:vmnesc,vmdesc_len:vmdesc_len,se:sche,ret:status,",1,GA,374,0.14940532843271892,GA,
362,"int avfilter_register(AVFilter *filter)

{

    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)

        return -1;



    registered_avfilters[next_registered_avfilter_idx++] = filter;

    return 0;

}
",33,,LABEL_0,LABEL_0,LABEL_0,-1,filter,,,,0,,0,GA,237,0.08339097499847412,failed,
363,"static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out)

{

    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);

    void *dst;

    if (o_out)

        *o_out= o;

    if (!o || o->offset<=0)

        return AVERROR_OPTION_NOT_FOUND;



    if (o->max*den < num*intnum || o->min*den > num*intnum) {

        av_log(obj, AV_LOG_ERROR, ""Value %lf for parameter '%s' out of range\n"", num, name);

        return AVERROR(ERANGE);

    }



    dst= ((uint8_t*)obj) + o->offset;



    switch (o->type) {

    case FF_OPT_TYPE_FLAGS:

    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;

    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;

    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;

    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;

    case FF_OPT_TYPE_RATIONAL:

        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};

        else                 *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);

        break;

    default:

        return AVERROR(EINVAL);

    }

    return 0;

}
",301,,LABEL_0,LABEL_0,LABEL_0,-1,"obj,name,num,den,intnum,o_out,o,dst",,,,0,,0,GA,1688,0.6644686897595723,failed,
364,"static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *c = avctx->priv_data;



    if(avctx->channels > 2U){

        return -1;

    }



    c->channel = 0;

    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;



    switch(avctx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            c->status[0].predictor = AV_RL32(avctx->extradata);

            c->status[1].predictor = AV_RL32(avctx->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}
",219,"static int adpcm_decode_init(AVCodecContext * broadcontext)

{

    ADPCMContext *c = browdcontext->priv_data;



    if(broadcontext->channels > 2U){

        return -1;

    }



    w->channel = 0;

    w->status[0].predictor = w->status[1].predictor = 0;

    w->status[0].step_index = w->status[1].step_index = 0;

    w->status[0].step = w->status[1].step = 0;



    switch(broadcontext->codec->id) {

    case CODEC_ID_ADPCM_CT:

        w->status[0].step = w->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (broadcontext->extradata && broadcontext->extradata_size == 2 * 4) {

            c->statws[0].predictor = AV_RL32(broadcontext->extradata);

            c->statws[1].predictor = AV_RL32(broadcontext->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,c",,,,0,"avctx:broadcontext,c:w,",0,GA,349,0.1296127398808797,GA,
365,"static void *do_data_decompress(void *opaque)

{

    DecompressParam *param = opaque;

    unsigned long pagesize;



    while (!quit_decomp_thread) {

        qemu_mutex_lock(&param->mutex);

        while (!param->start && !quit_decomp_thread) {

            qemu_cond_wait(&param->cond, &param->mutex);

        }

        if (!quit_decomp_thread) {

            pagesize = TARGET_PAGE_SIZE;

            /* uncompress() will return failed in some case, especially

             * when the page is dirted when doing the compression, it's

             * not a problem because the dirty page will be retransferred

             * and uncompress() won't break the data in other pages.

             */

            uncompress((Bytef *)param->des, &pagesize,

                       (const Bytef *)param->compbuf, param->len);

        }

        param->start = false;

        qemu_mutex_unlock(&param->mutex);



        qemu_mutex_lock(&decomp_done_lock);

        param->done = true;

        qemu_cond_signal(&decomp_done_cond);

        qemu_mutex_unlock(&decomp_done_lock);

    }



    return NULL;

}
",206,"static void *do_data_decompress(void * opca)

{

    DecompressParam adrm =  opca;

    unsigned long pagesiz;



    while (!quit_decomp_thread) {

        qemu_mutex_lock(&adr->mutex);

        while (!param->start && !quit_decomp_thread) {

            qemu_cond_wait(&adr->cond, &adr->mutex);

        }

        if (!quit_decomp_thread) {

            pagesiz = TARGET_PAGE_SIZE;

            /* uncompress() will return failed in some case, especially

             * when the page is dirted when doing the compression, it's

             * not a problem because the dirty page will be retransferred

             * and uncompress() won't break the data in other pages.

             */

            uncompress((Bytef *)adr->des, &pagesiz,

                       (const Bytef *)adr->compbuf, adr->len);

        }

        adr->start = false;

        qemu_mutex_unlock(&adr->mutex);



        qemu_mutex_lock(&decomp_done_lock);

        adr->done = true;

        qemu_cond_signal(&decomp_done_cond);

        qemu_mutex_unlock(&decomp_done_lock);

    }



    return NULL;

}
",LABEL_0,LABEL_0,LABEL_1,1,"opaque,param,pagesize",,,,0,"opaque: opca,param:adr,pagesize:pagesiz,",0,GA,183,0.07073835134506226,GA,
366,"void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)

{

#if defined(TARGET_HAS_ICE)

    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);



    breakpoint_invalidate(cpu, breakpoint->pc);



    g_free(breakpoint);

#endif

}
",41,"void cpu_breakpoint_remove_by_ref(CPUState *CU, CPUBreakpoint *breakerframe)

{

#if defined(TARGET_HAS_ICE)

    QTAILQ_REMOVE(&CU->breakpoints, breakerframe, entry);



    breakpoint_invalidate(CU, breakerframe->pc);



    g_free(breakerframe);

#endif

}
",LABEL_0,LABEL_0,LABEL_1,1,"cpu,breakpoint",,,,0,"cpu:CU,breakpoint:breakerframe,",0,GA,239,0.08404785394668579,GA,
367,"static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,

                                       PutBitContext *pb, const float *in,

                                       const float *scaled, int size, int scale_idx,

                                       int cb, const float lambda, const float uplim,

                                       int *bits)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    int i;

    float cost = 0;

    int qc1, qc2, qc3, qc4;

    int curbits = 0;



    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];

    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];



    for (i = 0; i < size; i += 4) {

        const float *vec, *vec2;

        int curidx, curidx2, sign1, count1, sign2, count2;

        int   *in_int = (int   *)&in[i];

        float *in_pos = (float *)&in[i];

        float di0, di1, di2, di3;

        int t0, t1, t2, t3, t4;



        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;

        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;

        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;

        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;



        __asm__ volatile (

            "".set push                                          \n\t""

            "".set noreorder                                     \n\t""



            ""ori        %[t4],      $zero,      7               \n\t""

            ""ori        %[sign1],   $zero,      0               \n\t""

            ""ori        %[sign2],   $zero,      0               \n\t""

            ""slt        %[t0],      %[t4],      %[qc1]          \n\t""

            ""slt        %[t1],      %[t4],      %[qc2]          \n\t""

            ""slt        %[t2],      %[t4],      %[qc3]          \n\t""

            ""slt        %[t3],      %[t4],      %[qc4]          \n\t""

            ""movn       %[qc1],     %[t4],      %[t0]           \n\t""

            ""movn       %[qc2],     %[t4],      %[t1]           \n\t""

            ""movn       %[qc3],     %[t4],      %[t2]           \n\t""

            ""movn       %[qc4],     %[t4],      %[t3]           \n\t""

            ""lw         %[t0],      0(%[in_int])                \n\t""

            ""lw         %[t1],      4(%[in_int])                \n\t""

            ""lw         %[t2],      8(%[in_int])                \n\t""

            ""lw         %[t3],      12(%[in_int])               \n\t""

            ""slt        %[t0],      %[t0],      $zero           \n\t""

            ""movn       %[sign1],   %[t0],      %[qc1]          \n\t""

            ""slt        %[t2],      %[t2],      $zero           \n\t""

            ""movn       %[sign2],   %[t2],      %[qc3]          \n\t""

            ""slt        %[t1],      %[t1],      $zero           \n\t""

            ""sll        %[t0],      %[sign1],   1               \n\t""

            ""or         %[t0],      %[t0],      %[t1]           \n\t""

            ""movn       %[sign1],   %[t0],      %[qc2]          \n\t""

            ""slt        %[t3],      %[t3],      $zero           \n\t""

            ""sll        %[t0],      %[sign2],   1               \n\t""

            ""or         %[t0],      %[t0],      %[t3]           \n\t""

            ""movn       %[sign2],   %[t0],      %[qc4]          \n\t""

            ""slt        %[count1],  $zero,      %[qc1]          \n\t""

            ""slt        %[t1],      $zero,      %[qc2]          \n\t""

            ""slt        %[count2],  $zero,      %[qc3]          \n\t""

            ""slt        %[t2],      $zero,      %[qc4]          \n\t""

            ""addu       %[count1],  %[count1],  %[t1]           \n\t""

            ""addu       %[count2],  %[count2],  %[t2]           \n\t""



            "".set pop                                           \n\t""



            : [qc1]""+r""(qc1), [qc2]""+r""(qc2),

              [qc3]""+r""(qc3), [qc4]""+r""(qc4),

              [sign1]""=&r""(sign1), [count1]""=&r""(count1),

              [sign2]""=&r""(sign2), [count2]""=&r""(count2),

              [t0]""=&r""(t0), [t1]""=&r""(t1), [t2]""=&r""(t2), [t3]""=&r""(t3),

              [t4]""=&r""(t4)

            : [in_int]""r""(in_int)

            : ""memory""

        );



        curidx = 8 * qc1;

        curidx += qc2;



        curidx2 = 8 * qc3;

        curidx2 += qc4;



        curbits += p_bits[curidx];

        curbits += upair7_sign_bits[curidx];

        vec     = &p_codes[curidx*2];



        curbits += p_bits[curidx2];

        curbits += upair7_sign_bits[curidx2];

        vec2    = &p_codes[curidx2*2];



        __asm__ volatile (

            "".set push                                          \n\t""

            "".set noreorder                                     \n\t""



            ""lwc1       %[di0],     0(%[in_pos])                \n\t""

            ""lwc1       %[di1],     4(%[in_pos])                \n\t""

            ""lwc1       %[di2],     8(%[in_pos])                \n\t""

            ""lwc1       %[di3],     12(%[in_pos])               \n\t""

            ""abs.s      %[di0],     %[di0]                      \n\t""

            ""abs.s      %[di1],     %[di1]                      \n\t""

            ""abs.s      %[di2],     %[di2]                      \n\t""

            ""abs.s      %[di3],     %[di3]                      \n\t""

            ""lwc1       $f0,        0(%[vec])                   \n\t""

            ""lwc1       $f1,        4(%[vec])                   \n\t""

            ""lwc1       $f2,        0(%[vec2])                  \n\t""

            ""lwc1       $f3,        4(%[vec2])                  \n\t""

            ""nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \n\t""

            ""nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \n\t""

            ""nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \n\t""

            ""nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \n\t""



            "".set pop                                           \n\t""



            : [di0]""=&f""(di0), [di1]""=&f""(di1),

              [di2]""=&f""(di2), [di3]""=&f""(di3)

            : [in_pos]""r""(in_pos), [vec]""r""(vec),

              [vec2]""r""(vec2), [IQ]""f""(IQ)

            : ""$f0"", ""$f1"", ""$f2"", ""$f3"",

              ""memory""

        );



        cost += di0 * di0 + di1 * di1

                + di2 * di2 + di3 * di3;

    }



    if (bits)

        *bits = curbits;

    return cost * lambda + curbits;

}
",1353,"static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,

                                       PutBitContext *pb, const float *complex,

                                       const float *scaled, int size, int scale_idx,

                                       int cb, const float lambda, const float uplim,

                                       int *bits)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    int i;

    float cost = 0;

    int qc1, qc2, qc3, qc4;

    int curbits = 0;



    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];

    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];



    for (i = 0; i < size; i += 4) {

        const float *nec, *vec2;

        int curidx, curidx2, sign1, count1, sign2, sign8;

        int   *in_inin_intnt   *)&complex[i];

        float *in_poin_posloat *)&complex[i];

        float di0, di1, mi0, di3;

        int t0, t1, t2, t3, t4;



        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;

        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;

        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;

        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;



        __asm__ volatile (

            "".set push                                          
\t""

            "".set noreorder                                     
\t""



            ""ori        %[t4],      $zero,      7               
\t""

            ""ori        %[sign1],   $zero,      0               
\t""

            ""ori        %[sign2],   $zero,      0               
\t""

            ""slt        %[t0],      %[t4],      %[qc1]          
\t""

            ""slt        %[t1],      %[t4],      %[qc2]          
\t""

            ""slt        %[t2],      %[t4],      %[qc3]          
\t""

            ""slt        %[t3],      %[t4],      %[qc4]          
\t""

            ""movn       %[qc1],     %[t4],      %[t0]           
\t""

            ""movn       %[qc2],     %[t4],      %[t1]           
\t""

            ""movn       %[qc3],     %[t4],      %[t2]           
\t""

            ""movn       %[qc4],     %[t4],      %[t3]           
\t""

            ""lw         %[t0],      0(%[in_int])                
\t""

            ""lw         %[t1],      4(%[in_int])                
\t""

            ""lw         %[t2],      8(%[in_int])                
\t""

            ""lw         %[t3],      12(%[in_int])               
\t""

            ""slt        %[t0],      %[t0],      $zero           
\t""

            ""movn       %[sign1],   %[t0],      %[qc1]          
\t""

            ""slt        %[t2],      %[t2],      $zero           
\t""

            ""movn       %[sign2],   %[t2],      %[qc3]          
\t""

            ""slt        %[t1],      %[t1],      $zero           
\t""

            ""sll        %[t0],      %[sign1],   1               
\t""

            ""or         %[t0],      %[t0],      %[t1]           
\t""

            ""movn       %[sign1],   %[t0],      %[qc2]          
\t""

            ""slt        %[t3],      %[t3],      $zero           
\t""

            ""sll        %[t0],      %[sign2],   1               
\t""

            ""or         %[t0],      %[t0],      %[t3]           
\t""

            ""movn       %[sign2],   %[t0],      %[qc4]          
\t""

            ""slt        %[count1],  $zero,      %[qc1]          
\t""

            ""slt        %[t1],      $zero,      %[qc2]          
\t""

            ""slt        %[sign8],  $zero,      %[qc3]          
\t""

            ""slt        %[t2],      $zero,      %[qc4]          
\t""

            ""addu       %[count1],  %[count1],  %[t1]           
\t""

            ""addu       %[sign8],  %[sign8],  %[t2]           
\t""



            "".set pop                                           
\t""



            : [qc1]""+r""(qc1), [qc2]""+r""(qc2),

              [qc3]""+r""(qc3), [qc4]""+r""(qc4),

              [sign1]""=&r""(sign1), [count1]""=&r""(count1),

              [sign2]""=&r""(sign2), [sign8]""=&r""(sign8),

              [t0]""=&r""(t0), [t1]""=&r""(t1), [t2]""=&r""(t2), [t3]""=&r""(t3),

              [t4]""=&r""(t4)

            : [in_int]""r""(in_int)

            : ""memory""

        );



        curidx = 8 * qc1;

        curidx += qc2;



        curidx2 = 8 * qc3;

        curidx2 += qc4;



        curbits += p_bits[curidx];

        curbits += upair7_sign_bits[curidx];

        nec     = &p_codes[curidx*2];



        curbits += p_bits[curidx2];

        curbits += upair7_sign_bits[curidx2];

        vec2    = &p_codes[curidx2*2];



        __asm__ volatile (

            "".set push                                          
\t""

            "".set noreorder                                     
\t""



            ""lwc1       %[di0],     0(%[in_pos])                
\t""

            ""lwc1       %[di1],     4(%[in_pos])                
\t""

            ""lwc1       %[mi0],     8(%[in_pos])                
\t""

            ""lwc1       %[di3],     12(%[in_pos])               
\t""

            ""abs.s      %[di0],     %[di0]                      
\t""

            ""abs.s      %[di1],     %[di1]                      
\t""

            ""abs.s      %[mi0],     %[mi0]                      
\t""

            ""abs.s      %[di3],     %[di3]                      
\t""

            ""lwc1       $f0,        0(%[nec])                   
\t""

            ""lwc1       $f1,        4(%[nec])                   
\t""

            ""lwc1       $f2,        0(%[vec2])                  
\t""

            ""lwc1       $f3,        4(%[vec2])                  
\t""

            ""nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   
\t""

            ""nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   
\t""

            ""nmsub.s    %[mi0],     %[mi0],     $f2,    %[IQ]   
\t""

            ""nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   
\t""



            "".set pop                                           
\t""



            : [di0]""=&f""(di0), [di1]""=&f""(di1),

              [mi0]""=&f""(mi0), [di3]""=&f""(di3)

            : [in_pos]""r""(in_pos), [nec]""r""(nec),

              [vec2]""r""(vec2), [IQ]""f""(IQ)

            : ""$f0"", ""$f1"", ""$f2"", ""$f3"",

              ""memory""

        );



        cost += di0 * di0 + di1 * di1

                + mi0 * mi0 + di3 * di3;

    }



    if (bits)

        *bits = curbits;

    return cost * lambda + curbits;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,pb,in,scaled,size,scale_idx,cb,lambda,uplim,bits,i,qc1,qc2,qc3,qc4,p_bits,p_codes,vec,vec2,curidx,curidx2,sign1,count1,sign2,count2,in_int,in_pos,di0,di1,di2,di3,t0,t1,t2,t3,t4",,,,217,"s:s,pb:pb,in:complex,scaled:scaled,size:size,scale_idx:scale_idx,cb:cb,lambda:lambda,uplim:uplim,bits:bits,i:i,qc1:qc1,qc2:qc2,qc3:qc3,qc4:qc4,p_bits:p_bits,p_codes:p_codes,vec:nec,vec2:vec2,curidx:curidx,curidx2:curidx2,sign1:sign1,count1:count1,sign2:sign2,count2:sign8,in_int:in_int,in_pos:in_pos,di0:di0,di1:di1,di2:mi0,di3:di3,t0:t0,t1:t1,t2:t2,t3:t3,t4:t4,",32,GA,1020,0.6226314425468444,GA,
368,"static void scsi_write_data(SCSIRequest *req)

{

    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);

    uint32_t n;



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    /* The request is used as the AIO opaque value, so add a ref.  */

    scsi_req_ref(&r->req);

    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {

        DPRINTF(""Data transfer direction invalid\n"");

        scsi_write_complete(r, -EINVAL);

        return;

    }



    if (!r->req.sg && !r->qiov.size) {

        /* Called for the first time.  Ask the driver to send us more data.  */

        r->started = true;

        scsi_write_complete(r, 0);

        return;

    }

    if (s->tray_open) {

        scsi_write_complete(r, -ENOMEDIUM);

        return;

    }



    if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 ||

        r->req.cmd.buf[0] == VERIFY_16) {

        if (r->req.sg) {

            scsi_dma_complete(r, 0);

        } else {

            scsi_write_complete(r, 0);

        }

        return;

    }



    if (r->req.sg) {

        dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_WRITE);

        r->req.resid -= r->req.sg->size;

        r->req.aiocb = dma_bdrv_write(s->qdev.conf.bs, r->req.sg, r->sector,

                                      scsi_dma_complete, r);

    } else {

        n = r->qiov.size / 512;

        bdrv_acct_start(s->qdev.conf.bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE);

        r->req.aiocb = bdrv_aio_writev(s->qdev.conf.bs, r->sector, &r->qiov, n,

                                       scsi_write_complete, r);

    }

}
",447,,LABEL_1,LABEL_0,,-4,"req,r,s,n",,,,0,,0,Greedy,1,0.0006678382555643718,,
369,"static void pc_init1(ram_addr_t ram_size,

                     const char *boot_device,

                     const char *kernel_filename,

                     const char *kernel_cmdline,

                     const char *initrd_filename,

                     const char *cpu_model,

                     int pci_enabled,

                     int kvmclock_enabled)

{

    int i;

    ram_addr_t below_4g_mem_size, above_4g_mem_size;

    PCIBus *pci_bus;

    PCII440FXState *i440fx_state;

    int piix3_devfn = -1;

    qemu_irq *cpu_irq;

    qemu_irq *isa_irq;

    qemu_irq *i8259;

    qemu_irq *cmos_s3;

    qemu_irq *smi_irq;

    IsaIrqState *isa_irq_state;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    FDCtrl *floppy_controller;

    BusState *idebus[MAX_IDE_BUS];

    ISADevice *rtc_state;



    pc_cpus_init(cpu_model);



    if (kvmclock_enabled) {

        kvmclock_create();

    }



    /* allocate ram and load rom/bios */

    pc_memory_init(ram_size, kernel_filename, kernel_cmdline, initrd_filename,

                   &below_4g_mem_size, &above_4g_mem_size);



    cpu_irq = pc_allocate_cpu_irq();

    i8259 = i8259_init(cpu_irq[0]);

    isa_irq_state = qemu_mallocz(sizeof(*isa_irq_state));

    isa_irq_state->i8259 = i8259;

    if (pci_enabled) {

        ioapic_init(isa_irq_state);

    }

    isa_irq = qemu_allocate_irqs(isa_irq_handler, isa_irq_state, 24);



    if (pci_enabled) {

        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, isa_irq, ram_size);

    } else {

        pci_bus = NULL;

        i440fx_state = NULL;

        isa_bus_new(NULL);

    }

    isa_bus_irqs(isa_irq);



    pc_register_ferr_irq(isa_reserve_irq(13));



    pc_vga_init(pci_enabled? pci_bus: NULL);



    /* init basic PC hardware */

    pc_basic_device_init(isa_irq, &floppy_controller, &rtc_state);



    for(i = 0; i < nb_nics; i++) {

        NICInfo *nd = &nd_table[i];



        if (!pci_enabled || (nd->model && strcmp(nd->model, ""ne2k_isa"") == 0))

            pc_init_ne2k_isa(nd);

        else

            pci_nic_init_nofail(nd, ""e1000"", NULL);

    }



    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus\n"");

        exit(1);

    }



    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {

        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);

    }



    if (pci_enabled) {

        PCIDevice *dev;

        dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);

        idebus[0] = qdev_get_child_bus(&dev->qdev, ""ide.0"");

        idebus[1] = qdev_get_child_bus(&dev->qdev, ""ide.1"");

    } else {

        for(i = 0; i < MAX_IDE_BUS; i++) {

            ISADevice *dev;

            dev = isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],

                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);

            idebus[i] = qdev_get_child_bus(&dev->qdev, ""ide.0"");

        }

    }



    audio_init(isa_irq, pci_enabled ? pci_bus : NULL);



    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device,

                 idebus[0], idebus[1], floppy_controller, rtc_state);



    if (pci_enabled && usb_enabled) {

        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);

    }



    if (pci_enabled && acpi_enabled) {

        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */

        i2c_bus *smbus;



        cmos_s3 = qemu_allocate_irqs(pc_cmos_set_s3_resume, rtc_state, 1);

        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);

        /* TODO: Populate SPD eeprom data.  */

        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,

                              isa_reserve_irq(9), *cmos_s3, *smi_irq,

                              kvm_enabled());

        for (i = 0; i < 8; i++) {

            DeviceState *eeprom;

            eeprom = qdev_create((BusState *)smbus, ""smbus-eeprom"");

            qdev_prop_set_uint8(eeprom, ""address"", 0x50 + i);

            qdev_prop_set_ptr(eeprom, ""data"", eeprom_buf + (i * 256));

            qdev_init_nofail(eeprom);

        }

    }



    if (i440fx_state) {

        i440fx_init_memory_mappings(i440fx_state);

    }



    if (pci_enabled) {

        pc_pci_device_init(pci_bus);

    }

}
",783,"static void pc_init1(ram_addr_t gram_scale,

                     const char *boot_device,

                     const char *kernel_filename,

                     const char *kernel_cmdline,

                     const char *initrd_filename,

                     const char *cpu_model,

                     int pci_enabled,

                     int kvmclock_enabled)

{

    int i;

    ram_addr_t below_4g_mem_size, above_4g_mem_size;

    PCIBus *pci_bus;

    PCII440FXState *i440fx_state;

    int piix3_devfn = -1;

    qemu_irq *cpu_irq;

    qemu_irq *isa_irq;

    qemu_irq *i8259;

    qemu_irq *cmos_ggd;

    qemu_irq *smi_irq;

    IsaIrqState *isa_irq_state;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    FDCtrl *floppy_controller;

    BusState *idebus[MAX_IDE_BUS];

    ISADevice *rtc_state;



    pc_cpus_init(cpu_model);



    if (kvmclock_enabled) {

        kvmclock_create();

    }



    /* allocate ram and load rom/bios */

    pc_memory_init(gram_scale, kernel_filename, kernel_cmdline, initrd_filename,

                   &below_4g_mem_size, &above_4g_mem_size);



    cpu_irq = pc_allocate_cpu_irq();

    i8259 = i8259_init(cpu_irq[0]);

    isa_irq_state = qemu_mallocz(sizeof(*isa_irq_state));

    isa_irq_state->i8259 = i8259;

    if (pci_enabled) {

        ioapic_init(isa_irq_state);

    }

    isa_irq = qemu_allocate_irqs(isa_irq_handler, isa_irq_state, 24);



    if (pci_enabled) {

        pcpci_bus i440fx_init(&i4i440fx_state&piix3_devfn, isisa_irqgram_scale);

    } else {

        pci_bus = NULL;

        i440fx_state = NULL;

        isa_bus_new(NULL);

    }

    isa_bus_irqs(isa_irq);



    pc_register_ferr_irq(isa_reserve_irq(13));



    pc_vga_init(pci_enabled? pci_bus: NULL);



    /* init basic PC hardware */

    pc_basic_device_init(isa_irq, &floppy_controller, &rtc_state);



    for(i = 0; i < nb_nics; i++) {

        NICInfo *nd = &nd_table[i];



        if (!pci_enabled || (nd->model && strcmp(nd->model, ""ne2k_isa"") == 0))

            pc_init_ne2k_isa(nd);

        else

            pci_nic_init_nofail(nd, ""e1000"", NULL);

    }



    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus
"");

        exit(1);

    }



    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {

        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);

    }



    if (pci_enabled) {

        PCIDevice *dev;

        dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);

        idebus[0] = qdev_get_child_bus(&dev->qdev, ""ide.0"");

        idebus[1] = qdev_get_child_bus(&dev->qdev, ""ide.1"");

    } else {

        for(i = 0; i < MAX_IDE_BUS; i++) {

            ISADevice *dev;

            dev = isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],

                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);

            idebus[i] = qdev_get_child_bus(&dev->qdev, ""ide.0"");

        }

    }



    audio_init(isa_irq, pci_enabled ? pci_bus : NULL);



    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device,

                 idebus[0], idebus[1], floppy_controller, rtc_state);



    if (pci_enabled && usb_enabled) {

        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);

    }



    if (pci_enabled && acpi_enabled) {

        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */

        i2c_bus *smbus;



        cmos_ggd = qemu_allocate_irqs(pc_cmos_set_s3_resume, rtc_state, 1);

        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);

        /* TODO: Populate SPD eeprom data.  */

        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,

                              isa_reserve_irq(9), *cmos_ggd, *smi_irq,

                              kvm_enabled());

        for (i = 0; i < 8; i++) {

            DeviceState *eeprom;

            eeprom = qdev_create((BusState *)smbus, ""smbus-eeprom"");

            qdev_prop_set_uint8(eeprom, ""address"", 0x50 + i);

            qdev_prop_set_ptr(eeprom, ""data"", eeprom_buf + (i * 256));

            qdev_init_nofail(eeprom);

        }

    }



    if (i440fx_state) {

        i440fx_init_memory_mappings(i440fx_state);

    }



    if (pci_enabled) {

        pc_pci_device_init(pci_bus);

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"ram_size,boot_device,kernel_filename,kernel_cmdline,initrd_filename,cpu_model,pci_enabled,kvmclock_enabled,i,below_4g_mem_size,above_4g_mem_size,pci_bus,i440fx_state,cpu_irq,isa_irq,i8259,cmos_s3,smi_irq,isa_irq_state,hd,MAX_IDE_BUS,MAX_IDE_DEVS,floppy_controller,idebus,rtc_state",,,,117,"ram_size:gram_scale,boot_device:boot_device,kernel_filename:kernel_filename,kernel_cmdline:kernel_cmdline,initrd_filename:initrd_filename,cpu_model:cpu_model,pci_enabled:pci_enabled,kvmclock_enabled:kvmclock_enabled,i:i,below_4g_mem_size:below_4g_mem_size,above_4g_mem_size:above_4g_mem_size,pci_bus:pci_bus,i440fx_state:i440fx_state,cpu_irq:cpu_irq,isa_irq:isa_irq,i8259:i8259,cmos_s3:cmos_ggd,smi_irq:smi_irq,isa_irq_state:isa_irq_state,hd:hd,MAX_IDE_BUS:MAX_IDE_BUS,MAX_IDE_DEVS:MAX_IDE_DEVS,floppy_controller:floppy_controller,idebus:idebus,rtc_state:rtc_state,",23,GA,634,0.31126912832260134,GA,
370,"static void check_default_settings(AVCodecContext *avctx)

{

    X264Context *x4 = avctx->priv_data;



    int score = 0;

    score += x4->params.analyse.i_me_range == 0;

    score += x4->params.rc.i_qp_step == 3;

    score += x4->params.i_keyint_max == 12;

    score += x4->params.rc.i_qp_min == 2;

    score += x4->params.rc.i_qp_max == 31;

    score += x4->params.rc.f_qcompress == 0.5;

    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;

    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;

    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;

    if (score >= 5) {

        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");

        x4->preset = av_strdup(""medium"");

        if (avctx->bit_rate == 200*1000)

            avctx->crf = 23;

    }

}
",214,,LABEL_0,LABEL_0,LABEL_0,-1,"avctx,x4",,,,0,,0,GA,541,0.19901679356892904,failed,
371,"static av_cold int ffmmal_init_decoder(AVCodecContext *avctx)
{
    MMALDecodeContext *ctx = avctx->priv_data;
    MMAL_STATUS_T status;
    MMAL_ES_FORMAT_T *format_in;
    MMAL_COMPONENT_T *decoder;
    char tmp[32];
    int ret = 0;
    bcm_host_init();
    if (mmal_vc_init()) {
        av_log(avctx, AV_LOG_ERROR, ""Cannot initialize MMAL VC driver!\n"");
        return AVERROR(ENOSYS);
    if ((ret = ff_get_format(avctx, avctx->codec->pix_fmts)) < 0)
        return ret;
    avctx->pix_fmt = ret;
    if ((status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER, &ctx->decoder)))
        goto fail;
    decoder = ctx->decoder;
    format_in = decoder->input[0]->format;
    format_in->type = MMAL_ES_TYPE_VIDEO;
    switch (avctx->codec_id) {
        case AV_CODEC_ID_MPEG2VIDEO:
            format_in->encoding = MMAL_ENCODING_MP2V;
            break;
        case AV_CODEC_ID_MPEG4:
            format_in->encoding = MMAL_ENCODING_MP4V;
            break;
        case AV_CODEC_ID_VC1:
            format_in->encoding = MMAL_ENCODING_WVC1;
            break;
        case AV_CODEC_ID_H264:
        default:
            format_in->encoding = MMAL_ENCODING_H264;
            break;
    format_in->es->video.width = FFALIGN(avctx->width, 32);
    format_in->es->video.height = FFALIGN(avctx->height, 16);
    format_in->es->video.crop.width = avctx->width;
    format_in->es->video.crop.height = avctx->height;
    format_in->es->video.frame_rate.num = 24000;
    format_in->es->video.frame_rate.den = 1001;
    format_in->es->video.par.num = avctx->sample_aspect_ratio.num;
    format_in->es->video.par.den = avctx->sample_aspect_ratio.den;
    format_in->flags = MMAL_ES_FORMAT_FLAG_FRAMED;
    av_get_codec_tag_string(tmp, sizeof(tmp), format_in->encoding);
    av_log(avctx, AV_LOG_DEBUG, ""Using MMAL %s encoding.\n"", tmp);
    if ((status = mmal_port_format_commit(decoder->input[0])))
        goto fail;
    decoder->input[0]->buffer_num =
        FFMAX(decoder->input[0]->buffer_num_min, 20);
    decoder->input[0]->buffer_size =
        FFMAX(decoder->input[0]->buffer_size_min, 512 * 1024);
    ctx->pool_in = mmal_pool_create(decoder->input[0]->buffer_num, 0);
    if (!ctx->pool_in) {
        ret = AVERROR(ENOMEM);
        goto fail;
    if ((ret = ffmal_update_format(avctx)) < 0)
        goto fail;
    ctx->queue_decoded_frames = mmal_queue_create();
    if (!ctx->queue_decoded_frames)
        goto fail;
    decoder->input[0]->userdata = (void*)avctx;
    decoder->output[0]->userdata = (void*)avctx;
    decoder->control->userdata = (void*)avctx;
    if ((status = mmal_port_enable(decoder->control, control_port_cb)))
        goto fail;
    if ((status = mmal_port_enable(decoder->input[0], input_callback)))
        goto fail;
    if ((status = mmal_port_enable(decoder->output[0], output_callback)))
        goto fail;
    if ((status = mmal_component_enable(decoder)))
        goto fail;
    return 0;
fail:
    ffmmal_close_decoder(avctx);
    return ret < 0 ? ret : AVERROR_UNKNOWN;",685,,LABEL_1,LABEL_1,LABEL_1,-1,"avctx,ctx,status,format_in,decoder,tmp",,,,0,,0,GA,1313,0.5963571667671204,failed,
372,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,

                                           const void *pkt_data,

                                           size_t pkt_len)

{

    struct virtio_net_hdr *vhdr;

    bool isip4, isip6, istcp, isudp;

    uint8_t *data;

    int len;



    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {

        return;

    }



    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);

    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);

    if (!(isip4 || isip6) || !(istcp || isudp)) {

        return;

    }



    vmxnet3_dump_virt_hdr(vhdr);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  len, vhdr->csum_start, vhdr->csum_offset);

        return;

    }



    data = (uint8_t *)pkt_data + vhdr->csum_start;

    len = pkt_len - vhdr->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len));



    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",243,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *wct,

                                           const void *pkt_data,

                                           size_t pkt2length)

{

    struct virtio_net_hdr *vhdr;

    bool isip4, isip6, istcp, isudp;

    uint8_t *valid;

    int len;



    if (!vmxnet_rx_pkt_has_virt_hdr(wct)) {

        return;

    }



    vhdr = vmxnet_rx_pkt_get_vhdr(wct);

    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(wct, &isip4, &isip6, &isudp, &istcp);

    if (!(isip4 || isip6) || !(istcp || isudp)) {

        return;

    }



    vmxnet3_dump_virt_hdr(vhdr);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (pkt2length < (vhdr->csum_start + vhdr->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  len, vhdr->csum_start, vhdr->csum_offset);

        return;

    }



    valid = (uint8_t *)pkt_data + vhdr->csum_start;

    lenlenpkt2length - vhdr->csum_start;

    /* Put the checksum obtained into the packet */

    stw_be_p(valid + vhdr->csum_offset, net_raw_checksum(valid, len));



    vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;

    vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID;

}
",LABEL_1,LABEL_1,LABEL_0,1,"pkt,pkt_data,pkt_len,vhdr,isip4,isip6,istcp,isudp,data,len",,,,32,"pkt:wct,pkt_data:pkt_data,pkt_len:pkt2length,vhdr:vhdr,isip4:isip4,isip6:isip6,istcp:istcp,isudp:isudp,data:valid,len:len,",7,GA,651,0.2486674189567566,GA,
373,"uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,

                       uint32_t r3)

{

    uintptr_t ra = GETPC();

    uint64_t destlen = get_length(env, r1 + 1);

    uint64_t dest = get_address(env, r1);

    uint64_t srclen = get_length(env, r3 + 1);

    uint64_t src = get_address(env, r3);

    uint8_t pad = a2 & 0xff;

    uint32_t cc = 0;



    if (!(destlen || srclen)) {

        return cc;

    }



    if (srclen > destlen) {

        srclen = destlen;

    }



    for (; destlen || srclen; src++, dest++, destlen--, srclen--) {

        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;

        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;

        if (v1 != v2) {

            cc = (v1 < v2) ? 1 : 2;

            break;

        }

    }



    set_length(env, r1 + 1, destlen);

    /* can't use srclen here, we trunc'ed it */

    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);

    set_address(env, r1, dest);

    set_address(env, r3, src);



    return cc;

}
",261,"uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t A2,

                       uint32_t p03)

{

    uintptr_t ra = GETPC();

    uint64_t routelen = get_length(env, r1 + 1);

    uint64_t dest = get_address(env, r1);

    uint64_t ssrclen= get_length(env, p03 + 1);

    uint64_t ssrc= get_address(env, p03);

    uint8_t pad = A2 & 0xff;

    uint32_t cc = 0;



    if (!(routelen || srclen)) {

        return cc;

    }



    if (ssrclen> routelen) {

        ssrclen= routelen;

    }



    for (; routelen || ssrclen src++, dest++, routelen--, srclen--) {

        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;

        uint8_t v2 = routelen ? cpu_ldub_data_ra(env, dest, ra) : pad;

        if (v1 != v2) {

            cc = (v1 < v2) ? 1 : 2;

            break;

        }

    }



    set_length(env, r1 + 1, routelen);

    /* can't use srclen here, we trunc'ed it */

    set_length(env, p03 + 1, env->regs[p03 + 1] - ssrc- env->regs[p03]);

    set_address(env, r1, dest);

    set_address(env, p03, src);



    return cc;

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,r1,a2,r3,src,dest,destlen,srclen",,,,35,"env:env,r1:r1,a2:A2,r3:p03,src:src,dest:dest,destlen:routelen,srclen:srclen,",5,GA,565,0.21472520828247071,GA,
374,"bool machine_iommu(MachineState *machine)

{

    return machine->iommu;

}
",14,,LABEL_0,LABEL_0,LABEL_0,-1,machine,,,,0,,0,GA,243,0.08465718030929566,failed,
375,"static void QEMU_NORETURN help(void)

{

    const char *help_msg =

           QEMU_IMG_VERSION

           ""usage: qemu-img [standard options] command [command options]\n""

           ""QEMU disk image utility\n""

           ""\n""

           ""    '-h', '--help'       display this help and exit\n""

           ""    '-V', '--version'    output version information and exit\n""

           ""    '-T', '--trace'      [[enable=]<pattern>][,events=<file>][,file=<file>]\n""

           ""                         specify tracing options\n""

           ""\n""

           ""Command syntax:\n""

#define DEF(option, callback, arg_string)        \

           ""  "" arg_string ""\n""

#include ""qemu-img-cmds.h""

#undef DEF

#undef GEN_DOCS

           ""\n""

           ""Command parameters:\n""

           ""  'filename' is a disk image filename\n""

           ""  'objectdef' is a QEMU user creatable object definition. See the qemu(1)\n""

           ""    manual page for a description of the object properties. The most common\n""

           ""    object type is a 'secret', which is used to supply passwords and/or\n""

           ""    encryption keys.\n""

           ""  'fmt' is the disk image format. It is guessed automatically in most cases\n""

           ""  'cache' is the cache mode used to write the output disk image, the valid\n""

           ""    options are: 'none', 'writeback' (default, except for convert), 'writethrough',\n""

           ""    'directsync' and 'unsafe' (default for convert)\n""

           ""  'src_cache' is the cache mode used to read input disk images, the valid\n""

           ""    options are the same as for the 'cache' option\n""

           ""  'size' is the disk image size in bytes. Optional suffixes\n""

           ""    'k' or 'K' (kilobyte, 1024), 'M' (megabyte, 1024k), 'G' (gigabyte, 1024M),\n""

           ""    'T' (terabyte, 1024G), 'P' (petabyte, 1024T) and 'E' (exabyte, 1024P)  are\n""

           ""    supported. 'b' is ignored.\n""

           ""  'output_filename' is the destination disk image filename\n""

           ""  'output_fmt' is the destination format\n""

           ""  'options' is a comma separated list of format specific options in a\n""

           ""    name=value format. Use -o ? for an overview of the options supported by the\n""

           ""    used format\n""

           ""  'snapshot_param' is param used for internal snapshot, format\n""

           ""    is 'snapshot.id=[ID],snapshot.name=[NAME]', or\n""

           ""    '[ID_OR_NAME]'\n""

           ""  'snapshot_id_or_name' is deprecated, use 'snapshot_param'\n""

           ""    instead\n""

           ""  '-c' indicates that target image must be compressed (qcow format only)\n""

           ""  '-u' enables unsafe rebasing. It is assumed that old and new backing file\n""

           ""       match exactly. The image doesn't need a working backing file before\n""

           ""       rebasing in this case (useful for renaming the backing file)\n""

           ""  '-h' with or without a command shows this help and lists the supported formats\n""

           ""  '-p' show progress of command (only certain commands)\n""

           ""  '-q' use Quiet mode - do not print any output (except errors)\n""

           ""  '-S' indicates the consecutive number of bytes (defaults to 4k) that must\n""

           ""       contain only zeros for qemu-img to create a sparse image during\n""

           ""       conversion. If the number of bytes is 0, the source will not be scanned for\n""

           ""       unallocated or zero sectors, and the destination image will always be\n""

           ""       fully allocated\n""

           ""  '--output' takes the format in which the output must be done (human or json)\n""

           ""  '-n' skips the target volume creation (useful if the volume is created\n""

           ""       prior to running qemu-img)\n""

           ""\n""

           ""Parameters to check subcommand:\n""

           ""  '-r' tries to repair any inconsistencies that are found during the check.\n""

           ""       '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\n""

           ""       kinds of errors, with a higher risk of choosing the wrong fix or\n""

           ""       hiding corruption that has already occurred.\n""

           ""\n""

           ""Parameters to convert subcommand:\n""

           ""  '-m' specifies how many coroutines work in parallel during the convert\n""

           ""       process (defaults to 8)\n""

           ""  '-W' allow to write to the target out of order rather than sequential\n""

           ""\n""

           ""Parameters to snapshot subcommand:\n""

           ""  'snapshot' is the name of the snapshot to create, apply or delete\n""

           ""  '-a' applies a snapshot (revert disk to saved state)\n""

           ""  '-c' creates a snapshot\n""

           ""  '-d' deletes a snapshot\n""

           ""  '-l' lists all snapshots in the given image\n""

           ""\n""

           ""Parameters to compare subcommand:\n""

           ""  '-f' first image format\n""

           ""  '-F' second image format\n""

           ""  '-s' run in Strict mode - fail on different image size or sector allocation\n""

           ""\n""

           ""Parameters to dd subcommand:\n""

           ""  'bs=BYTES' read and write up to BYTES bytes at a time ""

           ""(default: 512)\n""

           ""  'count=N' copy only N input blocks\n""

           ""  'if=FILE' read from FILE\n""

           ""  'of=FILE' write to FILE\n""

           ""  'skip=N' skip N bs-sized blocks at the start of input\n"";



    printf(""%s\nSupported formats:"", help_msg);

    bdrv_iterate_format(format_print, NULL);

    printf(""\n"");

    exit(EXIT_SUCCESS);

}
",850,,LABEL_0,LABEL_0,LABEL_0,-1,"QEMU_NORETURN,help_msg",,,,0,,0,GA,404,0.2347144325574239,failed,
376,"static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)

{

    int rex;



    if (opc & P_GS) {

        tcg_out8(s, 0x65);

    }

    if (opc & P_DATA16) {

        /* We should never be asking for both 16 and 64-bit operation.  */

        assert((opc & P_REXW) == 0);

        tcg_out8(s, 0x66);

    }

    if (opc & P_ADDR32) {

        tcg_out8(s, 0x67);

    }



    rex = 0;

    rex |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */

    rex |= (r & 8) >> 1;                /* REX.R */

    rex |= (x & 8) >> 2;                /* REX.X */

    rex |= (rm & 8) >> 3;               /* REX.B */



    /* P_REXB_{R,RM} indicates that the given register is the low byte.

       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,

       as otherwise the encoding indicates %[abcd]h.  Note that the values

       that are ORed in merely indicate that the REX byte must be present;

       those bits get discarded in output.  */

    rex |= opc & (r >= 4 ? P_REXB_R : 0);

    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);



    if (rex) {

        tcg_out8(s, (uint8_t)(rex | 0x40));

    }



    if (opc & (P_EXT | P_EXT38)) {

        tcg_out8(s, 0x0f);

        if (opc & P_EXT38) {

            tcg_out8(s, 0x38);

        }

    }



    tcg_out8(s, opc);

}
",346,"static void tcg_out_opc(TCGContext *s, int uplc, int r, int rm, int x)

{

    int gal;



    if (uplc & P_GS) {

        tcg_out8(s, 0x65);

    }

    if (uplc & P_DATA16) {

        /* We should never be asking for both 16 and 64-bit operation.  */

        assert((uplc & P_REXW) == 0);

        tcg_out8(s, 0x66);

    }

    if (uplc & P_ADDR32) {

        tcg_out8(s, 0x67);

    }



    gal = 0;

    rgal|= (uplc & P_REXW) ? 0x8 : 0x0;  /* REX.W */

    gal |= (r & 8) >> 1;                /* REX.R */

    gal |= (x & 8) >> 2;                /* REX.X */

    gal |= (rm & 8) >> 3;               /* REX.B */



    /* P_REXB_{R,RM} indicates that the given register is the low byte.

       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,

       as otherwise the encoding indicates %[abcd]h.  Note that the values

       that are ORed in merely indicate that the REX byte must be present;

       those bits get discarded in output.  */

    rgal|= uplc & (r >= 4 ? P_REXB_R : 0);

    rgal|= uplc & (rm >= 4 ? P_REXB_RM : 0);



    if (gal) {

        tcg_out8(s, (uint8_t)(gal | 0x40));

    }



    if (uplc & (P_EXT | P_EXT38)) {

        tcg_out8(s, 0x0f);

        if (uplc & P_EXT38) {

            tcg_out8(s, 0x38);

        }

    }



    tcg_out8(s, uplc);

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,opc,r,rm,x,rex",,,,16,"s:s,opc:uplc,r:r,rm:rm,x:x,rex:gal,",4,GA,369,0.146762748559316,GA,
377,"static int decode_element(AVCodecContext *avctx, void *data, int ch_index,

                          int channels)

{

    ALACContext *alac = avctx->priv_data;

    int has_size, bps, is_compressed, decorr_shift, decorr_left_weight, ret;

    uint32_t output_samples;

    int i, ch;



    skip_bits(&alac->gb, 4);  /* element instance tag */

    skip_bits(&alac->gb, 12); /* unused header bits */



    /* the number of output samples is stored in the frame */

    has_size = get_bits1(&alac->gb);



    alac->extra_bits = get_bits(&alac->gb, 2) << 3;

    bps = alac->sample_size - alac->extra_bits + channels - 1;

    if (bps > 32) {

        av_log(avctx, AV_LOG_ERROR, ""bps is unsupported: %d\n"", bps);

        return AVERROR_PATCHWELCOME;

    }



    /* whether the frame is compressed */

    is_compressed = !get_bits1(&alac->gb);



    if (has_size)

        output_samples = get_bits_long(&alac->gb, 32);

    else

        output_samples = alac->max_samples_per_frame;

    if (!output_samples || output_samples > alac->max_samples_per_frame) {

        av_log(avctx, AV_LOG_ERROR, ""invalid samples per frame: %d\n"",

               output_samples);

        return AVERROR_INVALIDDATA;

    }

    if (!alac->nb_samples) {

        /* get output buffer */

        alac->frame.nb_samples = output_samples;

        if ((ret = avctx->get_buffer(avctx, &alac->frame)) < 0) {

            av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

            return ret;

        }

    } else if (output_samples != alac->nb_samples) {

        av_log(avctx, AV_LOG_ERROR, ""sample count mismatch: %u != %d\n"",

               output_samples, alac->nb_samples);

        return AVERROR_INVALIDDATA;

    }

    alac->nb_samples = output_samples;

    if (alac->direct_output) {

        for (ch = 0; ch < channels; ch++)

            alac->output_samples_buffer[ch] = (int32_t *)alac->frame.extended_data[ch_index + ch];

    }



    if (is_compressed) {

        int16_t lpc_coefs[2][32];

        int lpc_order[2];

        int prediction_type[2];

        int lpc_quant[2];

        int rice_history_mult[2];



        decorr_shift       = get_bits(&alac->gb, 8);

        decorr_left_weight = get_bits(&alac->gb, 8);



        for (ch = 0; ch < channels; ch++) {

            prediction_type[ch]   = get_bits(&alac->gb, 4);

            lpc_quant[ch]         = get_bits(&alac->gb, 4);

            rice_history_mult[ch] = get_bits(&alac->gb, 3);

            lpc_order[ch]         = get_bits(&alac->gb, 5);



            /* read the predictor table */

            for (i = lpc_order[ch] - 1; i >= 0; i--)

                lpc_coefs[ch][i] = get_sbits(&alac->gb, 16);

        }



        if (alac->extra_bits) {

            for (i = 0; i < alac->nb_samples; i++) {

                if(get_bits_left(&alac->gb) <= 0)

                    return -1;

                for (ch = 0; ch < channels; ch++)

                    alac->extra_bits_buffer[ch][i] = get_bits(&alac->gb, alac->extra_bits);

            }

        }

        for (ch = 0; ch < channels; ch++) {

            int ret=rice_decompress(alac, alac->predict_error_buffer[ch],

                            alac->nb_samples, bps,

                            rice_history_mult[ch] * alac->rice_history_mult / 4);

            if(ret<0)

                return ret;



            /* adaptive FIR filter */

            if (prediction_type[ch] == 15) {

                /* Prediction type 15 runs the adaptive FIR twice.

                 * The first pass uses the special-case coef_num = 31, while

                 * the second pass uses the coefs from the bitstream.

                 *

                 * However, this prediction type is not currently used by the

                 * reference encoder.

                 */

                lpc_prediction(alac->predict_error_buffer[ch],

                               alac->predict_error_buffer[ch],

                               alac->nb_samples, bps, NULL, 31, 0);

            } else if (prediction_type[ch] > 0) {

                av_log(avctx, AV_LOG_WARNING, ""unknown prediction type: %i\n"",

                       prediction_type[ch]);

            }

            lpc_prediction(alac->predict_error_buffer[ch],

                           alac->output_samples_buffer[ch], alac->nb_samples,

                           bps, lpc_coefs[ch], lpc_order[ch], lpc_quant[ch]);

        }

    } else {

        /* not compressed, easy case */

        for (i = 0; i < alac->nb_samples; i++) {

            if(get_bits_left(&alac->gb) <= 0)

                return -1;

            for (ch = 0; ch < channels; ch++) {

                alac->output_samples_buffer[ch][i] =

                         get_sbits_long(&alac->gb, alac->sample_size);

            }

        }

        alac->extra_bits   = 0;

        decorr_shift       = 0;

        decorr_left_weight = 0;

    }



    if (channels == 2 && decorr_left_weight) {

        decorrelate_stereo(alac->output_samples_buffer, alac->nb_samples,

                           decorr_shift, decorr_left_weight);

    }



    if (alac->extra_bits) {

        append_extra_bits(alac->output_samples_buffer, alac->extra_bits_buffer,

                          alac->extra_bits, channels, alac->nb_samples);

    }



    if(av_sample_fmt_is_planar(avctx->sample_fmt)) {

    switch(alac->sample_size) {

    case 16: {

        for (ch = 0; ch < channels; ch++) {

            int16_t *outbuffer = (int16_t *)alac->frame.extended_data[ch_index + ch];

            for (i = 0; i < alac->nb_samples; i++)

                *outbuffer++ = alac->output_samples_buffer[ch][i];

        }}

        break;

    case 24: {

        for (ch = 0; ch < channels; ch++) {

            for (i = 0; i < alac->nb_samples; i++)

                alac->output_samples_buffer[ch][i] <<= 8;

        }}

        break;

    }

    }else{

        switch(alac->sample_size) {

        case 16: {

            int16_t *outbuffer = ((int16_t *)alac->frame.extended_data[0]) + ch_index;

            for (i = 0; i < alac->nb_samples; i++) {

                for (ch = 0; ch < channels; ch++)

                    *outbuffer++ = alac->output_samples_buffer[ch][i];

                outbuffer += alac->channels - channels;

            }

            }

            break;

        case 24: {

            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;

            for (i = 0; i < alac->nb_samples; i++) {

                for (ch = 0; ch < channels; ch++)

                    *outbuffer++ = alac->output_samples_buffer[ch][i] << 8;

                outbuffer += alac->channels - channels;

            }

            }

            break;

        case 32: {

            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;

            for (i = 0; i < alac->nb_samples; i++) {

                for (ch = 0; ch < channels; ch++)

                    *outbuffer++ = alac->output_samples_buffer[ch][i];

                outbuffer += alac->channels - channels;

            }

            }

            break;

        }

    }



    return 0;

}
",1533,"static int decode_element(AVCodecContext *avctx, void *data, int ch_index,

                          int channels)

{

    ALACContext *alac = avctx->priv_data;

    int has_size, bps, is_compressed, decorr_shift, decorr_left_weight, ret;

    uint32_t output_outspects;

    int n, ch;



    skip_bits(&alac->gb, 4);  /* element instance tag */

    skip_bits(&alac->gb, 12); /* unused header bits */



    /* the number of output samples is stored in the frame */

    has_size = get_bits1(&alac->gb);



    alac->extra_bits = get_bits(&alac->gb, 2) << 3;

    bps = alac->sample_size - alac->extra_bits + channels - 1;

    if (bps > 32) {

        av_log(avctx, AV_LOG_ERROR, ""bps is unsupported: %d
"", bps);

        return AVERROR_PATCHWELCOME;

    }



    /* whether the frame is compressed */

    is_compressed = !get_bits1(&alac->gb);



    if (has_size)

        output_outspects = get_bits_long(&alac->gb, 32);

    else

        output_outspects = alac->max_samples_per_frame;

    if (!output_samples || output_outspects > alac->max_samples_per_frame) {

        av_log(avctx, AV_LOG_ERROR, ""invalid samples per frame: %d
"",

               output_outspects);

        return AVERROR_INVALIDDATA;

    }

    if (!alac->nb_samples) {

        /* get output buffer */

        alac->frame.nb_samples = output_outspects;

        if ((ret = avctx->get_buffer(avctx, &alac->frame)) < 0) {

            av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
"");

            return ret;

        }

    } else if (output_outspects != alac->nb_samples) {

        av_log(avctx, AV_LOG_ERROR, ""sample count mismatch: %u != %d
"",

               output_outspects, alac->nb_samples);

        return AVERROR_INVALIDDATA;

    }

    alac->nb_samples = output_outspects;

    if (alac->direct_output) {

        for (ch = 0; ch < channels; ch++)

            alac->output_samples_buffer[ch] = (int32_t *)alac->frame.extended_data[ch_index + ch];

    }



    if (is_compressed) {

        int16_t lpc_coefs[2][32];

        int lpc_order[2];

        int prediction_type[2];

        int lpc_quant[2];

        int rice_history_mult[2];



        decorr_shift       = get_bits(&alac->gb, 8);

        decorr_left_weight = get_bits(&alac->gb, 8);



        for (ch = 0; ch < channels; ch++) {

            prediction_type[ch]   = get_bits(&alac->gb, 4);

            lpc_quant[ch]         = get_bits(&alac->gb, 4);

            rice_history_mult[ch] = get_bits(&alac->gb, 3);

            lpc_order[ch]         = get_bits(&alac->gb, 5);



            /* read the predictor table */

            for (n = lpc_order[ch] - 1; n >= 0; n--)

                lpc_coefs[ch][n] = get_sbits(&alac->gb, 16);

        }



        if (alac->extra_bits) {

            for (n = 0; n < alac->nb_samples; n++) {

                if(get_bits_left(&alac->gb) <= 0)

                    return -1;

                for (ch = 0; ch < channels; ch++)

                    alac->extra_bits_buffer[ch][n] = get_bits(&alac->gb, alac->extra_bits);

            }

        }

        for (ch = 0; ch < channels; ch++) {

            int ret=rice_decompress(alac, alac->predict_error_buffer[ch],

                            alac->nb_samples, bps,

                            rice_history_mult[ch] * alac->rice_history_mult / 4);

            if(ret<0)

                return ret;



            /* adaptive FIR filter */

            if (prediction_type[ch] == 15) {

                /* Prediction type 15 runs the adaptive FIR twice.

                 * The first pass uses the special-case coef_num = 31, while

                 * the second pass uses the coefs from the bitstream.

                 *

                 * However, this prediction type is not currently used by the

                 * reference encoder.

                 */

                lpc_prediction(alac->predict_error_buffer[ch],

                               alac->predict_error_buffer[ch],

                               alac->nb_samples, bps, NULL, 31, 0);

            } else if (prediction_type[ch] > 0) {

                av_log(avctx, AV_LOG_WARNING, ""unknown prediction type: %n
"",

                       prediction_type[ch]);

            }

            lpc_prediction(alac->predict_error_buffer[ch],

                           alac->output_samples_buffer[ch], alac->nb_samples,

                           bps, lpc_coefs[ch], lpc_order[ch], lpc_quant[ch]);

        }

    } else {

        /* not compressed, easy case */

        for (n = 0; n < alac->nb_samples; n++) {

            if(get_bits_left(&alac->gb) <= 0)

                return -1;

            for (ch = 0; ch < channels; ch++) {

                alac->output_samples_buffer[ch][n] =

                         get_sbits_long(&alac->gb, alac->sample_size);

            }

        }

        alac->extra_bits   = 0;

        decorr_shift       = 0;

        decorr_left_weight = 0;

    }



    if (channels == 2 && decorr_left_weight) {

        decorrelate_stereo(alac->output_samples_buffer, alac->nb_samples,

                           decorr_shift, decorr_left_weight);

    }



    if (alac->extra_bits) {

        append_extra_bits(alac->output_samples_buffer, alac->extra_bits_buffer,

                          alac->extra_bits, channels, alac->nb_samples);

    }



    if(av_sample_fmt_is_planar(avctx->sample_fmt)) {

    switch(alac->sample_size) {

    case 16: {

        for (ch = 0; ch < channels; ch++) {

            int16_t *outbuffer = (int16_t *)alac->frame.extended_data[ch_index + ch];

            for (n = 0; n < alac->nb_samples; n++)

                *outbuffer++ = alac->output_samples_buffer[ch][n];

        }}

        break;

    case 24: {

        for (ch = 0; ch < channels; ch++) {

            for (n = 0; n < alac->nb_samples; n++)

                alac->output_samples_buffer[ch][n] <<= 8;

        }}

        break;

    }

    }else{

        switch(alac->sample_size) {

        case 16: {

            int16_t *outbuffer = ((int16_t *)alac->frame.extended_data[0]) + ch_index;

            for (n = 0; n < alac->nb_samples; n++) {

                for (ch = 0; ch < channels; ch++)

                    *outbuffer++ = alac->output_samples_buffer[ch][n];

                outbuffer += alac->channels - channels;

            }

            }

            break;

        case 24: {

            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;

            for (n = 0; n < alac->nb_samples; n++) {

                for (ch = 0; ch < channels; ch++)

                    *outbuffer++ = alac->output_samples_buffer[ch][n] << 8;

                outbuffer += alac->channels - channels;

            }

            }

            break;

        case 32: {

            int32_t *outbuffer = ((int32_t *)alac->frame.extended_data[0]) + ch_index;

            for (n = 0; n < alac->nb_samples; n++) {

                for (ch = 0; ch < channels; ch++)

                    *outbuffer++ = alac->output_samples_buffer[ch][n];

                outbuffer += alac->channels - channels;

            }

            }

            break;

        }

    }



    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,data,ch_index,channels,alac,has_size,bps,is_compressed,decorr_shift,decorr_left_weight,ret,output_samples,i,ch",,,,200,"avctx:avctx,data:data,ch_index:ch_index,channels:channels,alac:alac,has_size:has_size,bps:bps,is_compressed:is_compressed,decorr_shift:decorr_shift,decorr_left_weight:decorr_left_weight,ret:ret,output_samples:output_outspects,i:n,ch:ch,",12,GA,752,0.4692571441332499,GA,
378,"int select_watchdog(const char *p)

{

    WatchdogTimerModel *model;

    QemuOpts *opts;



    /* -watchdog ? lists available devices and exits cleanly. */

    if (strcmp(p, ""?"") == 0) {

        LIST_FOREACH(model, &watchdog_list, entry) {

            fprintf(stderr, ""\t%s\t%s\n"",

                     model->wdt_name, model->wdt_description);

        }

        return 2;

    }



    LIST_FOREACH(model, &watchdog_list, entry) {

        if (strcasecmp(model->wdt_name, p) == 0) {

            /* add the device */

            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);

            qemu_opt_set(opts, ""driver"", p);

            return 0;

        }

    }



    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");

    LIST_FOREACH(model, &watchdog_list, entry) {

        fprintf(stderr, ""\t%s\t%s\n"",

                 model->wdt_name, model->wdt_description);

    }

    return 1;

}
",189,,LABEL_0,LABEL_0,LABEL_0,-1,"p,model,opts",,,,0,,0,GA,651,0.24517683585484823,failed,
379,"static int vorbis_floor1_decode(vorbis_context *vc,

                                vorbis_floor_data *vfu, float *vec)

{

    vorbis_floor1 *vf = &vfu->t1;

    GetBitContext *gb = &vc->gb;

    uint16_t range_v[4] = { 256, 128, 86, 64 };

    unsigned range = range_v[vf->multiplier - 1];

    uint16_t floor1_Y[258];

    uint16_t floor1_Y_final[258];

    int floor1_flag[258];

    unsigned class, cdim, cbits, csub, cval, offset, i, j;

    int book, adx, ady, dy, off, predicted, err;





    if (!get_bits1(gb)) // silence

        return 1;



// Read values (or differences) for the floor's points



    floor1_Y[0] = get_bits(gb, ilog(range - 1));

    floor1_Y[1] = get_bits(gb, ilog(range - 1));



    av_dlog(NULL, ""floor 0 Y %d floor 1 Y %d \n"", floor1_Y[0], floor1_Y[1]);



    offset = 2;

    for (i = 0; i < vf->partitions; ++i) {

        class = vf->partition_class[i];

        cdim   = vf->class_dimensions[class];

        cbits  = vf->class_subclasses[class];

        csub = (1 << cbits) - 1;

        cval = 0;



        av_dlog(NULL, ""Cbits %u\n"", cbits);



        if (cbits) // this reads all subclasses for this partition's class

            cval = get_vlc2(gb, vc->codebooks[vf->class_masterbook[class]].vlc.table,

                            vc->codebooks[vf->class_masterbook[class]].nb_bits, 3);



        for (j = 0; j < cdim; ++j) {

            book = vf->subclass_books[class][cval & csub];



            av_dlog(NULL, ""book %d Cbits %u cval %u  bits:%d\n"",

                    book, cbits, cval, get_bits_count(gb));



            cval = cval >> cbits;

            if (book > -1) {

                floor1_Y[offset+j] = get_vlc2(gb, vc->codebooks[book].vlc.table,

                vc->codebooks[book].nb_bits, 3);

            } else {

                floor1_Y[offset+j] = 0;

            }



            av_dlog(NULL, "" floor(%d) = %d \n"",

                    vf->list[offset+j].x, floor1_Y[offset+j]);

        }

        offset+=cdim;

    }



// Amplitude calculation from the differences



    floor1_flag[0] = 1;

    floor1_flag[1] = 1;

    floor1_Y_final[0] = floor1_Y[0];

    floor1_Y_final[1] = floor1_Y[1];



    for (i = 2; i < vf->x_list_dim; ++i) {

        unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs;



        low_neigh_offs  = vf->list[i].low;

        high_neigh_offs = vf->list[i].high;

        dy  = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs];  // render_point begin

        adx = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x;

        ady = FFABS(dy);

        err = ady * (vf->list[i].x - vf->list[low_neigh_offs].x);

        off = err / adx;

        if (dy < 0) {

            predicted = floor1_Y_final[low_neigh_offs] - off;

        } else {

            predicted = floor1_Y_final[low_neigh_offs] + off;

        } // render_point end



        val = floor1_Y[i];

        highroom = range-predicted;

        lowroom  = predicted;

        if (highroom < lowroom) {

            room = highroom * 2;

        } else {

            room = lowroom * 2;   // SPEC mispelling

        }

        if (val) {

            floor1_flag[low_neigh_offs]  = 1;

            floor1_flag[high_neigh_offs] = 1;

            floor1_flag[i]               = 1;

            if (val >= room) {

                if (highroom > lowroom) {

                    floor1_Y_final[i] = val - lowroom + predicted;

                } else {

                    floor1_Y_final[i] = predicted - val + highroom - 1;

                }

            } else {

                if (val & 1) {

                    floor1_Y_final[i] = predicted - (val + 1) / 2;

                } else {

                    floor1_Y_final[i] = predicted + val / 2;

                }

            }

        } else {

            floor1_flag[i]    = 0;

            floor1_Y_final[i] = predicted;

        }



        av_dlog(NULL, "" Decoded floor(%d) = %u / val %u\n"",

                vf->list[i].x, floor1_Y_final[i], val);

    }



// Curve synth - connect the calculated dots and convert from dB scale FIXME optimize ?



    ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, vec, vf->list[1].x);



    av_dlog(NULL, "" Floor decoded\n"");



    return 0;

}
",977,"static int vorbis_floor1_decode(vorbis_context *vc,

                                vorbis_floor_data *vfu, float *vec)

{

    vorbis_floor1 *vf = &vfu->t1;

    GetBitContext *gb = &vc->gb;

    uint16_t range_v[4] = { 256, 128, 86, 64 };

    unsigned range = range_v[vf->multiplier - 1];

    uint16_t floor1_Y[258];

    uint16_t floor1_Y_final[258];

    int floor1_flag[258];

    unsigned class, cdim, cbits, csub, aceval, offset, i, j;

    int book, sdp, ady, dy, op, predicted, err;





    if (!get_bits1(gb)) // silence

        return 1;



// Read values (or differences) for the floor's points



    floor1_Y[0] = get_bits(gb, ilog(range - 1));

    floor1_Y[1] = get_bits(gb, ilog(range - 1));



    av_dlog(NULL, ""floor 0 Y %d floor 1 Y %d 
"", floor1_Y[0], floor1_Y[1]);



    offset = 2;

    for (i = 0; i < vf->partitions; ++i) {

        class = vf->partition_class[i];

        cdim   = vf->class_dimensions[class];

        cbits  = vf->class_subclasses[class];

        csub = (1 << cbits) - 1;

        aceval = 0;



        av_dlog(NULL, ""Cbits %u
"", cbits);



        if (cbits) // this reads all subclasses for this partition's class

            aceval = get_vlc2(gb, vc->codebooks[vf->class_masterbook[class]].vlc.table,

                            vc->codebooks[vf->class_masterbook[class]].nb_bits, 3);



        for (j = 0; j < cdim; ++j) {

            bobook vf->subclass_books[class][aceval & csub];



            av_dlog(NULL, ""bobookd Cbits %u aceval %u  bits:%d
"",

                    bobookcbits, aceval, get_bits_count(gb));



            aceval = aceval >> cbits;

            if (book > -1) {

                floor1_Y[offset+j] = get_vlc2(gb, vc->codebooks[book].vlc.table,

                vc->codebooks[book].nb_bits, 3);

            } else {

                floor1_Y[offset+j] = 0;

            }



            av_dlog(NULL, "" floor(%d) = %d 
"",

                    vf->list[offset+j].x, floor1_Y[offset+j]);

        }

        offset+=cdim;

    }



// Amplitude calculation from the differences



    floor1_flag[0] = 1;

    floor1_flag[1] = 1;

    floor1_Y_final[0] = floor1_Y[0];

    floor1_Y_final[1] = floor1_Y[1];



    for (i = 2; i < vf->x_list_dim; ++i) {

        unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs;



        low_neigh_offs  = vf->list[i].low;

        high_neigh_offs = vf->list[i].high;

        dy  = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs];  // render_point begin

        sdp = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x;

        ady = FFABS(dy);

        err = ady * (vf->list[i].x - vf->list[low_neigh_offs].x);

        op = err / sdp;

        if (dy < 0) {

           predictedd = floor1_Y_final[low_neigh_offs] - op;

        } else {

           predictedd = floor1_Y_final[low_neigh_offs] + op;

        } // render_point end



        val = floor1_Y[i];

        highroom = range-predicted;

        lowroom  = predicted;

        if (highroom < lowroom) {

            room = highroom * 2;

        } else {

            room = lowroom * 2;   // SPEC mispelling

        }

        if (val) {

            floor1_flag[low_neigh_offs]  = 1;

            floor1_flag[high_neigh_offs] = 1;

            floor1_flag[i]               = 1;

            if (val >= room) {

                if (highroom > lowroom) {

                    floor1_Y_final[i] = val - lowroom + predicted;

                } else {

                    floor1_Y_final[i] = predicted - val + highroom - 1;

                }

            } else {

                if (val & 1) {

                    floor1_Y_final[i] = predicted - (val + 1) / 2;

                } else {

                    floor1_Y_final[i] = predicted + val / 2;

                }

            }

        } else {

            floor1_flag[i]    = 0;

            floor1_Y_final[i] = predicted;

        }



        av_dlog(NULL, "" Decoded floor(%d) = %u / val %u
"",

                vf->list[i].x, floor1_Y_final[i], val);

    }



// Curve synth - connect the calculated dots and convert from dB scale FIXME optimize ?



    ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, vec, vf->list[1].x);



    av_dlog(NULL, "" Floor decoded
"");



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"vc,vfu,vec,vf,gb,range_v,floor1_Y,floor1_Y_final,floor1_flag,class,cdim,cbits,csub,cval,offset,i,j,book,adx,ady,dy,off,predicted,err",,,,160,"vc:vc,vfu:vfu,vec:vec,vf:vf,gb:gb,range_v:range_v,floor1_Y:floor1_Y,floor1_Y_final:floor1_Y_final,floor1_flag:floor1_flag,class:class,cdim:cdim,cbits:cbits,csub:csub,cval:aceval,offset:offset,i:i,j:j,book:book,adx:sdp,ady:ady,dy:dy,off:op,predicted:predicted,err:err,",21,GA,999,0.4818126916885376,GA,
380,"static void monitor_protocol_emitter(Monitor *mon, QObject *data)

{

    QDict *qmp;



    qmp = qdict_new();



    if (!monitor_has_error(mon)) {

        /* success response */

        if (data) {

            assert(qobject_type(data) == QTYPE_QDICT);

            qobject_incref(data);

            qdict_put_obj(qmp, ""return"", data);

        } else {

            /* return an empty QDict by default */

            qdict_put(qmp, ""return"", qdict_new());

        }

    } else {

        /* error response */

        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));

        qdict_put(qmp, ""error"", mon->error->error);

        QINCREF(mon->error->error);

        QDECREF(mon->error);

        mon->error = NULL;

    }



    if (mon->mc->id) {

        qdict_put_obj(qmp, ""id"", mon->mc->id);

        mon->mc->id = NULL;

    }



    monitor_json_emitter(mon, QOBJECT(qmp));

    QDECREF(qmp);

}
",219,,LABEL_0,LABEL_0,LABEL_0,-1,"mon,data,qmp",,,,0,,0,GA,758,0.28361141284306846,failed,
381,"static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)

{

    CommitBlockJob *s = container_of(job, CommitBlockJob, common);



    if (speed < 0) {

        error_setg(errp, QERR_INVALID_PARAMETER, ""speed"");

        return;

    }

    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);

}
",65,,LABEL_1,LABEL_0,,-4,"job,speed,errp,s",,,,0,,0,Greedy,1,0.0004634817441304525,,
382,"static void ppc_cpu_class_init(ObjectClass *oc, void *data)

{

    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);

    CPUClass *cc = CPU_CLASS(oc);

    DeviceClass *dc = DEVICE_CLASS(oc);



    pcc->parent_realize = dc->realize;

    pcc->pvr = CPU_POWERPC_DEFAULT_MASK;

    pcc->pvr_mask = CPU_POWERPC_DEFAULT_MASK;

    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_always;

    dc->realize = ppc_cpu_realizefn;

    dc->unrealize = ppc_cpu_unrealizefn;



    pcc->parent_reset = cc->reset;

    cc->reset = ppc_cpu_reset;



    cc->class_by_name = ppc_cpu_class_by_name;

    cc->has_work = ppc_cpu_has_work;

    cc->do_interrupt = ppc_cpu_do_interrupt;

    cc->dump_state = ppc_cpu_dump_state;

    cc->dump_statistics = ppc_cpu_dump_statistics;

    cc->set_pc = ppc_cpu_set_pc;

    cc->gdb_read_register = ppc_cpu_gdb_read_register;

    cc->gdb_write_register = ppc_cpu_gdb_write_register;

#ifdef CONFIG_USER_ONLY

    cc->handle_mmu_fault = ppc_cpu_handle_mmu_fault;

#else

    cc->get_phys_page_debug = ppc_cpu_get_phys_page_debug;

    cc->vmsd = &vmstate_ppc_cpu;

#if defined(TARGET_PPC64)

    cc->write_elf64_note = ppc64_cpu_write_elf64_note;

    cc->write_elf64_qemunote = ppc64_cpu_write_elf64_qemunote;

#endif

#endif



    cc->gdb_num_core_regs = 71;



#ifdef USE_APPLE_GDB

    cc->gdb_read_register = ppc_cpu_gdb_read_register_apple;

    cc->gdb_write_register = ppc_cpu_gdb_write_register_apple;

    cc->gdb_num_core_regs = 71 + 32;

#endif



#if defined(TARGET_PPC64)

    cc->gdb_core_xml_file = ""power64-core.xml"";

#else

    cc->gdb_core_xml_file = ""power-core.xml"";

#endif

#ifndef CONFIG_USER_ONLY

    cc->virtio_is_big_endian = ppc_cpu_is_big_endian;

#endif



    dc->fw_name = ""PowerPC,UNKNOWN"";

}
",254,"static void ppc_cpu_class_init(ObjectClass *oc, void *co)

{

    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);

    CPUClass *bb = CPU_CLASS(oc);

    DeviceClass *acc = DEVICE_CLASS(oc);



    pcc->parent_realize = acc->realize;

    pcc->pvr = CPU_POWERPC_DEFAULT_MASK;

    pcc->pvr_mask = CPU_POWERPC_DEFAULT_MASK;

    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_always;

    acc->realize = ppc_cpu_realizefn;

    acc->unrealize = ppc_cpu_unrealizefn;



    pcc->parent_reset = bb->reset;

    bb->reset = ppc_cpu_reset;



    bb->class_by_name = ppc_cpu_class_by_name;

    bb->has_work = ppc_cpu_has_work;

    bb->do_interrupt = ppc_cpu_do_interrupt;

    bb->dump_state = ppc_cpu_dump_state;

    bb->dump_statistics = ppc_cpu_dump_statistics;

    bb->set_pc = ppc_cpu_set_pc;

    bb->gdb_read_register = ppc_cpu_gdb_read_register;

    bb->gdb_write_register = ppc_cpu_gdb_write_register;

#ifdef CONFIG_USER_ONLY

    bb->handle_mmu_fault = ppc_cpu_handle_mmu_fault;

#else

    bb->get_phys_page_debug = ppc_cpu_get_phys_page_debug;

    bb->vmsd = &vmstate_ppc_cpu;

#if defined(TARGET_PPC64)

    bb->write_elf64_note = ppc64_cpu_write_elf64_note;

    bb->write_elf64_qemunote = ppc64_cpu_write_elf64_qemunote;

#endif

#endif



    bb->gdb_num_core_regs = 71;



#ifdef USE_APPLE_GDB

    bb->gdb_read_register = ppc_cpu_gdb_read_register_apple;

    bb->gdb_write_register = ppc_cpu_gdb_write_register_apple;

    bb->gdb_num_core_regs = 71 + 32;

#endif



#if defined(TARGET_PPC64)

    bb->gdb_core_xml_file = ""power64-core.xml"";

#else

    bb->gdb_core_xml_file = ""power-core.xml"";

#endif

#ifndef CONFIG_USER_ONLY

    bb->virtio_is_big_endian = ppc_cpu_is_big_endian;

#endif



    acc->fw_name = ""PowerPC,UNKNOWN"";

}
",LABEL_0,LABEL_0,LABEL_1,1,"oc,data,pcc,cc,dc",,,,10,"oc:oc,data:co,pcc:pcc,cc:bb,dc:acc,",2,GA,271,0.10411632855733235,GA,
383,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    afq->avctx             = avctx;

    afq->next_pts          = AV_NOPTS_VALUE;

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}
",55,,LABEL_0,LABEL_0,LABEL_0,-1,"avctx,afq",,,,0,,0,GA,414,0.1464280406634013,failed,
384,"static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)

{

    int i;

    float (*output)[256] = ctx->audio_block.block_output;



    for (i = 0; i < 256; i++)

        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);

    memset(output[2], 0, sizeof(output[2]));

    memset(output[3], 0, sizeof(output[3]));

    memset(output[4], 0, sizeof(output[4]));

}
",132,,LABEL_0,LABEL_0,LABEL_0,-1,"ctx,i,output",,,,0,,0,GA,673,0.24311848084131876,failed,
385,"static av_cold int tdsc_init(AVCodecContext *avctx)

{

    TDSCContext *ctx = avctx->priv_data;

    const AVCodec *codec;

    int ret;



    avctx->pix_fmt = AV_PIX_FMT_BGR24;



    /* These needs to be set to estimate buffer and frame size */

    if (!(avctx->width && avctx->height)) {

        av_log(avctx, AV_LOG_ERROR, ""Video size not set.\n"");

        return AVERROR_INVALIDDATA;

    }



    /* This value should be large enough for a RAW-only frame plus headers */

    ctx->deflatelen = avctx->width * avctx->height * (3 + 1);

    ret = av_reallocp(&ctx->deflatebuffer, ctx->deflatelen);

    if (ret < 0)

        return ret;



    /* Allocate reference and JPEG frame */

    ctx->refframe = av_frame_alloc();

    ctx->jpgframe = av_frame_alloc();

    if (!ctx->refframe || !ctx->jpgframe)

        return AVERROR(ENOMEM);



    /* Prepare everything needed for JPEG decoding */

    codec = avcodec_find_decoder(AV_CODEC_ID_MJPEG);

    if (!codec)

        return AVERROR_BUG;

    ctx->jpeg_avctx = avcodec_alloc_context3(codec);

    if (!ctx->jpeg_avctx)

        return AVERROR(ENOMEM);

    ctx->jpeg_avctx->flags = avctx->flags;

    ctx->jpeg_avctx->flags2 = avctx->flags2;

    ctx->jpeg_avctx->dct_algo = avctx->dct_algo;

    ctx->jpeg_avctx->idct_algo = avctx->idct_algo;;

    ret = avcodec_open2(ctx->jpeg_avctx, codec, NULL);

    if (ret < 0)

        return ret;



    /* Set the output pixel format on the reference frame */

    ctx->refframe->format = avctx->pix_fmt;



    return 0;

}
",352,,LABEL_1,LABEL_0,,-4,"avctx,ctx,codec,ret",,,,0,,0,Greedy,1,0.0006238977114359538,,
386,"void st_flush_trace_buffer(void)

{

    if (trace_file_enabled) {

        flush_trace_file();

    }



    /* Discard written trace records */

    trace_idx = 0;

}
",29,,LABEL_1,LABEL_0,,-4,,,,,0,,0,Greedy,1,0.0004346092542012533,,
387,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",190,"static void vc1_inv_trans_8x8_dc_c(uint8_t *tmp, int linesize, DCTELEM *block)

{

    int oi;

    int dc = block[0];

    const uint8_t *am;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    am = ff_cropTbl + MAX_NEG_CROP + dc;

    for(oi = 0; oi < 8; oi++){

        tmp[0] =amm[tmp[0]];

        tmp[1] =amm[tmp[1]];

        tmp[2] =amm[tmp[2]];

        tmp[3] =amm[tmp[3]];

        tmp[4] =amm[tmp[4]];

        tmp[5] =amm[tmp[5]];

        tmp[6] =amm[tmp[6]];

        tmp[7] =amm[tmp[7]];

        tmp += linesize;

    }

}
",LABEL_1,LABEL_1,LABEL_0,1,"dest,linesize,block,i,cm",,,,4,"dest:tmp,linesize:linesize,block:block,i:oi,cm:am,",2,GA,293,0.10986234347025553,GA,
388,"static void collie_init(MachineState *machine)

{

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cmdline = machine->kernel_cmdline;

    const char *initrd_filename = machine->initrd_filename;

    StrongARMState *s;

    DriveInfo *dinfo;

    MemoryRegion *sysmem = get_system_memory();



    if (!cpu_model) {

        cpu_model = ""sa1110"";

    }



    s = sa1110_init(sysmem, collie_binfo.ram_size, cpu_model);



    dinfo = drive_get(IF_PFLASH, 0, 0);

    pflash_cfi01_register(SA_CS0, NULL, ""collie.fl1"", 0x02000000,

                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,

                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);



    dinfo = drive_get(IF_PFLASH, 0, 1);

    pflash_cfi01_register(SA_CS1, NULL, ""collie.fl2"", 0x02000000,

                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,

                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);



    sysbus_create_simple(""scoop"", 0x40800000, NULL);



    collie_binfo.kernel_filename = kernel_filename;

    collie_binfo.kernel_cmdline = kernel_cmdline;

    collie_binfo.initrd_filename = initrd_filename;

    collie_binfo.board_id = 0x208;

    arm_load_kernel(s->cpu, &collie_binfo);

}
",243,,LABEL_0,LABEL_0,LABEL_0,-1,"machine,cpu_model,kernel_filename,kernel_cmdline,initrd_filename,s,dinfo,sysmem",,,,0,,0,GA,1581,0.6028524716695149,failed,
389,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}
",33,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *ichre = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&ichre->chr_write_lock);

    return ichre;

}
",LABEL_0,LABEL_0,LABEL_1,1,chr,,,,0,"chr:ichre,",0,GA,65,0.023059805234273274,GA,
390,"target_phys_addr_t cpu_get_phys_page_debug(CPUState *env, target_ulong addr)

{

    target_ulong pde_addr, pte_addr;

    uint64_t pte;

    target_phys_addr_t paddr;

    uint32_t page_offset;

    int page_size;



    if (env->cr[4] & CR4_PAE_MASK) {

        target_ulong pdpe_addr;

        uint64_t pde, pdpe;



#ifdef TARGET_X86_64

        if (env->hflags & HF_LMA_MASK) {

            uint64_t pml4e_addr, pml4e;

            int32_t sext;



            /* test virtual address sign extension */

            sext = (int64_t)addr >> 47;

            if (sext != 0 && sext != -1)

                return -1;



            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) &

                env->a20_mask;

            pml4e = ldq_phys(pml4e_addr);

            if (!(pml4e & PG_PRESENT_MASK))

                return -1;



            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &

                env->a20_mask;

            pdpe = ldq_phys(pdpe_addr);

            if (!(pdpe & PG_PRESENT_MASK))

                return -1;

        } else

#endif

        {

            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) &

                env->a20_mask;

            pdpe = ldq_phys(pdpe_addr);

            if (!(pdpe & PG_PRESENT_MASK))

                return -1;

        }



        pde_addr = ((pdpe & ~0xfff) + (((addr >> 21) & 0x1ff) << 3)) &

            env->a20_mask;

        pde = ldq_phys(pde_addr);

        if (!(pde & PG_PRESENT_MASK)) {

            return -1;

        }

        if (pde & PG_PSE_MASK) {

            /* 2 MB page */

            page_size = 2048 * 1024;

            pte = pde & ~( (page_size - 1) & ~0xfff); /* align to page_size */

        } else {

            /* 4 KB page */

            pte_addr = ((pde & ~0xfff) + (((addr >> 12) & 0x1ff) << 3)) &

                env->a20_mask;

            page_size = 4096;

            pte = ldq_phys(pte_addr);

        }

        if (!(pte & PG_PRESENT_MASK))

            return -1;

    } else {

        uint32_t pde;



        if (!(env->cr[0] & CR0_PG_MASK)) {

            pte = addr;

            page_size = 4096;

        } else {

            /* page directory entry */

            pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) & env->a20_mask;

            pde = ldl_phys(pde_addr);

            if (!(pde & PG_PRESENT_MASK))

                return -1;

            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {

                pte = pde & ~0x003ff000; /* align to 4MB */

                page_size = 4096 * 1024;

            } else {

                /* page directory entry */

                pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & env->a20_mask;

                pte = ldl_phys(pte_addr);

                if (!(pte & PG_PRESENT_MASK))

                    return -1;

                page_size = 4096;

            }

        }

        pte = pte & env->a20_mask;

    }



    page_offset = (addr & TARGET_PAGE_MASK) & (page_size - 1);

    paddr = (pte & TARGET_PAGE_MASK) + page_offset;

    return paddr;

}
",658,,LABEL_1,LABEL_0,,-4,"env,addr,pde_addr,pte_addr,pte,paddr,page_offset,page_size,pdpe_addr,pde,pdpe,pml4e_addr,pml4e,sext",,,,0,,0,Greedy,1,0.0008005142211914062,,
391,"uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,

                      uint64_t cpu_addr)

{

    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;



    HELPER_LOG(""%s: %016"" PRIx64 "" %08x %016"" PRIx64 ""\n"",

               __func__, order_code, r1, cpu_addr);



    /* Remember: Use ""R1 or R1 + 1, whichever is the odd-numbered register""

       as parameter (input). Status (output) is always R1. */



    switch (order_code) {

    case SIGP_SET_ARCH:

        /* switch arch */

        break;

    case SIGP_SENSE:

        /* enumerate CPU status */

        if (cpu_addr) {

            /* XXX implement when SMP comes */

            return 3;

        }

        env->regs[r1] &= 0xffffffff00000000ULL;

        cc = 1;

        break;

#if !defined(CONFIG_USER_ONLY)

    case SIGP_RESTART:

        qemu_system_reset_request();

        cpu_loop_exit(CPU(s390_env_get_cpu(env)));

        break;

    case SIGP_STOP:

        qemu_system_shutdown_request();

        cpu_loop_exit(CPU(s390_env_get_cpu(env)));

        break;

#endif

    default:

        /* unknown sigp */

        fprintf(stderr, ""XXX unknown sigp: 0x%"" PRIx64 ""\n"", order_code);

        cc = SIGP_CC_NOT_OPERATIONAL;

    }



    return cc;

}
",196,,LABEL_0,LABEL_0,LABEL_0,-1,"env,order_code,r1,cpu_addr",,,,0,,0,GA,565,0.217583962281545,failed,
392,"FDCtrl *fdctrl_init_isa(DriveInfo **fds)

{

    ISADevice *dev;



    dev = isa_create(""isa-fdc"");

    if (fds[0]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveA"", fds[0]->bdrv);

    }

    if (fds[1]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveB"", fds[1]->bdrv);

    }

    if (qdev_init(&dev->qdev) < 0)

        return NULL;

    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);

}
",110,"FDCtrl *fdctrl_init_isa(DriveInfo **cfrs)

{

    ISADevice *dem;



    dem = isa_create(""isa-fdc"");

    if (cfrs[0]) {

        qdev_prop_set_drive_nofail(&ddem>qdev, ""driveA"", cfrs[0]->bdrv);

    }

    if (cfrs[1]) {

        qdev_prop_set_drive_nofail(&ddem>qdev, ""driveB"", cfrs[1]->bdrv);

    }

    if (qdev_init(&dem->qdev) < 0)

        return NULL;

    return &(DO_UPCAST(FDCtrlISABus, busdev, dem)->state);

}
",LABEL_1,LABEL_1,LABEL_0,1,"fds,dev",,,,0,"fds:cfrs,dev:dem,",0,GA,147,0.05260701974232992,GA,
393,"void avfilter_link_free(AVFilterLink **link)

{

    if (!*link)

        return;



    if ((*link)->pool) {

        int i;

        for (i = 0; i < POOL_SIZE; i++) {

            if ((*link)->pool->pic[i]) {

                AVFilterBufferRef *picref = (*link)->pool->pic[i];

                /* free buffer: picrefs stored in the pool are not

                 * supposed to contain a free callback */

                av_freep(&picref->buf->data[0]);

                av_freep(&picref->buf);



                av_freep(&picref->audio);

                av_freep(&picref->video);

                av_freep(&picref);

            }

        }

        av_freep(&(*link)->pool);

    }

    av_freep(link);

}
",168,,LABEL_1,LABEL_0,,-4,"link,i,picref",,,,0,,0,Greedy,1,0.0005246241887410482,,
394,"static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)

{

    *range = 8 * (1 << (f_code - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)

	*range *= 2;



    if (s->unrestricted_mv) {

        *xmin = -16;

        *ymin = -16;

        if (s->h263_plus)

            *range *= 2;

        if(s->avctx->codec->id!=CODEC_ID_MPEG4){

            *xmax = s->mb_width*16;

            *ymax = s->mb_height*16;

        }else {

            *xmax = s->width;

            *ymax = s->height;

        }

    } else {

        *xmin = 0;

        *ymin = 0;

        *xmax = s->mb_width*16 - 16;

        *ymax = s->mb_height*16 - 16;

    }

}
",208,"static inline void get_limits(MpegEncContext *sym, int *range, int *yid, int *chmit, int *mxend, int *mxazon, int f_code)

{

    *range = 8 * (1 << (f_code - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (sym->out_format == FMT_H263 && !s->h263_msmpeg4)

	*range *= 2;



    if (sym->unrestricted_mv) {

        *yid = -16;

        *chmit = -16;

        if (sym->h263_plus)

            *range *= 2;

        if(sym->avctx->codec->id!=CODEC_ID_MPEG4){

            *xmmxend sym->mb_width*16;

            *ymmxazon sym->mb_height*16;

        }else {

            *xmmxend sym->width;

            *ymmxazon sym->height;

        }

    } else {

        *yid = 0;

        *chmit = 0;

        *xmmxend sym->mb_width*16 - 16;

        *ymmxazon sym->mb_height*16 - 16;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,range,xmin,ymin,xmax,ymax,f_code",,,,6,"s:sym,range:range,xmin:yid,ymin:chmit,xmax:mxend,ymax:mxazon,f_code:f_code,",2,GA,330,0.12354028224945068,GA,
395,"char *vnc_display_local_addr(const char *id)

{

    VncDisplay *vs = vnc_display_find(id);




    return vnc_socket_local_addr(""%s:%s"", vs->lsock);

}",33,,LABEL_1,LABEL_1,LABEL_1,-1,"id,vs",,,,0,,0,GA,375,0.1314524014790853,failed,
396,"void ide_atapi_cmd(IDEState *s)

{

    uint8_t *buf;



    buf = s->io_buffer;

#ifdef DEBUG_IDE_ATAPI

    {

        int i;

        printf(""ATAPI limit=0x%x packet:"", s->lcyl | (s->hcyl << 8));

        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {

            printf("" %02x"", buf[i]);

        }

        printf(""\n"");

    }

#endif

    /*

     * If there's a UNIT_ATTENTION condition pending, only command flagged with

     * ALLOW_UA are allowed to complete. with other commands getting a CHECK

     * condition response unless a higher priority status, defined by the drive

     * here, is pending.

     */

    if (s->sense_key == UNIT_ATTENTION &&

        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {

        ide_atapi_cmd_check_status(s);

        return;

    }

    /*

     * When a CD gets changed, we have to report an ejected state and

     * then a loaded state to guests so that they detect tray

     * open/close and media change events.  Guests that do not use

     * GET_EVENT_STATUS_NOTIFICATION to detect such tray open/close

     * states rely on this behavior.

     */

    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&

        !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {



        if (s->cdrom_changed == 1) {

            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);

            s->cdrom_changed = 2;

        } else {

            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);

            s->cdrom_changed = 0;

        }



        return;

    }



    /* Report a Not Ready condition if appropriate for the command */

    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&

        (!media_present(s) || !bdrv_is_inserted(s->bs)))

    {

        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);

        return;

    }



    /* Execute the command */

    if (atapi_cmd_table[s->io_buffer[0]].handler) {

        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);

        return;

    }



    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);

}
",434,,LABEL_0,LABEL_0,LABEL_0,-1,"s,buf,i",,,,0,,0,GA,655,0.273443341255188,failed,
397,"static int wsvqa_read_header(AVFormatContext *s,

                             AVFormatParameters *ap)

{

    WsVqaDemuxContext *wsvqa = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *st;

    unsigned char *header;

    unsigned char scratch[VQA_PREAMBLE_SIZE];

    unsigned int chunk_tag;

    unsigned int chunk_size;



    /* initialize the video decoder stream */

    st = av_new_stream(s, 0);

    if (!st)

        return AVERROR(ENOMEM);

    av_set_pts_info(st, 33, 1, VQA_FRAMERATE);

    wsvqa->video_stream_index = st->index;

    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

    st->codec->codec_id = CODEC_ID_WS_VQA;

    st->codec->codec_tag = 0;  /* no fourcc */



    /* skip to the start of the VQA header */

    avio_seek(pb, 20, SEEK_SET);



    /* the VQA header needs to go to the decoder */

    st->codec->extradata_size = VQA_HEADER_SIZE;

    st->codec->extradata = av_mallocz(VQA_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

    header = (unsigned char *)st->codec->extradata;

    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=

        VQA_HEADER_SIZE) {

        av_free(st->codec->extradata);

        return AVERROR(EIO);

    }

    st->codec->width = AV_RL16(&header[6]);

    st->codec->height = AV_RL16(&header[8]);



    /* initialize the audio decoder stream for VQA v1 or nonzero samplerate */

    if (AV_RL16(&header[24]) || (AV_RL16(&header[0]) == 1 && AV_RL16(&header[2]) == 1)) {

        st = av_new_stream(s, 0);

        if (!st)

            return AVERROR(ENOMEM);

        av_set_pts_info(st, 33, 1, VQA_FRAMERATE);

        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

        if (AV_RL16(&header[0]) == 1)

            st->codec->codec_id = CODEC_ID_WESTWOOD_SND1;

        else

            st->codec->codec_id = CODEC_ID_ADPCM_IMA_WS;

        st->codec->codec_tag = 0;  /* no tag */

        st->codec->sample_rate = AV_RL16(&header[24]);

        if (!st->codec->sample_rate)

            st->codec->sample_rate = 22050;

        st->codec->channels = header[26];

        if (!st->codec->channels)

            st->codec->channels = 1;

        st->codec->bits_per_coded_sample = 16;

        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *

            st->codec->bits_per_coded_sample / 4;

        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;



        wsvqa->audio_stream_index = st->index;

        wsvqa->audio_samplerate = st->codec->sample_rate;

        wsvqa->audio_channels = st->codec->channels;

        wsvqa->audio_frame_counter = 0;

    }



    /* there are 0 or more chunks before the FINF chunk; iterate until

     * FINF has been skipped and the file will be ready to be demuxed */

    do {

        if (avio_read(pb, scratch, VQA_PREAMBLE_SIZE) != VQA_PREAMBLE_SIZE) {

            av_free(st->codec->extradata);

            return AVERROR(EIO);

        }

        chunk_tag = AV_RB32(&scratch[0]);

        chunk_size = AV_RB32(&scratch[4]);



        /* catch any unknown header tags, for curiousity */

        switch (chunk_tag) {

        case CINF_TAG:

        case CINH_TAG:

        case CIND_TAG:

        case PINF_TAG:

        case PINH_TAG:

        case PIND_TAG:

        case FINF_TAG:

        case CMDS_TAG:

            break;



        default:

            av_log (s, AV_LOG_ERROR, "" note: unknown chunk seen (%c%c%c%c)\n"",

                scratch[0], scratch[1],

                scratch[2], scratch[3]);

            break;

        }



        avio_skip(pb, chunk_size);

    } while (chunk_tag != FINF_TAG);



    return 0;

}
",798,,LABEL_1,LABEL_0,,-4,"s,ap,wsvqa,pb,st,header,scratch,chunk_tag,chunk_size",,,,0,,0,Greedy,1,0.0008802294731140136,,
398,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",137,,LABEL_1,LABEL_1,LABEL_1,-1,"ctxt,token,ret",,,,0,,0,GA,678,0.2464230457941691,failed,
399,"static inline void idct_col(int16_t *blk, const uint8_t *quant)

{

    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;

    int t10, t11, t12, t13;

    int s0, s1, s2, s3, s4, s5, s6, s7;



    s0 = (int) blk[0 * 8] * quant[0 * 8];

    s1 = (int) blk[1 * 8] * quant[1 * 8];

    s2 = (int) blk[2 * 8] * quant[2 * 8];

    s3 = (int) blk[3 * 8] * quant[3 * 8];

    s4 = (int) blk[4 * 8] * quant[4 * 8];

    s5 = (int) blk[5 * 8] * quant[5 * 8];

    s6 = (int) blk[6 * 8] * quant[6 * 8];

    s7 = (int) blk[7 * 8] * quant[7 * 8];



    t0  =  (s3 * 19266 + s5 * 12873) >> 15;

    t1  =  (s5 * 19266 - s3 * 12873) >> 15;

    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;

    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;

    t4  = t0 * 2 + t2;

    t5  = t1 * 2 + t3;

    t6  = t2 - t3;

    t7  = t3 * 2 + t6;

    t8  = (t6 * 11585) >> 14;

    t9  = (t7 * 11585) >> 14;

    tA  = (s2 * 8867 - s6 * 21407) >> 14;

    tB  = (s6 * 8867 + s2 * 21407) >> 14;

    tC  = (s0 >> 1) - (s4 >> 1);

    tD  = (s4 >> 1) * 2 + tC;

    tE  = tC - (tA >> 1);

    tF  = tD - (tB >> 1);

    t10 = tF - t5;

    t11 = tE - t8;

    t12 = tE + (tA >> 1) * 2 - t9;

    t13 = tF + (tB >> 1) * 2 - t4;



    blk[0 * 8] = t13 + t4 * 2;

    blk[1 * 8] = t12 + t9 * 2;

    blk[2 * 8] = t11 + t8 * 2;

    blk[3 * 8] = t10 + t5 * 2;

    blk[4 * 8] = t10;

    blk[5 * 8] = t11;

    blk[6 * 8] = t12;

    blk[7 * 8] = t13;

}
",544,"static inline void idct_col(int16_t *blk, const uint8_t *local)

{

    int t0, t1, t2, ta5, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;

    int t10, t11, t12, t13;

    int s0, s1, s2, s3, s4, s5, s6, s7;



    s0 = (int) blk[0 * 8] * local[0 * 8];

    s1 = (int) blk[1 * 8] * local[1 * 8];

    s2 = (int) blk[2 * 8] * local[2 * 8];

    s3 = (int) blk[3 * 8] * local[3 * 8];

    s4 = (int) blk[4 * 8] * local[4 * 8];

    s5 = (int) blk[5 * 8] * local[5 * 8];

    s6 = (int) blk[6 * 8] * local[6 * 8];

    s7 = (int) blk[7 * 8] * local[7 * 8];



    t0  =  (s3 * 19266 + s5 * 12873) >> 15;

    t1  =  (s5 * 19266 - s3 * 12873) >> 15;

    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;

    ta5  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;

    t4  = t0 * 2 + t2;

    tt5 = t1 * 2 + ta5;

    tt6 = t2 - ta5;

    tt7 = ta5 * 2 + t6;

    t8  = (t6 * 11585) >> 14;

    t9  = (t7 * 11585) >> 14;

    tA  = (s2 * 8867 - s6 * 21407) >> 14;

    tB  = (s6 * 8867 + s2 * 21407) >> 14;

    tC  = (s0 >> 1) - (s4 >> 1);

    tD  = (s4 >> 1) * 2 + tC;

    tE  = tC - (tA >> 1);

    tF  = tD - (tB >> 1);

    t10 = tF - t5;

    t11 = tE - t8;

    t12 = tE + (tA >> 1) * 2 - t9;

    t13 = tF + (tB >> 1) * 2 - t4;



    blk[0 * 8] = t13 + t4 * 2;

    blk[1 * 8] = t12 + t9 * 2;

    blk[2 * 8] = t11 + t8 * 2;

    blk[3 * 8] = t10 + t5 * 2;

    blk[4 * 8] = t10;

    blk[5 * 8] = t11;

    blk[6 * 8] = t12;

    blk[7 * 8] = t13;

}
",LABEL_1,LABEL_1,LABEL_0,1,"blk,quant,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,tA,tB,tC,tD,tE,tF,t10,t11,t12,t13,s0,s1,s2,s3,s4,s5,s6,s7",,,,122,"blk:blk,quant:local,t0:t0,t1:t1,t2:t2,t3:ta5,t4:t4,t5:t5,t6:t6,t7:t7,t8:t8,t9:t9,tA:tA,tB:tB,tC:tC,tD:tD,tE:tE,tF:tF,t10:t10,t11:t11,t12:t12,t13:t13,s0:s0,s1:s1,s2:s2,s3:s3,s4:s4,s5:s5,s6:s6,s7:s7,",28,GA,984,0.39389488697052,GA,
400,"static void reset(DeviceState *d)

{

    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);

    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);



    trace_spapr_drc_reset(spapr_drc_index(drc));



    g_free(drc->ccs);

    drc->ccs = NULL;



    /* immediately upon reset we can safely assume DRCs whose devices

     * are pending removal can be safely removed, and that they will

     * subsequently be left in an ISOLATED state. move the DRC to this

     * state in these cases (which will in turn complete any pending

     * device removals)

     */

    if (drc->awaiting_release) {

        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);

        /* generally this should also finalize the removal, but if the device

         * hasn't yet been configured we normally defer removal under the

         * assumption that this transition is taking place as part of device

         * configuration. so check if we're still waiting after this, and

         * force removal if we are

         */

        if (drc->awaiting_release) {

            spapr_drc_detach(drc, DEVICE(drc->dev), NULL);

        }



        /* non-PCI devices may be awaiting a transition to UNUSABLE */

        if (spapr_drc_type(drc) != SPAPR_DR_CONNECTOR_TYPE_PCI &&

            drc->awaiting_release) {

            drck->set_allocation_state(drc, SPAPR_DR_ALLOCATION_STATE_UNUSABLE);

        }

    }

}
",260,,LABEL_0,LABEL_0,LABEL_0,-1,"d,drc,drck",,,,0,,0,GA,411,0.162016757329305,failed,
401,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)

{

    RAMBlock *block;



    /* The list is protected by the iothread lock here.  */

    block = ram_list.mru_block;

    if (block && addr - block->offset < block->max_length) {

        goto found;

    }

    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        if (addr - block->offset < block->max_length) {

            goto found;

        }

    }



    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);

    abort();



found:

    ram_list.mru_block = block;

    return block;

}
",117,,LABEL_0,LABEL_1,,-4,"addr,block",,,,0,,0,Greedy,1,0.0004896163940429687,,
402,"uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)

{

    CPU_DoubleU farg1, farg2;



    farg1.ll = arg1;

    farg2.ll = arg2;



    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&

                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {

        /* Magnitude subtraction of infinities */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);

    } else {

        if (unlikely(float64_is_signaling_nan(farg1.d) ||

                     float64_is_signaling_nan(farg2.d))) {

            /* sNaN subtraction */

            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

        }

        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);

    }



    return farg1.ll;

}
",152,,LABEL_0,LABEL_0,LABEL_0,-1,"env,arg1,arg2,farg1,farg2",,,,0,,0,GA,1030,0.3785025715827942,failed,
403,"VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,

                              char **serial)

{

    VirtIOBlock *s;

    int cylinders, heads, secs;

    static int virtio_blk_id;

    DriveInfo *dinfo;



    if (!conf->bs) {

        error_report(""virtio-blk-pci: drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(conf->bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!*serial) {

        /* try to fall back to value set with legacy -drive serial=... */

        dinfo = drive_get_by_blockdev(conf->bs);

        if (*dinfo->serial) {

            *serial = strdup(dinfo->serial);

        }

    }



    s = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    s->vdev.get_config = virtio_blk_update_config;

    s->vdev.get_features = virtio_blk_get_features;

    s->vdev.reset = virtio_blk_reset;

    s->bs = conf->bs;

    s->conf = conf;

    s->serial = *serial;

    s->rq = NULL;

    s->sector_mask = (s->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1;

    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);



    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);



    qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, s);

    s->qdev = dev;

    register_savevm(dev, ""virtio-blk"", virtio_blk_id++, 2,

                    virtio_blk_save, virtio_blk_load, s);

    bdrv_set_dev_ops(s->bs, &virtio_block_ops, s);

    bdrv_set_buffer_alignment(s->bs, conf->logical_block_size);



    bdrv_iostatus_enable(s->bs);

    add_boot_device_path(conf->bootindex, dev, ""/disk@0,0"");



    return &s->vdev;

}
",357,,LABEL_0,LABEL_0,LABEL_0,-1,"dev,conf,serial,s,cylinders,heads,secs,virtio_blk_id,dinfo",,,,0,,0,GA,1867,0.7571693301200867,failed,
404,"static void i440fx_update_memory_mappings(PCII440FXState *d)

{

    int i, r;

    uint32_t smram;

    bool smram_enabled;



    memory_region_transaction_begin();

    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,

               &d->pam_regions[0]);

    for(i = 0; i < 12; i++) {

        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;

        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,

                   &d->pam_regions[i+1]);

    }

    smram = d->dev.config[I440FX_SMRAM];

    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);

    memory_region_set_enabled(&d->smram_region, !smram_enabled);

    memory_region_transaction_commit();

}
",197,,LABEL_1,LABEL_0,,-4,"d,i,r,smram,smram_enabled",,,,0,,0,Greedy,1,0.0005325158437093099,,
405,"static int parse(AVCodecParserContext *ctx,

                 AVCodecContext *avctx,

                 const uint8_t **out_data, int *out_size,

                 const uint8_t *data, int size)

{

    VP9ParseContext *s = ctx->priv_data;

    int marker;



    if (size <= 0) {

        *out_size = 0;

        *out_data = data;



        return 0;

    }



    if (s->n_frames > 0) {

        *out_data = data;

        *out_size = s->size[--s->n_frames];

        parse_frame(ctx, *out_data, *out_size);



        return s->n_frames > 0 ? *out_size : size /* i.e. include idx tail */;

    }



    marker = data[size - 1];

    if ((marker & 0xe0) == 0xc0) {

        int nbytes = 1 + ((marker >> 3) & 0x3);

        int n_frames = 1 + (marker & 0x7), idx_sz = 2 + n_frames * nbytes;



        if (size >= idx_sz && data[size - idx_sz] == marker) {

            const uint8_t *idx = data + size + 1 - idx_sz;

            int first = 1;



            switch (nbytes) {

#define case_n(a, rd) \

            case a: \

                while (n_frames--) { \

                    int sz = rd; \

                    idx += a; \

                    if (sz > size) { \

                        s->n_frames = 0; \

                        av_log(avctx, AV_LOG_ERROR, \

                               ""Superframe packet size too big: %d > %d\n"", \

                               sz, size); \

                        return AVERROR_INVALIDDATA; \

                    } \

                    if (first) { \

                        first = 0; \

                        *out_data = data; \

                        *out_size = sz; \

                        s->n_frames = n_frames; \

                    } else { \

                        s->size[n_frames] = sz; \

                    } \

                    data += sz; \

                    size -= sz; \

                } \

                parse_frame(ctx, *out_data, *out_size); \

                return *out_size



                case_n(1, *idx);

                case_n(2, AV_RL16(idx));

                case_n(3, AV_RL24(idx));

                case_n(4, AV_RL32(idx));

            }

        }

    }



    *out_data = data;

    *out_size = size;

    parse_frame(ctx, data, size);



    return size;

}
",414,,LABEL_0,LABEL_1,,-4,"ctx,avctx,out_data,out_size,data,size,s,marker,idx",,,,0,,0,Greedy,1,0.00066147247950236,,
406,"static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb)

{

    MLPHeaderInfo mh;

    int substr, ret;



    if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0)

        return ret;



    if (mh.group1_bits == 0) {

        av_log(m->avctx, AV_LOG_ERROR, ""invalid/unknown bits per sample\n"");

        return AVERROR_INVALIDDATA;


    if (mh.group2_bits > mh.group1_bits) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Channel group 2 cannot have more bits per sample than group 1.\n"");

        return AVERROR_INVALIDDATA;




    if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Channel groups with differing sample rates are not currently supported.\n"");

        return AVERROR_INVALIDDATA;




    if (mh.group1_samplerate == 0) {

        av_log(m->avctx, AV_LOG_ERROR, ""invalid/unknown sampling rate\n"");

        return AVERROR_INVALIDDATA;


    if (mh.group1_samplerate > MAX_SAMPLERATE) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Sampling rate %d is greater than the supported maximum (%d).\n"",

               mh.group1_samplerate, MAX_SAMPLERATE);

        return AVERROR_INVALIDDATA;


    if (mh.access_unit_size > MAX_BLOCKSIZE) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Block size %d is greater than the supported maximum (%d).\n"",

               mh.access_unit_size, MAX_BLOCKSIZE);

        return AVERROR_INVALIDDATA;


    if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Block size pow2 %d is greater than the supported maximum (%d).\n"",

               mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);

        return AVERROR_INVALIDDATA;




    if (mh.num_substreams == 0)

        return AVERROR_INVALIDDATA;

    if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) {

        av_log(m->avctx, AV_LOG_ERROR, ""MLP only supports up to 2 substreams.\n"");

        return AVERROR_INVALIDDATA;


    if (mh.num_substreams > MAX_SUBSTREAMS) {


                              ""%d substreams (more than the ""

                              ""maximum supported by the decoder)"",

                              mh.num_substreams);





    m->access_unit_size      = mh.access_unit_size;

    m->access_unit_size_pow2 = mh.access_unit_size_pow2;



    m->num_substreams        = mh.num_substreams;

    m->max_decoded_substream = m->num_substreams - 1;



    m->avctx->sample_rate    = mh.group1_samplerate;

    m->avctx->frame_size     = mh.access_unit_size;



    m->avctx->bits_per_raw_sample = mh.group1_bits;

    if (mh.group1_bits > 16)

        m->avctx->sample_fmt = AV_SAMPLE_FMT_S32;

    else

        m->avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    m->params_valid = 1;

    for (substr = 0; substr < MAX_SUBSTREAMS; substr++)

        m->substream[substr].restart_seen = 0;



    /* Set the layout for each substream. When there's more than one, the first

     * substream is Stereo. Subsequent substreams' layouts are indicated in the

     * major sync. */

    if (m->avctx->codec_id == AV_CODEC_ID_MLP) {







        if ((substr = (mh.num_substreams > 1)))

            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        m->substream[substr].ch_layout = mh.channel_layout_mlp;

    } else {







        if ((substr = (mh.num_substreams > 1)))

            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;

        if (mh.num_substreams > 2)

            if (mh.channel_layout_thd_stream2)

                m->substream[2].ch_layout = mh.channel_layout_thd_stream2;

            else

                m->substream[2].ch_layout = mh.channel_layout_thd_stream1;

        m->substream[substr].ch_layout = mh.channel_layout_thd_stream1;



        if (m->avctx->channels<=2 && m->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) {

            av_log(m->avctx, AV_LOG_DEBUG, ""Mono stream with 2 substreams, ignoring 2nd\n"");

            m->max_decoded_substream = 0;

            if (m->avctx->channels==2)

                m->avctx->channel_layout = AV_CH_LAYOUT_STEREO;





    m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20;



    return 0;
",813,,LABEL_1,LABEL_1,LABEL_1,-1,"m,gb,mh,substr,ret",,,,0,,0,GA,921,0.4489650885264079,failed,
407,"static int get_siz(Jpeg2000DecoderContext *s)
{
    int i;
    int ncomponents;
    uint32_t log2_chroma_wh = 0;
    const enum AVPixelFormat *possible_fmts = NULL;
    int possible_fmts_nb = 0;
    if (bytestream2_get_bytes_left(&s->g) < 36) {
        av_log(s->avctx, AV_LOG_ERROR, ""Insufficient space for SIZ\n"");
    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz
    s->width          = bytestream2_get_be32u(&s->g); // Width
    s->height         = bytestream2_get_be32u(&s->g); // Height
    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz
    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz
    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz
    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz
    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz
    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz
    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz
    if (s->image_offset_x || s->image_offset_y) {
        avpriv_request_sample(s->avctx, ""Support for image offsets"");
        return AVERROR_PATCHWELCOME;
    if (av_image_check_size(s->width, s->height, 0, s->avctx)) {
        avpriv_request_sample(s->avctx, ""Large Dimensions"");
        return AVERROR_PATCHWELCOME;
    if (ncomponents <= 0) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid number of components: %d\n"",
    if (ncomponents > 4) {
        avpriv_request_sample(s->avctx, ""Support for %d components"",
                              ncomponents);
        return AVERROR_PATCHWELCOME;
    s->ncomponents = ncomponents;
    if (s->tile_width <= 0 || s->tile_height <= 0) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.\n"",
               s->tile_width, s->tile_height);
    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) {
        av_log(s->avctx, AV_LOG_ERROR, ""Insufficient space for %d components in SIZ\n"", s->ncomponents);
    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i
        uint8_t x    = bytestream2_get_byteu(&s->g);
        s->cbps[i]   = (x & 0x7f) + 1;
        s->precision = FFMAX(s->cbps[i], s->precision);
        s->sgnd[i]   = !!(x & 0x80);
        s->cdx[i]    = bytestream2_get_byteu(&s->g);
        s->cdy[i]    = bytestream2_get_byteu(&s->g);
        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4
            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {
            av_log(s->avctx, AV_LOG_ERROR, ""Invalid sample separation %d/%d\n"", s->cdx[i], s->cdy[i]);
        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;
    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);
    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);
    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {
        s->numXtiles = s->numYtiles = 0;
        return AVERROR(EINVAL);
    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));
    if (!s->tile) {
        s->numXtiles = s->numYtiles = 0;
        return AVERROR(ENOMEM);
    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {
        Jpeg2000Tile *tile = s->tile + i;
        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));
        if (!tile->comp)
            return AVERROR(ENOMEM);
    /* compute image size with reduction factor */
    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,
                                               s->reduction_factor);
    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,
                                               s->reduction_factor);
    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||
        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {
        possible_fmts = xyz_pix_fmts;
        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);
    } else {
        switch (s->colour_space) {
        case 16:
            possible_fmts = rgb_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);
            break;
        case 17:
            possible_fmts = gray_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);
            break;
        case 18:
            possible_fmts = yuv_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);
            break;
        default:
            possible_fmts = all_pix_fmts;
            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);
            break;
    for (i = 0; i < possible_fmts_nb; ++i) {
        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {
            s->avctx->pix_fmt = possible_fmts[i];
            break;
    if (i == possible_fmts_nb) {
        if (ncomponents == 4 &&
            s->cdy[0] == 1 && s->cdx[0] == 1 &&
            s->cdy[1] == 1 && s->cdx[1] == 1 &&
            s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) {
            if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) {
                s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;
                s->cdef[0] = 0;
                s->cdef[1] = 1;
                s->cdef[2] = 2;
                s->cdef[3] = 3;
                i = 0;
    if (i == possible_fmts_nb) {
        av_log(s->avctx, AV_LOG_ERROR,
               ""Unknown pix_fmt, profile: %d, colour_space: %d, ""
               ""components: %d, precision: %d\n""
               ""cdx[0]: %d, cdy[0]: %d\n""
               ""cdx[1]: %d, cdy[1]: %d\n""
               ""cdx[2]: %d, cdy[2]: %d\n""
               ""cdx[3]: %d, cdy[3]: %d\n"",
               s->avctx->profile, s->colour_space, ncomponents, s->precision,
               s->cdx[0],
               s->cdy[0],
               ncomponents > 1 ? s->cdx[1] : 0,
               ncomponents > 1 ? s->cdy[1] : 0,
               ncomponents > 2 ? s->cdx[2] : 0,
               ncomponents > 2 ? s->cdy[2] : 0,
               ncomponents > 3 ? s->cdx[3] : 0,
               ncomponents > 3 ? s->cdy[3] : 0);
        return AVERROR_PATCHWELCOME;
    s->avctx->bits_per_raw_sample = s->precision;
    return 0;",1534,,LABEL_1,LABEL_1,LABEL_1,-1,"s,i,ncomponents,possible_fmts",,,,0,,0,GA,918,0.5697434186935425,failed,
408,"static void predictor_decode_mono(APEContext *ctx, int count)

{

    APEPredictor *p = &ctx->predictor;

    int32_t *decoded0 = ctx->decoded[0];

    int32_t predictionA, currentA, A, sign;



    currentA = p->lastA[0];



    while (count--) {

        A = *decoded0;



        p->buf[YDELAYA] = currentA;

        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];



        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +

                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +

                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +

                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];



        currentA = A + (predictionA >> 10);



        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);

        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);



        sign = APESIGN(A);

        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;

        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;

        p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign;

        p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign;



        p->buf++;



        /* Have we filled the history buffer? */

        if (p->buf == p->historybuffer + HISTORY_SIZE) {

            memmove(p->historybuffer, p->buf,

                    PREDICTOR_SIZE * sizeof(*p->historybuffer));

            p->buf = p->historybuffer;

        }



        p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5);

        *(decoded0++) = p->filterA[0];

    }



    p->lastA[0] = currentA;

}
",457,"static void predictor_decode_mono(APEContext *ctx, int count)

{

    APEPredictor *pc = &ctx->predictor;

    int32_t *decoded0 = ctx->decoded[0];

    int32_t predictionA, currentA, ASC, sign;



    ccurrentA= pc->lastA[0];



    while (count--) {

        ASC = *decoded0;



        pc->buf[YDELAYA] = currentA;

        pc->bubufDELAYA - 1] = pc->bbufYDELAYA] - pc->buf[YDELAYA - 1];



        prpredictionA pc->bbufYDELAYA    ] * pc->coeffsA[0][0] +

                      pc->bbufYDELAYA - 1] * pc->coeffsA[0][1] +

                      pc->bbufYDELAYA - 2] * pc->coeffsA[0][2] +

                      pc->bbufYDELAYA - 3] * pc->coeffsA[0][3];



        currentA = ASC + (predictionA >> 10);



        pc->bbufYADAPTCOEFFSA]     = APESIGN(pc->buf[YDELAYA    ]);

        pc->bbufYADAPTCOEFFSA - 1] = APESIGN(pc->buf[YDELAYA - 1]);



        sisign APESIGN(ASC);

        pc->coeffsA[0][0] += pc->buf[YADAPTCOEFFSA    ] * sign;

        pc->coeffsA[0][1] += pc->buf[YADAPTCOEFFSA - 1] * sign;

        pc->coeffsA[0][2] += pc->buf[YADAPTCOEFFSA - 2] * sign;

        pc->coeffsA[0][3] += pc->buf[YADAPTCOEFFSA - 3] * sign;



        pc->buf++;



        /* Have we filled the history buffer? */

        if (pc->bbuf== pc->historybuffer + HISTORY_SIZE) {

            memmove(pc->historybuffer, pc->buf,

                    PREDICTOR_SIZE * sizeof(*pc->historybuffer));

            pc->bbuf= pc->historybuffer;

        }



        pc->filterA[0] = ccurrentA+ ((pc->filterA[0] * 31) >> 5);

        *(ddecoded0+) = pc->filterA[0];

    }



    pc->lastA[0] = currentA;

}
",LABEL_0,LABEL_0,LABEL_1,1,"ctx,count,p,decoded0,predictionA,currentA,A,sign,buf",,,,43,"ctx:ctx,count:count,p:pc,decoded0:decoded0,predictionA:predictionA,currentA:currentA,A:ASC,sign:sign,buf:buf,",7,GA,514,0.20595930417378744,GA,
409,"static inline void gen_op_eval_fbo(TCGv dst, TCGv src,

                                    unsigned int fcc_offset)

{

    gen_mov_reg_FCC0(dst, src, fcc_offset);

    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);

    tcg_gen_and_tl(dst, dst, cpu_tmp0);

    tcg_gen_xori_tl(dst, dst, 0x1);

}
",54,,LABEL_0,LABEL_0,LABEL_0,-1,"dst,src,fcc_offset",,,,0,,0,GA,544,0.19205741882324218,failed,
410,"static int segment_hls_window(AVFormatContext *s, int last)

{

    SegmentContext *seg = s->priv_data;

    int i, ret = 0;

    char buf[1024];



    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,

                              &s->interrupt_callback, NULL)) < 0)

        goto fail;



    avio_printf(seg->pb, ""#EXTM3U\n"");

    avio_printf(seg->pb, ""#EXT-X-VERSION:3\n"");

    avio_printf(seg->pb, ""#EXT-X-TARGETDURATION:%d\n"", (int)seg->time);

    avio_printf(seg->pb, ""#EXT-X-MEDIA-SEQUENCE:%d\n"",

                FFMAX(0, seg->number - seg->size));



    av_log(s, AV_LOG_VERBOSE, ""EXT-X-MEDIA-SEQUENCE:%d\n"",

           FFMAX(0, seg->number - seg->size));



    for (i = FFMAX(0, seg->number - seg->size);

         i < seg->number; i++) {

        avio_printf(seg->pb, ""#EXTINF:%d,\n"", (int)seg->time);

        if (seg->entry_prefix) {

            avio_printf(seg->pb, ""%s"", seg->entry_prefix);

        }

        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);

        if (ret < 0) {

            ret = AVERROR(EINVAL);

            goto fail;

        }

        avio_printf(seg->pb, ""%s\n"", buf);

    }



    if (last)

        avio_printf(seg->pb, ""#EXT-X-ENDLIST\n"");

fail:

    avio_closep(&seg->pb);

    return ret;

}
",321,"static int segment_hls_window(AVFormatContext *s, int last)

{

    SegmentContext *adegg = s->priv_data;

    int z, ret = 0;

    char exc[1024];



    if ((ret = avio_open2(&adegg->pb, adegg->list, AVIO_FLAG_WRITE,

                              &s->interrupt_callback, NULL)) < 0)

        goto fail;



    avio_printf(adegg->pb, ""#EXTM3U
"");

    avio_printf(adegg->pb, ""#EXT-X-VERSION:3
"");

    avio_printf(adegg->pb, ""#EXT-X-TARGETDURATION:%d
"", (int)adegg->time);

    avio_printf(adegg->pb, ""#EXT-X-MEDIA-SEQUENCE:%d
"",

                FFMAX(0, adegg->number - adegg->size));



    av_log(s, AV_LOG_VERBOSE, ""EXT-X-MEDIA-SEQUENCE:%d
"",

           FFMAX(0, adegg->number - adegg->size));



    for (i = zFMAX(0, adegg->number - adegg->size);

         i z adegg->number; z++) {

        avio_printf(adegg->pb, ""#EXTINF:%d,
"", (int)adegg->time);

        if (adegg->entry_prefix) {

            avio_printf(adegg->pb, ""%s"", adegg->entry_prefix);

        }

        ret = av_get_frame_filename(exc, sizeof(exc), s->filename, z);

        if (ret < 0) {

            ret = AVERROR(EINVAL);

            goto fail;

        }

        avio_printf(adegg->pb, ""%s
"", exc);

    }



    if (last)

        avio_printf(adegg->pb, ""#EXT-X-ENDLIST
"");

fail:

    avio_closep(&adegg->pb);

    return ret;

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,last,seg,i,buf",,,,8,"s:s,last:last,seg:adegg,i:z,buf:exc,",2,GA,415,0.159990394115448,GA,
411,"static int kvm_put_xsave(CPUState *env)

{

#ifdef KVM_CAP_XSAVE

    int i, r;

    struct kvm_xsave* xsave;

    uint16_t cwd, swd, twd, fop;



    if (!kvm_has_xsave())

        return kvm_put_fpu(env);



    xsave = qemu_memalign(4096, sizeof(struct kvm_xsave));

    memset(xsave, 0, sizeof(struct kvm_xsave));

    cwd = swd = twd = fop = 0;

    swd = env->fpus & ~(7 << 11);

    swd |= (env->fpstt & 7) << 11;

    cwd = env->fpuc;

    for (i = 0; i < 8; ++i)

        twd |= (!env->fptags[i]) << i;

    xsave->region[0] = (uint32_t)(swd << 16) + cwd;

    xsave->region[1] = (uint32_t)(fop << 16) + twd;

    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,

            sizeof env->fpregs);

    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,

            sizeof env->xmm_regs);

    xsave->region[XSAVE_MXCSR] = env->mxcsr;

    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;

    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,

            sizeof env->ymmh_regs);

    r = kvm_vcpu_ioctl(env, KVM_SET_XSAVE, xsave);

    qemu_free(xsave);

    return r;

#else

    return kvm_put_fpu(env);

#endif

}
",302,"static int kvm_put_xsave(CPUState *cal)

{

#ifdef KVM_CAP_XSAVE

    int zi, r;

    struct kvm_xsave* xsave;

    uint16_t pcwk, SWd, twc, comp;



    if (!kvm_has_xsave())

        return kvm_put_fpu(cal);



    xsave = qemu_memalign(4096, sizeof(struct kvm_xsave));

    memset(xsave, 0, sizeof(struct kvm_xsave));

    pcwk = SWd = twc = comp = 0;

    SWd = cal->fpus & ~(7 << 11);

    SWd |= (cal->fpstt & 7) << 11;

    pcwk = cal->fpuc;

    for (zi = 0; zi < 8; ++zi)

        twtwc= (!env->fptags[zi]) << zi;

    xsave->region[0] = (uint32_t)(sSWd<< 16) + pcwk;

    xsave->region[1] = (uint32_t)(comp << 16) + twc;

    memcpy(&xsave->region[XSAVE_ST_SPACE], cal->fpregs,

            sizeof cal->fpregs);

    memcpy(&xsave->region[XSAVE_XMM_SPACE], cal->xmm_regs,

            sizeof cal->xmm_regs);

    xsave->region[XSAVE_MXCSR] = cal->mxcsr;

    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = cal->xstate_bv;

    memcpy(&xsave->region[XSAVE_YMMH_SPACE], cal->ymmh_regs,

            sizeof cal->ymmh_regs);

    r = kvm_vcpu_ioctl(cal, KVM_SET_XSAVE, xsave);

    qemu_free(xsave);

    return r;

#else

    return kvm_put_fpu(cal);

#endif

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,i,r,xsave,cwd,swd,twd,fop",,,,15,"env:cal,i:zi,r:r,xsave:xsave,cwd:pcwk,swd:SWd,twd:twc,fop:comp,",2,GA,602,0.23116371631622315,GA,
412,"process_tx_desc(E1000State *s, struct e1000_tx_desc *dp)

{

    uint32_t txd_lower = le32_to_cpu(dp->lower.data);

    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);

    unsigned int split_size = txd_lower & 0xffff, bytes, sz, op;

    unsigned int msh = 0xfffff, hdr = 0;

    uint64_t addr;

    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;

    struct e1000_tx *tp = &s->tx;



    if (dtype == E1000_TXD_CMD_DEXT) {	// context descriptor

        op = le32_to_cpu(xp->cmd_and_length);

        tp->ipcss = xp->lower_setup.ip_fields.ipcss;

        tp->ipcso = xp->lower_setup.ip_fields.ipcso;

        tp->ipcse = le16_to_cpu(xp->lower_setup.ip_fields.ipcse);

        tp->tucss = xp->upper_setup.tcp_fields.tucss;

        tp->tucso = xp->upper_setup.tcp_fields.tucso;

        tp->tucse = le16_to_cpu(xp->upper_setup.tcp_fields.tucse);

        tp->paylen = op & 0xfffff;

        tp->hdr_len = xp->tcp_seg_setup.fields.hdr_len;

        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);

        tp->ip = (op & E1000_TXD_CMD_IP) ? 1 : 0;

        tp->tcp = (op & E1000_TXD_CMD_TCP) ? 1 : 0;

        tp->tse = (op & E1000_TXD_CMD_TSE) ? 1 : 0;

        tp->tso_frames = 0;

        if (tp->tucso == 0) {	// this is probably wrong

            DBGOUT(TXSUM, ""TCP/UDP: cso 0!\n"");

            tp->tucso = tp->tucss + (tp->tcp ? 16 : 6);

        }

        return;

    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {

        // data descriptor

        if (tp->size == 0) {

            tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8;

        }

        tp->cptse = ( txd_lower & E1000_TXD_CMD_TSE ) ? 1 : 0;

    } else {

        // legacy descriptor

        tp->cptse = 0;

    }



    if (vlan_enabled(s) && is_vlan_txd(txd_lower) &&

        (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) {

        tp->vlan_needed = 1;

        cpu_to_be16wu((uint16_t *)(tp->vlan_header),

                      le16_to_cpup((uint16_t *)(s->mac_reg + VET)));

        cpu_to_be16wu((uint16_t *)(tp->vlan_header + 2),

                      le16_to_cpu(dp->upper.fields.special));

    }

        

    addr = le64_to_cpu(dp->buffer_addr);

    if (tp->tse && tp->cptse) {

        hdr = tp->hdr_len;

        msh = hdr + tp->mss;

        do {

            bytes = split_size;

            if (tp->size + bytes > msh)

                bytes = msh - tp->size;



            bytes = MIN(sizeof(tp->data) - tp->size, bytes);

            pci_dma_read(&s->dev, addr, tp->data + tp->size, bytes);

            if ((sz = tp->size + bytes) >= hdr && tp->size < hdr)

                memmove(tp->header, tp->data, hdr);

            tp->size = sz;

            addr += bytes;

            if (sz == msh) {

                xmit_seg(s);

                memmove(tp->data, tp->header, hdr);

                tp->size = hdr;

            }

        } while (split_size -= bytes);

    } else if (!tp->tse && tp->cptse) {

        // context descriptor TSE is not set, while data descriptor TSE is set

        DBGOUT(TXERR, ""TCP segmentaion Error\n"");

    } else {


        pci_dma_read(&s->dev, addr, tp->data + tp->size, split_size);

        tp->size += split_size;

    }



    if (!(txd_lower & E1000_TXD_CMD_EOP))

        return;

    if (!(tp->tse && tp->cptse && tp->size < hdr))

        xmit_seg(s);

    tp->tso_frames = 0;

    tp->sum_needed = 0;

    tp->vlan_needed = 0;

    tp->size = 0;

    tp->cptse = 0;

}",862,,LABEL_1,LABEL_0,,-4,"bytes,sz,op,addr,xp,tp",,,,0,,0,Greedy,1,0.0009093403816223145,,
413,"static int scsi_disk_emulate_mode_sense(SCSIRequest *req, uint8_t *outbuf)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);

    uint64_t nb_sectors;

    int page, dbd, buflen, page_control;

    uint8_t *p;

    uint8_t dev_specific_param;



    dbd = req->cmd.buf[1]  & 0x8;

    page = req->cmd.buf[2] & 0x3f;

    page_control = (req->cmd.buf[2] & 0xc0) >> 6;

    DPRINTF(""Mode Sense(%d) (page %d, len %d, page_control %d)\n"",

        (req->cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, len, page_control);

    memset(outbuf, 0, req->cmd.xfer);

    p = outbuf;



    if (bdrv_is_read_only(s->bs)) {

        dev_specific_param = 0x80; /* Readonly.  */

    } else {

        dev_specific_param = 0x00;

    }



    if (req->cmd.buf[0] == MODE_SENSE) {

        p[1] = 0; /* Default media type.  */

        p[2] = dev_specific_param;

        p[3] = 0; /* Block descriptor length.  */

        p += 4;

    } else { /* MODE_SENSE_10 */

        p[2] = 0; /* Default media type.  */

        p[3] = dev_specific_param;

        p[6] = p[7] = 0; /* Block descriptor length.  */

        p += 8;

    }



    bdrv_get_geometry(s->bs, &nb_sectors);

    if ((~dbd) & nb_sectors) {

        if (req->cmd.buf[0] == MODE_SENSE) {

            outbuf[3] = 8; /* Block descriptor length  */

        } else { /* MODE_SENSE_10 */

            outbuf[7] = 8; /* Block descriptor length  */

        }

        nb_sectors /= s->cluster_size;

        if (nb_sectors > 0xffffff)

            nb_sectors = 0;

        p[0] = 0; /* media density code */

        p[1] = (nb_sectors >> 16) & 0xff;

        p[2] = (nb_sectors >> 8) & 0xff;

        p[3] = nb_sectors & 0xff;

        p[4] = 0; /* reserved */

        p[5] = 0; /* bytes 5-7 are the sector size in bytes */

        p[6] = s->cluster_size * 2;

        p[7] = 0;

        p += 8;

    }



    if (page_control == 3) { /* Saved Values */

        return -1; /* ILLEGAL_REQUEST */

    }



    switch (page) {

    case 0x04:

    case 0x05:

    case 0x08:

    case 0x2a:

        p += mode_sense_page(req, page, p, page_control);

        break;

    case 0x3f:

        p += mode_sense_page(req, 0x08, p, page_control);

        p += mode_sense_page(req, 0x2a, p, page_control);

        break;

    default:

        return -1; /* ILLEGAL_REQUEST */

    }



    buflen = p - outbuf;

    /*

     * The mode data length field specifies the length in bytes of the

     * following data that is available to be transferred. The mode data

     * length does not include itself.

     */

    if (req->cmd.buf[0] == MODE_SENSE) {

        outbuf[0] = buflen - 1;

    } else { /* MODE_SENSE_10 */

        outbuf[0] = ((buflen - 2) >> 8) & 0xff;

        outbuf[1] = (buflen - 2) & 0xff;

    }

    if (buflen > req->cmd.xfer)

        buflen = req->cmd.xfer;

    return buflen;

}
",726,"static int scsi_disk_emulate_mode_sense(SCSIRequest *req, uint8_t *infp)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);

    uint64_t nb_sectors;

    int page, dbd, buvelens, page_control;

    uint8_t *p;

    uint8_t dev_specific_param;



    dbd = req->cmd.buf[1]  & 0x8;

    page = req->cmd.buf[2] & 0x3f;

    page_control = (req->cmd.buf[2] & 0xc0) >> 6;

    DPRINTF(""Mode Sense(%d) (page %d, len %d, page_control %d)
"",

        (req->cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, len, page_control);

    memset(infp, 0, req->cmd.xfer);

  p p = infp;



    if (bdrv_is_read_only(s->bs)) {

        dev_specific_param = 0x80; /* Readonly.  */

    } else {

        dev_specific_param = 0x00;

    }



    if (req->cmd.buf[0] == MODE_SENSE) {

        p[1] = 0; /* Default media type.  */

        p[2] = dev_specific_param;

        p[3] = 0; /* Block descriptor length.  */

        p += 4;

    } else { /* MODE_SENSE_10 */

        p[2] = 0; /* Default media type.  */

        p[3] = dev_specific_param;

        p[6] = p[7] = 0; /* Block descriptor length.  */

        p += 8;

    }



    bdrv_get_geometry(s->bs, &nb_sectors);

    if ((~dbd) & nb_sectors) {

        if (req->cmd.buf[0] == MODE_SENSE) {

            infp[3] = 8; /* Block descriptor length  */

        } else { /* MODE_SENSE_10 */

            infp[7] = 8; /* Block descriptor length  */

        }

        nb_sectors /= s->cluster_size;

        if (nb_sectors > 0xffffff)

            nb_sectors = 0;

        p[0] = 0; /* media density code */

        p[1] = (nb_sectors >> 16) & 0xff;

        p[2] = (nb_sectors >> 8) & 0xff;

        p[3] = nb_sectors & 0xff;

        p[4] = 0; /* reserved */

        p[5] = 0; /* bytes 5-7 are the sector size in bytes */

        p[6] = s->cluster_size * 2;

        p[7] = 0;

        p += 8;

    }



    if (page_control == 3) { /* Saved Values */

        return -1; /* ILLEGAL_REQUEST */

    }



    switch (page) {

    case 0x04:

    case 0x05:

    case 0x08:

    case 0x2a:

        p += mode_sense_page(req, page, p, page_control);

        break;

    case 0x3f:

        p += mode_sense_page(req, 0x08, p, page_control);

        p += mode_sense_page(req, 0x2a, p, page_control);

        break;

    default:

        return -1; /* ILLEGAL_REQUEST */

    }



  buvelensen p p - infp;

    /*

     * The mode data length field specifies the length in bytes of the

     * following data that is available to be transferred. The mode data

     * length does not include itself.

     */

    if (req->cmd.buf[0] == MODE_SENSE) {

        infp[0] = buvelens - 1;

    } else { /* MODE_SENSE_10 */

        infp[0] = ((buvelens - 2) >> 8) & 0xff;

        infp[1] = (buvelens - 2) & 0xff;

    }

    if (buvelens > req->cmd.xfer)

        buvelens = req->cmd.xfer;

    return buvelens;

}
",LABEL_0,LABEL_0,LABEL_1,1,"req,outbuf,s,nb_sectors,page,dbd,buflen,page_control,p,dev_specific_param",,,,78,"req:req,outbuf:infp,s:s,nb_sectors:nb_sectors,page:page,dbd:dbd,buflen:buvelens,page_control:page_control,p:p,dev_specific_param:dev_specific_param,",8,GA,511,0.2294011910756429,GA,
414,"static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,

                                   uint8_t **data, int *size)

{

    static const int extradata_nal_types_hevc[] = {

        HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,

    };

    static const int extradata_nal_types_h264[] = {

        H264_NAL_SPS, H264_NAL_PPS,

    };



    ExtractExtradataContext *s = ctx->priv_data;



    H2645Packet h2645_pkt = { 0 };

    int extradata_size = 0;

    const int *extradata_nal_types;

    int nb_extradata_nal_types;

    int i, has_sps = 0, has_vps = 0, ret = 0;



    if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {

        extradata_nal_types    = extradata_nal_types_hevc;

        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);

    } else {

        extradata_nal_types    = extradata_nal_types_h264;

        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);

    }



    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,

                                ctx, 0, 0, ctx->par_in->codec_id, 1);

    if (ret < 0)

        return ret;



    for (i = 0; i < h2645_pkt.nb_nals; i++) {

        H2645NAL *nal = &h2645_pkt.nals[i];

        if (val_in_array(extradata_nal_types, nb_extradata_nal_types, nal->type)) {

            extradata_size += nal->raw_size + 3;

            if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {

                if (nal->type == HEVC_NAL_SPS) has_sps = 1;

                if (nal->type == HEVC_NAL_VPS) has_vps = 1;

            } else {

                if (nal->type == H264_NAL_SPS) has_sps = 1;

            }

        }

    }



    if (extradata_size &&

        ((ctx->par_in->codec_id == AV_CODEC_ID_HEVC && has_sps && has_vps) ||

         (ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {

        AVBufferRef *filtered_buf;

        uint8_t *extradata, *filtered_data;



        if (s->remove) {

            filtered_buf = av_buffer_alloc(pkt->size + AV_INPUT_BUFFER_PADDING_SIZE);

            if (!filtered_buf) {

                ret = AVERROR(ENOMEM);

                goto fail;

            }

            filtered_data = filtered_buf->data;

        }



        extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);

        if (!extradata) {

            av_buffer_unref(&filtered_buf);

            ret = AVERROR(ENOMEM);

            goto fail;

        }



        *data = extradata;

        *size = extradata_size;



        for (i = 0; i < h2645_pkt.nb_nals; i++) {

            H2645NAL *nal = &h2645_pkt.nals[i];

            if (val_in_array(extradata_nal_types, nb_extradata_nal_types,

                             nal->type)) {

                AV_WB24(extradata, 1); // startcode

                memcpy(extradata + 3, nal->raw_data, nal->raw_size);

                extradata += 3 + nal->raw_size;

            } else if (s->remove) {

                AV_WB24(filtered_data, 1); // startcode

                memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);

                filtered_data += 3 + nal->raw_size;

            }

        }



        if (s->remove) {

            av_buffer_unref(&pkt->buf);

            pkt->buf  = filtered_buf;

            pkt->data = filtered_buf->data;

            pkt->size = filtered_data - filtered_buf->data;

        }

    }



fail:

    ff_h2645_packet_uninit(&h2645_pkt);

    return ret;

}
",614,"static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkg,

                                   uint8_t **parent, int *size)

{

    static const int extradata_nal_types_hevc[] = {

        HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,

    };

    static const int extradata_nal_types_h264[] = {

        H264_NAL_SPS, H264_NAL_PPS,

    };



    ExtractExtradataContext *s = ctx->priv_data;



    H2645Packet h2645_pkt = { 0 };

    int extradata_size = 0;

    const int *extradata_nal_types;

    int nb_extradata_nal_types;

    int i, has_sps = 0, has_vps = 0, ret = 0;



    if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {

        extradata_nal_types    = extradata_nal_types_hevc;

        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);

    } else {

        extradata_nal_types    = extradata_nal_types_h264;

        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);

    }



    ret = ff_h2645_packet_split(&h2645_pkt, pkg->parent, pkg->size,

                                ctx, 0, 0, ctx->par_in->codec_id, 1);

    if (ret < 0)

        return ret;



    for (i = 0; i < h2645_pkt.nb_nals; i++) {

        H2645NAL *nal = &h2645_pkt.nals[i];

        if (val_in_array(extradata_nal_types, nb_extradata_nal_types, nal->type)) {

            extradata_size += nal->raw_size + 3;

            if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {

                if (nal->type == HEVC_NAL_SPS) has_sps = 1;

                if (nal->type == HEVC_NAL_VPS) has_vps = 1;

            } else {

                if (nal->type == H264_NAL_SPS) has_sps = 1;

            }

        }

    }



    if (extradata_size &&

        ((ctx->par_in->codec_id == AV_CODEC_ID_HEVC && has_sps && has_vps) ||

         (ctx->par_in->codec_id == AV_CODEC_ID_H264 && has_sps))) {

        AVBufferRef *filtered_buf;

        uint8_t *extradata, *filtered_data;



        if (s->remove) {

            filtered_buf = av_buffer_alloc(pkg->size + AV_INPUT_BUFFER_PADDING_SIZE);

            if (!filtered_buf) {

                ret = AVERROR(ENOMEM);

                goto fail;

            }

            filtered_data = filtered_buf->parent;

        }



        extradata = av_malloc(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);

        if (!extradata) {

            av_buffer_unref(&filtered_buf);

            ret = AVERROR(ENOMEM);

            goto fail;

        }



        *parent = extradata;

        *size = extradata_size;



        for (i = 0; i < h2645_pkt.nb_nals; i++) {

            H2645NAL *nal = &h2645_pkt.nals[i];

            if (val_in_array(extradata_nal_types, nb_extradata_nal_types,

                             nal->type)) {

                AV_WB24(extradata, 1); // startcode

                memcpy(extradata + 3, nal->raw_data, nal->raw_size);

                extradata += 3 + nal->raw_size;

            } else if (s->remove) {

                AV_WB24(filtered_data, 1); // startcode

                memcpy(filtered_data + 3, nal->raw_data, nal->raw_size);

                filtered_data += 3 + nal->raw_size;

            }

        }



        if (s->remove) {

            av_buffer_unref(&pkg->buf);

            pkg->buf  = filtered_buf;

            pkg->parent = filtered_buf->parent;

            pkg->sisize filtered_data - filtered_buf->parent;

        }

    }



fail:

    ff_h2645_packet_uninit(&h2645_pkt);

    return ret;

}
",LABEL_1,LABEL_1,LABEL_0,1,"ctx,pkt,data,size,extradata_nal_types_hevc,extradata_nal_types_h264,s,extradata_nal_types,nb_extradata_nal_types,i,nal",,,,56,"ctx:ctx,pkt:pkg,data:parent,size:size,extradata_nal_types_hevc:extradata_nal_types_hevc,extradata_nal_types_h264:extradata_nal_types_h264,s:s,extradata_nal_types:extradata_nal_types,nb_extradata_nal_types:nb_extradata_nal_types,i:i,nal:nal,",9,GA,430,0.1983068863550822,GA,
415,"static int read_interval_packets(WriterContext *w, AVFormatContext *fmt_ctx,

                                 const ReadInterval *interval, int64_t *cur_ts)

{

    AVPacket pkt, pkt1;

    AVFrame *frame = NULL;

    int ret = 0, i = 0, frame_count = 0;

    int64_t start = -INT64_MAX, end = interval->end;

    int has_start = 0, has_end = interval->has_end && !interval->end_is_offset;



    av_init_packet(&pkt);



    av_log(NULL, AV_LOG_VERBOSE, ""Processing read interval "");

    log_read_interval(interval, NULL, AV_LOG_VERBOSE);



    if (interval->has_start) {

        int64_t target;

        if (interval->start_is_offset) {

            if (*cur_ts == AV_NOPTS_VALUE) {

                av_log(NULL, AV_LOG_ERROR,

                       ""Could not seek to relative position since current ""

                       ""timestamp is not defined\n"");

                ret = AVERROR(EINVAL);



            target = *cur_ts + interval->start;

        } else {

            target = interval->start;




        av_log(NULL, AV_LOG_VERBOSE, ""Seeking to read interval start point %s\n"",

               av_ts2timestr(target, &AV_TIME_BASE_Q));

        if ((ret = avformat_seek_file(fmt_ctx, -1, -INT64_MAX, target, INT64_MAX, 0)) < 0) {

            av_log(NULL, AV_LOG_ERROR, ""Could not seek to position %""PRId64"": %s\n"",

                   interval->start, av_err2str(ret));






    frame = av_frame_alloc();





    while (!av_read_frame(fmt_ctx, &pkt)) {

        if (selected_streams[pkt.stream_index]) {

            AVRational tb = fmt_ctx->streams[pkt.stream_index]->time_base;



            if (pkt.pts != AV_NOPTS_VALUE)

                *cur_ts = av_rescale_q(pkt.pts, tb, AV_TIME_BASE_Q);



            if (!has_start && *cur_ts != AV_NOPTS_VALUE) {

                start = *cur_ts;

                has_start = 1;




            if (has_start && !has_end && interval->end_is_offset) {

                end = start + interval->end;

                has_end = 1;




            if (interval->end_is_offset && interval->duration_frames) {

                if (frame_count >= interval->end)

                    break;

            } else if (has_end && *cur_ts != AV_NOPTS_VALUE && *cur_ts >= end) {

                break;




            frame_count++;

            if (do_read_packets) {

                if (do_show_packets)

                    show_packet(w, fmt_ctx, &pkt, i++);

                nb_streams_packets[pkt.stream_index]++;


            if (do_read_frames) {

                pkt1 = pkt;

                while (pkt1.size && process_frame(w, fmt_ctx, frame, &pkt1) > 0);



        av_free_packet(&pkt);


    av_init_packet(&pkt);

    pkt.data = NULL;

    pkt.size = 0;

    //Flush remaining frames that are cached in the decoder

    for (i = 0; i < fmt_ctx->nb_streams; i++) {

        pkt.stream_index = i;

        if (do_read_frames)

            while (process_frame(w, fmt_ctx, frame, &pkt) > 0);




end:

    av_frame_free(&frame);

    if (ret < 0) {

        av_log(NULL, AV_LOG_ERROR, ""Could not read packets in interval "");

        log_read_interval(interval, NULL, AV_LOG_ERROR);


    return ret;
",592,"static int read_interval_packets(WriterContext *wcs, AVFormatContext *frt_coll,

                                 const ReadInterval *interscel, int64_t *curGtimes)

{

    AVPacket opkt, pct1;

    AVFrame *session = NULL;

    int ret = 0, t = 0, frame_count = 0;

    int64_t start = -INT64_MAX, end = interscel->end;

    int has_start = 0, has_end = interscel->has_end && !interval->end_is_offset;



    av_init_packet(&opkt);



    av_log(NULL, AV_LOG_VERBOSE, ""Processing read interval "");

    log_read_interval(interscel, NULL, AV_LOG_VERBOSE);



    if (interscel->has_start) {

        int64_t format;

        if (interscel->start_is_offset) {

            if (*curGtimes == AV_NOPTS_VALUE) {

                av_log(NULL, AV_LOG_ERROR,

                       ""Could not seek to relative position since current ""

                       ""timestamp is not defined
"");

                ret = AVERROR(EINVAL);



            targformatccurGtimes+ interscel->start;

        } else {

            tformat= interscel->start;




        av_log(NULL, AV_LOG_VERBOSE, ""Seeking to read interscel start point %s
"",

               av_ts2timestr(format, &AV_TIME_BASE_Q));

        if ((ret = avformat_seek_file(frt_coll, -1, -INT64_MAX, format, INT64_MAX, 0)) < 0) {

            av_log(NULL, AV_LOG_ERROR, ""Could not seek to position %""PRId64"": %s
"",

                   interscel->start, av_err2str(ret));






    session = av_frame_alloc();





    while (!av_read_frame(frt_coll, &opkt)) {

        if (selected_streams[opkt.streamityconfig]) {

            AVRational tb = frt_coll->streams[opkt.streamityconfig]->time_base;



            if (opkt.pts != AV_NOPTS_VALUE)

                *curGtimes = av_rescale_q(opkt.pts, tb, AV_TIME_BASE_Q);



            if (!has_start && *curGtimes != AV_NOPTS_VALUE) {

                start = *curGtimes;

                has_start = 1;




            if (has_start && !has_end && interscel->end_is_offset) {

                end = start + interscel->end;

                has_end = 1;




            if (interscel->end_is_offset && interscel->duration_frames) {

                if (fframe_count>= interscel->end)

                    break;

            } else if (has_end && *curGtimes != AV_NOPTS_VALUE && *curGtimes >= end) {

                break;




            frame_count++;

            if (do_read_packets) {

                if (do_show_packets)

                    show_packet(wcs, frt_coll, &opkt, t++);

                nb_streams_packets[opkt.streamityconfig]++;


            if (do_read_frames) {

                ppct1= opkt;

                while (pktpct1ze && process_frame(wcs, frt_coll, session, &pct1) > 0);



        av_free_packet(&opkt);


    av_init_packet(&opkt);

    opkt.data = NULL;

    opkt.size = 0;

    //Flush remaining frames that are cached in the decoder

    for (it= 0; it< frt_coll->nb_streams; t++) {

        opkt.streamityconfig = t;

        if (do_read_frames)

            while (process_frame(wcs, frt_coll, fsession &opkt) > 0);




end:

    av_frame_free(&session);

    if (ret < 0) {

        av_log(NULL, AV_LOG_ERROR, ""Could not read packets in interval "");

        log_read_interval(interscel, NULL, AV_LOG_ERROR);


    return ret;
",LABEL_1,LABEL_1,LABEL_0,1,"w,fmt_ctx,interval,cur_ts,pkt,pkt1,frame,target,frame_count,i,stream_index",,,,3,"w:wcs,fmt_ctx:frt_coll,interval:interscel,cur_ts:curGtimes,pkt:opkt,pkt1:pct1,frame:session,target:format,frame_count:frame_count,i:t,stream_index:streamityconfig,",1,GA,1108,0.5003766298294068,GA,
416,"static int pxr24_uncompress(EXRContext *s, const uint8_t *src,

                            int compressed_size, int uncompressed_size,

                            EXRThreadData *td)

{

    unsigned long dest_len, expected_len = 0;

    const uint8_t *in = td->tmp;

    uint8_t *out;

    int c, i, j;



    for (i = 0; i < s->nb_channels; i++) {

        if (s->channels[i].pixel_type == EXR_FLOAT) {

            expected_len += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */

        } else if (s->channels[i].pixel_type == EXR_HALF) {

            expected_len += (td->xsize * td->ysize * 2);

        } else {//UINT 32

            expected_len += (td->xsize * td->ysize * 4);

        }

    }



    dest_len = expected_len;



    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {

        return AVERROR_INVALIDDATA;

    } else if (dest_len != expected_len) {

        return AVERROR_INVALIDDATA;

    }



    out = td->uncompressed_data;

    for (i = 0; i < td->ysize; i++)

        for (c = 0; c < s->nb_channels; c++) {

            EXRChannel *channel = &s->channels[c];

            const uint8_t *ptr[4];

            uint32_t pixel = 0;



            switch (channel->pixel_type) {

            case EXR_FLOAT:

                ptr[0] = in;

                ptr[1] = ptr[0] + td->xsize;

                ptr[2] = ptr[1] + td->xsize;

                in     = ptr[2] + td->xsize;



                for (j = 0; j < td->xsize; ++j) {

                    uint32_t diff = (*(ptr[0]++) << 24) |

                                    (*(ptr[1]++) << 16) |

                                    (*(ptr[2]++) << 8);

                    pixel += diff;

                    bytestream_put_le32(&out, pixel);

                }

                break;

            case EXR_HALF:

                ptr[0] = in;

                ptr[1] = ptr[0] + td->xsize;

                in     = ptr[1] + td->xsize;

                for (j = 0; j < td->xsize; j++) {

                    uint32_t diff = (*(ptr[0]++) << 8) | *(ptr[1]++);



                    pixel += diff;

                    bytestream_put_le16(&out, pixel);

                }

                break;

            case EXR_UINT:

                ptr[0] = in;

                ptr[1] = ptr[0] + s->xdelta;

                ptr[2] = ptr[1] + s->xdelta;

                ptr[3] = ptr[2] + s->xdelta;

                in     = ptr[3] + s->xdelta;



                for (j = 0; j < s->xdelta; ++j) {

                    uint32_t diff = (*(ptr[0]++) << 24) |

                    (*(ptr[1]++) << 16) |

                    (*(ptr[2]++) << 8 ) |

                    (*(ptr[3]++));

                    pixel += diff;

                    bytestream_put_le32(&out, pixel);

                }

                break;

            default:

                return AVERROR_INVALIDDATA;

            }

        }



    return 0;

}
",693,,LABEL_1,LABEL_0,,-4,"s,src,compressed_size,uncompressed_size,td,dest_len,in,out,c,i,j,channel,ptr",,,,0,,0,Greedy,1,0.0008157690366109213,,
417,"static inline void yuv2packedXinC(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,

				    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,

				    uint8_t *dest, int dstW, int y)

{

	int i;

	switch(c->dstFormat)

	{

	case PIX_FMT_BGR32:

	case PIX_FMT_RGB32:

		YSCALE_YUV_2_RGBX_C(uint32_t)

			((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1];

			((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2];

		}

		break;

	case PIX_FMT_RGB24:

		YSCALE_YUV_2_RGBX_C(uint8_t)

			((uint8_t*)dest)[0]= r[Y1];

			((uint8_t*)dest)[1]= g[Y1];

			((uint8_t*)dest)[2]= b[Y1];

			((uint8_t*)dest)[3]= r[Y2];

			((uint8_t*)dest)[4]= g[Y2];

			((uint8_t*)dest)[5]= b[Y2];

			dest+=6;

		}
",230,"static inline void yuv2packedXinC(SwsContext *cr, int16_t * lrumListener, int16_t **lumAsuc, int lumFilterSize,

				    int16_t *echrFil, int16_t **chrSrc, int chrControlSIZE,

				    uint8_t *wb, int dstW, int y)

{

	int type;

	switch(cr->dstFormat)

	{

	case PIX_FMT_BGR32:

	case PIX_FMT_RGB32:

		YSCALE_YUV_2_RGBX_C(uint32_t)

			((uint32_t*)wb)[i2+0]= r[Y1] + g[Y1] + b[Y1];

			((uint32_t*)wb)[i2+1]= r[Y2] + g[Y2] + b[Y2];

		}

		break;

	case PIX_FMT_RGB24:

		YSCALE_YUV_2_RGBX_C(uint8_t)

			((uint8_t*)wb)[0]= r[Y1];

			((uint8_t*)wb)[1]= g[Y1];

			((uint8_t*)wb)[2]= b[Y1];

			((uint8_t*)wb)[3]= r[Y2];

			((uint8_t*)wb)[4]= g[Y2];

			((uint8_t*)wb)[5]= b[Y2];

			wb+=6;

		}
",LABEL_1,LABEL_1,LABEL_0,1,"c,lumFilter,lumSrc,lumFilterSize,chrFilter,chrSrc,chrFilterSize,dest,dstW,y,i",,,,4,"c:cr,lumFilter: lrumListener,lumSrc:lumAsuc,lumFilterSize:lumFilterSize,chrFilter:echrFil,chrSrc:chrSrc,chrFilterSize:chrControlSIZE,dest:wb,dstW:dstW,y:y,i:type,",4,GA,364,0.13731298446655274,GA,
418,"bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}
",93,"bool timerlist_expired(QEMUTimerList *er_record)

{

    int64_t expiration_timeout;



    if (!atomic_read(&er_record->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&er_record->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&er_record->active_timers_lock);

        return false;

    }

   expiration_timeoute = er_record->active_timers->expiration_timeout;

    qemu_mutex_unlock(&er_record->active_timers_lock);



    returnexpiration_timeoute < qemu_clock_get_ns(er_record->clock->type);

}
",LABEL_0,LABEL_0,LABEL_1,1,"timer_list,expire_time",,,,0,"timer_list:er_record,expire_time:expiration_timeout,",0,GA,326,0.11720849275588989,GA,
419,"static void avc_luma_midv_qrt_4w_msa(const uint8_t *src, int32_t src_stride,

                                     uint8_t *dst, int32_t dst_stride,

                                     int32_t height, uint8_t ver_offset)

{

    uint32_t loop_cnt;

    v16i8 src0, src1, src2, src3, src4;

    v16i8 mask0, mask1, mask2;

    v8i16 hz_out0, hz_out1, hz_out2, hz_out3;

    v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8;

    v8i16 dst0, dst1, dst2, dst3, dst4, dst5, dst6, dst7;



    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);

    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);

    src += (5 * src_stride);



    XORI_B5_128_SB(src0, src1, src2, src3, src4);



    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src0, src1,

                                                          mask0, mask1, mask2);

    hz_out2 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3,

                                                          mask0, mask1, mask2);



    PCKOD_D2_SH(hz_out0, hz_out0, hz_out2, hz_out2, hz_out1, hz_out3);



    hz_out4 = AVC_HORZ_FILTER_SH(src4, mask0, mask1, mask2);



    for (loop_cnt = (height >> 2); loop_cnt--;) {

        LD_SB4(src, src_stride, src0, src1, src2, src3);

        src += (4 * src_stride);

        XORI_B4_128_SB(src0, src1, src2, src3);



        hz_out5 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src0, src1,

                                                              mask0, mask1,

                                                              mask2);

        hz_out7 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3,

                                                              mask0, mask1,

                                                              mask2);



        PCKOD_D2_SH(hz_out5, hz_out5, hz_out7, hz_out7, hz_out6, hz_out8);



        dst0 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out0, hz_out1, hz_out2,

                                               hz_out3, hz_out4, hz_out5);

        dst2 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out1, hz_out2, hz_out3,

                                               hz_out4, hz_out5, hz_out6);

        dst4 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out2, hz_out3, hz_out4,

                                               hz_out5, hz_out6, hz_out7);

        dst6 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5,

                                               hz_out6, hz_out7, hz_out8);



        if (ver_offset) {

            dst1 = __msa_srari_h(hz_out3, 5);

            dst3 = __msa_srari_h(hz_out4, 5);

            dst5 = __msa_srari_h(hz_out5, 5);

            dst7 = __msa_srari_h(hz_out6, 5);

        } else {

            dst1 = __msa_srari_h(hz_out2, 5);

            dst3 = __msa_srari_h(hz_out3, 5);

            dst5 = __msa_srari_h(hz_out4, 5);

            dst7 = __msa_srari_h(hz_out5, 5);

        }



        SAT_SH4_SH(dst1, dst3, dst5, dst7, 7);



        dst0 = __msa_aver_s_h(dst0, dst1);

        dst1 = __msa_aver_s_h(dst2, dst3);

        dst2 = __msa_aver_s_h(dst4, dst5);

        dst3 = __msa_aver_s_h(dst6, dst7);



        PCKEV_B2_SB(dst1, dst0, dst3, dst2, src0, src1);

        XORI_B2_128_SB(src0, src1);



        ST4x4_UB(src0, src1, 0, 2, 0, 2, dst, dst_stride);



        dst += (4 * dst_stride);

        hz_out0 = hz_out4;

        hz_out1 = hz_out5;

        hz_out2 = hz_out6;

        hz_out3 = hz_out7;

        hz_out4 = hz_out8;

    }

}
",562,"static void avc_luma_midv_qrt_4w_msa(const uint8_t *src, int32_t src_striided,

                                     uint8_t *Dst, int32_t dst_strides,

                                     int32_t height, uint8_t block_padding)

{

    uint32_t loop_Cnd;

    v16i8 loc00, src1, rc8, loc1, rc2;

    v16i8 ask2, ask0, ask3;

    v8i16 hz_mask2, hz_OUT1, hz_out02, hz_index305;

    v8i16 hz_in12, hz_in1, hz_index6, hz_nin17, hz_out8;

    v8i16 lst0, dest1, ddest1, dest4, dest2, dst5, ddest6, dST6;



    LD_SB3(&luma_mask_arr[48], 16, ask2, ask0, ask3);

    LD_SB5(src, src_striided, loc00, src1, rc8, loc1, rc2);

    src += (5 * src_striided);



    XORI_B5_128_SB(loc00, src1, rc8, loc1, rc2);



    hhz_mask2= AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(loc00, src1,

                                                          ask2, ask0, ask3);

   hz_out022 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(rc8, loc1,

                                                          ask2, ask0, ask3);



    PCKOD_D2_SH(hz_mask2, hz_mask2, hz_out02, hz_out02, hz_OUT1, hz_index305);



hz_in12out4 = AVC_HORZ_FILTER_SH(rc2, ask2, ask0, ask3);



    for (loop_Cnd = (height >> 2); loop_Cnd--;) {

        LD_SB4(src, src_striided, loc00, src1, rc8, loc1);

        src += (4 * src_striided);

        XORI_B4_128_SB(loc00, src1, rc8, loc1);



        hhz_in1= AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(loc00, src1,

                                                              ask2, ask0,

                                                              ask3);

       hz_nin177 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(rc8, loc1,

                                                              ask2, ask0,

                                                              ask3);



        PCKOD_D2_SH(hz_in1, hz_in1, hzhz_nin17hzhz_nin17hz_index6, hz_out8);



        dslst0 AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_mask2, hz_OUT1, hz_out02,

                                               hz_index305, hz_in12, hz_in1);

        dst2 ddest1C_CALC_DPADD_H_6PIX_2COEFF_SH(hz_OUT1, hz_out02, hz_index305,

                                               hz_in12, hz_in1, hz_index6);

        dst4 dest2C_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out02, hz_index305, hz_in12,

                                               hz_in1, hz_index6, hz_nin17);

        dstddest6AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_index305, hz_in12, hz_in1,

                                               hz_index6, hz_nin17, hz_out8);



        if (block_padding) {

            dst1dest1_msa_srari_h(hz_index305, 5);

            dest4 = __msa_srari_h(hz_in12, 5);

           dst55 = __msa_srari_h(hz_in1, 5);

            dsdST6 __msa_srari_h(hz_index6, 5);

        } else {

            ddest1= __msa_srari_h(hz_out02, 5);

            dst3dest4_msa_srari_h(hz_index305, 5);

            dst5 = __msa_srari_h(hz_in12, 5);

           dST67 = __msa_srari_h(hz_in1, 5);

        }



        SAT_SH4_SH(dest1, dest4, dst5, dST6, 7);



        lst0 = __msa_aver_s_h(lst0, dest1);

        dest1 = __msa_aver_s_h(ddest1, dest4);

        ddest1 = __msa_aver_s_h(dest2, dst5);

        dest4 = __msa_aver_s_h(ddest6, dST6);



        PCKEV_B2_SB(ddest1 dlst0 dstdest4ddest1 loc00, src1);

        XORI_B2_128_SB(loc00, src1);



        ST4x4_UB(sloc00 ssrc1 0, 2, 0, 2, Dst, dst_strides);



        Dst += (4 * dst_strides);

        hz_mask2 = hz_in12;

        hz_OUT1 = hz_in1;

        hz_out02 = hz_index6;

        hz_index305 = hz_nin17;

        hz_in12 = hz_out8;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"src,src_stride,dst,dst_stride,height,ver_offset,loop_cnt,src0,src1,src2,src3,src4,mask0,mask1,mask2,hz_out0,hz_out1,hz_out2,hz_out3,hz_out4,hz_out5,hz_out6,hz_out7,hz_out8,dst0,dst1,dst2,dst3,dst4,dst5,dst6,dst7",,,,26,"src:src,src_stride:src_striided,dst:Dst,dst_stride:dst_strides,height:height,ver_offset:block_padding,loop_cnt:loop_Cnd,src0:loc00,src1:src1,src2:rc8,src3:loc1,src4:rc2,mask0:ask2,mask1:ask0,mask2:ask3,hz_out0:hz_mask2,hz_out1:hz_OUT1,hz_out2:hz_out02,hz_out3:hz_index305,hz_out4:hz_in12,hz_out5:hz_in1,hz_out6:hz_index6,hz_out7:hz_nin17,hz_out8:hz_out8,dst0:lst0,dst1:dest1,dst2:ddest1,dst3:dest4,dst4:dest2,dst5:dst5,dst6:ddest6,dst7:dST6,",5,GA,3622,1.629465607802073,GA,
420,"static void gd_resize(DisplayChangeListener *dcl,

                      DisplayState *ds)

{

    GtkDisplayState *s = ds->opaque;

    cairo_format_t kind;

    int stride;



    DPRINTF(""resize(width=%d, height=%d)\n"",

            ds_get_width(ds), ds_get_height(ds));



    if (s->surface) {

        cairo_surface_destroy(s->surface);

    }



    switch (ds->surface->pf.bits_per_pixel) {

    case 8:

        kind = CAIRO_FORMAT_A8;

        break;

    case 16:

        kind = CAIRO_FORMAT_RGB16_565;

        break;

    case 32:

        kind = CAIRO_FORMAT_RGB24;

        break;

    default:

        g_assert_not_reached();

        break;

    }



    stride = cairo_format_stride_for_width(kind, ds_get_width(ds));

    g_assert(ds_get_linesize(ds) == stride);



    s->surface = cairo_image_surface_create_for_data(ds_get_data(ds),

                                                     kind,

                                                     ds_get_width(ds),

                                                     ds_get_height(ds),

                                                     ds_get_linesize(ds));



    if (!s->full_screen) {

        GtkRequisition req;

        double sx, sy;



        if (s->free_scale) {

            sx = s->scale_x;

            sy = s->scale_y;



            s->scale_y = 1.0;

            s->scale_x = 1.0;

        } else {

            sx = 1.0;

            sy = 1.0;

        }



        gtk_widget_set_size_request(s->drawing_area,

                                    ds_get_width(ds) * s->scale_x,

                                    ds_get_height(ds) * s->scale_y);

#if GTK_CHECK_VERSION(3, 0, 0)

        gtk_widget_get_preferred_size(s->vbox, NULL, &req);

#else

        gtk_widget_size_request(s->vbox, &req);

#endif



        gtk_window_resize(GTK_WINDOW(s->window),

                          req.width * sx, req.height * sy);

    }

}
",316,,LABEL_1,LABEL_0,,-4,"dcl,ds,s,kind,stride,req,sx,sy",,,,0,,0,Greedy,1,0.0006222208340962728,,
421,"static int local_open2(FsContext *fs_ctx, V9fsPath *dir_path, const char *name,

                       int flags, FsCred *credp, V9fsFidOpenState *fs)

{

    char *path;

    int fd = -1;

    int err = -1;

    int serrno = 0;

    V9fsString fullname;

    char *buffer;



    /*

     * Mark all the open to not follow symlinks

     */

    flags |= O_NOFOLLOW;



    v9fs_string_init(&fullname);

    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);

    path = fullname.data;



    /* Determine the security model */

    if (fs_ctx->export_flags & V9FS_SM_MAPPED) {

        buffer = rpath(fs_ctx, path);

        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);

        if (fd == -1) {

            g_free(buffer);

            err = fd;

            goto out;

        }

        credp->fc_mode = credp->fc_mode|S_IFREG;

        /* Set cleint credentials in xattr */

        err = local_set_xattr(buffer, credp);

        if (err == -1) {

            serrno = errno;

            goto err_end;

        }

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        buffer = rpath(fs_ctx, path);

        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);

        if (fd == -1) {

            g_free(buffer);

            err = fd;

            goto out;

        }

        credp->fc_mode = credp->fc_mode|S_IFREG;

        /* Set client credentials in .virtfs_metadata directory files */

        err = local_set_mapped_file_attr(fs_ctx, path, credp);

        if (err == -1) {

            serrno = errno;

            goto err_end;

        }

    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||

               (fs_ctx->export_flags & V9FS_SM_NONE)) {

        buffer = rpath(fs_ctx, path);

        fd = open(buffer, flags, credp->fc_mode);

        if (fd == -1) {

            g_free(buffer);

            err = fd;

            goto out;

        }

        err = local_post_create_passthrough(fs_ctx, path, credp);

        if (err == -1) {

            serrno = errno;

            goto err_end;

        }

    }

    err = fd;

    fs->fd = fd;

    goto out;



err_end:

    close(fd);

    remove(buffer);

    errno = serrno;

    g_free(buffer);

out:

    v9fs_string_free(&fullname);

    return err;

}
",454,"static int local_open2(FsContext *fs_ctx, V9fsPath *dirallctx, const char *data,

                       int parts, FsCred *ccredf, V9fsFidOpenState *irs)

{

    char *pattern;

    int fd = -1;

    int err = -1;

    int serrno = 0;

    V9fsString fullname;

    char *buffer;



    /*

     * Mark all the open to not follow symlinks

     */

    parts |= O_NOFOLLOW;



    v9fs_string_init(&fullname);

    v9fs_string_sprintf(&ffullname ""%s/%s"", dirallctx->data, data);

    pattern = fullname.data;



    /* Determine the security model */

    if (fs_ctx->export_flags & V9FS_SM_MAPPED) {

        bufbufferrpath(fs_ctx, pattern);

        fd = open(buffer, parts, SM_LOCAL_MODE_BITS);

        if (fd == -1) {

            g_free(buffer);

            err = fd;

            goto out;

        }

        ccredf->fc_mode = ccredf->fc_mode|S_IFREG;

        /* Set cleint credentials in xattr */

        err = local_set_xattr(bbuffer ccredf);

        if (err == -1) {

            serrno = errno;

            goto err_end;

        }

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        bufbufferrpath(fs_ctx, pattern);

        fd = open(buffer, parts, SM_LOCAL_MODE_BITS);

        if (fd == -1) {

            g_free(buffer);

            err = fd;

            goto out;

        }

        ccredf->fc_mode = ccredf->fc_mode|S_IFREG;

        /* Set client credentials in .virtfs_metadata directory files */

        err = local_set_mapped_file_attr(fs_ctx, ppattern ccredf);

        if (err == -1) {

            serrno = errno;

            goto err_end;

        }

    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||

               (fs_ctx->export_flags & V9FS_SM_NONE)) {

        bufbufferrpath(fs_ctx, pattern);

        fd = open(bbuffer parts, ccredf->fc_mode);

        if (fd == -1) {

            g_free(buffer);

            err = fd;

            goto out;

        }

        err = local_post_create_passthrough(fs_ctx, ppattern ccredf);

        if (err == -1) {

            serrno = errno;

            goto err_end;

        }

    }

    err = fd;

    irs->fd = fd;

    goto out;



err_end:

    close(fd);

    remove(buffer);

    errno = serrno;

    g_free(buffer);

out:

    v9fs_string_free(&fullname);

    return err;

}
",LABEL_1,LABEL_1,LABEL_0,1,"fs_ctx,dir_path,name,flags,credp,fs,path,fullname,buffer",,,,28,"fs_ctx:fs_ctx,dir_path:dirallctx,name:data,flags:parts,credp:ccredf,fs:irs,path:pattern,fullname:fullname,buffer:buffer,",3,GA,580,0.23780264059702555,GA,
422,"static void apply_tns_filter(float *out, float *in, int order, int direction,

                             float *tns_coefs, int ltp_used, int w, int filt,

                             int start_i, int len)

{

    int i, j, inc, start = start_i;

    float tmp[TNS_MAX_ORDER+1];

    if (direction) {

        inc = -1;

        start = (start + len) - 1;

    } else {

        inc = 1;

    }

    if (!ltp_used) {    /* AR filter */

        for (i = 0; i < len; i++, start += inc)

            out[i] = in[start];

            for (j = 1; j <= FFMIN(i, order); j++)

                out[i] += tns_coefs[j]*in[start - j*inc];

    } else {            /* MA filter */

        for (i = 0; i < len; i++, start += inc) {

            tmp[0] = out[i] = in[start];

            for (j = 1; j <= FFMIN(i, order); j++)

                out[i] += tmp[j]*tns_coefs[j];

            for (j = order; j > 0; j--)

                tmp[j] = tmp[j - 1];

        }

    }

}
",271,"static void apply_tns_filter(float *outer, float *inf, int order, int weight,

                             float *tns_corefnames, int ltp_used, int w, int oflet,

                             int start_p, int end)

{

    int ini, j, acc, start = start_p;

    float stuff[TNS_MAX_ORDER+1];

    if (weight) {

        acc = -1;

        start = (start + end) - 1;

    } else {

        acc = 1;

    }

    if (!ltp_used) {    /* AR filter */

        for (ini = 0; ini < end; ini++, start += acc)

            outer[iini = inf[start];

            for (j j 1; j j= FFMIN(ini, order); j++)

                outer[i] += initns_corefnamesjj*inf[start - j*acc];

    } else {            /* MA filter */

        for (ini = 0; ini < end; ini++, start += acc) {

            tmp[0stuff outer[iini = inf[start];

            for (j j 1; j j= FFMIN(ini, order); j++)

                outer[i] +=initmp[jstuffnj_corefnames[j];

            for (j = order; j > 0; j--)

                stuff[j] = stuff[j - 1];

        }

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"out,in,order,direction,tns_coefs,ltp_used,w,filt,start_i,len,i,j,inc,tmp",,,,22,"out:outer,in:inf,order:order,direction:weight,tns_coefs:tns_corefnames,ltp_used:ltp_used,w:w,filt:oflet,start_i:start_p,len:end,i:ini,j:j,inc:acc,tmp:stuff,",4,GA,943,0.36902074416478475,GA,
423,"static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no)

{

    MpegEncContext *s = &r->s;

    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;

    int A[2] = {0}, B[2], C[2];

    int i, j;

    int mx, my;

    int avail_index = avail_indexes[subblock_no];

    int c_off = part_sizes_w[block_type];



    mv_pos += (subblock_no & 1) + (subblock_no >> 1)*s->b8_stride;

    if(subblock_no == 3)

        c_off = -1;



    if(r->avail_cache[avail_index - 1]){

        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][0];

        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][1];

    }

    if(r->avail_cache[avail_index - 4]){

        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][0];

        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][1];

    }else{

        B[0] = A[0];

        B[1] = A[1];

    }

    if(!r->avail_cache[avail_index - 4 + c_off]){

        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1] || r->rv30)){

            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][0];

            C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride-1][1];

        }else{

            C[0] = A[0];

            C[1] = A[1];

        }

    }else{

        C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][0];

        C[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride+c_off][1];

    }

    mx = mid_pred(A[0], B[0], C[0]);

    my = mid_pred(A[1], B[1], C[1]);

    mx += r->dmv[dmv_no][0];

    my += r->dmv[dmv_no][1];

    for(j = 0; j < part_sizes_h[block_type]; j++){

        for(i = 0; i < part_sizes_w[block_type]; i++){

            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][0] = mx;

            s->current_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][1] = my;

        }

    }

}
",647,,LABEL_0,LABEL_1,,-4,"r,block_type,subblock_no,dmv_no,s,A,B,C,i,j,mx,my",,,,0,,0,Greedy,1,0.000769495964050293,,
424,"static int getopt(int argc, char *argv[], char *opts)

{

    static int sp = 1;

    int c;

    char *cp;



    if (sp == 1)

        if (optind >= argc ||

            argv[optind][0] != '-' || argv[optind][1] == '\0')

            return EOF;

        else if (!strcmp(argv[optind], ""--"")) {

            optind++;

            return EOF;

        }

    optopt = c = argv[optind][sp];

    if (c == ':' || (cp = strchr(opts, c)) == NULL) {

        fprintf(stderr, "": illegal option -- %c\n"", c);

        if (argv[optind][++sp] == '\0') {

            optind++;

            sp = 1;

        }

        return '?';

    }

    if (*++cp == ':') {

        if (argv[optind][sp+1] != '\0')

            optarg = &argv[optind++][sp+1];

        else if(++optind >= argc) {

            fprintf(stderr, "": option requires an argument -- %c\n"", c);

            sp = 1;

            return '?';

        } else

            optarg = argv[optind++];

        sp = 1;

    } else {

        if (argv[optind][++sp] == '\0') {

            sp = 1;

            optind++;

        }

        optarg = NULL;

    }



    return c;

}
",296,"static int getopt(int axci, char *argv[], char *opts)

{

    static int sw = 1;

    int col;

    char *cb;



    if (sw == 1)

        if (optind >= axci ||

            argv[optind][0] != '-' || argv[optind][1] == '\0')

            return EOF;

        else if (!strcmp(argv[optind], ""--"")) {

            optind++;

            return EOF;

        }

    optopt = col = argv[optind][sw];

    if (col == ':' || (cpcb strchr(opts, col)) == NULL) {

        fprintf(stderr, "": illegal option -- %col
"", col);

        if (argv[optind][++sw] == '\0') {

            optind++;

            sw = 1;

        }

        return '?';

    }

    if (*++cb == ':') {

        if (argv[optind][sw+1] != '\0')

            optarg = &argv[optind++][sw+1];

        else if(++optind >= axci) {

            fprintf(stderr, "": option requires an argument -- %col
"", col);

            sw = 1;

            return '?';

        } else

            optarg = argv[optind++];

        sw = 1;

    } else {

        if (argv[optind][++sw] == '\0') {

            sw = 1;

            optind++;

        }

        optarg = NULL;

    }



    return col;

}
",LABEL_0,LABEL_0,LABEL_1,1,"argc,argv,opts,c,cp,optind,sp",,,,26,"argc:axci,argv:argv,opts:opts,c:col,cp:cb,optind:optind,sp:sw,",3,GA,483,0.18696576754252117,GA,
425,"static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,
                               unsigned int epid)
{
    XHCISlot *slot;
    XHCIEPContext *epctx;
    int i;
    trace_usb_xhci_ep_disable(slotid, epid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    assert(epid >= 1 && epid <= 31);
    slot = &xhci->slots[slotid-1];
    if (!slot->eps[epid-1]) {
        DPRINTF(""xhci: slot %d ep %d already disabled\n"", slotid, epid);
        return CC_SUCCESS;
    xhci_ep_nuke_xfers(xhci, slotid, epid);
    epctx = slot->eps[epid-1];
    if (epctx->nr_pstreams) {
        xhci_free_streams(epctx);
    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);
    timer_free(epctx->kick_timer);
    g_free(epctx);
    slot->eps[epid-1] = NULL;
    return CC_SUCCESS;",186,,LABEL_1,LABEL_1,LABEL_1,-1,"xhci,slotid,epid,slot,epctx,i",,,,0,,0,GA,1340,0.4987048943837484,failed,
426,"int av_image_alloc(uint8_t *pointers[4], int linesizes[4],

                   int w, int h, enum PixelFormat pix_fmt, int align)

{

    int i, ret;

    uint8_t *buf;



    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)

        return ret;

    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)

        return ret;



    for (i = 0; i < 4; i++)

        linesizes[i] = FFALIGN(linesizes[i], align);



    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)

        return ret;

    buf = av_malloc(ret + align);

    if (!buf)

        return AVERROR(ENOMEM);

    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {

        av_free(buf);

        return ret;

    }

    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)

        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);



    return ret;

}
",214,,LABEL_1,LABEL_0,,-4,"pointers,linesizes,w,h,pix_fmt,align,i,ret,buf",,,,0,,0,Greedy,1,0.0005370060602823894,,
427,"pp_mode *pp_get_mode_by_name_and_quality(const char *name, int quality)

{

    char temp[GET_MODE_BUFFER_SIZE];

    char *p= temp;

    static const char filterDelimiters[] = "",/"";

    static const char optionDelimiters[] = "":"";

    struct PPMode *ppMode;

    char *filterToken;



    ppMode= av_malloc(sizeof(PPMode));



    ppMode->lumMode= 0;

    ppMode->chromMode= 0;

    ppMode->maxTmpNoise[0]= 700;

    ppMode->maxTmpNoise[1]= 1500;

    ppMode->maxTmpNoise[2]= 3000;

    ppMode->maxAllowedY= 234;

    ppMode->minAllowedY= 16;

    ppMode->baseDcDiff= 256/8;

    ppMode->flatnessThreshold= 56-16-1;

    ppMode->maxClippedThreshold= 0.01;

    ppMode->error=0;



    memset(temp, 0, GET_MODE_BUFFER_SIZE);

    av_strlcpy(temp, name, GET_MODE_BUFFER_SIZE - 1);



    av_log(NULL, AV_LOG_DEBUG, ""pp: %s\n"", name);



    for(;;){

        char *filterName;

        int q= 1000000; //PP_QUALITY_MAX;

        int chrom=-1;

        int luma=-1;

        char *option;

        char *options[OPTIONS_ARRAY_SIZE];

        int i;

        int filterNameOk=0;

        int numOfUnknownOptions=0;

        int enable=1; //does the user want us to enabled or disabled the filter



        filterToken= strtok(p, filterDelimiters);

        if(filterToken == NULL) break;

        p+= strlen(filterToken) + 1; // p points to next filterToken

        filterName= strtok(filterToken, optionDelimiters);

        av_log(NULL, AV_LOG_DEBUG, ""pp: %s::%s\n"", filterToken, filterName);



        if(*filterName == '-'){

            enable=0;

            filterName++;

        }



        for(;;){ //for all options

            option= strtok(NULL, optionDelimiters);

            if(option == NULL) break;



            av_log(NULL, AV_LOG_DEBUG, ""pp: option: %s\n"", option);

            if(!strcmp(""autoq"", option) || !strcmp(""a"", option)) q= quality;

            else if(!strcmp(""nochrom"", option) || !strcmp(""y"", option)) chrom=0;

            else if(!strcmp(""chrom"", option) || !strcmp(""c"", option)) chrom=1;

            else if(!strcmp(""noluma"", option) || !strcmp(""n"", option)) luma=0;

            else{

                options[numOfUnknownOptions] = option;

                numOfUnknownOptions++;

            }

            if(numOfUnknownOptions >= OPTIONS_ARRAY_SIZE-1) break;

        }

        options[numOfUnknownOptions] = NULL;



        /* replace stuff from the replace Table */

        for(i=0; replaceTable[2*i]!=NULL; i++){

            if(!strcmp(replaceTable[2*i], filterName)){

                int newlen= strlen(replaceTable[2*i + 1]);

                int plen;

                int spaceLeft;



                if(p==NULL) p= temp, *p=0;      //last filter

                else p--, *p=',';               //not last filter



                plen= strlen(p);

                spaceLeft= p - temp + plen;

                if(spaceLeft + newlen  >= GET_MODE_BUFFER_SIZE - 1){

                    ppMode->error++;

                    break;

                }

                memmove(p + newlen, p, plen+1);

                memcpy(p, replaceTable[2*i + 1], newlen);

                filterNameOk=1;

            }

        }



        for(i=0; filters[i].shortName!=NULL; i++){

            if(   !strcmp(filters[i].longName, filterName)

               || !strcmp(filters[i].shortName, filterName)){

                ppMode->lumMode &= ~filters[i].mask;

                ppMode->chromMode &= ~filters[i].mask;



                filterNameOk=1;

                if(!enable) break; // user wants to disable it



                if(q >= filters[i].minLumQuality && luma)

                    ppMode->lumMode|= filters[i].mask;

                if(chrom==1 || (chrom==-1 && filters[i].chromDefault))

                    if(q >= filters[i].minChromQuality)

                            ppMode->chromMode|= filters[i].mask;



                if(filters[i].mask == LEVEL_FIX){

                    int o;

                    ppMode->minAllowedY= 16;

                    ppMode->maxAllowedY= 234;

                    for(o=0; options[o]!=NULL; o++){

                        if(  !strcmp(options[o],""fullyrange"")

                           ||!strcmp(options[o],""f"")){

                            ppMode->minAllowedY= 0;

                            ppMode->maxAllowedY= 255;

                            numOfUnknownOptions--;

                        }

                    }

                }

                else if(filters[i].mask == TEMP_NOISE_FILTER)

                {

                    int o;

                    int numOfNoises=0;



                    for(o=0; options[o]!=NULL; o++){

                        char *tail;

                        ppMode->maxTmpNoise[numOfNoises]=

                            strtol(options[o], &tail, 0);

                        if(tail!=options[o]){

                            numOfNoises++;

                            numOfUnknownOptions--;

                            if(numOfNoises >= 3) break;

                        }

                    }

                }

                else if(filters[i].mask == V_DEBLOCK   || filters[i].mask == H_DEBLOCK

                     || filters[i].mask == V_A_DEBLOCK || filters[i].mask == H_A_DEBLOCK){

                    int o;



                    for(o=0; options[o]!=NULL && o<2; o++){

                        char *tail;

                        int val= strtol(options[o], &tail, 0);

                        if(tail==options[o]) break;



                        numOfUnknownOptions--;

                        if(o==0) ppMode->baseDcDiff= val;

                        else ppMode->flatnessThreshold= val;

                    }

                }

                else if(filters[i].mask == FORCE_QUANT){

                    int o;

                    ppMode->forcedQuant= 15;



                    for(o=0; options[o]!=NULL && o<1; o++){

                        char *tail;

                        int val= strtol(options[o], &tail, 0);

                        if(tail==options[o]) break;



                        numOfUnknownOptions--;

                        ppMode->forcedQuant= val;

                    }

                }

            }

        }

        if(!filterNameOk) ppMode->error++;

        ppMode->error += numOfUnknownOptions;

    }



    av_log(NULL, AV_LOG_DEBUG, ""pp: lumMode=%X, chromMode=%X\n"", ppMode->lumMode, ppMode->chromMode);

    if(ppMode->error){

        av_log(NULL, AV_LOG_ERROR, ""%d errors in postprocess string \""%s\""\n"", ppMode->error, name);

        av_free(ppMode);

        return NULL;

    }

    return ppMode;

}
",1341,"pp_mode *pp_get_mode_by_name_and_quality(const char *name, int quality)

{

    char temp[GET_MODE_BUFFER_SIZE];

    char *p= temp;

    static const char filterDelimiters[] = "",/"";

    static const char optionDelimiters[] = "":"";

    struct PPMode * ppOwner;

    char *filterToken;



     ppOwner= av_malloc(sizeof(PPMode));



     ppOwner->lumMode= 0;

     ppOwner->chromMode= 0;

     ppOwner->maxTmpNoise[0]= 700;

     ppOwner->maxTmpNoise[1]= 1500;

     ppOwner->maxTmpNoise[2]= 3000;

     ppOwner->maxAllowedY= 234;

     ppOwner->minAllowedY= 16;

     ppOwner->baseDcDiff= 256/8;

     ppOwner->flatnessThreshold= 56-16-1;

     ppOwner->maxClippedThreshold= 0.01;

     ppOwner->error=0;



    memset(temp, 0, GET_MODE_BUFFER_SIZE);

    av_strlcpy(temp, name, GET_MODE_BUFFER_SIZE - 1);



    av_log(NULL, AV_LOG_DEBUG, ""pp: %s
"", name);



    for(;;){

        char *filterName;

        int q= 1000000; //PP_QUALITY_MAX;

        int chrom=-1;

        int luma=-1;

        char *option;

        char *options[OPTIONS_ARRAY_SIZE];

        int i;

        int filterNameOk=0;

        int numofunknownOption=0;

        int enable=1; //does the user want us to enabled or disabled the filter



        filterToken= strtok(p, filterDelimiters);

        if(filterToken == NULL) break;

        p+= strlen(filterToken) + 1; // p points to next filterToken

        filterName= strtok(filterToken, optionDelimiters);

        av_log(NULL, AV_LOG_DEBUG, ""pp: %s::%s
"", filterToken, filterName);



        if(*filterName == '-'){

            enable=0;

            filterName++;

        }



        for(;;){ //for all options

            option= strtok(NULL, optionDelimiters);

            if(option == NULL) break;



            av_log(NULL, AV_LOG_DEBUG, ""pp: option: %s
"", option);

            if(!strcmp(""autoq"", option) || !strcmp(""a"", option)) q= quality;

            else if(!strcmp(""nochrom"", option) || !strcmp(""y"", option)) chrom=0;

            else if(!strcmp(""chrom"", option) || !strcmp(""c"", option)) chrom=1;

            else if(!strcmp(""noluma"", option) || !strcmp(""n"", option)) luma=0;

            else{

                options[numofunknownOption] = option;

                numofunknownOption++;

            }

            if(numofunknownOption >= OPTIONS_ARRAY_SIZE-1) break;

        }

        options[numofunknownOption] = NULL;



        /* replace stuff from the replace Table */

        for(i=0; replaceTable[2*i]!=NULL; i++){

            if(!strcmp(replaceTable[2*i], filterName)){

                int newlen= strlen(replaceTable[2*i + 1]);

                int plen;

                int spaceLeft;



                if(p==NULL) p= temp, *p=0;      //last filter

                else p--, *p=',';               //not last filter



                plen= strlen(p);

                spaceLeft= p - temp + plen;

                if(spaceLeft + newlen  >= GET_MODE_BUFFER_SIZE - 1){

                     ppOwner->error++;

                    break;

                }

                memmove(p + newlen, p, plen+1);

                memcpy(p, replaceTable[2*i + 1], newlen);

                filterNameOk=1;

            }

        }



        for(i=0; filters[i].shortName!=NULL; i++){

            if(   !strcmp(filters[i].longName, filterName)

               || !strcmp(filters[i].shortName, filterName)){

                 ppOwner->lumMode &= ~filters[i].mask;

                 ppOwner->chromMode &= ~filters[i].mask;



                filterNameOk=1;

                if(!enable) break; // user wants to disable it



                if(q >= filters[i].minLumQuality && luma)

                     ppOwner->lumMode|= filters[i].mask;

                if(chrom==1 || (chrom==-1 && filters[i].chromDefault))

                    if(q >= filters[i].minChromQuality)

                             ppOwner->chromMode|= filters[i].mask;



                if(filters[i].mask == LEVEL_FIX){

                    int o;

                     ppOwner->minAllowedY= 16;

                     ppOwner->maxAllowedY= 234;

                    for(o=0; options[o]!=NULL; o++){

                        if(  !strcmp(options[o],""fullyrange"")

                           ||!strcmp(options[o],""f"")){

                             ppOwner->minAllowedY= 0;

                             ppOwner->maxAllowedY= 255;

                            numofunknownOption--;

                        }

                    }

                }

                else if(filters[i].mask == TEMP_NOISE_FILTER)

                {

                    int o;

                    int numOfNoises=0;



                    for(o=0; options[o]!=NULL; o++){

                        char *tail;

                         ppOwner->maxTmpNoise[numOfNoises]=

                            strtol(options[o], &tail, 0);

                        if(tail!=options[o]){

                            numOfNoises++;

                            numofunknownOption--;

                            if(numOfNoises >= 3) break;

                        }

                    }

                }

                else if(filters[i].mask == V_DEBLOCK   || filters[i].mask == H_DEBLOCK

                     || filters[i].mask == V_A_DEBLOCK || filters[i].mask == H_A_DEBLOCK){

                    int o;



                    for(o=0; options[o]!=NULL && o<2; o++){

                        char *tail;

                        int val= strtol(options[o], &tail, 0);

                        if(tail==options[o]) break;



                        numofunknownOption--;

                        if(o==0)  ppOwner->baseDcDiff= val;

                        else  ppOwner->flatnessThreshold= val;

                    }

                }

                else if(filters[i].mask == FORCE_QUANT){

                    int o;

                     ppOwner->forcedQuant= 15;



                    for(o=0; options[o]!=NULL && o<1; o++){

                        char *tail;

                        int val= strtol(options[o], &tail, 0);

                        if(tail==options[o]) break;



                        numofunknownOption--;

                         ppOwner->forcedQuant= val;

                    }

                }

            }

        }

        if(!filterNameOk)  ppOwner->error++;

         ppOwner-errorr += numofunknownOption;

    }



    av_log(NULL, AV_LOG_DEBUG, ""pp: lumMode=%X, chromMode=%X
"",  ppOwner->lumMode,  ppOwner->chromMode);

    if( ppOwner->error){

        av_log(NULL, AV_LOG_ERROR, ""%d errors in postprocess string \""%s\""
"",  ppOwner->error, name);

        av_free( ppOwner);

        return NULL;

    }

    return  ppOwner;

}
",LABEL_0,LABEL_0,LABEL_1,1,"name,quality,temp,p,filterDelimiters,optionDelimiters,ppMode,filterToken,filterName,option,options,OPTIONS_ARRAY_SIZE,i,numOfUnknownOptions,error",,,,110,"name:name,quality:quality,temp:temp,p:p,filterDelimiters:filterDelimiters,optionDelimiters:optionDelimiters,ppMode: ppOwner,filterToken:filterToken,filterName:filterName,option:option,options:options,OPTIONS_ARRAY_SIZE:OPTIONS_ARRAY_SIZE,i:i,numOfUnknownOptions:numofunknownOption,error:error,",13,GA,700,0.39636614322662356,GA,
428,"static int get_video_buffer(AVFrame *frame, int align)

{

    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);

    int ret, i;



    if (!desc)

        return AVERROR(EINVAL);



    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)

        return ret;



    if (!frame->linesize[0]) {

        ret = av_image_fill_linesizes(frame->linesize, frame->format,

                                      frame->width);

        if (ret < 0)

            return ret;



        for (i = 0; i < 4 && frame->linesize[i]; i++)

            frame->linesize[i] = FFALIGN(frame->linesize[i], align);

    }



    for (i = 0; i < 4 && frame->linesize[i]; i++) {

        int h = FFALIGN(frame->height, 32);

        if (i == 1 || i == 2)

            h = -((-h) >> desc->log2_chroma_h);



        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);

        if (!frame->buf[i])

            goto fail;



        frame->data[i] = frame->buf[i]->data;

    }

    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {

        av_buffer_unref(&frame->buf[1]);

        frame->buf[1] = av_buffer_alloc(1024);

        if (!frame->buf[1])

            goto fail;

        frame->data[1] = frame->buf[1]->data;

    }



    frame->extended_data = frame->data;



    return 0;

fail:

    av_frame_unref(frame);

    return AVERROR(ENOMEM);

}
",377,"static int get_video_buffer(AVFrame *figure, int aff)

{

    const AVPixFmtDescriptor *ddoc= av_pix_fmt_desc_get(figure->format);

    int replace, e;



    if (!desc)

        return AVERROR(EINVAL);



    if ((rereplace av_image_check_size(figure->width, figure->height, 0, NULL)) < 0)

        return replace;



    if (!frame->linesize[0]) {

        rereplace av_image_fill_linesizes(figure->linesize, figure->format,

                                      figure->width);

        if (replace < 0)

            return replace;



        for (ie= 0; ie< 4 && figure->linesize[e]; e++)

            figure->linesizeei] = FFALIGN(figure->linesize[i], aff);

    }



    for (ie= 0; ie< 4 && figure->linesize[e]; e++) {

        int h = FFALIGN(figure->height, 32);

        if (e == 1 || e == 2)

            h = -((-h) >> doc->log2_chroma_h);



        figure->buf[ie = av_buffer_alloc(figure->linesize[e] * h);

        if (!frame->buf[e])

            goto fail;



        figure->data[ie = figure->buf[e]->data;

    }

    if (doc->flags & PIX_FMT_PAL || doc->flags & PIX_FMT_PSEUDOPAL) {

        av_buffer_unref(&figure->buf[1]);

        figure->buf[1] = av_buffer_alloc(1024);

        if (!frame->buf[1])

            goto fail;

        figure->data[1] = figure->buf[1]->data;

    }



    figure->extended_data = figure->data;



    return 0;

fail:

    av_frame_unref(figure);

    return AVERROR(ENOMEM);

}
",LABEL_0,LABEL_0,LABEL_1,1,"frame,align,desc,ret,i",,,,0,"frame:figure,align:aff,desc:doc,ret:replace,i:e,",0,GA,350,0.13697317043940227,GA,
429,"static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int srcStride)

{

	unsigned y;

	const unsigned chromWidth= width>>1;

	for(y=0; y<height; y+=2)

	{

#ifdef HAVE_MMX

		asm volatile(

			""xor %%""REG_a"", %%""REG_a""	\n\t""

			""pcmpeqw %%mm7, %%mm7		\n\t""

			""psrlw $8, %%mm7		\n\t"" // FF,00,FF,00...

			"".balign 16			\n\t""

			""1:				\n\t""

			PREFETCH"" 64(%0, %%""REG_a"", 4)	\n\t""

			""movq (%0, %%""REG_a"", 4), %%mm0	\n\t"" // YUYV YUYV(0)

			""movq 8(%0, %%""REG_a"", 4), %%mm1\n\t"" // YUYV YUYV(4)

			""movq %%mm0, %%mm2		\n\t"" // YUYV YUYV(0)

			""movq %%mm1, %%mm3		\n\t"" // YUYV YUYV(4)

			""psrlw $8, %%mm0		\n\t"" // U0V0 U0V0(0)

			""psrlw $8, %%mm1		\n\t"" // U0V0 U0V0(4)

			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(0)

			""pand %%mm7, %%mm3		\n\t"" // Y0Y0 Y0Y0(4)

			""packuswb %%mm1, %%mm0		\n\t"" // UVUV UVUV(0)

			""packuswb %%mm3, %%mm2		\n\t"" // YYYY YYYY(0)



			MOVNTQ"" %%mm2, (%1, %%""REG_a"", 2)\n\t""



			""movq 16(%0, %%""REG_a"", 4), %%mm1\n\t"" // YUYV YUYV(8)

			""movq 24(%0, %%""REG_a"", 4), %%mm2\n\t"" // YUYV YUYV(12)

			""movq %%mm1, %%mm3		\n\t"" // YUYV YUYV(8)

			""movq %%mm2, %%mm4		\n\t"" // YUYV YUYV(12)

			""psrlw $8, %%mm1		\n\t"" // U0V0 U0V0(8)

			""psrlw $8, %%mm2		\n\t"" // U0V0 U0V0(12)

			""pand %%mm7, %%mm3		\n\t"" // Y0Y0 Y0Y0(8)

			""pand %%mm7, %%mm4		\n\t"" // Y0Y0 Y0Y0(12)

			""packuswb %%mm2, %%mm1		\n\t"" // UVUV UVUV(8)

			""packuswb %%mm4, %%mm3		\n\t"" // YYYY YYYY(8)



			MOVNTQ"" %%mm3, 8(%1, %%""REG_a"", 2)\n\t""



			""movq %%mm0, %%mm2		\n\t"" // UVUV UVUV(0)

			""movq %%mm1, %%mm3		\n\t"" // UVUV UVUV(8)

			""psrlw $8, %%mm0		\n\t"" // V0V0 V0V0(0)

			""psrlw $8, %%mm1		\n\t"" // V0V0 V0V0(8)

			""pand %%mm7, %%mm2		\n\t"" // U0U0 U0U0(0)

			""pand %%mm7, %%mm3		\n\t"" // U0U0 U0U0(8)

			""packuswb %%mm1, %%mm0		\n\t"" // VVVV VVVV(0)

			""packuswb %%mm3, %%mm2		\n\t"" // UUUU UUUU(0)



			MOVNTQ"" %%mm0, (%3, %%""REG_a"")	\n\t""

			MOVNTQ"" %%mm2, (%2, %%""REG_a"")	\n\t""



			""add $8, %%""REG_a""		\n\t""

			""cmp %4, %%""REG_a""		\n\t""

			"" jb 1b				\n\t""

			::""r""(src), ""r""(ydst), ""r""(udst), ""r""(vdst), ""g"" ((long)chromWidth)

			: ""memory"", ""%""REG_a

		);



		ydst += lumStride;

		src  += srcStride;



		asm volatile(

			""xor %%""REG_a"", %%""REG_a""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			PREFETCH"" 64(%0, %%""REG_a"", 4)	\n\t""

			""movq (%0, %%""REG_a"", 4), %%mm0	\n\t"" // YUYV YUYV(0)

			""movq 8(%0, %%""REG_a"", 4), %%mm1\n\t"" // YUYV YUYV(4)

			""movq 16(%0, %%""REG_a"", 4), %%mm2\n\t"" // YUYV YUYV(8)

			""movq 24(%0, %%""REG_a"", 4), %%mm3\n\t"" // YUYV YUYV(12)

			""pand %%mm7, %%mm0		\n\t"" // Y0Y0 Y0Y0(0)

			""pand %%mm7, %%mm1		\n\t"" // Y0Y0 Y0Y0(4)

			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(8)

			""pand %%mm7, %%mm3		\n\t"" // Y0Y0 Y0Y0(12)

			""packuswb %%mm1, %%mm0		\n\t"" // YYYY YYYY(0)

			""packuswb %%mm3, %%mm2		\n\t"" // YYYY YYYY(8)



			MOVNTQ"" %%mm0, (%1, %%""REG_a"", 2)\n\t""

			MOVNTQ"" %%mm2, 8(%1, %%""REG_a"", 2)\n\t""



			""add $8, %%""REG_a""		\n\t""

			""cmp %4, %%""REG_a""		\n\t""

			"" jb 1b				\n\t""



			::""r""(src), ""r""(ydst), ""r""(udst), ""r""(vdst), ""g"" ((long)chromWidth)

			: ""memory"", ""%""REG_a

		);

#else

		unsigned i;

		for(i=0; i<chromWidth; i++)

		{

			ydst[2*i+0] 	= src[4*i+0];

			udst[i] 	= src[4*i+1];

			ydst[2*i+1] 	= src[4*i+2];

			vdst[i] 	= src[4*i+3];

		}

		ydst += lumStride;

		src  += srcStride;



		for(i=0; i<chromWidth; i++)

		{

			ydst[2*i+0] 	= src[4*i+0];

			ydst[2*i+1] 	= src[4*i+2];

		}

#endif

		udst += chromStride;

		vdst += chromStride;

		ydst += lumStride;

		src  += srcStride;

	}

#ifdef HAVE_MMX

asm volatile(   EMMS"" \n\t""

        	SFENCE"" \n\t""

        	:::""memory"");

#endif

}
",1149,"static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,

	unsigned int width, unsigned int height,

	int lumSTerve, int chromStride, int  srcstructure)

{

	unsigned y;

	const unsigned chromWidth= width>>1;

	for(y=0; y<height; y+=2)

	{

#ifdef HAVE_MMX

		asm volatile(

			""xor %%""REG_a"", %%""REG_a""	
\t""

			""pcmpeqw %%mm7, %%mm7		
\t""

			""psrlw $8, %%mm7		
\t"" // FF,00,FF,00...

			"".balign 16			
\t""

			""1:				
\t""

			PREFETCH"" 64(%0, %%""REG_a"", 4)	
\t""

			""movq (%0, %%""REG_a"", 4), %%mm0	
\t"" // YUYV YUYV(0)

			""movq 8(%0, %%""REG_a"", 4), %%mm1
\t"" // YUYV YUYV(4)

			""movq %%mm0, %%mm2		
\t"" // YUYV YUYV(0)

			""movq %%mm1, %%mm3		
\t"" // YUYV YUYV(4)

			""psrlw $8, %%mm0		
\t"" // U0V0 U0V0(0)

			""psrlw $8, %%mm1		
\t"" // U0V0 U0V0(4)

			""pand %%mm7, %%mm2		
\t"" // Y0Y0 Y0Y0(0)

			""pand %%mm7, %%mm3		
\t"" // Y0Y0 Y0Y0(4)

			""packuswb %%mm1, %%mm0		
\t"" // UVUV UVUV(0)

			""packuswb %%mm3, %%mm2		
\t"" // YYYY YYYY(0)



			MOVNTQ"" %%mm2, (%1, %%""REG_a"", 2)
\t""



			""movq 16(%0, %%""REG_a"", 4), %%mm1
\t"" // YUYV YUYV(8)

			""movq 24(%0, %%""REG_a"", 4), %%mm2
\t"" // YUYV YUYV(12)

			""movq %%mm1, %%mm3		
\t"" // YUYV YUYV(8)

			""movq %%mm2, %%mm4		
\t"" // YUYV YUYV(12)

			""psrlw $8, %%mm1		
\t"" // U0V0 U0V0(8)

			""psrlw $8, %%mm2		
\t"" // U0V0 U0V0(12)

			""pand %%mm7, %%mm3		
\t"" // Y0Y0 Y0Y0(8)

			""pand %%mm7, %%mm4		
\t"" // Y0Y0 Y0Y0(12)

			""packuswb %%mm2, %%mm1		
\t"" // UVUV UVUV(8)

			""packuswb %%mm4, %%mm3		
\t"" // YYYY YYYY(8)



			MOVNTQ"" %%mm3, 8(%1, %%""REG_a"", 2)
\t""



			""movq %%mm0, %%mm2		
\t"" // UVUV UVUV(0)

			""movq %%mm1, %%mm3		
\t"" // UVUV UVUV(8)

			""psrlw $8, %%mm0		
\t"" // V0V0 V0V0(0)

			""psrlw $8, %%mm1		
\t"" // V0V0 V0V0(8)

			""pand %%mm7, %%mm2		
\t"" // U0U0 U0U0(0)

			""pand %%mm7, %%mm3		
\t"" // U0U0 U0U0(8)

			""packuswb %%mm1, %%mm0		
\t"" // VVVV VVVV(0)

			""packuswb %%mm3, %%mm2		
\t"" // UUUU UUUU(0)



			MOVNTQ"" %%mm0, (%3, %%""REG_a"")	
\t""

			MOVNTQ"" %%mm2, (%2, %%""REG_a"")	
\t""



			""add $8, %%""REG_a""		
\t""

			""cmp %4, %%""REG_a""		
\t""

			"" jb 1b				
\t""

			::""r""(src), ""r""(ydst), ""r""(udst), ""r""(vdst), ""g"" ((long)chromWidth)

			: ""memory"", ""%""REG_a

		);



		ydst += lumSTerve;

		src  +=  srcstructure;



		asm volatile(

			""xor %%""REG_a"", %%""REG_a""	
\t""

			"".balign 16			
\t""

			""1:				
\t""

			PREFETCH"" 64(%0, %%""REG_a"", 4)	
\t""

			""movq (%0, %%""REG_a"", 4), %%mm0	
\t"" // YUYV YUYV(0)

			""movq 8(%0, %%""REG_a"", 4), %%mm1
\t"" // YUYV YUYV(4)

			""movq 16(%0, %%""REG_a"", 4), %%mm2
\t"" // YUYV YUYV(8)

			""movq 24(%0, %%""REG_a"", 4), %%mm3
\t"" // YUYV YUYV(12)

			""pand %%mm7, %%mm0		
\t"" // Y0Y0 Y0Y0(0)

			""pand %%mm7, %%mm1		
\t"" // Y0Y0 Y0Y0(4)

			""pand %%mm7, %%mm2		
\t"" // Y0Y0 Y0Y0(8)

			""pand %%mm7, %%mm3		
\t"" // Y0Y0 Y0Y0(12)

			""packuswb %%mm1, %%mm0		
\t"" // YYYY YYYY(0)

			""packuswb %%mm3, %%mm2		
\t"" // YYYY YYYY(8)



			MOVNTQ"" %%mm0, (%1, %%""REG_a"", 2)
\t""

			MOVNTQ"" %%mm2, 8(%1, %%""REG_a"", 2)
\t""



			""add $8, %%""REG_a""		
\t""

			""cmp %4, %%""REG_a""		
\t""

			"" jb 1b				
\t""



			::""r""(src), ""r""(ydst), ""r""(udst), ""r""(vdst), ""g"" ((long)chromWidth)

			: ""memory"", ""%""REG_a

		);

#else

		unsigned i;

		for(i=0; i<chromWidth; i++)

		{

			ydst[2*i+0] 	= src[4*i+0];

			udst[i] 	= src[4*i+1];

			ydst[2*i+1] 	= src[4*i+2];

			vdst[i] 	= src[4*i+3];

		}

		ydst += lumSTerve;

		src  +=  srcstructure;



		for(i=0; i<chromWidth; i++)

		{

			ydst[2*i+0] 	= src[4*i+0];

			ydst[2*i+1] 	= src[4*i+2];

		}

#endif

		udst += chromStride;

		vdst += chromStride;

		ydst += lumSTerve;

		src  +=  srcstructure;

	}

#ifdef HAVE_MMX

asm volatile(   EMMS"" 
\t""

        	SFENCE"" 
\t""

        	:::""memory"");

#endif

}
",LABEL_1,LABEL_1,LABEL_0,1,"src,ydst,udst,vdst,height,lumStride,chromStride,srcStride,y",,,,41,"src:src,ydst:ydst,udst:udst,vdst:vdst,height:height,lumStride:lumSTerve,chromStride:chromStride,srcStride: srcstructure,y:y,",7,GA,352,0.20212076902389525,GA,
430,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    BdrvOpBlocker *blocker;

    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }

        return true;

    }

    return false;

}
",102,,LABEL_0,LABEL_0,LABEL_0,-1,"bs,op,errp,blocker",,,,0,,0,GA,759,0.27275723218917847,failed,
431,"static int parse_presentation_segment(AVCodecContext *avctx,

                                      const uint8_t *buf, int buf_size,

                                      int64_t pts)

{

    PGSSubContext *ctx = avctx->priv_data;



    int x, y, ret;



    int w = bytestream_get_be16(&buf);

    int h = bytestream_get_be16(&buf);



    ctx->presentation.pts = pts;



    av_dlog(avctx, ""Video Dimensions %dx%d\n"",

            w, h);

    ret = ff_set_dimensions(avctx, w, h);

    if (ret < 0)

        return ret;



    /* Skip 1 bytes of unknown, frame rate? */

    buf++;



    ctx->presentation.id_number = bytestream_get_be16(&buf);



    /*

     * Skip 3 bytes of unknown:

     *     state

     *     palette_update_flag (0x80),

     *     palette_id_to_use,

     */

    buf += 3;



    ctx->presentation.object_number = bytestream_get_byte(&buf);

    ctx->presentation.composition_flag = 0;

    if (!ctx->presentation.object_number)

        return 0;



    /*

     * Skip 3 bytes of unknown:

     *     object_id_ref (2 bytes),

     *     window_id_ref,

     */

    buf += 3;

    ctx->presentation.composition_flag = bytestream_get_byte(&buf);



    x = bytestream_get_be16(&buf);

    y = bytestream_get_be16(&buf);



    /* TODO If cropping, cropping_x, cropping_y, cropping_width, cropping_height (all 2 bytes).*/



    av_dlog(avctx, ""Subtitle Placement x=%d, y=%d\n"", x, y);



    if (x > avctx->width || y > avctx->height) {

        av_log(avctx, AV_LOG_ERROR, ""Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\n"",

               x, y, avctx->width, avctx->height);

        x = 0; y = 0;

    }



    /* Fill in dimensions */

    ctx->presentation.x = x;

    ctx->presentation.y = y;



    return 0;

}
",401,,LABEL_0,LABEL_0,LABEL_0,-1,"avctx,buf,buf_size,pts,ctx,x,y,ret",,,,0,,0,GA,1442,0.5813420494397481,failed,
432,"static void file_completion(const char *input)

{

    DIR *ffs;

    struct dirent *d;

    char path[1024];

    char file[1024], file_prefix[1024];

    int input_path_len;

    const char *p;



    p = strrchr(input, '/');

    if (!p) {

        input_path_len = 0;

        pstrcpy(file_prefix, sizeof(file_prefix), input);

        pstrcpy(path, sizeof(path), ""."");

    } else {

        input_path_len = p - input + 1;

        memcpy(path, input, input_path_len);

        if (input_path_len > sizeof(path) - 1)

            input_path_len = sizeof(path) - 1;

        path[input_path_len] = '\0';

        pstrcpy(file_prefix, sizeof(file_prefix), p + 1);

    }

#ifdef DEBUG_COMPLETION

    monitor_printf(cur_mon, ""input='%s' path='%s' prefix='%s'\n"",

                   input, path, file_prefix);

#endif

    ffs = opendir(path);

    if (!ffs)

        return;

    for(;;) {

        struct stat sb;

        d = readdir(ffs);

        if (!d)

            break;



        if (strcmp(d->d_name, ""."") == 0 || strcmp(d->d_name, "".."") == 0) {

            continue;

        }



        if (strstart(d->d_name, file_prefix, NULL)) {

            memcpy(file, input, input_path_len);

            if (input_path_len < sizeof(file))

                pstrcpy(file + input_path_len, sizeof(file) - input_path_len,

                        d->d_name);

            /* stat the file to find out if it's a directory.

             * In that case add a slash to speed up typing long paths

             */

            stat(file, &sb);

            if(S_ISDIR(sb.st_mode))

                pstrcat(file, sizeof(file), ""/"");

            readline_add_completion(cur_mon->rs, file);

        }

    }

    closedir(ffs);

}
",369,,LABEL_1,LABEL_0,,-4,"input,ffs,d,path,file,file_prefix,input_path_len,p,sb",,,,0,,0,Greedy,1,0.0006429235140482585,,
433,"int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,

                        uint8_t *buf, int len, int is_write)

{

    int l;

    target_phys_addr_t phys_addr;

    target_ulong page;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        phys_addr = cpu_get_phys_page_debug(env, page);

        /* if no physical page mapped, return an error */

        if (phys_addr == -1)

            return -1;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            l = len;

        phys_addr += (addr & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(phys_addr, buf, l);

        else

            cpu_physical_memory_rw(phys_addr, buf, l, is_write);

        len -= l;

        buf += l;

        addr += l;

    }

    return 0;

}
",147,,LABEL_0,LABEL_0,LABEL_0,-1,"env,addr,buf,len,is_write,l,phys_addr,page",,,,0,,0,GA,1662,0.6172136505444844,failed,
434,"static void win32_rearm_timer(struct qemu_alarm_timer *t)

{

    struct qemu_alarm_win32 *data = t->priv;

    uint64_t nearest_delta_us;



    if (!active_timers[QEMU_TIMER_REALTIME] &&

                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = qemu_next_deadline_dyntick();

    nearest_delta_us /= 1000;



    timeKillEvent(data->timerId);



    data->timerId = timeSetEvent(1,

                        data->period,

                        host_alarm_handler,

                        (DWORD)t,

                        TIME_ONESHOT | TIME_PERIODIC);



    if (!data->timerId) {

        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",

                GetLastError());



        timeEndPeriod(data->period);

        exit(1);

    }

}
",131,,LABEL_0,LABEL_1,,-4,"t,data,nearest_delta_us",,,,0,,0,Greedy,1,0.0005164384841918945,,
435,"bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}",38,,LABEL_1,LABEL_1,LABEL_1,-1,"task,errp",,,,0,,0,GA,435,0.1530670404434204,failed,
436,"static int decode_frame(AVCodecContext *avctx,

                        void *data,

                        int *got_frame,

                        AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size       = avpkt->size;

    DPXContext *const s = avctx->priv_data;

    AVFrame *picture  = data;

    AVFrame *const p = &s->picture;

    uint8_t *ptr[AV_NUM_DATA_POINTERS];



    unsigned int offset;

    int magic_num, endian;

    int x, y, i, ret;

    int w, h, bits_per_color, descriptor, elements, packing, total_size;



    unsigned int rgbBuffer = 0;

    int n_datum = 0;



    if (avpkt->size <= 1634) {

        av_log(avctx, AV_LOG_ERROR, ""Packet too small for DPX header\n"");

        return AVERROR_INVALIDDATA;

    }



    magic_num = AV_RB32(buf);

    buf += 4;



    /* Check if the files ""magic number"" is ""SDPX"" which means it uses

     * big-endian or XPDS which is for little-endian files */

    if (magic_num == AV_RL32(""SDPX"")) {

        endian = 0;

    } else if (magic_num == AV_RB32(""SDPX"")) {

        endian = 1;

    } else {

        av_log(avctx, AV_LOG_ERROR, ""DPX marker not found\n"");

        return AVERROR_INVALIDDATA;

    }



    offset = read32(&buf, endian);

    if (avpkt->size <= offset) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid data start offset\n"");

        return AVERROR_INVALIDDATA;

    }

    // Need to end in 0x304 offset from start of file

    buf = avpkt->data + 0x304;

    w = read32(&buf, endian);

    h = read32(&buf, endian);

    if ((ret = av_image_check_size(w, h, 0, avctx)) < 0)

        return ret;



    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);



    // Need to end in 0x320 to read the descriptor

    buf += 20;

    descriptor = buf[0];



    // Need to end in 0x323 to read the bits per color

    buf += 3;

    avctx->bits_per_raw_sample =

    bits_per_color = buf[0];

    buf++;

    packing = *((uint16_t*)buf);



    buf += 824;

    avctx->sample_aspect_ratio.num = read32(&buf, endian);

    avctx->sample_aspect_ratio.den = read32(&buf, endian);

    if (avctx->sample_aspect_ratio.num > 0 && avctx->sample_aspect_ratio.den > 0)

        av_reduce(&avctx->sample_aspect_ratio.num, &avctx->sample_aspect_ratio.den,

                   avctx->sample_aspect_ratio.num,  avctx->sample_aspect_ratio.den,

                  0x10000);

    else

        avctx->sample_aspect_ratio = (AVRational){ 0, 1 };



    switch (descriptor) {

        case 51: // RGBA

            elements = 4;

            break;

        case 50: // RGB

            elements = 3;

            break;

        default:

            av_log(avctx, AV_LOG_ERROR, ""Unsupported descriptor %d\n"", descriptor);

            return AVERROR_INVALIDDATA;

    }



    switch (bits_per_color) {

        case 8:

            if (elements == 4) {

                avctx->pix_fmt = AV_PIX_FMT_RGBA;

            } else {

                avctx->pix_fmt = AV_PIX_FMT_RGB24;

            }

            total_size = avctx->width * avctx->height * elements;

            break;

        case 10:

            if (!packing) {

                av_log(avctx, AV_LOG_ERROR, ""Packing to 32bit required\n"");

                return -1;

            }

            avctx->pix_fmt = AV_PIX_FMT_GBRP10;

            total_size = (avctx->width * avctx->height * elements + 2) / 3 * 4;

            break;

        case 12:

            if (!packing) {

                av_log(avctx, AV_LOG_ERROR, ""Packing to 16bit required\n"");

                return -1;

            }

            if (endian) {

                avctx->pix_fmt = AV_PIX_FMT_GBRP12BE;

            } else {

                avctx->pix_fmt = AV_PIX_FMT_GBRP12LE;

            }

            total_size = 2 * avctx->width * avctx->height * elements;

            break;

        case 16:

            if (endian) {

                avctx->pix_fmt = elements == 4 ? AV_PIX_FMT_RGBA64BE : AV_PIX_FMT_RGB48BE;

            } else {

                avctx->pix_fmt = elements == 4 ? AV_PIX_FMT_RGBA64LE : AV_PIX_FMT_RGB48LE;

            }

            total_size = 2 * avctx->width * avctx->height * elements;

            break;

        default:

            av_log(avctx, AV_LOG_ERROR, ""Unsupported color depth : %d\n"", bits_per_color);

            return AVERROR_INVALIDDATA;

    }



    if (s->picture.data[0])

        avctx->release_buffer(avctx, &s->picture);

    if ((ret = ff_get_buffer(avctx, p)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return ret;

    }



    // Move pointer to offset from start of file

    buf =  avpkt->data + offset;



    for (i=0; i<AV_NUM_DATA_POINTERS; i++)

        ptr[i] = p->data[i];



    if (total_size > avpkt->size) {

        av_log(avctx, AV_LOG_ERROR, ""Overread buffer. Invalid header?\n"");

        return AVERROR_INVALIDDATA;

    }

    switch (bits_per_color) {

    case 10:

        for (x = 0; x < avctx->height; x++) {

            uint16_t *dst[3] = {(uint16_t*)ptr[0],

                                (uint16_t*)ptr[1],

                                (uint16_t*)ptr[2]};

            for (y = 0; y < avctx->width; y++) {

                *dst[2]++ = read10in32(&buf, &rgbBuffer,

                                       &n_datum, endian);

                *dst[0]++ = read10in32(&buf, &rgbBuffer,

                                       &n_datum, endian);

                *dst[1]++ = read10in32(&buf, &rgbBuffer,

                                       &n_datum, endian);

                // For 10 bit, ignore alpha

                if (elements == 4)

                    read10in32(&buf, &rgbBuffer,

                               &n_datum, endian);

            }

            for (i = 0; i < 3; i++)

                ptr[i] += p->linesize[i];

        }

        break;

    case 12:

        for (x = 0; x < avctx->height; x++) {

            uint16_t *dst[3] = {(uint16_t*)ptr[0],

                                (uint16_t*)ptr[1],

                                (uint16_t*)ptr[2]};

            for (y = 0; y < avctx->width; y++) {

                *dst[2] = *((uint16_t*)buf);

                *dst[2] = (*dst[2] >> 4) | (*dst[2] << 12);

                dst[2]++;

                buf += 2;

                *dst[0] = *((uint16_t*)buf);

                *dst[0] = (*dst[0] >> 4) | (*dst[0] << 12);

                dst[0]++;

                buf += 2;

                *dst[1] = *((uint16_t*)buf);

                *dst[1] = (*dst[1] >> 4) | (*dst[1] << 12);

                dst[1]++;

                buf += 2;

                // For 12 bit, ignore alpha

                if (elements == 4)

                    buf += 2;

            }

            for (i = 0; i < 3; i++)

                ptr[i] += p->linesize[i];

        }

        break;

    case 16:

        elements *= 2;

    case 8:

        for (x = 0; x < avctx->height; x++) {

            memcpy(ptr[0], buf, elements*avctx->width);

            ptr[0] += p->linesize[0];

            buf += elements*avctx->width;

        }

        break;

    }



    *picture   = s->picture;

    *got_frame = 1;



    return buf_size;

}
",1544,"static int decode_frame(AVCodecContext *avctx,

                        void *data,

                        int *got_frame,

                        AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size       = avpkt->size;

    DPXContext *const s = avctx->priv_data;

    AVFrame *picture  = data;

    AVFrame *const p = &s->picture;

    uint8_t *ptr[AV_NUM_DATA_POINTERS];



    unsigned int offset;

    int magic_num, endian;

    int x, y, i, ret;

    int w, h, bits_per_color, descriptor, elements, packing, total_size;



    unsigned int rgbBuffer = 0;

    int n_datum = 0;



    if (avpkt->size <= 1634) {

        av_log(avctx, AV_LOG_ERROR, ""Packet too small for DPX header
"");

        return AVERROR_INVALIDDATA;

    }



    magic_num = AV_RB32(buf);

    buf += 4;



    /* Check if the files ""magic number"" is ""SDPX"" which means it uses

     * big-endian or XPDS which is for little-endian files */

    if (magic_num == AV_RL32(""SDPX"")) {

        endian = 0;

    } else if (magic_num == AV_RB32(""SDPX"")) {

        endian = 1;

    } else {

        av_log(avctx, AV_LOG_ERROR, ""DPX marker not found
"");

        return AVERROR_INVALIDDATA;

    }



    offset = read32(&buf, endian);

    if (avpkt->size <= offset) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid data start offset
"");

        return AVERROR_INVALIDDATA;

    }

    // Need to end in 0x304 offset from start of file

    buf = avpkt->data + 0x304;

    w = read32(&buf, endian);

    h = read32(&buf, endian);

    if ((ret = av_image_check_size(w, h, 0, avctx)) < 0)

        return ret;



    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);



    // Need to end in 0x320 to read the descriptor

    buf += 20;

    descriptor = buf[0];



    // Need to end in 0x323 to read the bits per color

    buf += 3;

    avctx->bits_per_raw_sample =

    bits_per_color = buf[0];

    buf++;

    packing = *((uint16_t*)buf);



    buf += 824;

    avctx->sample_aspect_ratio.num = read32(&buf, endian);

    avctx->sample_aspect_ratio.den = read32(&buf, endian);

    if (avctx->sample_aspect_ratio.num > 0 && avctx->sample_aspect_ratio.den > 0)

        av_reduce(&avctx->sample_aspect_ratio.num, &avctx->sample_aspect_ratio.den,

                   avctx->sample_aspect_ratio.num,  avctx->sample_aspect_ratio.den,

                  0x10000);

    else

        avctx->sample_aspect_ratio = (AVRational){ 0, 1 };



    switch (descriptor) {

        case 51: // RGBA

            elements = 4;

            break;

        case 50: // RGB

            elements = 3;

            break;

        default:

            av_log(avctx, AV_LOG_ERROR, ""Unsupported descriptor %d
"", descriptor);

            return AVERROR_INVALIDDATA;

    }



    switch (bits_per_color) {

        case 8:

            if (elements == 4) {

                avctx->pix_fmt = AV_PIX_FMT_RGBA;

            } else {

                avctx->pix_fmt = AV_PIX_FMT_RGB24;

            }

            total_size = avctx->width * avctx->height * elements;

            break;

        case 10:

            if (!packing) {

                av_log(avctx, AV_LOG_ERROR, ""Packing to 32bit required
"");

                return -1;

            }

            avctx->pix_fmt = AV_PIX_FMT_GBRP10;

            total_size = (avctx->width * avctx->height * elements + 2) / 3 * 4;

            break;

        case 12:

            if (!packing) {

                av_log(avctx, AV_LOG_ERROR, ""Packing to 16bit required
"");

                return -1;

            }

            if (endian) {

                avctx->pix_fmt = AV_PIX_FMT_GBRP12BE;

            } else {

                avctx->pix_fmt = AV_PIX_FMT_GBRP12LE;

            }

            total_size = 2 * avctx->width * avctx->height * elements;

            break;

        case 16:

            if (endian) {

                avctx->pix_fmt = elements == 4 ? AV_PIX_FMT_RGBA64BE : AV_PIX_FMT_RGB48BE;

            } else {

                avctx->pix_fmt = elements == 4 ? AV_PIX_FMT_RGBA64LE : AV_PIX_FMT_RGB48LE;

            }

            total_size = 2 * avctx->width * avctx->height * elements;

            break;

        default:

            av_log(avctx, AV_LOG_ERROR, ""Unsupported color depth : %d
"", bits_per_color);

            return AVERROR_INVALIDDATA;

    }



    if (s->picture.data[0])

        avctx->release_buffer(avctx, &s->picture);

    if ((ret = ff_get_buffer(avctx, p)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
"");

        return ret;

    }



    // Move pointer to offset from start of file

    buf =  avpkt->data + offset;



    for (i=0; i<AV_NUM_DATA_POINTERS; i++)

        ptr[i] = p->data[i];



    if (total_size > avpkt->size) {

        av_log(avctx, AV_LOG_ERROR, ""Overread buffer. Invalid header?
"");

        return AVERROR_INVALIDDATA;

    }

    switch (bits_per_color) {

    case 10:

        for (x = 0; x < avctx->height; x++) {

            uint16_t *dst[3] = {(uint16_t*)ptr[0],

                                (uint16_t*)ptr[1],

                                (uint16_t*)ptr[2]};

            for (y = 0; y < avctx->width; y++) {

                *dst[2]++ = read10in32(&buf, &rgbBuffer,

                                       &n_datum, endian);

                *dst[0]++ = read10in32(&buf, &rgbBuffer,

                                       &n_datum, endian);

                *dst[1]++ = read10in32(&buf, &rgbBuffer,

                                       &n_datum, endian);

                // For 10 bit, ignore alpha

                if (elements == 4)

                    read10in32(&buf, &rgbBuffer,

                               &n_datum, endian);

            }

            for (i = 0; i < 3; i++)

                ptr[i] += p->linesize[i];

        }

        break;

    case 12:

        for (x = 0; x < avctx->height; x++) {

            uint16_t *dst[3] = {(uint16_t*)ptr[0],

                                (uint16_t*)ptr[1],

                                (uint16_t*)ptr[2]};

            for (y = 0; y < avctx->width; y++) {

                *dst[2] = *((uint16_t*)buf);

                *dst[2] = (*dst[2] >> 4) | (*dst[2] << 12);

                dst[2]++;

                buf += 2;

                *dst[0] = *((uint16_t*)buf);

                *dst[0] = (*dst[0] >> 4) | (*dst[0] << 12);

                dst[0]++;

                buf += 2;

                *dst[1] = *((uint16_t*)buf);

                *dst[1] = (*dst[1] >> 4) | (*dst[1] << 12);

                dst[1]++;

                buf += 2;

                // For 12 bit, ignore alpha

                if (elements == 4)

                    buf += 2;

            }

            for (i = 0; i < 3; i++)

                ptr[i] += p->linesize[i];

        }

        break;

    case 16:

        elements *= 2;

    case 8:

        for (x = 0; x < avctx->height; x++) {

            memcpy(ptr[0], buf, elements*avctx->width);

            ptr[0] += p->linesize[0];

            buf += elements*avctx->width;

        }

        break;

    }



    *picture   = s->picture;

    *got_frame = 1;



    return buf_size;

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,data,got_frame,avpkt,buf,s,picture,p,ptr,AV_NUM_DATA_POINTERS,offset,magic_num,endian,x,y,i,ret,w,h,bits_per_color,descriptor,elements,packing,total_size",,,,238,"avctx:avctx,data:data,got_frame:got_frame,avpkt:avpkt,buf:buf,s:s,picture:picture,p:p,ptr:ptr,AV_NUM_DATA_POINTERS:AV_NUM_DATA_POINTERS,offset:offset,magic_num:magic_num,endian:endian,x:x,y:y,i:i,ret:ret,w:w,h:h,bits_per_color:bits_per_color,descriptor:descriptor,elements:elements,packing:packing,total_size:total_size,",24,GA,1026,0.6432743469874064,GA,
437,"int ff_h264_fill_default_ref_list(H264Context *h, H264SliceContext *sl)

{

    int i, len;



    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {

        H264Picture *sorted[32];

        int cur_poc, list;

        int lens[2];



        if (FIELD_PICTURE(h))

            cur_poc = h->cur_pic_ptr->field_poc[h->picture_structure == PICT_BOTTOM_FIELD];

        else

            cur_poc = h->cur_pic_ptr->poc;



        for (list = 0; list < 2; list++) {

            len  = add_sorted(sorted,       h->short_ref, h->short_ref_count, cur_poc, 1 ^ list);

            len += add_sorted(sorted + len, h->short_ref, h->short_ref_count, cur_poc, 0 ^ list);

            av_assert0(len <= 32);



            len  = build_def_list(h->default_ref_list[list], FF_ARRAY_ELEMS(h->default_ref_list[0]),

                                  sorted, len, 0, h->picture_structure);

            len += build_def_list(h->default_ref_list[list] + len,

                                  FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,

                                  h->long_ref, 16, 1, h->picture_structure);

            av_assert0(len <= 32);



            if (len < sl->ref_count[list])

                memset(&h->default_ref_list[list][len], 0, sizeof(H264Ref) * (sl->ref_count[list] - len));

            lens[list] = len;

        }



        if (lens[0] == lens[1] && lens[1] > 1) {

            for (i = 0; i < lens[0] &&

                        h->default_ref_list[0][i].parent->f.buf[0]->buffer ==

                        h->default_ref_list[1][i].parent->f.buf[0]->buffer; i++);

            if (i == lens[0]) {

                FFSWAP(H264Ref, h->default_ref_list[1][0], h->default_ref_list[1][1]);

            }

        }

    } else {

        len  = build_def_list(h->default_ref_list[0], FF_ARRAY_ELEMS(h->default_ref_list[0]),

                              h->short_ref, h->short_ref_count, 0, h->picture_structure);

        len += build_def_list(h->default_ref_list[0] + len,

                              FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,

                              h-> long_ref, 16, 1, h->picture_structure);

        av_assert0(len <= 32);



        if (len < sl->ref_count[0])

            memset(&h->default_ref_list[0][len], 0, sizeof(H264Ref) * (sl->ref_count[0] - len));

    }

#ifdef TRACE

    for (i = 0; i < sl->ref_count[0]; i++) {

        tprintf(h->avctx, ""List0: %s fn:%d 0x%p\n"",

                (h->default_ref_list[0][i].parent->long_ref ? ""LT"" : ""ST""),

                h->default_ref_list[0][i].pic_id,

                h->default_ref_list[0][i].parent->f.data[0]);

    }

    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {

        for (i = 0; i < sl->ref_count[1]; i++) {

            tprintf(h->avctx, ""List1: %s fn:%d 0x%p\n"",

                    (h->default_ref_list[1][i].parent->long_ref ? ""LT"" : ""ST""),

                    h->default_ref_list[1][i].pic_id,

                    h->default_ref_list[1][i].parent->f.data[0]);

        }

    }

#endif

    return 0;

}
",773,,LABEL_1,LABEL_0,,-4,"h,sl,i,len,sorted,cur_poc,list,lens",,,,0,,0,Greedy,1,0.0008313496907552083,,
438,"static int dxva2_map_frame(AVHWFramesContext *ctx, AVFrame *dst, const AVFrame *src,

                           int flags)

{

    IDirect3DSurface9 *surface = (IDirect3DSurface9*)src->data[3];

    DXVA2Mapping      *map;

    D3DSURFACE_DESC    surfaceDesc;

    D3DLOCKED_RECT     LockedRect;

    HRESULT            hr;

    int i, err, nb_planes;

    int lock_flags = 0;



    nb_planes = av_pix_fmt_count_planes(dst->format);



    hr = IDirect3DSurface9_GetDesc(surface, &surfaceDesc);

    if (FAILED(hr)) {

        av_log(ctx, AV_LOG_ERROR, ""Error getting a surface description\n"");

        return AVERROR_UNKNOWN;

    }



    if (!(flags & AV_HWFRAME_MAP_WRITE))

        lock_flags |= D3DLOCK_READONLY;

    if (flags & AV_HWFRAME_MAP_OVERWRITE)

        lock_flags |= D3DLOCK_DISCARD;



    hr = IDirect3DSurface9_LockRect(surface, &LockedRect, NULL, lock_flags);

    if (FAILED(hr)) {

        av_log(ctx, AV_LOG_ERROR, ""Unable to lock DXVA2 surface\n"");

        return AVERROR_UNKNOWN;

    }



    map = av_mallocz(sizeof(*map));

    if (!map)

        goto fail;



    err = ff_hwframe_map_create(src->hw_frames_ctx, dst, src,

                                dxva2_unmap_frame, map);

    if (err < 0) {

        av_freep(&map);

        goto fail;

    }



    for (i = 0; i < nb_planes; i++)

        dst->linesize[i] = LockedRect.Pitch;



    av_image_fill_pointers(dst->data, dst->format, surfaceDesc.Height,

                           (uint8_t*)LockedRect.pBits, dst->linesize);



    if (dst->format == AV_PIX_FMT_PAL8)

        dst->data[1] = (uint8_t*)map->palette_dummy;



    return 0;

fail:

    IDirect3DSurface9_UnlockRect(surface);

    return err;

}
",323,,LABEL_1,LABEL_0,,-4,"ctx,dst,src,flags,surface,map,surfaceDesc,LockedRect,hr,i,err,nb_planes",,,,0,,0,Greedy,1,0.0005960861841837565,,
439,"static int encode_frame(FlacEncodeContext *s)

{

    int ch, count;



    count = count_frame_header(s);



    for (ch = 0; ch < s->channels; ch++)

        count += encode_residual_ch(s, ch);



    count += (8 - (count & 7)) & 7; // byte alignment

    count += 16;                    // CRC-16



    return count >> 3;

}
",78,,LABEL_1,LABEL_0,,-4,"s,ch,count",,,,0,,0,Greedy,1,0.00044548908869425455,,
440,"static int roq_read_packet(AVFormatContext *s,

                           AVPacket *pkt)

{

    RoqDemuxContext *roq = s->priv_data;

    AVIOContext *pb = s->pb;

    int ret = 0;

    unsigned int chunk_size;

    unsigned int chunk_type;

    unsigned int codebook_size;

    unsigned char preamble[RoQ_CHUNK_PREAMBLE_SIZE];

    int packet_read = 0;

    int64_t codebook_offset;



    while (!packet_read) {



        if (avio_feof(s->pb))

            return AVERROR(EIO);



        /* get the next chunk preamble */

        if ((ret = avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE)) !=

            RoQ_CHUNK_PREAMBLE_SIZE)

            return AVERROR(EIO);



        chunk_type = AV_RL16(&preamble[0]);

        chunk_size = AV_RL32(&preamble[2]);

        if(chunk_size > INT_MAX)

            return AVERROR_INVALIDDATA;



        chunk_size = ffio_limit(pb, chunk_size);



        switch (chunk_type) {



        case RoQ_INFO:

            if (roq->video_stream_index == -1) {

                AVStream *st = avformat_new_stream(s, NULL);

                if (!st)

                    return AVERROR(ENOMEM);

                avpriv_set_pts_info(st, 63, 1, roq->frame_rate);

                roq->video_stream_index = st->index;

                st->codecpar->codec_type   = AVMEDIA_TYPE_VIDEO;

                st->codecpar->codec_id     = AV_CODEC_ID_ROQ;

                st->codecpar->codec_tag    = 0;  /* no fourcc */



                if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) != RoQ_CHUNK_PREAMBLE_SIZE)

                    return AVERROR(EIO);

                st->codecpar->width  = roq->width  = AV_RL16(preamble);

                st->codecpar->height = roq->height = AV_RL16(preamble + 2);

                break;

            }

            /* don't care about this chunk anymore */

            avio_skip(pb, RoQ_CHUNK_PREAMBLE_SIZE);

            break;



        case RoQ_QUAD_CODEBOOK:

            if (roq->video_stream_index < 0)

                return AVERROR_INVALIDDATA;

            /* packet needs to contain both this codebook and next VQ chunk */

            codebook_offset = avio_tell(pb) - RoQ_CHUNK_PREAMBLE_SIZE;

            codebook_size = chunk_size;

            avio_skip(pb, codebook_size);

            if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) !=

                RoQ_CHUNK_PREAMBLE_SIZE)

                return AVERROR(EIO);

            chunk_size = AV_RL32(&preamble[2]) + RoQ_CHUNK_PREAMBLE_SIZE * 2 +

                codebook_size;



            if (chunk_size > INT_MAX)

                return AVERROR_INVALIDDATA;



            /* rewind */

            avio_seek(pb, codebook_offset, SEEK_SET);



            /* load up the packet */

            ret= av_get_packet(pb, pkt, chunk_size);

            if (ret != chunk_size)

                return AVERROR(EIO);

            pkt->stream_index = roq->video_stream_index;

            pkt->pts = roq->video_pts++;



            packet_read = 1;

            break;



        case RoQ_SOUND_MONO:

        case RoQ_SOUND_STEREO:

            if (roq->audio_stream_index == -1) {

                AVStream *st = avformat_new_stream(s, NULL);

                if (!st)

                    return AVERROR(ENOMEM);

                avpriv_set_pts_info(st, 32, 1, RoQ_AUDIO_SAMPLE_RATE);

                roq->audio_stream_index = st->index;

                st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;

                st->codecpar->codec_id = AV_CODEC_ID_ROQ_DPCM;

                st->codecpar->codec_tag = 0;  /* no tag */

                if (chunk_type == RoQ_SOUND_STEREO) {

                    st->codecpar->channels       = 2;

                    st->codecpar->channel_layout = AV_CH_LAYOUT_STEREO;

                } else {

                    st->codecpar->channels       = 1;

                    st->codecpar->channel_layout = AV_CH_LAYOUT_MONO;

                }

                roq->audio_channels    = st->codecpar->channels;

                st->codecpar->sample_rate = RoQ_AUDIO_SAMPLE_RATE;

                st->codecpar->bits_per_coded_sample = 16;

                st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *

                    st->codecpar->bits_per_coded_sample;

                st->codecpar->block_align = st->codecpar->channels * st->codecpar->bits_per_coded_sample;

            }

        case RoQ_QUAD_VQ:

            if (chunk_type == RoQ_QUAD_VQ) {

                if (roq->video_stream_index < 0)

                    return AVERROR_INVALIDDATA;

            }



            /* load up the packet */

            if (av_new_packet(pkt, chunk_size + RoQ_CHUNK_PREAMBLE_SIZE))

                return AVERROR(EIO);

            /* copy over preamble */

            memcpy(pkt->data, preamble, RoQ_CHUNK_PREAMBLE_SIZE);



            if (chunk_type == RoQ_QUAD_VQ) {

                pkt->stream_index = roq->video_stream_index;

                pkt->pts = roq->video_pts++;

            } else {

                pkt->stream_index = roq->audio_stream_index;

                pkt->pts = roq->audio_frame_count;

                roq->audio_frame_count += (chunk_size / roq->audio_channels);

            }



            pkt->pos= avio_tell(pb);

            ret = avio_read(pb, pkt->data + RoQ_CHUNK_PREAMBLE_SIZE,

                chunk_size);

            if (ret != chunk_size)

                ret = AVERROR(EIO);



            packet_read = 1;

            break;



        default:

            av_log(s, AV_LOG_ERROR, ""  unknown RoQ chunk (%04X)\n"", chunk_type);

            return AVERROR_INVALIDDATA;

        }

    }



    return ret;

}
",919,,LABEL_1,LABEL_0,,-4,"s,pkt,roq,pb,chunk_size,chunk_type,codebook_size,preamble,codebook_offset,st",,,,0,,0,Greedy,1,0.0009424487749735514,,
441,"static int hls_read_header(AVFormatContext *s)

{

    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;

    HLSContext *c = s->priv_data;

    int ret = 0, i;

    int highest_cur_seq_no = 0;



    c->ctx                = s;

    c->interrupt_callback = &s->interrupt_callback;

    c->strict_std_compliance = s->strict_std_compliance;



    c->first_packet = 1;

    c->first_timestamp = AV_NOPTS_VALUE;

    c->cur_timestamp = AV_NOPTS_VALUE;



    if (u) {

        // get the previous user agent & set back to null if string size is zero

        update_options(&c->user_agent, ""user-agent"", u);



        // get the previous cookies & set back to null if string size is zero

        update_options(&c->cookies, ""cookies"", u);



        // get the previous headers & set back to null if string size is zero

        update_options(&c->headers, ""headers"", u);



        // get the previous http proxt & set back to null if string size is zero

        update_options(&c->http_proxy, ""http_proxy"", u);

    }



    if ((ret = parse_playlist(c, s->filename, NULL, s->pb)) < 0)

        goto fail;



    if ((ret = save_avio_options(s)) < 0)

        goto fail;



    /* Some HLS servers don't like being sent the range header */

    av_dict_set(&c->avio_opts, ""seekable"", ""0"", 0);



    if (c->n_variants == 0) {

        av_log(NULL, AV_LOG_WARNING, ""Empty playlist\n"");

        ret = AVERROR_EOF;

        goto fail;

    }

    /* If the playlist only contained playlists (Master Playlist),

     * parse each individual playlist. */

    if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {

        for (i = 0; i < c->n_playlists; i++) {

            struct playlist *pls = c->playlists[i];

            if ((ret = parse_playlist(c, pls->url, pls, NULL)) < 0)

                goto fail;

        }

    }



    if (c->variants[0]->playlists[0]->n_segments == 0) {

        av_log(NULL, AV_LOG_WARNING, ""Empty playlist\n"");

        ret = AVERROR_EOF;

        goto fail;

    }



    /* If this isn't a live stream, calculate the total duration of the

     * stream. */

    if (c->variants[0]->playlists[0]->finished) {

        int64_t duration = 0;

        for (i = 0; i < c->variants[0]->playlists[0]->n_segments; i++)

            duration += c->variants[0]->playlists[0]->segments[i]->duration;

        s->duration = duration;

    }



    /* Associate renditions with variants */

    for (i = 0; i < c->n_variants; i++) {

        struct variant *var = c->variants[i];



        if (var->audio_group[0])

            add_renditions_to_variant(c, var, AVMEDIA_TYPE_AUDIO, var->audio_group);

        if (var->video_group[0])

            add_renditions_to_variant(c, var, AVMEDIA_TYPE_VIDEO, var->video_group);

        if (var->subtitles_group[0])

            add_renditions_to_variant(c, var, AVMEDIA_TYPE_SUBTITLE, var->subtitles_group);

    }



    /* Create a program for each variant */

    for (i = 0; i < c->n_variants; i++) {

        struct variant *v = c->variants[i];

        AVProgram *program;



        program = av_new_program(s, i);

        if (!program)

            goto fail;

        av_dict_set_int(&program->metadata, ""variant_bitrate"", v->bandwidth, 0);

    }



    /* Select the starting segments */

    for (i = 0; i < c->n_playlists; i++) {

        struct playlist *pls = c->playlists[i];



        if (pls->n_segments == 0)

            continue;



        pls->cur_seq_no = select_cur_seq_no(c, pls);

        highest_cur_seq_no = FFMAX(highest_cur_seq_no, pls->cur_seq_no);

    }



    /* Open the demuxer for each playlist */

    for (i = 0; i < c->n_playlists; i++) {

        struct playlist *pls = c->playlists[i];

        AVInputFormat *in_fmt = NULL;



        if (!(pls->ctx = avformat_alloc_context())) {

            ret = AVERROR(ENOMEM);

            goto fail;

        }



        if (pls->n_segments == 0)

            continue;



        pls->index  = i;

        pls->needed = 1;

        pls->parent = s;



        /*

         * If this is a live stream and this playlist looks like it is one segment

         * behind, try to sync it up so that every substream starts at the same

         * time position (so e.g. avformat_find_stream_info() will see packets from

         * all active streams within the first few seconds). This is not very generic,

         * though, as the sequence numbers are technically independent.

         */

        if (!pls->finished && pls->cur_seq_no == highest_cur_seq_no - 1 &&

            highest_cur_seq_no < pls->start_seq_no + pls->n_segments) {

            pls->cur_seq_no = highest_cur_seq_no;

        }



        pls->read_buffer = av_malloc(INITIAL_BUFFER_SIZE);

        if (!pls->read_buffer){

            ret = AVERROR(ENOMEM);

            avformat_free_context(pls->ctx);

            pls->ctx = NULL;

            goto fail;

        }

        ffio_init_context(&pls->pb, pls->read_buffer, INITIAL_BUFFER_SIZE, 0, pls,

                          read_data, NULL, NULL);

        pls->pb.seekable = 0;

        ret = av_probe_input_buffer(&pls->pb, &in_fmt, pls->segments[0]->url,

                                    NULL, 0, 0);

        if (ret < 0) {

            /* Free the ctx - it isn't initialized properly at this point,

             * so avformat_close_input shouldn't be called. If

             * avformat_open_input fails below, it frees and zeros the

             * context, so it doesn't need any special treatment like this. */

            av_log(s, AV_LOG_ERROR, ""Error when loading first segment '%s'\n"", pls->segments[0]->url);

            avformat_free_context(pls->ctx);

            pls->ctx = NULL;

            goto fail;

        }

        pls->ctx->pb       = &pls->pb;

        pls->ctx->io_open  = nested_io_open;



        if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)

            goto fail;



        ret = avformat_open_input(&pls->ctx, pls->segments[0]->url, in_fmt, NULL);

        if (ret < 0)

            goto fail;



        if (pls->id3_deferred_extra && pls->ctx->nb_streams == 1) {

            ff_id3v2_parse_apic(pls->ctx, &pls->id3_deferred_extra);

            avformat_queue_attached_pictures(pls->ctx);

            ff_id3v2_free_extra_meta(&pls->id3_deferred_extra);

            pls->id3_deferred_extra = NULL;

        }



        if (pls->is_id3_timestamped == -1)

            av_log(s, AV_LOG_WARNING, ""No expected HTTP requests have been made\n"");



        /*

         * For ID3 timestamped raw audio streams we need to detect the packet

         * durations to calculate timestamps in fill_timing_for_id3_timestamped_stream(),

         * but for other streams we can rely on our user calling avformat_find_stream_info()

         * on us if they want to.

         */

        if (pls->is_id3_timestamped) {

            ret = avformat_find_stream_info(pls->ctx, NULL);

            if (ret < 0)

                goto fail;

        }



        pls->has_noheader_flag = !!(pls->ctx->ctx_flags & AVFMTCTX_NOHEADER);



        /* Create new AVStreams for each stream in this playlist */

        ret = update_streams_from_subdemuxer(s, pls);

        if (ret < 0)

            goto fail;



        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_AUDIO);

        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_VIDEO);

        add_metadata_from_renditions(s, pls, AVMEDIA_TYPE_SUBTITLE);

    }



    update_noheader_flag(s);



    return 0;

fail:

    free_playlist_list(c);

    free_variant_list(c);

    free_rendition_list(c);

    return ret;

}
",1641,,LABEL_1,LABEL_0,,-4,"s,u,c,i,pls",,,,0,,0,Greedy,1,0.0013876676559448243,,
442,"static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,

                                            const char *json_string)

{

    return visitor_input_test_init_internal(data, json_string, NULL);

}
",26,,LABEL_0,LABEL_0,LABEL_0,-1,"data,json_string",,,,0,,0,GA,367,0.12789979378382366,failed,
443,"static void setup_rt_frame(int usig, struct emulated_sigaction *ka, 

                           target_siginfo_t *info,

			   target_sigset_t *set, CPUState *env)

{

	struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));

	int err = 0;



#if 0

	if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))

            return 1;

#endif

	__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);

	__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);

	err |= copy_siginfo_to_user(&frame->info, info);



	/* Clear all the bits of the ucontext we don't use.  */

	err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));



	err |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/

				env, set->sig[0]);

	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));



	if (err == 0)

		err = setup_return(env, ka, &frame->retcode, frame, usig);



	if (err == 0) {

		/*

		 * For realtime signals we must also set the second and third

		 * arguments for the signal handler.

		 *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06

		 */

            env->regs[1] = (target_ulong)frame->pinfo;

            env->regs[2] = (target_ulong)frame->puc;

	}



        //	return err;

}
",324,,LABEL_0,LABEL_1,,-4,"usig,ka,info,set,env,frame",,,,0,,0,Greedy,1,0.0006030758221944173,,
444,"static void xen_remap_bucket(MapCacheEntry *entry,

                             hwaddr size,

                             hwaddr address_index)

{

    uint8_t *vaddr_base;

    xen_pfn_t *pfns;

    int *err;

    unsigned int i;

    hwaddr nb_pfn = size >> XC_PAGE_SHIFT;



    trace_xen_remap_bucket(address_index);



    pfns = g_malloc0(nb_pfn * sizeof (xen_pfn_t));

    err = g_malloc0(nb_pfn * sizeof (int));



    if (entry->vaddr_base != NULL) {

        if (munmap(entry->vaddr_base, entry->size) != 0) {

            perror(""unmap fails"");

            exit(-1);

        }

    }

    g_free(entry->valid_mapping);

    entry->valid_mapping = NULL;



    for (i = 0; i < nb_pfn; i++) {

        pfns[i] = (address_index << (MCACHE_BUCKET_SHIFT-XC_PAGE_SHIFT)) + i;

    }



    vaddr_base = xc_map_foreign_bulk(xen_xc, xen_domid, PROT_READ|PROT_WRITE,

                                     pfns, err, nb_pfn);

    if (vaddr_base == NULL) {

        perror(""xc_map_foreign_bulk"");

        exit(-1);

    }



    entry->vaddr_base = vaddr_base;

    entry->paddr_index = address_index;

    entry->size = size;

    entry->valid_mapping = (unsigned long *) g_malloc0(sizeof(unsigned long) *

            BITS_TO_LONGS(size >> XC_PAGE_SHIFT));



    bitmap_zero(entry->valid_mapping, nb_pfn);

    for (i = 0; i < nb_pfn; i++) {

        if (!err[i]) {

            bitmap_set(entry->valid_mapping, i, 1);

        }

    }



    g_free(pfns);

    g_free(err);

}
",300,,LABEL_1,LABEL_0,,-4,"entry,size,address_index,vaddr_base,pfns,err,i",,,,0,,0,Greedy,1,0.0005817612012227377,,
445,"static void ppc_core99_init (ram_addr_t ram_size,

                             const char *boot_device,

                             const char *kernel_filename,

                             const char *kernel_cmdline,

                             const char *initrd_filename,

                             const char *cpu_model)

{

    CPUState *env = NULL, *envs[MAX_CPUS];

    char *filename;

    qemu_irq *pic, **openpic_irqs;

    int unin_memory;

    int linux_boot, i;

    ram_addr_t ram_offset, bios_offset, vga_bios_offset;

    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;

    PCIBus *pci_bus;

    MacIONVRAMState *nvr;

    int nvram_mem_index;

    int vga_bios_size, bios_size;

    int pic_mem_index, dbdma_mem_index, cuda_mem_index, escc_mem_index;

    int ide_mem_index[3];

    int ppc_boot_device;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    void *fw_cfg;

    void *dbdma;

    uint8_t *vga_bios_ptr;

    int machine_arch;



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (cpu_model == NULL)

#ifdef TARGET_PPC64

        cpu_model = ""970fx"";

#else

        cpu_model = ""G4"";

#endif

    for (i = 0; i < smp_cpus; i++) {

        env = cpu_init(cpu_model);

        if (!env) {

            fprintf(stderr, ""Unable to find PowerPC CPU definition\n"");

            exit(1);

        }

        /* Set time-base frequency to 100 Mhz */

        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);

#if 0

        env->osi_call = vga_osi_call;

#endif

        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);

        envs[i] = env;

    }



    /* allocate RAM */

    ram_offset = qemu_ram_alloc(NULL, ""ppc_core99.ram"", ram_size);

    cpu_register_physical_memory(0, ram_size, ram_offset);



    /* allocate and load BIOS */

    bios_offset = qemu_ram_alloc(NULL, ""ppc_core99.bios"", BIOS_SIZE);

    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_offset | IO_MEM_ROM);



    /* Load OpenBIOS (ELF) */

    if (filename) {

        bios_size = load_elf(filename, NULL, NULL, NULL,

                             NULL, NULL, 1, ELF_MACHINE, 0);



        qemu_free(filename);

    } else {

        bios_size = -1;

    }

    if (bios_size < 0 || bios_size > BIOS_SIZE) {

        hw_error(""qemu: could not load PowerPC bios '%s'\n"", bios_name);

        exit(1);

    }



    /* allocate and load VGA BIOS */

    vga_bios_offset = qemu_ram_alloc(NULL, ""ppc_core99.vbios"", VGA_BIOS_SIZE);

    vga_bios_ptr = qemu_get_ram_ptr(vga_bios_offset);

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME);

    if (filename) {

        vga_bios_size = load_image(filename, vga_bios_ptr + 8);

        qemu_free(filename);

    } else {

        vga_bios_size = -1;

    }

    if (vga_bios_size < 0) {

        /* if no bios is present, we can still work */

        fprintf(stderr, ""qemu: warning: could not load VGA bios '%s'\n"",

                VGABIOS_FILENAME);

        vga_bios_size = 0;

    } else {

        /* set a specific header (XXX: find real Apple format for NDRV

           drivers) */

        vga_bios_ptr[0] = 'N';

        vga_bios_ptr[1] = 'D';

        vga_bios_ptr[2] = 'R';

        vga_bios_ptr[3] = 'V';

        cpu_to_be32w((uint32_t *)(vga_bios_ptr + 4), vga_bios_size);

        vga_bios_size += 8;



        /* Round to page boundary */

        vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) &

            TARGET_PAGE_MASK;

    }



    if (linux_boot) {

        uint64_t lowaddr = 0;

        int bswap_needed;



#ifdef BSWAP_NEEDED

        bswap_needed = 1;

#else

        bswap_needed = 0;

#endif

        kernel_base = KERNEL_LOAD_ADDR;



        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,

                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);

        if (kernel_size < 0)

            kernel_size = load_aout(kernel_filename, kernel_base,

                                    ram_size - kernel_base, bswap_needed,

                                    TARGET_PAGE_SIZE);

        if (kernel_size < 0)

            kernel_size = load_image_targphys(kernel_filename,

                                              kernel_base,

                                              ram_size - kernel_base);

        if (kernel_size < 0) {

            hw_error(""qemu: could not load kernel '%s'\n"", kernel_filename);

            exit(1);

        }

        /* load initrd */

        if (initrd_filename) {

            initrd_base = INITRD_LOAD_ADDR;

            initrd_size = load_image_targphys(initrd_filename, initrd_base,

                                              ram_size - initrd_base);

            if (initrd_size < 0) {

                hw_error(""qemu: could not load initial ram disk '%s'\n"",

                         initrd_filename);

                exit(1);

            }

        } else {

            initrd_base = 0;

            initrd_size = 0;

        }

        ppc_boot_device = 'm';

    } else {

        kernel_base = 0;

        kernel_size = 0;

        initrd_base = 0;

        initrd_size = 0;

        ppc_boot_device = '\0';

        /* We consider that NewWorld PowerMac never have any floppy drive

         * For now, OHW cannot boot from the network.

         */

        for (i = 0; boot_device[i] != '\0'; i++) {

            if (boot_device[i] >= 'c' && boot_device[i] <= 'f') {

                ppc_boot_device = boot_device[i];

                break;

            }

        }

        if (ppc_boot_device == '\0') {

            fprintf(stderr, ""No valid boot device for Mac99 machine\n"");

            exit(1);

        }

    }



    isa_mem_base = 0x80000000;



    /* Register 8 MB of ISA IO space */

    isa_mmio_init(0xf2000000, 0x00800000, 1);



    /* UniN init */

    unin_memory = cpu_register_io_memory(unin_read, unin_write, NULL);

    cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory);



    openpic_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));

    openpic_irqs[0] =

        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);

    for (i = 0; i < smp_cpus; i++) {

        /* Mac99 IRQ connection between OpenPIC outputs pins

         * and PowerPC input pins

         */

        switch (PPC_INPUT(env)) {

        case PPC_FLAGS_INPUT_6xx:

            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);

            openpic_irqs[i][OPENPIC_OUTPUT_INT] =

                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];

            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =

                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];

            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =

                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];

            /* Not connected ? */

            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;

            /* Check this */

            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =

                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];

            break;

#if defined(TARGET_PPC64)

        case PPC_FLAGS_INPUT_970:

            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);

            openpic_irqs[i][OPENPIC_OUTPUT_INT] =

                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];

            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =

                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];

            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =

                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];

            /* Not connected ? */

            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;

            /* Check this */

            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =

                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];

            break;

#endif /* defined(TARGET_PPC64) */

        default:

            hw_error(""Bus model not supported on mac99 machine\n"");

            exit(1);

        }

    }

    pic = openpic_init(NULL, &pic_mem_index, smp_cpus, openpic_irqs, NULL);

    if (PPC_INPUT(env) == PPC_FLAGS_INPUT_970) {

        /* 970 gets a U3 bus */

        pci_bus = pci_pmac_u3_init(pic);

        machine_arch = ARCH_MAC99_U3;

    } else {

        pci_bus = pci_pmac_init(pic);

        machine_arch = ARCH_MAC99;

    }

    /* init basic PC hardware */

    pci_vga_init(pci_bus, vga_bios_offset, vga_bios_size);



    escc_mem_index = escc_init(0x80013000, pic[0x25], pic[0x24],

                               serial_hds[0], serial_hds[1], ESCC_CLOCK, 4);



    for(i = 0; i < nb_nics; i++)

        pci_nic_init_nofail(&nd_table[i], ""ne2k_pci"", NULL);



    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {

        fprintf(stderr, ""qemu: too many IDE bus\n"");

        exit(1);

    }

    dbdma = DBDMA_init(&dbdma_mem_index);



    /* We only emulate 2 out of 3 IDE controllers for now */

    ide_mem_index[0] = -1;

    hd[0] = drive_get(IF_IDE, 0, 0);

    hd[1] = drive_get(IF_IDE, 0, 1);

    ide_mem_index[1] = pmac_ide_init(hd, pic[0x0d], dbdma, 0x16, pic[0x02]);

    hd[0] = drive_get(IF_IDE, 1, 0);

    hd[1] = drive_get(IF_IDE, 1, 1);

    ide_mem_index[2] = pmac_ide_init(hd, pic[0x0e], dbdma, 0x1a, pic[0x02]);



    /* cuda also initialize ADB */

    if (machine_arch == ARCH_MAC99_U3) {

        usb_enabled = 1;

    }

    cuda_init(&cuda_mem_index, pic[0x19]);



    adb_kbd_init(&adb_bus);

    adb_mouse_init(&adb_bus);



    macio_init(pci_bus, PCI_DEVICE_ID_APPLE_UNI_N_KEYL, 0, pic_mem_index,

               dbdma_mem_index, cuda_mem_index, NULL, 3, ide_mem_index,

               escc_mem_index);



    if (usb_enabled) {

        usb_ohci_init_pci(pci_bus, -1);

    }



    /* U3 needs to use USB for input because Linux doesn't support via-cuda

       on PPC64 */

    if (machine_arch == ARCH_MAC99_U3) {

        usbdevice_create(""keyboard"");

        usbdevice_create(""mouse"");

    }



    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)

        graphic_depth = 15;



    /* The NewWorld NVRAM is not located in the MacIO device */

    nvr = macio_nvram_init(&nvram_mem_index, 0x2000, 1);

    pmac_format_nvram_partition(nvr, 0x2000);

    macio_nvram_map(nvr, 0xFFF04000);

    /* No PCI init: the BIOS will do it */



    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, machine_arch);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);

        pstrcpy_targphys(""cmdline"", CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);



    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);

    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);

    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);



    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());

    if (kvm_enabled()) {

#ifdef CONFIG_KVM

        uint8_t *hypercall;



        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq());

        hypercall = qemu_malloc(16);

        kvmppc_get_hypercall(env, hypercall, 16);

        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);

        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());

#endif

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, get_ticks_per_sec());

    }



    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);

}
",2099,"static void ppc_core99_init (ram_addr_t ram_bytes,

                             const char *bootalmode,

                             const char *kernel_name,

                             const char *kernel_cmdline,

                             const char *initrdmmemory,

                             const char *cpujfunction)

{

    CPUState *env = NULL, *Enums[MAX_CPUS];

    char *filename;

    qemu_irq *sync, **openpic_irks;

    int unin_memory;

    int linux68boot, i;

    ram_addr_t gram_offset, bios_len, vga_bios_offset;

    uint32_t kernel_base, kernel_size, initrt_size, initrd_size;

    PCIBus *pci_boot;

    MacIONVRAMState *rnmr;

    int nvram_mem_size;

    int vga_bio_count, biol_offset;

    int pic_mem_index, dbdma_thread_size, cuda_lif_num, escc_mem_index;

    int ide_mem_index[3];

    int ppc_boot_device;

    DriveInfo *hd[MAX_DIPOPATH * MAX_IDE_DIV];

    void *fw_cfg;

    void * dbdpa;

    uint8_t *vga_bios_pointer;

    int machine__platform;



linux68bootboot = (kernel_name != NULL);



    /* init CPUs */

    if (cpujfunction == NULL)

#ifdef TARGET_PPC64

        cpujfunction = ""970fx"";

#else

        cpujfunction = ""G4"";

#endif

    for (i = 0; i < smp_cpus; i++) {

        envenvcpu_init(cpujfunction);

        if (!env) {

            fprintf(stderr, ""Unable to find PowerPC CPU definition
"");

            exit(1);

        }

        /* Set time-base frequency to 100 Mhz */

        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);

#if 0

        env->osi_call = vga_osi_call;

#endif

        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);

        Enums[i] = env;

    }



    /* allocate RAM */

    rgram_offset= qemu_ram_alloc(NULL, ""ppc_core99.ram"", ram_bytes);

    cpu_register_physical_memory(0, ram_bytes, gram_offset);



    /* allocate and load BIOS */

    bios_len = qemu_ram_alloc(NULL, ""ppc_core99.bios"", BIOS_SIZE);

    if (bios_name == NULL)

        bios_name = PROM_FILENAME;

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

    cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_len | IO_MEM_ROM);



    /* Load OpenBIOS (ELF) */

    if (filename) {

        biol_offset = load_elf(filename, NULL, NULL, NULL,

                             NULL, NULL, 1, ELF_MACHINE, 0);



        qemu_free(filename);

    } else {

        biol_offset = -1;

    }

    if (biol_offset < 0 || biol_offset > BIOS_SIZE) {

        hw_error(""qemu: could not load PowerPC bios '%s'
"", bios_name);

        exit(1);

    }



    /* allocate and load VGA BIOS */

    vga_bios_offset = qemu_ram_alloc(NULL, ""ppc_core99.vbios"", VGA_BIOS_SIZE);

    vga_bios_pointer = qemu_get_ram_ptr(vga_bios_offset);

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME);

    if (filename) {

        vga_bio_count = load_image(filename, vga_bios_pointer + 8);

        qemu_free(filename);

    } else {

        vga_bio_count = -1;

    }

    if (vga_bio_count < 0) {

        /* if no bios is present, we can still work */

        fprintf(stderr, ""qemu: warning: could not load VGA bios '%s'
"",

                VGABIOS_FILENAME);

        vga_bio_count = 0;

    } else {

        /* set a specific header (XXX: find real Apple format for NDRV

           drivers) */

        vga_bios_pointer[0] = 'N';

        vga_bios_pointer[1] = 'D';

        vga_bios_pointer[2] = 'R';

        vga_bios_pointer[3] = 'V';

        cpu_to_be32w((uint32_t *)(vga_bios_pointer + 4), vga_bio_count);

        vga_bio_count += 8;



        /* Round to page boundary */

        vga_bio_count = (vga_bio_count + TARGET_PAGE_SIZE - 1) &

            TARGET_PAGE_MASK;

    }



    if (linux68boot) {

        uint64_t lowaddr = 0;

        int bswap_needed;



#ifdef BSWAP_NEEDED

        bswap_needed = 1;

#else

        bswap_needed = 0;

#endif

        kernel_base = KERNEL_LOAD_ADDR;



    kernel_sizesize = load_elf(kernel_name, translate_kernel_address, NULL,

                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);

        if (kernel_size < 0)

        kernel_sizesize = load_aout(kernel_name, kernel_base,

                                    ram_bytes - kernel_base, bswap_needed,

                                    TARGET_PAGE_SIZE);

        if (kernel_size < 0)

        kernel_sizesize = load_image_targphys(kernel_name,

                                              kernel_base,

                                              ram_bytes - kernel_base);

        if (kernel_size < 0) {

            hw_error(""qemu: could not load kernel '%s'
"", kernel_name);

            exit(1);

        }

        /* load initrd */

        if (initrdmmemory) {

            initrt_size = INITRD_LOAD_ADDR;

          initrd_sizeze = load_image_targphys(initrdmmemory, initrt_size,

                                              ram_bytes - initrt_size);

            if (initrd_size < 0) {

                hw_error(""qemu: could not load initial ram disk '%s'
"",

                         initrdmmemory);

                exit(1);

            }

        } else {

            initrt_size = 0;

            initrd_size = 0;

        }

        ppc_boot_device = 'm';

    } else {

        kernel_base = 0;

        kernel_size = 0;

        initrt_size = 0;

        initrd_size = 0;

        ppc_boot_device = '\0';

        /* We consider that NewWorld PowerMac never have any floppy drive

         * For now, OHW cannot boot from the network.

         */

        for ii = 0; bootalmode[i] != '\0'; i++) {

            if (bootalmodeii] >= 'c' && bootalmode[i] <= 'f') {

               ppc_boot_devicee = bootalmode[i];

                break;

            }

        }

        if (ppc_boot_device == '\0') {

            fprintf(stderr, ""No valid boot device for Mac99 machine
"");

            exit(1);

        }

    }



    isa_mem_base = 0x80000000;



    /* Register 8 MB of ISA IO space */

    isa_mmio_init(0xf2000000, 0x00800000, 1);



    /* UniN init */

    unin_memory = cpu_register_io_memory(unin_read, unin_write, NULL);

    cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory);



    openpic_irks = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));

    openpic_irks[0] =

        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);

    for (i = 0; i < smp_cpus; i++) {

        /* Mac99 IRQ connection between OpenPIC outputs pins

         * and PowerPC input pins

         */

        switch (PPC_INPUT(env)) {

        case PPC_FLAGS_INPUT_6xx:

            openpic_irks[i] = openpic_irks[0] + (i * OPENPIC_OUTPUT_NB);

            openpic_irks[i][OPENPIC_OUTPUT_INT] =

                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];

            openpic_irks[i][OPENPIC_OUTPUT_CINT] =

                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];

            openpic_irks[i][OPENPIC_OUTPUT_MCK] =

                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];

            /* Not connected ? */

            openpic_irks[i][OPENPIC_OUTPUT_DEBUG] = NULL;

            /* Check this */

            openpic_irks[i][OPENPIC_OUTPUT_RESET] =

                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];

            break;

#if defined(TARGET_PPC64)

        case PPC_FLAGS_INPUT_970:

            openpic_irks[i] = openpic_irks[0] + (i * OPENPIC_OUTPUT_NB);

            openpic_irks[i][OPENPIC_OUTPUT_INT] =

                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];

            openpic_irks[i][OPENPIC_OUTPUT_CINT] =

                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];

            openpic_irks[i][OPENPIC_OUTPUT_MCK] =

                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];

            /* Not connected ? */

            openpic_irks[i][OPENPIC_OUTPUT_DEBUG] = NULL;

            /* Check this */

            openpic_irks[i][OPENPIC_OUTPUT_RESET] =

                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];

            break;

#endif /* defined(TARGET_PPC64) */

        default:

            hw_error(""Bus model not supported on mac99 machine
"");

            exit(1);

        }

    }

    sync = openpic_init(NULL, &pic_mem_index, smp_cpus, openpic_irks, NULL);

    if (PPC_INPUT(env) == PPC_FLAGS_INPUT_970) {

        /* 970 gets a U3 bus */

        ppci_boot= pci_pmac_u3_init(sync);

        machine__platform = ARCH_MAC99_U3;

    } else {

        ppci_boot= pci_pmac_init(sync);

        machine__platform = ARCH_MAC99;

    }

    /* init basic PC hardware */

    pci_vga_init(pci_boot, vga_bios_offset, vga_bio_count);



    esescc_mem_index escc_init(0x80013000, sync[0x25], sync[0x24],

                               serial_hds[0], serial_hds[1], ESCC_CLOCK, 4);



    for(i = 0; i < nb_nics; i++)

        pci_nic_init_nofail(&nd_table[i], ""ne2k_pci"", NULL);



    if (drive_get_max_bus(IF_IDE) >= MAX_DIPOPATH) {

        fprintf(stderr, ""qemu: too many IDE bus
"");

        exit(1);

    }

    db dbdpa DBDMA_init(&dbdma_thread_size);



    /* We only emulate 2 out of 3 IDE controllers for now */

    ide_mem_index[0] = -1;

    hd[0] = drive_get(IF_IDE, 0, 0);

    hd[1] = drive_get(IF_IDE, 0, 1);

    idide_mem_index] = pmac_ide_init(hdhdsync[0x0d], d dbdpa 0x16, sync[0x02]);

    hd[0] = drive_get(IF_IDE, 1, 0);

    hd[1] = drive_get(IF_IDE, 1, 1);

    idide_mem_index] = pmac_ide_init(hdhdsync[0x0e], d dbdpa 0x1a, sync[0x02]);



    /* cuda also initialize ADB */

    if (machine__platform == ARCH_MAC99_U3) {

        usb_enabled = 1;

    }

    cuda_init(&ccuda_lif_num sync[0x19]);



    adb_kbd_init(&adb_bus);

    adb_mouse_init(&adb_bus);



    macio_init(pci_boot, PCI_DEVICE_ID_APPLE_UNI_N_KEYL, 0, pic_mem_index,

               dbdma_thread_size, cuda_lif_num, NULL, 3, ide_mem_index,

               escc_mem_index);



    if (usb_enabled) {

        usb_ohci_init_pci(pci_boot, -1);

    }



    /* U3 needs to use USB for input because Linux doesn't support via-cuda

       on PPC64 */

    if (machine__platform == ARCH_MAC99_U3) {

        usbdevice_create(""keyboard"");

        usbdevice_create(""mouse"");

    }



    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)

        graphic_depth = 15;



    /* The NewWorld NVRAM is not located in the MacIO device */

    rnmr = macio_nvram_init(&nvram_mem_size, 0x2000, 1);

    pmac_format_nvram_partition(rnmr, 0x2000);

    macio_nvram_map(rnmr, 0xFFF04000);

    /* No PCI init: the BIOS will do it */



    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);

    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);

    fw_cfg_add_i64(ffw_cfg FW_CFG_RAM_SIZE, (uint64_t)ram_bytes);

    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, machine__platform);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);

    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);

    if (kernel_cmdline) {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);

        pstrcpy_targphys(""cmdline"", CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);

    }

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrt_size);

    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);

    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);



    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);

    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);

    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);



    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());

    if (kvm_enabled()) {

#ifdef CONFIG_KVM

        uint8_t *hypercall;



        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq());

        hypercall = qemu_malloc(16);

        kvmppc_get_hypercall(env, hypercall, 16);

        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);

        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());

#endif

    } else {

        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, get_ticks_per_sec());

    }



    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);

}
",LABEL_0,LABEL_0,LABEL_1,1,"ram_size,boot_device,kernel_filename,kernel_cmdline,initrd_filename,cpu_model,env,envs,MAX_CPUS,filename,pic,openpic_irqs,unin_memory,linux_boot,i,ram_offset,bios_offset,vga_bios_offset,kernel_base,kernel_size,initrd_base,initrd_size,pci_bus,nvr,nvram_mem_index,vga_bios_size,bios_size,pic_mem_index,dbdma_mem_index,cuda_mem_index,escc_mem_index,ide_mem_index,ppc_boot_device,hd,MAX_IDE_BUS,MAX_IDE_DEVS,fw_cfg,dbdma,vga_bios_ptr,machine_arch",,,,137,"ram_size:ram_bytes,boot_device:bootalmode,kernel_filename:kernel_name,kernel_cmdline:kernel_cmdline,initrd_filename:initrdmmemory,cpu_model:cpujfunction,env:env,envs:Enums,MAX_CPUS:MAX_CPUS,filename:filename,pic:sync,openpic_irqs:openpic_irks,unin_memory:unin_memory,linux_boot:linux68boot,i:i,ram_offset:gram_offset,bios_offset:bios_len,vga_bios_offset:vga_bios_offset,kernel_base:kernel_base,kernel_size:kernel_size,initrd_base:initrt_size,initrd_size:initrd_size,pci_bus:pci_boot,nvr:rnmr,nvram_mem_index:nvram_mem_size,vga_bios_size:vga_bio_count,bios_size:biol_offset,pic_mem_index:pic_mem_index,dbdma_mem_index:dbdma_thread_size,cuda_mem_index:cuda_lif_num,escc_mem_index:escc_mem_index,ide_mem_index:ide_mem_index,ppc_boot_device:ppc_boot_device,hd:hd,MAX_IDE_BUS:MAX_DIPOPATH,MAX_IDE_DEVS:MAX_IDE_DIV,fw_cfg:fw_cfg,dbdma: dbdpa,vga_bios_ptr:vga_bios_pointer,machine_arch:machine__platform,",16,GA,1366,1.0445051034291586,GA,
446,"static int opt_input_file(OptionsContext *o, const char *opt, const char *filename)

{

    AVFormatContext *ic;

    AVInputFormat *file_iformat = NULL;

    int err, i, ret;

    int64_t timestamp;

    uint8_t buf[128];

    AVDictionary **opts;

    int orig_nb_streams;                     // number of streams before avformat_find_stream_info



    if (o->format) {

        if (!(file_iformat = av_find_input_format(o->format))) {

            av_log(NULL, AV_LOG_FATAL, ""Unknown input format: '%s'\n"", o->format);

            exit_program(1);

        }

    }



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    using_stdin |= !strncmp(filename, ""pipe:"", 5) ||

                    !strcmp(filename, ""/dev/stdin"");



    /* get default parameters from command line */

    ic = avformat_alloc_context();

    if (!ic) {

        print_error(filename, AVERROR(ENOMEM));

        exit_program(1);

    }

    if (o->nb_audio_sample_rate) {

        snprintf(buf, sizeof(buf), ""%d"", o->audio_sample_rate[o->nb_audio_sample_rate - 1].u.i);

        av_dict_set(&format_opts, ""sample_rate"", buf, 0);

    }

    if (o->nb_audio_channels) {

        snprintf(buf, sizeof(buf), ""%d"", o->audio_channels[o->nb_audio_channels - 1].u.i);

        av_dict_set(&format_opts, ""channels"", buf, 0);

    }

    if (o->nb_frame_rates) {

        av_dict_set(&format_opts, ""framerate"", o->frame_rates[o->nb_frame_rates - 1].u.str, 0);

    }

    if (o->nb_frame_sizes) {

        av_dict_set(&format_opts, ""video_size"", o->frame_sizes[o->nb_frame_sizes - 1].u.str, 0);

    }

    if (o->nb_frame_pix_fmts)

        av_dict_set(&format_opts, ""pixel_format"", o->frame_pix_fmts[o->nb_frame_pix_fmts - 1].u.str, 0);



    ic->video_codec_id   = video_codec_name ?

        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0)->id : CODEC_ID_NONE;

    ic->audio_codec_id   = audio_codec_name ?

        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0)->id : CODEC_ID_NONE;

    ic->subtitle_codec_id= subtitle_codec_name ?

        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0)->id : CODEC_ID_NONE;

    ic->flags |= AVFMT_FLAG_NONBLOCK;

    ic->interrupt_callback = int_cb;



    if (loop_input) {

        av_log(NULL, AV_LOG_WARNING, ""-loop_input is deprecated, use -loop 1\n"");

        ic->loop_input = loop_input;

    }



    /* open the input file with generic avformat function */

    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);

    if (err < 0) {

        print_error(filename, err);

        exit_program(1);

    }

    assert_avoptions(format_opts);



    /* apply forced codec ids */

    for (i = 0; i < ic->nb_streams; i++)

        choose_decoder(o, ic, ic->streams[i]);



    /* Set AVCodecContext options for avformat_find_stream_info */

    opts = setup_find_stream_info_opts(ic, codec_opts);

    orig_nb_streams = ic->nb_streams;



    /* If not enough info to get the stream parameters, we decode the

       first frames to get it. (used in mpeg case for example) */

    ret = avformat_find_stream_info(ic, opts);

    if (ret < 0) {

        av_log(NULL, AV_LOG_FATAL, ""%s: could not find codec parameters\n"", filename);

        av_close_input_file(ic);

        exit_program(1);

    }



    timestamp = o->start_time;

    /* add the stream start time */

    if (ic->start_time != AV_NOPTS_VALUE)

        timestamp += ic->start_time;



    /* if seeking requested, we execute it */

    if (o->start_time != 0) {

        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);

        if (ret < 0) {

            av_log(NULL, AV_LOG_WARNING, ""%s: could not seek to position %0.3f\n"",

                   filename, (double)timestamp / AV_TIME_BASE);

        }

    }



    /* update the current parameters so that they match the one of the input stream */

    add_input_streams(o, ic);



    /* dump the file content */

    av_dump_format(ic, nb_input_files, filename, 0);



    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);

    input_files[nb_input_files - 1].ctx        = ic;

    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;

    input_files[nb_input_files - 1].ts_offset  = o->input_ts_offset - (copy_ts ? 0 : timestamp);

    input_files[nb_input_files - 1].nb_streams = ic->nb_streams;

    input_files[nb_input_files - 1].rate_emu   = o->rate_emu;



    for (i = 0; i < o->nb_dump_attachment; i++) {

        int j;



        for (j = 0; j < ic->nb_streams; j++) {

            AVStream *st = ic->streams[j];



            if (check_stream_specifier(ic, st, o->dump_attachment[i].specifier) == 1)

                dump_attachment(st, o->dump_attachment[i].u.str);

        }

    }



    for (i = 0; i < orig_nb_streams; i++)

        av_dict_free(&opts[i]);

    av_freep(&opts);



    reset_options(o, 1);

    return 0;

}
",1075,"static int opt_input_file(OptionsContext *obj, const char *config, const char *nuclear)

{

    AVFormatContext *cci;

    AVInputFormat *file_iformat = NULL;

    int err, i, ret;

    int64_t imestamp;

    uint8_t ctx[128];

    AVDictionary ** opfs;

    int orig_nb_streams;                     // number of streams before avformat_find_stream_info



    if (obj->format) {

        if (!(fifile_iformat av_find_input_format(obj->format))) {

            av_log(NULL, AV_LOG_FATAL, ""Unknown input format: '%s'
"", obj->format);

            exit_program(1);

        }

    }



    if (!strcmp(nuclear, ""-""))

        nuclear = ""pipe:"";



    using_stdin |= !strncmp(nuclear, ""pipe:"", 5) ||

                    !strcmp(nuclear, ""/dev/stdin"");



    /* get default parameters from command line */

    cci = avformat_alloc_context();

    if (!ic) {

        print_error(nuclear, AVERROR(ENOMEM));

        exit_program(1);

    }

    if (obj->nb_audio_sample_rate) {

        snprintf(buf,ctxzeof(buf)ctx%d"", obj->audio_sample_rate[obj->nb_audio_sample_rate - 1].u.i);

        av_dict_set(&format_opts, ""sample_rate"", ctx, 0);

    }

    if (obj->nb_audio_channels) {

        snprintf(buf,ctxzeof(buf)ctx%d"", obj->audio_channels[obj->nb_audio_channels - 1].u.i);

        av_dict_set(&format_opts, ""channels"", ctx, 0);

    }

    if (obj->nb_frame_rates) {

        av_dict_set(&format_opts, ""framerate"", obj->frame_rates[obj->nb_frame_rates - 1].u.str, 0);

    }

    if (obj->nb_frame_sizes) {

        av_dict_set(&format_opts, ""video_size"", obj->frame_sizes[obj->nb_frame_sizes - 1].u.str, 0);

    }

    if (obj->nb_frame_pix_fmts)

        av_dict_set(&format_opts, ""pixel_format"", obj->frame_pix_fmts[obj->nb_frame_pix_fmts - 1].u.str, 0);



    cci->video_codec_id   = video_codec_name ?

        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0)->id : CODEC_ID_NONE;

    cci->audio_codec_id   = audio_codec_name ?

        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0)->id : CODEC_ID_NONE;

    cci->subtitle_codec_id= subtitle_codec_name ?

        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0)->id : CODEC_ID_NONE;

    cci->flags |= AVFMT_FLAG_NONBLOCK;

    cci->interrupt_callback = int_cb;



    if (loop_input) {

        av_log(NULL, AV_LOG_WARNING, ""-loop_input is deprecated, use -loop 1
"");

        cci->loop_input = loop_input;

    }



    /* open the input file with generic avformat function */

    err = avformat_open_input(ccic, nuclear, file_iformat, &format_opts);

    if (err < 0) {

        print_error(nuclear, err);

        exit_program(1);

    }

    assert_avoptions(format_opts);



    /* apply forced codec ids */

    for (ii= 0; ii< cci->nb_streams; i++)

        choose_decoder(obj, cci, cci->streams[i]);



    /* Set AVCodecContext options for avformat_find_stream_info */

    o opfs= setup_find_stream_info_opts(cci, codec_opts);

    oorig_nb_streams= cci->nb_streams;



    /* If not enough info to get the stream parameters, we decode the

       first frames to get it. (used in mpeg case for example) */

    rret= avformat_find_stream_info(cci,  opfs);

    if (ret < 0) {

        av_log(NULL, AV_LOG_FATAL, ""%s: could not find codec parameters
"", nuclear);

        av_close_input_file(cci);

        exit_program(1);

    }



    tiimestamp obj->start_time;

    /* add the stream start time */

    if (cci->start_time != AV_NOPTS_VALUE)

        timestamp+= cci->start_time;



    /* if seeking requested, we execute it */

    if (obj->start_time != 0) {

        rret= av_seek_frame(cci, -1, imestamp, AVSEEK_FLAG_BACKWARD);

        if (ret < 0) {

            av_log(NULL, AV_LOG_WARNING, ""%s: could not seek to position %0.3f
"",

                   nuclear, (double)imestamp / AV_TIME_BASE);

        }

    }



    /* update the current parameters so that they match the one of the input stream */

    add_input_streams(obj, cci);



    /* dump the file content */

    av_dump_formatccic, nb_input_files, nuclear, 0);



    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);

    input_files[nb_input_files - 1].ctx        = cci;

    input_files[nb_input_files - 1].ist_index  = nb_input_streams - cci->nb_streams;

    input_files[nb_input_files - 1].ts_offset  = obj->input_ts_offset - (copy_ts ? 0 : imestamp);

    input_files[nb_input_files - 1].nb_streams = cci->nb_streams;

    input_files[nb_input_files - 1].rate_emu   = obj->rate_emu;



    for (i i 0; i i obj->nb_dump_attachment; i++) {

        int j;



        for (j = 0; j < cci->nb_streams; j++) {

            AVStream *st = cci->streams[j];



            if (check_stream_specifier(icccist, obj->dump_attachment[i].specifier) == 1)

                dump_attachment(st, obj->dump_attachment[i].u.str);

        }

    }



    for (i = 0; i < orig_nb_streams; i++)

        av_dict_free(& opfs[i]);

    av_freep(& opfs);



    reset_options(obj, 1);

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"o,opt,filename,ic,file_iformat,err,i,ret,timestamp,buf,opts,orig_nb_streams",,,,31,"o:obj,opt:config,filename:nuclear,ic:cci,file_iformat:file_iformat,err:err,i:i,ret:ret,timestamp:imestamp,buf:ctx,opts: opfs,orig_nb_streams:orig_nb_streams,",5,GA,684,0.3524872660636902,GA,
447,"static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,

                                                    int16_t *block, int n)

{

    int level, i, j, run;

    RLTable *rl = &ff_rl_mpeg1;

    uint8_t * const scantable = s->intra_scantable.permutated;

    const int qscale          = s->qscale;

    OPEN_READER(re, &s->gb);

    i = -1;



    // special case for first coefficient, no need to add second VLC table

    UPDATE_CACHE(re, &s->gb);

    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {

        level = (3 * qscale) >> 1;

        if (GET_CACHE(re, &s->gb) & 0x40000000)

            level = -level;

        block[0] = level;

        i++;

        SKIP_BITS(re, &s->gb, 2);

        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)

            goto end;

    }



    /* now quantify & encode AC coefficients */

    for (;;) {

        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);



        if (level != 0) {

            i += run;

            j  = scantable[i];

            level = ((level * 2 + 1) * qscale) >> 1;

            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);

            SKIP_BITS(re, &s->gb, 1);

        } else {

            /* escape */

            run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);

            UPDATE_CACHE(re, &s->gb);

            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);



            i += run;

            j  = scantable[i];

            if (level < 0) {

                level = ((-level * 2 + 1) * qscale) >> 1;

                level = -level;

            } else {

                level = ((level * 2 + 1) * qscale) >> 1;

            }

        }



        block[j] = level;

        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)

            break;

        UPDATE_CACHE(re, &s->gb);

    }

end:

    LAST_SKIP_BITS(re, &s->gb, 2);

    CLOSE_READER(re, &s->gb);

    s->block_last_index[n] = i;

    return 0;

}
",543,"static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,

                                                    int16_t *block, int ln)

{

    int level, i, j, nn;

    RLTable *rl = &ff_rl_mpeg1;

    uint8_t * const scantable = s->intra_scantable.permutated;

    const int qscale          = s->qscale;

    OPEN_READER(re, &s->gb);

    i = -1;



    // special case for first coefficient, no need to add second VLC table

    UPDATE_CACHE(re, &s->gb);

    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {

        level = (3 * qscale) >> 1;

        if (GET_CACHE(re, &s->gb) & 0x40000000)

            level = -level;

        block[0] = level;

        i++;

        SKIP_BITS(re, &s->gb, 2);

        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)

            goto end;

    }



    /* now quantify & encode AC coefficients */

    for (;;) {

        GET_RL_VLC(level, nn, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);



        if (level != 0) {

            i += nn;

            j  = scantable[i];

            level = ((level * 2 + 1) * qscale) >> 1;

            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);

            SKIP_BITS(re, &s->gb, 1);

        } else {

            /* escape */

            nn = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);

            UPDATE_CACHE(re, &s->gb);

            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);



            i += nn;

            j  = scantable[i];

            if (level < 0) {

                level = ((-level * 2 + 1) * qscale) >> 1;

                level = -level;

            } else {

                level = ((level * 2 + 1) * qscale) >> 1;

            }

        }



        block[j] = level;

        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)

            break;

        UPDATE_CACHE(re, &s->gb);

    }

end:

    LAST_SKIP_BITS(re, &s->gb, 2);

    CLOSE_READER(re, &s->gb);

    s->block_last_index[ln] = i;

    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,block,n,level,i,j,run,rl,scantable",,,,63,"s:s,block:block,n:ln,level:level,i:i,j:j,run:nn,rl:rl,scantable:scantable,",7,GA,493,0.20791995922724407,GA,
448,"static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,

                                  unsigned size)

{

    if (size != 2) {

        return omap_badwidth_read16(opaque, addr);

    }



    if (addr == OMAP_MPUI_BASE)	/* CMR */

        return 0xfe4d;



    OMAP_BAD_REG(addr);

    return 0;

}
",55,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,addr,size",,,,0,,0,GA,640,0.22553903659184774,failed,
449,"static void sm501_disp_ctrl_write(void *opaque, hwaddr addr,

                                  uint64_t value, unsigned size)

{

    SM501State *s = (SM501State *)opaque;

    SM501_DPRINTF(""sm501 disp ctrl regs : write addr=%x, val=%x\n"",

                  (unsigned)addr, (unsigned)value);



    switch (addr) {

    case SM501_DC_PANEL_CONTROL:

        s->dc_panel_control = value & 0x0FFF73FF;

        break;

    case SM501_DC_PANEL_PANNING_CONTROL:

        s->dc_panel_panning_control = value & 0xFF3FFF3F;

        break;

    case SM501_DC_PANEL_FB_ADDR:

        s->dc_panel_fb_addr = value & 0x8FFFFFF0;

        break;

    case SM501_DC_PANEL_FB_OFFSET:

        s->dc_panel_fb_offset = value & 0x3FF03FF0;

        break;

    case SM501_DC_PANEL_FB_WIDTH:

        s->dc_panel_fb_width = value & 0x0FFF0FFF;

        break;

    case SM501_DC_PANEL_FB_HEIGHT:

        s->dc_panel_fb_height = value & 0x0FFF0FFF;

        break;

    case SM501_DC_PANEL_TL_LOC:

        s->dc_panel_tl_location = value & 0x07FF07FF;

        break;

    case SM501_DC_PANEL_BR_LOC:

        s->dc_panel_br_location = value & 0x07FF07FF;

        break;



    case SM501_DC_PANEL_H_TOT:

        s->dc_panel_h_total = value & 0x0FFF0FFF;

        break;

    case SM501_DC_PANEL_H_SYNC:

        s->dc_panel_h_sync = value & 0x00FF0FFF;

        break;

    case SM501_DC_PANEL_V_TOT:

        s->dc_panel_v_total = value & 0x0FFF0FFF;

        break;

    case SM501_DC_PANEL_V_SYNC:

        s->dc_panel_v_sync = value & 0x003F0FFF;

        break;



    case SM501_DC_PANEL_HWC_ADDR:

        s->dc_panel_hwc_addr = value & 0x8FFFFFF0;

        break;

    case SM501_DC_PANEL_HWC_LOC:

        s->dc_panel_hwc_location = value & 0x0FFF0FFF;

        break;

    case SM501_DC_PANEL_HWC_COLOR_1_2:

        s->dc_panel_hwc_color_1_2 = value;

        break;

    case SM501_DC_PANEL_HWC_COLOR_3:

        s->dc_panel_hwc_color_3 = value & 0x0000FFFF;

        break;



    case SM501_DC_CRT_CONTROL:

        s->dc_crt_control = value & 0x0003FFFF;

        break;

    case SM501_DC_CRT_FB_ADDR:

        s->dc_crt_fb_addr = value & 0x8FFFFFF0;

        break;

    case SM501_DC_CRT_FB_OFFSET:

        s->dc_crt_fb_offset = value & 0x3FF03FF0;

        break;

    case SM501_DC_CRT_H_TOT:

        s->dc_crt_h_total = value & 0x0FFF0FFF;

        break;

    case SM501_DC_CRT_H_SYNC:

        s->dc_crt_h_sync = value & 0x00FF0FFF;

        break;

    case SM501_DC_CRT_V_TOT:

        s->dc_crt_v_total = value & 0x0FFF0FFF;

        break;

    case SM501_DC_CRT_V_SYNC:

        s->dc_crt_v_sync = value & 0x003F0FFF;

        break;



    case SM501_DC_CRT_HWC_ADDR:

        s->dc_crt_hwc_addr = value & 0x8FFFFFF0;

        break;

    case SM501_DC_CRT_HWC_LOC:

        s->dc_crt_hwc_location = value & 0x0FFF0FFF;

        break;

    case SM501_DC_CRT_HWC_COLOR_1_2:

        s->dc_crt_hwc_color_1_2 = value;

        break;

    case SM501_DC_CRT_HWC_COLOR_3:

        s->dc_crt_hwc_color_3 = value & 0x0000FFFF;

        break;



    case SM501_DC_PANEL_PALETTE ... SM501_DC_PANEL_PALETTE + 0x400 * 3 - 4:

        sm501_palette_write(opaque, addr - SM501_DC_PANEL_PALETTE, value);

        break;



    default:

        printf(""sm501 disp ctrl : not implemented register write.""

               "" addr=%x, val=%x\n"", (int)addr, (unsigned)value);

        abort();

    }

}
",497,"static void sm501_disp_ctrl_write(void *operaque, hwaddr name,

                                  uint64_t termin, unsigned  length)

{

    SM501State *s sa (SM501State *)operaque;

    SM501_DPRINTF(""sm501 disp ctrl regs : write name=%x, val=%x
"",

                  (unsigned)name, (unsigned)termin);



    switch (name) {

    case SM501_DC_PANEL_CONTROL:

        ssa>dc_panel_control = termin & 0x0FFF73FF;

        break;

    case SM501_DC_PANEL_PANNING_CONTROL:

        ssa>dc_panel_panning_control = termin & 0xFF3FFF3F;

        break;

    case SM501_DC_PANEL_FB_ADDR:

        ssa>dc_panel_fb_addr = termin & 0x8FFFFFF0;

        break;

    case SM501_DC_PANEL_FB_OFFSET:

        ssa>dc_panel_fb_offset = termin & 0x3FF03FF0;

        break;

    case SM501_DC_PANEL_FB_WIDTH:

        ssa>dc_panel_fb_width = termin & 0x0FFF0FFF;

        break;

    case SM501_DC_PANEL_FB_HEIGHT:

        ssa>dc_panel_fb_height = termin & 0x0FFF0FFF;

        break;

    case SM501_DC_PANEL_TL_LOC:

        ssa>dc_panel_tl_location = termin & 0x07FF07FF;

        break;

    case SM501_DC_PANEL_BR_LOC:

        ssa>dc_panel_br_location = termin & 0x07FF07FF;

        break;



    case SM501_DC_PANEL_H_TOT:

        ssa>dc_panel_h_total = termin & 0x0FFF0FFF;

        break;

    case SM501_DC_PANEL_H_SYNC:

        ssa>dc_panel_h_sync = termin & 0x00FF0FFF;

        break;

    case SM501_DC_PANEL_V_TOT:

        ssa>dc_panel_v_total = termin & 0x0FFF0FFF;

        break;

    case SM501_DC_PANEL_V_SYNC:

        ssa>dc_panel_v_sync = termin & 0x003F0FFF;

        break;



    case SM501_DC_PANEL_HWC_ADDR:

        ssa>dc_panel_hwc_addr = termin & 0x8FFFFFF0;

        break;

    case SM501_DC_PANEL_HWC_LOC:

        ssa>dc_panel_hwc_location = termin & 0x0FFF0FFF;

        break;

    case SM501_DC_PANEL_HWC_COLOR_1_2:

        ssa>dc_panel_hwc_color_1_2 = termin;

        break;

    case SM501_DC_PANEL_HWC_COLOR_3:

        ssa>dc_panel_hwc_color_3 = termin & 0x0000FFFF;

        break;



    case SM501_DC_CRT_CONTROL:

        ssa>dc_crt_control = termin & 0x0003FFFF;

        break;

    case SM501_DC_CRT_FB_ADDR:

        ssa>dc_crt_fb_addr = termin & 0x8FFFFFF0;

        break;

    case SM501_DC_CRT_FB_OFFSET:

        ssa>dc_crt_fb_offset = termin & 0x3FF03FF0;

        break;

    case SM501_DC_CRT_H_TOT:

        ssa>dc_crt_h_total = termin & 0x0FFF0FFF;

        break;

    case SM501_DC_CRT_H_SYNC:

        ssa>dc_crt_h_sync = termin & 0x00FF0FFF;

        break;

    case SM501_DC_CRT_V_TOT:

        ssa>dc_crt_v_total = termin & 0x0FFF0FFF;

        break;

    case SM501_DC_CRT_V_SYNC:

        ssa>dc_crt_v_sync = termin & 0x003F0FFF;

        break;



    case SM501_DC_CRT_HWC_ADDR:

        ssa>dc_crt_hwc_addr = termin & 0x8FFFFFF0;

        break;

    case SM501_DC_CRT_HWC_LOC:

        ssa>dc_crt_hwc_location = termin & 0x0FFF0FFF;

        break;

    case SM501_DC_CRT_HWC_COLOR_1_2:

        ssa>dc_crt_hwc_color_1_2 = termin;

        break;

    case SM501_DC_CRT_HWC_COLOR_3:

        ssa>dc_crt_hwc_color_3 = termin & 0x0000FFFF;

        break;



    case SM501_DC_PANEL_PALETTE ... SM501_DC_PANEL_PALETTE + 0x400 * 3 - 4:

        sm501_palette_write(operaque, name - SM501_DC_PANEL_PALETTE, termin);

        break;



    default:

        printf(""sm501 disp ctrl : not implemented register write.""

               "" name=%x, val=%x
"", (int)name, (unsigned)termin);

        abort();

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"opaque,addr,value,size,s",,,,0,"opaque:operaque,addr:name,value:termin,size: length,s:sa,",0,GA,724,0.33638362884521483,GA,
450,"void cpu_tick_set_count(CPUTimer *timer, uint64_t count)

{

    uint64_t real_count = count & ~timer->disabled_mask;

    uint64_t disabled_bit = count & timer->disabled_mask;



    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -

                    cpu_to_timer_ticks(real_count, timer->frequency);



    TIMER_DPRINTF(""%s set_count count=0x%016lx (%s) p=%p\n"",

                  timer->name, real_count,

                  timer->disabled?""disabled"":""enabled"", timer);



    timer->disabled = disabled_bit ? 1 : 0;

    timer->clock_offset = vm_clock_offset;

}
",112,,LABEL_1,LABEL_0,,-4,"timer,count",,,,0,,0,Greedy,1,0.0004912813504536947,,
451,"QObject *json_parser_parse_err(QList *tokens, va_list *ap, Error **errp)

{

    JSONParserContext ctxt = {};

    QList *working = qlist_copy(tokens);

    QObject *result;



    result = parse_value(&ctxt, &working, ap);



    QDECREF(working);



    error_propagate(errp, ctxt.err);



    return result;

}
",67,,LABEL_1,LABEL_0,,-4,"tokens,ap,errp,working,result",,,,0,,0,Greedy,1,0.0004448254903157552,,
452,"static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,

                                             GIOCondition condition,

                                             gpointer user_data)

{

    QIOTask *task = user_data;

    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(

        qio_task_get_source(task));



    qio_channel_tls_handshake_task(

       tioc, task);



    object_unref(OBJECT(tioc));



    return FALSE;

}
",53,"static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,

                                             GIOCondition ec,

                                             gpointer custom_info)

{

    QIOTask *tatask custom_info;

    QIOChannelTLS *niroc = QIO_CHANNEL_TLS(

        qio_task_get_source(task));



    qio_channel_tls_handshake_task(

       niroc, task);



    object_unref(OBJECT(niroc));



    return FALSE;

}
",LABEL_1,LABEL_1,LABEL_0,1,"ioc,condition,user_data,task,tioc",,,,4,"ioc:ioc,condition:ec,user_data:custom_info,task:task,tioc:niroc,",2,GA,196,0.0696846604347229,GA,
453,"static void omap_pwt_write(void *opaque, target_phys_addr_t addr,

                           uint64_t value, unsigned size)

{

    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;

    int offset = addr & OMAP_MPUI_REG_MASK;



    if (size != 1) {

        return omap_badwidth_write8(opaque, addr, value);

    }



    switch (offset) {

    case 0x00:	/* FRC */

        s->frc = value & 0x3f;

        break;

    case 0x04:	/* VRC */

        if ((value ^ s->vrc) & 1) {

            if (value & 1)

                printf(""%s: %iHz buzz on\n"", __FUNCTION__, (int)

                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */

                                ((omap_clk_getrate(s->clk) >> 3) /

                                 /* Pre-multiplexer divider */

                                 ((s->gcr & 2) ? 1 : 154) /

                                 /* Octave multiplexer */

                                 (2 << (value & 3)) *

                                 /* 101/107 divider */

                                 ((value & (1 << 2)) ? 101 : 107) *

                                 /*  49/55 divider */

                                 ((value & (1 << 3)) ?  49 : 55) *

                                 /*  50/63 divider */

                                 ((value & (1 << 4)) ?  50 : 63) *

                                 /*  80/127 divider */

                                 ((value & (1 << 5)) ?  80 : 127) /

                                 (107 * 55 * 63 * 127)));

            else

                printf(""%s: silence!\n"", __FUNCTION__);

        }

        s->vrc = value & 0x7f;

        break;

    case 0x08:	/* GCR */

        s->gcr = value & 3;

        break;

    default:

        OMAP_BAD_REG(addr);

        return;

    }

}
",355,,LABEL_0,LABEL_0,LABEL_0,-1,"opaque,addr,value,size,s",,,,0,,0,GA,1074,0.4356851100921631,failed,
454,"static void do_token_in(USBDevice *s, USBPacket *p)

{

    int request, value, index;



    assert(p->ep->nr == 0);



    request = (s->setup_buf[0] << 8) | s->setup_buf[1];

    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];

    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];

 

    switch(s->setup_state) {

    case SETUP_STATE_ACK:

        if (!(s->setup_buf[0] & USB_DIR_IN)) {

            usb_device_handle_control(s, p, request, value, index,

                                      s->setup_len, s->data_buf);

            if (p->status == USB_RET_ASYNC) {

                return;

            }

            s->setup_state = SETUP_STATE_IDLE;

            p->actual_length = 0;

        }

        break;



    case SETUP_STATE_DATA:

        if (s->setup_buf[0] & USB_DIR_IN) {

            int len = s->setup_len - s->setup_index;

            if (len > p->iov.size) {

                len = p->iov.size;

            }

            usb_packet_copy(p, s->data_buf + s->setup_index, len);

            s->setup_index += len;

            if (s->setup_index >= s->setup_len) {

                s->setup_state = SETUP_STATE_ACK;

            }

            return;

        }

        s->setup_state = SETUP_STATE_IDLE;

        p->status = USB_RET_STALL;

        break;



    default:

        p->status = USB_RET_STALL;

    }

}
",305,"static void do_token_in(USBDevice *r, USBPacket *ic)

{

    int data, value, slice;



    assert(ic->ep->nr == 0);



    data = (r->setup_buf[0] << 8) | r->setup_buf[1];

    value   = (r->setup_buf[3] << 8) | r->setup_buf[2];

    slice   = (r->setup_buf[5] << 8) | r->setup_buf[4];

 

    switch(r->setup_state) {

    case SETUP_STATE_ACK:

        if (!(r->setup_buf[0] & USB_DIR_IN)) {

            usb_device_handle_control(r, ic, data, value, slice,

                                      r->setup_len, r->data_buf);

            if (ic->status == USB_RET_ASYNC) {

                return;

            }

            r->setup_state = SETUP_STATE_IDLE;

            ic->actual_length = 0;

        }

        break;



    case SETUP_STATE_DATA:

        if (r->setup_buf[0] & USB_DIR_IN) {

            int len = r->setup_len - r->setup_index;

            if (len > ic->iov.size) {

                len = ic->iov.size;

            }

            usb_packet_copy(ic, r->data_buf + r->setup_index, len);

            r->setup_index += len;

            if (r->setup_index >= r->setup_len) {

                r->setup_state = SETUP_STATE_ACK;

            }

            return;

        }

        r->setup_state = SETUP_STATE_IDLE;

        ic->status = USB_RET_STALL;

        break;



    default:

        ic->status = USB_RET_STALL;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,p,request,value,index",,,,3,"s:r,p:ic,request:data,value:value,index:slice,",1,GA,303,0.11745951970418295,GA,
455,"static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,

                              int buf_size, int buf_size2)

{

    RVDecContext *rv = avctx->priv_data;

    MpegEncContext *s = &rv->m;

    int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret;



    active_bits_size = buf_size * 8;

    init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8);

    if (s->codec_id == AV_CODEC_ID_RV10)

        mb_count = rv10_decode_picture_header(s);

    else

        mb_count = rv20_decode_picture_header(rv);

    if (mb_count < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""HEADER ERROR\n"");

        return AVERROR_INVALIDDATA;

    }



    if (s->mb_x >= s->mb_width ||

        s->mb_y >= s->mb_height) {

        av_log(s->avctx, AV_LOG_ERROR, ""POS ERROR %d %d\n"", s->mb_x, s->mb_y);

        return AVERROR_INVALIDDATA;

    }

    mb_pos = s->mb_y * s->mb_width + s->mb_x;

    left   = s->mb_width * s->mb_height - mb_pos;

    if (mb_count > left) {

        av_log(s->avctx, AV_LOG_ERROR, ""COUNT ERROR\n"");

        return AVERROR_INVALIDDATA;

    }



    if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) {

        // FIXME write parser so we always have complete frames?

        if (s->current_picture_ptr) {

            ff_er_frame_end(&s->er);

            ff_MPV_frame_end(s);

            s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0;

        }

        if ((ret = ff_MPV_frame_start(s, avctx)) < 0)

            return ret;

        ff_mpeg_er_frame_start(s);

    } else {

        if (s->current_picture_ptr->f.pict_type != s->pict_type) {

            av_log(s->avctx, AV_LOG_ERROR, ""Slice type mismatch\n"");

            return AVERROR_INVALIDDATA;

        }

    }



    av_dlog(avctx, ""qscale=%d\n"", s->qscale);



    /* default quantization values */

    if (s->codec_id == AV_CODEC_ID_RV10) {

        if (s->mb_y == 0)

            s->first_slice_line = 1;

    } else {

        s->first_slice_line = 1;

        s->resync_mb_x      = s->mb_x;

    }

    start_mb_x     = s->mb_x;

    s->resync_mb_y = s->mb_y;

    if (s->h263_aic) {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_aic_dc_scale_table;

    } else {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;

    }



    if (s->modified_quant)

        s->chroma_qscale_table = ff_h263_chroma_qscale_table;



    ff_set_qscale(s, s->qscale);



    s->rv10_first_dc_coded[0] = 0;

    s->rv10_first_dc_coded[1] = 0;

    s->rv10_first_dc_coded[2] = 0;

    s->block_wrap[0] =

    s->block_wrap[1] =

    s->block_wrap[2] =

    s->block_wrap[3] = s->b8_stride;

    s->block_wrap[4] =

    s->block_wrap[5] = s->mb_stride;

    ff_init_block_index(s);



    /* decode each macroblock */

    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {

        int ret;

        ff_update_block_index(s);

        av_dlog(avctx, ""**mb x=%d y=%d\n"", s->mb_x, s->mb_y);



        s->mv_dir  = MV_DIR_FORWARD;

        s->mv_type = MV_TYPE_16X16;

        ret = ff_h263_decode_mb(s, s->block);



        // Repeat the slice end check from ff_h263_decode_mb with our active

        // bitstream size

        if (ret != SLICE_ERROR) {

            int v = show_bits(&s->gb, 16);



            if (get_bits_count(&s->gb) + 16 > active_bits_size)

                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;



            if (!v)

                ret = SLICE_END;

        }

        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&

            8 * buf_size2 >= get_bits_count(&s->gb)) {

            active_bits_size = buf_size2 * 8;

            av_log(avctx, AV_LOG_DEBUG, ""update size from %d to %d\n"",

                   8 * buf_size, active_bits_size);

            ret = SLICE_OK;

        }



        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {

            av_log(s->avctx, AV_LOG_ERROR, ""ERROR at MB %d %d\n"", s->mb_x,

                   s->mb_y);

            return AVERROR_INVALIDDATA;

        }

        if (s->pict_type != AV_PICTURE_TYPE_B)

            ff_h263_update_motion_val(s);

        ff_MPV_decode_mb(s, s->block);

        if (s->loop_filter)

            ff_h263_loop_filter(s);



        if (++s->mb_x == s->mb_width) {

            s->mb_x = 0;

            s->mb_y++;

            ff_init_block_index(s);

        }

        if (s->mb_x == s->resync_mb_x)

            s->first_slice_line = 0;

        if (ret == SLICE_END)

            break;

    }



    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y,

                    ER_MB_END);



    return active_bits_size;

}
",1050,"static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,

                              int buf_size, int buf_scale182)

{

    RVDecContext *rv = avctx->priv_data;

    MpegEncContext *s = &rv->m;

    int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret;



    active_bits_size = buf_size * 8;

    init_get_bits(&s->sb, buf, FFMAX(buf_size, buf_scale182) * 8);

    if (s->codec_id == AV_CODEC_ID_RV10)

        mb_count = rv10_decode_picture_header(s);

    else

        mb_count = rv20_decode_picture_header(rv);

    if (mb_count < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""HEADER ERROR
"");

        return AVERROR_INVALIDDATA;

    }



    if (s->mb_x >= s->mb_width ||

        s->mbFy >= s->mb_height) {

        av_log(s->avctx, AV_LOG_ERROR, ""POS ERROR %d %d
"", s->mb_x, s->mbFy);

        return AVERROR_INVALIDDATA;

    }

    mb_pos = s->mbFy * s->mb_width + s->mb_x;

    left   = s->mb_width * s->mb_height - mb_pos;

    if (mb_count > left) {

        av_log(s->avctx, AV_LOG_ERROR, ""COUNT ERROR
"");

        return AVERROR_INVALIDDATA;

    }



    if ((s->mb_x == 0 && s->mbFy == 0) || s->current_picture_ptr == NULL) {

        // FIXME write parser so we always have complete frames?

        if (s->current_picture_ptr) {

            ff_er_frame_end(&s->er);

            ff_MPV_frame_end(s);

            s->mb_x = s->mbFy = s->resync_mb_x = s->resync_mb_y = 0;

        }

        if ((ret = ff_MPV_frame_start(s, avctx)) < 0)

            return ret;

        ff_mpeg_er_frame_start(s);

    } else {

        if (s->current_picture_ptr->f.pict_type != s->pict_type) {

            av_log(s->avctx, AV_LOG_ERROR, ""Slice type mismatch
"");

            return AVERROR_INVALIDDATA;

        }

    }



    av_dlog(avctx, ""qscale=%d
"", s->qscale);



    /* default quantization values */

    if (s->codec_id == AV_CODEC_ID_RV10) {

        if (s->mbFy == 0)

            s->first_slice_line = 1;

    } else {

        s->first_slice_line = 1;

        s->resync_mb_x      = s->mb_x;

    }

    start_mb_x     = s->mb_x;

    s->resync_mb_y = s->mbFy;

    if (s->h263_aic) {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_aic_dc_scale_table;

    } else {

        s->y_dc_scale_table =

        s->c_dc_scale_table = ff_mpeg1_dc_scale_table;

    }



    if (s->modified_quant)

        s->chroma_qscale_table = ff_h263_chroma_qscale_table;



    ff_set_qscale(s, s->qscale);



    s->rv10_first_dc_coded[0] = 0;

    s->rv10_first_dc_coded[1] = 0;

    s->rv10_first_dc_coded[2] = 0;

    s->block_wrap[0] =

    s->block_wrap[1] =

    s->block_wrap[2] =

    s->block_wrap[3] = s->b8_stride;

    s->block_wrap[4] =

    s->block_wrap[5] = s->mb_stride;

    ff_init_block_index(s);



    /* decode each macroblock */

    for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {

        int ret;

        ff_update_block_index(s);

        av_dlog(avctx, ""**mb x=%d y=%d
"", s->mb_x, s->mbFy);



        s->mv_dir  = MV_DIR_FORWARD;

        s->mv_type = MV_TYPE_16X16;

        ret = ff_h263_decode_mb(s, s->block);



        // Repeat the slice end check from ff_h263_decode_mb with our active

        // bitstream size

        if (ret != SLICE_ERROR) {

            int v = show_bits(&s->gb, 16);



            if (get_bits_count(&s->gb) + 16 > active_bits_size)

                v >>= get_bits_count(&s->gb) + 16 - active_bits_size;



            if (!v)

                ret = SLICE_END;

        }

        if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) &&

            8 * buf_scale182 >= get_bits_count(&s->gb)) {

            actactive_bits_sizebuf_scale182 * 8;

            av_log(avctx, AV_LOG_DEBUG, ""update size from %d to %d
"",

                   8 * buf_size, active_bits_size);

            ret = SLICE_OK;

        }



        if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) {

            av_log(s->avctx, AV_LOG_ERROR, ""ERROR at MB %d %d
"", s->mb_x,

                   s->mbFy);

            return AVERROR_INVALIDDATA;

        }

        if (s->pict_type != AV_PICTURE_TYPE_B)

            ff_h263_update_motion_val(s);

        ff_MPV_decode_mb(s, s->block);

        if (s->loop_filter)

            ff_h263_loop_filter(s);



        if (++s->mb_x == s->mb_width) {

            s->mb_x = 0;

            s->mbFy++;

            ff_init_block_index(s);

        }

        if (s->mb_x == s->resync_mb_x)

            s->first_slice_line = 0;

        if (ret == SLICE_END)

            break;

    }



    ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mbFy,

                    ER_MB_END);



    return active_bits_size;

}
",LABEL_1,LABEL_1,LABEL_0,1,"avctx,buf,buf_size,buf_size2,rv,s,mb_count,mb_pos,start_mb_x,active_bits_size,ret,mb_x,mb_y",,,,166,"avctx:avctx,buf:buf,buf_size:buf_size,buf_size2:buf_scale182,rv:rv,s:s,mb_count:mb_count,mb_pos:mb_pos,start_mb_x:start_mb_x,active_bits_size:active_bits_size,ret:ret,mb_x:mb_x,mb_y:mbFy,",11,GA,555,0.295794689655304,GA,
456,"void arm_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,

                        int flags)

{

    ARMCPU *cpu = ARM_CPU(cs);

    CPUARMState *env = &cpu->env;

    int i;



    if (is_a64(env)) {

        aarch64_cpu_dump_state(cs, f, cpu_fprintf, flags);

        return;

    }



    for(i=0;i<16;i++) {

        cpu_fprintf(f, ""R%02d=%08x"", i, env->regs[i]);

        if ((i % 4) == 3)

            cpu_fprintf(f, ""\n"");

        else

            cpu_fprintf(f, "" "");

    }



    if (arm_feature(env, ARM_FEATURE_M)) {

        uint32_t xpsr = xpsr_read(env);

        const char *mode;



        if (xpsr & XPSR_EXCP) {

            mode = ""handler"";

        } else {

            if (env->v7m.control & R_V7M_CONTROL_NPRIV_MASK) {

                mode = ""unpriv-thread"";

            } else {

                mode = ""priv-thread"";

            }

        }



        cpu_fprintf(f, ""XPSR=%08x %c%c%c%c %c %s\n"",

                    xpsr,

                    xpsr & XPSR_N ? 'N' : '-',

                    xpsr & XPSR_Z ? 'Z' : '-',

                    xpsr & XPSR_C ? 'C' : '-',

                    xpsr & XPSR_V ? 'V' : '-',

                    xpsr & XPSR_T ? 'T' : 'A',

                    mode);

    } else {

        uint32_t psr = cpsr_read(env);

        const char *ns_status = """";



        if (arm_feature(env, ARM_FEATURE_EL3) &&

            (psr & CPSR_M) != ARM_CPU_MODE_MON) {

            ns_status = env->cp15.scr_el3 & SCR_NS ? ""NS "" : ""S "";

        }



        cpu_fprintf(f, ""PSR=%08x %c%c%c%c %c %s%s%d\n"",

                    psr,

                    psr & CPSR_N ? 'N' : '-',

                    psr & CPSR_Z ? 'Z' : '-',

                    psr & CPSR_C ? 'C' : '-',

                    psr & CPSR_V ? 'V' : '-',

                    psr & CPSR_T ? 'T' : 'A',

                    ns_status,

                    cpu_mode_names[psr & 0xf], (psr & 0x10) ? 32 : 26);

    }



    if (flags & CPU_DUMP_FPU) {

        int numvfpregs = 0;

        if (arm_feature(env, ARM_FEATURE_VFP)) {

            numvfpregs += 16;

        }

        if (arm_feature(env, ARM_FEATURE_VFP3)) {

            numvfpregs += 16;

        }

        for (i = 0; i < numvfpregs; i++) {

            uint64_t v = float64_val(env->vfp.regs[i]);

            cpu_fprintf(f, ""s%02d=%08x s%02d=%08x d%02d=%016"" PRIx64 ""\n"",

                        i * 2, (uint32_t)v,

                        i * 2 + 1, (uint32_t)(v >> 32),

                        i, v);

        }

        cpu_fprintf(f, ""FPSCR: %08x\n"", (int)env->vfp.xregs[ARM_VFP_FPSCR]);

    }

}
",534,"void arm_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_rfprintf,

                        int ants)

{

    ARMCPU *cpu = ARM_CPU(cs);

    CPUARMState *env = &cpu->env;

    int col;



    if (is_a64(env)) {

        aarch64_cpu_dump_state(cs, f, cpu_rfprintf, ants);

        return;

    }



    for(col=0;col<16;col++) {

        cpu_rfprintf(f, ""R%02d=%08x"", col, env->regs[col]);

        if ((col % 4) == 3)

            cpu_rfprintf(f, ""
"");

        else

            cpu_rfprintf(f, "" "");

    }



    if (arm_feature(env, ARM_FEATURE_M)) {

        uint32_t xpsr = xpsr_read(env);

        const char *normal;



        if (xpsr & XPSR_EXCP) {

            normal = ""handler"";

        } else {

            if (env->v7m.control & R_V7M_CONTROL_NPRIV_MASK) {

                normal = ""unpriv-thread"";

            } else {

                normal = ""priv-thread"";

            }

        }



        cpu_rfprintf(f, ""XPSR=%08x %c%c%c%c %c %s
"",

                    xpsr,

                    xpsr & XPSR_N ? 'N' : '-',

                    xpsr & XPSR_Z ? 'Z' : '-',

                    xpsr & XPSR_C ? 'C' : '-',

                    xpsr & XPSR_V ? 'V' : '-',

                    xpsr & XPSR_T ? 'T' : 'A',

                    normal);

    } else {

        uint32_t psr = cpsr_read(env);

        const char *ns__num = """";



        if (arm_feature(env, ARM_FEATURE_EL3) &&

            (psr & CPSR_M) != ARM_CPU_MODE_MON) {

            ns__num = env->cp15.scr_el3 & SCR_NS ? ""NS "" : ""S "";

        }



        cpu_rfprintf(f, ""PSR=%08x %c%c%c%c %c %s%s%d
"",

                    psr,

                    psr & CPSR_N ? 'N' : '-',

                    psr & CPSR_Z ? 'Z' : '-',

                    psr & CPSR_C ? 'C' : '-',

                    psr & CPSR_V ? 'V' : '-',

                    psr & CPSR_T ? 'T' : 'A',

                    ns__num,

                    cpu_mode_names[psr & 0xf], (psr & 0x10) ? 32 : 26);

    }



    if (ants & CPU_DUMP_FPU) {

        int numvfpregs = 0;

        if (arm_feature(env, ARM_FEATURE_VFP)) {

            numvfpregs += 16;

        }

        if (arm_feature(env, ARM_FEATURE_VFP3)) {

            numvfpregs += 16;

        }

        for (col = 0; col < numvfpregs; col++) {

            uint64_t v = float64_val(env->vfp.regs[col]);

            cpu_rfprintf(f, ""s%02d=%08x s%02d=%08x d%02d=%016"" PRIx64 ""
"",

                        col * 2, (uint32_t)v,

                        col * 2 + 1, (uint32_t)(v >> 32),

                        col, v);

        }

        cpu_rfprintf(f, ""FPSCR: %08x
"", (int)env->vfp.xregs[ARM_VFP_FPSCR]);

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"cs,f,cpu_fprintf,flags,cpu,env,i,mode,ns_status",,,,28,"cs:cs,f:f,cpu_fprintf:cpu_rfprintf,flags:ants,cpu:cpu,env:env,i:col,mode:normal,ns_status:ns__num,",4,GA,530,0.23488123814264933,GA,
457,"DeviceState *qdev_try_create(BusState *bus, const char *name)

{

    DeviceState *dev;



    if (object_class_by_name(name) == NULL) {

        return NULL;

    }

    dev = DEVICE(object_new(name));

    if (!dev) {

        return NULL;

    }



    if (!bus) {

        bus = sysbus_get_default();

    }



    qdev_set_parent_bus(dev, bus);

    qdev_prop_set_globals(dev);



    return dev;

}
",81,"DeviceState *qdev_try_create(BusState *plugin, const char *unknown)

{

    DeviceState *di;



    if (object_class_by_name(unknown) == NULL) {

        return NULL;

    }

    devdiDEVICE(object_new(unknown));

    if (!dev) {

        return NULL;

    }



    if (!bus) {

        plugin = sysbus_get_default();

    }



    qdev_set_parent_bus(devdilugin);

    qdev_prop_set_globals(di);



    return di;

}
",LABEL_0,LABEL_0,LABEL_1,1,"bus,name,dev",,,,0,"bus:plugin,name:unknown,dev:di,",0,GA,291,0.10399909416834513,GA,
458,"static void spapr_hotplug_req_event(sPAPRDRConnector *drc, uint8_t hp_action)

{

    struct hp_log_full *new_hp;

    struct rtas_error_log *hdr;

    struct rtas_event_log_v6 *v6hdr;

    struct rtas_event_log_v6_maina *maina;

    struct rtas_event_log_v6_mainb *mainb;

    struct rtas_event_log_v6_hp *hp;

    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);

    sPAPRDRConnectorType drc_type = drck->get_type(drc);



    new_hp = g_malloc0(sizeof(struct hp_log_full));

    hdr = &new_hp->hdr;

    v6hdr = &new_hp->v6hdr;

    maina = &new_hp->maina;

    mainb = &new_hp->mainb;

    hp = &new_hp->hp;



    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6

                               | RTAS_LOG_SEVERITY_EVENT

                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED

                               | RTAS_LOG_OPTIONAL_PART_PRESENT

                               | RTAS_LOG_INITIATOR_HOTPLUG

                               | RTAS_LOG_TYPE_HOTPLUG);

    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)

                                       - sizeof(new_hp->hdr));



    spapr_init_v6hdr(v6hdr);

    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);



    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);

    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));

    mainb->subsystem_id = 0x80; /* External environment */

    mainb->event_severity = 0x00; /* Informational / non-error */

    mainb->event_subtype = 0x00; /* Normal shutdown */



    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);

    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));

    hp->hdr.section_version = 1; /* includes extended modifier */

    hp->hotplug_action = hp_action;





    switch (drc_type) {

    case SPAPR_DR_CONNECTOR_TYPE_PCI:

        hp->drc.index = cpu_to_be32(drck->get_index(drc));

        hp->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX;

        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;

        break;

    default:

        /* we shouldn't be signaling hotplug events for resources

         * that don't support them

         */

        g_assert(false);

        return;

    }



    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp);



    qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq));

}
",399,,LABEL_0,LABEL_0,LABEL_0,-1,"drc,hp_action,new_hp,hdr,v6hdr,maina,mainb,hp,drck",,,,0,,0,GA,1884,0.7680670619010925,failed,
459,"static int sdp_parse_rtpmap(AVFormatContext *s,

                            AVCodecContext *codec, RTSPStream *rtsp_st,

                            int payload_type, const char *p)

{

    char buf[256];

    int i;

    AVCodec *c;

    const char *c_name;



    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and

     * see if we can handle this kind of payload.

     * The space should normally not be there but some Real streams or

     * particular servers (""RealServer Version 6.1.3.970"", see issue 1658)

     * have a trailing space. */

    get_word_sep(buf, sizeof(buf), ""/ "", &p);

    if (payload_type >= RTP_PT_PRIVATE) {

        RTPDynamicProtocolHandler *handler;

        for (handler = RTPFirstDynamicPayloadHandler;

             handler; handler = handler->next) {

            if (!strcasecmp(buf, handler->enc_name) &&

                codec->codec_type == handler->codec_type) {

                codec->codec_id          = handler->codec_id;

                rtsp_st->dynamic_handler = handler;

                if (handler->open)

                    rtsp_st->dynamic_protocol_context = handler->open();

                break;

            }

        }

    } else {

        /* We are in a standard case

         * (from http://www.iana.org/assignments/rtp-parameters). */

        /* search into AVRtpPayloadTypes[] */

        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);

    }



    c = avcodec_find_decoder(codec->codec_id);

    if (c && c->name)

        c_name = c->name;

    else

        c_name = (char *) NULL;



    if (c_name) {

        get_word_sep(buf, sizeof(buf), ""/"", &p);

        i = atoi(buf);

        switch (codec->codec_type) {

        case CODEC_TYPE_AUDIO:

            av_log(s, AV_LOG_DEBUG, ""audio codec set to: %s\n"", c_name);

            codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;

            codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;

            if (i > 0) {

                codec->sample_rate = i;

                get_word_sep(buf, sizeof(buf), ""/"", &p);

                i = atoi(buf);

                if (i > 0)

                    codec->channels = i;

                // TODO: there is a bug here; if it is a mono stream, and

                // less than 22000Hz, faad upconverts to stereo and twice

                // the frequency.  No problem, but the sample rate is being

                // set here by the sdp line. Patch on its way. (rdm)

            }

            av_log(s, AV_LOG_DEBUG, ""audio samplerate set to: %i\n"",

                   codec->sample_rate);

            av_log(s, AV_LOG_DEBUG, ""audio channels set to: %i\n"",

                   codec->channels);

            break;

        case CODEC_TYPE_VIDEO:

            av_log(s, AV_LOG_DEBUG, ""video codec set to: %s\n"", c_name);

            break;

        default:

            break;

        }

        return 0;

    }



    return -1;

}
",562,"static int sdp_parse_rtpmap(AVFormatContext *s,

                            AVCodecContext *codec, RTSPStream *rtsp_st,

                            int payload_type, const char *p)

{

    char bi[256];

    int i;

    AVCodec *u;

    const char *c_name;



    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and

     * see if we can handle this kind of payload.

     * The space should normally not be there but some Real streams or

     * particular servers (""RealServer Version 6.1.3.970"", see issue 1658)

     * have a trailing space. */

    get_word_sep(bi, sizeof(bi), ""/ "", &p);

    if (payload_type >= RTP_PT_PRIVATE) {

        RTPDynamicProtocolHandler *handler;

        for (handler = RTPFirstDynamicPayloadHandler;

             handler; handler = handler->next) {

            if (!strcasecmp(bi, handler->enc_name) &&

                codec->codec_type == handler->codec_type) {

                codec->codec_id          = handler->codec_id;

                rtsp_st->dynamic_handler = handler;

                if (handler->open)

                    rtsp_st->dynamic_protocol_context = handler->open();

                break;

            }

        }

    } else {

        /* We are in a standard case

         * (from http://www.iana.org/assignments/rtp-parameters). */

        /* search into AVRtpPayloadTypes[] */

        codec->codec_id = ff_rtp_codec_id(bi, codec->codec_type);

    }



    u = avcodec_find_decoder(codec->codec_id);

    if (u && u->name)

        c_name = u->name;

    else

        c_name = (char *) NULL;



    if (c_name) {

        get_word_sep(bi, sizeof(bi), ""/"", &p);

       ii = atoi(bi);

        switch (codec->codec_type) {

        case CODEC_TYPE_AUDIO:

            av_log(s, AV_LOG_DEBUG, ""audio codec set to: %s
"", c_name);

            codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;

            codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;

            if (i > 0) {

                codec->sample_rate = i;

                get_word_sep(bi, sizeof(bi), ""/"", &p);

               ii = atoi(bi);

                if (i > 0)

                    codec->channels = i;

                // TODO: there is a bug here; if it is a mono stream, and

                // less than 22000Hz, faad upconverts to stereo and twice

                // the frequency.  No problem, but the sample rate is being

                // set here by the sdp line. Patch on its way. (rdm)

            }

            av_log(s, AV_LOG_DEBUG, ""audio samplerate set to: %i
"",

                   codec->sample_rate);

            av_log(s, AV_LOG_DEBUG, ""audio channels set to: %i
"",

                   codec->channels);

            break;

        case CODEC_TYPE_VIDEO:

            av_log(s, AV_LOG_DEBUG, ""video codec set to: %s
"", c_name);

            break;

        default:

            break;

        }

        return 0;

    }



    return -1;

}
",LABEL_1,LABEL_1,LABEL_0,1,"s,codec,rtsp_st,payload_type,p,buf,i,c,c_name,handler",,,,57,"s:s,codec:codec,rtsp_st:rtsp_st,payload_type:payload_type,p:p,buf:bi,i:i,c:u,c_name:c_name,handler:handler,",8,GA,609,0.272740638256073,GA,
460,"static bool try_poll_mode(AioContext *ctx, bool blocking)

{

    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),

                             (uint64_t)ctx->poll_max_ns);



        if (max_ns) {

            if (run_poll_handlers(ctx, max_ns)) {

                return true;

            }

        }

    }



    return false;

}
",87,,LABEL_1,LABEL_0,,-4,"ctx,blocking",,,,0,,0,Greedy,1,0.0004778146743774414,,
461,"static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    QEMUFileSocket *s = opaque;

    ssize_t len;



    do {

        len = qemu_recv(s->fd, buf, size, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();



    return len;

}
",82,"static int socket_get_buffer(void *opicit, uint8_t *cap, int64_t p, int size)

{

    QEMUFileSocket *s = opicit;

    ssize_t len;



    do {

        len = qemu_recv(s->fd, cap, size, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();



    return len;

}
",LABEL_1,LABEL_1,LABEL_0,1,"opaque,buf,pos,size,s,len",,,,10,"opaque:opicit,buf:cap,pos:p,size:size,s:s,len:len,",3,GA,263,0.09377190669377646,GA,
462,"static int mov_read_ctts(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)

{

    AVStream *st = c->fc->streams[c->fc->nb_streams-1];

    MOVStreamContext *sc = st->priv_data;

    unsigned int i, entries;



    get_byte(pb); /* version */

    get_be24(pb); /* flags */

    entries = get_be32(pb);

    if(entries >= UINT_MAX / sizeof(MOV_stts_t))

        return -1;



    sc->ctts_count = entries;

    sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t));

    if (!sc->ctts_data)

        return -1;

    dprintf(c->fc, ""track[%i].ctts.entries = %i\n"", c->fc->nb_streams-1, entries);



    for(i=0; i<entries; i++) {

        int count    =get_be32(pb);

        int duration =get_be32(pb);



        if (duration < 0) {

            av_log(c->fc, AV_LOG_ERROR, ""negative ctts, ignoring\n"");

            sc->ctts_count = 0;

            url_fskip(pb, 8 * (entries - i - 1));

            break;

        }

        sc->ctts_data[i].count   = count;

        sc->ctts_data[i].duration= duration;



        sc->time_rate= ff_gcd(sc->time_rate, duration);

    }

    return 0;

}
",289,"static int mov_read_ctts(MOVContext *dc, ByteIOContext *pl, MOV_atom_t  org)

{

    AVStream *stl dc->fc->streams[dc->fc->nb_streams-1];

    MOVStreamContext accc = l->priv_data;

    unsigned int i, antry;



    get_byte(pl); /* version */

    get_be24(pl); /* flags */

    antry = get_be32(pl);

    if(antry >= UINT_MAX / sizeof(MOV_stts_t))

        return -1;



    acc->ctts_count = antry;

    acc->ctts_data = av_malloc(antry * sizeof(MOV_stts_t));

    if (!sdc->ctts_data)

        return -1;

    dprintf(dc->fc, ""track[%i].ctts.antry = %i
"", dc->fc->nb_streams-1, antry);



    for(i=0; i<antry; i++) {

        int count    =get_be32(pl);

        int duration =get_be32(pl);



        if (duration < 0) {

            av_log(dc->fc, AV_LOG_ERROR, ""negative ctts, ignoring
"");

            acc->ctts_count = 0;

            url_fskip(pl, 8 * (antry - i - 1));

            break;

        }

        acc->ctts_data[i].count   = count;

        acc->ctts_data[i].duration= duration;



        acc->time_rate= ff_gcd(acc->time_rate, duration);

    }

    return 0;

}
",LABEL_0,LABEL_0,LABEL_1,1,"c,pb,atom,st,sc,i,entries",,,,9,"c:dc,pb:pl,atom: org,st:l,sc:acc,i:i,entries:antry,",1,GA,571,0.2194487452507019,GA,
463,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",56,"bool qemu_co_enter_next(CoQueue *route)

{

    Coroutine *last;



    last = QSIMPLEQ_FIRST(&route->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&route->entries, co_queue_next);

    qemu_coroutine_enter(last, NULL);

    return true;

}
",LABEL_1,LABEL_1,LABEL_0,1,"queue,next",,,,0,"queue:route,next:last,",0,GA,127,0.045024967193603514,GA,
464,"int kvm_init(int smp_cpus)
{
    KVMState *s;
    int ret;
    int i;
    if (smp_cpus > 1)
        return -EINVAL;
    s = qemu_mallocz(sizeof(KVMState));
    if (s == NULL)
        return -ENOMEM;
    for (i = 0; i < ARRAY_SIZE(s->slots); i++)
        s->slots[i].slot = i;
    s->vmfd = -1;
    s->fd = open(""/dev/kvm"", O_RDWR);
    if (s->fd == -1) {
        fprintf(stderr, ""Could not access KVM kernel module: %m\n"");
        ret = -errno;
        goto err;
    }
    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);
    if (ret < KVM_API_VERSION) {
            ret = -EINVAL;
        fprintf(stderr, ""kvm version too old\n"");
        goto err;
    }
    if (ret > KVM_API_VERSION) {
        ret = -EINVAL;
        fprintf(stderr, ""kvm version not supported\n"");
        goto err;
    }
    s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0);
    if (s->vmfd < 0)
        goto err;
    /* initially, KVM allocated its own memory and we had to jump through
     * hooks to make phys_ram_base point to this.  Modern versions of KVM
     * just use a user allocated buffer so we can use phys_ram_base
     * unmodified.  Make sure we have a sufficiently modern version of KVM.
     */
    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION, KVM_CAP_USER_MEMORY);
    if (ret <= 0) {
        if (ret == 0)
            ret = -EINVAL;
        fprintf(stderr, ""kvm does not support KVM_CAP_USER_MEMORY\n"");
        goto err;
    }
    /* There was a nasty bug in < kvm-80 that prevents memory slots from being
     * destroyed properly.  Since we rely on this capability, refuse to work
     * with any kernel without this capability. */
    ret = kvm_ioctl(s, KVM_CHECK_EXTENSION,
                    KVM_CAP_DESTROY_MEMORY_REGION_WORKS);
    if (ret <= 0) {
        if (ret == 0)
            ret = -EINVAL;
        fprintf(stderr,
                ""KVM kernel module broken (DESTROY_MEMORY_REGION)\n""
                ""Please upgrade to at least kvm-81.\n"");
        goto err;
    }
    ret = kvm_arch_init(s, smp_cpus);
    if (ret < 0)
        goto err;
    kvm_state = s;
    return 0;
err:
    if (s) {
        if (s->vmfd != -1)
            close(s->vmfd);
        if (s->fd != -1)
            close(s->fd);
    }
    qemu_free(s);
    return ret;
}",509,,LABEL_1,LABEL_1,LABEL_1,-1,"smp_cpus,s,ret,i",,,,0,,0,GA,811,0.3532649477322896,failed,
465,"void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,

                                        QGuestAllocator *alloc, uint16_t entry)

{

    uint16_t vector;

    uint32_t control;

    void *addr;



    g_assert(d->pdev->msix_enabled);

    addr = d->pdev->msix_table + (entry * 16);



    g_assert_cmpint(entry, >=, 0);

    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));

    d->config_msix_entry = entry;



    d->config_msix_data = 0x12345678;

    d->config_msix_addr = guest_alloc(alloc, 4);



    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,

                                                    d->config_msix_addr & ~0UL);

    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,

                                            (d->config_msix_addr >> 32) & ~0UL);

    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);



    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);

    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,

                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);



    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);

    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);

    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);

}
",241,"void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *ct,

                                        QGuestAllocator *ea, uint16_t section)

{

    uint16_t letter;

    uint32_t control;

    void *dd;



    g_assert(ct->pdev->msix_enabled);

    addddct->pdev->msix_table + (section * 16);



    g_assert_cmpint(section, >=, 0);

    g_assert_cmpint(esection <, qpci_msix_table_size(ct->pdev));

    ct->config_msix_entry = section;



    ct->config_msix_data = 0x12345678;

    ct->config_msix_addr = guest_alloc(ea, 4);



    qpci_io_writel(ct->pdev, dd + PCI_MSIX_ENTRY_LOWER_ADDR,

                                                    ct->config_msix_addr & ~0UL);

    qpci_io_writel(ct->pdev, dd + PCI_MSIX_ENTRY_UPPER_ADDR,

                                            (ct->config_msix_addr >> 32) & ~0UL);

    qpci_io_writel(ct->pdev, add+ PCI_MSIX_ENTRY_DATA, ct->config_msix_data);



    ccontrol= qpci_io_readl(ct->pdev, dd + PCI_MSIX_ENTRY_VECTOR_CTRL);

    qpci_io_writel(ct->pdev, dd + PCI_MSIX_ENTRY_VECTOR_CTRL,

                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);



    qpci_io_writew(ct->pdev, ct->addd VIRTIO_MSI_CONFIG_VECTOR, section);

    veletter qpci_io_readw(ct->pdev, ct->dd + VIRTIO_MSI_CONFIG_VECTOR);

    g_assert_cmphex(letter, !=, VIRTIO_MSI_NO_VECTOR);

}
",LABEL_1,LABEL_1,LABEL_0,1,"d,alloc,entry,vector,control,addr",,,,3,"d:ct,alloc:ea,entry:section,vector:letter,control:control,addr:dd,",1,GA,467,0.1752617875734965,GA,
466,"static uint64_t omap2_inth_read(void *opaque, target_phys_addr_t addr,

                                unsigned size)

{

    struct omap_intr_handler_s *s = (struct omap_intr_handler_s *) opaque;

    int offset = addr;

    int bank_no, line_no;

    struct omap_intr_handler_bank_s *bank = NULL;



    if ((offset & 0xf80) == 0x80) {

        bank_no = (offset & 0x60) >> 5;

        if (bank_no < s->nbanks) {

            offset &= ~0x60;

            bank = &s->bank[bank_no];




        }

    }



    switch (offset) {

    case 0x00:	/* INTC_REVISION */

        return s->revision;



    case 0x10:	/* INTC_SYSCONFIG */

        return (s->autoidle >> 2) & 1;



    case 0x14:	/* INTC_SYSSTATUS */

        return 1;						/* RESETDONE */



    case 0x40:	/* INTC_SIR_IRQ */

        return s->sir_intr[0];



    case 0x44:	/* INTC_SIR_FIQ */

        return s->sir_intr[1];



    case 0x48:	/* INTC_CONTROL */

        return (!s->mask) << 2;					/* GLOBALMASK */



    case 0x4c:	/* INTC_PROTECTION */




    case 0x50:	/* INTC_IDLE */

        return s->autoidle & 3;



    /* Per-bank registers */

    case 0x80:	/* INTC_ITR */

        return bank->inputs;



    case 0x84:	/* INTC_MIR */

        return bank->mask;



    case 0x88:	/* INTC_MIR_CLEAR */

    case 0x8c:	/* INTC_MIR_SET */




    case 0x90:	/* INTC_ISR_SET */

        return bank->swi;



    case 0x94:	/* INTC_ISR_CLEAR */




    case 0x98:	/* INTC_PENDING_IRQ */

        return bank->irqs & ~bank->mask & ~bank->fiq;



    case 0x9c:	/* INTC_PENDING_FIQ */

        return bank->irqs & ~bank->mask & bank->fiq;



    /* Per-line registers */

    case 0x100 ... 0x300:	/* INTC_ILR */

        bank_no = (offset - 0x100) >> 7;

        if (bank_no > s->nbanks)

            break;

        bank = &s->bank[bank_no];

        line_no = (offset & 0x7f) >> 2;

        return (bank->priority[line_no] << 2) |

                ((bank->fiq >> line_no) & 1);

    }



}",452,"static uint64_t omap2_inth_read(void *opaco, target_phys_addr_t addr,

                                unsigned len)

{

    struct omap_intr_handler_s syss = (struct omap_intr_handler_s *) opaco;

    int offset = addr;

    int bank_no, Line_no;

    struct omap_intr_handler_bank_s *bank = NULL;



    if ((offset & 0xf80) == 0x80) {

        bank_no = (offset & 0x60) >> 5;

        if (babank_no sys->nbanks) {

            offset &= ~0x60;

            babank &sys->bank[bank_no];




        }

    }



    switch (offset) {

    case 0x00:	/* INTC_REVISION */

        return sys->revision;



    case 0x10:	/* INTC_SYSCONFIG */

        return (sys->autoidle >> 2) & 1;



    case 0x14:	/* INTC_SYSSTATUS */

        return 1;						/* RESETDONE */



    case 0x40:	/* INTC_SIR_IRQ */

        return sys->sir_intr[0];



    case 0x44:	/* INTC_SIR_FIQ */

        return sys->sir_intr[1];



    case 0x48:	/* INTC_CONTROL */

        return (!s->mask) << 2;					/* GLOBALMASK */



    case 0x4c:	/* INTC_PROTECTION */




    case 0x50:	/* INTC_IDLE */

        return sys->autoidle & 3;



    /* Per-bank registers */

    case 0x80:	/* INTC_ITR */

        return bank->inputs;



    case 0x84:	/* INTC_MIR */

        return bank->mask;



    case 0x88:	/* INTC_MIR_CLEAR */

    case 0x8c:	/* INTC_MIR_SET */




    case 0x90:	/* INTC_ISR_SET */

        return bank->swi;



    case 0x94:	/* INTC_ISR_CLEAR */




    case 0x98:	/* INTC_PENDING_IRQ */

        return bank->irqs & ~bank->mask & ~bank->fiq;



    case 0x9c:	/* INTC_PENDING_FIQ */

        return bank->irqs & ~bank->mask & bank->fiq;



    /* Per-line registers */

    case 0x100 ... 0x300:	/* INTC_ILR */

        bank_no = (offset - 0x100) >> 7;

        if (babank_no sys->nbanks)

            break;

        babank &sys->bank[bank_no];

        Line_no = (offset & 0x7f) >> 2;

        return (bank->priority[Line_no] << 2) |

                ((bank->fiq >> Line_no) & 1);

    }



}",LABEL_1,LABEL_1,LABEL_0,1,"opaque,addr,size,s,bank_no,line_no,bank",,,,26,"opaque:opaco,addr:addr,size:len,s:sys,bank_no:bank_no,line_no:Line_no,bank:bank,",3,GA,404,0.16218961477279664,GA,
467,"static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    tcg_gen_qemu_st16(val, addr, index);

    dead_tmp(val);

}
",31,"static inline void gen_st16(TCGv valid, TCGv obj, int weight)

{

    tcg_gen_qemu_st16(valid, obj, weight);

    dead_tmp(valid);

}
",LABEL_1,LABEL_1,LABEL_0,1,"val,addr,index",,,,0,"val:valid,addr:obj,index:weight,",0,GA,291,0.10167935689290365,GA,
468,"static int net_connect(struct XenDevice *xendev)

{

    struct XenNetDev *netdev = container_of(xendev, struct XenNetDev, xendev);

    int rx_copy;



    if (xenstore_read_fe_int(&netdev->xendev, ""tx-ring-ref"",

                             &netdev->tx_ring_ref) == -1) {

        return -1;

    }

    if (xenstore_read_fe_int(&netdev->xendev, ""rx-ring-ref"",

                             &netdev->rx_ring_ref) == -1) {

        return 1;

    }

    if (xenstore_read_fe_int(&netdev->xendev, ""event-channel"",

                             &netdev->xendev.remote_port) == -1) {

        return -1;

    }



    if (xenstore_read_fe_int(&netdev->xendev, ""request-rx-copy"", &rx_copy) == -1) {

        rx_copy = 0;

    }

    if (rx_copy == 0) {

        xen_be_printf(&netdev->xendev, 0, ""frontend doesn't support rx-copy.\n"");

        return -1;

    }



    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,

                                          netdev->xendev.dom,

                                          netdev->tx_ring_ref,

                                          PROT_READ | PROT_WRITE);

    netdev->rxs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,

                                          netdev->xendev.dom,

                                          netdev->rx_ring_ref,

                                          PROT_READ | PROT_WRITE);

    if (!netdev->txs || !netdev->rxs) {

        return -1;

    }

    BACK_RING_INIT(&netdev->tx_ring, netdev->txs, XC_PAGE_SIZE);

    BACK_RING_INIT(&netdev->rx_ring, netdev->rxs, XC_PAGE_SIZE);



    xen_be_bind_evtchn(&netdev->xendev);



    xen_be_printf(&netdev->xendev, 1, ""ok: tx-ring-ref %d, rx-ring-ref %d, ""

                  ""remote port %d, local port %d\n"",

                  netdev->tx_ring_ref, netdev->rx_ring_ref,

                  netdev->xendev.remote_port, netdev->xendev.local_port);



    net_tx_packets(netdev);

    return 0;

}
",354,,LABEL_1,LABEL_0,,-4,"xendev,netdev,rx_copy",,,,0,,0,Greedy,1,0.0006440957387288411,,
469,"static int zero_single_l2(BlockDriverState *bs, uint64_t offset,

    unsigned int nb_clusters)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t *l2_table;

    int l2_index;

    int ret;

    int i;



    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);

    if (ret < 0) {

        return ret;

    }



    /* Limit nb_clusters to one L2 table */

    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);



    for (i = 0; i < nb_clusters; i++) {

        uint64_t old_offset;



        old_offset = be64_to_cpu(l2_table[l2_index + i]);



        /* Update L2 entries */

        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);

        if (old_offset & QCOW_OFLAG_COMPRESSED) {

            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);

            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);

        } else {

            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);

        }

    }



    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);

    if (ret < 0) {

        return ret;

    }



    return nb_clusters;

}
",219,,LABEL_0,LABEL_0,LABEL_0,-1,"bs,offset,nb_clusters,s,l2_table,l2_index,ret,i,old_offset",,,,0,,0,GA,1932,0.738923207918803,failed,
470,"static void ide_identify(IDEState *s)

{

    uint16_t *p;

    unsigned int oldsize;



    memset(s->io_buffer, 0, 512);

    p = (uint16_t *)s->io_buffer;

    stw(p + 0, 0x0040);

    stw(p + 1, s->cylinders); 

    stw(p + 3, s->heads);

    stw(p + 4, 512 * s->sectors); /* sectors */

    stw(p + 5, 512); /* sector size */

    stw(p + 6, s->sectors); 

    stw(p + 20, 3); /* buffer type */

    stw(p + 21, 512); /* cache size in sectors */

    stw(p + 22, 4); /* ecc bytes */

    padstr((uint8_t *)(p + 27), ""QEMU HARDDISK"", 40);

#if MAX_MULT_SECTORS > 1    

    stw(p + 47, MAX_MULT_SECTORS);

#endif

    stw(p + 48, 1); /* dword I/O */

    stw(p + 49, 1 << 9); /* LBA supported, no DMA */

    stw(p + 51, 0x200); /* PIO transfer cycle */

    stw(p + 52, 0x200); /* DMA transfer cycle */

    stw(p + 54, s->cylinders);

    stw(p + 55, s->heads);

    stw(p + 56, s->sectors);

    oldsize = s->cylinders * s->heads * s->sectors;

    stw(p + 57, oldsize);

    stw(p + 58, oldsize >> 16);

    if (s->mult_sectors)

        stw(p + 59, 0x100 | s->mult_sectors);

    stw(p + 60, s->nb_sectors);

    stw(p + 61, s->nb_sectors >> 16);

    stw(p + 80, (1 << 1) | (1 << 2));

    stw(p + 82, (1 << 14));

    stw(p + 83, (1 << 14));

    stw(p + 84, (1 << 14));

    stw(p + 85, (1 << 14));

    stw(p + 86, 0);

    stw(p + 87, (1 << 14));

}
",476,"static void ide_identify(IDEState *ss)

{

    uint16_t *b;

    unsigned int Oldsize;



    memset(ss->io_buffer, 0, 512);

    pb= (uint16_t *)ss->io_buffer;

    stw(b + 0, 0x0040);

    stw(pb+ 1, ss->cylinders); 

    stw(pb+ 3, ss->heads);

    stw(pb+ 4, 512 * ss->sectors); /* sectors */

    stw(b + 5, 512); /* sector size */

    stw(pb+ 6, ss->sectors); 

    stw(b + 20, 3); /* buffer type */

    stw(b + 21, 512); /* cache size in sectors */

    stw(b + 22, 4); /* ecc bytes */

    padstr((uint8_t *)(b + 27), ""QEMU HARDDISK"", 40);

#if MAX_MULT_SECTORS > 1    

    stw(b + 47, MAX_MULT_SECTORS);

#endif

    stw(b + 48, 1); /* dword I/O */

    stw(b + 49, 1 << 9); /* LBA supported, no DMA */

    stw(b + 51, 0x200); /* PIO transfer cycle */

    stw(b + 52, 0x200); /* DMA transfer cycle */

    stw(pb+ 54, ss->cylinders);

    stw(pb+ 55, ss->heads);

    stw(pb+ 56, ss->sectors);

    oldOldsizess->cylinders * ss->heads * ss->sectors;

    stw(b + 57, Oldsize);

    stw(b + 58, Oldsize >> 16);

    if (ss->mult_sectors)

        stw(pb+ 59, 0x100 | ss->mult_sectors);

    stw(pb+ 60, ss->nb_sectors);

    stw(pb+ 61, ss->nb_sectors >> 16);

    stw(b + 80, (1 << 1) | (1 << 2));

    stw(b + 82, (1 << 14));

    stw(b + 83, (1 << 14));

    stw(b + 84, (1 << 14));

    stw(b + 85, (1 << 14));

    stw(b + 86, 0);

    stw(b + 87, (1 << 14));

}
",LABEL_0,LABEL_0,LABEL_1,1,"s,p,oldsize",,,,0,"s:ss,p:b,oldsize:Oldsize,",0,GA,228,0.08989550272623698,GA,
471,"static void xtensa_kc705_init(MachineState *machine)

{

    static const LxBoardDesc kc705_board = {

        .flash_base = 0xf0000000,

        .flash_size = 0x08000000,

        .flash_boot_base = 0x06000000,

        .flash_sector_size = 0x20000,

        .sram_size = 0x2000000,

    };

    lx_init(&kc705_board, machine);

}
",53,,LABEL_0,LABEL_0,LABEL_0,-1,machine,,,,0,,0,GA,250,0.08877893686294555,failed,
472,"static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)

{

    int sum, i, j;

    int coeffs[pred_order];



    for (i=0; i<pred_order; i++)

        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);



    for (i=0; i < s->blocksize; i++) {

        sum = s->lpcqoffset;

        for (j=0; j<pred_order; j++)

            sum += coeffs[j] * s->decoded[channel][i-j-1];

        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);

    }

}
",153,,LABEL_1,LABEL_0,,-4,"s,channel,residual_size,pred_order,sum,i,j,coeffs",,,,0,,0,Greedy,1,0.0005210598309834798,,
473,"static int decode_channel_residues(WmallDecodeCtx *s, int ch, int tile_size)

{

    int i = 0;

    unsigned int ave_mean;

    s->transient[ch] = get_bits1(&s->gb);

    if (s->transient[ch]) {

        s->transient_pos[ch] = get_bits(&s->gb, av_log2(tile_size));

        if (s->transient_pos[ch])

            s->transient[ch] = 0;

        s->channel[ch].transient_counter =

            FFMAX(s->channel[ch].transient_counter, s->samples_per_frame / 2);

    } else if (s->channel[ch].transient_counter)

        s->transient[ch] = 1;



    if (s->seekable_tile) {

        ave_mean = get_bits(&s->gb, s->bits_per_sample);

        s->ave_sum[ch] = ave_mean << (s->movave_scaling + 1);

    }



    if (s->seekable_tile) {

        if (s->do_inter_ch_decorr)

            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample + 1);

        else

            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample);

        i++;

    }

    for (; i < tile_size; i++) {

        int quo = 0, rem, rem_bits, residue;

        while(get_bits1(&s->gb)) {

            quo++;

            if (get_bits_left(&s->gb) <= 0)

                return -1;

        }

        if (quo >= 32)

            quo += get_bits_long(&s->gb, get_bits(&s->gb, 5) + 1);



        ave_mean = (s->ave_sum[ch] + (1 << s->movave_scaling)) >> (s->movave_scaling + 1);

        if (ave_mean <= 1)

            residue = quo;

        else {

            rem_bits = av_ceil_log2(ave_mean);

            rem      = rem_bits ? get_bits(&s->gb, rem_bits) : 0;

            residue  = (quo << rem_bits) + rem;

        }



        s->ave_sum[ch] = residue + s->ave_sum[ch] -

                         (s->ave_sum[ch] >> s->movave_scaling);



        if (residue & 1)

            residue = -(residue >> 1) - 1;

        else

            residue = residue >> 1;

        s->channel_residues[ch][i] = residue;

    }



    return 0;



}
",498,,LABEL_1,LABEL_0,,-4,"s,ch,tile_size,ave_mean,i,rem,rem_bits,residue,quo",,,,0,,0,Greedy,1,0.0006876230239868164,,
474,"static int vdpau_frames_init(AVHWFramesContext *ctx)

{

    VDPAUDeviceContext *device_priv = ctx->device_ctx->internal->priv;

    VDPAUFramesContext        *priv = ctx->internal->priv;



    int i;



    switch (ctx->sw_format) {

    case AV_PIX_FMT_YUV420P: priv->chroma_type = VDP_CHROMA_TYPE_420; break;

    case AV_PIX_FMT_YUV422P: priv->chroma_type = VDP_CHROMA_TYPE_422; break;

    case AV_PIX_FMT_YUV444P: priv->chroma_type = VDP_CHROMA_TYPE_444; break;

    default:

        av_log(ctx, AV_LOG_ERROR, ""Unsupported data layout: %s\n"",

               av_get_pix_fmt_name(ctx->sw_format));

        return AVERROR(ENOSYS);

    }



    for (i = 0; i < FF_ARRAY_ELEMS(vdpau_pix_fmts); i++) {

        if (vdpau_pix_fmts[i].chroma_type == priv->chroma_type) {

            priv->chroma_idx  = i;

            priv->pix_fmts    = device_priv->pix_fmts[i];

            priv->nb_pix_fmts = device_priv->nb_pix_fmts[i];

            break;

        }

    }

    if (!priv->pix_fmts) {

        av_log(ctx, AV_LOG_ERROR, ""Unsupported chroma type: %d\n"", priv->chroma_type);

        return AVERROR(ENOSYS);

    }



    if (!ctx->pool) {

        ctx->internal->pool_internal = av_buffer_pool_init2(sizeof(VdpVideoSurface), ctx,

                                                            vdpau_pool_alloc, NULL);

        if (!ctx->internal->pool_internal)

            return AVERROR(ENOMEM);

    }



    priv->get_data = device_priv->get_data;

    priv->put_data = device_priv->put_data;



    return 0;

}
",298,,LABEL_1,LABEL_0,,-4,"ctx,device_priv,priv,i",,,,0,,0,Greedy,1,0.0005759636561075847,,
475,"static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,

                                            target_phys_addr_t base,

                                            qemu_irq txirq, qemu_irq rxirq,

                                            qemu_irq *dma, omap_clk clk)

{

    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)

            g_malloc0(sizeof(struct omap_mcbsp_s));



    s->txirq = txirq;

    s->rxirq = rxirq;

    s->txdrq = dma[0];

    s->rxdrq = dma[1];

    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);

    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);

    omap_mcbsp_reset(s);



    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, ""omap-mcbsp"", 0x800);

    memory_region_add_subregion(system_memory, base, &s->iomem);



    return s;

}
",150,,LABEL_0,LABEL_0,LABEL_0,-1,"system_memory,base,txirq,rxirq,dma,clk,s",,,,0,,0,GA,1352,0.5062516331672668,failed,
476,"void vp8_mc(VP8Context *s, int luma,

            uint8_t *dst, uint8_t *src, const VP56mv *mv,

            int x_off, int y_off, int block_w, int block_h,

            int width, int height, int linesize,

            vp8_mc_func mc_func[3][3])

{

    if (AV_RN32A(mv)) {

        static const uint8_t idx[3][8] = {

            { 0, 1, 2, 1, 2, 1, 2, 1 }, // nr. of left extra pixels,

                                        // also function pointer index

            { 0, 3, 5, 3, 5, 3, 5, 3 }, // nr. of extra pixels required

            { 0, 2, 3, 2, 3, 2, 3, 2 }, // nr. of right extra pixels

        };

        int mx = (mv->x << luma)&7, mx_idx = idx[0][mx];

        int my = (mv->y << luma)&7, my_idx = idx[0][my];



        x_off += mv->x >> (3 - luma);

        y_off += mv->y >> (3 - luma);



        // edge emulation

        src += y_off * linesize + x_off;

        if (x_off < mx_idx || x_off >= width  - block_w - idx[2][mx] ||

            y_off < my_idx || y_off >= height - block_h - idx[2][my]) {

            s->dsp.emulated_edge_mc(s->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize,

                                block_w + idx[1][mx], block_h + idx[1][my],

                                x_off - mx_idx, y_off - my_idx, width, height);

            src = s->edge_emu_buffer + mx_idx + linesize * my_idx;

        }

        mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my);

    } else

        mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0);

}
",408,,LABEL_0,LABEL_1,,-4,"s,luma,dst,src,mv,x_off,y_off,block_w,block_h,height,linesize,mc_func,idx",,,,0,,0,Greedy,1,0.0006449182828267415,,
477,"static void term_exit(void)

{

#ifndef __MINGW32__

    tcsetattr (0, TCSANOW, &oldtty);

#endif

}
",18,,LABEL_0,LABEL_1,,-4,,,,,0,,0,Greedy,1,0.00041834115982055666,,
478,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)

{

    tcet->bypass = bypass;

}
",19,"void spapr_tce_set_bypass(sPAPRTCETable *tgen, bool byterupt)

{

    tgen->byterupt = byterupt;

}
",LABEL_0,LABEL_0,LABEL_1,1,"tcet,bypass",,,,0,"tcet:tgen,bypass:byterupt,",0,GA,92,0.0322005828221639,GA,
479,"static void mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s)

{

    AVStream       *video_st    = s->streams[0];

    AVCodecParameters *video_par = s->streams[0]->codecpar;

    AVCodecParameters *audio_par = s->streams[1]->codecpar;

    int audio_rate = audio_par->sample_rate;

    // TODO: should be avg_frame_rate

    int frame_rate = ((video_st->time_base.den) * (0x10000)) / (video_st->time_base.num);

    int audio_kbitrate = audio_par->bit_rate / 1000;

    int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate);



    avio_wb32(pb, 0x94); /* size */

    ffio_wfourcc(pb, ""uuid"");

    ffio_wfourcc(pb, ""PROF"");



    avio_wb32(pb, 0x21d24fce); /* 96 bit UUID */

    avio_wb32(pb, 0xbb88695c);

    avio_wb32(pb, 0xfac9c740);



    avio_wb32(pb, 0x0);  /* ? */

    avio_wb32(pb, 0x3);  /* 3 sections ? */



    avio_wb32(pb, 0x14); /* size */

    ffio_wfourcc(pb, ""FPRF"");

    avio_wb32(pb, 0x0);  /* ? */

    avio_wb32(pb, 0x0);  /* ? */

    avio_wb32(pb, 0x0);  /* ? */



    avio_wb32(pb, 0x2c);  /* size */

    ffio_wfourcc(pb, ""APRF""); /* audio */

    avio_wb32(pb, 0x0);

    avio_wb32(pb, 0x2);   /* TrackID */

    ffio_wfourcc(pb, ""mp4a"");

    avio_wb32(pb, 0x20f);

    avio_wb32(pb, 0x0);

    avio_wb32(pb, audio_kbitrate);

    avio_wb32(pb, audio_kbitrate);

    avio_wb32(pb, audio_rate);

    avio_wb32(pb, audio_par->channels);



    avio_wb32(pb, 0x34);  /* size */

    ffio_wfourcc(pb, ""VPRF"");   /* video */

    avio_wb32(pb, 0x0);

    avio_wb32(pb, 0x1);    /* TrackID */

    if (video_par->codec_id == AV_CODEC_ID_H264) {

        ffio_wfourcc(pb, ""avc1"");

        avio_wb16(pb, 0x014D);

        avio_wb16(pb, 0x0015);

    } else {

        ffio_wfourcc(pb, ""mp4v"");

        avio_wb16(pb, 0x0000);

        avio_wb16(pb, 0x0103);

    }

    avio_wb32(pb, 0x0);

    avio_wb32(pb, video_kbitrate);

    avio_wb32(pb, video_kbitrate);

    avio_wb32(pb, frame_rate);

    avio_wb32(pb, frame_rate);

    avio_wb16(pb, video_par->width);

    avio_wb16(pb, video_par->height);

    avio_wb32(pb, 0x010001); /* ? */

}
",523,,LABEL_1,LABEL_0,,-4,"pb,s,video_st,video_par,audio_par",,,,0,,0,Greedy,1,0.0007192015647888184,,
480,"static void virtio_notify(struct subchannel_id schid)

{

    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);

}
",25,,LABEL_0,LABEL_1,,-4,schid,,,,0,,0,Greedy,1,0.00041755437850952146,,
481,"static void vp6_parse_coeff_models(VP56Context *s)

{

    VP56RangeCoder *c = &s->c;

    VP56Model *model = s->modelp;

    int def_prob[11];

    int node, cg, ctx, pos;

    int ct;    /* code type */

    int pt;    /* plane type (0 for Y, 1 for U or V) */



    memset(def_prob, 0x80, sizeof(def_prob));



    for (pt=0; pt<2; pt++)

        for (node=0; node<11; node++)

            if (vp56_rac_get_prob(c, vp6_dccv_pct[pt][node])) {

                def_prob[node] = vp56_rac_gets_nn(c, 7);

                model->coeff_dccv[pt][node] = def_prob[node];

            } else if (s->framep[VP56_FRAME_CURRENT]->key_frame) {

                model->coeff_dccv[pt][node] = def_prob[node];

            }



    if (vp56_rac_get(c)) {

        for (pos=1; pos<64; pos++)

            if (vp56_rac_get_prob(c, vp6_coeff_reorder_pct[pos]))

                model->coeff_reorder[pos] = vp56_rac_gets(c, 4);

        vp6_coeff_order_table_init(s);

    }



    for (cg=0; cg<2; cg++)

        for (node=0; node<14; node++)

            if (vp56_rac_get_prob(c, vp6_runv_pct[cg][node]))

                model->coeff_runv[cg][node] = vp56_rac_gets_nn(c, 7);



    for (ct=0; ct<3; ct++)

        for (pt=0; pt<2; pt++)

            for (cg=0; cg<6; cg++)

                for (node=0; node<11; node++)

                    if (vp56_rac_get_prob(c, vp6_ract_pct[ct][pt][cg][node])) {

                        def_prob[node] = vp56_rac_gets_nn(c, 7);

                        model->coeff_ract[pt][ct][cg][node] = def_prob[node];

                    } else if (s->framep[VP56_FRAME_CURRENT]->key_frame) {

                        model->coeff_ract[pt][ct][cg][node] = def_prob[node];

                    }



    if (s->use_huffman) {

        for (pt=0; pt<2; pt++) {

            vp6_build_huff_tree(s, model->coeff_dccv[pt],

                                vp6_huff_coeff_map, 12, &s->dccv_vlc[pt]);

            vp6_build_huff_tree(s, model->coeff_runv[pt],

                                vp6_huff_run_map, 9, &s->runv_vlc[pt]);

            for (ct=0; ct<3; ct++)

                for (cg = 0; cg < 6; cg++)

                    vp6_build_huff_tree(s, model->coeff_ract[pt][ct][cg],

                                        vp6_huff_coeff_map, 12,

                                        &s->ract_vlc[pt][ct][cg]);

        }

        memset(s->nb_null, 0, sizeof(s->nb_null));

    } else {

    /* coeff_dcct is a linear combination of coeff_dccv */

    for (pt=0; pt<2; pt++)

        for (ctx=0; ctx<3; ctx++)

            for (node=0; node<5; node++)

                model->coeff_dcct[pt][ctx][node] = av_clip(((model->coeff_dccv[pt][node] * vp6_dccv_lc[ctx][node][0] + 128) >> 8) + vp6_dccv_lc[ctx][node][1], 1, 255);

    }

}
",740,,LABEL_0,LABEL_1,,-4,"s,c,model,def_prob,node,cg,ctx,pos,ct,pt",,,,0,,0,Greedy,1,0.000807030995686849,,
482,"static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev,

                                  DeviceState *dev, Error **errp)

{

    PCIDevice *pci_dev = PCI_DEVICE(dev);

    S390PCIBusDevice *pbdev;

    S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev)

                                           ->qbus.parent);



    pbdev = &s->pbdev[PCI_SLOT(pci_dev->devfn)];



    pbdev->fid = s390_pci_get_pfid(pci_dev);

    pbdev->pdev = pci_dev;

    pbdev->configured = true;

    pbdev->fh = s390_pci_get_pfh(pci_dev);



    s390_pcihost_setup_msix(pbdev);



    if (dev->hotplugged) {

        s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY,

                                     pbdev->fh, pbdev->fid);

        s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED,

                                     pbdev->fh, pbdev->fid);

    }

}
",144,,LABEL_0,LABEL_0,LABEL_0,-1,"hotplug_dev,dev,errp,pci_dev,pbdev,s",,,,0,,0,GA,1198,0.4403354644775391,failed,
483,"static av_cold int dnxhd_encode_init(AVCodecContext *avctx)

{

    DNXHDEncContext *ctx = avctx->priv_data;

    int i, index, bit_depth, ret;



    switch (avctx->pix_fmt) {

    case AV_PIX_FMT_YUV422P:

        bit_depth = 8;

        break;

    case AV_PIX_FMT_YUV422P10:

        bit_depth = 10;

        break;

    default:

        av_log(avctx, AV_LOG_ERROR,

               ""pixel format is incompatible with DNxHD\n"");

        return AVERROR(EINVAL);

    }



    ctx->cid = ff_dnxhd_find_cid(avctx, bit_depth);

    if (!ctx->cid) {

        av_log(avctx, AV_LOG_ERROR,

               ""video parameters incompatible with DNxHD\n"");

        return AVERROR(EINVAL);

    }

    av_log(avctx, AV_LOG_DEBUG, ""cid %d\n"", ctx->cid);



    index = ff_dnxhd_get_cid_table(ctx->cid);

    if (index < 0)

        return index;

    ctx->cid_table = &ff_dnxhd_cid_table[index];



    ctx->m.avctx    = avctx;

    ctx->m.mb_intra = 1;

    ctx->m.h263_aic = 1;



    avctx->bits_per_raw_sample = ctx->cid_table->bit_depth;



    ff_blockdsp_init(&ctx->bdsp, avctx);

    ff_fdctdsp_init(&ctx->m.fdsp, avctx);

    ff_mpv_idct_init(&ctx->m);

    ff_mpegvideoencdsp_init(&ctx->m.mpvencdsp, avctx);

    ff_pixblockdsp_init(&ctx->m.pdsp, avctx);

    if (!ctx->m.dct_quantize)

        ctx->m.dct_quantize = ff_dct_quantize_c;



    if (ctx->cid_table->bit_depth == 10) {

        ctx->m.dct_quantize     = dnxhd_10bit_dct_quantize;

        ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;

        ctx->block_width_l2     = 4;

    } else {

        ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;

        ctx->block_width_l2     = 3;

    }



    if (ARCH_X86)

        ff_dnxhdenc_init_x86(ctx);



    ctx->m.mb_height = (avctx->height + 15) / 16;

    ctx->m.mb_width  = (avctx->width  + 15) / 16;



    if (avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) {

        ctx->interlaced   = 1;

        ctx->m.mb_height /= 2;

    }



    ctx->m.mb_num = ctx->m.mb_height * ctx->m.mb_width;



#if FF_API_QUANT_BIAS

FF_DISABLE_DEPRECATION_WARNINGS

    if (ctx->intra_quant_bias == FF_DEFAULT_QUANT_BIAS &&

        avctx->intra_quant_bias != FF_DEFAULT_QUANT_BIAS)

        ctx->intra_quant_bias = avctx->intra_quant_bias;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    // XXX tune lbias/cbias

    if ((ret = dnxhd_init_qmat(ctx, ctx->intra_quant_bias, 0)) < 0)

        return ret;



    /* Avid Nitris hardware decoder requires a minimum amount of padding

     * in the coding unit payload */

    if (ctx->nitris_compat)

        ctx->min_padding = 1600;



    if ((ret = dnxhd_init_vlc(ctx)) < 0)

        return ret;

    if ((ret = dnxhd_init_rc(ctx)) < 0)

        return ret;



    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size,

                      ctx->m.mb_height * sizeof(uint32_t), fail);

    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs,

                      ctx->m.mb_height * sizeof(uint32_t), fail);

    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits,

                      ctx->m.mb_num * sizeof(uint16_t), fail);

    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale,

                      ctx->m.mb_num * sizeof(uint8_t), fail);



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    avctx->coded_frame->key_frame = 1;

    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    if (avctx->thread_count > MAX_THREADS) {

        av_log(avctx, AV_LOG_ERROR, ""too many threads\n"");

        return AVERROR(EINVAL);

    }



    ctx->thread[0] = ctx;

    for (i = 1; i < avctx->thread_count; i++) {

        ctx->thread[i] = av_malloc(sizeof(DNXHDEncContext));

        memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext));

    }



    return 0;

fail:  // for FF_ALLOCZ_OR_GOTO

    return AVERROR(ENOMEM);

}
",802,"static av_cold int dnxhd_encode_init(AVCodecContext * avca)

{

    DNXHDEncContext *cat =  avca->priv_data;

    int ip, index, bit64deep, arr;



    switch ( avca->pix_fmt) {

    case AV_PIX_FMT_YUV422P:

        bit64deep = 8;

        break;

    case AV_PIX_FMT_YUV422P10:

        bit64deep = 10;

        break;

    default:

        av_log( avca, AV_LOG_ERROR,

               ""pixel format is incompatible with DNxHD
"");

        return AVERROR(EINVAL);

    }



    cat->cid = ff_dnxhd_find_cid( avca, bit64deep);

    if (!ctx->cid) {

        av_log( avca, AV_LOG_ERROR,

               ""video parameters incompatible with DNxHD
"");

        return AVERROR(EINVAL);

    }

    av_log( avca, AV_LOG_DEBUG, ""cid %d
"", cat->cid);



    index = ff_dnxhd_get_cid_table(cat->cid);

    if (index < 0)

        return index;

    cat->cid_table = &ff_dnxhd_cid_table[index];



    cat->m. avca    =  avca;

    cat->m.mb_intra = 1;

    cat->m.h263_aic = 1;



     avca->bits_per_raw_sample = cat->cid_table->bit64deep;



    ff_blockdsp_init(&cat->bdsp,  avca);

    ff_fdctdsp_init(&cat->m.fdsp,  avca);

    ff_mpv_idct_init(&cat->m);

    ff_mpegvideoencdsp_init(&cat->m.mpvencdsp,  avca);

    ff_pixblockdsp_init(&cat->m.pdsp,  avca);

    if (!ctx->m.dct_quantize)

        cat->m.dct_quantize = ff_dct_quantize_c;



    if (cat->cid_table->bit64deep == 10) {

        cat->m.dct_quantize     = dnxhd_10bit_dct_quantize;

        cat->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;

        cat->block_width_l2     = 4;

    } else {

        cat->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;

        cat->block_width_l2     = 3;

    }



    if (ARCH_X86)

        ff_dnxhdenc_init_x86(cat);



    cat->m.mb_height = ( avca->height + 15) / 16;

    cat->m.mb_width  = ( avca->width  + 15) / 16;



    if ( avca->flags & AV_CODEC_FLAG_INTERLACED_DCT) {

        cat->interlaced   = 1;

        cat->m.mb_height /= 2;

    }



    cat->m.mb_num = cat->m.mb_height * cat->m.mb_width;



#if FF_API_QUANT_BIAS

FF_DISABLE_DEPRECATION_WARNINGS

    if (cat->intra_quant_bias == FF_DEFAULT_QUANT_BIAS &&

         avca->intra_quant_bias != FF_DEFAULT_QUANT_BIAS)

        cat->intra_quant_bias =  avca->intra_quant_bias;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    // XXX tune lbias/cbias

    if ((arr = dnxhd_init_qmat(cat, cat->intra_quant_bias, 0)) < 0)

        return arr;



    /* Avid Nitris hardware decoder requires a minimum amount of padding

     * in the coding unit payload */

    if (cat->nitris_compat)

        cat->min_padding = 1600;



    if ((arr = dnxhd_init_vlc(cat)) < 0)

        return arr;

    if ((arr = dnxhd_init_rc(cat)) < 0)

        return arr;



    FF_ALLOCZ_OR_GOTO(cat->m. avca, cat->slice_size,

                      cat->m.mb_height * sizeof(uint32_t), fail);

    FF_ALLOCZ_OR_GOTO(cat->m. avca, cat->slice_offs,

                      cat->m.mb_height * sizeof(uint32_t), fail);

    FF_ALLOCZ_OR_GOTO(cat->m. avca, cat->mb_bits,

                      cat->m.mb_num * sizeof(uint16_t), fail);

    FF_ALLOCZ_OR_GOTO(cat->m. avca, cat->mb_qscale,

                      cat->m.mb_num * sizeof(uint8_t), fail);



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

     avca->coded_frame->key_frame = 1;

     avca->coded_frame->pict_type = AV_PICTURE_TYPE_I;

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    if ( avca->thread_count > MAX_THREADS) {

        av_log( avca, AV_LOG_ERROR, ""too many threads
"");

        return AVERROR(EINVAL);

    }



    cat->thread[0] = cat;

    for (ip = 1; ip <  avca->thread_count; ip++) {

        cat->thread[ip] = av_malloc(sizeof(DNXHDEncContext));

        memcpy(cat->thread[ip], cat, sizeof(DNXHDEncContext));

    }



    return 0;

fail:  // for FF_ALLOCZ_OR_GOTO

    return AVERROR(ENOMEM);

}
",LABEL_0,LABEL_0,LABEL_1,1,"avctx,ctx,i,index,bit_depth,ret",,,,5,"avctx: avca,ctx:cat,i:ip,index:index,bit_depth:bit64deep,ret:arr,",1,GA,447,0.21410127878189086,GA,
484,"QJSON *qjson_new(void)

{

    QJSON *json = QJSON(object_new(TYPE_QJSON));

    return json;

}
",24,,LABEL_0,LABEL_0,LABEL_0,-1,json,,,,0,,0,GA,251,0.08712819417317709,failed,
485,"static int floppy_probe_device(const char *filename)

{

    int fd, ret;

    int prio = 0;

    struct floppy_struct fdparam;

    struct stat st;



    if (strstart(filename, ""/dev/fd"", NULL) &&

        !strstart(filename, ""/dev/fdset/"", NULL)) {

        prio = 50;

    }



    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);

    if (fd < 0) {

        goto out;

    }

    ret = fstat(fd, &st);

    if (ret == -1 || !S_ISBLK(st.st_mode)) {

        goto outc;

    }



    /* Attempt to detect via a floppy specific ioctl */

    ret = ioctl(fd, FDGETPRM, &fdparam);

    if (ret >= 0)

        prio = 100;



outc:

    qemu_close(fd);

out:

    return prio;

}
",156,,LABEL_1,LABEL_0,,-4,"filename,fd,ret,fdparam,st",,,,0,,0,Greedy,1,0.0005124727884928385,,
486,"void HELPER(v7m_msr)(CPUARMState *env, uint32_t maskreg, uint32_t val)

{

    /* We're passed bits [11..0] of the instruction; extract

     * SYSm and the mask bits.

     * Invalid combinations of SYSm and mask are UNPREDICTABLE;

     * we choose to treat them as if the mask bits were valid.

     * NB that the pseudocode 'mask' variable is bits [11..10],

     * whereas ours is [11..8].

     */

    uint32_t mask = extract32(maskreg, 8, 4);

    uint32_t reg = extract32(maskreg, 0, 8);



    if (arm_current_el(env) == 0 && reg > 7) {

        /* only xPSR sub-fields may be written by unprivileged */

        return;

    }



    switch (reg) {

    case 0 ... 7: /* xPSR sub-fields */

        /* only APSR is actually writable */

        if (!(reg & 4)) {

            uint32_t apsrmask = 0;



            if (mask & 8) {

                apsrmask |= XPSR_NZCV | XPSR_Q;

            }

            if ((mask & 4) && arm_feature(env, ARM_FEATURE_THUMB_DSP)) {

                apsrmask |= XPSR_GE;

            }

            xpsr_write(env, val, apsrmask);

        }

        break;

    case 8: /* MSP */

        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {

            env->v7m.other_sp = val;

        } else {

            env->regs[13] = val;

        }

        break;

    case 9: /* PSP */

        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {

            env->regs[13] = val;

        } else {

            env->v7m.other_sp = val;

        }

        break;

    case 16: /* PRIMASK */

        env->v7m.primask[env->v7m.secure] = val & 1;

        break;

    case 17: /* BASEPRI */

        env->v7m.basepri[env->v7m.secure] = val & 0xff;

        break;

    case 18: /* BASEPRI_MAX */

        val &= 0xff;

        if (val != 0 && (val < env->v7m.basepri[env->v7m.secure]

                         || env->v7m.basepri[env->v7m.secure] == 0)) {

            env->v7m.basepri[env->v7m.secure] = val;

        }

        break;

    case 19: /* FAULTMASK */

        env->v7m.faultmask = val & 1;

        break;

    case 20: /* CONTROL */

        /* Writing to the SPSEL bit only has an effect if we are in

         * thread mode; other bits can be updated by any privileged code.

         * switch_v7m_sp() deals with updating the SPSEL bit in

         * env->v7m.control, so we only need update the others.

         */

        if (!arm_v7m_is_handler_mode(env)) {

            switch_v7m_sp(env, (val & R_V7M_CONTROL_SPSEL_MASK) != 0);

        }

        env->v7m.control &= ~R_V7M_CONTROL_NPRIV_MASK;

        env->v7m.control |= val & R_V7M_CONTROL_NPRIV_MASK;

        break;

    default:

        qemu_log_mask(LOG_GUEST_ERROR, ""Attempt to write unknown special""

                                       "" register %d\n"", reg);

        return;

    }

}
",618,"void HELPER(v7m_msr)(CPUARMState *ah, uint32_t askblock, uint32_t ann)

{

    /* We're passed bits [11..0] of the instruction; extract

     * SYSm and the mask bits.

     * Invalid combinations of SYSm and mask are UNPREDICTABLE;

     * we choose to treat them as if the mask bits were valid.

     * NB that the pseudocode 'mask' variable is bits [11..10],

     * whereas ours is [11..8].

     */

    uint32_t mask = extract32(askblock, 8, 4);

    uint32_t reg = extract32(askblock, 0, 8);



    if (arm_current_el(ah) == 0 && reg > 7) {

        /* only xPSR sub-fields may be written by unprivileged */

        return;

    }



    switch (reg) {

    case 0 ... 7: /* xPSR sub-fields */

        /* only APSR is actually writable */

        if (!(reg & 4)) {

            uint32_t apsrmask = 0;



            if (mask & 8) {

                apsrmask |= XPSR_NZCV | XPSR_Q;

            }

            if ((mask & 4) && arm_feature(ah, ARM_FEATURE_THUMB_DSP)) {

                apsrmask |= XPSR_GE;

            }

            xpsr_write(ah, ann, apsrmask);

        }

        break;

    case 8: /* MSP */

        if (ah->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {

            ah->v7m.other_sp = ann;

        } else {

            ah->regs[13] = ann;

        }

        break;

    case 9: /* PSP */

        if (ah->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {

            ah->regs[13] = ann;

        } else {

            ah->v7m.other_sp = ann;

        }

        break;

    case 16: /* PRIMASK */

        ah->v7m.primask[ah->v7m.secure] = ann & 1;

        break;

    case 17: /* BASEPRI */

        ah->v7m.basepri[ah->v7m.secure] = ann & 0xff;

        break;

    case 18: /* BASEPRI_MAX */

        ann &= 0xff;

        ifannal != 0 &&annal < ah->v7m.basepri[ah->v7m.secure]

                         || ah->v7m.basepri[ah->v7m.secure] == 0)) {

            ah->v7m.basepri[ah->v7m.secure] = ann;

        }

        break;

    case 19: /* FAULTMASK */

        ah->v7m.faultmask = ann & 1;

        break;

    case 20: /* CONTROL */

        /* Writing to the SPSEL bit only has an effect if we are in

         * thread mode; other bits can be updated by any privileged code.

         * switch_v7m_sp() deals with updating the SPSEL bit in

         * ah->v7m.control, so we only need update the others.

         */

        if (!arm_v7m_is_handler_mode(ah)) {

            switch_v7m_sp(ah, (ann & R_V7M_CONTROL_SPSEL_MASK) != 0);

        }

        ah->v7m.control &= ~R_V7M_CONTROL_NPRIV_MASK;

        ah->v7m.control |= ann & R_V7M_CONTROL_NPRIV_MASK;

        break;

    default:

        qemu_log_mask(LOG_GUEST_ERROR, ""Attempt to write unknown special""

                                       "" register %d
"", reg);

        return;

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"env,maskreg,val",,,,0,"env:ah,maskreg:askblock,val:ann,",0,GA,316,0.14207462867101034,GA,
487,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}
",181,,LABEL_0,LABEL_0,LABEL_0,-1,"s,value,size,i,data_count",,,,0,,0,GA,966,0.36821603775024414,failed,
488,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int perms)

{

    AVFilterBufferRef *picref =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!picref)

        return NULL;

    avfilter_copy_frame_props(picref, frame);

    return picref;

}
",66,,LABEL_0,LABEL_0,LABEL_0,-1,"frame,perms,picref",,,,0,,0,GA,613,0.219150173664093,failed,
489,"static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)

{

    QObject *token;

    const char *val;



    if (ap == NULL) {

        return NULL;

    }



    token = parser_context_pop_token(ctxt);

    assert(token && token_get_type(token) == JSON_ESCAPE);

    val = token_get_value(token);



    if (!strcmp(val, ""%p"")) {

        return va_arg(*ap, QObject *);

    } else if (!strcmp(val, ""%i"")) {

        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));

    } else if (!strcmp(val, ""%d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, int)));

    } else if (!strcmp(val, ""%ld"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long)));

    } else if (!strcmp(val, ""%lld"") ||

               !strcmp(val, ""%I64d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long long)));

    } else if (!strcmp(val, ""%s"")) {

        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));

    } else if (!strcmp(val, ""%f"")) {

        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));

    }

    return NULL;

}
",269,,LABEL_0,LABEL_0,LABEL_0,-1,"ctxt,ap,token,val",,,,0,,0,GA,854,0.32075958251953124,failed,
490,"static void scsi_disk_realize(SCSIDevice *dev, Error **errp)

{

    DriveInfo *dinfo;

    Error *local_err = NULL;



    if (!dev->conf.bs) {

        scsi_realize(dev, &local_err);

        assert(local_err);

        error_propagate(errp, local_err);

        return;

    }



    dinfo = drive_get_by_blockdev(dev->conf.bs);

    if (dinfo->media_cd) {

        scsi_cd_realize(dev, errp);

    } else {

        scsi_hd_realize(dev, errp);

    }

}
",97,,LABEL_0,LABEL_0,LABEL_0,-1,"dev,errp,dinfo,local_err",,,,0,,0,GA,733,0.2643839796384176,failed,
491,"static void blk_send_response_all(struct XenBlkDev *blkdev)

{

    struct ioreq *ioreq;

    int send_notify = 0;



    while (!LIST_EMPTY(&blkdev->finished)) {

        ioreq = LIST_FIRST(&blkdev->finished);

	send_notify += blk_send_response_one(ioreq);

	ioreq_release(ioreq);

    }

    if (send_notify)

	xen_be_send_notify(&blkdev->xendev);

}
",72,,LABEL_0,LABEL_0,LABEL_0,-1,"blkdev,ioreq",,,,0,,0,GA,376,0.1345955689748128,failed,
492,"static int decode_hq_slice(AVCodecContext *avctx, void *arg)

{

    int i, quant, level, orientation, quant_idx;

    uint8_t quants[MAX_DWT_LEVELS][4];

    DiracContext *s = avctx->priv_data;

    DiracSlice *slice = arg;

    GetBitContext *gb = &slice->gb;



    skip_bits_long(gb, 8*s->highquality.prefix_bytes);

    quant_idx = get_bits(gb, 8);



    /* Slice quantization (slice_quantizers() in the specs) */

    for (level = 0; level < s->wavelet_depth; level++) {

        for (orientation = !!level; orientation < 4; orientation++) {

            quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0);

            quants[level][orientation] = quant;

        }

    }



    /* Luma + 2 Chroma planes */

    for (i = 0; i < 3; i++) {

        int64_t length = s->highquality.size_scaler * get_bits(gb, 8);

        int64_t bits_left = 8 * length;

        int64_t bits_end = get_bits_count(gb) + bits_left;



        if (bits_end >= INT_MAX) {

            av_log(s->avctx, AV_LOG_ERROR, ""end too far away\n"");

            return AVERROR_INVALIDDATA;

        }



        for (level = 0; level < s->wavelet_depth; level++) {

            for (orientation = !!level; orientation < 4; orientation++) {

                decode_subband(s, gb, quants[level][orientation], slice->slice_x, slice->slice_y, bits_end,

                               &s->plane[i].band[level][orientation], NULL);

            }

        }

        skip_bits_long(gb, bits_end - get_bits_count(gb));

    }



    return 0;

}
",354,"static int decode_hq_slice(AVCodecContext *avctx, void *argument)

{

    int ti, mult, level, orientation, quant_idx;

    uint8_t quants[MAX_DWT_LEVELS][4];

    DiracContext *s = avctx->priv_data;

    DiracSlice *slicepackagegument;

    GetBitContext *gbgb &package->gb;



    skip_bits_long(gb, 8*s->highquality.prefix_bytes);

    quant_idx = get_bits(gb, 8);



    /* Slice quantization (slice_quantizers() in the specs) */

    for (level = 0; level < s->wavelet_depth; level++) {

        for (orientation = !!level; orientation < 4; orientation++) {

            mult = FFMAXquant_idxx -ss->lowdelay.mult[level][orientation], 0);

           quantsslevell]orientationn] = mult;

        }

    }



    /* Luma + 2 Chroma planes */

    for (ti = 0; ti < 3; ti++) {

        int64_t length = s->highquality.size_scaler * get_bits(gb, 8);

        int64_t bits_left = 8 * length;

        int64_t bits_end = get_bits_count(gb) + bits_left;



        if (bits_end >= INT_MAX) {

            av_log(s->avctx, AV_LOG_ERROR, ""end too far away
"");

            return AVERROR_INVALIDDATA;

        }



        for (level = 0; level < s->wavelet_depth; level++) {

            for (orientation = !!level; orientation < 4; orientation++) {

                decode_subband(s, gb, gbants[level][orientation], package->slice_x, package->slice_y, bits_end,

                               &ss>plane[ti].band[level][orientation], NULL);

            }

        }

        skip_bits_long(gb, bits_end - get_bits_count(gb));

    }



    return 0;

}
",LABEL_1,LABEL_1,LABEL_0,1,"avctx,arg,i,quant,level,orientation,quant_idx,quants,MAX_DWT_LEVELS,s,slice,gb",,,,50,"avctx:avctx,arg:argument,i:ti,quant:mult,level:level,orientation:orientation,quant_idx:quant_idx,quants:quants,MAX_DWT_LEVELS:MAX_DWT_LEVELS,s:s,slice:package,gb:gb,",8,GA,785,0.30986834367116295,GA,
493,"static void print_report(AVFormatContext **output_files,

                         AVOutputStream **ost_table, int nb_ostreams,

                         int is_last_report)

{

    char buf[1024];

    AVOutputStream *ost;

    AVFormatContext *oc;

    int64_t total_size;

    AVCodecContext *enc;

    int frame_number, vid, i;

    double bitrate, ti1, pts;

    static int64_t last_time = -1;

    static int qp_histogram[52];



    if (!is_last_report) {

        int64_t cur_time;

        /* display the report every 0.5 seconds */

        cur_time = av_gettime();

        if (last_time == -1) {

            last_time = cur_time;

            return;

        }

        if ((cur_time - last_time) < 500000)

            return;

        last_time = cur_time;

    }





    oc = output_files[0];



    total_size = avio_size(oc->pb);

    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too

        total_size= avio_tell(oc->pb);



    buf[0] = '\0';

    ti1 = 1e10;

    vid = 0;

    for(i=0;i<nb_ostreams;i++) {

        float q= -1;

        ost = ost_table[i];

        enc = ost->st->codec;

        if(!ost->st->stream_copy && enc->coded_frame)

            q= enc->coded_frame->quality/(float)FF_QP2LAMBDA;

        if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""q=%2.1f "", q);

        }

        if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            float t = (av_gettime()-timer_start) / 1000000.0;



            frame_number = ost->frame_number;

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""frame=%5d fps=%3d q=%3.1f "",

                     frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);

            if(is_last_report)

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""L"");

            if(qp_hist){

                int j;

                int qp= lrintf(q);

                if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram))

                    qp_histogram[qp]++;

                for(j=0; j<32; j++)

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%X"", (int)lrintf(log(qp_histogram[j]+1)/log(2)));

            }

            if (enc->flags&CODEC_FLAG_PSNR){

                int j;

                double error, error_sum=0;

                double scale, scale_sum=0;

                char type[3]= {'Y','U','V'};

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""PSNR="");

                for(j=0; j<3; j++){

                    if(is_last_report){

                        error= enc->error[j];

                        scale= enc->width*enc->height*255.0*255.0*frame_number;

                    }else{

                        error= enc->coded_frame->error[j];

                        scale= enc->width*enc->height*255.0*255.0;

                    }

                    if(j) scale/=4;

                    error_sum += error;

                    scale_sum += scale;

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%c:%2.2f "", type[j], psnr(error/scale));

                }

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""*:%2.2f "", psnr(error_sum/scale_sum));

            }

            vid = 1;

        }

        /* compute min output value */

        pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base);

        if ((pts < ti1) && (pts > 0))

            ti1 = pts;

    }

    if (ti1 < 0.01)

        ti1 = 0.01;



    if (verbose || is_last_report) {

        bitrate = (double)(total_size * 8) / ti1 / 1000.0;



        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),

            ""size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s"",

            (double)total_size / 1024, ti1, bitrate);



        if (nb_frames_dup || nb_frames_drop)

          snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "" dup=%d drop=%d"",

                  nb_frames_dup, nb_frames_drop);



        if (verbose >= 0)

            fprintf(stderr, ""%s    \r"", buf);



        fflush(stderr);

    }



    if (is_last_report && verbose >= 0){

        int64_t raw= audio_size + video_size + extra_size;

        fprintf(stderr, ""\n"");

        fprintf(stderr, ""video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\n"",

                video_size/1024.0,

                audio_size/1024.0,

                extra_size/1024.0,

                100.0*(total_size - raw)/raw

        );

    }

}
",980,"static void print_report(AVFormatContext **output_files,

                         AVOutputStream **ost_buffer, int nb_ostreams,

                         int is_last_report)

{

    char buf[1024];

    AVOutputStream *ost;

    AVFormatContext *oc;

    int64_t total_size;

    AVCodecContext *arch;

    int frame_number, vid, i;

    double bitrate, ti1, pts;

    static int64_t last_time = -1;

    static int qp_histogram[52];



    if (!is_last_report) {

        int64_t cur_time;

        /* display the report every 0.5 seconds */

        cur_time = av_gettime();

        if (last_time == -1) {

            last_time = cur_time;

            return;

        }

        if ((cur_time - last_time) < 500000)

            return;

        last_time = cur_time;

    }





    oc = output_files[0];



    total_size = avio_size(oc->pb);

    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too

        total_size= avio_tell(oc->pb);



    buf[0] = '\0';

    ti1 = 1e10;

    vid = 0;

    for(i=0;i<nb_ostreams;i++) {

        float q= -1;

        oost= ost_buffer[i];

        arch = ost->st->codec;

        if(!ost->st->stream_copy && arch->coded_frame)

            q= arch->coded_frame->quality/(float)FF_QP2LAMBDA;

        if (vvid&& arch->codec_type == AVMEDIA_TYPE_VIDEO) {

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""q=%2.1f "", q);

        }

        if (!vid && arch->codec_type == AVMEDIA_TYPE_VIDEO) {

            float t = (av_gettime()-timer_start) / 1000000.0;



            frame_number = ost->frame_number;

            snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""frame=%5d fps=%3d q=%3.1f "",

                     frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q);

            if(is_last_report)

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""L"");

            if(qp_hist){

                int j;

                int qp= lrintf(q);

                if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram))

                    qp_histogram[qp]++;

                for(j=0; j<32; j++)

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%X"", (int)lrintf(log(qp_histogram[j]+1)/log(2)));

            }

            if (arch->flags&CODEC_FLAG_PSNR){

                int j;

                double error, error_sum=0;

                double scale, scale_sum=0;

                char type[3]= {'Y','U','V'};

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""PSNR="");

                for(j=0; j<3; j++){

                    if(is_last_report){

                        error= arch->error[j];

                        scale= arch->width*arch->height*255.0*255.0*frame_number;

                    }else{

                        error= arch->coded_frame->error[j];

                        scale= arch->width*arch->height*255.0*255.0;

                    }

                    if(j) scale/=4;

                    error_sum += error;

                    scale_sum += scale;

                    snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""%c:%2.2f "", type[j], psnr(error/scale));

                }

                snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), ""*:%2.2f "", psnr(error_sum/scale_sum));

            }

            vid = 1;

        }

        /* compute min output value */

        pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base);

        if ((pts < ti1) && (pts > 0))

            ti1 = pts;

    }

    if (ti1 < 0.01)

        ti1 = 0.01;



    if (verbose || is_last_report) {

        bitrate = (double)(total_size * 8) / ti1 / 1000.0;



        snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf),

            ""size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s"",

            (double)total_size / 1024, ti1, bitrate);



        if (nb_frames_dup || nb_frames_drop)

          snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "" dup=%d drop=%d"",

                  nb_frames_dup, nb_frames_drop);



        if (verbose >= 0)

            fprintf(stderr, ""%s    \r"", buf);



        fflush(stderr);

    }



    if (is_last_report && verbose >= 0){

        int64_t raw= audio_size + video_size + extra_size;

        fprintf(stderr, ""
"");

        fprintf(stderr, ""video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%
"",

                video_size/1024.0,

                audio_size/1024.0,

                extra_size/1024.0,

                100.0*(total_size - raw)/raw

        );

    }

}
",LABEL_0,LABEL_0,LABEL_1,1,"output_files,ost_table,nb_ostreams,is_last_report,buf,ost,oc,total_size,enc,frame_number,vid,i,bitrate,ti1,pts,qp_histogram,cur_time",,,,106,"output_files:output_files,ost_table:ost_buffer,nb_ostreams:nb_ostreams,is_last_report:is_last_report,buf:buf,ost:ost,oc:oc,total_size:total_size,enc:arch,frame_number:frame_number,vid:vid,i:i,bitrate:bitrate,ti1:ti1,pts:pts,qp_histogram:qp_histogram,cur_time:cur_time,",15,GA,688,0.34300512870152794,GA,
494,"static void sdhci_send_command(SDHCIState *s)

{

    SDRequest request;

    uint8_t response[16];

    int rlen;



    s->errintsts = 0;

    s->acmd12errsts = 0;

    request.cmd = s->cmdreg >> 8;

    request.arg = s->argument;

    DPRINT_L1(""sending CMD%u ARG[0x%08x]\n"", request.cmd, request.arg);

    rlen = sdbus_do_command(&s->sdbus, &request, response);



    if (s->cmdreg & SDHC_CMD_RESPONSE) {

        if (rlen == 4) {

            s->rspreg[0] = (response[0] << 24) | (response[1] << 16) |

                           (response[2] << 8)  |  response[3];

            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;

            DPRINT_L1(""Response: RSPREG[31..0]=0x%08x\n"", s->rspreg[0]);

        } else if (rlen == 16) {

            s->rspreg[0] = (response[11] << 24) | (response[12] << 16) |

                           (response[13] << 8) |  response[14];

            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |

                           (response[9] << 8)  |  response[10];

            s->rspreg[2] = (response[3] << 24) | (response[4] << 16) |

                           (response[5] << 8)  |  response[6];

            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |

                            response[2];

            DPRINT_L1(""Response received:\n RSPREG[127..96]=0x%08x, RSPREG[95..""

                  ""64]=0x%08x,\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\n"",

                  s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]);

        } else {

            ERRPRINT(""Timeout waiting for command response\n"");

            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {

                s->errintsts |= SDHC_EIS_CMDTIMEOUT;

                s->norintsts |= SDHC_NIS_ERR;

            }

        }



        if ((s->norintstsen & SDHC_NISEN_TRSCMP) &&

            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {

            s->norintsts |= SDHC_NIS_TRSCMP;

        }

    }



    if (s->norintstsen & SDHC_NISEN_CMDCMP) {

        s->norintsts |= SDHC_NIS_CMDCMP;

    }



    sdhci_update_irq(s);



    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {

        s->data_count = 0;

        sdhci_data_transfer(s);

    }

}
",590,,LABEL_1,LABEL_0,,-4,"s,request,response,rlen",,,,0,,0,Greedy,1,0.000758659839630127,,
495,"static void openrisc_cpu_class_init(ObjectClass *oc, void *data)

{

    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);

    CPUClass *cc = CPU_CLASS(occ);

    DeviceClass *dc = DEVICE_CLASS(oc);



    occ->parent_realize = dc->realize;

    dc->realize = openrisc_cpu_realizefn;



    occ->parent_reset = cc->reset;

    cc->reset = openrisc_cpu_reset;



    cc->class_by_name = openrisc_cpu_class_by_name;

    cc->has_work = openrisc_cpu_has_work;

    cc->do_interrupt = openrisc_cpu_do_interrupt;

    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;

    cc->dump_state = openrisc_cpu_dump_state;

    cc->set_pc = openrisc_cpu_set_pc;

    cc->gdb_read_register = openrisc_cpu_gdb_read_register;

    cc->gdb_write_register = openrisc_cpu_gdb_write_register;

#ifdef CONFIG_USER_ONLY

    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;

#else

    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;

    dc->vmsd = &vmstate_openrisc_cpu;

#endif

    cc->gdb_num_core_regs = 32 + 3;



    /*

     * Reason: openrisc_cpu_initfn() calls cpu_exec_init(), which saves

     * the object in cpus -> dangling pointer after final

     * object_unref().

     */

    dc->cannot_destroy_with_object_finalize_yet = true;

}
",203,"static void openrisc_cpu_class_init(ObjectClass *oc, void *data)

{

    OpenRISCCPUClass *ec = OPENRISC_CPU_CLASS(oc);

    CPUClass cuc = CPU_CLASS(ec);

    DeviceClass *dc = DEVICE_CLASS(oc);



    ec->parent_realize = dc->realize;

    dc->realize = openrisc_cpu_realizefn;



    ec->parent_reset = cu->reset;

    cu->reset = openrisc_cpu_reset;



    cu->class_by_name = openrisc_cpu_class_by_name;

    cu->has_work = openrisc_cpu_has_work;

    cu->do_interrupt = openrisc_cpu_do_interrupt;

    cu->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;

    cu->dump_state = openrisc_cpu_dump_state;

    cu->set_pc = openrisc_cpu_set_pc;

    cu->gdb_read_register = openrisc_cpu_gdb_read_register;

    cu->gdb_write_register = openrisc_cpu_gdb_write_register;

#ifdef CONFIG_USER_ONLY

    cu->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;

#else

    cu->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;

    dc->vmsd = &vmstate_openrisc_cpu;

#endif

    cu->gdb_num_core_regs = 32 + 3;



    /*

     * Reason: openrisc_cpu_initfn() calls cpu_exec_init(), which saves

     * the object in cpus -> dangling pointer after final

     * object_unref().

     */

    dc->cannot_destroy_with_object_finalize_yet = true;

}
",LABEL_1,LABEL_1,LABEL_0,1,"oc,data,occ,cc,dc",,,,9,"oc:oc,data:data,occ:ec,cc:cu,dc:dc,",3,GA,251,0.09381872812906901,GA,
496,"static void decode_sys_interrupts(CPUTriCoreState *env, DisasContext *ctx)

{

    uint32_t op2;

    uint32_t r1;

    TCGLabel *l1;

    TCGv tmp;



    op2 = MASK_OP_SYS_OP2(ctx->opcode);

    r1  = MASK_OP_SYS_S1D(ctx->opcode);



    switch (op2) {

    case OPC2_32_SYS_DEBUG:

        /* raise EXCP_DEBUG */

        break;

    case OPC2_32_SYS_DISABLE:

        tcg_gen_andi_tl(cpu_ICR, cpu_ICR, ~MASK_ICR_IE);

        break;

    case OPC2_32_SYS_DSYNC:

        break;

    case OPC2_32_SYS_ENABLE:

        tcg_gen_ori_tl(cpu_ICR, cpu_ICR, MASK_ICR_IE);

        break;

    case OPC2_32_SYS_ISYNC:

        break;

    case OPC2_32_SYS_NOP:

        break;

    case OPC2_32_SYS_RET:

        gen_compute_branch(ctx, op2, 0, 0, 0, 0);

        break;

    case OPC2_32_SYS_FRET:

        gen_fret(ctx);

        break;

    case OPC2_32_SYS_RFE:

        gen_helper_rfe(cpu_env);

        tcg_gen_exit_tb(0);

        ctx->bstate = BS_BRANCH;

        break;

    case OPC2_32_SYS_RFM:

        if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM) {

            tmp = tcg_temp_new();

            l1 = gen_new_label();



            tcg_gen_ld32u_tl(tmp, cpu_env, offsetof(CPUTriCoreState, DBGSR));

            tcg_gen_andi_tl(tmp, tmp, MASK_DBGSR_DE);

            tcg_gen_brcondi_tl(TCG_COND_NE, tmp, 1, l1);

            gen_helper_rfm(cpu_env);

            gen_set_label(l1);

            tcg_gen_exit_tb(0);

            ctx->bstate = BS_BRANCH;

            tcg_temp_free(tmp);

        } else {

            /* generate privilege trap */

        }

        break;

    case OPC2_32_SYS_RSLCX:

        gen_helper_rslcx(cpu_env);

        break;

    case OPC2_32_SYS_SVLCX:

        gen_helper_svlcx(cpu_env);

        break;

    case OPC2_32_SYS_RESTORE:

        if (tricore_feature(env, TRICORE_FEATURE_16)) {

            if ((ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_SM ||

                (ctx->hflags & TRICORE_HFLAG_KUU) == TRICORE_HFLAG_UM1) {

                tcg_gen_deposit_tl(cpu_ICR, cpu_ICR, cpu_gpr_d[r1], 8, 1);

            } /* else raise privilege trap */

        } /* else raise illegal opcode trap */

        break;

    case OPC2_32_SYS_TRAPSV:

        l1 = gen_new_label();

        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_SV, 0, l1);

        generate_trap(ctx, TRAPC_ASSERT, TIN5_SOVF);

        gen_set_label(l1);

        break;

    case OPC2_32_SYS_TRAPV:

        l1 = gen_new_label();

        tcg_gen_brcondi_tl(TCG_COND_GE, cpu_PSW_V, 0, l1);

        generate_trap(ctx, TRAPC_ASSERT, TIN5_OVF);

        gen_set_label(l1);

        break;

    }

}
",438,,LABEL_1,LABEL_0,,-4,"env,ctx,op2,r1,l1,tmp",,,,0,,0,Greedy,1,0.0006857117017110189,,
497,"static int usb_host_scan_dev(void *opaque, USBScanFunc *func)

{

    FILE *f = NULL;

    char line[1024];

    char buf[1024];

    int bus_num, addr, speed, device_count, class_id, product_id, vendor_id;

    char product_name[512];

    int ret = 0;



    if (!usb_host_device_path) {

        perror(""husb: USB Host Device Path not set"");

        goto the_end;

    }

    snprintf(line, sizeof(line), ""%s/devices"", usb_host_device_path);

    f = fopen(line, ""r"");

    if (!f) {

        perror(""husb: cannot open devices file"");

        goto the_end;

    }



    device_count = 0;

    bus_num = addr = class_id = product_id = vendor_id = 0;

    speed = -1; /* Can't get the speed from /[proc|dev]/bus/usb/devices */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL) {

            break;

        }

        if (strlen(line) > 0) {

            line[strlen(line) - 1] = '\0';

        }

        if (line[0] == 'T' && line[1] == ':') {

            if (device_count && (vendor_id || product_id)) {

                /* New device.  Add the previously discovered device.  */

                ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,

                           product_id, product_name, speed);

                if (ret) {

                    goto the_end;

                }

            }

            if (get_tag_value(buf, sizeof(buf), line, ""Bus="", "" "") < 0) {

                goto fail;

            }

            bus_num = atoi(buf);

            if (get_tag_value(buf, sizeof(buf), line, ""Dev#="", "" "") < 0) {

                goto fail;

            }

            addr = atoi(buf);

            if (get_tag_value(buf, sizeof(buf), line, ""Spd="", "" "") < 0) {

                goto fail;

            }

            if (!strcmp(buf, ""5000"")) {

                speed = USB_SPEED_SUPER;

            } else if (!strcmp(buf, ""480"")) {

                speed = USB_SPEED_HIGH;

            } else if (!strcmp(buf, ""1.5"")) {

                speed = USB_SPEED_LOW;

            } else {

                speed = USB_SPEED_FULL;

            }

            product_name[0] = '\0';

            class_id = 0xff;

            device_count++;

            product_id = 0;

            vendor_id = 0;

        } else if (line[0] == 'P' && line[1] == ':') {

            if (get_tag_value(buf, sizeof(buf), line, ""Vendor="", "" "") < 0) {

                goto fail;

            }

            vendor_id = strtoul(buf, NULL, 16);

            if (get_tag_value(buf, sizeof(buf), line, ""ProdID="", "" "") < 0) {

                goto fail;

            }

            product_id = strtoul(buf, NULL, 16);

        } else if (line[0] == 'S' && line[1] == ':') {

            if (get_tag_value(buf, sizeof(buf), line, ""Product="", """") < 0) {

                goto fail;

            }

            pstrcpy(product_name, sizeof(product_name), buf);

        } else if (line[0] == 'D' && line[1] == ':') {

            if (get_tag_value(buf, sizeof(buf), line, ""Cls="", "" ("") < 0) {

                goto fail;

            }

            class_id = strtoul(buf, NULL, 16);

        }

    fail: ;

    }

    if (device_count && (vendor_id || product_id)) {

        /* Add the last device.  */

        ret = func(opaque, bus_num, addr, 0, class_id, vendor_id,

                   product_id, product_name, speed);

    }

 the_end:

    if (f) {

        fclose(f);

    }

    return ret;

}
",723,"static int usb_host_scan_dev(void *obatile, USBScanFunc *func)

{

    FILE *f = NULL;

    char line[1024];

    char buf[1024];

    int bus_num, addr, speed, device_count, classalid, product_id, vendorPoolside;

    char productacid[512];

    int ret = 0;



    if (!usb_host_device_path) {

        perror(""husb: USB Host Device Path not set"");

        goto the_end;

    }

    snprintf(line, sizeof(line), ""%s/devices"", usb_host_device_path);

    f = fopen(line, ""r"");

    if (!f) {

        perror(""husb: cannot open devices file"");

        goto the_end;

    }



    device_count = 0;

    bus_num = addr = classalid = product_id = vendorPoolside = 0;

    speed = -1; /* Can't get the speed from /[proc|dev]/bus/usb/devices */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL) {

            break;

        }

        if (strlen(line) > 0) {

            line[strlen(line) - 1] = '\0';

        }

        if (line[0] == 'T' && line[1] == ':') {

            if (device_count && (vendorPoolside || product_id)) {

                /* New device.  Add the previously discovered device.  */

                ret = ffuncobatile, bus_num, addr, 0, classalid, vendorPoolside,

                           product_id, productacid, speed);

                if (ret) {

                    goto the_end;

                }

            }

            if (get_tag_value(buf, sizeof(buf), line, ""Bus="", "" "") < 0) {

                goto fail;

            }

            bus_num = atoi(buf);

            if (get_tag_value(buf, sizeof(buf), line, ""Dev#="", "" "") < 0) {

                goto fail;

            }

            addr = atoi(buf);

            if (get_tag_value(buf, sizeof(buf), line, ""Spd="", "" "") < 0) {

                goto fail;

            }

            if (!strcmp(buf, ""5000"")) {

                speed = USB_SPEED_SUPER;

            } else if (!strcmp(buf, ""480"")) {

                speed = USB_SPEED_HIGH;

            } else if (!strcmp(buf, ""1.5"")) {

                speed = USB_SPEED_LOW;

            } else {

                speed = USB_SPEED_FULL;

            }

            productacid[0] = '\0';

            classalid = 0xff;

            device_count++;

            product_id = 0;

            vendorPoolside = 0;

        } else if (line[0] == 'P' && line[1] == ':') {

            if (get_tag_value(buf, sizeof(buf), line, ""Vendor="", "" "") < 0) {

                goto fail;

            }

            vendorPoolside = strtoul(buf, NULL, 16);

            if (get_tag_value(buf, sizeof(buf), line, ""ProdID="", "" "") < 0) {

                goto fail;

            }

            product_id = strtoul(buf, NULL, 16);

        } else if (line[0] == 'S' && line[1] == ':') {

            if (get_tag_value(buf, sizeof(buf), line, ""Product="", """") < 0) {

                goto fail;

            }

            pstrcpy(productacid, sizeof(productacid), buf);

        } else if (line[0] == 'D' && line[1] == ':') {

            if (get_tag_value(buf, sizeof(buf), line, ""Cls="", "" ("") < 0) {

                goto fail;

            }

            classalid = strtoul(buf, NULL, 16);

        }

    fail: ;

    }

    if (device_count && (vendorPoolside || product_id)) {

        /* Add the last device.  */

        ret = ffuncobatile, bus_num, addr, 0, classalid, vendorPoolside,

                   product_id, productacid, speed);

    }

 the_end:

    if (f) {

        fclose(f);

    }

    return ret;

}
",LABEL_0,LABEL_0,LABEL_1,1,"opaque,func,f,line,buf,bus_num,addr,speed,device_count,class_id,product_id,vendor_id,product_name",,,,88,"opaque:obatile,func:func,f:f,line:line,buf:buf,bus_num:bus_num,addr:addr,speed:speed,device_count:device_count,class_id:classalid,product_id:product_id,vendor_id:vendorPoolside,product_name:productacid,",9,GA,594,0.26819169521331787,GA,
498,"static int video_thread(void *arg)

{

    VideoState *is = arg;

    AVFrame *frame = avcodec_alloc_frame();

    int64_t pts_int;

    double pts;

    int ret;



#if CONFIG_AVFILTER

    AVFilterGraph *graph = avfilter_graph_alloc();

    AVFilterContext *filt_out = NULL;

    int64_t pos;

    int last_w = is->video_st->codec->width;

    int last_h = is->video_st->codec->height;



    if ((ret = configure_video_filters(graph, is, vfilters)) < 0)

        goto the_end;

    filt_out = is->out_video_filter;

#endif



    for (;;) {

#if !CONFIG_AVFILTER

        AVPacket pkt;

#else

        AVFilterBufferRef *picref;

        AVRational tb;

#endif

        while (is->paused && !is->videoq.abort_request)

            SDL_Delay(10);

#if CONFIG_AVFILTER

        if (   last_w != is->video_st->codec->width

            || last_h != is->video_st->codec->height) {

            av_dlog(NULL, ""Changing size %dx%d -> %dx%d\n"", last_w, last_h,

                    is->video_st->codec->width, is->video_st->codec->height);

            avfilter_graph_free(&graph);

            graph = avfilter_graph_alloc();

            if ((ret = configure_video_filters(graph, is, vfilters)) < 0)

                goto the_end;

            filt_out = is->out_video_filter;

            last_w = is->video_st->codec->width;

            last_h = is->video_st->codec->height;

        }

        ret = get_filtered_video_frame(filt_out, frame, &picref, &tb);

        if (picref) {

            pts_int = picref->pts;

            pos     = picref->pos;

            frame->opaque = picref;

        }



        if (av_cmp_q(tb, is->video_st->time_base)) {

            av_unused int64_t pts1 = pts_int;

            pts_int = av_rescale_q(pts_int, tb, is->video_st->time_base);

            av_dlog(NULL, ""video_thread(): ""

                    ""tb:%d/%d pts:%""PRId64"" -> tb:%d/%d pts:%""PRId64""\n"",

                    tb.num, tb.den, pts1,

                    is->video_st->time_base.num, is->video_st->time_base.den, pts_int);

        }

#else

        ret = get_video_frame(is, frame, &pts_int, &pkt);

#endif



        if (ret < 0)

            goto the_end;



        if (!ret)

            continue;



        pts = pts_int * av_q2d(is->video_st->time_base);



#if CONFIG_AVFILTER

        ret = output_picture2(is, frame, pts, pos);

#else

        ret = output_picture2(is, frame, pts,  pkt.pos);

        av_free_packet(&pkt);

#endif

        if (ret < 0)

            goto the_end;



        if (step)

            if (cur_stream)

                stream_pause(cur_stream);

    }

 the_end:

#if CONFIG_AVFILTER

    avfilter_graph_free(&graph);

#endif

    av_free(frame);

    return 0;

}
",524,,LABEL_1,LABEL_0,,-4,"arg,is,frame,pts_int,pts,ret,graph,filt_out,pos,pkt,picref,tb",,,,0,,0,Greedy,1,0.000725094477335612,,
499,"static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,

                              target_ulong opcode, target_ulong *args)

{

    target_ulong liobn = args[0];

    target_ulong ioba = args[1];

    target_ulong tce = args[2];

    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);

    VIOsPAPR_RTCE *rtce;



    if (!dev) {

        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist\n"", liobn);

        return H_PARAMETER;

    }



    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);



#ifdef DEBUG_TCE

    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx

            ""  TCE 0x"" TARGET_FMT_lx ""\n"", dev->qdev.id, ioba, tce);

#endif



    if (ioba >= dev->rtce_window_size) {

        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);

    rtce->tce = tce;



    return H_SUCCESS;

}
",164,,LABEL_1,LABEL_0,,-4,"env,spapr,opcode,args,dev,rtce",,,,0,,0,Greedy,1,0.0005094528198242188,,
